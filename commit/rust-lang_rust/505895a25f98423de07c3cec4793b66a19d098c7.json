{"sha": "505895a25f98423de07c3cec4793b66a19d098c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwNTg5NWEyNWY5ODQyM2RlMDdjM2NlYzQ3OTNiNjZhMTlkMDk4Yzc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-10T09:57:40Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-10T09:57:40Z"}, "message": "store file rsovler", "tree": {"sha": "2df3f41f33b5db0b2bba1e2d2acd08f23fffbc2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2df3f41f33b5db0b2bba1e2d2acd08f23fffbc2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/505895a25f98423de07c3cec4793b66a19d098c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/505895a25f98423de07c3cec4793b66a19d098c7", "html_url": "https://github.com/rust-lang/rust/commit/505895a25f98423de07c3cec4793b66a19d098c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/505895a25f98423de07c3cec4793b66a19d098c7/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f647096665b2ca3725ba1f7415a21fbc46044bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f647096665b2ca3725ba1f7415a21fbc46044bb", "html_url": "https://github.com/rust-lang/rust/commit/4f647096665b2ca3725ba1f7415a21fbc46044bb"}], "stats": {"total": 262, "additions": 146, "deletions": 116}, "files": [{"sha": "3e65ee14ab74f500375cb370a5057ef7759c2c52", "filename": "crates/libanalysis/src/imp.rs", "status": "modified", "additions": 45, "deletions": 20, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/505895a25f98423de07c3cec4793b66a19d098c7/crates%2Flibanalysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505895a25f98423de07c3cec4793b66a19d098c7/crates%2Flibanalysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fimp.rs?ref=505895a25f98423de07c3cec4793b66a19d098c7", "patch": "@@ -7,6 +7,7 @@ use std::{\n     collections::{HashSet, VecDeque},\n };\n \n+use relative_path::RelativePath;\n use libeditor::{self, FileSymbol, LineIndex, find_node_at_offset, LocalEdit};\n use libsyntax2::{\n     TextUnit, TextRange, SmolStr, File, AstNode,\n@@ -21,6 +22,40 @@ use {\n     roots::{SourceRoot, ReadonlySourceRoot, WritableSourceRoot},\n };\n \n+\n+#[derive(Clone, Debug)]\n+pub(crate) struct FileResolverImp {\n+    inner: Arc<FileResolver>\n+}\n+\n+impl FileResolverImp {\n+    pub(crate) fn new(inner: Arc<FileResolver>) -> FileResolverImp {\n+        FileResolverImp { inner }\n+    }\n+    pub(crate) fn file_stem(&self, file_id: FileId) -> String {\n+        self.inner.file_stem(file_id)\n+    }\n+    pub(crate) fn resolve(&self, file_id: FileId, path: &RelativePath) -> Option<FileId> {\n+        self.inner.resolve(file_id, path)\n+    }\n+}\n+\n+impl Default for FileResolverImp {\n+    fn default() -> FileResolverImp {\n+        #[derive(Debug)]\n+        struct DummyResolver;\n+        impl FileResolver for DummyResolver {\n+            fn file_stem(&self, _file_: FileId) -> String {\n+                panic!(\"file resolver not set\")\n+            }\n+            fn resolve(&self, _file_id: FileId, _path: &::relative_path::RelativePath) -> Option<FileId> {\n+                panic!(\"file resolver not set\")\n+            }\n+        }\n+        FileResolverImp { inner: Arc::new(DummyResolver) }\n+    }\n+}\n+\n #[derive(Debug)]\n pub(crate) struct AnalysisHostImpl {\n     data: Arc<WorldData>\n@@ -32,13 +67,9 @@ impl AnalysisHostImpl {\n             data: Arc::new(WorldData::default()),\n         }\n     }\n-    pub fn analysis(\n-        &self,\n-        file_resolver: Arc<dyn FileResolver>,\n-    ) -> AnalysisImpl {\n+    pub fn analysis(&self) -> AnalysisImpl {\n         AnalysisImpl {\n             needs_reindex: AtomicBool::new(false),\n-            file_resolver,\n             data: self.data.clone(),\n         }\n     }\n@@ -48,6 +79,11 @@ impl AnalysisHostImpl {\n             data.root.update(file_id, text);\n         }\n     }\n+    pub fn set_file_resolver(&mut self, resolver: FileResolverImp) {\n+        let data = self.data_mut();\n+        data.file_resolver = resolver.clone();\n+        data.root.set_file_resolver(resolver);\n+    }\n     pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n         let mut visited = HashSet::new();\n         for &file_id in graph.crate_roots.values() {\n@@ -67,7 +103,6 @@ impl AnalysisHostImpl {\n \n pub(crate) struct AnalysisImpl {\n     needs_reindex: AtomicBool,\n-    file_resolver: Arc<dyn FileResolver>,\n     data: Arc<WorldData>,\n }\n \n@@ -81,7 +116,6 @@ impl Clone for AnalysisImpl {\n     fn clone(&self) -> AnalysisImpl {\n         AnalysisImpl {\n             needs_reindex: AtomicBool::new(self.needs_reindex.load(SeqCst)),\n-            file_resolver: Arc::clone(&self.file_resolver),\n             data: Arc::clone(&self.data),\n         }\n     }\n@@ -117,11 +151,7 @@ impl AnalysisImpl {\n         let module_map = root.module_map();\n         let id = module_map.file2module(file_id);\n         module_map\n-            .parent_modules(\n-                id,\n-                &*self.file_resolver,\n-                &|file_id| root.syntax(file_id),\n-            )\n+            .parent_modules(id, &|file_id| root.syntax(file_id))\n             .into_iter()\n             .map(|(id, name, node)| {\n                 let id = module_map.module2file(id);\n@@ -149,11 +179,7 @@ impl AnalysisImpl {\n             }\n             let mid = module_map.file2module(id);\n             let parents = module_map\n-                .parent_module_ids(\n-                    mid,\n-                    &*self.file_resolver,\n-                    &|file_id| self.file_syntax(file_id),\n-                )\n+                .parent_module_ids(mid, &|file_id| self.file_syntax(file_id))\n                 .into_iter()\n                 .map(|id| module_map.module2file(id))\n                 .filter(|&id| visited.insert(id));\n@@ -213,7 +239,6 @@ impl AnalysisImpl {\n \n         module_map.problems(\n             file_id,\n-            &*self.file_resolver,\n             &|file_id| self.file_syntax(file_id),\n             |name_node, problem| {\n                 let diag = match problem {\n@@ -291,7 +316,6 @@ impl AnalysisImpl {\n         module_map\n             .child_module_by_name(\n                 id, name.as_str(),\n-                &*self.file_resolver,\n                 &|file_id| self.file_syntax(file_id),\n             )\n             .into_iter()\n@@ -306,8 +330,9 @@ impl AnalysisImpl {\n     }\n }\n \n-#[derive(Clone, Default, Debug)]\n+#[derive(Default, Clone, Debug)]\n struct WorldData {\n+    file_resolver: FileResolverImp,\n     crate_graph: CrateGraph,\n     root: WritableSourceRoot,\n     libs: Vec<Arc<ReadonlySourceRoot>>,"}, {"sha": "80cde079f9c19ca8ed00c2b7c8fb013b3f7f0d1e", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/505895a25f98423de07c3cec4793b66a19d098c7/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505895a25f98423de07c3cec4793b66a19d098c7/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=505895a25f98423de07c3cec4793b66a19d098c7", "patch": "@@ -19,11 +19,12 @@ mod roots;\n use std::{\n     sync::Arc,\n     collections::HashMap,\n+    fmt::Debug,\n };\n \n use relative_path::{RelativePath, RelativePathBuf};\n use libsyntax2::{File, TextRange, TextUnit, AtomEdit};\n-use imp::{AnalysisImpl, AnalysisHostImpl};\n+use imp::{AnalysisImpl, AnalysisHostImpl, FileResolverImp};\n \n pub use libeditor::{\n     StructureNode, LineIndex, FileSymbol,\n@@ -42,9 +43,9 @@ pub struct CrateGraph {\n     pub crate_roots: HashMap<CrateId, FileId>,\n }\n \n-pub trait FileResolver: Send + Sync + 'static {\n-    fn file_stem(&self, id: FileId) -> String;\n-    fn resolve(&self, id: FileId, path: &RelativePath) -> Option<FileId>;\n+pub trait FileResolver: Debug + Send + Sync + 'static {\n+    fn file_stem(&self, file_id: FileId) -> String;\n+    fn resolve(&self, file_id: FileId, path: &RelativePath) -> Option<FileId>;\n }\n \n #[derive(Debug)]\n@@ -56,15 +57,18 @@ impl AnalysisHost {\n     pub fn new() -> AnalysisHost {\n         AnalysisHost { imp: AnalysisHostImpl::new() }\n     }\n-    pub fn analysis(&self, file_resolver: impl FileResolver) -> Analysis {\n-        Analysis { imp: self.imp.analysis(Arc::new(file_resolver)) }\n+    pub fn analysis(&self) -> Analysis {\n+        Analysis { imp: self.imp.analysis() }\n     }\n     pub fn change_file(&mut self, file_id: FileId, text: Option<String>) {\n         self.change_files(::std::iter::once((file_id, text)));\n     }\n     pub fn change_files(&mut self, mut changes: impl Iterator<Item=(FileId, Option<String>)>) {\n         self.imp.change_files(&mut changes)\n     }\n+    pub fn set_file_resolver(&mut self, resolver: Arc<FileResolver>) {\n+        self.imp.set_file_resolver(FileResolverImp::new(resolver));\n+    }\n     pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n         self.imp.set_crate_graph(graph)\n     }\n@@ -223,8 +227,9 @@ pub struct LibraryData {\n }\n \n impl LibraryData {\n-    pub fn prepare(files: Vec<(FileId, String)>) -> LibraryData {\n-        let root = roots::ReadonlySourceRoot::new(files);\n+    pub fn prepare(files: Vec<(FileId, String)>, file_resolver: Arc<FileResolver>) -> LibraryData {\n+        let file_resolver = FileResolverImp::new(file_resolver);\n+        let root = roots::ReadonlySourceRoot::new(files, file_resolver);\n         LibraryData { root }\n     }\n }"}, {"sha": "9acebd6e2647dc0b6429cc17574b55cb005298ab", "filename": "crates/libanalysis/src/module_map.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/505895a25f98423de07c3cec4793b66a19d098c7/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505895a25f98423de07c3cec4793b66a19d098c7/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs?ref=505895a25f98423de07c3cec4793b66a19d098c7", "patch": "@@ -1,12 +1,11 @@\n use relative_path::RelativePathBuf;\n-\n use parking_lot::{RwLock, RwLockReadGuard, RwLockWriteGuard};\n use libsyntax2::{\n     File,\n     ast::{self, AstNode, NameOwner},\n     SyntaxNode, SmolStr,\n };\n-use {FileId, FileResolver};\n+use {FileId, imp::FileResolverImp};\n \n type SyntaxProvider<'a> = dyn Fn(FileId) -> &'a File + 'a;\n \n@@ -32,6 +31,7 @@ impl Clone for ModuleMap {\n \n #[derive(Clone, Debug, Default)]\n struct State {\n+    file_resolver: FileResolverImp,\n     changes: Vec<(FileId, ChangeKind)>,\n     links: Vec<Link>,\n }\n@@ -59,27 +59,25 @@ impl ModuleMap {\n     pub fn new() -> ModuleMap {\n         Default::default()\n     }\n-\n-    pub fn update_file(&mut self, file: FileId, change_kind: ChangeKind) {\n-        self.state.get_mut().changes.push((file, change_kind));\n+    pub fn update_file(&mut self, file_id: FileId, change_kind: ChangeKind) {\n+        self.state.get_mut().changes.push((file_id, change_kind));\n+    }\n+    pub(crate) fn set_file_resolver(&mut self, file_resolver: FileResolverImp) {\n+        self.state.get_mut().file_resolver = file_resolver;\n     }\n-\n     pub fn module2file(&self, m: ModuleId) -> FileId {\n         m.0\n     }\n-\n     pub fn file2module(&self, file_id: FileId) -> ModuleId {\n         ModuleId(file_id)\n     }\n-\n     pub fn child_module_by_name<'a>(\n         &self,\n         parent_mod: ModuleId,\n         child_mod: &str,\n-        file_resolver: &FileResolver,\n         syntax_provider: &SyntaxProvider,\n     ) -> Vec<ModuleId> {\n-        self.links(file_resolver, syntax_provider)\n+        self.links(syntax_provider)\n             .links\n             .iter()\n             .filter(|link| link.owner == parent_mod)\n@@ -92,11 +90,10 @@ impl ModuleMap {\n     pub fn parent_modules(\n         &self,\n         m: ModuleId,\n-        file_resolver: &FileResolver,\n         syntax_provider: &SyntaxProvider,\n     ) -> Vec<(ModuleId, SmolStr, SyntaxNode)> {\n         let mut res = Vec::new();\n-        self.for_each_parent_link(m, file_resolver, syntax_provider, |link| {\n+        self.for_each_parent_link(m, syntax_provider, |link| {\n             res.push(\n                 (link.owner, link.name().clone(), link.syntax.clone())\n             )\n@@ -107,22 +104,20 @@ impl ModuleMap {\n     pub fn parent_module_ids(\n         &self,\n         m: ModuleId,\n-        file_resolver: &FileResolver,\n         syntax_provider: &SyntaxProvider,\n     ) -> Vec<ModuleId> {\n         let mut res = Vec::new();\n-        self.for_each_parent_link(m, file_resolver, syntax_provider, |link| res.push(link.owner));\n+        self.for_each_parent_link(m, syntax_provider, |link| res.push(link.owner));\n         res\n     }\n \n     fn for_each_parent_link(\n         &self,\n         m: ModuleId,\n-        file_resolver: &FileResolver,\n         syntax_provider: &SyntaxProvider,\n         f: impl FnMut(&Link)\n     ) {\n-        self.links(file_resolver, syntax_provider)\n+        self.links(syntax_provider)\n             .links\n             .iter()\n             .filter(move |link| link.points_to.iter().any(|&it| it == m))\n@@ -132,12 +127,11 @@ impl ModuleMap {\n     pub fn problems(\n         &self,\n         file: FileId,\n-        file_resolver: &FileResolver,\n         syntax_provider: &SyntaxProvider,\n         mut cb: impl FnMut(ast::Name, &Problem),\n     ) {\n         let module = self.file2module(file);\n-        let links = self.links(file_resolver, syntax_provider);\n+        let links = self.links(syntax_provider);\n         links\n             .links\n             .iter()\n@@ -151,7 +145,6 @@ impl ModuleMap {\n \n     fn links(\n         &self,\n-        file_resolver: &FileResolver,\n         syntax_provider: &SyntaxProvider,\n     ) -> RwLockReadGuard<State> {\n         {\n@@ -162,7 +155,7 @@ impl ModuleMap {\n         }\n         let mut guard = self.state.write();\n         if !guard.changes.is_empty() {\n-            guard.apply_changes(file_resolver, syntax_provider);\n+            guard.apply_changes(syntax_provider);\n         }\n         assert!(guard.changes.is_empty());\n         RwLockWriteGuard::downgrade(guard)\n@@ -172,7 +165,6 @@ impl ModuleMap {\n impl State {\n     pub fn apply_changes(\n         &mut self,\n-        file_resolver: &FileResolver,\n         syntax_provider: &SyntaxProvider,\n     ) {\n         let mut reresolve = false;\n@@ -197,13 +189,14 @@ impl State {\n                 }\n                 ChangeKind::Update => {\n                     let file = syntax_provider(file_id);\n+                    let resolver = &self.file_resolver;\n                     self.links.extend(\n                         file\n                             .ast()\n                             .modules()\n                             .filter_map(|it| Link::new(mod_id, it))\n                             .map(|mut link| {\n-                                link.resolve(file_resolver);\n+                                link.resolve(resolver);\n                                 link\n                             })\n                     );\n@@ -212,7 +205,7 @@ impl State {\n         }\n         if reresolve {\n             for link in self.links.iter_mut() {\n-                link.resolve(file_resolver)\n+                link.resolve(&self.file_resolver)\n             }\n         }\n     }\n@@ -245,7 +238,7 @@ impl Link {\n             .unwrap()\n     }\n \n-    fn resolve(&mut self, file_resolver: &FileResolver) {\n+    fn resolve(&mut self, file_resolver: &FileResolverImp) {\n         if !self.ast().has_semi() {\n             self.problem = None;\n             self.points_to = Vec::new();"}, {"sha": "629a697c5adb185e77df79bbc4eecf3aa18e735a", "filename": "crates/libanalysis/src/roots.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/505895a25f98423de07c3cec4793b66a19d098c7/crates%2Flibanalysis%2Fsrc%2Froots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505895a25f98423de07c3cec4793b66a19d098c7/crates%2Flibanalysis%2Fsrc%2Froots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Froots.rs?ref=505895a25f98423de07c3cec4793b66a19d098c7", "patch": "@@ -12,6 +12,7 @@ use libsyntax2::File;\n \n use {\n     FileId,\n+    imp::FileResolverImp,\n     module_map::{ModuleMap, ChangeKind},\n     symbol_index::SymbolIndex,\n };\n@@ -48,6 +49,9 @@ impl WritableSourceRoot {\n             self.file_map.insert(file_id, Arc::new((file_data, Default::default())));\n         }\n     }\n+    pub fn set_file_resolver(&mut self, file_resolver: FileResolverImp) {\n+        self.module_map.set_file_resolver(file_resolver)\n+    }\n     pub fn reindex(&self) {\n         let now = Instant::now();\n         self.file_map\n@@ -136,8 +140,9 @@ pub(crate) struct ReadonlySourceRoot {\n }\n \n impl ReadonlySourceRoot {\n-    pub fn new(files: Vec<(FileId, String)>) -> ReadonlySourceRoot {\n+    pub(crate) fn new(files: Vec<(FileId, String)>, file_resolver: FileResolverImp) -> ReadonlySourceRoot {\n         let mut module_map = ModuleMap::new();\n+        module_map.set_file_resolver(file_resolver);\n         let symbol_index = SymbolIndex::for_files(\n             files.par_iter().map(|(file_id, text)| {\n                 (*file_id, File::parse(text))"}, {"sha": "00efe059ccc50717976f1e7ee6c13c49171ff1d3", "filename": "crates/libanalysis/tests/tests.rs", "status": "modified", "additions": 45, "deletions": 48, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/505895a25f98423de07c3cec4793b66a19d098c7/crates%2Flibanalysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505895a25f98423de07c3cec4793b66a19d098c7/crates%2Flibanalysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Ftests%2Ftests.rs?ref=505895a25f98423de07c3cec4793b66a19d098c7", "patch": "@@ -3,21 +3,38 @@ extern crate relative_path;\n extern crate test_utils;\n \n use std::{\n+    sync::Arc,\n     collections::HashMap,\n };\n \n-use relative_path::{RelativePath};\n-use libanalysis::{AnalysisHost, FileId, FileResolver, JobHandle, CrateGraph, CrateId};\n+use relative_path::{RelativePath, RelativePathBuf};\n+use libanalysis::{Analysis, AnalysisHost, FileId, FileResolver, JobHandle, CrateGraph, CrateId};\n use test_utils::assert_eq_dbg;\n \n-struct FileMap(&'static [(u32, &'static str)]);\n+#[derive(Debug)]\n+struct FileMap(Vec<(FileId, RelativePathBuf)>);\n+\n+fn analysis_host(files: &'static [(&'static str, &'static str)]) -> AnalysisHost {\n+    let mut host = AnalysisHost::new();\n+    let mut file_map = Vec::new();\n+    for (id, &(path, contents)) in files.iter().enumerate() {\n+        let file_id = FileId((id + 1) as u32);\n+        assert!(path.starts_with('/'));\n+        let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n+        host.change_file(file_id, Some(contents.to_string()));\n+        file_map.push((file_id, path));\n+    }\n+    host.set_file_resolver(Arc::new(FileMap(file_map)));\n+    host\n+}\n+\n+fn analysis(files: &'static [(&'static str, &'static str)]) -> Analysis {\n+    analysis_host(files).analysis()\n+}\n \n impl FileMap {\n     fn iter<'a>(&'a self) -> impl Iterator<Item=(FileId, &'a RelativePath)> + 'a {\n-        self.0.iter().map(|&(id, path)| {\n-            assert!(path.starts_with('/'));\n-            (FileId(id), RelativePath::new(&path[1..]))\n-        })\n+        self.0.iter().map(|(id, path)| (*id, path.as_relative_path()))\n     }\n \n     fn path(&self, id: FileId) -> &RelativePath {\n@@ -42,25 +59,21 @@ impl FileResolver for FileMap {\n \n #[test]\n fn test_resolve_module() {\n-    let mut world = AnalysisHost::new();\n-    world.change_file(FileId(1), Some(\"mod foo;\".to_string()));\n-    world.change_file(FileId(2), Some(\"\".to_string()));\n-\n-    let snap = world.analysis(FileMap(&[\n-        (1, \"/lib.rs\"),\n-        (2, \"/foo.rs\"),\n-    ]));\n+    let snap = analysis(&[\n+        (\"/lib.rs\", \"mod foo;\"),\n+        (\"/foo.rs\", \"\")\n+    ]);\n     let (_handle, token) = JobHandle::new();\n     let symbols = snap.approximately_resolve_symbol(FileId(1), 4.into(), &token);\n     assert_eq_dbg(\n         r#\"[(FileId(2), FileSymbol { name: \"foo\", node_range: [0; 0), kind: MODULE })]\"#,\n         &symbols,\n     );\n \n-    let snap = world.analysis(FileMap(&[\n-        (1, \"/lib.rs\"),\n-        (2, \"/foo/mod.rs\")\n-    ]));\n+    let snap = analysis(&[\n+        (\"/lib.rs\", \"mod foo;\"),\n+        (\"/foo/mod.rs\", \"\")\n+    ]);\n     let symbols = snap.approximately_resolve_symbol(FileId(1), 4.into(), &token);\n     assert_eq_dbg(\n         r#\"[(FileId(2), FileSymbol { name: \"foo\", node_range: [0; 0), kind: MODULE })]\"#,\n@@ -70,10 +83,7 @@ fn test_resolve_module() {\n \n #[test]\n fn test_unresolved_module_diagnostic() {\n-    let mut world = AnalysisHost::new();\n-    world.change_file(FileId(1), Some(\"mod foo;\".to_string()));\n-\n-    let snap = world.analysis(FileMap(&[(1, \"/lib.rs\")]));\n+    let snap = analysis(&[(\"/lib.rs\", \"mod foo;\")]);\n     let diagnostics = snap.diagnostics(FileId(1));\n     assert_eq_dbg(\n         r#\"[Diagnostic {\n@@ -90,10 +100,7 @@ fn test_unresolved_module_diagnostic() {\n \n #[test]\n fn test_unresolved_module_diagnostic_no_diag_for_inline_mode() {\n-    let mut world = AnalysisHost::new();\n-    world.change_file(FileId(1), Some(\"mod foo {}\".to_string()));\n-\n-    let snap = world.analysis(FileMap(&[(1, \"/lib.rs\")]));\n+    let snap = analysis(&[(\"/lib.rs\", \"mod foo {}\")]);\n     let diagnostics = snap.diagnostics(FileId(1));\n     assert_eq_dbg(\n         r#\"[]\"#,\n@@ -103,14 +110,10 @@ fn test_unresolved_module_diagnostic_no_diag_for_inline_mode() {\n \n #[test]\n fn test_resolve_parent_module() {\n-    let mut world = AnalysisHost::new();\n-    world.change_file(FileId(1), Some(\"mod foo;\".to_string()));\n-    world.change_file(FileId(2), Some(\"\".to_string()));\n-\n-    let snap = world.analysis(FileMap(&[\n-        (1, \"/lib.rs\"),\n-        (2, \"/foo.rs\"),\n-    ]));\n+    let snap = analysis(&[\n+        (\"/lib.rs\", \"mod foo;\"),\n+        (\"/foo.rs\", \"\"),\n+    ]);\n     let symbols = snap.parent_module(FileId(2));\n     assert_eq_dbg(\n         r#\"[(FileId(1), FileSymbol { name: \"foo\", node_range: [0; 8), kind: MODULE })]\"#,\n@@ -120,14 +123,11 @@ fn test_resolve_parent_module() {\n \n #[test]\n fn test_resolve_crate_root() {\n-    let mut world = AnalysisHost::new();\n-    world.change_file(FileId(1), Some(\"mod foo;\".to_string()));\n-    world.change_file(FileId(2), Some(\"\".to_string()));\n-\n-    let snap = world.analysis(FileMap(&[\n-        (1, \"/lib.rs\"),\n-        (2, \"/foo.rs\"),\n-    ]));\n+    let mut host = analysis_host(&[\n+        (\"/lib.rs\", \"mod foo;\"),\n+        (\"/foo.rs\", \"\"),\n+    ]);\n+    let snap = host.analysis();\n     assert!(snap.crate_for(FileId(2)).is_empty());\n \n     let crate_graph = CrateGraph {\n@@ -137,12 +137,9 @@ fn test_resolve_crate_root() {\n             m\n         },\n     };\n-    world.set_crate_graph(crate_graph);\n+    host.set_crate_graph(crate_graph);\n+    let snap = host.analysis();\n \n-    let snap = world.analysis(FileMap(&[\n-        (1, \"/lib.rs\"),\n-        (2, \"/foo.rs\"),\n-    ]));\n     assert_eq!(\n         snap.crate_for(FileId(2)),\n         vec![CrateId(1)],"}, {"sha": "f3b2744bfb0187b61417d5addd27d0bfbd30101d", "filename": "crates/server/src/main_loop/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/505895a25f98423de07c3cec4793b66a19d098c7/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505895a25f98423de07c3cec4793b66a19d098c7/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs?ref=505895a25f98423de07c3cec4793b66a19d098c7", "patch": "@@ -135,12 +135,12 @@ fn main_loop_inner(\n                 if root == ws_root {\n                     state.apply_fs_changes(events);\n                 } else {\n-                    let files = state.events_to_files(events);\n+                    let (files, resolver) = state.events_to_files(events);\n                     let sender = libdata_sender.clone();\n                     pool.spawn(move || {\n                         let start = ::std::time::Instant::now();\n                         info!(\"indexing {} ... \", root.display());\n-                        let data = LibraryData::prepare(files);\n+                        let data = LibraryData::prepare(files, resolver);\n                         info!(\"indexed {:?} {}\", start.elapsed(), root.display());\n                         sender.send(data);\n                     });"}, {"sha": "ffa0e74b83b56e0756d969c83d475dc85da4b7dc", "filename": "crates/server/src/server_world.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/505895a25f98423de07c3cec4793b66a19d098c7/crates%2Fserver%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/505895a25f98423de07c3cec4793b66a19d098c7/crates%2Fserver%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fserver_world.rs?ref=505895a25f98423de07c3cec4793b66a19d098c7", "patch": "@@ -6,7 +6,7 @@ use std::{\n };\n \n use languageserver_types::Url;\n-use libanalysis::{FileId, AnalysisHost, Analysis, CrateGraph, CrateId, LibraryData};\n+use libanalysis::{FileId, AnalysisHost, Analysis, CrateGraph, CrateId, LibraryData, FileResolver};\n \n use {\n     Result,\n@@ -64,24 +64,29 @@ impl ServerWorldState {\n \n         self.analysis_host.change_files(changes);\n     }\n-    pub fn events_to_files(&mut self, events: Vec<FileEvent>) -> Vec<(FileId, String)> {\n-        let pm = &mut self.path_map;\n-        events.into_iter()\n-            .map(|event| {\n-                let text = match event.kind {\n-                    FileEventKind::Add(text) => text,\n-                };\n-                (event.path, text)\n-            })\n-            .map(|(path, text)| (pm.get_or_insert(path, Root::Lib), text))\n-            .collect()\n+    pub fn events_to_files(&mut self, events: Vec<FileEvent>) -> (Vec<(FileId, String)>, Arc<FileResolver>) {\n+        let files = {\n+            let pm = &mut self.path_map;\n+            events.into_iter()\n+                .map(|event| {\n+                    let text = match event.kind {\n+                        FileEventKind::Add(text) => text,\n+                    };\n+                    (event.path, text)\n+                })\n+                .map(|(path, text)| (pm.get_or_insert(path, Root::Lib), text))\n+                .collect()\n+        };\n+        let resolver = Arc::new(self.path_map.clone());\n+        (files, resolver)\n     }\n     pub fn add_lib(&mut self, data: LibraryData) {\n         self.analysis_host.add_library(data);\n     }\n \n     pub fn add_mem_file(&mut self, path: PathBuf, text: String) -> FileId {\n         let file_id = self.path_map.get_or_insert(path, Root::Workspace);\n+        self.analysis_host.set_file_resolver(Arc::new(self.path_map.clone()));\n         self.mem_map.insert(file_id, None);\n         if self.path_map.get_root(file_id) != Root::Lib {\n             self.analysis_host.change_file(file_id, Some(text));\n@@ -135,7 +140,7 @@ impl ServerWorldState {\n     pub fn snapshot(&self) -> ServerWorld {\n         ServerWorld {\n             workspaces: Arc::clone(&self.workspaces),\n-            analysis: self.analysis_host.analysis(self.path_map.clone()),\n+            analysis: self.analysis_host.analysis(),\n             path_map: self.path_map.clone()\n         }\n     }"}]}