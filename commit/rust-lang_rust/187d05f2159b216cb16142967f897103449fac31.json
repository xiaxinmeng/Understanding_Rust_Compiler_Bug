{"sha": "187d05f2159b216cb16142967f897103449fac31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4N2QwNWYyMTU5YjIxNmNiMTYxNDI5NjdmODk3MTAzNDQ5ZmFjMzE=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-04-17T01:04:54Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-11-11T20:14:31Z"}, "message": "Add hooks for Miri panic unwinding\n\nThis commits adds in some additional hooks to allow Miri to properly\nhandle panic unwinding. None of this should have any impact on CTFE mode", "tree": {"sha": "2d640c6d3c3f168af6b4e05fff94cd12c718b876", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d640c6d3c3f168af6b4e05fff94cd12c718b876"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/187d05f2159b216cb16142967f897103449fac31", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl3JwScACgkQtAh+UQ6Y\nsWTy9g/+MEYMA/6QZ2JRuNvpYEDT2UztTo+BkAHXBxObbz2pCW6Mxqn7+rDnUElm\npBdNtbNa/vvfnOP1B7lukrn2Kw4HHbw0PJk5MkaEknMipkounJn44vimyOvTOkkA\nMK7FjgWT36AuI1Ui15NpHkTV766GIy5uEJs+yg6WvmEGFO+LBOklShC7pz1sgmt9\npGZbzVpCyjC5fHBoFP86CrJvt4foVCNis6NAkG+ezsfQHILcgYjc7VOdhFIY9xy5\ncnxCCtIgbJXPSwm4VtvWtJxRj4eKNw26fBC9o6NBPu9NvOAmfvpG01ZtUG4Tg5ia\nssOypExGqVPSpwIHrINJjH/RTAXSo1Ln/XZ1F9r8UcYpk13sxsFq1MHdGkPfSxPP\nhFH5ke+oo5FsyetqRqioEw3w3AwFXmOC6ec81kAbYLEJwAvKcCaYOVnDEMrngYBv\nQXmHoYWzAv+bSP0tCDEGdRlMsT4sXIoUq/+67jqimlXETFKL448yaBpm2xauhiie\n+Rd8W7WFDltXpQiWoS9gKF9YDwcue+Pt8xlBtTQUOc4n2I8sLIxVIE4b/e2iCdtJ\ngs4CPlhFd0LCVFo+EP/YB2j6Xw7SBHA70h/hAKpuSBxcGgQpGIBejTRiXztOzOdu\n7dvMb8R3DSGpuPa9BjOUpqBp9wmldWzzpWSo2JGUp0qJ69/yxgU=\n=z6XU\n-----END PGP SIGNATURE-----", "payload": "tree 2d640c6d3c3f168af6b4e05fff94cd12c718b876\nparent 56237d75b4271a8a2e0f47d86ea76ebf6d966152\nauthor Aaron Hill <aa1ronham@gmail.com> 1555463094 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1573503271 -0500\n\nAdd hooks for Miri panic unwinding\n\nThis commits adds in some additional hooks to allow Miri to properly\nhandle panic unwinding. None of this should have any impact on CTFE mode\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/187d05f2159b216cb16142967f897103449fac31", "html_url": "https://github.com/rust-lang/rust/commit/187d05f2159b216cb16142967f897103449fac31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/187d05f2159b216cb16142967f897103449fac31/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56237d75b4271a8a2e0f47d86ea76ebf6d966152", "url": "https://api.github.com/repos/rust-lang/rust/commits/56237d75b4271a8a2e0f47d86ea76ebf6d966152", "html_url": "https://github.com/rust-lang/rust/commit/56237d75b4271a8a2e0f47d86ea76ebf6d966152"}], "stats": {"total": 270, "additions": 211, "deletions": 59}, "files": [{"sha": "1af8190e569f720405e786095444bb1c2cc97eaa", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/187d05f2159b216cb16142967f897103449fac31/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/187d05f2159b216cb16142967f897103449fac31/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=187d05f2159b216cb16142967f897103449fac31", "patch": "@@ -24,7 +24,7 @@ use crate::interpret::{self,\n     PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar, Pointer,\n     RawConst, ConstValue, Machine,\n     InterpResult, InterpErrorInfo, GlobalId, InterpCx, StackPopCleanup,\n-    Allocation, AllocId, MemoryKind, Memory,\n+    Allocation, AllocId, MemoryKind, Memory, StackPopInfo,\n     snapshot, RefTracking, intern_const_alloc_recursive,\n };\n \n@@ -325,6 +325,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         args: &[OpTy<'tcx>],\n         dest: Option<PlaceTy<'tcx>>,\n         ret: Option<mir::BasicBlock>,\n+        _unwind: Option<mir::BasicBlock> // unwinding is not supported in consts\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         debug!(\"eval_fn_call: {:?}\", instance);\n         // Only check non-glue functions\n@@ -374,7 +375,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n-        dest: PlaceTy<'tcx>,\n+        dest: Option<PlaceTy<'tcx>>,\n     ) -> InterpResult<'tcx> {\n         if ecx.emulate_intrinsic(span, instance, args, dest)? {\n             return Ok(());\n@@ -472,8 +473,10 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     /// Called immediately before a stack frame gets popped.\n     #[inline(always)]\n-    fn stack_pop(_ecx: &mut InterpCx<'mir, 'tcx, Self>, _extra: ()) -> InterpResult<'tcx> {\n-        Ok(())\n+    fn stack_pop(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>, _extra: ()) -> InterpResult<'tcx, StackPopInfo> {\n+        // Const-eval mode does not support unwinding from panics\n+        Ok(StackPopInfo::Normal)\n     }\n }\n "}, {"sha": "6371ced2f6bca1fa49d29b51e7a9a646f4f81220", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 141, "deletions": 32, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/187d05f2159b216cb16142967f897103449fac31/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/187d05f2159b216cb16142967f897103449fac31/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=187d05f2159b216cb16142967f897103449fac31", "patch": "@@ -21,7 +21,7 @@ use rustc_data_structures::fx::FxHashMap;\n \n use super::{\n     Immediate, Operand, MemPlace, MPlaceTy, Place, PlaceTy, ScalarMaybeUndef,\n-    Memory, Machine\n+    Memory, Machine, PointerArithmetic, FnVal, StackPopInfo\n };\n \n pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n@@ -96,7 +96,9 @@ pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n     /// that may never return). Also store layout of return place so\n     /// we can validate it at that layout.\n-    Goto(Option<mir::BasicBlock>),\n+    /// 'ret' stores the block we jump to on a normal return, while 'unwind'\n+    /// stores the block used for cleanup during unwinding\n+    Goto { ret: Option<mir::BasicBlock>, unwind: Option<mir::BasicBlock> },\n     /// Just do nohing: Used by Main and for the box_alloc hook in miri.\n     /// `cleanup` says whether locals are deallocated. Static computation\n     /// wants them leaked to intern what they need (and just throw away\n@@ -547,56 +549,142 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n-    pub(super) fn pop_stack_frame(&mut self) -> InterpResult<'tcx> {\n-        info!(\"LEAVING({}) {}\", self.cur_frame(), self.frame().instance);\n+    pub(super) fn pop_stack_frame_internal(\n+        &mut self,\n+        unwinding: bool\n+    ) -> InterpResult<'tcx, (StackPopCleanup, StackPopInfo)> {\n+        info!(\"LEAVING({}) {} (unwinding = {})\",\n+            self.cur_frame(), self.frame().instance, unwinding);\n+\n         ::log_settings::settings().indentation -= 1;\n         let frame = self.stack.pop().expect(\n             \"tried to pop a stack frame, but there were none\",\n         );\n-        M::stack_pop(self, frame.extra)?;\n+        let stack_pop_info = M::stack_pop(self, frame.extra)?;\n+\n         // Abort early if we do not want to clean up: We also avoid validation in that case,\n         // because this is CTFE and the final value will be thoroughly validated anyway.\n         match frame.return_to_block {\n-            StackPopCleanup::Goto(_) => {},\n-            StackPopCleanup::None { cleanup } => {\n+            StackPopCleanup::Goto{ .. } => {},\n+            StackPopCleanup::None { cleanup, .. } => {\n+                assert!(!unwinding, \"Encountered StackPopCleanup::None while unwinding\");\n+\n                 if !cleanup {\n                     assert!(self.stack.is_empty(), \"only the topmost frame should ever be leaked\");\n                     // Leak the locals, skip validation.\n-                    return Ok(());\n+                    return Ok((frame.return_to_block, stack_pop_info));\n                 }\n             }\n         }\n         // Deallocate all locals that are backed by an allocation.\n         for local in frame.locals {\n             self.deallocate_local(local.value)?;\n         }\n-        // Validate the return value. Do this after deallocating so that we catch dangling\n-        // references.\n-        if let Some(return_place) = frame.return_place {\n-            if M::enforce_validity(self) {\n-                // Data got changed, better make sure it matches the type!\n-                // It is still possible that the return place held invalid data while\n-                // the function is running, but that's okay because nobody could have\n-                // accessed that same data from the \"outside\" to observe any broken\n-                // invariant -- that is, unless a function somehow has a ptr to\n-                // its return place... but the way MIR is currently generated, the\n-                // return place is always a local and then this cannot happen.\n-                self.validate_operand(\n-                    self.place_to_op(return_place)?,\n-                    vec![],\n-                    None,\n-                )?;\n+\n+        // If we're popping frames due to unwinding, and we didn't just exit\n+        // unwinding, we skip a bunch of validation and cleanup logic (including\n+        // jumping to the regular return block specified in the StackPopCleanu)\n+        let cur_unwinding = unwinding && stack_pop_info != StackPopInfo::StopUnwinding;\n+\n+        info!(\"StackPopCleanup: {:?} StackPopInfo: {:?} cur_unwinding = {:?}\",\n+               frame.return_to_block, stack_pop_info, cur_unwinding);\n+\n+\n+        // When we're popping a stack frame for unwinding purposes,\n+        // we don't care at all about returning-related stuff (i.e. return_place\n+        // and return_to_block), because we're not performing a return from this frame.\n+        if !cur_unwinding  {\n+            // Validate the return value. Do this after deallocating so that we catch dangling\n+            // references.\n+            if let Some(return_place) = frame.return_place {\n+                if M::enforce_validity(self) {\n+                    // Data got changed, better make sure it matches the type!\n+                    // It is still possible that the return place held invalid data while\n+                    // the function is running, but that's okay because nobody could have\n+                    // accessed that same data from the \"outside\" to observe any broken\n+                    // invariant -- that is, unless a function somehow has a ptr to\n+                    // its return place... but the way MIR is currently generated, the\n+                    // return place is always a local and then this cannot happen.\n+                    self.validate_operand(\n+                        self.place_to_op(return_place)?,\n+                        vec![],\n+                        None,\n+                    )?;\n+                }\n+            } else {\n+                // Uh, that shouldn't happen... the function did not intend to return\n+                throw_ub!(Unreachable);\n+            }\n+\n+            // Jump to new block -- *after* validation so that the spans make more sense.\n+            match frame.return_to_block {\n+                StackPopCleanup::Goto { ret, ..  } => {\n+                    self.goto_block(ret)?;\n+                }\n+                StackPopCleanup::None { .. } => {}\n             }\n-        } else {\n-            // Uh, that shouldn't happen... the function did not intend to return\n-            throw_ub!(Unreachable)\n         }\n-        // Jump to new block -- *after* validation so that the spans make more sense.\n-        match frame.return_to_block {\n-            StackPopCleanup::Goto(block) => {\n-                self.goto_block(block)?;\n+\n+\n+        Ok((frame.return_to_block, stack_pop_info))\n+    }\n+\n+    pub(super) fn pop_stack_frame(&mut self, unwinding: bool) -> InterpResult<'tcx> {\n+        let (mut cleanup, mut stack_pop_info) = self.pop_stack_frame_internal(unwinding)?;\n+\n+        // There are two cases where we want to unwind the stack:\n+        // * The caller explicitly told us (i.e. we hit a Resume terminator)\n+        // * The machine indicated that we've just started unwinding (i.e.\n+        // a panic has just occured)\n+        if unwinding || stack_pop_info == StackPopInfo::StartUnwinding {\n+            trace!(\"unwinding: starting stack unwind...\");\n+            // Overwrite our current stack_pop_info, so that the check\n+            // below doesn't fail.\n+            stack_pop_info = StackPopInfo::Normal;\n+            // There are three posible ways that we can exit the loop:\n+            // 1) We find an unwind block - we jump to it to allow cleanup\n+            // to occur for that frame\n+            // 2) pop_stack_frame_internal reports that we're no longer unwinding\n+            //    - this means that the panic has been caught, and that execution\n+            //    should continue as normal\n+            // 3) We pop all of our frames off the stack - this should never happen.\n+            while !self.stack.is_empty() {\n+                match stack_pop_info {\n+                    // We tried to start unwinding while we were already\n+                    // unwinding. Note that this **is not** the same thing\n+                    // as a double panic, which will be intercepted by\n+                    // libcore/libstd before we actually attempt to unwind.\n+                    StackPopInfo::StartUnwinding => {\n+                        throw_ub_format!(\"Attempted to start unwinding while already unwinding!\");\n+                    },\n+                    StackPopInfo::StopUnwinding => {\n+                        trace!(\"unwinding: no longer unwinding!\");\n+                        break;\n+                    }\n+                    StackPopInfo::Normal => {}\n+                }\n+\n+                match cleanup {\n+                    StackPopCleanup::Goto { unwind, .. } if unwind.is_some() => {\n+\n+                        info!(\"unwind: found cleanup block {:?}\", unwind);\n+                        self.goto_block(unwind)?;\n+                        break;\n+                    },\n+                    _ => {}\n+                }\n+\n+                info!(\"unwinding: popping frame!\");\n+                let res = self.pop_stack_frame_internal(true)?;\n+                cleanup = res.0;\n+                stack_pop_info = res.1;\n+            }\n+            if self.stack.is_empty() {\n+                // We should never get here:\n+                // The 'start_fn' lang item should always install a panic handler\n+                throw_ub!(Unreachable);\n             }\n-            StackPopCleanup::None { .. } => {}\n+\n         }\n \n         if self.stack.len() > 0 {\n@@ -760,4 +848,25 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         trace!(\"generate stacktrace: {:#?}, {:?}\", frames, explicit_span);\n         frames\n     }\n+\n+    /// Resolve the function at the specified slot in the provided\n+    /// vtable. An index of '0' corresponds to the first method\n+    /// declared in the trait of the provided vtable\n+    pub fn get_vtable_slot(\n+        &self,\n+        vtable: Scalar<M::PointerTag>,\n+        idx: usize\n+    ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n+        let ptr_size = self.pointer_size();\n+        // Skip over the 'drop_ptr', 'size', and 'align' fields\n+        let vtable_slot = vtable.ptr_offset(ptr_size * (idx as u64 + 3), self)?;\n+        let vtable_slot = self.memory.check_ptr_access(\n+            vtable_slot,\n+            ptr_size,\n+            self.tcx.data_layout.pointer_align.abi,\n+        )?.expect(\"cannot be a ZST\");\n+        let fn_ptr = self.memory.get(vtable_slot.alloc_id)?\n+            .read_ptr_sized(self, vtable_slot)?.not_undef()?;\n+        Ok(self.memory.get_fn(fn_ptr)?)\n+    }\n }"}, {"sha": "d6d53a740bb2ae451b09c2514f0b5d77af063538", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/187d05f2159b216cb16142967f897103449fac31/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/187d05f2159b216cb16142967f897103449fac31/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=187d05f2159b216cb16142967f897103449fac31", "patch": "@@ -91,11 +91,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n     ) -> InterpResult<'tcx, bool> {\n         let substs = instance.substs;\n \n-        let intrinsic_name = &*self.tcx.item_name(instance.def_id()).as_str();\n+        // The intrinsic itself cannot diverge, so if we got here without a return\n+        // place... (can happen e.g., for transmute returning `!`)\n+        let dest = match dest {\n+            Some(dest) => dest,\n+            None => throw_ub!(Unreachable)\n+        };\n+        let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str();\n+\n         match intrinsic_name {\n             \"caller_location\" => {\n                 let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);"}, {"sha": "78c789fc1ca3f7058d43bc14ae68e67b1d208093", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/187d05f2159b216cb16142967f897103449fac31/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/187d05f2159b216cb16142967f897103449fac31/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=187d05f2159b216cb16142967f897103449fac31", "patch": "@@ -16,6 +16,22 @@ use super::{\n     Frame, Operand,\n };\n \n+/// Data returned by Machine::stack_pop,\n+/// to provide further control over the popping of the stack frame\n+#[derive(Eq, PartialEq, Debug)]\n+pub enum StackPopInfo {\n+    /// Indicates that we have just started unwinding\n+    /// as the result of panic\n+    StartUnwinding,\n+\n+    /// Indicates that we performed a normal return\n+    Normal,\n+\n+    /// Indicates that we should stop unwinding,\n+    /// as we've reached a catch frame\n+    StopUnwinding\n+}\n+\n /// Whether this kind of memory is allowed to leak\n pub trait MayLeak: Copy {\n     fn may_leak(self) -> bool;\n@@ -137,6 +153,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n         ret: Option<mir::BasicBlock>,\n+        unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>>;\n \n     /// Execute `fn_val`.  it is the hook's responsibility to advance the instruction\n@@ -156,7 +173,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n-        dest: PlaceTy<'tcx, Self::PointerTag>,\n+        dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n     ) -> InterpResult<'tcx>;\n \n     /// Called for read access to a foreign static item.\n@@ -253,7 +270,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn stack_pop(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         extra: Self::FrameExtra,\n-    ) -> InterpResult<'tcx>;\n+    ) -> InterpResult<'tcx, StackPopInfo>;\n \n     fn int_to_ptr(\n         _mem: &Memory<'mir, 'tcx, Self>,"}, {"sha": "520bd434faa253c720621ec8de50f92e55b884de", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/187d05f2159b216cb16142967f897103449fac31/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/187d05f2159b216cb16142967f897103449fac31/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=187d05f2159b216cb16142967f897103449fac31", "patch": "@@ -26,7 +26,7 @@ pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};\n \n pub use self::memory::{Memory, MemoryKind, AllocCheck, FnVal};\n \n-pub use self::machine::{Machine, AllocMap, MayLeak};\n+pub use self::machine::{Machine, AllocMap, MayLeak, StackPopInfo};\n \n pub use self::operand::{ScalarMaybeUndef, Immediate, ImmTy, Operand, OpTy};\n "}, {"sha": "a463263120c866339ee07e0f0dfd3e00bac361f1", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/187d05f2159b216cb16142967f897103449fac31/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/187d05f2159b216cb16142967f897103449fac31/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=187d05f2159b216cb16142967f897103449fac31", "patch": "@@ -315,7 +315,7 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n }\n \n impl_stable_hash_for!(enum crate::interpret::eval_context::StackPopCleanup {\n-    Goto(block),\n+    Goto { ret, unwind },\n     None { cleanup },\n });\n "}, {"sha": "96e5a372afddefcf7d31309a224d921a18e31a4e", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/187d05f2159b216cb16142967f897103449fac31/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/187d05f2159b216cb16142967f897103449fac31/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=187d05f2159b216cb16142967f897103449fac31", "patch": "@@ -290,6 +290,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let old_stack = self.cur_frame();\n         let old_bb = self.frame().block;\n+\n         self.eval_terminator(terminator)?;\n         if !self.stack.is_empty() {\n             // This should change *something*"}, {"sha": "af6fe399739994f6970df6d9f6439ccd2fef8a6d", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/187d05f2159b216cb16142967f897103449fac31/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/187d05f2159b216cb16142967f897103449fac31/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=187d05f2159b216cb16142967f897103449fac31", "patch": "@@ -31,7 +31,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match terminator.kind {\n             Return => {\n                 self.frame().return_place.map(|r| self.dump_place(*r));\n-                self.pop_stack_frame()?\n+                self.pop_stack_frame(/* unwinding */ false)?\n             }\n \n             Goto { target } => self.goto_block(Some(target))?,\n@@ -67,6 +67,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 ref func,\n                 ref args,\n                 ref destination,\n+                ref cleanup,\n                 ..\n             } => {\n                 let (dest, ret) = match *destination {\n@@ -98,13 +99,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     &args[..],\n                     dest,\n                     ret,\n+                    *cleanup\n                 )?;\n             }\n \n             Drop {\n                 ref location,\n                 target,\n-                ..\n+                unwind,\n             } => {\n                 // FIXME(CTFE): forbid drop in const eval\n                 let place = self.eval_place(location)?;\n@@ -117,6 +119,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     instance,\n                     terminator.source_info.span,\n                     target,\n+                    unwind\n                 )?;\n             }\n \n@@ -160,10 +163,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n \n+\n+            // When we encounter Resume, we've finished unwinding\n+            // cleanup for the current stack frame. We pop it in order\n+            // to continue unwinding the next frame\n+            Resume => {\n+                trace!(\"unwinding: resuming from cleanup\");\n+                // By definition, a Resume terminaor means\n+                // that we're unwinding\n+                self.pop_stack_frame(/* unwinding */ true)?;\n+                return Ok(())\n+            },\n+\n             Yield { .. } |\n             GeneratorDrop |\n             DropAndReplace { .. } |\n-            Resume |\n             Abort => unimplemented!(\"{:#?}\", terminator.kind),\n             FalseEdges { .. } => bug!(\"should have been eliminated by\\\n                                       `simplify_branches` mir pass\"),\n@@ -237,6 +251,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         args: &[OpTy<'tcx, M::PointerTag>],\n         dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n         ret: Option<mir::BasicBlock>,\n+        unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", fn_val);\n \n@@ -249,6 +264,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n+\n+                if caller_abi != Abi::RustIntrinsic {\n+                    throw_unsup!(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic))\n+                }\n+\n                 // The intrinsic itself cannot diverge, so if we got here without a return\n                 // place... (can happen e.g., for transmute returning `!`)\n                 let dest = match dest {\n@@ -259,7 +279,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // No stack frame gets pushed, the main loop will just act as if the\n                 // call completed.\n                 self.goto_block(ret)?;\n-                self.dump_place(*dest);\n+                if let Some(dest) = dest {\n+                    self.dump_place(*dest)\n+                }\n                 Ok(())\n             }\n             ty::InstanceDef::VtableShim(..) |\n@@ -294,7 +316,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n \n                 // We need MIR for this fn\n-                let body = match M::find_fn(self, instance, args, dest, ret)? {\n+                let body = match M::find_fn(self, instance, args, dest, ret, unwind)? {\n                     Some(body) => body,\n                     None => return Ok(()),\n                 };\n@@ -304,7 +326,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     span,\n                     body,\n                     dest,\n-                    StackPopCleanup::Goto(ret),\n+                    StackPopCleanup::Goto { ret, unwind }\n                 )?;\n \n                 // We want to pop this frame again in case there was an error, to put\n@@ -422,7 +444,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let mut args = args.to_vec();\n-                let ptr_size = self.pointer_size();\n                 // We have to implement all \"object safe receivers\".  Currently we\n                 // support built-in pointers (&, &mut, Box) as well as unsized-self.  We do\n                 // not yet support custom self types.\n@@ -439,15 +460,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 // Find and consult vtable\n                 let vtable = receiver_place.vtable();\n-                let vtable_slot = vtable.ptr_offset(ptr_size * (idx as u64 + 3), self)?;\n-                let vtable_slot = self.memory.check_ptr_access(\n-                    vtable_slot,\n-                    ptr_size,\n-                    self.tcx.data_layout.pointer_align.abi,\n-                )?.expect(\"cannot be a ZST\");\n-                let fn_ptr = self.memory.get_raw(vtable_slot.alloc_id)?\n-                    .read_ptr_sized(self, vtable_slot)?.not_undef()?;\n-                let drop_fn = self.memory.get_fn(fn_ptr)?;\n+                let drop_fn = self.get_vtable_slot(vtable, idx)?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we\n                 // want for args[0]: We have to project to field 0 because we want\n@@ -462,7 +475,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 });\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(drop_fn, span, caller_abi, &args, dest, ret)\n+                self.eval_fn_call(drop_fn, span, caller_abi, &args, dest, ret, unwind)\n             }\n         }\n     }\n@@ -473,6 +486,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         instance: ty::Instance<'tcx>,\n         span: Span,\n         target: mir::BasicBlock,\n+        unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx> {\n         trace!(\"drop_in_place: {:?},\\n  {:?}, {:?}\", *place, place.layout.ty, instance);\n         // We take the address of the object.  This may well be unaligned, which is fine\n@@ -503,6 +517,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             &[arg.into()],\n             Some(dest.into()),\n             Some(target),\n+            unwind\n         )\n     }\n }"}]}