{"sha": "16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MjAxZDQ1ZjE2ODQ1Y2I1ZGMyZmMwYjQ4YmNmMzRhNjcxNWVhMTQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-23T19:21:50Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T15:52:30Z"}, "message": "trans: Get functions and do calls only through Callee.", "tree": {"sha": "b2d6164dc3834a2027556547c5be41f7c3d8474f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2d6164dc3834a2027556547c5be41f7c3d8474f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "html_url": "https://github.com/rust-lang/rust/commit/16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "062a05dde8c3ea5386fa358d882e1eaca99a9ff0", "url": "https://api.github.com/repos/rust-lang/rust/commits/062a05dde8c3ea5386fa358d882e1eaca99a9ff0", "html_url": "https://github.com/rust-lang/rust/commit/062a05dde8c3ea5386fa358d882e1eaca99a9ff0"}], "stats": {"total": 423, "additions": 197, "deletions": 226}, "files": [{"sha": "8aea2f1ec4f4a6150c801ba0bbe57756d5c57b03", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "patch": "@@ -200,12 +200,13 @@ use middle::lang_items::StrEqFnLangItem;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n use middle::pat_util::*;\n+use middle::subst::Substs;\n use trans::adt;\n use trans::base::*;\n use trans::build::{AddCase, And, Br, CondBr, GEPi, InBoundsGEP, Load, PointerCast};\n use trans::build::{Not, Store, Sub, add_comment};\n use trans::build;\n-use trans::callee;\n+use trans::callee::{Callee, ArgVals};\n use trans::cleanup::{self, CleanupMethods, DropHintMethods};\n use trans::common::*;\n use trans::consts;\n@@ -881,19 +882,21 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                               rhs_t: Ty<'tcx>,\n                               debug_loc: DebugLoc)\n                               -> Result<'blk, 'tcx> {\n-    fn compare_str<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+    fn compare_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                lhs_data: ValueRef,\n                                lhs_len: ValueRef,\n                                rhs_data: ValueRef,\n                                rhs_len: ValueRef,\n                                rhs_t: Ty<'tcx>,\n                                debug_loc: DebugLoc)\n                                -> Result<'blk, 'tcx> {\n-        let did = langcall(cx,\n+        let did = langcall(bcx,\n                            None,\n                            &format!(\"comparison of `{}`\", rhs_t),\n                            StrEqFnLangItem);\n-        callee::trans_lang_call(cx, did, &[lhs_data, lhs_len, rhs_data, rhs_len], None, debug_loc)\n+        let args = [lhs_data, lhs_len, rhs_data, rhs_len];\n+        Callee::def(bcx.ccx(), did, bcx.tcx().mk_substs(Substs::empty()))\n+            .call(bcx, debug_loc, ArgVals(&args), None)\n     }\n \n     let _icx = push_ctxt(\"compare_values\");"}, {"sha": "b2d7b83887e3d585d7175744dc423f8b1470ccc6", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 17, "deletions": 37, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "patch": "@@ -57,7 +57,7 @@ use trans::assert_dep_graph;\n use trans::attributes;\n use trans::build::*;\n use trans::builder::{Builder, noname};\n-use trans::callee;\n+use trans::callee::{Callee, CallArgs, ArgExprs, ArgVals};\n use trans::cleanup::{self, CleanupMethods, DropHint};\n use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_uint, C_integral};\n@@ -280,11 +280,9 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"malloc_raw_exchange\");\n \n     // Allocate space:\n-    let r = callee::trans_lang_call(bcx,\n-                                    require_alloc_fn(bcx, info_ty, ExchangeMallocFnLangItem),\n-                                    &[size, align],\n-                                    None,\n-                                    debug_loc);\n+    let def_id = require_alloc_fn(bcx, info_ty, ExchangeMallocFnLangItem);\n+    let r = Callee::def(bcx.ccx(), def_id, bcx.tcx().mk_substs(Substs::empty()))\n+        .call(bcx, debug_loc, ArgVals(&[size, align]), None);\n \n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n@@ -1219,9 +1217,8 @@ pub fn trans_unwind_resume(bcx: Block, lpval: ValueRef) {\n         Resume(bcx, lpval);\n     } else {\n         let exc_ptr = ExtractValue(bcx, lpval, 0);\n-        let llunwresume = bcx.fcx.eh_unwind_resume();\n-        Call(bcx, llunwresume, &[exc_ptr], None, DebugLoc::None);\n-        Unreachable(bcx);\n+        bcx.fcx.eh_unwind_resume()\n+            .call(bcx, DebugLoc::None, ArgVals(&[exc_ptr]), None);\n     }\n }\n \n@@ -2147,20 +2144,10 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   closure::ClosureEnv::NotClosure);\n }\n \n-pub fn trans_enum_variant<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                    ctor_id: ast::NodeId,\n-                                    disr: Disr,\n-                                    param_substs: &'tcx Substs<'tcx>,\n-                                    llfndecl: ValueRef) {\n-    let _icx = push_ctxt(\"trans_enum_variant\");\n-\n-    trans_enum_variant_or_tuple_like_struct(ccx, ctor_id, disr, param_substs, llfndecl);\n-}\n-\n pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                  ctor_ty: Ty<'tcx>,\n                                                  disr: Disr,\n-                                                 args: callee::CallArgs,\n+                                                 args: CallArgs,\n                                                  dest: expr::Dest,\n                                                  debug_loc: DebugLoc)\n                                                  -> Result<'blk, 'tcx> {\n@@ -2188,7 +2175,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     if !type_is_zero_size(ccx, result_ty) {\n         match args {\n-            callee::ArgExprs(exprs) => {\n+            ArgExprs(exprs) => {\n                 let fields = exprs.iter().map(|x| &**x).enumerate().collect::<Vec<_>>();\n                 bcx = expr::trans_adt(bcx,\n                                       result_ty,\n@@ -2204,7 +2191,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         // Just eval all the expressions (if any). Since expressions in Rust can have arbitrary\n         // contents, there could be side-effects we need from them.\n         match args {\n-            callee::ArgExprs(exprs) => {\n+            ArgExprs(exprs) => {\n                 for expr in exprs {\n                     bcx = expr::trans_into(bcx, expr, expr::Ignore);\n                 }\n@@ -2500,8 +2487,9 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                 // compilation unit that references the item, so it will still get\n                 // translated everywhere it's needed.\n                 for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n-                    let llfn = get_item_val(ccx, item.id);\n-                    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+                    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n+                    let def_id = tcx.map.local_def_id(item.id);\n+                    let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n                     if abi != Abi::Rust {\n                         foreign::trans_rust_fn_with_foreign_abi(ccx,\n                                                                 &decl,\n@@ -2536,9 +2524,8 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                         // error in trans. This is used to write compile-fail tests\n                         // that actually test that compilation succeeds without\n                         // reporting an error.\n-                        let item_def_id = ccx.tcx().map.local_def_id(item.id);\n-                        if ccx.tcx().has_attr(item_def_id, \"rustc_error\") {\n-                            ccx.tcx().sess.span_fatal(item.span, \"compilation successful\");\n+                        if tcx.has_attr(def_id, \"rustc_error\") {\n+                            tcx.sess.span_fatal(item.span, \"compilation successful\");\n                         }\n                     }\n                 }\n@@ -2671,17 +2658,10 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,\n-                    Err(s) => {\n-                        ccx.sess().fatal(&s[..]);\n-                    }\n-                };\n-                let start_fn = if let Some(start_node_id) = ccx.tcx()\n-                                                               .map\n-                                                               .as_local_node_id(start_def_id) {\n-                    get_item_val(ccx, start_node_id)\n-                } else {\n-                    get_extern_fn(ccx, start_def_id).val\n+                    Err(s) => ccx.sess().fatal(&s)\n                 };\n+                let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+                let start_fn = Callee::def(ccx, start_def_id, empty_substs).reify(ccx).val;\n                 let args = {\n                     let opaque_rust_main =\n                         llvm::LLVMBuildPointerCast(bld,"}, {"sha": "318c968692c7158bf477151376247f5efc1a5733", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 97, "deletions": 82, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "patch": "@@ -97,61 +97,115 @@ impl<'tcx> Callee<'tcx> {\n     pub fn method<'blk>(bcx: Block<'blk, 'tcx>,\n                         method: ty::MethodCallee<'tcx>) -> Callee<'tcx> {\n         let substs = bcx.tcx().mk_substs(bcx.fcx.monomorphize(&method.substs));\n-        let ty = bcx.fcx.monomorphize(&method.ty);\n-        Callee::def(bcx.ccx(), method.def_id, substs, ty)\n+        Callee::def(bcx.ccx(), method.def_id, substs)\n     }\n \n     /// Function or method definition.\n     pub fn def<'a>(ccx: &CrateContext<'a, 'tcx>,\n                    def_id: DefId,\n-                   substs: &'tcx subst::Substs<'tcx>,\n-                   ty: Ty<'tcx>)\n+                   substs: &'tcx subst::Substs<'tcx>)\n                    -> Callee<'tcx> {\n         let tcx = ccx.tcx();\n \n         if substs.self_ty().is_some() {\n             // Only trait methods can have a Self parameter.\n-            let method_item = tcx.impl_or_trait_item(def_id);\n-            let trait_id = method_item.container().id();\n-            let trait_ref = ty::Binder(substs.to_trait_ref(tcx, trait_id));\n-            let vtbl = common::fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n-            return meth::callee_for_trait_impl(ccx, def_id, substs,\n-                                               trait_id, ty, vtbl);\n+            return Callee::trait_method(ccx, def_id, substs);\n         }\n \n         let maybe_node_id = inline::get_local_instance(ccx, def_id)\n             .and_then(|def_id| tcx.map.as_local_node_id(def_id));\n         let maybe_ast_node = maybe_node_id.and_then(|node_id| {\n             tcx.map.find(node_id)\n         });\n-        match maybe_ast_node {\n+\n+        let data = match maybe_ast_node {\n             Some(hir_map::NodeStructCtor(_)) => {\n-                return Callee {\n-                    data: NamedTupleConstructor(Disr(0)),\n-                    ty: ty\n-                };\n+                NamedTupleConstructor(Disr(0))\n             }\n             Some(hir_map::NodeVariant(_)) => {\n                 let vinfo = common::inlined_variant_def(ccx, maybe_node_id.unwrap());\n-                assert_eq!(vinfo.kind(), ty::VariantKind::Tuple);\n+                NamedTupleConstructor(Disr::from(vinfo.disr_val))\n+            }\n+            Some(hir_map::NodeForeignItem(fi)) if {\n+                let abi = tcx.map.get_foreign_abi(fi.id);\n+                abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic\n+            } => Intrinsic,\n+\n+            _ => return Callee::ptr(get_fn(ccx, def_id, substs))\n+        };\n+\n+        Callee {\n+            data: data,\n+            ty: def_ty(tcx, def_id, substs)\n+        }\n+    }\n+\n+    /// Trait method, which has to be resolved to an impl method.\n+    pub fn trait_method<'a>(ccx: &CrateContext<'a, 'tcx>,\n+                            def_id: DefId,\n+                            substs: &'tcx subst::Substs<'tcx>)\n+                            -> Callee<'tcx> {\n+        let tcx = ccx.tcx();\n \n-                return Callee {\n-                    data: NamedTupleConstructor(Disr::from(vinfo.disr_val)),\n-                    ty: ty\n+        let method_item = tcx.impl_or_trait_item(def_id);\n+        let trait_id = method_item.container().id();\n+        let trait_ref = ty::Binder(substs.to_trait_ref(tcx, trait_id));\n+        match common::fulfill_obligation(ccx, DUMMY_SP, trait_ref) {\n+            traits::VtableImpl(vtable_impl) => {\n+                let impl_did = vtable_impl.impl_def_id;\n+                let mname = tcx.item_name(def_id);\n+                // create a concatenated set of substitutions which includes\n+                // those from the impl and those from the method:\n+                let impl_substs = vtable_impl.substs.with_method_from(&substs);\n+                let substs = tcx.mk_substs(impl_substs);\n+                let mth = tcx.get_impl_method(impl_did, substs, mname);\n+\n+                // Translate the function, bypassing Callee::def.\n+                // That is because default methods have the same ID as the\n+                // trait method used to look up the impl method that ended\n+                // up here, so calling Callee::def would infinitely recurse.\n+                Callee::ptr(get_fn(ccx, mth.method.def_id, mth.substs))\n+            }\n+            traits::VtableClosure(vtable_closure) => {\n+                // The substitutions should have no type parameters remaining\n+                // after passing through fulfill_obligation\n+                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+                let llfn = closure::trans_closure_method(ccx,\n+                                                         vtable_closure.closure_def_id,\n+                                                         vtable_closure.substs,\n+                                                         trait_closure_kind);\n+\n+                let method_ty = def_ty(tcx, def_id, substs);\n+                let fn_ptr_ty = match method_ty.sty {\n+                    ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n+                    _ => unreachable!(\"expected fn item type, found {}\",\n+                                      method_ty)\n                 };\n+                Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n             }\n-            Some(hir_map::NodeForeignItem(fi)) => {\n-                let abi = tcx.map.get_foreign_abi(fi.id);\n-                if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-                    return Callee {\n-                        data: Intrinsic(fi.id, substs),\n-                        ty: ty\n-                    };\n+            traits::VtableFnPointer(fn_ty) => {\n+                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+                let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n+\n+                let method_ty = def_ty(tcx, def_id, substs);\n+                let fn_ptr_ty = match method_ty.sty {\n+                    ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n+                    _ => unreachable!(\"expected fn item type, found {}\",\n+                                      method_ty)\n+                };\n+                Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n+            }\n+            traits::VtableObject(ref data) => {\n+                Callee {\n+                    data: Virtual(traits::get_vtable_index_of_object_method(\n+                        tcx, data, def_id)),\n+                    ty: def_ty(tcx, def_id, substs)\n                 }\n             }\n-            _ => {}\n+            vtable => {\n+                unreachable!(\"resolved vtable bad vtable {:?} in trans\", vtable);\n+            }\n         }\n-        Callee::ptr(trans_fn_ref_with_substs(ccx, def_id, Some(ty), substs))\n     }\n \n     /// This behemoth of a function translates function calls. Unfortunately, in\n@@ -187,7 +241,7 @@ impl<'tcx> Callee<'tcx> {\n             Virtual(idx) => meth::trans_object_shim(ccx, self.ty, idx),\n             NamedTupleConstructor(_) => match self.ty.sty {\n                 ty::TyFnDef(def_id, substs, _) => {\n-                    return trans_fn_ref_with_substs(ccx, def_id, Some(self.ty), substs);\n+                    return get_fn(ccx, def_id, substs);\n                 }\n                 _ => unreachable!(\"expected fn item type, found {}\", self.ty)\n             },\n@@ -196,31 +250,13 @@ impl<'tcx> Callee<'tcx> {\n     }\n }\n \n-/// Translates a reference (with id `ref_id`) to the fn/method with id `def_id` into a function\n-/// pointer. This may require monomorphization or inlining.\n-pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                              def_id: DefId,\n-                              node: ExprOrMethodCall,\n-                              param_substs: &'tcx subst::Substs<'tcx>)\n-                              -> Datum<'tcx, Rvalue> {\n-    let _icx = push_ctxt(\"trans_fn_ref\");\n-\n-    let substs = common::node_id_substs(ccx, node, param_substs);\n-    debug!(\"trans_fn_ref(def_id={:?}, node={:?}, substs={:?})\",\n-           def_id,\n-           node,\n-           substs);\n-    let ref_ty = match node {\n-        ExprId(0) => return trans_fn_ref_with_substs(ccx, def_id, None, substs),\n-        ExprId(id) => ccx.tcx().node_id_to_type(id),\n-        MethodCallKey(method_call) => {\n-            ccx.tcx().tables.borrow().method_map[&method_call].ty\n-        }\n-    };\n-    let ref_ty = monomorphize::apply_param_substs(ccx.tcx(),\n-                                                  param_substs,\n-                                                  &ref_ty);\n-    trans_fn_ref_with_substs(ccx, def_id, Some(ref_ty), substs)\n+/// Given a DefId and some Substs, produces the monomorphic item type.\n+fn def_ty<'tcx>(tcx: &TyCtxt<'tcx>,\n+                def_id: DefId,\n+                substs: &'tcx subst::Substs<'tcx>)\n+                -> Ty<'tcx> {\n+    let ty = tcx.lookup_item_type(def_id).ty;\n+    monomorphize::apply_param_substs(tcx, substs, &ty)\n }\n \n /// Translates an adapter that implements the `Fn` trait for a fn\n@@ -323,7 +359,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfnpointer = match bare_fn_ty.sty {\n         ty::TyFnDef(def_id, substs, _) => {\n             // Function definitions have to be turned into a pointer.\n-            Callee::def(ccx, def_id, substs, bare_fn_ty).reify(ccx).val\n+            Callee::def(ccx, def_id, substs).reify(ccx).val\n         }\n \n         // the first argument (`self`) will be ptr to the fn pointer\n@@ -360,25 +396,14 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n ///\n /// - `ccx`: the crate context\n /// - `def_id`: def id of the fn or method item being referenced\n-/// - `node`: node id of the reference to the fn/method, if applicable.\n-///   This parameter may be zero; but, if so, the resulting value may not\n-///   have the right type, so it must be cast before being used.\n-/// - `ref_ty`: monotype of the reference to the fn/method, if applicable.\n-///   This parameter may be None; but, if so, the resulting value may not\n-///   have the right type, so it must be cast before being used.\n /// - `substs`: values for each of the fn/method's parameters\n-pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n-    ccx: &CrateContext<'a, 'tcx>,\n-    def_id: DefId,\n-    ref_ty: Option<Ty<'tcx>>,\n-    substs: &'tcx subst::Substs<'tcx>)\n-    -> Datum<'tcx, Rvalue>\n-{\n-    let _icx = push_ctxt(\"trans_fn_ref_with_substs\");\n+fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                    def_id: DefId,\n+                    substs: &'tcx subst::Substs<'tcx>)\n+                    -> Datum<'tcx, Rvalue> {\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_fn_ref_with_substs(def_id={:?}, ref_ty={:?}, substs={:?})\",\n-           def_id, ref_ty, substs);\n+    debug!(\"get_fn(def_id={:?}, substs={:?})\", def_id, substs);\n \n     assert!(!substs.types.needs_infer());\n     assert!(!substs.types.has_escaping_regions());\n@@ -408,7 +433,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     let must_monomorphise =\n         !substs.types.is_empty() || is_named_tuple_constructor(tcx, def_id);\n \n-    debug!(\"trans_fn_ref_with_substs({:?}) must_monomorphise: {}\",\n+    debug!(\"get_fn({:?}) must_monomorphise: {}\",\n            def_id, must_monomorphise);\n \n     // Create a monomorphic version of generic functions\n@@ -494,16 +519,6 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n // ______________________________________________________________________\n // Translating calls\n \n-pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   did: DefId,\n-                                   args: &[ValueRef],\n-                                   dest: Option<expr::Dest>,\n-                                   debug_loc: DebugLoc)\n-                                   -> Result<'blk, 'tcx> {\n-    let datum = trans_fn_ref(bcx.ccx(), did, ExprId(0), bcx.fcx.param_substs);\n-    Callee::ptr(datum).call(bcx, debug_loc, ArgVals(args), dest)\n-}\n-\n fn trans_call_inner<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                     debug_loc: DebugLoc,\n                                     callee: Callee<'tcx>,"}, {"sha": "c974173f765ba72404ccef114563def4ff238337", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "patch": "@@ -512,11 +512,12 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         // `rust_eh_personality` function, but rather we wired it up to the\n         // CRT's custom personality function, which forces LLVM to consider\n         // landing pads as \"landing pads for SEH\".\n-        let target = &self.ccx.sess().target.target;\n-        match self.ccx.tcx().lang_items.eh_personality() {\n-            Some(def_id) if !base::wants_msvc_seh(self.ccx.sess()) => {\n-                callee::trans_fn_ref(self.ccx, def_id, ExprId(0),\n-                                     self.param_substs).val\n+        let ccx = self.ccx;\n+        let tcx = ccx.tcx();\n+        let target = &ccx.sess().target.target;\n+        match tcx.lang_items.eh_personality() {\n+            Some(def_id) if !base::wants_msvc_seh(ccx.sess()) => {\n+                Callee::def(ccx, def_id, tcx.mk_substs(Substs::empty())).reify(ccx).val\n             }\n             _ => {\n                 let mut personality = self.ccx.eh_personality().borrow_mut();"}, {"sha": "ec550c680de448a1350df861847404bf0dabec64", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "patch": "@@ -352,9 +352,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         Some(AdjustReifyFnPointer) => {\n             match ety.sty {\n                 ty::TyFnDef(def_id, substs, _) => {\n-                    let datum = Callee::def(cx, def_id, substs, ety).reify(cx);\n-                    llconst = datum.val;\n-                    ety_adjusted = datum.ty;\n+                    llconst = Callee::def(cx, def_id, substs).reify(cx).val;\n                 }\n                 _ => {\n                     unreachable!(\"{} cannot be reified to a fn ptr\", ety)"}, {"sha": "ef8d4cfff9dddabdfe316bd4b488d9db7ce2e667", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "patch": "@@ -11,10 +11,11 @@\n use llvm::ValueRef;\n use middle::def::Def;\n use middle::lang_items::{PanicFnLangItem, PanicBoundsCheckFnLangItem};\n+use middle::subst::Substs;\n use trans::base::*;\n use trans::basic_block::BasicBlock;\n use trans::build::*;\n-use trans::callee;\n+use trans::callee::{Callee, ArgVals};\n use trans::cleanup::CleanupMethods;\n use trans::cleanup;\n use trans::common::*;\n@@ -405,13 +406,8 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let expr_file_line = consts::addr_of(ccx, expr_file_line_const, align, \"panic_loc\");\n     let args = vec!(expr_file_line);\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicFnLangItem);\n-    let bcx = callee::trans_lang_call(bcx,\n-                                      did,\n-                                      &args[..],\n-                                      Some(expr::Ignore),\n-                                      call_info.debug_loc()).bcx;\n-    Unreachable(bcx);\n-    return bcx;\n+    Callee::def(ccx, did, ccx.tcx().mk_substs(Substs::empty()))\n+        .call(bcx, call_info.debug_loc(), ArgVals(&args), None).bcx\n }\n \n pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -438,11 +434,6 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let file_line = consts::addr_of(ccx, file_line_const, align, \"panic_bounds_check_loc\");\n     let args = vec!(file_line, index, len);\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n-    let bcx = callee::trans_lang_call(bcx,\n-                                      did,\n-                                      &args[..],\n-                                      Some(expr::Ignore),\n-                                      call_info.debug_loc()).bcx;\n-    Unreachable(bcx);\n-    return bcx;\n+    Callee::def(ccx, did, ccx.tcx().mk_substs(Substs::empty()))\n+        .call(bcx, call_info.debug_loc(), ArgVals(&args), None).bcx\n }"}, {"sha": "63612cd1e1f4319d3efe35f6f2f2eb72913342c5", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "patch": "@@ -385,7 +385,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         AdjustReifyFnPointer => {\n             match datum.ty.sty {\n                 ty::TyFnDef(def_id, substs, _) => {\n-                    datum = Callee::def(bcx.ccx(), def_id, substs, datum.ty)\n+                    datum = Callee::def(bcx.ccx(), def_id, substs)\n                         .reify(bcx.ccx()).to_expr_datum();\n                 }\n                 _ => {\n@@ -1143,7 +1143,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let f = unpack_datum!(bcx, trans(bcx, f));\n                 (match f.ty.sty {\n                     ty::TyFnDef(def_id, substs, _) => {\n-                        Callee::def(bcx.ccx(), def_id, substs, f.ty)\n+                        Callee::def(bcx.ccx(), def_id, substs)\n                     }\n                     ty::TyFnPtr(_) => {\n                         let f = unpack_datum!(bcx,"}, {"sha": "c93548fe1c2c16b13aa38ef908585277c8629394", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "patch": "@@ -25,7 +25,7 @@ use trans::adt;\n use trans::adt::GetDtorType; // for tcx.dtor_type()\n use trans::base::*;\n use trans::build::*;\n-use trans::callee;\n+use trans::callee::{Callee, ArgVals};\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::collector::{self, TransItem};\n@@ -44,19 +44,18 @@ use libc::c_uint;\n use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n \n-pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+pub fn trans_exchange_free_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                            v: ValueRef,\n                                            size: ValueRef,\n                                            align: ValueRef,\n                                            debug_loc: DebugLoc)\n                                            -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_exchange_free\");\n-    let ccx = cx.ccx();\n-    callee::trans_lang_call(cx,\n-        langcall(cx, None, \"\", ExchangeFreeFnLangItem),\n-        &[PointerCast(cx, v, Type::i8p(ccx)), size, align],\n-        Some(expr::Ignore),\n-        debug_loc).bcx\n+\n+    let def_id = langcall(bcx, None, \"\", ExchangeFreeFnLangItem);\n+    let args = [PointerCast(bcx, v, Type::i8p(bcx.ccx())), size, align];\n+    Callee::def(bcx.ccx(), def_id, bcx.tcx().mk_substs(Substs::empty()))\n+        .call(bcx, debug_loc, ArgVals(&args), None).bcx\n }\n \n pub fn trans_exchange_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n@@ -366,9 +365,8 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => tcx.sess.bug(&format!(\"dtor for {:?} is not an impl???\", t))\n     };\n     let dtor_did = def.destructor().unwrap();\n-    bcx = callee::Callee::ptr(callee::trans_fn_ref_with_substs(\n-            bcx.ccx(), dtor_did, None, vtbl.substs))\n-        .call(bcx, DebugLoc::None, callee::ArgVals(args), Some(expr::Ignore)).bcx;\n+    bcx = Callee::def(bcx.ccx(), dtor_did, vtbl.substs)\n+        .call(bcx, DebugLoc::None, ArgVals(args), None).bcx;\n \n     bcx.fcx.pop_and_trans_custom_cleanup_scope(bcx, contents_scope)\n }"}, {"sha": "c260f77e8875e652eeb9516440accd7a24617348", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "patch": "@@ -12,7 +12,8 @@ use llvm::{AvailableExternallyLinkage, InternalLinkage, SetLinkage};\n use middle::cstore::{CrateStore, FoundAst, InlinedItem};\n use middle::def_id::DefId;\n use middle::subst::Substs;\n-use trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};\n+use trans::base::{push_ctxt, trans_item, trans_fn};\n+use trans::callee::Callee;\n use trans::common::*;\n \n use rustc::dep_graph::DepNode;\n@@ -21,14 +22,15 @@ use rustc_front::hir;\n fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n     debug!(\"instantiate_inline({:?})\", fn_id);\n     let _icx = push_ctxt(\"instantiate_inline\");\n-    let _task = ccx.tcx().dep_graph.in_task(DepNode::TransInlinedItem(fn_id));\n+    let tcx = ccx.tcx();\n+    let _task = tcx.dep_graph.in_task(DepNode::TransInlinedItem(fn_id));\n \n     match ccx.external().borrow().get(&fn_id) {\n         Some(&Some(node_id)) => {\n             // Already inline\n             debug!(\"instantiate_inline({}): already inline as node id {}\",\n-                   ccx.tcx().item_path_str(fn_id), node_id);\n-            let node_def_id = ccx.tcx().map.local_def_id(node_id);\n+                   tcx.item_path_str(fn_id), node_id);\n+            let node_def_id = tcx.map.local_def_id(node_id);\n             return Some(node_def_id);\n         }\n         Some(&None) => {\n@@ -39,7 +41,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n         }\n     }\n \n-    let inlined = ccx.tcx().sess.cstore.maybe_get_item_ast(ccx.tcx(), fn_id);\n+    let inlined = tcx.sess.cstore.maybe_get_item_ast(tcx, fn_id);\n     let inline_id = match inlined {\n         FoundAst::NotFound => {\n             ccx.external().borrow_mut().insert(fn_id, None);\n@@ -52,38 +54,27 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n             ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n             trans_item(ccx, item);\n \n-            let linkage = match item.node {\n-                hir::ItemFn(_, _, _, _, ref generics, _) => {\n-                    if generics.is_type_parameterized() {\n-                        // Generics have no symbol, so they can't be given any\n-                        // linkage.\n-                        None\n+            if let hir::ItemFn(_, _, _, _, ref generics, _) = item.node {\n+                // Generics have no symbol, so they can't be given any linkage.\n+                if !generics.is_type_parameterized() {\n+                    let linkage = if ccx.sess().opts.cg.codegen_units == 1 {\n+                        // We could use AvailableExternallyLinkage here,\n+                        // but InternalLinkage allows LLVM to optimize more\n+                        // aggressively (at the cost of sometimes\n+                        // duplicating code).\n+                        InternalLinkage\n                     } else {\n-                        if ccx.sess().opts.cg.codegen_units == 1 {\n-                            // We could use AvailableExternallyLinkage here,\n-                            // but InternalLinkage allows LLVM to optimize more\n-                            // aggressively (at the cost of sometimes\n-                            // duplicating code).\n-                            Some(InternalLinkage)\n-                        } else {\n-                            // With multiple compilation units, duplicated code\n-                            // is more of a problem.  Also, `codegen_units > 1`\n-                            // means the user is okay with losing some\n-                            // performance.\n-                            Some(AvailableExternallyLinkage)\n-                        }\n-                    }\n-                }\n-                hir::ItemConst(..) => None,\n-                _ => unreachable!(),\n-            };\n-\n-            match linkage {\n-                Some(linkage) => {\n-                    let g = get_item_val(ccx, item.id);\n-                    SetLinkage(g, linkage);\n+                        // With multiple compilation units, duplicated code\n+                        // is more of a problem.  Also, `codegen_units > 1`\n+                        // means the user is okay with losing some\n+                        // performance.\n+                        AvailableExternallyLinkage\n+                    };\n+                    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n+                    let def_id = tcx.map.local_def_id(item.id);\n+                    let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n+                    SetLinkage(llfn, linkage);\n                 }\n-                None => {}\n             }\n \n             item.id\n@@ -120,7 +111,6 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n                 _ => ccx.sess().bug(\"instantiate_inline: item has a \\\n                                  non-enum, non-struct parent\")\n             }\n-            trans_item(ccx, &item);\n             my_id\n         }\n         FoundAst::Found(&InlinedItem::TraitItem(_, ref trait_item)) => {\n@@ -133,10 +123,10 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n             // the logic to do that already exists in `middle`. In order to\n             // reuse that code, it needs to be able to look up the traits for\n             // inlined items.\n-            let ty_trait_item = ccx.tcx().impl_or_trait_item(fn_id).clone();\n-            let trait_item_def_id = ccx.tcx().map.local_def_id(trait_item.id);\n-            ccx.tcx().impl_or_trait_items.borrow_mut()\n-                     .insert(trait_item_def_id, ty_trait_item);\n+            let ty_trait_item = tcx.impl_or_trait_item(fn_id).clone();\n+            let trait_item_def_id = tcx.map.local_def_id(trait_item.id);\n+            tcx.impl_or_trait_items.borrow_mut()\n+               .insert(trait_item_def_id, ty_trait_item);\n \n             // If this is a default method, we can't look up the\n             // impl type. But we aren't going to translate anyways, so\n@@ -151,11 +141,12 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n \n             // Translate monomorphic impl methods immediately.\n             if let hir::ImplItemKind::Method(ref sig, ref body) = impl_item.node {\n-                let impl_tpt = ccx.tcx().lookup_item_type(impl_did);\n+                let impl_tpt = tcx.lookup_item_type(impl_did);\n                 if impl_tpt.generics.types.is_empty() &&\n                         sig.generics.ty_params.is_empty() {\n-                    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-                    let llfn = get_item_val(ccx, impl_item.id);\n+                    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n+                    let def_id = tcx.map.local_def_id(impl_item.id);\n+                    let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n                     trans_fn(ccx,\n                              &sig.decl,\n                              body,\n@@ -176,7 +167,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n         }\n     };\n \n-    let inline_def_id = ccx.tcx().map.local_def_id(inline_id);\n+    let inline_def_id = tcx.map.local_def_id(inline_id);\n     Some(inline_def_id)\n }\n "}, {"sha": "77df214d6dd114b38458c15eaa35ba2f50ba8275", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "patch": "@@ -213,7 +213,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     if out_type_size != 0 {\n                         // FIXME #19925 Remove this hack after a release cycle.\n                         let _ = unpack_datum!(bcx, expr::trans(bcx, &arg_exprs[0]));\n-                        let llfn = Callee::def(ccx, def_id, substs, in_type).reify(ccx).val;\n+                        let llfn = Callee::def(ccx, def_id, substs).reify(ccx).val;\n                         let llfnty = val_ty(llfn);\n                         let llresult = match dest {\n                             expr::SaveIn(d) => d,\n@@ -1208,6 +1208,7 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              dloc: DebugLoc) -> Block<'blk, 'tcx> {\n     let llfn = get_rust_try_fn(bcx.fcx, &mut |bcx| {\n         let ccx = bcx.ccx();\n+        let tcx = ccx.tcx();\n         let dloc = DebugLoc::None;\n \n         // Translates the shims described above:\n@@ -1228,10 +1229,11 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // managed by the standard library.\n \n         attributes::emit_uwtable(bcx.fcx.llfn, true);\n-        let catch_pers = match bcx.tcx().lang_items.eh_personality_catch() {\n-            Some(did) => callee::trans_fn_ref(ccx, did, ExprId(0),\n-                                              bcx.fcx.param_substs).val,\n-            None => bcx.tcx().sess.bug(\"eh_personality_catch not defined\"),\n+        let catch_pers = match tcx.lang_items.eh_personality_catch() {\n+            Some(did) => {\n+                Callee::def(ccx, did, tcx.mk_substs(Substs::empty())).reify(ccx).val\n+            }\n+            None => ccx.sess().bug(\"eh_personality_catch not defined\"),\n         };\n \n         let then = bcx.fcx.new_temp_block(\"then\");\n@@ -1341,9 +1343,10 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     let tcx = ccx.tcx();\n     let dloc = DebugLoc::None;\n \n-    let rust_try_filter = match ccx.tcx().lang_items.msvc_try_filter() {\n-        Some(did) => callee::trans_fn_ref(ccx, did, ExprId(0),\n-                                          fcx.param_substs).val,\n+    let rust_try_filter = match tcx.lang_items.msvc_try_filter() {\n+        Some(did) => {\n+            Callee::def(ccx, did, tcx.mk_substs(Substs::empty())).reify(ccx).val\n+        }\n         None => ccx.sess().bug(\"msvc_try_filter not defined\"),\n     };\n "}, {"sha": "5b052a8e6024f5689da611cc3bec85eaf581d6c2", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "patch": "@@ -310,17 +310,9 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 let nullptr = C_null(Type::nil(ccx).ptr_to());\n                 get_vtable_methods(ccx, id, substs)\n                     .into_iter()\n-                    .map(|opt_mth| {\n-                        match opt_mth {\n-                            Some(mth) => {\n-                                trans_fn_ref_with_substs(ccx,\n-                                                         mth.method.def_id,\n-                                                         None,\n-                                                         &mth.substs).val\n-                            }\n-                            None => nullptr\n-                        }\n-                    })\n+                    .map(|opt_mth| opt_mth.map_or(nullptr, |mth| {\n+                        Callee::def(ccx, mth.method.def_id, &mth.substs).reify(ccx).val\n+                    }))\n                     .collect::<Vec<_>>()\n                     .into_iter()\n             }"}, {"sha": "1bbb2447e6a3ccec81e19194e58101485b60bfc5", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "patch": "@@ -163,7 +163,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 let (callee, fty) = match callee.ty.sty {\n                     ty::TyFnDef(def_id, substs, f) => {\n-                        (Callee::def(bcx.ccx(), def_id, substs, callee.ty), f)\n+                        (Callee::def(bcx.ccx(), def_id, substs), f)\n                     }\n                     ty::TyFnPtr(f) => {\n                         (Callee {"}, {"sha": "99c388f604b907cffc2c566940ecd5d5006a7c83", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16201d45f16845cb5dc2fc0b48bcf34a6715ea14/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=16201d45f16845cb5dc2fc0b48bcf34a6715ea14", "patch": "@@ -201,7 +201,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         match operand.ty.sty {\n                             ty::TyFnDef(def_id, substs, _) => {\n                                 OperandValue::Immediate(\n-                                    Callee::def(bcx.ccx(), def_id, substs, operand.ty)\n+                                    Callee::def(bcx.ccx(), def_id, substs)\n                                         .reify(bcx.ccx()).val)\n                             }\n                             _ => {\n@@ -511,8 +511,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 if use_fmod {\n                     let f64t = Type::f64(bcx.ccx());\n                     let fty = Type::func(&[f64t, f64t], &f64t);\n-                    let llfn = declare::declare_cfn(bcx.ccx(), \"fmod\", fty,\n-                                                    tcx.types.f64);\n+                    let llfn = declare::declare_cfn(bcx.ccx(), \"fmod\", fty);\n                     if input_ty == tcx.types.f32 {\n                         let lllhs = bcx.fpext(lhs, f64t);\n                         let llrhs = bcx.fpext(rhs, f64t);"}]}