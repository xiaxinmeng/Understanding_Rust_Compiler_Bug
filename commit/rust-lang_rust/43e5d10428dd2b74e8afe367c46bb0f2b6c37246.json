{"sha": "43e5d10428dd2b74e8afe367c46bb0f2b6c37246", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZTVkMTA0MjhkZDJiNzRlOGFmZTM2N2M0NmJiMGYyYjZjMzcyNDY=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-10-13T20:26:23Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-10-13T20:48:29Z"}, "message": "Improve the error message for missing else clauses in if expressions", "tree": {"sha": "79ed633bef6682933311064290f7346a711d7c3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79ed633bef6682933311064290f7346a711d7c3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43e5d10428dd2b74e8afe367c46bb0f2b6c37246", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43e5d10428dd2b74e8afe367c46bb0f2b6c37246", "html_url": "https://github.com/rust-lang/rust/commit/43e5d10428dd2b74e8afe367c46bb0f2b6c37246", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43e5d10428dd2b74e8afe367c46bb0f2b6c37246/comments", "author": null, "committer": null, "parents": [{"sha": "4a382d7c4743775e9ee87735ed606b0a673d8ed5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a382d7c4743775e9ee87735ed606b0a673d8ed5", "html_url": "https://github.com/rust-lang/rust/commit/4a382d7c4743775e9ee87735ed606b0a673d8ed5"}], "stats": {"total": 94, "additions": 63, "deletions": 31}, "files": [{"sha": "2c47c8845cb2ad65c6528c0f8713f17918c70d79", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/43e5d10428dd2b74e8afe367c46bb0f2b6c37246/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43e5d10428dd2b74e8afe367c46bb0f2b6c37246/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=43e5d10428dd2b74e8afe367c46bb0f2b6c37246", "patch": "@@ -2999,35 +2999,36 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                        expected: Expectation) {\n         check_expr_has_type(fcx, cond_expr, ty::mk_bool());\n \n+        // Disregard \"castable to\" expectations because they\n+        // can lead us astray. Consider for example `if cond\n+        // {22} else {c} as u8` -- if we propagate the\n+        // \"castable to u8\" constraint to 22, it will pick the\n+        // type 22u8, which is overly constrained (c might not\n+        // be a u8). In effect, the problem is that the\n+        // \"castable to\" expectation is not the tightest thing\n+        // we can say, so we want to drop it in this case.\n+        // The tightest thing we can say is \"must unify with\n+        // else branch\". Note that in the case of a \"has type\"\n+        // constraint, this limitation does not hold.\n+\n+        // If the expected type is just a type variable, then don't use\n+        // an expected type. Otherwise, we might write parts of the type\n+        // when checking the 'then' block which are incompatible with the\n+        // 'else' branch.\n+        let expected = match expected.only_has_type() {\n+            ExpectHasType(ety) => {\n+                match infer::resolve_type(fcx.infcx(), Some(sp), ety, force_tvar) {\n+                    Ok(rty) if !ty::type_is_ty_var(rty) => ExpectHasType(rty),\n+                    _ => NoExpectation\n+                }\n+            }\n+            _ => NoExpectation\n+        };\n+        check_block_with_expected(fcx, then_blk, expected);\n+        let then_ty = fcx.node_ty(then_blk.id);\n+\n         let branches_ty = match opt_else_expr {\n             Some(ref else_expr) => {\n-                // Disregard \"castable to\" expectations because they\n-                // can lead us astray. Consider for example `if cond\n-                // {22} else {c} as u8` -- if we propagate the\n-                // \"castable to u8\" constraint to 22, it will pick the\n-                // type 22u8, which is overly constrained (c might not\n-                // be a u8). In effect, the problem is that the\n-                // \"castable to\" expectation is not the tightest thing\n-                // we can say, so we want to drop it in this case.\n-                // The tightest thing we can say is \"must unify with\n-                // else branch\". Note that in the case of a \"has type\"\n-                // constraint, this limitation does not hold.\n-\n-                // If the expected type is just a type variable, then don't use\n-                // an expected type. Otherwise, we might write parts of the type\n-                // when checking the 'then' block which are incompatible with the\n-                // 'else' branch.\n-                let expected = match expected.only_has_type() {\n-                    ExpectHasType(ety) => {\n-                        match infer::resolve_type(fcx.infcx(), Some(sp), ety, force_tvar) {\n-                            Ok(rty) if !ty::type_is_ty_var(rty) => ExpectHasType(rty),\n-                            _ => NoExpectation\n-                        }\n-                    }\n-                    _ => NoExpectation\n-                };\n-                check_block_with_expected(fcx, then_blk, expected);\n-                let then_ty = fcx.node_ty(then_blk.id);\n                 check_expr_with_expectation(fcx, &**else_expr, expected);\n                 let else_ty = fcx.expr_ty(&**else_expr);\n                 infer::common_supertype(fcx.infcx(),\n@@ -3037,8 +3038,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                         else_ty)\n             }\n             None => {\n-                check_block_no_value(fcx, then_blk);\n-                ty::mk_nil()\n+                infer::common_supertype(fcx.infcx(),\n+                                        infer::IfExpressionWithNoElse(sp),\n+                                        false,\n+                                        then_ty,\n+                                        ty::mk_nil())\n             }\n         };\n "}, {"sha": "1a79837c03ae35704f4245165edd0683f4841db6", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43e5d10428dd2b74e8afe367c46bb0f2b6c37246/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43e5d10428dd2b74e8afe367c46bb0f2b6c37246/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=43e5d10428dd2b74e8afe367c46bb0f2b6c37246", "patch": "@@ -366,6 +366,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n             infer::RelateOutputImplTypes(_) => \"mismatched types\",\n             infer::MatchExpressionArm(_, _) => \"match arms have incompatible types\",\n             infer::IfExpression(_) => \"if and else have incompatible types\",\n+            infer::IfExpressionWithNoElse(_) => \"if may be missing an else clause\",\n         };\n \n         self.tcx.sess.span_err(\n@@ -1486,6 +1487,9 @@ impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n                     infer::IfExpression(_) => {\n                         format!(\"if and else have compatible types\")\n                     }\n+                    infer::IfExpressionWithNoElse(_) => {\n+                        format!(\"if may be missing an else clause\")\n+                    }\n                 };\n \n                 match self.values_str(&trace.values) {"}, {"sha": "7c04b371aaea084c9f8468c414b10105a1d71654", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43e5d10428dd2b74e8afe367c46bb0f2b6c37246/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43e5d10428dd2b74e8afe367c46bb0f2b6c37246/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=43e5d10428dd2b74e8afe367c46bb0f2b6c37246", "patch": "@@ -121,6 +121,9 @@ pub enum TypeOrigin {\n \n     // Computing common supertype in an if expression\n     IfExpression(Span),\n+\n+    // Computing common supertype of an if expression with no else counter-part\n+    IfExpressionWithNoElse(Span)\n }\n \n /// See `error_reporting.rs` for more details\n@@ -1001,6 +1004,7 @@ impl TypeOrigin {\n             RelateOutputImplTypes(span) => span,\n             MatchExpressionArm(match_span, _) => match_span,\n             IfExpression(span) => span,\n+            IfExpressionWithNoElse(span) => span\n         }\n     }\n }\n@@ -1030,6 +1034,9 @@ impl Repr for TypeOrigin {\n             IfExpression(a) => {\n                 format!(\"IfExpression({})\", a.repr(tcx))\n             }\n+            IfExpressionWithNoElse(a) => {\n+                format!(\"IfExpressionWithNoElse({})\", a.repr(tcx))\n+            }\n         }\n     }\n }"}, {"sha": "0754d273a9bd28819b548225be2f2e377429d7e9", "filename": "src/test/compile-fail/if-without-else-result.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43e5d10428dd2b74e8afe367c46bb0f2b6c37246/src%2Ftest%2Fcompile-fail%2Fif-without-else-result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43e5d10428dd2b74e8afe367c46bb0f2b6c37246/src%2Ftest%2Fcompile-fail%2Fif-without-else-result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-without-else-result.rs?ref=43e5d10428dd2b74e8afe367c46bb0f2b6c37246", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:mismatched types: expected `()`, found `bool`\n-\n extern crate debug;\n \n fn main() {\n     let a = if true { true };\n+//~^ ERROR if may be missing an else clause: expected `()`, found `bool` (expected (), found bool)\n     println!(\"{:?}\", a);\n }"}, {"sha": "4b2be9e58acdc2028f5d13fc9c4cb00ac28a89c1", "filename": "src/test/compile-fail/issue-4201.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43e5d10428dd2b74e8afe367c46bb0f2b6c37246/src%2Ftest%2Fcompile-fail%2Fissue-4201.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43e5d10428dd2b74e8afe367c46bb0f2b6c37246/src%2Ftest%2Fcompile-fail%2Fissue-4201.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4201.rs?ref=43e5d10428dd2b74e8afe367c46bb0f2b6c37246", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let a = if true {\n+        0\n+    } else if false {\n+//~^ ERROR if may be missing an else clause: expected `()`, found `<generic integer #1>`\n+        1\n+    };\n+}"}]}