{"sha": "46f649c479ce40f3b4590590dda6c2895e8d60f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ZjY0OWM0NzljZTQwZjNiNDU5MDU5MGRkYTZjMjg5NWU4ZDYwZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-18T08:27:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-18T08:27:22Z"}, "message": "Auto merge of #22838 - petrochenkov:bytelit, r=alexcrichton\n\nThis patch changes the type of byte string literals from `&[u8]` to `&[u8; N]`.\r\nIt also implements some necessary traits (`IntoBytes`, `Seek`, `Read`, `BufRead`) for fixed-size arrays (also related to #21725) and adds test for #17233, which seems to be resolved.\r\n\r\nFixes #18465\r\n[breaking-change]", "tree": {"sha": "1c775c64a8d726183113d966c2b01ae6d60c6289", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c775c64a8d726183113d966c2b01ae6d60c6289"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46f649c479ce40f3b4590590dda6c2895e8d60f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46f649c479ce40f3b4590590dda6c2895e8d60f6", "html_url": "https://github.com/rust-lang/rust/commit/46f649c479ce40f3b4590590dda6c2895e8d60f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46f649c479ce40f3b4590590dda6c2895e8d60f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9a7bc58f89b9b15eb1269f0c0d68baf5fc7e966", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9a7bc58f89b9b15eb1269f0c0d68baf5fc7e966", "html_url": "https://github.com/rust-lang/rust/commit/f9a7bc58f89b9b15eb1269f0c0d68baf5fc7e966"}, {"sha": "dccd17d23e6e67e410e41f97ba9feb7f71717627", "url": "https://api.github.com/repos/rust-lang/rust/commits/dccd17d23e6e67e410e41f97ba9feb7f71717627", "html_url": "https://github.com/rust-lang/rust/commit/dccd17d23e6e67e410e41f97ba9feb7f71717627"}], "stats": {"total": 467, "additions": 276, "deletions": 191}, "files": [{"sha": "edb11df54894c8ec502755d6c9978e8483ce0e3a", "filename": "src/libcore/array.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -23,10 +23,34 @@ use marker::{Copy, Sized};\n use option::Option;\n use slice::{Iter, IterMut, SliceExt};\n \n+/// Utility trait implemented only on arrays of fixed size\n+///\n+/// This trait can be used to implement other traits on fixed-size arrays\n+/// without causing much metadata bloat.\n+#[unstable(feature = \"core\")]\n+pub trait FixedSizeArray<T> {\n+    /// Converts the array to immutable slice\n+    fn as_slice(&self) -> &[T];\n+    /// Converts the array to mutable slice\n+    fn as_mut_slice(&mut self) -> &mut [T];\n+}\n+\n // macro for implementing n-ary tuple functions and operations\n macro_rules! array_impls {\n     ($($N:expr)+) => {\n         $(\n+            #[unstable(feature = \"core\")]\n+            impl<T> FixedSizeArray<T> for [T; $N] {\n+                #[inline]\n+                fn as_slice(&self) -> &[T] {\n+                    &self[..]\n+                }\n+                #[inline]\n+                fn as_mut_slice(&mut self) -> &mut [T] {\n+                    &mut self[..]\n+                }\n+            }\n+\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T:Copy> Clone for [T; $N] {\n                 fn clone(&self) -> [T; $N] {"}, {"sha": "29cc11d5a60a18e7ad7062c4c36c6aa8f33bca1e", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -129,6 +129,7 @@ pub mod default;\n /* Core types and methods on primitives */\n \n pub mod any;\n+pub mod array;\n pub mod atomic;\n pub mod cell;\n pub mod char;\n@@ -151,7 +152,6 @@ mod bool {\n \n // note: does not need to be public\n mod tuple;\n-mod array;\n \n #[doc(hidden)]\n mod core {"}, {"sha": "7732ff5f9b99573dd3ae9b2845bc552791ff7d4f", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -448,7 +448,8 @@ impl<T, E> Result<T, E> {\n     /// ```\n     /// use std::old_io::IoResult;\n     ///\n-    /// let mut buffer = &mut b\"1\\n2\\n3\\n4\\n\";\n+    /// let mut buffer: &[u8] = b\"1\\n2\\n3\\n4\\n\";\n+    /// let mut buffer = &mut buffer;\n     ///\n     /// let mut sum = 0;\n     ///"}, {"sha": "44f6d1bfd0b07fa1a5378096530191e45647a488", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -200,7 +200,7 @@ use middle::mem_categorization as mc;\n use middle::pat_util::*;\n use trans::adt;\n use trans::base::*;\n-use trans::build::{AddCase, And, BitCast, Br, CondBr, GEPi, InBoundsGEP, Load};\n+use trans::build::{AddCase, And, Br, CondBr, GEPi, InBoundsGEP, Load, PointerCast};\n use trans::build::{Not, Store, Sub, add_comment};\n use trans::build;\n use trans::callee;\n@@ -853,14 +853,31 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n             ty::ty_str => compare_str(cx, lhs, rhs, rhs_t, debug_loc),\n             ty::ty_vec(ty, _) => match ty.sty {\n                 ty::ty_uint(ast::TyU8) => {\n-                    // NOTE: cast &[u8] to &str and abuse the str_eq lang item,\n+                    // NOTE: cast &[u8] and &[u8; N] to &str and abuse the str_eq lang item,\n                     // which calls memcmp().\n-                    let t = ty::mk_str_slice(cx.tcx(),\n-                                             cx.tcx().mk_region(ty::ReStatic),\n-                                             ast::MutImmutable);\n-                    let lhs = BitCast(cx, lhs, type_of::type_of(cx.ccx(), t).ptr_to());\n-                    let rhs = BitCast(cx, rhs, type_of::type_of(cx.ccx(), t).ptr_to());\n-                    compare_str(cx, lhs, rhs, rhs_t, debug_loc)\n+                    let pat_len = val_ty(rhs).element_type().array_length();\n+                    let ty_str_slice = ty::mk_str_slice(cx.tcx(),\n+                                                        cx.tcx().mk_region(ty::ReStatic),\n+                                                        ast::MutImmutable);\n+\n+                    let rhs_str = alloc_ty(cx, ty_str_slice, \"rhs_str\");\n+                    Store(cx, GEPi(cx, rhs, &[0, 0]), expr::get_dataptr(cx, rhs_str));\n+                    Store(cx, C_uint(cx.ccx(), pat_len), expr::get_len(cx, rhs_str));\n+\n+                    let lhs_str;\n+                    if val_ty(lhs) == val_ty(rhs) {\n+                        // Both the discriminant and the pattern are thin pointers\n+                        lhs_str = alloc_ty(cx, ty_str_slice, \"lhs_str\");\n+                        Store(cx, GEPi(cx, lhs, &[0, 0]), expr::get_dataptr(cx, lhs_str));\n+                        Store(cx, C_uint(cx.ccx(), pat_len), expr::get_len(cx, lhs_str));\n+                    }\n+                    else {\n+                        // The discriminant is a fat pointer\n+                        let llty_str_slice = type_of::type_of(cx.ccx(), ty_str_slice).ptr_to();\n+                        lhs_str = PointerCast(cx, lhs, llty_str_slice);\n+                    }\n+\n+                    compare_str(cx, lhs_str, rhs_str, rhs_t, debug_loc)\n                 },\n                 _ => cx.sess().bug(\"only byte strings supported in compare_values\"),\n             },"}, {"sha": "2a3fcd66195b340e456ac5301002f19058a9506f", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -75,14 +75,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         ast::LitBool(b) => C_bool(cx, b),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n         ast::LitBinary(ref data) => {\n-            let g = addr_of(cx, C_bytes(cx, &data[..]), \"binary\", e.id);\n-            let base = ptrcast(g, Type::i8p(cx));\n-            let prev_const = cx.const_unsized().borrow_mut()\n-                               .insert(base, g);\n-            assert!(prev_const.is_none() || prev_const == Some(g));\n-            assert_eq!(abi::FAT_PTR_ADDR, 0);\n-            assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-            C_struct(cx, &[base, C_uint(cx, data.len())], false)\n+            addr_of(cx, C_bytes(cx, &data[..]), \"binary\", e.id)\n         }\n     }\n }"}, {"sha": "3e8cc46e2550107d9fede430516be79e4e3b289c", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -4054,7 +4054,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n /// .debug_gdb_scripts global is referenced, so it isn't removed by the linker.\n pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext) {\n     if needs_gdb_debug_scripts_section(ccx) {\n-        let empty = CString::new(b\"\").unwrap();\n+        let empty = CString::new(\"\").unwrap();\n         let gdb_debug_scripts_section_global =\n             get_or_insert_gdb_debug_scripts_section_global(ccx);\n         unsafe {"}, {"sha": "8e2f4dcefa02231db95ee7d5d576e8dc7df057b7", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -48,7 +48,23 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         ast::PatLit(ref lt) => {\n             check_expr(fcx, &**lt);\n             let expr_ty = fcx.expr_ty(&**lt);\n-            fcx.write_ty(pat.id, expr_ty);\n+\n+            // Byte string patterns behave the same way as array patterns\n+            // They can denote both statically and dynamically sized byte arrays\n+            let mut pat_ty = expr_ty;\n+            if let ast::ExprLit(ref lt) = lt.node {\n+                if let ast::LitBinary(_) = lt.node {\n+                    let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n+                    if let ty::ty_rptr(_, mt) = expected_ty.sty {\n+                        if let ty::ty_vec(_, None) = mt.ty.sty {\n+                            pat_ty = ty::mk_slice(tcx, tcx.mk_region(ty::ReStatic),\n+                                ty::mt{ ty: tcx.types.u8, mutbl: ast::MutImmutable })\n+                        }\n+                    }\n+                }\n+            }\n+\n+            fcx.write_ty(pat.id, pat_ty);\n \n             // somewhat surprising: in this case, the subtyping\n             // relation goes the opposite way as the other\n@@ -62,7 +78,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             //     &'static str <: expected\n             //\n             // that's equivalent to there existing a LUB.\n-            demand::suptype(fcx, pat.span, expected, expr_ty);\n+            demand::suptype(fcx, pat.span, expected, pat_ty);\n         }\n         ast::PatRange(ref begin, ref end) => {\n             check_expr(fcx, &**begin);"}, {"sha": "0d32d7a34e78e8a017705f2155d6ca65486afae1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -2505,10 +2505,11 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     match lit.node {\n         ast::LitStr(..) => ty::mk_str_slice(tcx, tcx.mk_region(ty::ReStatic), ast::MutImmutable),\n-        ast::LitBinary(..) => {\n-            ty::mk_slice(tcx,\n-                         tcx.mk_region(ty::ReStatic),\n-                         ty::mt{ ty: tcx.types.u8, mutbl: ast::MutImmutable })\n+        ast::LitBinary(ref v) => {\n+            ty::mk_rptr(tcx, tcx.mk_region(ty::ReStatic), ty::mt {\n+                ty: ty::mk_vec(tcx, tcx.types.u8, Some(v.len())),\n+                mutbl: ast::MutImmutable,\n+            })\n         }\n         ast::LitByte(_) => tcx.types.u8,\n         ast::LitChar(_) => tcx.types.char,"}, {"sha": "28f22468d2223656640fa0afb2d9db6401a500a5", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -58,7 +58,7 @@ use vec::Vec;\n ///     fn my_printer(s: *const libc::c_char);\n /// }\n ///\n-/// let to_print = b\"Hello, world!\";\n+/// let to_print = &b\"Hello, world!\"[..];\n /// let c_to_print = CString::new(to_print).unwrap();\n /// unsafe {\n ///     my_printer(c_to_print.as_ptr());\n@@ -469,14 +469,14 @@ mod tests {\n \n     #[test]\n     fn simple() {\n-        let s = CString::new(b\"1234\").unwrap();\n+        let s = CString::new(\"1234\").unwrap();\n         assert_eq!(s.as_bytes(), b\"1234\");\n         assert_eq!(s.as_bytes_with_nul(), b\"1234\\0\");\n     }\n \n     #[test]\n     fn build_with_zero1() {\n-        assert!(CString::new(b\"\\0\").is_err());\n+        assert!(CString::new(&b\"\\0\"[..]).is_err());\n     }\n     #[test]\n     fn build_with_zero2() {\n@@ -493,7 +493,7 @@ mod tests {\n \n     #[test]\n     fn formatted() {\n-        let s = CString::new(b\"12\").unwrap();\n+        let s = CString::new(&b\"12\"[..]).unwrap();\n         assert_eq!(format!(\"{:?}\", s), \"\\\"12\\\"\");\n     }\n "}, {"sha": "43eec695274208213e2a1f4e9850a2c58879037f", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -622,7 +622,7 @@ mod tests {\n \n     #[test]\n     fn test_read_line() {\n-        let in_buf = b\"a\\nb\\nc\";\n+        let in_buf: &[u8] = b\"a\\nb\\nc\";\n         let mut reader = BufReader::with_capacity(2, in_buf);\n         let mut s = String::new();\n         reader.read_line(&mut s).unwrap();\n@@ -640,7 +640,7 @@ mod tests {\n \n     #[test]\n     fn test_lines() {\n-        let in_buf = b\"a\\nb\\nc\";\n+        let in_buf: &[u8] = b\"a\\nb\\nc\";\n         let reader = BufReader::with_capacity(2, in_buf);\n         let mut it = reader.lines();\n         assert_eq!(it.next(), Some(Ok(\"a\".to_string())));"}, {"sha": "365f5e37b0b30a6413bd81f8361dbe560197fd8d", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -328,7 +328,7 @@ mod tests {\n \n     #[test]\n     fn test_read_char() {\n-        let b = b\"Vi\\xE1\\xBB\\x87t\";\n+        let b = &b\"Vi\\xE1\\xBB\\x87t\"[..];\n         let mut c = Cursor::new(b).chars();\n         assert_eq!(c.next(), Some(Ok('V')));\n         assert_eq!(c.next(), Some(Ok('i')));\n@@ -339,7 +339,7 @@ mod tests {\n \n     #[test]\n     fn test_read_bad_char() {\n-        let b = b\"\\x80\";\n+        let b = &b\"\\x80\"[..];\n         let mut c = Cursor::new(b).chars();\n         assert!(c.next().unwrap().is_err());\n     }"}, {"sha": "d9e8047104ad0275147817c58e728e36078a01c5", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -933,12 +933,12 @@ mod tests {\n \n     #[test]\n     fn read_until() {\n-        let mut buf = Cursor::new(b\"12\");\n+        let mut buf = Cursor::new(&b\"12\"[..]);\n         let mut v = Vec::new();\n         assert_eq!(buf.read_until(b'3', &mut v), Ok(2));\n         assert_eq!(v, b\"12\");\n \n-        let mut buf = Cursor::new(b\"1233\");\n+        let mut buf = Cursor::new(&b\"1233\"[..]);\n         let mut v = Vec::new();\n         assert_eq!(buf.read_until(b'3', &mut v), Ok(3));\n         assert_eq!(v, b\"123\");\n@@ -952,12 +952,12 @@ mod tests {\n \n     #[test]\n     fn split() {\n-        let buf = Cursor::new(b\"12\");\n+        let buf = Cursor::new(&b\"12\"[..]);\n         let mut s = buf.split(b'3');\n         assert_eq!(s.next(), Some(Ok(vec![b'1', b'2'])));\n         assert_eq!(s.next(), None);\n \n-        let buf = Cursor::new(b\"1233\");\n+        let buf = Cursor::new(&b\"1233\"[..]);\n         let mut s = buf.split(b'3');\n         assert_eq!(s.next(), Some(Ok(vec![b'1', b'2'])));\n         assert_eq!(s.next(), Some(Ok(vec![])));\n@@ -966,12 +966,12 @@ mod tests {\n \n     #[test]\n     fn read_line() {\n-        let mut buf = Cursor::new(b\"12\");\n+        let mut buf = Cursor::new(&b\"12\"[..]);\n         let mut v = String::new();\n         assert_eq!(buf.read_line(&mut v), Ok(2));\n         assert_eq!(v, \"12\");\n \n-        let mut buf = Cursor::new(b\"12\\n\\n\");\n+        let mut buf = Cursor::new(&b\"12\\n\\n\"[..]);\n         let mut v = String::new();\n         assert_eq!(buf.read_line(&mut v), Ok(3));\n         assert_eq!(v, \"12\\n\");\n@@ -985,12 +985,12 @@ mod tests {\n \n     #[test]\n     fn lines() {\n-        let buf = Cursor::new(b\"12\");\n+        let buf = Cursor::new(&b\"12\"[..]);\n         let mut s = buf.lines();\n         assert_eq!(s.next(), Some(Ok(\"12\".to_string())));\n         assert_eq!(s.next(), None);\n \n-        let buf = Cursor::new(b\"12\\n\\n\");\n+        let buf = Cursor::new(&b\"12\\n\\n\"[..]);\n         let mut s = buf.lines();\n         assert_eq!(s.next(), Some(Ok(\"12\".to_string())));\n         assert_eq!(s.next(), Some(Ok(String::new())));\n@@ -999,30 +999,30 @@ mod tests {\n \n     #[test]\n     fn read_to_end() {\n-        let mut c = Cursor::new(b\"\");\n+        let mut c = Cursor::new(&b\"\"[..]);\n         let mut v = Vec::new();\n         assert_eq!(c.read_to_end(&mut v), Ok(0));\n         assert_eq!(v, []);\n \n-        let mut c = Cursor::new(b\"1\");\n+        let mut c = Cursor::new(&b\"1\"[..]);\n         let mut v = Vec::new();\n         assert_eq!(c.read_to_end(&mut v), Ok(1));\n         assert_eq!(v, b\"1\");\n     }\n \n     #[test]\n     fn read_to_string() {\n-        let mut c = Cursor::new(b\"\");\n+        let mut c = Cursor::new(&b\"\"[..]);\n         let mut v = String::new();\n         assert_eq!(c.read_to_string(&mut v), Ok(0));\n         assert_eq!(v, \"\");\n \n-        let mut c = Cursor::new(b\"1\");\n+        let mut c = Cursor::new(&b\"1\"[..]);\n         let mut v = String::new();\n         assert_eq!(c.read_to_string(&mut v), Ok(1));\n         assert_eq!(v, \"1\");\n \n-        let mut c = Cursor::new(b\"\\xff\");\n+        let mut c = Cursor::new(&b\"\\xff\"[..]);\n         let mut v = String::new();\n         assert!(c.read_to_string(&mut v).is_err());\n     }"}, {"sha": "53b126ec00038f5ca8205abbc0cc9d2fc4055521", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -1231,7 +1231,7 @@ mod tests {\n         cmd.env(\"path\", \"foo\");\n         cmd.env(\"Path\", \"bar\");\n         let env = &cmd.env.unwrap();\n-        let val = env.get(&EnvKey(CString::new(b\"PATH\").unwrap()));\n-        assert!(val.unwrap() == &CString::new(b\"bar\").unwrap());\n+        let val = env.get(&EnvKey(CString::new(\"PATH\").unwrap()));\n+        assert!(val.unwrap() == &CString::new(\"bar\").unwrap());\n     }\n }"}, {"sha": "413184c84d2a8e2c9c2373c911b6bdf65e01ff3a", "filename": "src/libstd/old_io/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -445,7 +445,8 @@ mod test {\n \n     #[test]\n     fn limit_reader_buffer() {\n-        let r = &mut b\"0123456789\\n0123456789\\n\";\n+        let mut r: &[u8] = b\"0123456789\\n0123456789\\n\";\n+        let r = &mut r;\n         {\n             let mut r = LimitReader::new(r.by_ref(), 3);\n             assert_eq!(r.read_line(), Ok(\"012\".to_string()));"}, {"sha": "5fc34c0fe920a84bb665413be7029271005b3a3c", "filename": "src/libstd/old_path/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -311,7 +311,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # #[cfg(windows)] fn foo() {}\n     /// # #[cfg(unix)] fn foo() {\n     /// let p = Path::new(\"abc/def/ghi\");\n-    /// assert_eq!(p.filename(), Some(b\"ghi\"));\n+    /// assert_eq!(p.filename(), Some(&b\"ghi\"[..]));\n     /// # }\n     /// ```\n     fn filename<'a>(&'a self) -> Option<&'a [u8]>;\n@@ -345,7 +345,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # #[cfg(windows)] fn foo() {}\n     /// # #[cfg(unix)] fn foo() {\n     /// let p = Path::new(\"/abc/def.txt\");\n-    /// assert_eq!(p.filestem(), Some(b\"def\"));\n+    /// assert_eq!(p.filestem(), Some(&b\"def\"[..]));\n     /// # }\n     /// ```\n     fn filestem<'a>(&'a self) -> Option<&'a [u8]> {\n@@ -392,7 +392,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # #[cfg(windows)] fn foo() {}\n     /// # #[cfg(unix)] fn foo() {\n     /// let p = Path::new(\"abc/def.txt\");\n-    /// assert_eq!(p.extension(), Some(b\"txt\"));\n+    /// assert_eq!(p.extension(), Some(&b\"txt\"[..]));\n     /// # }\n     /// ```\n     fn extension<'a>(&'a self) -> Option<&'a [u8]> {"}, {"sha": "c42f1e6b07da5efba0c67a8cd9be572b01f45723", "filename": "src/libstd/old_path/posix.rs", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -477,11 +477,11 @@ mod tests {\n     fn test_paths() {\n         let empty: &[u8] = &[];\n         t!(v: Path::new(empty), b\".\");\n-        t!(v: Path::new(b\"/\"), b\"/\");\n-        t!(v: Path::new(b\"a/b/c\"), b\"a/b/c\");\n-        t!(v: Path::new(b\"a/b/c\\xFF\"), b\"a/b/c\\xFF\");\n-        t!(v: Path::new(b\"\\xFF/../foo\\x80\"), b\"foo\\x80\");\n-        let p = Path::new(b\"a/b/c\\xFF\");\n+        t!(v: Path::new(&b\"/\"[..]), b\"/\");\n+        t!(v: Path::new(&b\"a/b/c\"[..]), b\"a/b/c\");\n+        t!(v: Path::new(&b\"a/b/c\\xFF\"[..]), b\"a/b/c\\xFF\");\n+        t!(v: Path::new(&b\"\\xFF/../foo\\x80\"[..]), b\"foo\\x80\");\n+        let p = Path::new(&b\"a/b/c\\xFF\"[..]);\n         assert!(p.as_str().is_none());\n \n         t!(s: Path::new(\"\"), \".\");\n@@ -507,18 +507,18 @@ mod tests {\n         t!(s: Path::new(\"foo/../../..\"), \"../..\");\n         t!(s: Path::new(\"foo/../../bar\"), \"../bar\");\n \n-        assert_eq!(Path::new(b\"foo/bar\").into_vec(), b\"foo/bar\");\n-        assert_eq!(Path::new(b\"/foo/../../bar\").into_vec(),\n+        assert_eq!(Path::new(&b\"foo/bar\"[..]).into_vec(), b\"foo/bar\");\n+        assert_eq!(Path::new(&b\"/foo/../../bar\"[..]).into_vec(),\n                    b\"/bar\");\n \n-        let p = Path::new(b\"foo/bar\\x80\");\n+        let p = Path::new(&b\"foo/bar\\x80\"[..]);\n         assert!(p.as_str().is_none());\n     }\n \n     #[test]\n     fn test_opt_paths() {\n-        assert!(Path::new_opt(b\"foo/bar\\0\").is_none());\n-        t!(v: Path::new_opt(b\"foo/bar\").unwrap(), b\"foo/bar\");\n+        assert!(Path::new_opt(&b\"foo/bar\\0\"[..]).is_none());\n+        t!(v: Path::new_opt(&b\"foo/bar\"[..]).unwrap(), b\"foo/bar\");\n         assert!(Path::new_opt(\"foo/bar\\0\").is_none());\n         t!(s: Path::new_opt(\"foo/bar\").unwrap(), \"foo/bar\");\n     }\n@@ -527,17 +527,17 @@ mod tests {\n     fn test_null_byte() {\n         use thread;\n         let result = thread::spawn(move|| {\n-            Path::new(b\"foo/bar\\0\");\n+            Path::new(&b\"foo/bar\\0\"[..]);\n         }).join();\n         assert!(result.is_err());\n \n         let result = thread::spawn(move|| {\n-            Path::new(\"test\").set_filename(b\"f\\0o\")\n+            Path::new(\"test\").set_filename(&b\"f\\0o\"[..])\n         }).join();\n         assert!(result.is_err());\n \n         let result = thread::spawn(move|| {\n-            Path::new(\"test\").push(b\"f\\0o\");\n+            Path::new(\"test\").push(&b\"f\\0o\"[..]);\n         }).join();\n         assert!(result.is_err());\n     }\n@@ -553,11 +553,11 @@ mod tests {\n             )\n         }\n         t!(\"foo\", display, \"foo\");\n-        t!(b\"foo\\x80\", display, \"foo\\u{FFFD}\");\n-        t!(b\"foo\\xFFbar\", display, \"foo\\u{FFFD}bar\");\n-        t!(b\"foo\\xFF/bar\", filename_display, \"bar\");\n-        t!(b\"foo/\\xFFbar\", filename_display, \"\\u{FFFD}bar\");\n-        t!(b\"/\", filename_display, \"\");\n+        t!(&b\"foo\\x80\"[..], display, \"foo\\u{FFFD}\");\n+        t!(&b\"foo\\xFFbar\"[..], display, \"foo\\u{FFFD}bar\");\n+        t!(&b\"foo\\xFF/bar\"[..], filename_display, \"bar\");\n+        t!(&b\"foo/\\xFFbar\"[..], filename_display, \"\\u{FFFD}bar\");\n+        t!(&b\"/\"[..], filename_display, \"\");\n \n         macro_rules! t {\n             ($path:expr, $exp:expr) => (\n@@ -577,11 +577,11 @@ mod tests {\n         }\n \n         t!(\"foo\", \"foo\");\n-        t!(b\"foo\\x80\", \"foo\\u{FFFD}\");\n-        t!(b\"foo\\xFFbar\", \"foo\\u{FFFD}bar\");\n-        t!(b\"foo\\xFF/bar\", \"bar\", filename);\n-        t!(b\"foo/\\xFFbar\", \"\\u{FFFD}bar\", filename);\n-        t!(b\"/\", \"\", filename);\n+        t!(&b\"foo\\x80\"[..], \"foo\\u{FFFD}\");\n+        t!(&b\"foo\\xFFbar\"[..], \"foo\\u{FFFD}bar\");\n+        t!(&b\"foo\\xFF/bar\"[..], \"bar\", filename);\n+        t!(&b\"foo/\\xFFbar\"[..], \"\\u{FFFD}bar\", filename);\n+        t!(&b\"/\"[..], \"\", filename);\n     }\n \n     #[test]\n@@ -598,13 +598,13 @@ mod tests {\n             )\n         }\n \n-        t!(b\"foo\", \"foo\", \"foo\");\n-        t!(b\"foo/bar\", \"foo/bar\", \"bar\");\n-        t!(b\"/\", \"/\", \"\");\n-        t!(b\"foo\\xFF\", \"foo\\u{FFFD}\", \"foo\\u{FFFD}\");\n-        t!(b\"foo\\xFF/bar\", \"foo\\u{FFFD}/bar\", \"bar\");\n-        t!(b\"foo/\\xFFbar\", \"foo/\\u{FFFD}bar\", \"\\u{FFFD}bar\");\n-        t!(b\"\\xFFfoo/bar\\xFF\", \"\\u{FFFD}foo/bar\\u{FFFD}\", \"bar\\u{FFFD}\");\n+        t!(&b\"foo\"[..], \"foo\", \"foo\");\n+        t!(&b\"foo/bar\"[..], \"foo/bar\", \"bar\");\n+        t!(&b\"/\"[..], \"/\", \"\");\n+        t!(&b\"foo\\xFF\"[..], \"foo\\u{FFFD}\", \"foo\\u{FFFD}\");\n+        t!(&b\"foo\\xFF/bar\"[..], \"foo\\u{FFFD}/bar\", \"bar\");\n+        t!(&b\"foo/\\xFFbar\"[..], \"foo/\\u{FFFD}bar\", \"\\u{FFFD}bar\");\n+        t!(&b\"\\xFFfoo/bar\\xFF\"[..], \"\\u{FFFD}foo/bar\\u{FFFD}\", \"bar\\u{FFFD}\");\n     }\n \n     #[test]\n@@ -632,9 +632,9 @@ mod tests {\n             );\n         }\n \n-        t!(v: b\"a/b/c\", filename, Some(b\"c\"));\n-        t!(v: b\"a/b/c\\xFF\", filename, Some(b\"c\\xFF\"));\n-        t!(v: b\"a/b\\xFF/c\", filename, Some(b\"c\"));\n+        t!(v: &b\"a/b/c\"[..], filename, Some(&b\"c\"[..]));\n+        t!(v: &b\"a/b/c\\xFF\"[..], filename, Some(&b\"c\\xFF\"[..]));\n+        t!(v: &b\"a/b\\xFF/c\"[..], filename, Some(&b\"c\"[..]));\n         t!(s: \"a/b/c\", filename, Some(\"c\"), opt);\n         t!(s: \"/a/b/c\", filename, Some(\"c\"), opt);\n         t!(s: \"a\", filename, Some(\"a\"), opt);\n@@ -644,9 +644,9 @@ mod tests {\n         t!(s: \"..\", filename, None, opt);\n         t!(s: \"../..\", filename, None, opt);\n \n-        t!(v: b\"a/b/c\", dirname, b\"a/b\");\n-        t!(v: b\"a/b/c\\xFF\", dirname, b\"a/b\");\n-        t!(v: b\"a/b\\xFF/c\", dirname, b\"a/b\\xFF\");\n+        t!(v: &b\"a/b/c\"[..], dirname, b\"a/b\");\n+        t!(v: &b\"a/b/c\\xFF\"[..], dirname, b\"a/b\");\n+        t!(v: &b\"a/b\\xFF/c\"[..], dirname, b\"a/b\\xFF\");\n         t!(s: \"a/b/c\", dirname, \"a/b\");\n         t!(s: \"/a/b/c\", dirname, \"/a/b\");\n         t!(s: \"a\", dirname, \".\");\n@@ -656,9 +656,9 @@ mod tests {\n         t!(s: \"..\", dirname, \"..\");\n         t!(s: \"../..\", dirname, \"../..\");\n \n-        t!(v: b\"hi/there.txt\", filestem, Some(b\"there\"));\n-        t!(v: b\"hi/there\\x80.txt\", filestem, Some(b\"there\\x80\"));\n-        t!(v: b\"hi/there.t\\x80xt\", filestem, Some(b\"there\"));\n+        t!(v: &b\"hi/there.txt\"[..], filestem, Some(&b\"there\"[..]));\n+        t!(v: &b\"hi/there\\x80.txt\"[..], filestem, Some(&b\"there\\x80\"[..]));\n+        t!(v: &b\"hi/there.t\\x80xt\"[..], filestem, Some(&b\"there\"[..]));\n         t!(s: \"hi/there.txt\", filestem, Some(\"there\"), opt);\n         t!(s: \"hi/there\", filestem, Some(\"there\"), opt);\n         t!(s: \"there.txt\", filestem, Some(\"there\"), opt);\n@@ -672,11 +672,11 @@ mod tests {\n         t!(s: \"..\", filestem, None, opt);\n         t!(s: \"../..\", filestem, None, opt);\n \n-        t!(v: b\"hi/there.txt\", extension, Some(b\"txt\"));\n-        t!(v: b\"hi/there\\x80.txt\", extension, Some(b\"txt\"));\n-        t!(v: b\"hi/there.t\\x80xt\", extension, Some(b\"t\\x80xt\"));\n-        t!(v: b\"hi/there\", extension, None);\n-        t!(v: b\"hi/there\\x80\", extension, None);\n+        t!(v: &b\"hi/there.txt\"[..], extension, Some(&b\"txt\"[..]));\n+        t!(v: &b\"hi/there\\x80.txt\"[..], extension, Some(&b\"txt\"[..]));\n+        t!(v: &b\"hi/there.t\\x80xt\"[..], extension, Some(&b\"t\\x80xt\"[..]));\n+        t!(v: &b\"hi/there\"[..], extension, None);\n+        t!(v: &b\"hi/there\\x80\"[..], extension, None);\n         t!(s: \"hi/there.txt\", extension, Some(\"txt\"), opt);\n         t!(s: \"hi/there\", extension, None, opt);\n         t!(s: \"there.txt\", extension, Some(\"txt\"), opt);\n@@ -756,9 +756,9 @@ mod tests {\n         t!(s: \"a/b/c\", [\"d\", \"/e\"], \"/e\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n         t!(s: \"a/b/c\", [\"d\".to_string(), \"e\".to_string()], \"a/b/c/d/e\");\n-        t!(v: b\"a/b/c\", [b\"d\", b\"e\"], b\"a/b/c/d/e\");\n-        t!(v: b\"a/b/c\", [b\"d\", b\"/e\", b\"f\"], b\"/e/f\");\n-        t!(v: b\"a/b/c\", [b\"d\".to_vec(), b\"e\".to_vec()], b\"a/b/c/d/e\");\n+        t!(v: &b\"a/b/c\"[..], [&b\"d\"[..], &b\"e\"[..]], b\"a/b/c/d/e\");\n+        t!(v: &b\"a/b/c\"[..], [&b\"d\"[..], &b\"/e\"[..], &b\"f\"[..]], b\"/e/f\");\n+        t!(v: &b\"a/b/c\"[..], [b\"d\".to_vec(), b\"e\".to_vec()], b\"a/b/c/d/e\");\n     }\n \n     #[test]\n@@ -782,15 +782,15 @@ mod tests {\n             )\n         }\n \n-        t!(b: b\"a/b/c\", b\"a/b\", true);\n-        t!(b: b\"a\", b\".\", true);\n-        t!(b: b\".\", b\".\", false);\n-        t!(b: b\"/a\", b\"/\", true);\n-        t!(b: b\"/\", b\"/\", false);\n-        t!(b: b\"a/b/c\\x80\", b\"a/b\", true);\n-        t!(b: b\"a/b\\x80/c\", b\"a/b\\x80\", true);\n-        t!(b: b\"\\xFF\", b\".\", true);\n-        t!(b: b\"/\\xFF\", b\"/\", true);\n+        t!(b: &b\"a/b/c\"[..], b\"a/b\", true);\n+        t!(b: &b\"a\"[..], b\".\", true);\n+        t!(b: &b\".\"[..], b\".\", false);\n+        t!(b: &b\"/a\"[..], b\"/\", true);\n+        t!(b: &b\"/\"[..], b\"/\", false);\n+        t!(b: &b\"a/b/c\\x80\"[..], b\"a/b\", true);\n+        t!(b: &b\"a/b\\x80/c\"[..], b\"a/b\\x80\", true);\n+        t!(b: &b\"\\xFF\"[..], b\".\", true);\n+        t!(b: &b\"/\\xFF\"[..], b\"/\", true);\n         t!(s: \"a/b/c\", \"a/b\", true);\n         t!(s: \"a\", \".\", true);\n         t!(s: \".\", \".\", false);\n@@ -800,15 +800,15 @@ mod tests {\n \n     #[test]\n     fn test_root_path() {\n-        assert_eq!(Path::new(b\"a/b/c\").root_path(), None);\n-        assert_eq!(Path::new(b\"/a/b/c\").root_path(), Some(Path::new(\"/\")));\n+        assert_eq!(Path::new(&b\"a/b/c\"[..]).root_path(), None);\n+        assert_eq!(Path::new(&b\"/a/b/c\"[..]).root_path(), Some(Path::new(\"/\")));\n     }\n \n     #[test]\n     fn test_join() {\n-        t!(v: Path::new(b\"a/b/c\").join(b\"..\"), b\"a/b\");\n-        t!(v: Path::new(b\"/a/b/c\").join(b\"d\"), b\"/a/b/c/d\");\n-        t!(v: Path::new(b\"a/\\x80/c\").join(b\"\\xFF\"), b\"a/\\x80/c/\\xFF\");\n+        t!(v: Path::new(&b\"a/b/c\"[..]).join(&b\"..\"[..]), b\"a/b\");\n+        t!(v: Path::new(&b\"/a/b/c\"[..]).join(&b\"d\"[..]), b\"/a/b/c/d\");\n+        t!(v: Path::new(&b\"a/\\x80/c\"[..]).join(&b\"\\xFF\"[..]), b\"a/\\x80/c/\\xFF\");\n         t!(s: Path::new(\"a/b/c\").join(\"..\"), \"a/b\");\n         t!(s: Path::new(\"/a/b/c\").join(\"d\"), \"/a/b/c/d\");\n         t!(s: Path::new(\"a/b\").join(\"c/d\"), \"a/b/c/d\");\n@@ -861,17 +861,17 @@ mod tests {\n         t!(s: \"a/b/c\", [\"..\", \"d\"], \"a/b/d\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n         t!(s: \"a/b/c\", [\"d\".to_string(), \"e\".to_string()], \"a/b/c/d/e\");\n-        t!(v: b\"a/b/c\", [b\"d\", b\"e\"], b\"a/b/c/d/e\");\n-        t!(v: b\"a/b/c\", [b\"d\".to_vec(), b\"e\".to_vec()], b\"a/b/c/d/e\");\n+        t!(v: &b\"a/b/c\"[..], [&b\"d\"[..], &b\"e\"[..]], b\"a/b/c/d/e\");\n+        t!(v: &b\"a/b/c\"[..], [b\"d\".to_vec(), b\"e\".to_vec()], b\"a/b/c/d/e\");\n     }\n \n     #[test]\n     fn test_with_helpers() {\n         let empty: &[u8] = &[];\n \n-        t!(v: Path::new(b\"a/b/c\").with_filename(b\"d\"), b\"a/b/d\");\n-        t!(v: Path::new(b\"a/b/c\\xFF\").with_filename(b\"\\x80\"), b\"a/b/\\x80\");\n-        t!(v: Path::new(b\"/\\xFF/foo\").with_filename(b\"\\xCD\"),\n+        t!(v: Path::new(&b\"a/b/c\"[..]).with_filename(&b\"d\"[..]), b\"a/b/d\");\n+        t!(v: Path::new(&b\"a/b/c\\xFF\"[..]).with_filename(&b\"\\x80\"[..]), b\"a/b/\\x80\");\n+        t!(v: Path::new(&b\"/\\xFF/foo\"[..]).with_filename(&b\"\\xCD\"[..]),\n               b\"/\\xFF/\\xCD\");\n         t!(s: Path::new(\"a/b/c\").with_filename(\"d\"), \"a/b/d\");\n         t!(s: Path::new(\".\").with_filename(\"foo\"), \"foo\");\n@@ -893,13 +893,13 @@ mod tests {\n         t!(s: Path::new(\"..\").with_filename(\"\"), \"..\");\n         t!(s: Path::new(\"../..\").with_filename(\"\"), \"../..\");\n \n-        t!(v: Path::new(b\"hi/there\\x80.txt\").with_extension(b\"exe\"),\n+        t!(v: Path::new(&b\"hi/there\\x80.txt\"[..]).with_extension(&b\"exe\"[..]),\n               b\"hi/there\\x80.exe\");\n-        t!(v: Path::new(b\"hi/there.txt\\x80\").with_extension(b\"\\xFF\"),\n+        t!(v: Path::new(&b\"hi/there.txt\\x80\"[..]).with_extension(&b\"\\xFF\"[..]),\n               b\"hi/there.\\xFF\");\n-        t!(v: Path::new(b\"hi/there\\x80\").with_extension(b\"\\xFF\"),\n+        t!(v: Path::new(&b\"hi/there\\x80\"[..]).with_extension(&b\"\\xFF\"[..]),\n               b\"hi/there\\x80.\\xFF\");\n-        t!(v: Path::new(b\"hi/there.\\xFF\").with_extension(empty), b\"hi/there\");\n+        t!(v: Path::new(&b\"hi/there.\\xFF\"[..]).with_extension(empty), b\"hi/there\");\n         t!(s: Path::new(\"hi/there.txt\").with_extension(\"exe\"), \"hi/there.exe\");\n         t!(s: Path::new(\"hi/there.txt\").with_extension(\"\"), \"hi/there\");\n         t!(s: Path::new(\"hi/there.txt\").with_extension(\".\"), \"hi/there..\");\n@@ -941,17 +941,17 @@ mod tests {\n             )\n         }\n \n-        t!(v: b\"a/b/c\", set_filename, with_filename, b\"d\");\n-        t!(v: b\"/\", set_filename, with_filename, b\"foo\");\n-        t!(v: b\"\\x80\", set_filename, with_filename, b\"\\xFF\");\n+        t!(v: &b\"a/b/c\"[..], set_filename, with_filename, &b\"d\"[..]);\n+        t!(v: &b\"/\"[..], set_filename, with_filename, &b\"foo\"[..]);\n+        t!(v: &b\"\\x80\"[..], set_filename, with_filename, &b\"\\xFF\"[..]);\n         t!(s: \"a/b/c\", set_filename, with_filename, \"d\");\n         t!(s: \"/\", set_filename, with_filename, \"foo\");\n         t!(s: \".\", set_filename, with_filename, \"foo\");\n         t!(s: \"a/b\", set_filename, with_filename, \"\");\n         t!(s: \"a\", set_filename, with_filename, \"\");\n \n-        t!(v: b\"hi/there.txt\", set_extension, with_extension, b\"exe\");\n-        t!(v: b\"hi/there.t\\x80xt\", set_extension, with_extension, b\"exe\\xFF\");\n+        t!(v: &b\"hi/there.txt\"[..], set_extension, with_extension, &b\"exe\"[..]);\n+        t!(v: &b\"hi/there.t\\x80xt\"[..], set_extension, with_extension, &b\"exe\\xFF\"[..]);\n         t!(s: \"hi/there.txt\", set_extension, with_extension, \"exe\");\n         t!(s: \"hi/there.\", set_extension, with_extension, \"txt\");\n         t!(s: \"hi/there\", set_extension, with_extension, \"txt\");\n@@ -983,10 +983,10 @@ mod tests {\n             )\n         }\n \n-        t!(v: Path::new(b\"a/b/c\"), Some(b\"c\"), b\"a/b\", Some(b\"c\"), None);\n-        t!(v: Path::new(b\"a/b/\\xFF\"), Some(b\"\\xFF\"), b\"a/b\", Some(b\"\\xFF\"), None);\n-        t!(v: Path::new(b\"hi/there.\\xFF\"), Some(b\"there.\\xFF\"), b\"hi\",\n-              Some(b\"there\"), Some(b\"\\xFF\"));\n+        t!(v: Path::new(&b\"a/b/c\"[..]), Some(&b\"c\"[..]), b\"a/b\", Some(&b\"c\"[..]), None);\n+        t!(v: Path::new(&b\"a/b/\\xFF\"[..]), Some(&b\"\\xFF\"[..]), b\"a/b\", Some(&b\"\\xFF\"[..]), None);\n+        t!(v: Path::new(&b\"hi/there.\\xFF\"[..]), Some(&b\"there.\\xFF\"[..]), b\"hi\",\n+              Some(&b\"there\"[..]), Some(&b\"\\xFF\"[..]));\n         t!(s: Path::new(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), None);\n         t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n         t!(s: Path::new(\"/\"), None, Some(\"/\"), None, None);\n@@ -1000,16 +1000,16 @@ mod tests {\n         t!(s: Path::new(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n         t!(s: Path::new(\"hi/..there\"), Some(\"..there\"), Some(\"hi\"),\n               Some(\".\"), Some(\"there\"));\n-        t!(s: Path::new(b\"a/b/\\xFF\"), None, Some(\"a/b\"), None, None);\n-        t!(s: Path::new(b\"a/b/\\xFF.txt\"), None, Some(\"a/b\"), None, Some(\"txt\"));\n-        t!(s: Path::new(b\"a/b/c.\\x80\"), None, Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: Path::new(b\"\\xFF/b\"), Some(\"b\"), None, Some(\"b\"), None);\n+        t!(s: Path::new(&b\"a/b/\\xFF\"[..]), None, Some(\"a/b\"), None, None);\n+        t!(s: Path::new(&b\"a/b/\\xFF.txt\"[..]), None, Some(\"a/b\"), None, Some(\"txt\"));\n+        t!(s: Path::new(&b\"a/b/c.\\x80\"[..]), None, Some(\"a/b\"), Some(\"c\"), None);\n+        t!(s: Path::new(&b\"\\xFF/b\"[..]), Some(\"b\"), None, Some(\"b\"), None);\n     }\n \n     #[test]\n     fn test_dir_path() {\n-        t!(v: Path::new(b\"hi/there\\x80\").dir_path(), b\"hi\");\n-        t!(v: Path::new(b\"hi\\xFF/there\").dir_path(), b\"hi\\xFF\");\n+        t!(v: Path::new(&b\"hi/there\\x80\"[..]).dir_path(), b\"hi\");\n+        t!(v: Path::new(&b\"hi\\xFF/there\"[..]).dir_path(), b\"hi\\xFF\");\n         t!(s: Path::new(\"hi/there\").dir_path(), \"hi\");\n         t!(s: Path::new(\"hi\").dir_path(), \".\");\n         t!(s: Path::new(\"/hi\").dir_path(), \"/\");\n@@ -1107,9 +1107,9 @@ mod tests {\n         t!(s: \"/a/b/c\", \"d/e/f\", false);\n         t!(s: \"a/b/c\", \"a/b\", false);\n         t!(s: \"a/b/c\", \"b\", false);\n-        t!(v: b\"a/b/c\", b\"b/c\", true);\n-        t!(v: b\"a/b/\\xFF\", b\"\\xFF\", true);\n-        t!(v: b\"a/b/\\xFF\", b\"b/\\xFF\", true);\n+        t!(v: &b\"a/b/c\"[..], &b\"b/c\"[..], true);\n+        t!(v: &b\"a/b/\\xFF\"[..], &b\"\\xFF\"[..], true);\n+        t!(v: &b\"a/b/\\xFF\"[..], &b\"b/\\xFF\"[..], true);\n     }\n \n     #[test]\n@@ -1185,9 +1185,9 @@ mod tests {\n             )\n         }\n \n-        t!(b: b\"a/b/c\", [b\"a\", b\"b\", b\"c\"]);\n-        t!(b: b\"/\\xFF/a/\\x80\", [b\"\\xFF\", b\"a\", b\"\\x80\"]);\n-        t!(b: b\"../../foo\\xCDbar\", [b\"..\", b\"..\", b\"foo\\xCDbar\"]);\n+        t!(b: &b\"a/b/c\"[..], [b\"a\", b\"b\", b\"c\"]);\n+        t!(b: &b\"/\\xFF/a/\\x80\"[..], [b\"\\xFF\", b\"a\", b\"\\x80\"]);\n+        t!(b: &b\"../../foo\\xCDbar\"[..], [b\"..\", b\"..\", b\"foo\\xCDbar\"]);\n         t!(s: \"a/b/c\", [\"a\", \"b\", \"c\"]);\n         t!(s: \"a/b/d\", [\"a\", \"b\", \"d\"]);\n         t!(s: \"a/b/cd\", [\"a\", \"b\", \"cd\"]);\n@@ -1217,9 +1217,9 @@ mod tests {\n             )\n         }\n \n-        t!(b: b\"a/b/c\", [Some(\"a\"), Some(\"b\"), Some(\"c\")]);\n-        t!(b: b\"/\\xFF/a/\\x80\", [None, Some(\"a\"), None]);\n-        t!(b: b\"../../foo\\xCDbar\", [Some(\"..\"), Some(\"..\"), None]);\n+        t!(b: &b\"a/b/c\"[..], [Some(\"a\"), Some(\"b\"), Some(\"c\")]);\n+        t!(b: &b\"/\\xFF/a/\\x80\"[..], [None, Some(\"a\"), None]);\n+        t!(b: &b\"../../foo\\xCDbar\"[..], [Some(\"..\"), Some(\"..\"), None]);\n         // str_components is a wrapper around components, so no need to do\n         // the full set of tests\n     }"}, {"sha": "6c5311d859c2d2d2f031494f34a03b03b2190450", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -1217,8 +1217,8 @@ mod tests {\n     fn test_paths() {\n         let empty: &[u8] = &[];\n         t!(v: Path::new(empty), b\".\");\n-        t!(v: Path::new(b\"\\\\\"), b\"\\\\\");\n-        t!(v: Path::new(b\"a\\\\b\\\\c\"), b\"a\\\\b\\\\c\");\n+        t!(v: Path::new(&b\"\\\\\"[..]), b\"\\\\\");\n+        t!(v: Path::new(&b\"a\\\\b\\\\c\"[..]), b\"a\\\\b\\\\c\");\n \n         t!(s: Path::new(\"\"), \".\");\n         t!(s: Path::new(\"\\\\\"), \"\\\\\");\n@@ -1250,8 +1250,8 @@ mod tests {\n         t!(s: Path::new(\"foo\\\\..\\\\..\\\\..\"), \"..\\\\..\");\n         t!(s: Path::new(\"foo\\\\..\\\\..\\\\bar\"), \"..\\\\bar\");\n \n-        assert_eq!(Path::new(b\"foo\\\\bar\").into_vec(), b\"foo\\\\bar\");\n-        assert_eq!(Path::new(b\"\\\\foo\\\\..\\\\..\\\\bar\").into_vec(), b\"\\\\bar\");\n+        assert_eq!(Path::new(&b\"foo\\\\bar\"[..]).into_vec(), b\"foo\\\\bar\");\n+        assert_eq!(Path::new(&b\"\\\\foo\\\\..\\\\..\\\\bar\"[..]).into_vec(), b\"\\\\bar\");\n \n         t!(s: Path::new(\"\\\\\\\\a\"), \"\\\\a\");\n         t!(s: Path::new(\"\\\\\\\\a\\\\\"), \"\\\\a\");\n@@ -1304,9 +1304,9 @@ mod tests {\n \n     #[test]\n     fn test_opt_paths() {\n-        assert!(Path::new_opt(b\"foo\\\\bar\\0\") == None);\n-        assert!(Path::new_opt(b\"foo\\\\bar\\x80\") == None);\n-        t!(v: Path::new_opt(b\"foo\\\\bar\").unwrap(), b\"foo\\\\bar\");\n+        assert!(Path::new_opt(&b\"foo\\\\bar\\0\"[..]) == None);\n+        assert!(Path::new_opt(&b\"foo\\\\bar\\x80\"[..]) == None);\n+        t!(v: Path::new_opt(&b\"foo\\\\bar\"[..]).unwrap(), b\"foo\\\\bar\");\n         assert!(Path::new_opt(\"foo\\\\bar\\0\") == None);\n         t!(s: Path::new_opt(\"foo\\\\bar\").unwrap(), \"foo\\\\bar\");\n     }\n@@ -1315,38 +1315,38 @@ mod tests {\n     fn test_null_byte() {\n         use thread;\n         let result = thread::spawn(move|| {\n-            Path::new(b\"foo/bar\\0\");\n+            Path::new(&b\"foo/bar\\0\"[..]);\n         }).join();\n         assert!(result.is_err());\n \n         let result = thread::spawn(move|| {\n-            Path::new(\"test\").set_filename(b\"f\\0o\")\n+            Path::new(\"test\").set_filename(&b\"f\\0o\"[..])\n         }).join();\n         assert!(result.is_err());\n \n         let result = thread::spawn(move || {\n-            Path::new(\"test\").push(b\"f\\0o\");\n+            Path::new(\"test\").push(&b\"f\\0o\"[..]);\n         }).join();\n         assert!(result.is_err());\n     }\n \n     #[test]\n     #[should_panic]\n     fn test_not_utf8_panics() {\n-        Path::new(b\"hello\\x80.txt\");\n+        Path::new(&b\"hello\\x80.txt\"[..]);\n     }\n \n     #[test]\n     fn test_display_str() {\n         let path = Path::new(\"foo\");\n         assert_eq!(path.display().to_string(), \"foo\");\n-        let path = Path::new(b\"\\\\\");\n+        let path = Path::new(&b\"\\\\\"[..]);\n         assert_eq!(path.filename_display().to_string(), \"\");\n \n         let path = Path::new(\"foo\");\n         let mo = path.display().as_cow();\n         assert_eq!(mo, \"foo\");\n-        let path = Path::new(b\"\\\\\");\n+        let path = Path::new(&b\"\\\\\"[..]);\n         let mo = path.filename_display().as_cow();\n         assert_eq!(mo, \"\");\n     }\n@@ -1397,7 +1397,7 @@ mod tests {\n             )\n         }\n \n-        t!(v: b\"a\\\\b\\\\c\", filename, Some(b\"c\"));\n+        t!(v: &b\"a\\\\b\\\\c\"[..], filename, Some(&b\"c\"[..]));\n         t!(s: \"a\\\\b\\\\c\", filename_str, \"c\");\n         t!(s: \"\\\\a\\\\b\\\\c\", filename_str, \"c\");\n         t!(s: \"a\", filename_str, \"a\");\n@@ -1430,7 +1430,7 @@ mod tests {\n         t!(s: \"\\\\\\\\.\\\\\", filename_str, None, opt);\n         t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", filename_str, \"b\");\n \n-        t!(v: b\"a\\\\b\\\\c\", dirname, b\"a\\\\b\");\n+        t!(v: &b\"a\\\\b\\\\c\"[..], dirname, b\"a\\\\b\");\n         t!(s: \"a\\\\b\\\\c\", dirname_str, \"a\\\\b\");\n         t!(s: \"\\\\a\\\\b\\\\c\", dirname_str, \"\\\\a\\\\b\");\n         t!(s: \"a\", dirname_str, \".\");\n@@ -1461,7 +1461,7 @@ mod tests {\n         t!(s: \"\\\\\\\\.\\\\foo\", dirname_str, \"\\\\\\\\.\\\\foo\");\n         t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", dirname_str, \"\\\\\\\\?\\\\a\");\n \n-        t!(v: b\"hi\\\\there.txt\", filestem, Some(b\"there\"));\n+        t!(v: &b\"hi\\\\there.txt\"[..], filestem, Some(&b\"there\"[..]));\n         t!(s: \"hi\\\\there.txt\", filestem_str, \"there\");\n         t!(s: \"hi\\\\there\", filestem_str, \"there\");\n         t!(s: \"there.txt\", filestem_str, \"there\");\n@@ -1476,8 +1476,8 @@ mod tests {\n         t!(s: \"..\\\\..\", filestem_str, None, opt);\n         // filestem is based on filename, so we don't need the full set of prefix tests\n \n-        t!(v: b\"hi\\\\there.txt\", extension, Some(b\"txt\"));\n-        t!(v: b\"hi\\\\there\", extension, None);\n+        t!(v: &b\"hi\\\\there.txt\"[..], extension, Some(&b\"txt\"[..]));\n+        t!(v: &b\"hi\\\\there\"[..], extension, None);\n         t!(s: \"hi\\\\there.txt\", extension_str, Some(\"txt\"), opt);\n         t!(s: \"hi\\\\there\", extension_str, None, opt);\n         t!(s: \"there.txt\", extension_str, Some(\"txt\"), opt);\n@@ -1603,9 +1603,9 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\"], \"\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\".to_string(), \"e\".to_string()], \"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(v: b\"a\\\\b\\\\c\", [b\"d\", b\"e\"], b\"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(v: b\"a\\\\b\\\\c\", [b\"d\", b\"\\\\e\", b\"f\"], b\"\\\\e\\\\f\");\n-        t!(v: b\"a\\\\b\\\\c\", [b\"d\".to_vec(), b\"e\".to_vec()],\n+        t!(v: &b\"a\\\\b\\\\c\"[..], [&b\"d\"[..], &b\"e\"[..]], b\"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(v: &b\"a\\\\b\\\\c\"[..], [&b\"d\"[..], &b\"\\\\e\"[..], &b\"f\"[..]], b\"\\\\e\\\\f\");\n+        t!(v: &b\"a\\\\b\\\\c\"[..], [b\"d\".to_vec(), b\"e\".to_vec()],\n            b\"a\\\\b\\\\c\\\\d\\\\e\");\n     }\n \n@@ -1637,11 +1637,11 @@ mod tests {\n         t!(s: \".\", \".\", false);\n         t!(s: \"\\\\a\", \"\\\\\", true);\n         t!(s: \"\\\\\", \"\\\\\", false);\n-        t!(b: b\"a\\\\b\\\\c\", b\"a\\\\b\", true);\n-        t!(b: b\"a\", b\".\", true);\n-        t!(b: b\".\", b\".\", false);\n-        t!(b: b\"\\\\a\", b\"\\\\\", true);\n-        t!(b: b\"\\\\\", b\"\\\\\", false);\n+        t!(b: &b\"a\\\\b\\\\c\"[..], b\"a\\\\b\", true);\n+        t!(b: &b\"a\"[..], b\".\", true);\n+        t!(b: &b\".\"[..], b\".\", false);\n+        t!(b: &b\"\\\\a\"[..], b\"\\\\\", true);\n+        t!(b: &b\"\\\\\"[..], b\"\\\\\", false);\n \n         t!(s: \"C:\\\\a\\\\b\", \"C:\\\\a\", true);\n         t!(s: \"C:\\\\a\", \"C:\\\\\", true);\n@@ -1690,8 +1690,8 @@ mod tests {\n         t!(s: Path::new(\"a\\\\b\").join(\"\\\\c\\\\d\"), \"\\\\c\\\\d\");\n         t!(s: Path::new(\".\").join(\"a\\\\b\"), \"a\\\\b\");\n         t!(s: Path::new(\"\\\\\").join(\"a\\\\b\"), \"\\\\a\\\\b\");\n-        t!(v: Path::new(b\"a\\\\b\\\\c\").join(b\"..\"), b\"a\\\\b\");\n-        t!(v: Path::new(b\"\\\\a\\\\b\\\\c\").join(b\"d\"), b\"\\\\a\\\\b\\\\c\\\\d\");\n+        t!(v: Path::new(&b\"a\\\\b\\\\c\"[..]).join(&b\"..\"[..]), b\"a\\\\b\");\n+        t!(v: Path::new(&b\"\\\\a\\\\b\\\\c\"[..]).join(&b\"d\"[..]), b\"\\\\a\\\\b\\\\c\\\\d\");\n         // full join testing is covered under test_push_path, so no need for\n         // the full set of prefix tests\n     }\n@@ -1742,8 +1742,8 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"..\", \"d\"], \"a\\\\b\\\\d\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\".to_string(), \"e\".to_string()], \"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(v: b\"a\\\\b\\\\c\", [b\"d\", b\"e\"], b\"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(v: b\"a\\\\b\\\\c\", [b\"d\".to_vec(), b\"e\".to_vec()],\n+        t!(v: &b\"a\\\\b\\\\c\"[..], [&b\"d\"[..], &b\"e\"[..]], b\"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(v: &b\"a\\\\b\\\\c\"[..], [b\"d\".to_vec(), b\"e\".to_vec()],\n            b\"a\\\\b\\\\c\\\\d\\\\e\");\n     }\n \n@@ -1855,15 +1855,15 @@ mod tests {\n             )\n         }\n \n-        t!(v: b\"a\\\\b\\\\c\", set_filename, with_filename, b\"d\");\n-        t!(v: b\"\\\\\", set_filename, with_filename, b\"foo\");\n+        t!(v: &b\"a\\\\b\\\\c\"[..], set_filename, with_filename, &b\"d\"[..]);\n+        t!(v: &b\"\\\\\"[..], set_filename, with_filename, &b\"foo\"[..]);\n         t!(s: \"a\\\\b\\\\c\", set_filename, with_filename, \"d\");\n         t!(s: \"\\\\\", set_filename, with_filename, \"foo\");\n         t!(s: \".\", set_filename, with_filename, \"foo\");\n         t!(s: \"a\\\\b\", set_filename, with_filename, \"\");\n         t!(s: \"a\", set_filename, with_filename, \"\");\n \n-        t!(v: b\"hi\\\\there.txt\", set_extension, with_extension, b\"exe\");\n+        t!(v: &b\"hi\\\\there.txt\"[..], set_extension, with_extension, &b\"exe\"[..]);\n         t!(s: \"hi\\\\there.txt\", set_extension, with_extension, \"exe\");\n         t!(s: \"hi\\\\there.\", set_extension, with_extension, \"txt\");\n         t!(s: \"hi\\\\there\", set_extension, with_extension, \"txt\");\n@@ -1898,7 +1898,7 @@ mod tests {\n             )\n         }\n \n-        t!(v: Path::new(b\"a\\\\b\\\\c\"), Some(b\"c\"), b\"a\\\\b\", Some(b\"c\"), None);\n+        t!(v: Path::new(&b\"a\\\\b\\\\c\"[..]), Some(&b\"c\"[..]), b\"a\\\\b\", Some(&b\"c\"[..]), None);\n         t!(s: Path::new(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n         t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n         t!(s: Path::new(\"\\\\\"), None, Some(\"\\\\\"), None, None);\n@@ -2240,7 +2240,7 @@ mod tests {\n             );\n         }\n \n-        t!(s: b\"a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n+        t!(s: &b\"a\\\\b\\\\c\"[..], [\"a\", \"b\", \"c\"]);\n         t!(s: \"a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n         t!(s: \"a\\\\b\\\\d\", [\"a\", \"b\", \"d\"]);\n         t!(s: \"a\\\\b\\\\cd\", [\"a\", \"b\", \"cd\"]);"}, {"sha": "fbe2a65bc893719e4fec693f056314704ed1aec4", "filename": "src/test/run-pass/byte-literals.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Ftest%2Frun-pass%2Fbyte-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Ftest%2Frun-pass%2Fbyte-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbyte-literals.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -13,9 +13,13 @@\n \n static FOO: u8 = b'\\xF0';\n static BAR: &'static [u8] = b\"a\\xF0\\t\";\n+static BAR_FIXED: &'static [u8; 3] = b\"a\\xF0\\t\";\n static BAZ: &'static [u8] = br\"a\\n\";\n \n pub fn main() {\n+    let bar: &'static [u8] = b\"a\\xF0\\t\";\n+    let bar_fixed: &'static [u8; 3] = b\"a\\xF0\\t\";\n+\n     assert_eq!(b'a', 97u8);\n     assert_eq!(b'\\n', 10u8);\n     assert_eq!(b'\\r', 13u8);\n@@ -44,18 +48,21 @@ pub fn main() {\n                  b\", expected);\n     let expected: &[_] = &[97u8, 240u8, 9u8];\n     assert_eq!(BAR, expected);\n+    assert_eq!(BAR_FIXED, expected);\n+    assert_eq!(bar, expected);\n+    assert_eq!(bar_fixed, expected);\n \n-    let val: &[_] = &[97u8, 10u8];\n+    let val = &[97u8, 10u8];\n     match val {\n         b\"a\\n\" => {},\n         _ => panic!(),\n     }\n \n     let buf = vec!(97u8, 98, 99, 100);\n     assert_eq!(match &buf[0..3] {\n-         b\"def\" => 1_usize,\n-         b\"abc\" => 2_usize,\n-         _ => 3_usize\n+         b\"def\" => 1,\n+         b\"abc\" => 2,\n+         _ => 3\n     }, 2);\n \n     let expected: &[_] = &[97u8, 92u8, 110u8];"}, {"sha": "9623613b5555a6bc4b5d9a907afa31b49c38f380", "filename": "src/test/run-pass/issue-17233.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Ftest%2Frun-pass%2Fissue-17233.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Ftest%2Frun-pass%2Fissue-17233.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17233.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const X1: &'static [u8] = &[b'1'];\n+const X2: &'static [u8] = b\"1\";\n+const X3: &'static [u8; 1] = &[b'1'];\n+const X4: &'static [u8; 1] = b\"1\";\n+\n+static Y1: u8 = X1[0];\n+static Y2: u8 = X2[0];\n+static Y3: u8 = X3[0];\n+static Y4: u8 = X4[0];\n+\n+fn main() {\n+    assert_eq!(Y1, Y2);\n+    assert_eq!(Y1, Y3);\n+    assert_eq!(Y1, Y4);\n+}"}, {"sha": "e0810d395558ef38bd686e7bb692c455018e5494", "filename": "src/test/run-pass/rename-directory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Ftest%2Frun-pass%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Ftest%2Frun-pass%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frename-directory.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -32,11 +32,11 @@ fn rename_directory() {\n \n         /* Write the temp input file */\n         let fromp = CString::new(test_file.as_vec()).unwrap();\n-        let modebuf = CString::new(b\"w+b\").unwrap();\n+        let modebuf = CString::new(&b\"w+b\"[..]).unwrap();\n         let ostream = libc::fopen(fromp.as_ptr(), modebuf.as_ptr());\n         assert!((ostream as uint != 0));\n         let s = \"hello\".to_string();\n-        let buf = CString::new(b\"hello\").unwrap();\n+        let buf = CString::new(&b\"hello\"[..]).unwrap();\n         let write_len = libc::fwrite(buf.as_ptr() as *mut _,\n                                      1_usize as libc::size_t,\n                                      (s.len() + 1_usize) as libc::size_t,"}, {"sha": "60d617822cd7fd1ee6207b33df1e2b0aaf1d398e", "filename": "src/test/run-pass/variadic-ffi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f649c479ce40f3b4590590dda6c2895e8d60f6/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs?ref=46f649c479ce40f3b4590590dda6c2895e8d60f6", "patch": "@@ -28,11 +28,11 @@ pub fn main() {\n \n     unsafe {\n         // Call with just the named parameter\n-        let c = CString::new(b\"Hello World\\n\").unwrap();\n+        let c = CString::new(&b\"Hello World\\n\"[..]).unwrap();\n         check(\"Hello World\\n\", |s| sprintf(s, c.as_ptr()));\n \n         // Call with variable number of arguments\n-        let c = CString::new(b\"%d %f %c %s\\n\").unwrap();\n+        let c = CString::new(&b\"%d %f %c %s\\n\"[..]).unwrap();\n         check(\"42 42.500000 a %d %f %c %s\\n\\n\", |s| {\n             sprintf(s, c.as_ptr(), 42, 42.5f64, 'a' as c_int, c.as_ptr());\n         });\n@@ -43,11 +43,11 @@ pub fn main() {\n         // A function that takes a function pointer\n         unsafe fn call(p: unsafe extern fn(*mut c_char, *const c_char, ...) -> c_int) {\n             // Call with just the named parameter\n-            let c = CString::new(b\"Hello World\\n\").unwrap();\n+            let c = CString::new(&b\"Hello World\\n\"[..]).unwrap();\n             check(\"Hello World\\n\", |s| sprintf(s, c.as_ptr()));\n \n             // Call with variable number of arguments\n-            let c = CString::new(b\"%d %f %c %s\\n\").unwrap();\n+            let c = CString::new(&b\"%d %f %c %s\\n\"[..]).unwrap();\n             check(\"42 42.500000 a %d %f %c %s\\n\\n\", |s| {\n                 sprintf(s, c.as_ptr(), 42, 42.5f64, 'a' as c_int, c.as_ptr());\n             });"}]}