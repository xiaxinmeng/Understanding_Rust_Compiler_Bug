{"sha": "2291abf313b1c619a34694e1756ddaf2a5cb34d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyOTFhYmYzMTNiMWM2MTlhMzQ2OTRlMTc1NmRkYWYyYTVjYjM0ZDk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-16T09:57:03Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-25T18:07:19Z"}, "message": "refactor item-paths in diagnostics, symbol names\n\nThis change has a few parts. We introduce a new `item_path` module for\nconstructing item paths. The job of this module is basically to make\nnice, user-readable paths -- but these paths are not necessarily 100%\nunique. They meant to help a *human* find code, but not necessarily a\ncompute. These paths are used to drive `item_path_str` but also symbol\nnames.\n\nBecause the paths are not unique, we also modify the symbol name hash to\ninclude the full `DefPath`, whereas before it included only those\naspects of the def-path that were not included in the \"informative\"\nsymbol name.\n\nEventually, I'd like to make the item-path infrastructure a bit more\ndeclarative.  Right now it's based purely on strings. In particular, for\nimpls, we should supply the raw types to the `ItemPathBuffer`, so that\nsymbol names can be encoded using the C++ encoding scheme for better\nintegration with tooling.", "tree": {"sha": "9705c3b38095d9691865a32dbcacd1464f6b8d80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9705c3b38095d9691865a32dbcacd1464f6b8d80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2291abf313b1c619a34694e1756ddaf2a5cb34d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2291abf313b1c619a34694e1756ddaf2a5cb34d9", "html_url": "https://github.com/rust-lang/rust/commit/2291abf313b1c619a34694e1756ddaf2a5cb34d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2291abf313b1c619a34694e1756ddaf2a5cb34d9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd5cf09635c41e3f9b6df79a50c1fb24ee855153", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd5cf09635c41e3f9b6df79a50c1fb24ee855153", "html_url": "https://github.com/rust-lang/rust/commit/cd5cf09635c41e3f9b6df79a50c1fb24ee855153"}], "stats": {"total": 388, "additions": 362, "deletions": 26}, "files": [{"sha": "147230f5bdcd0ac0bc0ee15086027c2504ed6af1", "filename": "src/librustc/middle/ty/item_path.rs", "status": "added", "additions": 317, "deletions": 0, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/2291abf313b1c619a34694e1756ddaf2a5cb34d9/src%2Flibrustc%2Fmiddle%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2291abf313b1c619a34694e1756ddaf2a5cb34d9/src%2Flibrustc%2Fmiddle%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fitem_path.rs?ref=2291abf313b1c619a34694e1756ddaf2a5cb34d9", "patch": "@@ -0,0 +1,317 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use front::map::DefPathData;\n+use middle::cstore::LOCAL_CRATE;\n+use middle::def_id::DefId;\n+use middle::ty::{self, Ty, TyCtxt};\n+use syntax::ast;\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    /// Returns a string identifying this def-id. This string is\n+    /// suitable for user output. It is relative to the current crate\n+    /// root.\n+    pub fn item_path_str(&self, def_id: DefId) -> String {\n+        let mut buffer = LocalPathBuffer::new(RootMode::Local);\n+        self.push_item_path(&mut buffer, def_id);\n+        buffer.into_string()\n+    }\n+\n+    /// Returns a string identifying this def-id. This string is\n+    /// suitable for user output. It always begins with a crate identifier.\n+    pub fn absolute_item_path_str(&self, def_id: DefId) -> String {\n+        let mut buffer = LocalPathBuffer::new(RootMode::Absolute);\n+        self.push_item_path(&mut buffer, def_id);\n+        buffer.into_string()\n+    }\n+\n+    /// Returns the \"path\" to a particular crate. This can proceed in\n+    /// various ways, depending on the `root_mode` of the `buffer`.\n+    /// (See `RootMode` enum for more details.)\n+    pub fn push_krate_path<T>(&self, buffer: &mut T, cnum: ast::CrateNum)\n+        where T: ItemPathBuffer\n+    {\n+        match *buffer.root_mode() {\n+            RootMode::Local => {\n+                // In local mode, when we encounter a crate other than\n+                // LOCAL_CRATE, execution proceeds in one of two ways:\n+                //\n+                // 1. for a direct dependency, where user added an\n+                //    `extern crate` manually, we put the `extern\n+                //    crate` as the parent. So you wind up with\n+                //    something relative to the current crate.\n+                // 2. for an indirect crate, where there is no extern\n+                //    crate, we just prepend the crate name.\n+                //\n+                // Returns `None` for the local crate.\n+                if cnum != LOCAL_CRATE {\n+                    let opt_extern_crate = self.sess.cstore.extern_crate(cnum);\n+                    let opt_extern_crate = opt_extern_crate.and_then(|extern_crate| {\n+                        if extern_crate.direct {\n+                            Some(extern_crate.def_id)\n+                        } else {\n+                            None\n+                        }\n+                    });\n+                    if let Some(extern_crate_def_id) = opt_extern_crate {\n+                        self.push_item_path(buffer, extern_crate_def_id);\n+                    } else {\n+                        buffer.push(&self.crate_name(cnum));\n+                    }\n+                }\n+            }\n+            RootMode::Absolute => {\n+                // In absolute mode, just write the crate name\n+                // unconditionally.\n+                buffer.push(&self.crate_name(cnum));\n+            }\n+        }\n+    }\n+\n+    pub fn push_item_path<T>(&self, buffer: &mut T, def_id: DefId)\n+        where T: ItemPathBuffer\n+    {\n+        let key = self.def_key(def_id);\n+        match key.disambiguated_data.data {\n+            DefPathData::CrateRoot => {\n+                assert!(key.parent.is_none());\n+                self.push_krate_path(buffer, def_id.krate);\n+            }\n+\n+            DefPathData::InlinedRoot(ref root_path) => {\n+                assert!(key.parent.is_none());\n+                self.push_item_path(buffer, root_path.def_id);\n+            }\n+\n+            DefPathData::Impl => {\n+                self.push_impl_path(buffer, def_id);\n+            }\n+\n+            // Unclear if there is any value in distinguishing these.\n+            // Probably eventually (and maybe we would even want\n+            // finer-grained distinctions, e.g. between enum/struct).\n+            data @ DefPathData::Misc |\n+            data @ DefPathData::TypeNs(..) |\n+            data @ DefPathData::ValueNs(..) |\n+            data @ DefPathData::TypeParam(..) |\n+            data @ DefPathData::LifetimeDef(..) |\n+            data @ DefPathData::EnumVariant(..) |\n+            data @ DefPathData::Field(..) |\n+            data @ DefPathData::StructCtor |\n+            data @ DefPathData::Initializer |\n+            data @ DefPathData::MacroDef(..) |\n+            data @ DefPathData::ClosureExpr |\n+            data @ DefPathData::Binding(..) => {\n+                let parent_def_id = self.parent_def_id(def_id).unwrap();\n+                self.push_item_path(buffer, parent_def_id);\n+                buffer.push(&data.as_interned_str());\n+            }\n+        }\n+    }\n+\n+    fn push_impl_path<T>(&self,\n+                         buffer: &mut T,\n+                         impl_def_id: DefId)\n+        where T: ItemPathBuffer\n+    {\n+        let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n+\n+        let use_types = if !impl_def_id.is_local() {\n+            // always have full types available for extern crates\n+            true\n+        } else {\n+            // for local crates, check whether type info is\n+            // available; typeck might not have completed yet\n+            self.impl_trait_refs.borrow().contains_key(&impl_def_id)\n+        };\n+\n+        if !use_types {\n+            return self.push_impl_path_fallback(buffer, impl_def_id);\n+        }\n+\n+        // Decide whether to print the parent path for the impl.\n+        // Logically, since impls are global, it's never needed, but\n+        // users may find it useful. Currently, we omit the parent if\n+        // the impl is either in the same module as the self-type or\n+        // as the trait.\n+        let self_ty = self.lookup_item_type(impl_def_id).ty;\n+        let in_self_mod = match self.characteristic_def_id_of_type(self_ty) {\n+            None => false,\n+            Some(ty_def_id) => self.parent_def_id(ty_def_id) == Some(parent_def_id),\n+        };\n+\n+        let impl_trait_ref = self.impl_trait_ref(impl_def_id);\n+        let in_trait_mod = match impl_trait_ref {\n+            None => false,\n+            Some(trait_ref) => self.parent_def_id(trait_ref.def_id) == Some(parent_def_id),\n+        };\n+\n+        if !in_self_mod && !in_trait_mod {\n+            // If the impl is not co-located with either self-type or\n+            // trait-type, then fallback to a format that identifies\n+            // the module more clearly.\n+            self.push_item_path(buffer, parent_def_id);\n+            if let Some(trait_ref) = impl_trait_ref {\n+                buffer.push(&format!(\"<impl {} for {}>\", trait_ref, self_ty));\n+            } else {\n+                buffer.push(&format!(\"<impl {}>\", self_ty));\n+            }\n+            return;\n+        }\n+\n+        // Otherwise, try to give a good form that would be valid language\n+        // syntax. Preferably using associated item notation.\n+\n+        if let Some(trait_ref) = impl_trait_ref {\n+            // Trait impls.\n+            buffer.push(&format!(\"<{} as {}>\",\n+                                 self_ty,\n+                                 trait_ref));\n+            return;\n+        }\n+\n+        // Inherent impls. Try to print `Foo::bar` for an inherent\n+        // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n+        // anything other than a simple path.\n+        match self_ty.sty {\n+            ty::TyStruct(adt_def, substs) |\n+            ty::TyEnum(adt_def, substs) => {\n+                if substs.types.is_empty() { // ignore regions\n+                    self.push_item_path(buffer, adt_def.did);\n+                } else {\n+                    buffer.push(&format!(\"<{}>\", self_ty));\n+                }\n+            }\n+\n+            ty::TyBool |\n+            ty::TyChar |\n+            ty::TyInt(_) |\n+            ty::TyUint(_) |\n+            ty::TyFloat(_) |\n+            ty::TyStr => {\n+                buffer.push(&format!(\"{}\", self_ty));\n+            }\n+\n+            _ => {\n+                buffer.push(&format!(\"<{}>\", self_ty));\n+            }\n+        }\n+    }\n+\n+    fn push_impl_path_fallback<T>(&self,\n+                                  buffer: &mut T,\n+                                  impl_def_id: DefId)\n+        where T: ItemPathBuffer\n+    {\n+        // If no type info is available, fall back to\n+        // pretty printing some span information. This should\n+        // only occur very early in the compiler pipeline.\n+        let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n+        self.push_item_path(buffer, parent_def_id);\n+        let node_id = self.map.as_local_node_id(impl_def_id).unwrap();\n+        let item = self.map.expect_item(node_id);\n+        let span_str = self.sess.codemap().span_to_string(item.span);\n+        buffer.push(&format!(\"<impl at {}>\", span_str));\n+    }\n+\n+    /// As a heuristic, when we see an impl, if we see that the\n+    /// 'self-type' is a type defined in the same module as the impl,\n+    /// we can omit including the path to the impl itself. This\n+    /// function tries to find a \"characteristic def-id\" for a\n+    /// type. It's just a heuristic so it makes some questionable\n+    /// decisions and we may want to adjust it later.\n+    fn characteristic_def_id_of_type(&self, ty: Ty<'tcx>) -> Option<DefId> {\n+        match ty.sty {\n+            ty::TyStruct(adt_def, _) |\n+            ty::TyEnum(adt_def, _) =>\n+                Some(adt_def.did),\n+\n+            ty::TyTrait(ref data) =>\n+                Some(data.principal_def_id()),\n+\n+            ty::TyBox(subty) =>\n+                self.characteristic_def_id_of_type(subty),\n+\n+            ty::TyRawPtr(mt) |\n+            ty::TyRef(_, mt) =>\n+                self.characteristic_def_id_of_type(mt.ty),\n+\n+            ty::TyTuple(ref tys) =>\n+                tys.iter()\n+                   .filter_map(|ty| self.characteristic_def_id_of_type(ty))\n+                   .next(),\n+\n+            _ =>\n+                None\n+        }\n+    }\n+\n+    /// Returns the def-id of `def_id`'s parent in the def tree. If\n+    /// this returns `None`, then `def_id` represents a crate root or\n+    /// inlined root.\n+    fn parent_def_id(&self, def_id: DefId) -> Option<DefId> {\n+        let key = self.def_key(def_id);\n+        key.parent.map(|index| DefId { krate: def_id.krate, index: index })\n+    }\n+}\n+\n+/// Unifying Trait for different kinds of item paths we might\n+/// construct. The basic interface is that components get pushed: the\n+/// instance can also customize how we handle the root of a crate.\n+pub trait ItemPathBuffer {\n+    fn root_mode(&self) -> &RootMode;\n+    fn push(&mut self, text: &str);\n+}\n+\n+#[derive(Debug)]\n+pub enum RootMode {\n+    /// Try to make a path relative to the local crate.  In\n+    /// particular, local paths have no prefix, and if the path comes\n+    /// from an extern crate, start with the path to the `extern\n+    /// crate` declaration.\n+    Local,\n+\n+    /// Always prepend the crate name to the path, forming an absolute\n+    /// path from within a given set of crates.\n+    Absolute,\n+}\n+\n+#[derive(Debug)]\n+struct LocalPathBuffer {\n+    root_mode: RootMode,\n+    str: String,\n+}\n+\n+impl LocalPathBuffer {\n+    fn new(root_mode: RootMode) -> LocalPathBuffer {\n+        LocalPathBuffer {\n+            root_mode: root_mode,\n+            str: String::new()\n+        }\n+    }\n+\n+    fn into_string(self) -> String {\n+        self.str\n+    }\n+\n+}\n+\n+impl ItemPathBuffer for LocalPathBuffer {\n+    fn root_mode(&self) -> &RootMode {\n+        &self.root_mode\n+    }\n+\n+    fn push(&mut self, text: &str) {\n+        if !self.str.is_empty() {\n+            self.str.push_str(\"::\");\n+        }\n+        self.str.push_str(text);\n+    }\n+}"}, {"sha": "a4c3e82b6335db7472435cff21dda19edff0f1bd", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2291abf313b1c619a34694e1756ddaf2a5cb34d9/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2291abf313b1c619a34694e1756ddaf2a5cb34d9/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=2291abf313b1c619a34694e1756ddaf2a5cb34d9", "patch": "@@ -86,6 +86,7 @@ pub mod cast;\n pub mod error;\n pub mod fast_reject;\n pub mod fold;\n+pub mod item_path;\n pub mod _match;\n pub mod maps;\n pub mod outlives;\n@@ -2218,8 +2219,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.def_map.borrow().get(&tr.ref_id).expect(\"no def-map entry for trait\").def_id()\n     }\n \n-    pub fn item_path_str(&self, id: DefId) -> String {\n-        self.with_path(id, |path| ast_map::path_to_string(path))\n+    pub fn def_key(&self, id: DefId) -> ast_map::DefKey {\n+        if id.is_local() {\n+            self.map.def_key(id)\n+        } else {\n+            self.sess.cstore.def_key(id)\n+        }\n     }\n \n     /// Returns the `DefPath` of an item. Note that if `id` is not"}, {"sha": "81b00c3827f3c1c69f8cdfeb0fdd2815adfed6c1", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2291abf313b1c619a34694e1756ddaf2a5cb34d9/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2291abf313b1c619a34694e1756ddaf2a5cb34d9/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=2291abf313b1c619a34694e1756ddaf2a5cb34d9", "patch": "@@ -103,10 +103,10 @@ use util::sha2::{Digest, Sha256};\n use rustc::middle::cstore;\n use rustc::middle::def_id::DefId;\n use rustc::middle::ty::{self, TypeFoldable};\n+use rustc::middle::ty::item_path::{ItemPathBuffer, RootMode};\n use rustc::front::map::definitions::DefPath;\n \n use std::fmt::Write;\n-use syntax::ast;\n use syntax::parse::token::{self, InternedString};\n use serialize::hex::ToHex;\n \n@@ -135,29 +135,23 @@ pub fn def_path_to_string<'tcx>(tcx: &ty::TyCtxt<'tcx>, def_path: &DefPath) -> S\n \n fn get_symbol_hash<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                              def_path: &DefPath,\n-                             originating_crate: ast::CrateNum,\n                              parameters: &[ty::Ty<'tcx>])\n                              -> String {\n+    debug!(\"get_symbol_hash(def_path={:?}, parameters={:?})\",\n+           def_path, parameters);\n+\n     let tcx = ccx.tcx();\n \n     let mut hash_state = ccx.symbol_hasher().borrow_mut();\n \n     hash_state.reset();\n \n-    if originating_crate == cstore::LOCAL_CRATE {\n-        hash_state.input_str(&tcx.sess.crate_disambiguator.borrow()[..]);\n-    } else {\n-        hash_state.input_str(&tcx.sess.cstore.crate_disambiguator(originating_crate));\n-    }\n-\n-    for component in def_path {\n-        let disambiguator_bytes = [(component.disambiguator >>  0) as u8,\n-                                   (component.disambiguator >>  8) as u8,\n-                                   (component.disambiguator >> 16) as u8,\n-                                   (component.disambiguator >> 24) as u8];\n-        hash_state.input(&disambiguator_bytes);\n-    }\n+    // the main symbol name is not necessarily unique; hash in the\n+    // compiler's internal def-path, guaranteeing each symbol has a\n+    // truly unique path\n+    hash_state.input_str(&def_path_to_string(tcx, def_path));\n \n+    // also include any type parameters (for generic items)\n     for t in parameters {\n        assert!(!t.has_erasable_regions());\n        assert!(!t.needs_subst());\n@@ -180,28 +174,44 @@ fn exported_name_with_opt_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                            -> String {\n     let &Instance { def: mut def_id, params: parameters } = instance;\n \n+    debug!(\"exported_name_with_opt_suffix(def_id={:?}, parameters={:?}, suffix={:?})\",\n+           def_id, parameters, suffix);\n+\n     if let Some(node_id) = ccx.tcx().map.as_local_node_id(def_id) {\n         if let Some(&src_def_id) = ccx.external_srcs().borrow().get(&node_id) {\n             def_id = src_def_id;\n         }\n     }\n \n     let def_path = ccx.tcx().def_path(def_id);\n-    let hash = get_symbol_hash(ccx, &def_path, def_id.krate, parameters.as_slice());\n+    assert_eq!(def_path.krate, def_id.krate);\n+    let hash = get_symbol_hash(ccx, &def_path, parameters.as_slice());\n \n-    let mut path = Vec::with_capacity(16);\n+    let mut buffer = SymbolPathBuffer {\n+        names: Vec::with_capacity(def_path.data.len())\n+    };\n+    ccx.tcx().push_item_path(&mut buffer, def_id);\n \n-    if def_id.is_local() {\n-        path.push(ccx.tcx().crate_name.clone());\n+    if let Some(suffix) = suffix {\n+        buffer.push(suffix);\n     }\n \n-    path.extend(def_path.into_iter().map(|e| e.data.as_interned_str()));\n+    mangle(buffer.names.into_iter(), Some(&hash[..]))\n+}\n \n-    if let Some(suffix) = suffix {\n-        path.push(token::intern_and_get_ident(suffix));\n+struct SymbolPathBuffer {\n+    names: Vec<InternedString>,\n+}\n+\n+impl ItemPathBuffer for SymbolPathBuffer {\n+    fn root_mode(&self) -> &RootMode {\n+        const ABSOLUTE: &'static RootMode = &RootMode::Absolute;\n+        ABSOLUTE\n     }\n \n-    mangle(path.into_iter(), Some(&hash[..]))\n+    fn push(&mut self, text: &str) {\n+        self.names.push(token::intern(text).as_str());\n+    }\n }\n \n pub fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -225,7 +235,11 @@ pub fn internal_name_from_type_and_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>\n                                                     -> String {\n     let path = [token::intern(&t.to_string()).as_str(),\n                 gensym_name(suffix).as_str()];\n-    let hash = get_symbol_hash(ccx, &Vec::new(), cstore::LOCAL_CRATE, &[t]);\n+    let def_path = DefPath {\n+        data: vec![],\n+        krate: cstore::LOCAL_CRATE,\n+    };\n+    let hash = get_symbol_hash(ccx, &def_path, &[t]);\n     mangle(path.iter().cloned(), Some(&hash[..]))\n }\n "}]}