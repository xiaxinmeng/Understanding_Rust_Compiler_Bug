{"sha": "67e516c5c2ddd0dbed6b07ccca6b5bdd4ad10b36", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3ZTUxNmM1YzJkZGQwZGJlZDZiMDdjY2NhNmI1YmRkNGFkMTBiMzY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-23T22:07:23Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-23T22:07:23Z"}, "message": "rollup merge of #23269: shepmaster/split-not-double-ended\n\nCloses #23262", "tree": {"sha": "7bb80b608956ad6ffb759f09fe2ef5cdcf4696e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bb80b608956ad6ffb759f09fe2ef5cdcf4696e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67e516c5c2ddd0dbed6b07ccca6b5bdd4ad10b36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67e516c5c2ddd0dbed6b07ccca6b5bdd4ad10b36", "html_url": "https://github.com/rust-lang/rust/commit/67e516c5c2ddd0dbed6b07ccca6b5bdd4ad10b36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67e516c5c2ddd0dbed6b07ccca6b5bdd4ad10b36/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec1a85a85c784a8481ea7f6d28453239db716829", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec1a85a85c784a8481ea7f6d28453239db716829", "html_url": "https://github.com/rust-lang/rust/commit/ec1a85a85c784a8481ea7f6d28453239db716829"}, {"sha": "c6ca2205eae522387237057812b7901a2c5d3906", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6ca2205eae522387237057812b7901a2c5d3906", "html_url": "https://github.com/rust-lang/rust/commit/c6ca2205eae522387237057812b7901a2c5d3906"}], "stats": {"total": 227, "additions": 188, "deletions": 39}, "files": [{"sha": "67b7039a1959eb568714a5674d13fedd726ba887", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/67e516c5c2ddd0dbed6b07ccca6b5bdd4ad10b36/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e516c5c2ddd0dbed6b07ccca6b5bdd4ad10b36/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=67e516c5c2ddd0dbed6b07ccca6b5bdd4ad10b36", "patch": "@@ -74,8 +74,8 @@ use slice::SliceConcatExt;\n \n pub use core::str::{FromStr, Utf8Error, Str};\n pub use core::str::{Lines, LinesAny, MatchIndices, SplitStr, CharRange};\n-pub use core::str::{Split, SplitTerminator};\n-pub use core::str::{SplitN, RSplitN};\n+pub use core::str::{Split, SplitTerminator, SplitN};\n+pub use core::str::{RSplit, RSplitN};\n pub use core::str::{from_utf8, CharEq, Chars, CharIndices, Bytes};\n pub use core::str::{from_utf8_unchecked, from_c_str, ParseBoolError};\n pub use unicode::str::{Words, Graphemes, GraphemeIndices};\n@@ -699,23 +699,48 @@ impl str {\n         core_str::StrExt::split_terminator(&self[..], pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters matched by a pattern,\n+    /// An iterator over substrings of `self`, separated by a pattern,\n     /// starting from the end of the string.\n     ///\n-    /// Restricted to splitting at most `count` times.\n+    /// # Examples\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplit(|c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rsplit(&self[..], pat)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by a pattern,\n+    /// starting from the end of the string, restricted to splitting\n+    /// at most `count` times.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n     /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(1, \"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n     /// ```\n     ///\n     /// More complex patterns with a lambda:\n@@ -725,7 +750,9 @@ impl str {\n     /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P> {\n+    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n         core_str::StrExt::rsplitn(&self[..], count, pat)\n     }\n "}, {"sha": "5cfa800905415dd855554be725c97731ac513448", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/67e516c5c2ddd0dbed6b07ccca6b5bdd4ad10b36/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e516c5c2ddd0dbed6b07ccca6b5bdd4ad10b36/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=67e516c5c2ddd0dbed6b07ccca6b5bdd4ad10b36", "patch": "@@ -910,6 +910,34 @@ fn test_split_char_iterator_no_trailing() {\n     assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n }\n \n+#[test]\n+fn test_rsplit() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.rsplit(' ').collect();\n+    assert_eq!(split, [\"l\u00e4mb\\n\", \"l\u00e4mb\\nLittle\", \"little\", \"\u00e4\", \"h\u00e4d\", \"\\nM\u00e4ry\"]);\n+\n+    let split: Vec<&str> = data.rsplit(\"l\u00e4mb\").collect();\n+    assert_eq!(split, [\"\\n\", \"\\nLittle \", \"\\nM\u00e4ry h\u00e4d \u00e4 little \"]);\n+\n+    let split: Vec<&str> = data.rsplit(|c: char| c == '\u00e4').collect();\n+    assert_eq!(split, [\"mb\\n\", \"mb\\nLittle l\", \" little l\", \"d \", \"ry h\", \"\\nM\"]);\n+}\n+\n+#[test]\n+fn test_rsplitn() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.rsplitn(1, ' ').collect();\n+    assert_eq!(split, [\"l\u00e4mb\\n\", \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle\"]);\n+\n+    let split: Vec<&str> = data.rsplitn(1, \"l\u00e4mb\").collect();\n+    assert_eq!(split, [\"\\n\", \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle \"]);\n+\n+    let split: Vec<&str> = data.rsplitn(1, |c: char| c == '\u00e4').collect();\n+    assert_eq!(split, [\"mb\\n\", \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\"]);\n+}\n+\n #[test]\n fn test_words() {\n     let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";"}, {"sha": "4734e9b7a9fe58d3e8bec8086943323ee30ecfe1", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 124, "deletions": 30, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/67e516c5c2ddd0dbed6b07ccca6b5bdd4ad10b36/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e516c5c2ddd0dbed6b07ccca6b5bdd4ad10b36/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=67e516c5c2ddd0dbed6b07ccca6b5bdd4ad10b36", "patch": "@@ -111,7 +111,24 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n-    }\n+    };\n+    (pattern reverse $te:ty : $ti:ty) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a, P: Pattern<'a>> Iterator for $ti\n+            where P::Searcher: ReverseSearcher<'a>\n+        {\n+            type Item = $te;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<$te> {\n+                self.0.next()\n+            }\n+            #[inline]\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n+                self.0.size_hint()\n+            }\n+        }\n+    };\n }\n \n /// A trait to abstract the idea of creating a new instance of a type from a\n@@ -550,7 +567,26 @@ struct CharSplitsN<'a, P: Pattern<'a>> {\n     iter: CharSplits<'a, P>,\n     /// The number of splits remaining\n     count: usize,\n-    invert: bool,\n+}\n+\n+/// An iterator over the substrings of a string, separated by a\n+/// pattern, in reverse order.\n+struct RCharSplits<'a, P: Pattern<'a>> {\n+    /// The slice remaining to be iterated\n+    start: usize,\n+    end: usize,\n+    matcher: P::Searcher,\n+    /// Whether an empty string at the end of iteration is allowed\n+    allow_final_empty: bool,\n+    finished: bool,\n+}\n+\n+/// An iterator over the substrings of a string, separated by a\n+/// pattern, splitting at most `count` times, in reverse order.\n+struct RCharSplitsN<'a, P: Pattern<'a>> {\n+    iter: RCharSplits<'a, P>,\n+    /// The number of splits remaining\n+    count: usize,\n }\n \n /// An iterator over the lines of a string, separated by `\\n`.\n@@ -631,21 +667,74 @@ where P::Searcher: DoubleEndedSearcher<'a> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> Iterator for CharSplitsN<'a, P>\n-where P::Searcher: DoubleEndedSearcher<'a> {\n+impl<'a, P: Pattern<'a>> Iterator for CharSplitsN<'a, P> {\n     type Item = &'a str;\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         if self.count != 0 {\n             self.count -= 1;\n-            if self.invert { self.iter.next_back() } else { self.iter.next() }\n+            self.iter.next()\n         } else {\n             self.iter.get_end()\n         }\n     }\n }\n \n+impl<'a, P: Pattern<'a>> RCharSplits<'a, P> {\n+    #[inline]\n+    fn get_remainder(&mut self) -> Option<&'a str> {\n+        if !self.finished && (self.allow_final_empty || self.end - self.start > 0) {\n+            self.finished = true;\n+            unsafe {\n+                let string = self.matcher.haystack().slice_unchecked(self.start, self.end);\n+                Some(string)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, P: Pattern<'a>> Iterator for RCharSplits<'a, P>\n+    where P::Searcher: ReverseSearcher<'a>\n+{\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        if self.finished { return None }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match_back() {\n+            Some((a, b)) => unsafe {\n+                let elt = haystack.slice_unchecked(b, self.end);\n+                self.end = a;\n+                Some(elt)\n+            },\n+            None => self.get_remainder(),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, P: Pattern<'a>> Iterator for RCharSplitsN<'a, P>\n+    where P::Searcher: ReverseSearcher<'a>\n+{\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        if self.count != 0 {\n+            self.count -= 1;\n+            self.iter.next()\n+        } else {\n+            self.iter.get_remainder()\n+        }\n+    }\n+}\n+\n /// The internal state of an iterator that searches for matches of a substring\n /// within a larger string using two-way search\n #[derive(Clone)]\n@@ -1293,23 +1382,7 @@ impl<'a, S: ?Sized> Str for &'a S where S: Str {\n /// Return type of `StrExt::split`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Split<'a, P: Pattern<'a>>(CharSplits<'a, P>);\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> Iterator for Split<'a, P> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        self.0.next()\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> DoubleEndedIterator for Split<'a, P>\n-where P::Searcher: DoubleEndedSearcher<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        self.0.next_back()\n-    }\n-}\n+delegate_iter!{pattern &'a str : Split<'a, P>}\n \n /// Return type of `StrExt::split_terminator`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1321,10 +1394,15 @@ delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}\n pub struct SplitN<'a, P: Pattern<'a>>(CharSplitsN<'a, P>);\n delegate_iter!{pattern forward &'a str : SplitN<'a, P>}\n \n+/// Return type of `StrExt::rsplit`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct RSplit<'a, P: Pattern<'a>>(RCharSplits<'a, P>);\n+delegate_iter!{pattern reverse &'a str : RSplit<'a, P>}\n+\n /// Return type of `StrExt::rsplitn`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RSplitN<'a, P: Pattern<'a>>(CharSplitsN<'a, P>);\n-delegate_iter!{pattern forward &'a str : RSplitN<'a, P>}\n+pub struct RSplitN<'a, P: Pattern<'a>>(RCharSplitsN<'a, P>);\n+delegate_iter!{pattern reverse &'a str : RSplitN<'a, P>}\n \n /// Methods for string slices\n #[allow(missing_docs)]\n@@ -1340,7 +1418,10 @@ pub trait StrExt {\n     fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P>;\n     fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;\n     fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n-    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>;\n+    fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>;\n+    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>;\n     fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P>;\n     #[allow(deprecated) /* for SplitStr */]\n     fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P>;\n@@ -1424,7 +1505,6 @@ impl StrExt for str {\n         SplitN(CharSplitsN {\n             iter: self.split(pat).0,\n             count: count,\n-            invert: false,\n         })\n     }\n \n@@ -1437,11 +1517,25 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P> {\n-        RSplitN(CharSplitsN {\n-            iter: self.split(pat).0,\n+    fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        RSplit(RCharSplits {\n+            start: 0,\n+            end: self.len(),\n+            matcher: pat.into_searcher(self),\n+            allow_final_empty: true,\n+            finished: false,\n+        })\n+    }\n+\n+    #[inline]\n+    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        RSplitN(RCharSplitsN {\n+            iter: self.rsplit(pat).0,\n             count: count,\n-            invert: true,\n         })\n     }\n "}]}