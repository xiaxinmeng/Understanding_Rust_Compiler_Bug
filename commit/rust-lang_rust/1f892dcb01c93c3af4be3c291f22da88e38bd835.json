{"sha": "1f892dcb01c93c3af4be3c291f22da88e38bd835", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmODkyZGNiMDFjOTNjM2FmNGJlM2MyOTFmMjJkYTg4ZTM4YmQ4MzU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-04-02T17:48:32Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-04-03T23:23:50Z"}, "message": "Monomorphize class constructors, support generic classes and class methods\n\nAllow class methods to have type parameters (this is a change from the\noriginal classes proposal).\n\nAdd test cases for classes with type parameters, and classes with methods\nthat have their own type parameters.", "tree": {"sha": "5dbc8c6cf968734e5fca3c718487c22d55e32b3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5dbc8c6cf968734e5fca3c718487c22d55e32b3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f892dcb01c93c3af4be3c291f22da88e38bd835", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f892dcb01c93c3af4be3c291f22da88e38bd835", "html_url": "https://github.com/rust-lang/rust/commit/1f892dcb01c93c3af4be3c291f22da88e38bd835", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f892dcb01c93c3af4be3c291f22da88e38bd835/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f4b7b10bb7557e47bf9e5a6119e205365f35419", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f4b7b10bb7557e47bf9e5a6119e205365f35419", "html_url": "https://github.com/rust-lang/rust/commit/4f4b7b10bb7557e47bf9e5a6119e205365f35419"}], "stats": {"total": 335, "additions": 217, "deletions": 118}, "files": [{"sha": "dfd682b9ae9a019e30836730b4112f2aec444a81", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=1f892dcb01c93c3af4be3c291f22da88e38bd835", "patch": "@@ -2062,11 +2062,24 @@ fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n                 attrs);\n }\n \n+// Instantiates ident <i> with references to <typarams> as arguments\n+fn ident_to_path_tys(p: parser, i: ast::ident,\n+                     typarams: [ast::ty_param]) -> @ast::path {\n+    let s = p.last_span;\n+    let p_: ast::path_ = {global: false, idents: [i],\n+          types: vec::map(typarams,\n+            {|tp| @{id: p.get_id(),\n+                   node: ast::ty_path(ident_to_path(s, tp.ident),\n+                                      p.get_id()),\n+                        span: s}})};\n+    @spanned(s.lo, s.hi, p_)\n+}\n+\n fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo;\n     let class_name = parse_value_ident(p);\n-    let class_path = ident_to_path(p.last_span, class_name);\n     let ty_params = parse_ty_params(p);\n+    let class_path = ident_to_path_tys(p, class_name, ty_params);\n     expect(p, token::LBRACE);\n     let mut ms: [@ast::class_member] = [];\n     let ctor_id = p.get_id();\n@@ -2104,15 +2117,16 @@ fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n enum class_contents { ctor_decl(ast::fn_decl, ast::blk, codemap::span),\n                       members([@ast::class_member]) }\n \n-fn parse_class_item(p:parser, class_name:@ast::path) -> class_contents {\n+fn parse_class_item(p:parser, class_name_with_tps:@ast::path)\n+    -> class_contents {\n     if eat_word(p, \"new\") {\n         let lo = p.last_span.lo;\n         // Can ctors have attrs?\n             // result type is always the type of the class\n         let decl_ = parse_fn_decl(p, ast::impure_fn);\n         let decl = {output: @{id: p.get_id(),\n-                              node: ast::ty_path(class_name, p.get_id()),\n-                              span: decl_.output.span}\n+                      node: ast::ty_path(class_name_with_tps, p.get_id()),\n+                      span: decl_.output.span}\n                     with decl_};\n         let body = parse_block(p);\n         ret ctor_decl(decl, body, ast_util::mk_sp(lo, p.last_span.hi));"}, {"sha": "c02ec4a23775ce8d6b7737afe3831604aa79c311", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=1f892dcb01c93c3af4be3c291f22da88e38bd835", "patch": "@@ -189,10 +189,26 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n                 let did = ast_util::def_id_of_def(cx.tcx.def_map.get(e.id));\n                 ty::lookup_item_type(cx.tcx, did).bounds\n               }\n-              expr_field(_, _, _) {\n+              expr_field(base, _, _) {\n                 alt cx.method_map.get(e.id) {\n                   typeck::method_static(did) {\n-                    ty::lookup_item_type(cx.tcx, did).bounds\n+                   /*\n+                        If this is a class method, we want to use the\n+                        class bounds plus the method bounds -- otherwise the\n+                        indices come out wrong. So we check base's type...\n+                   */\n+                   let mut bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n+                   alt ty::get(ty::node_id_to_type(cx.tcx, base.id)).struct {\n+                        ty::ty_class(parent_id, ts) {\n+                            /* ...and if it has a class type, prepend the\n+                               class bounds onto the method bounds */\n+                            bounds =\n+                             @(*ty::lookup_item_type(cx.tcx, parent_id).bounds\n+                               + *bounds);\n+                        }\n+                        _ { }\n+                      }\n+                      bounds\n                   }\n                   typeck::method_param(ifce_id, n_mth, _, _) |\n                   typeck::method_iface(ifce_id, n_mth) {"}, {"sha": "38af204a4e74f31fa770cbd0ce427f6e30b50033", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 73, "deletions": 59, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1f892dcb01c93c3af4be3c291f22da88e38bd835", "patch": "@@ -950,7 +950,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       ty::ty_class(did, tps) {\n           // a class is like a record type\n         let mut i: int = 0;\n-        for vec::each(ty::class_items_as_fields(cx.tcx(), did)) {|fld|\n+        for vec::each(ty::class_items_as_fields(cx.tcx(), did, tps)) {|fld|\n             let llfld_a = GEPi(cx, av, [0, i]);\n             cx = f(cx, llfld_a, fld.mt.ty);\n             i += 1;\n@@ -1983,8 +1983,13 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n             set_inline_hint(lldecl);\n             trans_res_ctor(ccx, pt, decl, fn_id.node, psubsts, lldecl);\n           }\n-          ast::item_class(_, _, ctor) {\n-            ccx.sess.unimpl(\"monomorphic class constructor\");\n+          ast::item_class(tps, _, ctor) {\n+            set_inline_hint_if_appr(i.attrs, lldecl);\n+            let tp_tys: [ty::t] = ty::ty_params_to_tys(ccx.tcx, tps);\n+            trans_class_ctor(ccx, pt, ctor.node.dec, ctor.node.body, lldecl,\n+                 option::get_or_default(psubsts,\n+                   {tys:tp_tys, vtables: none, bounds: @[]}),\n+              fn_id.node, i.id, ctor.span);\n           }\n         }\n       }\n@@ -2238,7 +2243,8 @@ fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n                          field: ast::ident, sp: span) -> lval_result {\n     let fields = alt ty::get(ty).struct {\n             ty::ty_rec(fs) { fs }\n-            ty::ty_class(did,_) { ty::class_items_as_fields(bcx.tcx(), did) }\n+            ty::ty_class(did,ts) {\n+                ty::class_items_as_fields(bcx.tcx(), did, ts) }\n             // Constraint?\n             _ { bcx.tcx().sess.span_bug(sp, \"trans_rec_field:\\\n                  base expr has non-record type\"); }\n@@ -4255,6 +4261,61 @@ fn trans_const(ccx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {\n     llvm::LLVMSetGlobalConstant(g, True);\n }\n \n+fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n+                    body: ast::blk, llctor_decl: ValueRef,\n+                    psubsts: param_substs, ctor_id: ast::node_id,\n+                    parent_id: ast::node_id, sp: span) {\n+  // Add ctor to the ctor map\n+  ccx.class_ctors.insert(ctor_id, parent_id);\n+  // Translate the ctor\n+\n+  // Set up the type for the result of the ctor\n+  // kludgy -- this wouldn't be necessary if the typechecker\n+  // special-cased constructors, then we could just look up\n+  // the ctor's return type.\n+  let rslt_ty =  ty::mk_class(ccx.tcx, local_def(parent_id),\n+                                    psubsts.tys);\n+  // Make the fn context\n+  let fcx = new_fn_ctxt_w_id(ccx, path, llctor_decl, ctor_id,\n+                                   some(psubsts), some(sp));\n+  // FIXME: need to substitute into the fn arg types too?\n+  create_llargs_for_fn_args(fcx, no_self, decl.inputs);\n+  let mut bcx_top = top_scope_block(fcx, some(sp));\n+  let lltop = bcx_top.llbb;\n+  bcx_top = copy_args_to_allocas(fcx, bcx_top, decl.inputs,\n+              ty::ty_fn_args(node_id_type(bcx_top, ctor_id)));\n+\n+  // We *don't* want self to be passed to the ctor -- that\n+  // wouldn't make sense\n+  // So we initialize it here\n+  let selfptr = alloc_ty(bcx_top, rslt_ty);\n+  // initialize fields to zero\n+  let fields = ty::class_items_as_fields(bcx_top.tcx(),\n+                                         local_def(parent_id),\n+                                         psubsts.tys);\n+  let mut bcx = bcx_top;\n+  // Initialize fields to zero so init assignments can validly\n+  // drop their LHS\n+  for field in fields {\n+     let ix = field_idx_strict(bcx.tcx(), sp, field.ident, fields);\n+     bcx = zero_alloca(bcx, GEPi(bcx, selfptr, [0, ix]),\n+                       field.mt.ty);\n+  }\n+\n+  // note we don't want to take *or* drop self.\n+  fcx.llself = some({v: selfptr, t: rslt_ty});\n+\n+  // Translate the body of the ctor\n+  bcx = trans_block(bcx_top, body, ignore);\n+  let lval_res = {bcx: bcx, val: selfptr, kind: owned};\n+  // Generate the return expression\n+  bcx = store_temp_expr(bcx, INIT, fcx.llretptr, lval_res,\n+                        rslt_ty, true);\n+  cleanup_and_leave(bcx, none, some(fcx.llreturn));\n+  Unreachable(bcx);\n+  finish_fn(fcx, lltop);\n+}\n+\n fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_item\");\n     let path = alt check ccx.tcx.items.get(item.id) {\n@@ -4322,62 +4383,15 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         native::trans_native_mod(ccx, native_mod, abi);\n       }\n       ast::item_class(tps, items, ctor) {\n-        // FIXME factor our ctor translation, call from monomorphic_fn\n-        let llctor_decl = get_item_val(ccx, ctor.node.id);\n-        // Add ctor to the ctor map\n-        ccx.class_ctors.insert(ctor.node.id, item.id);\n-        // Translate the ctor\n-\n-        // Set up the type for the result of the ctor\n-        // kludgy -- this wouldn't be necessary if the typechecker\n-        // special-cased constructors, then we could just look up\n-        // the ctor's return type.\n-        let ty_args = vec::from_fn(tps.len(), {|i|\n-            ty::mk_param(ccx.tcx, i, local_def(tps[i].id))\n-        });\n-        let rslt_ty =  ty::mk_class(ccx.tcx,\n-                                    local_def(item.id),\n-                                    ty_args);\n-\n-        // Make the fn context\n-        let fcx = new_fn_ctxt_w_id(ccx, *path, llctor_decl, ctor.node.id,\n-                                      // substs?\n-                                      none, some(ctor.span));\n-        create_llargs_for_fn_args(fcx, no_self, ctor.node.dec.inputs);\n-        let mut bcx_top = top_scope_block(fcx, some(ctor.span));\n-        let lltop = bcx_top.llbb;\n-        bcx_top = copy_args_to_allocas(fcx, bcx_top, ctor.node.dec.inputs,\n-           ty::ty_fn_args(node_id_type(bcx_top, ctor.node.id)));\n-\n-        // We *don't* want self to be passed to the ctor -- that\n-        // wouldn't make sense\n-        // So we initialize it here\n-        let selfptr = alloc_ty(bcx_top, rslt_ty);\n-        // initialize fields to zero\n-        let fields = ty::class_items_as_fields(bcx_top.tcx(),\n-                                               local_def(item.id));\n-        let mut bcx = bcx_top;\n-        // Initialize fields to zero so init assignments can validly\n-        // drop their LHS\n-        for field in fields {\n-           let ix = field_idx_strict(bcx.tcx(), ctor.span, field.ident,\n-                                     fields);\n-           bcx = zero_alloca(bcx, GEPi(bcx, selfptr, [0, ix]),\n-                                       field.mt.ty);\n+        if tps.len() == 0u {\n+          let psubsts = {tys: ty::ty_params_to_tys(ccx.tcx, tps),\n+                         vtables: none,\n+                         bounds: @[]};\n+          trans_class_ctor(ccx, *path, ctor.node.dec, ctor.node.body,\n+                         get_item_val(ccx, ctor.node.id), psubsts,\n+                         ctor.node.id, item.id, ctor.span);\n         }\n-\n-        // note we don't want to take *or* drop self.\n-        fcx.llself = some({v: selfptr, t: rslt_ty});\n-\n-        // Translate the body of the ctor\n-        bcx = trans_block(bcx_top, ctor.node.body, ignore);\n-        let lval_res = {bcx: bcx, val: selfptr, kind: owned};\n-        // Generate the return expression\n-        bcx = store_temp_expr(bcx, INIT, fcx.llretptr, lval_res,\n-                              rslt_ty, true);\n-        cleanup_and_leave(bcx, none, some(fcx.llreturn));\n-        Unreachable(bcx);\n-        finish_fn(fcx, lltop);\n+        // If there are ty params, the ctor will get monomorphized\n \n         // Translate methods\n         let (_, ms) = ast_util::split_class_items(items);"}, {"sha": "03277667ada05cd53d300af2ce937ec7caeced97", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=1f892dcb01c93c3af4be3c291f22da88e38bd835", "patch": "@@ -369,10 +369,10 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         s\n       }\n       ty::ty_iface(_, _) { [shape_box_fn] }\n-      ty::ty_class(did, _) {\n+      ty::ty_class(did, ts) {\n         // same as records\n         let mut s = [shape_struct], sub = [];\n-        for f:field in ty::class_items_as_fields(ccx.tcx, did) {\n+        for f:field in ty::class_items_as_fields(ccx.tcx, did, ts) {\n             sub += shape_of(ccx, f.mt.ty, ty_param_map);\n         }\n         add_substr(s, sub);"}, {"sha": "7f471e76bb727337414949cd30697a6b3b3cf873", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=1f892dcb01c93c3af4be3c291f22da88e38bd835", "patch": "@@ -81,11 +81,11 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       }\n       ty::ty_opaque_closure_ptr(_) { T_opaque_box_ptr(cx) }\n       ty::ty_constr(subt,_) { type_of(cx, subt) }\n-      ty::ty_class(did, _) {\n+      ty::ty_class(did, ts) {\n         // only instance vars are record fields at runtime\n         let fields = lookup_class_fields(cx.tcx, did);\n         let tys = vec::map(fields) {|f|\n-            let t = ty::lookup_field_type(cx.tcx, did, f.id);\n+            let t = ty::lookup_field_type(cx.tcx, did, f.id, ts);\n             type_of(cx, t)\n         };\n         T_struct(tys)"}, {"sha": "3705831e36feb26bbf0ca7dae3954ffc4bdb6222", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=1f892dcb01c93c3af4be3c291f22da88e38bd835", "patch": "@@ -1,4 +1,4 @@\n-// Determines the ways in which a generic function body is dependant\n+// Determines the ways in which a generic function body depends\n // on its type parameters. Used to aggressively reuse compiled\n // function bodies for different types.\n \n@@ -80,7 +80,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n         }\n       }\n       ast_map::node_ctor(@{node: item_class(_, _, ctor), _}, _) {\n-        ccx.sess.unimpl(\"type uses in class constructor\");\n+        handle_body(cx, ctor.node.body);\n       }\n     }\n     let uses = vec::from_mut(cx.uses);"}, {"sha": "1cd78f890fc00d9f66eb0fad99c57249410c2710", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=1f892dcb01c93c3af4be3c291f22da88e38bd835", "patch": "@@ -197,6 +197,20 @@ type pred_args = spanned<pred_args_>;\n // for this local.\n type constr_arg_use = spanned<constr_arg_general_<inst>>;\n \n+/*\n+  A constraint is either an init constraint, referring to the initialization\n+  state of a variable (not initialized, definitely initialized, or maybe\n+  initialized) or a predicate constraint, referring to the truth value of a\n+  predicate on variables (definitely false, maybe true, or definitely true).\n+\n+  cinit and ninit represent init constraints, while cpred and npred\n+  represent predicate constraints.\n+\n+  In a predicate constraint, the <path> field (and the <def_id> field\n+  in the npred constructor) names a user-defined function that may\n+  be the operator in a \"check\" expression in the source.\n+ */\n+\n enum constraint {\n     cinit(uint, span, ident),\n "}, {"sha": "b30db401da590ee58f5f55e0451392d3f808e127", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=1f892dcb01c93c3af4be3c291f22da88e38bd835", "patch": "@@ -82,7 +82,7 @@ export ty_vec, mk_vec, type_is_vec;\n export ty_nil, mk_nil, type_is_nil;\n export ty_iface, mk_iface;\n export ty_res, mk_res;\n-export ty_param, mk_param;\n+export ty_param, mk_param, ty_params_to_tys;\n export ty_ptr, mk_ptr, mk_mut_ptr, mk_imm_ptr, mk_nil_ptr, type_is_unsafe_ptr;\n export ty_rptr, mk_rptr;\n export ty_rec, mk_rec;\n@@ -742,6 +742,10 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n           ty_constr(subty, cs) {\n               ty = mk_constr(cx, do_fold(cx, fld, subty, under_rptr), cs);\n           }\n+          ty_class(did, ts) {\n+              ty = mk_class(cx, did, vec::map(ts, {|t|\n+                              do_fold(cx, fld, t, under_rptr)}));\n+          }\n           _ {\n               cx.sess.bug(\"unsupported sort of type in fold_ty\");\n           }\n@@ -886,8 +890,8 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n         for f in flds { if type_needs_drop(cx, f.mt.ty) { accum = true; } }\n         accum\n       }\n-      ty_class(did,_) {\n-          for f in ty::class_items_as_fields(cx, did)\n+      ty_class(did, ts) {\n+          for f in ty::class_items_as_fields(cx, did, ts)\n           { if type_needs_drop(cx, f.mt.ty) { accum = true; } }\n         accum\n       }\n@@ -1996,7 +2000,8 @@ fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n \n fn def_has_ty_params(def: ast::def) -> bool {\n     alt def {\n-      ast::def_fn(_, _) | ast::def_variant(_, _) { true }\n+      ast::def_fn(_, _) | ast::def_variant(_, _) | ast::def_class(_)\n+        { true }\n       _ { false }\n     }\n }\n@@ -2166,9 +2171,6 @@ fn enum_variant_with_id(cx: ctxt, enum_id: ast::def_id,\n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n-    /*\n-      Are we putting class ids in the tcache (where does that happen?)\n-     */\n     alt cx.tcache.find(did) {\n       some(tpt) { ret tpt; }\n       none {\n@@ -2184,23 +2186,26 @@ fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n }\n \n // Look up a field ID, whether or not it's local\n-fn lookup_field_type(tcx: ctxt, class_id: def_id, id: def_id) -> ty::t {\n-    if id.crate == ast::local_crate {\n+// Takes a list of type substs in case the class is generic\n+fn lookup_field_type(tcx: ctxt, class_id: def_id, id: def_id,\n+                     substs: [ty::t]) -> ty::t {\n+    let t = if id.crate == ast::local_crate {\n         node_id_to_type(tcx, id.node)\n     }\n     else {\n         alt tcx.tcache.find(id) {\n-           some(tpt) { ret tpt.ty; }\n+           some(tpt) { tpt.ty }\n            none {\n                let tpt = csearch::get_field_type(tcx, class_id, id);\n                // ok b/c fields are monomorphic\n                // TODO: Comment might be a lie, what if it mentions\n                // class-bound ty params?\n                tcx.tcache.insert(id, tpt);\n-               ret tpt.ty;\n+               tpt.ty\n            }\n         }\n-    }\n+    };\n+    substitute_type_params(tcx, substs, t)\n }\n \n // Look up the list of field names and IDs for a given class\n@@ -2298,13 +2303,16 @@ fn class_field_tys(items: [@class_member]) -> [field_ty] {\n \n // Return a list of fields corresponding to the class's items\n // (as if the class was a record). trans uses this\n-fn class_items_as_fields(cx:ctxt, did: ast::def_id) -> [field] {\n+// Takes a list of substs with which to instantiate field types\n+fn class_items_as_fields(cx:ctxt, did: ast::def_id, substs: [ty::t])\n+    -> [field] {\n     let mut rslt = [];\n     for f in lookup_class_fields(cx, did) {\n        // consider all instance vars mut, because the\n        // constructor may mutate all vars\n-      rslt += [{ident: f.ident, mt: {ty: lookup_field_type(cx, did, f.id),\n-                  mutbl: m_mutbl}}];\n+       rslt += [{ident: f.ident, mt:\n+               {ty: lookup_field_type(cx, did, f.id, substs),\n+                    mutbl: m_mutbl}}];\n     }\n     rslt\n }\n@@ -2408,7 +2416,11 @@ fn ast_constr_to_constr<T>(tcx: ctxt, c: @ast::constr_general<T>) ->\n     }\n }\n \n-\n+fn ty_params_to_tys(tcx: ty::ctxt, tps: [ast::ty_param]) -> [t] {\n+    vec::from_fn(tps.len(), {|i|\n+                ty::mk_param(tcx, i, ast_util::local_def(tps[i].id))\n+        })\n+}\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "d90a3f243b5ab562b270de5790cb6eceb01b51d8", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 13, "deletions": 31, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=1f892dcb01c93c3af4be3c291f22da88e38bd835", "patch": "@@ -218,7 +218,7 @@ fn instantiate_path(fcx: @fn_ctxt, pth: @ast::path,\n                 (sp, \"this item does not take type parameters\");\n         } else if ty_substs_len > ty_param_count {\n             fcx.ccx.tcx.sess.span_fatal\n-                (sp, \"too many type parameter provided for this item\");\n+                (sp, \"too many type parameters provided for this item\");\n         } else if ty_substs_len < ty_param_count {\n             fcx.ccx.tcx.sess.span_fatal\n                 (sp, \"not enough type parameters provided for this item\");\n@@ -399,7 +399,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n                                                        path_to_str(path))); }\n               some(d) { d }};\n             alt a_def {\n-              ast::def_ty(did) {\n+              ast::def_ty(did) | ast::def_class(did) {\n                 instantiate(tcx, ast_ty.span, mode, did,\n                             id, path.node.types)\n               }\n@@ -433,28 +433,6 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n                   }\n                 }\n               }\n-             ast::def_class(class_id) {\n-              if class_id.crate == ast::local_crate {\n-                 alt tcx.items.find(class_id.node) {\n-                   some(ast_map::node_item(\n-                     @{node: ast::item_class(tps, _, _), _}, _)) {\n-                        if vec::len(tps) != vec::len(path.node.types) {\n-                          tcx.sess.span_err(ast_ty.span, \"incorrect number \\\n-                            of type parameters to object type\");\n-                        }\n-                        ty::mk_class(tcx, class_id, vec::map(path.node.types,\n-                          {|ast_ty| ast_ty_to_ty(tcx, mode, ast_ty)}))\n-                     }\n-                   _ {\n-                      tcx.sess.span_bug(ast_ty.span, #fmt(\"class id is \\\n-                        unbound in items\"));\n-                   }\n-                }\n-              }\n-              else {\n-                  getter(tcx, mode, class_id).ty\n-              }\n-             }\n              _ {\n                 tcx.sess.span_fatal(ast_ty.span,\n                                     \"found type name used as a variable\");\n@@ -2196,7 +2174,8 @@ fn lookup_method_inner_(tcx: ty::ctxt, ms: [ty::method],\n                tcx.sess.span_fatal(\n                     sp, \"can not call a method that contains a \\\n                                     self type through a boxed iface\");\n-          } else if (*m.tps).len() > 0u {\n+          } else if (*m.tps).len() > 0u  &&\n+               alt parent { an_iface(_) { true } cls(_) { false } } {\n                    tcx.sess.span_fatal(\n                         sp, \"can not call a generic method through a \\\n                                     boxed iface\");\n@@ -2276,8 +2255,10 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n         }\n       }\n       ty::ty_class(did, tps) {\n-        alt lookup_method_inner_(tcx, *ty::iface_methods(tcx, did), tps,\n-              cls(did), name, expr.span, include_private) {\n+        alt lookup_method_inner_(tcx, *ty::iface_methods(tcx, did),\n+                                /* Need to include class tps so that the\n+                                    indices for ty params work out right */\n+                         tps, cls(did), name, expr.span, include_private) {\n           some(r) { ret some(r); }\n           none    { }\n         }\n@@ -2361,9 +2342,10 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n // Only for fields! Returns <none> for methods>\n // FIXME: privacy flags\n fn lookup_field_ty(tcx: ty::ctxt, class_id: ast::def_id,\n-  items:[ty::field_ty], fieldname: ast::ident) -> option<ty::t> {\n+   items:[ty::field_ty], fieldname: ast::ident, substs: [ty::t])\n+    -> option<ty::t> {\n     option::map(vec::find(items, {|f| f.ident == fieldname}),\n-                {|f| ty::lookup_field_type(tcx, class_id, f.id) })\n+                {|f| ty::lookup_field_type(tcx, class_id, f.id, substs) })\n }\n \n /*\n@@ -3236,7 +3218,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               _ {}\n             }\n           }\n-          ty::ty_class(base_id, _params) {\n+          ty::ty_class(base_id, params) {\n               // This is just for fields -- the same code handles\n               // methods in both classes and ifaces\n \n@@ -3255,7 +3237,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               else {\n                   lookup_public_fields(tcx, base_id)\n               };\n-              alt lookup_field_ty(tcx, base_id, cls_items, field) {\n+              alt lookup_field_ty(tcx, base_id, cls_items, field, params) {\n                  some(field_ty) {\n                     // (2) look up what field's type is, and return it\n                     // FIXME: actually instantiate any type params"}, {"sha": "0d738913ee56dcaefdf9e6c99484bb12757b9797", "filename": "src/test/run-pass/class-poly-methods.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs?ref=1f892dcb01c93c3af4be3c291f22da88e38bd835", "patch": "@@ -0,0 +1,28 @@\n+class cat<U> {\n+  priv {\n+    let mut info : [U];\n+    let mut meows : uint;\n+  }\n+\n+  let how_hungry : int;\n+\n+  new(in_x : uint, in_y : int, -in_info: [U])\n+    { self.meows = in_x; self.how_hungry = in_y;\n+      self.info <- in_info; }\n+\n+  fn speak<T>(stuff: [T]) {\n+    self.meows += stuff.len();\n+  }\n+  fn meow_count() -> uint { self.meows }\n+}\n+\n+fn main() {\n+  let nyan : cat<int> = cat::<int>(52u, 99, [9]);\n+  let kitty = cat(1000u, 2, [\"tabby\"]);\n+  assert(nyan.how_hungry == 99);\n+  assert(kitty.how_hungry == 2);\n+  nyan.speak([1,2,3]);\n+  assert(nyan.meow_count() == 55u);\n+  kitty.speak([\"meow\", \"mew\", \"purr\", \"chirp\"]);\n+  assert(kitty.meow_count() == 1004u);\n+}"}, {"sha": "caefb72a6a47d7322a515deea04b8075eed6aab6", "filename": "src/test/run-pass/class-typarams.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Ftest%2Frun-pass%2Fclass-typarams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f892dcb01c93c3af4be3c291f22da88e38bd835/src%2Ftest%2Frun-pass%2Fclass-typarams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-typarams.rs?ref=1f892dcb01c93c3af4be3c291f22da88e38bd835", "patch": "@@ -0,0 +1,19 @@\n+class cat<U> {\n+  priv {\n+    let mut meows : uint;\n+  }\n+\n+  let how_hungry : int;\n+\n+  new(in_x : uint, in_y : int) { self.meows = in_x; self.how_hungry = in_y; }\n+\n+  fn speak() {\n+    self.meows += 1u;\n+  }\n+  fn meow_count() -> uint { self.meows }\n+}\n+\n+fn main() {\n+  let _nyan : cat<int> = cat::<int>(52u, 99);\n+  //  let kitty = cat(1000u, 2);\n+}"}]}