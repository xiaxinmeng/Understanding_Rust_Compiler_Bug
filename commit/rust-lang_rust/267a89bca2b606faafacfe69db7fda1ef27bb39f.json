{"sha": "267a89bca2b606faafacfe69db7fda1ef27bb39f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2N2E4OWJjYTJiNjA2ZmFhZmFjZmU2OWRiN2ZkYTFlZjI3YmIzOWY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-02T20:24:58Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-03T09:26:40Z"}, "message": "use LocalSyntaxPtr for file symbol", "tree": {"sha": "aeba5501cce0417dd79b0be0cab653589354523c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aeba5501cce0417dd79b0be0cab653589354523c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/267a89bca2b606faafacfe69db7fda1ef27bb39f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/267a89bca2b606faafacfe69db7fda1ef27bb39f", "html_url": "https://github.com/rust-lang/rust/commit/267a89bca2b606faafacfe69db7fda1ef27bb39f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/267a89bca2b606faafacfe69db7fda1ef27bb39f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f534d2132b90fca8c0646cc81f8a60fa20423fe1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f534d2132b90fca8c0646cc81f8a60fa20423fe1", "html_url": "https://github.com/rust-lang/rust/commit/f534d2132b90fca8c0646cc81f8a60fa20423fe1"}], "stats": {"total": 102, "additions": 49, "deletions": 53}, "files": [{"sha": "7604c7def46439479bd524247297909e4279792b", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/267a89bca2b606faafacfe69db7fda1ef27bb39f/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267a89bca2b606faafacfe69db7fda1ef27bb39f/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=267a89bca2b606faafacfe69db7fda1ef27bb39f", "patch": "@@ -360,52 +360,52 @@ impl db::RootDatabase {\n         // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n         let file_symbols = self.index_resolve(name_ref)?;\n         for (fn_file_id, fs) in file_symbols {\n-            if fs.kind == FN_DEF {\n+            if fs.ptr.kind() == FN_DEF {\n                 let fn_file = self.source_file(fn_file_id);\n-                if let Some(fn_def) = find_node_at_offset(fn_file.syntax(), fs.node_range.start()) {\n-                    let descr = ctry!(source_binder::function_from_source(\n-                        self, fn_file_id, fn_def\n-                    )?);\n-                    if let Some(descriptor) = descr.signature_info(self) {\n-                        // If we have a calling expression let's find which argument we are on\n-                        let mut current_parameter = None;\n-\n-                        let num_params = descriptor.params.len();\n-                        let has_self = fn_def.param_list().and_then(|l| l.self_param()).is_some();\n-\n-                        if num_params == 1 {\n-                            if !has_self {\n-                                current_parameter = Some(0);\n-                            }\n-                        } else if num_params > 1 {\n-                            // Count how many parameters into the call we are.\n-                            // TODO: This is best effort for now and should be fixed at some point.\n-                            // It may be better to see where we are in the arg_list and then check\n-                            // where offset is in that list (or beyond).\n-                            // Revisit this after we get documentation comments in.\n-                            if let Some(ref arg_list) = calling_node.arg_list() {\n-                                let start = arg_list.syntax().range().start();\n-\n-                                let range_search = TextRange::from_to(start, position.offset);\n-                                let mut commas: usize = arg_list\n-                                    .syntax()\n-                                    .text()\n-                                    .slice(range_search)\n-                                    .to_string()\n-                                    .matches(',')\n-                                    .count();\n-\n-                                // If we have a method call eat the first param since it's just self.\n-                                if has_self {\n-                                    commas += 1;\n-                                }\n-\n-                                current_parameter = Some(commas);\n-                            }\n+                let fn_def = fs.ptr.resolve(&fn_file);\n+                let fn_def = ast::FnDef::cast(fn_def.borrowed()).unwrap();\n+                let descr = ctry!(source_binder::function_from_source(\n+                    self, fn_file_id, fn_def\n+                )?);\n+                if let Some(descriptor) = descr.signature_info(self) {\n+                    // If we have a calling expression let's find which argument we are on\n+                    let mut current_parameter = None;\n+\n+                    let num_params = descriptor.params.len();\n+                    let has_self = fn_def.param_list().and_then(|l| l.self_param()).is_some();\n+\n+                    if num_params == 1 {\n+                        if !has_self {\n+                            current_parameter = Some(0);\n                         }\n+                    } else if num_params > 1 {\n+                        // Count how many parameters into the call we are.\n+                        // TODO: This is best effort for now and should be fixed at some point.\n+                        // It may be better to see where we are in the arg_list and then check\n+                        // where offset is in that list (or beyond).\n+                        // Revisit this after we get documentation comments in.\n+                        if let Some(ref arg_list) = calling_node.arg_list() {\n+                            let start = arg_list.syntax().range().start();\n+\n+                            let range_search = TextRange::from_to(start, position.offset);\n+                            let mut commas: usize = arg_list\n+                                .syntax()\n+                                .text()\n+                                .slice(range_search)\n+                                .to_string()\n+                                .matches(',')\n+                                .count();\n+\n+                            // If we have a method call eat the first param since it's just self.\n+                            if has_self {\n+                                commas += 1;\n+                            }\n \n-                        return Ok(Some((descriptor, current_parameter)));\n+                            current_parameter = Some(commas);\n+                        }\n                     }\n+\n+                    return Ok(Some((descriptor, current_parameter)));\n                 }\n             }\n         }"}, {"sha": "69d6754d6a7aacca57d9086bfc430993900bc771", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/267a89bca2b606faafacfe69db7fda1ef27bb39f/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267a89bca2b606faafacfe69db7fda1ef27bb39f/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=267a89bca2b606faafacfe69db7fda1ef27bb39f", "patch": "@@ -231,9 +231,9 @@ impl NavigationTarget {\n     fn from_symbol(file_id: FileId, symbol: FileSymbol) -> NavigationTarget {\n         NavigationTarget {\n             name: symbol.name.clone(),\n-            kind: symbol.kind.clone(),\n+            kind: symbol.ptr.kind(),\n             file_id,\n-            range: symbol.node_range.clone(),\n+            range: symbol.ptr.range(),\n         }\n     }\n     pub fn name(&self) -> &SmolStr {"}, {"sha": "1b6815bbfd477636360cbf7740c2aaba407c8ee9", "filename": "crates/ra_analysis/src/symbol_index.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/267a89bca2b606faafacfe69db7fda1ef27bb39f/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/267a89bca2b606faafacfe69db7fda1ef27bb39f/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs?ref=267a89bca2b606faafacfe69db7fda1ef27bb39f", "patch": "@@ -5,12 +5,12 @@ use std::{\n \n use fst::{self, Streamer};\n use ra_syntax::{\n-    SyntaxNodeRef, SourceFileNode, SmolStr, TextRange,\n+    SyntaxNodeRef, SourceFileNode, SmolStr,\n     algo::visit::{visitor, Visitor},\n     SyntaxKind::{self, *},\n     ast::{self, NameOwner},\n };\n-use ra_db::{SyntaxDatabase, SourceRootId, FilesDatabase};\n+use ra_db::{SyntaxDatabase, SourceRootId, FilesDatabase, LocalSyntaxPtr};\n use salsa::ParallelDatabase;\n use rayon::prelude::*;\n \n@@ -140,7 +140,7 @@ impl Query {\n                 let idx = indexed_value.value as usize;\n \n                 let (file_id, symbol) = &file_symbols.symbols[idx];\n-                if self.only_types && !is_type(symbol.kind) {\n+                if self.only_types && !is_type(symbol.ptr.kind()) {\n                     continue;\n                 }\n                 if self.exact && symbol.name != self.query {\n@@ -163,19 +163,15 @@ fn is_type(kind: SyntaxKind) -> bool {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub(crate) struct FileSymbol {\n     pub(crate) name: SmolStr,\n-    pub(crate) node_range: TextRange,\n-    pub(crate) kind: SyntaxKind,\n-    _x: (),\n+    pub(crate) ptr: LocalSyntaxPtr,\n }\n \n fn to_symbol(node: SyntaxNodeRef) -> Option<FileSymbol> {\n     fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<FileSymbol> {\n         let name = node.name()?;\n         Some(FileSymbol {\n             name: name.text(),\n-            node_range: node.syntax().range(),\n-            kind: node.syntax().kind(),\n-            _x: (),\n+            ptr: LocalSyntaxPtr::new(node.syntax()),\n         })\n     }\n     visitor()"}]}