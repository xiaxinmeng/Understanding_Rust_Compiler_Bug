{"sha": "4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5NjBmMmY5MDc0ZDBkMGY5ZGU4MGIzOWYwYjBkZWQ2NTQ3ZTJhZDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-23T04:11:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-23T04:11:27Z"}, "message": "Auto merge of #34374 - jseyfried:fix_hygiene_bug, r=nrc\n\nFix macro hygiene regression\n\nThe regression was caused by #32923, which is currently in beta.\n\nThe following is an example of regressed code:\n```rust\nfn main() {\n    let x = 0;\n    macro_rules! foo { () => {\n        println!(\"{}\", x); // prints `0` on stable and after this PR, prints `1` on beta and nightly\n    } }\n\n    let x = 1;\n    foo!();\n}\n```\n\nFor code to regress, the following is necessary (but not sufficient):\n - There must be a local variable before a macro in a block, and the macro must use the variable.\n - There must be a second local variable with the same name after the macro.\n - The macro must be invoked in a statement position after the second local variable.\n\nFor example, if the `let x = 0;` from the breaking example were commented out, it would (correctly) not compile on beta/nightly. If the semicolon were removed from `foo!();`, it would (correctly) print `0` on beta and nightly.\n\nr? @nrc", "tree": {"sha": "36dce8fb815e3a389fd7afff4ae501c8aed73d7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36dce8fb815e3a389fd7afff4ae501c8aed73d7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8", "html_url": "https://github.com/rust-lang/rust/commit/4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dcc2c1dee3b58afd44665d1df4a248bdd04cce5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dcc2c1dee3b58afd44665d1df4a248bdd04cce5", "html_url": "https://github.com/rust-lang/rust/commit/6dcc2c1dee3b58afd44665d1df4a248bdd04cce5"}, {"sha": "eef8485f5f707fbe0143d0f7c64aefceba6900d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/eef8485f5f707fbe0143d0f7c64aefceba6900d9", "html_url": "https://github.com/rust-lang/rust/commit/eef8485f5f707fbe0143d0f7c64aefceba6900d9"}], "stats": {"total": 759, "additions": 163, "deletions": 596}, "files": [{"sha": "73acbb2aa0aede831ac88b9025179e84e0b54b64", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 261, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8", "patch": "@@ -681,7 +681,7 @@ pub struct IdentRenamer<'a> {\n \n impl<'a> Folder for IdentRenamer<'a> {\n     fn fold_ident(&mut self, id: Ident) -> Ident {\n-        Ident::new(id.name, mtwt::apply_renames(self.renames, id.ctxt))\n+        mtwt::apply_renames(self.renames, id)\n     }\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n         fold::noop_fold_mac(mac, self)\n@@ -705,8 +705,7 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n \n         pat.map(|ast::Pat {id, node, span}| match node {\n             PatKind::Ident(binding_mode, Spanned{span: sp, node: ident}, sub) => {\n-                let new_ident = Ident::new(ident.name,\n-                                           mtwt::apply_renames(self.renames, ident.ctxt));\n+                let new_ident = mtwt::apply_renames(self.renames, ident);\n                 let new_node =\n                     PatKind::Ident(binding_mode,\n                                   Spanned{span: sp, node: new_ident},\n@@ -1266,7 +1265,7 @@ mod tests {\n     use ext::mtwt;\n     use fold::Folder;\n     use parse;\n-    use parse::token::{self, keywords};\n+    use parse::token;\n     use util::parser_testing::{string_to_parser};\n     use util::parser_testing::{string_to_pat, string_to_crate, strs_to_idents};\n     use visit;\n@@ -1396,267 +1395,10 @@ mod tests {\n             );\n     }\n \n-    // renaming tests expand a crate and then check that the bindings match\n-    // the right varrefs. The specification of the test case includes the\n-    // text of the crate, and also an array of arrays.  Each element in the\n-    // outer array corresponds to a binding in the traversal of the AST\n-    // induced by visit.  Each of these arrays contains a list of indexes,\n-    // interpreted as the varrefs in the varref traversal that this binding\n-    // should match.  So, for instance, in a program with two bindings and\n-    // three varrefs, the array [[1, 2], [0]] would indicate that the first\n-    // binding should match the second two varrefs, and the second binding\n-    // should match the first varref.\n-    //\n-    // Put differently; this is a sparse representation of a boolean matrix\n-    // indicating which bindings capture which identifiers.\n-    //\n-    // Note also that this matrix is dependent on the implicit ordering of\n-    // the bindings and the varrefs discovered by the name-finder and the path-finder.\n-    //\n-    // The comparisons are done post-mtwt-resolve, so we're comparing renamed\n-    // names; differences in marks don't matter any more.\n-    //\n-    // oog... I also want tests that check \"bound-identifier-=?\". That is,\n-    // not just \"do these have the same name\", but \"do they have the same\n-    // name *and* the same marks\"? Understanding this is really pretty painful.\n-    // in principle, you might want to control this boolean on a per-varref basis,\n-    // but that would make things even harder to understand, and might not be\n-    // necessary for thorough testing.\n-    type RenamingTest = (&'static str, Vec<Vec<usize>>, bool);\n-\n-    #[test]\n-    fn automatic_renaming () {\n-        let tests: Vec<RenamingTest> =\n-            vec!(// b & c should get new names throughout, in the expr too:\n-                (\"fn a() -> i32 { let b = 13; let c = b; b+c }\",\n-                 vec!(vec!(0,1),vec!(2)), false),\n-                // both x's should be renamed (how is this causing a bug?)\n-                (\"fn main () {let x: i32 = 13;x;}\",\n-                 vec!(vec!(0)), false),\n-                // the use of b after the + should be renamed, the other one not:\n-                (\"macro_rules! f (($x:ident) => (b + $x)); fn a() -> i32 { let b = 13; f!(b)}\",\n-                 vec!(vec!(1)), false),\n-                // the b before the plus should not be renamed (requires marks)\n-                (\"macro_rules! f (($x:ident) => ({let b=9; ($x + b)})); fn a() -> i32 { f!(b)}\",\n-                 vec!(vec!(1)), false),\n-                // the marks going in and out of letty should cancel, allowing that $x to\n-                // capture the one following the semicolon.\n-                // this was an awesome test case, and caught a *lot* of bugs.\n-                (\"macro_rules! letty(($x:ident) => (let $x = 15;));\n-                  macro_rules! user(($x:ident) => ({letty!($x); $x}));\n-                  fn main() -> i32 {user!(z)}\",\n-                 vec!(vec!(0)), false)\n-                );\n-        for (idx,s) in tests.iter().enumerate() {\n-            run_renaming_test(s,idx);\n-        }\n-    }\n-\n-    // no longer a fixme #8062: this test exposes a *potential* bug; our system does\n-    // not behave exactly like MTWT, but a conversation with Matthew Flatt\n-    // suggests that this can only occur in the presence of local-expand, which\n-    // we have no plans to support. ... unless it's needed for item hygiene....\n-    #[ignore]\n-    #[test]\n-    fn issue_8062(){\n-        run_renaming_test(\n-            &(\"fn main() {let hrcoo = 19; macro_rules! getx(()=>(hrcoo)); getx!();}\",\n-              vec!(vec!(0)), true), 0)\n-    }\n-\n-    // FIXME #6994:\n-    // the z flows into and out of two macros (g & f) along one path, and one\n-    // (just g) along the other, so the result of the whole thing should\n-    // be \"let z_123 = 3; z_123\"\n-    #[ignore]\n-    #[test]\n-    fn issue_6994(){\n-        run_renaming_test(\n-            &(\"macro_rules! g (($x:ident) =>\n-              ({macro_rules! f(($y:ident)=>({let $y=3;$x}));f!($x)}));\n-              fn a(){g!(z)}\",\n-              vec!(vec!(0)),false),\n-            0)\n-    }\n-\n-    // match variable hygiene. Should expand into\n-    // fn z() {match 8 {x_1 => {match 9 {x_2 | x_2 if x_2 == x_1 => x_2 + x_1}}}}\n-    #[test]\n-    fn issue_9384(){\n-        run_renaming_test(\n-            &(\"macro_rules! bad_macro (($ex:expr) => ({match 9 {x | x if x == $ex => x + $ex}}));\n-              fn z() {match 8 {x => bad_macro!(x)}}\",\n-              // NB: the third \"binding\" is the repeat of the second one.\n-              vec!(vec!(1,3),vec!(0,2),vec!(0,2)),\n-              true),\n-            0)\n-    }\n-\n-    // interpolated nodes weren't getting labeled.\n-    // should expand into\n-    // fn main(){let g1_1 = 13; g1_1}}\n-    #[test]\n-    fn pat_expand_issue_15221(){\n-        run_renaming_test(\n-            &(\"macro_rules! inner ( ($e:pat ) => ($e));\n-              macro_rules! outer ( ($e:pat ) => (inner!($e)));\n-              fn main() { let outer!(g) = 13; g;}\",\n-              vec!(vec!(0)),\n-              true),\n-            0)\n-    }\n-\n     // create a really evil test case where a $x appears inside a binding of $x\n     // but *shouldn't* bind because it was inserted by a different macro....\n     // can't write this test case until we have macro-generating macros.\n \n-    // method arg hygiene\n-    // method expands to fn get_x(&self_0, x_1: i32) {self_0 + self_2 + x_3 + x_1}\n-    #[test]\n-    fn method_arg_hygiene(){\n-        run_renaming_test(\n-            &(\"macro_rules! inject_x (()=>(x));\n-              macro_rules! inject_self (()=>(self));\n-              struct A;\n-              impl A{fn get_x(&self, x: i32) {self + inject_self!() + inject_x!() + x;} }\",\n-              vec!(vec!(0),vec!(3)),\n-              true),\n-            0)\n-    }\n-\n-    // ooh, got another bite?\n-    // expands to struct A; impl A {fn thingy(&self_1) {self_1;}}\n-    #[test]\n-    fn method_arg_hygiene_2(){\n-        run_renaming_test(\n-            &(\"struct A;\n-              macro_rules! add_method (($T:ty) =>\n-              (impl $T {  fn thingy(&self) {self;} }));\n-              add_method!(A);\",\n-              vec!(vec!(0)),\n-              true),\n-            0)\n-    }\n-\n-    // item fn hygiene\n-    // expands to fn q(x_1: i32){fn g(x_2: i32){x_2 + x_1};}\n-    #[test]\n-    fn issue_9383(){\n-        run_renaming_test(\n-            &(\"macro_rules! bad_macro (($ex:expr) => (fn g(x: i32){ x + $ex }));\n-              fn q(x: i32) { bad_macro!(x); }\",\n-              vec!(vec!(1),vec!(0)),true),\n-            0)\n-    }\n-\n-    // closure arg hygiene (ExprKind::Closure)\n-    // expands to fn f(){(|x_1 : i32| {(x_2 + x_1)})(3);}\n-    #[test]\n-    fn closure_arg_hygiene(){\n-        run_renaming_test(\n-            &(\"macro_rules! inject_x (()=>(x));\n-            fn f(){(|x : i32| {(inject_x!() + x)})(3);}\",\n-              vec!(vec!(1)),\n-              true),\n-            0)\n-    }\n-\n-    // macro_rules in method position. Sadly, unimplemented.\n-    #[test]\n-    fn macro_in_method_posn(){\n-        expand_crate_str(\n-            \"macro_rules! my_method (() => (fn thirteen(&self) -> i32 {13}));\n-            struct A;\n-            impl A{ my_method!(); }\n-            fn f(){A.thirteen;}\".to_string());\n-    }\n-\n-    // another nested macro\n-    // expands to impl Entries {fn size_hint(&self_1) {self_1;}\n-    #[test]\n-    fn item_macro_workaround(){\n-        run_renaming_test(\n-            &(\"macro_rules! item { ($i:item) => {$i}}\n-              struct Entries;\n-              macro_rules! iterator_impl {\n-              () => { item!( impl Entries { fn size_hint(&self) { self;}});}}\n-              iterator_impl! { }\",\n-              vec!(vec!(0)), true),\n-            0)\n-    }\n-\n-    // run one of the renaming tests\n-    fn run_renaming_test(t: &RenamingTest, test_idx: usize) {\n-        let invalid_name = keywords::Invalid.name();\n-        let (teststr, bound_connections, bound_ident_check) = match *t {\n-            (ref str,ref conns, bic) => (str.to_string(), conns.clone(), bic)\n-        };\n-        let cr = expand_crate_str(teststr.to_string());\n-        let bindings = crate_bindings(&cr);\n-        let varrefs = crate_varrefs(&cr);\n-\n-        // must be one check clause for each binding:\n-        assert_eq!(bindings.len(),bound_connections.len());\n-        for (binding_idx,shouldmatch) in bound_connections.iter().enumerate() {\n-            let binding_name = mtwt::resolve(bindings[binding_idx]);\n-            let binding_marks = mtwt::marksof(bindings[binding_idx].ctxt, invalid_name);\n-            // shouldmatch can't name varrefs that don't exist:\n-            assert!((shouldmatch.is_empty()) ||\n-                    (varrefs.len() > *shouldmatch.iter().max().unwrap()));\n-            for (idx,varref) in varrefs.iter().enumerate() {\n-                let print_hygiene_debug_info = || {\n-                    // good lord, you can't make a path with 0 segments, can you?\n-                    let final_varref_ident = match varref.segments.last() {\n-                        Some(pathsegment) => pathsegment.identifier,\n-                        None => panic!(\"varref with 0 path segments?\")\n-                    };\n-                    let varref_name = mtwt::resolve(final_varref_ident);\n-                    let varref_idents : Vec<ast::Ident>\n-                        = varref.segments.iter().map(|s| s.identifier)\n-                        .collect();\n-                    println!(\"varref #{}: {:?}, resolves to {}\",idx, varref_idents, varref_name);\n-                    println!(\"varref's first segment's string: \\\"{}\\\"\", final_varref_ident);\n-                    println!(\"binding #{}: {}, resolves to {}\",\n-                             binding_idx, bindings[binding_idx], binding_name);\n-                    mtwt::with_sctable(|x| mtwt::display_sctable(x));\n-                };\n-                if shouldmatch.contains(&idx) {\n-                    // it should be a path of length 1, and it should\n-                    // be free-identifier=? or bound-identifier=? to the given binding\n-                    assert_eq!(varref.segments.len(),1);\n-                    let varref_name = mtwt::resolve(varref.segments[0].identifier);\n-                    let varref_marks = mtwt::marksof(varref.segments[0]\n-                                                           .identifier\n-                                                           .ctxt,\n-                                                     invalid_name);\n-                    if !(varref_name==binding_name) {\n-                        println!(\"uh oh, should match but doesn't:\");\n-                        print_hygiene_debug_info();\n-                    }\n-                    assert_eq!(varref_name,binding_name);\n-                    if bound_ident_check {\n-                        // we're checking bound-identifier=?, and the marks\n-                        // should be the same, too:\n-                        assert_eq!(varref_marks,binding_marks.clone());\n-                    }\n-                } else {\n-                    let varref_name = mtwt::resolve(varref.segments[0].identifier);\n-                    let fail = (varref.segments.len() == 1)\n-                        && (varref_name == binding_name);\n-                    // temp debugging:\n-                    if fail {\n-                        println!(\"failure on test {}\",test_idx);\n-                        println!(\"text of test case: \\\"{}\\\"\", teststr);\n-                        println!(\"\");\n-                        println!(\"uh oh, matches but shouldn't:\");\n-                        print_hygiene_debug_info();\n-                    }\n-                    assert!(!fail);\n-                }\n-            }\n-        }\n-    }\n-\n     #[test]\n     fn fmt_in_macro_used_inside_module_macro() {\n         let crate_str = \"macro_rules! fmt_wrap(($b:expr)=>($b.to_string()));"}, {"sha": "c9e8715dda6a8a288ae2cebb61284268dca6f507", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 44, "deletions": 335, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8", "patch": "@@ -25,34 +25,22 @@ use std::collections::HashMap;\n /// The SCTable contains a table of SyntaxContext_'s. It\n /// represents a flattened tree structure, to avoid having\n /// managed pointers everywhere (that caused an ICE).\n-/// the mark_memo and rename_memo fields are side-tables\n+/// the `marks` and `renames` fields are side-tables\n /// that ensure that adding the same mark to the same context\n-/// gives you back the same context as before. This shouldn't\n-/// change the semantics--everything here is immutable--but\n-/// it should cut down on memory use *a lot*; applying a mark\n-/// to a tree containing 50 identifiers would otherwise generate\n-/// 50 new contexts\n+/// gives you back the same context as before. This should cut\n+/// down on memory use *a lot*; applying a mark to a tree containing\n+/// 50 identifiers would otherwise generate 50 new contexts.\n pub struct SCTable {\n     table: RefCell<Vec<SyntaxContext_>>,\n-    mark_memo: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n-    // The pair (Name,SyntaxContext) is actually one Ident, but it needs to be hashed and\n-    // compared as pair (name, ctxt) and not as an Ident\n-    rename_memo: RefCell<HashMap<(SyntaxContext,(Name,SyntaxContext),Name),SyntaxContext>>,\n+    marks: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n+    renames: RefCell<HashMap<Name,SyntaxContext>>,\n }\n \n #[derive(PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, Clone)]\n pub enum SyntaxContext_ {\n     EmptyCtxt,\n     Mark (Mrk,SyntaxContext),\n-    /// flattening the name and syntaxcontext into the rename...\n-    /// HIDDEN INVARIANTS:\n-    /// 1) the first name in a Rename node\n-    /// can only be a programmer-supplied name.\n-    /// 2) Every Rename node with a given Name in the\n-    /// \"to\" slot must have the same name and context\n-    /// in the \"from\" slot. In essence, they're all\n-    /// pointers to a single \"rename\" event node.\n-    Rename (Ident,Name,SyntaxContext),\n+    Rename (Name),\n     /// actually, IllegalCtxt may not be necessary.\n     IllegalCtxt\n }\n@@ -67,37 +55,39 @@ pub fn apply_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n \n /// Extend a syntax context with a given mark and sctable (explicit memoization)\n fn apply_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxContext {\n-    let key = (ctxt, m);\n-    *table.mark_memo.borrow_mut().entry(key).or_insert_with(|| {\n-        SyntaxContext(idx_push(&mut *table.table.borrow_mut(), Mark(m, ctxt)))\n-    })\n+    let ctxts = &mut *table.table.borrow_mut();\n+    match ctxts[ctxt.0 as usize] {\n+        // Applying the same mark twice is a no-op.\n+        Mark(outer_mark, prev_ctxt) if outer_mark == m => return prev_ctxt,\n+        _ => *table.marks.borrow_mut().entry((ctxt, m)).or_insert_with(|| {\n+            SyntaxContext(idx_push(ctxts, Mark(m, ctxt)))\n+        }),\n+    }\n }\n \n /// Extend a syntax context with a given rename\n-pub fn apply_rename(id: Ident, to:Name,\n-                  ctxt: SyntaxContext) -> SyntaxContext {\n-    with_sctable(|table| apply_rename_internal(id, to, ctxt, table))\n+pub fn apply_rename(from: Ident, to: Name, ident: Ident) -> Ident {\n+    with_sctable(|table| apply_rename_internal(from, to, ident, table))\n }\n \n /// Extend a syntax context with a given rename and sctable (explicit memoization)\n-fn apply_rename_internal(id: Ident,\n-                       to: Name,\n-                       ctxt: SyntaxContext,\n-                       table: &SCTable) -> SyntaxContext {\n-    let key = (ctxt, (id.name, id.ctxt), to);\n-\n-    *table.rename_memo.borrow_mut().entry(key).or_insert_with(|| {\n-            SyntaxContext(idx_push(&mut *table.table.borrow_mut(), Rename(id, to, ctxt)))\n-    })\n+fn apply_rename_internal(from: Ident, to: Name, ident: Ident, table: &SCTable) -> Ident {\n+    if (ident.name, ident.ctxt) != (from.name, from.ctxt) {\n+        return ident;\n+    }\n+    let ctxt = *table.renames.borrow_mut().entry(to).or_insert_with(|| {\n+        SyntaxContext(idx_push(&mut *table.table.borrow_mut(), Rename(to)))\n+    });\n+    Ident { ctxt: ctxt, ..ident }\n }\n \n /// Apply a list of renamings to a context\n // if these rename lists get long, it would make sense\n // to consider memoizing this fold. This may come up\n // when we add hygiene to item names.\n-pub fn apply_renames(renames: &RenameList, ctxt: SyntaxContext) -> SyntaxContext {\n-    renames.iter().fold(ctxt, |ctxt, &(from, to)| {\n-        apply_rename(from, to, ctxt)\n+pub fn apply_renames(renames: &RenameList, ident: Ident) -> Ident {\n+    renames.iter().fold(ident, |ident, &(from, to)| {\n+        apply_rename(from, to, ident)\n     })\n }\n \n@@ -114,8 +104,8 @@ pub fn with_sctable<T, F>(op: F) -> T where\n fn new_sctable_internal() -> SCTable {\n     SCTable {\n         table: RefCell::new(vec!(EmptyCtxt, IllegalCtxt)),\n-        mark_memo: RefCell::new(HashMap::new()),\n-        rename_memo: RefCell::new(HashMap::new()),\n+        marks: RefCell::new(HashMap::new()),\n+        renames: RefCell::new(HashMap::new()),\n     }\n }\n \n@@ -131,20 +121,18 @@ pub fn display_sctable(table: &SCTable) {\n pub fn clear_tables() {\n     with_sctable(|table| {\n         *table.table.borrow_mut() = Vec::new();\n-        *table.mark_memo.borrow_mut() = HashMap::new();\n-        *table.rename_memo.borrow_mut() = HashMap::new();\n+        *table.marks.borrow_mut() = HashMap::new();\n+        *table.renames.borrow_mut() = HashMap::new();\n     });\n-    with_resolve_table_mut(|table| *table = HashMap::new());\n }\n \n /// Reset the tables to their initial state\n pub fn reset_tables() {\n     with_sctable(|table| {\n         *table.table.borrow_mut() = vec!(EmptyCtxt, IllegalCtxt);\n-        *table.mark_memo.borrow_mut() = HashMap::new();\n-        *table.rename_memo.borrow_mut() = HashMap::new();\n+        *table.marks.borrow_mut() = HashMap::new();\n+        *table.renames.borrow_mut() = HashMap::new();\n     });\n-    with_resolve_table_mut(|table| *table = HashMap::new());\n }\n \n /// Add a value to the end of a vec, return its index\n@@ -156,103 +144,19 @@ fn idx_push<T>(vec: &mut Vec<T>, val: T) -> u32 {\n /// Resolve a syntax object to a name, per MTWT.\n pub fn resolve(id: Ident) -> Name {\n     with_sctable(|sctable| {\n-        with_resolve_table_mut(|resolve_table| {\n-            resolve_internal(id, sctable, resolve_table)\n-        })\n+        resolve_internal(id, sctable)\n     })\n }\n \n-type ResolveTable = HashMap<(Name,SyntaxContext),Name>;\n-\n-// okay, I admit, putting this in TLS is not so nice:\n-// fetch the SCTable from TLS, create one if it doesn't yet exist.\n-fn with_resolve_table_mut<T, F>(op: F) -> T where\n-    F: FnOnce(&mut ResolveTable) -> T,\n-{\n-    thread_local!(static RESOLVE_TABLE_KEY: RefCell<ResolveTable> = {\n-        RefCell::new(HashMap::new())\n-    });\n-\n-    RESOLVE_TABLE_KEY.with(move |slot| op(&mut *slot.borrow_mut()))\n-}\n-\n /// Resolve a syntax object to a name, per MTWT.\n /// adding memoization to resolve 500+ seconds in resolve for librustc (!)\n-fn resolve_internal(id: Ident,\n-                    table: &SCTable,\n-                    resolve_table: &mut ResolveTable) -> Name {\n-    let key = (id.name, id.ctxt);\n-\n-    match resolve_table.get(&key) {\n-        Some(&name) => return name,\n-        None => {}\n-    }\n-\n-    let resolved = {\n-        let result = (*table.table.borrow())[id.ctxt.0 as usize];\n-        match result {\n-            EmptyCtxt => id.name,\n-            // ignore marks here:\n-            Mark(_,subctxt) =>\n-                resolve_internal(Ident::new(id.name, subctxt),\n-                                 table, resolve_table),\n-            // do the rename if necessary:\n-            Rename(Ident{name, ctxt}, toname, subctxt) => {\n-                let resolvedfrom =\n-                    resolve_internal(Ident::new(name, ctxt),\n-                                     table, resolve_table);\n-                let resolvedthis =\n-                    resolve_internal(Ident::new(id.name, subctxt),\n-                                     table, resolve_table);\n-                if (resolvedthis == resolvedfrom)\n-                    && (marksof_internal(ctxt, resolvedthis, table)\n-                        == marksof_internal(subctxt, resolvedthis, table)) {\n-                    toname\n-                } else {\n-                    resolvedthis\n-                }\n-            }\n-            IllegalCtxt => panic!(\"expected resolvable context, got IllegalCtxt\")\n-        }\n-    };\n-    resolve_table.insert(key, resolved);\n-    resolved\n-}\n-\n-/// Compute the marks associated with a syntax context.\n-pub fn marksof(ctxt: SyntaxContext, stopname: Name) -> Vec<Mrk> {\n-    with_sctable(|table| marksof_internal(ctxt, stopname, table))\n-}\n-\n-// the internal function for computing marks\n-// it's not clear to me whether it's better to use a [] mutable\n-// vector or a cons-list for this.\n-fn marksof_internal(ctxt: SyntaxContext,\n-                    stopname: Name,\n-                    table: &SCTable) -> Vec<Mrk> {\n-    let mut result = Vec::new();\n-    let mut loopvar = ctxt;\n-    loop {\n-        let table_entry = (*table.table.borrow())[loopvar.0 as usize];\n-        match table_entry {\n-            EmptyCtxt => {\n-                return result;\n-            },\n-            Mark(mark, tl) => {\n-                xor_push(&mut result, mark);\n-                loopvar = tl;\n-            },\n-            Rename(_,name,tl) => {\n-                // see MTWT for details on the purpose of the stopname.\n-                // short version: it prevents duplication of effort.\n-                if name == stopname {\n-                    return result;\n-                } else {\n-                    loopvar = tl;\n-                }\n-            }\n-            IllegalCtxt => panic!(\"expected resolvable context, got IllegalCtxt\")\n-        }\n+fn resolve_internal(id: Ident, table: &SCTable) -> Name {\n+    match table.table.borrow()[id.ctxt.0 as usize] {\n+        EmptyCtxt => id.name,\n+        // ignore marks here:\n+        Mark(_, subctxt) => resolve_internal(Ident::new(id.name, subctxt), table),\n+        Rename(name) => name,\n+        IllegalCtxt => panic!(\"expected resolvable context, got IllegalCtxt\")\n     }\n }\n \n@@ -267,103 +171,16 @@ pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n     })\n }\n \n-/// Push a name... unless it matches the one on top, in which\n-/// case pop and discard (so two of the same marks cancel)\n-fn xor_push(marks: &mut Vec<Mrk>, mark: Mrk) {\n-    if (!marks.is_empty()) && (*marks.last().unwrap() == mark) {\n-        marks.pop().unwrap();\n-    } else {\n-        marks.push(mark);\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n-    use self::TestSC::*;\n     use ast::{EMPTY_CTXT, Ident, Mrk, Name, SyntaxContext};\n-    use super::{resolve, xor_push, apply_mark_internal, new_sctable_internal};\n-    use super::{apply_rename_internal, apply_renames, marksof_internal, resolve_internal};\n-    use super::{SCTable, EmptyCtxt, Mark, Rename, IllegalCtxt};\n-    use std::collections::HashMap;\n-\n-    #[test]\n-    fn xorpush_test () {\n-        let mut s = Vec::new();\n-        xor_push(&mut s, 14);\n-        assert_eq!(s.clone(), [14]);\n-        xor_push(&mut s, 14);\n-        assert_eq!(s.clone(), []);\n-        xor_push(&mut s, 14);\n-        assert_eq!(s.clone(), [14]);\n-        xor_push(&mut s, 15);\n-        assert_eq!(s.clone(), [14, 15]);\n-        xor_push(&mut s, 16);\n-        assert_eq!(s.clone(), [14, 15, 16]);\n-        xor_push(&mut s, 16);\n-        assert_eq!(s.clone(), [14, 15]);\n-        xor_push(&mut s, 15);\n-        assert_eq!(s.clone(), [14]);\n-    }\n+    use super::{resolve, apply_mark_internal, new_sctable_internal};\n+    use super::{SCTable, Mark};\n \n     fn id(n: u32, s: SyntaxContext) -> Ident {\n         Ident::new(Name(n), s)\n     }\n \n-    // because of the SCTable, I now need a tidy way of\n-    // creating syntax objects. Sigh.\n-    #[derive(Clone, PartialEq, Debug)]\n-    enum TestSC {\n-        M(Mrk),\n-        R(Ident,Name)\n-    }\n-\n-    // unfold a vector of TestSC values into a SCTable,\n-    // returning the resulting index\n-    fn unfold_test_sc(tscs : Vec<TestSC> , tail: SyntaxContext, table: &SCTable)\n-        -> SyntaxContext {\n-        tscs.iter().rev().fold(tail, |tail : SyntaxContext, tsc : &TestSC|\n-                  {match *tsc {\n-                      M(mrk) => apply_mark_internal(mrk,tail,table),\n-                      R(ident,name) => apply_rename_internal(ident,name,tail,table)}})\n-    }\n-\n-    // gather a SyntaxContext back into a vector of TestSCs\n-    fn refold_test_sc(mut sc: SyntaxContext, table : &SCTable) -> Vec<TestSC> {\n-        let mut result = Vec::new();\n-        loop {\n-            let table = table.table.borrow();\n-            match (*table)[sc.0 as usize] {\n-                EmptyCtxt => {return result;},\n-                Mark(mrk,tail) => {\n-                    result.push(M(mrk));\n-                    sc = tail;\n-                    continue;\n-                },\n-                Rename(id,name,tail) => {\n-                    result.push(R(id,name));\n-                    sc = tail;\n-                    continue;\n-                }\n-                IllegalCtxt => panic!(\"expected resolvable context, got IllegalCtxt\")\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unfold_refold(){\n-        let mut t = new_sctable_internal();\n-\n-        let test_sc = vec!(M(3),R(id(101,EMPTY_CTXT),Name(14)),M(9));\n-        assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),SyntaxContext(4));\n-        {\n-            let table = t.table.borrow();\n-            assert!((*table)[2] == Mark(9,EMPTY_CTXT));\n-            assert!((*table)[3] == Rename(id(101,EMPTY_CTXT),Name(14),SyntaxContext(2)));\n-            assert!((*table)[4] == Mark(3,SyntaxContext(3)));\n-        }\n-        assert_eq!(refold_test_sc(SyntaxContext(4),&t),test_sc);\n-    }\n-\n     // extend a syntax context with a sequence of marks given\n     // in a vector. v[0] will be the outermost mark.\n     fn unfold_marks(mrks: Vec<Mrk> , tail: SyntaxContext, table: &SCTable)\n@@ -383,98 +200,12 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn test_marksof () {\n-        let stopname = Name(242);\n-        let name1 = Name(243);\n-        let mut t = new_sctable_internal();\n-        assert_eq!(marksof_internal (EMPTY_CTXT,stopname,&t),Vec::new());\n-        // FIXME #5074: ANF'd to dodge nested calls\n-        { let ans = unfold_marks(vec!(4,98),EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans,stopname,&t), [4, 98]);}\n-        // does xoring work?\n-        { let ans = unfold_marks(vec!(5,5,16),EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans,stopname,&t), [16]);}\n-        // does nested xoring work?\n-        { let ans = unfold_marks(vec!(5,10,10,5,16),EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans, stopname,&t), [16]);}\n-        // rename where stop doesn't match:\n-        { let chain = vec!(M(9),\n-                        R(id(name1.0,\n-                             apply_mark_internal (4, EMPTY_CTXT,&mut t)),\n-                          Name(100101102)),\n-                        M(14));\n-         let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans, stopname, &t), [9, 14]);}\n-        // rename where stop does match\n-        { let name1sc = apply_mark_internal(4, EMPTY_CTXT, &mut t);\n-         let chain = vec!(M(9),\n-                       R(id(name1.0, name1sc),\n-                         stopname),\n-                       M(14));\n-         let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans, stopname, &t), [9]); }\n-    }\n-\n-\n-    #[test]\n-    fn resolve_tests () {\n-        let a = 40;\n-        let mut t = new_sctable_internal();\n-        let mut rt = HashMap::new();\n-        // - ctxt is MT\n-        assert_eq!(resolve_internal(id(a,EMPTY_CTXT),&mut t, &mut rt),Name(a));\n-        // - simple ignored marks\n-        { let sc = unfold_marks(vec!(1,2,3),EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),Name(a));}\n-        // - orthogonal rename where names don't match\n-        { let sc = unfold_test_sc(vec!(R(id(50,EMPTY_CTXT),Name(51)),M(12)),EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),Name(a));}\n-        // - rename where names do match, but marks don't\n-        { let sc1 = apply_mark_internal(1,EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(vec!(R(id(a,sc1),Name(50)),\n-                                   M(1),\n-                                   M(2)),\n-                                 EMPTY_CTXT,&mut t);\n-        assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), Name(a));}\n-        // - rename where names and marks match\n-        { let sc1 = unfold_test_sc(vec!(M(1),M(2)),EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(vec!(R(id(a,sc1),Name(50)),M(1),M(2)),EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), Name(50)); }\n-        // - rename where names and marks match by literal sharing\n-        { let sc1 = unfold_test_sc(vec!(M(1),M(2)),EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(vec!(R(id(a,sc1),Name(50))),sc1,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), Name(50)); }\n-        // - two renames of the same var.. can only happen if you use\n-        // local-expand to prevent the inner binding from being renamed\n-        // during the rename-pass caused by the first:\n-        println!(\"about to run bad test\");\n-        { let sc = unfold_test_sc(vec!(R(id(a,EMPTY_CTXT),Name(50)),\n-                                    R(id(a,EMPTY_CTXT),Name(51))),\n-                                  EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), Name(51)); }\n-        // the simplest double-rename:\n-        { let a_to_a50 = apply_rename_internal(id(a,EMPTY_CTXT),Name(50),EMPTY_CTXT,&mut t);\n-         let a50_to_a51 = apply_rename_internal(id(a,a_to_a50),Name(51),a_to_a50,&mut t);\n-         assert_eq!(resolve_internal(id(a,a50_to_a51),&mut t, &mut rt),Name(51));\n-         // mark on the outside doesn't stop rename:\n-         let sc = apply_mark_internal(9,a50_to_a51,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),Name(51));\n-         // but mark on the inside does:\n-         let a50_to_a51_b = unfold_test_sc(vec!(R(id(a,a_to_a50),Name(51)),\n-                                              M(9)),\n-                                           a_to_a50,\n-                                           &mut t);\n-         assert_eq!(resolve_internal(id(a,a50_to_a51_b),&mut t, &mut rt),Name(50));}\n-    }\n-\n     #[test]\n     fn mtwt_resolve_test(){\n         let a = 40;\n         assert_eq!(resolve(id(a,EMPTY_CTXT)),Name(a));\n     }\n \n-\n     #[test]\n     fn hashing_tests () {\n         let mut t = new_sctable_internal();\n@@ -484,26 +215,4 @@ mod tests {\n         assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(2));\n         // I'm assuming that the rename table will behave the same....\n     }\n-\n-    #[test]\n-    fn resolve_table_hashing_tests() {\n-        let mut t = new_sctable_internal();\n-        let mut rt = HashMap::new();\n-        assert_eq!(rt.len(),0);\n-        resolve_internal(id(30,EMPTY_CTXT),&mut t, &mut rt);\n-        assert_eq!(rt.len(),1);\n-        resolve_internal(id(39,EMPTY_CTXT),&mut t, &mut rt);\n-        assert_eq!(rt.len(),2);\n-        resolve_internal(id(30,EMPTY_CTXT),&mut t, &mut rt);\n-        assert_eq!(rt.len(),2);\n-    }\n-\n-    #[test]\n-    fn new_resolves_test() {\n-        let renames = vec!((Ident::with_empty_ctxt(Name(23)),Name(24)),\n-                           (Ident::with_empty_ctxt(Name(29)),Name(29)));\n-        let new_ctxt1 = apply_renames(&renames,EMPTY_CTXT);\n-        assert_eq!(resolve(Ident::new(Name(23),new_ctxt1)),Name(24));\n-        assert_eq!(resolve(Ident::new(Name(29),new_ctxt1)),Name(29));\n-    }\n }"}, {"sha": "4507ba50192dd67ccae1245cebb7c3245a1a0d4d", "filename": "src/test/run-pass/hygiene.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8/src%2Ftest%2Frun-pass%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8/src%2Ftest%2Frun-pass%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene.rs?ref=4960f2f9074d0d0f9de80b39f0b0ded6547e2ad8", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+\n+fn f() {\n+    let x = 0;\n+    macro_rules! foo { () => {\n+        assert_eq!(x, 0);\n+    } }\n+\n+    let x = 1;\n+    foo!();\n+}\n+\n+fn g() {\n+    let x = 0;\n+    macro_rules! m { ($x:ident) => {\n+        macro_rules! m2 { () => { ($x, x) } }\n+        let x = 1;\n+        macro_rules! m3 { () => { ($x, x) } }\n+    } }\n+\n+    let x = 2;\n+    m!(x);\n+\n+    let x = 3;\n+    assert_eq!(m2!(), (2, 0));\n+    assert_eq!(m3!(), (2, 1));\n+\n+    let x = 4;\n+    m!(x);\n+    assert_eq!(m2!(), (4, 0));\n+    assert_eq!(m3!(), (4, 1));\n+}\n+\n+mod foo {\n+    macro_rules! m {\n+        ($f:ident : |$x:ident| $e:expr) => {\n+            pub fn $f() -> (i32, i32) {\n+                let x = 0;\n+                let $x = 1;\n+                (x, $e)\n+            }\n+        }\n+    }\n+\n+    m!(f: |x| x + 10);\n+}\n+\n+fn interpolated_pattern() {\n+    let x = 0;\n+    macro_rules! m {\n+        ($p:pat, $e:expr) => {\n+            let $p = 1;\n+            assert_eq!((x, $e), (0, 1));\n+        }\n+    }\n+\n+    m!(x, x);\n+}\n+\n+fn patterns_in_macro_generated_macros() {\n+    let x = 0;\n+    macro_rules! m {\n+        ($a:expr, $b:expr) => {\n+            assert_eq!(x, 0);\n+            let x = $a;\n+            macro_rules! n {\n+                () => {\n+                    (x, $b)\n+                }\n+            }\n+        }\n+    }\n+\n+    let x = 1;\n+    m!(2, x);\n+\n+    let x = 3;\n+    assert_eq!(n!(), (2, 1));\n+}\n+\n+fn match_hygiene() {\n+    let x = 0;\n+\n+    macro_rules! m {\n+        ($p:pat, $e:expr) => {\n+            for result in &[Ok(1), Err(1)] {\n+                match *result {\n+                    $p => { assert_eq!(($e, x), (1, 0)); }\n+                    Err(x) => { assert_eq!(($e, x), (2, 1)); }\n+                }\n+            }\n+        }\n+    }\n+\n+    let x = 2;\n+    m!(Ok(x), x);\n+}\n+\n+fn main() {\n+    f();\n+    g();\n+    assert_eq!(foo::f(), (0, 11));\n+    interpolated_pattern();\n+    patterns_in_macro_generated_macros();\n+    match_hygiene();\n+}"}]}