{"sha": "03017003c77d782cf7ed841a05d7c628a9b93f25", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMDE3MDAzYzc3ZDc4MmNmN2VkODQxYTA1ZDdjNjI4YTliOTNmMjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-24T12:54:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-24T12:54:39Z"}, "message": "Auto merge of #74590 - jyn514:timing, r=Mark-Simulacrum\n\nAdd some timing info to rustdoc\n\nThere are various improvements, but the main one is to time each pass\nthat rustdoc performs (`rustdoc::passes`).\n\nBefore, these were the top five timings for `cargo doc` on the cargo\nrepository:\n\n```\n+---------------------------------+-----------+-----------------+----------+------------+\n| Item                            | Self time | % of total time | Time     | Item count |\n+---------------------------------+-----------+-----------------+----------+------------+\n| <unknown>                       | 854.70ms  | 20.888          | 2.47s    | 744823     |\n+---------------------------------+-----------+-----------------+----------+------------+\n| expand_crate                    | 795.29ms  | 19.436          | 848.00ms | 1          |\n+---------------------------------+-----------+-----------------+----------+------------+\n| metadata_decode_entry           | 256.73ms  | 6.274           | 279.49ms | 518344     |\n+---------------------------------+-----------+-----------------+----------+------------+\n| resolve_crate                   | 240.56ms  | 5.879           | 242.86ms | 1          |\n+---------------------------------+-----------+-----------------+----------+------------+\n| hir_lowering                    | 146.79ms  | 3.587           | 146.79ms | 1          |\n+---------------------------------+-----------+-----------------+----------+------------+\n```\n\nNow the timings are:\n\n```\n+---------------------------------+-----------+-----------------+----------+------------+\n| Item                            | Self time | % of total time | Time     | Item count |\n+---------------------------------+-----------+-----------------+----------+------------+\n| <unknown>                       | 1.40s     | 22.662          | 3.73s    | 771430     |\n+---------------------------------+-----------+-----------------+----------+------------+\n| collect-trait-impls             | 1.34s     | 21.672          | 2.87s    | 1          |\n+---------------------------------+-----------+-----------------+----------+------------+\n| expand_crate                    | 1.21s     | 19.577          | 1.28s    | 1          |\n+---------------------------------+-----------+-----------------+----------+------------+\n| build extern trait impl         | 704.66ms  | 11.427          | 1.07s    | 21893      |\n+---------------------------------+-----------+-----------------+----------+------------+\n| metadata_decode_entry           | 354.84ms  | 5.754           | 391.81ms | 544919     |\n+---------------------------------+-----------+-----------------+----------+------------+\n```\n\nThe goal is to help me debug regressions like https://github.com/rust-lang/rust/pull/74518#issuecomment-661498214 (currently I have _no_ idea what could have gone wrong).\n\nr? @eddyb or @Mark-Simulacrum", "tree": {"sha": "c8aa266079d483681ce6bafa9f0b05d17cd6b221", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8aa266079d483681ce6bafa9f0b05d17cd6b221"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03017003c77d782cf7ed841a05d7c628a9b93f25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03017003c77d782cf7ed841a05d7c628a9b93f25", "html_url": "https://github.com/rust-lang/rust/commit/03017003c77d782cf7ed841a05d7c628a9b93f25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03017003c77d782cf7ed841a05d7c628a9b93f25/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa7010df9027c5c346ab32b3a7fefca06365856f", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa7010df9027c5c346ab32b3a7fefca06365856f", "html_url": "https://github.com/rust-lang/rust/commit/aa7010df9027c5c346ab32b3a7fefca06365856f"}, {"sha": "6e3e74dd719334e84edd70ba0a842f5d4f94d266", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e3e74dd719334e84edd70ba0a842f5d4f94d266", "html_url": "https://github.com/rust-lang/rust/commit/6e3e74dd719334e84edd70ba0a842f5d4f94d266"}], "stats": {"total": 402, "additions": 216, "deletions": 186}, "files": [{"sha": "7a0cf3717c93f77a1476a9ab975ca447da8e6963", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 205, "deletions": 179, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/03017003c77d782cf7ed841a05d7c628a9b93f25/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03017003c77d782cf7ed841a05d7c628a9b93f25/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=03017003c77d782cf7ed841a05d7c628a9b93f25", "patch": "@@ -32,8 +32,8 @@ use std::rc::Rc;\n \n use crate::clean;\n use crate::clean::{AttributesExt, MAX_DEF_ID};\n-use crate::config::RenderInfo;\n use crate::config::{Options as RustdocOptions, RenderOptions};\n+use crate::config::{OutputFormat, RenderInfo};\n use crate::passes::{self, Condition::*, ConditionalPass};\n \n pub use rustc_session::config::{CodegenOptions, DebuggingOptions, Input, Options};\n@@ -280,7 +280,9 @@ where\n     (lint_opts, lint_caps)\n }\n \n-pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOptions) {\n+pub fn run_core(\n+    options: RustdocOptions,\n+) -> (clean::Crate, RenderInfo, RenderOptions, Lrc<Session>) {\n     // Parse, resolve, and typecheck the given crate.\n \n     let RustdocOptions {\n@@ -299,8 +301,8 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         lint_opts,\n         describe_lints,\n         lint_cap,\n-        mut default_passes,\n-        mut manual_passes,\n+        default_passes,\n+        manual_passes,\n         display_warnings,\n         render_options,\n         output_format,\n@@ -407,7 +409,9 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                 let hir = tcx.hir();\n                 let body = hir.body(hir.body_owned_by(hir.local_def_id_to_hir_id(def_id)));\n                 debug!(\"visiting body for {:?}\", def_id);\n-                EmitIgnoredResolutionErrors::new(tcx).visit_body(body);\n+                tcx.sess.time(\"emit_ignored_resolution_errors\", || {\n+                    EmitIgnoredResolutionErrors::new(tcx).visit_body(body);\n+                });\n                 (rustc_interface::DEFAULT_QUERY_PROVIDERS.typeck)(tcx, def_id)\n             };\n         }),\n@@ -429,18 +433,20 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                 // actually be loaded, just in case they're only referred to inside\n                 // intra-doc-links\n                 resolver.borrow_mut().access(|resolver| {\n-                    for extern_name in &extern_names {\n-                        resolver\n-                            .resolve_str_path_error(\n-                                DUMMY_SP,\n-                                extern_name,\n-                                TypeNS,\n-                                LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id(),\n-                            )\n-                            .unwrap_or_else(|()| {\n-                                panic!(\"Unable to resolve external crate {}\", extern_name)\n-                            });\n-                    }\n+                    sess.time(\"load_extern_crates\", || {\n+                        for extern_name in &extern_names {\n+                            resolver\n+                                .resolve_str_path_error(\n+                                    DUMMY_SP,\n+                                    extern_name,\n+                                    TypeNS,\n+                                    LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id(),\n+                                )\n+                                .unwrap_or_else(|()| {\n+                                    panic!(\"Unable to resolve external crate {}\", extern_name)\n+                                });\n+                        }\n+                    });\n                 });\n \n                 // Now we're good to clone the resolver because everything should be loaded\n@@ -453,181 +459,201 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n             let mut global_ctxt = abort_on_err(queries.global_ctxt(), sess).take();\n \n-            global_ctxt.enter(|tcx| {\n-                // Certain queries assume that some checks were run elsewhere\n-                // (see https://github.com/rust-lang/rust/pull/73566#issuecomment-656954425),\n-                // so type-check everything other than function bodies in this crate before running lints.\n+            let (krate, render_info, opts) = sess.time(\"run_global_ctxt\", || {\n+                global_ctxt.enter(|tcx| {\n+                    run_global_ctxt(\n+                        tcx,\n+                        resolver,\n+                        default_passes,\n+                        manual_passes,\n+                        render_options,\n+                        output_format,\n+                    )\n+                })\n+            });\n+            (krate, render_info, opts, Lrc::clone(sess))\n+        })\n+    })\n+}\n \n-                // NOTE: this does not call `tcx.analysis()` so that we won't\n-                // typeck function bodies or run the default rustc lints.\n-                // (see `override_queries` in the `config`)\n+fn run_global_ctxt(\n+    tcx: TyCtxt<'_>,\n+    resolver: Rc<RefCell<interface::BoxedResolver>>,\n+    mut default_passes: passes::DefaultPassOption,\n+    mut manual_passes: Vec<String>,\n+    render_options: RenderOptions,\n+    output_format: Option<OutputFormat>,\n+) -> (clean::Crate, RenderInfo, RenderOptions) {\n+    // Certain queries assume that some checks were run elsewhere\n+    // (see https://github.com/rust-lang/rust/pull/73566#issuecomment-656954425),\n+    // so type-check everything other than function bodies in this crate before running lints.\n+\n+    // NOTE: this does not call `tcx.analysis()` so that we won't\n+    // typeck function bodies or run the default rustc lints.\n+    // (see `override_queries` in the `config`)\n+\n+    // HACK(jynelson) this calls an _extremely_ limited subset of `typeck`\n+    // and might break if queries change their assumptions in the future.\n+\n+    // NOTE: This is copy/pasted from typeck/lib.rs and should be kept in sync with those changes.\n+    tcx.sess.time(\"item_types_checking\", || {\n+        for &module in tcx.hir().krate().modules.keys() {\n+            tcx.ensure().check_mod_item_types(tcx.hir().local_def_id(module));\n+        }\n+    });\n+    tcx.sess.abort_if_errors();\n+    tcx.sess.time(\"missing_docs\", || {\n+        rustc_lint::check_crate(tcx, rustc_lint::builtin::MissingDoc::new);\n+    });\n+    tcx.sess.time(\"check_mod_attrs\", || {\n+        for &module in tcx.hir().krate().modules.keys() {\n+            let local_def_id = tcx.hir().local_def_id(module);\n+            tcx.ensure().check_mod_attrs(local_def_id);\n+        }\n+    });\n \n-                // HACK(jynelson) this calls an _extremely_ limited subset of `typeck`\n-                // and might break if queries change their assumptions in the future.\n+    let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);\n+    // Convert from a HirId set to a DefId set since we don't always have easy access\n+    // to the map from defid -> hirid\n+    let access_levels = AccessLevels {\n+        map: access_levels\n+            .map\n+            .iter()\n+            .map(|(&k, &v)| (tcx.hir().local_def_id(k).to_def_id(), v))\n+            .collect(),\n+    };\n \n-                // NOTE: This is copy/pasted from typeck/lib.rs and should be kept in sync with those changes.\n-                tcx.sess.time(\"item_types_checking\", || {\n-                    for &module in tcx.hir().krate().modules.keys() {\n-                        tcx.ensure().check_mod_item_types(tcx.hir().local_def_id(module));\n-                    }\n-                });\n-                tcx.sess.abort_if_errors();\n-                sess.time(\"missing_docs\", || {\n-                    rustc_lint::check_crate(tcx, rustc_lint::builtin::MissingDoc::new);\n-                });\n-                for &module in tcx.hir().krate().modules.keys() {\n-                    let local_def_id = tcx.hir().local_def_id(module);\n-                    tcx.ensure().check_mod_attrs(local_def_id);\n-                }\n+    let mut renderinfo = RenderInfo::default();\n+    renderinfo.access_levels = access_levels;\n+    renderinfo.output_format = output_format;\n+\n+    let mut ctxt = DocContext {\n+        tcx,\n+        resolver,\n+        external_traits: Default::default(),\n+        active_extern_traits: Default::default(),\n+        renderinfo: RefCell::new(renderinfo),\n+        ty_substs: Default::default(),\n+        lt_substs: Default::default(),\n+        ct_substs: Default::default(),\n+        impl_trait_bounds: Default::default(),\n+        fake_def_ids: Default::default(),\n+        all_fake_def_ids: Default::default(),\n+        generated_synthetics: Default::default(),\n+        auto_traits: tcx\n+            .all_traits(LOCAL_CRATE)\n+            .iter()\n+            .cloned()\n+            .filter(|trait_def_id| tcx.trait_is_auto(*trait_def_id))\n+            .collect(),\n+        render_options,\n+        module_trait_cache: RefCell::new(FxHashMap::default()),\n+    };\n+    debug!(\"crate: {:?}\", tcx.hir().krate());\n+\n+    let mut krate = tcx.sess.time(\"clean_crate\", || clean::krate(&mut ctxt));\n+\n+    if let Some(ref m) = krate.module {\n+        if let None | Some(\"\") = m.doc_value() {\n+            let help = \"The following guide may be of use:\\n\\\n+                    https://doc.rust-lang.org/nightly/rustdoc/how-to-write-documentation\\\n+                    .html\";\n+            tcx.struct_lint_node(\n+                rustc_lint::builtin::MISSING_CRATE_LEVEL_DOCS,\n+                ctxt.as_local_hir_id(m.def_id).unwrap(),\n+                |lint| {\n+                    let mut diag =\n+                        lint.build(\"no documentation found for this crate's top-level module\");\n+                    diag.help(help);\n+                    diag.emit();\n+                },\n+            );\n+        }\n+    }\n \n-                let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);\n-                // Convert from a HirId set to a DefId set since we don't always have easy access\n-                // to the map from defid -> hirid\n-                let access_levels = AccessLevels {\n-                    map: access_levels\n-                        .map\n-                        .iter()\n-                        .map(|(&k, &v)| (tcx.hir().local_def_id(k).to_def_id(), v))\n-                        .collect(),\n-                };\n-\n-                let mut renderinfo = RenderInfo::default();\n-                renderinfo.access_levels = access_levels;\n-                renderinfo.output_format = output_format;\n-\n-                let mut ctxt = DocContext {\n-                    tcx,\n-                    resolver,\n-                    external_traits: Default::default(),\n-                    active_extern_traits: Default::default(),\n-                    renderinfo: RefCell::new(renderinfo),\n-                    ty_substs: Default::default(),\n-                    lt_substs: Default::default(),\n-                    ct_substs: Default::default(),\n-                    impl_trait_bounds: Default::default(),\n-                    fake_def_ids: Default::default(),\n-                    all_fake_def_ids: Default::default(),\n-                    generated_synthetics: Default::default(),\n-                    auto_traits: tcx\n-                        .all_traits(LOCAL_CRATE)\n-                        .iter()\n-                        .cloned()\n-                        .filter(|trait_def_id| tcx.trait_is_auto(*trait_def_id))\n-                        .collect(),\n-                    render_options,\n-                    module_trait_cache: RefCell::new(FxHashMap::default()),\n-                };\n-                debug!(\"crate: {:?}\", tcx.hir().krate());\n-\n-                let mut krate = clean::krate(&mut ctxt);\n-\n-                if let Some(ref m) = krate.module {\n-                    if let None | Some(\"\") = m.doc_value() {\n-                        let help = \"The following guide may be of use:\\n\\\n-                             https://doc.rust-lang.org/nightly/rustdoc/how-to-write-documentation\\\n-                             .html\";\n-                        tcx.struct_lint_node(\n-                            rustc_lint::builtin::MISSING_CRATE_LEVEL_DOCS,\n-                            ctxt.as_local_hir_id(m.def_id).unwrap(),\n-                            |lint| {\n-                                let mut diag = lint.build(\n-                                    \"no documentation found for this crate's top-level module\",\n-                                );\n-                                diag.help(help);\n-                                diag.emit();\n-                            },\n-                        );\n-                    }\n-                }\n+    fn report_deprecated_attr(name: &str, diag: &rustc_errors::Handler) {\n+        let mut msg = diag\n+            .struct_warn(&format!(\"the `#![doc({})]` attribute is considered deprecated\", name));\n+        msg.warn(\n+            \"see issue #44136 <https://github.com/rust-lang/rust/issues/44136> \\\n+                for more information\",\n+        );\n \n-                fn report_deprecated_attr(name: &str, diag: &rustc_errors::Handler) {\n-                    let mut msg = diag.struct_warn(&format!(\n-                        \"the `#![doc({})]` attribute is considered deprecated\",\n-                        name\n-                    ));\n-                    msg.warn(\n-                        \"see issue #44136 <https://github.com/rust-lang/rust/issues/44136> \\\n-                         for more information\",\n-                    );\n+        if name == \"no_default_passes\" {\n+            msg.help(\"you may want to use `#![doc(document_private_items)]`\");\n+        }\n \n-                    if name == \"no_default_passes\" {\n-                        msg.help(\"you may want to use `#![doc(document_private_items)]`\");\n-                    }\n+        msg.emit();\n+    }\n \n-                    msg.emit();\n+    // Process all of the crate attributes, extracting plugin metadata along\n+    // with the passes which we are supposed to run.\n+    for attr in krate.module.as_ref().unwrap().attrs.lists(sym::doc) {\n+        let diag = ctxt.sess().diagnostic();\n+\n+        let name = attr.name_or_empty();\n+        if attr.is_word() {\n+            if name == sym::no_default_passes {\n+                report_deprecated_attr(\"no_default_passes\", diag);\n+                if default_passes == passes::DefaultPassOption::Default {\n+                    default_passes = passes::DefaultPassOption::None;\n+                }\n+            }\n+        } else if let Some(value) = attr.value_str() {\n+            let sink = match name {\n+                sym::passes => {\n+                    report_deprecated_attr(\"passes = \\\"...\\\"\", diag);\n+                    &mut manual_passes\n                 }\n+                sym::plugins => {\n+                    report_deprecated_attr(\"plugins = \\\"...\\\"\", diag);\n+                    eprintln!(\n+                        \"WARNING: `#![doc(plugins = \\\"...\\\")]` \\\n+                            no longer functions; see CVE-2018-1000622\"\n+                    );\n+                    continue;\n+                }\n+                _ => continue,\n+            };\n+            for name in value.as_str().split_whitespace() {\n+                sink.push(name.to_string());\n+            }\n+        }\n \n-                // Process all of the crate attributes, extracting plugin metadata along\n-                // with the passes which we are supposed to run.\n-                for attr in krate.module.as_ref().unwrap().attrs.lists(sym::doc) {\n-                    let diag = ctxt.sess().diagnostic();\n-\n-                    let name = attr.name_or_empty();\n-                    if attr.is_word() {\n-                        if name == sym::no_default_passes {\n-                            report_deprecated_attr(\"no_default_passes\", diag);\n-                            if default_passes == passes::DefaultPassOption::Default {\n-                                default_passes = passes::DefaultPassOption::None;\n-                            }\n-                        }\n-                    } else if let Some(value) = attr.value_str() {\n-                        let sink = match name {\n-                            sym::passes => {\n-                                report_deprecated_attr(\"passes = \\\"...\\\"\", diag);\n-                                &mut manual_passes\n-                            }\n-                            sym::plugins => {\n-                                report_deprecated_attr(\"plugins = \\\"...\\\"\", diag);\n-                                eprintln!(\n-                                    \"WARNING: `#![doc(plugins = \\\"...\\\")]` \\\n-                                      no longer functions; see CVE-2018-1000622\"\n-                                );\n-                                continue;\n-                            }\n-                            _ => continue,\n-                        };\n-                        for name in value.as_str().split_whitespace() {\n-                            sink.push(name.to_string());\n-                        }\n-                    }\n+        if attr.is_word() && name == sym::document_private_items {\n+            ctxt.render_options.document_private = true;\n+        }\n+    }\n \n-                    if attr.is_word() && name == sym::document_private_items {\n-                        ctxt.render_options.document_private = true;\n-                    }\n-                }\n+    let passes = passes::defaults(default_passes).iter().copied().chain(\n+        manual_passes.into_iter().flat_map(|name| {\n+            if let Some(pass) = passes::find_pass(&name) {\n+                Some(ConditionalPass::always(pass))\n+            } else {\n+                error!(\"unknown pass {}, skipping\", name);\n+                None\n+            }\n+        }),\n+    );\n \n-                let passes = passes::defaults(default_passes).iter().copied().chain(\n-                    manual_passes.into_iter().flat_map(|name| {\n-                        if let Some(pass) = passes::find_pass(&name) {\n-                            Some(ConditionalPass::always(pass))\n-                        } else {\n-                            error!(\"unknown pass {}, skipping\", name);\n-                            None\n-                        }\n-                    }),\n-                );\n-\n-                info!(\"Executing passes\");\n-\n-                for p in passes {\n-                    let run = match p.condition {\n-                        Always => true,\n-                        WhenDocumentPrivate => ctxt.render_options.document_private,\n-                        WhenNotDocumentPrivate => !ctxt.render_options.document_private,\n-                        WhenNotDocumentHidden => !ctxt.render_options.document_hidden,\n-                    };\n-                    if run {\n-                        debug!(\"running pass {}\", p.pass.name);\n-                        krate = (p.pass.run)(krate, &ctxt);\n-                    }\n-                }\n+    info!(\"Executing passes\");\n \n-                ctxt.sess().abort_if_errors();\n+    for p in passes {\n+        let run = match p.condition {\n+            Always => true,\n+            WhenDocumentPrivate => ctxt.render_options.document_private,\n+            WhenNotDocumentPrivate => !ctxt.render_options.document_private,\n+            WhenNotDocumentHidden => !ctxt.render_options.document_hidden,\n+        };\n+        if run {\n+            debug!(\"running pass {}\", p.pass.name);\n+            krate = ctxt.tcx.sess.time(p.pass.name, || (p.pass.run)(krate, &ctxt));\n+        }\n+    }\n \n-                (krate, ctxt.renderinfo.into_inner(), ctxt.render_options)\n-            })\n-        })\n-    })\n+    ctxt.sess().abort_if_errors();\n+\n+    (krate, ctxt.renderinfo.into_inner(), ctxt.render_options)\n }\n \n /// Due to https://github.com/rust-lang/rust/pull/73566,"}, {"sha": "6d79924a06b5b93dc23d6099b25c56330e7c9982", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/03017003c77d782cf7ed841a05d7c628a9b93f25/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03017003c77d782cf7ed841a05d7c628a9b93f25/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=03017003c77d782cf7ed841a05d7c628a9b93f25", "patch": "@@ -501,7 +501,7 @@ fn main_options(options: config::Options) -> MainResult {\n     let crate_name = options.crate_name.clone();\n     let crate_version = options.crate_version.clone();\n     let output_format = options.output_format;\n-    let (mut krate, renderinfo, renderopts) = core::run_core(options);\n+    let (mut krate, renderinfo, renderopts, sess) = core::run_core(options);\n \n     info!(\"finished with rustc\");\n \n@@ -524,11 +524,11 @@ fn main_options(options: config::Options) -> MainResult {\n     let (error_format, edition, debugging_options) = diag_opts;\n     let diag = core::new_handler(error_format, None, &debugging_options);\n     match output_format {\n-        None | Some(config::OutputFormat::Html) => {\n+        None | Some(config::OutputFormat::Html) => sess.time(\"render_html\", || {\n             run_renderer::<html::render::Context>(krate, renderopts, renderinfo, &diag, edition)\n-        }\n-        Some(config::OutputFormat::Json) => {\n+        }),\n+        Some(config::OutputFormat::Json) => sess.time(\"render_json\", || {\n             run_renderer::<json::JsonRenderer>(krate, renderopts, renderinfo, &diag, edition)\n-        }\n+        }),\n     }\n }"}, {"sha": "b2c4c30d8ff089f17f1797d95315eb557e492051", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03017003c77d782cf7ed841a05d7c628a9b93f25/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03017003c77d782cf7ed841a05d7c628a9b93f25/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=03017003c77d782cf7ed841a05d7c628a9b93f25", "patch": "@@ -29,7 +29,9 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n \n     for &cnum in cx.tcx.crates().iter() {\n         for &(did, _) in cx.tcx.all_trait_implementations(cnum).iter() {\n-            inline::build_impl(cx, did, None, &mut new_items);\n+            cx.tcx.sess.time(\"build_extern_trait_impl\", || {\n+                inline::build_impl(cx, did, None, &mut new_items);\n+            });\n         }\n     }\n \n@@ -87,7 +89,9 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     for &trait_did in cx.tcx.all_traits(LOCAL_CRATE).iter() {\n         for &impl_node in cx.tcx.hir().trait_impls(trait_did) {\n             let impl_did = cx.tcx.hir().local_def_id(impl_node);\n-            inline::build_impl(cx, impl_did.to_def_id(), None, &mut new_items);\n+            cx.tcx.sess.time(\"build_local_trait_impl\", || {\n+                inline::build_impl(cx, impl_did.to_def_id(), None, &mut new_items);\n+            });\n         }\n     }\n "}]}