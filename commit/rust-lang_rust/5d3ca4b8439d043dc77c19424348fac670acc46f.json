{"sha": "5d3ca4b8439d043dc77c19424348fac670acc46f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkM2NhNGI4NDM5ZDA0M2RjNzdjMTk0MjQzNDhmYWM2NzBhY2M0NmY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-26T02:03:12Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-06-26T02:32:00Z"}, "message": "Merge remote-tracking branch 'mozilla/master' into incoming\n\nConflicts:\n\tsrc/librustc/middle/astencode.rs\n\tsrc/librustc/middle/check_const.rs", "tree": {"sha": "32ce48a428a42a09b93950a6d91f327a132b2214", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32ce48a428a42a09b93950a6d91f327a132b2214"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d3ca4b8439d043dc77c19424348fac670acc46f", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d3ca4b8439d043dc77c19424348fac670acc46f", "html_url": "https://github.com/rust-lang/rust/commit/5d3ca4b8439d043dc77c19424348fac670acc46f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d3ca4b8439d043dc77c19424348fac670acc46f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c06ee9f7a7fe1ad311c9fd0eb57e00646297cdbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c06ee9f7a7fe1ad311c9fd0eb57e00646297cdbd", "html_url": "https://github.com/rust-lang/rust/commit/c06ee9f7a7fe1ad311c9fd0eb57e00646297cdbd"}, {"sha": "efd1438770ae371406327304cb6ad4501db256ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/efd1438770ae371406327304cb6ad4501db256ae", "html_url": "https://github.com/rust-lang/rust/commit/efd1438770ae371406327304cb6ad4501db256ae"}], "stats": {"total": 3837, "additions": 2265, "deletions": 1572}, "files": [{"sha": "fa6c7806581352fa216bb1d92fae6e5988a78af4", "filename": "Makefile.in", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -239,29 +239,29 @@ $(foreach target,$(CFG_TARGET_TRIPLES),\\\n # Standard library variables\n ######################################################################\n \n-STDLIB_CRATE := $(S)src/libstd/core.rc\n+STDLIB_CRATE := $(S)src/libstd/std.rs\n STDLIB_INPUTS := $(wildcard $(addprefix $(S)src/libstd/,        \\\n-                                           core.rc *.rs */*.rs */*/*rs */*/*/*rs))\n+                                           *.rs */*.rs */*/*rs */*/*/*rs))\n \n ######################################################################\n # Extra library variables\n ######################################################################\n \n-EXTRALIB_CRATE := $(S)src/libextra/std.rc\n+EXTRALIB_CRATE := $(S)src/libextra/extra.rs\n EXTRALIB_INPUTS := $(wildcard $(addprefix $(S)src/libextra/,          \\\n-                                          std.rc *.rs */*.rs))\n+                                          *.rs */*.rs))\n \n ######################################################################\n # rustc crate variables\n ######################################################################\n \n-COMPILER_CRATE := $(S)src/librustc/rustc.rc\n+COMPILER_CRATE := $(S)src/librustc/rustc.rs\n COMPILER_INPUTS := $(wildcard $(addprefix $(S)src/librustc/,      \\\n-                           rustc.rc *.rs */*.rs */*/*.rs */*/*/*.rs))\n+                           *.rs */*.rs */*/*.rs */*/*/*.rs))\n \n-LIBSYNTAX_CRATE := $(S)src/libsyntax/syntax.rc\n+LIBSYNTAX_CRATE := $(S)src/libsyntax/syntax.rs\n LIBSYNTAX_INPUTS := $(wildcard $(addprefix $(S)src/libsyntax/, \\\n-                            syntax.rc *.rs */*.rs */*/*.rs))\n+                           *.rs */*.rs */*/*.rs))\n \n DRIVER_CRATE := $(S)src/driver/driver.rs\n "}, {"sha": "9e54622688b04b9db66cc295c8e8075f3b39d1c1", "filename": "doc/tutorial.md", "status": "modified", "additions": 44, "deletions": 13, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -1552,13 +1552,6 @@ fn each(v: &[int], op: &fn(v: &int)) {\n }\n ~~~~\n \n-As an aside, the reason we pass in a *pointer* to an integer rather\n-than the integer itself is that this is how the actual `each()`\n-function for vectors works. `vec::each` though is a\n-[generic](#generics) function, so must be efficient to use for all\n-types. Passing the elements by pointer avoids copying potentially\n-large objects.\n-\n As a caller, if we use a closure to provide the final operator\n argument, we can write it in a way that has a pleasant, block-like\n structure.\n@@ -1616,6 +1609,9 @@ To enable `debug!` logging, set the RUST_LOG environment variable to the name of\n \n ## For loops\n \n+> ***Note:*** The closure-based protocol used `for` loop is on the way out. The `for` loop will\n+> use iterator objects in the future instead.\n+\n The most common way to express iteration in Rust is with a `for`\n loop. Like `do`, `for` is a nice syntax for describing control flow\n with closures.  Additionally, within a `for` loop, `break`, `loop`,\n@@ -1640,7 +1636,16 @@ fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n And using this function to iterate over a vector:\n \n ~~~~\n-# use each = std::vec::each;\n+# fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n+#    let mut n = 0;\n+#    while n < v.len() {\n+#        if !op(&v[n]) {\n+#            return false;\n+#        }\n+#        n += 1;\n+#    }\n+#    return true;\n+# }\n each([2, 4, 8, 5, 16], |n| {\n     if *n % 2 != 0 {\n         println(\"found odd number!\");\n@@ -1656,7 +1661,16 @@ out of the loop, you just write `break`. To skip ahead\n to the next iteration, write `loop`.\n \n ~~~~\n-# use each = std::vec::each;\n+# fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n+#    let mut n = 0;\n+#    while n < v.len() {\n+#        if !op(&v[n]) {\n+#            return false;\n+#        }\n+#        n += 1;\n+#    }\n+#    return true;\n+# }\n for each([2, 4, 8, 5, 16]) |n| {\n     if *n % 2 != 0 {\n         println(\"found odd number!\");\n@@ -1671,7 +1685,16 @@ normally allowed in closures, in a block that appears as the body of a\n the enclosing function, not just the loop body.\n \n ~~~~\n-# use each = std::vec::each;\n+# fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n+#    let mut n = 0;\n+#    while n < v.len() {\n+#        if !op(&v[n]) {\n+#            return false;\n+#        }\n+#        n += 1;\n+#    }\n+#    return true;\n+# }\n fn contains(v: &[int], elt: int) -> bool {\n     for each(v) |x| {\n         if (*x == elt) { return true; }\n@@ -1686,7 +1709,16 @@ In these situations it can be convenient to lean on Rust's\n argument patterns to bind `x` to the actual value, not the pointer.\n \n ~~~~\n-# use each = std::vec::each;\n+# fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n+#    let mut n = 0;\n+#    while n < v.len() {\n+#        if !op(&v[n]) {\n+#            return false;\n+#        }\n+#        n += 1;\n+#    }\n+#    return true;\n+# }\n # fn contains(v: &[int], elt: int) -> bool {\n     for each(v) |&x| {\n         if (x == elt) { return true; }\n@@ -1841,10 +1873,9 @@ vector consisting of the result of applying `function` to each element\n of `vector`:\n \n ~~~~\n-# use std::vec;\n fn map<T, U>(vector: &[T], function: &fn(v: &T) -> U) -> ~[U] {\n     let mut accumulator = ~[];\n-    for vec::each(vector) |element| {\n+    for vector.iter().advance |element| {\n         accumulator.push(function(element));\n     }\n     return accumulator;"}, {"sha": "7b50441b3c7f2f4a483649f651f031c5aae2c5be", "filename": "mk/tools.mk", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/mk%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/mk%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftools.mk?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -12,23 +12,23 @@\n # and host architectures\n \n # The test runner that runs the cfail/rfail/rpass and bxench tests\n-COMPILETEST_CRATE := $(S)src/compiletest/compiletest.rc\n-COMPILETEST_INPUTS := $(wildcard $(S)src/compiletest/*rs)\n+COMPILETEST_CRATE := $(S)src/compiletest/compiletest.rs\n+COMPILETEST_INPUTS := $(wildcard $(S)src/compiletest/*.rs)\n \n # Rustpkg, the package manager and build system\n-RUSTPKG_LIB := $(S)src/librustpkg/rustpkg.rc\n-RUSTPKG_INPUTS := $(wildcard $(S)src/librustpkg/*rs)\n+RUSTPKG_LIB := $(S)src/librustpkg/rustpkg.rs\n+RUSTPKG_INPUTS := $(wildcard $(S)src/librustpkg/*.rs)\n \n # Rustdoc, the documentation tool\n-RUSTDOC_LIB := $(S)src/librustdoc/rustdoc.rc\n+RUSTDOC_LIB := $(S)src/librustdoc/rustdoc.rs\n RUSTDOC_INPUTS := $(wildcard $(S)src/librustdoc/*.rs)\n \n # Rusti, the JIT REPL\n-RUSTI_LIB := $(S)src/librusti/rusti.rc\n+RUSTI_LIB := $(S)src/librusti/rusti.rs\n RUSTI_INPUTS := $(wildcard $(S)src/librusti/*.rs)\n \n # Rust, the convenience tool\n-RUST_LIB := $(S)src/librust/rust.rc\n+RUST_LIB := $(S)src/librust/rust.rs\n RUST_INPUTS := $(wildcard $(S)src/librust/*.rs)\n \n # FIXME: These are only built for the host arch. Eventually we'll"}, {"sha": "527e472b0b7be868d4d14d58817a619516119753", "filename": "src/compiletest/compiletest.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "previous_filename": "src/compiletest/compiletest.rc"}, {"sha": "3e2f484ee53d4e1007129afceb381de14b66a316", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -529,7 +529,7 @@ fn compose_and_run_compiler(\n     let extra_link_args = ~[~\"-L\",\n                             aux_output_dir_name(config, testfile).to_str()];\n \n-    for vec::each(props.aux_builds) |rel_ab| {\n+    for props.aux_builds.iter().advance |rel_ab| {\n         let abs_ab = config.aux_base.push_rel(&Path(*rel_ab));\n         let aux_args =\n             make_compile_args(config, props, ~[~\"--lib\"] + extra_link_args,"}, {"sha": "d1fe08b2e877eee97b18fa56ca85735b2373b73a", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -521,6 +521,7 @@ mod tests {\n     use core::cell::Cell;\n     use core::comm;\n     use core::task;\n+    use core::uint;\n \n     #[test]\n     fn manually_share_arc() {\n@@ -790,18 +791,20 @@ mod tests {\n                 }\n                 assert_eq!(*state, 42);\n                 *state = 31337;\n+                // FIXME: #7372: hits type inference bug with iterators\n                 // send to other readers\n-                for vec::each(reader_convos) |x| {\n-                    match *x {\n+                for uint::range(0, reader_convos.len()) |i| {\n+                    match reader_convos[i] {\n                         (ref rc, _) => rc.send(()),\n                     }\n                 }\n             }\n             let read_mode = arc.downgrade(write_mode);\n             do (&read_mode).read |state| {\n+                // FIXME: #7372: hits type inference bug with iterators\n                 // complete handshake with other readers\n-                for vec::each(reader_convos) |x| {\n-                    match *x {\n+                for uint::range(0, reader_convos.len()) |i| {\n+                    match reader_convos[i] {\n                         (_, ref rp) => rp.recv(),\n                     }\n                 }"}, {"sha": "4d37c244b139f1792d68ded917036da4b44beb09", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -41,30 +41,21 @@ use list::{MutList, MutCons, MutNil};\n use core::at_vec;\n use core::cast::{transmute, transmute_mut, transmute_mut_region};\n use core::cast;\n-use core::libc::size_t;\n use core::ptr;\n-use core::sys::TypeDesc;\n use core::sys;\n use core::uint;\n use core::vec;\n use core::unstable::intrinsics;\n+use core::unstable::intrinsics::{TyDesc};\n \n-pub mod rustrt {\n-    use core::libc::size_t;\n-    use core::sys::TypeDesc;\n+#[cfg(not(stage0))]\n+use core::unstable::intrinsics::{get_tydesc};\n \n-    pub extern {\n-        #[rust_stack]\n-        unsafe fn rust_call_tydesc_glue(root: *u8,\n-                                        tydesc: *TypeDesc,\n-                                        field: size_t);\n-    }\n+#[cfg(stage0)]\n+unsafe fn get_tydesc<T>() -> *TyDesc {\n+    intrinsics::get_tydesc::<T>() as *TyDesc\n }\n \n-// This probably belongs somewhere else. Needs to be kept in sync with\n-// changes to glue...\n-static tydesc_drop_glue_index: size_t = 3 as size_t;\n-\n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n@@ -125,6 +116,19 @@ fn round_up_to(base: uint, align: uint) -> uint {\n     (base + (align - 1)) & !(align - 1)\n }\n \n+#[inline]\n+#[cfg(not(stage0))]\n+unsafe fn call_drop_glue(tydesc: *TyDesc, data: *i8) {\n+    // This function should be inlined when stage0 is gone\n+    ((*tydesc).drop_glue)(data);\n+}\n+\n+#[inline]\n+#[cfg(stage0)]\n+unsafe fn call_drop_glue(tydesc: *TyDesc, data: *i8) {\n+    ((*tydesc).drop_glue)(0 as **TyDesc, data);\n+}\n+\n // Walk down a chunk, running the destructors for any objects stored\n // in it.\n unsafe fn destroy_chunk(chunk: &Chunk) {\n@@ -137,19 +141,18 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n         let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n         let (size, align) = ((*tydesc).size, (*tydesc).align);\n \n-        let after_tydesc = idx + sys::size_of::<*TypeDesc>();\n+        let after_tydesc = idx + sys::size_of::<*TyDesc>();\n \n         let start = round_up_to(after_tydesc, align);\n \n         //debug!(\"freeing object: idx = %u, size = %u, align = %u, done = %b\",\n         //       start, size, align, is_done);\n         if is_done {\n-            rustrt::rust_call_tydesc_glue(\n-                ptr::offset(buf, start), tydesc, tydesc_drop_glue_index);\n+            call_drop_glue(tydesc, ptr::offset(buf, start) as *i8);\n         }\n \n         // Find where the next tydesc lives\n-        idx = round_up_to(start + size, sys::pref_align_of::<*TypeDesc>());\n+        idx = round_up_to(start + size, sys::pref_align_of::<*TyDesc>());\n     }\n }\n \n@@ -158,12 +161,12 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n // is necessary in order to properly do cleanup if a failure occurs\n // during an initializer.\n #[inline]\n-unsafe fn bitpack_tydesc_ptr(p: *TypeDesc, is_done: bool) -> uint {\n+unsafe fn bitpack_tydesc_ptr(p: *TyDesc, is_done: bool) -> uint {\n     let p_bits: uint = transmute(p);\n     p_bits | (is_done as uint)\n }\n #[inline]\n-unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n+unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TyDesc, bool) {\n     (transmute(p & !1), p & 1 == 1)\n }\n \n@@ -203,7 +206,7 @@ impl Arena {\n     #[inline]\n     fn alloc_pod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n-            let tydesc = sys::get_type_desc::<T>();\n+            let tydesc = get_tydesc::<T>();\n             let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n             let ptr: *mut T = transmute(ptr);\n             intrinsics::move_val_init(&mut (*ptr), op());\n@@ -231,13 +234,13 @@ impl Arena {\n             let head = transmute_mut_region(&mut self.head);\n \n             let tydesc_start = head.fill;\n-            let after_tydesc = head.fill + sys::size_of::<*TypeDesc>();\n+            let after_tydesc = head.fill + sys::size_of::<*TyDesc>();\n             let start = round_up_to(after_tydesc, align);\n             let end = start + n_bytes;\n             if end > at_vec::capacity(head.data) {\n                 return self.alloc_nonpod_grow(n_bytes, align);\n             }\n-            head.fill = round_up_to(end, sys::pref_align_of::<*TypeDesc>());\n+            head.fill = round_up_to(end, sys::pref_align_of::<*TyDesc>());\n \n             //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n             //       start, n_bytes, align, head.fill);\n@@ -250,7 +253,7 @@ impl Arena {\n     #[inline]\n     fn alloc_nonpod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n         unsafe {\n-            let tydesc = sys::get_type_desc::<T>();\n+            let tydesc = get_tydesc::<T>();\n             let (ty_ptr, ptr) =\n                 self.alloc_nonpod_inner((*tydesc).size, (*tydesc).align);\n             let ty_ptr: *mut uint = transmute(ty_ptr);"}, {"sha": "43c4aecdd27fa5e60ffd97cc63f45d9a1375c6f9", "filename": "src/libextra/dbg.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdbg.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -13,56 +13,62 @@\n #[allow(missing_doc)];\n \n use core::cast::transmute;\n-use core::sys;\n+#[cfg(stage0)]\n+use intrinsic::{get_tydesc};\n+#[cfg(not(stage0))]\n+use core::unstable::intrinsics::{get_tydesc};\n \n pub mod rustrt {\n-    use core::sys;\n+    #[cfg(stage0)]\n+    use intrinsic::{TyDesc};\n+    #[cfg(not(stage0))]\n+    use core::unstable::intrinsics::{TyDesc};\n \n     #[abi = \"cdecl\"]\n     pub extern {\n-        pub unsafe fn debug_tydesc(td: *sys::TypeDesc);\n-        pub unsafe fn debug_opaque(td: *sys::TypeDesc, x: *());\n-        pub unsafe fn debug_box(td: *sys::TypeDesc, x: *());\n-        pub unsafe fn debug_tag(td: *sys::TypeDesc, x: *());\n-        pub unsafe fn debug_fn(td: *sys::TypeDesc, x: *());\n-        pub unsafe fn debug_ptrcast(td: *sys::TypeDesc, x: *()) -> *();\n+        pub unsafe fn debug_tydesc(td: *TyDesc);\n+        pub unsafe fn debug_opaque(td: *TyDesc, x: *());\n+        pub unsafe fn debug_box(td: *TyDesc, x: *());\n+        pub unsafe fn debug_tag(td: *TyDesc, x: *());\n+        pub unsafe fn debug_fn(td: *TyDesc, x: *());\n+        pub unsafe fn debug_ptrcast(td: *TyDesc, x: *()) -> *();\n         pub unsafe fn rust_dbg_breakpoint();\n     }\n }\n \n pub fn debug_tydesc<T>() {\n     unsafe {\n-        rustrt::debug_tydesc(sys::get_type_desc::<T>());\n+        rustrt::debug_tydesc(get_tydesc::<T>());\n     }\n }\n \n pub fn debug_opaque<T>(x: T) {\n     unsafe {\n-        rustrt::debug_opaque(sys::get_type_desc::<T>(), transmute(&x));\n+        rustrt::debug_opaque(get_tydesc::<T>(), transmute(&x));\n     }\n }\n \n pub fn debug_box<T>(x: @T) {\n     unsafe {\n-        rustrt::debug_box(sys::get_type_desc::<T>(), transmute(&x));\n+        rustrt::debug_box(get_tydesc::<T>(), transmute(&x));\n     }\n }\n \n pub fn debug_tag<T>(x: T) {\n     unsafe {\n-        rustrt::debug_tag(sys::get_type_desc::<T>(), transmute(&x));\n+        rustrt::debug_tag(get_tydesc::<T>(), transmute(&x));\n     }\n }\n \n pub fn debug_fn<T>(x: T) {\n     unsafe {\n-        rustrt::debug_fn(sys::get_type_desc::<T>(), transmute(&x));\n+        rustrt::debug_fn(get_tydesc::<T>(), transmute(&x));\n     }\n }\n \n pub unsafe fn ptr_cast<T, U>(x: @T) -> @U {\n     transmute(\n-        rustrt::debug_ptrcast(sys::get_type_desc::<T>(), transmute(x)))\n+        rustrt::debug_ptrcast(get_tydesc::<T>(), transmute(x)))\n }\n \n /// Triggers a debugger breakpoint"}, {"sha": "11aebdf467ff29ac7ba8857d0b26adcb3156f0ac", "filename": "src/libextra/extra.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "previous_filename": "src/libextra/std.rc"}, {"sha": "9c416550eb787be896de787f23370c7af21577fc", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -418,10 +418,11 @@ pub fn opts_str(mm: &Matches, names: &[~str]) -> ~str {\n  */\n pub fn opt_strs(mm: &Matches, nm: &str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n-    for vec::each(opt_vals(mm, nm)) |v| {\n+    let r = opt_vals(mm, nm);\n+    for r.iter().advance |v| {\n         match *v { Val(ref s) => acc.push(copy *s), _ => () }\n     }\n-    return acc;\n+    acc\n }\n \n /// Returns the string argument supplied to a matching option or none"}, {"sha": "15553b035f65e7dadcae1c5c464b7992c15874cb", "filename": "src/libextra/json.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -1123,7 +1123,7 @@ impl Eq for Json {\n                     &Object(ref d1) => {\n                         if d0.len() == d1.len() {\n                             let mut equal = true;\n-                            for d0.each |k, v0| {\n+                            for d0.iter().advance |(k, v0)| {\n                                 match d1.find(k) {\n                                     Some(v1) if v0 == v1 => { },\n                                     _ => { equal = false; break }\n@@ -1186,12 +1186,12 @@ impl Ord for Json {\n                         let mut d1_flat = ~[];\n \n                         // FIXME #4430: this is horribly inefficient...\n-                        for d0.each |k, v| {\n+                        for d0.iter().advance |(k, v)| {\n                              d0_flat.push((@copy *k, @copy *v));\n                         }\n                         d0_flat.qsort();\n \n-                        for d1.each |k, v| {\n+                        for d1.iter().advance |(k, v)| {\n                             d1_flat.push((@copy *k, @copy *v));\n                         }\n                         d1_flat.qsort();\n@@ -1326,7 +1326,7 @@ impl<A:ToJson> ToJson for ~[A] {\n impl<A:ToJson + Copy> ToJson for HashMap<~str, A> {\n     fn to_json(&self) -> Json {\n         let mut d = HashMap::new();\n-        for self.each |key, value| {\n+        for self.iter().advance |(key, value)| {\n             d.insert(copy *key, value.to_json());\n         }\n         Object(~d)"}, {"sha": "5d3d31fdec47eb623ad7c0bac2644b111f8b6b77", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -207,7 +207,7 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, ~[~str]>) -> ~str {\n     let mut out = ~\"\";\n     let mut first = true;\n \n-    for m.each |key, values| {\n+    for m.iter().advance |(key, values)| {\n         let key = encode_plus(*key);\n \n         for values.iter().advance |value| {"}, {"sha": "555cceb5b44b98e58c3dda52d40aab671e34dccf", "filename": "src/libextra/rc.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frc.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -70,10 +70,12 @@ impl<T> Rc<T> {\n impl<T> Drop for Rc<T> {\n     fn finalize(&self) {\n         unsafe {\n-            (*self.ptr).count -= 1;\n-            if (*self.ptr).count == 0 {\n-                ptr::replace_ptr(self.ptr, intrinsics::uninit());\n-                free(self.ptr as *c_void)\n+            if self.ptr.is_not_null() {\n+                (*self.ptr).count -= 1;\n+                if (*self.ptr).count == 0 {\n+                    ptr::replace_ptr(self.ptr, intrinsics::uninit());\n+                    free(self.ptr as *c_void)\n+                }\n             }\n         }\n     }\n@@ -220,10 +222,12 @@ impl<T> RcMut<T> {\n impl<T> Drop for RcMut<T> {\n     fn finalize(&self) {\n         unsafe {\n-            (*self.ptr).count -= 1;\n-            if (*self.ptr).count == 0 {\n-                ptr::replace_ptr(self.ptr, uninit());\n-                free(self.ptr as *c_void)\n+            if self.ptr.is_not_null() {\n+                (*self.ptr).count -= 1;\n+                if (*self.ptr).count == 0 {\n+                    ptr::replace_ptr(self.ptr, uninit());\n+                    free(self.ptr as *c_void)\n+                }\n             }\n         }\n     }"}, {"sha": "345b217871cc51b28ddd84fa1aa9d36dfd4a51d3", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -710,7 +710,7 @@ impl<\n     fn encode(&self, e: &mut E) {\n         do e.emit_map(self.len()) |e| {\n             let mut i = 0;\n-            for self.each |key, val| {\n+            for self.iter().advance |(key, val)| {\n                 e.emit_map_elt_key(i, |e| key.encode(e));\n                 e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n@@ -744,7 +744,7 @@ impl<\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n             let mut i = 0;\n-            for self.each |e| {\n+            for self.iter().advance |e| {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }"}, {"sha": "1d163922955d0f0baa23eddcfe7e190bf28b9f9c", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -56,38 +56,6 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         self.find(key).is_some()\n     }\n \n-    /// Visit all key-value pairs in order\n-    fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) -> bool {\n-        for uint::range(0, self.v.len()) |i| {\n-            match self.v[i] {\n-              Some(ref elt) => if !it(&i, elt) { return false; },\n-              None => ()\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /// Visit all keys in order\n-    fn each_key(&self, blk: &fn(key: &uint) -> bool) -> bool {\n-        self.each(|k, _| blk(k))\n-    }\n-\n-    /// Visit all values in order\n-    fn each_value<'a>(&'a self, blk: &fn(value: &'a V) -> bool) -> bool {\n-        self.each(|_, v| blk(v))\n-    }\n-\n-    /// Iterate over the map and mutate the contained values\n-    fn mutate_values(&mut self, it: &fn(&uint, &mut V) -> bool) -> bool {\n-        for uint::range(0, self.v.len()) |i| {\n-            match self.v[i] {\n-              Some(ref mut elt) => if !it(&i, elt) { return false; },\n-              None => ()\n-            }\n-        }\n-        return true;\n-    }\n-\n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a V> {\n         if *key < self.v.len() {\n@@ -156,6 +124,38 @@ impl<V> SmallIntMap<V> {\n     /// Create an empty SmallIntMap\n     pub fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n+    /// Visit all key-value pairs in order\n+    pub fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) -> bool {\n+        for uint::range(0, self.v.len()) |i| {\n+            match self.v[i] {\n+              Some(ref elt) => if !it(&i, elt) { return false; },\n+              None => ()\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /// Visit all keys in order\n+    pub fn each_key(&self, blk: &fn(key: &uint) -> bool) -> bool {\n+        self.each(|k, _| blk(k))\n+    }\n+\n+    /// Visit all values in order\n+    pub fn each_value<'a>(&'a self, blk: &fn(value: &'a V) -> bool) -> bool {\n+        self.each(|_, v| blk(v))\n+    }\n+\n+    /// Iterate over the map and mutate the contained values\n+    pub fn mutate_values(&mut self, it: &fn(&uint, &mut V) -> bool) -> bool {\n+        for uint::range(0, self.v.len()) |i| {\n+            match self.v[i] {\n+              Some(ref mut elt) => if !it(&i, elt) { return false; },\n+              None => ()\n+            }\n+        }\n+        return true;\n+    }\n+\n     /// Visit all key-value pairs in reverse order\n     pub fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) -> bool {\n         for uint::range_rev(self.v.len(), 0) |i| {"}, {"sha": "5cb52a7b9dfb40632c125793bf76b874e4a25e2c", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -1094,7 +1094,8 @@ mod tests {\n         };\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n-        for vec::each(p.recv()) |p| { p.recv(); } // wait on all its siblings\n+        let r = p.recv();\n+        for r.iter().advance |p| { p.recv(); } // wait on all its siblings\n         do m.lock_cond |cond| {\n             let woken = cond.broadcast();\n             assert_eq!(woken, 0);"}, {"sha": "fd83fd199167403f4e0bf9976534caf17f8d31cb", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -107,26 +107,6 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n         self.find(key).is_some()\n     }\n \n-    /// Visit all key-value pairs in order\n-    fn each<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n-        each(&self.root, f)\n-    }\n-\n-    /// Visit all keys in order\n-    fn each_key(&self, f: &fn(&K) -> bool) -> bool {\n-        self.each(|k, _| f(k))\n-    }\n-\n-    /// Visit all values in order\n-    fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) -> bool {\n-        self.each(|_, v| f(v))\n-    }\n-\n-    /// Iterate over the map and mutate the contained values\n-    fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) -> bool {\n-        mutate_values(&mut self.root, f)\n-    }\n-\n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n         let mut current: &'a Option<~TreeNode<K, V>> = &self.root;\n@@ -184,6 +164,26 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n+    /// Visit all key-value pairs in order\n+    pub fn each<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n+        each(&self.root, f)\n+    }\n+\n+    /// Visit all keys in order\n+    pub fn each_key(&self, f: &fn(&K) -> bool) -> bool {\n+        self.each(|k, _| f(k))\n+    }\n+\n+    /// Visit all values in order\n+    pub fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) -> bool {\n+        self.each(|_, v| f(v))\n+    }\n+\n+    /// Iterate over the map and mutate the contained values\n+    pub fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) -> bool {\n+        mutate_values(&mut self.root, f)\n+    }\n+\n     /// Visit all key-value pairs in reverse order\n     pub fn each_reverse<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) -> bool {\n         each_reverse(&self.root, f)"}, {"sha": "a014293f0630d2d5566cb11a6ac24ca7d54f834c", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -146,7 +146,7 @@ impl WorkMap {\n impl<S:Encoder> Encodable<S> for WorkMap {\n     fn encode(&self, s: &mut S) {\n         let mut d = ~[];\n-        for self.each |k, v| {\n+        for self.iter().advance |(k, v)| {\n             d.push((copy *k, copy *v))\n         }\n         sort::tim_sort(d);\n@@ -320,7 +320,7 @@ impl TPrep for Prep {\n     }\n \n     fn all_fresh(&self, cat: &str, map: &WorkMap) -> bool {\n-        for map.each |k, v| {\n+        for map.iter().advance |(k, v)| {\n             if ! self.is_fresh(cat, k.kind, k.name, *v) {\n                 return false;\n             }"}, {"sha": "68427745ff592d78bc2ea9daffab98ad9e2c1d36", "filename": "src/librust/rust.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrust%2Frust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrust%2Frust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "previous_filename": "src/librust/rust.rc"}, {"sha": "05b6e90c682f0f6030588c444c9df4e5e59a9c8f", "filename": "src/librustc/back/abi.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fabi.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-\n-\n pub static rc_base_field_refcnt: uint = 0u;\n \n pub static task_field_refcnt: uint = 0u;\n@@ -49,9 +46,7 @@ pub static tydesc_field_take_glue: uint = 2u;\n pub static tydesc_field_drop_glue: uint = 3u;\n pub static tydesc_field_free_glue: uint = 4u;\n pub static tydesc_field_visit_glue: uint = 5u;\n-pub static tydesc_field_shape: uint = 6u;\n-pub static tydesc_field_shape_tables: uint = 7u;\n-pub static n_tydesc_fields: uint = 8u;\n+pub static n_tydesc_fields: uint = 6u;\n \n // The two halves of a closure: code and environment.\n pub static fn_field_code: uint = 0u;\n@@ -71,6 +66,4 @@ pub static vec_elt_elems: uint = 2u;\n pub static slice_elt_base: uint = 0u;\n pub static slice_elt_len: uint = 1u;\n \n-pub static worst_case_glue_call_args: uint = 7u;\n-\n pub static abi_version: uint = 1u;"}, {"sha": "fbb273450df29bed6721c823f4ef88068a8a4799", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -206,9 +206,6 @@ pub fn compile_rest(sess: Session,\n     let mut crate = crate_opt.unwrap();\n \n     let (llcx, llmod, link_meta) = {\n-    crate = time(time_passes, ~\"intrinsic injection\", ||\n-                 front::intrinsic_inject::inject_intrinsic(sess, crate));\n-\n         crate = time(time_passes, ~\"extra injection\", ||\n                      front::std_inject::maybe_inject_libstd_ref(sess, crate));\n "}, {"sha": "fcb08180a5ea27565ff9f3a854c9981c8df6d866", "filename": "src/librustc/front/intrinsic.rs", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/c06ee9f7a7fe1ad311c9fd0eb57e00646297cdbd/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c06ee9f7a7fe1ad311c9fd0eb57e00646297cdbd/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic.rs?ref=c06ee9f7a7fe1ad311c9fd0eb57e00646297cdbd", "patch": "@@ -1,140 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// NB: this file is include_str!'ed into the compiler, re-parsed\n-// and injected into each crate the compiler builds. Keep it small.\n-\n-pub mod intrinsic {\n-    #[allow(missing_doc)];\n-\n-    pub use intrinsic::rusti::visit_tydesc;\n-\n-    // FIXME (#3727): remove this when the interface has settled and the\n-    // version in sys is no longer present.\n-    pub fn get_tydesc<T>() -> *TyDesc {\n-        unsafe {\n-            rusti::get_tydesc::<T>() as *TyDesc\n-        }\n-    }\n-\n-    pub struct TyDesc {\n-        size: uint,\n-        align: uint\n-        // Remaining fields not listed\n-    }\n-\n-    pub enum Opaque { }\n-\n-    pub trait TyVisitor {\n-        fn visit_bot(&self) -> bool;\n-        fn visit_nil(&self) -> bool;\n-        fn visit_bool(&self) -> bool;\n-\n-        fn visit_int(&self) -> bool;\n-        fn visit_i8(&self) -> bool;\n-        fn visit_i16(&self) -> bool;\n-        fn visit_i32(&self) -> bool;\n-        fn visit_i64(&self) -> bool;\n-\n-        fn visit_uint(&self) -> bool;\n-        fn visit_u8(&self) -> bool;\n-        fn visit_u16(&self) -> bool;\n-        fn visit_u32(&self) -> bool;\n-        fn visit_u64(&self) -> bool;\n-\n-        fn visit_float(&self) -> bool;\n-        fn visit_f32(&self) -> bool;\n-        fn visit_f64(&self) -> bool;\n-\n-        fn visit_char(&self) -> bool;\n-        fn visit_str(&self) -> bool;\n-\n-        fn visit_estr_box(&self) -> bool;\n-        fn visit_estr_uniq(&self) -> bool;\n-        fn visit_estr_slice(&self) -> bool;\n-        fn visit_estr_fixed(&self, n: uint, sz: uint, align: uint) -> bool;\n-\n-        fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-\n-        fn visit_vec(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_evec_fixed(&self, n: uint, sz: uint, align: uint,\n-                            mtbl: uint, inner: *TyDesc) -> bool;\n-\n-        fn visit_enter_rec(&self, n_fields: uint,\n-                           sz: uint, align: uint) -> bool;\n-        fn visit_rec_field(&self, i: uint, name: &str,\n-                           mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_leave_rec(&self, n_fields: uint,\n-                           sz: uint, align: uint) -> bool;\n-\n-        fn visit_enter_class(&self, n_fields: uint,\n-                             sz: uint, align: uint) -> bool;\n-        fn visit_class_field(&self, i: uint, name: &str,\n-                             mtbl: uint, inner: *TyDesc) -> bool;\n-        fn visit_leave_class(&self, n_fields: uint,\n-                             sz: uint, align: uint) -> bool;\n-\n-        fn visit_enter_tup(&self, n_fields: uint,\n-                           sz: uint, align: uint) -> bool;\n-        fn visit_tup_field(&self, i: uint, inner: *TyDesc) -> bool;\n-        fn visit_leave_tup(&self, n_fields: uint,\n-                           sz: uint, align: uint) -> bool;\n-\n-        fn visit_enter_enum(&self, n_variants: uint,\n-                            get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n-                            sz: uint, align: uint) -> bool;\n-        fn visit_enter_enum_variant(&self, variant: uint,\n-                                    disr_val: int,\n-                                    n_fields: uint,\n-                                    name: &str) -> bool;\n-        fn visit_enum_variant_field(&self, i: uint, offset: uint, inner: *TyDesc) -> bool;\n-        fn visit_leave_enum_variant(&self, variant: uint,\n-                                    disr_val: int,\n-                                    n_fields: uint,\n-                                    name: &str) -> bool;\n-        fn visit_leave_enum(&self, n_variants: uint,\n-                            get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n-                            sz: uint, align: uint) -> bool;\n-\n-        fn visit_enter_fn(&self, purity: uint, proto: uint,\n-                          n_inputs: uint, retstyle: uint) -> bool;\n-        fn visit_fn_input(&self, i: uint, mode: uint, inner: *TyDesc) -> bool;\n-        fn visit_fn_output(&self, retstyle: uint, inner: *TyDesc) -> bool;\n-        fn visit_leave_fn(&self, purity: uint, proto: uint,\n-                          n_inputs: uint, retstyle: uint) -> bool;\n-\n-        fn visit_trait(&self) -> bool;\n-        fn visit_var(&self) -> bool;\n-        fn visit_var_integral(&self) -> bool;\n-        fn visit_param(&self, i: uint) -> bool;\n-        fn visit_self(&self) -> bool;\n-        fn visit_type(&self) -> bool;\n-        fn visit_opaque_box(&self) -> bool;\n-        fn visit_constr(&self, inner: *TyDesc) -> bool;\n-        fn visit_closure_ptr(&self, ck: uint) -> bool;\n-    }\n-\n-    pub mod rusti {\n-        use super::{TyDesc, TyVisitor};\n-\n-        #[abi = \"rust-intrinsic\"]\n-        pub extern \"rust-intrinsic\" {\n-            pub fn get_tydesc<T>() -> *();\n-            pub fn visit_tydesc(td: *TyDesc, tv: @TyVisitor);\n-        }\n-    }\n-}"}, {"sha": "0caadc8572e90cf545744b9e2af78d3cdcacd173", "filename": "src/librustc/front/intrinsic_inject.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c06ee9f7a7fe1ad311c9fd0eb57e00646297cdbd/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c06ee9f7a7fe1ad311c9fd0eb57e00646297cdbd/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs?ref=c06ee9f7a7fe1ad311c9fd0eb57e00646297cdbd", "patch": "@@ -1,47 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::prelude::*;\n-\n-use core::vec;\n-use driver::session::Session;\n-use syntax::parse;\n-use syntax::ast;\n-use syntax::codemap::spanned;\n-\n-pub fn inject_intrinsic(sess: Session, crate: @ast::crate) -> @ast::crate {\n-    let intrinsic_module = include_str!(\"intrinsic.rs\").to_managed();\n-\n-    let item = parse::parse_item_from_source_str(@\"<intrinsic>\",\n-                                                 intrinsic_module,\n-                                                 /*bad*/copy sess.opts.cfg,\n-                                                 ~[],\n-                                                 sess.parse_sess);\n-    let item =\n-        match item {\n-          Some(i) => i,\n-          None => {\n-            sess.fatal(\"no item found in intrinsic module\");\n-          }\n-        };\n-\n-    let items = vec::append(~[item], crate.node.module.items);\n-\n-    @spanned {\n-        node: ast::crate_ {\n-            module: ast::_mod {\n-                items: items,\n-                .. /*bad*/copy crate.node.module\n-            },\n-            .. /*bad*/copy crate.node\n-        },\n-        .. /*bad*/copy *crate\n-    }\n-}"}, {"sha": "b0a955fef8f7f70d88200a6249cf1b4b8d194f51", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -86,7 +86,7 @@ pub fn have_crate_data(cstore: &CStore, cnum: ast::crate_num) -> bool {\n \n pub fn iter_crate_data(cstore: &CStore,\n                        i: &fn(ast::crate_num, @crate_metadata)) {\n-    for cstore.metas.each |&k, &v| {\n+    for cstore.metas.iter().advance |(&k, &v)| {\n         i(k, v);\n     }\n }"}, {"sha": "d2b939dc0fc0fdb1ea9a3d94660ff75f8a19efc8", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -35,7 +35,6 @@ use extra::ebml;\n use extra::serialize::Decodable;\n use syntax::ast_map;\n use syntax::attr;\n-use syntax::diagnostic::span_handler;\n use syntax::parse::token::{ident_interner, special_idents};\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n@@ -97,7 +96,8 @@ fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n \n #[deriving(Eq)]\n enum Family {\n-    Const,                 // c\n+    ImmStatic,             // c\n+    MutStatic,             // b\n     Fn,                    // f\n     UnsafeFn,              // u\n     StaticMethod,          // F\n@@ -120,7 +120,8 @@ enum Family {\n fn item_family(item: ebml::Doc) -> Family {\n     let fam = reader::get_doc(item, tag_items_data_item_family);\n     match reader::doc_as_u8(fam) as char {\n-      'c' => Const,\n+      'c' => ImmStatic,\n+      'b' => MutStatic,\n       'f' => Fn,\n       'u' => UnsafeFn,\n       'F' => StaticMethod,\n@@ -317,7 +318,8 @@ fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::crate_num)\n     -> def_like {\n     let fam = item_family(item);\n     match fam {\n-        Const     => dl_def(ast::def_const(did)),\n+        ImmStatic => dl_def(ast::def_static(did, false)),\n+        MutStatic => dl_def(ast::def_static(did, true)),\n         Struct    => dl_def(ast::def_struct(did)),\n         UnsafeFn  => dl_def(ast::def_fn(did, ast::unsafe_fn)),\n         Fn        => dl_def(ast::def_fn(did, ast::impure_fn)),\n@@ -890,8 +892,8 @@ pub fn get_item_visibility(cdata: cmd, id: ast::node_id)\n \n fn family_has_type_params(fam: Family) -> bool {\n     match fam {\n-      Const | ForeignType | Mod | ForeignMod | PublicField | PrivateField\n-      | ForeignFn => false,\n+      ImmStatic | ForeignType | Mod | ForeignMod | PublicField | PrivateField\n+      | ForeignFn | MutStatic => false,\n       _           => true\n     }\n }\n@@ -921,7 +923,8 @@ fn describe_def(items: ebml::Doc, id: ast::def_id) -> ~str {\n \n fn item_family_to_str(fam: Family) -> ~str {\n     match fam {\n-      Const => ~\"const\",\n+      ImmStatic => ~\"static\",\n+      MutStatic => ~\"static mut\",\n       Fn => ~\"fn\",\n       UnsafeFn => ~\"unsafe fn\",\n       StaticMethod => ~\"static method\","}, {"sha": "f6d620df80ab1becc57691f87a8463897badefab", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -731,8 +731,8 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     }\n \n     let mut combined_ty_params = opt_vec::Empty;\n-    for owner_generics.ty_params.each |x| { combined_ty_params.push(copy *x) }\n-    for method_generics.ty_params.each |x| { combined_ty_params.push(copy *x) }\n+    for owner_generics.ty_params.iter().advance |x| { combined_ty_params.push(copy *x) }\n+    for method_generics.ty_params.iter().advance |x| { combined_ty_params.push(copy *x) }\n     let len = combined_ty_params.len();\n     encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n \n@@ -783,7 +783,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     let must_write =\n         match item.node {\n           item_enum(_, _) | item_impl(*) | item_trait(*) | item_struct(*) |\n-          item_mod(*) | item_foreign_mod(*) | item_const(*) => true,\n+          item_mod(*) | item_foreign_mod(*) | item_static(*) => true,\n           _ => false\n         };\n     if !must_write && !reachable(ecx, item.id) { return; }\n@@ -798,11 +798,15 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            ecx.tcx.sess.codemap.span_to_str(item.span));\n \n     match item.node {\n-      item_const(_, _) => {\n+      item_static(_, m, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n-        encode_family(ebml_w, 'c');\n+        if m == ast::m_mutbl {\n+            encode_family(ebml_w, 'b');\n+        } else {\n+            encode_family(ebml_w, 'c');\n+        }\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n@@ -1105,9 +1109,13 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));\n       }\n-      foreign_item_const(*) => {\n+      foreign_item_static(_, mutbl) => {\n         encode_def_id(ebml_w, local_def(nitem.id));\n-        encode_family(ebml_w, 'c');\n+        if mutbl {\n+            encode_family(ebml_w, 'b');\n+        } else {\n+            encode_family(ebml_w, 'c');\n+        }\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         encode_symbol(ecx, ebml_w, nitem.id);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));"}, {"sha": "fb8238b84d6e69c31d1bf1123c747b8a51c680b5", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -373,7 +373,7 @@ impl tr for ast::def {\n           ast::def_self(nid, i) => ast::def_self(xcx.tr_id(nid), i),\n           ast::def_mod(did) => ast::def_mod(did.tr(xcx)),\n           ast::def_foreign_mod(did) => ast::def_foreign_mod(did.tr(xcx)),\n-          ast::def_const(did) => ast::def_const(did.tr(xcx)),\n+          ast::def_static(did, m) => ast::def_static(did.tr(xcx), m),\n           ast::def_arg(nid, b) => ast::def_arg(xcx.tr_id(nid), b),\n           ast::def_local(nid, b) => ast::def_local(xcx.tr_id(nid), b),\n           ast::def_variant(e_did, v_did) => {"}, {"sha": "2fa25b10f60518d744e2298934e8828fbe8a08dd", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -43,7 +43,7 @@ pub fn check_item(sess: Session,\n                   (_is_const, v): (bool,\n                                    visit::vt<bool>)) {\n     match it.node {\n-      item_const(_, ex) => {\n+      item_static(_, _, ex) => {\n         (v.visit_expr)(ex, (true, v));\n         check_item_recursion(sess, ast_map, def_map, it);\n       }\n@@ -124,7 +124,7 @@ pub fn check_expr(sess: Session,\n                              items without type parameters\");\n             }\n             match def_map.find(&e.id) {\n-              Some(&def_const(_)) |\n+              Some(&def_static(*)) |\n               Some(&def_fn(_, _)) |\n               Some(&def_variant(_, _)) |\n               Some(&def_struct(_)) => { }\n@@ -236,7 +236,7 @@ pub fn check_item_recursion(sess: Session,\n     fn visit_expr(e: @expr, (env, v): (env, visit::vt<env>)) {\n         match e.node {\n             expr_path(*) => match env.def_map.find(&e.id) {\n-                Some(&def_const(def_id)) if ast_util::is_local(def_id) =>\n+                Some(&def_static(def_id, _)) if ast_util::is_local(def_id) =>\n                     match env.ast_map.get_copy(&def_id.node) {\n                         ast_map::node_item(it, _) => {\n                             (v.visit_item)(it, (env, v));"}, {"sha": "b4c8a6b19c29fbd046edb9969f336e991d318652", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -304,7 +304,7 @@ pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n       pat_ident(_, _, _) | pat_enum(_, _) => {\n         match cx.tcx.def_map.find(&pat.id) {\n           Some(&def_variant(_, id)) => Some(variant(id)),\n-          Some(&def_const(did)) => {\n+          Some(&def_static(did, false)) => {\n             let const_expr = lookup_const_by_id(cx.tcx, did).get();\n             Some(val(eval_const_expr(cx.tcx, const_expr)))\n           }\n@@ -339,7 +339,7 @@ pub fn is_wild(cx: @MatchCheckCtxt, p: @pat) -> bool {\n       pat_wild => { true }\n       pat_ident(_, _, _) => {\n         match cx.tcx.def_map.find(&pat.id) {\n-          Some(&def_variant(_, _)) | Some(&def_const(*)) => { false }\n+          Some(&def_variant(_, _)) | Some(&def_static(*)) => { false }\n           _ => { true }\n         }\n       }\n@@ -499,7 +499,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             None\n                         }\n                     }\n-                    Some(&def_const(did)) => {\n+                    Some(&def_static(did, _)) => {\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).get();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n@@ -549,7 +549,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n             }\n             pat_enum(_, args) => {\n                 match cx.tcx.def_map.get_copy(&pat_id) {\n-                    def_const(did) => {\n+                    def_static(did, _) => {\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).get();\n                         let e_v = eval_const_expr(cx.tcx, const_expr);\n@@ -790,7 +790,7 @@ pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n             return true;\n         }\n       }\n-      Some(&def_const(*)) => return true,\n+      Some(&def_static(*)) => return true,\n       _ => ()\n     }\n "}, {"sha": "299d71b2567a12faa881fbd7559d943f80998277", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -166,7 +166,7 @@ pub fn classify(e: @expr,\n \n pub fn lookup_const(tcx: ty::ctxt, e: @expr) -> Option<@expr> {\n     match tcx.def_map.find(&e.id) {\n-        Some(&ast::def_const(def_id)) => lookup_const_by_id(tcx, def_id),\n+        Some(&ast::def_static(def_id, false)) => lookup_const_by_id(tcx, def_id),\n         _ => None\n     }\n }\n@@ -178,7 +178,7 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n         match tcx.items.find(&def_id.node) {\n             None => None,\n             Some(&ast_map::node_item(it, _)) => match it.node {\n-                item_const(_, const_expr) => Some(const_expr),\n+                item_static(_, ast::m_imm, const_expr) => Some(const_expr),\n                 _ => None\n             },\n             Some(_) => None\n@@ -195,7 +195,7 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n         match csearch::maybe_get_item_ast(tcx, def_id,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, maps, /*bar*/ copy c, d)) {\n             csearch::found(ast::ii_item(item)) => match item.node {\n-                item_const(_, const_expr) => Some(const_expr),\n+                item_static(_, ast::m_imm, const_expr) => Some(const_expr),\n                 _ => None\n             },\n             _ => None"}, {"sha": "513b2015a834a7f08f11786e3699e1aa1b506dce", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -17,7 +17,7 @@ use middle::typeck::method_map;\n use util::ppaux;\n \n use syntax::ast::{deref, expr_call, expr_inline_asm, expr_method_call};\n-use syntax::ast::{expr_unary, node_id, unsafe_blk, unsafe_fn};\n+use syntax::ast::{expr_unary, node_id, unsafe_blk, unsafe_fn, expr_path};\n use syntax::ast;\n use syntax::codemap::span;\n use syntax::visit::{fk_item_fn, fk_method};\n@@ -143,6 +143,14 @@ pub fn check_crate(tcx: ty::ctxt,\n                 expr_inline_asm(*) => {\n                     require_unsafe(expr.span, \"use of inline assembly\")\n                 }\n+                expr_path(*) => {\n+                    match ty::resolve_expr(tcx, expr) {\n+                        ast::def_static(_, true) => {\n+                            require_unsafe(expr.span, \"use of mutable static\")\n+                        }\n+                        _ => {}\n+                    }\n+                }\n                 _ => {}\n             }\n "}, {"sha": "b0b2a16cf89392d465d262a96fdaabe436c187bf", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -240,7 +240,8 @@ fn check_fn(\n \n     // Check kinds on free variables:\n     do with_appropriate_checker(cx, fn_id) |chk| {\n-        for vec::each(*freevars::get_freevars(cx.tcx, fn_id)) |fv| {\n+        let r = freevars::get_freevars(cx.tcx, fn_id);\n+        for r.iter().advance |fv| {\n             chk(cx, *fv);\n         }\n     }"}, {"sha": "9d4064e99bdb109021a33182b8904daf08c4fbec", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -76,16 +76,20 @@ pub enum LangItem {\n     UnrecordBorrowFnLangItem,   // 36\n \n     StartFnLangItem,            // 37\n+\n+    TyDescStructLangItem,       // 38\n+    TyVisitorTraitLangItem,     // 39\n+    OpaqueStructLangItem,       // 40\n }\n \n pub struct LanguageItems {\n-    items: [Option<def_id>, ..38]\n+    items: [Option<def_id>, ..41]\n }\n \n impl LanguageItems {\n     pub fn new() -> LanguageItems {\n         LanguageItems {\n-            items: [ None, ..38 ]\n+            items: [ None, ..41 ]\n         }\n     }\n \n@@ -138,6 +142,10 @@ impl LanguageItems {\n \n             37 => \"start\",\n \n+            38 => \"ty_desc\",\n+            39 => \"ty_visitor\",\n+            40 => \"opaque\",\n+\n             _ => \"???\"\n         }\n     }\n@@ -262,6 +270,15 @@ impl LanguageItems {\n     pub fn start_fn(&const self) -> def_id {\n         self.items[StartFnLangItem as uint].get()\n     }\n+    pub fn ty_desc(&const self) -> def_id {\n+        self.items[TyDescStructLangItem as uint].get()\n+    }\n+    pub fn ty_visitor(&const self) -> def_id {\n+        self.items[TyVisitorTraitLangItem as uint].get()\n+    }\n+    pub fn opaque(&const self) -> def_id {\n+        self.items[OpaqueStructLangItem as uint].get()\n+    }\n }\n \n fn LanguageItemCollector(crate: @crate,\n@@ -313,6 +330,9 @@ fn LanguageItemCollector(crate: @crate,\n     item_refs.insert(@\"record_borrow\", RecordBorrowFnLangItem as uint);\n     item_refs.insert(@\"unrecord_borrow\", UnrecordBorrowFnLangItem as uint);\n     item_refs.insert(@\"start\", StartFnLangItem as uint);\n+    item_refs.insert(@\"ty_desc\", TyDescStructLangItem as uint);\n+    item_refs.insert(@\"ty_visitor\", TyVisitorTraitLangItem as uint);\n+    item_refs.insert(@\"opaque\", OpaqueStructLangItem as uint);\n \n     LanguageItemCollector {\n         crate: crate,\n@@ -416,7 +436,7 @@ impl LanguageItemCollector {\n     }\n \n     pub fn check_completeness(&self) {\n-        for self.item_refs.each |&key, &item_ref| {\n+        for self.item_refs.iter().advance |(&key, &item_ref)| {\n             match self.items.items[item_ref] {\n                 None => {\n                     self.session.err(fmt!(\"no item found for `%s`\", key));"}, {"sha": "6da10b7c2774953784d88a2c6fd7044d4cc324ff", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -96,6 +96,8 @@ pub enum lint {\n \n     missing_doc,\n     unreachable_code,\n+\n+    warnings,\n }\n \n pub fn level_to_str(lv: level) -> &'static str {\n@@ -280,6 +282,13 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         desc: \"detects unreachable code\",\n         default: warn\n     }),\n+\n+    (\"warnings\",\n+     LintSpec {\n+        lint: warnings,\n+        desc: \"mass-change the level for lints which produce warnings\",\n+        default: warn\n+    }),\n ];\n \n /*\n@@ -352,7 +361,7 @@ impl Context {\n     }\n \n     fn lint_to_str(&self, lint: lint) -> &'static str {\n-        for self.dict.each |k, v| {\n+        for self.dict.iter().advance |(k, v)| {\n             if v.lint == lint {\n                 return *k;\n             }\n@@ -362,10 +371,11 @@ impl Context {\n \n     fn span_lint(&self, lint: lint, span: span, msg: &str) {\n         let (level, src) = match self.curr.find(&(lint as uint)) {\n+            None => { return }\n+            Some(&(warn, src)) => (self.get_level(warnings), src),\n             Some(&pair) => pair,\n-            None => { return; }\n         };\n-        if level == allow { return; }\n+        if level == allow { return }\n \n         let mut note = None;\n         let msg = match src {\n@@ -709,40 +719,43 @@ fn check_item_default_methods(cx: &Context, item: @ast::item) {\n }\n \n fn check_item_ctypes(cx: &Context, it: @ast::item) {\n-\n-    fn check_foreign_fn(cx: &Context, decl: &ast::fn_decl) {\n-        let tys = vec::map(decl.inputs, |a| a.ty );\n-        for vec::each(vec::append_one(tys, decl.output)) |ty| {\n-            match ty.node {\n-              ast::ty_path(_, _, id) => {\n+    fn check_ty(cx: &Context, ty: @ast::Ty) {\n+        match ty.node {\n+            ast::ty_path(_, _, id) => {\n                 match cx.tcx.def_map.get_copy(&id) {\n-                  ast::def_prim_ty(ast::ty_int(ast::ty_i)) => {\n-                    cx.span_lint(ctypes, ty.span,\n-                        \"found rust type `int` in foreign module, while \\\n-                         libc::c_int or libc::c_long should be used\");\n-                  }\n-                  ast::def_prim_ty(ast::ty_uint(ast::ty_u)) => {\n-                    cx.span_lint(ctypes, ty.span,\n-                        \"found rust type `uint` in foreign module, while \\\n-                         libc::c_uint or libc::c_ulong should be used\");\n-                  }\n-                  _ => ()\n+                    ast::def_prim_ty(ast::ty_int(ast::ty_i)) => {\n+                        cx.span_lint(ctypes, ty.span,\n+                                \"found rust type `int` in foreign module, while \\\n+                                libc::c_int or libc::c_long should be used\");\n+                    }\n+                    ast::def_prim_ty(ast::ty_uint(ast::ty_u)) => {\n+                        cx.span_lint(ctypes, ty.span,\n+                                \"found rust type `uint` in foreign module, while \\\n+                                libc::c_uint or libc::c_ulong should be used\");\n+                    }\n+                    _ => ()\n                 }\n-              }\n-              _ => ()\n             }\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_foreign_fn(cx: &Context, decl: &ast::fn_decl) {\n+        let tys = vec::map(decl.inputs, |a| a.ty );\n+        let r = vec::append_one(tys, decl.output);\n+        for r.iter().advance |ty| {\n+            check_ty(cx, *ty);\n         }\n     }\n \n     match it.node {\n       ast::item_foreign_mod(ref nmod) if !nmod.abis.is_intrinsic() => {\n         for nmod.items.iter().advance |ni| {\n             match ni.node {\n-              ast::foreign_item_fn(ref decl, _, _) => {\n-                check_foreign_fn(cx, decl);\n-              }\n-              // FIXME #4622: Not implemented.\n-              ast::foreign_item_const(*) => {}\n+                ast::foreign_item_fn(ref decl, _, _) => {\n+                    check_foreign_fn(cx, decl);\n+                }\n+                ast::foreign_item_static(t, _) => { check_ty(cx, t); }\n             }\n         }\n       }\n@@ -1159,7 +1172,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n \n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code.\n-    for tcx.sess.lints.each |_, v| {\n+    for tcx.sess.lints.iter().advance |(_, v)| {\n         for v.iter().advance |t| {\n             match *t {\n                 (lint, span, ref msg) =>"}, {"sha": "f93cb265d785f5ad7885ad9b103306ad79acfefa", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -447,19 +447,29 @@ impl mem_categorization_ctxt {\n                    -> cmt {\n         match def {\n           ast::def_fn(*) | ast::def_static_method(*) | ast::def_mod(_) |\n-          ast::def_foreign_mod(_) | ast::def_const(_) |\n+          ast::def_foreign_mod(_) | ast::def_static(_, false) |\n           ast::def_use(_) | ast::def_variant(*) |\n           ast::def_trait(_) | ast::def_ty(_) | ast::def_prim_ty(_) |\n           ast::def_ty_param(*) | ast::def_struct(*) |\n           ast::def_typaram_binder(*) | ast::def_region(_) |\n           ast::def_label(_) | ast::def_self_ty(*) => {\n-            @cmt_ {\n-                id:id,\n-                span:span,\n-                cat:cat_static_item,\n-                mutbl: McImmutable,\n-                ty:expr_ty\n-            }\n+              @cmt_ {\n+                  id:id,\n+                  span:span,\n+                  cat:cat_static_item,\n+                  mutbl: McImmutable,\n+                  ty:expr_ty\n+              }\n+          }\n+\n+          ast::def_static(_, true) => {\n+              @cmt_ {\n+                  id:id,\n+                  span:span,\n+                  cat:cat_static_item,\n+                  mutbl: McDeclared,\n+                  ty:expr_ty\n+              }\n           }\n \n           ast::def_arg(vid, mutbl) => {\n@@ -894,7 +904,7 @@ impl mem_categorization_ctxt {\n                         self.cat_pattern(cmt_field, subpat, op);\n                     }\n                 }\n-                Some(&ast::def_const(*)) => {\n+                Some(&ast::def_static(*)) => {\n                     for subpats.iter().advance |&subpat| {\n                         self.cat_pattern(cmt, subpat, op);\n                     }"}, {"sha": "5bd39e8586374cad55477fb61720593bb683f964", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -45,7 +45,7 @@ pub fn pat_is_const(dm: resolve::DefMap, pat: &pat) -> bool {\n     match pat.node {\n         pat_ident(_, _, None) | pat_enum(*) => {\n             match dm.find(&pat.id) {\n-                Some(&def_const(*)) => true,\n+                Some(&def_static(_, false)) => true,\n                 _ => false\n             }\n         }"}, {"sha": "7d3e895a0edd595ef16f7e37450c50fe11182558", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -948,7 +948,7 @@ pub fn determine_rp_in_crate(sess: Session,\n     debug!(\"%s\", {\n         debug!(\"Region variance results:\");\n         let region_paramd_items = cx.region_paramd_items;\n-        for region_paramd_items.each |&key, &value| {\n+        for region_paramd_items.iter().advance |(&key, &value)| {\n             debug!(\"item %? (%s) is parameterized with variance %?\",\n                    key,\n                    ast_map::node_id_to_str(ast_map, key,"}, {"sha": "a8626ca89aa898a15a089f539b4e4605ecacbf97", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 54, "deletions": 39, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -101,6 +101,14 @@ pub enum Namespace {\n     ValueNS\n }\n \n+#[deriving(Eq)]\n+pub enum NamespaceError {\n+    NoError,\n+    ModuleError,\n+    TypeError,\n+    ValueError\n+}\n+\n /// A NamespaceResult represents the result of resolving an import in\n /// a particular namespace. The result is either definitely-resolved,\n /// definitely- unresolved, or unknown.\n@@ -759,10 +767,12 @@ pub fn PrimitiveTypeTable() -> PrimitiveTypeTable {\n }\n \n \n-pub fn namespace_to_str(ns: Namespace) -> ~str {\n+pub fn namespace_error_to_str(ns: NamespaceError) -> &'static str {\n     match ns {\n-        TypeNS  => ~\"type\",\n-        ValueNS => ~\"value\",\n+        NoError     => \"\",\n+        ModuleError => \"module\",\n+        TypeError   => \"type\",\n+        ValueError  => \"value\",\n     }\n }\n \n@@ -993,21 +1003,25 @@ impl Resolver {\n                 // * If no duplicate checking was requested at all, do\n                 //   nothing.\n \n-                let mut is_duplicate = false;\n+                let mut duplicate_type = NoError;\n                 let ns = match duplicate_checking_mode {\n                     ForbidDuplicateModules => {\n-                        is_duplicate = child.get_module_if_available().is_some();\n+                        if (child.get_module_if_available().is_some()) {\n+                            duplicate_type = ModuleError;\n+                        }\n                         Some(TypeNS)\n                     }\n                     ForbidDuplicateTypes => {\n                         match child.def_for_namespace(TypeNS) {\n                             Some(def_mod(_)) | None => {}\n-                            Some(_) => is_duplicate = true\n+                            Some(_) => duplicate_type = TypeError\n                         }\n                         Some(TypeNS)\n                     }\n                     ForbidDuplicateValues => {\n-                        is_duplicate = child.defined_in_namespace(ValueNS);\n+                        if child.defined_in_namespace(ValueNS) {\n+                            duplicate_type = ValueError;\n+                        }\n                         Some(ValueNS)\n                     }\n                     ForbidDuplicateTypesAndValues => {\n@@ -1016,31 +1030,31 @@ impl Resolver {\n                             Some(def_mod(_)) | None => {}\n                             Some(_) => {\n                                 n = Some(TypeNS);\n-                                is_duplicate = true;\n+                                duplicate_type = TypeError;\n                             }\n                         };\n                         if child.defined_in_namespace(ValueNS) {\n-                            is_duplicate = true;\n+                            duplicate_type = ValueError;\n                             n = Some(ValueNS);\n                         }\n                         n\n                     }\n                     OverwriteDuplicates => None\n                 };\n-                if is_duplicate {\n+                if (duplicate_type != NoError) {\n                     // Return an error here by looking up the namespace that\n                     // had the duplicate.\n                     let ns = ns.unwrap();\n                     self.session.span_err(sp,\n                         fmt!(\"duplicate definition of %s `%s`\",\n-                             namespace_to_str(ns),\n+                             namespace_error_to_str(duplicate_type),\n                              self.session.str_of(name)));\n                     {\n                         let r = child.span_for_namespace(ns);\n                         for r.iter().advance |sp| {\n                             self.session.span_note(*sp,\n-                                 fmt!(\"first definition of %s %s here:\",\n-                                      namespace_to_str(ns),\n+                                 fmt!(\"first definition of %s `%s` here\",\n+                                      namespace_error_to_str(duplicate_type),\n                                       self.session.str_of(name)));\n                         }\n                     }\n@@ -1146,12 +1160,13 @@ impl Resolver {\n             }\n \n             // These items live in the value namespace.\n-            item_const(*) => {\n+            item_static(_, m, _) => {\n                 let (name_bindings, _) =\n                     self.add_child(ident, parent, ForbidDuplicateValues, sp);\n+                let mutbl = m == ast::m_mutbl;\n \n                 name_bindings.define_value\n-                    (privacy, def_const(local_def(item.id)), sp);\n+                    (privacy, def_static(local_def(item.id), mutbl), sp);\n             }\n             item_fn(_, purity, _, _, _) => {\n               let (name_bindings, new_parent) =\n@@ -1385,7 +1400,7 @@ impl Resolver {\n                 }\n \n                 let def_id = local_def(item.id);\n-                for method_names.each |name, _| {\n+                for method_names.iter().advance |(name, _)| {\n                     if !self.method_map.contains_key(name) {\n                         self.method_map.insert(*name, HashSet::new());\n                     }\n@@ -1565,8 +1580,8 @@ impl Resolver {\n                     visit_foreign_item(foreign_item, (new_parent, visitor));\n                 }\n             }\n-            foreign_item_const(*) => {\n-                let def = def_const(local_def(foreign_item.id));\n+            foreign_item_static(_, m) => {\n+                let def = def_static(local_def(foreign_item.id), m);\n                 name_bindings.define_value(Public, def, foreign_item.span);\n \n                 visit_foreign_item(foreign_item, (new_parent, visitor));\n@@ -1673,7 +1688,7 @@ impl Resolver {\n             let privacy = variant_visibility_to_privacy(visibility, true);\n             child_name_bindings.define_value(privacy, def, dummy_sp());\n           }\n-          def_fn(*) | def_static_method(*) | def_const(*) => {\n+          def_fn(*) | def_static_method(*) | def_static(*) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building value %s\", final_ident);\n             child_name_bindings.define_value(privacy, def, dummy_sp());\n@@ -1703,7 +1718,7 @@ impl Resolver {\n                       interned_method_names.insert(method_name);\n                   }\n               }\n-              for interned_method_names.each |name| {\n+              for interned_method_names.iter().advance |name| {\n                   if !self.method_map.contains_key(name) {\n                       self.method_map.insert(*name, HashSet::new());\n                   }\n@@ -2469,8 +2484,8 @@ impl Resolver {\n         assert_eq!(containing_module.glob_count, 0);\n \n         // Add all resolved imports from the containing module.\n-        for containing_module.import_resolutions.each\n-                |ident, target_import_resolution| {\n+        for containing_module.import_resolutions.iter().advance\n+                |(ident, target_import_resolution)| {\n \n             debug!(\"(resolving glob import) writing module resolution \\\n                     %? into `%s`\",\n@@ -2554,13 +2569,13 @@ impl Resolver {\n         };\n \n         // Add all children from the containing module.\n-        for containing_module.children.each |&ident, name_bindings| {\n+        for containing_module.children.iter().advance |(&ident, name_bindings)| {\n             merge_import_resolution(ident, *name_bindings);\n         }\n \n         // Add external module children from the containing module.\n-        for containing_module.external_module_children.each\n-                |&ident, module| {\n+        for containing_module.external_module_children.iter().advance\n+                |(&ident, module)| {\n             let name_bindings =\n                 @mut Resolver::create_name_bindings_from_module(*module);\n             merge_import_resolution(ident, name_bindings);\n@@ -3250,7 +3265,7 @@ impl Resolver {\n     pub fn add_exports_for_module(@mut self,\n                                   exports2: &mut ~[Export2],\n                                   module_: @mut Module) {\n-        for module_.children.each |ident, namebindings| {\n+        for module_.children.iter().advance |(ident, namebindings)| {\n             debug!(\"(computing exports) maybe export '%s'\",\n                    self.session.str_of(*ident));\n             self.add_exports_of_namebindings(&mut *exports2,\n@@ -3265,7 +3280,7 @@ impl Resolver {\n                                              false);\n         }\n \n-        for module_.import_resolutions.each |ident, importresolution| {\n+        for module_.import_resolutions.iter().advance |(ident, importresolution)| {\n             if importresolution.privacy != Public {\n                 debug!(\"(computing exports) not reexporting private `%s`\",\n                        self.session.str_of(*ident));\n@@ -3664,7 +3679,7 @@ impl Resolver {\n                                     || visit_foreign_item(*foreign_item,\n                                                           ((), visitor)));\n                             }\n-                            foreign_item_const(_) => {\n+                            foreign_item_static(*) => {\n                                 visit_foreign_item(*foreign_item,\n                                                    ((), visitor));\n                             }\n@@ -3686,7 +3701,7 @@ impl Resolver {\n                                       visitor);\n             }\n \n-            item_const(*) => {\n+            item_static(*) => {\n                 self.with_constant_rib(|| {\n                     visit_item(item, ((), visitor));\n                 });\n@@ -3833,8 +3848,8 @@ impl Resolver {\n     pub fn resolve_type_parameters(@mut self,\n                                    type_parameters: &OptVec<TyParam>,\n                                    visitor: ResolveVisitor) {\n-        for type_parameters.each |type_parameter| {\n-            for type_parameter.bounds.each |bound| {\n+        for type_parameters.iter().advance |type_parameter| {\n+            for type_parameter.bounds.iter().advance |bound| {\n                 self.resolve_type_parameter_bound(bound, visitor);\n             }\n         }\n@@ -4038,7 +4053,7 @@ impl Resolver {\n         for arm.pats.iter().enumerate().advance |(i, p)| {\n             let map_i = self.binding_mode_map(*p);\n \n-            for map_0.each |&key, &binding_0| {\n+            for map_0.iter().advance |(&key, &binding_0)| {\n                 match map_i.find(&key) {\n                   None => {\n                     self.session.span_err(\n@@ -4059,7 +4074,7 @@ impl Resolver {\n                 }\n             }\n \n-            for map_i.each |&key, &binding| {\n+            for map_i.iter().advance |(&key, &binding)| {\n                 if !map_0.contains_key(&key) {\n                     self.session.span_err(\n                         binding.span,\n@@ -4180,13 +4195,13 @@ impl Resolver {\n                     }\n                 }\n \n-                for bounds.each |bound| {\n+                for bounds.iter().advance |bound| {\n                     self.resolve_type_parameter_bound(bound, visitor);\n                 }\n             }\n \n             ty_closure(c) => {\n-                for c.bounds.each |bound| {\n+                for c.bounds.iter().advance |bound| {\n                     self.resolve_type_parameter_bound(bound, visitor);\n                 }\n                 visit_ty(ty, ((), visitor));\n@@ -4344,7 +4359,7 @@ impl Resolver {\n                                 Some(def @ def_struct(*)) => {\n                             self.record_def(pattern.id, def);\n                         }\n-                        Some(def @ def_const(*)) => {\n+                        Some(def @ def_static(*)) => {\n                             self.enforce_default_binding_mode(\n                                 pattern,\n                                 binding_mode,\n@@ -4376,7 +4391,7 @@ impl Resolver {\n                         Some(def @ def_fn(*))      |\n                         Some(def @ def_variant(*)) |\n                         Some(def @ def_struct(*))  |\n-                        Some(def @ def_const(*)) => {\n+                        Some(def @ def_static(*)) => {\n                             self.record_def(pattern.id, def);\n                         }\n                         Some(_) => {\n@@ -4459,7 +4474,7 @@ impl Resolver {\n                             def @ def_variant(*) | def @ def_struct(*) => {\n                                 return FoundStructOrEnumVariant(def);\n                             }\n-                            def @ def_const(*) => {\n+                            def @ def_static(_, false) => {\n                                 return FoundConst(def);\n                             }\n                             _ => {\n@@ -5354,7 +5369,7 @@ impl Resolver {\n         }\n \n         debug!(\"Import resolutions:\");\n-        for module_.import_resolutions.each |name, import_resolution| {\n+        for module_.import_resolutions.iter().advance |(name, import_resolution)| {\n             let value_repr;\n             match import_resolution.target_for_namespace(ValueNS) {\n                 None => { value_repr = ~\"\"; }"}, {"sha": "63b39b8fe763e443d54e6c6457963eeab65cf745", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -820,7 +820,7 @@ pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n                         add_to_set(ccx.tcx, &mut found,\n                                    lit(UnitLikeStructLit(cur.id)));\n                     }\n-                    Some(&ast::def_const(const_did)) => {\n+                    Some(&ast::def_static(const_did, false)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n@@ -836,7 +836,7 @@ pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n                         add_to_set(ccx.tcx, &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n-                    Some(&ast::def_const(const_did)) => {\n+                    Some(&ast::def_static(const_did, false)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n@@ -1673,7 +1673,7 @@ pub fn trans_match_inner(scope_cx: block,\n \n     let mut arm_datas = ~[];\n     let mut matches = ~[];\n-    for vec::each(arms) |arm| {\n+    for arms.iter().advance |arm| {\n         let body = scope_block(bcx, arm.body.info(), \"case_body\");\n         let bindings_map = create_bindings_map(bcx, arm.pats[0]);\n         let arm_data = @ArmData {bodycx: body,\n@@ -1831,8 +1831,9 @@ pub fn bind_irrefutable_pat(bcx: block,\n                         }\n                     }\n                 }\n-                Some(&ast::def_const(*)) => {\n-                    bcx = bind_irrefutable_pat(bcx, pat, val, make_copy, binding_mode);\n+                Some(&ast::def_static(_, false)) => {\n+                    bcx = bind_irrefutable_pat(bcx, pat, val, make_copy,\n+                                               binding_mode);\n                 }\n                 _ => {\n                     // Nothing to do here."}, {"sha": "9b7c7037f42a2d17e18f793cc401715ed955afde", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -135,7 +135,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n                 ty::lookup_field_type(cx.tcx, def_id, field.id, substs)\n             };\n             let packed = ty::lookup_packed(cx.tcx, def_id);\n-            let dtor = ty::ty_dtor(cx.tcx, def_id).is_present();\n+            let dtor = ty::ty_dtor(cx.tcx, def_id).has_drop_flag();\n             let ftys =\n                 if dtor { ftys + [ty::mk_bool()] } else { ftys };\n             return Univariant(mk_struct(cx, ftys, packed), dtor)"}, {"sha": "5bf0e596ca05185920ed59fa4a2777da63019056", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -2122,14 +2122,19 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n             trans_enum_def(ccx, enum_definition, item.id, vi, &mut i);\n         }\n       }\n-      ast::item_const(_, expr) => {\n-          consts::trans_const(ccx, expr, item.id);\n+      ast::item_static(_, m, expr) => {\n+          consts::trans_const(ccx, m, item.id);\n           // Do static_assert checking. It can't really be done much earlier because we need to get\n           // the value of the bool out of LLVM\n           for item.attrs.iter().advance |attr| {\n               match attr.node.value.node {\n                   ast::meta_word(x) => {\n                       if x.slice(0, x.len()) == \"static_assert\" {\n+                          if m == ast::m_mutbl {\n+                              ccx.sess.span_fatal(expr.span,\n+                                                  \"cannot have static_assert \\\n+                                                   on a mutable static\");\n+                          }\n                           let v = ccx.const_values.get_copy(&item.id);\n                           unsafe {\n                               if !(llvm::LLVMConstIntGetZExtValue(v) as bool) {\n@@ -2398,13 +2403,14 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n             let my_path = vec::append(/*bad*/copy *pth,\n                                       [path_name(i.ident)]);\n             match i.node {\n-              ast::item_const(_, expr) => {\n+              ast::item_static(_, m, expr) => {\n                 let typ = ty::node_id_to_type(ccx.tcx, i.id);\n                 let s = mangle_exported_name(ccx, my_path, typ);\n                 // We need the translated value here, because for enums the\n                 // LLVM type is not fully determined by the Rust type.\n                 let v = consts::const_expr(ccx, expr);\n                 ccx.const_values.insert(id, v);\n+                exprt = m == ast::m_mutbl;\n                 unsafe {\n                     let llty = llvm::LLVMTypeOf(v);\n                     let g = str::as_c_str(s, |buf| {\n@@ -2457,7 +2463,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n                                 ni.id,\n                                 ni.attrs)\n                 }\n-                ast::foreign_item_const(*) => {\n+                ast::foreign_item_static(*) => {\n                     let typ = ty::node_id_to_type(ccx.tcx, ni.id);\n                     let ident = token::ident_to_str(&ni.ident);\n                     let g = do str::as_c_str(ident) |buf| {\n@@ -2939,7 +2945,7 @@ pub fn trans_crate(sess: session::Session,\n     }\n \n     if ccx.sess.count_llvm_insns() {\n-        for ccx.stats.llvm_insns.each |&k, &v| {\n+        for ccx.stats.llvm_insns.iter().advance |(&k, &v)| {\n             io::println(fmt!(\"%-7u %s\", v, k));\n         }\n     }"}, {"sha": "cb475550638433690a95e0674dc6ce04bbd618fd", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -143,7 +143,7 @@ pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n                 datum_callee(bcx, ref_expr)\n             }\n             ast::def_mod(*) | ast::def_foreign_mod(*) | ast::def_trait(*) |\n-            ast::def_const(*) | ast::def_ty(*) | ast::def_prim_ty(*) |\n+            ast::def_static(*) | ast::def_ty(*) | ast::def_prim_ty(*) |\n             ast::def_use(*) | ast::def_typaram_binder(*) |\n             ast::def_region(*) | ast::def_label(*) | ast::def_ty_param(*) |\n             ast::def_self_ty(*) => {\n@@ -704,11 +704,11 @@ pub fn trans_args(cx: block,\n     // now that all arguments have been successfully built, we can revoke any\n     // temporary cleanups, as they are only needed if argument construction\n     // should fail (for example, cleanup of copy mode args).\n-    for vec::each(temp_cleanups) |c| {\n+    for temp_cleanups.iter().advance |c| {\n         revoke_clean(bcx, *c)\n     }\n \n-    return bcx;\n+    bcx\n }\n \n pub enum AutorefArg {"}, {"sha": "98eb858be55fd10e3a6511577414bc47b7517a8a", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -164,9 +164,9 @@ pub fn get_const_val(cx: @mut CrateContext, mut def_id: ast::def_id) -> ValueRef\n         }\n         match cx.tcx.items.get_copy(&def_id.node) {\n             ast_map::node_item(@ast::item {\n-                node: ast::item_const(_, subexpr), _\n+                node: ast::item_static(_, ast::m_imm, _), _\n             }, _) => {\n-                trans_const(cx, subexpr, def_id.node);\n+                trans_const(cx, ast::m_imm, def_id.node);\n             }\n             _ => cx.tcx.sess.bug(\"expected a const to be an item\")\n         }\n@@ -538,7 +538,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n                         base::get_item_val(cx, def_id.node)\n                     }\n                 }\n-                Some(&ast::def_const(def_id)) => {\n+                Some(&ast::def_static(def_id, false)) => {\n                     get_const_val(cx, def_id)\n                 }\n                 Some(&ast::def_variant(enum_did, variant_did)) => {\n@@ -587,14 +587,16 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n     }\n }\n \n-pub fn trans_const(ccx: @mut CrateContext, _e: @ast::expr, id: ast::node_id) {\n+pub fn trans_const(ccx: @mut CrateContext, m: ast::mutability, id: ast::node_id) {\n     unsafe {\n         let _icx = push_ctxt(\"trans_const\");\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n         let v = ccx.const_values.get_copy(&id);\n         llvm::LLVMSetInitializer(g, v);\n-        llvm::LLVMSetGlobalConstant(g, True);\n+        if m != ast::m_mutbl {\n+            llvm::LLVMSetGlobalConstant(g, True);\n+        }\n     }\n }"}, {"sha": "1aebf73b81a87a113a0ff7e6ff9e6df99947e5c7", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -945,7 +945,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         let _icx = push_ctxt(\"trans_def_lvalue\");\n         let ccx = bcx.ccx();\n         match def {\n-            ast::def_const(did) => {\n+            ast::def_static(did, _) => {\n                 let const_ty = expr_ty(bcx, ref_expr);\n \n                 fn get_did(ccx: @mut CrateContext, did: ast::def_id)"}, {"sha": "a5a6c1434c63fc639be4c5eb8c8ccdd2f8513ad4", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -332,7 +332,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                     }\n                 }\n             }\n-            ast::foreign_item_const(*) => {\n+            ast::foreign_item_static(*) => {\n                 let ident = token::ident_to_str(&foreign_item.ident);\n                 ccx.item_symbols.insert(foreign_item.id, /* bad */ident.to_owned());\n             }\n@@ -681,9 +681,12 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let static_ti = get_tydesc(ccx, tp_ty);\n             glue::lazily_emit_all_tydesc_glue(ccx, static_ti);\n \n-            // FIXME (#3727): change this to ccx.tydesc_ty.ptr_to() when the\n-            // core::sys copy of the get_tydesc interface dies off.\n-            let td = PointerCast(bcx, static_ti.tydesc, Type::nil().ptr_to());\n+            // FIXME (#3730): ideally this shouldn't need a cast,\n+            // but there's a circularity between translating rust types to llvm\n+            // types and having a tydesc type available. So I can't directly access\n+            // the llvm type of intrinsic::TyDesc struct.\n+            let userland_tydesc_ty = type_of::type_of(ccx, output_type);\n+            let td = PointerCast(bcx, static_ti.tydesc, userland_tydesc_ty);\n             Store(bcx, td, fcx.llretptr.get());\n         }\n         \"init\" => {"}, {"sha": "1f16a735c7c6019eac8c72d9953484f471db0a8e", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 70, "deletions": 31, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -232,7 +232,7 @@ pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n                                field: uint,\n                                ti: @mut tydesc_info) {\n     let _icx = push_ctxt(\"lazily_emit_tydesc_glue\");\n-    let llfnty = type_of_glue_fn(ccx);\n+    let llfnty = Type::glue_fn();\n \n     if lazily_emit_simplified_tydesc_glue(ccx, field, ti) {\n         return;\n@@ -338,9 +338,7 @@ pub fn call_tydesc_glue_full(bcx: block,\n         }\n     };\n \n-    Call(bcx, llfn, [C_null(Type::nil().ptr_to()),\n-                        C_null(bcx.ccx().tydesc_type.ptr_to().ptr_to()),\n-                        llrawptr]);\n+    Call(bcx, llfn, [C_null(Type::nil().ptr_to()), llrawptr]);\n }\n \n // See [Note-arg-mode]\n@@ -406,13 +404,8 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     build_return(bcx);\n }\n \n-pub fn trans_struct_drop(bcx: block,\n-                         t: ty::t,\n-                         v0: ValueRef,\n-                         dtor_did: ast::def_id,\n-                         class_did: ast::def_id,\n-                         substs: &ty::substs)\n-                      -> block {\n+pub fn trans_struct_drop_flag(bcx: block, t: ty::t, v0: ValueRef, dtor_did: ast::def_id,\n+                              class_did: ast::def_id, substs: &ty::substs) -> block {\n     let repr = adt::represent_type(bcx.ccx(), t);\n     let drop_flag = adt::trans_drop_flag_ptr(bcx, repr, v0);\n     do with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) |cx| {\n@@ -454,6 +447,43 @@ pub fn trans_struct_drop(bcx: block,\n     }\n }\n \n+pub fn trans_struct_drop(mut bcx: block, t: ty::t, v0: ValueRef, dtor_did: ast::def_id,\n+                         class_did: ast::def_id, substs: &ty::substs) -> block {\n+    let repr = adt::represent_type(bcx.ccx(), t);\n+\n+    // Find and call the actual destructor\n+    let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did,\n+                                 class_did, /*bad*/copy substs.tps);\n+\n+    // The second argument is the \"self\" argument for drop\n+    let params = unsafe {\n+        let ty = Type::from_ref(llvm::LLVMTypeOf(dtor_addr));\n+        ty.element_type().func_params()\n+    };\n+\n+    // Class dtors have no explicit args, so the params should\n+    // just consist of the environment (self)\n+    assert_eq!(params.len(), 1);\n+\n+    // Take a reference to the class (because it's using the Drop trait),\n+    // do so now.\n+    let llval = alloca(bcx, val_ty(v0));\n+    Store(bcx, v0, llval);\n+\n+    let self_arg = PointerCast(bcx, llval, params[0]);\n+    let args = ~[self_arg];\n+\n+    Call(bcx, dtor_addr, args);\n+\n+    // Drop the fields\n+    let field_tys = ty::struct_fields(bcx.tcx(), class_did, substs);\n+    for field_tys.iter().enumerate().advance |(i, fld)| {\n+        let llfld_a = adt::trans_field_ptr(bcx, repr, v0, 0, i);\n+        bcx = drop_ty(bcx, llfld_a, fld.mt.ty);\n+    }\n+\n+    bcx\n+}\n \n pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n@@ -474,7 +504,10 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       ty::ty_struct(did, ref substs) => {\n         let tcx = bcx.tcx();\n         match ty::ty_dtor(tcx, did) {\n-          ty::TraitDtor(dtor) => {\n+          ty::TraitDtor(dtor, true) => {\n+            trans_struct_drop_flag(bcx, t, v0, dtor, did, substs)\n+          }\n+          ty::TraitDtor(dtor, false) => {\n             trans_struct_drop(bcx, t, v0, dtor, did, substs)\n           }\n           ty::NoDtor => {\n@@ -594,6 +627,23 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_opaque_closure_ptr(ck) => {\n         closure::make_opaque_cbox_take_glue(bcx, ck, v)\n       }\n+      ty::ty_struct(did, ref substs) => {\n+        let tcx = bcx.tcx();\n+        let bcx = iter_structural_ty(bcx, v, t, take_ty);\n+\n+        match ty::ty_dtor(tcx, did) {\n+          ty::TraitDtor(dtor, false) => {\n+            // Zero out the struct\n+            unsafe {\n+                let ty = Type::from_ref(llvm::LLVMTypeOf(v));\n+                memzero(bcx, v, ty);\n+            }\n+\n+          }\n+          _ => { }\n+        }\n+        bcx\n+      }\n       _ if ty::type_is_structural(t) => {\n         iter_structural_ty(bcx, v, t, take_ty)\n       }\n@@ -680,7 +730,7 @@ pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n \n     let bcx = top_scope_block(fcx, None);\n     let lltop = bcx.llbb;\n-    let rawptr0_arg = fcx.arg_pos(1u);\n+    let rawptr0_arg = fcx.arg_pos(0u);\n     let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, rawptr0_arg as c_uint) };\n     let llty = type_of(ccx, t);\n     let llrawptr0 = PointerCast(bcx, llrawptr0, llty.ptr_to());\n@@ -715,7 +765,7 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n     let _icx = push_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs = true;\n-    let glue_fn_ty = Type::generic_glue_fn(ccx);\n+    let glue_fn_ty = Type::generic_glue_fn(ccx).ptr_to();\n     let tyds = &mut ccx.tydescs;\n     for tyds.each_value |&val| {\n         let ti = val;\n@@ -765,19 +815,13 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n               }\n             };\n \n-\n-        let shape = C_null(Type::i8p());\n-        let shape_tables = C_null(Type::i8p());\n-\n         let tydesc = C_named_struct(ccx.tydesc_type,\n-                           [ti.size, // size\n-                            ti.align, // align\n-                            take_glue, // take_glue\n-                            drop_glue, // drop_glue\n-                            free_glue, // free_glue\n-                            visit_glue, // visit_glue\n-                            shape, // shape\n-                            shape_tables]); // shape_tables\n+                                    [ti.size, // size\n+                                    ti.align, // align\n+                                    take_glue, // take_glue\n+                                    drop_glue, // drop_glue\n+                                    free_glue, // free_glue\n+                                    visit_glue]); // visit_glue\n \n         unsafe {\n             let gvar = ti.tydesc;\n@@ -788,8 +832,3 @@ pub fn emit_tydescs(ccx: &mut CrateContext) {\n         }\n     };\n }\n-\n-fn type_of_glue_fn(ccx: &CrateContext) -> Type {\n-    let tydescpp = ccx.tydesc_type.ptr_to().ptr_to();\n-    Type::func([ Type::nil().ptr_to(), tydescpp, Type::i8p() ], &Type::void())\n-}"}, {"sha": "e950c24c49e8d415c40bac705c59ada2357b1fc0", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -146,7 +146,7 @@ fn traverse_public_item(cx: @mut ctx, item: @item) {\n                         visit::mk_vt(@visit::Visitor {visit_ty: traverse_ty,\n                                                       ..*visit::default_visitor()})))\n       }\n-      item_const(*) |\n+      item_static(*) |\n       item_enum(*) | item_trait(*) => (),\n       item_mac(*) => fail!(\"item macros unimplemented\")\n     }"}, {"sha": "24c7333469765182dca575d04f3145492ec855da", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -274,9 +274,7 @@ impl Reflector {\n             let repr = adt::represent_type(bcx.ccx(), t);\n             let variants = ty::substd_enum_variants(ccx.tcx, did, substs);\n             let llptrty = type_of(ccx, t).ptr_to();\n-            let (_, opaquety) =\n-                ccx.tcx.intrinsic_defs.find_copy(&ccx.sess.ident_of(\"Opaque\"))\n-                .expect(\"Failed to resolve intrinsic::Opaque\");\n+            let opaquety = ty::get_opaque_ty(ccx.tcx);\n             let opaqueptrty = ty::mk_ptr(ccx.tcx, ty::mt { ty: opaquety, mutbl: ast::m_imm });\n \n             let make_get_disr = || {\n@@ -373,10 +371,8 @@ pub fn emit_calls_to_trait_visit_ty(bcx: block,\n                                     visitor_val: ValueRef,\n                                     visitor_trait_id: def_id)\n                                  -> block {\n-    use syntax::parse::token::special_idents::tydesc;\n     let final = sub_block(bcx, \"final\");\n-    assert!(bcx.ccx().tcx.intrinsic_defs.contains_key(&tydesc));\n-    let (_, tydesc_ty) = bcx.ccx().tcx.intrinsic_defs.get_copy(&tydesc);\n+    let tydesc_ty = ty::get_tydesc_ty(bcx.ccx().tcx);\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);\n     let mut r = Reflector {\n         visitor_val: visitor_val,"}, {"sha": "64688ac4134243d0933906145c0ffc8dc9f83d4d", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -20,7 +20,6 @@ use middle::trans::base;\n \n use syntax::ast;\n use syntax::abi::{Architecture, X86, X86_64, Arm, Mips};\n-use back::abi;\n \n use core::vec;\n use core::cast;\n@@ -189,25 +188,26 @@ impl Type {\n             None => ()\n         }\n \n-        let ty = cx.tydesc_type.get_field(abi::tydesc_field_drop_glue);\n+        let ty = Type::glue_fn();\n         cx.tn.associate_type(\"glue_fn\", &ty);\n \n         return ty;\n     }\n \n+    pub fn glue_fn() -> Type {\n+        Type::func([ Type::nil().ptr_to(), Type::i8p() ],\n+            &Type::void())\n+    }\n+\n     pub fn tydesc(arch: Architecture) -> Type {\n         let mut tydesc = Type::named_struct(\"tydesc\");\n-        let tydescpp = tydesc.ptr_to().ptr_to();\n-        let pvoid = Type::i8p();\n-        let glue_fn_ty = Type::func([ Type::nil().ptr_to(), tydescpp, pvoid ],\n-            &Type::void()).ptr_to();\n+        let glue_fn_ty = Type::glue_fn().ptr_to();\n \n         let int_ty = Type::int(arch);\n \n         let elems = [\n             int_ty, int_ty,\n-            glue_fn_ty, glue_fn_ty, glue_fn_ty, glue_fn_ty,\n-            pvoid, pvoid\n+            glue_fn_ty, glue_fn_ty, glue_fn_ty, glue_fn_ty\n         ];\n \n         tydesc.set_struct_body(elems, false);\n@@ -265,10 +265,6 @@ impl Type {\n         cx.int_type\n     }\n \n-    pub fn captured_tydescs(ctx: &CrateContext, num: uint) -> Type {\n-        Type::struct_(vec::from_elem(num, ctx.tydesc_type.ptr_to()), false)\n-    }\n-\n     pub fn opaque_trait(ctx: &CrateContext, store: ty::TraitStore) -> Type {\n         let tydesc_ptr = ctx.tydesc_type.ptr_to();\n         match store {"}, {"sha": "8cd776c99d697eb9c3f549d9378787b93aa446a4", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -213,7 +213,8 @@ pub fn type_needs_inner(cx: Context,\n               ty::ty_enum(did, ref substs) => {\n                 if list::find(enums_seen, |id| *id == did).is_none() {\n                     let seen = @Cons(did, enums_seen);\n-                    for vec::each(*ty::enum_variants(cx.ccx.tcx, did)) |v| {\n+                    let r = ty::enum_variants(cx.ccx.tcx, did);\n+                    for r.iter().advance |v| {\n                         for v.args.iter().advance |aty| {\n                             let t = ty::subst(cx.ccx.tcx, &(*substs), *aty);\n                             type_needs_inner(cx, use_, t, seen);"}, {"sha": "87b6e61e1373a245c5e5eb0cf37886d1fd624712", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -21,7 +21,7 @@ use middle::ty;\n use middle::subst::Subst;\n use middle::typeck;\n use middle;\n-use util::ppaux::{note_and_explain_region, bound_region_to_str, bound_region_ptr_to_str};\n+use util::ppaux::{note_and_explain_region, bound_region_ptr_to_str};\n use util::ppaux::{trait_store_to_str, ty_to_str, vstore_to_str};\n use util::ppaux::{Repr, UserString};\n use util::common::{indenter};\n@@ -44,7 +44,6 @@ use syntax::attr;\n use syntax::codemap::span;\n use syntax::codemap;\n use syntax::parse::token;\n-use syntax::parse::token::special_idents;\n use syntax::{ast, ast_map};\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n@@ -276,8 +275,7 @@ struct ctxt_ {\n     trait_defs: @mut HashMap<def_id, @TraitDef>,\n \n     items: ast_map::map,\n-    intrinsic_defs: @mut HashMap<ast::ident, (ast::def_id, t)>,\n-    intrinsic_traits: @mut HashMap<ast::ident, @TraitRef>,\n+    intrinsic_defs: @mut HashMap<ast::def_id, t>,\n     freevars: freevars::freevar_map,\n     tcache: type_cache,\n     rcache: creader_cache,\n@@ -954,7 +952,6 @@ pub fn mk_ctxt(s: session::Session,\n         node_type_substs: @mut HashMap::new(),\n         trait_refs: @mut HashMap::new(),\n         trait_defs: @mut HashMap::new(),\n-        intrinsic_traits: @mut HashMap::new(),\n         items: amap,\n         intrinsic_defs: @mut HashMap::new(),\n         freevars: freevars,\n@@ -3269,7 +3266,7 @@ pub fn expr_kind(tcx: ctxt,\n                 // Note: there is actually a good case to be made that\n                 // def_args, particularly those of immediate type, ought to\n                 // considered rvalues.\n-                ast::def_const(*) |\n+                ast::def_static(*) |\n                 ast::def_binding(*) |\n                 ast::def_upvar(*) |\n                 ast::def_arg(*) |\n@@ -3855,7 +3852,7 @@ pub fn item_path_str(cx: ctxt, id: ast::def_id) -> ~str {\n \n pub enum DtorKind {\n     NoDtor,\n-    TraitDtor(def_id)\n+    TraitDtor(def_id, bool)\n }\n \n impl DtorKind {\n@@ -3869,13 +3866,24 @@ impl DtorKind {\n     pub fn is_present(&const self) -> bool {\n         !self.is_not_present()\n     }\n+\n+    pub fn has_drop_flag(&self) -> bool {\n+        match self {\n+            &NoDtor => false,\n+            &TraitDtor(_, flag) => flag\n+        }\n+    }\n }\n \n /* If struct_id names a struct with a dtor, return Some(the dtor's id).\n    Otherwise return none. */\n pub fn ty_dtor(cx: ctxt, struct_id: def_id) -> DtorKind {\n     match cx.destructor_for_type.find(&struct_id) {\n-        Some(&method_def_id) => TraitDtor(method_def_id),\n+        Some(&method_def_id) => {\n+            let flag = !has_attr(cx, struct_id, \"no_drop_flag\");\n+\n+            TraitDtor(method_def_id, flag)\n+        }\n         None => NoDtor,\n     }\n }\n@@ -4469,10 +4477,26 @@ pub fn get_impl_id(tcx: ctxt, trait_id: def_id, self_ty: t) -> def_id {\n     }\n }\n \n+pub fn get_tydesc_ty(tcx: ctxt) -> t {\n+    let tydesc_lang_item = tcx.lang_items.ty_desc();\n+    tcx.intrinsic_defs.find_copy(&tydesc_lang_item)\n+        .expect(\"Failed to resolve TyDesc\")\n+}\n+\n+pub fn get_opaque_ty(tcx: ctxt) -> t {\n+    let opaque_lang_item = tcx.lang_items.opaque();\n+    tcx.intrinsic_defs.find_copy(&opaque_lang_item)\n+        .expect(\"Failed to resolve Opaque\")\n+}\n+\n pub fn visitor_object_ty(tcx: ctxt) -> (@TraitRef, t) {\n-    let ty_visitor_name = special_idents::ty_visitor;\n-    assert!(tcx.intrinsic_traits.contains_key(&ty_visitor_name));\n-    let trait_ref = tcx.intrinsic_traits.get_copy(&ty_visitor_name);\n+    let substs = substs {\n+        self_r: None,\n+        self_ty: None,\n+        tps: ~[]\n+    };\n+    let trait_lang_item = tcx.lang_items.ty_visitor();\n+    let trait_ref = @TraitRef { def_id: trait_lang_item, substs: substs };\n     (trait_ref,\n      mk_trait(tcx, trait_ref.def_id, copy trait_ref.substs,\n               BoxTraitStore, ast::m_imm, EmptyBuiltinBounds()))"}, {"sha": "5e6574850f1b8ca1aa94617b37ca6d8a73887e39", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -752,7 +752,7 @@ fn conv_builtin_bounds(tcx: ty::ctxt,\n     //! legal.\n \n     let mut builtin_bounds = ty::EmptyBuiltinBounds();\n-    for ast_bounds.each |ast_bound| {\n+    for ast_bounds.iter().advance |ast_bound| {\n         match *ast_bound {\n             ast::TraitTyParamBound(b) => {\n                 match lookup_def_tcx(tcx, b.path.span, b.ref_id) {"}, {"sha": "a38a2dced93b62ab55be0e199b1b9e6056fe6684", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -107,7 +107,7 @@ use middle::typeck::{isr_alist, lookup_def_ccx};\n use middle::typeck::no_params;\n use middle::typeck::{require_same_types, method_map, vtable_map};\n use util::common::{block_query, indenter, loop_query};\n-use util::ppaux::{bound_region_to_str,bound_region_ptr_to_str};\n+use util::ppaux::{bound_region_ptr_to_str};\n use util::ppaux;\n \n \n@@ -585,7 +585,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n     let _indenter = indenter();\n \n     match it.node {\n-      ast::item_const(_, e) => check_const(ccx, it.span, e, it.id),\n+      ast::item_static(_, _, e) => check_const(ccx, it.span, e, it.id),\n       ast::item_enum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n@@ -3216,7 +3216,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n       }\n \n       ast::def_fn(id, _) | ast::def_static_method(id, _, _) |\n-      ast::def_const(id) | ast::def_variant(_, id) |\n+      ast::def_static(id, _) | ast::def_variant(_, id) |\n       ast::def_struct(id) => {\n         return ty::lookup_item_type(fcx.ccx.tcx, id);\n       }\n@@ -3506,13 +3506,15 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n             }\n \n             \"get_tydesc\" => {\n-              // FIXME (#3730): return *intrinsic::tydesc, not *()\n-              (1u, ~[], ty::mk_nil_ptr(ccx.tcx))\n+              let tydesc_ty = ty::get_tydesc_ty(ccx.tcx);\n+              let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n+                  ty: tydesc_ty,\n+                  mutbl: ast::m_imm\n+              });\n+              (1u, ~[], td_ptr)\n             }\n             \"visit_tydesc\" => {\n-              let tydesc_name = special_idents::tydesc;\n-              assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n-              let (_, tydesc_ty) = tcx.intrinsic_defs.get_copy(&tydesc_name);\n+              let tydesc_ty = ty::get_tydesc_ty(ccx.tcx);\n               let (_, visitor_object_ty) = ty::visitor_object_ty(tcx);\n               let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n                   ty: tydesc_ty,"}, {"sha": "ae62e768ea2bb8c255a463e0dc353713fd87eeb8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -16,10 +16,8 @@\n \n use core::prelude::*;\n \n-use driver;\n use metadata::csearch::{each_path, get_impl_trait};\n use metadata::csearch::{get_impls_for_mod};\n-use metadata::csearch;\n use metadata::cstore::{CStore, iter_crate_data};\n use metadata::decoder::{dl_def, dl_field, dl_impl};\n use middle::resolve::{Impl, MethodInfo};\n@@ -39,7 +37,7 @@ use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar};\n use middle::typeck::infer::{resolve_nested_tvar, resolve_type};\n-use syntax::ast::{crate, def_id, def_mod, def_struct, def_trait, def_ty};\n+use syntax::ast::{crate, def_id, def_mod, def_struct, def_ty};\n use syntax::ast::{item, item_enum, item_impl, item_mod, item_struct};\n use syntax::ast::{local_crate, method, trait_ref, ty_path};\n use syntax::ast;"}, {"sha": "7812a0ed0ebacaf0c9a1e6257815e219db22d9bb", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 51, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -62,55 +62,16 @@ use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n \n pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n-\n-    // FIXME (#2592): hooking into the \"intrinsic\" root module is crude.\n-    // There ought to be a better approach. Attributes?\n-\n-    for crate.node.module.items.iter().advance |crate_item| {\n-        if crate_item.ident\n-            == ::syntax::parse::token::special_idents::intrinsic {\n-\n-            match crate_item.node {\n-              ast::item_mod(ref m) => {\n-                for m.items.iter().advance |intrinsic_item| {\n-                    let def_id = ast::def_id { crate: ast::local_crate,\n-                                               node: intrinsic_item.id };\n-                    let substs = substs {\n-                        self_r: None,\n-                        self_ty: None,\n-                        tps: ~[]\n-                    };\n-\n-                    match intrinsic_item.node {\n-                      ast::item_trait(*) => {\n-                          let tref = @ty::TraitRef {def_id: def_id,\n-                                                    substs: substs};\n-                          ccx.tcx.intrinsic_traits.insert\n-                              (intrinsic_item.ident, tref);\n-                      }\n-\n-                      ast::item_enum(*) => {\n-                        let ty = ty::mk_enum(ccx.tcx, def_id, substs);\n-                        ccx.tcx.intrinsic_defs.insert\n-                            (intrinsic_item.ident, (def_id, ty));\n-                      }\n-\n-                      ast::item_struct(*) => {\n-                        let ty = ty::mk_struct(ccx.tcx, def_id, substs);\n-                        ccx.tcx.intrinsic_defs.insert\n-                            (intrinsic_item.ident, (def_id, ty));\n-                      }\n-\n-                      _ => {}\n-                    }\n-                }\n-              }\n-              _ => { }\n-            }\n-            break;\n-        }\n+    fn collect_intrinsic_type(ccx: @mut CrateCtxt,\n+                              lang_item: ast::def_id) {\n+        let ty::ty_param_bounds_and_ty { ty: ty, _ } =\n+            ccx.get_item_ty(lang_item);\n+        ccx.tcx.intrinsic_defs.insert(lang_item, ty);\n     }\n \n+    collect_intrinsic_type(ccx, ccx.tcx.lang_items.ty_desc());\n+    collect_intrinsic_type(ccx, ccx.tcx.lang_items.opaque());\n+\n     visit::visit_crate(\n         crate, ((),\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n@@ -814,7 +775,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n                                  span: span,\n                                  generics: &ast::Generics,\n                                  thing: &'static str) {\n-    for generics.ty_params.each |ty_param| {\n+    for generics.ty_params.iter().advance |ty_param| {\n         if ty_param.bounds.len() > 0 {\n             ccx.tcx.sess.span_err(\n                 span,\n@@ -1060,7 +1021,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n     }\n     let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n     match it.node {\n-      ast::item_const(t, _) => {\n+      ast::item_static(t, _, _) => {\n         let typ = ccx.to_ty(&empty_rscope, t);\n         let tpt = no_params(typ);\n         tcx.tcache.insert(local_def(it.id), tpt);\n@@ -1153,7 +1114,7 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n                                   generics,\n                                   abis)\n         }\n-        ast::foreign_item_const(t) => {\n+        ast::foreign_item_static(t, _) => {\n             ty::ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n                     type_param_defs: @~[],\n@@ -1211,7 +1172,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n             builtin_bounds: ty::EmptyBuiltinBounds(),\n             trait_bounds: ~[]\n         };\n-        for ast_bounds.each |ast_bound| {\n+        for ast_bounds.iter().advance |ast_bound| {\n             match *ast_bound {\n                 TraitTyParamBound(b) => {\n                     let ty = ty::mk_param(ccx.tcx, param_ty.idx, param_ty.def_id);"}, {"sha": "0aad161a6788faee3bb5e145dfe8e2b6922b1e64", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -1285,7 +1285,7 @@ impl RegionVarBindings {\n \n         // It would be nice to write this using map():\n         let mut edges = vec::with_capacity(num_edges);\n-        for self.constraints.each |constraint, span| {\n+        for self.constraints.iter().advance |(constraint, span)| {\n             edges.push(GraphEdge {\n                 next_edge: [uint::max_value, uint::max_value],\n                 constraint: *constraint,"}, {"sha": "dc9fc264f85dc9a1466ba3f341d992468a3d9f06", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -57,7 +57,7 @@ impl RegionParamNames {\n     }\n \n     fn has_ident(&self, ident: ast::ident) -> bool {\n-        for self.each |region_param_name| {\n+        for self.iter().advance |region_param_name| {\n             if *region_param_name == ident {\n                 return true;\n             }"}, {"sha": "ca49d143d48097b9242fce255ee1f8de23909304", "filename": "src/librustc/rustc.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -86,7 +86,6 @@ pub mod front {\n     pub mod config;\n     pub mod test;\n     pub mod std_inject;\n-    pub mod intrinsic_inject;\n }\n \n pub mod back {\n@@ -167,7 +166,7 @@ Available lint options:\n                      padded(max_key, \"name\"), \"default\", \"meaning\"));\n     io::println(fmt!(\"    %s  %7.7s  %s\\n\",\n                      padded(max_key, \"----\"), \"-------\", \"-------\"));\n-    for lint_dict.each |k, v| {\n+    for lint_dict.iter().advance |(k, v)| {\n         let k = k.replace(\"_\", \"-\");\n         io::println(fmt!(\"    %s  %7.7s  %s\",\n                          padded(max_key, k),", "previous_filename": "src/librustc/rustc.rc"}, {"sha": "3194df269c0e3673b2eb57326ac4d835a4ffca84", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -32,7 +32,6 @@ use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n \n-use core::str;\n use core::vec;\n \n /// Produces a string suitable for debugging output."}, {"sha": "b7b2b70769bbdb5c6b37a5cf1ffccef5c68cb57e", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -102,7 +102,7 @@ fn moddoc_from_mod(\n                     fndoc_from_fn(ItemDoc)\n                 ))\n               }\n-              ast::item_const(_, _) => {\n+              ast::item_static(*) => {\n                 Some(doc::ConstTag(\n                     constdoc_from_const(ItemDoc)\n                 ))\n@@ -150,7 +150,7 @@ fn nmoddoc_from_mod(\n           ast::foreign_item_fn(*) => {\n             fns.push(fndoc_from_fn(ItemDoc));\n           }\n-          ast::foreign_item_const(*) => {} // XXX: Not implemented.\n+          ast::foreign_item_static(*) => {} // XXX: Not implemented.\n         }\n     }\n     doc::NmodDoc {"}, {"sha": "d02620229f5bea1cf9e16326c87829c1feeda879", "filename": "src/librustdoc/rustdoc.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "previous_filename": "src/librustdoc/rustdoc.rc"}, {"sha": "459daaa468f92e8a1b5f8f419aea77b8c471b6e7", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -96,7 +96,7 @@ fn fold_const(\n             do astsrv::exec(srv) |ctxt| {\n                 match ctxt.ast_map.get_copy(&doc.id()) {\n                     ast_map::node_item(@ast::item {\n-                        node: ast::item_const(ty, _), _\n+                        node: ast::item_static(ty, _, _), _\n                     }, _) => {\n                         pprust::ty_to_str(ty, extract::interner())\n                     }"}, {"sha": "f17777559deb56b5a23f580a21f0ca9803e9b712", "filename": "src/librusti/program.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -96,7 +96,7 @@ impl Program {\n \n         code.push_str(\"fn main() {\\n\");\n         // It's easy to initialize things if we don't run things...\n-        for self.local_vars.each |name, var| {\n+        for self.local_vars.iter().advance |(name, var)| {\n             let mt = var.mt();\n             code.push_str(fmt!(\"let%s %s: %s = fail!();\\n\", mt, *name, var.ty));\n             var.alter(*name, &mut code);\n@@ -149,7 +149,7 @@ impl Program {\n \n         // Using this __tls_map handle, deserialize each variable binding that\n         // we know about\n-        for self.local_vars.each |name, var| {\n+        for self.local_vars.iter().advance |(name, var)| {\n             let mt = var.mt();\n             code.push_str(fmt!(\"let%s %s: %s = {\n                 let data = __tls_map.get_copy(&~\\\"%s\\\");\n@@ -175,7 +175,7 @@ impl Program {\n \n         // After the input code is run, we can re-serialize everything back out\n         // into tls map (to be read later on by this task)\n-        for self.local_vars.each |name, var| {\n+        for self.local_vars.iter().advance |(name, var)| {\n             code.push_str(fmt!(\"{\n                 let local: %s = %s;\n                 let bytes = do ::std::io::with_bytes_writer |io| {\n@@ -237,7 +237,7 @@ impl Program {\n     /// program starts\n     pub fn set_cache(&self) {\n         let map = @mut HashMap::new();\n-        for self.local_vars.each |name, value| {\n+        for self.local_vars.iter().advance |(name, value)| {\n             map.insert(copy *name, @copy value.data);\n         }\n         unsafe {"}, {"sha": "57a2a48a0f634d8ab2c2c153d993d36cd86120a8", "filename": "src/librusti/rusti.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "previous_filename": "src/librusti/rusti.rc"}, {"sha": "9242e450e24991e4b4254dd19c9c0fb56c4754fb", "filename": "src/librustpkg/rustpkg.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "previous_filename": "src/librustpkg/rustpkg.rc"}, {"sha": "5a2f948600a800a14e155499b1ae5312069a42b0", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -25,13 +25,16 @@ use vec::ImmutableVector;\n \n pub mod rustrt {\n     use libc;\n-    use sys;\n     use vec;\n+    #[cfg(stage0)]\n+    use intrinsic::{TyDesc};\n+    #[cfg(not(stage0))]\n+    use unstable::intrinsics::{TyDesc};\n \n     #[abi = \"cdecl\"]\n     #[link_name = \"rustrt\"]\n     pub extern {\n-        pub unsafe fn vec_reserve_shared_actual(t: *sys::TypeDesc,\n+        pub unsafe fn vec_reserve_shared_actual(t: *TyDesc,\n                                                 v: **vec::raw::VecRepr,\n                                                 n: libc::size_t);\n     }\n@@ -197,6 +200,10 @@ pub mod raw {\n     use uint;\n     use unstable::intrinsics::{move_val_init};\n     use vec;\n+    #[cfg(stage0)]\n+    use intrinsic::{get_tydesc};\n+    #[cfg(not(stage0))]\n+    use unstable::intrinsics::{get_tydesc};\n \n     pub type VecRepr = vec::raw::VecRepr;\n     pub type SliceRepr = vec::raw::SliceRepr;\n@@ -258,7 +265,7 @@ pub mod raw {\n         // Only make the (slow) call into the runtime if we have to\n         if capacity(*v) < n {\n             let ptr: **VecRepr = transmute(v);\n-            rustrt::vec_reserve_shared_actual(sys::get_type_desc::<T>(),\n+            rustrt::vec_reserve_shared_actual(get_tydesc::<T>(),\n                                               ptr, n as libc::size_t);\n         }\n     }"}, {"sha": "ee9fdd3c6200575b0abe53078aef89ab8e12ff45", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -10,24 +10,19 @@\n \n #[doc(hidden)];\n \n-use libc::{c_char, c_void, intptr_t, uintptr_t};\n-use ptr::mut_null;\n+use libc::{c_char, intptr_t, uintptr_t};\n+use ptr::{mut_null};\n use repr::BoxRepr;\n-use sys::TypeDesc;\n use cast::transmute;\n+use unstable::intrinsics::TyDesc;\n #[cfg(not(test))] use unstable::lang::clear_task_borrow_list;\n \n-#[cfg(not(test))] use ptr::to_unsafe_ptr;\n-\n /**\n  * Runtime structures\n  *\n  * NB: These must match the representation in the C++ runtime.\n  */\n \n-type DropGlue<'self> = &'self fn(**TypeDesc, *c_void);\n-type FreeGlue<'self> = &'self fn(**TypeDesc, *c_void);\n-\n type TaskID = uintptr_t;\n \n struct StackSegment { priv opaque: () }\n@@ -164,6 +159,19 @@ fn debug_mem() -> bool {\n     false\n }\n \n+#[inline]\n+#[cfg(not(stage0))]\n+unsafe fn call_drop_glue(tydesc: *TyDesc, data: *i8) {\n+    // This function should be inlined when stage0 is gone\n+    ((*tydesc).drop_glue)(data);\n+}\n+\n+#[inline]\n+#[cfg(stage0)]\n+unsafe fn call_drop_glue(tydesc: *TyDesc, data: *i8) {\n+    ((*tydesc).drop_glue)(0 as **TyDesc, data);\n+}\n+\n /// Destroys all managed memory (i.e. @ boxes) held by the current task.\n #[cfg(not(test))]\n #[lang=\"annihilate\"]\n@@ -205,9 +213,9 @@ pub unsafe fn annihilate() {\n     // callback, as the original value may have been freed.\n     for each_live_alloc(false) |box, uniq| {\n         if !uniq {\n-            let tydesc: *TypeDesc = transmute(copy (*box).header.type_desc);\n-            let drop_glue: DropGlue = transmute(((*tydesc).drop_glue, 0));\n-            drop_glue(to_unsafe_ptr(&tydesc), transmute(&(*box).data));\n+            let tydesc = (*box).header.type_desc;\n+            let data = transmute(&(*box).data);\n+            call_drop_glue(tydesc, data);\n         }\n     }\n "}, {"sha": "d6f4c26715a4f6e18c656ab322d6c596c57e7d24", "filename": "src/libstd/container.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcontainer.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -34,18 +34,6 @@ pub trait Map<K, V>: Mutable {\n     /// Return true if the map contains a value for the specified key\n     fn contains_key(&self, key: &K) -> bool;\n \n-    /// Visits all keys and values\n-    fn each<'a>(&'a self, f: &fn(&K, &'a V) -> bool) -> bool;\n-\n-    /// Visit all keys\n-    fn each_key(&self, f: &fn(&K) -> bool) -> bool;\n-\n-    /// Visit all values\n-    fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) -> bool;\n-\n-    /// Iterate over the map and mutate the contained values\n-    fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) -> bool;\n-\n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V>;\n "}, {"sha": "c9e33219fa5033d3917c4af2a4b62e13c6652b3c", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -40,12 +40,13 @@ with destructors.\n use cast;\n use container::{Map, Set};\n use io;\n-use libc::{size_t, uintptr_t};\n+use libc::{uintptr_t};\n use option::{None, Option, Some};\n use ptr;\n use hashmap::HashSet;\n use stackwalk::walk_stack;\n use sys;\n+use unstable::intrinsics::{TyDesc};\n \n pub use stackwalk::Word;\n \n@@ -58,17 +59,11 @@ pub struct StackSegment {\n }\n \n pub mod rustrt {\n-    use libc::size_t;\n     use stackwalk::Word;\n     use super::StackSegment;\n \n     #[link_name = \"rustrt\"]\n     pub extern {\n-        #[rust_stack]\n-        pub unsafe fn rust_call_tydesc_glue(root: *Word,\n-                                            tydesc: *Word,\n-                                            field: size_t);\n-\n         #[rust_stack]\n         pub unsafe fn rust_gc_metadata() -> *Word;\n \n@@ -125,7 +120,7 @@ unsafe fn is_safe_point(pc: *Word) -> Option<SafePoint> {\n     return None;\n }\n \n-type Visitor<'self> = &'self fn(root: **Word, tydesc: *Word) -> bool;\n+type Visitor<'self> = &'self fn(root: **Word, tydesc: *TyDesc) -> bool;\n \n // Walks the list of roots for the given safe point, and calls visitor\n // on each root.\n@@ -139,7 +134,7 @@ unsafe fn _walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n     let stack_roots: *u32 = bump(sp_meta, 2);\n     let reg_roots: *u8 = bump(stack_roots, num_stack_roots);\n     let addrspaces: *Word = align_to_pointer(bump(reg_roots, num_reg_roots));\n-    let tydescs: ***Word = bump(addrspaces, num_stack_roots);\n+    let tydescs: ***TyDesc = bump(addrspaces, num_stack_roots);\n \n     // Stack roots\n     let mut sri = 0;\n@@ -321,6 +316,19 @@ fn expect_sentinel() -> bool { true }\n #[cfg(nogc)]\n fn expect_sentinel() -> bool { false }\n \n+#[inline]\n+#[cfg(not(stage0))]\n+unsafe fn call_drop_glue(tydesc: *TyDesc, data: *i8) {\n+    // This function should be inlined when stage0 is gone\n+    ((*tydesc).drop_glue)(data);\n+}\n+\n+#[inline]\n+#[cfg(stage0)]\n+unsafe fn call_drop_glue(tydesc: *TyDesc, data: *i8) {\n+    ((*tydesc).drop_glue)(0 as **TyDesc, data);\n+}\n+\n // Entry point for GC-based cleanup. Walks stack looking for exchange\n // heap and stack allocations requiring drop, and runs all\n // destructors.\n@@ -364,7 +372,7 @@ pub fn cleanup_stack_for_failure() {\n                 // FIXME #4420: Destroy this box\n                 // FIXME #4330: Destroy this box\n             } else {\n-                rustrt::rust_call_tydesc_glue(*root, tydesc, 3 as size_t);\n+                call_drop_glue(tydesc, *root as *i8);\n             }\n         }\n     }"}, {"sha": "bfa0f2fa124d222173bf569639dfa893f355daf5", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 23, "deletions": 34, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -307,34 +307,6 @@ impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n         }\n     }\n \n-    /// Visit all key-value pairs\n-    fn each<'a>(&'a self, blk: &fn(&K, &'a V) -> bool) -> bool {\n-        self.iter().advance(|(k, v)| blk(k, v))\n-    }\n-\n-    /// Visit all keys\n-    fn each_key(&self, blk: &fn(k: &K) -> bool) -> bool {\n-        self.iter().advance(|(k, _)| blk(k))\n-    }\n-\n-    /// Visit all values\n-    fn each_value<'a>(&'a self, blk: &fn(v: &'a V) -> bool) -> bool {\n-        self.iter().advance(|(_, v)| blk(v))\n-    }\n-\n-    /// Iterate over the map and mutate the contained values\n-    fn mutate_values(&mut self, blk: &fn(&K, &mut V) -> bool) -> bool {\n-        for uint::range(0, self.buckets.len()) |i| {\n-            match self.buckets[i] {\n-              Some(Bucket{key: ref key, value: ref mut value, _}) => {\n-                if !blk(key, value) { return false; }\n-              }\n-              None => ()\n-            }\n-        }\n-        return true;\n-    }\n-\n     /// Return a reference to the value corresponding to the key\n     fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n         match self.bucket_for_key(k) {\n@@ -516,6 +488,29 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n         }\n     }\n \n+    /// Visit all keys\n+    pub fn each_key(&self, blk: &fn(k: &K) -> bool) -> bool {\n+        self.iter().advance(|(k, _)| blk(k))\n+    }\n+\n+    /// Visit all values\n+    pub fn each_value<'a>(&'a self, blk: &fn(v: &'a V) -> bool) -> bool {\n+        self.iter().advance(|(_, v)| blk(v))\n+    }\n+\n+    /// Iterate over the map and mutate the contained values\n+    pub fn mutate_values(&mut self, blk: &fn(&K, &mut V) -> bool) -> bool {\n+        for uint::range(0, self.buckets.len()) |i| {\n+            match self.buckets[i] {\n+              Some(Bucket{key: ref key, value: ref mut value, _}) => {\n+                if !blk(key, value) { return false; }\n+              }\n+              None => ()\n+            }\n+        }\n+        return true;\n+    }\n+\n     /// An iterator visiting all key-value pairs in arbitrary order.\n     /// Iterator element type is (&'a K, &'a V).\n     pub fn iter<'a>(&'a self) -> HashMapIterator<'a, K, V> {\n@@ -718,12 +713,6 @@ impl<T:Hash + Eq> HashSet<T> {\n       self.map.contains_key_equiv(value)\n     }\n \n-    /// Visit all elements in arbitrary order\n-    /// FIXME: #6978: Remove when all callers are converted\n-    pub fn each(&self, f: &fn(&T) -> bool) -> bool {\n-        self.iter().advance(f)\n-    }\n-\n     /// An iterator visiting all elements in arbitrary order.\n     /// Iterator element type is &'a T.\n     pub fn iter<'a>(&'a self) -> HashSetIterator<'a, T> {"}, {"sha": "9177ecabed6a886cdd9f145acfaad84ac84139bb", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -43,7 +43,6 @@ pub trait Iterator<A> {\n     /// Return a lower bound and upper bound on the remaining length of the iterator.\n     ///\n     /// The common use case for the estimate is pre-allocating space to store the results.\n-    #[cfg(not(stage0))]\n     fn size_hint(&self) -> (Option<uint>, Option<uint>) { (None, None) }\n }\n \n@@ -610,7 +609,6 @@ impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for ChainIterator<A, T, U> {\n     }\n \n     #[inline]\n-    #[cfg(not(stage0))]\n     fn size_hint(&self) -> (Option<uint>, Option<uint>) {\n         let (a_lower, a_upper) = self.a.size_hint();\n         let (b_lower, b_upper) = self.b.size_hint();\n@@ -664,7 +662,6 @@ impl<'self, A, B, T: Iterator<A>> Iterator<B> for MapIterator<'self, A, B, T> {\n     }\n \n     #[inline]\n-    #[cfg(not(stage0))]\n     fn size_hint(&self) -> (Option<uint>, Option<uint>) {\n         self.iter.size_hint()\n     }\n@@ -690,7 +687,6 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for FilterIterator<'self, A, T> {\n     }\n \n     #[inline]\n-    #[cfg(not(stage0))]\n     fn size_hint(&self) -> (Option<uint>, Option<uint>) {\n         let (_, upper) = self.iter.size_hint();\n         (None, upper) // can't know a lower bound, due to the predicate\n@@ -716,7 +712,6 @@ impl<'self, A, B, T: Iterator<A>> Iterator<B> for FilterMapIterator<'self, A, B,\n     }\n \n     #[inline]\n-    #[cfg(not(stage0))]\n     fn size_hint(&self) -> (Option<uint>, Option<uint>) {\n         let (_, upper) = self.iter.size_hint();\n         (None, upper) // can't know a lower bound, due to the predicate"}, {"sha": "523645e69a52ae16af6436b3959c48816ca089cf", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 872, "deletions": 316, "changes": 1188, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -102,10 +102,12 @@ pub use libc::funcs::posix88::stdio::*;\n pub use libc::funcs::posix88::fcntl::*;\n pub use libc::funcs::posix88::dirent::*;\n pub use libc::funcs::posix88::unistd::*;\n+pub use libc::funcs::posix88::mman::*;\n \n pub use libc::funcs::posix01::stat_::*;\n pub use libc::funcs::posix01::unistd::*;\n pub use libc::funcs::posix01::glob::*;\n+pub use libc::funcs::posix01::mman::*;\n pub use libc::funcs::posix08::unistd::*;\n \n pub use libc::funcs::bsd44::*;\n@@ -285,7 +287,7 @@ pub mod types {\n             #[cfg(target_arch = \"x86\")]\n             #[cfg(target_arch = \"mips\")]\n             pub mod posix01 {\n-                use libc::types::os::arch::c95::{c_short, c_long, c_ulong, time_t};\n+                use libc::types::os::arch::c95::{c_short, c_long, time_t};\n                 use libc::types::os::arch::posix88::{dev_t, gid_t, ino_t};\n                 use libc::types::os::arch::posix88::{mode_t, off_t};\n                 use libc::types::os::arch::posix88::{uid_t};\n@@ -903,52 +905,56 @@ pub mod consts {\n     #[cfg(target_os = \"win32\")]\n     pub mod os {\n         pub mod c95 {\n-            pub static EXIT_FAILURE : int = 1;\n-            pub static EXIT_SUCCESS : int = 0;\n-            pub static RAND_MAX : int = 32767;\n-            pub static EOF : int = -1;\n-            pub static SEEK_SET : int = 0;\n-            pub static SEEK_CUR : int = 1;\n-            pub static SEEK_END : int = 2;\n-            pub static _IOFBF : int = 0;\n-            pub static _IONBF : int = 4;\n-            pub static _IOLBF : int = 64;\n-            pub static BUFSIZ : uint = 512_u;\n-            pub static FOPEN_MAX : uint = 20_u;\n-            pub static FILENAME_MAX : uint = 260_u;\n-            pub static L_tmpnam : uint = 16_u;\n-            pub static TMP_MAX : uint = 32767_u;\n+            use libc::types::os::arch::c95::{c_int, c_uint};\n+\n+            pub static EXIT_FAILURE : c_int = 1;\n+            pub static EXIT_SUCCESS : c_int = 0;\n+            pub static RAND_MAX : c_int = 32767;\n+            pub static EOF : c_int = -1;\n+            pub static SEEK_SET : c_int = 0;\n+            pub static SEEK_CUR : c_int = 1;\n+            pub static SEEK_END : c_int = 2;\n+            pub static _IOFBF : c_int = 0;\n+            pub static _IONBF : c_int = 4;\n+            pub static _IOLBF : c_int = 64;\n+            pub static BUFSIZ : c_uint = 512_u32;\n+            pub static FOPEN_MAX : c_uint = 20_u32;\n+            pub static FILENAME_MAX : c_uint = 260_u32;\n+            pub static L_tmpnam : c_uint = 16_u32;\n+            pub static TMP_MAX : c_uint = 32767_u32;\n         }\n         pub mod c99 {\n         }\n         pub mod posix88 {\n-            pub static O_RDONLY : int = 0;\n-            pub static O_WRONLY : int = 1;\n-            pub static O_RDWR : int = 2;\n-            pub static O_APPEND : int = 8;\n-            pub static O_CREAT : int = 256;\n-            pub static O_EXCL : int = 1024;\n-            pub static O_TRUNC : int = 512;\n-            pub static S_IFIFO : int = 4096;\n-            pub static S_IFCHR : int = 8192;\n-            pub static S_IFBLK : int = 12288;\n-            pub static S_IFDIR : int = 16384;\n-            pub static S_IFREG : int = 32768;\n-            pub static S_IFMT : int = 61440;\n-            pub static S_IEXEC : int = 64;\n-            pub static S_IWRITE : int = 128;\n-            pub static S_IREAD : int = 256;\n-            pub static S_IRWXU : int = 448;\n-            pub static S_IXUSR : int = 64;\n-            pub static S_IWUSR : int = 128;\n-            pub static S_IRUSR : int = 256;\n-            pub static F_OK : int = 0;\n-            pub static R_OK : int = 4;\n-            pub static W_OK : int = 2;\n-            pub static X_OK : int = 1;\n-            pub static STDIN_FILENO : int = 0;\n-            pub static STDOUT_FILENO : int = 1;\n-            pub static STDERR_FILENO : int = 2;\n+            use libc::types::os::arch::c95::c_int;\n+\n+            pub static O_RDONLY : c_int = 0;\n+            pub static O_WRONLY : c_int = 1;\n+            pub static O_RDWR : c_int = 2;\n+            pub static O_APPEND : c_int = 8;\n+            pub static O_CREAT : c_int = 256;\n+            pub static O_EXCL : c_int = 1024;\n+            pub static O_TRUNC : c_int = 512;\n+            pub static S_IFIFO : c_int = 4096;\n+            pub static S_IFCHR : c_int = 8192;\n+            pub static S_IFBLK : c_int = 12288;\n+            pub static S_IFDIR : c_int = 16384;\n+            pub static S_IFREG : c_int = 32768;\n+            pub static S_IFMT : c_int = 61440;\n+            pub static S_IEXEC : c_int = 64;\n+            pub static S_IWRITE : c_int = 128;\n+            pub static S_IREAD : c_int = 256;\n+            pub static S_IRWXU : c_int = 448;\n+            pub static S_IXUSR : c_int = 64;\n+            pub static S_IWUSR : c_int = 128;\n+            pub static S_IRUSR : c_int = 256;\n+            pub static F_OK : c_int = 0;\n+            pub static R_OK : c_int = 4;\n+            pub static W_OK : c_int = 2;\n+            pub static X_OK : c_int = 1;\n+            pub static STDIN_FILENO : c_int = 0;\n+            pub static STDOUT_FILENO : c_int = 1;\n+            pub static STDERR_FILENO : c_int = 2;\n         }\n         pub mod posix01 {\n         }\n@@ -957,18 +963,19 @@ pub mod consts {\n         pub mod bsd44 {\n         }\n         pub mod extra {\n+            use libc::types::os::arch::c95::c_int;\n             use libc::types::os::arch::extra::{DWORD, BOOL};\n \n             pub static TRUE : BOOL = 1;\n             pub static FALSE : BOOL = 0;\n \n-            pub static O_TEXT : int = 16384;\n-            pub static O_BINARY : int = 32768;\n-            pub static O_NOINHERIT: int = 128;\n+            pub static O_TEXT : c_int = 16384;\n+            pub static O_BINARY : c_int = 32768;\n+            pub static O_NOINHERIT: c_int = 128;\n \n-            pub static ERROR_SUCCESS : int = 0;\n-            pub static ERROR_INSUFFICIENT_BUFFER : int = 122;\n-            pub static INVALID_HANDLE_VALUE: int = -1;\n+            pub static ERROR_SUCCESS : c_int = 0;\n+            pub static ERROR_INSUFFICIENT_BUFFER : c_int = 122;\n+            pub static INVALID_HANDLE_VALUE: c_int = -1;\n \n             pub static DELETE : DWORD = 0x00010000;\n             pub static READ_CONTROL : DWORD = 0x00020000;\n@@ -1021,331 +1028,815 @@ pub mod consts {\n     #[cfg(target_os = \"android\")]\n     pub mod os {\n         pub mod c95 {\n-            pub static EXIT_FAILURE : int = 1;\n-            pub static EXIT_SUCCESS : int = 0;\n-            pub static RAND_MAX : int = 2147483647;\n-            pub static EOF : int = -1;\n-            pub static SEEK_SET : int = 0;\n-            pub static SEEK_CUR : int = 1;\n-            pub static SEEK_END : int = 2;\n-            pub static _IOFBF : int = 0;\n-            pub static _IONBF : int = 2;\n-            pub static _IOLBF : int = 1;\n-            pub static BUFSIZ : uint = 8192_u;\n-            pub static FOPEN_MAX : uint = 16_u;\n-            pub static FILENAME_MAX : uint = 4096_u;\n-            pub static L_tmpnam : uint = 20_u;\n-            pub static TMP_MAX : uint = 238328_u;\n+            use libc::types::os::arch::c95::{c_int, c_uint};\n+\n+            pub static EXIT_FAILURE : c_int = 1;\n+            pub static EXIT_SUCCESS : c_int = 0;\n+            pub static RAND_MAX : c_int = 2147483647;\n+            pub static EOF : c_int = -1;\n+            pub static SEEK_SET : c_int = 0;\n+            pub static SEEK_CUR : c_int = 1;\n+            pub static SEEK_END : c_int = 2;\n+            pub static _IOFBF : c_int = 0;\n+            pub static _IONBF : c_int = 2;\n+            pub static _IOLBF : c_int = 1;\n+            pub static BUFSIZ : c_uint = 8192_u32;\n+            pub static FOPEN_MAX : c_uint = 16_u32;\n+            pub static FILENAME_MAX : c_uint = 4096_u32;\n+            pub static L_tmpnam : c_uint = 20_u32;\n+            pub static TMP_MAX : c_uint = 238328_u32;\n         }\n         pub mod c99 {\n         }\n         #[cfg(target_arch = \"x86\")]\n         #[cfg(target_arch = \"x86_64\")]\n         #[cfg(target_arch = \"arm\")]\n         pub mod posix88 {\n-            pub static O_RDONLY : int = 0;\n-            pub static O_WRONLY : int = 1;\n-            pub static O_RDWR : int = 2;\n-            pub static O_APPEND : int = 1024;\n-            pub static O_CREAT : int = 64;\n-            pub static O_EXCL : int = 128;\n-            pub static O_TRUNC : int = 512;\n-            pub static S_IFIFO : int = 4096;\n-            pub static S_IFCHR : int = 8192;\n-            pub static S_IFBLK : int = 24576;\n-            pub static S_IFDIR : int = 16384;\n-            pub static S_IFREG : int = 32768;\n-            pub static S_IFMT : int = 61440;\n-            pub static S_IEXEC : int = 64;\n-            pub static S_IWRITE : int = 128;\n-            pub static S_IREAD : int = 256;\n-            pub static S_IRWXU : int = 448;\n-            pub static S_IXUSR : int = 64;\n-            pub static S_IWUSR : int = 128;\n-            pub static S_IRUSR : int = 256;\n-            pub static F_OK : int = 0;\n-            pub static R_OK : int = 4;\n-            pub static W_OK : int = 2;\n-            pub static X_OK : int = 1;\n-            pub static STDIN_FILENO : int = 0;\n-            pub static STDOUT_FILENO : int = 1;\n-            pub static STDERR_FILENO : int = 2;\n-            pub static F_LOCK : int = 1;\n-            pub static F_TEST : int = 3;\n-            pub static F_TLOCK : int = 2;\n-            pub static F_ULOCK : int = 0;\n-            pub static SIGHUP : int = 1;\n-            pub static SIGINT : int = 2;\n-            pub static SIGQUIT : int = 3;\n-            pub static SIGILL : int = 4;\n-            pub static SIGABRT : int = 6;\n-            pub static SIGFPE : int = 8;\n-            pub static SIGKILL : int = 9;\n-            pub static SIGSEGV : int = 11;\n-            pub static SIGPIPE : int = 13;\n-            pub static SIGALRM : int = 14;\n-            pub static SIGTERM : int = 15;\n+            use libc::types::os::arch::c95::c_int;\n+            use libc::types::common::c95::c_void;\n+\n+            pub static O_RDONLY : c_int = 0;\n+            pub static O_WRONLY : c_int = 1;\n+            pub static O_RDWR : c_int = 2;\n+            pub static O_APPEND : c_int = 1024;\n+            pub static O_CREAT : c_int = 64;\n+            pub static O_EXCL : c_int = 128;\n+            pub static O_TRUNC : c_int = 512;\n+            pub static S_IFIFO : c_int = 4096;\n+            pub static S_IFCHR : c_int = 8192;\n+            pub static S_IFBLK : c_int = 24576;\n+            pub static S_IFDIR : c_int = 16384;\n+            pub static S_IFREG : c_int = 32768;\n+            pub static S_IFMT : c_int = 61440;\n+            pub static S_IEXEC : c_int = 64;\n+            pub static S_IWRITE : c_int = 128;\n+            pub static S_IREAD : c_int = 256;\n+            pub static S_IRWXU : c_int = 448;\n+            pub static S_IXUSR : c_int = 64;\n+            pub static S_IWUSR : c_int = 128;\n+            pub static S_IRUSR : c_int = 256;\n+            pub static F_OK : c_int = 0;\n+            pub static R_OK : c_int = 4;\n+            pub static W_OK : c_int = 2;\n+            pub static X_OK : c_int = 1;\n+            pub static STDIN_FILENO : c_int = 0;\n+            pub static STDOUT_FILENO : c_int = 1;\n+            pub static STDERR_FILENO : c_int = 2;\n+            pub static F_LOCK : c_int = 1;\n+            pub static F_TEST : c_int = 3;\n+            pub static F_TLOCK : c_int = 2;\n+            pub static F_ULOCK : c_int = 0;\n+            pub static SIGHUP : c_int = 1;\n+            pub static SIGINT : c_int = 2;\n+            pub static SIGQUIT : c_int = 3;\n+            pub static SIGILL : c_int = 4;\n+            pub static SIGABRT : c_int = 6;\n+            pub static SIGFPE : c_int = 8;\n+            pub static SIGKILL : c_int = 9;\n+            pub static SIGSEGV : c_int = 11;\n+            pub static SIGPIPE : c_int = 13;\n+            pub static SIGALRM : c_int = 14;\n+            pub static SIGTERM : c_int = 15;\n+\n+            pub static PROT_NONE : c_int = 0;\n+            pub static PROT_READ : c_int = 1;\n+            pub static PROT_WRITE : c_int = 2;\n+            pub static PROT_EXEC : c_int = 4;\n+\n+            pub static MAP_FILE : c_int = 0x0000;\n+            pub static MAP_SHARED : c_int = 0x0001;\n+            pub static MAP_PRIVATE : c_int = 0x0002;\n+            pub static MAP_FIXED : c_int = 0x0010;\n+            pub static MAP_ANON : c_int = 0x1000;\n+\n+            pub static MAP_FAILED : *c_void = -1 as *c_void;\n+\n+            pub static MCL_CURRENT : c_int = 0x0001;\n+            pub static MCL_FUTURE : c_int = 0x0002;\n+\n+            pub static MS_ASYNC : c_int = 0x0001;\n+            pub static MS_INVALIDATE : c_int = 0x0002;\n+            pub static MS_SYNC : c_int = 0x0004;\n         }\n         #[cfg(target_arch = \"mips\")]\n         pub mod posix88 {\n-            pub static O_RDONLY : int = 0;\n-            pub static O_WRONLY : int = 1;\n-            pub static O_RDWR : int = 2;\n-            pub static O_APPEND : int = 8;\n-            pub static O_CREAT : int = 256;\n-            pub static O_EXCL : int = 1024;\n-            pub static O_TRUNC : int = 512;\n-            pub static S_IFIFO : int = 4096;\n-            pub static S_IFCHR : int = 8192;\n-            pub static S_IFBLK : int = 24576;\n-            pub static S_IFDIR : int = 16384;\n-            pub static S_IFREG : int = 32768;\n-            pub static S_IFMT : int = 61440;\n-            pub static S_IEXEC : int = 64;\n-            pub static S_IWRITE : int = 128;\n-            pub static S_IREAD : int = 256;\n-            pub static S_IRWXU : int = 448;\n-            pub static S_IXUSR : int = 64;\n-            pub static S_IWUSR : int = 128;\n-            pub static S_IRUSR : int = 256;\n-            pub static F_OK : int = 0;\n-            pub static R_OK : int = 4;\n-            pub static W_OK : int = 2;\n-            pub static X_OK : int = 1;\n-            pub static STDIN_FILENO : int = 0;\n-            pub static STDOUT_FILENO : int = 1;\n-            pub static STDERR_FILENO : int = 2;\n-            pub static F_LOCK : int = 1;\n-            pub static F_TEST : int = 3;\n-            pub static F_TLOCK : int = 2;\n-            pub static F_ULOCK : int = 0;\n-            pub static SIGHUP : int = 1;\n-            pub static SIGINT : int = 2;\n-            pub static SIGQUIT : int = 3;\n-            pub static SIGILL : int = 4;\n-            pub static SIGABRT : int = 6;\n-            pub static SIGFPE : int = 8;\n-            pub static SIGKILL : int = 9;\n-            pub static SIGSEGV : int = 11;\n-            pub static SIGPIPE : int = 13;\n-            pub static SIGALRM : int = 14;\n-            pub static SIGTERM : int = 15;\n+            use libc::types::os::arch::c95::c_int;\n+            use libc::types::common::c95::c_void;\n+\n+            pub static O_RDONLY : c_int = 0;\n+            pub static O_WRONLY : c_int = 1;\n+            pub static O_RDWR : c_int = 2;\n+            pub static O_APPEND : c_int = 8;\n+            pub static O_CREAT : c_int = 256;\n+            pub static O_EXCL : c_int = 1024;\n+            pub static O_TRUNC : c_int = 512;\n+            pub static S_IFIFO : c_int = 4096;\n+            pub static S_IFCHR : c_int = 8192;\n+            pub static S_IFBLK : c_int = 24576;\n+            pub static S_IFDIR : c_int = 16384;\n+            pub static S_IFREG : c_int = 32768;\n+            pub static S_IFMT : c_int = 61440;\n+            pub static S_IEXEC : c_int = 64;\n+            pub static S_IWRITE : c_int = 128;\n+            pub static S_IREAD : c_int = 256;\n+            pub static S_IRWXU : c_int = 448;\n+            pub static S_IXUSR : c_int = 64;\n+            pub static S_IWUSR : c_int = 128;\n+            pub static S_IRUSR : c_int = 256;\n+            pub static F_OK : c_int = 0;\n+            pub static R_OK : c_int = 4;\n+            pub static W_OK : c_int = 2;\n+            pub static X_OK : c_int = 1;\n+            pub static STDIN_FILENO : c_int = 0;\n+            pub static STDOUT_FILENO : c_int = 1;\n+            pub static STDERR_FILENO : c_int = 2;\n+            pub static F_LOCK : c_int = 1;\n+            pub static F_TEST : c_int = 3;\n+            pub static F_TLOCK : c_int = 2;\n+            pub static F_ULOCK : c_int = 0;\n+            pub static SIGHUP : c_int = 1;\n+            pub static SIGINT : c_int = 2;\n+            pub static SIGQUIT : c_int = 3;\n+            pub static SIGILL : c_int = 4;\n+            pub static SIGABRT : c_int = 6;\n+            pub static SIGFPE : c_int = 8;\n+            pub static SIGKILL : c_int = 9;\n+            pub static SIGSEGV : c_int = 11;\n+            pub static SIGPIPE : c_int = 13;\n+            pub static SIGALRM : c_int = 14;\n+            pub static SIGTERM : c_int = 15;\n+\n+            pub static PROT_NONE : c_int = 0;\n+            pub static PROT_READ : c_int = 1;\n+            pub static PROT_WRITE : c_int = 2;\n+            pub static PROT_EXEC : c_int = 4;\n+\n+            pub static MAP_FILE : c_int = 0x0000;\n+            pub static MAP_SHARED : c_int = 0x0001;\n+            pub static MAP_PRIVATE : c_int = 0x0002;\n+            pub static MAP_FIXED : c_int = 0x0010;\n+            pub static MAP_ANON : c_int = 0x1000;\n+\n+            pub static MAP_FAILED : *c_void = -1 as *c_void;\n+\n+            pub static MCL_CURRENT : c_int = 0x0001;\n+            pub static MCL_FUTURE : c_int = 0x0002;\n+\n+            pub static MS_ASYNC : c_int = 0x0001;\n+            pub static MS_INVALIDATE : c_int = 0x0002;\n+            pub static MS_SYNC : c_int = 0x0004;\n+\n+            pub static _SC_ARG_MAX : c_int = 0;\n+            pub static _SC_CHILD_MAX : c_int = 1;\n+            pub static _SC_CLK_TCK : c_int = 2;\n+            pub static _SC_NGROUPS_MAX : c_int = 3;\n+            pub static _SC_OPEN_MAX : c_int = 4;\n+            pub static _SC_STREAM_MAX : c_int = 5;\n+            pub static _SC_TZNAME_MAX : c_int = 6;\n+            pub static _SC_JOB_CONTROL : c_int = 7;\n+            pub static _SC_SAVED_IDS : c_int = 8;\n+            pub static _SC_REALTIME_SIGNALS : c_int = 9;\n+            pub static _SC_PRIORITY_SCHEDULING : c_int = 10;\n+            pub static _SC_TIMERS : c_int = 11;\n+            pub static _SC_ASYNCHRONOUS_IO : c_int = 12;\n+            pub static _SC_PRIORITIZED_IO : c_int = 13;\n+            pub static _SC_SYNCHRONIZED_IO : c_int = 14;\n+            pub static _SC_FSYNC : c_int = 15;\n+            pub static _SC_MAPPED_FILES : c_int = 16;\n+            pub static _SC_MEMLOCK : c_int = 17;\n+            pub static _SC_MEMLOCK_RANGE : c_int = 18;\n+            pub static _SC_MEMORY_PROTECTION : c_int = 19;\n+            pub static _SC_MESSAGE_PASSING : c_int = 20;\n+            pub static _SC_SEMAPHORES : c_int = 21;\n+            pub static _SC_SHARED_MEMORY_OBJECTS : c_int = 22;\n+            pub static _SC_AIO_LISTIO_MAX : c_int = 23;\n+            pub static _SC_AIO_MAX : c_int = 24;\n+            pub static _SC_AIO_PRIO_DELTA_MAX : c_int = 25;\n+            pub static _SC_DELAYTIMER_MAX : c_int = 26;\n+            pub static _SC_MQ_OPEN_MAX : c_int = 27;\n+            pub static _SC_VERSION : c_int = 29;\n+            pub static _SC_PAGESIZE : c_int = 30;\n+            pub static _SC_RTSIG_MAX : c_int = 31;\n+            pub static _SC_SEM_NSEMS_MAX : c_int = 32;\n+            pub static _SC_SEM_VALUE_MAX : c_int = 33;\n+            pub static _SC_SIGQUEUE_MAX : c_int = 34;\n+            pub static _SC_TIMER_MAX : c_int = 35;\n+            pub static _SC_BC_BASE_MAX : c_int = 36;\n+            pub static _SC_BC_DIM_MAX : c_int = 37;\n+            pub static _SC_BC_SCALE_MAX : c_int = 38;\n+            pub static _SC_BC_STRING_MAX : c_int = 39;\n+            pub static _SC_COLL_WEIGHTS_MAX : c_int = 40;\n+            pub static _SC_EXPR_NEST_MAX : c_int = 42;\n+            pub static _SC_LINE_MAX : c_int = 43;\n+            pub static _SC_RE_DUP_MAX : c_int = 44;\n+            pub static _SC_2_VERSION : c_int = 46;\n+            pub static _SC_2_C_BIND : c_int = 47;\n+            pub static _SC_2_C_DEV : c_int = 48;\n+            pub static _SC_2_FORT_DEV : c_int = 49;\n+            pub static _SC_2_FORT_RUN : c_int = 50;\n+            pub static _SC_2_SW_DEV : c_int = 51;\n+            pub static _SC_2_LOCALEDEF : c_int = 52;\n+            pub static _SC_2_CHAR_TERM : c_int = 95;\n+            pub static _SC_2_C_VERSION : c_int = 96;\n+            pub static _SC_2_UPE : c_int = 97;\n+            pub static _SC_XBS5_ILP32_OFF32 : c_int = 125;\n+            pub static _SC_XBS5_ILP32_OFFBIG : c_int = 126;\n+            pub static _SC_XBS5_LPBIG_OFFBIG : c_int = 128;\n         }\n         pub mod posix01 {\n-            pub static SIGTRAP : int = 5;\n-\n-            pub static GLOB_ERR      : int = 1 << 0;\n-            pub static GLOB_MARK     : int = 1 << 1;\n-            pub static GLOB_NOSORT   : int = 1 << 2;\n-            pub static GLOB_DOOFFS   : int = 1 << 3;\n-            pub static GLOB_NOCHECK  : int = 1 << 4;\n-            pub static GLOB_APPEND   : int = 1 << 5;\n-            pub static GLOB_NOESCAPE : int = 1 << 6;\n-\n-            pub static GLOB_NOSPACE  : int = 1;\n-            pub static GLOB_ABORTED  : int = 2;\n-            pub static GLOB_NOMATCH  : int = 3;\n+            use libc::types::os::arch::c95::c_int;\n+\n+            pub static SIGTRAP : c_int = 5;\n+\n+            pub static GLOB_ERR      : c_int = 1 << 0;\n+            pub static GLOB_MARK     : c_int = 1 << 1;\n+            pub static GLOB_NOSORT   : c_int = 1 << 2;\n+            pub static GLOB_DOOFFS   : c_int = 1 << 3;\n+            pub static GLOB_NOCHECK  : c_int = 1 << 4;\n+            pub static GLOB_APPEND   : c_int = 1 << 5;\n+            pub static GLOB_NOESCAPE : c_int = 1 << 6;\n+\n+            pub static GLOB_NOSPACE  : c_int = 1;\n+            pub static GLOB_ABORTED  : c_int = 2;\n+            pub static GLOB_NOMATCH  : c_int = 3;\n+\n+            pub static POSIX_MADV_NORMAL : c_int = 0;\n+            pub static POSIX_MADV_RANDOM : c_int = 1;\n+            pub static POSIX_MADV_SEQUENTIAL : c_int = 2;\n+            pub static POSIX_MADV_WILLNEED : c_int = 3;\n+            pub static POSIX_MADV_DONTNEED : c_int = 4;\n+\n+            pub static _SC_MQ_PRIO_MAX : c_int = 28;\n+            pub static _SC_IOV_MAX : c_int = 60;\n+            pub static _SC_GETGR_R_SIZE_MAX : c_int = 69;\n+            pub static _SC_GETPW_R_SIZE_MAX : c_int = 70;\n+            pub static _SC_LOGIN_NAME_MAX : c_int = 71;\n+            pub static _SC_TTY_NAME_MAX : c_int = 72;\n+            pub static _SC_THREADS : c_int = 67;\n+            pub static _SC_THREAD_SAFE_FUNCTIONS : c_int = 68;\n+            pub static _SC_THREAD_DESTRUCTOR_ITERATIONS : c_int = 73;\n+            pub static _SC_THREAD_KEYS_MAX : c_int = 74;\n+            pub static _SC_THREAD_STACK_MIN : c_int = 75;\n+            pub static _SC_THREAD_THREADS_MAX : c_int = 76;\n+            pub static _SC_THREAD_ATTR_STACKADDR : c_int = 77;\n+            pub static _SC_THREAD_ATTR_STACKSIZE : c_int = 78;\n+            pub static _SC_THREAD_PRIORITY_SCHEDULING : c_int = 79;\n+            pub static _SC_THREAD_PRIO_INHERIT : c_int = 80;\n+            pub static _SC_THREAD_PRIO_PROTECT : c_int = 81;\n+            pub static _SC_THREAD_PROCESS_SHARED : c_int = 82;\n+            pub static _SC_ATEXIT_MAX : c_int = 87;\n+            pub static _SC_XOPEN_VERSION : c_int = 89;\n+            pub static _SC_XOPEN_XCU_VERSION : c_int = 90;\n+            pub static _SC_XOPEN_UNIX : c_int = 91;\n+            pub static _SC_XOPEN_CRYPT : c_int = 92;\n+            pub static _SC_XOPEN_ENH_I18N : c_int = 93;\n+            pub static _SC_XOPEN_SHM : c_int = 94;\n+            pub static _SC_XOPEN_LEGACY : c_int = 129;\n+            pub static _SC_XOPEN_REALTIME : c_int = 130;\n+            pub static _SC_XOPEN_REALTIME_THREADS : c_int = 131;\n         }\n         pub mod posix08 {\n         }\n         pub mod bsd44 {\n+            use libc::types::os::arch::c95::c_int;\n+\n+            pub static MADV_NORMAL : c_int = 0;\n+            pub static MADV_RANDOM : c_int = 1;\n+            pub static MADV_SEQUENTIAL : c_int = 2;\n+            pub static MADV_WILLNEED : c_int = 3;\n+            pub static MADV_DONTNEED : c_int = 4;\n+            pub static MADV_REMOVE : c_int = 9;\n+            pub static MADV_DONTFORK : c_int = 10;\n+            pub static MADV_DOFORK : c_int = 11;\n+            pub static MADV_MERGEABLE : c_int = 12;\n+            pub static MADV_UNMERGEABLE : c_int = 13;\n+            pub static MADV_HWPOISON : c_int = 100;\n         }\n         #[cfg(target_arch = \"x86\")]\n         #[cfg(target_arch = \"x86_64\")]\n         #[cfg(target_arch = \"arm\")]\n         pub mod extra {\n-            pub static O_RSYNC : int = 1052672;\n-            pub static O_DSYNC : int = 4096;\n-            pub static O_SYNC : int = 1052672;\n+            use libc::types::os::arch::c95::c_int;\n+\n+            pub static O_RSYNC : c_int = 1052672;\n+            pub static O_DSYNC : c_int = 4096;\n+            pub static O_SYNC : c_int = 1052672;\n+\n+            pub static PROT_GROWSDOWN : c_int = 0x010000000;\n+            pub static PROT_GROWSUP : c_int = 0x020000000;\n+\n+            pub static MAP_TYPE : c_int = 0x000f;\n+            pub static MAP_ANONONYMOUS : c_int = 0x1000;\n+            pub static MAP_32BIT : c_int = 0x0040;\n+            pub static MAP_GROWSDOWN : c_int = 0x0100;\n+            pub static MAP_DENYWRITE : c_int = 0x0800;\n+            pub static MAP_EXECUTABLE : c_int = 0x01000;\n+            pub static MAP_LOCKED : c_int = 0x02000;\n+            pub static MAP_NONRESERVE : c_int = 0x04000;\n+            pub static MAP_POPULATE : c_int = 0x08000;\n+            pub static MAP_NONBLOCK : c_int = 0x010000;\n+            pub static MAP_STACK : c_int = 0x020000;\n         }\n         #[cfg(target_arch = \"mips\")]\n         pub mod extra {\n-            pub static O_RSYNC : int = 16400;\n-            pub static O_DSYNC : int = 16;\n-            pub static O_SYNC : int = 16400;\n+            use libc::types::os::arch::c95::c_int;\n+\n+            pub static O_RSYNC : c_int = 16400;\n+            pub static O_DSYNC : c_int = 16;\n+            pub static O_SYNC : c_int = 16400;\n+\n+            pub static PROT_GROWSDOWN : c_int = 0x010000000;\n+            pub static PROT_GROWSUP : c_int = 0x020000000;\n+\n+            pub static MAP_TYPE : c_int = 0x000f;\n+            pub static MAP_ANONONYMOUS : c_int = 0x1000;\n+            pub static MAP_32BIT : c_int = 0x0040;\n+            pub static MAP_GROWSDOWN : c_int = 0x0100;\n+            pub static MAP_DENYWRITE : c_int = 0x0800;\n+            pub static MAP_EXECUTABLE : c_int = 0x01000;\n+            pub static MAP_LOCKED : c_int = 0x02000;\n+            pub static MAP_NONRESERVE : c_int = 0x04000;\n+            pub static MAP_POPULATE : c_int = 0x08000;\n+            pub static MAP_NONBLOCK : c_int = 0x010000;\n+            pub static MAP_STACK : c_int = 0x020000;\n         }\n     }\n \n     #[cfg(target_os = \"freebsd\")]\n     pub mod os {\n         pub mod c95 {\n-            pub static EXIT_FAILURE : int = 1;\n-            pub static EXIT_SUCCESS : int = 0;\n-            pub static RAND_MAX : int = 2147483647;\n-            pub static EOF : int = -1;\n-            pub static SEEK_SET : int = 0;\n-            pub static SEEK_CUR : int = 1;\n-            pub static SEEK_END : int = 2;\n-            pub static _IOFBF : int = 0;\n-            pub static _IONBF : int = 2;\n-            pub static _IOLBF : int = 1;\n-            pub static BUFSIZ : uint = 1024_u;\n-            pub static FOPEN_MAX : uint = 20_u;\n-            pub static FILENAME_MAX : uint = 1024_u;\n-            pub static L_tmpnam : uint = 1024_u;\n-            pub static TMP_MAX : uint = 308915776_u;\n+            use libc::types::os::arch::c95::{c_int, c_uint};\n+\n+            pub static EXIT_FAILURE : c_int = 1;\n+            pub static EXIT_SUCCESS : c_int = 0;\n+            pub static RAND_MAX : c_int = 2147483647;\n+            pub static EOF : c_int = -1;\n+            pub static SEEK_SET : c_int = 0;\n+            pub static SEEK_CUR : c_int = 1;\n+            pub static SEEK_END : c_int = 2;\n+            pub static _IOFBF : c_int = 0;\n+            pub static _IONBF : c_int = 2;\n+            pub static _IOLBF : c_int = 1;\n+            pub static BUFSIZ : c_uint = 1024_u32;\n+            pub static FOPEN_MAX : c_uint = 20_u32;\n+            pub static FILENAME_MAX : c_uint = 1024_u32;\n+            pub static L_tmpnam : c_uint = 1024_u32;\n+            pub static TMP_MAX : c_uint = 308915776_u32;\n         }\n         pub mod c99 {\n         }\n         pub mod posix88 {\n-            pub static O_RDONLY : int = 0;\n-            pub static O_WRONLY : int = 1;\n-            pub static O_RDWR : int = 2;\n-            pub static O_APPEND : int = 8;\n-            pub static O_CREAT : int = 512;\n-            pub static O_EXCL : int = 2048;\n-            pub static O_TRUNC : int = 1024;\n-            pub static S_IFIFO : int = 4096;\n-            pub static S_IFCHR : int = 8192;\n-            pub static S_IFBLK : int = 24576;\n-            pub static S_IFDIR : int = 16384;\n-            pub static S_IFREG : int = 32768;\n-            pub static S_IFMT : int = 61440;\n-            pub static S_IEXEC : int = 64;\n-            pub static S_IWRITE : int = 128;\n-            pub static S_IREAD : int = 256;\n-            pub static S_IRWXU : int = 448;\n-            pub static S_IXUSR : int = 64;\n-            pub static S_IWUSR : int = 128;\n-            pub static S_IRUSR : int = 256;\n-            pub static F_OK : int = 0;\n-            pub static R_OK : int = 4;\n-            pub static W_OK : int = 2;\n-            pub static X_OK : int = 1;\n-            pub static STDIN_FILENO : int = 0;\n-            pub static STDOUT_FILENO : int = 1;\n-            pub static STDERR_FILENO : int = 2;\n-            pub static F_LOCK : int = 1;\n-            pub static F_TEST : int = 3;\n-            pub static F_TLOCK : int = 2;\n-            pub static F_ULOCK : int = 0;\n-            pub static SIGHUP : int = 1;\n-            pub static SIGINT : int = 2;\n-            pub static SIGQUIT : int = 3;\n-            pub static SIGILL : int = 4;\n-            pub static SIGABRT : int = 6;\n-            pub static SIGFPE : int = 8;\n-            pub static SIGKILL : int = 9;\n-            pub static SIGSEGV : int = 11;\n-            pub static SIGPIPE : int = 13;\n-            pub static SIGALRM : int = 14;\n-            pub static SIGTERM : int = 15;\n+            use libc::types::common::c95::c_void;\n+            use libc::types::os::arch::c95::c_int;\n+\n+            pub static O_RDONLY : c_int = 0;\n+            pub static O_WRONLY : c_int = 1;\n+            pub static O_RDWR : c_int = 2;\n+            pub static O_APPEND : c_int = 8;\n+            pub static O_CREAT : c_int = 512;\n+            pub static O_EXCL : c_int = 2048;\n+            pub static O_TRUNC : c_int = 1024;\n+            pub static S_IFIFO : c_int = 4096;\n+            pub static S_IFCHR : c_int = 8192;\n+            pub static S_IFBLK : c_int = 24576;\n+            pub static S_IFDIR : c_int = 16384;\n+            pub static S_IFREG : c_int = 32768;\n+            pub static S_IFMT : c_int = 61440;\n+            pub static S_IEXEC : c_int = 64;\n+            pub static S_IWRITE : c_int = 128;\n+            pub static S_IREAD : c_int = 256;\n+            pub static S_IRWXU : c_int = 448;\n+            pub static S_IXUSR : c_int = 64;\n+            pub static S_IWUSR : c_int = 128;\n+            pub static S_IRUSR : c_int = 256;\n+            pub static F_OK : c_int = 0;\n+            pub static R_OK : c_int = 4;\n+            pub static W_OK : c_int = 2;\n+            pub static X_OK : c_int = 1;\n+            pub static STDIN_FILENO : c_int = 0;\n+            pub static STDOUT_FILENO : c_int = 1;\n+            pub static STDERR_FILENO : c_int = 2;\n+            pub static F_LOCK : c_int = 1;\n+            pub static F_TEST : c_int = 3;\n+            pub static F_TLOCK : c_int = 2;\n+            pub static F_ULOCK : c_int = 0;\n+            pub static SIGHUP : c_int = 1;\n+            pub static SIGINT : c_int = 2;\n+            pub static SIGQUIT : c_int = 3;\n+            pub static SIGILL : c_int = 4;\n+            pub static SIGABRT : c_int = 6;\n+            pub static SIGFPE : c_int = 8;\n+            pub static SIGKILL : c_int = 9;\n+            pub static SIGSEGV : c_int = 11;\n+            pub static SIGPIPE : c_int = 13;\n+            pub static SIGALRM : c_int = 14;\n+            pub static SIGTERM : c_int = 15;\n+\n+            pub static PROT_NONE : c_int = 0;\n+            pub static PROT_READ : c_int = 1;\n+            pub static PROT_WRITE : c_int = 2;\n+            pub static PROT_EXEC : c_int = 4;\n+\n+            pub static MAP_FILE : c_int = 0x0000;\n+            pub static MAP_SHARED : c_int = 0x0001;\n+            pub static MAP_PRIVATE : c_int = 0x0002;\n+            pub static MAP_FIXED : c_int = 0x0010;\n+            pub static MAP_ANON : c_int = 0x1000;\n+\n+            pub static MAP_FAILED : *c_void = -1 as *c_void;\n+\n+            pub static MCL_CURRENT : c_int = 0x0001;\n+            pub static MCL_FUTURE : c_int = 0x0002;\n+\n+            pub static MS_SYNC : c_int = 0x0000;\n+            pub static MS_ASYNC : c_int = 0x0001;\n+            pub static MS_INVALIDATE : c_int = 0x0002;\n+\n+            pub static _SC_ARG_MAX : c_int = 1;\n+            pub static _SC_CHILD_MAX : c_int = 2;\n+            pub static _SC_CLK_TCK : c_int = 3;\n+            pub static _SC_NGROUPS_MAX : c_int = 4;\n+            pub static _SC_OPEN_MAX : c_int = 5;\n+            pub static _SC_JOB_CONTROL : c_int = 6;\n+            pub static _SC_SAVED_IDS : c_int = 7;\n+            pub static _SC_VERSION : c_int = 8;\n+            pub static _SC_BC_BASE_MAX : c_int = 9;\n+            pub static _SC_BC_DIM_MAX : c_int = 10;\n+            pub static _SC_BC_SCALE_MAX : c_int = 11;\n+            pub static _SC_BC_STRING_MAX : c_int = 12;\n+            pub static _SC_COLL_WEIGHTS_MAX : c_int = 13;\n+            pub static _SC_EXPR_NEST_MAX : c_int = 14;\n+            pub static _SC_LINE_MAX : c_int = 15;\n+            pub static _SC_RE_DUP_MAX : c_int = 16;\n+            pub static _SC_2_VERSION : c_int = 17;\n+            pub static _SC_2_C_BIND : c_int = 18;\n+            pub static _SC_2_C_DEV : c_int = 19;\n+            pub static _SC_2_CHAR_TERM : c_int = 20;\n+            pub static _SC_2_FORT_DEV : c_int = 21;\n+            pub static _SC_2_FORT_RUN : c_int = 22;\n+            pub static _SC_2_LOCALEDEF : c_int = 23;\n+            pub static _SC_2_SW_DEV : c_int = 24;\n+            pub static _SC_2_UPE : c_int = 25;\n+            pub static _SC_STREAM_MAX : c_int = 26;\n+            pub static _SC_TZNAME_MAX : c_int = 27;\n+            pub static _SC_ASYNCHRONOUS_IO : c_int = 28;\n+            pub static _SC_MAPPED_FILES : c_int = 29;\n+            pub static _SC_MEMLOCK : c_int = 30;\n+            pub static _SC_MEMLOCK_RANGE : c_int = 31;\n+            pub static _SC_MEMORY_PROTECTION : c_int = 32;\n+            pub static _SC_MESSAGE_PASSING : c_int = 33;\n+            pub static _SC_PRIORITIZED_IO : c_int = 34;\n+            pub static _SC_PRIORITY_SCHEDULING : c_int = 35;\n+            pub static _SC_REALTIME_SIGNALS : c_int = 36;\n+            pub static _SC_SEMAPHORES : c_int = 37;\n+            pub static _SC_FSYNC : c_int = 38;\n+            pub static _SC_SHARED_MEMORY_OBJECTS : c_int = 39;\n+            pub static _SC_SYNCHRONIZED_IO : c_int = 40;\n+            pub static _SC_TIMERS : c_int = 41;\n+            pub static _SC_AIO_LISTIO_MAX : c_int = 42;\n+            pub static _SC_AIO_MAX : c_int = 43;\n+            pub static _SC_AIO_PRIO_DELTA_MAX : c_int = 44;\n+            pub static _SC_DELAYTIMER_MAX : c_int = 45;\n+            pub static _SC_MQ_OPEN_MAX : c_int = 46;\n+            pub static _SC_PAGESIZE : c_int = 47;\n+            pub static _SC_RTSIG_MAX : c_int = 48;\n+            pub static _SC_SEM_NSEMS_MAX : c_int = 49;\n+            pub static _SC_SEM_VALUE_MAX : c_int = 50;\n+            pub static _SC_SIGQUEUE_MAX : c_int = 51;\n+            pub static _SC_TIMER_MAX : c_int = 52;\n         }\n         pub mod posix01 {\n-            pub static SIGTRAP : int = 5;\n-\n-            pub static GLOB_APPEND   : int = 0x0001;\n-            pub static GLOB_DOOFFS   : int = 0x0002;\n-            pub static GLOB_ERR      : int = 0x0004;\n-            pub static GLOB_MARK     : int = 0x0008;\n-            pub static GLOB_NOCHECK  : int = 0x0010;\n-            pub static GLOB_NOSORT   : int = 0x0020;\n-            pub static GLOB_NOESCAPE : int = 0x2000;\n-\n-            pub static GLOB_NOSPACE  : int = -1;\n-            pub static GLOB_ABORTED  : int = -2;\n-            pub static GLOB_NOMATCH  : int = -3;\n+            use libc::types::os::arch::c95::c_int;\n+\n+            pub static SIGTRAP : c_int = 5;\n+\n+            pub static GLOB_APPEND   : c_int = 0x0001;\n+            pub static GLOB_DOOFFS   : c_int = 0x0002;\n+            pub static GLOB_ERR      : c_int = 0x0004;\n+            pub static GLOB_MARK     : c_int = 0x0008;\n+            pub static GLOB_NOCHECK  : c_int = 0x0010;\n+            pub static GLOB_NOSORT   : c_int = 0x0020;\n+            pub static GLOB_NOESCAPE : c_int = 0x2000;\n+\n+            pub static GLOB_NOSPACE  : c_int = -1;\n+            pub static GLOB_ABORTED  : c_int = -2;\n+            pub static GLOB_NOMATCH  : c_int = -3;\n+\n+            pub static POSIX_MADV_NORMAL : c_int = 0;\n+            pub static POSIX_MADV_RANDOM : c_int = 1;\n+            pub static POSIX_MADV_SEQUENTIAL : c_int = 2;\n+            pub static POSIX_MADV_WILLNEED : c_int = 3;\n+            pub static POSIX_MADV_DONTNEED : c_int = 4;\n+\n+            pub static _SC_IOV_MAX : c_int = 56;\n+            pub static _SC_GETGR_R_SIZE_MAX : c_int = 70;\n+            pub static _SC_GETPW_R_SIZE_MAX : c_int = 71;\n+            pub static _SC_LOGIN_NAME_MAX : c_int = 73;\n+            pub static _SC_MQ_PRIO_MAX : c_int = 75;\n+            pub static _SC_THREAD_ATTR_STACKADDR : c_int = 82;\n+            pub static _SC_THREAD_ATTR_STACKSIZE : c_int = 83;\n+            pub static _SC_THREAD_DESTRUCTOR_ITERATIONS : c_int = 85;\n+            pub static _SC_THREAD_KEYS_MAX : c_int = 86;\n+            pub static _SC_THREAD_PRIO_INHERIT : c_int = 87;\n+            pub static _SC_THREAD_PRIO_PROTECT : c_int = 88;\n+            pub static _SC_THREAD_PRIORITY_SCHEDULING : c_int = 89;\n+            pub static _SC_THREAD_PROCESS_SHARED : c_int = 90;\n+            pub static _SC_THREAD_SAFE_FUNCTIONS : c_int = 91;\n+            pub static _SC_THREAD_STACK_MIN : c_int = 93;\n+            pub static _SC_THREAD_THREADS_MAX : c_int = 94;\n+            pub static _SC_THREADS : c_int = 96;\n+            pub static _SC_TTY_NAME_MAX : c_int = 101;\n+            pub static _SC_ATEXIT_MAX : c_int = 107;\n+            pub static _SC_XOPEN_CRYPT : c_int = 108;\n+            pub static _SC_XOPEN_ENH_I18N : c_int = 109;\n+            pub static _SC_XOPEN_LEGACY : c_int = 110;\n+            pub static _SC_XOPEN_REALTIME : c_int = 111;\n+            pub static _SC_XOPEN_REALTIME_THREADS : c_int = 112;\n+            pub static _SC_XOPEN_SHM : c_int = 113;\n+            pub static _SC_XOPEN_UNIX : c_int = 115;\n+            pub static _SC_XOPEN_VERSION : c_int = 116;\n+            pub static _SC_XOPEN_XCU_VERSION : c_int = 117;\n         }\n         pub mod posix08 {\n         }\n         pub mod bsd44 {\n+            use libc::types::os::arch::c95::c_int;\n+\n+            pub static MADV_NORMAL : c_int = 0;\n+            pub static MADV_RANDOM : c_int = 1;\n+            pub static MADV_SEQUENTIAL : c_int = 2;\n+            pub static MADV_WILLNEED : c_int = 3;\n+            pub static MADV_DONTNEED : c_int = 4;\n+            pub static MADV_FREE : c_int = 5;\n+            pub static MADV_NOSYNC : c_int = 6;\n+            pub static MADV_AUTOSYNC : c_int = 7;\n+            pub static MADV_NOCORE : c_int = 8;\n+            pub static MADV_CORE : c_int = 9;\n+            pub static MADV_PROTECT : c_int = 10;\n+\n+            pub static MINCORE_INCORE : c_int =  0x1;\n+            pub static MINCORE_REFERENCED : c_int = 0x2;\n+            pub static MINCORE_MODIFIED : c_int = 0x4;\n+            pub static MINCORE_REFERENCED_OTHER : c_int = 0x8;\n+            pub static MINCORE_MODIFIED_OTHER : c_int = 0x10;\n+            pub static MINCORE_SUPER : c_int = 0x20;\n         }\n         pub mod extra {\n-            pub static O_SYNC : int = 128;\n-            pub static CTL_KERN: int = 1;\n-            pub static KERN_PROC: int = 14;\n-            pub static KERN_PROC_PATHNAME: int = 12;\n+            use libc::types::os::arch::c95::c_int;\n+\n+            pub static O_SYNC : c_int = 128;\n+            pub static CTL_KERN: c_int = 1;\n+            pub static KERN_PROC: c_int = 14;\n+            pub static KERN_PROC_PATHNAME: c_int = 12;\n+\n+            pub static MAP_COPY : c_int = 0x0002;\n+            pub static MAP_RENAME : c_int = 0x0020;\n+            pub static MAP_NORESERVE : c_int = 0x0040;\n+            pub static MAP_HASSEMAPHORE : c_int = 0x0200;\n+            pub static MAP_STACK : c_int = 0x0400;\n+            pub static MAP_NOSYNC : c_int = 0x0800;\n+            pub static MAP_NOCORE : c_int = 0x020000;\n         }\n     }\n \n     #[cfg(target_os = \"macos\")]\n     pub mod os {\n         pub mod c95 {\n-            pub static EXIT_FAILURE : int = 1;\n-            pub static EXIT_SUCCESS : int = 0;\n-            pub static RAND_MAX : int = 2147483647;\n-            pub static EOF : int = -1;\n-            pub static SEEK_SET : int = 0;\n-            pub static SEEK_CUR : int = 1;\n-            pub static SEEK_END : int = 2;\n-            pub static _IOFBF : int = 0;\n-            pub static _IONBF : int = 2;\n-            pub static _IOLBF : int = 1;\n-            pub static BUFSIZ : uint = 1024_u;\n-            pub static FOPEN_MAX : uint = 20_u;\n-            pub static FILENAME_MAX : uint = 1024_u;\n-            pub static L_tmpnam : uint = 1024_u;\n-            pub static TMP_MAX : uint = 308915776_u;\n+            use libc::types::os::arch::c95::{c_int, c_uint};\n+\n+            pub static EXIT_FAILURE : c_int = 1;\n+            pub static EXIT_SUCCESS : c_int = 0;\n+            pub static RAND_MAX : c_int = 2147483647;\n+            pub static EOF : c_int = -1;\n+            pub static SEEK_SET : c_int = 0;\n+            pub static SEEK_CUR : c_int = 1;\n+            pub static SEEK_END : c_int = 2;\n+            pub static _IOFBF : c_int = 0;\n+            pub static _IONBF : c_int = 2;\n+            pub static _IOLBF : c_int = 1;\n+            pub static BUFSIZ : c_uint = 1024_u32;\n+            pub static FOPEN_MAX : c_uint = 20_u32;\n+            pub static FILENAME_MAX : c_uint = 1024_u32;\n+            pub static L_tmpnam : c_uint = 1024_u32;\n+            pub static TMP_MAX : c_uint = 308915776_u32;\n         }\n         pub mod c99 {\n         }\n         pub mod posix88 {\n-            pub static O_RDONLY : int = 0;\n-            pub static O_WRONLY : int = 1;\n-            pub static O_RDWR : int = 2;\n-            pub static O_APPEND : int = 8;\n-            pub static O_CREAT : int = 512;\n-            pub static O_EXCL : int = 2048;\n-            pub static O_TRUNC : int = 1024;\n-            pub static S_IFIFO : int = 4096;\n-            pub static S_IFCHR : int = 8192;\n-            pub static S_IFBLK : int = 24576;\n-            pub static S_IFDIR : int = 16384;\n-            pub static S_IFREG : int = 32768;\n-            pub static S_IFMT : int = 61440;\n-            pub static S_IEXEC : int = 64;\n-            pub static S_IWRITE : int = 128;\n-            pub static S_IREAD : int = 256;\n-            pub static S_IRWXU : int = 448;\n-            pub static S_IXUSR : int = 64;\n-            pub static S_IWUSR : int = 128;\n-            pub static S_IRUSR : int = 256;\n-            pub static F_OK : int = 0;\n-            pub static R_OK : int = 4;\n-            pub static W_OK : int = 2;\n-            pub static X_OK : int = 1;\n-            pub static STDIN_FILENO : int = 0;\n-            pub static STDOUT_FILENO : int = 1;\n-            pub static STDERR_FILENO : int = 2;\n-            pub static F_LOCK : int = 1;\n-            pub static F_TEST : int = 3;\n-            pub static F_TLOCK : int = 2;\n-            pub static F_ULOCK : int = 0;\n-            pub static SIGHUP : int = 1;\n-            pub static SIGINT : int = 2;\n-            pub static SIGQUIT : int = 3;\n-            pub static SIGILL : int = 4;\n-            pub static SIGABRT : int = 6;\n-            pub static SIGFPE : int = 8;\n-            pub static SIGKILL : int = 9;\n-            pub static SIGSEGV : int = 11;\n-            pub static SIGPIPE : int = 13;\n-            pub static SIGALRM : int = 14;\n-            pub static SIGTERM : int = 15;\n+            use libc::types::common::c95::c_void;\n+            use libc::types::os::arch::c95::c_int;\n+\n+            pub static O_RDONLY : c_int = 0;\n+            pub static O_WRONLY : c_int = 1;\n+            pub static O_RDWR : c_int = 2;\n+            pub static O_APPEND : c_int = 8;\n+            pub static O_CREAT : c_int = 512;\n+            pub static O_EXCL : c_int = 2048;\n+            pub static O_TRUNC : c_int = 1024;\n+            pub static S_IFIFO : c_int = 4096;\n+            pub static S_IFCHR : c_int = 8192;\n+            pub static S_IFBLK : c_int = 24576;\n+            pub static S_IFDIR : c_int = 16384;\n+            pub static S_IFREG : c_int = 32768;\n+            pub static S_IFMT : c_int = 61440;\n+            pub static S_IEXEC : c_int = 64;\n+            pub static S_IWRITE : c_int = 128;\n+            pub static S_IREAD : c_int = 256;\n+            pub static S_IRWXU : c_int = 448;\n+            pub static S_IXUSR : c_int = 64;\n+            pub static S_IWUSR : c_int = 128;\n+            pub static S_IRUSR : c_int = 256;\n+            pub static F_OK : c_int = 0;\n+            pub static R_OK : c_int = 4;\n+            pub static W_OK : c_int = 2;\n+            pub static X_OK : c_int = 1;\n+            pub static STDIN_FILENO : c_int = 0;\n+            pub static STDOUT_FILENO : c_int = 1;\n+            pub static STDERR_FILENO : c_int = 2;\n+            pub static F_LOCK : c_int = 1;\n+            pub static F_TEST : c_int = 3;\n+            pub static F_TLOCK : c_int = 2;\n+            pub static F_ULOCK : c_int = 0;\n+            pub static SIGHUP : c_int = 1;\n+            pub static SIGINT : c_int = 2;\n+            pub static SIGQUIT : c_int = 3;\n+            pub static SIGILL : c_int = 4;\n+            pub static SIGABRT : c_int = 6;\n+            pub static SIGFPE : c_int = 8;\n+            pub static SIGKILL : c_int = 9;\n+            pub static SIGSEGV : c_int = 11;\n+            pub static SIGPIPE : c_int = 13;\n+            pub static SIGALRM : c_int = 14;\n+            pub static SIGTERM : c_int = 15;\n+\n+            pub static PROT_NONE : c_int = 0;\n+            pub static PROT_READ : c_int = 1;\n+            pub static PROT_WRITE : c_int = 2;\n+            pub static PROT_EXEC : c_int = 4;\n+\n+            pub static MAP_FILE : c_int = 0x0000;\n+            pub static MAP_SHARED : c_int = 0x0001;\n+            pub static MAP_PRIVATE : c_int = 0x0002;\n+            pub static MAP_FIXED : c_int = 0x0010;\n+            pub static MAP_ANON : c_int = 0x1000;\n+\n+            pub static MAP_FAILED : *c_void = -1 as *c_void;\n+\n+            pub static MCL_CURRENT : c_int = 0x0001;\n+            pub static MCL_FUTURE : c_int = 0x0002;\n+\n+            pub static MS_ASYNC : c_int = 0x0001;\n+            pub static MS_INVALIDATE : c_int = 0x0002;\n+            pub static MS_SYNC : c_int = 0x0010;\n+\n+            pub static MS_KILLPAGES : c_int = 0x0004;\n+            pub static MS_DEACTIVATE : c_int = 0x0008;\n+\n+            pub static _SC_ARG_MAX : c_int = 1;\n+            pub static _SC_CHILD_MAX : c_int = 2;\n+            pub static _SC_CLK_TCK : c_int = 3;\n+            pub static _SC_NGROUPS_MAX : c_int = 4;\n+            pub static _SC_OPEN_MAX : c_int = 5;\n+            pub static _SC_JOB_CONTROL : c_int = 6;\n+            pub static _SC_SAVED_IDS : c_int = 7;\n+            pub static _SC_VERSION : c_int = 8;\n+            pub static _SC_BC_BASE_MAX : c_int = 9;\n+            pub static _SC_BC_DIM_MAX : c_int = 10;\n+            pub static _SC_BC_SCALE_MAX : c_int = 11;\n+            pub static _SC_BC_STRING_MAX : c_int = 12;\n+            pub static _SC_COLL_WEIGHTS_MAX : c_int = 13;\n+            pub static _SC_EXPR_NEST_MAX : c_int = 14;\n+            pub static _SC_LINE_MAX : c_int = 15;\n+            pub static _SC_RE_DUP_MAX : c_int = 16;\n+            pub static _SC_2_VERSION : c_int = 17;\n+            pub static _SC_2_C_BIND : c_int = 18;\n+            pub static _SC_2_C_DEV : c_int = 19;\n+            pub static _SC_2_CHAR_TERM : c_int = 20;\n+            pub static _SC_2_FORT_DEV : c_int = 21;\n+            pub static _SC_2_FORT_RUN : c_int = 22;\n+            pub static _SC_2_LOCALEDEF : c_int = 23;\n+            pub static _SC_2_SW_DEV : c_int = 24;\n+            pub static _SC_2_UPE : c_int = 25;\n+            pub static _SC_STREAM_MAX : c_int = 26;\n+            pub static _SC_TZNAME_MAX : c_int = 27;\n+            pub static _SC_ASYNCHRONOUS_IO : c_int = 28;\n+            pub static _SC_PAGESIZE : c_int = 29;\n+            pub static _SC_MEMLOCK : c_int = 30;\n+            pub static _SC_MEMLOCK_RANGE : c_int = 31;\n+            pub static _SC_MEMORY_PROTECTION : c_int = 32;\n+            pub static _SC_MESSAGE_PASSING : c_int = 33;\n+            pub static _SC_PRIORITIZED_IO : c_int = 34;\n+            pub static _SC_PRIORITY_SCHEDULING : c_int = 35;\n+            pub static _SC_REALTIME_SIGNALS : c_int = 36;\n+            pub static _SC_SEMAPHORES : c_int = 37;\n+            pub static _SC_FSYNC : c_int = 38;\n+            pub static _SC_SHARED_MEMORY_OBJECTS : c_int = 39;\n+            pub static _SC_SYNCHRONIZED_IO : c_int = 40;\n+            pub static _SC_TIMERS : c_int = 41;\n+            pub static _SC_AIO_LISTIO_MAX : c_int = 42;\n+            pub static _SC_AIO_MAX : c_int = 43;\n+            pub static _SC_AIO_PRIO_DELTA_MAX : c_int = 44;\n+            pub static _SC_DELAYTIMER_MAX : c_int = 45;\n+            pub static _SC_MQ_OPEN_MAX : c_int = 46;\n+            pub static _SC_MAPPED_FILES : c_int = 47;\n+            pub static _SC_RTSIG_MAX : c_int = 48;\n+            pub static _SC_SEM_NSEMS_MAX : c_int = 49;\n+            pub static _SC_SEM_VALUE_MAX : c_int = 50;\n+            pub static _SC_SIGQUEUE_MAX : c_int = 51;\n+            pub static _SC_TIMER_MAX : c_int = 52;\n+            pub static _SC_XBS5_ILP32_OFF32 : c_int = 122;\n+            pub static _SC_XBS5_ILP32_OFFBIG : c_int = 123;\n+            pub static _SC_XBS5_LP64_OFF64 : c_int = 124;\n+            pub static _SC_XBS5_LPBIG_OFFBIG : c_int = 125;\n         }\n         pub mod posix01 {\n-            pub static SIGTRAP : int = 5;\n-\n-            pub static GLOB_APPEND   : int = 0x0001;\n-            pub static GLOB_DOOFFS   : int = 0x0002;\n-            pub static GLOB_ERR      : int = 0x0004;\n-            pub static GLOB_MARK     : int = 0x0008;\n-            pub static GLOB_NOCHECK  : int = 0x0010;\n-            pub static GLOB_NOSORT   : int = 0x0020;\n-            pub static GLOB_NOESCAPE : int = 0x2000;\n-\n-            pub static GLOB_NOSPACE  : int = -1;\n-            pub static GLOB_ABORTED  : int = -2;\n-            pub static GLOB_NOMATCH  : int = -3;\n+            use libc::types::os::arch::c95::c_int;\n+\n+            pub static SIGTRAP : c_int = 5;\n+\n+            pub static GLOB_APPEND   : c_int = 0x0001;\n+            pub static GLOB_DOOFFS   : c_int = 0x0002;\n+            pub static GLOB_ERR      : c_int = 0x0004;\n+            pub static GLOB_MARK     : c_int = 0x0008;\n+            pub static GLOB_NOCHECK  : c_int = 0x0010;\n+            pub static GLOB_NOSORT   : c_int = 0x0020;\n+            pub static GLOB_NOESCAPE : c_int = 0x2000;\n+\n+            pub static GLOB_NOSPACE  : c_int = -1;\n+            pub static GLOB_ABORTED  : c_int = -2;\n+            pub static GLOB_NOMATCH  : c_int = -3;\n+\n+            pub static POSIX_MADV_NORMAL : c_int = 0;\n+            pub static POSIX_MADV_RANDOM : c_int = 1;\n+            pub static POSIX_MADV_SEQUENTIAL : c_int = 2;\n+            pub static POSIX_MADV_WILLNEED : c_int = 3;\n+            pub static POSIX_MADV_DONTNEED : c_int = 4;\n+\n+            pub static _SC_IOV_MAX : c_int = 56;\n+            pub static _SC_GETGR_R_SIZE_MAX : c_int = 70;\n+            pub static _SC_GETPW_R_SIZE_MAX : c_int = 71;\n+            pub static _SC_LOGIN_NAME_MAX : c_int = 73;\n+            pub static _SC_MQ_PRIO_MAX : c_int = 75;\n+            pub static _SC_THREAD_ATTR_STACKADDR : c_int = 82;\n+            pub static _SC_THREAD_ATTR_STACKSIZE : c_int = 83;\n+            pub static _SC_THREAD_DESTRUCTOR_ITERATIONS : c_int = 85;\n+            pub static _SC_THREAD_KEYS_MAX : c_int = 86;\n+            pub static _SC_THREAD_PRIO_INHERIT : c_int = 87;\n+            pub static _SC_THREAD_PRIO_PROTECT : c_int = 88;\n+            pub static _SC_THREAD_PRIORITY_SCHEDULING : c_int = 89;\n+            pub static _SC_THREAD_PROCESS_SHARED : c_int = 90;\n+            pub static _SC_THREAD_SAFE_FUNCTIONS : c_int = 91;\n+            pub static _SC_THREAD_STACK_MIN : c_int = 93;\n+            pub static _SC_THREAD_THREADS_MAX : c_int = 94;\n+            pub static _SC_THREADS : c_int = 96;\n+            pub static _SC_TTY_NAME_MAX : c_int = 101;\n+            pub static _SC_ATEXIT_MAX : c_int = 107;\n+            pub static _SC_XOPEN_CRYPT : c_int = 108;\n+            pub static _SC_XOPEN_ENH_I18N : c_int = 109;\n+            pub static _SC_XOPEN_LEGACY : c_int = 110;\n+            pub static _SC_XOPEN_REALTIME : c_int = 111;\n+            pub static _SC_XOPEN_REALTIME_THREADS : c_int = 112;\n+            pub static _SC_XOPEN_SHM : c_int = 113;\n+            pub static _SC_XOPEN_UNIX : c_int = 115;\n+            pub static _SC_XOPEN_VERSION : c_int = 116;\n+            pub static _SC_XOPEN_XCU_VERSION : c_int = 121;\n         }\n         pub mod posix08 {\n         }\n         pub mod bsd44 {\n+            use libc::types::os::arch::c95::c_int;\n+\n+            pub static MADV_NORMAL : c_int = 0;\n+            pub static MADV_RANDOM : c_int = 1;\n+            pub static MADV_SEQUENTIAL : c_int = 2;\n+            pub static MADV_WILLNEED : c_int = 3;\n+            pub static MADV_DONTNEED : c_int = 4;\n+            pub static MADV_FREE : c_int = 5;\n+            pub static MADV_ZERO_WIRED_PAGES : c_int = 6;\n+            pub static MADV_FREE_REUSABLE : c_int = 7;\n+            pub static MADV_FREE_REUSE : c_int = 8;\n+            pub static MADV_CAN_REUSE : c_int = 9;\n+\n+            pub static MINCORE_INCORE : c_int =  0x1;\n+            pub static MINCORE_REFERENCED : c_int = 0x2;\n+            pub static MINCORE_MODIFIED : c_int = 0x4;\n+            pub static MINCORE_REFERENCED_OTHER : c_int = 0x8;\n+            pub static MINCORE_MODIFIED_OTHER : c_int = 0x10;\n         }\n         pub mod extra {\n-            pub static O_DSYNC : int = 4194304;\n-            pub static O_SYNC : int = 128;\n-            pub static F_FULLFSYNC : int = 51;\n+            use libc::types::os::arch::c95::c_int;\n+\n+            pub static O_DSYNC : c_int = 4194304;\n+            pub static O_SYNC : c_int = 128;\n+            pub static F_FULLFSYNC : c_int = 51;\n+\n+            pub static MAP_COPY : c_int = 0x0002;\n+            pub static MAP_RENAME : c_int = 0x0020;\n+            pub static MAP_NORESERVE : c_int = 0x0040;\n+            pub static MAP_NOEXTEND : c_int = 0x0100;\n+            pub static MAP_HASSEMAPHORE : c_int = 0x0200;\n+            pub static MAP_NOCACHE : c_int = 0x0400;\n+            pub static MAP_JIT : c_int = 0x0800;\n         }\n     }\n }\n@@ -1658,6 +2149,9 @@ pub mod funcs {\n                              -> c_int;\n             }\n         }\n+\n+        pub mod mman {\n+        }\n     }\n \n \n@@ -1835,6 +2329,38 @@ pub mod funcs {\n                 unsafe fn kill(pid: pid_t, sig: c_int) -> c_int;\n             }\n         }\n+\n+        #[nolink]\n+        #[abi = \"cdecl\"]\n+        pub mod mman {\n+            use libc::types::common::c95::{c_void};\n+            use libc::types::os::arch::c95::{size_t, c_int, c_char};\n+            use libc::types::os::arch::posix88::{mode_t, off_t};\n+\n+            pub extern {\n+                unsafe fn mlock(addr: *c_void, len: size_t) -> c_int;\n+                unsafe fn munlock(addr: *c_void, len: size_t) -> c_int;\n+                unsafe fn mlockall(flags: c_int) -> c_int;\n+                unsafe fn munlockall() -> c_int;\n+\n+                unsafe fn mmap(addr: *c_void,\n+                               len: size_t,\n+                               prot: c_int,\n+                               flags: c_int,\n+                               fd: c_int,\n+                               offset: off_t) -> *mut c_void;\n+                unsafe fn munmap(addr: *c_void, len: size_t) -> c_int;\n+\n+                unsafe fn mprotect(addr: *c_void, len: size_t, prot: c_int)\n+                    -> c_int;\n+\n+                unsafe fn msync(addr: *c_void, len: size_t, flags: c_int)\n+                    -> c_int;\n+                unsafe fn shm_open(name: *c_char, oflag: c_int, mode: mode_t)\n+                    -> c_int;\n+                unsafe fn shm_unlink(name: *c_char) -> c_int;\n+            }\n+        }\n     }\n \n     #[cfg(target_os = \"linux\")]\n@@ -1913,6 +2439,19 @@ pub mod funcs {\n                 unsafe fn globfree(pglob: *mut glob_t);\n             }\n         }\n+\n+        #[nolink]\n+        #[abi = \"cdecl\"]\n+        pub mod mman {\n+            use libc::types::common::c95::{c_void};\n+            use libc::types::os::arch::c95::{c_int, size_t};\n+\n+            pub extern {\n+                unsafe fn posix_madvise(addr: *c_void,\n+                                        len: size_t,\n+                                        advice: c_int) -> c_int;\n+            }\n+        }\n     }\n \n     #[cfg(target_os = \"win32\")]\n@@ -1925,6 +2464,9 @@ pub mod funcs {\n \n         pub mod glob {\n         }\n+\n+        pub mod mman {\n+        }\n     }\n \n \n@@ -1943,7 +2485,8 @@ pub mod funcs {\n     #[cfg(target_os = \"freebsd\")]\n     pub mod bsd44 {\n         use libc::types::common::c95::{c_void};\n-        use libc::types::os::arch::c95::{c_char, c_int, c_uint, size_t};\n+        use libc::types::os::arch::c95::{c_char, c_uchar, c_int, c_uint,\n+                                         size_t};\n \n         #[abi = \"cdecl\"]\n         pub extern {\n@@ -1959,18 +2502,31 @@ pub mod funcs {\n                                sizep: *mut size_t) -> c_int;\n \n             unsafe fn getdtablesize() -> c_int;\n+\n+            unsafe fn madvise(addr: *c_void, len: size_t, advice: c_int)\n+                -> c_int;\n+\n+            unsafe fn mincore(addr: *c_void, len: size_t, vec: *c_uchar)\n+                -> c_int;\n         }\n     }\n \n \n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     pub mod bsd44 {\n-        use libc::types::os::arch::c95::{c_int};\n+        use libc::types::common::c95::{c_void};\n+        use libc::types::os::arch::c95::{c_uchar, c_int, size_t};\n \n         #[abi = \"cdecl\"]\n         pub extern {\n             unsafe fn getdtablesize() -> c_int;\n+\n+            unsafe fn madvise(addr: *c_void, len: size_t, advice: c_int)\n+                -> c_int;\n+\n+            unsafe fn mincore(addr: *c_void, len: size_t, vec: *c_uchar)\n+                -> c_int;\n         }\n     }\n "}, {"sha": "b71b3b503c2acca5514562275b63692b308d5db0", "filename": "src/libstd/managed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmanaged.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -15,7 +15,7 @@ use ptr::to_unsafe_ptr;\n #[cfg(not(test))] use cmp::{Eq, Ord};\n \n pub mod raw {\n-    use intrinsic::TyDesc;\n+    use std::unstable::intrinsics::TyDesc;\n \n     pub static RC_EXCHANGE_UNIQUE : uint = (-1) as uint;\n     pub static RC_MANAGED_UNIQUE : uint = (-2) as uint;"}, {"sha": "84fdc1c46d182bdb938ba4849a78503a56e1d40d", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -758,7 +758,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n                     FindFirstFileW(\n                         path_ptr,\n                         ::cast::transmute(wfd_ptr));\n-                if find_handle as int != INVALID_HANDLE_VALUE {\n+                if find_handle as libc::c_int != INVALID_HANDLE_VALUE {\n                     let mut more_files = 1 as libc::c_int;\n                     while more_files != 0 {\n                         let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr);"}, {"sha": "16ab4771d0de10a837b1584145bef9e933fa4c9e", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -16,8 +16,10 @@ Runtime type reflection\n \n #[allow(missing_doc)];\n \n-use intrinsic::{TyDesc, TyVisitor};\n-use intrinsic::Opaque;\n+#[cfg(stage0)]\n+use intrinsic::{Opaque, TyDesc, TyVisitor};\n+#[cfg(not(stage0))]\n+use unstable::intrinsics::{Opaque, TyDesc, TyVisitor};\n use libc::c_void;\n use sys;\n use vec;"}, {"sha": "f39b5a00ed054b61fafeb678079500a8e527041b", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -19,9 +19,6 @@ More runtime type reflection\n use cast::transmute;\n use char;\n use container::Container;\n-use intrinsic;\n-use intrinsic::{TyDesc, TyVisitor, visit_tydesc};\n-use intrinsic::Opaque;\n use io::{Writer, WriterUtil};\n use iterator::IteratorUtil;\n use libc::c_void;\n@@ -34,6 +31,10 @@ use to_str::ToStr;\n use vec::raw::{VecRepr, SliceRepr};\n use vec;\n use vec::{OwnedVector, UnboxedVecRepr};\n+#[cfg(stage0)]\n+use intrinsic::{Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n+#[cfg(not(stage0))]\n+use unstable::intrinsics::{Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n \n #[cfg(test)] use io;\n \n@@ -564,13 +565,24 @@ impl TyVisitor for ReprVisitor {\n     fn visit_self(&self) -> bool { true }\n     fn visit_type(&self) -> bool { true }\n \n+    #[cfg(not(stage0))]\n     fn visit_opaque_box(&self) -> bool {\n         self.writer.write_char('@');\n         do self.get::<&managed::raw::BoxRepr> |b| {\n             let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n             self.visit_ptr_inner(p, b.header.type_desc);\n         }\n     }\n+    #[cfg(stage0)]\n+    fn visit_opaque_box(&self) -> bool {\n+        self.writer.write_char('@');\n+        do self.get::<&managed::raw::BoxRepr> |b| {\n+            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n+            unsafe {\n+                self.visit_ptr_inner(p, transmute(b.header.type_desc));\n+            }\n+        }\n+    }\n \n     // Type no longer exists, vestigial function.\n     fn visit_constr(&self, _inner: *TyDesc) -> bool { fail!(); }\n@@ -581,7 +593,7 @@ impl TyVisitor for ReprVisitor {\n pub fn write_repr<T>(writer: @Writer, object: &T) {\n     unsafe {\n         let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n-        let tydesc = intrinsic::get_tydesc::<T>();\n+        let tydesc = get_tydesc::<T>();\n         let u = ReprVisitor(ptr, writer);\n         let v = reflect::MovePtrAdaptor(u);\n         visit_tydesc(tydesc, @v as @TyVisitor)"}, {"sha": "1e9f9aab8345cb24ed10b64495c063e44d75ee0d", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -8,26 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use sys::{TypeDesc, size_of};\n+use sys::{size_of};\n use libc::{c_void, size_t, uintptr_t};\n use c_malloc = libc::malloc;\n use c_free = libc::free;\n use managed::raw::{BoxHeaderRepr, BoxRepr};\n use cast::transmute;\n-use unstable::intrinsics::{atomic_xadd,atomic_xsub};\n+use unstable::intrinsics::{atomic_xadd,atomic_xsub,TyDesc};\n use ptr::null;\n-use intrinsic::TyDesc;\n \n-pub unsafe fn malloc(td: *TypeDesc, size: uint) -> *c_void {\n+pub unsafe fn malloc(td: *TyDesc, size: uint) -> *c_void {\n     assert!(td.is_not_null());\n \n     let total_size = get_box_size(size, (*td).align);\n     let p = c_malloc(total_size as size_t);\n     assert!(p.is_not_null());\n \n-    // FIXME #3475: Converting between our two different tydesc types\n-    let td: *TyDesc = transmute(td);\n-\n     let box: &mut BoxRepr = transmute(p);\n     box.header.ref_count = -1; // Exchange values not ref counted\n     box.header.type_desc = td;"}, {"sha": "13c54799fac4d75c1b40941b00d34828523a6171", "filename": "src/libstd/std.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "previous_filename": "src/libstd/core.rc"}, {"sha": "a1d6342323c64bc09cf6b56fee8c0929b0ac3315", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -17,23 +17,11 @@ use cast;\n use gc;\n use io;\n use libc;\n-use libc::{c_void, c_char, size_t};\n+use libc::{c_char, size_t};\n use repr;\n use str;\n use unstable::intrinsics;\n \n-pub type FreeGlue<'self> = &'self fn(*TypeDesc, *c_void);\n-\n-// Corresponds to runtime type_desc type\n-pub struct TypeDesc {\n-    size: uint,\n-    align: uint,\n-    take_glue: uint,\n-    drop_glue: uint,\n-    free_glue: uint\n-    // Remaining fields not listed\n-}\n-\n /// The representation of a Rust closure\n pub struct Closure {\n     code: *(),\n@@ -51,23 +39,6 @@ pub mod rustrt {\n     }\n }\n \n-/**\n- * Returns a pointer to a type descriptor.\n- *\n- * Useful for calling certain function in the Rust runtime or otherwise\n- * performing dark magick.\n- */\n-#[inline]\n-pub fn get_type_desc<T>() -> *TypeDesc {\n-    unsafe { intrinsics::get_tydesc::<T>() as *TypeDesc }\n-}\n-\n-/// Returns a pointer to a type descriptor.\n-#[inline]\n-pub fn get_type_desc_val<T>(_val: &T) -> *TypeDesc {\n-    get_type_desc::<T>()\n-}\n-\n /// Returns the size of a type\n #[inline]\n pub fn size_of<T>() -> uint {"}, {"sha": "04c0dd79deda98767ef1c9c20ad976b90077ac9f", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -111,7 +111,7 @@ fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n     assert!(was_present);\n }\n pub fn taskset_each(tasks: &TaskSet, blk: &fn(v: *rust_task) -> bool) -> bool {\n-    tasks.each(|k| blk(*k))\n+    tasks.iter().advance(|k| blk(*k))\n }\n \n // One of these per group of linked-failure tasks."}, {"sha": "4d5bc0f8842f7ac5d41821f45effcf4710d0b6c6", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -18,11 +18,9 @@ use str::OwnedStr;\n use hashmap::HashMap;\n use hashmap::HashSet;\n use iterator::IteratorUtil;\n-use container::Map;\n use hash::Hash;\n use cmp::Eq;\n use vec::ImmutableVector;\n-use iterator::IteratorUtil;\n \n /// A generic trait for converting a value to a string\n pub trait ToStr {\n@@ -179,7 +177,7 @@ impl<A:ToStr> ToStr for @[A] {\n mod tests {\n     use hashmap::HashMap;\n     use hashmap::HashSet;\n-    use container::Set;\n+    use container::{Set,Map};\n     #[test]\n     fn test_simple_types() {\n         assert_eq!(1i.to_str(), ~\"1\");"}, {"sha": "8f70c75439a016c121c31f41b6c9bacbb9a4b6e3", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -58,30 +58,6 @@ impl<T> Map<uint, T> for TrieMap<T> {\n         self.find(key).is_some()\n     }\n \n-    /// Visit all key-value pairs in order\n-    #[inline]\n-    fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n-        self.root.each(f)\n-    }\n-\n-    /// Visit all keys in order\n-    #[inline]\n-    fn each_key(&self, f: &fn(&uint) -> bool) -> bool {\n-        self.each(|k, _| f(k))\n-    }\n-\n-    /// Visit all values in order\n-    #[inline]\n-    fn each_value<'a>(&'a self, f: &fn(&'a T) -> bool) -> bool {\n-        self.each(|_, v| f(v))\n-    }\n-\n-    /// Iterate over the map and mutate the contained values\n-    #[inline]\n-    fn mutate_values(&mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n-        self.root.mutate_values(f)\n-    }\n-\n     /// Return a reference to the value corresponding to the key\n     #[inline]\n     fn find<'a>(&'a self, key: &uint) -> Option<&'a T> {\n@@ -158,6 +134,30 @@ impl<T> TrieMap<T> {\n         self.root.each_reverse(f)\n     }\n \n+    /// Visit all key-value pairs in order\n+    #[inline]\n+    pub fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+        self.root.each(f)\n+    }\n+\n+    /// Visit all keys in order\n+    #[inline]\n+    pub fn each_key(&self, f: &fn(&uint) -> bool) -> bool {\n+        self.each(|k, _| f(k))\n+    }\n+\n+    /// Visit all values in order\n+    #[inline]\n+    pub fn each_value<'a>(&'a self, f: &fn(&'a T) -> bool) -> bool {\n+        self.each(|_, v| f(v))\n+    }\n+\n+    /// Iterate over the map and mutate the contained values\n+    #[inline]\n+    pub fn mutate_values(&mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n+        self.root.mutate_values(f)\n+    }\n+\n     /// Visit all keys in reverse order\n     #[inline]\n     pub fn each_key_reverse(&self, f: &fn(&uint) -> bool) -> bool {"}, {"sha": "7a3a5f51d3562441a89219fc26a056c00e5a8ff7", "filename": "src/libstd/unstable/atomics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Funstable%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Funstable%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fatomics.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -62,6 +62,7 @@ pub struct AtomicPtr<T> {\n /**\n  * An owned atomic pointer. Ensures that only a single reference to the data is held at any time.\n  */\n+#[no_drop_flag]\n pub struct AtomicOption<T> {\n     priv p: *mut c_void\n }"}, {"sha": "5c47901df480226214d2db95f88ac4ef310c8b64", "filename": "src/libstd/unstable/exchange_alloc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Funstable%2Fexchange_alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Funstable%2Fexchange_alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fexchange_alloc.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -8,26 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use sys::{TypeDesc, size_of};\n+use sys::size_of;\n use libc::{c_void, size_t};\n use c_malloc = libc::malloc;\n use c_free = libc::free;\n use managed::raw::{BoxHeaderRepr, BoxRepr};\n use cast::transmute;\n use unstable::intrinsics::{atomic_xadd,atomic_xsub};\n use ptr::null;\n+#[cfg(stage0)]\n use intrinsic::TyDesc;\n+#[cfg(not(stage0))]\n+use unstable::intrinsics::TyDesc;\n \n-pub unsafe fn malloc(td: *TypeDesc, size: uint) -> *c_void {\n+pub unsafe fn malloc(td: *TyDesc, size: uint) -> *c_void {\n     assert!(td.is_not_null());\n \n     let total_size = get_box_size(size, (*td).align);\n     let p = c_malloc(total_size as size_t);\n     assert!(p.is_not_null());\n \n-    // FIXME #3475: Converting between our two different tydesc types\n-    let td: *TyDesc = transmute(td);\n-\n     let box: &mut BoxRepr = transmute(p);\n     box.header.ref_count = -1; // Exchange values not ref counted\n     box.header.type_desc = td;"}, {"sha": "1254a591293265b32b8a7a74e2649b4068b6b50a", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 129, "deletions": 53, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -32,6 +32,130 @@ A quick refresher on memory ordering:\n \n */\n \n+// This is needed to prevent duplicate lang item definitions.\n+#[cfg(test)]\n+pub use realstd::unstable::intrinsics::{TyDesc, Opaque, TyVisitor};\n+\n+#[cfg(not(stage0))]\n+pub type GlueFn = extern \"Rust\" fn(*i8);\n+\n+#[cfg(stage0)]\n+pub type GlueFn = extern \"Rust\" fn(**TyDesc, *i8);\n+\n+// NB: this has to be kept in sync with the Rust ABI.\n+#[lang=\"ty_desc\"]\n+#[cfg(not(test))]\n+pub struct TyDesc {\n+    size: uint,\n+    align: uint,\n+    take_glue: GlueFn,\n+    drop_glue: GlueFn,\n+    free_glue: GlueFn,\n+    visit_glue: GlueFn,\n+}\n+\n+#[lang=\"opaque\"]\n+#[cfg(not(test))]\n+pub enum Opaque { }\n+\n+#[lang=\"ty_visitor\"]\n+#[cfg(not(test))]\n+pub trait TyVisitor {\n+    fn visit_bot(&self) -> bool;\n+    fn visit_nil(&self) -> bool;\n+    fn visit_bool(&self) -> bool;\n+\n+    fn visit_int(&self) -> bool;\n+    fn visit_i8(&self) -> bool;\n+    fn visit_i16(&self) -> bool;\n+    fn visit_i32(&self) -> bool;\n+    fn visit_i64(&self) -> bool;\n+\n+    fn visit_uint(&self) -> bool;\n+    fn visit_u8(&self) -> bool;\n+    fn visit_u16(&self) -> bool;\n+    fn visit_u32(&self) -> bool;\n+    fn visit_u64(&self) -> bool;\n+\n+    fn visit_float(&self) -> bool;\n+    fn visit_f32(&self) -> bool;\n+    fn visit_f64(&self) -> bool;\n+\n+    fn visit_char(&self) -> bool;\n+    fn visit_str(&self) -> bool;\n+\n+    fn visit_estr_box(&self) -> bool;\n+    fn visit_estr_uniq(&self) -> bool;\n+    fn visit_estr_slice(&self) -> bool;\n+    fn visit_estr_fixed(&self, n: uint, sz: uint, align: uint) -> bool;\n+\n+    fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+\n+    fn visit_vec(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_evec_fixed(&self, n: uint, sz: uint, align: uint,\n+                        mtbl: uint, inner: *TyDesc) -> bool;\n+\n+    fn visit_enter_rec(&self, n_fields: uint,\n+                       sz: uint, align: uint) -> bool;\n+    fn visit_rec_field(&self, i: uint, name: &str,\n+                       mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_leave_rec(&self, n_fields: uint,\n+                       sz: uint, align: uint) -> bool;\n+\n+    fn visit_enter_class(&self, n_fields: uint,\n+                         sz: uint, align: uint) -> bool;\n+    fn visit_class_field(&self, i: uint, name: &str,\n+                         mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_leave_class(&self, n_fields: uint,\n+                         sz: uint, align: uint) -> bool;\n+\n+    fn visit_enter_tup(&self, n_fields: uint,\n+                       sz: uint, align: uint) -> bool;\n+    fn visit_tup_field(&self, i: uint, inner: *TyDesc) -> bool;\n+    fn visit_leave_tup(&self, n_fields: uint,\n+                       sz: uint, align: uint) -> bool;\n+\n+    fn visit_enter_enum(&self, n_variants: uint,\n+                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        sz: uint, align: uint) -> bool;\n+    fn visit_enter_enum_variant(&self, variant: uint,\n+                                disr_val: int,\n+                                n_fields: uint,\n+                                name: &str) -> bool;\n+    fn visit_enum_variant_field(&self, i: uint, offset: uint, inner: *TyDesc) -> bool;\n+    fn visit_leave_enum_variant(&self, variant: uint,\n+                                disr_val: int,\n+                                n_fields: uint,\n+                                name: &str) -> bool;\n+    fn visit_leave_enum(&self, n_variants: uint,\n+                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n+                        sz: uint, align: uint) -> bool;\n+\n+    fn visit_enter_fn(&self, purity: uint, proto: uint,\n+                      n_inputs: uint, retstyle: uint) -> bool;\n+    fn visit_fn_input(&self, i: uint, mode: uint, inner: *TyDesc) -> bool;\n+    fn visit_fn_output(&self, retstyle: uint, inner: *TyDesc) -> bool;\n+    fn visit_leave_fn(&self, purity: uint, proto: uint,\n+                      n_inputs: uint, retstyle: uint) -> bool;\n+\n+    fn visit_trait(&self) -> bool;\n+    fn visit_var(&self) -> bool;\n+    fn visit_var_integral(&self) -> bool;\n+    fn visit_param(&self, i: uint) -> bool;\n+    fn visit_self(&self) -> bool;\n+    fn visit_type(&self) -> bool;\n+    fn visit_opaque_box(&self) -> bool;\n+    fn visit_constr(&self, inner: *TyDesc) -> bool;\n+    fn visit_closure_ptr(&self, ck: uint) -> bool;\n+}\n+\n #[abi = \"rust-intrinsic\"]\n pub extern \"rust-intrinsic\" {\n \n@@ -42,9 +166,7 @@ pub extern \"rust-intrinsic\" {\n     /// Atomic compare and exchange, release ordering.\n     pub fn atomic_cxchg_rel(dst: &mut int, old: int, src: int) -> int;\n \n-    #[cfg(not(stage0))]\n     pub fn atomic_cxchg_acqrel(dst: &mut int, old: int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_cxchg_relaxed(dst: &mut int, old: int, src: int) -> int;\n \n \n@@ -53,15 +175,13 @@ pub extern \"rust-intrinsic\" {\n     /// Atomic load, acquire ordering.\n     pub fn atomic_load_acq(src: &int) -> int;\n \n-    #[cfg(not(stage0))]\n     pub fn atomic_load_relaxed(src: &int) -> int;\n \n     /// Atomic store, sequentially consistent.\n     pub fn atomic_store(dst: &mut int, val: int);\n     /// Atomic store, release ordering.\n     pub fn atomic_store_rel(dst: &mut int, val: int);\n \n-    #[cfg(not(stage0))]\n     pub fn atomic_store_relaxed(dst: &mut int, val: int);\n \n     /// Atomic exchange, sequentially consistent.\n@@ -70,9 +190,7 @@ pub extern \"rust-intrinsic\" {\n     pub fn atomic_xchg_acq(dst: &mut int, src: int) -> int;\n     /// Atomic exchange, release ordering.\n     pub fn atomic_xchg_rel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_xchg_acqrel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_xchg_relaxed(dst: &mut int, src: int) -> int;\n \n     /// Atomic addition, sequentially consistent.\n@@ -81,9 +199,7 @@ pub extern \"rust-intrinsic\" {\n     pub fn atomic_xadd_acq(dst: &mut int, src: int) -> int;\n     /// Atomic addition, release ordering.\n     pub fn atomic_xadd_rel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_xadd_acqrel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_xadd_relaxed(dst: &mut int, src: int) -> int;\n \n     /// Atomic subtraction, sequentially consistent.\n@@ -92,97 +208,55 @@ pub extern \"rust-intrinsic\" {\n     pub fn atomic_xsub_acq(dst: &mut int, src: int) -> int;\n     /// Atomic subtraction, release ordering.\n     pub fn atomic_xsub_rel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_xsub_acqrel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_xsub_relaxed(dst: &mut int, src: int) -> int;\n \n-    #[cfg(not(stage0))]\n     pub fn atomic_and(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_and_acq(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_and_rel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_and_acqrel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_and_relaxed(dst: &mut int, src: int) -> int;\n \n-    #[cfg(not(stage0))]\n     pub fn atomic_nand(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_nand_acq(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_nand_rel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_nand_acqrel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_nand_relaxed(dst: &mut int, src: int) -> int;\n \n-    #[cfg(not(stage0))]\n     pub fn atomic_or(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_or_acq(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_or_rel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_or_acqrel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_or_relaxed(dst: &mut int, src: int) -> int;\n \n-    #[cfg(not(stage0))]\n     pub fn atomic_xor(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_xor_acq(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_xor_rel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_xor_acqrel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_xor_relaxed(dst: &mut int, src: int) -> int;\n \n-    #[cfg(not(stage0))]\n     pub fn atomic_max(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_max_acq(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_max_rel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_max_acqrel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_max_relaxed(dst: &mut int, src: int) -> int;\n \n-    #[cfg(not(stage0))]\n     pub fn atomic_min(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_min_acq(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_min_rel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_min_acqrel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_min_relaxed(dst: &mut int, src: int) -> int;\n \n-    #[cfg(not(stage0))]\n     pub fn atomic_umin(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_umin_acq(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_umin_rel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_umin_acqrel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_umin_relaxed(dst: &mut int, src: int) -> int;\n \n-    #[cfg(not(stage0))]\n     pub fn atomic_umax(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_umax_acq(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_umax_rel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_umax_acqrel(dst: &mut int, src: int) -> int;\n-    #[cfg(not(stage0))]\n     pub fn atomic_umax_relaxed(dst: &mut int, src: int) -> int;\n \n     /// The size of a type in bytes.\n@@ -209,6 +283,9 @@ pub extern \"rust-intrinsic\" {\n     pub fn pref_align_of<T>() -> uint;\n \n     /// Get a static pointer to a type descriptor.\n+    #[cfg(not(stage0))]\n+    pub fn get_tydesc<T>() -> *TyDesc;\n+    #[cfg(stage0)]\n     pub fn get_tydesc<T>() -> *();\n \n     /// Create a value initialized to zero.\n@@ -231,9 +308,8 @@ pub extern \"rust-intrinsic\" {\n     /// Returns `true` if a type requires drop glue.\n     pub fn needs_drop<T>() -> bool;\n \n-    // XXX: intrinsic uses legacy modes and has reference to TyDesc\n-    // and TyVisitor which are in librustc\n-    //fn visit_tydesc(++td: *TyDesc, &&tv: TyVisitor) -> ();\n+    #[cfg(not(stage0))]\n+    pub fn visit_tydesc(td: *TyDesc, tv: @TyVisitor);\n \n     pub fn frame_address(f: &once fn(*u8));\n "}, {"sha": "2e18a588fae313b5f798c8e7bc0540abc789e0d2", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 18, "deletions": 121, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -30,26 +30,33 @@ use sys;\n use sys::size_of;\n use uint;\n use unstable::intrinsics;\n+#[cfg(stage0)]\n+use intrinsic::{get_tydesc};\n+#[cfg(not(stage0))]\n+use unstable::intrinsics::{get_tydesc};\n use vec;\n use util;\n \n #[cfg(not(test))] use cmp::Equiv;\n \n pub mod rustrt {\n     use libc;\n-    use sys;\n     use vec::raw;\n+    #[cfg(stage0)]\n+    use intrinsic::{TyDesc};\n+    #[cfg(not(stage0))]\n+    use unstable::intrinsics::{TyDesc};\n \n     #[abi = \"cdecl\"]\n     pub extern {\n         // These names are terrible. reserve_shared applies\n         // to ~[] and reserve_shared_actual applies to @[].\n         #[fast_ffi]\n-        unsafe fn vec_reserve_shared(t: *sys::TypeDesc,\n+        unsafe fn vec_reserve_shared(t: *TyDesc,\n                                      v: **raw::VecRepr,\n                                      n: libc::size_t);\n         #[fast_ffi]\n-        unsafe fn vec_reserve_shared_actual(t: *sys::TypeDesc,\n+        unsafe fn vec_reserve_shared_actual(t: *TyDesc,\n                                             v: **raw::VecRepr,\n                                             n: libc::size_t);\n     }\n@@ -78,7 +85,7 @@ pub fn reserve<T>(v: &mut ~[T], n: uint) {\n     if capacity(v) < n {\n         unsafe {\n             let ptr: **raw::VecRepr = cast::transmute(v);\n-            let td = sys::get_type_desc::<T>();\n+            let td = get_tydesc::<T>();\n             if ((**ptr).box_header.ref_count ==\n                 managed::raw::RC_MANAGED_UNIQUE) {\n                 rustrt::vec_reserve_shared_actual(td, ptr, n as libc::size_t);\n@@ -437,7 +444,7 @@ pub fn partitioned<T:Copy>(v: &[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n     let mut lefts  = ~[];\n     let mut rights = ~[];\n \n-    for each(v) |elt| {\n+    for v.iter().advance |elt| {\n         if f(elt) {\n             lefts.push(copy *elt);\n         } else {\n@@ -843,7 +850,7 @@ pub fn grow_set<T:Copy>(v: &mut ~[T], index: uint, initval: &T, val: T) {\n /// Apply a function to each element of a vector and return the results\n pub fn map<T, U>(v: &[T], f: &fn(t: &T) -> U) -> ~[U] {\n     let mut result = with_capacity(v.len());\n-    for each(v) |elem| {\n+    for v.iter().advance |elem| {\n         result.push(f(elem));\n     }\n     result\n@@ -879,7 +886,7 @@ pub fn mapi<T, U>(v: &[T], f: &fn(uint, t: &T) -> U) -> ~[U] {\n  */\n pub fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n-    for each(v) |elem| { result.push_all_move(f(elem)); }\n+    for v.iter().advance |elem| { result.push_all_move(f(elem)); }\n     result\n }\n \n@@ -932,7 +939,7 @@ pub fn filter_mapped<T, U: Copy>(\n      */\n \n     let mut result = ~[];\n-    for each(v) |elem| {\n+    for v.iter().advance |elem| {\n         match f(elem) {\n           None => {/* no-op */ }\n           Some(result_elem) => { result.push(result_elem); }\n@@ -967,7 +974,7 @@ pub fn filter<T>(v: ~[T], f: &fn(t: &T) -> bool) -> ~[T] {\n  */\n pub fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n     let mut result = ~[];\n-    for each(v) |elem| {\n+    for v.iter().advance |elem| {\n         if f(elem) { result.push(copy *elem); }\n     }\n     result\n@@ -1051,7 +1058,7 @@ impl<'self, T:Copy> VectorVector<T> for &'self [&'self [T]] {\n \n /// Return true if a vector contains an element with the given value\n pub fn contains<T:Eq>(v: &[T], x: &T) -> bool {\n-    for each(v) |elt| { if *x == *elt { return true; } }\n+    for v.iter().advance |elt| { if *x == *elt { return true; } }\n     false\n }\n \n@@ -1202,7 +1209,7 @@ pub fn bsearch_elem<T:TotalOrd>(v: &[T], x: &T) -> Option<uint> {\n  */\n pub fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     let mut (ts, us) = (~[], ~[]);\n-    for each(v) |p| {\n+    for v.iter().advance |p| {\n         let (t, u) = copy *p;\n         ts.push(t);\n         us.push(u);\n@@ -1340,69 +1347,6 @@ pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n     rs\n }\n \n-/**\n- * Iterates over a vector, yielding each element to a closure.\n- *\n- * # Arguments\n- *\n- * * `v` - A vector, to be iterated over\n- * * `f` - A closure to do the iterating. Within this closure, return true to\n- * * continue iterating, false to break.\n- *\n- * # Examples\n- *\n- * ~~~ {.rust}\n- * [1,2,3].each(|&i| {\n- *     io::println(int::str(i));\n- *     true\n- * });\n- * ~~~\n- *\n- * ~~~ {.rust}\n- * [1,2,3,4,5].each(|&i| {\n- *     if i < 4 {\n- *         io::println(int::str(i));\n- *         true\n- *     }\n- *     else {\n- *         false\n- *     }\n- * });\n- * ~~~\n- *\n- * You probably will want to use each with a `for`/`do` expression, depending\n- * on your iteration needs:\n- *\n- * ~~~ {.rust}\n- * for [1,2,3].each |&i| {\n- *     io::println(int::str(i));\n- * }\n- * ~~~\n- */\n-#[inline]\n-pub fn each<'r,T>(v: &'r [T], f: &fn(&'r T) -> bool) -> bool {\n-    //            ^^^^\n-    // NB---this CANNOT be &const [T]!  The reason\n-    // is that you are passing it to `f()` using\n-    // an immutable.\n-\n-    let mut broke = false;\n-    do as_imm_buf(v) |p, n| {\n-        let mut n = n;\n-        let mut p = p;\n-        while n > 0u {\n-            unsafe {\n-                let q = cast::copy_lifetime_vec(v, &*p);\n-                if !f(q) { break; }\n-                p = ptr::offset(p, 1u);\n-            }\n-            n -= 1u;\n-        }\n-        broke = n > 0;\n-    }\n-    return !broke;\n-}\n-\n /**\n  * Iterate over all permutations of vector `v`.\n  *\n@@ -2446,7 +2390,6 @@ macro_rules! iterator {\n             }\n \n             #[inline]\n-            #[cfg(not(stage0))]\n             fn size_hint(&self) -> (Option<uint>, Option<uint>) {\n                 let exact = Some(((self.end as uint) - (self.ptr as uint)) / size_of::<$elem>());\n                 (exact, exact)\n@@ -3063,36 +3006,6 @@ mod tests {\n         assert_eq!(v, ~[1, 3, 5]);\n     }\n \n-    #[test]\n-    fn test_each_empty() {\n-        for each::<int>([]) |_v| {\n-            fail!(); // should never be executed\n-        }\n-    }\n-\n-    #[test]\n-    fn test_each_nonempty() {\n-        let mut i = 0;\n-        for each([1, 2, 3]) |v| {\n-            i += *v;\n-        }\n-        assert_eq!(i, 6);\n-    }\n-\n-    #[test]\n-    fn test_each_ret_len0() {\n-        let a0 : [int, .. 0] = [];\n-        assert_eq!(each(a0, |_p| fail!()), true);\n-    }\n-\n-    #[test]\n-    fn test_each_ret_len1() {\n-        let a1 = [17];\n-        assert_eq!(each(a1, |_p| true), true);\n-        assert_eq!(each(a1, |_p| false), false);\n-    }\n-\n-\n     #[test]\n     fn test_each_permutation() {\n         let mut results: ~[~[int]];\n@@ -3848,21 +3761,6 @@ mod tests {\n         };\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_each_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do each(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            false\n-        };\n-    }\n-\n     #[test]\n     #[ignore(windows)]\n     #[should_fail]\n@@ -3929,7 +3827,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg(not(stage0))]\n     fn test_iterator() {\n         use iterator::*;\n         let xs = [1, 2, 5, 10, 11];"}, {"sha": "54ffa270f3362691e7a35978137a165bf4d0d6b3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -190,7 +190,7 @@ pub enum def {\n     def_self_ty(/* trait id */ node_id),\n     def_mod(def_id),\n     def_foreign_mod(def_id),\n-    def_const(def_id),\n+    def_static(def_id, bool /* is_mutbl */),\n     def_arg(node_id, bool /* is_mutbl */),\n     def_local(node_id, bool /* is_mutbl */),\n     def_variant(def_id /* enum */, def_id /* variant */),\n@@ -1093,7 +1093,7 @@ pub struct item {\n \n #[deriving(Eq, Encodable, Decodable)]\n pub enum item_ {\n-    item_const(@Ty, @expr),\n+    item_static(@Ty, mutability, @expr),\n     item_fn(fn_decl, purity, AbiSet, Generics, blk),\n     item_mod(_mod),\n     item_foreign_mod(foreign_mod),\n@@ -1122,7 +1122,7 @@ pub struct foreign_item {\n #[deriving(Eq, Encodable, Decodable)]\n pub enum foreign_item_ {\n     foreign_item_fn(fn_decl, purity, Generics),\n-    foreign_item_const(@Ty)\n+    foreign_item_static(@Ty, /* is_mutbl */ bool),\n }\n \n // The data we save and restore about an inlined item or method.  This is not"}, {"sha": "421c4c566b56c23b193a3187ddfa02140d025f96", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -339,7 +339,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n       Some(&node_item(item, path)) => {\n         let path_str = path_ident_to_str(path, item.ident, itr);\n         let item_str = match item.node {\n-          item_const(*) => ~\"const\",\n+          item_static(*) => ~\"static\",\n           item_fn(*) => ~\"fn\",\n           item_mod(*) => ~\"mod\",\n           item_foreign_mod(*) => ~\"foreign mod\","}, {"sha": "a233c330b64d5cc8036df7a0d6e2c5a9fdb72cae", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -59,7 +59,7 @@ pub fn variant_def_ids(d: def) -> Option<(def_id, def_id)> {\n pub fn def_id_of_def(d: def) -> def_id {\n     match d {\n       def_fn(id, _) | def_static_method(id, _, _) | def_mod(id) |\n-      def_foreign_mod(id) | def_const(id) |\n+      def_foreign_mod(id) | def_static(id, _) |\n       def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n       def_use(id) | def_struct(id) | def_trait(id) => {\n         id\n@@ -394,10 +394,10 @@ impl id_range {\n \n pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n     let visit_generics: @fn(&Generics, T) = |generics, t| {\n-        for generics.ty_params.each |p| {\n+        for generics.ty_params.iter().advance |p| {\n             vfn(p.id, copy t);\n         }\n-        for generics.lifetimes.each |p| {\n+        for generics.lifetimes.iter().advance |p| {\n             vfn(p.id, copy t);\n         }\n     };"}, {"sha": "83e446fa4c688f4befc53a1081f3f97bdec7b16d", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -324,11 +324,11 @@ impl<'self> TraitDef<'self> {\n \n         let mut trait_generics = self.generics.to_generics(cx, span, type_ident, generics);\n         // Copy the lifetimes\n-        for generics.lifetimes.each |l| {\n+        for generics.lifetimes.iter().advance |l| {\n             trait_generics.lifetimes.push(copy *l)\n         };\n         // Create the type parameters.\n-        for generics.ty_params.each |ty_param| {\n+        for generics.ty_params.iter().advance |ty_param| {\n             // I don't think this can be moved out of the loop, since\n             // a TyParamBound requires an ast id\n             let mut bounds = opt_vec::from("}, {"sha": "da5455d433279cf6ff83693b1b382b11da336be7", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -374,7 +374,7 @@ impl gen_init for protocol {\n     fn buffer_ty_path(&self, cx: @ExtCtxt) -> @ast::Ty {\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n         for (copy self.states).iter().advance |s| {\n-            for s.generics.ty_params.each |tp| {\n+            for s.generics.ty_params.iter().advance |tp| {\n                 match params.iter().find_(|tpp| tp.ident == tpp.ident) {\n                   None => params.push(*tp),\n                   _ => ()\n@@ -392,7 +392,7 @@ impl gen_init for protocol {\n         let ext_cx = cx;\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n         let fields = do (copy self.states).iter().transform |s| {\n-            for s.generics.ty_params.each |tp| {\n+            for s.generics.ty_params.iter().advance |tp| {\n                 match params.iter().find_(|tpp| tp.ident == tpp.ident) {\n                   None => params.push(*tp),\n                   _ => ()"}, {"sha": "25839fb46339608117acf12a461ba28df2191385", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -236,8 +236,8 @@ fn noop_fold_foreign_item(ni: @foreign_item, fld: @ast_fold)\n                         purity,\n                         fold_generics(generics, fld))\n                 }\n-                foreign_item_const(t) => {\n-                    foreign_item_const(fld.fold_ty(t))\n+                foreign_item_static(t, m) => {\n+                    foreign_item_static(fld.fold_ty(t), m)\n                 }\n             },\n         id: fld.new_id(ni.id),\n@@ -270,7 +270,7 @@ fn noop_fold_struct_field(sf: @struct_field, fld: @ast_fold)\n \n pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n     match *i {\n-        item_const(t, e) => item_const(fld.fold_ty(t), fld.fold_expr(e)),\n+        item_static(t, m, e) => item_static(fld.fold_ty(t), m, fld.fold_expr(e)),\n         item_fn(ref decl, purity, abi, ref generics, ref body) => {\n             item_fn(\n                 fold_fn_decl(decl, fld),"}, {"sha": "22b1d040d42e06652e4fe86b1086079d23c501d0", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -38,13 +38,6 @@ pub fn from<T>(t: ~[T]) -> OptVec<T> {\n }\n \n impl<T> OptVec<T> {\n-    fn each(&self, blk: &fn(v: &T) -> bool) -> bool {\n-        match *self {\n-            Empty => true,\n-            Vec(ref v) => v.iter().advance(blk)\n-        }\n-    }\n-\n     fn push(&mut self, t: T) {\n         match *self {\n             Vec(ref mut v) => {"}, {"sha": "d8aab1f68eea58f2d938b85a1a89b4f8c03c0d47", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -33,8 +33,8 @@ use ast::{expr_vec, expr_vstore, expr_vstore_mut_box};\n use ast::{expr_vstore_slice, expr_vstore_box};\n use ast::{expr_vstore_mut_slice, expr_while, extern_fn, field, fn_decl};\n use ast::{expr_vstore_uniq, Onceness, Once, Many};\n-use ast::{foreign_item, foreign_item_const, foreign_item_fn, foreign_mod};\n-use ast::{ident, impure_fn, inherited, item, item_, item_const};\n+use ast::{foreign_item, foreign_item_static, foreign_item_fn, foreign_mod};\n+use ast::{ident, impure_fn, inherited, item, item_, item_static};\n use ast::{item_enum, item_fn, item_foreign_mod, item_impl};\n use ast::{item_mac, item_mod, item_struct, item_trait, item_ty, lit, lit_};\n use ast::{lit_bool, lit_float, lit_float_unsuffixed, lit_int};\n@@ -60,7 +60,7 @@ use ast::{view_item_, view_item_extern_mod, view_item_use};\n use ast::{view_path, view_path_glob, view_path_list, view_path_simple};\n use ast::visibility;\n use ast;\n-use ast_util::{as_prec, ident_to_path, operator_prec};\n+use ast_util::{as_prec, operator_prec};\n use ast_util;\n use codemap::{span, BytePos, spanned, mk_sp};\n use codemap;\n@@ -3556,13 +3556,14 @@ impl Parser {\n     }\n \n     fn parse_item_const(&self) -> item_info {\n+        let m = if self.eat_keyword(keywords::Mut) {m_mutbl} else {m_imm};\n         let id = self.parse_ident();\n         self.expect(&token::COLON);\n         let ty = self.parse_ty(false);\n         self.expect(&token::EQ);\n         let e = self.parse_expr();\n         self.expect(&token::SEMI);\n-        (id, item_const(ty, e), None)\n+        (id, item_static(ty, m, e), None)\n     }\n \n     // parse a mod { ...}  item\n@@ -3683,6 +3684,7 @@ impl Parser {\n         } else {\n             self.expect_keyword(keywords::Static);\n         }\n+        let mutbl = self.eat_keyword(keywords::Mut);\n \n         let ident = self.parse_ident();\n         self.expect(&token::COLON);\n@@ -3691,7 +3693,7 @@ impl Parser {\n         self.expect(&token::SEMI);\n         @ast::foreign_item { ident: ident,\n                              attrs: attrs,\n-                             node: foreign_item_const(ty),\n+                             node: foreign_item_static(ty, mutbl),\n                              id: self.get_id(),\n                              span: mk_sp(lo, hi),\n                              vis: vis }"}, {"sha": "d40b96f077bb1f18208a243561855ef6a98ef099", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 99, "deletions": 105, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -331,21 +331,18 @@ pub mod special_idents {\n     pub static str : ident = ident { name: 19, ctxt: 0}; // for the type\n \n     /* outside of libsyntax */\n-    pub static ty_visitor : ident = ident { name: 20, ctxt: 0};\n-    pub static arg : ident = ident { name: 21, ctxt: 0};\n-    pub static descrim : ident = ident { name: 22, ctxt: 0};\n-    pub static clownshoe_abi : ident = ident { name: 23, ctxt: 0};\n-    pub static clownshoe_stack_shim : ident = ident { name: 24, ctxt: 0};\n-    pub static tydesc : ident = ident { name: 25, ctxt: 0};\n-    pub static main : ident = ident { name: 26, ctxt: 0};\n-    pub static opaque : ident = ident { name: 27, ctxt: 0};\n-    pub static blk : ident = ident { name: 28, ctxt: 0};\n-    pub static statik : ident = ident { name: 29, ctxt: 0};\n-    pub static intrinsic : ident = ident { name: 30, ctxt: 0};\n-    pub static clownshoes_foreign_mod: ident = ident { name: 31, ctxt: 0};\n-    pub static unnamed_field: ident = ident { name: 32, ctxt: 0};\n-    pub static c_abi: ident = ident { name: 33, ctxt: 0};\n-    pub static type_self: ident = ident { name: 34, ctxt: 0};    // `Self`\n+    pub static arg : ident = ident { name: 20, ctxt: 0};\n+    pub static descrim : ident = ident { name: 21, ctxt: 0};\n+    pub static clownshoe_abi : ident = ident { name: 22, ctxt: 0};\n+    pub static clownshoe_stack_shim : ident = ident { name: 23, ctxt: 0};\n+    pub static main : ident = ident { name: 24, ctxt: 0};\n+    pub static opaque : ident = ident { name: 25, ctxt: 0};\n+    pub static blk : ident = ident { name: 26, ctxt: 0};\n+    pub static statik : ident = ident { name: 27, ctxt: 0};\n+    pub static clownshoes_foreign_mod: ident = ident { name: 28, ctxt: 0};\n+    pub static unnamed_field: ident = ident { name: 29, ctxt: 0};\n+    pub static c_abi: ident = ident { name: 30, ctxt: 0};\n+    pub static type_self: ident = ident { name: 31, ctxt: 0};    // `Self`\n }\n \n /**\n@@ -426,59 +423,56 @@ fn mk_fresh_ident_interner() -> @ident_interner {\n         \"tt\",                 // 17\n         \"matchers\",           // 18\n         \"str\",                // 19\n-        \"TyVisitor\",          // 20\n-        \"arg\",                // 21\n-        \"descrim\",            // 22\n-        \"__rust_abi\",         // 23\n-        \"__rust_stack_shim\",  // 24\n-        \"TyDesc\",             // 25\n-        \"main\",               // 26\n-        \"<opaque>\",           // 27\n-        \"blk\",                // 28\n-        \"static\",             // 29\n-        \"intrinsic\",          // 30\n-        \"__foreign_mod__\",    // 31\n-        \"__field__\",          // 32\n-        \"C\",                  // 33\n-        \"Self\",               // 34\n-\n-        \"as\",                 // 35\n-        \"break\",              // 36\n-        \"const\",              // 37\n-        \"copy\",               // 38\n-        \"do\",                 // 39\n-        \"else\",               // 40\n-        \"enum\",               // 41\n-        \"extern\",             // 42\n-        \"false\",              // 43\n-        \"fn\",                 // 44\n-        \"for\",                // 45\n-        \"if\",                 // 46\n-        \"impl\",               // 47\n-        \"let\",                // 48\n-        \"__log\",              // 49\n-        \"loop\",               // 50\n-        \"match\",              // 51\n-        \"mod\",                // 52\n-        \"mut\",                // 53\n-        \"once\",               // 54\n-        \"priv\",               // 55\n-        \"pub\",                // 56\n-        \"pure\",               // 57\n-        \"ref\",                // 58\n-        \"return\",             // 59\n-        \"static\",             // 29 -- also a special ident\n+        \"arg\",                // 20\n+        \"descrim\",            // 21\n+        \"__rust_abi\",         // 22\n+        \"__rust_stack_shim\",  // 23\n+        \"main\",               // 24\n+        \"<opaque>\",           // 25\n+        \"blk\",                // 26\n+        \"static\",             // 27\n+        \"__foreign_mod__\",    // 28\n+        \"__field__\",          // 29\n+        \"C\",                  // 30\n+        \"Self\",               // 31\n+\n+        \"as\",                 // 32\n+        \"break\",              // 33\n+        \"const\",              // 34\n+        \"copy\",               // 35\n+        \"do\",                 // 36\n+        \"else\",               // 37\n+        \"enum\",               // 38\n+        \"extern\",             // 39\n+        \"false\",              // 40\n+        \"fn\",                 // 41\n+        \"for\",                // 42\n+        \"if\",                 // 43\n+        \"impl\",               // 44\n+        \"let\",                // 45\n+        \"__log\",              // 46\n+        \"loop\",               // 47\n+        \"match\",              // 48\n+        \"mod\",                // 49\n+        \"mut\",                // 50\n+        \"once\",               // 51\n+        \"priv\",               // 52\n+        \"pub\",                // 53\n+        \"pure\",               // 54\n+        \"ref\",                // 55\n+        \"return\",             // 56\n+        \"static\",             // 27 -- also a special ident\n         \"self\",               //  8 -- also a special ident\n-        \"struct\",             // 60\n-        \"super\",              // 61\n-        \"true\",               // 62\n-        \"trait\",              // 63\n-        \"type\",               // 64\n-        \"unsafe\",             // 65\n-        \"use\",                // 66\n-        \"while\",              // 67\n-\n-        \"be\",                 // 68\n+        \"struct\",             // 57\n+        \"super\",              // 58\n+        \"true\",               // 59\n+        \"trait\",              // 60\n+        \"type\",               // 61\n+        \"unsafe\",             // 62\n+        \"use\",                // 63\n+        \"while\",              // 64\n+\n+        \"be\",                 // 65\n     ];\n \n     @ident_interner {\n@@ -612,42 +606,42 @@ pub mod keywords {\n     impl Keyword {\n         pub fn to_ident(&self) -> ident {\n             match *self {\n-                As => ident { name: 35, ctxt: 0 },\n-                Break => ident { name: 36, ctxt: 0 },\n-                Const => ident { name: 37, ctxt: 0 },\n-                Copy => ident { name: 38, ctxt: 0 },\n-                Do => ident { name: 39, ctxt: 0 },\n-                Else => ident { name: 40, ctxt: 0 },\n-                Enum => ident { name: 41, ctxt: 0 },\n-                Extern => ident { name: 42, ctxt: 0 },\n-                False => ident { name: 43, ctxt: 0 },\n-                Fn => ident { name: 44, ctxt: 0 },\n-                For => ident { name: 45, ctxt: 0 },\n-                If => ident { name: 46, ctxt: 0 },\n-                Impl => ident { name: 47, ctxt: 0 },\n-                Let => ident { name: 48, ctxt: 0 },\n-                __Log => ident { name: 49, ctxt: 0 },\n-                Loop => ident { name: 50, ctxt: 0 },\n-                Match => ident { name: 51, ctxt: 0 },\n-                Mod => ident { name: 52, ctxt: 0 },\n-                Mut => ident { name: 53, ctxt: 0 },\n-                Once => ident { name: 54, ctxt: 0 },\n-                Priv => ident { name: 55, ctxt: 0 },\n-                Pub => ident { name: 56, ctxt: 0 },\n-                Pure => ident { name: 57, ctxt: 0 },\n-                Ref => ident { name: 58, ctxt: 0 },\n-                Return => ident { name: 59, ctxt: 0 },\n-                Static => ident { name: 29, ctxt: 0 },\n+                As => ident { name: 32, ctxt: 0 },\n+                Break => ident { name: 33, ctxt: 0 },\n+                Const => ident { name: 34, ctxt: 0 },\n+                Copy => ident { name: 35, ctxt: 0 },\n+                Do => ident { name: 36, ctxt: 0 },\n+                Else => ident { name: 37, ctxt: 0 },\n+                Enum => ident { name: 38, ctxt: 0 },\n+                Extern => ident { name: 39, ctxt: 0 },\n+                False => ident { name: 40, ctxt: 0 },\n+                Fn => ident { name: 41, ctxt: 0 },\n+                For => ident { name: 42, ctxt: 0 },\n+                If => ident { name: 43, ctxt: 0 },\n+                Impl => ident { name: 44, ctxt: 0 },\n+                Let => ident { name: 45, ctxt: 0 },\n+                __Log => ident { name: 46, ctxt: 0 },\n+                Loop => ident { name: 47, ctxt: 0 },\n+                Match => ident { name: 48, ctxt: 0 },\n+                Mod => ident { name: 49, ctxt: 0 },\n+                Mut => ident { name: 50, ctxt: 0 },\n+                Once => ident { name: 51, ctxt: 0 },\n+                Priv => ident { name: 52, ctxt: 0 },\n+                Pub => ident { name: 53, ctxt: 0 },\n+                Pure => ident { name: 54, ctxt: 0 },\n+                Ref => ident { name: 55, ctxt: 0 },\n+                Return => ident { name: 56, ctxt: 0 },\n+                Static => ident { name: 27, ctxt: 0 },\n                 Self => ident { name: 8, ctxt: 0 },\n-                Struct => ident { name: 60, ctxt: 0 },\n-                Super => ident { name: 61, ctxt: 0 },\n-                True => ident { name: 62, ctxt: 0 },\n-                Trait => ident { name: 63, ctxt: 0 },\n-                Type => ident { name: 64, ctxt: 0 },\n-                Unsafe => ident { name: 65, ctxt: 0 },\n-                Use => ident { name: 66, ctxt: 0 },\n-                While => ident { name: 67, ctxt: 0 },\n-                Be => ident { name: 68, ctxt: 0 },\n+                Struct => ident { name: 57, ctxt: 0 },\n+                Super => ident { name: 58, ctxt: 0 },\n+                True => ident { name: 59, ctxt: 0 },\n+                Trait => ident { name: 60, ctxt: 0 },\n+                Type => ident { name: 61, ctxt: 0 },\n+                Unsafe => ident { name: 62, ctxt: 0 },\n+                Use => ident { name: 63, ctxt: 0 },\n+                While => ident { name: 64, ctxt: 0 },\n+                Be => ident { name: 65, ctxt: 0 },\n             }\n         }\n     }\n@@ -663,7 +657,7 @@ pub fn is_keyword(kw: keywords::Keyword, tok: &Token) -> bool {\n pub fn is_any_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {\n-            8 | 29 | 35 .. 68 => true,\n+            8 | 27 | 32 .. 65 => true,\n             _ => false,\n         },\n         _ => false\n@@ -673,7 +667,7 @@ pub fn is_any_keyword(tok: &Token) -> bool {\n pub fn is_strict_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {\n-            8 | 29 | 35 .. 67 => true,\n+            8 | 27 | 32 .. 64 => true,\n             _ => false,\n         },\n         _ => false,\n@@ -683,7 +677,7 @@ pub fn is_strict_keyword(tok: &Token) -> bool {\n pub fn is_reserved_keyword(tok: &Token) -> bool {\n     match *tok {\n         token::IDENT(sid, false) => match sid.name {\n-            68 => true,\n+            65 => true,\n             _ => false,\n         },\n         _ => false,"}, {"sha": "0a20526da44c512de9c918fdbbe677463e3bad14", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -458,8 +458,11 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n         word(s.s, \";\");\n         end(s); // end the outer fn box\n       }\n-      ast::foreign_item_const(t) => {\n+      ast::foreign_item_static(t, m) => {\n         head(s, \"static\");\n+        if m {\n+            word_space(s, \"mut\");\n+        }\n         print_ident(s, item.ident);\n         word_space(s, \":\");\n         print_type(s, t);\n@@ -477,8 +480,11 @@ pub fn print_item(s: @ps, item: @ast::item) {\n     let ann_node = node_item(s, item);\n     (s.ann.pre)(ann_node);\n     match item.node {\n-      ast::item_const(ty, expr) => {\n+      ast::item_static(ty, m, expr) => {\n         head(s, visibility_qualified(item.vis, \"static\"));\n+        if m == ast::m_mutbl {\n+            word_space(s, \"mut\");\n+        }\n         print_ident(s, item.ident);\n         word_space(s, \":\");\n         print_type(s, ty);\n@@ -1737,7 +1743,7 @@ pub fn print_bounds(s: @ps, bounds: @OptVec<ast::TyParamBound>) {\n     if !bounds.is_empty() {\n         word(s.s, \":\");\n         let mut first = true;\n-        for bounds.each |bound| {\n+        for bounds.iter().advance |bound| {\n             nbsp(s);\n             if first {\n                 first = false;"}, {"sha": "278600bc0394cf4768f6c6b87bbce7824107ed7e", "filename": "src/libsyntax/syntax.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "previous_filename": "src/libsyntax/syntax.rc"}, {"sha": "5e409be3e6cce72c71a3709dfa0a85e82dab7c9d", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -148,7 +148,7 @@ fn visit_trait_ref<E: Copy>(tref: @ast::trait_ref, (e, v): (E, vt<E>)) {\n \n pub fn visit_item<E: Copy>(i: @item, (e, v): (E, vt<E>)) {\n     match i.node {\n-        item_const(t, ex) => {\n+        item_static(t, _, ex) => {\n             (v.visit_ty)(t, (copy e, v));\n             (v.visit_expr)(ex, (copy e, v));\n         }\n@@ -326,15 +326,15 @@ pub fn visit_foreign_item<E: Copy>(ni: @foreign_item, (e, v): (E, vt<E>)) {\n             visit_fn_decl(fd, (copy e, v));\n             (v.visit_generics)(generics, (e, v));\n         }\n-        foreign_item_const(t) => {\n+        foreign_item_static(t, _) => {\n             (v.visit_ty)(t, (e, v));\n         }\n     }\n }\n \n pub fn visit_ty_param_bounds<E: Copy>(bounds: &OptVec<TyParamBound>,\n                                       (e, v): (E, vt<E>)) {\n-    for bounds.each |bound| {\n+    for bounds.iter().advance |bound| {\n         match *bound {\n             TraitTyParamBound(ty) => visit_trait_ref(ty, (copy e, v)),\n             RegionTyParamBound => {}\n@@ -343,7 +343,7 @@ pub fn visit_ty_param_bounds<E: Copy>(bounds: &OptVec<TyParamBound>,\n }\n \n pub fn visit_generics<E: Copy>(generics: &Generics, (e, v): (E, vt<E>)) {\n-    for generics.ty_params.each |tp| {\n+    for generics.ty_params.iter().advance |tp| {\n         visit_ty_param_bounds(tp.bounds, (copy e, v));\n     }\n }"}, {"sha": "de46d7b3e8ae7a05a4050557b2698962903d7de5", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -154,6 +154,16 @@ debug_abi_2(floats f) {\n     return ff;\n }\n \n+extern \"C\" int\n+debug_static_mut;\n+\n+int debug_static_mut = 3;\n+\n+extern \"C\" void\n+debug_static_mut_check_four() {\n+    assert(debug_static_mut == 4);\n+}\n+\n /* Debug builtins for std::dbg. */\n \n static void\n@@ -729,15 +739,6 @@ rust_task_deref(rust_task *task) {\n     task->deref();\n }\n \n-// Must call on rust stack.\n-extern \"C\" CDECL void\n-rust_call_tydesc_glue(void *root, size_t *tydesc, size_t glue_index) {\n-    void (*glue_fn)(void *, void *, void *) =\n-        (void (*)(void *, void *, void *))tydesc[glue_index];\n-    if (glue_fn)\n-        glue_fn(0, 0, root);\n-}\n-\n // Don't run on the Rust stack!\n extern \"C\" void\n rust_log_str(uint32_t level, const char *str, size_t size) {"}, {"sha": "81ae991623f8c7f06d8a5b3a9f4961d65ab086aa", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -183,7 +183,11 @@ void task_start_wrapper(spawn_args *a)\n     if(env) {\n         // free the environment (which should be a unique closure).\n         const type_desc *td = env->td;\n-        td->drop_glue(NULL, NULL, box_body(env));\n+        td->drop_glue(NULL,\n+#ifdef _RUST_STAGE0\n+                      NULL,\n+#endif\n+                      box_body(env));\n         task->kernel->region()->free(env);\n     }\n "}, {"sha": "30ff5f1fa54e2d399c6f8de792f2e90ae1c8bfe6", "filename": "src/rt/rust_type.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Frt%2Frust_type.h", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Frt%2Frust_type.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_type.h?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -25,7 +25,11 @@ typedef void (*CDECL spawn_fn)(rust_opaque_box*, void *);\n \n struct type_desc;\n \n-typedef void CDECL (glue_fn)(void *, const type_desc **, void *);\n+typedef void CDECL (glue_fn)(void *,\n+#ifdef _RUST_STAGE0\n+                             const type_desc **,\n+#endif\n+                             void *);\n \n // Corresponds to the boxed data in the @ region.  The body follows the\n // header; you can obtain a ptr via box_body() below.\n@@ -57,8 +61,6 @@ struct type_desc {\n     glue_fn *drop_glue;\n     glue_fn *free_glue;\n     glue_fn *visit_glue;\n-    const uint8_t *unused;\n-    const uint8_t *unused2;\n };\n \n extern \"C\" type_desc *rust_clone_type_desc(type_desc*);"}, {"sha": "4a15830e529a0fb59ce4262cb5a60cfd9248fbdb", "filename": "src/rt/rust_util.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Frt%2Frust_util.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Frt%2Frust_util.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.cpp?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -21,8 +21,6 @@ struct type_desc str_body_tydesc = {\n     NULL, // drop_glue\n     NULL, // free_glue\n     NULL, // visit_glue\n-    NULL, // shape\n-    NULL, // shape_tables\n };\n \n //"}, {"sha": "a4876618c971573ecbc5756c86c72fdd642e79a2", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -7,6 +7,8 @@ debug_tydesc\n debug_get_stk_seg\n debug_abi_1\n debug_abi_2\n+debug_static_mut\n+debug_static_mut_check_four\n get_task_id\n get_time\n rust_tzset\n@@ -174,7 +176,6 @@ rust_set_task_local_data\n rust_task_local_data_atexit\n rust_task_ref\n rust_task_deref\n-rust_call_tydesc_glue\n tdefl_compress_mem_to_heap\n tinfl_decompress_mem_to_heap\n rust_gc_metadata\n@@ -239,4 +240,4 @@ rust_valgrind_stack_deregister\n rust_take_env_lock\n rust_drop_env_lock\n rust_update_log_settings\n-rust_running_on_valgrind\n\\ No newline at end of file\n+rust_running_on_valgrind"}, {"sha": "910de5f66b7f69deb76cfdbc7022e73053b2abcf", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -1,3 +1,11 @@\n+S 2013-06-23 f827561\n+  macos-i386 63ffbcf99b6853d7840bdfe01380068518d0e466\n+  macos-x86_64 b34fdf3845f8ef4760817007d8ef820cd32f2e07\n+  winnt-i386 6602150074ec442fd376fddb2eaf63f5da6fdff9\n+  freebsd-x86_64 a05bdda2d9ec0e66336d81b98bee8a95442a501f\n+  linux-i386 b8f4a0f0c2250aa4d76ec1eb57c83bfae5725f93\n+  linux-x86_64 caea3402663334d0a3967c21f58a860c060d5474\n+\n S 2013-06-21 6759ce4\n   macos-i386 6e5395d2fda1db356f64af28ba525031bf9871c7\n   macos-x86_64 7b8ded4e1ba1e999a5614eea3a4acacb2c7cef1d"}, {"sha": "8dc45c681bfef07e1b89c26c7611210740e3341e", "filename": "src/test/auxiliary/static_mut_xc.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fauxiliary%2Fstatic_mut_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fauxiliary%2Fstatic_mut_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic_mut_xc.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -0,0 +1 @@\n+pub static mut a: int = 3;"}, {"sha": "d21888f12ec671c7c041ff60046acd7b39cf0c86", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -86,7 +86,7 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n         HashSet::new()\n     };\n \n-    for vec::each(edges) |e| {\n+    for edges.iter().advance |e| {\n         match *e {\n             (i, j) => {\n                 graph[i].insert(j);\n@@ -441,7 +441,7 @@ fn main() {\n     let stop = time::precise_time_s();\n \n     let mut total_edges = 0;\n-    vec::each(graph, |edges| { total_edges += edges.len(); true });\n+    for graph.iter().advance |edges| { total_edges += edges.len(); }\n \n     io::stdout().write_line(fmt!(\"Generated graph with %? edges in %? seconds.\",\n                                  total_edges / 2,"}, {"sha": "102f7f17065926012ce773a7d94c1bf3d46b0587", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -83,7 +83,7 @@ fn run(args: &[~str]) {\n         server(&from_parent, &to_parent);\n     }\n \n-    for vec::each(worker_results) |r| {\n+    for worker_results.iter().advance |r| {\n         r.recv();\n     }\n "}, {"sha": "b8d91bb93e2e308b0d63e1d1a3ffa0b3d8c88973", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -79,7 +79,7 @@ fn run(args: &[~str]) {\n         server(&from_parent, &to_parent);\n     }\n \n-    for vec::each(worker_results) |r| {\n+    for worker_results.iter().advance |r| {\n         r.recv();\n     }\n "}, {"sha": "96c7e4e9b375bb5656fb31fcd06328d0d3d6839a", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -188,15 +188,15 @@ fn rendezvous(nn: uint, set: ~[color]) {\n \n     // save each creature's meeting stats\n     let mut report = ~[];\n-    for vec::each(to_creature) |_to_one| {\n+    for to_creature.iter().advance |_to_one| {\n         report.push(from_creatures_log.recv());\n     }\n \n     // print each color in the set\n     io::println(show_color_list(set));\n \n     // print each creature's stats\n-    for vec::each(report) |rep| {\n+    for report.iter().advance |rep| {\n         io::println(*rep);\n     }\n "}, {"sha": "20042aa0e918aa0c827d98a7e070e954aa2a2697", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -56,7 +56,7 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n    let mut pairs = ~[];\n \n    // map -> [(k,%)]\n-   for mm.each |&key, &val| {\n+   for mm.iter().advance |(&key, &val)| {\n       pairs.push((key, pct(val, total)));\n    }\n "}, {"sha": "1aa05a9477de9a43dc85d09de7d499bbd5a7173a", "filename": "src/test/compile-fail/block-must-not-have-result-for.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n-\n fn main() {\n-    for vec::each(~[0]) |_i| {  //~ ERROR A for-loop body must return (), but\n+    for 2.times {  //~ ERROR A for-loop body must return (), but\n         true\n     }\n }"}, {"sha": "189a0ef9d700b341a1d530bff06188d09a8bb7b8", "filename": "src/test/compile-fail/borrowck-insert-during-each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -16,7 +16,7 @@ struct Foo {\n \n impl Foo {\n     pub fn foo(&mut self, fun: &fn(&int)) {\n-        for self.n.each |f| {\n+        for self.n.iter().advance |f| {\n             fun(f);\n         }\n     }"}, {"sha": "5559ba344ed17a44e61bc775f65e77413276e033", "filename": "src/test/compile-fail/issue-2151.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -8,10 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n-\n fn main() {\n-    for vec::each(fail!()) |i| {\n-        let _ = i * 2; //~ ERROR the type of this value must be known\n-   };\n+    let x = fail!();\n+    x.clone(); //~ ERROR the type of this value must be known in this context\n }"}, {"sha": "5502b18f094130910049e6f28d78ae2ce6f3f88e", "filename": "src/test/compile-fail/issue-3099-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fissue-3099-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fissue-3099-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3099-b.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -10,6 +10,6 @@\n \n pub mod a {}\n \n-pub mod a {} //~ ERROR duplicate definition of type `a`\n+pub mod a {} //~ ERROR duplicate definition of module `a`\n \n fn main() {}"}, {"sha": "977abc4dc0d12d7edd9622b9160ef3b533539659", "filename": "src/test/compile-fail/lint-change-warnings.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Flint-change-warnings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Flint-change-warnings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-change-warnings.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deny(warnings)];\n+\n+fn main() {\n+    while true {} //~ ERROR: infinite\n+}\n+\n+#[allow(warnings)]\n+fn foo() {\n+    while true {}\n+}\n+\n+#[warn(warnings)]\n+fn bar() {\n+    while true {} //~ WARNING: infinite\n+}\n+\n+#[forbid(warnings)]\n+fn baz() {\n+    while true {} //~ ERROR: warnings\n+}"}, {"sha": "fbb6d03b220029d97947fbac672cb5bab04c429a", "filename": "src/test/compile-fail/liveness-issue-2163.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -12,7 +12,7 @@ use std::vec;\n \n fn main() {\n     let a: ~[int] = ~[];\n-    vec::each(a, |_| -> bool {\n+    a.iter().advance(|_| -> bool {\n         //~^ ERROR mismatched types\n     });\n }"}, {"sha": "7aed3ce30bc5987d53125ee8bc8545e1119627d3", "filename": "src/test/compile-fail/static-mut-bad-types.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fstatic-mut-bad-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fstatic-mut-bad-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-bad-types.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static mut a: int = 3;\n+\n+fn main() {\n+    unsafe {\n+        a = true; //~ ERROR: mismatched types\n+    }\n+}"}, {"sha": "7b371cf708dc1af76df0858c66a0b85271defd56", "filename": "src/test/compile-fail/static-mut-foreign-requires-unsafe.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fstatic-mut-foreign-requires-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fstatic-mut-foreign-requires-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-foreign-requires-unsafe.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::libc;\n+\n+extern {\n+    static mut a: libc::c_int;\n+}\n+\n+fn main() {\n+    a += 3;     //~ ERROR: requires unsafe\n+    a = 4;      //~ ERROR: requires unsafe\n+    let _b = a; //~ ERROR: requires unsafe\n+}"}, {"sha": "61d3ed7fd18e14309f52dc47ec8e488cd358d0ee", "filename": "src/test/compile-fail/static-mut-not-constant.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static mut a: ~int = ~3; //~ ERROR: disallowed operator in constant\n+\n+fn main() {}"}, {"sha": "997003a28d4235343692d4d955317970a2ea5ab7", "filename": "src/test/compile-fail/static-mut-not-pat.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-pat.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Constants (static variables) can be used to match in patterns, but mutable\n+// statics cannot. This ensures that there's some form of error if this is\n+// attempted.\n+\n+static mut a: int = 3;\n+\n+fn main() {\n+    // If they can't be matched against, then it's possible to capture the same\n+    // name as a variable, hence this should be an unreachable pattern situation\n+    // instead of spitting out a custom error about some identifier collisions\n+    // (we should allow shadowing)\n+    match 4 {\n+        a => {}\n+        _ => {} //~ ERROR: unreachable pattern\n+    }\n+}"}, {"sha": "7337920cce68c559785939721a28ac0867e2c4b6", "filename": "src/test/compile-fail/static-mut-requires-unsafe.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fstatic-mut-requires-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Fcompile-fail%2Fstatic-mut-requires-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-requires-unsafe.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static mut a: int = 3;\n+\n+fn main() {\n+    a += 3;         //~ ERROR: requires unsafe\n+    a = 4;          //~ ERROR: requires unsafe\n+    let _b = a;     //~ ERROR: requires unsafe\n+}"}, {"sha": "b65b18e1ab3af95b9009c9921c9adb97d23364fa", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -12,21 +12,19 @@\n // making method calls, but only if there aren't any matches without\n // it.\n \n-use std::vec;\n-\n trait iterable<A> {\n     fn iterate(&self, blk: &fn(x: &A) -> bool) -> bool;\n }\n \n impl<'self,A> iterable<A> for &'self [A] {\n     fn iterate(&self, f: &fn(x: &A) -> bool) -> bool {\n-        vec::each(*self, f)\n+        self.iter().advance(f)\n     }\n }\n \n impl<A> iterable<A> for ~[A] {\n     fn iterate(&self, f: &fn(x: &A) -> bool) -> bool {\n-        vec::each(*self, f)\n+        self.iter().advance(f)\n     }\n }\n "}, {"sha": "e6f05970cced78ffaa53190298c915cd144d92e1", "filename": "src/test/run-pass/attr-no-drop-flag-size.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fattr-no-drop-flag-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fattr-no-drop-flag-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fattr-no-drop-flag-size.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::sys::size_of;\n+\n+#[no_drop_flag]\n+struct Test<T> {\n+    a: T\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for Test<T> {\n+    fn finalize(&self) { }\n+}\n+\n+fn main() {\n+    assert_eq!(size_of::<int>(), size_of::<Test<int>>());\n+}"}, {"sha": "185a5a6407c7d70b9b287710b9ac02c64568603c", "filename": "src/test/run-pass/auto-loop.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-loop.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n-\n pub fn main() {\n     let mut sum = 0;\n-    for vec::each(~[1, 2, 3, 4, 5]) |x| {\n+    let xs = ~[1, 2, 3, 4, 5];\n+    for xs.iter().advance |x| {\n         sum += *x;\n     }\n     assert_eq!(sum, 15);"}, {"sha": "ff5d0e9f05c657d341fdfa964689d517d77016c9", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -15,7 +15,7 @@ pub fn main() {\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n \n     // Statement form does not require parentheses:\n-    for vec::each(v) |i| {\n+    for v.iter().advance |i| {\n         info!(\"%?\", *i);\n     }\n "}, {"sha": "8f74e6cdc299fa3ce0feb496042026dba85ad0dc", "filename": "src/test/run-pass/borrowck-mut-vec-as-imm-slice.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n-\n fn want_slice(v: &[int]) -> int {\n     let mut sum = 0;\n-    for vec::each(v) |i| { sum += *i; }\n-    return sum;\n+    for v.iter().advance |i| { sum += *i; }\n+    sum\n }\n \n fn has_mut_vec(v: ~[int]) -> int {"}, {"sha": "85c6f90a742bef6362598216db848ce5bb1192aa", "filename": "src/test/run-pass/break.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fbreak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fbreak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbreak.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -16,7 +16,8 @@ pub fn main() {\n     assert_eq!(i, 10);\n     loop { i += 1; if i == 20 { break; } }\n     assert_eq!(i, 20);\n-    for vec::each(~[1, 2, 3, 4, 5, 6]) |x| {\n+    let xs = [1, 2, 3, 4, 5, 6];\n+    for xs.iter().advance |x| {\n         if *x == 3 { break; } assert!((*x <= 3));\n     }\n     i = 0;\n@@ -26,7 +27,8 @@ pub fn main() {\n         i += 1; if i % 2 == 0 { loop; } assert!((i % 2 != 0));\n         if i >= 10 { break; }\n     }\n-    for vec::each(~[1, 2, 3, 4, 5, 6]) |x| {\n+    let ys = ~[1, 2, 3, 4, 5, 6];\n+    for ys.iter().advance |x| {\n         if *x % 2 == 0 { loop; }\n         assert!((*x % 2 != 0));\n     }"}, {"sha": "2805fec6fce2cda2a6afe8cec5bce4bed8c37e5c", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -61,29 +61,8 @@ impl<T> Mutable for cat<T> {\n }\n \n impl<T> Map<int, T> for cat<T> {\n-    fn each<'a>(&'a self, f: &fn(&int, &'a T) -> bool) -> bool {\n-        let mut n = int::abs(self.meows);\n-        while n > 0 {\n-            if !f(&n, &self.name) { return false; }\n-            n -= 1;\n-        }\n-        return true;\n-    }\n-\n     fn contains_key(&self, k: &int) -> bool { *k <= self.meows }\n \n-    fn each_key(&self, f: &fn(v: &int) -> bool) -> bool {\n-        self.each(|k, _| f(k))\n-    }\n-\n-    fn each_value<'a>(&'a self, f: &fn(v: &'a T) -> bool) -> bool {\n-        self.each(|_, v| f(v))\n-    }\n-\n-    fn mutate_values(&mut self, _f: &fn(&int, &mut T) -> bool) -> bool {\n-        fail!(\"nope\")\n-    }\n-\n     fn insert(&mut self, k: int, _: T) -> bool {\n         self.meows += k;\n         true"}, {"sha": "45302363c380ce5fc5b73c03738e7b1847fb6b08", "filename": "src/test/run-pass/const-vec-of-fns.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-fast\n+// xfail-test\n+// FIXME: #7385: hits a codegen bug on OS X x86_64\n \n /*!\n  * Try to double-check that static fns have the right size (with or\n@@ -23,6 +24,6 @@ struct S<'self>(&'self fn());\n static closures: &'static [S<'static>] = &[S(f), S(f)];\n \n pub fn main() {\n-    for std::vec::each(bare_fns) |&bare_fn| { bare_fn() }\n-    for std::vec::each(closures) |&closure| { (*closure)() }\n+    for bare_fns.iter().advance |&bare_fn| { bare_fn() }\n+    for closures.iter().advance |&closure| { (*closure)() }\n }"}, {"sha": "27c45893930ca937a7399660d6292ebbdba28bc8", "filename": "src/test/run-pass/extern-pub.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fextern-pub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fextern-pub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pub.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -1,11 +1,5 @@\n-use std::libc;\n-use std::sys;\n-use std::vec;\n-\n extern {\n-    pub unsafe fn vec_reserve_shared_actual(t: *sys::TypeDesc,\n-                                            v: **vec::raw::VecRepr,\n-                                            n: libc::size_t);\n+    pub unsafe fn free(p: *u8);\n }\n \n pub fn main() {"}, {"sha": "dd1cda22e653880682b02ed92250e1257eb5563e", "filename": "src/test/run-pass/for-destruct.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Ffor-destruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Ffor-destruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffor-destruct.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test: #3511: does not currently compile, due to rvalue issues\n+\n use std::vec;\n \n struct Pair { x: int, y: int }\n-\n pub fn main() {\n     for vec::each(~[Pair {x: 10, y: 20}, Pair {x: 30, y: 0}]) |elt| {\n         assert_eq!(elt.x + elt.y, 30);"}, {"sha": "b62475ded54fe1bb69d66ae667797ac2300921e0", "filename": "src/test/run-pass/rcvr-borrowed-to-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -18,7 +18,7 @@ trait sum {\n impl<'self> sum for &'self [int] {\n     fn sum(self) -> int {\n         let mut sum = 0;\n-        for vec::each(self) |e| { sum += *e; }\n+        for self.iter().advance |e| { sum += *e; }\n         return sum;\n     }\n }"}, {"sha": "176e49e0ea195b3b956ed05cb277b4ae7a0b82a6", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -10,15 +10,14 @@\n \n // xfail-fast\n \n-use std::bool;\n use std::int;\n use std::libc::c_void;\n use std::ptr;\n use std::sys;\n use std::vec::UnboxedVecRepr;\n-use intrinsic::{TyDesc, get_tydesc, visit_tydesc, TyVisitor, Opaque};\n+use std::unstable::intrinsics::{TyDesc, get_tydesc, visit_tydesc, TyVisitor, Opaque};\n \n-#[doc = \"High-level interfaces to `intrinsic::visit_ty` reflection system.\"]\n+#[doc = \"High-level interfaces to `std::unstable::intrinsics::visit_ty` reflection system.\"]\n \n /// Trait for visitor that wishes to reflect on data.\n trait movable_ptr {\n@@ -637,7 +636,9 @@ impl TyVisitor for my_visitor {\n }\n \n fn get_tydesc_for<T>(_t: T) -> *TyDesc {\n-    get_tydesc::<T>()\n+    unsafe {\n+        get_tydesc::<T>()\n+    }\n }\n \n struct Triple { x: int, y: int, z: int }\n@@ -651,8 +652,8 @@ pub fn main() {\n                                        vals: ~[]});\n         let v = ptr_visit_adaptor(Inner {inner: u});\n         let td = get_tydesc_for(r);\n-        unsafe { error!(\"tydesc sz: %u, align: %u\",\n-                        (*td).size, (*td).align); }\n+        error!(\"tydesc sz: %u, align: %u\",\n+               (*td).size, (*td).align);\n         let v = @v as @TyVisitor;\n         visit_tydesc(td, v);\n \n@@ -661,8 +662,7 @@ pub fn main() {\n             println(fmt!(\"val: %s\", *s));\n         }\n         error!(\"%?\", u.vals.clone());\n-        assert!(u.vals == ~[\n-            ~\"1\", ~\"2\", ~\"3\", ~\"true\", ~\"false\", ~\"5\", ~\"4\", ~\"3\", ~\"12\"\n-        ]);\n+        assert_eq!(u.vals.clone(),\n+                   ~[ ~\"1\", ~\"2\", ~\"3\", ~\"true\", ~\"false\", ~\"5\", ~\"4\", ~\"3\", ~\"12\"]);\n     }\n- }\n+}"}, {"sha": "bb1c92dfa8a730ab317c58e473d64e72c464d95a", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 96, "deletions": 85, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -8,151 +8,162 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n-use intrinsic::{TyDesc, get_tydesc, visit_tydesc, TyVisitor};\n-struct my_visitor(@mut { types: ~[str] });\n+use std::unstable::intrinsics::{TyDesc, get_tydesc, visit_tydesc, TyVisitor, Opaque};\n \n-impl TyVisitor for my_visitor {\n-    fn visit_bot() -> bool {\n-        self.types += ~[\"bot\"];\n+struct MyVisitor {\n+    types: @mut ~[~str],\n+}\n+\n+impl TyVisitor for MyVisitor {\n+    fn visit_bot(&self) -> bool {\n+        self.types.push(~\"bot\");\n         error!(\"visited bot type\");\n         true\n     }\n-    fn visit_nil() -> bool {\n-        self.types += ~[\"nil\"];\n+    fn visit_nil(&self) -> bool {\n+        self.types.push(~\"nil\");\n         error!(\"visited nil type\");\n         true\n     }\n-    fn visit_bool() -> bool {\n-        self.types += ~[\"bool\"];\n+    fn visit_bool(&self) -> bool {\n+        self.types.push(~\"bool\");\n         error!(\"visited bool type\");\n         true\n     }\n-    fn visit_int() -> bool {\n-        self.types += ~[\"int\"];\n+    fn visit_int(&self) -> bool {\n+        self.types.push(~\"int\");\n         error!(\"visited int type\");\n         true\n     }\n-    fn visit_i8() -> bool {\n-        self.types += ~[\"i8\"];\n+    fn visit_i8(&self) -> bool {\n+        self.types.push(~\"i8\");\n         error!(\"visited i8 type\");\n         true\n     }\n-    fn visit_i16() -> bool {\n-        self.types += ~[\"i16\"];\n+    fn visit_i16(&self) -> bool {\n+        self.types.push(~\"i16\");\n         error!(\"visited i16 type\");\n         true\n     }\n-    fn visit_i32() -> bool { true }\n-    fn visit_i64() -> bool { true }\n-\n-    fn visit_uint() -> bool { true }\n-    fn visit_u8() -> bool { true }\n-    fn visit_u16() -> bool { true }\n-    fn visit_u32() -> bool { true }\n-    fn visit_u64() -> bool { true }\n-\n-    fn visit_float() -> bool { true }\n-    fn visit_f32() -> bool { true }\n-    fn visit_f64() -> bool { true }\n-\n-    fn visit_char() -> bool { true }\n-    fn visit_str() -> bool { true }\n-\n-    fn visit_estr_box() -> bool { true }\n-    fn visit_estr_uniq() -> bool { true }\n-    fn visit_estr_slice() -> bool { true }\n-    fn visit_estr_fixed(_sz: uint, _sz: uint,\n+    fn visit_i32(&self) -> bool { true }\n+    fn visit_i64(&self) -> bool { true }\n+\n+    fn visit_uint(&self) -> bool { true }\n+    fn visit_u8(&self) -> bool { true }\n+    fn visit_u16(&self) -> bool { true }\n+    fn visit_u32(&self) -> bool { true }\n+    fn visit_u64(&self) -> bool { true }\n+\n+    fn visit_float(&self) -> bool { true }\n+    fn visit_f32(&self) -> bool { true }\n+    fn visit_f64(&self) -> bool { true }\n+\n+    fn visit_char(&self) -> bool { true }\n+    fn visit_str(&self) -> bool { true }\n+\n+    fn visit_estr_box(&self) -> bool { true }\n+    fn visit_estr_uniq(&self) -> bool { true }\n+    fn visit_estr_slice(&self) -> bool { true }\n+    fn visit_estr_fixed(&self,\n+                        _sz: uint, _sz: uint,\n                         _align: uint) -> bool { true }\n \n-    fn visit_box(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_uniq(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_ptr(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_rptr(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-\n-    fn visit_vec(_mtbl: uint, inner: *TyDesc) -> bool {\n-        self.types += ~[\"[\"];\n-        visit_tydesc(inner, my_visitor(*self) as TyVisitor);\n-        self.types += ~[\"]\"];\n+    fn visit_box(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_uniq(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_ptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_rptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+\n+    fn visit_vec(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_unboxed_vec(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_box(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_uniq(&self, _mtbl: uint, inner: *TyDesc) -> bool {\n+        self.types.push(~\"[\");\n+        unsafe {\n+            visit_tydesc(inner, (@*self) as @TyVisitor);\n+        }\n+        self.types.push(~\"]\");\n         true\n     }\n-    fn visit_unboxed_vec(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_box(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_uniq(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_slice(_mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_fixed(_n: uint, _sz: uint, _align: uint,\n+    fn visit_evec_slice(&self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_fixed(&self, _n: uint, _sz: uint, _align: uint,\n                         _mtbl: uint, _inner: *TyDesc) -> bool { true }\n \n-    fn visit_enter_rec(_n_fields: uint,\n+    fn visit_enter_rec(&self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n-    fn visit_rec_field(_i: uint, _name: &str,\n+    fn visit_rec_field(&self, _i: uint, _name: &str,\n                        _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_leave_rec(_n_fields: uint,\n+    fn visit_leave_rec(&self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_class(_n_fields: uint,\n+    fn visit_enter_class(&self, _n_fields: uint,\n                          _sz: uint, _align: uint) -> bool { true }\n-    fn visit_class_field(_i: uint, _name: &str,\n+    fn visit_class_field(&self, _i: uint, _name: &str,\n                          _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_leave_class(_n_fields: uint,\n+    fn visit_leave_class(&self, _n_fields: uint,\n                          _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_tup(_n_fields: uint,\n+    fn visit_enter_tup(&self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n-    fn visit_tup_field(_i: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_leave_tup(_n_fields: uint,\n+    fn visit_tup_field(&self, _i: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_leave_tup(&self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_enum(_n_variants: uint,\n+    fn visit_enter_enum(&self, _n_variants: uint,\n+                        _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         _sz: uint, _align: uint) -> bool { true }\n-    fn visit_enter_enum_variant(_variant: uint,\n+    fn visit_enter_enum_variant(&self,\n+                                _variant: uint,\n                                 _disr_val: int,\n                                 _n_fields: uint,\n                                 _name: &str) -> bool { true }\n-    fn visit_enum_variant_field(_i: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_leave_enum_variant(_variant: uint,\n+    fn visit_enum_variant_field(&self, _i: uint, _offset: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_leave_enum_variant(&self,\n+                                _variant: uint,\n                                 _disr_val: int,\n                                 _n_fields: uint,\n                                 _name: &str) -> bool { true }\n-    fn visit_leave_enum(_n_variants: uint,\n+    fn visit_leave_enum(&self,\n+                        _n_variants: uint,\n+                        _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n                         _sz: uint, _align: uint) -> bool { true }\n \n-    fn visit_enter_fn(_purity: uint, _proto: uint,\n+    fn visit_enter_fn(&self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }\n-    fn visit_fn_input(_i: uint, _mode: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_fn_output(_retstyle: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_leave_fn(_purity: uint, _proto: uint,\n+    fn visit_fn_input(&self, _i: uint, _mode: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_fn_output(&self, _retstyle: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_leave_fn(&self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }\n \n \n-    fn visit_trait() -> bool { true }\n-    fn visit_var() -> bool { true }\n-    fn visit_var_integral() -> bool { true }\n-    fn visit_param(_i: uint) -> bool { true }\n-    fn visit_self() -> bool { true }\n-    fn visit_type() -> bool { true }\n-    fn visit_opaque_box() -> bool { true }\n-    fn visit_constr(_inner: *TyDesc) -> bool { true }\n-    fn visit_closure_ptr(_ck: uint) -> bool { true }\n+    fn visit_trait(&self) -> bool { true }\n+    fn visit_var(&self) -> bool { true }\n+    fn visit_var_integral(&self) -> bool { true }\n+    fn visit_param(&self, _i: uint) -> bool { true }\n+    fn visit_self(&self) -> bool { true }\n+    fn visit_type(&self) -> bool { true }\n+    fn visit_opaque_box(&self) -> bool { true }\n+    fn visit_constr(&self, _inner: *TyDesc) -> bool { true }\n+    fn visit_closure_ptr(&self, _ck: uint) -> bool { true }\n }\n \n-fn visit_ty<T>(v: TyVisitor) {\n-    visit_tydesc(get_tydesc::<T>(), v);\n+fn visit_ty<T>(v: @TyVisitor) {\n+    unsafe {\n+        visit_tydesc(get_tydesc::<T>(), v);\n+    }\n }\n \n pub fn main() {\n-    let v = my_visitor(@mut {types: ~[]});\n-    let vv = v as TyVisitor;\n+    let v = @MyVisitor {types: @mut ~[]};\n+    let vv = v as @TyVisitor;\n \n     visit_ty::<bool>(vv);\n     visit_ty::<int>(vv);\n     visit_ty::<i8>(vv);\n     visit_ty::<i16>(vv);\n     visit_ty::<~[int]>(vv);\n \n-    for (v.types.clone()).each {|s|\n-        io::println(fmt!(\"type: %s\", s));\n+    for v.types.iter().advance |&s| {\n+        println(fmt!(\"type: %s\", s));\n     }\n-    assert!(v.types == [\"bool\", \"int\", \"i8\", \"i16\",\n-                       \"[\", \"int\", \"]\"]);\n+    assert_eq!((*v.types).clone(), ~[~\"bool\", ~\"int\", ~\"i8\", ~\"i16\", ~\"[\", ~\"int\", ~\"]\"]);\n }"}, {"sha": "7af143a1529203406e27fa9faeb67f672e2e54b1", "filename": "src/test/run-pass/static-mut-foreign.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fstatic-mut-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fstatic-mut-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-mut-foreign.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Constants (static variables) can be used to match in patterns, but mutable\n+// statics cannot. This ensures that there's some form of error if this is\n+// attempted.\n+\n+use std::libc;\n+\n+#[nolink]\n+extern {\n+    static mut debug_static_mut: libc::c_int;\n+    pub fn debug_static_mut_check_four();\n+}\n+\n+unsafe fn static_bound(_: &'static libc::c_int) {}\n+\n+fn static_bound_set(a: &'static mut libc::c_int) {\n+    *a = 3;\n+}\n+\n+unsafe fn run() {\n+    assert!(debug_static_mut == 3);\n+    debug_static_mut = 4;\n+    assert!(debug_static_mut == 4);\n+    debug_static_mut_check_four();\n+    debug_static_mut += 1;\n+    assert!(debug_static_mut == 5);\n+    debug_static_mut *= 3;\n+    assert!(debug_static_mut == 15);\n+    debug_static_mut = -3;\n+    assert!(debug_static_mut == -3);\n+    static_bound(&debug_static_mut);\n+    static_bound_set(&mut debug_static_mut);\n+}\n+\n+pub fn main() {\n+    unsafe { run() }\n+}"}, {"sha": "ab6bdc20c491cca868dd40dcbfb4011b397ab354", "filename": "src/test/run-pass/static-mut-xc.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fstatic-mut-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Fstatic-mut-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-mut-xc.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Constants (static variables) can be used to match in patterns, but mutable\n+// statics cannot. This ensures that there's some form of error if this is\n+// attempted.\n+\n+// xfail-fast\n+// aux-build:static_mut_xc.rs\n+\n+extern mod static_mut_xc;\n+\n+unsafe fn static_bound(_: &'static int) {}\n+\n+fn static_bound_set(a: &'static mut int) {\n+    *a = 3;\n+}\n+\n+unsafe fn run() {\n+    assert!(static_mut_xc::a == 3);\n+    static_mut_xc::a = 4;\n+    assert!(static_mut_xc::a == 4);\n+    static_mut_xc::a += 1;\n+    assert!(static_mut_xc::a == 5);\n+    static_mut_xc::a *= 3;\n+    assert!(static_mut_xc::a == 15);\n+    static_mut_xc::a = -3;\n+    assert!(static_mut_xc::a == -3);\n+    static_bound(&static_mut_xc::a);\n+    static_bound_set(&mut static_mut_xc::a);\n+}\n+\n+pub fn main() {\n+    unsafe { run() }\n+}\n+\n+pub mod inner {\n+    pub static mut a: int = 4;\n+}"}, {"sha": "dc6bdbf5c1a5c6895cfa4d67e77607437bdb46c9", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d3ca4b8439d043dc77c19424348fac670acc46f/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=5d3ca4b8439d043dc77c19424348fac670acc46f", "patch": "@@ -31,7 +31,10 @@ trait map<T> {\n impl<T> map<T> for ~[T] {\n     fn map<U:Copy>(&self, f: &fn(&T) -> U) -> ~[U] {\n         let mut r = ~[];\n-        for std::vec::each(*self) |x| { r += ~[f(x)]; }\n+        // FIXME: #7355 generates bad code with Iterator\n+        for std::uint::range(0, self.len()) |i| {\n+            r += ~[f(&self[i])];\n+        }\n         r\n     }\n }"}]}