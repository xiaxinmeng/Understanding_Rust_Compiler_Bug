{"sha": "b05556e06da7c79f9db746728c2557114a94b3b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNTU1NmUwNmRhN2M3OWY5ZGI3NDY3MjhjMjU1NzExNGE5NGIzYjE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-23T20:04:27Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:32Z"}, "message": "trans: Rename MonoId to Instance and start using it in more places.", "tree": {"sha": "663da768f0a239f856fb498593ef2aa85033d328", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/663da768f0a239f856fb498593ef2aa85033d328"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b05556e06da7c79f9db746728c2557114a94b3b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b05556e06da7c79f9db746728c2557114a94b3b1", "html_url": "https://github.com/rust-lang/rust/commit/b05556e06da7c79f9db746728c2557114a94b3b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b05556e06da7c79f9db746728c2557114a94b3b1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6e72c48dd7dacebe08b44e7ee6ce0f052797f55", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6e72c48dd7dacebe08b44e7ee6ce0f052797f55", "html_url": "https://github.com/rust-lang/rust/commit/d6e72c48dd7dacebe08b44e7ee6ce0f052797f55"}], "stats": {"total": 416, "additions": 230, "deletions": 186}, "files": [{"sha": "f85d87413843ec927464fef374f86809e893ec44", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=b05556e06da7c79f9db746728c2557114a94b3b1", "patch": "@@ -182,7 +182,7 @@ pub trait CrateStore<'tcx> : Any {\n     fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n                      -> Option<DefId>;\n     fn impl_or_trait_item(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> ty::ImplOrTraitItem<'tcx>;\n+                          -> Option<ty::ImplOrTraitItem<'tcx>>;\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n@@ -353,7 +353,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n                      -> Option<DefId> { unimplemented!() }\n     fn impl_or_trait_item(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> ty::ImplOrTraitItem<'tcx> { unimplemented!() }\n+                          -> Option<ty::ImplOrTraitItem<'tcx>> { unimplemented!() }\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { unimplemented!() }"}, {"sha": "6344553e88bbf09094a8c9fdbd4e478fbf965966", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=b05556e06da7c79f9db746728c2557114a94b3b1", "patch": "@@ -2182,7 +2182,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn impl_or_trait_item(&self, id: DefId) -> ImplOrTraitItem<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"impl_or_trait_items\", id, &self.impl_or_trait_items,\n-            || self.sess.cstore.impl_or_trait_item(self, id))\n+            || self.sess.cstore.impl_or_trait_item(self, id)\n+                   .expect(\"missing ImplOrTraitItem in metadata\"))\n     }\n \n     pub fn trait_item_def_ids(&self, id: DefId) -> Rc<Vec<ImplOrTraitItemId>> {\n@@ -2502,10 +2503,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// ID of the impl that the method belongs to. Otherwise, return `None`.\n     pub fn impl_of_method(&self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return match self.sess.cstore.impl_or_trait_item(self, def_id).container() {\n-                TraitContainer(_) => None,\n-                ImplContainer(def_id) => Some(def_id),\n-            };\n+            return self.sess.cstore.impl_or_trait_item(self, def_id).and_then(|item| {\n+                match item.container() {\n+                    TraitContainer(_) => None,\n+                    ImplContainer(def_id) => Some(def_id),\n+                }\n+            });\n         }\n         match self.impl_or_trait_items.borrow().get(&def_id).cloned() {\n             Some(trait_item) => {"}, {"sha": "fe86e3b1ed69d8b7d9dbdfdeff25ed0c839553cd", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=b05556e06da7c79f9db746728c2557114a94b3b1", "patch": "@@ -14,6 +14,7 @@ use rustc_const_eval::{ConstUsize, ConstInt};\n use middle::def_id::DefId;\n use middle::subst::Substs;\n use middle::ty::{self, AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n+use util::ppaux;\n use rustc_back::slice;\n use rustc_front::hir::InlineAsm;\n use std::ascii;\n@@ -775,8 +776,8 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n             Aggregate(ref kind, ref lvs) => {\n                 use self::AggregateKind::*;\n \n-                fn fmt_tuple(fmt: &mut Formatter, name: &str, lvs: &[Operand]) -> fmt::Result {\n-                    let mut tuple_fmt = fmt.debug_tuple(name);\n+                fn fmt_tuple(fmt: &mut Formatter, lvs: &[Operand]) -> fmt::Result {\n+                    let mut tuple_fmt = fmt.debug_tuple(\"\");\n                     for lv in lvs {\n                         tuple_fmt.field(lv);\n                     }\n@@ -790,19 +791,24 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         match lvs.len() {\n                             0 => write!(fmt, \"()\"),\n                             1 => write!(fmt, \"({:?},)\", lvs[0]),\n-                            _ => fmt_tuple(fmt, \"\", lvs),\n+                            _ => fmt_tuple(fmt, lvs),\n                         }\n                     }\n \n-                    Adt(adt_def, variant, _) => {\n+                    Adt(adt_def, variant, substs) => {\n                         let variant_def = &adt_def.variants[variant];\n-                        let name = ty::tls::with(|tcx| tcx.item_path_str(variant_def.did));\n+\n+                        try!(ppaux::parameterized(fmt, substs, variant_def.did,\n+                                                  ppaux::Ns::Value, &[],\n+                                                  |tcx| {\n+                            tcx.lookup_item_type(variant_def.did).generics\n+                        }));\n \n                         match variant_def.kind() {\n-                            ty::VariantKind::Unit => write!(fmt, \"{}\", name),\n-                            ty::VariantKind::Tuple => fmt_tuple(fmt, &name, lvs),\n+                            ty::VariantKind::Unit => Ok(()),\n+                            ty::VariantKind::Tuple => fmt_tuple(fmt, lvs),\n                             ty::VariantKind::Struct => {\n-                                let mut struct_fmt = fmt.debug_struct(&name);\n+                                let mut struct_fmt = fmt.debug_struct(\"\");\n                                 for (field, lv) in variant_def.fields.iter().zip(lvs) {\n                                     struct_fmt.field(&field.name.as_str(), lv);\n                                 }\n@@ -882,8 +888,10 @@ impl<'tcx> Debug for Literal<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::Literal::*;\n         match *self {\n-            Item { def_id, .. } =>\n-                write!(fmt, \"{}\", item_path_str(def_id)),\n+            Item { def_id, substs } => {\n+                ppaux::parameterized(fmt, substs, def_id, ppaux::Ns::Value, &[],\n+                                     |tcx| tcx.lookup_item_type(def_id).generics)\n+            }\n             Value { ref value } => {\n                 try!(write!(fmt, \"const \"));\n                 fmt_const_val(fmt, value)"}, {"sha": "e1690f1a8592a11d1b542d39ce7317c3773f3905", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 56, "deletions": 24, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b05556e06da7c79f9db746728c2557114a94b3b1", "patch": "@@ -60,17 +60,37 @@ fn fn_sig(f: &mut fmt::Formatter,\n     }\n }\n \n-fn parameterized<GG>(f: &mut fmt::Formatter,\n-                     substs: &subst::Substs,\n-                     did: DefId,\n-                     projections: &[ty::ProjectionPredicate],\n-                     get_generics: GG)\n-                     -> fmt::Result\n+/// Namespace of the path given to parameterized to print.\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum Ns {\n+    Type,\n+    Value\n+}\n+\n+pub fn parameterized<GG>(f: &mut fmt::Formatter,\n+                         substs: &subst::Substs,\n+                         did: DefId,\n+                         ns: Ns,\n+                         projections: &[ty::ProjectionPredicate],\n+                         get_generics: GG)\n+                         -> fmt::Result\n     where GG: for<'tcx> FnOnce(&TyCtxt<'tcx>) -> ty::Generics<'tcx>\n {\n-    let (fn_trait_kind, verbose) = try!(ty::tls::with(|tcx| {\n+    if let (Ns::Value, Some(self_ty)) = (ns, substs.self_ty()) {\n+        try!(write!(f, \"<{} as \", self_ty));\n+    }\n+\n+    let (fn_trait_kind, verbose, last_name) = try!(ty::tls::with(|tcx| {\n+        let (did, last_name) = if ns == Ns::Value {\n+            // Try to get the impl/trait parent, if this is an\n+            // associated value item (method or constant).\n+            tcx.trait_of_item(did).or_else(|| tcx.impl_of_method(did))\n+               .map_or((did, None), |parent| (parent, Some(tcx.item_name(did))))\n+        } else {\n+            (did, None)\n+        };\n         try!(write!(f, \"{}\", tcx.item_path_str(did)));\n-        Ok((tcx.lang_items.fn_trait_kind(did), tcx.sess.verbose()))\n+        Ok((tcx.lang_items.fn_trait_kind(did), tcx.sess.verbose(), last_name))\n     }));\n \n     let mut empty = true;\n@@ -185,7 +205,28 @@ fn parameterized<GG>(f: &mut fmt::Formatter,\n                     projection.ty));\n     }\n \n-    start_or_continue(f, \"\", \">\")\n+    try!(start_or_continue(f, \"\", \">\"));\n+\n+    // For values, also print their name and type parameters.\n+    if ns == Ns::Value {\n+        if substs.self_ty().is_some() {\n+            try!(write!(f, \">\"));\n+        }\n+\n+        if let Some(name) = last_name {\n+            try!(write!(f, \"::{}\", name));\n+        }\n+        let tps = substs.types.get_slice(subst::FnSpace);\n+        if !tps.is_empty() {\n+            try!(write!(f, \"::<{}\", tps[0]));\n+            for ty in &tps[1..] {\n+                try!(write!(f, \", {}\", ty));\n+            }\n+            try!(write!(f, \">\"));\n+        }\n+    }\n+\n+    Ok(())\n }\n \n fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n@@ -265,6 +306,7 @@ impl<'tcx> fmt::Display for TraitAndProjections<'tcx> {\n         let TraitAndProjections(ref trait_ref, ref projection_bounds) = *self;\n         parameterized(f, trait_ref.substs,\n                       trait_ref.def_id,\n+                      Ns::Type,\n                       projection_bounds,\n                       |tcx| tcx.lookup_trait_def(trait_ref.def_id).generics.clone())\n     }\n@@ -769,7 +811,7 @@ impl fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region, ty::Region>>\n \n impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        parameterized(f, self.substs, self.def_id, &[],\n+        parameterized(f, self.substs, self.def_id, Ns::Type, &[],\n                       |tcx| tcx.lookup_trait_def(self.def_id).generics.clone())\n     }\n }\n@@ -821,19 +863,9 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     try!(write!(f, \"extern {} \", bare_fn.abi));\n                 }\n \n-                try!(write!(f, \"{}\", bare_fn.sig.0));\n-                try!(ty::tls::with(|tcx| {\n-                    write!(f, \" {{{}\", tcx.item_path_str(def_id))\n-                }));\n-\n-                let tps = substs.types.get_slice(subst::FnSpace);\n-                if tps.len() >= 1 {\n-                    try!(write!(f, \"::<{}\", tps[0]));\n-                    for &ty in &tps[1..] {\n-                        try!(write!(f, \", {}\", ty));\n-                    }\n-                    try!(write!(f, \">\"));\n-                }\n+                try!(write!(f, \"{} {{\", bare_fn.sig.0));\n+                try!(parameterized(f, substs, def_id, Ns::Value, &[],\n+                                   |tcx| tcx.lookup_item_type(def_id).generics));\n                 write!(f, \"}}\")\n             }\n             TyFnPtr(ref bare_fn) => {\n@@ -856,7 +888,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                           !tcx.tcache.borrow().contains_key(&def.did) {\n                         write!(f, \"{}<..>\", tcx.item_path_str(def.did))\n                     } else {\n-                        parameterized(f, substs, def.did, &[],\n+                        parameterized(f, substs, def.did, Ns::Type, &[],\n                                       |tcx| tcx.lookup_item_type(def.did).generics)\n                     }\n                 })"}, {"sha": "9ac7216165caf7c60e1839b0350747502adb373d", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=b05556e06da7c79f9db746728c2557114a94b3b1", "patch": "@@ -236,7 +236,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     }\n \n     fn impl_or_trait_item(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> ty::ImplOrTraitItem<'tcx>\n+                          -> Option<ty::ImplOrTraitItem<'tcx>>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_impl_or_trait_item("}, {"sha": "1cb5f2b1c3fbcf86b85287c27bb9bb781edeb23d", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b05556e06da7c79f9db746728c2557114a94b3b1", "patch": "@@ -955,12 +955,16 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n                                     cdata: Cmd,\n                                     id: DefIndex,\n                                     tcx: &TyCtxt<'tcx>)\n-                                    -> ty::ImplOrTraitItem<'tcx> {\n+                                    -> Option<ty::ImplOrTraitItem<'tcx>> {\n     let item_doc = cdata.lookup_item(id);\n \n     let def_id = item_def_id(item_doc, cdata);\n \n-    let container_id = item_require_parent_item(cdata, item_doc);\n+    let container_id = if let Some(id) = item_parent_item(cdata, item_doc) {\n+        id\n+    } else {\n+        return None;\n+    };\n     let container_doc = cdata.lookup_item(container_id.index);\n     let container = match item_family(container_doc) {\n         Trait => TraitContainer(container_id),\n@@ -971,7 +975,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n     let vis = item_visibility(item_doc);\n     let defaultness = item_defaultness(item_doc);\n \n-    match item_sort(item_doc) {\n+    Some(match item_sort(item_doc) {\n         sort @ Some('C') | sort @ Some('c') => {\n             let ty = doc_type(item_doc, tcx, cdata);\n             ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n@@ -1017,8 +1021,8 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n                 container: container,\n             }))\n         }\n-        _ => panic!(\"unknown impl/trait item sort\"),\n-    }\n+        _ => return None\n+    })\n }\n \n pub fn get_trait_item_def_ids(cdata: Cmd, id: DefIndex)\n@@ -1058,7 +1062,7 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n                                                     cdata,\n                                                     did.index,\n                                                     tcx);\n-            if let ty::MethodTraitItem(ref method) = trait_item {\n+            if let Some(ty::MethodTraitItem(ref method)) = trait_item {\n                 Some((*method).clone())\n             } else {\n                 None\n@@ -1087,7 +1091,7 @@ pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n                                                             cdata,\n                                                             did.index,\n                                                             tcx);\n-                    if let ty::ConstTraitItem(ref ac) = trait_item {\n+                    if let Some(ty::ConstTraitItem(ref ac)) = trait_item {\n                         Some((*ac).clone())\n                     } else {\n                         None"}, {"sha": "53bbff50ecf48173f6c440b893d6e525a63a29ca", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=b05556e06da7c79f9db746728c2557114a94b3b1", "patch": "@@ -82,7 +82,7 @@ use trans::machine;\n use trans::machine::{llsize_of, llsize_of_real};\n use trans::meth;\n use trans::mir;\n-use trans::monomorphize;\n+use trans::monomorphize::{self, Instance};\n use trans::tvec;\n use trans::type_::Type;\n use trans::type_of;\n@@ -2077,10 +2077,10 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     .unwrap_or_else(|| ccx.tcx().map.local_def_id(node_id)),\n         };\n \n-        ccx.record_translation_item_as_generated(TransItem::Fn{\n-            def_id: def_id,\n-            substs: ccx.tcx().mk_substs(ccx.tcx().erase_regions(param_substs)),\n-        });\n+        ccx.record_translation_item_as_generated(TransItem::Fn(Instance {\n+            def: def_id,\n+            params: &param_substs.types,\n+        }));\n     }\n }\n "}, {"sha": "bc81b32ae450dcf46ccc861cd5b7a97296edcbd7", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=b05556e06da7c79f9db746728c2557114a94b3b1", "patch": "@@ -25,7 +25,7 @@ use trans::datum::{self, Datum, rvalue_scratch_datum, Rvalue};\n use trans::debuginfo::{self, DebugLoc};\n use trans::declare;\n use trans::expr;\n-use trans::monomorphize::{MonoId};\n+use trans::monomorphize::{Instance};\n use trans::type_of::*;\n use trans::value::Value;\n use trans::Disr;\n@@ -140,7 +140,7 @@ pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n     let substs = ccx.tcx().erase_regions(substs);\n-    let mono_id = MonoId {\n+    let mono_id = Instance {\n         def: closure_id,\n         params: &substs.func_substs.types\n     };"}, {"sha": "43d3cde0f687940858bdb316c5f7e6dae97b7a32", "filename": "src/librustc_trans/trans/collector.rs", "status": "modified", "additions": 65, "deletions": 96, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs?ref=b05556e06da7c79f9db746728c2557114a94b3b1", "patch": "@@ -194,10 +194,10 @@ use rustc_front::intravisit as hir_visit;\n use rustc::front::map as hir_map;\n use rustc::middle::def_id::DefId;\n use rustc::middle::lang_items::{ExchangeFreeFnLangItem, ExchangeMallocFnLangItem};\n-use rustc::middle::{ty, traits};\n+use rustc::middle::traits;\n use rustc::middle::subst::{self, Substs, Subst};\n+use rustc::middle::ty::{self, Ty, TypeFoldable};\n use rustc::middle::ty::adjustment::CustomCoerceUnsized;\n-use rustc::middle::ty::fold::TypeFoldable;\n use rustc::mir::repr as mir;\n use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor as MirVisitor;\n@@ -213,7 +213,7 @@ use trans::common::{fulfill_obligation, normalize_and_test_predicates,\n                     type_is_sized};\n use trans::glue;\n use trans::meth;\n-use trans::monomorphize;\n+use trans::monomorphize::{self, Instance};\n use util::nodemap::{FnvHashSet, FnvHashMap, DefIdMap};\n \n use std::hash::{Hash, Hasher};\n@@ -225,13 +225,10 @@ pub enum TransItemCollectionMode {\n     Lazy\n }\n \n-#[derive(Eq, Clone, Copy, Debug)]\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub enum TransItem<'tcx> {\n-    DropGlue(ty::Ty<'tcx>),\n-    Fn {\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>\n-    },\n+    DropGlue(Ty<'tcx>),\n+    Fn(Instance<'tcx>),\n     Static(NodeId)\n }\n \n@@ -242,35 +239,19 @@ impl<'tcx> Hash for TransItem<'tcx> {\n                 0u8.hash(s);\n                 t.hash(s);\n             },\n-            TransItem::Fn { def_id, substs } => {\n+            TransItem::Fn(instance) => {\n                 1u8.hash(s);\n-                def_id.hash(s);\n-                (substs as *const Substs<'tcx> as usize).hash(s);\n+                instance.def.hash(s);\n+                (instance.params as *const _ as usize).hash(s);\n             }\n             TransItem::Static(node_id) => {\n-                3u8.hash(s);\n+                2u8.hash(s);\n                 node_id.hash(s);\n             }\n         };\n     }\n }\n \n-impl<'tcx> PartialEq for TransItem<'tcx> {\n-    fn eq(&self, other: &Self) -> bool {\n-        match (*self, *other) {\n-            (TransItem::DropGlue(t1), TransItem::DropGlue(t2)) => t1 == t2,\n-            (TransItem::Fn { def_id: def_id1, substs: substs1 },\n-             TransItem::Fn { def_id: def_id2, substs: substs2 }) => {\n-                def_id1 == def_id2 && substs1 == substs2\n-            },\n-            (TransItem::Static(node_id1), TransItem::Static(node_id2)) => {\n-                node_id1 == node_id2\n-            },\n-            _ => false\n-        }\n-    }\n-}\n-\n pub fn collect_crate_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                  mode: TransItemCollectionMode)\n                                                  -> FnvHashSet<TransItem<'tcx>> {\n@@ -357,21 +338,24 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n         TransItem::Static(_) => {\n             recursion_depth_reset = None;\n         }\n-        TransItem::Fn { def_id, substs: ref param_substs } => {\n+        TransItem::Fn(instance) => {\n             // Keep track of the monomorphization recursion depth\n             recursion_depth_reset = Some(check_recursion_limit(ccx,\n-                                                               def_id,\n+                                                               instance,\n                                                                recursion_depths));\n \n             // Scan the MIR in order to find function calls, closures, and\n             // drop-glue\n-            let mir = load_mir(ccx, def_id, mir_cache);\n+            let mir = load_mir(ccx, instance.def, mir_cache);\n \n             let mut visitor = MirNeighborCollector {\n                 ccx: ccx,\n                 mir: mir.get_ref(),\n                 output: &mut neighbors,\n-                param_substs: param_substs\n+                param_substs: ccx.tcx().mk_substs(Substs {\n+                    types: instance.params.clone(),\n+                    regions: subst::ErasedRegions\n+                })\n             };\n \n             visitor.visit_mir(mir.get_ref());\n@@ -421,10 +405,10 @@ fn load_mir<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n fn check_recursion_limit<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n-                                       def_id: DefId,\n+                                       instance: Instance<'tcx>,\n                                        recursion_depths: &mut DefIdMap<usize>)\n                                        -> (DefId, usize) {\n-    let recursion_depth = recursion_depths.get(&def_id)\n+    let recursion_depth = recursion_depths.get(&instance.def)\n                                           .map(|x| *x)\n                                           .unwrap_or(0);\n     debug!(\" => recursion depth={}\", recursion_depth);\n@@ -433,20 +417,18 @@ fn check_recursion_limit<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n     // more than the recursion limit is assumed to be causing an\n     // infinite expansion.\n     if recursion_depth > ccx.sess().recursion_limit.get() {\n-        if let Some(node_id) = ccx.tcx().map.as_local_node_id(def_id) {\n-            ccx.sess().span_fatal(ccx.tcx().map.span(node_id),\n-                \"reached the recursion limit during monomorphization\");\n+        let error = format!(\"reached the recursion limit while instantiating `{}`\",\n+                            instance);\n+        if let Some(node_id) = ccx.tcx().map.as_local_node_id(instance.def) {\n+            ccx.sess().span_fatal(ccx.tcx().map.span(node_id), &error);\n         } else {\n-            let error = format!(\"reached the recursion limit during \\\n-                                monomorphization of '{}'\",\n-                                ccx.tcx().item_path_str(def_id));\n-            ccx.sess().fatal(&error[..]);\n+            ccx.sess().fatal(&error);\n         }\n     }\n \n-    recursion_depths.insert(def_id, recursion_depth + 1);\n+    recursion_depths.insert(instance.def, recursion_depth + 1);\n \n-    (def_id, recursion_depth)\n+    (instance.def, recursion_depth)\n }\n \n struct MirNeighborCollector<'a, 'tcx: 'a> {\n@@ -750,7 +732,7 @@ fn do_static_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 param_substs: &'tcx Substs<'tcx>)\n                                 -> Option<(DefId, &'tcx Substs<'tcx>)> {\n     debug!(\"do_static_dispatch(fn_def_id={}, fn_substs={:?}, param_substs={:?})\",\n-           def_id_to_string(ccx, fn_def_id, None),\n+           def_id_to_string(ccx, fn_def_id),\n            fn_substs,\n            param_substs);\n \n@@ -798,8 +780,8 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                             trait_id={}, \\\n                                             callee_substs={:?}, \\\n                                             param_substs={:?}\",\n-           def_id_to_string(ccx, trait_method.def_id, None),\n-           def_id_to_string(ccx, trait_id, None),\n+           def_id_to_string(ccx, trait_method.def_id),\n+           def_id_to_string(ccx, trait_id),\n            callee_substs,\n            param_substs);\n \n@@ -933,7 +915,7 @@ fn create_fn_trans_item<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   -> TransItem<'tcx>\n {\n     debug!(\"create_fn_trans_item(def_id={}, fn_substs={:?}, param_substs={:?})\",\n-            def_id_to_string(ccx, def_id, None),\n+            def_id_to_string(ccx, def_id),\n             fn_substs,\n             param_substs);\n \n@@ -945,10 +927,10 @@ fn create_fn_trans_item<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                            fn_substs);\n     let concrete_substs = ccx.tcx().erase_regions(&concrete_substs);\n \n-    let trans_item = TransItem::Fn {\n-        def_id: def_id,\n-        substs: ccx.tcx().mk_substs(concrete_substs),\n-    };\n+    let trans_item = TransItem::Fn(Instance {\n+        def: def_id,\n+        params: &ccx.tcx().mk_substs(concrete_substs).types,\n+    });\n \n     return trans_item;\n }\n@@ -1048,8 +1030,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                     if self.mode == TransItemCollectionMode::Eager {\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n                                def_id_to_string(self.ccx,\n-                                                self.ccx.tcx().map.local_def_id(item.id),\n-                                                None));\n+                                                self.ccx.tcx().map.local_def_id(item.id)));\n \n                         let ty = glue::get_drop_glue_type(self.ccx, ty);\n                         self.output.push(TransItem::DropGlue(ty));\n@@ -1059,8 +1040,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n             hir::ItemStatic(..) => {\n                 debug!(\"RootCollector: ItemStatic({})\",\n                        def_id_to_string(self.ccx,\n-                                        self.ccx.tcx().map.local_def_id(item.id),\n-                                        None));\n+                                        self.ccx.tcx().map.local_def_id(item.id)));\n                 self.output.push(TransItem::Static(item.id));\n             }\n             hir::ItemFn(_, _, constness, _, ref generics, _) => {\n@@ -1069,12 +1049,10 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                     let def_id = self.ccx.tcx().map.local_def_id(item.id);\n \n                     debug!(\"RootCollector: ItemFn({})\",\n-                           def_id_to_string(self.ccx, def_id, None));\n+                           def_id_to_string(self.ccx, def_id));\n \n-                    self.output.push(TransItem::Fn {\n-                        def_id: def_id,\n-                        substs: self.trans_empty_substs\n-                    });\n+                    let instance = Instance::mono(self.ccx.tcx(), def_id);\n+                    self.output.push(TransItem::Fn(instance));\n                 }\n             }\n         }\n@@ -1108,12 +1086,10 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                     let def_id = self.ccx.tcx().map.local_def_id(ii.id);\n \n                     debug!(\"RootCollector: MethodImplItem({})\",\n-                           def_id_to_string(self.ccx, def_id, None));\n+                           def_id_to_string(self.ccx, def_id));\n \n-                    self.output.push(TransItem::Fn {\n-                        def_id: def_id,\n-                        substs: self.trans_empty_substs\n-                    });\n+                    let instance = Instance::mono(self.ccx.tcx(), def_id);\n+                    self.output.push(TransItem::Fn(instance));\n                 }\n             }\n             _ => { /* Nothing to do here */ }\n@@ -1142,7 +1118,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let impl_def_id = tcx.map.local_def_id(item.id);\n \n             debug!(\"create_trans_items_for_default_impls(item={})\",\n-                   def_id_to_string(ccx, impl_def_id, None));\n+                   def_id_to_string(ccx, impl_def_id));\n \n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 let default_impls = tcx.provided_trait_methods(trait_ref.def_id);\n@@ -1225,7 +1201,7 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyStruct(adt_def, substs) |\n         ty::TyEnum(adt_def, substs) => {\n             push_item_name(cx, adt_def.did, output);\n-            push_type_params(cx, substs, &[], output);\n+            push_type_params(cx, &substs.types, &[], output);\n         },\n         ty::TyTuple(ref component_types) => {\n             output.push('(');\n@@ -1275,7 +1251,7 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyTrait(ref trait_data) => {\n             push_item_name(cx, trait_data.principal.skip_binder().def_id, output);\n             push_type_params(cx,\n-                             &trait_data.principal.skip_binder().substs,\n+                             &trait_data.principal.skip_binder().substs.types,\n                              &trait_data.bounds.projection_bounds,\n                              output);\n         },\n@@ -1329,7 +1305,7 @@ pub fn push_unique_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             output.push_str(\"{\");\n             output.push_str(&format!(\"{}:{}\", def_id.krate, def_id.index.as_usize()));\n             output.push_str(\"}\");\n-            push_type_params(cx, closure_substs.func_substs, &[], output);\n+            push_type_params(cx, &closure_substs.func_substs.types, &[], output);\n         }\n         ty::TyError |\n         ty::TyInfer(_) |\n@@ -1371,16 +1347,16 @@ fn push_item_name(ccx: &CrateContext,\n }\n \n fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                              substs: &Substs<'tcx>,\n+                              types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n                               projections: &[ty::PolyProjectionPredicate<'tcx>],\n                               output: &mut String) {\n-    if substs.types.is_empty() && projections.is_empty() {\n+    if types.is_empty() && projections.is_empty() {\n         return;\n     }\n \n     output.push('<');\n \n-    for &type_parameter in &substs.types {\n+    for &type_parameter in types {\n         push_unique_type_name(cx, type_parameter, output);\n         output.push_str(\", \");\n     }\n@@ -1400,23 +1376,16 @@ fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     output.push('>');\n }\n \n-fn push_def_id_as_string<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                              def_id: DefId,\n-                              substs: Option<&Substs<'tcx>>,\n-                              output: &mut String) {\n-    push_item_name(ccx, def_id, output);\n-\n-    if let Some(substs) = substs {\n-        push_type_params(ccx, substs, &[], output);\n-    }\n+fn push_instance_as_string<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                     instance: Instance<'tcx>,\n+                                     output: &mut String) {\n+    push_item_name(ccx, instance.def, output);\n+    push_type_params(ccx, instance.params, &[], output);\n }\n \n-fn def_id_to_string<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                              def_id: DefId,\n-                              substs: Option<&Substs<'tcx>>)\n-                              -> String {\n+fn def_id_to_string(ccx: &CrateContext, def_id: DefId) -> String {\n     let mut output = String::new();\n-    push_def_id_as_string(ccx, def_id, substs, &mut output);\n+    push_item_name(ccx, def_id, &mut output);\n     output\n }\n \n@@ -1440,23 +1409,23 @@ impl<'tcx> TransItem<'tcx> {\n                 push_unique_type_name(ccx, t, &mut s);\n                 s\n             }\n-            TransItem::Fn { def_id, ref substs } => {\n-                to_string_internal(ccx, \"fn \", def_id, Some(substs))\n+            TransItem::Fn(instance) => {\n+                to_string_internal(ccx, \"fn \", instance)\n             },\n             TransItem::Static(node_id) => {\n                 let def_id = hir_map.local_def_id(node_id);\n-                to_string_internal(ccx, \"static \", def_id, None)\n+                let instance = Instance::mono(ccx.tcx(), def_id);\n+                to_string_internal(ccx, \"static \", instance)\n             },\n         };\n \n         fn to_string_internal<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                         prefix: &str,\n-                                        def_id: DefId,\n-                                        substs: Option<&Substs<'tcx>>)\n+                                        instance: Instance<'tcx>)\n                                         -> String {\n             let mut result = String::with_capacity(32);\n             result.push_str(prefix);\n-            push_def_id_as_string(ccx, def_id, substs, &mut result);\n+            push_instance_as_string(ccx, instance, &mut result);\n             result\n         }\n     }\n@@ -1466,10 +1435,10 @@ impl<'tcx> TransItem<'tcx> {\n             TransItem::DropGlue(t) => {\n                 format!(\"DropGlue({})\", t as *const _ as usize)\n             }\n-            TransItem::Fn { def_id, substs } => {\n+            TransItem::Fn(instance) => {\n                 format!(\"Fn({:?}, {})\",\n-                         def_id,\n-                         substs as *const _ as usize)\n+                         instance.def,\n+                         instance.params as *const _ as usize)\n             }\n             TransItem::Static(id) => {\n                 format!(\"Static({:?})\", id)"}, {"sha": "f2b68c477f69b8f834f20696ccf04f22c4b5fcbe", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=b05556e06da7c79f9db746728c2557114a94b3b1", "patch": "@@ -29,8 +29,8 @@ use trans::common::{C_struct, C_undef, const_to_opt_int, const_to_opt_uint, Vari\n use trans::common::{type_is_fat_ptr, Field, C_vector, C_array, C_null};\n use trans::datum::{Datum, Lvalue};\n use trans::declare;\n-use trans::monomorphize;\n use trans::foreign;\n+use trans::monomorphize::{self, Instance};\n use trans::type_::Type;\n use trans::type_of;\n use trans::value::Value;\n@@ -1024,6 +1024,11 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                             -> Datum<'tcx, Lvalue> {\n     let ty = ccx.tcx().lookup_item_type(def_id).ty;\n \n+    let instance = Instance::mono(ccx.tcx(), def_id);\n+    if let Some(&g) = ccx.instances().borrow().get(&instance) {\n+        return Datum::new(g, ty, Lvalue::new(\"static\"));\n+    }\n+\n     let g = if let Some(id) = ccx.tcx().map.as_local_node_id(def_id) {\n         match ccx.tcx().map.get(id) {\n             hir_map::NodeItem(&hir::Item {\n@@ -1076,6 +1081,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n         g\n     };\n \n+    ccx.instances().borrow_mut().insert(instance, g);\n     Datum::new(g, ty, Lvalue::new(\"static\"))\n }\n "}, {"sha": "b558dd70ab8f8d95214c502c5c82606ee46c4bb1", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=b05556e06da7c79f9db746728c2557114a94b3b1", "patch": "@@ -23,7 +23,7 @@ use trans::common::{ExternMap,BuilderRef_res};\n use trans::debuginfo;\n use trans::declare;\n use trans::glue::DropGlueKind;\n-use trans::monomorphize::MonoId;\n+use trans::monomorphize::Instance;\n use trans::collector::{TransItem, TransItemState};\n use trans::type_::{Type, TypeNames};\n use middle::subst::Substs;\n@@ -100,8 +100,8 @@ pub struct LocalCrateContext<'tcx> {\n     /// Backwards version of the `external` map (inlined items to where they\n     /// came from)\n     external_srcs: RefCell<NodeMap<DefId>>,\n-    /// Cache instances of monomorphized functions\n-    monomorphized: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n+    /// Cache instances of monomorphic and polymorphic items\n+    instances: RefCell<FnvHashMap<Instance<'tcx>, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<usize>>,\n     available_monomorphizations: RefCell<FnvHashSet<String>>,\n     /// Cache generated vtables\n@@ -148,7 +148,7 @@ pub struct LocalCrateContext<'tcx> {\n     builder: BuilderRef_res,\n \n     /// Holds the LLVM values for closure IDs.\n-    closure_vals: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n+    closure_vals: RefCell<FnvHashMap<Instance<'tcx>, ValueRef>>,\n \n     dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n@@ -471,7 +471,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 drop_glues: RefCell::new(FnvHashMap()),\n                 external: RefCell::new(DefIdMap()),\n                 external_srcs: RefCell::new(NodeMap()),\n-                monomorphized: RefCell::new(FnvHashMap()),\n+                instances: RefCell::new(FnvHashMap()),\n                 monomorphizing: RefCell::new(DefIdMap()),\n                 available_monomorphizations: RefCell::new(FnvHashSet()),\n                 vtables: RefCell::new(FnvHashMap()),\n@@ -660,8 +660,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.external_srcs\n     }\n \n-    pub fn monomorphized<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>> {\n-        &self.local.monomorphized\n+    pub fn instances<'a>(&'a self) -> &'a RefCell<FnvHashMap<Instance<'tcx>, ValueRef>> {\n+        &self.local.instances\n     }\n \n     pub fn monomorphizing<'a>(&'a self) -> &'a RefCell<DefIdMap<usize>> {\n@@ -746,7 +746,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.opaque_vec_type\n     }\n \n-    pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>> {\n+    pub fn closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<Instance<'tcx>, ValueRef>> {\n         &self.local.closure_vals\n     }\n "}, {"sha": "b3be7c858b5ca66e53b6d27295de9c67710c6606", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=b05556e06da7c79f9db746728c2557114a94b3b1", "patch": "@@ -26,13 +26,16 @@ use trans::foreign;\n use middle::ty::{self, Ty, TyCtxt};\n use trans::Disr;\n use rustc::front::map as hir_map;\n+use rustc::util::ppaux;\n \n use rustc_front::hir;\n \n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n use syntax::errors;\n+\n+use std::fmt;\n use std::hash::{Hasher, Hash, SipHasher};\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -48,7 +51,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let _icx = push_ctxt(\"monomorphic_fn\");\n \n-    let hash_id = MonoId {\n+    let instance = Instance {\n         def: fn_id,\n         params: &psubsts.types\n     };\n@@ -59,32 +62,25 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let mono_ty = apply_param_substs(ccx.tcx(), psubsts, &item_ty);\n     debug!(\"mono_ty = {:?} (post-substitution)\", mono_ty);\n \n-    match ccx.monomorphized().borrow().get(&hash_id) {\n+    match ccx.instances().borrow().get(&instance) {\n         Some(&val) => {\n-            debug!(\"leaving monomorphic fn {}\",\n-            ccx.tcx().item_path_str(fn_id));\n-            return (val, mono_ty, false);\n+            debug!(\"leaving monomorphic fn {:?}\", instance);\n+            return (val, mono_ty);\n         }\n         None => ()\n     }\n \n-    debug!(\"monomorphic_fn(\\\n-            fn_id={:?}, \\\n-            psubsts={:?}, \\\n-            hash_id={:?})\",\n-           fn_id,\n-           psubsts,\n-           hash_id);\n+    debug!(\"monomorphic_fn({:?})\", instance);\n \n \n     let map_node = errors::expect(\n         ccx.sess().diagnostic(),\n         ccx.tcx().map.find(fn_node_id),\n         || {\n-            format!(\"while monomorphizing {:?}, couldn't find it in \\\n+            format!(\"while instantiating `{}`, couldn't find it in \\\n                      the item map (may have attempted to monomorphize \\\n                      an item defined in a different crate?)\",\n-                    fn_id)\n+                    instance)\n         });\n \n     if let hir_map::NodeForeignItem(_) = map_node {\n@@ -110,8 +106,13 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // recursively more than thirty times can probably safely be assumed\n         // to be causing an infinite expansion.\n         if depth > ccx.sess().recursion_limit.get() {\n-            ccx.sess().span_fatal(ccx.tcx().map.span(fn_node_id),\n-                \"reached the recursion limit during monomorphization\");\n+            let error = format!(\"reached the recursion limit while instantiating `{}`\",\n+                                instance);\n+            if let Some(id) = ccx.tcx().map.as_local_node_id(fn_id) {\n+                ccx.sess().span_fatal(ccx.tcx().map.span(id), &error);\n+            } else {\n+                ccx.sess().fatal(&error);\n+            }\n         }\n \n         monomorphizing.insert(fn_id, depth + 1);\n@@ -120,15 +121,16 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let hash;\n     let s = {\n         let mut state = SipHasher::new();\n-        hash_id.hash(&mut state);\n+        instance.hash(&mut state);\n         mono_ty.hash(&mut state);\n \n         hash = format!(\"h{}\", state.finish());\n-        let path = ccx.tcx().map.def_path_from_id(fn_node_id);\n+        let path = ccx.tcx().map.def_path(fn_id);\n         exported_name(path, &hash[..])\n     };\n \n     debug!(\"monomorphize_fn mangled to {}\", s);\n+    assert!(declare::get_defined_value(ccx, &s).is_none());\n \n     // This shouldn't need to option dance.\n     let mut hash_id = Some(hash_id);\n@@ -281,12 +283,32 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     (lldecl, mono_ty, true)\n }\n \n-#[derive(PartialEq, Eq, Hash, Debug)]\n-pub struct MonoId<'tcx> {\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct Instance<'tcx> {\n     pub def: DefId,\n     pub params: &'tcx subst::VecPerParamSpace<Ty<'tcx>>\n }\n \n+impl<'tcx> fmt::Display for Instance<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let substs = Substs {\n+            types: self.params.clone(),\n+            regions: subst::ErasedRegions\n+        };\n+        ppaux::parameterized(f, &substs, self.def, ppaux::Ns::Value, &[],\n+                             |tcx| tcx.lookup_item_type(self.def).generics)\n+    }\n+}\n+\n+impl<'tcx> Instance<'tcx> {\n+    pub fn mono(tcx: &TyCtxt<'tcx>, def_id: DefId) -> Instance<'tcx> {\n+        Instance {\n+            def: def_id,\n+            params: &tcx.mk_substs(Substs::trans_empty()).types\n+        }\n+    }\n+}\n+\n /// Monomorphizes a type from the AST by first applying the in-scope\n /// substitutions and then normalizing any associated types.\n pub fn apply_param_substs<'tcx,T>(tcx: &TyCtxt<'tcx>,"}, {"sha": "949000dfed6ace36d779db53888756fabd7f0de6", "filename": "src/test/compile-fail/fn-item-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-item-type.rs?ref=b05556e06da7c79f9db746728c2557114a94b3b1", "patch": "@@ -42,6 +42,6 @@ fn main() {\n     // Make sure we distinguish between trait methods correctly.\n     eq(<u8 as Foo>::foo, <u16 as Foo>::foo);\n     //~^ ERROR mismatched types\n-    //~|  expected `fn() {Foo::foo}`\n-    //~|  found `fn() {Foo::foo}`\n+    //~|  expected `fn() {<u8 as Foo>::foo}`\n+    //~|  found `fn() {<u16 as Foo>::foo}`\n }"}, {"sha": "d293a1816d89e01c0d2f471df0d041ad87f6cbab", "filename": "src/test/compile-fail/infinite-instantiation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-instantiation.rs?ref=b05556e06da7c79f9db746728c2557114a94b3b1", "patch": "@@ -31,7 +31,7 @@ impl<T:Clone> ToOpt for Option<T> {\n }\n \n fn function<T:ToOpt + Clone>(counter: usize, t: T) {\n-//~^ ERROR reached the recursion limit during monomorphization\n+//~^ ERROR reached the recursion limit while instantiating `function::<core::option::Option<\n     if counter > 0 {\n         function(counter - 1, t.to_option());\n         // FIXME(#4287) Error message should be here. It should be"}, {"sha": "0c8c2311dcaa583eb662b00dda4ce4bdadea8f8a", "filename": "src/test/compile-fail/issue-22638.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Ftest%2Fcompile-fail%2Fissue-22638.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Ftest%2Fcompile-fail%2Fissue-22638.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22638.rs?ref=b05556e06da7c79f9db746728c2557114a94b3b1", "patch": "@@ -17,7 +17,7 @@ struct A (B);\n \n impl A {\n     pub fn matches<F: Fn()>(&self, f: &F) {\n-        //~^ ERROR reached the recursion limit during monomorphization\n+        //~^ ERROR reached the recursion limit while instantiating `A::matches::<[closure\n         let &A(ref term) = self;\n         term.matches(f);\n     }"}, {"sha": "525ec855762840a4100d41822a27ccdceaf539a5", "filename": "src/test/compile-fail/issue-8727.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05556e06da7c79f9db746728c2557114a94b3b1/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8727.rs?ref=b05556e06da7c79f9db746728c2557114a94b3b1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:reached the recursion limit during monomorphization\n+// error-pattern:reached the recursion limit while instantiating `generic::<core::option::Option<\n \n // Verify the compiler fails with an error on infinite function\n // recursions."}]}