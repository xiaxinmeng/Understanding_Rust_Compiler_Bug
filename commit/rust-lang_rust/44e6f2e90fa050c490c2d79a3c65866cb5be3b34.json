{"sha": "44e6f2e90fa050c490c2d79a3c65866cb5be3b34", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0ZTZmMmU5MGZhMDUwYzQ5MGMyZDc5YTNjNjU4NjZjYjViZTNiMzQ=", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-08-22T03:58:23Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-09-10T02:17:38Z"}, "message": "Remove unnecessary `Cache.*_did` fields\n\nThey can be obtained by accessing the `TyCtxt` where they are needed.", "tree": {"sha": "c6aefdfbc14d4b97335e3245b61b84b90688076a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6aefdfbc14d4b97335e3245b61b84b90688076a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44e6f2e90fa050c490c2d79a3c65866cb5be3b34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44e6f2e90fa050c490c2d79a3c65866cb5be3b34", "html_url": "https://github.com/rust-lang/rust/commit/44e6f2e90fa050c490c2d79a3c65866cb5be3b34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44e6f2e90fa050c490c2d79a3c65866cb5be3b34/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "497ee321af3b8496eaccd7af7b437f18bab81abf", "url": "https://api.github.com/repos/rust-lang/rust/commits/497ee321af3b8496eaccd7af7b437f18bab81abf", "html_url": "https://github.com/rust-lang/rust/commit/497ee321af3b8496eaccd7af7b437f18bab81abf"}], "stats": {"total": 48, "additions": 19, "deletions": 29}, "files": [{"sha": "873ecd759ebbda8520019bb42ee11a220fde336d", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44e6f2e90fa050c490c2d79a3c65866cb5be3b34/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e6f2e90fa050c490c2d79a3c65866cb5be3b34/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=44e6f2e90fa050c490c2d79a3c65866cb5be3b34", "patch": "@@ -29,10 +29,6 @@ crate fn krate(cx: &mut DocContext<'_>) -> Crate {\n     let krate = cx.tcx.hir().krate();\n     let module = crate::visit_ast::RustdocVisitor::new(cx).visit(krate);\n \n-    cx.cache.deref_trait_did = cx.tcx.lang_items().deref_trait();\n-    cx.cache.deref_mut_trait_did = cx.tcx.lang_items().deref_mut_trait();\n-    cx.cache.owned_box_did = cx.tcx.lang_items().owned_box();\n-\n     let mut externs = Vec::new();\n     for &cnum in cx.tcx.crates(()).iter() {\n         externs.push(ExternalCrate { crate_num: cnum });"}, {"sha": "a88f82dadda12e0dcb261f678312d331c0105f69", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44e6f2e90fa050c490c2d79a3c65866cb5be3b34/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e6f2e90fa050c490c2d79a3c65866cb5be3b34/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=44e6f2e90fa050c490c2d79a3c65866cb5be3b34", "patch": "@@ -98,9 +98,6 @@ crate struct Cache {\n     stripped_mod: bool,\n \n     crate search_index: Vec<IndexItem>,\n-    crate deref_trait_did: Option<DefId>,\n-    crate deref_mut_trait_did: Option<DefId>,\n-    crate owned_box_did: Option<DefId>,\n \n     // In rare case where a structure is defined in one module but implemented\n     // in another, if the implementing module is parsed before defining module,"}, {"sha": "f8f71c6f3daf36e6e289cb9932cb2b1e1de7d870", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/44e6f2e90fa050c490c2d79a3c65866cb5be3b34/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e6f2e90fa050c490c2d79a3c65866cb5be3b34/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=44e6f2e90fa050c490c2d79a3c65866cb5be3b34", "patch": "@@ -1069,13 +1069,13 @@ fn render_assoc_items(\n         return;\n     }\n     if !traits.is_empty() {\n-        let deref_impl = traits\n-            .iter()\n-            .find(|t| t.inner_impl().trait_.def_id_full(cache) == cache.deref_trait_did);\n+        let deref_impl = traits.iter().find(|t| {\n+            t.inner_impl().trait_.def_id_full(cache) == cx.tcx().lang_items().deref_trait()\n+        });\n         if let Some(impl_) = deref_impl {\n-            let has_deref_mut = traits\n-                .iter()\n-                .any(|t| t.inner_impl().trait_.def_id_full(cache) == cache.deref_mut_trait_did);\n+            let has_deref_mut = traits.iter().any(|t| {\n+                t.inner_impl().trait_.def_id_full(cache) == cx.tcx().lang_items().deref_mut_trait()\n+            });\n             render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n         }\n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n@@ -1165,7 +1165,7 @@ fn render_deref_methods(\n     }\n }\n \n-fn should_render_item(item: &clean::Item, deref_mut_: bool, cache: &Cache) -> bool {\n+fn should_render_item(item: &clean::Item, deref_mut_: bool, cx: &Context<'_>) -> bool {\n     let self_type_opt = match *item.kind {\n         clean::MethodItem(ref method, _) => method.decl.self_type(),\n         clean::TyMethodItem(ref method) => method.decl.self_type(),\n@@ -1179,7 +1179,7 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool, cache: &Cache) -> bo\n                 (mutability == Mutability::Mut, false, false)\n             }\n             SelfTy::SelfExplicit(clean::ResolvedPath { did, .. }) => {\n-                (false, Some(did) == cache.owned_box_did, false)\n+                (false, Some(did) == cx.tcx().lang_items().owned_box(), false)\n             }\n             SelfTy::SelfValue => (false, false, true),\n             _ => (false, false, false),\n@@ -1302,7 +1302,7 @@ fn render_impl(\n             && match render_mode {\n                 RenderMode::Normal => true,\n                 RenderMode::ForDeref { mut_: deref_mut_ } => {\n-                    should_render_item(&item, deref_mut_, cx.cache())\n+                    should_render_item(&item, deref_mut_, cx)\n                 }\n             };\n \n@@ -1800,13 +1800,13 @@ fn get_methods(\n     for_deref: bool,\n     used_links: &mut FxHashSet<String>,\n     deref_mut: bool,\n-    cache: &Cache,\n+    cx: &Context<'_>,\n ) -> Vec<String> {\n     i.items\n         .iter()\n         .filter_map(|item| match item.name {\n             Some(ref name) if !name.is_empty() && item.is_method() => {\n-                if !for_deref || should_render_item(item, deref_mut, cache) {\n+                if !for_deref || should_render_item(item, deref_mut, cx) {\n                     Some(format!(\n                         \"<a href=\\\"#{}\\\">{}</a>\",\n                         get_next_url(used_links, format!(\"method.{}\", name)),\n@@ -1868,7 +1868,7 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n             let mut ret = v\n                 .iter()\n                 .filter(|i| i.inner_impl().trait_.is_none())\n-                .flat_map(move |i| get_methods(i.inner_impl(), false, used_links_bor, false, cache))\n+                .flat_map(move |i| get_methods(i.inner_impl(), false, used_links_bor, false, cx))\n                 .collect::<Vec<_>>();\n             if !ret.is_empty() {\n                 // We want links' order to be reproducible so we don't use unstable sort.\n@@ -1886,11 +1886,9 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n         }\n \n         if v.iter().any(|i| i.inner_impl().trait_.is_some()) {\n-            if let Some(impl_) = v\n-                .iter()\n-                .filter(|i| i.inner_impl().trait_.is_some())\n-                .find(|i| i.inner_impl().trait_.def_id_full(cache) == cache.deref_trait_did)\n-            {\n+            if let Some(impl_) = v.iter().filter(|i| i.inner_impl().trait_.is_some()).find(|i| {\n+                i.inner_impl().trait_.def_id_full(cache) == cx.tcx().lang_items().deref_trait()\n+            }) {\n                 sidebar_deref_methods(cx, out, impl_, v);\n             }\n \n@@ -1988,10 +1986,9 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n                 }\n             }\n         }\n-        let deref_mut = v\n-            .iter()\n-            .filter(|i| i.inner_impl().trait_.is_some())\n-            .any(|i| i.inner_impl().trait_.def_id_full(c) == c.deref_mut_trait_did);\n+        let deref_mut = v.iter().filter(|i| i.inner_impl().trait_.is_some()).any(|i| {\n+            i.inner_impl().trait_.def_id_full(c) == cx.tcx().lang_items().deref_mut_trait()\n+        });\n         let inner_impl = target\n             .def_id_full(c)\n             .or_else(|| {\n@@ -2004,7 +2001,7 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n             let mut ret = impls\n                 .iter()\n                 .filter(|i| i.inner_impl().trait_.is_none())\n-                .flat_map(|i| get_methods(i.inner_impl(), true, &mut used_links, deref_mut, c))\n+                .flat_map(|i| get_methods(i.inner_impl(), true, &mut used_links, deref_mut, cx))\n                 .collect::<Vec<_>>();\n             if !ret.is_empty() {\n                 write!("}]}