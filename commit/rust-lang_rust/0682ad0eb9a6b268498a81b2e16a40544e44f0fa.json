{"sha": "0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ODJhZDBlYjlhNmIyNjg0OThhODFiMmUxNmE0MDU0NGU0NGYwZmE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-10T18:59:58Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-31T20:09:00Z"}, "message": "Finalize moves-based-on-type implementation.\n\nChanges:\n\n- Refactor move mode computation\n- Removes move mode arguments, unary move, capture clauses\n  (though they still parse for backwards compatibility)\n- Simplify how moves are handled in trans\n- Fix a number of illegal copies that cropped up\n- Workaround for bug involving def-ids in params\n  (see details below)\n\nFuture work (I'll open bugs for these...):\n\n- Improve error messages for moves that are due\n  to bindings\n- Add support for moving owned content like a.b.c\n  to borrow check, test in trans (but I think it'll\n  \"just work\")\n- Proper fix for def-ids in params\n\nDef ids in params:\n\nMove captures into a map instead of recomputing.\n\nThis is a workaround for a larger bug having to do with the def-ids associated\nwith ty_params, which are not always properly preserved when inlining.  I am\nnot sure of my preferred fix for the larger bug yet.  This current fix removes\nthe only code in trans that I know of which relies on ty_param def-ids, but\nfeels fragile.", "tree": {"sha": "694819bae28cd319401c121afa4daa00adcbdde2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/694819bae28cd319401c121afa4daa00adcbdde2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "html_url": "https://github.com/rust-lang/rust/commit/0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42b462e0765f02fd7bb0f2613240ae2489a47fee", "url": "https://api.github.com/repos/rust-lang/rust/commits/42b462e0765f02fd7bb0f2613240ae2489a47fee", "html_url": "https://github.com/rust-lang/rust/commit/42b462e0765f02fd7bb0f2613240ae2489a47fee"}], "stats": {"total": 5329, "additions": 2685, "deletions": 2644}, "files": [{"sha": "7a5b8dfd004bbf3c4e1e18431695942dd8d6cc3f", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -1234,7 +1234,7 @@ For example:\n \n ~~~~\n trait Num {\n-    static pure fn from_int(n: int) -> self;\n+    static pure fn from_int(n: int) -> Self;\n }\n impl float: Num {\n     static pure fn from_int(n: int) -> float { n as float }"}, {"sha": "98ed6b8658484cc5bf20d7f7e7f65fd93e39dd7f", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -440,8 +440,8 @@ Finally, tasks can be configured to not propagate failure to each\n other at all, using `task::spawn_unlinked` for _isolated failure_.\n \n ~~~\n-# fn random() -> int { 100 }\n-# fn sleep_for(i: int) { for i.times { task::yield() } }\n+# fn random() -> uint { 100 }\n+# fn sleep_for(i: uint) { for i.times { task::yield() } }\n # do task::try::<()> {\n let (time1, time2) = (random(), random());\n do task::spawn_unlinked {"}, {"sha": "997a9dd50fd18319534699c12c2c84a799b12ecf", "filename": "src/etc/tidy.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Fetc%2Ftidy.py", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Fetc%2Ftidy.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftidy.py?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -51,7 +51,7 @@ def do_license_check(name, contents):\n                 report_err(\"TODO is deprecated; use FIXME\")\n             idx = line.find(\"// NOTE\")\n             if idx != -1:\n-                report_warn(\"NOTE:\" + line[idx + len(\"// NOTE\"):])\n+                report_warn(\"NOTE\" + line[idx + len(\"// NOTE\"):])\n         if (line.find('\\t') != -1 and\n             fileinput.filename().find(\"Makefile\") == -1):\n             report_err(\"tab character\")"}, {"sha": "bb5e3f9f74d7eeb6b17092c0be857d90506c3dc5", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -1965,19 +1965,17 @@ pub fn main() {\n         c = configure(o);\n     }\n \n-    let c = &move c;\n-\n     match o.free[1] {\n-        ~\"init\" => cmd_init(c),\n-        ~\"install\" => cmd_install(c),\n-        ~\"uninstall\" => cmd_uninstall(c),\n-        ~\"list\" => cmd_list(c),\n-        ~\"search\" => cmd_search(c),\n-        ~\"sources\" => cmd_sources(c),\n+        ~\"init\" => cmd_init(&c),\n+        ~\"install\" => cmd_install(&c),\n+        ~\"uninstall\" => cmd_uninstall(&c),\n+        ~\"list\" => cmd_list(&c),\n+        ~\"search\" => cmd_search(&c),\n+        ~\"sources\" => cmd_sources(&c),\n         _ => cmd_usage()\n     }\n \n-    dump_cache(c);\n-    dump_sources(c);\n+    dump_cache(&c);\n+    dump_sources(&c);\n }\n "}, {"sha": "f129022957cd12921957c3adc2d21178e340d13d", "filename": "src/libcore/private/global.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibcore%2Fprivate%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibcore%2Fprivate%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fglobal.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -177,8 +177,10 @@ fn get_global_state() -> Exclusive<GlobalState> {\n         let state = ~exclusive(state);\n \n         // Convert it to an integer\n-        let state_ptr: &Exclusive<GlobalState> = state;\n-        let state_i: int = unsafe { transmute(state_ptr) };\n+        let state_i: int = unsafe {\n+            let state_ptr: &Exclusive<GlobalState> = state;\n+            transmute(state_ptr)\n+        };\n \n         // Swap our structure into the global pointer\n         let prev_i = unsafe { atomic_cxchg(&mut *global_ptr, 0, state_i) };"}, {"sha": "62d317abb95729c83be97d164336a00564b216ff", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -836,12 +836,20 @@ fn test_run_basic() {\n     po.recv();\n }\n \n+#[test]\n+struct Wrapper {\n+    mut f: Option<Chan<()>>\n+}\n+\n #[test]\n fn test_add_wrapper() {\n     let (po, ch) = stream::<()>();\n     let b0 = task();\n+    let ch = Wrapper { f: Some(ch) };\n     let b1 = do b0.add_wrapper |body| {\n+        let ch = Wrapper { f: Some(ch.f.swap_unwrap()) };\n         fn~(move body) {\n+            let ch = ch.f.swap_unwrap();\n             body();\n             ch.send(());\n         }\n@@ -929,9 +937,12 @@ fn test_spawn_sched_childs_on_default_sched() {\n     // Assuming tests run on the default scheduler\n     let default_id = unsafe { rt::rust_get_sched_id() };\n \n+    let ch = Wrapper { f: Some(ch) };\n     do spawn_sched(SingleThreaded) {\n         let parent_sched_id = unsafe { rt::rust_get_sched_id() };\n+        let ch = Wrapper { f: Some(ch.f.swap_unwrap()) };\n         do spawn {\n+            let ch = ch.f.swap_unwrap();\n             let child_sched_id = unsafe { rt::rust_get_sched_id() };\n             assert parent_sched_id != child_sched_id;\n             assert child_sched_id == default_id;"}, {"sha": "560b26951a64fc394407ce941f9f9105e9b51957", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -191,7 +191,7 @@ pub fn minimize_rpaths(rpaths: &[Path]) -> ~[Path] {\n     let mut minimized = ~[];\n     for rpaths.each |rpath| {\n         let s = rpath.to_str();\n-        if !set.contains_key(s) {\n+        if !set.contains_key_ref(&s) {\n             minimized.push(/*bad*/copy *rpath);\n             set.insert(s, ());\n         }"}, {"sha": "eca6a598f8d2f1213d585ae65b6a1d2a530d5952", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -16,7 +16,7 @@ use front;\n use lib::llvm::llvm;\n use metadata::{creader, cstore, filesearch};\n use metadata;\n-use middle::{trans, freevars, kind, ty, typeck, lint};\n+use middle::{trans, freevars, kind, ty, typeck, lint, astencode};\n use middle;\n use session::{Session, Session_, OptLevel, No, Less, Default, Aggressive};\n use session;\n@@ -281,20 +281,26 @@ pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n         time(time_passes, ~\"loop checking\", ||\n              middle::check_loop::check_crate(ty_cx, crate));\n \n-        time(time_passes, ~\"mode computation\", ||\n-             middle::mode::compute_modes(ty_cx, method_map, crate));\n+        let middle::moves::MoveMaps {moves_map, variable_moves_map,\n+                                     capture_map} =\n+            time(time_passes, ~\"compute moves\", ||\n+                 middle::moves::compute_moves(ty_cx, method_map, crate));\n \n         time(time_passes, ~\"match checking\", ||\n-             middle::check_match::check_crate(ty_cx, method_map, crate));\n+             middle::check_match::check_crate(ty_cx, method_map,\n+                                              moves_map, crate));\n \n         let last_use_map =\n             time(time_passes, ~\"liveness checking\", ||\n-                 middle::liveness::check_crate(ty_cx, method_map, crate));\n+                 middle::liveness::check_crate(ty_cx, method_map,\n+                                               variable_moves_map,\n+                                               capture_map, crate));\n \n         let (root_map, mutbl_map, write_guard_map) =\n             time(time_passes, ~\"borrow checking\", ||\n                  middle::borrowck::check_crate(ty_cx, method_map,\n-                                               last_use_map, crate));\n+                                               moves_map, capture_map,\n+                                               crate));\n \n         time(time_passes, ~\"kind checking\", ||\n              kind::check_crate(ty_cx, method_map, last_use_map, crate));\n@@ -304,12 +310,16 @@ pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n \n         if upto == cu_no_trans { return {crate: crate, tcx: Some(ty_cx)}; }\n \n-        let maps = {mutbl_map: mutbl_map,\n-                    root_map: root_map,\n-                    last_use_map: last_use_map,\n-                    method_map: method_map,\n-                    vtable_map: vtable_map,\n-                    write_guard_map: write_guard_map};\n+        let maps = astencode::Maps {\n+            mutbl_map: mutbl_map,\n+            root_map: root_map,\n+            last_use_map: last_use_map,\n+            method_map: method_map,\n+            vtable_map: vtable_map,\n+            write_guard_map: write_guard_map,\n+            moves_map: moves_map,\n+            capture_map: capture_map\n+        };\n \n         time(time_passes, ~\"translation\", ||\n              trans::base::trans_crate(sess, crate, ty_cx,\n@@ -528,7 +538,7 @@ pub fn build_session_options(+binary: ~str,\n                                 getopts::opt_strs(matches, level_name));\n         for flags.each |lint_name| {\n             let lint_name = str::replace(*lint_name, ~\"-\", ~\"_\");\n-            match lint_dict.find(lint_name) {\n+            match lint_dict.find(/*bad*/ copy lint_name) {\n               None => {\n                 early_error(demitter, fmt!(\"unknown %s flag: %s\",\n                                            level_name, lint_name));"}, {"sha": "a7c071919ffdb8e63d998723438380f2ea17e675", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -190,7 +190,7 @@ pub fn metas_in_cfg(cfg: ast::crate_cfg,\n     if !has_cfg_metas { return true; }\n \n     for cfg_metas.each |cfg_mi| {\n-        if attr::contains(/*bad*/copy cfg, *cfg_mi) { return true; }\n+        if attr::contains(cfg, *cfg_mi) { return true; }\n     }\n \n     return false;"}, {"sha": "53c2f71c548b9ecea17dbe55f38e6fab0adf1c77", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -46,7 +46,7 @@ pub fn modify_for_testing(sess: session::Session,\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n-    let should_test = attr::contains(/*bad*/copy crate.node.config,\n+    let should_test = attr::contains(crate.node.config,\n                                      attr::mk_word_item(~\"test\"));\n \n     if should_test {\n@@ -510,7 +510,7 @@ fn mk_test_wrapper(cx: test_ctxt,\n     let wrapper_expr = ast::expr  {\n         id: cx.sess.next_node_id(),\n         callee_id: cx.sess.next_node_id(),\n-        node: ast::expr_fn(ast::ProtoBare, wrapper_decl, wrapper_body, @~[]),\n+        node: ast::expr_fn(ast::ProtoBare, wrapper_decl, wrapper_body),\n         span: span\n     };\n "}, {"sha": "375a3b43aada8a27b672a9dd66185d1928e72f5a", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -1344,23 +1344,22 @@ pub fn mk_type_names() -> type_names {\n }\n \n pub fn type_to_str(names: type_names, ty: TypeRef) -> @str {\n-    return type_to_str_inner(names, ~[], ty);\n+    return type_to_str_inner(names, [], ty);\n }\n \n-pub fn type_to_str_inner(names: type_names, +outer0: ~[TypeRef], ty: TypeRef)\n+pub fn type_to_str_inner(names: type_names, +outer0: &[TypeRef], ty: TypeRef)\n                       -> @str {\n     unsafe {\n         match type_has_name(names, ty) {\n           option::Some(n) => return n,\n           _ => {}\n         }\n \n-        // FIXME #2543: Bad copy.\n-        let outer = vec::append_one(copy outer0, ty);\n+        let outer = vec::append_one(outer0.to_vec(), ty);\n \n         let kind = llvm::LLVMGetTypeKind(ty);\n \n-        fn tys_str(names: type_names, outer: ~[TypeRef],\n+        fn tys_str(names: type_names, outer: &[TypeRef],\n                    tys: ~[TypeRef]) -> @str {\n             let mut s = ~\"\";\n             let mut first: bool = true;"}, {"sha": "37c19e80600b7f9ddaf4d6debb68afc17cfb6bc1", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -133,7 +133,8 @@ pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_table_vtable_map = 0x61,\n     tag_table_adjustments = 0x62,\n     tag_table_legacy_boxed_trait = 0x63,\n-    tag_table_value_mode = 0x64\n+    tag_table_moves_map = 0x64,\n+    tag_table_capture_map = 0x65\n }\n \n pub const tag_item_trait_method_sort: uint = 0x70;"}, {"sha": "e91c4f938640cb50996a5beeab94327bcaf1dd7f", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -163,8 +163,8 @@ fn visit_item(e: env, i: @ast::item) {\n                 None => /*bad*/copy *e.intr.get(i.ident)\n             };\n             if attr::find_attrs_by_name(i.attrs, ~\"nolink\").is_empty() {\n-                already_added = !cstore::add_used_library(cstore,\n-                                                          foreign_name);\n+                already_added =\n+                    !cstore::add_used_library(cstore, copy foreign_name);\n             }\n             if !link_args.is_empty() && already_added {\n                 e.diag.span_fatal(i.span, ~\"library '\" + foreign_name +\n@@ -281,7 +281,8 @@ fn resolve_crate_deps(e: env, cdata: @~[u8]) -> cstore::cnum_map {\n         let cmetas = metas_with(/*bad*/copy dep.vers, ~\"vers\", ~[]);\n         debug!(\"resolving dep crate %s ver: %s hash: %s\",\n                *e.intr.get(dep.name), dep.vers, dep.hash);\n-        match existing_match(e, metas_with_ident(*e.intr.get(cname), cmetas),\n+        match existing_match(e, metas_with_ident(copy *e.intr.get(cname),\n+                                                 copy cmetas),\n                              dep.hash) {\n           Some(local_cnum) => {\n             debug!(\"already have it\");"}, {"sha": "49d7bfeb2f9986b80011457b9d9ec3ec807174d9", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -648,14 +648,22 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         /* Encode the dtor */\n         do struct_def.dtor.iter |dtor| {\n             index.push({val: dtor.node.id, pos: ebml_w.writer.tell()});\n-          encode_info_for_ctor(ecx, ebml_w, dtor.node.id,\n+          encode_info_for_ctor(ecx,\n+                               ebml_w,\n+                               dtor.node.id,\n                                ecx.tcx.sess.ident_of(\n                                    ecx.tcx.sess.str_of(item.ident) +\n                                    ~\"_dtor\"),\n-                               path, if tps.len() > 0u {\n-                                   Some(ii_dtor(*dtor, item.ident, tps,\n+                               path,\n+                               if tps.len() > 0u {\n+                                   Some(ii_dtor(copy *dtor,\n+                                                item.ident,\n+                                                copy tps,\n                                                 local_def(item.id))) }\n-                               else { None }, tps);\n+                               else {\n+                                   None\n+                               },\n+                               tps);\n         }\n \n         /* Index the class*/\n@@ -869,27 +877,35 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                         syntax::parse::token::special_idents::invalid);\n     visit::visit_crate(*crate, (), visit::mk_vt(@visit::Visitor {\n         visit_expr: |_e, _cx, _v| { },\n-        visit_item: |i, cx, v, copy ebml_w| {\n-            visit::visit_item(i, cx, v);\n-            match ecx.tcx.items.get(i.id) {\n-              ast_map::node_item(_, pt) => {\n-                encode_info_for_item(ecx, ebml_w, i, index, *pt);\n-              }\n-              _ => fail ~\"bad item\"\n+        visit_item: {\n+            let ebml_w = copy ebml_w;\n+            |i, cx, v| {\n+                visit::visit_item(i, cx, v);\n+                match ecx.tcx.items.get(i.id) {\n+                    ast_map::node_item(_, pt) => {\n+                        encode_info_for_item(ecx, ebml_w, i,\n+                                             index, *pt);\n+                    }\n+                    _ => fail ~\"bad item\"\n+                }\n             }\n         },\n-        visit_foreign_item: |ni, cx, v, copy ebml_w| {\n-            visit::visit_foreign_item(ni, cx, v);\n-            match ecx.tcx.items.get(ni.id) {\n-              ast_map::node_foreign_item(_, abi, pt) => {\n-                encode_info_for_foreign_item(ecx, ebml_w, ni,\n-                                             index, /*bad*/copy *pt, abi);\n-              }\n-              // case for separate item and foreign-item tables\n-              _ => fail ~\"bad foreign item\"\n+        visit_foreign_item: {\n+            let ebml_w = copy ebml_w;\n+            |ni, cx, v| {\n+                visit::visit_foreign_item(ni, cx, v);\n+                match ecx.tcx.items.get(ni.id) {\n+                    ast_map::node_foreign_item(_, abi, pt) => {\n+                        encode_info_for_foreign_item(ecx, ebml_w, ni,\n+                                                     index, /*bad*/copy *pt,\n+                                                     abi);\n+                    }\n+                    // case for separate item and foreign-item tables\n+                    _ => fail ~\"bad foreign item\"\n+                }\n             }\n-        }\n-        ,.. *visit::default_visitor()\n+        },\n+        ..*visit::default_visitor()\n     }));\n     ebml_w.end_tag();\n     return /*bad*/copy *index;"}, {"sha": "d523b198b31015864427f98776be1bcb07eb9bdc", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -165,7 +165,8 @@ pub fn note_linkage_attrs(intr: @ident_interner, diag: span_handler,\n     }\n }\n \n-fn crate_matches(crate_data: @~[u8], +metas: ~[@ast::meta_item],\n+fn crate_matches(crate_data: @~[u8],\n+                 metas: &[@ast::meta_item],\n                  hash: ~str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     let linkage_metas = attr::find_linkage_metas(attrs);\n@@ -177,7 +178,7 @@ fn crate_matches(crate_data: @~[u8], +metas: ~[@ast::meta_item],\n }\n \n pub fn metadata_matches(extern_metas: ~[@ast::meta_item],\n-                        local_metas: ~[@ast::meta_item]) -> bool {\n+                        local_metas: &[@ast::meta_item]) -> bool {\n \n     debug!(\"matching %u metadata requirements against %u items\",\n            vec::len(local_metas), vec::len(extern_metas));"}, {"sha": "4c2937b952ef58d7df708beafe4dcc917f51169a", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -275,6 +275,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       }\n       'p' => {\n         let did = parse_def(st, TypeParameter, conv);\n+        debug!(\"parsed ty_param: did=%?\", did);\n         return ty::mk_param(st.tcx, parse_int(st) as uint, did);\n       }\n       's' => {\n@@ -422,7 +423,6 @@ fn parse_arg(st: @pstate, conv: conv_did) -> ty::arg {\n \n fn parse_mode(st: @pstate) -> ast::mode {\n     let m = ast::expl(match next(st) {\n-        '-' => ast::by_move,\n         '+' => ast::by_copy,\n         '=' => ast::by_ref,\n         '#' => ast::by_val,"}, {"sha": "97f8c8f12a1e44aadd338c461cfa82ea3eca9425", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -342,7 +342,6 @@ pub fn enc_arg(w: io::Writer, cx: @ctxt, arg: ty::arg) {\n \n pub fn enc_mode(w: io::Writer, cx: @ctxt, m: mode) {\n     match ty::resolved_mode(cx.tcx, m) {\n-      by_move => w.write_char('-'),\n       by_copy => w.write_char('+'),\n       by_ref => w.write_char('='),\n       by_val => w.write_char('#')"}, {"sha": "95a9f602a6dd4b19982cfc187a446b81fda72b71", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 77, "deletions": 19, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -22,7 +22,7 @@ use metadata::tyencode;\n use middle::freevars::freevar_entry;\n use middle::typeck::{method_origin, method_map_entry, vtable_res};\n use middle::typeck::{vtable_origin};\n-use middle::{ty, typeck};\n+use middle::{ty, typeck, moves};\n use middle;\n use util::ppaux::ty_to_str;\n \n@@ -51,19 +51,21 @@ use syntax;\n use writer = std::ebml::writer;\n \n // Auxiliary maps of things to be encoded\n-pub type maps = {\n+pub struct Maps {\n     mutbl_map: middle::borrowck::mutbl_map,\n     root_map: middle::borrowck::root_map,\n     last_use_map: middle::liveness::last_use_map,\n     method_map: middle::typeck::method_map,\n     vtable_map: middle::typeck::vtable_map,\n     write_guard_map: middle::borrowck::write_guard_map,\n-};\n+    moves_map: middle::moves::MovesMap,\n+    capture_map: middle::moves::CaptureMap,\n+}\n \n type decode_ctxt = @{\n     cdata: cstore::crate_metadata,\n     tcx: ty::ctxt,\n-    maps: maps\n+    maps: Maps\n };\n \n type extended_decode_ctxt_ = {\n@@ -91,7 +93,7 @@ pub fn encode_inlined_item(ecx: @e::encode_ctxt,\n                            ebml_w: writer::Encoder,\n                            path: &[ast_map::path_elt],\n                            ii: ast::inlined_item,\n-                           maps: maps) {\n+                           maps: Maps) {\n     debug!(\"> Encoding inlined item: %s::%s (%u)\",\n            ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n            ecx.tcx.sess.str_of(ii.ident()),\n@@ -112,7 +114,7 @@ pub fn encode_inlined_item(ecx: @e::encode_ctxt,\n \n pub fn decode_inlined_item(cdata: cstore::crate_metadata,\n                            tcx: ty::ctxt,\n-                           maps: maps,\n+                           maps: Maps,\n                            +path: ast_map::path,\n                            par_doc: ebml::Doc)\n                         -> Option<ast::inlined_item> {\n@@ -513,6 +515,30 @@ impl freevar_entry: tr {\n     }\n }\n \n+// ______________________________________________________________________\n+// Encoding and decoding of CaptureVar information\n+\n+trait capture_var_helper {\n+    fn read_capture_var(xcx: extended_decode_ctxt) -> moves::CaptureVar;\n+}\n+\n+impl reader::Decoder : capture_var_helper {\n+    fn read_capture_var(xcx: extended_decode_ctxt) -> moves::CaptureVar {\n+        let cvar: moves::CaptureVar = Decodable::decode(&self);\n+        cvar.tr(xcx)\n+    }\n+}\n+\n+impl moves::CaptureVar : tr {\n+    fn tr(xcx: extended_decode_ctxt) -> moves::CaptureVar {\n+        moves::CaptureVar {\n+            def: self.def.tr(xcx),\n+            span: self.span.tr(xcx),\n+            mode: self.mode\n+        }\n+    }\n+}\n+\n // ______________________________________________________________________\n // Encoding and decoding of method_map_entry\n \n@@ -788,10 +814,11 @@ impl writer::Encoder: write_tag_and_id {\n }\n \n fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n-                             maps: maps,\n+                             maps: Maps,\n                              ebml_w: writer::Encoder,\n                              ii: ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_table as uint) {\n+        let ebml_w = copy ebml_w;\n         ast_util::visit_ids_for_inlined_item(\n             ii,\n             fn@(id: ast::node_id, copy ebml_w) {\n@@ -804,7 +831,7 @@ fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n }\n \n fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n-                             maps: maps,\n+                             maps: Maps,\n                              ebml_w: writer::Encoder,\n                              id: ast::node_id) {\n     let tcx = ecx.tcx;\n@@ -931,11 +958,19 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(&tcx.value_modes.find(id)) |vm| {\n-        do ebml_w.tag(c::tag_table_value_mode) {\n+    for maps.moves_map.find(id).each |_| {\n+        do ebml_w.tag(c::tag_table_moves_map) {\n+            ebml_w.id(id);\n+        }\n+    }\n+\n+    for maps.capture_map.find(id).each |cap_vars| {\n+        do ebml_w.tag(c::tag_table_capture_map) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                (*vm).encode(&ebml_w)\n+                do ebml_w.emit_from_vec(*cap_vars) |cap_var| {\n+                    cap_var.encode(&ebml_w);\n+                }\n             }\n         }\n     }\n@@ -980,10 +1015,24 @@ impl reader::Decoder: ebml_decoder_decoder_helpers {\n         // context.  However, we do not bother, because region types\n         // are not used during trans.\n \n-        do self.read_opaque |doc| {\n-            tydecode::parse_ty_data(\n+        return do self.read_opaque |doc| {\n+\n+            let ty = tydecode::parse_ty_data(\n                 doc.data, xcx.dcx.cdata.cnum, doc.start, xcx.dcx.tcx,\n-                |s, a| self.convert_def_id(xcx, s, a))\n+                |s, a| self.convert_def_id(xcx, s, a));\n+\n+            debug!(\"read_ty(%s) = %s\",\n+                   type_string(doc), ty_to_str(xcx.dcx.tcx, ty));\n+\n+            ty\n+        };\n+\n+        fn type_string(doc: ebml::Doc) -> ~str {\n+            let mut str = ~\"\";\n+            for uint::range(doc.start, doc.end) |i| {\n+                str::push_char(&mut str, doc.data[i] as char);\n+            }\n+            str\n         }\n     }\n \n@@ -1034,10 +1083,12 @@ impl reader::Decoder: ebml_decoder_decoder_helpers {\n          * to refer to the new, cloned copy of the type parameter.\n          */\n \n-        match source {\n+        let r = match source {\n             NominalType | TypeWithId => xcx.tr_def_id(did),\n             TypeParameter => xcx.tr_intern_def_id(did)\n-        }\n+        };\n+        debug!(\"convert_def_id(source=%?, did=%?)=%?\", source, did, r);\n+        return r;\n     }\n }\n \n@@ -1057,6 +1108,8 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n             dcx.maps.mutbl_map.insert(id, ());\n         } else if tag == (c::tag_table_legacy_boxed_trait as uint) {\n             dcx.tcx.legacy_boxed_traits.insert(id, ());\n+        } else if tag == (c::tag_table_moves_map as uint) {\n+            dcx.maps.moves_map.insert(id, ());\n         } else {\n             let val_doc = entry_doc[c::tag_table_val as uint];\n             let val_dsr = &reader::Decoder(val_doc);\n@@ -1065,6 +1118,8 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 dcx.tcx.def_map.insert(id, def);\n             } else if tag == (c::tag_table_node_type as uint) {\n                 let ty = val_dsr.read_ty(xcx);\n+                debug!(\"inserting ty for node %?: %s\",\n+                       id, ty_to_str(dcx.tcx, ty));\n                 (*dcx.tcx.node_types).insert(id as uint, ty);\n             } else if tag == (c::tag_table_node_type_subst as uint) {\n                 let tys = val_dsr.read_tys(xcx);\n@@ -1098,9 +1153,12 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 let adj: @ty::AutoAdjustment = @Decodable::decode(val_dsr);\n                 adj.tr(xcx);\n                 dcx.tcx.adjustments.insert(id, adj);\n-            } else if tag == (c::tag_table_value_mode as uint) {\n-                let vm: ty::ValueMode = Decodable::decode(val_dsr);\n-                dcx.tcx.value_modes.insert(id, vm);\n+            } else if tag == (c::tag_table_capture_map as uint) {\n+                let cvars =\n+                    at_vec::from_owned(\n+                        val_dsr.read_to_vec(\n+                            || val_dsr.read_capture_var(xcx)));\n+                dcx.maps.capture_map.insert(id, cvars);\n             } else {\n                 xcx.dcx.tcx.sess.bug(\n                     fmt!(\"unknown tag found in side tables: %x\", tag));"}, {"sha": "76b3aea2dd14aef8916dab56f0d488d462f7ad6d", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 118, "deletions": 97, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -19,13 +19,15 @@\n \n use core::prelude::*;\n \n-use middle::borrowck::{Loan, bckerr, borrowck_ctxt, inherent_mutability};\n+use middle::moves;\n+use middle::borrowck::{Loan, bckerr, BorrowckCtxt, inherent_mutability};\n use middle::borrowck::{req_maps, root_map_key, save_and_restore};\n+use middle::borrowck::{MoveError, MoveOk, MoveFromIllegalCmt};\n+use middle::borrowck::{MoveWhileBorrowed};\n use middle::mem_categorization::{cat_arg, cat_binding, cat_comp, cat_deref};\n use middle::mem_categorization::{cat_local, cat_rvalue, cat_self};\n use middle::mem_categorization::{cat_special, cmt, gc_ptr, loan_path, lp_arg};\n use middle::mem_categorization::{lp_comp, lp_deref, lp_local};\n-use middle::ty::{CopyValue, MoveValue, ReadValue};\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n@@ -42,7 +44,7 @@ use syntax::print::pprust;\n use syntax::visit;\n \n enum check_loan_ctxt = @{\n-    bccx: borrowck_ctxt,\n+    bccx: @BorrowckCtxt,\n     req_maps: req_maps,\n \n     reported: HashMap<ast::node_id, ()>,\n@@ -63,9 +65,9 @@ enum purity_cause {\n     pc_cmt(bckerr)\n }\n \n-pub fn check_loans(bccx: borrowck_ctxt,\n-                   req_maps: req_maps,\n-                   crate: @ast::crate) {\n+pub fn check_loans(bccx: @BorrowckCtxt,\n+               req_maps: req_maps,\n+               crate: @ast::crate) {\n     let clcx = check_loan_ctxt(@{bccx: bccx,\n                                  req_maps: req_maps,\n                                  reported: HashMap(),\n@@ -471,12 +473,40 @@ impl check_loan_ctxt {\n         }\n     }\n \n-    fn check_move_out(ex: @ast::expr) {\n-        let cmt = self.bccx.cat_expr(ex);\n-        self.check_move_out_from_cmt(cmt);\n+    fn check_move_out_from_expr(ex: @ast::expr) {\n+        match ex.node {\n+            ast::expr_paren(*) => {\n+                /* In the case of an expr_paren(), the expression inside\n+                 * the parens will also be marked as being moved.  Ignore\n+                 * the parents then so as not to report duplicate errors. */\n+            }\n+            _ => {\n+                let cmt = self.bccx.cat_expr(ex);\n+                match self.analyze_move_out_from_cmt(cmt) {\n+                    MoveOk => {}\n+                    MoveFromIllegalCmt(_) => {\n+                        self.bccx.span_err(\n+                            cmt.span,\n+                            fmt!(\"moving out of %s\",\n+                                 self.bccx.cmt_to_str(cmt)));\n+                    }\n+                    MoveWhileBorrowed(_, loan_cmt) => {\n+                        self.bccx.span_err(\n+                            cmt.span,\n+                            fmt!(\"moving out of %s prohibited \\\n+                                  due to outstanding loan\",\n+                                 self.bccx.cmt_to_str(cmt)));\n+                        self.bccx.span_note(\n+                            loan_cmt.span,\n+                            fmt!(\"loan of %s granted here\",\n+                                 self.bccx.cmt_to_str(loan_cmt)));\n+                    }\n+                }\n+            }\n+        }\n     }\n \n-    fn check_move_out_from_cmt(cmt: cmt) {\n+    fn analyze_move_out_from_cmt(cmt: cmt) -> MoveError {\n         debug!(\"check_move_out_from_cmt(cmt=%s)\",\n                self.bccx.cmt_to_repr(cmt));\n \n@@ -493,59 +523,27 @@ impl check_loan_ctxt {\n \n           // Nothing else.\n           _ => {\n-            self.bccx.span_err(\n-                cmt.span,\n-                fmt!(\"moving out of %s\", self.bccx.cmt_to_str(cmt)));\n-            return;\n+              return MoveFromIllegalCmt(cmt);\n           }\n         }\n \n         self.bccx.add_to_mutbl_map(cmt);\n \n         // check for a conflicting loan:\n-        let lp = match cmt.lp {\n-          None => return,\n-          Some(lp) => lp\n-        };\n-        for self.walk_loans_of(cmt.id, lp) |loan| {\n-            self.bccx.span_err(\n-                cmt.span,\n-                fmt!(\"moving out of %s prohibited due to outstanding loan\",\n-                     self.bccx.cmt_to_str(cmt)));\n-            self.bccx.span_note(\n-                loan.cmt.span,\n-                fmt!(\"loan of %s granted here\",\n-                     self.bccx.cmt_to_str(loan.cmt)));\n-            return;\n-        }\n-    }\n-\n-    // Very subtle (#2633): liveness can mark options as last_use even\n-    // when there is an outstanding loan.  In that case, it is not\n-    // safe to consider the use a last_use.\n-    fn check_last_use(expr: @ast::expr) {\n-        debug!(\"Checking last use of expr %?\", expr.id);\n-        let cmt = self.bccx.cat_expr(expr);\n-        let lp = match cmt.lp {\n-            None => {\n-                debug!(\"Not a loanable expression\");\n-                return;\n+        for cmt.lp.each |lp| {\n+            for self.walk_loans_of(cmt.id, *lp) |loan| {\n+                return MoveWhileBorrowed(cmt, loan.cmt);\n             }\n-            Some(lp) => lp\n-        };\n-        for self.walk_loans_of(cmt.id, lp) |_loan| {\n-            debug!(\"Removing last use entry %? due to outstanding loan\",\n-                   expr.id);\n-            self.bccx.last_use_map.remove(expr.id);\n-            return;\n         }\n+\n+        return MoveOk;\n     }\n \n     fn check_call(expr: @ast::expr,\n                   callee: Option<@ast::expr>,\n                   callee_id: ast::node_id,\n                   callee_span: span,\n-                  args: ~[@ast::expr]) {\n+                  args: &[@ast::expr]) {\n         match self.purity(expr.id) {\n           None => {}\n           Some(ref pc) => {\n@@ -557,35 +555,26 @@ impl check_loan_ctxt {\n             }\n           }\n         }\n-        let arg_tys =\n-            ty::ty_fn_args(\n-                ty::node_id_to_type(self.tcx(), callee_id));\n-        for vec::each2(args, arg_tys) |arg, arg_ty| {\n-            match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n-                ast::by_move => {\n-                    self.check_move_out(*arg);\n-                }\n-                ast::by_ref |\n-                ast::by_copy | ast::by_val => {\n-                }\n-            }\n-        }\n     }\n }\n \n fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                      sp: span, id: ast::node_id, &&self: check_loan_ctxt,\n-                     visitor: visit::vt<check_loan_ctxt>) {\n+                     visitor: visit::vt<check_loan_ctxt>)\n+{\n+    let is_stack_closure = self.is_stack_closure(id);\n+    let fty = ty::node_id_to_type(self.tcx(), id);\n+    let fty_proto = ty::ty_fn_proto(fty);\n+\n+    check_moves_from_captured_variables(self, id, fty_proto);\n \n     debug!(\"purity on entry=%?\", copy self.declared_purity);\n     do save_and_restore(&mut(self.declared_purity)) {\n         do save_and_restore(&mut(self.fn_args)) {\n-            let is_stack_closure = self.is_stack_closure(id);\n-            let fty = ty::node_id_to_type(self.tcx(), id);\n             self.declared_purity = ty::determine_inherited_purity(\n                 copy self.declared_purity,\n                 ty::ty_fn_purity(fty),\n-                ty::ty_fn_proto(fty));\n+                fty_proto);\n \n             match fk {\n                 visit::fk_anon(*) |\n@@ -616,6 +605,50 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n         }\n     }\n     debug!(\"purity on exit=%?\", copy self.declared_purity);\n+\n+    fn check_moves_from_captured_variables(&&self: check_loan_ctxt,\n+                                           id: ast::node_id,\n+                                           fty_proto: ast::Proto)\n+    {\n+        match fty_proto {\n+            ast::ProtoBox | ast::ProtoUniq => {\n+                let cap_vars = self.bccx.capture_map.get(id);\n+                for cap_vars.each |cap_var| {\n+                    match cap_var.mode {\n+                        moves::CapRef | moves::CapCopy => { loop; }\n+                        moves::CapMove => { }\n+                    }\n+                    let def_id = ast_util::def_id_of_def(cap_var.def).node;\n+                    let ty = ty::node_id_to_type(self.tcx(), def_id);\n+                    let cmt = self.bccx.cat_def(id, cap_var.span,\n+                                                ty, cap_var.def);\n+                    let move_err = self.analyze_move_out_from_cmt(cmt);\n+                    match move_err {\n+                        MoveOk => {}\n+                        MoveFromIllegalCmt(move_cmt) => {\n+                            self.bccx.span_err(\n+                                cap_var.span,\n+                                fmt!(\"illegal by-move capture of %s\",\n+                                     self.bccx.cmt_to_str(move_cmt)));\n+                        }\n+                        MoveWhileBorrowed(move_cmt, loan_cmt) => {\n+                            self.bccx.span_err(\n+                                cap_var.span,\n+                                fmt!(\"by-move capture of %s prohibited \\\n+                                      due to outstanding loan\",\n+                                     self.bccx.cmt_to_str(move_cmt)));\n+                            self.bccx.span_note(\n+                                loan_cmt.span,\n+                                fmt!(\"loan of %s granted here\",\n+                                     self.bccx.cmt_to_str(loan_cmt)));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            ast::ProtoBorrowed | ast::ProtoBare => {}\n+        }\n+    }\n }\n \n fn check_loans_in_local(local: @ast::local,\n@@ -632,48 +665,24 @@ fn check_loans_in_expr(expr: @ast::expr,\n \n     self.check_for_conflicting_loans(expr.id);\n \n-    // If this is a move, check it.\n-    match self.tcx().value_modes.find(expr.id) {\n-        Some(MoveValue) => self.check_move_out(expr),\n-        Some(ReadValue) | Some(CopyValue) | None => {}\n+    if self.bccx.moves_map.contains_key(expr.id) {\n+        self.check_move_out_from_expr(expr);\n     }\n \n-    match /*bad*/copy expr.node {\n-      ast::expr_path(*) if self.bccx.last_use_map.contains_key(expr.id) => {\n-        self.check_last_use(expr);\n-      }\n-\n+    match expr.node {\n       ast::expr_swap(l, r) => {\n         self.check_assignment(at_swap, l);\n         self.check_assignment(at_swap, r);\n       }\n-      ast::expr_unary_move(src) => {\n-        self.check_move_out(src);\n-      }\n       ast::expr_assign(dest, _) |\n       ast::expr_assign_op(_, dest, _) => {\n         self.check_assignment(at_straight_up, dest);\n       }\n-      ast::expr_fn(_, _, _, cap_clause) |\n-      ast::expr_fn_block(_, _, cap_clause) => {\n-        for (*cap_clause).each |cap_item| {\n-            if cap_item.is_move {\n-                let def = self.tcx().def_map.get(cap_item.id);\n-\n-                // Hack: the type that is used in the cmt doesn't actually\n-                // matter here, so just subst nil instead of looking up\n-                // the type of the def that is referred to\n-                let cmt = self.bccx.cat_def(cap_item.id, cap_item.span,\n-                                            ty::mk_nil(self.tcx()), def);\n-                self.check_move_out_from_cmt(cmt);\n-            }\n-        }\n+      ast::expr_call(f, ref args, _) => {\n+        self.check_call(expr, Some(f), f.id, f.span, *args);\n       }\n-      ast::expr_call(f, args, _) => {\n-        self.check_call(expr, Some(f), f.id, f.span, args);\n-      }\n-      ast::expr_method_call(_, _, _, args, _) => {\n-        self.check_call(expr, None, expr.callee_id, expr.span, args);\n+      ast::expr_method_call(_, _, _, ref args, _) => {\n+        self.check_call(expr, None, expr.callee_id, expr.span, *args);\n       }\n       ast::expr_index(_, rval) |\n       ast::expr_binary(_, _, rval)\n@@ -692,6 +701,18 @@ fn check_loans_in_expr(expr: @ast::expr,\n                         expr.span,\n                         ~[]);\n       }\n+      ast::expr_match(*) => {\n+          // Note: moves out of pattern bindings are not checked by\n+          // the borrow checker, at least not directly.  What happens\n+          // is that if there are any moved bindings, the discriminant\n+          // will be considered a move, and this will be checked as\n+          // normal.  Then, in `middle::check_match`, we will check\n+          // that no move occurs in a binding that is underneath an\n+          // `@` or `&`.  Together these give the same guarantees as\n+          // `check_move_out_from_expr()` without requiring us to\n+          // rewalk the patterns and rebuild the pattern\n+          // categorizations.\n+      }\n       _ => { }\n     }\n "}, {"sha": "bfcdacf811d36447f64bfcf64ae0ac9dbb5cdbce", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -18,8 +18,8 @@\n \n use core::prelude::*;\n \n-use middle::borrowck::preserve::{preserve_condition, pc_ok, pc_if_pure};\n-use middle::borrowck::{Loan, bckerr, bckres, borrowck_ctxt, err_mutbl};\n+use middle::borrowck::preserve::{PreserveCondition, PcOk, PcIfPure};\n+use middle::borrowck::{Loan, bckerr, bckres, BorrowckCtxt, err_mutbl};\n use middle::borrowck::{req_maps};\n use middle::mem_categorization::{cat_binding, cat_discr, cmt, comp_variant};\n use middle::mem_categorization::{mem_categorization_ctxt};\n@@ -68,13 +68,13 @@ use syntax::visit;\n /// No good.  Instead what will happen is that `root_ub` will be set to the\n /// body of the while loop and we will refuse to root the pointer `&*x`\n /// because it would have to be rooted for a region greater than `root_ub`.\n-enum gather_loan_ctxt = @{bccx: borrowck_ctxt,\n+enum gather_loan_ctxt = @{bccx: @BorrowckCtxt,\n                           req_maps: req_maps,\n                           mut item_ub: ast::node_id,\n                           mut root_ub: ast::node_id,\n                           mut ignore_adjustments: LinearSet<ast::node_id>};\n \n-pub fn gather_loans(bccx: borrowck_ctxt, crate: @ast::crate) -> req_maps {\n+pub fn gather_loans(bccx: @BorrowckCtxt, crate: @ast::crate) -> req_maps {\n     let glcx = gather_loan_ctxt(@{bccx: bccx,\n                                   req_maps: {req_loan_map: HashMap(),\n                                              pure_map: HashMap()},\n@@ -148,11 +148,11 @@ fn req_loans_in_expr(ex: @ast::expr,\n         let scope_r = ty::re_scope(ex.id);\n         for vec::each2(args, arg_tys) |arg, arg_ty| {\n             match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n-              ast::by_ref => {\n-                let arg_cmt = self.bccx.cat_expr(*arg);\n-                self.guarantee_valid(arg_cmt, m_imm,  scope_r);\n-              }\n-               ast::by_val | ast::by_move | ast::by_copy => {}\n+                ast::by_ref => {\n+                    let arg_cmt = self.bccx.cat_expr(*arg);\n+                    self.guarantee_valid(arg_cmt, m_imm,  scope_r);\n+                }\n+                ast::by_val | ast::by_copy => {}\n             }\n         }\n         visit::visit_expr(ex, self, vt);\n@@ -164,11 +164,11 @@ fn req_loans_in_expr(ex: @ast::expr,\n         let scope_r = ty::re_scope(ex.id);\n         for vec::each2(args, arg_tys) |arg, arg_ty| {\n             match ty::resolved_mode(self.tcx(), arg_ty.mode) {\n-              ast::by_ref => {\n-                let arg_cmt = self.bccx.cat_expr(*arg);\n-                self.guarantee_valid(arg_cmt, m_imm,  scope_r);\n-              }\n-               ast::by_val | ast::by_move | ast::by_copy => {}\n+                ast::by_ref => {\n+                    let arg_cmt = self.bccx.cat_expr(*arg);\n+                    self.guarantee_valid(arg_cmt, m_imm,  scope_r);\n+                }\n+                ast::by_val | ast::by_copy => {}\n             }\n         }\n \n@@ -374,7 +374,7 @@ impl gather_loan_ctxt {\n           // matches with the actual mutability (but if an immutable\n           // pointer is desired, that is ok as long as we are pure)\n           None => {\n-            let result: bckres<preserve_condition> = {\n+            let result: bckres<PreserveCondition> = {\n                 do self.check_mutbl(req_mutbl, cmt).chain |pc1| {\n                     do self.bccx.preserve(cmt, scope_r,\n                                           self.item_ub,\n@@ -385,16 +385,16 @@ impl gather_loan_ctxt {\n             };\n \n             match result {\n-                Ok(pc_ok) => {\n-                    debug!(\"result of preserve: pc_ok\");\n+                Ok(PcOk) => {\n+                    debug!(\"result of preserve: PcOk\");\n \n                     // we were able guarantee the validity of the ptr,\n                     // perhaps by rooting or because it is immutably\n                     // rooted.  good.\n                     self.bccx.stable_paths += 1;\n                 }\n-                Ok(pc_if_pure(ref e)) => {\n-                    debug!(\"result of preserve: %?\", pc_if_pure((*e)));\n+                Ok(PcIfPure(ref e)) => {\n+                    debug!(\"result of preserve: %?\", PcIfPure((*e)));\n \n                     // we are only able to guarantee the validity if\n                     // the scope is pure\n@@ -443,25 +443,25 @@ impl gather_loan_ctxt {\n     // mutable memory.\n     fn check_mutbl(&self,\n                    req_mutbl: ast::mutability,\n-                   cmt: cmt) -> bckres<preserve_condition> {\n+                   cmt: cmt) -> bckres<PreserveCondition> {\n         debug!(\"check_mutbl(req_mutbl=%?, cmt.mutbl=%?)\",\n                req_mutbl, cmt.mutbl);\n \n         if req_mutbl == m_const || req_mutbl == cmt.mutbl {\n             debug!(\"required is const or they are the same\");\n-            Ok(pc_ok)\n+            Ok(PcOk)\n         } else {\n             let e = bckerr { cmt: cmt, code: err_mutbl(req_mutbl) };\n             if req_mutbl == m_imm {\n                 // if this is an @mut box, then it's generally OK to borrow as\n                 // &imm; this will result in a write guard\n                 if cmt.cat.is_mutable_box() {\n-                    Ok(pc_ok)\n+                    Ok(PcOk)\n                 } else {\n                     // you can treat mutable things as imm if you are pure\n                     debug!(\"imm required, must be pure\");\n \n-                    Ok(pc_if_pure(e))\n+                    Ok(PcIfPure(e))\n                 }\n             } else {\n                 Err(e)\n@@ -556,11 +556,6 @@ impl gather_loan_ctxt {\n             match pat.node {\n               ast::pat_ident(bm, _, _) if self.pat_is_binding(pat) => {\n                 match bm {\n-                  ast::bind_by_value | ast::bind_by_move => {\n-                    // copying does not borrow anything, so no check\n-                    // is required\n-                    // as for move, check::_match ensures it's from an rvalue.\n-                  }\n                   ast::bind_by_ref(mutbl) => {\n                     // ref x or ref x @ p --- creates a ptr which must\n                     // remain valid for the scope of the match\n@@ -582,9 +577,9 @@ impl gather_loan_ctxt {\n                         self.guarantee_valid(cmt, mutbl, scope_r);\n                     }\n                   }\n-                  ast::bind_infer => {\n-                    // Nothing to do here; this is either a copy or a move;\n-                    // thus either way there is nothing to check. Yay!\n+                  ast::bind_by_copy | ast::bind_infer => {\n+                    // Nothing to do here; neither copies nor moves induce\n+                    // borrows.\n                   }\n                 }\n               }"}, {"sha": "c4b36085ec802f98c09857b91f3da35836aa7b07", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -43,7 +43,7 @@ XXX --- much more needed, don't have time to write this all up now\n \n use core::prelude::*;\n \n-use middle::borrowck::{Loan, bckerr, bckres, borrowck_ctxt, err_mutbl};\n+use middle::borrowck::{Loan, bckerr, bckres, BorrowckCtxt, err_mutbl};\n use middle::borrowck::{err_out_of_scope};\n use middle::mem_categorization::{cat_arg, cat_binding, cat_discr, cat_comp};\n use middle::mem_categorization::{cat_deref, cat_discr, cat_local, cat_self};\n@@ -57,8 +57,9 @@ use core::result::{Err, Ok, Result};\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;\n \n-impl borrowck_ctxt {\n-    fn loan(cmt: cmt,\n+impl BorrowckCtxt {\n+    fn loan(&self,\n+            cmt: cmt,\n             scope_region: ty::Region,\n             mutbl: ast::mutability) -> bckres<~[Loan]> {\n         let lc = LoanContext {\n@@ -77,7 +78,7 @@ impl borrowck_ctxt {\n }\n \n struct LoanContext {\n-    bccx: borrowck_ctxt,\n+    bccx: &BorrowckCtxt,\n \n     // the region scope for which we must preserve the memory\n     scope_region: ty::Region,"}, {"sha": "c0c59c686998f92413878a14bc36d61e63409ed1", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 59, "deletions": 49, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -230,6 +230,7 @@ use middle::liveness;\n use middle::mem_categorization::*;\n use middle::region;\n use middle::ty;\n+use middle::moves;\n use util::common::{indenter, stmt_set};\n use util::ppaux::{expr_repr, note_and_explain_region};\n use util::ppaux::{ty_to_str, region_to_str, explain_region};\n@@ -254,15 +255,17 @@ pub mod gather_loans;\n pub mod loan;\n pub mod preserve;\n \n-pub fn check_crate(tcx: ty::ctxt,\n-                   method_map: typeck::method_map,\n-                   last_use_map: liveness::last_use_map,\n-                   crate: @ast::crate)\n-                -> (root_map, mutbl_map, write_guard_map) {\n-\n-    let bccx = borrowck_ctxt_(@{tcx: tcx,\n+pub fn check_crate(\n+    tcx: ty::ctxt,\n+    method_map: typeck::method_map,\n+    moves_map: moves::MovesMap,\n+    capture_map: moves::CaptureMap,\n+    crate: @ast::crate) -> (root_map, mutbl_map, write_guard_map)\n+{\n+    let bccx = @BorrowckCtxt   {tcx: tcx,\n                                 method_map: method_map,\n-                                last_use_map: last_use_map,\n+                                moves_map: moves_map,\n+                                capture_map: capture_map,\n                                 root_map: root_map(),\n                                 mutbl_map: HashMap(),\n                                 write_guard_map: HashMap(),\n@@ -271,7 +274,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                                 mut loaned_paths_imm: 0,\n                                 mut stable_paths: 0,\n                                 mut req_pure_paths: 0,\n-                                mut guaranteed_paths: 0});\n+                                mut guaranteed_paths: 0};\n \n     let req_maps = gather_loans::gather_loans(bccx, crate);\n     check_loans::check_loans(bccx, req_maps, crate);\n@@ -292,7 +295,7 @@ pub fn check_crate(tcx: ty::ctxt,\n \n     return (bccx.root_map, bccx.mutbl_map, bccx.write_guard_map);\n \n-    fn make_stat(bccx: borrowck_ctxt, stat: uint) -> ~str {\n+    fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> ~str {\n         let stat_f = stat as float;\n         let total = bccx.guaranteed_paths as float;\n         fmt!(\"%u (%.0f%%)\", stat  , stat_f * 100f / total)\n@@ -302,23 +305,22 @@ pub fn check_crate(tcx: ty::ctxt,\n // ----------------------------------------------------------------------\n // Type definitions\n \n-pub type borrowck_ctxt_ = {tcx: ty::ctxt,\n-                           method_map: typeck::method_map,\n-                           last_use_map: liveness::last_use_map,\n-                           root_map: root_map,\n-                           mutbl_map: mutbl_map,\n-                           write_guard_map: write_guard_map,\n-                           stmt_map: stmt_set,\n-\n-                           // Statistics:\n-                           mut loaned_paths_same: uint,\n-                           mut loaned_paths_imm: uint,\n-                           mut stable_paths: uint,\n-                           mut req_pure_paths: uint,\n-                           mut guaranteed_paths: uint};\n-\n-pub enum borrowck_ctxt {\n-    borrowck_ctxt_(@borrowck_ctxt_)\n+pub struct BorrowckCtxt {\n+    tcx: ty::ctxt,\n+    method_map: typeck::method_map,\n+    moves_map: moves::MovesMap,\n+    capture_map: moves::CaptureMap,\n+    root_map: root_map,\n+    mutbl_map: mutbl_map,\n+    write_guard_map: write_guard_map,\n+    stmt_map: stmt_set,\n+\n+    // Statistics:\n+    mut loaned_paths_same: uint,\n+    mut loaned_paths_imm: uint,\n+    mut stable_paths: uint,\n+    mut req_pure_paths: uint,\n+    mut guaranteed_paths: uint\n }\n \n pub struct RootInfo {\n@@ -371,6 +373,12 @@ pub struct bckerr {\n     code: bckerr_code\n }\n \n+pub enum MoveError {\n+    MoveOk,\n+    MoveFromIllegalCmt(cmt),\n+    MoveWhileBorrowed(/*move*/ cmt, /*loan*/ cmt)\n+}\n+\n // shorthand for something that fails with `bckerr` or succeeds with `T`\n pub type bckres<T> = Result<T, bckerr>;\n \n@@ -411,76 +419,78 @@ pub fn root_map() -> root_map {\n // ___________________________________________________________________________\n // Misc\n \n-pub impl borrowck_ctxt {\n-    fn is_subregion_of(r_sub: ty::Region, r_sup: ty::Region) -> bool {\n+pub impl BorrowckCtxt {\n+    fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region) -> bool {\n         region::is_subregion_of(self.tcx.region_map, r_sub, r_sup)\n     }\n \n-    fn cat_expr(expr: @ast::expr) -> cmt {\n+    fn cat_expr(&self, expr: @ast::expr) -> cmt {\n         cat_expr(self.tcx, self.method_map, expr)\n     }\n \n-    fn cat_expr_unadjusted(expr: @ast::expr) -> cmt {\n+    fn cat_expr_unadjusted(&self, expr: @ast::expr) -> cmt {\n         cat_expr_unadjusted(self.tcx, self.method_map, expr)\n     }\n \n-    fn cat_expr_autoderefd(expr: @ast::expr,\n+    fn cat_expr_autoderefd(&self, expr: @ast::expr,\n                            adj: @ty::AutoAdjustment)\n                         -> cmt {\n         cat_expr_autoderefd(self.tcx, self.method_map, expr, adj)\n     }\n \n-    fn cat_def(id: ast::node_id,\n+    fn cat_def(&self,\n+               id: ast::node_id,\n                span: span,\n                ty: ty::t,\n                def: ast::def) -> cmt {\n         cat_def(self.tcx, self.method_map, id, span, ty, def)\n     }\n \n-    fn cat_variant<N: ast_node>(arg: N,\n+    fn cat_variant<N: ast_node>(&self,\n+                                arg: N,\n                                 enum_did: ast::def_id,\n                                 cmt: cmt) -> cmt {\n         cat_variant(self.tcx, self.method_map, arg, enum_did, cmt)\n     }\n \n-    fn cat_discr(cmt: cmt, match_id: ast::node_id) -> cmt {\n-        return @cmt_ { cat: cat_discr(cmt, match_id),.. *cmt };\n+    fn cat_discr(&self, cmt: cmt, match_id: ast::node_id) -> cmt {\n+        return @cmt_ {cat:cat_discr(cmt, match_id),.. *cmt};\n     }\n \n-    fn mc_ctxt() -> mem_categorization_ctxt {\n+    fn mc_ctxt(&self) -> mem_categorization_ctxt {\n         mem_categorization_ctxt {tcx: self.tcx,\n                                  method_map: self.method_map}\n     }\n \n-    fn cat_pattern(cmt: cmt, pat: @ast::pat, op: fn(cmt, @ast::pat)) {\n+    fn cat_pattern(&self, cmt: cmt, pat: @ast::pat, op: fn(cmt, @ast::pat)) {\n         let mc = self.mc_ctxt();\n         mc.cat_pattern(cmt, pat, op);\n     }\n \n-    fn report_if_err(bres: bckres<()>) {\n+    fn report_if_err(&self, bres: bckres<()>) {\n         match bres {\n           Ok(()) => (),\n           Err(ref e) => self.report((*e))\n         }\n     }\n \n-    fn report(err: bckerr) {\n+    fn report(&self, err: bckerr) {\n         self.span_err(\n             err.cmt.span,\n             fmt!(\"illegal borrow: %s\",\n                  self.bckerr_to_str(err)));\n         self.note_and_explain_bckerr(err);\n     }\n \n-    fn span_err(s: span, +m: ~str) {\n+    fn span_err(&self, s: span, +m: ~str) {\n         self.tcx.sess.span_err(s, m);\n     }\n \n-    fn span_note(s: span, +m: ~str) {\n+    fn span_note(&self, s: span, +m: ~str) {\n         self.tcx.sess.span_note(s, m);\n     }\n \n-    fn add_to_mutbl_map(cmt: cmt) {\n+    fn add_to_mutbl_map(&self, cmt: cmt) {\n         match cmt.cat {\n           cat_local(id) | cat_arg(id) => {\n             self.mutbl_map.insert(id, ());\n@@ -492,7 +502,7 @@ pub impl borrowck_ctxt {\n         }\n     }\n \n-    fn bckerr_to_str(err: bckerr) -> ~str {\n+    fn bckerr_to_str(&self, err: bckerr) -> ~str {\n         match err.code {\n             err_mutbl(req) => {\n                 fmt!(\"creating %s alias to %s\",\n@@ -520,7 +530,7 @@ pub impl borrowck_ctxt {\n         }\n     }\n \n-    fn note_and_explain_bckerr(err: bckerr) {\n+    fn note_and_explain_bckerr(&self, err: bckerr) {\n         let code = err.code;\n         match code {\n             err_mutbl(*) | err_mut_uniq | err_mut_variant |\n@@ -555,25 +565,25 @@ pub impl borrowck_ctxt {\n     }\n \n \n-    fn cmt_to_str(cmt: cmt) -> ~str {\n+    fn cmt_to_str(&self, cmt: cmt) -> ~str {\n         let mc = &mem_categorization_ctxt {tcx: self.tcx,\n                                            method_map: self.method_map};\n         mc.cmt_to_str(cmt)\n     }\n \n-    fn cmt_to_repr(cmt: cmt) -> ~str {\n+    fn cmt_to_repr(&self, cmt: cmt) -> ~str {\n         let mc = &mem_categorization_ctxt {tcx: self.tcx,\n                                            method_map: self.method_map};\n         mc.cmt_to_repr(cmt)\n     }\n \n-    fn mut_to_str(mutbl: ast::mutability) -> ~str {\n+    fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n         let mc = &mem_categorization_ctxt {tcx: self.tcx,\n                                            method_map: self.method_map};\n         mc.mut_to_str(mutbl)\n     }\n \n-    fn loan_to_repr(loan: &Loan) -> ~str {\n+    fn loan_to_repr(&self, loan: &Loan) -> ~str {\n         fmt!(\"Loan(lp=%?, cmt=%s, mutbl=%?)\",\n              loan.lp, self.cmt_to_repr(loan.cmt), loan.mutbl)\n     }"}, {"sha": "570b439cf8c5eab770cb35f1fb465e1149cd9600", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 58, "deletions": 54, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -15,7 +15,7 @@\n \n use core::prelude::*;\n \n-use middle::borrowck::{RootInfo, bckerr, bckerr_code, bckres, borrowck_ctxt};\n+use middle::borrowck::{RootInfo, bckerr, bckerr_code, bckres, BorrowckCtxt};\n use middle::borrowck::{err_mut_uniq, err_mut_variant};\n use middle::borrowck::{err_out_of_root_scope, err_out_of_scope};\n use middle::borrowck::{err_root_not_permitted, root_map_key};\n@@ -30,40 +30,42 @@ use util::common::indenter;\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;\n \n-pub enum preserve_condition {\n-    pc_ok,\n-    pc_if_pure(bckerr)\n+pub enum PreserveCondition {\n+    PcOk,\n+    PcIfPure(bckerr)\n }\n \n-impl preserve_condition {\n+impl PreserveCondition {\n     // combines two preservation conditions such that if either of\n     // them requires purity, the result requires purity\n-    fn combine(pc: preserve_condition) -> preserve_condition {\n-        match self {\n-          pc_ok => {pc}\n-          pc_if_pure(_) => {self}\n+    fn combine(&self, pc: PreserveCondition) -> PreserveCondition {\n+        match *self {\n+            PcOk => {pc}\n+            PcIfPure(_) => {*self}\n         }\n     }\n }\n \n-impl borrowck_ctxt {\n-    fn preserve(cmt: cmt,\n+impl BorrowckCtxt {\n+    fn preserve(&self,\n+                cmt: cmt,\n                 scope_region: ty::Region,\n                 item_ub: ast::node_id,\n-                root_ub: ast::node_id)\n-        -> bckres<preserve_condition> {\n-\n-        let ctxt = preserve_ctxt({bccx: self,\n-                                  scope_region: scope_region,\n-                                  item_ub: item_ub,\n-                                  root_ub: root_ub,\n-                                  root_managed_data: true});\n-        (&ctxt).preserve(cmt)\n+                root_ub: ast::node_id) -> bckres<PreserveCondition>\n+    {\n+        let ctxt = PreserveCtxt {\n+            bccx: self,\n+            scope_region: scope_region,\n+            item_ub: item_ub,\n+            root_ub: root_ub,\n+            root_managed_data: true\n+        };\n+        ctxt.preserve(cmt)\n     }\n }\n \n-enum preserve_ctxt = {\n-    bccx: borrowck_ctxt,\n+struct PreserveCtxt {\n+    bccx: &BorrowckCtxt,\n \n     // the region scope for which we must preserve the memory\n     scope_region: ty::Region,\n@@ -76,13 +78,12 @@ enum preserve_ctxt = {\n \n     // if false, do not attempt to root managed data\n     root_managed_data: bool\n-};\n-\n+}\n \n-priv impl &preserve_ctxt {\n-    fn tcx() -> ty::ctxt { self.bccx.tcx }\n+impl PreserveCtxt {\n+    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn preserve(cmt: cmt) -> bckres<preserve_condition> {\n+    fn preserve(&self, cmt: cmt) -> bckres<PreserveCondition> {\n         debug!(\"preserve(cmt=%s, root_ub=%?, root_managed_data=%b)\",\n                self.bccx.cmt_to_repr(cmt), self.root_ub,\n                self.root_managed_data);\n@@ -94,7 +95,7 @@ priv impl &preserve_ctxt {\n             self.compare_scope(cmt, ty::re_scope(self.item_ub))\n           }\n           cat_special(sk_static_item) | cat_special(sk_method) => {\n-            Ok(pc_ok)\n+            Ok(PcOk)\n           }\n           cat_rvalue => {\n             // when we borrow an rvalue, we can keep it rooted but only\n@@ -181,7 +182,7 @@ priv impl &preserve_ctxt {\n           }\n           cat_deref(_, _, unsafe_ptr) => {\n             // Unsafe pointers are the user's problem\n-            Ok(pc_ok)\n+            Ok(PcOk)\n           }\n           cat_deref(base, derefs, gc_ptr(*)) => {\n             // GC'd pointers of type @MT: if this pointer lives in\n@@ -193,13 +194,15 @@ priv impl &preserve_ctxt {\n             if cmt.cat.derefs_through_mutable_box() {\n                 self.attempt_root(cmt, base, derefs)\n             } else if base.mutbl == m_imm {\n-                let non_rooting_ctxt =\n-                    preserve_ctxt({root_managed_data: false,.. **self});\n-                match (&non_rooting_ctxt).preserve(base) {\n-                  Ok(pc_ok) => {\n-                    Ok(pc_ok)\n+                let non_rooting_ctxt = PreserveCtxt {\n+                    root_managed_data: false,\n+                    ..*self\n+                };\n+                match non_rooting_ctxt.preserve(base) {\n+                  Ok(PcOk) => {\n+                    Ok(PcOk)\n                   }\n-                  Ok(pc_if_pure(_)) => {\n+                  Ok(PcIfPure(_)) => {\n                     debug!(\"must root @T, otherwise purity req'd\");\n                     self.attempt_root(cmt, base, derefs)\n                   }\n@@ -267,10 +270,11 @@ priv impl &preserve_ctxt {\n             // node appears to draw the line between what will be rooted\n             // in the *arm* vs the *match*.\n \n-            let match_rooting_ctxt =\n-                preserve_ctxt({scope_region: ty::re_scope(match_id),\n-                               .. **self});\n-            (&match_rooting_ctxt).preserve(base)\n+              let match_rooting_ctxt = PreserveCtxt {\n+                  scope_region: ty::re_scope(match_id),\n+                  ..*self\n+              };\n+              match_rooting_ctxt.preserve(base)\n           }\n         }\n     }\n@@ -279,28 +283,29 @@ priv impl &preserve_ctxt {\n     /// `base`) be found in an immutable location (that is, `base`\n     /// must be immutable).  Also requires that `base` itself is\n     /// preserved.\n-    fn require_imm(cmt: cmt,\n+    fn require_imm(&self,\n+                   cmt: cmt,\n                    cmt_base: cmt,\n-                   code: bckerr_code) -> bckres<preserve_condition> {\n+                   code: bckerr_code) -> bckres<PreserveCondition> {\n         // Variant contents and unique pointers: must be immutably\n         // rooted to a preserved address.\n         match self.preserve(cmt_base) {\n           // the base is preserved, but if we are not mutable then\n           // purity is required\n-          Ok(pc_ok) => {\n+          Ok(PcOk) => {\n             match cmt_base.mutbl {\n               m_mutbl | m_const => {\n-                Ok(pc_if_pure(bckerr { cmt: cmt, code: code }))\n+                Ok(PcIfPure(bckerr {cmt:cmt, code:code}))\n               }\n               m_imm => {\n-                Ok(pc_ok)\n+                Ok(PcOk)\n               }\n             }\n           }\n \n           // the base requires purity too, that's fine\n-          Ok(pc_if_pure(ref e)) => {\n-            Ok(pc_if_pure((*e)))\n+          Ok(PcIfPure(ref e)) => {\n+            Ok(PcIfPure((*e)))\n           }\n \n           // base is not stable, doesn't matter\n@@ -312,10 +317,11 @@ priv impl &preserve_ctxt {\n \n     /// Checks that the scope for which the value must be preserved\n     /// is a subscope of `scope_ub`; if so, success.\n-    fn compare_scope(cmt: cmt,\n-                     scope_ub: ty::Region) -> bckres<preserve_condition> {\n+    fn compare_scope(&self,\n+                     cmt: cmt,\n+                     scope_ub: ty::Region) -> bckres<PreserveCondition> {\n         if self.bccx.is_subregion_of(self.scope_region, scope_ub) {\n-            Ok(pc_ok)\n+            Ok(PcOk)\n         } else {\n             Err(bckerr {\n                 cmt:cmt,\n@@ -333,10 +339,8 @@ priv impl &preserve_ctxt {\n     /// value live for longer than the current fn or else potentially\n     /// require that an statically unbounded number of values be\n     /// rooted (if a loop exists).\n-    fn attempt_root(cmt: cmt,\n-                    base: cmt,\n-                    derefs: uint)\n-                 -> bckres<preserve_condition> {\n+    fn attempt_root(&self, cmt: cmt, base: cmt,\n+                    derefs: uint) -> bckres<PreserveCondition> {\n         if !self.root_managed_data {\n             // normally, there is a root_ub; the only time that this\n             // is none is when a boxed value is stored in an immutable\n@@ -387,7 +391,7 @@ priv impl &preserve_ctxt {\n                     scope: scope_to_use,\n                     freezes: cmt.cat.derefs_through_mutable_box()\n                 });\n-                return Ok(pc_ok);\n+                return Ok(PcOk);\n             } else {\n                 debug!(\"Unable to root\");\n                 return Err(bckerr {"}, {"sha": "5b77228d1abe4ec6572711a0316d7a198d883a44", "filename": "src/librustc/middle/capture.rs", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Flibrustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Flibrustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcapture.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,141 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::prelude::*;\n-\n-use middle::freevars;\n-use middle::ty;\n-\n-use core::option;\n-use core::vec;\n-use std::map::HashMap;\n-use std::map;\n-use syntax::codemap::span;\n-use syntax::{ast, ast_util};\n-\n-pub enum capture_mode {\n-    cap_copy, // Copy the value into the closure.\n-    cap_move, // Move the value into the closure.\n-    cap_drop, // Drop value after creating closure.\n-    cap_ref,  // Reference directly from parent stack frame (block fn).\n-}\n-\n-pub type capture_var = {\n-    def: ast::def,                       // Variable being accessed free\n-    span: span,                          // Location of access or cap item\n-    cap_item: Option<ast::capture_item>, // Capture item, if any\n-    mode: capture_mode                   // How variable is being accessed\n-};\n-\n-pub type capture_map = map::HashMap<ast::def_id, capture_var>;\n-\n-// checks the capture clause for a fn_expr() and issues warnings or\n-// errors for any irregularities which we identify.\n-pub fn check_capture_clause(tcx: ty::ctxt,\n-                            fn_expr_id: ast::node_id,\n-                            cap_clause: ast::capture_clause) {\n-    let freevars = freevars::get_freevars(tcx, fn_expr_id);\n-    let seen_defs = map::HashMap();\n-\n-    for (*cap_clause).each |cap_item| {\n-        let cap_def = tcx.def_map.get(cap_item.id);\n-        if !vec::any(*freevars, |fv| fv.def == cap_def ) {\n-            tcx.sess.span_warn(\n-                cap_item.span,\n-                fmt!(\"captured variable `%s` not used in closure\",\n-                     tcx.sess.str_of(cap_item.name)));\n-        }\n-\n-        let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n-        if !seen_defs.insert(cap_def_id, ()) {\n-            tcx.sess.span_err(\n-                cap_item.span,\n-                fmt!(\"variable `%s` captured more than once\",\n-                     tcx.sess.str_of(cap_item.name)));\n-        }\n-    }\n-}\n-\n-pub fn compute_capture_vars(tcx: ty::ctxt,\n-                            fn_expr_id: ast::node_id,\n-                            fn_proto: ast::Proto,\n-                            cap_clause: ast::capture_clause)\n-                         -> ~[capture_var] {\n-    let freevars = freevars::get_freevars(tcx, fn_expr_id);\n-    let cap_map = map::HashMap();\n-\n-    // first add entries for anything explicitly named in the cap clause\n-\n-    for (*cap_clause).each |cap_item| {\n-        debug!(\"Doing capture var: %s (%?)\",\n-               tcx.sess.str_of(cap_item.name), cap_item.id);\n-\n-        let cap_def = tcx.def_map.get(cap_item.id);\n-        let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n-        if cap_item.is_move {\n-            // if we are moving the value in, but it's not actually used,\n-            // must drop it.\n-            if vec::any(*freevars, |fv| fv.def == cap_def ) {\n-                cap_map.insert(cap_def_id, {def:cap_def,\n-                                            span: cap_item.span,\n-                                            cap_item: Some(*cap_item),\n-                                            mode:cap_move});\n-            } else {\n-                cap_map.insert(cap_def_id, {def:cap_def,\n-                                            span: cap_item.span,\n-                                            cap_item: Some(*cap_item),\n-                                            mode:cap_drop});\n-            }\n-        } else {\n-            // if we are copying the value in, but it's not actually used,\n-            // just ignore it.\n-            if vec::any(*freevars, |fv| fv.def == cap_def ) {\n-                cap_map.insert(cap_def_id, {def:cap_def,\n-                                            span: cap_item.span,\n-                                            cap_item: Some(*cap_item),\n-                                            mode:cap_copy});\n-            }\n-        }\n-    }\n-\n-    // now go through anything that is referenced but was not explicitly\n-    // named and add that\n-\n-    let implicit_mode_is_by_ref = fn_proto == ast::ProtoBorrowed;\n-    for vec::each(*freevars) |fvar| {\n-        let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n-        match cap_map.find(fvar_def_id) {\n-            option::Some(_) => { /* was explicitly named, do nothing */ }\n-            option::None => {\n-                // Move if this type implicitly moves; copy otherwise.\n-                let mode;\n-                if implicit_mode_is_by_ref {\n-                    mode = cap_ref;\n-                } else {\n-                    let fvar_ty = ty::node_id_to_type(tcx, fvar_def_id);\n-                    if ty::type_implicitly_moves(tcx, fvar_ty) {\n-                        mode = cap_move;\n-                    } else {\n-                        mode = cap_copy;\n-                    }\n-                };\n-\n-                cap_map.insert(fvar_def_id, {def:fvar.def,\n-                                             span: fvar.span,\n-                                             cap_item: None,\n-                                             mode:mode});\n-            }\n-        }\n-    }\n-\n-    let mut result = ~[];\n-    for cap_map.each_value |cap_var| { result.push(cap_var); }\n-    return result;\n-}"}, {"sha": "bfe73a9d15cf5db9d3c49d1b020ff605bc6942c5", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -32,13 +32,13 @@ pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n               expr_loop(ref b, _) => {\n                 (v.visit_block)((*b), {in_loop: true,.. cx}, v);\n               }\n-              expr_fn(_, _, _, _) => {\n+              expr_fn(_, _, _) => {\n                 visit::visit_expr(e, {in_loop: false, can_ret: true}, v);\n               }\n-              expr_fn_block(_, ref b, _) => {\n+              expr_fn_block(_, ref b) => {\n                 (v.visit_block)((*b), {in_loop: false, can_ret: false}, v);\n               }\n-              expr_loop_body(@expr {node: expr_fn_block(_, ref b, _), _}) => {\n+              expr_loop_body(@expr {node: expr_fn_block(_, ref b), _}) => {\n                 let proto = ty::ty_fn_proto(ty::expr_ty(tcx, e));\n                 let blk = (proto == ProtoBorrowed);\n                 (v.visit_block)((*b), {in_loop: true, can_ret: blk}, v);"}, {"sha": "406fdbaeac71cc3f285b0651c94fab2733d889e5", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 42, "deletions": 56, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -16,6 +16,7 @@ use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n use middle::typeck::method_map;\n+use middle::moves;\n use util::ppaux::ty_to_str;\n \n use core::cmp;\n@@ -34,10 +35,16 @@ use syntax::visit;\n pub struct MatchCheckCtxt {\n     tcx: ty::ctxt,\n     method_map: method_map,\n+    moves_map: moves::MovesMap\n }\n \n-pub fn check_crate(tcx: ty::ctxt, method_map: method_map, crate: @crate) {\n-    let cx = @MatchCheckCtxt { tcx: tcx, method_map: method_map };\n+pub fn check_crate(tcx: ty::ctxt,\n+                   method_map: method_map,\n+                   moves_map: moves::MovesMap,\n+                   crate: @crate) {\n+    let cx = @MatchCheckCtxt {tcx: tcx,\n+                              method_map: method_map,\n+                              moves_map: moves_map};\n     visit::visit_crate(*crate, (), visit::mk_vt(@visit::Visitor {\n         visit_expr: |a,b,c| check_expr(cx, a, b, c),\n         visit_local: |a,b,c| check_local(cx, a, b, c),\n@@ -53,13 +60,7 @@ pub fn expr_is_non_moving_lvalue(cx: @MatchCheckCtxt, expr: @expr) -> bool {\n         return false;\n     }\n \n-    match cx.tcx.value_modes.find(expr.id) {\n-        Some(MoveValue) => return false,\n-        Some(CopyValue) | Some(ReadValue) => return true,\n-        None => {\n-            cx.tcx.sess.span_bug(expr.span, ~\"no entry in value mode map\");\n-        }\n-    }\n+    !cx.moves_map.contains_key(expr.id)\n }\n \n pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n@@ -113,7 +114,7 @@ pub fn check_arms(cx: @MatchCheckCtxt, arms: ~[arm]) {\n     for arms.each |arm| {\n         for arm.pats.each |pat| {\n             let v = ~[*pat];\n-            match is_useful(cx, seen, v) {\n+            match is_useful(cx, copy seen, v) {\n               not_useful => {\n                 cx.tcx.sess.span_err(pat.span, ~\"unreachable pattern\");\n               }\n@@ -197,7 +198,7 @@ pub enum ctor {\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-pub fn is_useful(cx: @MatchCheckCtxt, +m: matrix, +v: ~[@pat]) -> useful {\n+pub fn is_useful(cx: @MatchCheckCtxt, +m: matrix, +v: &[@pat]) -> useful {\n     if m.len() == 0u { return useful_; }\n     if m[0].len() == 0u { return not_useful; }\n     let real_pat = match vec::find(m, |r| r[0].id != 0) {\n@@ -272,12 +273,12 @@ pub fn is_useful(cx: @MatchCheckCtxt, +m: matrix, +v: ~[@pat]) -> useful {\n \n pub fn is_useful_specialized(cx: @MatchCheckCtxt,\n                              m: matrix,\n-                             +v: ~[@pat],\n+                             +v: &[@pat],\n                              +ctor: ctor,\n                              arity: uint,\n                              lty: ty::t)\n                           -> useful {\n-    let ms = vec::filter_map(m, |r| specialize(cx, copy *r,\n+    let ms = vec::filter_map(m, |r| specialize(cx, *r,\n                                                ctor, arity, lty));\n     let could_be_useful = is_useful(\n         cx, ms, specialize(cx, v, ctor, arity, lty).get());\n@@ -467,7 +468,7 @@ pub fn wild() -> @pat {\n }\n \n pub fn specialize(cx: @MatchCheckCtxt,\n-                  +r: ~[@pat],\n+                  +r: &[@pat],\n                   ctor_id: ctor,\n                   arity: uint,\n                   left_ty: ty::t)\n@@ -729,21 +730,13 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n     for pats.each |pat| {\n         do pat_bindings(def_map, *pat) |bm, id, span, _path| {\n             match bm {\n+                bind_by_copy => {}\n                 bind_by_ref(_) => {\n                     by_ref_span = Some(span);\n                 }\n-                bind_by_move => {\n-                    any_by_move = true;\n-                }\n-                bind_by_value => {}\n                 bind_infer => {\n-                    match cx.tcx.value_modes.find(id) {\n-                        Some(MoveValue) => any_by_move = true,\n-                        Some(CopyValue) | Some(ReadValue) => {}\n-                        None => {\n-                            cx.tcx.sess.span_bug(span, ~\"no mode for pat \\\n-                                                         binding\");\n-                        }\n+                    if cx.moves_map.contains_key(id) {\n+                        any_by_move = true;\n                     }\n                 }\n             }\n@@ -781,61 +774,54 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n         do walk_pat(*pat) |p| {\n             if pat_is_binding(def_map, p) {\n                 match p.node {\n-                    pat_ident(bind_by_move, _, sub) => check_move(p, sub),\n-                    pat_ident(bind_infer, _, sub) => {\n-                        match tcx.value_modes.find(p.id) {\n-                            Some(MoveValue) => check_move(p, sub),\n-                            Some(CopyValue) | Some(ReadValue) => {}\n-                            None => {\n-                                cx.tcx.sess.span_bug(\n-                                    pat.span, ~\"no mode for pat binding\");\n-                            }\n+                    pat_ident(_, _, sub) => {\n+                        if cx.moves_map.contains_key(p.id) {\n+                            check_move(p, sub);\n                         }\n                     }\n-                    _ => {}\n+                    _ => {\n+                        cx.tcx.sess.span_bug(\n+                            p.span,\n+                            fmt!(\"Binding pattern %d is \\\n+                                  not an identifier: %?\",\n+                                 p.id, p.node));\n+                    }\n                 }\n             }\n         }\n \n         // Now check to ensure that any move binding is not behind an @ or &.\n         // This is always illegal.\n         let vt = visit::mk_vt(@visit::Visitor {\n-            visit_pat: |pat, behind_bad_pointer, v| {\n-                let error_out = || {\n-                    cx.tcx.sess.span_err(pat.span, ~\"by-move pattern \\\n-                                                     bindings may not occur \\\n-                                                     behind @ or & bindings\");\n-                };\n+            visit_pat: |pat, behind_bad_pointer: bool, v| {\n                 match pat.node {\n-                    pat_ident(binding_mode, _, sub) => {\n+                    pat_ident(_, _, sub) => {\n                         debug!(\"(check legality of move) checking pat \\\n                                 ident with behind_bad_pointer %?\",\n                                 behind_bad_pointer);\n-                        match binding_mode {\n-                            bind_by_move if behind_bad_pointer => error_out(),\n-                            bind_infer if behind_bad_pointer => {\n-                                match cx.tcx.value_modes.find(pat.id) {\n-                                    Some(MoveValue) => error_out(),\n-                                    Some(CopyValue) |\n-                                    Some(ReadValue) => {}\n-                                    None => {\n-                                        cx.tcx.sess.span_bug(pat.span,\n-                                            ~\"no mode for pat binding\");\n-                                    }\n-                                }\n-                            }\n-                            _ => {}\n+\n+                        if behind_bad_pointer &&\n+                            cx.moves_map.contains_key(pat.id)\n+                        {\n+                            cx.tcx.sess.span_err(\n+                                pat.span,\n+                                ~\"by-move pattern \\\n+                                  bindings may not occur \\\n+                                  behind @ or & bindings\");\n                         }\n+\n                         match sub {\n                             None => {}\n                             Some(subpat) => {\n                                 (v.visit_pat)(subpat, behind_bad_pointer, v);\n                             }\n                         }\n                     }\n+\n                     pat_box(subpat) | pat_region(subpat) => {\n                         (v.visit_pat)(subpat, true, v);\n                     }\n+\n                     _ => visit::visit_pat(pat, behind_bad_pointer, v)\n                 }\n             },"}, {"sha": "7edc345adc47e00317be3ab4973fcb429f9d59ee", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -413,8 +413,8 @@ pub fn lit_to_const(lit: @lit) -> const_val {\n }\n \n pub fn compare_const_vals(a: const_val, b: const_val) -> int {\n-  match (a, b) {\n-    (const_int(a), const_int(b)) => {\n+  match (&a, &b) {\n+    (&const_int(a), &const_int(b)) => {\n         if a == b {\n             0\n         } else if a < b {\n@@ -423,7 +423,7 @@ pub fn compare_const_vals(a: const_val, b: const_val) -> int {\n             1\n         }\n     }\n-    (const_uint(a), const_uint(b)) => {\n+    (&const_uint(a), &const_uint(b)) => {\n         if a == b {\n             0\n         } else if a < b {\n@@ -432,7 +432,7 @@ pub fn compare_const_vals(a: const_val, b: const_val) -> int {\n             1\n         }\n     }\n-    (const_float(a), const_float(b)) => {\n+    (&const_float(a), &const_float(b)) => {\n         if a == b {\n             0\n         } else if a < b {\n@@ -441,7 +441,7 @@ pub fn compare_const_vals(a: const_val, b: const_val) -> int {\n             1\n         }\n     }\n-    (const_str(ref a), const_str(ref b)) => {\n+    (&const_str(ref a), &const_str(ref b)) => {\n         if (*a) == (*b) {\n             0\n         } else if (*a) < (*b) {\n@@ -450,7 +450,7 @@ pub fn compare_const_vals(a: const_val, b: const_val) -> int {\n             1\n         }\n     }\n-    (const_bool(a), const_bool(b)) => {\n+    (&const_bool(a), &const_bool(b)) => {\n         if a == b {\n             0\n         } else if a < b {"}, {"sha": "68bb1db9af36d81525b256e3be0351b0f5af1571", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -48,7 +48,7 @@ fn collect_freevars(def_map: resolve::DefMap, blk: ast::blk)\n \n     let walk_expr = fn@(expr: @ast::expr, &&depth: int, v: visit::vt<int>) {\n             match expr.node {\n-              ast::expr_fn(proto, _, _, _) => {\n+              ast::expr_fn(proto, _, _) => {\n                 if proto != ast::ProtoBare {\n                     visit::visit_expr(expr, depth + 1, v);\n                 }\n@@ -123,6 +123,7 @@ pub fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n       Some(d) => return d\n     }\n }\n+\n pub fn has_freevars(tcx: ty::ctxt, fid: ast::node_id) -> bool {\n     return vec::len(*get_freevars(tcx, fid)) != 0u;\n }"}, {"sha": "8977052e029a77104fafb8ff084f363810312d84", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 106, "deletions": 294, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -15,7 +15,6 @@ use middle::freevars;\n use middle::lint::{non_implicitly_copyable_typarams, implicit_copies};\n use middle::liveness;\n use middle::pat_util;\n-use middle::ty::{CopyValue, MoveValue, ReadValue};\n use middle::ty::{Kind, kind_copyable, kind_noncopyable, kind_const};\n use middle::ty;\n use middle::typeck;\n@@ -102,8 +101,6 @@ pub fn check_crate(tcx: ty::ctxt,\n     let visit = visit::mk_vt(@visit::Visitor {\n         visit_arm: check_arm,\n         visit_expr: check_expr,\n-        visit_stmt: check_stmt,\n-        visit_block: check_block,\n         visit_fn: check_fn,\n         visit_ty: check_ty,\n         visit_item: fn@(i: @item, cx: ctx, v: visit::vt<ctx>) {\n@@ -115,75 +112,41 @@ pub fn check_crate(tcx: ty::ctxt,\n     tcx.sess.abort_if_errors();\n }\n \n-// bool flag is only used for checking closures,\n-// where it refers to whether a var is 'move' in the\n-// capture clause\n-pub type check_fn = fn@(ctx,\n-                        node_id,\n-                        Option<@freevar_entry>,\n-                        bool,\n-                        ty::t,\n-                        sp: span);\n+type check_fn = fn@(ctx, @freevar_entry);\n \n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the node_id for some expression that creates the\n // closure.\n-pub fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n-    fn check_for_uniq(cx: ctx, id: node_id, fv: Option<@freevar_entry>,\n-                      is_move: bool, var_t: ty::t, sp: span) {\n+fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n+    fn check_for_uniq(cx: ctx, fv: @freevar_entry) {\n         // all captured data must be sendable, regardless of whether it is\n         // moved in or copied in.  Note that send implies owned.\n-        if !check_send(cx, var_t, sp) { return; }\n-\n-        // copied in data must be copyable, but moved in data can be anything\n-        let is_implicit = fv.is_some();\n-        if !is_move {\n-            check_copy(cx, id, var_t, sp, is_implicit,\n-                       Some((\"non-copyable value cannot be copied into a \\\n-                              ~fn closure\",\n-                             \"to copy values into a ~fn closure, use a \\\n-                              capture clause: `fn~(copy x)` or `|copy x|`\")));\n-        }\n+        let id = ast_util::def_id_of_def(fv.def).node;\n+        let var_t = ty::node_id_to_type(cx.tcx, id);\n+        if !check_send(cx, var_t, fv.span) { return; }\n+\n         // check that only immutable variables are implicitly copied in\n-        for fv.each |fv| {\n-            check_imm_free_var(cx, fv.def, fv.span);\n-        }\n+        check_imm_free_var(cx, fv.def, fv.span);\n     }\n \n-    fn check_for_box(cx: ctx, id: node_id, fv: Option<@freevar_entry>,\n-                     is_move: bool, var_t: ty::t, sp: span) {\n+    fn check_for_box(cx: ctx, fv: @freevar_entry) {\n         // all captured data must be owned\n-        if !check_durable(cx.tcx, var_t, sp) { return; }\n-\n-        // copied in data must be copyable, but moved in data can be anything\n-        let is_implicit = fv.is_some();\n-        if !is_move {\n-            check_copy(cx, id, var_t, sp, is_implicit,\n-                       Some((\"non-copyable value cannot be copied into a \\\n-                              @fn closure\",\n-                             \"to copy values into a @fn closure, use a \\\n-                              capture clause: `fn~(copy x)` or `|copy x|`\")));\n-        }\n+        let id = ast_util::def_id_of_def(fv.def).node;\n+        let var_t = ty::node_id_to_type(cx.tcx, id);\n+        if !check_durable(cx.tcx, var_t, fv.span) { return; }\n+\n         // check that only immutable variables are implicitly copied in\n-        for fv.each |fv| {\n-            check_imm_free_var(cx, fv.def, fv.span);\n-        }\n+        check_imm_free_var(cx, fv.def, fv.span);\n     }\n \n-    fn check_for_block(cx: ctx, _id: node_id, fv: Option<@freevar_entry>,\n-                       _is_move: bool, _var_t: ty::t, sp: span) {\n-        // only restriction: no capture clauses (we would have to take\n-        // ownership of the moved/copied in data).\n-        if fv.is_none() {\n-            cx.tcx.sess.span_err(\n-                sp,\n-                ~\"cannot capture values explicitly with a block closure\");\n-        }\n+    fn check_for_block(_cx: ctx, _fv: @freevar_entry) {\n+        // no restrictions\n     }\n \n-    fn check_for_bare(cx: ctx, _id: node_id, _fv: Option<@freevar_entry>,\n-                      _is_move: bool, _var_t: ty::t, sp: span) {\n-        cx.tcx.sess.span_err(sp, ~\"attempted dynamic environment capture\");\n+    fn check_for_bare(cx: ctx, fv: @freevar_entry) {\n+        cx.tcx.sess.span_err(\n+            fv.span,\n+            ~\"attempted dynamic environment capture\");\n     }\n \n     let fty = ty::node_id_to_type(cx.tcx, id);\n@@ -197,68 +160,26 @@ pub fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n \n // Check that the free variables used in a shared/sendable closure conform\n // to the copy/move kind bounds. Then recursively check the function body.\n-pub fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n-                fn_id: node_id, cx: ctx, v: visit::vt<ctx>) {\n-    // Find the check function that enforces the appropriate bounds for this\n-    // kind of function:\n-    do with_appropriate_checker(cx, fn_id) |chk| {\n-\n-        // Begin by checking the variables in the capture clause, if any.\n-        // Here we slightly abuse the map function to both check and report\n-        // errors and produce a list of the def id's for all capture\n-        // variables.  This list is used below to avoid checking and reporting\n-        // on a given variable twice.\n-        let cap_clause = match fk {\n-            visit::fk_anon(_, cc) | visit::fk_fn_block(cc) => cc,\n-            visit::fk_item_fn(*) | visit::fk_method(*) |\n-            visit::fk_dtor(*) => @~[]\n-        };\n-        let captured_vars = do (*cap_clause).map |cap_item| {\n-            let cap_def = cx.tcx.def_map.get(cap_item.id);\n-            let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n-            let ty = ty::node_id_to_type(cx.tcx, cap_def_id);\n-            chk(cx, fn_id, None, cap_item.is_move, ty, cap_item.span);\n-            cap_def_id\n-        };\n+fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n+            fn_id: node_id, cx: ctx, v: visit::vt<ctx>) {\n \n-        // Iterate over any free variables that may not have appeared in the\n-        // capture list.  Ensure that they too are of the appropriate kind.\n+    // Check kinds on free variables:\n+    do with_appropriate_checker(cx, fn_id) |chk| {\n         for vec::each(*freevars::get_freevars(cx.tcx, fn_id)) |fv| {\n-            let id = ast_util::def_id_of_def(fv.def).node;\n-\n-            // skip over free variables that appear in the cap clause\n-            if captured_vars.contains(&id) { loop; }\n-\n-            let ty = ty::node_id_to_type(cx.tcx, id);\n-\n-            // is_move is true if this type implicitly moves and false\n-            // otherwise.\n-            let is_move = ty::type_implicitly_moves(cx.tcx, ty);\n-\n-            chk(cx, fn_id, Some(*fv), is_move, ty, fv.span);\n+            chk(cx, *fv);\n         }\n     }\n \n     visit::visit_fn(fk, decl, body, sp, fn_id, cx, v);\n }\n \n-pub fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n-    match b.node.expr {\n-      Some(ex) => maybe_copy(cx, ex,\n-         Some((\"Tail expressions in blocks must be copyable\",\n-                                  try_adding))),\n-      _ => ()\n-    }\n-    visit::visit_block(b, cx, v);\n-}\n-\n-pub fn check_arm(a: arm, cx: ctx, v: visit::vt<ctx>) {\n+fn check_arm(a: arm, cx: ctx, v: visit::vt<ctx>) {\n     for vec::each(a.pats) |p| {\n         do pat_util::pat_bindings(cx.tcx.def_map, *p) |mode, id, span, _pth| {\n-            if mode == bind_by_value {\n+            if mode == bind_by_copy {\n                 let t = ty::node_id_to_type(cx.tcx, id);\n                 let reason = \"consider binding with `ref` or `move` instead\";\n-                check_copy(cx, id, t, span, false, Some((reason,reason)));\n+                check_copy(cx, t, span, reason);\n             }\n         }\n     }\n@@ -267,14 +188,14 @@ pub fn check_arm(a: arm, cx: ctx, v: visit::vt<ctx>) {\n \n pub fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n     debug!(\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr()));\n-    let id_to_use = match e.node {\n+\n+    // Handle any kind bounds on type parameters\n+    let type_parameter_id = match e.node {\n         expr_index(*)|expr_assign_op(*)|\n         expr_unary(*)|expr_binary(*)|expr_method_call(*) => e.callee_id,\n         _ => e.id\n     };\n-\n-    // Handle any kind bounds on type parameters\n-    do option::iter(&cx.tcx.node_type_substs.find(id_to_use)) |ts| {\n+    do option::iter(&cx.tcx.node_type_substs.find(type_parameter_id)) |ts| {\n         let bounds = match e.node {\n           expr_path(_) => {\n             let did = ast_util::def_id_of_def(cx.tcx.def_map.get(e.id));\n@@ -299,137 +220,76 @@ pub fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n                       *bounds, (*bounds).len());\n         }\n         for vec::each2(*ts, *bounds) |ty, bound| {\n-            check_bounds(cx, id_to_use, e.span, *ty, *bound)\n+            check_bounds(cx, type_parameter_id, e.span, *ty, *bound)\n         }\n     }\n \n-    match /*bad*/copy e.node {\n-      expr_assign(_, ex) |\n-      expr_unary(box(_), ex) | expr_unary(uniq(_), ex) |\n-      expr_ret(Some(ex)) => {\n-        maybe_copy(cx, ex, Some((\"returned values must be copyable\",\n-                                 try_adding)));\n-      }\n-      expr_cast(source, _) => {\n-        maybe_copy(cx, source, Some((\"casted values must be copyable\",\n-                                     try_adding)));\n-        check_cast_for_escaping_regions(cx, source, e);\n-        check_kind_bounds_of_cast(cx, source, e);\n-      }\n-      expr_copy(expr) => check_copy_ex(cx, expr, false,\n-          Some((\"explicit copy requires a copyable argument\", \"\"))),\n-      // Vector add copies, but not \"implicitly\"\n-      expr_assign_op(_, _, ex) => check_copy_ex(cx, ex, false,\n-                                   Some((\"assignment with operation requires \\\n-                                          a copyable argument\", \"\"))),\n-      expr_binary(add, ls, rs) => {\n-        let reason = Some((\"binary operators require copyable arguments\",\n-                           \"\"));\n-        check_copy_ex(cx, ls, false, reason);\n-        check_copy_ex(cx, rs, false, reason);\n-      }\n-      expr_rec(ref fields, def) | expr_struct(_, ref fields, def) => {\n-        for (*fields).each |field| { maybe_copy(cx, field.node.expr,\n-                                   Some((\"record or struct fields require \\\n-                                          copyable arguments\", \"\"))); }\n-        match def {\n-          Some(ex) => {\n-            // All noncopyable fields must be overridden\n-            let t = ty::expr_ty(cx.tcx, ex);\n-            let ty_fields = match /*bad*/copy ty::get(t).sty {\n-              ty::ty_rec(f) => f,\n-              ty::ty_struct(did, ref substs) =>\n-                  ty::struct_fields(cx.tcx, did, &(*substs)),\n-              _ => cx.tcx.sess.span_bug(ex.span,\n-                                        ~\"bad base expr type in record\")\n-            };\n-            for ty_fields.each |tf| {\n-                if !vec::any((*fields), |f| f.node.ident == tf.ident ) &&\n-                    !ty::kind_can_be_copied(ty::type_kind(cx.tcx, tf.mt.ty)) {\n-                    cx.tcx.sess.span_err(e.span,\n-                                         ~\"copying a noncopyable value\");\n-                }\n-            }\n-          }\n-          _ => {}\n+    match e.node {\n+        expr_cast(source, _) => {\n+            check_cast_for_escaping_regions(cx, source, e);\n+            check_kind_bounds_of_cast(cx, source, e);\n         }\n-      }\n-      expr_tup(exprs) | expr_vec(exprs, _) => {\n-        for exprs.each |expr| { maybe_copy(cx, *expr,\n-                    Some((\"tuple or vec elements must be copyable\", \"\"))); }\n-      }\n-      expr_call(f, args, _) => {\n-        for ty::ty_fn_args(ty::expr_ty(cx.tcx, f)).eachi |i, arg_t| {\n-            match ty::arg_mode(cx.tcx, *arg_t) {\n-              by_copy => maybe_copy(cx, args[i],\n-                     Some((\"function arguments must be copyable\",\n-                           \"try changing the function to take a reference \\\n-                            instead\"))),\n-              by_ref | by_val | by_move => ()\n-            }\n+        expr_copy(expr) => {\n+            // Note: This is the only place where we must check whether the\n+            // argument is copyable.  This is not because this is the only\n+            // kind of expression that may copy things, but rather because all\n+            // other copies will have been converted to moves by by the\n+            // `moves` pass if the value is not copyable.\n+            check_copy(cx,\n+                       ty::expr_ty(cx.tcx, expr),\n+                       expr.span,\n+                       \"explicit copy requires a copyable argument\");\n         }\n-      }\n-      expr_method_call(_, _, _, args, _) => {\n-        for ty::ty_fn_args(ty::node_id_to_type(cx.tcx, e.callee_id)).eachi\n-                |i, arg_t| {\n-            match ty::arg_mode(cx.tcx, *arg_t) {\n-              by_copy => maybe_copy(cx, args[i],\n-                     Some((\"function arguments must be copyable\",\n-                           \"try changing the function to take a \\\n-                            reference instead\"))),\n-              by_ref | by_val | by_move => ()\n-            }\n-        }\n-      }\n-      expr_field(lhs, _, _) => {\n-        // If this is a method call with a by-val argument, we need\n-        // to check the copy\n-        match cx.method_map.find(e.id) {\n-            Some(ref mme) => {\n-                match ty::arg_mode(cx.tcx, mme.self_arg) {\n-                    by_copy => maybe_copy(cx, lhs,\n-                      Some((\"method call takes its self argument by copy\",\n-                            \"\"))),\n-                    by_ref | by_val | by_move => ()\n+        expr_rec(ref fields, def) | expr_struct(_, ref fields, def) => {\n+            match def {\n+                Some(ex) => {\n+                    // All noncopyable fields must be overridden\n+                    let t = ty::expr_ty(cx.tcx, ex);\n+                    let ty_fields = match ty::get(t).sty {\n+                        ty::ty_rec(ref f) => {\n+                            copy *f\n+                        }\n+                        ty::ty_struct(did, ref substs) => {\n+                            ty::struct_fields(cx.tcx, did, substs)\n+                        }\n+                        _ => {\n+                            cx.tcx.sess.span_bug(\n+                                ex.span,\n+                                ~\"bad base expr type in record\")\n+                        }\n+                    };\n+                    for ty_fields.each |tf| {\n+                        // If this field would not be copied, ok.\n+                        if fields.any(|f| f.node.ident == tf.ident) { loop; }\n+\n+                        // If this field is copyable, ok.\n+                        let kind = ty::type_kind(cx.tcx, tf.mt.ty);\n+                        if ty::kind_can_be_copied(kind) { loop; }\n+\n+                        cx.tcx.sess.span_err(\n+                            e.span,\n+                            fmt!(\"cannot copy field `%s` of base expression, \\\n+                                  which has a noncopyable type\",\n+                                 *cx.tcx.sess.intr().get(tf.ident)));\n+                    }\n                 }\n+                _ => {}\n             }\n-            _ => ()\n         }\n-      }\n-      expr_repeat(element, count_expr, _) => {\n-        let count = ty::eval_repeat_count(cx.tcx, count_expr, e.span);\n-        if count == 1 {\n-            maybe_copy(cx, element, Some((\"trivial repeat takes its element \\\n-                                           by copy\", \"\")));\n-        } else {\n-            let element_ty = ty::expr_ty(cx.tcx, element);\n-            check_copy(cx, element.id, element_ty, element.span, true,\n-                       Some((\"repeat takes its elements by copy\", \"\")));\n-        }\n-      }\n-      _ => { }\n-    }\n-    visit::visit_expr(e, cx, v);\n-}\n-\n-pub fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n-    match stmt.node {\n-      stmt_decl(@spanned {node: decl_local(ref locals), _}, _) => {\n-        for locals.each |local| {\n-            match local.node.init {\n-              Some(expr) =>\n-                  maybe_copy(cx, expr, Some((\"initializer statement \\\n-                              takes its right-hand side by copy\", \"\"))),\n-              _ => {}\n+        expr_repeat(element, count_expr, _) => {\n+            let count = ty::eval_repeat_count(cx.tcx, count_expr, e.span);\n+            if count > 1 {\n+                let element_ty = ty::expr_ty(cx.tcx, element);\n+                check_copy(cx, element_ty, element.span,\n+                           \"repeated element will be copied\");\n             }\n         }\n-      }\n-      _ => {}\n+        _ => {}\n     }\n-    visit::visit_stmt(stmt, cx, v);\n+    visit::visit_expr(e, cx, v);\n }\n \n-pub fn check_ty(aty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n+fn check_ty(aty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n     match aty.node {\n       ty_path(_, id) => {\n         do option::iter(&cx.tcx.node_type_substs.find(id)) |ts| {\n@@ -471,11 +331,7 @@ pub fn check_bounds(cx: ctx, id: node_id, sp: span,\n     }\n }\n \n-pub fn maybe_copy(cx: ctx, ex: @expr, why: Option<(&str,&str)>) {\n-    check_copy_ex(cx, ex, true, why);\n-}\n-\n-pub fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n+fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n     match ex.node {\n       expr_path(_) => {\n         match cx.tcx.def_map.get(ex.id) {\n@@ -489,75 +345,31 @@ pub fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n     }\n }\n \n-pub fn check_copy_ex(cx: ctx, ex: @expr, implicit_copy: bool,\n-                     why: Option<(&str,&str)>) {\n-    if ty::expr_is_lval(cx.tcx, cx.method_map, ex) &&\n-\n-        // a reference to a constant like `none`... no need to warn\n-        // about *this* even if the type is Option<~int>\n-        !is_nullary_variant(cx, ex) &&\n-\n-        // borrowed unique value isn't really a copy\n-        !is_autorefd(cx, ex)\n-    {\n-        match cx.tcx.value_modes.find(ex.id) {\n-            None => cx.tcx.sess.span_bug(ex.span, ~\"no value mode for lval\"),\n-            Some(MoveValue) | Some(ReadValue) => {} // Won't be a copy.\n-            Some(CopyValue) => {\n-                debug!(\"(kind checking) is a copy value: `%s`\",\n-                       expr_to_str(ex, cx.tcx.sess.intr()));\n-                let ty = ty::expr_ty(cx.tcx, ex);\n-                check_copy(cx, ex.id, ty, ex.span, implicit_copy, why);\n+fn check_imm_free_var(cx: ctx, def: def, sp: span) {\n+    match def {\n+        def_local(_, is_mutbl) => {\n+            if is_mutbl {\n+                cx.tcx.sess.span_err(\n+                    sp,\n+                    ~\"mutable variables cannot be implicitly captured\");\n             }\n         }\n-    }\n-\n-    fn is_autorefd(cx: ctx, ex: @expr) -> bool {\n-        match cx.tcx.adjustments.find(ex.id) {\n-            None => false,\n-            Some(ref adj) => adj.autoref.is_some()\n-        }\n-    }\n-}\n-\n-pub fn check_imm_free_var(cx: ctx, def: def, sp: span) {\n-    let msg = ~\"mutable variables cannot be implicitly captured; \\\n-               use a capture clause\";\n-    match def {\n-      def_local(_, is_mutbl) => {\n-        if is_mutbl {\n-            cx.tcx.sess.span_err(sp, msg);\n+        def_arg(*) => { /* ok */ }\n+        def_upvar(_, def1, _, _) => { check_imm_free_var(cx, *def1, sp); }\n+        def_binding(*) | def_self(*) => { /*ok*/ }\n+        _ => {\n+            cx.tcx.sess.span_bug(\n+                sp,\n+                fmt!(\"unknown def for free variable: %?\", def));\n         }\n-      }\n-      def_arg(*) => { /* ok */ }\n-      def_upvar(_, def1, _, _) => {\n-        check_imm_free_var(cx, *def1, sp);\n-      }\n-      def_binding(*) | def_self(*) => { /*ok*/ }\n-      _ => {\n-        cx.tcx.sess.span_bug(\n-            sp,\n-            fmt!(\"unknown def for free variable: %?\", def));\n-      }\n     }\n }\n \n-pub fn check_copy(cx: ctx, id: node_id, ty: ty::t, sp: span,\n-                  implicit_copy: bool, why: Option<(&str,&str)>) {\n+fn check_copy(cx: ctx, ty: ty::t, sp: span, reason: &str) {\n     let k = ty::type_kind(cx.tcx, ty);\n     if !ty::kind_can_be_copied(k) {\n         cx.tcx.sess.span_err(sp, ~\"copying a noncopyable value\");\n-        do why.map |reason| {\n-            cx.tcx.sess.span_note(sp, fmt!(\"%s\", reason.first()));\n-        };\n-    } else if implicit_copy && !ty::kind_can_be_implicitly_copied(k) {\n-        cx.tcx.sess.span_lint(\n-            implicit_copies, id, cx.current_item,\n-            sp,\n-            ~\"implicitly copying a non-implicitly-copyable value\");\n-        do why.map |reason| {\n-            cx.tcx.sess.span_note(sp, fmt!(\"%s\", reason.second()));\n-        };\n+        cx.tcx.sess.span_note(sp, fmt!(\"%s\", reason));\n     }\n }\n "}, {"sha": "6d691438359e26413ef0af52bc4eb00c3047c732", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -352,7 +352,7 @@ impl LanguageItemCollector {\n             return;    // Didn't match.\n         }\n \n-        match self.item_refs.find(value) {\n+        match self.item_refs.find(/*bad*/copy value) {\n             None => {\n                 // Didn't match.\n             }"}, {"sha": "1bc3827586c3d7a0193c2b5b0c53a984bb05ebb3", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -344,7 +344,7 @@ impl ctxt {\n \n         for triples.each |pair| {\n             let (meta, level, lintname) = /*bad*/copy *pair;\n-            match self.dict.find(lintname) {\n+            match self.dict.find(/*bad*/ copy lintname) {\n               None => {\n                 self.span_lint(\n                     new_ctxt.get_level(unrecognized_lint),\n@@ -518,9 +518,9 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n \n     fn check_limits(cx: ty::ctxt, binop: ast::binop, l: &ast::expr,\n                     r: &ast::expr) -> bool {\n-        let (lit, expr, swap) = match (l.node, r.node) {\n-            (ast::expr_lit(_), _) => (l, r, true),\n-            (_, ast::expr_lit(_)) => (r, l, false),\n+        let (lit, expr, swap) = match (&l.node, &r.node) {\n+            (&ast::expr_lit(_), _) => (l, r, true),\n+            (_, &ast::expr_lit(_)) => (r, l, false),\n             _ => return true\n         };\n         // Normalize the binop so that the literal is always on the RHS in"}, {"sha": "e5e0181bd3cec1b3d519a045b9e322f1d703194d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 146, "deletions": 161, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -105,12 +105,11 @@\n \n use core::prelude::*;\n \n-use middle::capture::{cap_move, cap_drop, cap_copy, cap_ref};\n-use middle::capture;\n use middle::pat_util;\n-use middle::ty::MoveValue;\n use middle::ty;\n use middle::typeck;\n+use middle::moves;\n+use util::ppaux::ty_to_str;\n \n use core::cmp;\n use core::dvec::DVec;\n@@ -203,6 +202,8 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n \n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n+                   variable_moves_map: moves::VariableMovesMap,\n+                   capture_map: moves::CaptureMap,\n                    crate: @crate) -> last_use_map {\n     let visitor = visit::mk_vt(@visit::Visitor {\n         visit_fn: visit_fn,\n@@ -213,7 +214,8 @@ pub fn check_crate(tcx: ty::ctxt,\n     });\n \n     let last_use_map = HashMap();\n-    let initial_maps = @IrMaps(tcx, method_map, last_use_map);\n+    let initial_maps = @IrMaps(tcx, method_map, variable_moves_map,\n+                               capture_map, last_use_map);\n     visit::visit_crate(*crate, initial_maps, visitor);\n     tcx.sess.abort_if_errors();\n     return last_use_map;\n@@ -294,28 +296,35 @@ fn relevant_def(def: def) -> Option<node_id> {\n struct IrMaps {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n+    variable_moves_map: moves::VariableMovesMap,\n+    capture_map: moves::CaptureMap,\n     last_use_map: last_use_map,\n \n     mut num_live_nodes: uint,\n     mut num_vars: uint,\n     live_node_map: HashMap<node_id, LiveNode>,\n     variable_map: HashMap<node_id, Variable>,\n-    capture_map: HashMap<node_id, @~[CaptureInfo]>,\n+    capture_info_map: HashMap<node_id, @~[CaptureInfo]>,\n     mut var_kinds: ~[VarKind],\n     mut lnks: ~[LiveNodeKind],\n }\n \n-fn IrMaps(tcx: ty::ctxt, method_map: typeck::method_map,\n+fn IrMaps(tcx: ty::ctxt,\n+          method_map: typeck::method_map,\n+          variable_moves_map: moves::VariableMovesMap,\n+          capture_map: moves::CaptureMap,\n           last_use_map: last_use_map) -> IrMaps {\n     IrMaps {\n         tcx: tcx,\n         method_map: method_map,\n+        variable_moves_map: variable_moves_map,\n+        capture_map: capture_map,\n         last_use_map: last_use_map,\n         num_live_nodes: 0,\n         num_vars: 0,\n         live_node_map: HashMap(),\n         variable_map: HashMap(),\n-        capture_map: HashMap(),\n+        capture_info_map: HashMap(),\n         var_kinds: ~[],\n         lnks: ~[]\n     }\n@@ -377,11 +386,11 @@ impl IrMaps {\n     }\n \n     fn set_captures(node_id: node_id, +cs: ~[CaptureInfo]) {\n-        self.capture_map.insert(node_id, @cs);\n+        self.capture_info_map.insert(node_id, @cs);\n     }\n \n     fn captures(expr: @expr) -> @~[CaptureInfo] {\n-        match self.capture_map.find(expr.id) {\n+        match self.capture_info_map.find(expr.id) {\n           Some(caps) => caps,\n           None => {\n             self.tcx.sess.span_bug(expr.span, ~\"no registered caps\");\n@@ -397,7 +406,6 @@ impl IrMaps {\n         let vk = self.var_kinds[*var];\n         debug!(\"Node %d is a last use of variable %?\", expr_id, vk);\n         match vk {\n-          Arg(id, _, by_move) |\n           Arg(id, _, by_copy) |\n           Local(LocalInfo {id: id, kind: FromLetNoInitializer, _}) |\n           Local(LocalInfo {id: id, kind: FromLetWithInitializer, _}) |\n@@ -427,7 +435,10 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     let _i = ::util::common::indenter();\n \n     // swap in a new set of IR maps for this function body:\n-    let fn_maps = @IrMaps(self.tcx, self.method_map,\n+    let fn_maps = @IrMaps(self.tcx,\n+                          self.method_map,\n+                          self.variable_moves_map,\n+                          self.capture_map,\n                           self.last_use_map);\n \n     debug!(\"creating fn_maps: %x\", ptr::addr_of(&(*fn_maps)) as uint);\n@@ -548,8 +559,8 @@ fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n         }\n         visit::visit_expr(expr, self, vt);\n       }\n-      expr_fn(_, _, _, cap_clause) |\n-      expr_fn_block(_, _, cap_clause) => {\n+      expr_fn(_, _, _) |\n+      expr_fn_block(_, _) => {\n         // Interesting control flow (for loops can contain labeled\n         // breaks or continues)\n         self.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -558,17 +569,18 @@ fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n         // being the location that the variable is used.  This results\n         // in better error messages than just pointing at the closure\n         // construction site.\n-        let proto = ty::ty_fn_proto(ty::expr_ty(self.tcx, expr));\n-        let cvs = capture::compute_capture_vars(self.tcx, expr.id, proto,\n-                                                cap_clause);\n+        let cvs = self.capture_map.get(expr.id);\n         let mut call_caps = ~[];\n         for cvs.each |cv| {\n             match relevant_def(cv.def) {\n               Some(rv) => {\n                 let cv_ln = self.add_live_node(FreeVarNode(cv.span));\n                 let is_move = match cv.mode {\n-                  cap_move | cap_drop => true, // var must be dead afterwards\n-                  cap_copy | cap_ref => false // var can still be used\n+                    // var must be dead afterwards\n+                    moves::CapMove => true,\n+\n+                    // var can stil be used\n+                    moves::CapCopy | moves::CapRef => false\n                 };\n                 call_caps.push(CaptureInfo {ln: cv_ln,\n                                             is_move: is_move,\n@@ -600,7 +612,7 @@ fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n       expr_loop_body(*) | expr_do_body(*) | expr_cast(*) |\n       expr_unary(*) | expr_fail(*) |\n       expr_break(_) | expr_again(_) | expr_lit(_) | expr_ret(*) |\n-      expr_block(*) | expr_unary_move(*) | expr_assign(*) |\n+      expr_block(*) | expr_assign(*) |\n       expr_swap(*) | expr_assign_op(*) | expr_mac(*) | expr_struct(*) |\n       expr_repeat(*) | expr_paren(*) => {\n           visit::visit_expr(expr, self, vt);\n@@ -700,7 +712,7 @@ impl Liveness {\n     }\n \n     fn variable(node_id: node_id, span: span) -> Variable {\n-        (*self.ir).variable(node_id, span)\n+        self.ir.variable(node_id, span)\n     }\n \n     fn variable_from_def_map(node_id: node_id,\n@@ -760,7 +772,7 @@ impl Liveness {\n \n         assert ln.is_valid();\n         let reader = self.users[self.idx(ln, var)].reader;\n-        if reader.is_valid() {Some((*self.ir).lnk(reader))} else {None}\n+        if reader.is_valid() {Some(self.ir.lnk(reader))} else {None}\n     }\n \n     /*\n@@ -782,7 +794,7 @@ impl Liveness {\n \n         assert ln.is_valid();\n         let writer = self.users[self.idx(ln, var)].writer;\n-        if writer.is_valid() {Some((*self.ir).lnk(writer))} else {None}\n+        if writer.is_valid() {Some(self.ir.lnk(writer))} else {None}\n     }\n \n     fn assigned_on_exit(ln: LiveNode, var: Variable)\n@@ -980,21 +992,22 @@ impl Liveness {\n         // inputs passed by & mode should be considered live on exit:\n         for decl.inputs.each |arg| {\n             match ty::resolved_mode(self.tcx, arg.mode) {\n-              by_ref | by_val => {\n-                // These are \"non-owned\" modes, so register a read at\n-                // the end.  This will prevent us from moving out of\n-                // such variables but also prevent us from registering\n-                // last uses and so forth.\n-                do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n-                        |_bm, arg_id, _sp, _path| {\n-                    let var = self.variable(arg_id, blk.span);\n-                    self.acc(self.s.exit_ln, var, ACC_READ);\n+                by_val | by_ref => {\n+                    // By val and by ref do not own, so register a\n+                    // read at the end.  This will prevent us from\n+                    // moving out of such variables but also prevent\n+                    // us from registering last uses and so forth.\n+                    do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n+                        |_bm, arg_id, _sp, _path|\n+                    {\n+                        let var = self.variable(arg_id, blk.span);\n+                        self.acc(self.s.exit_ln, var, ACC_READ);\n+                    }\n+                }\n+                by_copy => {\n+                    // By copy is an owned mode.  If we don't use the\n+                    // variable, nobody will.\n                 }\n-              }\n-              by_move | by_copy => {\n-                // These are owned modes.  If we don't use the\n-                // variable, nobody will.\n-              }\n             }\n         }\n \n@@ -1092,7 +1105,7 @@ impl Liveness {\n               self.propagate_through_expr(e, succ)\n           }\n \n-          expr_fn(_, _, ref blk, _) | expr_fn_block(_, ref blk, _) => {\n+          expr_fn(_, _, ref blk) | expr_fn_block(_, ref blk) => {\n               debug!(\"%s is an expr_fn or expr_fn_block\",\n                    expr_to_str(expr, self.tcx.sess.intr()));\n \n@@ -1105,8 +1118,8 @@ impl Liveness {\n \n                  // the construction of a closure itself is not important,\n                  // but we have to consider the closed over variables.\n-                 let caps = (*self.ir).captures(expr);\n-                 do (*caps).foldr(succ) |cap, succ| {\n+                 let caps = self.ir.captures(expr);\n+                 do caps.foldr(succ) |cap, succ| {\n                      self.init_from_succ(cap.ln, succ);\n                      let var = self.variable(cap.var_nid, expr.span);\n                      self.acc(cap.ln, var, ACC_READ | ACC_USE);\n@@ -1315,7 +1328,6 @@ impl Liveness {\n           expr_assert(e) |\n           expr_addr_of(_, e) |\n           expr_copy(e) |\n-          expr_unary_move(e) |\n           expr_loop_body(e) |\n           expr_do_body(e) |\n           expr_cast(e, _) |\n@@ -1541,46 +1553,19 @@ fn check_arm(arm: arm, &&self: @Liveness, vt: vt<@Liveness>) {\n     visit::visit_arm(arm, self, vt);\n }\n \n-fn check_call(args: &[@expr],\n-              targs: &[ty::arg],\n-              &&self: @Liveness) {\n-    for vec::each2(args, targs) |arg_expr, arg_ty| {\n-        match ty::resolved_mode(self.tcx, arg_ty.mode) {\n-            by_val | by_copy | by_ref => {}\n-            by_move => {\n-                if ty::expr_is_lval(self.tcx, self.ir.method_map, *arg_expr) {\n-                    // Probably a bad error message (what's an rvalue?)\n-                    // but I can't think of anything better\n-                    self.tcx.sess.span_err(arg_expr.span,\n-                      fmt!(\"move mode argument must be an rvalue: try (move \\\n-                            %s) instead\",\n-                           expr_to_str(*arg_expr, self.tcx.sess.intr())));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n     match /*bad*/copy expr.node {\n       expr_path(_) => {\n         for self.variable_from_def_map(expr.id, expr.span).each |var| {\n             let ln = self.live_node(expr.id, expr.span);\n             self.consider_last_use(expr, ln, *var);\n \n-            match self.tcx.value_modes.find(expr.id) {\n-                Some(MoveValue) => {\n+            match self.ir.variable_moves_map.find(expr.id) {\n+                None => {}\n+                Some(entire_expr) => {\n                     debug!(\"(checking expr) is a move: `%s`\",\n                            expr_to_str(expr, self.tcx.sess.intr()));\n-                    self.check_move_from_var(expr.span, ln, *var);\n-                }\n-                Some(v) => {\n-                    debug!(\"(checking expr) not a move (%?): `%s`\",\n-                           v,\n-                           expr_to_str(expr, self.tcx.sess.intr()));\n-                }\n-                None => {\n-                    fail ~\"no mode for lval\";\n+                    self.check_move_from_var(ln, *var, entire_expr);\n                 }\n             }\n         }\n@@ -1589,12 +1574,12 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n       }\n \n       expr_fn(*) | expr_fn_block(*) => {\n-        let caps = (*self.ir).captures(expr);\n-        for (*caps).each |cap| {\n+        let caps = self.ir.captures(expr);\n+        for caps.each |cap| {\n             let var = self.variable(cap.var_nid, expr.span);\n             self.consider_last_use(expr, cap.ln, var);\n             if cap.is_move {\n-                self.check_move_from_var(expr.span, cap.ln, var);\n+                self.check_move_from_var(cap.ln, var, expr);\n             }\n         }\n \n@@ -1608,32 +1593,14 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n         visit::visit_expr(expr, self, vt);\n       }\n \n-      expr_unary_move(r) => {\n-        self.check_move_from_expr(r, vt);\n-\n-        visit::visit_expr(expr, self, vt);\n-      }\n-\n       expr_assign_op(_, l, _) => {\n         self.check_lvalue(l, vt);\n \n         visit::visit_expr(expr, self, vt);\n       }\n \n-      expr_call(f, args, _) => {\n-        let targs = ty::ty_fn_args(ty::expr_ty(self.tcx, f));\n-        check_call(args, targs, self);\n-        visit::visit_expr(expr, self, vt);\n-      }\n-\n-      expr_method_call(_, _, _, args, _) => {\n-        let targs = ty::ty_fn_args(ty::node_id_to_type(self.tcx,\n-                                                       expr.callee_id));\n-        check_call(args, targs, self);\n-        visit::visit_expr(expr, self, vt);\n-      }\n-\n       // no correctness conditions related to liveness\n+      expr_call(*) | expr_method_call(*) |\n       expr_if(*) | expr_match(*) |\n       expr_while(*) | expr_loop(*) |\n       expr_index(*) | expr_field(*) | expr_vstore(*) |\n@@ -1659,7 +1626,8 @@ fn check_fn(_fk: visit::fn_kind, _decl: fn_decl,\n enum ReadKind {\n     PossiblyUninitializedVariable,\n     PossiblyUninitializedField,\n-    MovedValue\n+    MovedValue,\n+    PartiallyMovedValue\n }\n \n impl @Liveness {\n@@ -1683,17 +1651,28 @@ impl @Liveness {\n         }\n     }\n \n-    /*\n-    Checks whether <var> is live on entry to any of the successors of <ln>.\n-    If it is, report an error.\n-    */\n-    fn check_move_from_var(span: span, ln: LiveNode, var: Variable) {\n+    fn check_move_from_var(ln: LiveNode,\n+                           var: Variable,\n+                           move_expr: @expr)\n+    {\n+        /*!\n+         *\n+         * Checks whether `var` is live on entry to any of the\n+         * successors of `ln`.  If it is, report an error.\n+         * `move_expr` is the expression which caused the variable\n+         * to be moved.\n+         *\n+         * Note that `move_expr` is not necessarily a reference to the\n+         * variable.  It might be an expression like `x.f` which could\n+         * cause a move of the variable `x`, or a closure creation.\n+         */\n+\n         debug!(\"check_move_from_var(%s, %s)\",\n                ln.to_str(), var.to_str());\n \n         match self.live_on_exit(ln, var) {\n           None => {}\n-          Some(lnk) => self.report_illegal_move(span, lnk, var)\n+          Some(lnk) => self.report_illegal_move(lnk, var, move_expr)\n         }\n     }\n \n@@ -1703,48 +1682,7 @@ impl @Liveness {\n \n         match self.live_on_exit(ln, var) {\n           Some(_) => {}\n-          None => (*self.ir).add_last_use(expr.id, var)\n-       }\n-    }\n-\n-    fn check_move_from_expr(expr: @expr, vt: vt<@Liveness>) {\n-        debug!(\"check_move_from_expr(node %d: %s)\",\n-               expr.id, expr_to_str(expr, self.tcx.sess.intr()));\n-\n-        if self.ir.method_map.contains_key(expr.id) {\n-            // actually an rvalue, since this calls a method\n-            return;\n-        }\n-\n-        match expr.node {\n-          expr_path(_) => {\n-            match self.variable_from_path(expr) {\n-              Some(var) => {\n-                let ln = self.live_node(expr.id, expr.span);\n-                self.check_move_from_var(expr.span, ln, var);\n-              }\n-              None => {}\n-            }\n-          }\n-\n-          expr_field(base, _, _) => {\n-            // Moving from x.y is allowed if x is never used later.\n-            // (Note that the borrowck guarantees that anything\n-            //  being moved from is uniquely tied to the stack frame)\n-            self.check_move_from_expr(base, vt);\n-          }\n-\n-          expr_index(base, _) => {\n-            // Moving from x[y] is allowed if x is never used later.\n-            // (Note that the borrowck guarantees that anything\n-            //  being moved from is uniquely tied to the stack frame)\n-            self.check_move_from_expr(base, vt);\n-          }\n-\n-          _ => {\n-            // For other kinds of lvalues, no checks are required,\n-            // and any embedded expressions are actually rvalues\n-          }\n+          None => self.ir.add_last_use(expr.id, var)\n        }\n     }\n \n@@ -1808,50 +1746,98 @@ impl @Liveness {\n         }\n     }\n \n-    fn report_illegal_move(move_span: span,\n-                           lnk: LiveNodeKind,\n-                           var: Variable) {\n-\n-        // the only time that it is possible to have a moved value\n+    fn report_illegal_move(lnk: LiveNodeKind,\n+                           var: Variable,\n+                           move_expr: @expr)\n+    {\n+        // the only time that it is possible to have a moved variable\n         // used by ExitNode would be arguments or fields in a ctor.\n         // we give a slightly different error message in those cases.\n         if lnk == ExitNode {\n+            // XXX this seems like it should be reported in the borrow checker\n             let vk = self.ir.var_kinds[*var];\n             match vk {\n               Arg(_, name, _) => {\n                 self.tcx.sess.span_err(\n-                    move_span,\n+                    move_expr.span,\n                     fmt!(\"illegal move from argument `%s`, which is not \\\n                           copy or move mode\", self.tcx.sess.str_of(name)));\n                 return;\n               }\n               Local(*) | ImplicitRet => {\n                 self.tcx.sess.span_bug(\n-                    move_span,\n+                    move_expr.span,\n                     fmt!(\"illegal reader (%?) for `%?`\",\n                          lnk, vk));\n               }\n             }\n         }\n \n-        self.report_illegal_read(move_span, lnk, var, MovedValue);\n-        self.tcx.sess.span_note(\n-            move_span, ~\"move of value occurred here\");\n+        match move_expr.node {\n+            expr_fn(*) | expr_fn_block(*) => {\n+                self.report_illegal_read(\n+                    move_expr.span, lnk, var, MovedValue);\n+                let name = self.ir.variable_name(var);\n+                self.tcx.sess.span_note(\n+                    move_expr.span,\n+                    fmt!(\"`%s` moved into closure environment here \\\n+                          because its type is moved by default\",\n+                         name));\n+            }\n+            expr_path(*) => {\n+                self.report_illegal_read(\n+                    move_expr.span, lnk, var, MovedValue);\n+                self.report_move_location(\n+                    move_expr, var, \"\", \"it\");\n+            }\n+            expr_field(*) => {\n+                self.report_illegal_read(\n+                    move_expr.span, lnk, var, PartiallyMovedValue);\n+                self.report_move_location(\n+                    move_expr, var, \"field of \", \"the field\");\n+            }\n+            expr_index(*) => {\n+                self.report_illegal_read(\n+                    move_expr.span, lnk, var, PartiallyMovedValue);\n+                self.report_move_location(\n+                    move_expr, var, \"element of \", \"the element\");\n+            }\n+            _ => {\n+                self.report_illegal_read(\n+                    move_expr.span, lnk, var, PartiallyMovedValue);\n+                self.report_move_location(\n+                    move_expr, var, \"subcomponent of \", \"the subcomponent\");\n+            }\n+        };\n+    }\n \n+    fn report_move_location(move_expr: @expr,\n+                            var: Variable,\n+                            expr_descr: &str,\n+                            pronoun: &str)\n+    {\n+        let move_expr_ty = ty::expr_ty(self.tcx, move_expr);\n+        let name = self.ir.variable_name(var);\n+        self.tcx.sess.span_note(\n+            move_expr.span,\n+            fmt!(\"%s`%s` moved here because %s has type %s, \\\n+                  which is moved by default (use `copy` to override)\",\n+                 expr_descr, name, pronoun,\n+                 ty_to_str(self.tcx, move_expr_ty)));\n     }\n \n     fn report_illegal_read(chk_span: span,\n                            lnk: LiveNodeKind,\n                            var: Variable,\n                            rk: ReadKind) {\n         let msg = match rk {\n-          PossiblyUninitializedVariable => {\n-            ~\"possibly uninitialized variable\"\n-          }\n-          PossiblyUninitializedField => ~\"possibly uninitialized field\",\n-          MovedValue => ~\"moved value\"\n+            PossiblyUninitializedVariable => \"possibly uninitialized \\\n+                                              variable\",\n+            PossiblyUninitializedField => \"possibly uninitialized field\",\n+            MovedValue => \"moved value\",\n+            PartiallyMovedValue => \"partially moved value\"\n         };\n-        let name = (*self.ir).variable_name(var);\n+        let name = self.ir.variable_name(var);\n         match lnk {\n           FreeVarNode(span) => {\n             self.tcx.sess.span_err(\n@@ -1863,8 +1849,7 @@ impl @Liveness {\n                 span,\n                 fmt!(\"use of %s: `%s`\", msg, name));\n           }\n-          ExitNode |\n-          VarDefNode(_) => {\n+          ExitNode | VarDefNode(_) => {\n             self.tcx.sess.span_bug(\n                 chk_span,\n                 fmt!(\"illegal reader: %?\", lnk));\n@@ -1873,7 +1858,7 @@ impl @Liveness {\n     }\n \n     fn should_warn(var: Variable) -> Option<~str> {\n-        let name = (*self.ir).variable_name(var);\n+        let name = self.ir.variable_name(var);\n         if name[0] == ('_' as u8) {None} else {Some(name)}\n     }\n "}, {"sha": "625b9889aad72f44610793d8808ce27e821e9efc", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -394,7 +394,7 @@ pub impl &mem_categorization_ctxt {\n           ast::expr_block(*) | ast::expr_loop(*) | ast::expr_match(*) |\n           ast::expr_lit(*) | ast::expr_break(*) | ast::expr_mac(*) |\n           ast::expr_again(*) | ast::expr_rec(*) | ast::expr_struct(*) |\n-          ast::expr_unary_move(*) | ast::expr_repeat(*) => {\n+          ast::expr_repeat(*) => {\n             return self.cat_rvalue(expr, expr_ty);\n           }\n         }\n@@ -430,20 +430,16 @@ pub impl &mem_categorization_ctxt {\n             // lp: loan path, must be none for aliasable things\n             let m = if mutbl {m_mutbl} else {m_imm};\n             let lp = match ty::resolved_mode(self.tcx, mode) {\n-              ast::by_move | ast::by_copy => {\n-                Some(@lp_arg(vid))\n-              }\n-              ast::by_ref => {\n-                None\n-              }\n-              ast::by_val => {\n-                // by-value is this hybrid mode where we have a\n-                // pointer but we do not own it.  This is not\n-                // considered loanable because, for example, a by-ref\n-                // and and by-val argument might both actually contain\n-                // the same unique ptr.\n-                None\n-              }\n+                ast::by_copy => Some(@lp_arg(vid)),\n+                ast::by_ref => None,\n+                ast::by_val => {\n+                    // by-value is this hybrid mode where we have a\n+                    // pointer but we do not own it.  This is not\n+                    // considered loanable because, for example, a by-ref\n+                    // and and by-val argument might both actually contain\n+                    // the same unique ptr.\n+                    None\n+                }\n             };\n             @cmt_ {\n                 id:id,"}, {"sha": "149821db28938b9b6d28e233306d8f1db37c8362", "filename": "src/librustc/middle/mode.rs", "status": "removed", "additions": 0, "deletions": 281, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Flibrustc%2Fmiddle%2Fmode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Flibrustc%2Fmiddle%2Fmode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmode.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,281 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use core::prelude::*;\n-\n-use middle::pat_util;\n-use middle::ty;\n-use middle::ty::{CopyValue, MoveValue, ReadValue, ValueMode, ctxt};\n-use middle::typeck::{method_map, method_map_entry};\n-\n-use core::vec;\n-use std::map::HashMap;\n-use syntax::ast::{bind_infer, box, by_copy, by_move, by_ref, by_val, crate};\n-use syntax::ast::{deref, expr, expr_addr_of, expr_assign, expr_assign_op};\n-use syntax::ast::{expr_binary, expr_call, expr_copy, expr_field, expr_index};\n-use syntax::ast::{expr_match, expr_method_call, expr_paren, expr_path};\n-use syntax::ast::{expr_swap, expr_unary, neg, node_id, not, pat, pat_ident};\n-use syntax::ast::{expr_vstore, expr_vec, expr_rec, expr_tup, expr_lit};\n-use syntax::ast::{expr_cast, expr_if, expr_while, expr_loop, expr_fn};\n-use syntax::ast::{expr_fn_block, expr_loop_body, expr_do_body, expr_block};\n-use syntax::ast::{expr_unary_move, expr_fail, expr_break, expr_again};\n-use syntax::ast::{expr_ret, expr_log, expr_assert, expr_mac, expr_struct};\n-use syntax::ast::{expr_repeat};\n-use syntax::ast::{sty_uniq, sty_value, uniq};\n-use syntax::ast::{fn_decl, blk};\n-use syntax::visit;\n-use syntax::visit::{fn_kind, vt};\n-use syntax::print::pprust;\n-use syntax::codemap::span;\n-\n-struct VisitContext {\n-    tcx: ctxt,\n-    method_map: HashMap<node_id,method_map_entry>,\n-    mode: ValueMode,\n-}\n-\n-fn compute_modes_for_fn(fk: fn_kind,\n-                        decl: fn_decl,\n-                        body: blk,\n-                        sp: span,\n-                        id: node_id,\n-                        &&cx: VisitContext,\n-                        v: vt<VisitContext>) {\n-    let body_cx = VisitContext { mode: MoveValue, ..cx };\n-    visit::visit_fn(fk, decl, body, sp, id, body_cx, v);\n-}\n-\n-fn compute_modes_for_fn_args(callee_id: node_id,\n-                             args: &[@expr],\n-                             last_arg_is_block: bool,\n-                             &&cx: VisitContext,\n-                             v: vt<VisitContext>) {\n-    let arg_tys = ty::ty_fn_args(ty::node_id_to_type(cx.tcx, callee_id));\n-    let mut i = 0;\n-    for vec::each2(args, arg_tys) |arg, arg_ty| {\n-        if last_arg_is_block && i == args.len() - 1 {\n-            let block_cx = VisitContext { mode: MoveValue, ..cx };\n-            compute_modes_for_expr(*arg, block_cx, v);\n-        } else {\n-            match ty::resolved_mode(cx.tcx, arg_ty.mode) {\n-                by_ref => {\n-                    let arg_cx = VisitContext { mode: ReadValue, ..cx };\n-                    compute_modes_for_expr(*arg, arg_cx, v);\n-                }\n-                by_val | by_move | by_copy => {\n-                    compute_modes_for_expr(*arg, cx, v);\n-                }\n-            }\n-        }\n-        i += 1;\n-    }\n-}\n-\n-fn record_mode_for_expr(expr: @expr, &&cx: VisitContext) {\n-    match cx.mode {\n-        ReadValue | CopyValue => {\n-            cx.tcx.value_modes.insert(expr.id, cx.mode);\n-        }\n-        MoveValue => {\n-            // This is, contextually, a move, but if this expression\n-            // is implicitly copyable it's cheaper to copy.\n-            let e_ty = ty::expr_ty(cx.tcx, expr);\n-            if ty::type_implicitly_moves(cx.tcx, e_ty) {\n-                cx.tcx.value_modes.insert(expr.id, MoveValue);\n-            } else {\n-                cx.tcx.value_modes.insert(expr.id, CopyValue);\n-            }\n-        }\n-    }\n-}\n-\n-fn compute_modes_for_expr(expr: @expr,\n-                          &&cx: VisitContext,\n-                          v: vt<VisitContext>) {\n-    debug!(\"compute_modes_for_expr(expr=%?/%s, mode=%?)\",\n-           expr.id, pprust::expr_to_str(expr, cx.tcx.sess.intr()),\n-           cx.mode);\n-\n-    // Adjust the mode if there was an implicit reference here.\n-    let cx = match cx.tcx.adjustments.find(expr.id) {\n-        None => cx,\n-        Some(adjustment) => {\n-            if adjustment.autoref.is_some() {\n-                VisitContext { mode: ReadValue, ..cx }\n-            } else {\n-                cx\n-            }\n-        }\n-    };\n-\n-    match copy expr.node {\n-        expr_call(callee, args, is_block) => {\n-            let callee_cx = VisitContext { mode: ReadValue, ..cx };\n-            compute_modes_for_expr(callee, callee_cx, v);\n-            compute_modes_for_fn_args(callee.id, args, is_block, cx, v);\n-        }\n-        expr_path(*) => {\n-            record_mode_for_expr(expr, cx);\n-        }\n-        expr_copy(expr) => {\n-            let callee_cx = VisitContext { mode: CopyValue, ..cx };\n-            compute_modes_for_expr(expr, callee_cx, v);\n-        }\n-        expr_method_call(callee, _, _, args, is_block) => {\n-            // The LHS of the dot may or may not result in a move, depending\n-            // on the method map entry.\n-            let callee_mode;\n-            match cx.method_map.find(expr.id) {\n-                Some(ref method_map_entry) => {\n-                    match method_map_entry.explicit_self {\n-                        sty_uniq(_) | sty_value => callee_mode = MoveValue,\n-                        _ => callee_mode = ReadValue\n-                    }\n-                }\n-                None => {\n-                    cx.tcx.sess.span_bug(expr.span, ~\"no method map entry\");\n-                }\n-            }\n-\n-            let callee_cx = VisitContext { mode: callee_mode, ..cx };\n-            compute_modes_for_expr(callee, callee_cx, v);\n-\n-            compute_modes_for_fn_args(expr.callee_id, args, is_block, cx, v);\n-        }\n-        expr_binary(_, lhs, rhs) | expr_assign_op(_, lhs, rhs) => {\n-            // The signatures of these take their arguments by-ref, so they\n-            // don't copy or move.\n-            let arg_cx = VisitContext { mode: ReadValue, ..cx };\n-            compute_modes_for_expr(lhs, arg_cx, v);\n-            compute_modes_for_expr(rhs, arg_cx, v);\n-        }\n-        expr_addr_of(_, arg) => {\n-            // Takes its argument by-ref, so it doesn't copy or move.\n-            let arg_cx = VisitContext { mode: ReadValue, ..cx };\n-            compute_modes_for_expr(arg, arg_cx, v);\n-        }\n-        expr_unary(unop, arg) => {\n-            match unop {\n-                deref => {\n-                    // Derefs function as reads.\n-                    let arg_cx = VisitContext { mode: ReadValue, ..cx };\n-                    compute_modes_for_expr(arg, arg_cx, v);\n-\n-                    // This is an lvalue, so it needs a value mode recorded\n-                    // for it.\n-                    record_mode_for_expr(expr, cx);\n-                }\n-                box(_) | uniq(_) => {\n-                    let arg_cx = VisitContext { mode: MoveValue, ..cx };\n-                    compute_modes_for_expr(arg, arg_cx, v);\n-                }\n-                not | neg => {\n-                    // Takes its argument by ref.\n-                    let arg_cx = VisitContext { mode: ReadValue, ..cx };\n-                    compute_modes_for_expr(arg, arg_cx, v);\n-                }\n-            }\n-        }\n-        expr_field(arg, _, _) => {\n-            let arg_cx = VisitContext { mode: ReadValue, ..cx };\n-            compute_modes_for_expr(arg, arg_cx, v);\n-\n-            record_mode_for_expr(expr, cx);\n-        }\n-        expr_assign(lhs, rhs) => {\n-            // The signatures of these take their arguments by-ref, so they\n-            // don't copy or move.\n-            let arg_cx = VisitContext { mode: ReadValue, ..cx };\n-            compute_modes_for_expr(lhs, arg_cx, v);\n-            compute_modes_for_expr(rhs, cx, v);\n-        }\n-        expr_swap(lhs, rhs) => {\n-            let arg_cx = VisitContext { mode: ReadValue, ..cx };\n-            compute_modes_for_expr(lhs, arg_cx, v);\n-            compute_modes_for_expr(rhs, arg_cx, v);\n-        }\n-        expr_index(lhs, rhs) => {\n-            let lhs_cx = VisitContext { mode: ReadValue, ..cx };\n-            compute_modes_for_expr(lhs, lhs_cx, v);\n-            let rhs_cx = VisitContext { mode: MoveValue, ..cx };\n-            compute_modes_for_expr(rhs, rhs_cx, v);\n-\n-            record_mode_for_expr(expr, cx);\n-        }\n-        expr_paren(arg) => {\n-            compute_modes_for_expr(arg, cx, v);\n-            record_mode_for_expr(expr, cx);\n-        }\n-        expr_match(head, ref arms) => {\n-            // We must do this first so that `arms_have_by_move_bindings`\n-            // below knows which bindings are moves.\n-            for arms.each |arm| {\n-                (v.visit_arm)(*arm, cx, v);\n-            }\n-\n-            let by_move_bindings_present =\n-                pat_util::arms_have_by_move_bindings(cx.tcx, *arms);\n-            if by_move_bindings_present {\n-                // Propagate the current mode flag downward.\n-                visit::visit_expr(expr, cx, v);\n-            } else {\n-                // We aren't moving into any pattern, so this is just a read.\n-                let head_cx = VisitContext { mode: ReadValue, ..cx };\n-                compute_modes_for_expr(head, head_cx, v);\n-            }\n-        }\n-        // Spell out every remaining expression so we don't forget to\n-        // update this code if we add a new variant.\n-        // (Maybe a macro to do this would be nice...)\n-        expr_vstore(*) | expr_vec(*) | expr_rec(*) | expr_tup(*) |\n-            expr_lit(*) | expr_cast(*) | expr_if(*) | expr_while(*) |\n-            expr_loop(*) | expr_fn(*) | expr_fn_block(*) |\n-            expr_loop_body(*) | expr_do_body(*) | expr_block(*) |\n-            expr_unary_move(*) | expr_fail(*) | expr_break(*) |\n-            expr_again(*) | expr_ret(*) | expr_log(*) | expr_assert(*) |\n-            expr_mac(*) | expr_struct(*) | expr_repeat(*) => {\n-            visit::visit_expr(expr, cx, v)\n-        }\n-    }\n-}\n-\n-fn compute_modes_for_pat(pat: @pat,\n-                         &&cx: VisitContext,\n-                         v: vt<VisitContext>) {\n-    match pat.node {\n-        pat_ident(bind_infer, _, _)\n-                if pat_util::pat_is_binding(cx.tcx.def_map, pat) => {\n-            if ty::type_implicitly_moves(cx.tcx, ty::pat_ty(cx.tcx, pat)) {\n-                cx.tcx.value_modes.insert(pat.id, MoveValue);\n-            } else {\n-                cx.tcx.value_modes.insert(pat.id, CopyValue);\n-            }\n-        }\n-        _ => {}\n-    }\n-\n-    visit::visit_pat(pat, cx, v);\n-}\n-\n-pub fn compute_modes(tcx: ctxt, method_map: method_map, crate: @crate) {\n-    let visitor = visit::mk_vt(@visit::Visitor {\n-        visit_fn: compute_modes_for_fn,\n-        visit_expr: compute_modes_for_expr,\n-        visit_pat: compute_modes_for_pat,\n-        .. *visit::default_visitor()\n-    });\n-    let callee_cx = VisitContext {\n-        tcx: tcx,\n-        method_map: method_map,\n-        mode: MoveValue\n-    };\n-    visit::visit_crate(*crate, callee_cx, visitor);\n-}\n-"}, {"sha": "2d6565cc9c6cea15f00a93108fdf85a88d04ddc7", "filename": "src/librustc/middle/moves.rs", "status": "added", "additions": 815, "deletions": 0, "changes": 815, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -0,0 +1,815 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+# Moves Computation\n+\n+The goal of this file is to compute which\n+expressions/patterns/captures correspond to *moves*.  This is\n+generally a function of the context in which the expression appears as\n+well as the expression's type.\n+\n+## Examples\n+\n+We will use the following fragment of code to explain the various\n+considerations.  Note that in this code `x` is used after it has been\n+moved here.  This is not relevant to this pass, though the information\n+we compute would later be used to detect this error (see the section\n+Enforcement of Moves, below).\n+\n+    struct Foo { a: int, b: ~int }\n+    let x: Foo = ...;\n+    let w = (x {Read}).a;      // Read\n+    let y = (x {Move}).b;      // Move\n+    let z = copy (x {Read}).b; // Read\n+\n+Let's look at these examples one by one.  In the first case, `w`, the\n+expression being assigned is `x.a`, which has `int` type.  In that\n+case, the value is read, and the container (`x`) is also read.\n+\n+In the second case, `y`, `x.b` is being assigned which has type\n+`~int`.  Because this type moves by default, that will be a move\n+reference.  Whenever we move from a compound expression like `x.b` (or\n+`x[b]` or `*x` or `{x)[b].c`, etc), this invalidates all containing\n+expressions since we do not currently permit \"incomplete\" variables\n+where part of them has been moved and part has not.  In this case,\n+this means that the reference to `x` is also a move.  We'll see later,\n+though, that these kind of \"partial moves\", where part of the\n+expression has been moved, are classified and stored somewhat\n+differently.\n+\n+The final example (`z`) is `copy x.b`: in this case, although the\n+expression being assigned has type `~int`, there are no moves\n+involved.\n+\n+### Patterns\n+\n+For each binding in a match or let pattern, we also compute a read\n+or move designation.  A move binding means that the value will be\n+moved from the value being matched.  As a result, the expression\n+being matched (aka, the 'discriminant') is either moved or read\n+depending on whethe the bindings move the value they bind to out of\n+the discriminant.\n+\n+For examples, consider this match expression:\n+\n+    match x {Move} {\n+      Foo { a: a {Read}, b: b {Move} } => {...}\n+    }\n+\n+Here, the binding `b` is value (not ref) mode, and `b` has type\n+`~int`, and therefore the discriminant expression `x` would be\n+incomplete so it also considered moved.\n+\n+In the following two examples, in contrast, the mode of `b` is either\n+`copy` or `ref` and hence the overall result is a read:\n+\n+    match x {Read} {\n+      Foo { a: a {Read}, b: copy b {Read} } => {...}\n+    }\n+\n+    match x {Read} {\n+      Foo { a: a {Read}, b: ref b {Read} } => {...}\n+    }\n+\n+Similar reasoning can be applied to `let` expressions:\n+\n+    let Foo { a: a {Read}, b: b {Move} } = x {Move};\n+    let Foo { a: a {Read}, b: copy b {Read} } = x {Read};\n+    let Foo { a: a {Read}, b: ref b  {Read} } = x {Read};\n+\n+## Output\n+\n+The pass results in the struct `MoveMaps` which contains two sets,\n+`moves_map` and `variable_moves_map`, and one map, `capture_map`.\n+\n+`moves_map` is a set containing the id of every *outermost\n+expression* or *binding* that is moved.  Note that `moves_map` only\n+contains the *outermost expressions* that are moved.  Therefore, if\n+you have a use of `x.b`, as in the example `y` above, the\n+expression `x.b` would be in the `moves_map` but not `x`.  The\n+reason for this is that, for most purposes, it's only the outermost\n+expression that is needed.  The borrow checker and trans, for\n+example, only care about the outermost expressions that are moved.\n+It is more efficient therefore just to store those entries.\n+\n+In the case of the liveness pass, however, we need to know which\n+*variable references* are moved (see the Enforcement of Moves\n+section below for more details).  That is, for the `x.b`\n+expression, liveness only cares about the `x`.  For this purpose,\n+we have a second map, `variable_moves_map`, that contains the ids\n+of all variable references which is moved.\n+\n+The `capture_map` maps from the node_id of a closure expression to an\n+array of `CaptureVar` structs detailing which variables are captured\n+and how (by ref, by copy, by move).\n+\n+## Enforcement of Moves\n+\n+The enforcement of moves is somewhat complicated because it is divided\n+amongst the liveness and borrowck modules. In general, the borrow\n+checker is responsible for guaranteeing that *only owned data is\n+moved*.  The liveness checker, in contrast, is responsible for\n+checking that *no variable is used after it is moved*.\n+\n+To see the difference, let's look at a few examples.  Here is a\n+program fragment where the error would be caught by liveness:\n+\n+    struct Foo { a: int, b: ~int }\n+    let x: Foo = ...;\n+    let y = x.b; // (1)\n+    let z = x;   // (2)            //~ ERROR use of moved value `x`\n+\n+Here the liveness checker will see the assignment to `y` moves\n+invalidates the variable `x` because it moves the expression `x.b`.\n+An error is resported because `x` is not dead at the point where it is\n+invalidated.\n+\n+In more concrete terms, the `moves_map` generated from this example\n+would contain both the expression `x.b` (1) and the expression `x`\n+(2).  Note that it would not contain `x` (1), because `moves_map` only\n+contains the outermost expressions that are moved.  However,\n+`moves_map` is not used by liveness.  It uses the\n+`variable_moves_map`, which would contain both references to `x`: (1)\n+and (2).  Therefore, after computing which variables are live where,\n+liveness will see that the reference (1) to `x` is both present in\n+`variable_moves_map` and that `x` is live and report an error.\n+\n+Now let's look at another illegal example, but one where liveness would\n+not catch the error:\n+\n+    struct Foo { a: int, b: ~int }\n+    let x: @Foo = ...;\n+    let y = x.b;                   //~ ERROR move from managed (@) box\n+\n+This is an interesting example because the only change I've made is\n+to make `x` have type `@Foo` and not `Foo`.  Thanks to auto-deref,\n+the expression `x.b` still works, but now it is short for `{x).b`,\n+and hence the move is actually moving out of the contents of a\n+managed box, which is illegal.  However, liveness knows nothing of\n+this.  It only tracks what variables are used where.  The moves\n+pass (that is, this pass) is also ignorant of such details.  From\n+the perspective of the moves pass, the `let y = x.b` line above\n+will be categorized as follows:\n+\n+    let y = {(x{Move}) {Move}).b; {Move}\n+\n+Therefore, the reference to `x` will be present in\n+`variable_moves_map`, but liveness will not report an error because\n+there is no subsequent use.\n+\n+This is where the borrow checker comes in.  When the borrow checker\n+runs, it will see that `x.b` is present in the `moves_map`.  It will\n+use the `mem_categorization` module to determine where the result of\n+this expression resides in memory and see that it is owned by managed\n+data, and report an error.\n+\n+In principle, liveness could use the `mem_categorization` module\n+itself and check that moves always originate from owned data\n+(historically, of course, this was not the case; `mem_categorization`\n+used to be private to the borrow checker).  However, there is another\n+kind of error which liveness could not possibly detect. Sometimes a\n+move is an error due to an outstanding loan, and it is borrow\n+checker's job to compute those loans.  That is, consider *this*\n+example:\n+\n+    struct Foo { a: int, b: ~int }\n+    let x: Foo = ...;\n+    let y = &x.b;                   //~ NOTE loan issued here\n+    let z = x.b;                    //~ ERROR move with outstanding loan\n+\n+In this case, `y` is a pointer into `x`, so when `z` tries to move out\n+of `x`, we get an error.  There is no way that liveness could compute\n+this information without redoing the efforts of the borrow checker.\n+\n+### Closures\n+\n+Liveness is somewhat complicated by having to deal with stack\n+closures.  More information to come!\n+\n+## Distributive property\n+\n+Copies are \"distributive\" over parenthesization, but blocks are\n+considered rvalues.  What this means is that, for example, neither\n+`a.clone()` nor `(a).clone()` will move `a` (presuming that `a` has a\n+linear type and `clone()` takes its self by reference), but\n+`{a}.clone()` will move `a`, as would `(if cond {a} else {b}).clone()`\n+and so on.\n+\n+*/\n+\n+use core::prelude::*;\n+\n+use middle::pat_util::{pat_bindings};\n+use middle::freevars;\n+use middle::ty;\n+use middle::typeck::{method_map, method_map_entry};\n+use middle::typeck::check::{DerefArgs, DoDerefArgs, DontDerefArgs};\n+use util::ppaux;\n+use util::common::indenter;\n+\n+use core::vec;\n+use std::map::HashMap;\n+use syntax::ast::*;\n+use syntax::ast_util;\n+use syntax::visit;\n+use syntax::visit::{fn_kind, fk_item_fn, fk_method, fk_dtor,\n+                    fk_anon, fk_fn_block, vt};\n+use syntax::print::pprust;\n+use syntax::codemap::span;\n+\n+#[auto_encode]\n+#[auto_decode]\n+pub enum CaptureMode {\n+    CapCopy, // Copy the value into the closure.\n+    CapMove, // Move the value into the closure.\n+    CapRef,  // Reference directly from parent stack frame (used by `&fn()`).\n+}\n+\n+#[auto_encode]\n+#[auto_decode]\n+pub struct CaptureVar {\n+    def: def,         // Variable being accessed free\n+    span: span,       // Location of an access to this variable\n+    mode: CaptureMode // How variable is being accessed\n+}\n+\n+pub type CaptureMap = HashMap<node_id, @[CaptureVar]>;\n+\n+pub type MovesMap = HashMap<node_id, ()>;\n+\n+/**\n+ * For each variable which will be moved, links to the\n+ * expression */\n+pub type VariableMovesMap = HashMap<node_id, @expr>;\n+\n+/** See the section Output on the module comment for explanation. */\n+pub struct MoveMaps {\n+    moves_map: MovesMap,\n+    variable_moves_map: VariableMovesMap,\n+    capture_map: CaptureMap\n+}\n+\n+struct VisitContext {\n+    tcx: ty::ctxt,\n+    method_map: HashMap<node_id,method_map_entry>,\n+    move_maps: MoveMaps\n+}\n+\n+enum UseMode {\n+    MoveInWhole,         // Move the entire value.\n+    MoveInPart(@expr),   // Some subcomponent will be moved\n+    Read                 // Read no matter what the type.\n+}\n+\n+pub fn compute_moves(tcx: ty::ctxt,\n+                     method_map: method_map,\n+                     crate: @crate) -> MoveMaps\n+{\n+    let visitor = visit::mk_vt(@visit::Visitor {\n+        visit_expr: compute_modes_for_expr,\n+        .. *visit::default_visitor()\n+    });\n+    let visit_cx = VisitContext {\n+        tcx: tcx,\n+        method_map: method_map,\n+        move_maps: MoveMaps {\n+            moves_map: HashMap(),\n+            variable_moves_map: HashMap(),\n+            capture_map: HashMap()\n+        }\n+    };\n+    visit::visit_crate(*crate, visit_cx, visitor);\n+    return visit_cx.move_maps;\n+}\n+\n+// ______________________________________________________________________\n+// Expressions\n+\n+fn compute_modes_for_expr(expr: @expr,\n+                          &&cx: VisitContext,\n+                          v: vt<VisitContext>)\n+{\n+    cx.consume_expr(expr, v);\n+}\n+\n+impl UseMode {\n+    fn component_mode(&self, expr: @expr) -> UseMode {\n+        /*!\n+         *\n+         * Assuming that `self` is the mode for an expression E,\n+         * returns the appropriate mode to use for a subexpression of E.\n+         */\n+\n+        match *self {\n+            Read | MoveInPart(_) => *self,\n+            MoveInWhole => MoveInPart(expr)\n+        }\n+    }\n+}\n+\n+impl VisitContext {\n+    fn consume_exprs(&self,\n+                     exprs: &[@expr],\n+                     visitor: vt<VisitContext>)\n+    {\n+        for exprs.each |expr| {\n+            self.consume_expr(*expr, visitor);\n+        }\n+    }\n+\n+    fn consume_expr(&self,\n+                    expr: @expr,\n+                    visitor: vt<VisitContext>)\n+    {\n+        /*!\n+         *\n+         * Indicates that the value of `expr` will be consumed,\n+         * meaning either copied or moved depending on its type.\n+         */\n+\n+        debug!(\"consume_expr(expr=%?/%s)\",\n+               expr.id,\n+               pprust::expr_to_str(expr, self.tcx.sess.intr()));\n+\n+        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n+        let mode = self.consume_mode_for_ty(expr_ty);\n+        self.use_expr(expr, mode, visitor);\n+    }\n+\n+    fn consume_block(&self,\n+                     blk: &blk,\n+                     visitor: vt<VisitContext>)\n+    {\n+        /*!\n+         *\n+         * Indicates that the value of `blk` will be consumed,\n+         * meaning either copied or moved depending on its type.\n+         */\n+\n+        debug!(\"consume_block(blk.id=%?)\", blk.node.id);\n+\n+        for blk.node.stmts.each |stmt| {\n+            (visitor.visit_stmt)(*stmt, *self, visitor);\n+        }\n+\n+        for blk.node.expr.each |tail_expr| {\n+            self.consume_expr(*tail_expr, visitor);\n+        }\n+    }\n+\n+    fn consume_mode_for_ty(&self, ty: ty::t) -> UseMode {\n+        /*!\n+         *\n+         * Selects the appropriate `UseMode` to consume a value with\n+         * the type `ty`.  This will be `MoveEntireMode` if `ty` is\n+         * not implicitly copyable.\n+         */\n+\n+        let result = if ty::type_implicitly_moves(self.tcx, ty) {\n+            MoveInWhole\n+        } else {\n+            Read\n+        };\n+\n+        debug!(\"consume_mode_for_ty(ty=%s) = %?\",\n+               ppaux::ty_to_str(self.tcx, ty), result);\n+\n+        return result;\n+    }\n+\n+    fn use_expr(&self,\n+                expr: @expr,\n+                expr_mode: UseMode,\n+                visitor: vt<VisitContext>)\n+    {\n+        /*!\n+         *\n+         * Indicates that `expr` is used with a given mode.  This will\n+         * in turn trigger calls to the subcomponents of `expr`.\n+         */\n+\n+        debug!(\"use_expr(expr=%?/%s, mode=%?)\",\n+               expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr()),\n+               expr_mode);\n+\n+        match expr_mode {\n+            MoveInWhole => { self.move_maps.moves_map.insert(expr.id, ()); }\n+            MoveInPart(_) | Read => {}\n+        }\n+\n+        // `expr_mode` refers to the post-adjustment value.  If one of\n+        // those adjustments is to take a reference, then it's only\n+        // reading the underlying expression, not moving it.\n+        let comp_mode = match self.tcx.adjustments.find(expr.id) {\n+            Some(adj) if adj.autoref.is_some() => Read,\n+            _ => expr_mode.component_mode(expr)\n+        };\n+\n+        debug!(\"comp_mode = %?\", comp_mode);\n+\n+        match expr.node {\n+            expr_path(*) => {\n+                match comp_mode {\n+                    MoveInPart(entire_expr) => {\n+                        self.move_maps.variable_moves_map.insert(\n+                            expr.id, entire_expr);\n+                    }\n+                    Read => {}\n+                    MoveInWhole => {\n+                        self.tcx.sess.span_bug(\n+                            expr.span,\n+                            fmt!(\"Component mode can never be MoveInWhole\"));\n+                    }\n+                }\n+            }\n+\n+            expr_unary(deref, base) => {       // *base\n+                if !self.use_overloaded_operator(\n+                    expr, DontDerefArgs, base, [], visitor)\n+                {\n+                    // Moving out of *base moves out of base.\n+                    self.use_expr(base, comp_mode, visitor);\n+                }\n+            }\n+\n+            expr_field(base, _, _) => {        // base.f\n+                // Moving out of base.f moves out of base.\n+                self.use_expr(base, comp_mode, visitor);\n+            }\n+\n+            expr_index(lhs, rhs) => {          // lhs[rhs]\n+                if !self.use_overloaded_operator(\n+                    expr, DontDerefArgs, lhs, [rhs], visitor)\n+                {\n+                    self.use_expr(lhs, comp_mode, visitor);\n+                    self.consume_expr(rhs, visitor);\n+                }\n+            }\n+\n+            expr_call(callee, ref args, _) => {    // callee(args)\n+                self.use_expr(callee, Read, visitor);\n+                self.use_fn_args(callee.id, *args, visitor);\n+            }\n+\n+            expr_method_call(callee, _, _, ref args, _) => { // callee.m(args)\n+                // Implicit self is equivalent to & mode, but every\n+                // other kind should be + mode.\n+                self.use_receiver(expr.id, expr.span, callee, visitor);\n+                self.use_fn_args(expr.callee_id, *args, visitor);\n+            }\n+\n+            expr_rec(ref fields, opt_with) |\n+            expr_struct(_, ref fields, opt_with) => {\n+                for fields.each |field| {\n+                    self.consume_expr(field.node.expr, visitor);\n+                }\n+\n+                for opt_with.each |with_expr| {\n+                    self.consume_expr(*with_expr, visitor);\n+                }\n+            }\n+\n+            expr_tup(ref exprs) => {\n+                self.consume_exprs(*exprs, visitor);\n+            }\n+\n+            expr_if(cond_expr, ref then_blk, opt_else_expr) => {\n+                self.consume_expr(cond_expr, visitor);\n+                self.consume_block(then_blk, visitor);\n+                for opt_else_expr.each |else_expr| {\n+                    self.consume_expr(*else_expr, visitor);\n+                }\n+            }\n+\n+            expr_match(discr, ref arms) => {\n+                // We must do this first so that `arms_have_by_move_bindings`\n+                // below knows which bindings are moves.\n+                for arms.each |arm| {\n+                    self.consume_arm(arm, visitor);\n+                }\n+\n+                let by_move_bindings_present =\n+                    self.arms_have_by_move_bindings(\n+                        self.move_maps.moves_map, *arms);\n+\n+                if by_move_bindings_present {\n+                    // If one of the arms moves a value out of the\n+                    // discriminant, then the discriminant itself is\n+                    // moved.\n+                    self.consume_expr(discr, visitor);\n+                } else {\n+                    // Otherwise, the discriminant is merely read.\n+                    self.use_expr(discr, Read, visitor);\n+                }\n+            }\n+\n+            expr_copy(base) => {\n+                self.use_expr(base, Read, visitor);\n+            }\n+\n+            expr_paren(base) => {\n+                // Note: base is not considered a *component* here, so\n+                // use `expr_mode` not `comp_mode`.\n+                self.use_expr(base, expr_mode, visitor);\n+            }\n+\n+            expr_vec(ref exprs, _) => {\n+                self.consume_exprs(*exprs, visitor);\n+            }\n+\n+            expr_addr_of(_, base) => {   // &base\n+                self.use_expr(base, Read, visitor);\n+            }\n+\n+            expr_break(*) |\n+            expr_again(*) |\n+            expr_lit(*) => {}\n+\n+            expr_loop(ref blk, _) => {\n+                self.consume_block(blk, visitor);\n+            }\n+\n+            expr_log(_, a_expr, b_expr) => {\n+                self.consume_expr(a_expr, visitor);\n+                self.use_expr(b_expr, Read, visitor);\n+            }\n+\n+            expr_assert(cond_expr) => {\n+                self.consume_expr(cond_expr, visitor);\n+            }\n+\n+            expr_while(cond_expr, ref blk) => {\n+                self.consume_expr(cond_expr, visitor);\n+                self.consume_block(blk, visitor);\n+            }\n+\n+            expr_unary(_, lhs) => {\n+                if !self.use_overloaded_operator(\n+                    expr, DontDerefArgs, lhs, [], visitor)\n+                {\n+                    self.consume_expr(lhs, visitor);\n+                }\n+            }\n+\n+            expr_binary(_, lhs, rhs) => {\n+                if !self.use_overloaded_operator(\n+                    expr, DoDerefArgs, lhs, [rhs], visitor)\n+                {\n+                    self.consume_expr(lhs, visitor);\n+                    self.consume_expr(rhs, visitor);\n+                }\n+            }\n+\n+            expr_block(ref blk) => {\n+                self.consume_block(blk, visitor);\n+            }\n+\n+            expr_fail(ref opt_expr) |\n+            expr_ret(ref opt_expr) => {\n+                for opt_expr.each |expr| {\n+                    self.consume_expr(*expr, visitor);\n+                }\n+            }\n+\n+            expr_assign(lhs, rhs) => {\n+                self.use_expr(lhs, Read, visitor);\n+                self.consume_expr(rhs, visitor);\n+            }\n+\n+            expr_cast(base, _) => {\n+                self.consume_expr(base, visitor);\n+            }\n+\n+            expr_assign_op(_, lhs, rhs) => {\n+                // FIXME(#4712) --- Overloaded operators?\n+                //\n+                // if !self.use_overloaded_operator(\n+                //     expr, DoDerefArgs, lhs, [rhs], visitor)\n+                // {\n+                self.consume_expr(lhs, visitor);\n+                self.consume_expr(rhs, visitor);\n+                // }\n+            }\n+\n+            expr_repeat(base, count, _) => {\n+                self.consume_expr(base, visitor);\n+                self.consume_expr(count, visitor);\n+            }\n+\n+            expr_swap(lhs, rhs) => {\n+                self.use_expr(lhs, Read, visitor);\n+                self.use_expr(rhs, Read, visitor);\n+            }\n+\n+            expr_loop_body(base) |\n+            expr_do_body(base) => {\n+                self.use_expr(base, comp_mode, visitor);\n+            }\n+\n+            expr_fn(_, _, ref body) |\n+            expr_fn_block(_, ref body) => {\n+                let cap_vars = self.compute_captures(expr.id);\n+                self.move_maps.capture_map.insert(expr.id, cap_vars);\n+                self.consume_block(body, visitor);\n+            }\n+\n+            expr_vstore(base, _) => {\n+                self.use_expr(base, comp_mode, visitor);\n+            }\n+\n+            expr_mac(*) => {\n+                self.tcx.sess.span_bug(\n+                    expr.span,\n+                    ~\"macro expression remains after expansion\");\n+            }\n+        }\n+    }\n+\n+    fn use_overloaded_operator(&self,\n+                               expr: @expr,\n+                               deref_args: DerefArgs,\n+                               receiver_expr: @expr,\n+                               arg_exprs: &[@expr],\n+                               visitor: vt<VisitContext>) -> bool\n+    {\n+        if !self.method_map.contains_key(expr.id) {\n+            return false;\n+        }\n+\n+        self.use_receiver(expr.id, expr.span, receiver_expr, visitor);\n+\n+        // The deref_args stuff should eventually be converted into\n+        // adjustments.  Moreover, it should eventually be applied\n+        // consistently to all overloaded operators.  But that's not\n+        // how it is today.\n+        match deref_args {\n+            DoDerefArgs => {\n+                // we are always passing in a borrowed pointer,\n+                // so it's always read mode:\n+                for arg_exprs.each |arg_expr| {\n+                    self.use_expr(*arg_expr, Read, visitor);\n+                }\n+            }\n+            DontDerefArgs => {\n+                self.use_fn_args(expr.callee_id, arg_exprs, visitor);\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    fn consume_arm(&self,\n+                   arm: &arm,\n+                   visitor: vt<VisitContext>)\n+    {\n+        for arm.pats.each |pat| {\n+            self.use_pat(*pat);\n+        }\n+\n+        for arm.guard.each |guard| {\n+            self.consume_expr(*guard, visitor);\n+        }\n+\n+        self.consume_block(&arm.body, visitor);\n+    }\n+\n+    fn use_pat(&self,\n+               pat: @pat)\n+    {\n+        /*!\n+         *\n+         * Decides whether each binding in a pattern moves the value\n+         * into itself or not based on its type and annotation.\n+         */\n+\n+        do pat_bindings(self.tcx.def_map, pat) |bm, id, _span, _path| {\n+            let mode = match bm {\n+                bind_by_copy => Read,\n+                bind_by_ref(_) => Read,\n+                bind_infer => {\n+                    let pat_ty = ty::node_id_to_type(self.tcx, id);\n+                    self.consume_mode_for_ty(pat_ty)\n+                }\n+            };\n+\n+            match mode {\n+                MoveInWhole => { self.move_maps.moves_map.insert(id, ()); }\n+                MoveInPart(_) | Read => {}\n+            }\n+        }\n+    }\n+\n+    fn use_receiver(&self,\n+                    expr_id: node_id,\n+                    span: span,\n+                    receiver_expr: @expr,\n+                    visitor: vt<VisitContext>)\n+    {\n+        let callee_mode = match self.method_map.find(expr_id) {\n+            Some(ref method_map_entry) => {\n+                match method_map_entry.explicit_self {\n+                    sty_by_ref => by_ref,\n+                    _ => by_copy\n+                }\n+            }\n+            None => {\n+                self.tcx.sess.span_bug(\n+                    span,\n+                    ~\"no method map entry\");\n+            }\n+        };\n+        self.use_fn_arg(callee_mode, receiver_expr, visitor);\n+    }\n+\n+    fn use_fn_args(&self,\n+                   callee_id: node_id,\n+                   arg_exprs: &[@expr],\n+                   visitor: vt<VisitContext>)\n+    {\n+        /*!\n+         *\n+         * Uses the argument expressions according to the function modes.\n+         */\n+\n+        let arg_tys =\n+            ty::ty_fn_args(ty::node_id_to_type(self.tcx, callee_id));\n+        for vec::each2(arg_exprs, arg_tys) |arg_expr, arg_ty| {\n+            let arg_mode = ty::resolved_mode(self.tcx, arg_ty.mode);\n+            self.use_fn_arg(arg_mode, *arg_expr, visitor);\n+        }\n+    }\n+\n+    fn use_fn_arg(&self,\n+                  arg_mode: rmode,\n+                  arg_expr: @expr,\n+                  visitor: vt<VisitContext>)\n+    {\n+        /*!\n+         *\n+         * Uses the argument according to the given argument mode.\n+         */\n+\n+        match arg_mode {\n+            by_val | by_ref => self.use_expr(arg_expr, Read, visitor),\n+            by_copy => self.consume_expr(arg_expr, visitor)\n+        }\n+    }\n+\n+    fn arms_have_by_move_bindings(&self,\n+                                  moves_map: MovesMap,\n+                                  +arms: &[arm]) -> bool\n+    {\n+        for arms.each |arm| {\n+            for arm.pats.each |pat| {\n+                let mut found = false;\n+                do pat_bindings(self.tcx.def_map, *pat) |_, node_id, _, _| {\n+                    if moves_map.contains_key(node_id) {\n+                        found = true;\n+                    }\n+                }\n+                if found { return true; }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    fn compute_captures(&self, fn_expr_id: node_id) -> @[CaptureVar] {\n+        debug!(\"compute_capture_vars(fn_expr_id=%?)\", fn_expr_id);\n+        let _indenter = indenter();\n+\n+        let fn_ty = ty::node_id_to_type(self.tcx, fn_expr_id);\n+        let proto = ty::ty_fn_proto(fn_ty);\n+        let freevars = freevars::get_freevars(self.tcx, fn_expr_id);\n+        if proto == ProtoBorrowed {\n+            // &fn() captures everything by ref\n+            at_vec::from_fn(freevars.len(), |i| {\n+                let fvar = &freevars[i];\n+                CaptureVar {def: fvar.def, span: fvar.span, mode: CapRef}\n+            })\n+        } else {\n+            // @fn() and ~fn() capture by copy or by move depending on type\n+            at_vec::from_fn(freevars.len(), |i| {\n+                let fvar = &freevars[i];\n+                let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n+                let fvar_ty = ty::node_id_to_type(self.tcx, fvar_def_id);\n+                debug!(\"fvar_def_id=%? fvar_ty=%s\",\n+                       fvar_def_id, ppaux::ty_to_str(self.tcx, fvar_ty));\n+                let mode = if ty::type_implicitly_moves(self.tcx, fvar_ty) {\n+                    CapMove\n+                } else {\n+                    CapCopy\n+                };\n+                CaptureVar {def: fvar.def, span: fvar.span, mode:mode}\n+            })\n+        }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "205be5f891b83a1986d8e485fa3264f5856d3e1d", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -11,7 +11,6 @@\n use core::prelude::*;\n \n use middle::resolve;\n-use middle::ty::{CopyValue, MoveValue, ReadValue};\n use middle::ty;\n \n use syntax::ast::*;\n@@ -94,30 +93,3 @@ pub fn pat_binding_ids(dm: resolve::DefMap, pat: @pat) -> ~[node_id] {\n     return found;\n }\n \n-pub fn arms_have_by_move_bindings(tcx: ty::ctxt, +arms: &[arm]) -> bool {\n-    for arms.each |arm| {\n-        for arm.pats.each |pat| {\n-            let mut found = false;\n-            do pat_bindings(tcx.def_map, *pat)\n-                    |binding_mode, node_id, span, _path| {\n-                match binding_mode {\n-                    bind_by_move => found = true,\n-                    bind_infer => {\n-                        match tcx.value_modes.find(node_id) {\n-                            Some(MoveValue) => found = true,\n-                            Some(CopyValue) | Some(ReadValue) => {}\n-                            None => {\n-                                tcx.sess.span_bug(span, ~\"pat binding not in \\\n-                                                          value mode map\");\n-                            }\n-                        }\n-                    }\n-                    bind_by_ref(*) | bind_by_value => {}\n-                }\n-            }\n-            if found { return true; }\n-        }\n-    }\n-    return false;\n-}\n-"}, {"sha": "31ac2f0f6761be0ac878a9204f31fea488b37ff0", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -290,15 +290,6 @@ pub fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n                                                            cx.sess.intr()));\n         new_cx.parent = Some(expr.id);\n       }\n-      ast::expr_fn(_, _, _, cap_clause) |\n-      ast::expr_fn_block(_, _, cap_clause) => {\n-        // although the capture items are not expressions per se, they\n-        // do get \"evaluated\" in some sense as copies or moves of the\n-        // relevant variables so we parent them like an expression\n-        for (*cap_clause).each |cap_item| {\n-            record_parent(new_cx, cap_item.id);\n-        }\n-      }\n       ast::expr_while(cond, _) => {\n         new_cx.root_exprs.insert(cond.id, ());\n       }"}, {"sha": "5314005a956aa318e703ef2a797c53827b3bfd2c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 47, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -24,8 +24,8 @@ use core::cmp;\n use core::str;\n use core::vec;\n use syntax::ast::{RegionTyParamBound, TraitTyParamBound, _mod, add, arm};\n-use syntax::ast::{binding_mode, bitand, bitor, bitxor, blk, capture_clause};\n-use syntax::ast::{bind_by_value, bind_infer, bind_by_ref, bind_by_move};\n+use syntax::ast::{binding_mode, bitand, bitor, bitxor, blk};\n+use syntax::ast::{bind_infer, bind_by_ref, bind_by_copy};\n use syntax::ast::{crate, crate_num, decl_item, def, def_arg, def_binding};\n use syntax::ast::{def_const, def_foreign_mod, def_fn, def_id, def_label};\n use syntax::ast::{def_local, def_mod, def_prim_ty, def_region, def_self};\n@@ -175,11 +175,6 @@ pub enum SelfBinding {\n     HasSelfBinding(node_id, bool /* is implicit */)\n }\n \n-pub enum CaptureClause {\n-    NoCaptureClause,\n-    HasCaptureClause(capture_clause)\n-}\n-\n pub type ResolveVisitor = vt<()>;\n \n #[deriving_eq]\n@@ -3727,7 +3722,6 @@ pub impl Resolver {\n                                          OpaqueFunctionRibKind),\n                                       (*block),\n                                       NoSelfBinding,\n-                                      NoCaptureClause,\n                                       visitor);\n             }\n \n@@ -3803,33 +3797,7 @@ pub impl Resolver {\n                         type_parameters: TypeParameters,\n                         block: blk,\n                         self_binding: SelfBinding,\n-                        capture_clause: CaptureClause,\n                         visitor: ResolveVisitor) {\n-        // Check each element of the capture clause.\n-        match capture_clause {\n-            NoCaptureClause => {\n-                // Nothing to do.\n-            }\n-            HasCaptureClause(capture_clause) => {\n-                // Resolve each captured item.\n-                for (*capture_clause).each |capture_item| {\n-                    match self.resolve_identifier(capture_item.name,\n-                                                  ValueNS,\n-                                                  true,\n-                                                  capture_item.span) {\n-                        None => {\n-                            self.session.span_err(capture_item.span,\n-                                                  ~\"unresolved name in \\\n-                                                   capture clause\");\n-                        }\n-                        Some(def) => {\n-                            self.record_def(capture_item.id, def);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n         // Create a value rib for the function.\n         let function_value_rib = @Rib(rib_kind);\n         (*self.value_ribs).push(function_value_rib);\n@@ -3945,7 +3913,6 @@ pub impl Resolver {\n                                           HasSelfBinding\n                                             ((*destructor).node.self_id,\n                                              true),\n-                                          NoCaptureClause,\n                                           visitor);\n                 }\n             }\n@@ -3976,7 +3943,6 @@ pub impl Resolver {\n                               type_parameters,\n                               method.body,\n                               self_binding,\n-                              NoCaptureClause,\n                               visitor);\n     }\n \n@@ -4047,7 +4013,6 @@ pub impl Resolver {\n                                              NormalRibKind),\n                                           method.body,\n                                           HasSelfBinding(method.self_id),\n-                                          NoCaptureClause,\n                                           visitor);\n */\n             }\n@@ -4855,14 +4820,13 @@ pub impl Resolver {\n                 visit_expr(expr, (), visitor);\n             }\n \n-            expr_fn(_, ref fn_decl, ref block, capture_clause) |\n-            expr_fn_block(ref fn_decl, ref block, capture_clause) => {\n+            expr_fn(_, ref fn_decl, ref block) |\n+            expr_fn_block(ref fn_decl, ref block) => {\n                 self.resolve_function(FunctionRibKind(expr.id, block.node.id),\n                                       Some(@/*bad*/copy *fn_decl),\n                                       NoTypeParameters,\n                                       (*block),\n                                       NoSelfBinding,\n-                                      HasCaptureClause(capture_clause),\n                                       visitor);\n             }\n \n@@ -5139,18 +5103,12 @@ pub impl Resolver {\n                                     descr: &str) {\n         match pat_binding_mode {\n             bind_infer => {}\n-            bind_by_value => {\n+            bind_by_copy => {\n                 self.session.span_err(\n                     pat.span,\n                     fmt!(\"cannot use `copy` binding mode with %s\",\n                          descr));\n             }\n-            bind_by_move => {\n-                self.session.span_err(\n-                    pat.span,\n-                    fmt!(\"cannot use `move` binding mode with %s\",\n-                         descr));\n-            }\n             bind_by_ref(*) => {\n                 self.session.span_err(\n                     pat.span,"}, {"sha": "2c36d0d088a42cb9c8f1283a5a75ec0c2c4d9caa", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -160,7 +160,6 @@ use middle::trans::datum::*;\n use middle::trans::expr::Dest;\n use middle::trans::expr;\n use middle::trans::glue;\n-use middle::ty::{CopyValue, MoveValue, ReadValue};\n use util::common::indenter;\n \n use core::dvec::DVec;\n@@ -935,7 +934,7 @@ pub fn root_pats_as_necessary(bcx: block,\n                 // for details (look for the case covering cat_discr).\n \n                 let datum = Datum {val: val, ty: node_id_type(bcx, pat_id),\n-                                   mode: ByRef, source: FromLvalue};\n+                                   mode: ByRef, source: ZeroMem};\n                 bcx = datum.root(bcx, root_info);\n                 // If we kept going, we'd only re-root the same value, so\n                 // return now.\n@@ -1091,7 +1090,7 @@ pub fn store_non_ref_bindings(bcx: block,\n             TrByValue(is_move, lldest) => {\n                 let llval = Load(bcx, binding_info.llmatch); // get a T*\n                 let datum = Datum {val: llval, ty: binding_info.ty,\n-                                   mode: ByRef, source: FromLvalue};\n+                                   mode: ByRef, source: ZeroMem};\n                 bcx = {\n                     if is_move {\n                         datum.move_to(bcx, INIT, lldest)\n@@ -1575,30 +1574,19 @@ pub fn trans_match_inner(scope_cx: block,\n         // Note that we use the names because each binding will have many ids\n         // from the various alternatives.\n         let bindings_map = HashMap();\n-        do pat_bindings(tcx.def_map, arm.pats[0]) |bm, p_id, s, path| {\n+        do pat_bindings(tcx.def_map, arm.pats[0]) |bm, p_id, _s, path| {\n             let ident = path_to_ident(path);\n             let variable_ty = node_id_type(bcx, p_id);\n             let llvariable_ty = type_of::type_of(bcx.ccx(), variable_ty);\n \n             let llmatch, trmode;\n             match bm {\n-                ast::bind_by_value | ast::bind_by_move => {\n-                    // in this case, the type of the variable will be T,\n-                    // but we need to store a *T\n-                    let is_move = (bm == ast::bind_by_move);\n-                    llmatch = alloca(bcx, T_ptr(llvariable_ty));\n-                    trmode = TrByValue(is_move, alloca(bcx, llvariable_ty));\n-                }\n-                ast::bind_infer => {\n-                    // in this case also, the type of the variable will be T,\n-                    // but we need to store a *T\n-                    let is_move = match tcx.value_modes.find(p_id) {\n-                        None => {\n-                            tcx.sess.span_bug(s, ~\"no value mode\");\n-                        }\n-                        Some(MoveValue) => true,\n-                        Some(CopyValue) | Some(ReadValue) => false\n-                    };\n+                ast::bind_by_copy | ast::bind_infer => {\n+                    // in this case, the final type of the variable will be T,\n+                    // but during matching we need to store a *T as explained\n+                    // above\n+                    let is_move =\n+                        scope_cx.ccx().maps.moves_map.contains_key(p_id);\n                     llmatch = alloca(bcx, T_ptr(llvariable_ty));\n                     trmode = TrByValue(is_move, alloca(bcx, llvariable_ty));\n                 }\n@@ -1657,7 +1645,8 @@ pub fn trans_match_inner(scope_cx: block,\n         arm_cxs.push(bcx);\n     }\n \n-    return controlflow::join_blocks(scope_cx, dvec::unwrap(move arm_cxs));\n+    bcx = controlflow::join_blocks(scope_cx, dvec::unwrap(move arm_cxs));\n+    return bcx;\n \n     fn mk_fail(bcx: block, sp: span, +msg: ~str,\n                finished: @mut Option<BasicBlockRef>) -> BasicBlockRef {\n@@ -1697,7 +1686,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n             if make_copy {\n                 let binding_ty = node_id_type(bcx, pat.id);\n                 let datum = Datum {val: val, ty: binding_ty,\n-                                   mode: ByRef, source: FromRvalue};\n+                                   mode: ByRef, source: RevokeClean};\n                 let scratch = scratch_datum(bcx, binding_ty, false);\n                 datum.copy_to_datum(bcx, INIT, scratch);\n                 match binding_mode {"}, {"sha": "e7d21cbbe53e910b5a0d26d06cf7204bc9a48325", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -1676,7 +1676,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n             ast::by_ref => {\n                 llarg = raw_llarg;\n             }\n-            ast::by_move | ast::by_copy => {\n+            ast::by_copy => {\n                 // only by value if immediate:\n                 if datum::appropriate_mode(arg_ty.ty).is_by_value() {\n                     let alloc = alloc_ty(bcx, arg_ty.ty);\n@@ -2198,16 +2198,8 @@ pub fn create_main_wrapper(ccx: @crate_ctxt, _sp: span, main_llfn: ValueRef) {\n     create_entry_fn(ccx, llfn);\n \n     fn create_main(ccx: @crate_ctxt, main_llfn: ValueRef) -> ValueRef {\n-        let unit_ty = ty::mk_estr(ccx.tcx, ty::vstore_uniq);\n-        let vecarg_ty: ty::arg =\n-            arg {\n-                mode: ast::expl(ast::by_val),\n-                ty: ty::mk_evec(ccx.tcx,\n-                    ty::mt {ty: unit_ty, mutbl: ast::m_imm},\n-                    ty::vstore_uniq)\n-            };\n         let nt = ty::mk_nil(ccx.tcx);\n-        let llfty = type_of_fn(ccx, ~[vecarg_ty], nt);\n+        let llfty = type_of_fn(ccx, ~[], nt);\n         let llfdecl = decl_fn(ccx.llmod, ~\"_rust_main\",\n                               lib::llvm::CCallConv, llfty);\n \n@@ -2953,7 +2945,7 @@ pub fn trans_crate(sess: session::Session,\n                    tcx: ty::ctxt,\n                    output: &Path,\n                    emap2: resolve::ExportMap2,\n-                   maps: astencode::maps) -> (ModuleRef, link_meta) {\n+                   maps: astencode::Maps) -> (ModuleRef, link_meta) {\n \n     let symbol_hasher = @hash::default_state();\n     let link_meta ="}, {"sha": "850da79290c396a5776e0f8dc2fe632bd7e5f7a1", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -79,7 +79,7 @@ pub fn count_insn(cx: block, category: &str) {\n         s += ~\"/\";\n         s += category;\n \n-        let n = match h.find(s) {\n+        let n = match h.find(/*bad*/ copy s) {\n           Some(n) => n,\n           _ => 0u\n         };"}, {"sha": "91eabaf6ab8515c2aa0cc0dee4e4e6305774d6e4", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -334,7 +334,7 @@ pub fn trans_method_call(in_cx: block,\n \n pub fn trans_rtcall_or_lang_call(bcx: block,\n                                  did: ast::def_id,\n-                                 args: ~[ValueRef],\n+                                 args: &[ValueRef],\n                                  dest: expr::Dest)\n                               -> block {\n     let fty = if did.crate == ast::local_crate {\n@@ -351,7 +351,7 @@ pub fn trans_rtcall_or_lang_call(bcx: block,\n \n pub fn trans_rtcall_or_lang_call_with_type_params(bcx: block,\n                                                   did: ast::def_id,\n-                                                  args: ~[ValueRef],\n+                                                  args: &[ValueRef],\n                                                   type_params: ~[ty::t],\n                                                   dest: expr::Dest)\n                                                -> block {\n@@ -418,11 +418,11 @@ pub fn trans_call_inner(\n     dest: expr::Dest,\n     autoref_arg: AutorefArg) -> block {\n     do base::with_scope(in_cx, call_info, ~\"call\") |cx| {\n-        let ret_in_loop = match /*bad*/copy args {\n+        let ret_in_loop = match args {\n           ArgExprs(args) => {\n             args.len() > 0u && match vec::last(args).node {\n               ast::expr_loop_body(@ast::expr {\n-                node: ast::expr_fn_block(_, ref body, _),\n+                node: ast::expr_fn_block(_, ref body),\n                 _\n               }) =>  body_contains_ret((*body)),\n               _ => false\n@@ -464,7 +464,7 @@ pub fn trans_call_inner(\n             }\n         };\n \n-        let args_res = trans_args(bcx, llenv, /*bad*/copy args, fn_expr_ty,\n+        let args_res = trans_args(bcx, llenv, args, fn_expr_ty,\n                                   dest, ret_flag, autoref_arg);\n         bcx = args_res.bcx;\n         let mut llargs = /*bad*/copy args_res.args;\n@@ -520,9 +520,10 @@ pub fn trans_call_inner(\n     }\n }\n \n+\n pub enum CallArgs {\n-    ArgExprs(~[@ast::expr]),\n-    ArgVals(~[ValueRef])\n+    ArgExprs(&[@ast::expr]),\n+    ArgVals(&[ValueRef])\n }\n \n pub fn trans_args(cx: block,\n@@ -625,7 +626,7 @@ pub fn trans_arg_expr(bcx: block,\n                 ast::expr_loop_body(\n                     // XXX: Bad copy.\n                     blk@@ast::expr {\n-                        node: ast::expr_fn_block(copy decl, ref body, cap),\n+                        node: ast::expr_fn_block(copy decl, ref body),\n                         _\n                     }) =>\n                 {\n@@ -635,12 +636,12 @@ pub fn trans_arg_expr(bcx: block,\n                     let proto = ty::ty_fn_proto(arg_ty);\n                     let bcx = closure::trans_expr_fn(\n                         bcx, proto, decl, /*bad*/copy *body, arg_expr.id,\n-                        blk.id, cap, Some(ret_flag), expr::SaveIn(scratch));\n+                        blk.id, Some(ret_flag), expr::SaveIn(scratch));\n                     DatumBlock {bcx: bcx,\n                                 datum: Datum {val: scratch,\n                                               ty: scratch_ty,\n                                               mode: ByRef,\n-                                              source: FromRvalue}}\n+                                              source: RevokeClean}}\n                 }\n                 _ => {\n                     bcx.sess().impossible_case(\n@@ -670,34 +671,35 @@ pub fn trans_arg_expr(bcx: block,\n     } else {\n         // FIXME(#3548) use the adjustments table\n         match autoref_arg {\n-            DoAutorefArg => { val = arg_datum.to_ref_llval(bcx); }\n+            DoAutorefArg => {\n+                assert !bcx.ccx().maps.moves_map.contains_key(arg_expr.id);\n+                val = arg_datum.to_ref_llval(bcx);\n+            }\n             DontAutorefArg => {\n                 match arg_mode {\n                     ast::by_ref => {\n+                        // This assertion should really be valid, but because\n+                        // the explicit self code currently passes by-ref, it\n+                        // does not hold.\n+                        //\n+                        //assert !bcx.ccx().maps.moves_map.contains_key(\n+                        //    arg_expr.id);\n                         val = arg_datum.to_ref_llval(bcx);\n                     }\n \n                     ast::by_val => {\n                         // NB: avoid running the take glue.\n+\n+                        assert !bcx.ccx().maps.moves_map.contains_key(\n+                            arg_expr.id);\n                         val = arg_datum.to_value_llval(bcx);\n                     }\n \n-                    ast::by_copy | ast::by_move => {\n+                    ast::by_copy => {\n                         let scratch = scratch_datum(bcx, arg_datum.ty, false);\n \n-                        if arg_mode == ast::by_move {\n-                            // NDM---Doesn't seem like this should be\n-                            // necessary\n-                            if !arg_datum.store_will_move() {\n-                                bcx.sess().span_bug(\n-                                    arg_expr.span,\n-                                    fmt!(\"move mode but datum will not \\\n-                                          store: %s\",\n-                                          arg_datum.to_str(bcx.ccx())));\n-                            }\n-                        }\n-\n-                        arg_datum.store_to_datum(bcx, INIT, scratch);\n+                        arg_datum.store_to_datum(bcx, arg_expr.id,\n+                                                 INIT, scratch);\n \n                         // Technically, ownership of val passes to the callee.\n                         // However, we must cleanup should we fail before the"}, {"sha": "52bb8f56218a406514394443cfa84e2acbed47c7", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 43, "deletions": 57, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -15,12 +15,12 @@ use back::link::{mangle_internal_name_by_path_and_seq};\n use back::link::{mangle_internal_name_by_path};\n use lib::llvm::llvm;\n use lib::llvm::{ValueRef, TypeRef};\n-use middle::capture;\n+use middle::moves;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::callee;\n use middle::trans::common::*;\n-use middle::trans::datum::{Datum, INIT, ByRef, ByValue, FromLvalue};\n+use middle::trans::datum::{Datum, INIT, ByRef, ByValue, ZeroMem};\n use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::machine;\n@@ -106,7 +106,7 @@ use syntax::print::pprust::expr_to_str;\n \n pub enum EnvAction {\n     /// Copy the value from this llvm ValueRef into the environment.\n-    EnvStore,\n+    EnvCopy,\n \n     /// Move the value from this llvm ValueRef into the environment.\n     EnvMove,\n@@ -123,7 +123,7 @@ pub struct EnvValue {\n pub impl EnvAction {\n     fn to_str() -> ~str {\n         match self {\n-            EnvStore => ~\"EnvStore\",\n+            EnvCopy => ~\"EnvCopy\",\n             EnvMove => ~\"EnvMove\",\n             EnvRef => ~\"EnvRef\"\n         }\n@@ -151,7 +151,7 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n     // converted to ptrs.\n     let bound_tys = bound_values.map(|bv| {\n         match bv.action {\n-            EnvStore | EnvMove => bv.datum.ty,\n+            EnvCopy | EnvMove => bv.datum.ty,\n             EnvRef => ty::mk_mut_ptr(tcx, bv.datum.ty)\n         }\n     });\n@@ -242,8 +242,8 @@ pub fn store_environment(bcx: block,\n         let bound_data = GEPi(bcx, llbox, [0u, abi::box_field_body, i]);\n \n         match bv.action {\n-            EnvStore => {\n-                bcx = bv.datum.store_to(bcx, INIT, bound_data);\n+            EnvCopy => {\n+                bcx = bv.datum.copy_to(bcx, INIT, bound_data);\n             }\n             EnvMove => {\n                 bcx = bv.datum.move_to(bcx, INIT, bound_data);\n@@ -264,7 +264,7 @@ pub fn store_environment(bcx: block,\n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for store_environment.\n pub fn build_closure(bcx0: block,\n-                     cap_vars: ~[capture::capture_var],\n+                     cap_vars: &[moves::CaptureVar],\n                      proto: ast::Proto,\n                      include_ret_handle: Option<ValueRef>) -> closure_result {\n     let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n@@ -274,27 +274,23 @@ pub fn build_closure(bcx0: block,\n \n     // Package up the captured upvars\n     let mut env_vals = ~[];\n-    for vec::each(cap_vars) |cap_var| {\n+    for cap_vars.each |cap_var| {\n         debug!(\"Building closure: captured variable %?\", *cap_var);\n-        let datum = expr::trans_local_var(bcx, cap_var.def, None);\n+        let datum = expr::trans_local_var(bcx, cap_var.def);\n         match cap_var.mode {\n-            capture::cap_ref => {\n+            moves::CapRef => {\n                 assert proto == ast::ProtoBorrowed;\n                 env_vals.push(EnvValue {action: EnvRef,\n                                         datum: datum});\n             }\n-            capture::cap_copy => {\n-                env_vals.push(EnvValue {action: EnvStore,\n+            moves::CapCopy => {\n+                env_vals.push(EnvValue {action: EnvCopy,\n                                         datum: datum});\n             }\n-            capture::cap_move => {\n+            moves::CapMove => {\n                 env_vals.push(EnvValue {action: EnvMove,\n                                         datum: datum});\n             }\n-            capture::cap_drop => {\n-                bcx = datum.drop_val(bcx);\n-                datum.cancel_clean(bcx);\n-            }\n         }\n     }\n \n@@ -303,7 +299,7 @@ pub fn build_closure(bcx0: block,\n     do option::iter(&include_ret_handle) |flagptr| {\n         // Flag indicating we have returned (a by-ref bool):\n         let flag_datum = Datum {val: *flagptr, ty: ty::mk_bool(tcx),\n-                                mode: ByRef, source: FromLvalue};\n+                                mode: ByRef, source: ZeroMem};\n         env_vals.push(EnvValue {action: EnvRef,\n                                 datum: flag_datum});\n \n@@ -315,7 +311,7 @@ pub fn build_closure(bcx0: block,\n         };\n         let ret_casted = PointerCast(bcx, ret_true, T_ptr(T_nil()));\n         let ret_datum = Datum {val: ret_casted, ty: ty::mk_nil(tcx),\n-                               mode: ByRef, source: FromLvalue};\n+                               mode: ByRef, source: ZeroMem};\n         env_vals.push(EnvValue {action: EnvRef,\n                                 datum: ret_datum});\n     }\n@@ -328,7 +324,7 @@ pub fn build_closure(bcx0: block,\n // with the upvars and type descriptors.\n pub fn load_environment(fcx: fn_ctxt,\n                         cdata_ty: ty::t,\n-                        cap_vars: ~[capture::capture_var],\n+                        cap_vars: &[moves::CaptureVar],\n                         load_ret_handle: bool,\n                         proto: ast::Proto) {\n     let _icx = fcx.insn_ctxt(\"closure::load_environment\");\n@@ -354,20 +350,15 @@ pub fn load_environment(fcx: fn_ctxt,\n \n     // Populate the upvars from the environment.\n     let mut i = 0u;\n-    for vec::each(cap_vars) |cap_var| {\n-        match cap_var.mode {\n-          capture::cap_drop => { /* ignore */ }\n-          _ => {\n-            let mut upvarptr = GEPi(bcx, llcdata, [0u, i]);\n-            match proto {\n-                ast::ProtoBorrowed => { upvarptr = Load(bcx, upvarptr); }\n-                ast::ProtoBox | ast::ProtoUniq | ast::ProtoBare => {}\n-            }\n-            let def_id = ast_util::def_id_of_def(cap_var.def);\n-            fcx.llupvars.insert(def_id.node, upvarptr);\n-            i += 1u;\n-          }\n+    for cap_vars.each |cap_var| {\n+        let mut upvarptr = GEPi(bcx, llcdata, [0u, i]);\n+        match proto {\n+            ast::ProtoBorrowed => { upvarptr = Load(bcx, upvarptr); }\n+            ast::ProtoBox | ast::ProtoUniq | ast::ProtoBare => {}\n         }\n+        let def_id = ast_util::def_id_of_def(cap_var.def);\n+        fcx.llupvars.insert(def_id.node, upvarptr);\n+        i += 1u;\n     }\n     if load_ret_handle {\n         let flagptr = Load(bcx, GEPi(bcx, llcdata, [0u, i]));\n@@ -383,9 +374,9 @@ pub fn trans_expr_fn(bcx: block,\n                      +body: ast::blk,\n                      outer_id: ast::node_id,\n                      user_id: ast::node_id,\n-                     cap_clause: ast::capture_clause,\n                      is_loop_body: Option<Option<ValueRef>>,\n-                     dest: expr::Dest) -> block {\n+                     dest: expr::Dest) -> block\n+{\n     /*!\n      *\n      * Translates the body of a closure expression.\n@@ -426,29 +417,24 @@ pub fn trans_expr_fn(bcx: block,\n                                                  ~\"expr_fn\");\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n \n-    let trans_closure_env: &fn(ast::Proto) -> Result = |proto| {\n-        let cap_vars = capture::compute_capture_vars(ccx.tcx, user_id, proto,\n-                                                     cap_clause);\n-        let ret_handle = match is_loop_body { Some(x) => x, None => None };\n-        // XXX: Bad copy.\n-        let {llbox, cdata_ty, bcx} = build_closure(bcx, copy cap_vars, proto,\n-                                                   ret_handle);\n-        trans_closure(ccx, /*bad*/copy sub_path, decl, /*bad*/copy body,\n-                      llfn, no_self, /*bad*/copy bcx.fcx.param_substs,\n-                      user_id, None, |fcx| {\n-                          load_environment(fcx, cdata_ty, copy cap_vars,\n-                                           ret_handle.is_some(), proto);\n-                      }, |bcx| {\n-                          if is_loop_body.is_some() {\n-                              Store(bcx, C_bool(true), bcx.fcx.llretptr);\n-                          }\n-                      });\n-        rslt(bcx, llbox)\n-    };\n-\n     let Result {bcx: bcx, val: closure} = match proto {\n         ast::ProtoBorrowed | ast::ProtoBox | ast::ProtoUniq => {\n-            trans_closure_env(proto)\n+            let cap_vars = ccx.maps.capture_map.get(user_id);\n+            let ret_handle = match is_loop_body {Some(x) => x,\n+                                                 None => None};\n+            let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, proto,\n+                                                       ret_handle);\n+            trans_closure(ccx, sub_path, decl,\n+                          body, llfn, no_self,\n+                          /*bad*/ copy bcx.fcx.param_substs, user_id, None,\n+                          |fcx| load_environment(fcx, cdata_ty, cap_vars,\n+                                                 ret_handle.is_some(), proto),\n+                          |bcx| {\n+                              if is_loop_body.is_some() {\n+                                  Store(bcx, C_bool(true), bcx.fcx.llretptr);\n+                              }\n+                          });\n+            rslt(bcx, llbox)\n         }\n         ast::ProtoBare => {\n             trans_closure(ccx, sub_path, decl, body, llfn, no_self, None,"}, {"sha": "6a2618412b9101e8166531a99d915003a7bd57a7", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -205,7 +205,7 @@ pub struct crate_ctxt {\n      type_short_names: HashMap<ty::t, ~str>,\n      all_llvm_symbols: Set<~str>,\n      tcx: ty::ctxt,\n-     maps: astencode::maps,\n+     maps: astencode::Maps,\n      stats: stats,\n      upcalls: @upcall::upcalls,\n      tydesc_type: TypeRef,\n@@ -1134,7 +1134,7 @@ pub fn C_u8(i: uint) -> ValueRef {\n // our boxed-and-length-annotated strings.\n pub fn C_cstr(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n     unsafe {\n-        match cx.const_cstr_cache.find(s) {\n+        match cx.const_cstr_cache.find(/*bad*/copy s) {\n           Some(llval) => return llval,\n           None => ()\n         }"}, {"sha": "6498b69fbc0809d9a1344411f48465c5c70f9963", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 55, "deletions": 83, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -41,45 +41,35 @@\n  *   convenient for interfacing with the various code floating around\n  *   that predates datums.\n  *\n- * # Datum sources\n+ * # Datum cleanup styles\n  *\n- * Each datum carries with it an idea of its \"source\".  This indicates\n- * the kind of expression from which the datum originated.  The source\n- * affects what happens when the datum is stored or moved.\n+ * Each datum carries with it an idea of how its value will be cleaned\n+ * up.  This is important after a move, because we need to know how to\n+ * cancel the cleanup (since the value has been moved and therefore does\n+ * not need to be freed).  There are two options:\n  *\n- * There are three options:\n+ * 1. `RevokeClean`: To cancel the cleanup, we invoke `revoke_clean()`.\n+ *    This is used for temporary rvalues.\n  *\n- * 1. `FromRvalue`: This value originates from some temporary rvalue.\n- *    This is therefore the owning reference to the datum.  If the\n- *    datum is stored, then, it will be *moved* into its new home.\n- *    Furthermore, we will not zero out the datum but rather use\n- *    `revoke_clean()` to cancel any cleanup.\n+ * 2. `ZeroMem`: To cancel the cleanup, we zero out the memory where\n+ *    the value resides.  This is used for lvalues.\n  *\n- * 2. `FromLvalue`: This value originates from an lvalue.  If the datum\n- *    is stored, it will be *copied* into its new home.  If the datum\n- *    is moved, it will be zeroed out.\n+ * # Copying, moving, and storing\n  *\n- * 3. `FromLastUseLvalue`: The same as FromLvalue, except that it\n- *    originates from the *last use* of an lvalue.  If the datum is\n- *    stored, then, it will be moved (and zeroed out).\n+ * There are three methods for moving the value into a new\n+ * location:\n  *\n- * # Storing, copying, and moving\n+ * - `copy_to()` will copy the value into a new location, meaning that\n+ *    the value is first mem-copied and then the new location is \"taken\"\n+ *    via the take glue, in effect creating a deep clone.\n  *\n- * There are three kinds of methods for moving the value into a new\n- * location.  *Storing* a datum is probably the one you want to reach\n- * for first: it is used when you will no longer use the datum and\n- * would like to place it somewhere.  It may translate to a copy or a\n- * move, depending on the source of the datum.  After a store, the\n- * datum may or may not be usable anymore, so you must assume it is\n- * not.\n+ * - `move_to()` will copy the value, meaning that the value is mem-copied\n+ *   into its new home and then the cleanup on the this datum is revoked.\n+ *   This is a \"shallow\" clone.  After `move_to()`, the current datum\n+ *   is invalid and should no longer be used.\n  *\n- * Sometimes, though, you want to use an explicit copy or move.  A\n- * copy copies the data from the datum into a new location and\n- * executes the take glue on that location, thus leaving the datum\n- * valid for further use.  Moving, in contrast, copies the data into\n- * the new location and then cancels any cleanups on the current datum\n- * (as appropriate for the source).  No glue code is executed.  After\n- * a move, the datum is no longer usable.\n+ * - `store_to()` either performs a copy or a move by consulting the\n+ *   moves_map computed by `middle::moves`.\n  *\n  * # Scratch datum\n  *\n@@ -133,8 +123,8 @@ pub struct Datum {\n     /// How did this value originate?  This is particularly important\n     /// if the value is MOVED or prematurely DROPPED, because it\n     /// describes how to cancel the cleanup that was scheduled before.\n-    /// See the def'n of the `DatumSource` type.\n-    source: DatumSource\n+    /// See the def'n of the `DatumCleanup` type.\n+    source: DatumCleanup\n }\n \n pub struct DatumBlock {\n@@ -173,32 +163,16 @@ pub impl DatumMode: to_bytes::IterBytes {\n     }\n }\n \n-/// See `Datum Sources` section at the head of this module.\n-pub enum DatumSource {\n-    FromRvalue,\n-    FromLvalue,\n-    FromLastUseLvalue,\n-}\n-\n-pub impl DatumSource {\n-    fn is_rvalue() -> bool {\n-        match self {\n-            FromRvalue => true,\n-            FromLvalue | FromLastUseLvalue => false\n-        }\n-    }\n-\n-    fn is_any_lvalue() -> bool {\n-        match self {\n-            FromRvalue => false,\n-            FromLvalue | FromLastUseLvalue => true\n-        }\n-    }\n+/// See `Datum cleanup styles` section at the head of this module.\n+#[deriving_eq]\n+pub enum DatumCleanup {\n+    RevokeClean,\n+    ZeroMem\n }\n \n pub fn immediate_rvalue(val: ValueRef, ty: ty::t) -> Datum {\n     return Datum {val: val, ty: ty,\n-                  mode: ByValue, source: FromRvalue};\n+                  mode: ByValue, source: RevokeClean};\n }\n \n pub fn immediate_rvalue_bcx(bcx: block,\n@@ -221,7 +195,7 @@ pub fn scratch_datum(bcx: block, ty: ty::t, zero: bool) -> Datum {\n \n     let llty = type_of::type_of(bcx.ccx(), ty);\n     let scratch = alloca_maybe_zeroed(bcx, llty, zero);\n-    Datum { val: scratch, ty: ty, mode: ByRef, source: FromRvalue }\n+    Datum { val: scratch, ty: ty, mode: ByRef, source: RevokeClean }\n }\n \n pub fn appropriate_mode(ty: ty::t) -> DatumMode {\n@@ -241,42 +215,39 @@ pub fn appropriate_mode(ty: ty::t) -> DatumMode {\n }\n \n pub impl Datum {\n-    fn store_will_move() -> bool {\n-        match self.source {\n-            FromRvalue | FromLastUseLvalue => true,\n-            FromLvalue => false\n-        }\n-    }\n-\n-    fn store_to(bcx: block, action: CopyAction, dst: ValueRef) -> block {\n+    fn store_to(bcx: block, id: ast::node_id,\n+                action: CopyAction, dst: ValueRef) -> block {\n         /*!\n          *\n          * Stores this value into its final home.  This moves if\n-         * possible, but copies otherwise. */\n+         * `id` is located in the move table, but copies otherwise.\n+         */\n \n-        if self.store_will_move() {\n+        if bcx.ccx().maps.moves_map.contains_key(id) {\n             self.move_to(bcx, action, dst)\n         } else {\n             self.copy_to(bcx, action, dst)\n         }\n     }\n \n-    fn store_to_dest(bcx: block, dest: expr::Dest) -> block {\n+    fn store_to_dest(bcx: block, id: ast::node_id,\n+                     dest: expr::Dest) -> block {\n         match dest {\n             expr::Ignore => {\n                 return bcx;\n             }\n             expr::SaveIn(addr) => {\n-                return self.store_to(bcx, INIT, addr);\n+                return self.store_to(bcx, id, INIT, addr);\n             }\n         }\n     }\n \n-    fn store_to_datum(bcx: block, action: CopyAction, datum: Datum) -> block {\n+    fn store_to_datum(bcx: block, id: ast::node_id,\n+                      action: CopyAction, datum: Datum) -> block {\n         debug!(\"store_to_datum(self=%s, action=%?, datum=%s)\",\n                self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n         assert datum.mode.is_by_ref();\n-        self.store_to(bcx, action, datum.val)\n+        self.store_to(bcx, id, action, datum.val)\n     }\n \n     fn move_to_datum(bcx: block, action: CopyAction, datum: Datum) -> block {\n@@ -396,7 +367,7 @@ pub impl Datum {\n          * Schedules this datum for cleanup in `bcx`.  The datum\n          * must be an rvalue. */\n \n-        assert self.source.is_rvalue();\n+        assert self.source == RevokeClean;\n         match self.mode {\n             ByValue => {\n                 add_clean_temp_immediate(bcx, self.val, self.ty);\n@@ -410,10 +381,10 @@ pub impl Datum {\n     fn cancel_clean(bcx: block) {\n         if ty::type_needs_drop(bcx.tcx(), self.ty) {\n             match self.source {\n-                FromRvalue => {\n+                RevokeClean => {\n                     revoke_clean(bcx, self.val);\n                 }\n-                FromLvalue | FromLastUseLvalue => {\n+                ZeroMem => {\n                     // Lvalues which potentially need to be dropped\n                     // must be passed by ref, so that we can zero them\n                     // out.\n@@ -444,7 +415,7 @@ pub impl Datum {\n             ByValue => self,\n             ByRef => {\n                 Datum {val: self.to_value_llval(bcx), mode: ByValue,\n-                       ty: self.ty, source: FromRvalue}\n+                       ty: self.ty, source: RevokeClean}\n             }\n         }\n     }\n@@ -476,7 +447,7 @@ pub impl Datum {\n             ByRef => self,\n             ByValue => {\n                 Datum {val: self.to_ref_llval(bcx), mode: ByRef,\n-                       ty: self.ty, source: FromRvalue}\n+                       ty: self.ty, source: RevokeClean}\n             }\n         }\n     }\n@@ -527,7 +498,7 @@ pub impl Datum {\n     fn GEPi(bcx: block,\n             ixs: &[uint],\n             ty: ty::t,\n-            source: DatumSource)\n+            source: DatumCleanup)\n          -> Datum {\n         let base_val = self.to_ref_llval(bcx);\n         Datum {\n@@ -618,7 +589,7 @@ pub impl Datum {\n \n         let ptr = self.to_value_llval(bcx);\n         let body = opaque_box_body(bcx, content_ty, ptr);\n-        Datum {val: body, ty: content_ty, mode: ByRef, source: FromLvalue}\n+        Datum {val: body, ty: content_ty, mode: ByRef, source: ZeroMem}\n     }\n \n     fn to_rptr(bcx: block) -> Datum {\n@@ -636,7 +607,7 @@ pub impl Datum {\n         let rptr_ty = ty::mk_imm_rptr(bcx.tcx(), ty::re_static,\n                                       self.ty);\n         Datum {val: llval, ty: rptr_ty,\n-               mode: ByValue, source: FromRvalue}\n+               mode: ByValue, source: RevokeClean}\n     }\n \n     fn try_deref(\n@@ -701,7 +672,7 @@ pub impl Datum {\n                                 val: PointerCast(bcx, self.val, llty),\n                                 ty: ty,\n                                 mode: ByRef,\n-                                source: FromLvalue\n+                                source: ZeroMem\n                             }),\n                             bcx\n                         )\n@@ -740,7 +711,7 @@ pub impl Datum {\n                                 val: GEPi(bcx, self.val, [0, 0, 0]),\n                                 ty: ty,\n                                 mode: ByRef,\n-                                source: FromLvalue\n+                                source: ZeroMem\n                             }),\n                             bcx\n                         )\n@@ -768,7 +739,7 @@ pub impl Datum {\n                 val: lv.to_value_llval(bcx),\n                 ty: ty,\n                 mode: ByRef,\n-                source: FromLvalue // *p is an lvalue\n+                source: ZeroMem // *p is an lvalue\n             }\n         }\n     }\n@@ -841,8 +812,9 @@ pub impl DatumBlock {\n         self.datum.drop_val(self.bcx)\n     }\n \n-    fn store_to(action: CopyAction, dst: ValueRef) -> block {\n-        self.datum.store_to(self.bcx, action, dst)\n+    fn store_to(id: ast::node_id, action: CopyAction,\n+                dst: ValueRef) -> block {\n+        self.datum.store_to(self.bcx, id, action, dst)\n     }\n \n     fn copy_to(action: CopyAction, dst: ValueRef) -> block {"}, {"sha": "7d724ef74419a2dbd167b2584431291fc82a5e09", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -789,10 +789,10 @@ pub fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n       }\n       ast_map::node_expr(expr) => {\n         match /*bad*/copy expr.node {\n-          ast::expr_fn(_, decl, _, _) => {\n+          ast::expr_fn(_, decl, _) => {\n             ((dbg_cx.names)(~\"fn\"), decl.output, expr.id)\n           }\n-          ast::expr_fn_block(decl, _, _) => {\n+          ast::expr_fn_block(decl, _) => {\n             ((dbg_cx.names)(~\"fn\"), decl.output, expr.id)\n           }\n           _ => fcx.ccx.sess.span_bug(expr.span,\n@@ -818,7 +818,7 @@ pub fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     }\n \n     let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n-    let file_node = create_file(cx, loc.file.name).node;\n+    let file_node = create_file(cx, copy loc.file.name).node;\n     let ty_node = if cx.sess.opts.extra_debuginfo {\n         match ret_ty.node {\n           ast::ty_nil => llnull(),"}, {"sha": "2a8a6a696c2ff1fe48d3a4da5c3fe1edaeb09e5e", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 281, "deletions": 267, "changes": 548, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -12,45 +12,53 @@\n \n # Translation of expressions.\n \n-## User's guide\n-\n-If you wish to translate an expression, there are two basic modes:\n-\n-1. `trans_into(block, expr, Dest) -> block`\n-2. `trans_to_datum(block, expr) -> DatumBlock`\n-\n-`trans_into()` is the preferred form to use whenever possible.  It\n-evaluates the expression and stores its result into `Dest`, which\n-must either be the special flag ignore (throw the result away) or\n-be a pointer to memory of the same type/size as the expression.\n-\n-Sometimes, though, you just want to evaluate the expression into\n-some memory location so you can go and inspect it (e.g., a `match`\n-expression).  In that case, `trans_to_datum()` is your friend.  It\n-will evaluate the expression and return a `Datum` describing where\n-the result is to be found.  This function tries to return its\n-result in the most efficient way possible, without introducing\n-extra copies or sacrificing information.  Therefore, for lvalue\n-expressions, you always get a by-ref `Datum` in return that points\n-at the memory for this lvalue (almost, see [1]).  For rvalue\n-expressions, we will return a by-value `Datum` whenever possible,\n-but it is often necessary to allocate a stack slot, store the\n-result of the rvalue in there, and then return a pointer to the\n-slot (see the discussion later on about the different kinds of\n-rvalues).\n-\n-## More specific functions\n-\n-The two functions above are the most general and can handle any\n-situation, but there are a few other functions that are useful\n-in specific scenarios:\n-\n-- `trans_lvalue()` is exactly like `trans_to_datum()` but it only\n-  works on lvalues.  This is mostly used as an assertion for those\n-  places where only an lvalue is expected.  It also guarantees that\n-  you will get a by-ref Datum back (almost, see [1]).\n-- `trans_local_var()` can be used to trans a ref to a local variable\n-  that is not an expression.\n+## Recommended entry point\n+\n+If you wish to translate an expression, the preferred way to do\n+so is to use:\n+\n+    expr::trans_into(block, expr, Dest) -> block\n+\n+This will generate code that evaluates `expr`, storing the result into\n+`Dest`, which must either be the special flag ignore (throw the result\n+away) or be a pointer to memory of the same type/size as the\n+expression.  It returns the resulting basic block.  This form will\n+handle all automatic adjustments and moves for you.\n+\n+## Translation to a datum\n+\n+In some cases, `trans_into()` is too narrow of an interface.\n+Generally this occurs either when you know that the result value is\n+going to be a scalar, or when you need to evaluate the expression into\n+some memory location so you can go and inspect it (e.g., assignments,\n+`match` expressions, the `&` operator).\n+\n+In such cases, you want the following function:\n+\n+    trans_to_datum(block, expr) -> DatumBlock\n+\n+This function generates code to evaluate the expression and return a\n+`Datum` describing where the result is to be found.  This function\n+tries to return its result in the most efficient way possible, without\n+introducing extra copies or sacrificing information.  Therefore, for\n+lvalue expressions, you always get a by-ref `Datum` in return that\n+points at the memory for this lvalue (almost, see [1]).  For rvalue\n+expressions, we will return a by-value `Datum` whenever possible, but\n+it is often necessary to allocate a stack slot, store the result of\n+the rvalue in there, and then return a pointer to the slot (see the\n+discussion later on about the different kinds of rvalues).\n+\n+NB: The `trans_to_datum()` function does perform adjustments, but\n+since it returns a pointer to the value \"in place\" it does not handle\n+any moves that may be relevant.  If you are transing an expression\n+whose result should be moved, you should either use the Datum methods\n+`move_to()` (for unconditional moves) or `store_to()` (for moves\n+conditioned on the type of the expression) at some point.\n+\n+## Translating local variables\n+\n+`trans_local_var()` can be used to trans a ref to a local variable\n+that is not an expression.  This is needed for captures.\n \n ## Ownership and cleanups\n \n@@ -127,7 +135,6 @@ use middle::trans::datum::*;\n use middle::trans::machine;\n use middle::trans::meth;\n use middle::trans::tvec;\n-use middle::ty::MoveValue;\n use middle::ty::struct_mutable_fields;\n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn};\n use util::common::indenter;\n@@ -258,21 +265,70 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n }\n \n pub fn trans_into(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n-    return match bcx.tcx().adjustments.find(expr.id) {\n-        None => trans_into_unadjusted(bcx, expr, dest),\n-        Some(_) => {\n-            // use trans_to_datum, which is mildly less efficient but\n-            // which will perform the adjustments:\n-            let datumblock = trans_to_datum(bcx, expr);\n+    if bcx.tcx().adjustments.contains_key(expr.id) {\n+        // use trans_to_datum, which is mildly less efficient but\n+        // which will perform the adjustments:\n+        let datumblock = trans_to_datum(bcx, expr);\n+        return match dest {\n+            Ignore => datumblock.bcx,\n+            SaveIn(lldest) => datumblock.store_to(expr.id, INIT, lldest)\n+        };\n+    }\n+\n+    let ty = expr_ty(bcx, expr);\n+\n+    debug!(\"trans_into_unadjusted(expr=%s, dest=%s)\",\n+           bcx.expr_to_str(expr),\n+           dest.to_str(bcx.ccx()));\n+    let _indenter = indenter();\n+\n+    debuginfo::update_source_pos(bcx, expr.span);\n+\n+    let dest = {\n+        if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n+            Ignore\n+        } else {\n+            dest\n+        }\n+    };\n+\n+    let kind = bcx.expr_kind(expr);\n+    debug!(\"expr kind = %?\", kind);\n+    return match kind {\n+        ty::LvalueExpr => {\n+            let datumblock = trans_lvalue_unadjusted(bcx, expr);\n             match dest {\n                 Ignore => datumblock.bcx,\n-                SaveIn(lldest) => datumblock.store_to(INIT, lldest)\n+                SaveIn(lldest) => datumblock.store_to(expr.id, INIT, lldest)\n             }\n         }\n-    }\n+        ty::RvalueDatumExpr => {\n+            let datumblock = trans_rvalue_datum_unadjusted(bcx, expr);\n+            match dest {\n+                Ignore => datumblock.drop_val(),\n+\n+                // NB: We always do `move_to()` regardless of the\n+                // moves_map because we're processing an rvalue\n+                SaveIn(lldest) => datumblock.move_to(INIT, lldest)\n+            }\n+        }\n+        ty::RvalueDpsExpr => {\n+            trans_rvalue_dps_unadjusted(bcx, expr, dest)\n+        }\n+        ty::RvalueStmtExpr => {\n+            trans_rvalue_stmt_unadjusted(bcx, expr)\n+        }\n+    };\n }\n \n fn trans_lvalue(bcx: block, expr: @ast::expr) -> DatumBlock {\n+    /*!\n+     *\n+     * Translates an lvalue expression, always yielding a by-ref\n+     * datum.  Generally speaking you should call trans_to_datum()\n+     * instead, but sometimes we call trans_lvalue() directly as a\n+     * means of asserting that a particular expression is an lvalue. */\n+\n     return match bcx.tcx().adjustments.find(expr.id) {\n         None => trans_lvalue_unadjusted(bcx, expr),\n         Some(_) => {\n@@ -350,50 +406,6 @@ fn trans_to_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     }\n }\n \n-fn trans_into_unadjusted(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n-    let ty = expr_ty(bcx, expr);\n-\n-    debug!(\"trans_into_unadjusted(expr=%s, dest=%s)\",\n-           bcx.expr_to_str(expr),\n-           dest.to_str(bcx.ccx()));\n-    let _indenter = indenter();\n-\n-    debuginfo::update_source_pos(bcx, expr.span);\n-\n-    let dest = {\n-        if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n-            Ignore\n-        } else {\n-            dest\n-        }\n-    };\n-\n-    let kind = bcx.expr_kind(expr);\n-    debug!(\"expr kind = %?\", kind);\n-    match kind {\n-        ty::LvalueExpr => {\n-            let datumblock = trans_lvalue_unadjusted(bcx, expr);\n-            match dest {\n-                Ignore => datumblock.bcx,\n-                SaveIn(lldest) => datumblock.store_to(INIT, lldest)\n-            }\n-        }\n-        ty::RvalueDatumExpr => {\n-            let datumblock = trans_rvalue_datum_unadjusted(bcx, expr);\n-            match dest {\n-                Ignore => datumblock.drop_val(),\n-                SaveIn(lldest) => datumblock.store_to(INIT, lldest)\n-            }\n-        }\n-        ty::RvalueDpsExpr => {\n-            return trans_rvalue_dps_unadjusted(bcx, expr, dest);\n-        }\n-        ty::RvalueStmtExpr => {\n-            return trans_rvalue_stmt_unadjusted(bcx, expr);\n-        }\n-    }\n-}\n-\n fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     let _icx = bcx.insn_ctxt(\"trans_rvalue_datum_unadjusted\");\n \n@@ -472,9 +484,12 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n             return controlflow::trans_loop(bcx, (*body), opt_label);\n         }\n         ast::expr_assign(dst, src) => {\n-            let src_datum = unpack_datum!(bcx, trans_to_datum(bcx, src));\n-            let dst_datum = unpack_datum!(bcx, trans_lvalue(bcx, dst));\n-            return src_datum.store_to_datum(bcx, DROP_EXISTING, dst_datum);\n+            let src_datum = unpack_datum!(\n+                bcx, trans_to_datum(bcx, src));\n+            let dst_datum = unpack_datum!(\n+                bcx, trans_lvalue(bcx, dst));\n+            return src_datum.store_to_datum(\n+                bcx, src.id, DROP_EXISTING, dst_datum);\n         }\n         ast::expr_swap(dst, src) => {\n             let dst_datum = unpack_datum!(bcx, trans_lvalue(bcx, dst));\n@@ -509,8 +524,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n \n     trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n \n-    // XXX: This copy is really bad.\n-    match /*bad*/copy expr.node {\n+    match expr.node {\n         ast::expr_paren(e) => {\n             return trans_rvalue_dps_unadjusted(bcx, e, dest);\n         }\n@@ -519,14 +533,14 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n                                             bcx.def(expr.id), dest);\n         }\n         ast::expr_if(cond, ref thn, els) => {\n-            return controlflow::trans_if(bcx, cond, (*thn), els, dest);\n+            return controlflow::trans_if(bcx, cond, *thn, els, dest);\n         }\n         ast::expr_match(discr, ref arms) => {\n             return _match::trans_match(bcx, expr, discr, /*bad*/copy *arms,\n                                        dest);\n         }\n         ast::expr_block(ref blk) => {\n-            return do base::with_scope(bcx, (*blk).info(),\n+            return do base::with_scope(bcx, blk.info(),\n                                        ~\"block-expr body\") |bcx| {\n                 controlflow::trans_block(bcx, (*blk), dest)\n             };\n@@ -535,8 +549,8 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         ast::expr_struct(_, ref fields, base) => {\n             return trans_rec_or_struct(bcx, (*fields), base, expr.id, dest);\n         }\n-        ast::expr_tup(args) => {\n-            return trans_tup(bcx, args, dest);\n+        ast::expr_tup(ref args) => {\n+            return trans_tup(bcx, *args, dest);\n         }\n         ast::expr_lit(@ast::spanned {node: ast::lit_str(s), _}) => {\n             return tvec::trans_lit_str(bcx, expr, s, dest);\n@@ -552,15 +566,15 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             return tvec::trans_fixed_vstore(bcx, expr, expr, dest);\n         }\n         // XXX: Bad copy.\n-        ast::expr_fn(proto, copy decl, ref body, cap_clause) => {\n+        ast::expr_fn(proto, copy decl, ref body) => {\n             // Don't use this function for anything real. Use the one in\n             // astconv instead.\n             return closure::trans_expr_fn(bcx, proto, decl,\n                                           /*bad*/copy *body,\n                                           expr.id, expr.id,\n-                                          cap_clause, None, dest);\n+                                          None, dest);\n         }\n-        ast::expr_fn_block(ref decl, ref body, cap_clause) => {\n+        ast::expr_fn_block(ref decl, ref body) => {\n             let expr_ty = expr_ty(bcx, expr);\n             match ty::get(expr_ty).sty {\n                 ty::ty_fn(ref fn_ty) => {\n@@ -570,7 +584,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n                     return closure::trans_expr_fn(\n                         bcx, fn_ty.meta.proto, /*bad*/copy *decl,\n                         /*bad*/copy *body, expr.id, expr.id,\n-                        cap_clause, None, dest);\n+                        None, dest);\n                 }\n                 _ => {\n                     bcx.sess().impossible_case(\n@@ -582,15 +596,14 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             match ty::get(expr_ty(bcx, expr)).sty {\n                 ty::ty_fn(ref fn_ty) => {\n                     match blk.node {\n-                        ast::expr_fn_block(copy decl, ref body, cap) => {\n+                        ast::expr_fn_block(copy decl, ref body) => {\n                             return closure::trans_expr_fn(\n                                 bcx,\n                                 fn_ty.meta.proto,\n                                 decl,\n                                 /*bad*/copy *body,\n                                 expr.id,\n                                 blk.id,\n-                                cap,\n                                 Some(None),\n                                 dest);\n                         }\n@@ -613,26 +626,15 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         ast::expr_copy(a) => {\n             return trans_into(bcx, a, dest);\n         }\n-        ast::expr_unary_move(a) => {\n-            if bcx.expr_is_lval(a) {\n-                let datum = unpack_datum!(bcx, trans_to_datum(bcx, a));\n-                return match dest {\n-                    Ignore => drop_and_cancel_clean(bcx, datum),\n-                    SaveIn(addr) => datum.move_to(bcx, INIT, addr)\n-                };\n-            } else {\n-                return trans_into(bcx, a, dest);\n-            }\n-        }\n-        ast::expr_call(f, args, _) => {\n+        ast::expr_call(f, ref args, _) => {\n             return callee::trans_call(\n-                bcx, expr, f, callee::ArgExprs(args), expr.id, dest);\n+                bcx, expr, f, callee::ArgExprs(*args), expr.id, dest);\n         }\n-        ast::expr_method_call(rcvr, _, _, args, _) => {\n+        ast::expr_method_call(rcvr, _, _, ref args, _) => {\n             return callee::trans_method_call(bcx,\n                                              expr,\n                                              rcvr,\n-                                             callee::ArgExprs(args),\n+                                             callee::ArgExprs(*args),\n                                              dest);\n         }\n         ast::expr_binary(_, lhs, rhs) => {\n@@ -727,9 +729,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     /*!\n      *\n      * Translates an lvalue expression, always yielding a by-ref\n-     * datum.  Generally speaking you should call trans_to_datum()\n-     * instead, but sometimes we call trans_lvalue() directly as a\n-     * means of asserting that a particular expression is an lvalue. */\n+     * datum.  Does not apply any adjustments. */\n \n     let _icx = bcx.insn_ctxt(\"trans_lval\");\n     let mut bcx = bcx;\n@@ -752,6 +752,17 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     return DatumBlock {bcx: bcx, datum: unrooted_datum};\n \n     fn unrooted(bcx: block, expr: @ast::expr) -> DatumBlock {\n+        /*!\n+         *\n+         * Translates `expr`.  Note that this version generally\n+         * yields an unrooted, unmoved version.  Rooting and possible\n+         * moves are dealt with above in trans_lvalue_unadjusted().\n+         *\n+         * One exception is if `expr` refers to a local variable,\n+         * in which case the source may already be FromMovedLvalue\n+         * if appropriate.\n+         */\n+\n         let mut bcx = bcx;\n \n         match expr.node {\n@@ -762,7 +773,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                 return trans_def_lvalue(bcx, expr, bcx.def(expr.id));\n             }\n             ast::expr_field(base, ident, _) => {\n-                return trans_rec_field(bcx, base, ident, expr.id);\n+                return trans_rec_field(bcx, base, ident);\n             }\n             ast::expr_index(base, idx) => {\n                 return trans_index(bcx, expr, base, idx);\n@@ -779,60 +790,160 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n             }\n         }\n     }\n-}\n \n-fn trans_def_lvalue(bcx: block,\n-                    ref_expr: @ast::expr,\n-                    def: ast::def)\n-                 -> DatumBlock {\n-    let _icx = bcx.insn_ctxt(\"trans_def_lvalue\");\n-    let ccx = bcx.ccx();\n-    match def {\n-        ast::def_const(did) => {\n-            let const_ty = expr_ty(bcx, ref_expr);\n-            let val = if did.crate == ast::local_crate {\n-                // The LLVM global has the type of its initializer,\n-                // which may not be equal to the enum's type for\n-                // non-C-like enums.\n-                PointerCast(bcx, base::get_item_val(ccx, did.node),\n-                            T_ptr(type_of(bcx.ccx(), const_ty)))\n-            } else {\n-                base::trans_external_path(ccx, did, const_ty)\n-            };\n+    fn trans_rec_field(bcx: block,\n+                       base: @ast::expr,\n+                       field: ast::ident) -> DatumBlock {\n+        /*!\n+         *\n+         * Translates `base.field`.  Note that this version always\n+         * yields an unrooted, unmoved version.  Rooting and possible\n+         * moves are dealt with above in trans_lvalue_unadjusted().\n+         */\n+\n+        let mut bcx = bcx;\n+        let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n+\n+        let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n+        do with_field_tys(bcx.tcx(), base_datum.ty, None) |_dtor, field_tys| {\n+            let ix = ty::field_idx_strict(bcx.tcx(), field, field_tys);\n             DatumBlock {\n-                bcx: bcx,\n-                datum: Datum {val: val,\n-                              ty: const_ty,\n-                              mode: ByRef,\n-                              source: FromLvalue}\n+                datum: base_datum.GEPi(bcx,\n+                                       [0u, 0u, ix],\n+                                       field_tys[ix].mt.ty,\n+                                       ZeroMem),\n+                bcx: bcx\n             }\n         }\n-        _ => {\n-            DatumBlock {\n-                bcx: bcx,\n-                datum: trans_local_var(bcx, def, Some(ref_expr.id))\n+    }\n+\n+    fn trans_index(bcx: block,\n+                   index_expr: @ast::expr,\n+                   base: @ast::expr,\n+                   idx: @ast::expr) -> DatumBlock {\n+        /*!\n+         *\n+         * Translates `base[idx]`.  Note that this version always\n+         * yields an unrooted, unmoved version.  Rooting and possible\n+         * moves are dealt with above in trans_lvalue_unadjusted().\n+         */\n+\n+        let _icx = bcx.insn_ctxt(\"trans_index\");\n+        let ccx = bcx.ccx();\n+        let base_ty = expr_ty(bcx, base);\n+        let mut bcx = bcx;\n+\n+        let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n+\n+        // Translate index expression and cast to a suitable LLVM integer.\n+        // Rust is less strict than LLVM in this regard.\n+        let Result {bcx, val: ix_val} = trans_to_datum(bcx, idx).to_result();\n+        let ix_size = machine::llbitsize_of_real(bcx.ccx(), val_ty(ix_val));\n+        let int_size = machine::llbitsize_of_real(bcx.ccx(), ccx.int_type);\n+        let ix_val = {\n+            if ix_size < int_size {\n+                if ty::type_is_signed(expr_ty(bcx, idx)) {\n+                    SExt(bcx, ix_val, ccx.int_type)\n+                } else { ZExt(bcx, ix_val, ccx.int_type) }\n+            } else if ix_size > int_size {\n+                Trunc(bcx, ix_val, ccx.int_type)\n+            } else {\n+                ix_val\n+            }\n+        };\n+\n+        let vt = tvec::vec_types(bcx, base_datum.ty);\n+        base::maybe_name_value(bcx.ccx(), vt.llunit_size, ~\"unit_sz\");\n+        let scaled_ix = Mul(bcx, ix_val, vt.llunit_size);\n+        base::maybe_name_value(bcx.ccx(), scaled_ix, ~\"scaled_ix\");\n+\n+        let mut (base, len) = base_datum.get_base_and_len(bcx);\n+\n+        if ty::type_is_str(base_ty) {\n+            // acccount for null terminator in the case of string\n+            len = Sub(bcx, len, C_uint(bcx.ccx(), 1u));\n+        }\n+\n+        debug!(\"trans_index: base %s\", val_str(bcx.ccx().tn, base));\n+        debug!(\"trans_index: len %s\", val_str(bcx.ccx().tn, len));\n+\n+        let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, len);\n+        let bcx = do with_cond(bcx, bounds_check) |bcx| {\n+            let unscaled_len = UDiv(bcx, len, vt.llunit_size);\n+            controlflow::trans_fail_bounds_check(bcx, index_expr.span,\n+                                                 ix_val, unscaled_len)\n+        };\n+        let elt = InBoundsGEP(bcx, base, ~[ix_val]);\n+        let elt = PointerCast(bcx, elt, T_ptr(vt.llunit_ty));\n+        return DatumBlock {\n+            bcx: bcx,\n+            datum: Datum {val: elt,\n+                          ty: vt.unit_ty,\n+                          mode: ByRef,\n+                          source: ZeroMem}\n+        };\n+    }\n+\n+    fn trans_def_lvalue(bcx: block,\n+                        ref_expr: @ast::expr,\n+                        def: ast::def)\n+        -> DatumBlock\n+    {\n+        /*!\n+         *\n+         * Translates a reference to a path.  Note that this version\n+         * generally yields an unrooted, unmoved version.  Rooting and\n+         * possible moves are dealt with above in\n+         * trans_lvalue_unadjusted(), with the caveat that local variables\n+         * may already be in move mode.\n+         */\n+\n+        let _icx = bcx.insn_ctxt(\"trans_def_lvalue\");\n+        let ccx = bcx.ccx();\n+        match def {\n+            ast::def_const(did) => {\n+                let const_ty = expr_ty(bcx, ref_expr);\n+                let val = if did.crate == ast::local_crate {\n+                    // The LLVM global has the type of its initializer,\n+                    // which may not be equal to the enum's type for\n+                    // non-C-like enums.\n+                    PointerCast(bcx, base::get_item_val(ccx, did.node),\n+                                T_ptr(type_of(bcx.ccx(), const_ty)))\n+                } else {\n+                    base::trans_external_path(ccx, did, const_ty)\n+                };\n+                DatumBlock {\n+                    bcx: bcx,\n+                    datum: Datum {val: val,\n+                                  ty: const_ty,\n+                                  mode: ByRef,\n+                                  source: ZeroMem}\n+                }\n+            }\n+            _ => {\n+                DatumBlock {\n+                    bcx: bcx,\n+                    datum: trans_local_var(bcx, def)\n+                }\n             }\n         }\n     }\n }\n \n-pub fn trans_local_var(bcx: block,\n-                       def: ast::def,\n-                       expr_id_opt: Option<ast::node_id>)\n-                    -> Datum {\n+pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n     let _icx = bcx.insn_ctxt(\"trans_local_var\");\n \n     return match def {\n         ast::def_upvar(nid, _, _, _) => {\n-            // Can't move upvars, so this is never a FromLvalueLastUse.\n+            // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n             match bcx.fcx.llupvars.find(nid) {\n                 Some(val) => {\n                     Datum {\n                         val: val,\n                         ty: local_ty,\n                         mode: ByRef,\n-                        source: FromLvalue\n+                        source: ZeroMem\n                     }\n                 }\n                 None => {\n@@ -842,10 +953,10 @@ pub fn trans_local_var(bcx: block,\n             }\n         }\n         ast::def_arg(nid, _, _) => {\n-            take_local(bcx, bcx.fcx.llargs, nid, expr_id_opt)\n+            take_local(bcx, bcx.fcx.llargs, nid)\n         }\n         ast::def_local(nid, _) | ast::def_binding(nid, _) => {\n-            take_local(bcx, bcx.fcx.lllocals, nid, expr_id_opt)\n+            take_local(bcx, bcx.fcx.lllocals, nid)\n         }\n         ast::def_self(nid, _) => {\n             let self_info: ValSelfData = match bcx.fcx.llself {\n@@ -867,7 +978,7 @@ pub fn trans_local_var(bcx: block,\n                 val: casted_val,\n                 ty: self_info.t,\n                 mode: ByRef,\n-                source: source_from_opt_lvalue_type(bcx.tcx(), expr_id_opt)\n+                source: ZeroMem\n             }\n         }\n         _ => {\n@@ -878,8 +989,7 @@ pub fn trans_local_var(bcx: block,\n \n     fn take_local(bcx: block,\n                   table: HashMap<ast::node_id, local_val>,\n-                  nid: ast::node_id,\n-                  expr_id_opt: Option<ast::node_id>) -> Datum {\n+                  nid: ast::node_id) -> Datum {\n         let (v, mode) = match table.find(nid) {\n             Some(local_mem(v)) => (v, ByRef),\n             Some(local_imm(v)) => (v, ByValue),\n@@ -897,7 +1007,7 @@ pub fn trans_local_var(bcx: block,\n             val: v,\n             ty: ty,\n             mode: mode,\n-            source: source_from_opt_lvalue_type(bcx.tcx(), expr_id_opt)\n+            source: ZeroMem\n         }\n     }\n }\n@@ -981,102 +1091,6 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n     }\n }\n \n-fn trans_rec_field(bcx: block,\n-                   base: @ast::expr,\n-                   field: ast::ident,\n-                   expr_id: ast::node_id) -> DatumBlock {\n-    let mut bcx = bcx;\n-    let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n-\n-    let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n-    do with_field_tys(bcx.tcx(), base_datum.ty, None) |_dtor, field_tys| {\n-        let ix = ty::field_idx_strict(bcx.tcx(), field, field_tys);\n-        DatumBlock {\n-            datum: base_datum.GEPi(bcx,\n-                                   [0u, 0u, ix],\n-                                   field_tys[ix].mt.ty,\n-                                   source_from_opt_lvalue_type(\n-                                        bcx.tcx(), Some(expr_id))),\n-            bcx: bcx\n-        }\n-    }\n-}\n-\n-fn source_from_opt_lvalue_type(tcx: ty::ctxt,\n-                               expr_id_opt: Option<ast::node_id>)\n-                            -> DatumSource {\n-    match expr_id_opt {\n-        None => FromLvalue,\n-        Some(expr_id) => {\n-            match tcx.value_modes.find(expr_id) {\n-                Some(MoveValue) => FromLastUseLvalue,\n-                Some(_) | None => FromLvalue,\n-            }\n-        }\n-    }\n-}\n-\n-fn trans_index(bcx: block,\n-               index_expr: @ast::expr,\n-               base: @ast::expr,\n-               idx: @ast::expr) -> DatumBlock {\n-    let _icx = bcx.insn_ctxt(\"trans_index\");\n-    let ccx = bcx.ccx();\n-    let base_ty = expr_ty(bcx, base);\n-    let mut bcx = bcx;\n-\n-    let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n-\n-    // Translate index expression and cast to a suitable LLVM integer.\n-    // Rust is less strict than LLVM in this regard.\n-    let Result {bcx, val: ix_val} = trans_to_datum(bcx, idx).to_result();\n-    let ix_size = machine::llbitsize_of_real(bcx.ccx(), val_ty(ix_val));\n-    let int_size = machine::llbitsize_of_real(bcx.ccx(), ccx.int_type);\n-    let ix_val = {\n-        if ix_size < int_size {\n-            if ty::type_is_signed(expr_ty(bcx, idx)) {\n-                SExt(bcx, ix_val, ccx.int_type)\n-            } else { ZExt(bcx, ix_val, ccx.int_type) }\n-        } else if ix_size > int_size {\n-            Trunc(bcx, ix_val, ccx.int_type)\n-        } else {\n-            ix_val\n-        }\n-    };\n-\n-    let vt = tvec::vec_types(bcx, base_datum.ty);\n-    base::maybe_name_value(bcx.ccx(), vt.llunit_size, ~\"unit_sz\");\n-    let scaled_ix = Mul(bcx, ix_val, vt.llunit_size);\n-    base::maybe_name_value(bcx.ccx(), scaled_ix, ~\"scaled_ix\");\n-\n-    let mut (base, len) = base_datum.get_base_and_len(bcx);\n-\n-    if ty::type_is_str(base_ty) {\n-        // acccount for null terminator in the case of string\n-        len = Sub(bcx, len, C_uint(bcx.ccx(), 1u));\n-    }\n-\n-    debug!(\"trans_index: base %s\", val_str(bcx.ccx().tn, base));\n-    debug!(\"trans_index: len %s\", val_str(bcx.ccx().tn, len));\n-\n-    let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, len);\n-    let bcx = do with_cond(bcx, bounds_check) |bcx| {\n-        let unscaled_len = UDiv(bcx, len, vt.llunit_size);\n-        controlflow::trans_fail_bounds_check(bcx, index_expr.span,\n-                                             ix_val, unscaled_len)\n-    };\n-    let elt = InBoundsGEP(bcx, base, ~[ix_val]);\n-    let elt = PointerCast(bcx, elt, T_ptr(vt.llunit_ty));\n-    return DatumBlock {\n-        bcx: bcx,\n-        datum: Datum {val: elt,\n-                      ty: vt.unit_ty,\n-                      mode: ByRef,\n-                      source: source_from_opt_lvalue_type(\n-                            bcx.tcx(), Some(index_expr.id))}\n-    };\n-}\n-\n fn trans_rec_or_struct(bcx: block,\n                        fields: &[ast::field],\n                        base: Option<@ast::expr>,\n@@ -1158,16 +1172,16 @@ fn trans_rec_or_struct(bcx: block,\n             let base_datum = unpack_datum!(\n                 bcx, trans_to_datum(bcx, *base_expr));\n \n-            // Copy over inherited fields\n+            // Copy/move over inherited fields\n             for field_tys.eachi |i, field_ty| {\n                 if !fields.any(|f| f.node.ident == field_ty.ident) {\n                     let dest = GEPi(bcx, addr, struct_field(i));\n                     let base_field =\n                         base_datum.GEPi(bcx,\n                                         struct_field(i),\n                                         field_ty.mt.ty,\n-                                        FromLvalue);\n-                    bcx = base_field.store_to(bcx, INIT, dest);\n+                                        ZeroMem);\n+                    bcx = base_field.store_to(bcx, base_expr.id, INIT, dest);\n                 }\n             }\n         }\n@@ -1187,7 +1201,7 @@ fn trans_rec_or_struct(bcx: block,\n     }\n }\n \n-fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: Dest) -> block {\n+fn trans_tup(bcx: block, elts: &[@ast::expr], dest: Dest) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_tup\");\n     let mut bcx = bcx;\n     let addr = match dest {\n@@ -1642,7 +1656,7 @@ fn trans_assign_op(bcx: block,\n                       trans_eager_binop(\n                           bcx, expr, dst_datum.ty, op,\n                           &dst_datum, &src_datum));\n-    return result_datum.store_to_datum(bcx, DROP_EXISTING, dst_datum);\n+    return result_datum.copy_to_datum(bcx, DROP_EXISTING, dst_datum);\n }\n \n fn shorten(+x: ~str) -> ~str {"}, {"sha": "0431d0aa4dd6d15b03608554f13990aa3891f18f", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -69,7 +69,7 @@ fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n         ty::ty_fn(ref fn_ty) => {\n             let llargtys = type_of_explicit_args(\n                 ccx,\n-                /*bad*/copy fn_ty.sig.inputs);\n+                fn_ty.sig.inputs);\n             let llretty = type_of::type_of(ccx, fn_ty.sig.output);\n             (llargtys, llretty, fn_ty.sig.output)\n         }\n@@ -441,15 +441,15 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n             //\n             // - the datum will be by ref if the value is non-immediate;\n             //\n-            // - the datum has a FromRvalue source because, that way,\n+            // - the datum has a RevokeClean source because, that way,\n             //   the `move_to()` method does not feel compelled to\n             //   zero out the memory where the datum resides.  Zeroing\n             //   is not necessary since, for intrinsics, there is no\n             //   cleanup to concern ourselves with.\n             let tp_ty = substs.tys[0];\n             let mode = appropriate_mode(tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n-                             ty: tp_ty, mode: mode, source: FromRvalue};\n+                             ty: tp_ty, mode: mode, source: RevokeClean};\n             bcx = src.move_to(bcx, DROP_EXISTING,\n                               get_param(decl, first_real_arg));\n         }\n@@ -458,7 +458,7 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n             let tp_ty = substs.tys[0];\n             let mode = appropriate_mode(tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n-                             ty: tp_ty, mode: mode, source: FromRvalue};\n+                             ty: tp_ty, mode: mode, source: RevokeClean};\n             bcx = src.move_to(bcx, INIT, get_param(decl, first_real_arg));\n         }\n         ~\"min_align_of\" => {\n@@ -546,16 +546,17 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n                               onceness: ast::Many,\n                               region: ty::re_bound(ty::br_anon(0)),\n                               bounds: @~[]},\n-                sig: FnSig {inputs: ~[arg {mode: ast::expl(ast::by_val),\n+                sig: FnSig {inputs: ~[arg {mode: ast::expl(ast::by_copy),\n                                            ty: star_u8}],\n                             output: ty::mk_nil(bcx.tcx())}\n             });\n             let datum = Datum {val: get_param(decl, first_real_arg),\n-                               mode: ByRef, ty: fty, source: FromLvalue};\n+                               mode: ByRef, ty: fty, source: ZeroMem};\n+            let arg_vals = ~[frameaddress_val];\n             bcx = trans_call_inner(\n                 bcx, None, fty, ty::mk_nil(bcx.tcx()),\n                 |bcx| Callee {bcx: bcx, data: Closure(datum)},\n-                ArgVals(~[frameaddress_val]), Ignore, DontAutorefArg);\n+                ArgVals(arg_vals), Ignore, DontAutorefArg);\n         }\n         ~\"morestack_addr\" => {\n             // XXX This is a hack to grab the address of this particular"}, {"sha": "26ea47d7e73113e0a5a72514e969c1a8888fc30f", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -232,7 +232,6 @@ pub impl reflector {\n                   ast::expl(e) => match e {\n                     ast::by_ref => 1u,\n                     ast::by_val => 2u,\n-                    ast::by_move => 4u,\n                     ast::by_copy => 5u\n                   }\n                 };"}, {"sha": "6f183aa50b03f45868d11557393632d2077adb2a", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -24,7 +24,7 @@ pub fn type_of_explicit_arg(ccx: @crate_ctxt, arg: ty::arg) -> TypeRef {\n     let llty = type_of(ccx, arg.ty);\n     match ty::resolved_mode(ccx.tcx, arg.mode) {\n         ast::by_val => llty,\n-        ast::by_copy | ast::by_move => {\n+        ast::by_copy => {\n             if ty::type_is_immediate(arg.ty) {\n                 llty\n             } else {\n@@ -35,12 +35,12 @@ pub fn type_of_explicit_arg(ccx: @crate_ctxt, arg: ty::arg) -> TypeRef {\n     }\n }\n \n-pub fn type_of_explicit_args(ccx: @crate_ctxt, inputs: ~[ty::arg])\n-                          -> ~[TypeRef] {\n+pub fn type_of_explicit_args(ccx: @crate_ctxt,\n+                             inputs: &[ty::arg]) -> ~[TypeRef] {\n     inputs.map(|arg| type_of_explicit_arg(ccx, *arg))\n }\n \n-pub fn type_of_fn(cx: @crate_ctxt, inputs: ~[ty::arg],\n+pub fn type_of_fn(cx: @crate_ctxt, inputs: &[ty::arg],\n                   output: ty::t) -> TypeRef {\n     unsafe {\n         let mut atys: ~[TypeRef] = ~[];"}, {"sha": "d678b76a1e197944cbaa994541f0c04231bd3620", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -72,7 +72,7 @@ pub fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n         ty::ty_fn(ref fn_ty) => {\n             for vec::each(fn_ty.sig.inputs) |arg| {\n                 match ty::resolved_mode(ccx.tcx, arg.mode) {\n-                    by_val | by_move | by_copy => {\n+                    by_val | by_copy => {\n                         type_needs(cx, use_repr, arg.ty);\n                     }\n                     by_ref => {}\n@@ -255,7 +255,7 @@ pub fn mark_for_expr(cx: ctx, e: @expr) {\n       expr_rec(_, _) | expr_struct(*) | expr_tup(_) |\n       expr_unary(box(_), _) | expr_unary(uniq(_), _) |\n       expr_binary(add, _, _) |\n-      expr_copy(_) | expr_unary_move(_) | expr_repeat(*) => {\n+      expr_copy(_) | expr_repeat(*) => {\n         node_type_needs(cx, use_repr, e.id);\n       }\n       expr_cast(base, _) => {\n@@ -316,7 +316,7 @@ pub fn mark_for_expr(cx: ctx, e: @expr) {\n               ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id))\n           ) |a| {\n               match a.mode {\n-                  expl(by_move) | expl(by_copy) | expl(by_val) => {\n+                  expl(by_copy) | expl(by_val) => {\n                       type_needs(cx, use_repr, a.ty);\n                   }\n                   _ => ()\n@@ -330,7 +330,7 @@ pub fn mark_for_expr(cx: ctx, e: @expr) {\n         for ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx,\n                                                e.callee_id)).each |a| {\n           match a.mode {\n-              expl(by_move) | expl(by_copy) | expl(by_val) => {\n+              expl(by_copy) | expl(by_val) => {\n                   type_needs(cx, use_repr, a.ty);\n               }\n               _ => ()"}, {"sha": "255b87e2d5ea941ba8a71fc0d6159e3bbc00ff5a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 120, "deletions": 16, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -99,15 +99,6 @@ pub struct field_ty {\n   mutability: ast::struct_mutability,\n }\n \n-/// How an lvalue is to be used.\n-#[auto_encode]\n-#[auto_decode]\n-pub enum ValueMode {\n-    ReadValue,  // Non-destructively read the value; do not copy or move.\n-    CopyValue,  // Copy the value.\n-    MoveValue,  // Move the value.\n-}\n-\n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n #[deriving_eq]\n@@ -295,9 +286,6 @@ struct ctxt_ {\n     // A method will be in this list if and only if it is a destructor.\n     destructors: HashMap<ast::def_id, ()>,\n \n-    // Records the value mode (read, copy, or move) for every value.\n-    value_modes: HashMap<ast::node_id, ValueMode>,\n-\n     // Maps a trait onto a mapping from self-ty to impl\n     trait_impls: HashMap<ast::def_id, HashMap<t, @Impl>>\n }\n@@ -875,7 +863,6 @@ pub fn mk_ctxt(s: session::Session,\n         supertraits: HashMap(),\n         destructor_for_type: HashMap(),\n         destructors: HashMap(),\n-        value_modes: HashMap(),\n         trait_impls: HashMap()\n      }\n }\n@@ -2170,7 +2157,14 @@ pub fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n       }\n \n       ty_param(p) => {\n-        param_bounds_to_kind(cx.ty_param_bounds.get(p.def_id.node))\n+          // We only ever ask for the kind of types that are defined in the\n+          // current crate; therefore, the only type parameters that could be\n+          // in scope are those defined in the current crate.  If this\n+          // assertion failures, it is likely because of a failure in the\n+          // cross-crate inlining code to translate a def-id.\n+          assert p.def_id.crate == ast::local_crate;\n+\n+          param_bounds_to_kind(cx.ty_param_bounds.get(p.def_id.node))\n       }\n \n       // self is a special type parameter that can only appear in traits; it\n@@ -2925,14 +2919,125 @@ pub fn pat_ty(cx: ctxt, pat: @ast::pat) -> t {\n \n // Returns the type of an expression as a monotype.\n //\n-// NB: This type doesn't provide type parameter substitutions; e.g. if you\n+// NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n+// some cases, we insert `AutoAdjustment` annotations such as auto-deref or\n+// auto-ref.  The type returned by this function does not consider such\n+// adjustments.  See `expr_ty_adjusted()` instead.\n+//\n+// NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n // instead of \"fn(t) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n pub fn expr_ty(cx: ctxt, expr: @ast::expr) -> t {\n     return node_id_to_type(cx, expr.id);\n }\n \n+pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n+    /*!\n+     *\n+     * Returns the type of `expr`, considering any `AutoAdjustment`\n+     * entry recorded for that expression.\n+     *\n+     * It would almost certainly be better to store the adjusted ty in with\n+     * the `AutoAdjustment`, but I opted not to do this because it would\n+     * require serializing and deserializing the type and, although that's not\n+     * hard to do, I just hate that code so much I didn't want to touch it\n+     * unless it was to fix it properly, which seemed a distraction from the\n+     * task at hand! -nmatsakis\n+     */\n+\n+    let unadjusted_ty = expr_ty(cx, expr);\n+\n+    return match cx.adjustments.find(expr.id) {\n+        None => unadjusted_ty,\n+\n+        Some(adj) => {\n+            let mut adjusted_ty = unadjusted_ty;\n+\n+            for uint::range(0, adj.autoderefs) |i| {\n+                match ty::deref(cx, adjusted_ty, true) {\n+                    Some(mt) => { adjusted_ty = mt.ty; }\n+                    None => {\n+                        cx.sess.span_bug(\n+                            expr.span,\n+                            fmt!(\"The %uth autoderef failed: %s\",\n+                                 i, ty_to_str(cx,\n+                                              adjusted_ty)));\n+                    }\n+                }\n+            }\n+\n+            match adj.autoref {\n+                None => adjusted_ty,\n+                Some(ref autoref) => {\n+                    match autoref.kind {\n+                        AutoPtr => {\n+                            mk_rptr(cx, autoref.region,\n+                                    mt {ty: adjusted_ty,\n+                                        mutbl: autoref.mutbl})\n+                        }\n+\n+                        AutoBorrowVec => {\n+                            borrow_vec(cx, expr, autoref, adjusted_ty)\n+                        }\n+\n+                        AutoBorrowVecRef => {\n+                            adjusted_ty = borrow_vec(cx, expr, autoref,\n+                                                     adjusted_ty);\n+                            mk_rptr(cx, autoref.region,\n+                                    mt {ty: adjusted_ty, mutbl: ast::m_imm})\n+                        }\n+\n+                        AutoBorrowFn => {\n+                            borrow_fn(cx, expr, autoref, adjusted_ty)\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    };\n+\n+    fn borrow_vec(cx: ctxt, expr: @ast::expr,\n+                  autoref: &AutoRef, ty: ty::t) -> ty::t {\n+        match get(ty).sty {\n+            ty_evec(mt, _) => {\n+                ty::mk_evec(cx, mt {ty: mt.ty, mutbl: autoref.mutbl},\n+                            vstore_slice(autoref.region))\n+            }\n+\n+            ty_estr(_) => {\n+                ty::mk_estr(cx, vstore_slice(autoref.region))\n+            }\n+\n+            ref s => {\n+                cx.sess.span_bug(\n+                    expr.span,\n+                    fmt!(\"borrow-vec associated with bad sty: %?\",\n+                         s));\n+            }\n+        }\n+    }\n+\n+    fn borrow_fn(cx: ctxt, expr: @ast::expr,\n+                 autoref: &AutoRef, ty: ty::t) -> ty::t {\n+        match get(ty).sty {\n+            ty_fn(ref fty) => {\n+                ty::mk_fn(cx, FnTyBase {meta: FnMeta {proto: ProtoBorrowed,\n+                                                      region: autoref.region,\n+                                                      ..copy fty.meta},\n+                                        sig: copy fty.sig})\n+            }\n+\n+            ref s => {\n+                cx.sess.span_bug(\n+                    expr.span,\n+                    fmt!(\"borrow-fn associated with bad sty: %?\",\n+                         s));\n+            }\n+        }\n+    }\n+}\n+\n pub fn expr_ty_params_and_ty(cx: ctxt,\n                              expr: @ast::expr)\n                           -> {params: ~[t], ty: t} {\n@@ -3060,7 +3165,6 @@ pub fn expr_kind(tcx: ctxt,\n         ast::expr_do_body(*) |\n         ast::expr_block(*) |\n         ast::expr_copy(*) |\n-        ast::expr_unary_move(*) |\n         ast::expr_repeat(*) |\n         ast::expr_lit(@ast::spanned {node: lit_str(_), _}) |\n         ast::expr_vstore(_, ast::expr_vstore_slice) |"}, {"sha": "33250c294e0917478a3c67abf669a37b4269e627", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -381,7 +381,7 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             demand::eqtype(fcx, pat.span, region_ty, typ);\n           }\n           // otherwise the type of x is the expected type T\n-          ast::bind_by_value | ast::bind_by_move | ast::bind_infer => {\n+          ast::bind_by_copy | ast::bind_infer => {\n             demand::eqtype(fcx, pat.span, expected, typ);\n           }\n         }"}, {"sha": "f13de691a6971dbdae599f89afbb7854120c5217", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -78,7 +78,6 @@ type parameter).\n \n use core::prelude::*;\n \n-use middle::capture;\n use middle::const_eval;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n@@ -1454,7 +1453,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         match ast_util::binop_to_method_name(op) {\n           Some(ref name) => {\n             match lookup_op_method(fcx, ex, lhs_expr, lhs_resolved_t,\n-                                   fcx.tcx().sess.ident_of((*name)),\n+                                   fcx.tcx().sess.ident_of(copy *name),\n                                    ~[rhs], DoDerefArgs) {\n               Some(pair) => return pair,\n               _ => ()\n@@ -1488,9 +1487,11 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n     fn check_user_unop(fcx: @fn_ctxt, op_str: ~str, mname: ~str,\n                        ex: @ast::expr,\n                        rhs_expr: @ast::expr, rhs_t: ty::t) -> ty::t {\n-        match lookup_op_method(fcx, ex, rhs_expr, rhs_t,\n-                               fcx.tcx().sess.ident_of(mname), ~[],\n-                               DontDerefArgs) {\n+        match lookup_op_method(\n+            fcx, ex, rhs_expr, rhs_t,\n+            fcx.tcx().sess.ident_of(/*bad*/ copy mname), ~[],\n+            DontDerefArgs)\n+        {\n           Some((ret_ty, _)) => ret_ty,\n           _ => {\n               fcx.type_error_message(ex.span, |actual| {\n@@ -2132,7 +2133,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         bot = check_expr_has_type(fcx, e, ty::mk_bool(tcx));\n         fcx.write_nil(id);\n       }\n-      ast::expr_copy(a) | ast::expr_unary_move(a) => {\n+      ast::expr_copy(a) => {\n         bot = check_expr_with_opt_hint(fcx, a, expected);\n         fcx.write_ty(id, fcx.expr_ty(a));\n       }\n@@ -2163,15 +2164,13 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_match(discrim, ref arms) => {\n         bot = _match::check_match(fcx, expr, discrim, (/*bad*/copy *arms));\n       }\n-      ast::expr_fn(proto, ref decl, ref body, cap_clause) => {\n+      ast::expr_fn(proto, ref decl, ref body) => {\n         check_expr_fn(fcx, expr, Some(proto),\n                       decl, (*body), Vanilla, expected);\n-        capture::check_capture_clause(tcx, expr.id, cap_clause);\n       }\n-      ast::expr_fn_block(ref decl, ref body, cap_clause) => {\n+      ast::expr_fn_block(ref decl, ref body) => {\n         check_expr_fn(fcx, expr, None,\n                       decl, (*body), Vanilla, expected);\n-        capture::check_capture_clause(tcx, expr.id, cap_clause);\n       }\n       ast::expr_loop_body(b) => {\n         // a loop body is the special argument to a `for` loop.  We know that\n@@ -2234,7 +2233,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n               }\n         };\n         match b.node {\n-                ast::expr_fn_block(ref decl, ref body, cap_clause) => {\n+                ast::expr_fn_block(ref decl, ref body) => {\n                     // If an error occurred, we pretend this isn't a for\n                     // loop, so as to assign types to all nodes while also\n                     // propagating ty_err throughout so as to suppress\n@@ -2246,7 +2245,6 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     check_expr_fn(fcx, b, None,\n                                   decl, *body, fn_kind, Some(inner_ty));\n                     demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n-                    capture::check_capture_clause(tcx, b.id, cap_clause);\n                 }\n                 // argh\n                 _ => fail ~\"expr_fn_block\"\n@@ -2283,11 +2281,10 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n               }\n         };\n         match b.node {\n-          ast::expr_fn_block(ref decl, ref body, cap_clause) => {\n+          ast::expr_fn_block(ref decl, ref body) => {\n             check_expr_fn(fcx, b, None,\n                           decl, *body, DoBlock, Some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n-            capture::check_capture_clause(tcx, b.id, cap_clause);\n           }\n           // argh\n           _ => fail ~\"expected fn ty\"\n@@ -3052,7 +3049,7 @@ pub fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n       ~\"size_of\" |\n       ~\"pref_align_of\" | ~\"min_align_of\" => (1u, ~[], ty::mk_uint(ccx.tcx)),\n       ~\"init\" => (1u, ~[], param(ccx, 0u)),\n-      ~\"forget\" => (1u, ~[arg(ast::by_move, param(ccx, 0u))],\n+      ~\"forget\" => (1u, ~[arg(ast::by_copy, param(ccx, 0u))],\n                     ty::mk_nil(tcx)),\n       ~\"reinterpret_cast\" => (2u, ~[arg(ast::by_ref, param(ccx, 0u))],\n                               param(ccx, 1u)),\n@@ -3062,7 +3059,7 @@ pub fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n           (1u, ~[arg(ast::by_copy,\n                      ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)),\n                                      param(ccx, 0u))),\n-               arg(ast::by_move, param(ccx, 0u))],\n+               arg(ast::by_copy, param(ccx, 0u))],\n          ty::mk_nil(tcx))\n       }\n       ~\"needs_drop\" => (1u, ~[], ty::mk_bool(tcx)),"}, {"sha": "ae8574f8d1edc10dd4383ccf3798194fa1abe995", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -710,7 +710,6 @@ pub mod guarantor {\n             ast::expr_do_body(*) |\n             ast::expr_block(*) |\n             ast::expr_copy(*) |\n-            ast::expr_unary_move(*) |\n             ast::expr_repeat(*) |\n             ast::expr_vec(*) => {\n                 assert !ty::expr_is_lval("}, {"sha": "85db1fd6e10b2e2cf06982d86938da7d110cd35d", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -606,10 +606,10 @@ pub fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n                         ty::ty_uniq(mt) => {\n                             // Ensure that the trait vstore and the pointer\n                             // type match.\n-                            match (ty::get(ty).sty, vstore) {\n-                                (ty::ty_box(_), ty::vstore_box) |\n-                                (ty::ty_uniq(_), ty::vstore_uniq) |\n-                                (ty::ty_rptr(*), ty::vstore_slice(*)) => {\n+                            match (&ty::get(ty).sty, vstore) {\n+                                (&ty::ty_box(_), ty::vstore_box) |\n+                                (&ty::ty_uniq(_), ty::vstore_uniq) |\n+                                (&ty::ty_rptr(*), ty::vstore_slice(*)) => {\n                                     let location_info =\n                                         &location_info_for_expr(ex);\n                                     let vtable_opt =\n@@ -634,8 +634,8 @@ pub fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n \n                                     // Now, if this is &trait, we need to link\n                                     // the regions.\n-                                    match (ty::get(ty).sty, vstore) {\n-                                        (ty::ty_rptr(ra, _),\n+                                    match (&ty::get(ty).sty, vstore) {\n+                                        (&ty::ty_rptr(ra, _),\n                                          ty::vstore_slice(rb)) => {\n                                             infer::mk_subr(fcx.infcx(),\n                                                            false,\n@@ -646,7 +646,7 @@ pub fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n                                         _ => {}\n                                     }\n                                 }\n-                                (ty::ty_box(_), _) => {\n+                                (&ty::ty_box(_), _) => {\n                                     fcx.ccx.tcx.sess.span_err(ex.span,\n                                                               ~\"must cast \\\n                                                                 a boxed \\\n@@ -655,15 +655,15 @@ pub fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n                                                                 trait\");\n                                     err = true;\n                                 }\n-                                (ty::ty_rptr(*), _) => {\n+                                (&ty::ty_rptr(*), _) => {\n                                     fcx.ccx.tcx.sess.span_err(ex.span,\n                                                               ~\"must cast \\\n                                                                 a borrowed \\\n                                                                 pointer to \\\n                                                                 a borrowed \\\n                                                                 trait\");\n                                 }\n-                                (ty::ty_uniq(*), _) => {\n+                                (&ty::ty_uniq(*), _) => {\n                                     fcx.ccx.tcx.sess.span_err(ex.span,\n                                                               ~\"must cast \\\n                                                                 a unique \\"}, {"sha": "8fe9b14040692fa4548635897810a22a134fb052", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -165,7 +165,7 @@ fn visit_expr(e: @ast::expr, wbcx: wb_ctxt, v: wb_vt) {\n     resolve_method_map_entry(wbcx.fcx, e.span, e.id);\n     resolve_method_map_entry(wbcx.fcx, e.span, e.callee_id);\n     match e.node {\n-      ast::expr_fn_block(ref decl, _, _) => {\n+      ast::expr_fn_block(ref decl, _) => {\n           for vec::each(decl.inputs) |input| {\n               let r_ty = resolve_type_vars_for_node(wbcx, e.span, input.id);\n "}, {"sha": "4f7bedd814978ffa1eac2936ef20b096e4a111c1", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -362,11 +362,11 @@ pub fn super_lattice_tys<L:LatticeDir TyLatticeDir Combine>(\n \n     let tcx = self.infcx().tcx;\n \n-    match (ty::get(a).sty, ty::get(b).sty) {\n-        (ty::ty_bot, _) => { return self.ty_bot(b); }\n-        (_, ty::ty_bot) => { return self.ty_bot(a); }\n+    match (&ty::get(a).sty, &ty::get(b).sty) {\n+        (&ty::ty_bot, _) => { return self.ty_bot(b); }\n+        (_, &ty::ty_bot) => { return self.ty_bot(a); }\n \n-        (ty::ty_infer(TyVar(a_id)), ty::ty_infer(TyVar(b_id))) => {\n+        (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n             let r = if_ok!(lattice_vars(self, a_id, b_id,\n                                         |x, y| self.tys(*x, *y)));\n             return match r {\n@@ -375,12 +375,12 @@ pub fn super_lattice_tys<L:LatticeDir TyLatticeDir Combine>(\n             };\n         }\n \n-        (ty::ty_infer(TyVar(a_id)), _) => {\n+        (&ty::ty_infer(TyVar(a_id)), _) => {\n             return lattice_var_and_t(self, a_id, &b,\n                                      |x, y| self.tys(*x, *y));\n         }\n \n-        (_, ty::ty_infer(TyVar(b_id))) => {\n+        (_, &ty::ty_infer(TyVar(b_id))) => {\n             return lattice_var_and_t(self, b_id, &a,\n                                      |x, y| self.tys(*x, *y));\n         }"}, {"sha": "2e30bdc58883f86b2bafb2a1faad8b4b7035865e", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -106,25 +106,25 @@ pub impl Sub: Combine {\n                a.inf_str(self.infcx), b.inf_str(self.infcx));\n         if a == b { return Ok(a); }\n         let _indenter = indenter();\n-        match (ty::get(a).sty, ty::get(b).sty) {\n-            (ty::ty_bot, _) => {\n+        match (&ty::get(a).sty, &ty::get(b).sty) {\n+            (&ty::ty_bot, _) => {\n                 Ok(a)\n             }\n \n-            (ty::ty_infer(TyVar(a_id)), ty::ty_infer(TyVar(b_id))) => {\n+            (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n                 if_ok!(self.var_sub_var(a_id, b_id));\n                 Ok(a)\n             }\n-            (ty::ty_infer(TyVar(a_id)), _) => {\n+            (&ty::ty_infer(TyVar(a_id)), _) => {\n                 if_ok!(self.var_sub_t(a_id, b));\n                 Ok(a)\n             }\n-            (_, ty::ty_infer(TyVar(b_id))) => {\n+            (_, &ty::ty_infer(TyVar(b_id))) => {\n                 if_ok!(self.t_sub_var(a, b_id));\n                 Ok(a)\n             }\n \n-            (_, ty::ty_bot) => {\n+            (_, &ty::ty_bot) => {\n                 Err(ty::terr_sorts(expected_found(&self, a, b)))\n             }\n "}, {"sha": "71a4600f4adac1133e312525d7bf0417f10b8390", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -91,14 +91,13 @@ pub mod middle {\n     pub mod liveness;\n     pub mod kind;\n     pub mod freevars;\n-    pub mod capture;\n     pub mod pat_util;\n     pub mod region;\n     pub mod const_eval;\n     pub mod astencode;\n     pub mod lang_items;\n     pub mod privacy;\n-    pub mod mode;\n+    pub mod moves;\n }\n \n pub mod front {\n@@ -221,9 +220,9 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n \n     let matches =\n         &match getopts::groups::getopts(args, optgroups()) {\n-          Ok(ref m) => (*m),\n-          Err(ref f) => {\n-            early_error(demitter, getopts::fail_str((*f)))\n+          Ok(m) => m,\n+          Err(f) => {\n+            early_error(demitter, getopts::fail_str(f));\n           }\n         };\n \n@@ -375,7 +374,7 @@ pub fn monitor(+f: fn~(diagnostic::emitter)) {\n }\n \n pub fn main() {\n-    let mut args = os::args();\n+    let args = os::args();\n     do monitor |move args, demitter| {\n         run_compiler(&args, demitter);\n     }"}, {"sha": "10d49ad4b0f0e5233543557971ebc6f656049efe", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -421,8 +421,15 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       }\n       ty_infer(infer_ty) => infer_ty.to_str(),\n       ty_err => ~\"[type error]\",\n-      ty_param(param_ty {idx: id, _}) => {\n-        ~\"'\" + str::from_bytes(~[('a' as u8) + (id as u8)])\n+      ty_param(param_ty {idx: id, def_id: did}) => {\n+          if cx.sess.verbose() {\n+              fmt!(\"'%s:%?\",\n+                   str::from_bytes(~[('a' as u8) + (id as u8)]),\n+                   did)\n+          } else {\n+              fmt!(\"'%s\",\n+                   str::from_bytes(~[('a' as u8) + (id as u8)]))\n+          }\n       }\n       ty_self => ~\"self\",\n       ty_enum(did, ref substs) | ty_struct(did, ref substs) => {"}, {"sha": "f3826af6caebfa8a06aa748b84a557942ba84c52", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -166,20 +166,27 @@ fn fold_enum(\n     doc::EnumDoc {\n         variants: do par::map(doc.variants) |variant| {\n             let variant = copy *variant;\n-            let desc = do astsrv::exec(srv) |ctxt, copy variant| {\n-                match ctxt.ast_map.get(doc_id) {\n-                  ast_map::node_item(@ast::item {\n-                    node: ast::item_enum(ref enum_definition, _), _\n-                  }, _) => {\n-                    let ast_variant = option::get(\n-                        vec::find(enum_definition.variants, |v| {\n-                            to_str(v.node.name) == variant.name\n-                        }));\n-\n-                    attr_parser::parse_desc(copy ast_variant.node.attrs)\n-                  }\n-                  _ => fail fmt!(\"Enum variant %s has id that's not bound \\\n-                         to an enum item\", variant.name)\n+            let desc = {\n+                let variant = copy variant;\n+                do astsrv::exec(srv) |ctxt| {\n+                    match ctxt.ast_map.get(doc_id) {\n+                        ast_map::node_item(@ast::item {\n+                            node: ast::item_enum(ref enum_definition, _), _\n+                        }, _) => {\n+                            let ast_variant = option::get(\n+                                vec::find(enum_definition.variants, |v| {\n+                                    to_str(v.node.name) == variant.name\n+                                }));\n+\n+                            attr_parser::parse_desc(\n+                                copy ast_variant.node.attrs)\n+                        }\n+                        _ => {\n+                            fail fmt!(\"Enum variant %s has id that's \\\n+                                       not bound to an enum item\",\n+                                      variant.name)\n+                        }\n+                    }\n                 }\n             };\n "}, {"sha": "6b04903601cdbe64abd63d637c109b0a9f743c08", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -26,6 +26,7 @@ use pass::Pass;\n \n use core::str;\n use core::vec;\n+use core::util;\n use std::par;\n \n pub fn mk_pass() -> Pass {\n@@ -194,8 +195,8 @@ fn paragraphs(s: ~str) -> ~[~str] {\n         } else {\n             if whitespace_lines > 0 {\n                 if !accum.is_empty() {\n-                    res += ~[accum];\n-                    accum = ~\"\";\n+                    let v = util::replace(&mut accum, ~\"\");\n+                    res.push(v);\n                 }\n             }\n "}, {"sha": "c5db76850806fc7a46a524150584bd83460ccf49", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -102,10 +102,11 @@ fn item_to_entry(\n     let link = match doc {\n       doc::ModTag(_) | doc::NmodTag(_)\n       if config.output_style == config::DocPerMod => {\n-        markdown_writer::make_filename(config, doc::ItemPage(doc)).to_str()\n+        markdown_writer::make_filename(config,\n+                                       doc::ItemPage(copy doc)).to_str()\n       }\n       _ => {\n-        ~\"#\" + pandoc_header_id(markdown_pass::header_text(doc))\n+        ~\"#\" + pandoc_header_id(markdown_pass::header_text(copy doc))\n       }\n     };\n "}, {"sha": "359d009716590acfc048f1eb3accf09eff306eef", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -291,12 +291,13 @@ pub fn header_text(doc: doc::ItemTag) -> ~str {\n             fmt!(\"of `%s` for `%s`\", ImplDoc.trait_types[0],\n                  (&ImplDoc.self_ty).get())\n         };\n-        fmt!(\"%s %s\", header_kind, desc)\n-      }\n-      _ => {\n-        header_text_(header_kind(doc), header_name(doc))\n+        return fmt!(\"%s %s\", header_kind, desc);\n       }\n+      _ => {}\n     }\n+\n+    header_text_(header_kind(copy doc),\n+                 header_name(doc))\n }\n \n fn header_text_(kind: &str, name: &str) -> ~str {"}, {"sha": "d5c4dda6d955b215b4f7d00dbe0a0c4a5c74b83a", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -73,7 +73,7 @@ fn fold_item(\n }\n \n fn apply_to_sections(\n-    op: NominalOp<Op>,\n+    +op: NominalOp<Op>,\n     sections: ~[doc::Section]\n ) -> ~[doc::Section] {\n     par::map(sections, |section, copy op| doc::Section {\n@@ -115,7 +115,8 @@ fn apply_to_methods(\n     op: NominalOp<Op>,\n     docs: ~[doc::MethodDoc]\n ) -> ~[doc::MethodDoc] {\n-    do par::map(docs) |doc, copy op| {\n+    let op = copy op;\n+    do par::map(docs) |doc| {\n         doc::MethodDoc {\n             brief: maybe_apply_op(copy op, &doc.brief),\n             desc: maybe_apply_op(copy op, &doc.desc),"}, {"sha": "016c554be276652076b7ef220bc8962b0b0ed169", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 75, "deletions": 58, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -103,16 +103,18 @@ fn fold_const(\n     let srv = fold.ctxt;\n \n     doc::SimpleItemDoc {\n-        sig: Some(do astsrv::exec(srv) |copy doc, ctxt| {\n-            match ctxt.ast_map.get(doc.id()) {\n-              ast_map::node_item(@ast::item {\n-                node: ast::item_const(ty, _), _\n-              }, _) => {\n-                pprust::ty_to_str(ty, extract::interner())\n-              }\n-              _ => fail ~\"fold_const: id not bound to a const item\"\n-            }\n-        }),\n+        sig: Some({\n+            let doc = copy doc;\n+            do astsrv::exec(srv) |ctxt| {\n+                match ctxt.ast_map.get(doc.id()) {\n+                    ast_map::node_item(@ast::item {\n+                        node: ast::item_const(ty, _), _\n+                    }, _) => {\n+                        pprust::ty_to_str(ty, extract::interner())\n+                    }\n+                    _ => fail ~\"fold_const: id not bound to a const item\"\n+                }\n+            }}),\n         .. doc\n     }\n }\n@@ -132,26 +134,29 @@ fn fold_enum(\n \n     doc::EnumDoc {\n         variants: do par::map(doc.variants) |variant| {\n-            let variant = copy *variant;\n-            let sig = do astsrv::exec(srv) |copy variant, ctxt| {\n-                match ctxt.ast_map.get(doc_id) {\n-                  ast_map::node_item(@ast::item {\n-                    node: ast::item_enum(ref enum_definition, _), _\n-                  }, _) => {\n-                    let ast_variant =\n-                        do vec::find(enum_definition.variants) |v| {\n-                            to_str(v.node.name) == variant.name\n-                        }.get();\n-\n-                    pprust::variant_to_str(ast_variant, extract::interner())\n-                  }\n-                  _ => fail ~\"enum variant not bound to an enum item\"\n+            let sig = {\n+                let variant = copy *variant;\n+                do astsrv::exec(srv) |copy variant, ctxt| {\n+                    match ctxt.ast_map.get(doc_id) {\n+                        ast_map::node_item(@ast::item {\n+                            node: ast::item_enum(ref enum_definition, _), _\n+                        }, _) => {\n+                            let ast_variant =\n+                                do vec::find(enum_definition.variants) |v| {\n+                                to_str(v.node.name) == variant.name\n+                            }.get();\n+\n+                            pprust::variant_to_str(\n+                                ast_variant, extract::interner())\n+                        }\n+                        _ => fail ~\"enum variant not bound to an enum item\"\n+                    }\n                 }\n             };\n \n             doc::VariantDoc {\n                 sig: Some(sig),\n-                .. variant\n+                .. copy *variant\n             }\n         },\n         .. doc\n@@ -262,18 +267,22 @@ fn fold_impl(\n \n     let srv = fold.ctxt;\n \n-    let (trait_types, self_ty) = do astsrv::exec(srv) |copy doc, ctxt| {\n-        match ctxt.ast_map.get(doc.id()) {\n-          ast_map::node_item(@ast::item {\n-            node: ast::item_impl(_, opt_trait_type, self_ty, _), _\n-          }, _) => {\n-            let trait_types = opt_trait_type.map_default(~[], |p| {\n-                ~[pprust::path_to_str(p.path, extract::interner())]\n-            });\n-            (trait_types, Some(pprust::ty_to_str(self_ty,\n-                                                 extract::interner())))\n-          }\n-          _ => fail ~\"expected impl\"\n+    let (trait_types, self_ty) = {\n+        let doc = copy doc;\n+        do astsrv::exec(srv) |ctxt| {\n+            match ctxt.ast_map.get(doc.id()) {\n+                ast_map::node_item(@ast::item {\n+                    node: ast::item_impl(_, opt_trait_type, self_ty, _), _\n+                }, _) => {\n+                    let trait_types = opt_trait_type.map_default(~[], |p| {\n+                        ~[pprust::path_to_str(p.path, extract::interner())]\n+                    });\n+                    (trait_types,\n+                     Some(pprust::ty_to_str(\n+                         self_ty, extract::interner())))\n+                }\n+                _ => fail ~\"expected impl\"\n+            }\n         }\n     };\n \n@@ -318,20 +327,25 @@ fn fold_type(\n     let srv = fold.ctxt;\n \n     doc::SimpleItemDoc {\n-        sig: do astsrv::exec(srv) |copy doc, ctxt| {\n-            match ctxt.ast_map.get(doc.id()) {\n-              ast_map::node_item(@ast::item {\n-                ident: ident,\n-                node: ast::item_ty(ty, ref params), _\n-              }, _) => {\n-                Some(fmt!(\n-                    \"type %s%s = %s\",\n-                    to_str(ident),\n-                    pprust::typarams_to_str(*params, extract::interner()),\n-                    pprust::ty_to_str(ty, extract::interner())\n-                ))\n-              }\n-              _ => fail ~\"expected type\"\n+        sig: {\n+            let doc = copy doc;\n+            do astsrv::exec(srv) |ctxt| {\n+                match ctxt.ast_map.get(doc.id()) {\n+                    ast_map::node_item(@ast::item {\n+                        ident: ident,\n+                        node: ast::item_ty(ty, ref params), _\n+                    }, _) => {\n+                        Some(fmt!(\n+                            \"type %s%s = %s\",\n+                            to_str(ident),\n+                            pprust::typarams_to_str(*params,\n+                                                    extract::interner()),\n+                            pprust::ty_to_str(ty,\n+                                              extract::interner())\n+                        ))\n+                    }\n+                    _ => fail ~\"expected type\"\n+                }\n             }\n         },\n         .. doc\n@@ -351,14 +365,17 @@ fn fold_struct(\n     let srv = fold.ctxt;\n \n     doc::StructDoc {\n-        sig: do astsrv::exec(srv) |copy doc, ctxt| {\n-            match ctxt.ast_map.get(doc.id()) {\n-                ast_map::node_item(item, _) => {\n-                    let item = strip_struct_extra_stuff(item);\n-                    Some(pprust::item_to_str(item,\n-                                             extract::interner()))\n+        sig: {\n+            let doc = copy doc;\n+            do astsrv::exec(srv) |ctxt| {\n+                match ctxt.ast_map.get(doc.id()) {\n+                    ast_map::node_item(item, _) => {\n+                        let item = strip_struct_extra_stuff(item);\n+                        Some(pprust::item_to_str(item,\n+                                                 extract::interner()))\n+                    }\n+                    _ => fail ~\"not an item\"\n                 }\n-                _ => fail ~\"not an item\"\n             }\n         },\n         .. doc"}, {"sha": "e108643790ed485332fcce20f37cc62683cbf4cd", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -788,13 +788,14 @@ mod test {\n         // The main task will wait until the test is over to proceed\n         let (finish_port, finish_chan) = pipes::stream();\n \n-        let addr = ip::v4::parse_addr(\"127.0.0.1\");\n+        let addr0 = ip::v4::parse_addr(\"127.0.0.1\");\n \n         let begin_connect_chan = Cell(move begin_connect_chan);\n         let accept_chan = Cell(move accept_chan);\n \n         // The server task\n-        do task::spawn |copy addr, move begin_connect_chan,\n+        let addr = copy addr0;\n+        do task::spawn |move begin_connect_chan,\n                         move accept_chan| {\n             let iotask = &uv::global_loop::get();\n             let begin_connect_chan = begin_connect_chan.take();\n@@ -821,7 +822,8 @@ mod test {\n         }\n \n         // Client task\n-        do task::spawn |copy addr, move begin_connect_port,\n+        let addr = copy addr0;\n+        do task::spawn |move begin_connect_port,\n                         move writer_chan| {\n \n             // Wait for the server to start listening"}, {"sha": "2447c2eb530de30698b8e7293b6d76e84cd95d3f", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -117,8 +117,9 @@ enum IpGetAddrErr {\n pub fn get_addr(node: &str, iotask: &iotask)\n     -> result::Result<~[IpAddr], IpGetAddrErr> {\n     let (output_po, output_ch) = stream();\n-    let output_ch = SharedChan(output_ch);\n+    let mut output_ch = Some(SharedChan(output_ch));\n     do str::as_buf(node) |node_ptr, len| {\n+        let output_ch = output_ch.swap_unwrap();\n         unsafe {\n             log(debug, fmt!(\"slice len %?\", len));\n             let handle = create_uv_getaddrinfo_t();"}, {"sha": "779dda0ab29765a18dd4b313f817b20a7424d054", "filename": "src/libstd/par.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -59,7 +59,8 @@ fn map_slices<A: Copy Owned, B: Copy Owned>(\n             let end = uint::min(len, base + items_per_task);\n             do vec::as_imm_buf(xs) |p, _len| {\n                 let f = f();\n-                let f = do future_spawn() |move f, copy base| {\n+                let base = base;\n+                let f = do future_spawn() |move f| {\n                     unsafe {\n                         let len = end - base;\n                         let slice = (ptr::offset(p, base),\n@@ -94,7 +95,8 @@ fn map_slices<A: Copy Owned, B: Copy Owned>(\n pub fn map<A: Copy Owned, B: Copy Owned>(\n     xs: &[A], f: fn~(&A) -> B) -> ~[B] {\n     vec::concat(map_slices(xs, || {\n-        fn~(_base: uint, slice : &[A], copy f) -> ~[B] {\n+        let f = copy f;\n+        fn~(_base: uint, slice : &[A]) -> ~[B] {\n             vec::map(slice, |x| f(x))\n         }\n     }))\n@@ -104,6 +106,7 @@ pub fn map<A: Copy Owned, B: Copy Owned>(\n pub fn mapi<A: Copy Owned, B: Copy Owned>(xs: &[A],\n                                     f: fn~(uint, &A) -> B) -> ~[B] {\n     let slices = map_slices(xs, || {\n+        let f = copy f;\n         fn~(base: uint, slice : &[A], copy f) -> ~[B] {\n             vec::mapi(slice, |i, x| {\n                 f(i + base, x)\n@@ -141,6 +144,7 @@ pub fn mapi_factory<A: Copy Owned, B: Copy Owned>(\n /// Returns true if the function holds for all elements in the vector.\n pub fn alli<A: Copy Owned>(xs: &[A], f: fn~(uint, &A) -> bool) -> bool {\n     do vec::all(map_slices(xs, || {\n+        let f = copy f;\n         fn~(base: uint, slice : &[A], copy f) -> bool {\n             vec::alli(slice, |i, x| {\n                 f(i + base, x)\n@@ -152,6 +156,7 @@ pub fn alli<A: Copy Owned>(xs: &[A], f: fn~(uint, &A) -> bool) -> bool {\n /// Returns true if the function holds for any elements in the vector.\n pub fn any<A: Copy Owned>(xs: &[A], f: fn~(&A) -> bool) -> bool {\n     do vec::any(map_slices(xs, || {\n+        let f = copy f;\n         fn~(_base : uint, slice: &[A], copy f) -> bool {\n             vec::any(slice, |x| f(x))\n         }"}, {"sha": "435e514df444ec76a1f30ce22c97f769519f0758", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 57, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -337,61 +337,27 @@ pub struct field_pat {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum binding_mode {\n-    bind_by_value,\n-    bind_by_move,\n+    bind_by_copy,\n     bind_by_ref(mutability),\n     bind_infer\n }\n \n pub impl binding_mode : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n-          bind_by_value => 0u8.iter_bytes(lsb0, f),\n-\n-          bind_by_move => 1u8.iter_bytes(lsb0, f),\n+          bind_by_copy => 0u8.iter_bytes(lsb0, f),\n \n           bind_by_ref(ref m) =>\n-          to_bytes::iter_bytes_2(&2u8, m, lsb0, f),\n+          to_bytes::iter_bytes_2(&1u8, m, lsb0, f),\n \n           bind_infer =>\n-          3u8.iter_bytes(lsb0, f),\n+          2u8.iter_bytes(lsb0, f),\n         }\n     }\n }\n \n-pub impl binding_mode : cmp::Eq {\n-    pure fn eq(&self, other: &binding_mode) -> bool {\n-        match (*self) {\n-            bind_by_value => {\n-                match (*other) {\n-                    bind_by_value => true,\n-                    _ => false\n-                }\n-            }\n-            bind_by_move => {\n-                match (*other) {\n-                    bind_by_move => true,\n-                    _ => false\n-                }\n-            }\n-            bind_by_ref(e0a) => {\n-                match (*other) {\n-                    bind_by_ref(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            bind_infer => {\n-                match (*other) {\n-                    bind_infer => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &binding_mode) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n pub enum pat_ {\n@@ -603,7 +569,7 @@ pub impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n // \"resolved\" mode: the real modes.\n #[auto_encode]\n #[auto_decode]\n-pub enum rmode { by_ref, by_val, by_move, by_copy }\n+pub enum rmode { by_ref, by_val, by_copy }\n \n pub impl rmode : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n@@ -729,8 +695,8 @@ pub enum expr_ {\n        (implicit) condition is always true. */\n     expr_loop(blk, Option<ident>),\n     expr_match(@expr, ~[arm]),\n-    expr_fn(Proto, fn_decl, blk, capture_clause),\n-    expr_fn_block(fn_decl, blk, capture_clause),\n+    expr_fn(Proto, fn_decl, blk),\n+    expr_fn_block(fn_decl, blk),\n     // Inner expr is always an expr_fn_block. We need the wrapping node to\n     // easily type this (a function returning nil on the inside but bool on\n     // the outside).\n@@ -740,7 +706,6 @@ pub enum expr_ {\n     expr_block(blk),\n \n     expr_copy(@expr),\n-    expr_unary_move(@expr),\n     expr_assign(@expr, @expr),\n     expr_swap(@expr, @expr),\n     expr_assign_op(binop, @expr, @expr),\n@@ -769,20 +734,6 @@ pub enum expr_ {\n     expr_paren(@expr)\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-pub struct capture_item_ {\n-    id: int,\n-    is_move: bool,\n-    name: ident, // Currently, can only capture a local var.\n-    span: span,\n-}\n-\n-pub type capture_item = @capture_item_;\n-\n-pub type capture_clause = @~[capture_item];\n-\n-//\n // When the main rust parser encounters a syntax-extension invocation, it\n // parses the arguments to the invocation as a token-tree. This is a very\n // loose structure, such that all sorts of different AST-fragments can"}, {"sha": "1ae232404048ee85c941ddc130f63f9fd55ef384", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -256,7 +256,7 @@ pub fn ident_to_path(s: span, +i: ident) -> @path {\n \n pub fn ident_to_pat(id: node_id, s: span, +i: ident) -> @pat {\n     @ast::pat { id: id,\n-                node: pat_ident(bind_by_value, ident_to_path(s, i), None),\n+                node: pat_ident(bind_by_copy, ident_to_path(s, i), None),\n                 span: s }\n }\n \n@@ -503,11 +503,8 @@ pub fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n                     vfn(m.self_id);\n                     for vec::each(tps) |tp| { vfn(tp.id); }\n                 }\n-                visit::fk_anon(_, capture_clause) |\n-                visit::fk_fn_block(capture_clause) => {\n-                    for vec::each(*capture_clause) |clause| {\n-                        vfn(clause.id);\n-                    }\n+                visit::fk_anon(_) |\n+                visit::fk_fn_block => {\n                 }\n             }\n "}, {"sha": "dd6a996b7304216325304b2ecd3c43933145f942", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -173,8 +173,8 @@ pub fn find_meta_items_by_name(metas: &[@ast::meta_item], name: &str) ->\n  * Returns true if a list of meta items contains another meta item. The\n  * comparison is performed structurally.\n  */\n-pub fn contains(haystack: ~[@ast::meta_item], needle: @ast::meta_item)\n-             -> bool {\n+pub fn contains(haystack: &[@ast::meta_item],\n+                needle: @ast::meta_item) -> bool {\n     for haystack.each |item| {\n         if eq(*item, needle) { return true; }\n     }"}, {"sha": "a2484e2d6df31d71f895c9a111c2fe2dec4a9839", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -569,7 +569,7 @@ fn mk_ser_method(\n         pat: @ast::pat {\n             id: cx.next_id(),\n             node: ast::pat_ident(\n-                ast::bind_by_value,\n+                ast::bind_by_copy,\n                 ast_util::ident_to_path(span, cx.ident_of(~\"__s\")),\n                 None),\n             span: span,\n@@ -633,7 +633,7 @@ fn mk_deser_method(\n         pat: @ast::pat {\n             id: cx.next_id(),\n             node: ast::pat_ident(\n-                ast::bind_by_value,\n+                ast::bind_by_copy,\n                 ast_util::ident_to_path(span, cx.ident_of(~\"__d\")),\n                 None),\n             span: span,\n@@ -1095,7 +1095,7 @@ fn mk_enum_deser_body(\n                     pat: @ast::pat {\n                         id: cx.next_id(),\n                         node: ast::pat_ident(\n-                            ast::bind_by_value,\n+                            ast::bind_by_copy,\n                             ast_util::ident_to_path(span, cx.ident_of(~\"i\")),\n                             None),\n                         span: span,\n@@ -1114,8 +1114,7 @@ fn mk_enum_deser_body(\n                     span,\n                     ast::expr_match(cx.expr_var(span, ~\"i\"), arms)\n                 )\n-            ),\n-            @~[]\n+            )\n         )\n     );\n "}, {"sha": "6d44a412742e0dec1a8432daffeba29c446155d2", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -203,7 +203,7 @@ pub fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n     let pat = @ast::pat {\n         id: cx.next_id(),\n         node: ast::pat_ident(\n-            ast::bind_by_value,\n+            ast::bind_by_copy,\n             mk_raw_path(sp, ~[ident]),\n             None),\n         span: sp,\n@@ -279,9 +279,8 @@ pub fn mk_pat(cx: ext_ctxt, span: span, +pat: ast::pat_) -> @ast::pat {\n }\n pub fn mk_pat_ident(cx: ext_ctxt,\n                     span: span,\n-                    ident: ast::ident)\n-                 -> @ast::pat {\n-    mk_pat_ident_with_binding_mode(cx, span, ident, ast::bind_by_value)\n+                    ident: ast::ident) -> @ast::pat {\n+    mk_pat_ident_with_binding_mode(cx, span, ident, ast::bind_by_copy)\n }\n pub fn mk_pat_ident_with_binding_mode(cx: ext_ctxt,\n                                       span: span,"}, {"sha": "8abca3d97f955117b35a96297ef6b5bf04e27738", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -105,7 +105,6 @@ pub trait ext_ctxt_ast_builder {\n     fn stmt_let(ident: ident, e: @ast::expr) -> @ast::stmt;\n     fn stmt_expr(e: @ast::expr) -> @ast::stmt;\n     fn block_expr(b: ast::blk) -> @ast::expr;\n-    fn move_expr(e: @ast::expr) -> @ast::expr;\n     fn ty_option(ty: @ast::Ty) -> @ast::Ty;\n     fn ty_infer() -> @ast::Ty;\n     fn ty_nil_ast_builder() -> @ast::Ty;\n@@ -130,15 +129,6 @@ pub impl ext_ctxt: ext_ctxt_ast_builder {\n         }\n     }\n \n-    fn move_expr(e: @ast::expr) -> @ast::expr {\n-        @expr {\n-            id: self.next_id(),\n-            callee_id: self.next_id(),\n-            node: ast::expr_unary_move(e),\n-            span: e.span,\n-        }\n-    }\n-\n     fn stmt_expr(e: @ast::expr) -> @ast::stmt {\n         @spanned { node: ast::stmt_expr(e, self.next_id()),\n                    span: dummy_sp()}\n@@ -205,7 +195,7 @@ pub impl ext_ctxt: ext_ctxt_ast_builder {\n             pat: @ast::pat {\n                 id: self.next_id(),\n                 node: ast::pat_ident(\n-                    ast::bind_by_value,\n+                    ast::bind_by_copy,\n                     ast_util::ident_to_path(dummy_sp(), name),\n                     None),\n                 span: dummy_sp(),"}, {"sha": "2c2ecb91e21b228f769c8e38d2fc34558c83e84c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -466,30 +466,17 @@ pub fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_match(fld.fold_expr(expr),\n                      vec::map((*arms), |x| fld.fold_arm(*x)))\n           }\n-          expr_fn(proto, decl, ref body, captures) => {\n-            let captures = do captures.map |cap_item| {\n-                @ast::capture_item_ {\n-                    id: fld.new_id(cap_item.id),\n-                    ..**cap_item\n-                }\n-            };\n-            expr_fn(proto, fold_fn_decl(decl, fld),\n-                    fld.fold_block((*body)),\n-                    @captures)\n+          expr_fn(proto, decl, ref body) => {\n+            expr_fn(proto,\n+                    fold_fn_decl(decl, fld),\n+                    fld.fold_block(*body))\n           }\n-          expr_fn_block(decl, ref body, captures) => {\n-            let captures = do captures.map |cap_item| {\n-                @ast::capture_item_ {\n-                    id: fld.new_id(cap_item.id),\n-                    ..**cap_item\n-                }\n-            };\n-            expr_fn_block(fold_fn_decl(decl, fld), fld.fold_block((*body)),\n-                          @captures)\n+          expr_fn_block(decl, ref body) => {\n+            expr_fn_block(fold_fn_decl(decl, fld),\n+                          fld.fold_block(*body))\n           }\n           expr_block(ref blk) => expr_block(fld.fold_block((*blk))),\n           expr_copy(e) => expr_copy(fld.fold_expr(e)),\n-          expr_unary_move(e) => expr_unary_move(fld.fold_expr(e)),\n           expr_assign(el, er) => {\n             expr_assign(fld.fold_expr(el), fld.fold_expr(er))\n           }"}, {"sha": "81393310cdaa320163cc558ac3e3630d267faf82", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 55, "deletions": 86, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -13,9 +13,9 @@ use core::prelude::*;\n use ast::{ProtoBox, ProtoUniq, RegionTyParamBound, TraitTyParamBound};\n use ast::{provided, public, pure_fn, purity, re_static};\n use ast::{_mod, add, arg, arm, attribute, bind_by_ref, bind_infer};\n-use ast::{bind_by_value, bind_by_move, bitand, bitor, bitxor, blk};\n-use ast::{blk_check_mode, box, by_copy, by_move, by_ref, by_val};\n-use ast::{capture_clause, capture_item, crate, crate_cfg, decl, decl_item};\n+use ast::{bind_by_copy, bitand, bitor, bitxor, blk};\n+use ast::{blk_check_mode, box, by_copy, by_ref, by_val};\n+use ast::{crate, crate_cfg, decl, decl_item};\n use ast::{decl_local, default_blk, deref, div, enum_def, enum_variant_kind};\n use ast::{expl, expr, expr_, expr_addr_of, expr_match, expr_again};\n use ast::{expr_assert, expr_assign, expr_assign_op, expr_binary, expr_block};\n@@ -24,7 +24,7 @@ use ast::{expr_fail, expr_field, expr_fn, expr_fn_block, expr_if, expr_index};\n use ast::{expr_lit, expr_log, expr_loop, expr_loop_body, expr_mac};\n use ast::{expr_method_call, expr_paren, expr_path, expr_rec, expr_repeat};\n use ast::{expr_ret, expr_swap, expr_struct, expr_tup, expr_unary};\n-use ast::{expr_unary_move, expr_vec, expr_vstore, expr_vstore_mut_box};\n+use ast::{expr_vec, expr_vstore, expr_vstore_mut_box};\n use ast::{expr_vstore_fixed, expr_vstore_slice, expr_vstore_box};\n use ast::{expr_vstore_mut_slice, expr_while, extern_fn, field, fn_decl};\n use ast::{expr_vstore_uniq, TyFn, Onceness, Once, Many};\n@@ -102,7 +102,7 @@ enum restriction {\n enum class_contents { dtor_decl(blk, ~[attribute], codemap::span),\n                       members(~[@struct_field]) }\n \n-type arg_or_capture_item = Either<arg, capture_item>;\n+type arg_or_capture_item = Either<arg, ()>;\n type item_info = (ident, item_, Option<~[attribute]>);\n \n pub enum item_or_view_item {\n@@ -401,7 +401,7 @@ pub impl Parser {\n \n             let tps = p.parse_ty_params();\n \n-            let (self_ty, d, _) = do self.parse_fn_decl_with_self() |p| {\n+            let (self_ty, d) = do self.parse_fn_decl_with_self() |p| {\n                 // This is somewhat dubious; We don't want to allow argument\n                 // names to be left off if there is a definition...\n                 either::Left(p.parse_arg_general(false))\n@@ -651,7 +651,7 @@ pub impl Parser {\n \n     fn parse_arg_mode() -> mode {\n         if self.eat(token::BINOP(token::MINUS)) {\n-            expl(by_move)\n+            expl(by_copy) // NDM outdated syntax\n         } else if self.eat(token::ANDAND) {\n             expl(by_ref)\n         } else if self.eat(token::BINOP(token::PLUS)) {\n@@ -689,23 +689,12 @@ pub impl Parser {\n     }\n \n     fn parse_capture_item_or(parse_arg_fn: fn(Parser) -> arg_or_capture_item)\n-        -> arg_or_capture_item {\n-\n-        fn parse_capture_item(p:Parser, is_move: bool) -> capture_item {\n-            let sp = mk_sp(p.span.lo, p.span.hi);\n-            let ident = p.parse_ident();\n-            @ast::capture_item_ {\n-                id: p.get_id(),\n-                is_move: is_move,\n-                name: ident,\n-                span: sp,\n-            }\n-        }\n-\n-        if self.eat_keyword(~\"move\") {\n-            either::Right(parse_capture_item(self, true))\n-        } else if self.eat_keyword(~\"copy\") {\n-            either::Right(parse_capture_item(self, false))\n+        -> arg_or_capture_item\n+    {\n+        if self.eat_keyword(~\"move\") || self.eat_keyword(~\"copy\") {\n+            // XXX outdated syntax now that moves-based-on-type has gone in\n+            self.parse_ident();\n+            either::Right(())\n         } else {\n             parse_arg_fn(self)\n         }\n@@ -1078,9 +1067,8 @@ pub impl Parser {\n             ex = expr_copy(e);\n             hi = e.span.hi;\n         } else if self.eat_keyword(~\"move\") {\n-            let e = self.parse_expr();\n-            ex = expr_unary_move(e);\n-            hi = e.span.hi;\n+            // XXX move keyword is no longer important, remove after snapshot\n+            return self.parse_expr();\n         } else if self.token == token::MOD_SEP ||\n             is_ident(self.token) && !self.is_keyword(~\"true\") &&\n             !self.is_keyword(~\"false\") {\n@@ -1576,12 +1564,10 @@ pub impl Parser {\n \n         // if we want to allow fn expression argument types to be inferred in\n         // the future, just have to change parse_arg to parse_fn_block_arg.\n-        let (decl, capture_clause) =\n-            self.parse_fn_decl(|p| p.parse_arg_or_capture_item());\n+        let decl = self.parse_fn_decl(|p| p.parse_arg_or_capture_item());\n \n         let body = self.parse_block();\n-        return self.mk_expr(lo, body.span.hi,\n-                         expr_fn(proto, decl, body, capture_clause));\n+        return self.mk_expr(lo, body.span.hi,expr_fn(proto, decl, body));\n     }\n \n     // `|args| { ... }` like in `do` expressions\n@@ -1594,18 +1580,15 @@ pub impl Parser {\n                   }\n                   _ => {\n                     // No argument list - `do foo {`\n-                    (\n-                        ast::fn_decl {\n-                            inputs: ~[],\n-                            output: @Ty {\n-                                id: self.get_id(),\n-                                node: ty_infer,\n-                                span: self.span\n-                            },\n-                            cf: return_val\n-                        },\n-                        @~[]\n-                    )\n+                      ast::fn_decl {\n+                          inputs: ~[],\n+                          output: @Ty {\n+                              id: self.get_id(),\n+                              node: ty_infer,\n+                              span: self.span\n+                          },\n+                          cf: return_val\n+                      }\n                   }\n                 }\n             },\n@@ -1621,10 +1604,10 @@ pub impl Parser {\n                                 || self.parse_expr())\n     }\n \n-    fn parse_lambda_expr_(parse_decl: fn&() -> (fn_decl, capture_clause),\n+    fn parse_lambda_expr_(parse_decl: fn&() -> fn_decl,\n                           parse_body: fn&() -> @expr) -> @expr {\n         let lo = self.last_span.lo;\n-        let (decl, captures) = parse_decl();\n+        let decl = parse_decl();\n         let body = parse_body();\n         let fakeblock = ast::blk_ {\n             view_items: ~[],\n@@ -1636,7 +1619,7 @@ pub impl Parser {\n         let fakeblock = spanned(body.span.lo, body.span.hi,\n                                 fakeblock);\n         return self.mk_expr(lo, body.span.hi,\n-                         expr_fn_block(decl, fakeblock, captures));\n+                            expr_fn_block(decl, fakeblock));\n     }\n \n     fn parse_else_expr() -> @expr {\n@@ -2065,22 +2048,16 @@ pub impl Parser {\n                 let mutbl = self.parse_mutability();\n                 pat = self.parse_pat_ident(refutable, bind_by_ref(mutbl));\n             } else if self.eat_keyword(~\"copy\") {\n-                pat = self.parse_pat_ident(refutable, bind_by_value);\n-            } else if self.eat_keyword(~\"move\") {\n-                pat = self.parse_pat_ident(refutable, bind_by_move);\n+                pat = self.parse_pat_ident(refutable, bind_by_copy);\n             } else {\n-                let binding_mode;\n-                // XXX: Aren't these two cases deadcode? -- bblum\n-                if self.eat_keyword(~\"copy\") {\n-                    binding_mode = bind_by_value;\n-                } else if self.eat_keyword(~\"move\") {\n-                    binding_mode = bind_by_move;\n-                } else if refutable {\n-                    binding_mode = bind_infer;\n-                } else {\n-                    binding_mode = bind_by_value;\n+                if self.eat_keyword(~\"move\") {\n+                    /* XXX---remove move keyword */\n                 }\n \n+                // XXX---refutable match bindings should work same as let\n+                let binding_mode =\n+                    if refutable {bind_infer} else {bind_by_copy};\n+\n                 let cannot_be_enum_or_struct;\n                 match self.look_ahead(1) {\n                     token::LPAREN | token::LBRACKET | token::LT |\n@@ -2560,25 +2537,21 @@ pub impl Parser {\n     }\n \n     fn parse_fn_decl(parse_arg_fn: fn(Parser) -> arg_or_capture_item)\n-        -> (fn_decl, capture_clause) {\n-\n+        -> fn_decl\n+    {\n         let args_or_capture_items: ~[arg_or_capture_item] =\n             self.parse_unspanned_seq(\n                 token::LPAREN, token::RPAREN,\n                 seq_sep_trailing_disallowed(token::COMMA), parse_arg_fn);\n \n         let inputs = either::lefts(args_or_capture_items);\n-        let capture_clause = @either::rights(args_or_capture_items);\n \n         let (ret_style, ret_ty) = self.parse_ret_ty();\n-        (\n-            ast::fn_decl {\n-                inputs: inputs,\n-                output: ret_ty,\n-                cf: ret_style,\n-            },\n-            capture_clause\n-        )\n+        ast::fn_decl {\n+            inputs: inputs,\n+            output: ret_ty,\n+            cf: ret_style,\n+        }\n     }\n \n     fn is_self_ident() -> bool {\n@@ -2598,8 +2571,8 @@ pub impl Parser {\n     }\n \n     fn parse_fn_decl_with_self(parse_arg_fn:\n-                                    fn(Parser) -> arg_or_capture_item)\n-                            -> (self_ty, fn_decl, capture_clause) {\n+                               fn(Parser) -> arg_or_capture_item)\n+                            -> (self_ty, fn_decl) {\n \n         fn maybe_parse_self_ty(cnstr: fn(+v: mutability) -> ast::self_ty_,\n                                p: Parser) -> ast::self_ty_ {\n@@ -2675,7 +2648,6 @@ pub impl Parser {\n         let hi = self.span.hi;\n \n         let inputs = either::lefts(args_or_capture_items);\n-        let capture_clause = @either::rights(args_or_capture_items);\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n \n         let fn_decl = ast::fn_decl {\n@@ -2684,10 +2656,10 @@ pub impl Parser {\n             cf: ret_style\n         };\n \n-        (spanned(lo, hi, self_ty), fn_decl, capture_clause)\n+        (spanned(lo, hi, self_ty), fn_decl)\n     }\n \n-    fn parse_fn_block_decl() -> (fn_decl, capture_clause) {\n+    fn parse_fn_block_decl() -> fn_decl {\n         let inputs_captures = {\n             if self.eat(token::OROR) {\n                 ~[]\n@@ -2704,14 +2676,11 @@ pub impl Parser {\n             @Ty { id: self.get_id(), node: ty_infer, span: self.span }\n         };\n \n-        (\n-            ast::fn_decl {\n-                inputs: either::lefts(inputs_captures),\n-                output: output,\n-                cf: return_val,\n-            },\n-            @either::rights(inputs_captures)\n-        )\n+        ast::fn_decl {\n+            inputs: either::lefts(inputs_captures),\n+            output: output,\n+            cf: return_val,\n+        }\n     }\n \n     fn parse_fn_header() -> {ident: ident, tps: ~[ty_param]} {\n@@ -2733,7 +2702,7 @@ pub impl Parser {\n \n     fn parse_item_fn(purity: purity) -> item_info {\n         let t = self.parse_fn_header();\n-        let (decl, _) = self.parse_fn_decl(|p| p.parse_arg());\n+        let decl = self.parse_fn_decl(|p| p.parse_arg());\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n         (t.ident, item_fn(decl, purity, t.tps, body), Some(inner_attrs))\n     }\n@@ -2753,7 +2722,7 @@ pub impl Parser {\n         let pur = self.parse_fn_purity();\n         let ident = self.parse_method_name();\n         let tps = self.parse_ty_params();\n-        let (self_ty, decl, _) = do self.parse_fn_decl_with_self() |p| {\n+        let (self_ty, decl) = do self.parse_fn_decl_with_self() |p| {\n             p.parse_arg()\n         };\n         // XXX: interaction between staticness, self_ty is broken now\n@@ -3262,7 +3231,7 @@ pub impl Parser {\n         let vis = self.parse_visibility();\n         let purity = self.parse_fn_purity();\n         let t = self.parse_fn_header();\n-        let (decl, _) = self.parse_fn_decl(|p| p.parse_arg());\n+        let decl = self.parse_fn_decl(|p| p.parse_arg());\n         let mut hi = self.span.hi;\n         self.expect(token::SEMI);\n         @ast::foreign_item { ident: t.ident,"}, {"sha": "39fb98aea2695bb29f029903a56a4cc78d41d46b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -1305,24 +1305,24 @@ pub fn print_expr(s: ps, &&expr: @ast::expr) {\n         }\n         bclose_(s, expr.span, match_indent_unit);\n       }\n-      ast::expr_fn(proto, decl, ref body, cap_clause) => {\n+      ast::expr_fn(proto, decl, ref body) => {\n         // containing cbox, will be closed by print-block at }\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block at start\n         ibox(s, 0u);\n         print_fn_header_info(s, None, None, ast::Many,\n                              Some(proto), ast::inherited);\n-        print_fn_args_and_ret(s, decl, *cap_clause, None);\n+        print_fn_args_and_ret(s, decl, None);\n         space(s.s);\n         print_block(s, (*body));\n       }\n-      ast::expr_fn_block(decl, ref body, cap_clause) => {\n+      ast::expr_fn_block(decl, ref body) => {\n         // in do/for blocks we don't want to show an empty\n         // argument list, but at this point we don't know which\n         // we are inside.\n         //\n         // if !decl.inputs.is_empty() {\n-        print_fn_block_args(s, decl, *cap_clause);\n+        print_fn_block_args(s, decl);\n         space(s.s);\n         // }\n         assert (*body).node.stmts.is_empty();\n@@ -1357,10 +1357,6 @@ pub fn print_expr(s: ps, &&expr: @ast::expr) {\n         print_block(s, (*blk));\n       }\n       ast::expr_copy(e) => { word_space(s, ~\"copy\"); print_expr(s, e); }\n-      ast::expr_unary_move(e) => {\n-          word_space(s, ~\"move\");\n-          print_expr(s, e);\n-      }\n       ast::expr_assign(lhs, rhs) => {\n         print_expr(s, lhs);\n         space(s.s);\n@@ -1554,10 +1550,7 @@ pub fn print_pat(s: ps, &&pat: @ast::pat, refutable: bool) {\n                       word_nbsp(s, ~\"ref\");\n                       print_mutability(s, mutbl);\n                   }\n-                  ast::bind_by_move => {\n-                      word_nbsp(s, ~\"move\");\n-                  }\n-                  ast::bind_by_value => {\n+                  ast::bind_by_copy => {\n                       word_nbsp(s, ~\"copy\");\n                   }\n                   ast::bind_infer => {}\n@@ -1693,16 +1686,14 @@ pub fn print_fn(s: ps,\n     nbsp(s);\n     print_ident(s, name);\n     print_type_params(s, typarams);\n-    print_fn_args_and_ret(s, decl, ~[], opt_self_ty);\n+    print_fn_args_and_ret(s, decl, opt_self_ty);\n }\n \n pub fn print_fn_args(s: ps, decl: ast::fn_decl,\n-                     cap_items: ~[ast::capture_item],\n-                     opt_self_ty: Option<ast::self_ty_>) {\n-    // It is unfortunate to duplicate the commasep logic, but we\n-    // we want the self type, the args, and the capture clauses all\n-    // in the same box.\n-    box(s, 0, inconsistent);\n+                 opt_self_ty: Option<ast::self_ty_>) {\n+    // It is unfortunate to duplicate the commasep logic, but we we want the\n+    // self type and the args all in the same box.\n+    box(s, 0u, inconsistent);\n     let mut first = true;\n     for opt_self_ty.each |self_ty| {\n         first = !print_self_ty(s, *self_ty);\n@@ -1713,21 +1704,13 @@ pub fn print_fn_args(s: ps, decl: ast::fn_decl,\n         print_arg(s, *arg);\n     }\n \n-    for cap_items.each |cap_item| {\n-        if first { first = false; } else { word_space(s, ~\",\"); }\n-        if cap_item.is_move { word_nbsp(s, ~\"move\") }\n-        else { word_nbsp(s, ~\"copy\") }\n-        print_ident(s, cap_item.name);\n-    }\n-\n     end(s);\n }\n \n pub fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n-                             cap_items: ~[ast::capture_item],\n                              opt_self_ty: Option<ast::self_ty_>) {\n     popen(s);\n-    print_fn_args(s, decl, cap_items, opt_self_ty);\n+    print_fn_args(s, decl, opt_self_ty);\n     pclose(s);\n \n     maybe_print_comment(s, decl.output.span.lo);\n@@ -1741,10 +1724,9 @@ pub fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n     }\n }\n \n-pub fn print_fn_block_args(s: ps, decl: ast::fn_decl,\n-                           cap_items: ~[ast::capture_item]) {\n+pub fn print_fn_block_args(s: ps, decl: ast::fn_decl) {\n     word(s.s, ~\"|\");\n-    print_fn_args(s, decl, cap_items, None);\n+    print_fn_args(s, decl, None);\n     word(s.s, ~\"|\");\n \n     match decl.output.node {\n@@ -1761,10 +1743,9 @@ pub fn print_fn_block_args(s: ps, decl: ast::fn_decl,\n \n pub fn mode_to_str(m: ast::mode) -> ~str {\n     match m {\n-      ast::expl(ast::by_move) => ~\"-\",\n       ast::expl(ast::by_ref) => ~\"&&\",\n-      ast::expl(ast::by_val) => ~\"++\",\n       ast::expl(ast::by_copy) => ~\"+\",\n+      ast::expl(ast::by_val) => ~\"++\",\n       ast::infer(_) => ~\"\"\n     }\n }"}, {"sha": "dd7f274b5ba026b8a3ba1f1cddc767004f7c3fe0", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -32,8 +32,8 @@ pub enum vt<E> { mk_vt(visitor<E>), }\n pub enum fn_kind {\n     fk_item_fn(ident, ~[ty_param], purity), //< an item declared with fn()\n     fk_method(ident, ~[ty_param], @method),\n-    fk_anon(Proto, capture_clause),  //< an anonymous function like fn@(...)\n-    fk_fn_block(capture_clause),     //< a block {||...}\n+    fk_anon(Proto),    //< an anonymous function like fn@(...)\n+    fk_fn_block,       //< a block {||...}\n     fk_dtor(~[ty_param], ~[attribute], node_id /* self id */,\n             def_id /* parent class id */) // class destructor\n \n@@ -457,12 +457,12 @@ pub fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         (v.visit_expr)(x, e, v);\n         for (*arms).each |a| { (v.visit_arm)(*a, e, v); }\n       }\n-      expr_fn(proto, decl, ref body, cap_clause) => {\n-        (v.visit_fn)(fk_anon(proto, cap_clause), decl, (*body),\n+      expr_fn(proto, decl, ref body) => {\n+        (v.visit_fn)(fk_anon(proto), decl, (*body),\n                      ex.span, ex.id, e, v);\n       }\n-      expr_fn_block(decl, ref body, cap_clause) => {\n-        (v.visit_fn)(fk_fn_block(cap_clause), decl, (*body),\n+      expr_fn_block(decl, ref body) => {\n+        (v.visit_fn)(fk_fn_block, decl, (*body),\n                      ex.span, ex.id, e, v);\n       }\n       expr_block(ref b) => (v.visit_block)((*b), e, v),\n@@ -471,7 +471,6 @@ pub fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         (v.visit_expr)(a, e, v);\n       }\n       expr_copy(a) => (v.visit_expr)(a, e, v),\n-      expr_unary_move(a) => (v.visit_expr)(a, e, v),\n       expr_swap(a, b) => { (v.visit_expr)(a, e, v); (v.visit_expr)(b, e, v); }\n       expr_assign_op(_, a, b) => {\n         (v.visit_expr)(b, e, v);"}, {"sha": "9667c1d82d859599142980c805f90427df6a6f4a", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -377,7 +377,8 @@ fn validate(edges: ~[(node_id, node_id)],\n \n     log(info, ~\"Verifying tree and graph edges...\");\n \n-    let status = do par::alli(tree) |u, v, copy edges| {\n+    let edges = copy edges;\n+    let status = do par::alli(tree) |u, v| {\n         let u = u as node_id;\n         if *v == -1i64 || u == root {\n             true"}, {"sha": "cd85cb197781ff7a12bd87d44d88bc3f058acc46", "filename": "src/test/compile-fail/alt-vec-tail-move.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Falt-vec-tail-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Falt-vec-tail-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-vec-tail-move.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,8 +0,0 @@\n-fn main() {\n-    let a = [mut 1, 2, 3, 4];\n-    let _ = match a {\n-        [1, 2, ..move tail] => tail,\n-        _ => core::util::unreachable()\n-    };\n-    a[0] = 0; //~ ERROR: use of moved value\n-}"}, {"sha": "366cf5a48ea2ca57320a9e89aab8dbaa0f949374", "filename": "src/test/compile-fail/block-deinitializes-upvar.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fblock-deinitializes-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fblock-deinitializes-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-deinitializes-upvar.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:moving out of captured outer immutable variable in a stack closure\n-fn force(f: fn()) { f(); }\n-fn main() {\n-    let mut x = @{x: 17, y: 2};\n-    let y = @{x: 5, y: 5};\n-\n-    force(|| x = move y );\n-}"}, {"sha": "50bedc573406bf5876953e99f017bfd19522efc3", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -13,18 +13,18 @@ fn borrow(v: &int, f: fn(x: &int)) {\n }\n \n fn box_imm() {\n-    let mut v = ~3;\n-    let _w = &mut v; //~ NOTE loan of mutable local variable granted here\n-    do task::spawn |move v| {\n-        //~^ ERROR moving out of mutable local variable prohibited due to outstanding loan\n+    let v = ~3;\n+    let _w = &v; //~ NOTE loan of immutable local variable granted here\n+    do task::spawn {\n         debug!(\"v=%d\", *v);\n+        //~^ ERROR by-move capture of immutable local variable prohibited due to outstanding loan\n     }\n \n-    let mut v = ~3;\n-    let _w = &mut v; //~ NOTE loan of mutable local variable granted here\n-    task::spawn(fn~(move v) {\n-        //~^ ERROR moving out of mutable local variable prohibited due to outstanding loan\n+    let v = ~3;\n+    let _w = &v; //~ NOTE loan of immutable local variable granted here\n+    task::spawn(fn~() {\n         debug!(\"v=%d\", *v);\n+        //~^ ERROR by-move capture of immutable local variable prohibited due to outstanding loan\n     });\n }\n "}, {"sha": "d80c56eb64f3ba7e2ca7fda870f6425b3c4d6ebc", "filename": "src/test/compile-fail/borrowck-move-by-capture.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -0,0 +1,18 @@\n+extern mod std;\n+\n+use std::ebml::reader;\n+use std::ebml::writer;\n+use std::serialize;\n+\n+fn main() {\n+    let foo = ~3;\n+    let _pfoo = &foo;\n+    let _f: @fn() -> int = || *foo + 5;\n+    //~^ ERROR by-move capture\n+\n+    let bar = ~3;\n+    let _g = || {\n+        let _h: @fn() -> int = || *bar;\n+        //~^ ERROR illegal by-move capture\n+    };\n+}"}, {"sha": "941883f80f93e18435829abc7af5b519ecaab657", "filename": "src/test/compile-fail/borrowck-vec-pattern-move-tail.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let a = [mut 1, 2, 3, 4];\n+    let _ = match a {\n+        [1, 2, ..tail] => tail,\n+        _ => core::util::unreachable()\n+    };\n+    a[0] = 0; //~ ERROR: assigning to mutable vec content prohibited due to outstanding loan\n+}"}, {"sha": "174715807ec3591fe179ec58a2d4a5f44bef6525", "filename": "src/test/compile-fail/cap-clause-both-copy-and-move.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-both-copy-and-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-both-copy-and-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-both-copy-and-move.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:variable `x` captured more than once\n-fn main() {\n-    let x = 5;\n-    let y = fn~(move x, copy x) -> int { x };\n-}"}, {"sha": "5c08382153817d427f0cc9da78af0a65552359ff", "filename": "src/test/compile-fail/cap-clause-double-copy.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-double-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-double-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-double-copy.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:variable `x` captured more than once\n-fn main() {\n-    let x = 5;\n-    let y = fn~(copy x, copy x) -> int { x };\n-}"}, {"sha": "d87d0804e9978322875785746571caf681defb88", "filename": "src/test/compile-fail/cap-clause-double-move.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-double-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-double-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-double-move.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:variable `x` captured more than once\n-fn main() {\n-    let x = 5;\n-    let y = fn~(move x, move x) -> int { x };\n-}"}, {"sha": "46a858a7cb2bd801dc70d9e343ee641fc1222a23", "filename": "src/test/compile-fail/cap-clause-illegal-cap.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-illegal-cap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-illegal-cap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-illegal-cap.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: copying a noncopyable value\n-\n-struct foo { x: int, }\n-\n-impl foo : Drop {\n-    fn finalize(&self) {}\n-}\n-\n-fn foo(x: int) -> foo {\n-    foo {\n-        x: x\n-    }\n-}\n-\n-fn to_lambda2(b: foo) -> fn@(uint) -> uint {\n-    // test case where copy clause specifies a value that is not used\n-    // in fn@ body, but value is illegal to copy:\n-    return fn@(u: uint, copy b) -> uint { 22u };\n-}\n-\n-fn main() {\n-}"}, {"sha": "255a17ac4267e8b952239ebc1663185191c1e2c1", "filename": "src/test/compile-fail/cap-clause-move-upvar.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-move-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-move-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-move-upvar.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    let x = 5;\n-    let _y = fn~(move x) -> int {\n-        let _z = fn~(move x) -> int { x }; //~ ERROR moving out of captured outer variable in a heap closure\n-        22\n-    };\n-}"}, {"sha": "3d38008c675224ba232d5020651314511e2d4951", "filename": "src/test/compile-fail/cap-clause-unresolved-copy.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-copy.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:unresolved name\n-fn main() {\n-    let x = 5;\n-    let y = fn~(copy z, copy x) {\n-    };\n-}"}, {"sha": "ada8b0d001b0f76f7486ce9079fd0649f70e0769", "filename": "src/test/compile-fail/cap-clause-unresolved-move.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-move.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:unresolved name\n-fn main() {\n-    let x = 5;\n-    let y = fn~(move z, move x) {\n-    };\n-}"}, {"sha": "097158843a295a2e37ab163423092492ce222958", "filename": "src/test/compile-fail/cap-clause-use-after-move.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-use-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-use-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-use-after-move.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    let x = 5;\n-    let _y = fn~(move x) { }; //~ WARNING captured variable `x` not used in closure\n-    let _z = x; //~ ERROR use of moved value: `x`\n-}"}, {"sha": "13d91eabcdec87a4655b54f7daf7db710f040ad3", "filename": "src/test/compile-fail/cap-clause-with-stack-closure.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-with-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcap-clause-with-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-with-stack-closure.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn foo(_f: fn()) {}\n-fn bar(_f: @int) {}\n-\n-fn main() {\n-    let x = @3;\n-    foo(|| bar(x) );\n-\n-    let x = @3;\n-    foo(|copy x| bar(x) ); //~ ERROR cannot capture values explicitly with a block closure\n-\n-    let x = @3;\n-    foo(|move x| bar(x) ); //~ ERROR cannot capture values explicitly with a block closure\n-}\n-"}, {"sha": "21d4fa8eab8808a29c592413992512ce3839d3f3", "filename": "src/test/compile-fail/copy-into-closure.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcopy-into-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fcopy-into-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-into-closure.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn closure2(+x: core::util::NonCopyable)\n-        -> (core::util::NonCopyable, fn@() -> core::util::NonCopyable) {\n-    let f = fn@(copy x) -> core::util::NonCopyable {\n-        //~^ ERROR copying a noncopyable value\n-        //~^^ NOTE non-copyable value cannot be copied into a @fn closure\n-        copy x\n-        //~^ ERROR copying a noncopyable value\n-    };\n-    (move x,f)\n-}\n-fn closure3(+x: core::util::NonCopyable) {\n-    do task::spawn |copy x| {\n-        //~^ ERROR copying a noncopyable value\n-        //~^^ NOTE non-copyable value cannot be copied into a ~fn closure\n-        error!(\"%?\", x);\n-    }\n-    error!(\"%?\", x);\n-}\n-fn main() {\n-}"}, {"sha": "c0430a6a8bb7dd0abb4e60592efe8db0a63a79ab", "filename": "src/test/compile-fail/functional-struct-update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -25,7 +25,7 @@ struct Foo {\n \n fn main() {\n     let a = Foo { x: 1, y: Bar { x: 5 } };\n-    let c = Foo { x: 4, .. a}; //~ ERROR copying a noncopyable value\n+    let c = Foo { x: 4, .. a}; //~ ERROR cannot copy field `y` of base expression, which has a noncopyable type\n     io::println(fmt!(\"%?\", c));\n }\n "}, {"sha": "a93b74461a1785524a86b67fd76aac9c740daf73", "filename": "src/test/compile-fail/issue-1965.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fissue-1965.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fcompile-fail%2Fissue-1965.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1965.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern:moving out of captured outer immutable variable in a stack closure\n-fn test(-x: uint) {}\n-\n-fn main() {\n-    let i = 3;\n-    for uint::range(0, 10) |_x| {test(move i)}\n-}"}, {"sha": "c2732d383ab5bd80d9346dd4dc4ea2c0beabc6af", "filename": "src/test/compile-fail/kindck-implicit-close-over-mut-var.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fkindck-implicit-close-over-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fkindck-implicit-close-over-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-implicit-close-over-mut-var.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -31,11 +31,14 @@ fn bar() {\n }\n \n fn car() {\n-    // Here, i is mutable, but *explicitly* copied:\n+    // Here, i is mutable, but *explicitly* shadowed copied:\n     let mut i = 0;\n     while i < 10 {\n-        do task::spawn |copy i| {\n-            user(i);\n+        {\n+            let i = i;\n+            do task::spawn {\n+                user(i);\n+            }\n         }\n         i += 1;\n     }"}, {"sha": "ae1c086b34037e8f04dabdfb8759846f86c6f0c4", "filename": "src/test/compile-fail/liveness-move-call-arg.rs", "status": "renamed", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fliveness-move-call-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fliveness-move-call-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-call-arg.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: use of moved value\n+fn take(_x: ~int) {}\n \n fn main() {\n-    let x = 3;\n-    let y = move x;\n-    debug!(\"%d\", x);\n-}\n \n+    let x: ~int = ~25;\n+    loop {\n+        take(x); //~ ERROR use of moved value: `x`\n+    }\n+}", "previous_filename": "src/test/compile-fail/unary-move.rs"}, {"sha": "d6c0be9f1833c713b5bd59a4173646aefbcfa7c3", "filename": "src/test/compile-fail/liveness-move-from-args.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-from-args.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -8,22 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn take(-_x: int) { }\n+fn take(_x: ~int) { }\n \n-fn from_by_value_arg(++x: int) {\n-    take(move x);  //~ ERROR illegal move from argument `x`, which is not copy or move mode\n+fn from_by_value_arg(++x: ~int) {\n+    take(x);  //~ ERROR illegal move from argument `x`, which is not copy or move mode\n }\n \n-fn from_by_ref_arg(&&x: int) {\n-    take(move x);  //~ ERROR illegal move from argument `x`, which is not copy or move mode\n+fn from_by_ref_arg(&&x: ~int) {\n+    take(x);  //~ ERROR illegal move from argument `x`, which is not copy or move mode\n }\n \n-fn from_copy_arg(+x: int) {\n-    take(move x);\n-}\n-\n-fn from_move_arg(-x: int) {\n-    take(move x);\n+fn from_copy_arg(+x: ~int) {\n+    take(x);\n }\n \n fn main() {"}, {"sha": "cb9d028809e7db833a71dfa102d9c54d13f1ba14", "filename": "src/test/compile-fail/liveness-move-in-loop.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -9,19 +9,16 @@\n // except according to those terms.\n \n fn main() {\n-\n-    let y: int = 42;\n-    let mut x: int;\n+    let y: ~int = ~42;\n+    let mut x: ~int;\n     loop {\n         log(debug, y);\n         loop {\n             loop {\n                 loop {\n // tjc: Not sure why it prints the same error twice\n-                    x = move y; //~ ERROR use of moved value\n-                    //~^ NOTE move of value occurred here\n-                    //~^^ ERROR use of moved value\n-                    //~^^^ NOTE move of value occurred here\n+                    x = y; //~ ERROR use of moved value\n+                    //~^ ERROR use of moved value\n \n                     copy x;\n                 }"}, {"sha": "fa8ce00fb0825bd53cb390243238a5b5ea04b567", "filename": "src/test/compile-fail/liveness-move-in-while.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -10,15 +10,13 @@\n \n fn main() {\n \n-    let y: int = 42;\n-    let mut x: int;\n+    let y: ~int = ~42;\n+    let mut x: ~int;\n     loop {\n         log(debug, y);\n // tjc: not sure why it prints the same error twice\n-        while true { while true { while true { x = move y; copy x; } } }\n+        while true { while true { while true { x = y; copy x; } } }\n         //~^ ERROR use of moved value: `y`\n-        //~^^ NOTE move of value occurred here\n-        //~^^^ ERROR use of moved value: `y`\n-        //~^^^^ NOTE move of value occurred here\n+        //~^^ ERROR use of moved value: `y`\n     }\n }"}, {"sha": "16518261009fffec29ea8c7ac2a7a2f9646a4657", "filename": "src/test/compile-fail/liveness-use-after-move.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-move.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n fn main() {\n-    let x = @5;\n-    let y = move x; //~ NOTE move of value occurred here\n+    let x = ~5;\n+    let y = x;\n     log(debug, *x); //~ ERROR use of moved value: `x`\n     copy y;\n }"}, {"sha": "2746c5a304bfbff7854d562543baab86d8950d65", "filename": "src/test/compile-fail/liveness-use-after-send.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -18,8 +18,8 @@ enum _chan<T> = int;\n \n // Tests that \"log(debug, message);\" is flagged as using\n // message after the send deinitializes it\n-fn test00_start(ch: _chan<int>, message: int, _count: int) {\n-    send(ch, move message); //~ NOTE move of value occurred here\n+fn test00_start(ch: _chan<~int>, message: ~int, _count: ~int) {\n+    send(ch, message);\n     log(debug, message); //~ ERROR use of moved value: `message`\n }\n "}, {"sha": "663b615816d0c149a6ac600f91ea407855543c4a", "filename": "src/test/compile-fail/moves-based-on-type-access-to-field.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -0,0 +1,20 @@\n+// Tests that if you move from `x.f` or `x[0]`, `x` is inaccessible.\n+// Also tests that we give a more specific error message.\n+\n+struct Foo { f: ~str, y: int }\n+fn consume(_s: ~str) {}\n+fn touch<A>(_a: &A) {}\n+\n+fn f10() {\n+    let x = Foo { f: ~\"hi\", y: 3 };\n+    consume(x.f); //~ NOTE field of `x` moved here\n+    touch(&x.y); //~ ERROR use of partially moved value: `x`\n+}\n+\n+fn f20() {\n+    let x = ~[~\"hi\"];\n+    consume(x[0]); //~ NOTE element of `x` moved here\n+    touch(&x[0]); //~ ERROR use of partially moved value: `x`\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "db52a2bbe1e501a2f4372d0cad076c7af61d6186", "filename": "src/test/compile-fail/moves-based-on-type-distribute-copy-over-paren.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-distribute-copy-over-paren.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-distribute-copy-over-paren.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-distribute-copy-over-paren.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -0,0 +1,43 @@\n+// Tests that references to move-by-default values trigger moves when\n+// they occur as part of various kinds of expressions.\n+\n+struct Foo<A> { f: A }\n+fn touch<A>(_a: &A) {}\n+\n+fn f00() {\n+    let x = ~\"hi\";\n+    let _y = Foo { f:x }; //~ NOTE `x` moved here\n+    touch(&x); //~ ERROR use of moved value: `x`\n+}\n+\n+fn f05() {\n+    let x = ~\"hi\";\n+    let _y = Foo { f:(((x))) }; //~ NOTE `x` moved here\n+    touch(&x); //~ ERROR use of moved value: `x`\n+}\n+\n+fn f10() {\n+    let x = ~\"hi\";\n+    let _y = Foo { f:copy x };\n+    touch(&x);\n+}\n+\n+fn f20() {\n+    let x = ~\"hi\";\n+    let _y = Foo { f:copy (x) };\n+    touch(&x);\n+}\n+\n+fn f30() {\n+    let x = ~\"hi\";\n+    let _y = Foo { f:copy ((x)) };\n+    touch(&x);\n+}\n+\n+fn f40() {\n+    let x = ~\"hi\";\n+    let _y = Foo { f:(((((copy ((x))))))) };\n+    touch(&x);\n+}\n+\n+fn main() {}"}, {"sha": "07fe8318836dd6de0a2dc8c606a9cd046cc05442", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -0,0 +1,95 @@\n+// Tests that references to move-by-default values trigger moves when\n+// they occur as part of various kinds of expressions.\n+\n+struct Foo<A> { f: A }\n+fn guard(_s: ~str) -> bool {fail}\n+fn touch<A>(_a: &A) {}\n+\n+fn f10() {\n+    let x = ~\"hi\";\n+    let _y = Foo { f:x };\n+    touch(&x); //~ ERROR use of moved value: `x`\n+}\n+\n+fn f20() {\n+    let x = ~\"hi\";\n+    let _y = (x, 3);\n+    touch(&x); //~ ERROR use of moved value: `x`\n+}\n+\n+fn f21() {\n+    let x = ~[1, 2, 3];\n+    let _y = (x[0], 3);\n+    touch(&x);\n+}\n+\n+fn f30(cond: bool) {\n+    let x = ~\"hi\", y = ~\"ho\";\n+    let _y = if cond {\n+        x\n+    } else {\n+        y\n+    };\n+    touch(&x); //~ ERROR use of moved value: `x`\n+    touch(&y); //~ ERROR use of moved value: `y`\n+}\n+\n+fn f40(cond: bool) {\n+    let x = ~\"hi\", y = ~\"ho\";\n+    let _y = match cond {\n+        true => x,\n+        false => y\n+    };\n+    touch(&x); //~ ERROR use of moved value: `x`\n+    touch(&y); //~ ERROR use of moved value: `y`\n+}\n+\n+fn f50(cond: bool) {\n+    let x = ~\"hi\", y = ~\"ho\";\n+    let _y = match cond {\n+        _ if guard(x) => 10,\n+        true => 10,\n+        false => 20,\n+    };\n+    touch(&x); //~ ERROR use of moved value: `x`\n+    touch(&y);\n+}\n+\n+fn f70() {\n+    let x = ~\"hi\";\n+    let _y = [x];\n+    touch(&x); //~ ERROR use of moved value: `x`\n+}\n+\n+fn f80() {\n+    let x = ~\"hi\";\n+    let _y = ~[x];\n+    touch(&x); //~ ERROR use of moved value: `x`\n+}\n+\n+fn f90() {\n+    let x = ~\"hi\";\n+    let _y = @[x];\n+    touch(&x); //~ ERROR use of moved value: `x`\n+}\n+\n+fn f100() {\n+    let x = ~[~\"hi\"];\n+    let _y = x[0];\n+    touch(&x); //~ ERROR use of partially moved value: `x`\n+}\n+\n+fn f110() {\n+    let x = ~[~\"hi\"];\n+    let _y = [x[0], ..1];\n+    touch(&x); //~ ERROR use of partially moved value: `x`\n+}\n+\n+fn f120() {\n+    let x = ~[~\"hi\", ~\"ho\"];\n+    x[0] <-> x[1];\n+    touch(&x[0]);\n+    touch(&x[1]);\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "3c15047a29697a80318d05eea65ed260981363f1", "filename": "src/test/compile-fail/moves-based-on-type-move-out-of-closure-env-issue-1965.rs", "status": "renamed", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn take(-_x: int) {}\n+fn test(_x: ~uint) {}\n \n fn main() {\n-\n-    let x: int = 25;\n-    loop {\n-        take(move x); //~ ERROR use of moved value: `x`\n-        //~^ NOTE move of value occurred here\n+    let i = ~3;\n+    for uint::range(0, 10) |_x| {\n+        test(i); //~ ERROR moving out of captured outer immutable variable in a stack closure\n     }\n }", "previous_filename": "src/test/compile-fail/liveness-move-from-mode.rs"}, {"sha": "8c33e026026947f4cac379f43588a69ac68f2c4f", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -15,7 +15,7 @@ fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let arc_v = arc::ARC(v);\n \n-    do task::spawn() |move arc_v| { //~ NOTE move of value occurred here\n+    do task::spawn() { //~ NOTE `arc_v` moved into closure environment here\n         let v = *arc::get(&arc_v);\n         assert v[3] == 4;\n     };"}, {"sha": "9a16ebda59df8919210cd3b57902fa2d7d660269", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -24,12 +24,12 @@ fn main() {\n             _x: x\n         }\n     }\n-   \n+\n     let x = ~mut Some(foo(Port(@())));\n \n-    do task::spawn |move x| { //~ ERROR not a sendable value\n+    do task::spawn {\n         let mut y = None;\n-        *x <-> y;\n+        *x <-> y; //~ ERROR not a sendable value\n         log(error, y);\n     }\n }"}, {"sha": "7ad41b518a13182bcc1ba867bedde159bc065304", "filename": "src/test/compile-fail/use-after-move-self.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -1,18 +1,18 @@\n struct S {\n-    x: int\n+    x: ~int\n }\n \n impl S {\n     fn foo(self) -> int {\n-        (move self).bar();\n-        return self.x;  //~ ERROR use of moved value\n+        self.bar();\n+        return *self.x;  //~ ERROR use of moved value\n     }\n \n     fn bar(self) {}\n }\n \n fn main() {\n-    let x = S { x: 1 };\n+    let x = S { x: ~1 };\n     io::println(x.foo().to_str());\n }\n "}, {"sha": "d8ade41257ac3e804b5d0039ba8bc5cc8a508319", "filename": "src/test/pretty/cap-clause.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fpretty%2Fcap-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Fpretty%2Fcap-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fcap-clause.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// pp-exact\n-\n-fn main() {\n-    let x = 1;\n-    let y = 2;\n-    let z = 3;\n-    let l1 = fn@(w: int, copy x) -> int { w + x + y };\n-    let l2 = fn@(w: int, copy x, move y) -> int { w + x + y };\n-    let l3 = fn@(w: int, move z) -> int { w + z };\n-\n-    let x = 1;\n-    let y = 2;\n-    let z = 3;\n-    let s1 = fn~(copy x) -> int { x + y };\n-    let s2 = fn~(copy x, move y) -> int { x + y };\n-    let s3 = fn~(move z) -> int { z };\n-}"}, {"sha": "f2a95728237e68c0ad67197c3f5f3092d142c51d", "filename": "src/test/run-fail/unwind-lambda.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-fail%2Funwind-lambda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-lambda.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -18,6 +18,7 @@ fn main() {\n         macerate(copy *tasties);\n     } (carrots, |food| {\n         let mush = food + cheese;\n+        let cheese = copy cheese;\n         let f = fn@() {\n             let chew = mush + cheese;\n             fail ~\"so yummy\""}, {"sha": "2724684dea4c728fe16d0c4b29a943aeeca47d1b", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -43,7 +43,7 @@ fn main() {\n     // Call a method\n     for x.iterate() |y| { assert x[*y] == *y; }\n     // Call a parameterized function\n-    assert length(x) == vec::len(x);\n+    assert length(copy x) == vec::len(x);\n     // Call a parameterized function, with type arguments that require\n     // a borrow\n     assert length::<int, &[int]>(x) == vec::len(x);"}, {"sha": "f13d6eef13643d38b72827067ffd549bf938e0a4", "filename": "src/test/run-pass/borrowck-borrow-from-expr-block.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -13,8 +13,7 @@ fn borrow(x: &int, f: fn(x: &int)) {\n }\n \n fn test1(x: @~int) {\n-    // Right now, at least, this induces a copy of the unique pointer:\n-    do borrow({*x}) |p| {\n+    do borrow(copy *x) |p| {\n         let x_a = ptr::addr_of(&(**x));\n         assert (x_a as uint) != ptr::to_uint(p);\n         assert unsafe{*x_a} == *p;"}, {"sha": "a196593743fea5f8895ed46133cd801acce93467", "filename": "src/test/run-pass/cap-clause-move.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -11,29 +11,21 @@\n fn main() {\n     let x = ~1;\n     let y = ptr::addr_of(&(*x)) as uint;\n-    let lam_copy = fn@(copy x) -> uint { ptr::addr_of(&(*x)) as uint };\n     let lam_move = fn@(move x) -> uint { ptr::addr_of(&(*x)) as uint };\n-    assert lam_copy() != y;\n     assert lam_move() == y;\n \n     let x = ~2;\n     let y = ptr::addr_of(&(*x)) as uint;\n-    let lam_copy: fn@() -> uint = |copy x| ptr::addr_of(&(*x)) as uint;\n     let lam_move: fn@() -> uint = |move x| ptr::addr_of(&(*x)) as uint;\n-    assert lam_copy() != y;\n     assert lam_move() == y;\n \n     let x = ~3;\n     let y = ptr::addr_of(&(*x)) as uint;\n-    let snd_copy = fn~(copy x) -> uint { ptr::addr_of(&(*x)) as uint };\n     let snd_move = fn~(move x) -> uint { ptr::addr_of(&(*x)) as uint };\n-    assert snd_copy() != y;\n     assert snd_move() == y;\n \n     let x = ~4;\n     let y = ptr::addr_of(&(*x)) as uint;\n-    let lam_copy: fn~() -> uint = |copy x| ptr::addr_of(&(*x)) as uint;\n     let lam_move: fn~() -> uint = |move x| ptr::addr_of(&(*x)) as uint;\n-    assert lam_copy() != y;\n     assert lam_move() == y;\n }"}, {"sha": "190177e53cbdd48513b6c396bf8ce8cca8f956e9", "filename": "src/test/run-pass/last-use-corner-cases.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Frun-pass%2Flast-use-corner-cases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b462e0765f02fd7bb0f2613240ae2489a47fee/src%2Ftest%2Frun-pass%2Flast-use-corner-cases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-corner-cases.rs?ref=42b462e0765f02fd7bb0f2613240ae2489a47fee", "patch": "@@ -1,44 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast\n-#[legacy_modes];\n-\n-fn main() {\n-    // Make sure closing over can be a last use\n-    let q = ~10;\n-    let addr = ptr::addr_of(&(*q));\n-    let f = fn@(move q) -> *int { ptr::addr_of(&(*q)) };\n-    assert addr == f();\n-\n-    // But only when it really is the last use\n-    let q = ~20;\n-    let f = fn@(copy q) -> *int { ptr::addr_of(&(*q)) };\n-    assert ptr::addr_of(&(*q)) != f();\n-\n-    // Ensure function arguments and box arguments interact sanely.\n-    fn call_me(x: fn() -> int, y: ~int) { assert x() == *y; }\n-    let q = ~30;\n-    call_me(|| *q, q);\n-\n-    // Check that no false positives are found in loops.\n-    let mut q = ~40, p = 10;\n-    loop {\n-        let i = copy q;\n-        p += *i;\n-        if p > 100 { break; }\n-    }\n-\n-    // Verify that blocks can't interfere with each other.\n-    fn two_blocks(a: fn(), b: fn()) { a(); b(); a(); b(); }\n-    let q = ~50;\n-    two_blocks(|| { let a = copy q; assert *a == 50;},\n-               || { let a = copy q; assert *a == 50;});\n-}"}, {"sha": "c5d7e9783e4def399fa7a8a4ab4016ce2b9ffa9a", "filename": "src/test/run-pass/move-1-unique.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Fmove-1-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Fmove-1-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-1-unique.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -19,8 +19,8 @@ fn test(x: bool, foo: ~Triple) -> int {\n \n fn main() {\n     let x = ~Triple{x: 1, y: 2, z: 3};\n-    assert (test(true, x) == 2);\n-    assert (test(true, x) == 2);\n-    assert (test(true, x) == 2);\n+    assert (test(true, copy x) == 2);\n+    assert (test(true, copy x) == 2);\n+    assert (test(true, copy x) == 2);\n     assert (test(false, x) == 5);\n }"}, {"sha": "5bf5654320a9c30ddf3f7536ce7638403a464f65", "filename": "src/test/run-pass/move-3-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Fmove-3-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Fmove-3-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-3-unique.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -22,7 +22,7 @@ fn test(x: bool, foo: ~Triple) -> int {\n fn main() {\n     let x = ~Triple{x: 1, y: 2, z: 3};\n     for uint::range(0u, 10000u) |_i| {\n-        assert (test(true, x) == 2);\n+        assert (test(true, copy x) == 2);\n     }\n     assert (test(false, x) == 5);\n }"}, {"sha": "6eb2fcdd520e9569981799f6d63e3ecb79c2826e", "filename": "src/test/run-pass/newtype-polymorphic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -16,7 +16,7 @@ fn myvec_elt<X: Copy>(mv: myvec<X>) -> X { return mv[0]; }\n \n fn main() {\n     let mv = myvec(~[1, 2, 3]);\n-    assert (myvec_deref(mv)[1] == 2);\n-    assert (myvec_elt(mv) == 1);\n+    assert (myvec_deref(copy mv)[1] == 2);\n+    assert (myvec_elt(copy mv) == 1);\n     assert (mv[2] == 3);\n }"}, {"sha": "f49a095c334127b9310f38f1ff3e3a82619f7d27", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -20,7 +20,7 @@ fn main() {\n         log(debug, i);\n         let (p, ch) = pipes::stream();\n         po.add(move p);\n-        task::spawn(|move ch, copy i| child(i, ch) );\n+        task::spawn({let i = i; |move ch| child(i, ch)});\n         i = i - 1;\n     }\n "}, {"sha": "ebbac2d1a0aa1a3750fa7ca10a3c557da06a8b0a", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -43,11 +43,12 @@ fn test00() {\n     let mut results = ~[];\n     while i < number_of_tasks {\n         let ch = po.chan();\n-        do task::task().future_result(|+r| {\n+        task::task().future_result(|+r| {\n             results.push(move r);\n-        }).spawn |move ch, copy i| {\n-            test00_start(ch, i, number_of_messages)\n-        }\n+        }).spawn({\n+            let i = i;\n+            |move ch| test00_start(ch, i, number_of_messages)\n+        });\n         i = i + 1;\n     }\n "}, {"sha": "e68d6dd748307195e8a5ac61fa0f927bf102e4f8", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -16,22 +16,11 @@ fn main() {\n     let x = ~1;\n     let x_in_parent = ptr::addr_of(&(*x)) as uint;\n \n-    let y = ~2;\n-    let y_in_parent = ptr::addr_of(&(*y)) as uint;\n-\n-    task::spawn(fn~(copy y, move x) {\n+    task::spawn(fn~() {\n         let x_in_child = ptr::addr_of(&(*x)) as uint;\n         ch.send(x_in_child);\n-\n-        let y_in_child = ptr::addr_of(&(*y)) as uint;\n-        ch.send(y_in_child);\n     });\n-    // Ensure last-use analysis doesn't move y to child.\n-    let _q = y;\n \n     let x_in_child = p.recv();\n     assert x_in_parent == x_in_child;\n-\n-    let y_in_child = p.recv();\n-    assert y_in_parent != y_in_child;\n }"}, {"sha": "02dcebb113246cdca72148e09141c31f25b2824e", "filename": "src/test/run-pass/threads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0682ad0eb9a6b268498a81b2e16a40544e44f0fa/src%2Ftest%2Frun-pass%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthreads.rs?ref=0682ad0eb9a6b268498a81b2e16a40544e44f0fa", "patch": "@@ -14,7 +14,7 @@ extern mod std;\n \n fn main() {\n     let mut i = 10;\n-    while i > 0 { task::spawn(|copy i| child(i) ); i = i - 1; }\n+    while i > 0 { task::spawn({let i = i; || child(i)}); i = i - 1; }\n     debug!(\"main thread exiting\");\n }\n "}]}