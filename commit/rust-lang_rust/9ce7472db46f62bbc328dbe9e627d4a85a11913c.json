{"sha": "9ce7472db46f62bbc328dbe9e627d4a85a11913c", "node_id": "C_kwDOAAsO6NoAKDljZTc0NzJkYjQ2ZjYyYmJjMzI4ZGJlOWU2MjdkNGE4NWExMTkxM2M", "commit": {"author": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2023-02-21T14:51:19Z"}, "committer": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2023-02-28T07:57:17Z"}, "message": "rename unmatched_braces to unmatched_delims", "tree": {"sha": "b3f9cce93413d7e62632c338f0749ee32856a996", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3f9cce93413d7e62632c338f0749ee32856a996"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ce7472db46f62bbc328dbe9e627d4a85a11913c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ce7472db46f62bbc328dbe9e627d4a85a11913c", "html_url": "https://github.com/rust-lang/rust/commit/9ce7472db46f62bbc328dbe9e627d4a85a11913c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ce7472db46f62bbc328dbe9e627d4a85a11913c/comments", "author": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65ad5f8de72c6994b6d2059bf5622af48de3afe4", "url": "https://api.github.com/repos/rust-lang/rust/commits/65ad5f8de72c6994b6d2059bf5622af48de3afe4", "html_url": "https://github.com/rust-lang/rust/commit/65ad5f8de72c6994b6d2059bf5622af48de3afe4"}], "stats": {"total": 53, "additions": 27, "deletions": 26}, "files": [{"sha": "27f4428d306cd47604dd8a30e35e7cf3022dd73a", "filename": "compiler/rustc_parse/src/lexer/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ce7472db46f62bbc328dbe9e627d4a85a11913c/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ce7472db46f62bbc328dbe9e627d4a85a11913c/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fdiagnostics.rs?ref=9ce7472db46f62bbc328dbe9e627d4a85a11913c", "patch": "@@ -1,4 +1,4 @@\n-use super::UnmatchedBrace;\n+use super::UnmatchedDelim;\n use rustc_ast::token::Delimiter;\n use rustc_errors::Diagnostic;\n use rustc_span::source_map::SourceMap;\n@@ -8,7 +8,7 @@ use rustc_span::Span;\n pub struct TokenTreeDiagInfo {\n     /// Stack of open delimiters and their spans. Used for error message.\n     pub open_braces: Vec<(Delimiter, Span)>,\n-    pub unmatched_braces: Vec<UnmatchedBrace>,\n+    pub unmatched_delims: Vec<UnmatchedDelim>,\n \n     /// Used only for error recovery when arriving to EOF with mismatched braces.\n     pub last_unclosed_found_span: Option<Span>,\n@@ -32,10 +32,10 @@ pub fn same_identation_level(sm: &SourceMap, open_sp: Span, close_sp: Span) -> b\n // it's more friendly compared to report `unmatched error` in later phase\n pub fn report_missing_open_delim(\n     err: &mut Diagnostic,\n-    unmatched_braces: &[UnmatchedBrace],\n+    unmatched_delims: &[UnmatchedDelim],\n ) -> bool {\n     let mut reported_missing_open = false;\n-    for unmatch_brace in unmatched_braces.iter() {\n+    for unmatch_brace in unmatched_delims.iter() {\n         if let Some(delim) = unmatch_brace.found_delim\n             && matches!(delim, Delimiter::Parenthesis | Delimiter::Bracket)\n         {\n@@ -60,7 +60,7 @@ pub fn report_suspicious_mismatch_block(\n     sm: &SourceMap,\n     delim: Delimiter,\n ) {\n-    if report_missing_open_delim(err, &diag_info.unmatched_braces) {\n+    if report_missing_open_delim(err, &diag_info.unmatched_delims) {\n         return;\n     }\n "}, {"sha": "db1bea199231549c8a61893afb1ec7ffae825860", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ce7472db46f62bbc328dbe9e627d4a85a11913c/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ce7472db46f62bbc328dbe9e627d4a85a11913c/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=9ce7472db46f62bbc328dbe9e627d4a85a11913c", "patch": "@@ -31,7 +31,7 @@ use unescape_error_reporting::{emit_unescape_error, escaped_char};\n rustc_data_structures::static_assert_size!(rustc_lexer::Token, 12);\n \n #[derive(Clone, Debug)]\n-pub struct UnmatchedBrace {\n+pub struct UnmatchedDelim {\n     pub expected_delim: Delimiter,\n     pub found_delim: Option<Delimiter>,\n     pub found_span: Span,\n@@ -44,7 +44,7 @@ pub(crate) fn parse_token_trees<'a>(\n     mut src: &'a str,\n     mut start_pos: BytePos,\n     override_span: Option<Span>,\n-) -> (PResult<'a, TokenStream>, Vec<UnmatchedBrace>) {\n+) -> (PResult<'a, TokenStream>, Vec<UnmatchedDelim>) {\n     // Skip `#!`, if present.\n     if let Some(shebang_len) = rustc_lexer::strip_shebang(src) {\n         src = &src[shebang_len..];"}, {"sha": "5abd62bc2a448c689ab6e46219770d1ef351508d", "filename": "compiler/rustc_parse/src/lexer/tokentrees.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9ce7472db46f62bbc328dbe9e627d4a85a11913c/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ce7472db46f62bbc328dbe9e627d4a85a11913c/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs?ref=9ce7472db46f62bbc328dbe9e627d4a85a11913c", "patch": "@@ -1,7 +1,7 @@\n use super::diagnostics::report_suspicious_mismatch_block;\n use super::diagnostics::same_identation_level;\n use super::diagnostics::TokenTreeDiagInfo;\n-use super::{StringReader, UnmatchedBrace};\n+use super::{StringReader, UnmatchedDelim};\n use rustc_ast::token::{self, Delimiter, Token};\n use rustc_ast::tokenstream::{DelimSpan, Spacing, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust::token_to_string;\n@@ -18,14 +18,14 @@ pub(super) struct TokenTreesReader<'a> {\n impl<'a> TokenTreesReader<'a> {\n     pub(super) fn parse_all_token_trees(\n         string_reader: StringReader<'a>,\n-    ) -> (PResult<'a, TokenStream>, Vec<UnmatchedBrace>) {\n+    ) -> (PResult<'a, TokenStream>, Vec<UnmatchedDelim>) {\n         let mut tt_reader = TokenTreesReader {\n             string_reader,\n             token: Token::dummy(),\n             diag_info: TokenTreeDiagInfo::default(),\n         };\n         let res = tt_reader.parse_token_trees(/* is_delimited */ false);\n-        (res, tt_reader.diag_info.unmatched_braces)\n+        (res, tt_reader.diag_info.unmatched_delims)\n     }\n \n     // Parse a stream of tokens into a list of `TokenTree`s.\n@@ -79,7 +79,7 @@ impl<'a> TokenTreesReader<'a> {\n         let mut err = self.string_reader.sess.span_diagnostic.struct_span_err(self.token.span, msg);\n         for &(_, sp) in &self.diag_info.open_braces {\n             err.span_label(sp, \"unclosed delimiter\");\n-            self.diag_info.unmatched_braces.push(UnmatchedBrace {\n+            self.diag_info.unmatched_delims.push(UnmatchedDelim {\n                 expected_delim: Delimiter::Brace,\n                 found_delim: None,\n                 found_span: self.token.span,\n@@ -161,7 +161,8 @@ impl<'a> TokenTreesReader<'a> {\n                         }\n                     }\n                     let (tok, _) = self.diag_info.open_braces.pop().unwrap();\n-                    self.diag_info.unmatched_braces.push(UnmatchedBrace {\n+                    debug!(\"anan now: open {:#?} close {:#?}\", open_delim, close_delim);\n+                    self.diag_info.unmatched_delims.push(UnmatchedDelim {\n                         expected_delim: tok,\n                         found_delim: Some(close_delim),\n                         found_span: self.token.span,"}, {"sha": "b6e54b53e2614b9a67670dc709ca078ee878fb71", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ce7472db46f62bbc328dbe9e627d4a85a11913c/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ce7472db46f62bbc328dbe9e627d4a85a11913c/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=9ce7472db46f62bbc328dbe9e627d4a85a11913c", "patch": "@@ -182,7 +182,7 @@ pub fn source_file_to_stream(\n     sess: &ParseSess,\n     source_file: Lrc<SourceFile>,\n     override_span: Option<Span>,\n-) -> (TokenStream, Vec<lexer::UnmatchedBrace>) {\n+) -> (TokenStream, Vec<lexer::UnmatchedDelim>) {\n     panictry_buffer!(&sess.span_diagnostic, maybe_file_to_stream(sess, source_file, override_span))\n }\n \n@@ -192,27 +192,27 @@ pub fn maybe_file_to_stream(\n     sess: &ParseSess,\n     source_file: Lrc<SourceFile>,\n     override_span: Option<Span>,\n-) -> Result<(TokenStream, Vec<lexer::UnmatchedBrace>), Vec<Diagnostic>> {\n+) -> Result<(TokenStream, Vec<lexer::UnmatchedDelim>), Vec<Diagnostic>> {\n     let src = source_file.src.as_ref().unwrap_or_else(|| {\n         sess.span_diagnostic.bug(&format!(\n             \"cannot lex `source_file` without source: {}\",\n             sess.source_map().filename_for_diagnostics(&source_file.name)\n         ));\n     });\n \n-    let (token_trees, unmatched_braces) =\n+    let (token_trees, unmatched_delims) =\n         lexer::parse_token_trees(sess, src.as_str(), source_file.start_pos, override_span);\n \n     match token_trees {\n-        Ok(stream) if unmatched_braces.is_empty() => Ok((stream, unmatched_braces)),\n+        Ok(stream) if unmatched_delims.is_empty() => Ok((stream, unmatched_delims)),\n         _ => {\n             // Return error if there are unmatched delimiters or unclosng delimiters.\n             // We emit delimiter mismatch errors first, then emit the unclosing delimiter mismatch\n             // because the delimiter mismatch is more likely to be the root cause of the\n \n             let mut buffer = Vec::with_capacity(1);\n             // Not using `emit_unclosed_delims` to use `db.buffer`\n-            for unmatched in unmatched_braces {\n+            for unmatched in unmatched_delims {\n                 if let Some(err) = make_unclosed_delims_error(unmatched, &sess) {\n                     err.buffer(&mut buffer);\n                 }"}, {"sha": "d0cf42b931b8c12a14a73d43a2020ec278c186ff", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ce7472db46f62bbc328dbe9e627d4a85a11913c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ce7472db46f62bbc328dbe9e627d4a85a11913c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=9ce7472db46f62bbc328dbe9e627d4a85a11913c", "patch": "@@ -19,9 +19,9 @@ use crate::errors::{\n };\n \n use crate::fluent_generated as fluent;\n-use crate::lexer::UnmatchedBrace;\n-use crate::parser;\n use rustc_ast as ast;\n+use crate::parser;\n+use crate::lexer::UnmatchedDelim;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Lit, LitKind, TokenKind};\n use rustc_ast::util::parser::AssocOp;\n@@ -222,7 +222,7 @@ impl MultiSugg {\n /// is dropped.\n pub struct SnapshotParser<'a> {\n     parser: Parser<'a>,\n-    unclosed_delims: Vec<UnmatchedBrace>,\n+    unclosed_delims: Vec<UnmatchedDelim>,\n }\n \n impl<'a> Deref for SnapshotParser<'a> {\n@@ -264,7 +264,7 @@ impl<'a> Parser<'a> {\n         self.unclosed_delims.extend(snapshot.unclosed_delims);\n     }\n \n-    pub fn unclosed_delims(&self) -> &[UnmatchedBrace] {\n+    pub fn unclosed_delims(&self) -> &[UnmatchedDelim] {\n         &self.unclosed_delims\n     }\n "}, {"sha": "b1b79fe4e054b7703733899d58b3419bc02e9a64", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ce7472db46f62bbc328dbe9e627d4a85a11913c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ce7472db46f62bbc328dbe9e627d4a85a11913c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=9ce7472db46f62bbc328dbe9e627d4a85a11913c", "patch": "@@ -10,7 +10,7 @@ mod path;\n mod stmt;\n mod ty;\n \n-use crate::lexer::UnmatchedBrace;\n+use crate::lexer::UnmatchedDelim;\n pub use attr_wrapper::AttrWrapper;\n pub use diagnostics::AttemptLocalParseRecovery;\n pub(crate) use item::FnParseMode;\n@@ -149,7 +149,7 @@ pub struct Parser<'a> {\n     /// A list of all unclosed delimiters found by the lexer. If an entry is used for error recovery\n     /// it gets removed from here. Every entry left at the end gets emitted as an independent\n     /// error.\n-    pub(super) unclosed_delims: Vec<UnmatchedBrace>,\n+    pub(super) unclosed_delims: Vec<UnmatchedDelim>,\n     last_unexpected_token_span: Option<Span>,\n     /// Span pointing at the `:` for the last type ascription the parser has seen, and whether it\n     /// looked like it could have been a mistyped path or literal `Option:Some(42)`).\n@@ -1521,11 +1521,11 @@ impl<'a> Parser<'a> {\n }\n \n pub(crate) fn make_unclosed_delims_error(\n-    unmatched: UnmatchedBrace,\n+    unmatched: UnmatchedDelim,\n     sess: &ParseSess,\n ) -> Option<DiagnosticBuilder<'_, ErrorGuaranteed>> {\n     // `None` here means an `Eof` was found. We already emit those errors elsewhere, we add them to\n-    // `unmatched_braces` only for error recovery in the `Parser`.\n+    // `unmatched_delims` only for error recovery in the `Parser`.\n     let found_delim = unmatched.found_delim?;\n     let mut spans = vec![unmatched.found_span];\n     if let Some(sp) = unmatched.unclosed_span {\n@@ -1542,7 +1542,7 @@ pub(crate) fn make_unclosed_delims_error(\n     Some(err)\n }\n \n-pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, sess: &ParseSess) {\n+pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedDelim>, sess: &ParseSess) {\n     *sess.reached_eof.borrow_mut() |=\n         unclosed_delims.iter().any(|unmatched_delim| unmatched_delim.found_delim.is_none());\n     for unmatched in unclosed_delims.drain(..) {"}]}