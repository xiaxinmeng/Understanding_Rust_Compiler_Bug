{"sha": "c8cbd4fc784e5d432c02b0dc14a592f112dab59f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4Y2JkNGZjNzg0ZTVkNDMyYzAyYjBkYzE0YTU5MmYxMTJkYWI1OWY=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-06-21T19:39:01Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-06-22T17:18:19Z"}, "message": "Merge `BitSetOperator` and `InitialFlow` into one trait.\n\nSince the value of `InitialFlow` defines the semantics of the `join`\noperation, there's no reason to have seperate traits for each. We can\nadd a default impl of `join` which branches based on `BOTTOM_VALUE`.\nThis should get optimized away.", "tree": {"sha": "5300621f90fc24eb556c5d4b8d5b79401cf61012", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5300621f90fc24eb556c5d4b8d5b79401cf61012"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8cbd4fc784e5d432c02b0dc14a592f112dab59f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8cbd4fc784e5d432c02b0dc14a592f112dab59f", "html_url": "https://github.com/rust-lang/rust/commit/c8cbd4fc784e5d432c02b0dc14a592f112dab59f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8cbd4fc784e5d432c02b0dc14a592f112dab59f/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c054186ec70ae2393330886cb8dc506aab21750c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c054186ec70ae2393330886cb8dc506aab21750c", "html_url": "https://github.com/rust-lang/rust/commit/c054186ec70ae2393330886cb8dc506aab21750c"}], "stats": {"total": 166, "additions": 51, "deletions": 115}, "files": [{"sha": "f4a60b4d2c192d32d2e60e0a54a06e4e5feabbcc", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8cbd4fc784e5d432c02b0dc14a592f112dab59f/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cbd4fc784e5d432c02b0dc14a592f112dab59f/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=c8cbd4fc784e5d432c02b0dc14a592f112dab59f", "patch": "@@ -273,11 +273,6 @@ impl<'a, T: Idx> Iterator for BitIter<'a, T> {\n     }\n }\n \n-pub trait BitSetOperator {\n-    /// Combine one bitset into another.\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool;\n-}\n-\n #[inline]\n fn bitwise<Op>(out_vec: &mut [Word], in_vec: &[Word], op: Op) -> bool\n     where Op: Fn(Word, Word) -> Word"}, {"sha": "0f7f37f2db8b47b10de129eae036b792750fabd0", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c8cbd4fc784e5d432c02b0dc14a592f112dab59f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cbd4fc784e5d432c02b0dc14a592f112dab59f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=c8cbd4fc784e5d432c02b0dc14a592f112dab59f", "patch": "@@ -83,18 +83,9 @@ impl<'a, 'tcx> BitDenotation<'tcx> for HaveBeenBorrowedLocals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitSetOperator for HaveBeenBorrowedLocals<'a, 'tcx> {\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n-    }\n-}\n-\n-impl<'a, 'tcx> InitialFlow for HaveBeenBorrowedLocals<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = unborrowed\n-    }\n+impl<'a, 'tcx> BottomValue for HaveBeenBorrowedLocals<'a, 'tcx> {\n+    // bottom = unborrowed\n+    const BOTTOM_VALUE: bool = false;\n }\n \n struct BorrowedLocalsVisitor<'gk> {"}, {"sha": "53d00d44e3f55e6000e47ba4cdd446f87da9b327", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c8cbd4fc784e5d432c02b0dc14a592f112dab59f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cbd4fc784e5d432c02b0dc14a592f112dab59f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=c8cbd4fc784e5d432c02b0dc14a592f112dab59f", "patch": "@@ -5,11 +5,11 @@ use rustc::mir::{self, Location, Place, PlaceBase, Body};\n use rustc::ty::TyCtxt;\n use rustc::ty::RegionVid;\n \n-use rustc_data_structures::bit_set::{BitSet, BitSetOperator};\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n-use crate::dataflow::{BitDenotation, InitialFlow, GenKillSet};\n+use crate::dataflow::{BitDenotation, BottomValue, GenKillSet};\n use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n use crate::borrow_check::nll::ToRegionVid;\n use crate::borrow_check::places_conflict;\n@@ -331,16 +331,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitSetOperator for Borrows<'a, 'tcx> {\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n-    }\n-}\n-\n-impl<'a, 'tcx> InitialFlow for Borrows<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = nothing is reserved or activated yet\n-    }\n+impl<'a, 'tcx> BottomValue for Borrows<'a, 'tcx> {\n+    /// bottom = nothing is reserved or activated yet;\n+    const BOTTOM_VALUE: bool = false;\n }"}, {"sha": "065cfe8a4e82340d1ef42a41af418fff35a90db0", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 14, "deletions": 60, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c8cbd4fc784e5d432c02b0dc14a592f112dab59f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cbd4fc784e5d432c02b0dc14a592f112dab59f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=c8cbd4fc784e5d432c02b0dc14a592f112dab59f", "patch": "@@ -4,15 +4,15 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::{self, Body, Location};\n-use rustc_data_structures::bit_set::{BitSet, BitSetOperator};\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::Idx;\n \n use super::MoveDataParamEnv;\n \n use crate::util::elaborate_drops::DropFlagState;\n \n use super::move_paths::{HasMoveData, MoveData, MovePathIndex, InitIndex, InitKind};\n-use super::{BitDenotation, InitialFlow, GenKillSet};\n+use super::{BitDenotation, BottomValue, GenKillSet};\n \n use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;\n@@ -505,68 +505,22 @@ impl<'a, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitSetOperator for MaybeInitializedPlaces<'a, 'tcx> {\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n-    }\n-}\n-\n-impl<'a, 'tcx> BitSetOperator for MaybeUninitializedPlaces<'a, 'tcx> {\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n-    }\n-}\n-\n-impl<'a, 'tcx> BitSetOperator for DefinitelyInitializedPlaces<'a, 'tcx> {\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        inout_set.intersect(in_set) // \"definitely\" means we intersect effects of both preds\n-    }\n-}\n-\n-impl<'a, 'tcx> BitSetOperator for EverInitializedPlaces<'a, 'tcx> {\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        inout_set.union(in_set) // inits from both preds are in scope\n-    }\n-}\n-\n-// The way that dataflow fixed point iteration works, you want to\n-// start at bottom and work your way to a fixed point. Control-flow\n-// merges will apply the `join` operator to each block entry's current\n-// state (which starts at that bottom value).\n-//\n-// This means, for propagation across the graph, that you either want\n-// to start at all-zeroes and then use Union as your merge when\n-// propagating, or you start at all-ones and then use Intersect as\n-// your merge when propagating.\n-\n-impl<'a, 'tcx> InitialFlow for MaybeInitializedPlaces<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = uninitialized\n-    }\n+impl<'a, 'tcx> BottomValue for MaybeInitializedPlaces<'a, 'tcx> {\n+    /// bottom = uninitialized\n+    const BOTTOM_VALUE: bool = false;\n }\n \n-impl<'a, 'tcx> InitialFlow for MaybeUninitializedPlaces<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = initialized (start_block_effect counters this at outset)\n-    }\n+impl<'a, 'tcx> BottomValue for MaybeUninitializedPlaces<'a, 'tcx> {\n+    /// bottom = initialized (start_block_effect counters this at outset)\n+    const BOTTOM_VALUE: bool = false;\n }\n \n-impl<'a, 'tcx> InitialFlow for DefinitelyInitializedPlaces<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        true // bottom = initialized (start_block_effect counters this at outset)\n-    }\n+impl<'a, 'tcx> BottomValue for DefinitelyInitializedPlaces<'a, 'tcx> {\n+    /// bottom = initialized (start_block_effect counters this at outset)\n+    const BOTTOM_VALUE: bool = true;\n }\n \n-impl<'a, 'tcx> InitialFlow for EverInitializedPlaces<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = no initialized variables by default\n-    }\n+impl<'a, 'tcx> BottomValue for EverInitializedPlaces<'a, 'tcx> {\n+    /// bottom = no initialized variables by default\n+    const BOTTOM_VALUE: bool = false;\n }"}, {"sha": "d2003993d45063f1f014b347412ec623dcddb984", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c8cbd4fc784e5d432c02b0dc14a592f112dab59f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cbd4fc784e5d432c02b0dc14a592f112dab59f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=c8cbd4fc784e5d432c02b0dc14a592f112dab59f", "patch": "@@ -59,16 +59,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitSetOperator for MaybeStorageLive<'a, 'tcx> {\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        inout_set.union(in_set) // \"maybe\" means we union effects of both preds\n-    }\n-}\n-\n-impl<'a, 'tcx> InitialFlow for MaybeStorageLive<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = dead\n-    }\n+impl<'a, 'tcx> BottomValue for MaybeStorageLive<'a, 'tcx> {\n+    /// bottom = dead\n+    const BOTTOM_VALUE: bool = false;\n }"}, {"sha": "444f73d73565e532cba0111b12d0b22000b265af", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c8cbd4fc784e5d432c02b0dc14a592f112dab59f/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8cbd4fc784e5d432c02b0dc14a592f112dab59f/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=c8cbd4fc784e5d432c02b0dc14a592f112dab59f", "patch": "@@ -1,7 +1,7 @@\n use syntax::ast::{self, MetaItem};\n use syntax::symbol::{Symbol, sym};\n \n-use rustc_data_structures::bit_set::{BitSet, BitSetOperator, HybridBitSet};\n+use rustc_data_structures::bit_set::{BitSet, HybridBitSet};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::work_queue::WorkQueue;\n \n@@ -552,25 +552,39 @@ impl<E:Idx> AllSets<E> {\n }\n \n /// Parameterization for the precise form of data flow that is used.\n-/// `InitialFlow` handles initializing the bitvectors before any\n-/// code is inspected by the analysis. Analyses that need more nuanced\n-/// initialization (e.g., they need to consult the results of some other\n-/// dataflow analysis to set up the initial bitvectors) should not\n-/// implement this.\n-pub trait InitialFlow {\n-    /// Specifies the initial value for each bit in the `on_entry` set\n-    fn bottom_value() -> bool;\n+///\n+/// `BottomValue` determines whether the initial entry set for each basic block is empty or full.\n+/// This also determines the semantics of the lattice `join` operator used to merge dataflow\n+/// results, since dataflow works by starting at the bottom and moving monotonically to a fixed\n+/// point.\n+///\n+/// This means, for propagation across the graph, that you either want to start at all-zeroes and\n+/// then use Union as your merge when propagating, or you start at all-ones and then use Intersect\n+/// as your merge when propagating.\n+pub trait BottomValue {\n+    /// Specifies the initial value for each bit in the entry set for each basic block.\n+    const BOTTOM_VALUE: bool;\n+\n+    /// Merges `in_set` into `inout_set`, returning `true` if `inout_set` changed.\n+    #[inline]\n+    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n+        if Self::BOTTOM_VALUE == false {\n+            inout_set.union(in_set)\n+        } else {\n+            inout_set.intersect(in_set)\n+        }\n+    }\n }\n \n /// A specific flavor of dataflow analysis.\n ///\n /// To run a dataflow analysis, one sets up an initial state for the\n /// `START_BLOCK` via `start_block_effect` and a transfer function (`trans`)\n /// for each block individually. The entry set for all other basic blocks is\n-/// initialized to `InitialFlow::bottom_value`. The dataflow analysis then\n+/// initialized to `Self::BOTTOM_VALUE`. The dataflow analysis then\n /// iteratively modifies the various entry sets (but leaves the the transfer\n /// function unchanged).\n-pub trait BitDenotation<'tcx>: BitSetOperator + InitialFlow {\n+pub trait BitDenotation<'tcx>: BottomValue {\n     /// Specifies what index type is used to access the bitvector.\n     type Idx: Idx;\n \n@@ -688,7 +702,7 @@ impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation<'tcx>\n         let bits_per_block = denotation.bits_per_block();\n         let num_blocks = body.basic_blocks().len();\n \n-        let on_entry = if D::bottom_value() {\n+        let on_entry = if D::BOTTOM_VALUE == true {\n             vec![BitSet::new_filled(bits_per_block); num_blocks]\n         } else {\n             vec![BitSet::new_empty(bits_per_block); num_blocks]"}]}