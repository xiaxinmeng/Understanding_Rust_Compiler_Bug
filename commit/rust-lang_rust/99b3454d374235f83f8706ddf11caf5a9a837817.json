{"sha": "99b3454d374235f83f8706ddf11caf5a9a837817", "node_id": "C_kwDOAAsO6NoAKDk5YjM0NTRkMzc0MjM1ZjgzZjg3MDZkZGYxMWNhZjVhOWE4Mzc4MTc", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-30T03:41:53Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-05T18:05:25Z"}, "message": "Enforce rust-check ABI in signatures, calls", "tree": {"sha": "09b10432b398845ff57aa308967eb79c1e833493", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09b10432b398845ff57aa308967eb79c1e833493"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99b3454d374235f83f8706ddf11caf5a9a837817", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99b3454d374235f83f8706ddf11caf5a9a837817", "html_url": "https://github.com/rust-lang/rust/commit/99b3454d374235f83f8706ddf11caf5a9a837817", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99b3454d374235f83f8706ddf11caf5a9a837817/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2786acce98a87a22a01fdc0ab82ca6f90d62d44e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2786acce98a87a22a01fdc0ab82ca6f90d62d44e", "html_url": "https://github.com/rust-lang/rust/commit/2786acce98a87a22a01fdc0ab82ca6f90d62d44e"}], "stats": {"total": 83, "additions": 44, "deletions": 39}, "files": [{"sha": "3ec8f9f5d14ea1970b99ef7c99e9248b804d097c", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/99b3454d374235f83f8706ddf11caf5a9a837817/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b3454d374235f83f8706ddf11caf5a9a837817/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=99b3454d374235f83f8706ddf11caf5a9a837817", "patch": "@@ -21,6 +21,7 @@ use rustc_middle::ty::{GenericArgKind, InternalSubsts};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::autoderef::Autoderef;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n@@ -1542,6 +1543,27 @@ fn check_fn_or_method<'tcx>(\n         sig.output(),\n         hir_decl.output.span(),\n     );\n+\n+    if sig.abi == Abi::RustCall {\n+        let span = tcx.def_span(def_id);\n+        let has_implicit_self = hir_decl.implicit_self != hir::ImplicitSelfKind::None;\n+        let mut inputs = sig.inputs().iter().skip(if has_implicit_self { 1 } else { 0 });\n+        // Check that the argument is a tuple\n+        if let Some(ty) = inputs.next() {\n+            wfcx.register_bound(\n+                ObligationCause::new(span, wfcx.body_id, ObligationCauseCode::RustCall),\n+                wfcx.param_env,\n+                *ty,\n+                tcx.require_lang_item(hir::LangItem::Tuple, Some(span)),\n+            );\n+        } else {\n+            tcx.sess.span_err(span, \"functions with the \\\"rust-call\\\" ABI must take a single non-self argument that is a tuple\");\n+        }\n+        // No more inputs other than the `self` type and the tuple type\n+        if inputs.next().is_some() {\n+            tcx.sess.span_err(span, \"functions with the \\\"rust-call\\\" ABI must take a single non-self argument that is a tuple\");\n+        }\n+    }\n }\n \n /// Basically `check_associated_type_bounds`, but separated for now and should be"}, {"sha": "eff65980f6436b2f725b7b86a0469366ec5ed9ea", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99b3454d374235f83f8706ddf11caf5a9a837817/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b3454d374235f83f8706ddf11caf5a9a837817/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=99b3454d374235f83f8706ddf11caf5a9a837817", "patch": "@@ -471,6 +471,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             def_id,\n         );\n \n+        if fn_sig.abi == abi::Abi::RustCall {\n+            let sp = arg_exprs.last().map_or(call_expr.span, |expr| expr.span);\n+            if let Some(ty) = fn_sig.inputs().last().copied() {\n+                self.register_bound(\n+                    ty,\n+                    self.tcx.require_lang_item(hir::LangItem::Tuple, Some(sp)),\n+                    traits::ObligationCause::new(sp, self.body_id, traits::RustCall),\n+                );\n+            } else {\n+                self.tcx.sess.span_err(\n+                        sp,\n+                        \"functions with the \\\"rust-call\\\" ABI must take a single non-self tuple argument\",\n+                    );\n+            }\n+        }\n+\n         fn_sig.output()\n     }\n "}, {"sha": "37af6e79c3ef5ef44a3ef78c02db79cb17e66788", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/99b3454d374235f83f8706ddf11caf5a9a837817/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b3454d374235f83f8706ddf11caf5a9a837817/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=99b3454d374235f83f8706ddf11caf5a9a837817", "patch": "@@ -6,13 +6,11 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{ImplicitSelfKind, ItemKind, Node};\n use rustc_hir_analysis::check::fn_maybe_err;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::RegionVariableOrigin;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::LocalDefId;\n-use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use std::cell::RefCell;\n \n@@ -56,41 +54,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     fn_maybe_err(tcx, span, fn_sig.abi);\n \n-    if fn_sig.abi == Abi::RustCall {\n-        let expected_args = if let ImplicitSelfKind::None = decl.implicit_self { 1 } else { 2 };\n-\n-        let err = || {\n-            let item = match tcx.hir().get(fn_id) {\n-                Node::Item(hir::Item { kind: ItemKind::Fn(header, ..), .. }) => Some(header),\n-                Node::ImplItem(hir::ImplItem {\n-                    kind: hir::ImplItemKind::Fn(header, ..), ..\n-                }) => Some(header),\n-                Node::TraitItem(hir::TraitItem {\n-                    kind: hir::TraitItemKind::Fn(header, ..),\n-                    ..\n-                }) => Some(header),\n-                // Closures are RustCall, but they tuple their arguments, so shouldn't be checked\n-                Node::Expr(hir::Expr { kind: hir::ExprKind::Closure { .. }, .. }) => None,\n-                node => bug!(\"Item being checked wasn't a function/closure: {:?}\", node),\n-            };\n-\n-            if let Some(header) = item {\n-                tcx.sess.span_err(header.span, \"functions with the \\\"rust-call\\\" ABI must take a single non-self argument that is a tuple\");\n-            }\n-        };\n-\n-        if fn_sig.inputs().len() != expected_args {\n-            err()\n-        } else {\n-            // FIXME(CraftSpider) Add a check on parameter expansion, so we don't just make the ICE happen later on\n-            //   This will probably require wide-scale changes to support a TupleKind obligation\n-            //   We can't resolve this without knowing the type of the param\n-            if !matches!(fn_sig.inputs()[expected_args - 1].kind(), ty::Tuple(_) | ty::Param(_)) {\n-                err()\n-            }\n-        }\n-    }\n-\n     if body.generator_kind.is_some() && can_be_generator.is_some() {\n         let yield_ty = fcx\n             .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });"}, {"sha": "2239a33a8e9f015adac44b5b27aac32ded0e7aa5", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99b3454d374235f83f8706ddf11caf5a9a837817/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b3454d374235f83f8706ddf11caf5a9a837817/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=99b3454d374235f83f8706ddf11caf5a9a837817", "patch": "@@ -136,6 +136,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             tuple_arguments,\n             Some(method.def_id),\n         );\n+\n         method.sig.output()\n     }\n "}, {"sha": "624443d9594c99b2af4c5c6debeba1ed6e627424", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b3454d374235f83f8706ddf11caf5a9a837817/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b3454d374235f83f8706ddf11caf5a9a837817/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=99b3454d374235f83f8706ddf11caf5a9a837817", "patch": "@@ -458,7 +458,7 @@ fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, qpath: &hir::QPath<'\n /// # fn f(x: (isize, isize)) {}\n /// f((1, 2));\n /// ```\n-#[derive(Clone, Eq, PartialEq)]\n+#[derive(Copy, Clone, Eq, PartialEq)]\n enum TupleArgumentsFlag {\n     DontTupleArguments,\n     TupleArguments,"}, {"sha": "a29f0722ff705056ee9535f5ad3e0a6a158b4246", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b3454d374235f83f8706ddf11caf5a9a837817/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b3454d374235f83f8706ddf11caf5a9a837817/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=99b3454d374235f83f8706ddf11caf5a9a837817", "patch": "@@ -438,6 +438,8 @@ pub enum ObligationCauseCode<'tcx> {\n     },\n \n     AscribeUserTypeProvePredicate(Span),\n+\n+    RustCall,\n }\n \n /// The 'location' at which we try to perform HIR-based wf checking."}, {"sha": "0f4aa87b43f5e7d0e499f22b0519517eb3ab8115", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99b3454d374235f83f8706ddf11caf5a9a837817/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b3454d374235f83f8706ddf11caf5a9a837817/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=99b3454d374235f83f8706ddf11caf5a9a837817", "patch": "@@ -2407,7 +2407,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             | ObligationCauseCode::CheckAssociatedTypeBounds { .. }\n             | ObligationCauseCode::LetElse\n             | ObligationCauseCode::BinOp { .. }\n-            | ObligationCauseCode::AscribeUserTypeProvePredicate(..) => {}\n+            | ObligationCauseCode::AscribeUserTypeProvePredicate(..)\n+            | ObligationCauseCode::RustCall => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }"}]}