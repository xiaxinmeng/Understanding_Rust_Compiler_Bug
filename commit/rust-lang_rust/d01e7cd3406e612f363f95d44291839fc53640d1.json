{"sha": "d01e7cd3406e612f363f95d44291839fc53640d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwMWU3Y2QzNDA2ZTYxMmYzNjNmOTVkNDQyOTE4MzlmYzUzNjQwZDE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-10T10:32:03Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-10T11:36:57Z"}, "message": "Represent boxed ifaces in a way similar to functions\n\nThey are now a (dictptr, box) pair, where box is a regular boxed\nrepresentation of the inner type. This cuts down on some special\ncase code.\n\nAlso removes some code from trans::base that was moved to shape but\nthen somehow restored in trans::base through a bad merge.\n\nStarts on issue #1567", "tree": {"sha": "e334c65e6ad7ef56ecbb510b98c9a123f2ddab54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e334c65e6ad7ef56ecbb510b98c9a123f2ddab54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d01e7cd3406e612f363f95d44291839fc53640d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d01e7cd3406e612f363f95d44291839fc53640d1", "html_url": "https://github.com/rust-lang/rust/commit/d01e7cd3406e612f363f95d44291839fc53640d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d01e7cd3406e612f363f95d44291839fc53640d1/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b17348527e2dc642561916f99b169949d7c0de93", "url": "https://api.github.com/repos/rust-lang/rust/commits/b17348527e2dc642561916f99b169949d7c0de93", "html_url": "https://github.com/rust-lang/rust/commit/b17348527e2dc642561916f99b169949d7c0de93"}], "stats": {"total": 355, "additions": 69, "deletions": 286}, "files": [{"sha": "02585c555d99c250b40a450cd652ca8c4b4543b7", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d01e7cd3406e612f363f95d44291839fc53640d1/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01e7cd3406e612f363f95d44291839fc53640d1/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=d01e7cd3406e612f363f95d44291839fc53640d1", "patch": "@@ -57,17 +57,13 @@ const shape_res: u8 = 20u8;\n const shape_var: u8 = 21u8;\n const shape_uniq: u8 = 22u8;\n const shape_opaque_closure_ptr: u8 = 23u8; // the closure itself.\n-const shape_iface: u8 = 24u8;\n const shape_uniq_fn: u8 = 25u8;\n const shape_stack_fn: u8 = 26u8;\n const shape_bare_fn: u8 = 27u8;\n const shape_tydesc: u8 = 28u8;\n const shape_send_tydesc: u8 = 29u8;\n const shape_class: u8 = 30u8;\n \n-// FIXME: This is a bad API in trans_common.\n-fn C_u8(n: u8) -> ValueRef { ret trans::common::C_u8(n as uint); }\n-\n fn hash_res_info(ri: res_info) -> uint {\n     let h = 5381u;\n     h *= 33u;\n@@ -404,7 +400,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         }\n         add_substr(s, sub);\n       }\n-      ty::ty_iface(_, _) { s += [shape_iface]; }\n+      ty::ty_iface(_, _) { s += [shape_box_fn]; }\n       ty::ty_class(_, _) { s += [shape_class]; }\n       ty::ty_res(did, raw_subt, tps) {\n         let subt = ty::substitute_type_params(ccx.tcx, tps, raw_subt);\n@@ -720,7 +716,7 @@ fn dynamic_metrics(cx: @block_ctxt, t: ty::t) -> metrics {\n \n     alt ty::get(t).struct {\n       ty::ty_param(p, _) {\n-        let ti = none::<@tydesc_info>;\n+        let ti = none;\n         let {bcx, val: tydesc} = base::get_tydesc(cx, t, false, ti).result;\n         let szptr = GEPi(bcx, tydesc, [0, abi::tydesc_field_size]);\n         let aptr = GEPi(bcx, tydesc, [0, abi::tydesc_field_align]);\n@@ -783,7 +779,7 @@ fn dynamic_metrics(cx: @block_ctxt, t: ty::t) -> metrics {\n fn simplify_type(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n     fn simplifier(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n         alt ty::get(typ).struct {\n-          ty::ty_box(_) | ty::ty_iface(_, _) {\n+          ty::ty_box(_) | ty::ty_opaque_box {\n             ret ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx));\n           }\n           ty::ty_uniq(_) {"}, {"sha": "eba29d3beb455918ee88875af4253cd1809106cf", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 34, "deletions": 242, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/d01e7cd3406e612f363f95d44291839fc53640d1/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01e7cd3406e612f363f95d44291839fc53640d1/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=d01e7cd3406e612f363f95d44291839fc53640d1", "patch": "@@ -41,9 +41,9 @@ import link::{mangle_internal_name_by_type_only,\n import metadata::{csearch, cstore};\n import util::ppaux::{ty_to_str, ty_to_short_str};\n \n-import shape::static_size_of_enum;\n import common::*;\n import build::*;\n+import shape::*;\n import ast_map::{path, path_mod, path_name};\n \n fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n@@ -136,7 +136,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_fn(_) {\n         T_fn_pair(cx, type_of_fn_from_ty(cx, t, []))\n       }\n-      ty::ty_iface(_, _) { T_opaque_iface_ptr(cx) }\n+      ty::ty_iface(_, _) { T_opaque_iface(cx) }\n       ty::ty_res(_, sub, tps) {\n         let sub1 = ty::substitute_type_params(cx.tcx, tps, sub);\n         // FIXME #1184: Resource flag is larger than necessary\n@@ -320,44 +320,6 @@ fn umin(cx: @block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n     ret Select(cx, cond, a, b);\n }\n \n-// Returns the real size of the given type for the current target.\n-fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    ret llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n-}\n-\n-// Returns the real alignment of the given type for the current target.\n-fn llalign_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    ret llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n-}\n-\n-fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n-    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), cx.int_type,\n-                               False);\n-}\n-\n-fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n-    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMAlignOf(t), cx.int_type,\n-                               False);\n-}\n-\n-fn size_of(cx: @block_ctxt, t: ty::t) -> result {\n-    size_of_(cx, t)\n-}\n-\n-fn size_of_(cx: @block_ctxt, t: ty::t) -> result {\n-    let ccx = bcx_ccx(cx);\n-    if check type_has_static_size(ccx, t) {\n-        rslt(cx, llsize_of(bcx_ccx(cx), type_of(ccx, t)))\n-    } else { dynamic_size_of(cx, t) }\n-}\n-\n-fn align_of(cx: @block_ctxt, t: ty::t) -> result {\n-    let ccx = bcx_ccx(cx);\n-    if check type_has_static_size(ccx, t) {\n-        rslt(cx, llalign_of(bcx_ccx(cx), type_of(ccx, t)))\n-    } else { dynamic_align_of(cx, t) }\n-}\n-\n fn alloca(cx: @block_ctxt, t: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(t); }\n     ret Alloca(new_raw_block_ctxt(cx.fcx, cx.fcx.llstaticallocas), t);\n@@ -394,158 +356,6 @@ fn mk_obstack_token(ccx: @crate_ctxt, fcx: @fn_ctxt) ->\n     ret Call(cx, ccx.upcalls.dynastack_mark, []);\n }\n \n-\n-// Creates a simpler, size-equivalent type. The resulting type is guaranteed\n-// to have (a) the same size as the type that was passed in; (b) to be non-\n-// recursive. This is done by replacing all boxes in a type with boxed unit\n-// types.\n-fn simplify_type(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n-    fn simplifier(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n-        alt ty::get(typ).struct {\n-          ty::ty_box(_) | ty::ty_iface(_, _) | ty::ty_opaque_box {\n-            ret ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx));\n-          }\n-          ty::ty_uniq(_) {\n-            ret ty::mk_imm_uniq(ccx.tcx, ty::mk_nil(ccx.tcx));\n-          }\n-          ty::ty_fn(_) {\n-            ret ty::mk_tup(ccx.tcx,\n-                           [ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx)),\n-                            ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx))]);\n-          }\n-          ty::ty_res(_, sub, tps) {\n-            let sub1 = ty::substitute_type_params(ccx.tcx, tps, sub);\n-            ret ty::mk_tup(ccx.tcx,\n-                           [ty::mk_int(ccx.tcx), simplify_type(ccx, sub1)]);\n-          }\n-          _ { ret typ; }\n-        }\n-    }\n-    ret ty::fold_ty(ccx.tcx, ty::fm_general(bind simplifier(ccx, _)), typ);\n-}\n-\n-fn dynamic_size_of(cx: @block_ctxt, t: ty::t) -> result {\n-    fn align_elements(cx: @block_ctxt, elts: [ty::t]) -> result {\n-        //\n-        // C padding rules:\n-        //\n-        //\n-        //   - Pad after each element so that next element is aligned.\n-        //   - Pad after final structure member so that whole structure\n-        //     is aligned to max alignment of interior.\n-        //\n-\n-        let off = C_int(bcx_ccx(cx), 0);\n-        let max_align = C_int(bcx_ccx(cx), 1);\n-        let bcx = cx;\n-        for e: ty::t in elts {\n-            let elt_align = align_of(bcx, e);\n-            bcx = elt_align.bcx;\n-            let elt_size = size_of(bcx, e);\n-            bcx = elt_size.bcx;\n-            let aligned_off = align_to(bcx, off, elt_align.val);\n-            off = Add(bcx, aligned_off, elt_size.val);\n-            max_align = umax(bcx, max_align, elt_align.val);\n-        }\n-        off = align_to(bcx, off, max_align);\n-        //off = alt mode {\n-        //  align_total. {\n-        //    align_to(bcx, off, max_align)\n-        //  }\n-        //  align_next(t) {\n-        //    let {bcx, val: align} = align_of(bcx, t);\n-        //    align_to(bcx, off, align)\n-        //  }\n-        //};\n-        ret rslt(bcx, off);\n-    }\n-    alt ty::get(t).struct {\n-      ty::ty_param(p, _) {\n-        let szptr = field_of_tydesc(cx, t, false, abi::tydesc_field_size);\n-        ret rslt(szptr.bcx, Load(szptr.bcx, szptr.val));\n-      }\n-      ty::ty_rec(flds) {\n-        let tys: [ty::t] = [];\n-        for f: ty::field in flds { tys += [f.mt.ty]; }\n-        ret align_elements(cx, tys);\n-      }\n-      ty::ty_tup(elts) {\n-        let tys = [];\n-        for tp in elts { tys += [tp]; }\n-        ret align_elements(cx, tys);\n-      }\n-      ty::ty_enum(tid, tps) {\n-        let bcx = cx;\n-        let ccx = bcx_ccx(bcx);\n-        // Compute max(variant sizes).\n-\n-        let max_size: ValueRef = alloca(bcx, ccx.int_type);\n-        Store(bcx, C_int(ccx, 0), max_size);\n-        let variants = ty::enum_variants(bcx_tcx(bcx), tid);\n-        for variant: ty::variant_info in *variants {\n-            // Perform type substitution on the raw argument types.\n-\n-            let raw_tys: [ty::t] = variant.args;\n-            let tys: [ty::t] = [];\n-            for raw_ty: ty::t in raw_tys {\n-                let t = ty::substitute_type_params(bcx_tcx(cx), tps, raw_ty);\n-                tys += [t];\n-            }\n-            let rslt = align_elements(bcx, tys);\n-            bcx = rslt.bcx;\n-            let this_size = rslt.val;\n-            let old_max_size = Load(bcx, max_size);\n-            Store(bcx, umax(bcx, this_size, old_max_size), max_size);\n-        }\n-        let max_size_val = Load(bcx, max_size);\n-        let total_size =\n-            if vec::len(*variants) != 1u {\n-                Add(bcx, max_size_val, llsize_of(ccx, ccx.int_type))\n-            } else { max_size_val };\n-        ret rslt(bcx, total_size);\n-      }\n-      // Precondition?\n-      _ { bcx_tcx(cx).sess.fatal(\"trans::dynamic_size_of alled on something \\\n-            with static size\"); }\n-    }\n-}\n-\n-fn dynamic_align_of(cx: @block_ctxt, t: ty::t) -> result {\n-// FIXME: Typestate constraint that shows this alt is\n-// exhaustive\n-    alt ty::get(t).struct {\n-      ty::ty_param(p, _) {\n-        let aptr = field_of_tydesc(cx, t, false, abi::tydesc_field_align);\n-        ret rslt(aptr.bcx, Load(aptr.bcx, aptr.val));\n-      }\n-      ty::ty_rec(flds) {\n-        let a = C_int(bcx_ccx(cx), 1);\n-        let bcx = cx;\n-        for f: ty::field in flds {\n-            let align = align_of(bcx, f.mt.ty);\n-            bcx = align.bcx;\n-            a = umax(bcx, a, align.val);\n-        }\n-        ret rslt(bcx, a);\n-      }\n-      ty::ty_enum(_, _) {\n-        ret rslt(cx, C_int(bcx_ccx(cx), 1)); // FIXME: stub\n-      }\n-      ty::ty_tup(elts) {\n-        let a = C_int(bcx_ccx(cx), 1);\n-        let bcx = cx;\n-        for e in elts {\n-            let align = align_of(bcx, e);\n-            bcx = align.bcx;\n-            a = umax(bcx, a, align.val);\n-        }\n-        ret rslt(bcx, a);\n-      }\n-      _ { bcx_tcx(cx).sess.bug(\"trans::dynamic_align_of called on \\\n-            something with static size\"); }\n-    }\n-}\n-\n // Given a pointer p, returns a pointer sz(p) (i.e., inc'd by sz bytes).\n // The type of the returned pointer is always i8*.  If you care about the\n // return type, use bump_ptr().\n@@ -712,8 +522,7 @@ fn opaque_box_body(bcx: @block_ctxt,\n // header.\n fn trans_malloc_boxed_raw(bcx: @block_ctxt, t: ty::t,\n                           &static_ti: option<@tydesc_info>) -> result {\n-    let bcx = bcx;\n-    let ccx = bcx_ccx(bcx);\n+    let bcx = bcx, ccx = bcx_ccx(bcx);\n \n     // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n     // wants.\n@@ -723,6 +532,7 @@ fn trans_malloc_boxed_raw(bcx: @block_ctxt, t: ty::t,\n \n     // Get the tydesc for the body:\n     let {bcx, val: lltydesc} = get_tydesc(bcx, t, true, static_ti).result;\n+    lazily_emit_all_tydesc_glue(ccx, static_ti);\n \n     // Allocate space:\n     let rval = Call(bcx, ccx.upcalls.malloc, [lltydesc]);\n@@ -816,7 +626,7 @@ fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n     let bcx = new_raw_block_ctxt(cx.fcx, cx.fcx.llderivedtydescs);\n     let tys = linearize_ty_params(bcx, t);\n     let root_ti = get_static_tydesc(bcx_ccx(bcx), t, tys.params);\n-    static_ti = some::<@tydesc_info>(root_ti);\n+    static_ti = some(root_ti);\n     lazily_emit_all_tydesc_glue(bcx_ccx(cx), static_ti);\n     let root = root_ti.tydesc;\n     let sz = size_of(bcx, t);\n@@ -1069,7 +879,7 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n \n-        let shape = shape::shape_of(ccx, key, ti.ty_params);\n+        let shape = shape_of(ccx, key, ti.ty_params);\n         let shape_tables =\n             llvm::LLVMConstPointerCast(ccx.shape_cx.llshapetables,\n                                        T_ptr(T_i8()));\n@@ -1100,11 +910,10 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n }\n \n fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n-\n     let bcx = cx;\n-    // NB: v is an *alias* of type t here, not a direct value.\n+    // NB: v is a *pointer* to type t here, not a direct value.\n     bcx = alt ty::get(t).struct {\n-      ty::ty_box(_) | ty::ty_iface(_, _) | ty::ty_opaque_box {\n+      ty::ty_box(_) | ty::ty_opaque_box {\n         incr_refcnt_of_boxed(bcx, Load(bcx, v))\n       }\n       ty::ty_uniq(_) {\n@@ -1128,6 +937,10 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n       ty::ty_fn(_) {\n         closure::make_fn_glue(bcx, v, t, take_ty)\n       }\n+      ty::ty_iface(_, _) {\n+        let box = Load(bcx, GEPi(bcx, v, [0, 1]));\n+        incr_refcnt_of_boxed(bcx, box)\n+      }\n       ty::ty_opaque_closure_ptr(ck) {\n         closure::make_opaque_cbox_take_glue(bcx, ck, v)\n       }\n@@ -1177,20 +990,6 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n       ty::ty_vec(_) | ty::ty_str {\n         tvec::make_free_glue(bcx, PointerCast(bcx, v, type_of(ccx, t)), t)\n       }\n-      ty::ty_iface(_, _) {\n-        // Call through the box's own fields-drop glue first.\n-        // Then free the body.\n-        let ccx = bcx_ccx(bcx);\n-        let llbox_ty = T_opaque_iface_ptr(ccx);\n-        let b = PointerCast(bcx, v, llbox_ty);\n-        let body = GEPi(bcx, b, [0, abi::box_field_body]);\n-        let tydescptr = GEPi(bcx, body, [0, 0]);\n-        let tydesc = Load(bcx, tydescptr);\n-        let ti = none;\n-        call_tydesc_glue_full(bcx, body, tydesc,\n-                              abi::tydesc_field_drop_glue, ti);\n-        trans_free(bcx, b)\n-      }\n       ty::ty_send_type {\n         // sendable type descriptors are basically unique pointers,\n         // they must be freed.\n@@ -1214,7 +1013,7 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let ccx = bcx_ccx(bcx);\n     let bcx = alt ty::get(t).struct {\n-      ty::ty_box(_) | ty::ty_iface(_, _) | ty::ty_opaque_box {\n+      ty::ty_box(_) | ty::ty_opaque_box {\n         decr_refcnt_maybe_free(bcx, Load(bcx, v0), t)\n       }\n       ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str | ty::ty_send_type {\n@@ -1226,6 +1025,10 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n       ty::ty_fn(_) {\n         closure::make_fn_glue(bcx, v0, t, drop_ty)\n       }\n+      ty::ty_iface(_, _) {\n+        let box = Load(bcx, GEPi(bcx, v0, [0, 1]));\n+        decr_refcnt_maybe_free(bcx, box, ty::mk_opaque_box(ccx.tcx))\n+      }\n       ty::ty_opaque_closure_ptr(ck) {\n         closure::make_opaque_cbox_drop_glue(bcx, ck, v0)\n       }\n@@ -1300,7 +1103,7 @@ fn decr_refcnt_maybe_free(cx: @block_ctxt, box_ptr: ValueRef, t: ty::t)\n     let rc_adj_cx = new_sub_block_ctxt(cx, \"rc--\");\n     let free_cx = new_sub_block_ctxt(cx, \"free\");\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n-    let llbox_ty = T_opaque_iface_ptr(ccx);\n+    let llbox_ty = T_opaque_box_ptr(ccx);\n     let box_ptr = PointerCast(cx, box_ptr, llbox_ty);\n     let null_test = IsNull(cx, box_ptr);\n     CondBr(cx, null_test, next_cx.llbb, rc_adj_cx.llbb);\n@@ -1699,7 +1502,7 @@ fn drop_ty(cx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n fn drop_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n     alt ty::get(t).struct {\n       ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str { free_ty(bcx, v, t) }\n-      ty::ty_box(_) | ty::ty_iface(_, _) | ty::ty_opaque_box {\n+      ty::ty_box(_) | ty::ty_opaque_box {\n         decr_refcnt_maybe_free(bcx, v, t)\n       }\n       // Precondition?\n@@ -1709,7 +1512,7 @@ fn drop_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n \n fn take_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n     alt ty::get(t).struct {\n-      ty::ty_box(_) | ty::ty_iface(_, _) | ty::ty_opaque_box {\n+      ty::ty_box(_) | ty::ty_opaque_box {\n         rslt(incr_refcnt_of_boxed(bcx, v), v)\n       }\n       ty::ty_uniq(_) {\n@@ -2429,13 +2232,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n     -> option<{llfn: ValueRef, fty: ty::t}> {\n     let substs = vec::map(substs, {|t|\n         alt ty::get(t).struct {\n-          ty::ty_box(mt) {\n-            if !ty::type_has_params(mt.ty) {\n-                let ti = some(get_static_tydesc(ccx, mt.ty, []));\n-                lazily_emit_all_tydesc_glue(ccx, ti);\n-            }\n-            ty::mk_opaque_box(ccx.tcx)\n-          }\n+          ty::ty_box(mt) { ty::mk_opaque_box(ccx.tcx) }\n           _ { t }\n         }\n     });\n@@ -4254,21 +4051,16 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n     dt: BasicBlockRef,\n     da: BasicBlockRef,\n     rt: BasicBlockRef} {\n-    ret {sa:\n-             str::as_buf(\"static_allocas\",\n-                         {|buf| llvm::LLVMAppendBasicBlock(llfn, buf) }),\n-         ca:\n-             str::as_buf(\"load_env\",\n-                         {|buf| llvm::LLVMAppendBasicBlock(llfn, buf) }),\n-         dt:\n-             str::as_buf(\"derived_tydescs\",\n-                         {|buf| llvm::LLVMAppendBasicBlock(llfn, buf) }),\n-         da:\n-             str::as_buf(\"dynamic_allocas\",\n-                         {|buf| llvm::LLVMAppendBasicBlock(llfn, buf) }),\n-         rt:\n-             str::as_buf(\"return\",\n-                         {|buf| llvm::LLVMAppendBasicBlock(llfn, buf) })};\n+    ret {sa: str::as_buf(\"static_allocas\", {|buf|\n+                 llvm::LLVMAppendBasicBlock(llfn, buf) }),\n+         ca: str::as_buf(\"load_env\", {|buf|\n+                 llvm::LLVMAppendBasicBlock(llfn, buf) }),\n+         dt: str::as_buf(\"derived_tydescs\", {|buf|\n+                 llvm::LLVMAppendBasicBlock(llfn, buf) }),\n+         da: str::as_buf(\"dynamic_allocas\", {|buf|\n+                 llvm::LLVMAppendBasicBlock(llfn, buf) }),\n+         rt: str::as_buf(\"return\", {|buf|\n+                 llvm::LLVMAppendBasicBlock(llfn, buf) })};\n }\n \n \n@@ -5415,7 +5207,7 @@ fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n \n // Writes the current ABI version into the crate.\n fn write_abi_version(ccx: @crate_ctxt) {\n-    shape::mk_global(ccx, \"rust_abi_version\", C_uint(ccx, abi::abi_version),\n+    mk_global(ccx, \"rust_abi_version\", C_uint(ccx, abi::abi_version),\n                      false);\n }\n \n@@ -5520,7 +5312,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           task_type: task_type,\n           opaque_vec_type: T_opaque_vec(targ_cfg),\n           builder: BuilderRef_res(llvm::LLVMCreateBuilder()),\n-          shape_cx: shape::mk_ctxt(llmod),\n+          shape_cx: mk_ctxt(llmod),\n           crate_map: crate_map,\n           dbg_cx: dbg_cx,\n           mutable do_not_commit_warning_issued: false};\n@@ -5529,7 +5321,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     trans_mod(ccx, crate.node.module);\n     fill_crate_map(ccx, crate_map);\n     emit_tydescs(ccx);\n-    shape::gen_shape_tables(ccx);\n+    gen_shape_tables(ccx);\n     write_abi_version(ccx);\n \n     // Translate the metadata."}, {"sha": "9255119379eaa0ce79bb5ae83e6ce99ccd807a59", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d01e7cd3406e612f363f95d44291839fc53640d1/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01e7cd3406e612f363f95d44291839fc53640d1/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=d01e7cd3406e612f363f95d44291839fc53640d1", "patch": "@@ -642,7 +642,7 @@ fn make_opaque_cbox_take_glue(\n         let sz = Load(bcx, GEPi(bcx, tydesc, [0, abi::tydesc_field_size]));\n \n         // Adjust sz to account for the rust_opaque_box header fields\n-        let sz = Add(bcx, sz, base::llsize_of(ccx, T_box_header(ccx)));\n+        let sz = Add(bcx, sz, shape::llsize_of(ccx, T_box_header(ccx)));\n \n         // Allocate memory, update original ptr, and copy existing data\n         let malloc = ccx.upcalls.shared_malloc;"}, {"sha": "9f1b7ef7dbd3ca0fd825b3c39800479671a3b24e", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d01e7cd3406e612f363f95d44291839fc53640d1/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01e7cd3406e612f363f95d44291839fc53640d1/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=d01e7cd3406e612f363f95d44291839fc53640d1", "patch": "@@ -710,9 +710,8 @@ fn T_captured_tydescs(cx: @crate_ctxt, n: uint) -> TypeRef {\n     ret T_struct(vec::init_elt::<TypeRef>(n, T_ptr(cx.tydesc_type)));\n }\n \n-fn T_opaque_iface_ptr(cx: @crate_ctxt) -> TypeRef {\n-    let tdptr = T_ptr(cx.tydesc_type);\n-    T_ptr(T_box(cx, T_struct([tdptr, tdptr, T_i8()])))\n+fn T_opaque_iface(cx: @crate_ctxt) -> TypeRef {\n+    T_struct([T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)])\n }\n \n fn T_opaque_port_ptr() -> TypeRef { ret T_ptr(T_i8()); }"}, {"sha": "b72a1e47a6098997ccbd0e3cbe8534bbd7473cc3", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d01e7cd3406e612f363f95d44291839fc53640d1/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01e7cd3406e612f363f95d44291839fc53640d1/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=d01e7cd3406e612f363f95d44291839fc53640d1", "patch": "@@ -38,7 +38,7 @@ import ast_map::{path, path_mod, path_name};\n // up.\n //\n // The trans_constants pass in trans.rs outputs the vtables. Typeck\n-// annotates notes with information about the methods and dicts that\n+// annotates nodes with information about the methods and dicts that\n // are referenced (ccx.method_map and ccx.dict_map).\n \n fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n@@ -189,17 +189,15 @@ fn trans_iface_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n                       base: @ast::expr, n_method: uint)\n     -> lval_maybe_callee {\n     let {bcx, val} = trans_temp_expr(bcx, base);\n-    let box_body = GEPi(bcx, val, [0, abi::box_field_body]);\n-    let dict = Load(bcx, PointerCast(bcx, GEPi(bcx, box_body, [0, 1]),\n+    let dict = Load(bcx, PointerCast(bcx, GEPi(bcx, val, [0, 0]),\n                                      T_ptr(T_ptr(T_dict()))));\n+    let box = Load(bcx, GEPi(bcx, val, [0, 1]));\n     // FIXME[impl] I doubt this is alignment-safe\n-    let self = PointerCast(bcx, GEPi(bcx, box_body, [0, 2]),\n+    let self = PointerCast(bcx, GEPi(bcx, box, [0, abi::box_field_body]),\n                            T_opaque_cbox_ptr(bcx_ccx(bcx)));\n     let iface_id = alt ty::get(expr_ty(bcx, base)).struct {\n         ty::ty_iface(did, _) { did }\n-        // precondition\n-        _ { bcx_tcx(bcx).sess.span_bug(base.span, \"base has non-iface type \\\n-             in trans_iface_callee\"); }\n+        _ { fail \"base has non-iface type in trans_iface_callee\"; }\n     };\n     trans_vtable_callee(bcx, self, dict, callee_id, iface_id, n_method)\n }\n@@ -360,20 +358,17 @@ fn trans_iface_wrapper(ccx: @crate_ctxt, pt: path, m: ty::method,\n     let {llty: llfty, _} = wrapper_fn_ty(ccx, T_ptr(T_i8()),\n                                          ty::mk_fn(ccx.tcx, m.fty), m.tps);\n     trans_wrapper(ccx, pt, llfty, {|llfn, bcx|\n-        let self = Load(bcx, PointerCast(bcx,\n-                                         LLVMGetParam(llfn, 2u as c_uint),\n-                                         T_ptr(T_opaque_iface_ptr(ccx))));\n-        let boxed = GEPi(bcx, self, [0, abi::box_field_body]);\n-        let dict = Load(bcx, PointerCast(bcx, GEPi(bcx, boxed, [0, 1]),\n-                                         T_ptr(T_ptr(T_dict()))));\n+        let param = PointerCast(bcx, LLVMGetParam(llfn, 2u as c_uint),\n+                                T_ptr(T_opaque_iface(ccx)));\n+        let dict = Load(bcx, GEPi(bcx, param, [0, 0]));\n+        let box = Load(bcx, GEPi(bcx, param, [0, 1]));\n+        let self = GEPi(bcx, box, [0, abi::box_field_body]);\n         let vtable = PointerCast(bcx, Load(bcx, GEPi(bcx, dict, [0, 0])),\n                                  T_ptr(T_array(T_ptr(llfty), n + 1u)));\n         let mptr = Load(bcx, GEPi(bcx, vtable, [0, n as int]));\n-        // FIXME[impl] This doesn't account for more-than-ptr-sized alignment\n-        let inner_self = GEPi(bcx, boxed, [0, 2]);\n         let args = [PointerCast(bcx, dict, T_ptr(T_i8())),\n                     LLVMGetParam(llfn, 1u as c_uint),\n-                    PointerCast(bcx, inner_self, T_opaque_cbox_ptr(ccx))];\n+                    PointerCast(bcx, self, T_opaque_cbox_ptr(ccx))];\n         let i = 3u as c_uint, total = llvm::LLVMCountParamTypes(llfty);\n         while i < total {\n             args += [LLVMGetParam(llfn, i)];\n@@ -531,18 +526,18 @@ fn get_dict_ptrs(bcx: @block_ctxt, origin: typeck::dict_origin)\n \n fn trans_cast(bcx: @block_ctxt, val: @ast::expr, id: ast::node_id, dest: dest)\n     -> @block_ctxt {\n-    let ccx = bcx_ccx(bcx), tcx = ccx.tcx;\n-    let val_ty = expr_ty(bcx, val);\n+    if dest == ignore { ret trans_expr(bcx, val, ignore); }\n+    let ccx = bcx_ccx(bcx);\n+    let v_ty = expr_ty(bcx, val);\n+    let {bcx, box, body} = trans_malloc_boxed(bcx, v_ty);\n+    add_clean_free(bcx, box, false);\n+    bcx = trans_expr_save_in(bcx, val, body);\n+    revoke_clean(bcx, box);\n+    let result = get_dest_addr(dest);\n+    Store(bcx, box, PointerCast(bcx, GEPi(bcx, result, [0, 1]),\n+                                T_ptr(val_ty(box))));\n     let {bcx, val: dict} = get_dict(bcx, ccx.dict_map.get(id)[0]);\n-    let body_ty = ty::mk_tup(tcx, [ty::mk_type(tcx), ty::mk_type(tcx),\n-                                   val_ty]);\n-    let ti = none;\n-    let {bcx, val: tydesc} = get_tydesc(bcx, body_ty, true, ti).result;\n-    lazily_emit_all_tydesc_glue(ccx, ti);\n-    let {bcx, box, body: box_body} = trans_malloc_boxed(bcx, body_ty);\n-    Store(bcx, tydesc, GEPi(bcx, box_body, [0, 0]));\n-    Store(bcx, PointerCast(bcx, dict, T_ptr(ccx.tydesc_type)),\n-          GEPi(bcx, box_body, [0, 1]));\n-    bcx = trans_expr_save_in(bcx, val, GEPi(bcx, box_body, [0, 2]));\n-    store_in_dest(bcx, PointerCast(bcx, box, T_opaque_iface_ptr(ccx)), dest)\n+    Store(bcx, dict, PointerCast(bcx, GEPi(bcx, result, [0, 0]),\n+                                 T_ptr(val_ty(dict))));\n+    bcx\n }"}, {"sha": "826ed0ea4bd8b83761f6d2cd232a6841df5c3a9b", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d01e7cd3406e612f363f95d44291839fc53640d1/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01e7cd3406e612f363f95d44291839fc53640d1/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=d01e7cd3406e612f363f95d44291839fc53640d1", "patch": "@@ -615,7 +615,7 @@ fn type_is_bool(ty: t) -> bool { get(ty).struct == ty_bool }\n fn type_is_structural(ty: t) -> bool {\n     alt get(ty).struct {\n       ty_rec(_) | ty_tup(_) | ty_enum(_, _) | ty_fn(_) |\n-      ty_res(_, _, _) { true }\n+      ty_iface(_, _) | ty_res(_, _, _) { true }\n       _ { false }\n     }\n }\n@@ -666,7 +666,7 @@ pure fn type_is_box(ty: t) -> bool {\n \n pure fn type_is_boxed(ty: t) -> bool {\n     alt get(ty).struct {\n-      ty_box(_) | ty_iface(_, _) | ty_opaque_box { true }\n+      ty_box(_) | ty_opaque_box { true }\n       _ { false }\n     }\n }"}, {"sha": "ef9b41562308365df35758431739fcf5376ec9f7", "filename": "src/rt/rust_shape.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d01e7cd3406e612f363f95d44291839fc53640d1/src%2Frt%2Frust_shape.h", "raw_url": "https://github.com/rust-lang/rust/raw/d01e7cd3406e612f363f95d44291839fc53640d1/src%2Frt%2Frust_shape.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.h?ref=d01e7cd3406e612f363f95d44291839fc53640d1", "patch": "@@ -51,12 +51,13 @@ const uint8_t SHAPE_OBJ = 19u;\n const uint8_t SHAPE_RES = 20u;\n const uint8_t SHAPE_VAR = 21u;\n const uint8_t SHAPE_UNIQ = 22u;\n-const uint8_t SHAPE_IFACE = 24u;\n+const uint8_t SHAPE_IFACE_OLD = 24u;\n const uint8_t SHAPE_UNIQ_FN = 25u;\n const uint8_t SHAPE_STACK_FN = 26u;\n const uint8_t SHAPE_BARE_FN = 27u;\n const uint8_t SHAPE_TYDESC = 28u;\n const uint8_t SHAPE_SEND_TYDESC = 29u;\n+const uint8_t SHAPE_IFACE = 31u;\n \n #ifdef _LP64\n const uint8_t SHAPE_PTR = SHAPE_U64;\n@@ -381,7 +382,7 @@ ctxt<T>::walk() {\n     case SHAPE_RES:      walk_res0();             break;\n     case SHAPE_VAR:      walk_var0();             break;\n     case SHAPE_UNIQ:     walk_uniq0();            break;\n-    case SHAPE_IFACE:    WALK_SIMPLE(walk_iface1);    break;\n+    case SHAPE_IFACE_OLD: WALK_SIMPLE(walk_iface1);    break;\n     case SHAPE_BOX_FN:\n     case SHAPE_UNIQ_FN:\n     case SHAPE_STACK_FN:"}]}