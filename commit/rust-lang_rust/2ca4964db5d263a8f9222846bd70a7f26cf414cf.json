{"sha": "2ca4964db5d263a8f9222846bd70a7f26cf414cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjYTQ5NjRkYjVkMjYzYThmOTIyMjg0NmJkNzBhN2YyNmNmNDE0Y2Y=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2020-11-13T17:01:16Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2020-11-27T14:23:47Z"}, "message": "Allow to self reference associated types in where clauses", "tree": {"sha": "29aa746f704a7e8b8a45a63ed1832b17c11b40e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29aa746f704a7e8b8a45a63ed1832b17c11b40e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ca4964db5d263a8f9222846bd70a7f26cf414cf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAl/BC/MACgkQgTGiTgx5\n768cVA//c/RJ7QcRrhjcFh0uKsfgv2Fdb5OgucZrVtgF+/rQARY4Fd780oD08muy\nTcoIo+YZdVJDTlB0/75oHmDHgdoxREz8rxspRbzkDKE2cyEWpRpAqhEEFbwQJg5C\nMgJZvaYCvvaaULbnTmbVrAc14bfc3rj6Evmoqudqq70pKcJCWjbmKeauV9GAIfTB\nDUxgywfwMgTiG+ZWE9h8ICt27TPU4n2AjHULTQeuiMR9sYpXlAsiLlvu9koNwecb\nSnuLlXCjpnbfDLgfNiikrvI58t4aAyS9qN8XAicQVeG4rfh5FDtCEyakM/gepL5X\niMOMe6RPXzCSlC76VLCR8CpU/wF66Z0IIjtJQUm5xFzR1MKOIiviU9M/Rca0kqBR\n2I7kjVWzTlTst2jL4UKd10MH16oXRgGezNj5X/td+r0iT/aZuVM5WO3qa6fkXfz5\nOc7JMHKjREWYVJWR057NSgKxBU3GIpQIYi/fhUewjrBVQKdpqkEUxdUOuMEQVOf9\nrrsUPXQZw3iTbG2HLhgSkdkDsc9Ew+2IDiHtlRfGBr51V7SmJW6/yXRLI46MLLoh\njR7gugJARiuzUn8TALkHa4KA9TW0SceeWaPJJ0vZL7NUKOWFt9bDTHh96lY7AlUb\nD1/m+9GcWzZ//o0Td2dPHcuYIoUBotdLMkIn1bVCB6mDGOlT/Gw=\n=mw7p\n-----END PGP SIGNATURE-----", "payload": "tree 29aa746f704a7e8b8a45a63ed1832b17c11b40e2\nparent 24dcf6f7a29d7577a3c3448046d2d48b2fee59de\nauthor Santiago Pastorino <spastorino@gmail.com> 1605286876 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1606487027 -0300\n\nAllow to self reference associated types in where clauses\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ca4964db5d263a8f9222846bd70a7f26cf414cf", "html_url": "https://github.com/rust-lang/rust/commit/2ca4964db5d263a8f9222846bd70a7f26cf414cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ca4964db5d263a8f9222846bd70a7f26cf414cf/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24dcf6f7a29d7577a3c3448046d2d48b2fee59de", "url": "https://api.github.com/repos/rust-lang/rust/commits/24dcf6f7a29d7577a3c3448046d2d48b2fee59de", "html_url": "https://github.com/rust-lang/rust/commit/24dcf6f7a29d7577a3c3448046d2d48b2fee59de"}], "stats": {"total": 267, "additions": 204, "deletions": 63}, "files": [{"sha": "26f6fcd5dab68ec92de5f63dd995a303d19257f1", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2ca4964db5d263a8f9222846bd70a7f26cf414cf/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca4964db5d263a8f9222846bd70a7f26cf414cf/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=2ca4964db5d263a8f9222846bd70a7f26cf414cf", "patch": "@@ -4,6 +4,7 @@ use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::ty::outlives::Component;\n use rustc_middle::ty::{self, ToPredicate, TyCtxt, WithConstness};\n+use rustc_span::symbol::Ident;\n \n pub fn anonymize_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -89,6 +90,32 @@ pub fn elaborate_trait_refs<'tcx>(\n     elaborate_predicates(tcx, predicates)\n }\n \n+pub fn elaborate_trait_refs_that_define_assoc_type<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+    assoc_name: Ident,\n+) -> FxHashSet<ty::PolyTraitRef<'tcx>> {\n+    let mut stack: Vec<_> = trait_refs.collect();\n+    let mut trait_refs = FxHashSet::default();\n+\n+    while let Some(trait_ref) = stack.pop() {\n+        if trait_refs.insert(trait_ref) {\n+            let super_predicates =\n+                tcx.super_predicates_that_define_assoc_type((trait_ref.def_id(), Some(assoc_name)));\n+            for (super_predicate, _) in super_predicates.predicates {\n+                let bound_predicate = super_predicate.bound_atom();\n+                let subst_predicate = super_predicate\n+                    .subst_supertrait(tcx, &bound_predicate.rebind(trait_ref.skip_binder()));\n+                if let Some(binder) = subst_predicate.to_opt_poly_trait_ref() {\n+                    stack.push(binder.value);\n+                }\n+            }\n+        }\n+    }\n+\n+    trait_refs\n+}\n+\n pub fn elaborate_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n@@ -287,6 +314,14 @@ pub fn transitive_bounds<'tcx>(\n     elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n+pub fn transitive_bounds_that_define_assoc_type<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+    assoc_name: Ident,\n+) -> FxHashSet<ty::PolyTraitRef<'tcx>> {\n+    elaborate_trait_refs_that_define_assoc_type(tcx, bounds, assoc_name)\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Other\n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "c19943e1f8ccd91a5d5333138fbfcf0ccd7cf98b", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ca4964db5d263a8f9222846bd70a7f26cf414cf/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca4964db5d263a8f9222846bd70a7f26cf414cf/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=2ca4964db5d263a8f9222846bd70a7f26cf414cf", "patch": "@@ -436,6 +436,16 @@ rustc_queries! {\n             desc { |tcx| \"computing the supertraits of `{}`\", tcx.def_path_str(key) }\n         }\n \n+        /// Maps from the `DefId` of a trait to the list of\n+        /// super-predicates. This is a subset of the full list of\n+        /// predicates. We store these in a separate map because we must\n+        /// evaluate them even during type conversion, often before the\n+        /// full predicates are available (note that supertraits have\n+        /// additional acyclicity requirements).\n+        query super_predicates_that_define_assoc_type(key: (DefId, Option<rustc_span::symbol::Ident>)) -> ty::GenericPredicates<'tcx> {\n+            desc { |tcx| \"computing the supertraits of `{}`\", tcx.def_path_str(key.0) }\n+        }\n+\n         /// To avoid cycles within the predicates of a single item we compute\n         /// per-type-parameter predicates for resolving `T::AssocTy`.\n         query type_param_predicates(key: (DefId, LocalDefId, rustc_span::symbol::Ident)) -> ty::GenericPredicates<'tcx> {"}, {"sha": "3949c303f727a7d938bc403ce90e6501b8368bc8", "filename": "compiler/rustc_middle/src/ty/query/keys.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2ca4964db5d263a8f9222846bd70a7f26cf414cf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca4964db5d263a8f9222846bd70a7f26cf414cf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs?ref=2ca4964db5d263a8f9222846bd70a7f26cf414cf", "patch": "@@ -149,6 +149,17 @@ impl Key for (LocalDefId, DefId) {\n     }\n }\n \n+impl Key for (DefId, Option<Ident>) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n+    fn query_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        tcx.def_span(self.0)\n+    }\n+}\n+\n impl Key for (DefId, LocalDefId, Ident) {\n     type CacheSelector = DefaultCacheSelector;\n "}, {"sha": "d027628828441d00084f14e7a3ae2c3aa3a1a4a2", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ca4964db5d263a8f9222846bd70a7f26cf414cf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca4964db5d263a8f9222846bd70a7f26cf414cf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=2ca4964db5d263a8f9222846bd70a7f26cf414cf", "patch": "@@ -65,7 +65,8 @@ pub use self::util::{\n     get_vtable_index_of_object_method, impl_item_is_final, predicate_for_trait_def, upcast_choices,\n };\n pub use self::util::{\n-    supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,\n+    supertrait_def_ids, supertraits, transitive_bounds, transitive_bounds_that_define_assoc_type,\n+    SupertraitDefIds, Supertraits,\n };\n \n pub use self::chalk_fulfill::FulfillmentContext as ChalkFulfillmentContext;"}, {"sha": "d8fbcb633cd3e93cb12a7dea7f6962868cb9e089", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2ca4964db5d263a8f9222846bd70a7f26cf414cf/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca4964db5d263a8f9222846bd70a7f26cf414cf/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=2ca4964db5d263a8f9222846bd70a7f26cf414cf", "patch": "@@ -6,6 +6,7 @@ mod errors;\n mod generics;\n \n use crate::bounds::Bounds;\n+use crate::collect::super_traits_of;\n use crate::collect::PlaceholderHirTyCollector;\n use crate::errors::{\n     AmbiguousLifetimeBound, MultipleRelaxedDefaultBounds, TraitObjectDeclaredWithNoTraits,\n@@ -768,7 +769,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     // Returns `true` if a bounds list includes `?Sized`.\n-    pub fn is_unsized(&self, ast_bounds: &[hir::GenericBound<'_>], span: Span) -> bool {\n+    pub fn is_unsized(&self, ast_bounds: &[&hir::GenericBound<'_>], span: Span) -> bool {\n         let tcx = self.tcx();\n \n         // Try to find an unbound in bounds.\n@@ -826,7 +827,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn add_bounds(\n         &self,\n         param_ty: Ty<'tcx>,\n-        ast_bounds: &[hir::GenericBound<'_>],\n+        ast_bounds: &[&hir::GenericBound<'_>],\n         bounds: &mut Bounds<'tcx>,\n     ) {\n         let mut trait_bounds = Vec::new();\n@@ -844,7 +845,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => {}\n                 hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => self\n                     .instantiate_lang_item_trait_ref(\n-                        lang_item, span, hir_id, args, param_ty, bounds,\n+                        *lang_item, *span, *hir_id, args, param_ty, bounds,\n                     ),\n                 hir::GenericBound::Outlives(ref l) => region_bounds.push(l),\n             }\n@@ -878,7 +879,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn compute_bounds(\n         &self,\n         param_ty: Ty<'tcx>,\n-        ast_bounds: &[hir::GenericBound<'_>],\n+        ast_bounds: &[&hir::GenericBound<'_>],\n         sized_by_default: SizedByDefault,\n         span: Span,\n     ) -> Bounds<'tcx> {\n@@ -896,6 +897,39 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         bounds\n     }\n \n+    pub fn compute_bounds_that_match_assoc_type(\n+        &self,\n+        param_ty: Ty<'tcx>,\n+        ast_bounds: &[hir::GenericBound<'_>],\n+        sized_by_default: SizedByDefault,\n+        span: Span,\n+        assoc_name: Ident,\n+    ) -> Bounds<'tcx> {\n+        let mut result = Vec::new();\n+\n+        for ast_bound in ast_bounds {\n+            if let Some(trait_ref) = ast_bound.trait_ref() {\n+                if let Some(trait_did) = trait_ref.trait_def_id() {\n+                    if super_traits_of(self.tcx(), trait_did).any(|trait_did| {\n+                        self.tcx()\n+                            .associated_items(trait_did)\n+                            .find_by_name_and_kind(\n+                                self.tcx(),\n+                                assoc_name,\n+                                ty::AssocKind::Type,\n+                                trait_did,\n+                            )\n+                            .is_some()\n+                    }) {\n+                        result.push(ast_bound);\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.compute_bounds(param_ty, &result, sized_by_default, span)\n+    }\n+\n     /// Given an HIR binding like `Item = Foo` or `Item: Foo`, pushes the corresponding predicates\n     /// onto `bounds`.\n     ///\n@@ -1050,7 +1084,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n                 // parameter to have a skipped binder.\n                 let param_ty = tcx.mk_projection(assoc_ty.def_id, candidate.skip_binder().substs);\n-                self.add_bounds(param_ty, ast_bounds, bounds);\n+                let ast_bounds: Vec<_> = ast_bounds.iter().collect();\n+                self.add_bounds(param_ty, &ast_bounds, bounds);\n             }\n         }\n         Ok(())\n@@ -1377,12 +1412,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let param_name = tcx.hir().ty_param_name(param_hir_id);\n         self.one_bound_for_assoc_type(\n             || {\n-                traits::transitive_bounds(\n+                traits::transitive_bounds_that_define_assoc_type(\n                     tcx,\n                     predicates.iter().filter_map(|(p, _)| {\n                         p.to_opt_poly_trait_ref().map(|trait_ref| trait_ref.value)\n                     }),\n+                    assoc_name,\n                 )\n+                .into_iter()\n             },\n             || param_name.to_string(),\n             assoc_name,"}, {"sha": "8b457c7ceec2754f6ed08e04d82ebd2dd215f52f", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 87, "deletions": 54, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/2ca4964db5d263a8f9222846bd70a7f26cf414cf/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca4964db5d263a8f9222846bd70a7f26cf414cf/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=2ca4964db5d263a8f9222846bd70a7f26cf414cf", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n //! \"Collection\" is the process of determining the type and other external\n //! details of each item in Rust. Collection is specifically concerned\n //! with *inter-procedural* things -- for example, for a function\n@@ -79,6 +80,7 @@ pub fn provide(providers: &mut Providers) {\n         projection_ty_from_predicates,\n         explicit_predicates_of,\n         super_predicates_of,\n+        super_predicates_that_define_assoc_type,\n         trait_explicit_predicates_and_bounds,\n         type_param_predicates,\n         trait_def,\n@@ -651,17 +653,10 @@ impl ItemCtxt<'tcx> {\n             hir::GenericBound::Trait(poly_trait_ref, _) => {\n                 let trait_ref = &poly_trait_ref.trait_ref;\n                 let trait_did = trait_ref.trait_def_id().unwrap();\n-                let traits_did = super_traits_of(self.tcx, trait_did);\n-\n-                traits_did.iter().any(|trait_did| {\n+                super_traits_of(self.tcx, trait_did).any(|trait_did| {\n                     self.tcx\n-                        .associated_items(*trait_did)\n-                        .find_by_name_and_kind(\n-                            self.tcx,\n-                            assoc_name,\n-                            ty::AssocKind::Type,\n-                            *trait_did,\n-                        )\n+                        .associated_items(trait_did)\n+                        .find_by_name_and_kind(self.tcx, assoc_name, ty::AssocKind::Type, trait_did)\n                         .is_some()\n                 })\n             }\n@@ -1035,55 +1030,91 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n /// the transitive super-predicates are converted.\n fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredicates<'_> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n-    let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id.expect_local());\n+    tcx.super_predicates_that_define_assoc_type((trait_def_id, None))\n+}\n \n-    let item = match tcx.hir().get(trait_hir_id) {\n-        Node::Item(item) => item,\n-        _ => bug!(\"trait_node_id {} is not an item\", trait_hir_id),\n-    };\n+/// Ensures that the super-predicates of the trait with a `DefId`\n+/// of `trait_def_id` are converted and stored. This also ensures that\n+/// the transitive super-predicates are converted.\n+fn super_predicates_that_define_assoc_type(\n+    tcx: TyCtxt<'_>,\n+    (trait_def_id, assoc_name): (DefId, Option<Ident>),\n+) -> ty::GenericPredicates<'_> {\n+    debug!(\n+        \"super_predicates_that_define_assoc_type(trait_def_id={:?}, assoc_name={:?})\",\n+        trait_def_id, assoc_name\n+    );\n+    if trait_def_id.is_local() {\n+        debug!(\"super_predicates_that_define_assoc_type: local trait_def_id={:?}\", trait_def_id);\n+        let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id.expect_local());\n \n-    let (generics, bounds) = match item.kind {\n-        hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n-        hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n-        _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n-    };\n+        let item = match tcx.hir().get(trait_hir_id) {\n+            Node::Item(item) => item,\n+            _ => bug!(\"trait_node_id {} is not an item\", trait_hir_id),\n+        };\n \n-    let icx = ItemCtxt::new(tcx, trait_def_id);\n-\n-    // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n-    let self_param_ty = tcx.types.self_param;\n-    let superbounds1 =\n-        AstConv::compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No, item.span);\n-\n-    let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n-\n-    // Convert any explicit superbounds in the where-clause,\n-    // e.g., `trait Foo where Self: Bar`.\n-    // In the case of trait aliases, however, we include all bounds in the where-clause,\n-    // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n-    // as one of its \"superpredicates\".\n-    let is_trait_alias = tcx.is_trait_alias(trait_def_id);\n-    let superbounds2 = icx.type_parameter_bounds_in_generics(\n-        generics,\n-        item.hir_id,\n-        self_param_ty,\n-        OnlySelfBounds(!is_trait_alias),\n-        None,\n-    );\n+        let (generics, bounds) = match item.kind {\n+            hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n+            hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n+            _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n+        };\n \n-    // Combine the two lists to form the complete set of superbounds:\n-    let superbounds = &*tcx.arena.alloc_from_iter(superbounds1.into_iter().chain(superbounds2));\n+        let icx = ItemCtxt::new(tcx, trait_def_id);\n \n-    // Now require that immediate supertraits are converted,\n-    // which will, in turn, reach indirect supertraits.\n-    for &(pred, span) in superbounds {\n-        debug!(\"superbound: {:?}\", pred);\n-        if let ty::PredicateAtom::Trait(bound, _) = pred.skip_binders() {\n-            tcx.at(span).super_predicates_of(bound.def_id());\n+        // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n+        let self_param_ty = tcx.types.self_param;\n+        let superbounds1 = if let Some(assoc_name) = assoc_name {\n+            AstConv::compute_bounds_that_match_assoc_type(\n+                &icx,\n+                self_param_ty,\n+                &bounds,\n+                SizedByDefault::No,\n+                item.span,\n+                assoc_name,\n+            )\n+        } else {\n+            let bounds: Vec<_> = bounds.iter().collect();\n+            AstConv::compute_bounds(&icx, self_param_ty, &bounds, SizedByDefault::No, item.span)\n+        };\n+\n+        let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n+\n+        // Convert any explicit superbounds in the where-clause,\n+        // e.g., `trait Foo where Self: Bar`.\n+        // In the case of trait aliases, however, we include all bounds in the where-clause,\n+        // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n+        // as one of its \"superpredicates\".\n+        let is_trait_alias = tcx.is_trait_alias(trait_def_id);\n+        let superbounds2 = icx.type_parameter_bounds_in_generics(\n+            generics,\n+            item.hir_id,\n+            self_param_ty,\n+            OnlySelfBounds(!is_trait_alias),\n+            assoc_name,\n+        );\n+\n+        // Combine the two lists to form the complete set of superbounds:\n+        let superbounds = &*tcx.arena.alloc_from_iter(superbounds1.into_iter().chain(superbounds2));\n+\n+        // Now require that immediate supertraits are converted,\n+        // which will, in turn, reach indirect supertraits.\n+        if assoc_name.is_none() {\n+            // FIXME: move this into the `super_predicates_of` query\n+            for &(pred, span) in superbounds {\n+                debug!(\"superbound: {:?}\", pred);\n+                if let ty::PredicateAtom::Trait(bound, _) = pred.skip_binders() {\n+                    tcx.at(span).super_predicates_of(bound.def_id());\n+                }\n+            }\n         }\n-    }\n \n-    ty::GenericPredicates { parent: None, predicates: superbounds }\n+        ty::GenericPredicates { parent: None, predicates: superbounds }\n+    } else {\n+        // if `assoc_name` is None, then the query should've been redirected to an\n+        // external provider\n+        assert!(assoc_name.is_some());\n+        tcx.super_predicates_of(trait_def_id)\n+    }\n }\n \n pub fn super_traits_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> impl Iterator<Item = DefId> {\n@@ -1123,6 +1154,8 @@ pub fn super_traits_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> impl Iterator<It\n             }\n         }\n     }\n+\n+    set.into_iter()\n }\n \n fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n@@ -1976,8 +2009,8 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 index += 1;\n \n                 let sized = SizedByDefault::Yes;\n-                let bounds =\n-                    AstConv::compute_bounds(&icx, param_ty, &param.bounds, sized, param.span);\n+                let bounds: Vec<_> = param.bounds.iter().collect();\n+                let bounds = AstConv::compute_bounds(&icx, param_ty, &bounds, sized, param.span);\n                 predicates.extend(bounds.predicates(tcx, param_ty));\n             }\n             GenericParamKind::Const { .. } => {"}, {"sha": "62586d793b4685329236b4017757d9de95e3bdb5", "filename": "compiler/rustc_typeck/src/collect/item_bounds.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ca4964db5d263a8f9222846bd70a7f26cf414cf/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca4964db5d263a8f9222846bd70a7f26cf414cf/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=2ca4964db5d263a8f9222846bd70a7f26cf414cf", "patch": "@@ -25,10 +25,11 @@ fn associated_type_bounds<'tcx>(\n         InternalSubsts::identity_for_item(tcx, assoc_item_def_id),\n     );\n \n+    let bounds: Vec<_> = bounds.iter().collect();\n     let bounds = AstConv::compute_bounds(\n         &ItemCtxt::new(tcx, assoc_item_def_id),\n         item_ty,\n-        bounds,\n+        &bounds,\n         SizedByDefault::Yes,\n         span,\n     );\n@@ -65,10 +66,11 @@ fn opaque_type_bounds<'tcx>(\n         let item_ty =\n             tcx.mk_opaque(opaque_def_id, InternalSubsts::identity_for_item(tcx, opaque_def_id));\n \n+        let bounds: Vec<_> = bounds.iter().collect();\n         let bounds = AstConv::compute_bounds(\n             &ItemCtxt::new(tcx, opaque_def_id),\n             item_ty,\n-            bounds,\n+            &bounds,\n             SizedByDefault::Yes,\n             span,\n         )"}, {"sha": "c82ec01f4d61db9b99f8a00d3adb039f1618f685", "filename": "src/test/ui/associated-type-bounds/super-trait-referencing-self.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ca4964db5d263a8f9222846bd70a7f26cf414cf/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca4964db5d263a8f9222846bd70a7f26cf414cf/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing-self.rs?ref=2ca4964db5d263a8f9222846bd70a7f26cf414cf", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+trait Foo {\n+    type Bar;\n+}\n+trait Qux: Foo + AsRef<Self::Bar> {}\n+trait Foo2 {}\n+\n+trait Qux2: Foo2 + AsRef<Self::Bar> {\n+    type Bar;\n+}\n+\n+fn main() {}"}]}