{"sha": "5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a", "node_id": "C_kwDOAAsO6NoAKDVjOTVhM2RiMmFjNTRjOTRiMDM3ZTBiMWI4NGQyOWIxMmNjZjhlN2E", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-06-02T13:15:01Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-06-14T14:08:11Z"}, "message": "fix clippy test failures", "tree": {"sha": "4bffe9b92f242f56aedcca7365634e0438251e19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bffe9b92f242f56aedcca7365634e0438251e19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a", "html_url": "https://github.com/rust-lang/rust/commit/5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "705d818bd52a6324d5e7693cc4306457395eebc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/705d818bd52a6324d5e7693cc4306457395eebc8", "html_url": "https://github.com/rust-lang/rust/commit/705d818bd52a6324d5e7693cc4306457395eebc8"}], "stats": {"total": 176, "additions": 111, "deletions": 65}, "files": [{"sha": "fe5c5be15f5a31f3259e6700322cb3464f9e23c8", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a", "patch": "@@ -199,6 +199,14 @@ impl<'tcx> Const<'tcx> {\n         tcx.mk_const(ConstS { kind: ConstKind::Value(val), ty })\n     }\n \n+    /// Panics if self.kind != ty::ConstKind::Value\n+    pub fn to_valtree(self) -> ty::ValTree<'tcx> {\n+        match self.val() {\n+            ty::ConstKind::Value(valtree) => valtree,\n+            _ => bug!(\"expected ConstKind::Value\"),\n+        }\n+    }\n+\n     pub fn from_scalar_int(tcx: TyCtxt<'tcx>, i: ScalarInt, ty: Ty<'tcx>) -> Self {\n         let valtree = ty::ValTree::from_scalar_int(i);\n         Self::from_value(tcx, valtree, ty)"}, {"sha": "f5d957e30ff09813ca8ac28de0b7338610e11af3", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a", "patch": "@@ -798,7 +798,7 @@ pub(crate) fn compare_const_vals<'tcx>(\n     if let ty::Str = ty.kind() && let (\n         Some(a_val @ ConstValue::Slice { .. }),\n         Some(b_val @ ConstValue::Slice { .. }),\n-    ) = (a.try_val(tcx), b.try_val(tcx))\n+    ) = (a.try_to_value(tcx), b.try_to_value(tcx))\n     {\n         let a_bytes = get_slice_bytes(&tcx, a_val);\n         let b_bytes = get_slice_bytes(&tcx, b_val);"}, {"sha": "b326d864d4bff9b00d978e4b78797a1bec8b3a09", "filename": "src/tools/clippy/clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs?ref=5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a", "patch": "@@ -48,9 +48,9 @@ impl<'tcx> LateLintPass<'tcx> for UnportableVariant {\n                     let mut ty = cx.tcx.type_of(def_id.to_def_id());\n                     let constant = cx\n                         .tcx\n-                        .const_eval_poly_for_typeck(def_id.to_def_id())\n+                        .const_eval_poly(def_id.to_def_id())\n                         .ok()\n-                        .and_then(|val| val.map(|valtree| rustc_middle::ty::Const::from_value(cx.tcx, valtree, ty)));\n+                        .and_then(|val| Some(rustc_middle::mir::ConstantKind::from_value(val, ty)));\n                     if let Some(Constant::Int(val)) = constant.and_then(|c| miri_to_const(cx.tcx, c)) {\n                         if let ty::Adt(adt, _) = ty.kind() {\n                             if adt.is_enum() {"}, {"sha": "ae69ca8a3393d57bc1ca1bee59f98cf61211afba", "filename": "src/tools/clippy/clippy_lints/src/matches/overlapping_arms.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs?ref=5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a", "patch": "@@ -3,6 +3,7 @@ use clippy_utils::diagnostics::span_lint_and_note;\n use core::cmp::Ordering;\n use rustc_hir::{Arm, Expr, PatKind, RangeEnd};\n use rustc_lint::LateContext;\n+use rustc_middle::mir;\n use rustc_middle::ty::Ty;\n use rustc_span::Span;\n \n@@ -34,11 +35,25 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                 if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n                     let lhs_const = match lhs {\n                         Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n-                        None => miri_to_const(cx.tcx, ty.numeric_min_val(cx.tcx)?)?,\n+                        None => {\n+                            let min_val_const = ty.numeric_min_val(cx.tcx)?;\n+                            let min_constant = mir::ConstantKind::from_value(\n+                                cx.tcx.valtree_to_const_val((ty, min_val_const.to_valtree())),\n+                                ty,\n+                            );\n+                            miri_to_const(cx.tcx, min_constant)?\n+                        },\n                     };\n                     let rhs_const = match rhs {\n                         Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n-                        None => miri_to_const(cx.tcx, ty.numeric_max_val(cx.tcx)?)?,\n+                        None => {\n+                            let max_val_const = ty.numeric_max_val(cx.tcx)?;\n+                            let max_constant = mir::ConstantKind::from_value(\n+                                cx.tcx.valtree_to_const_val((ty, max_val_const.to_valtree())),\n+                                ty,\n+                            );\n+                            miri_to_const(cx.tcx, max_constant)?\n+                        },\n                     };\n                     let lhs_val = lhs_const.int_value(cx, ty)?;\n                     let rhs_val = rhs_const.int_value(cx, ty)?;"}, {"sha": "7163cfe5e3a2c774911023904da8de297ebc346a", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a", "patch": "@@ -13,9 +13,10 @@ use rustc_hir::{\n     BodyId, Expr, ExprKind, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind, Node, TraitItem, TraitItemKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass, Lint};\n-use rustc_middle::mir::interpret::ErrorHandled;\n+use rustc_middle::mir;\n+use rustc_middle::mir::interpret::{ConstValue, ErrorHandled};\n use rustc_middle::ty::adjustment::Adjust;\n-use rustc_middle::ty::{self, Const, Ty};\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{InnerSpan, Span, DUMMY_SP};\n use rustc_typeck::hir_ty_to_ty;\n@@ -133,22 +134,21 @@ fn is_unfrozen<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n \n fn is_value_unfrozen_raw<'tcx>(\n     cx: &LateContext<'tcx>,\n-    result: Result<Option<ty::ValTree<'tcx>>, ErrorHandled>,\n+    result: Result<ConstValue<'tcx>, ErrorHandled>,\n     ty: Ty<'tcx>,\n ) -> bool {\n-    fn inner<'tcx>(cx: &LateContext<'tcx>, val: Const<'tcx>) -> bool {\n+    fn inner<'tcx>(cx: &LateContext<'tcx>, val: mir::ConstantKind<'tcx>) -> bool {\n         match val.ty().kind() {\n             // the fact that we have to dig into every structs to search enums\n             // leads us to the point checking `UnsafeCell` directly is the only option.\n             ty::Adt(ty_def, ..) if Some(ty_def.did()) == cx.tcx.lang_items().unsafe_cell_type() => true,\n             ty::Array(..) | ty::Adt(..) | ty::Tuple(..) => {\n-                let val = cx.tcx.destructure_const(val);\n+                let val = cx.tcx.destructure_mir_constant(cx.param_env, val);\n                 val.fields.iter().any(|field| inner(cx, *field))\n             },\n             _ => false,\n         }\n     }\n-\n     result.map_or_else(\n         |err| {\n             // Consider `TooGeneric` cases as being unfrozen.\n@@ -174,19 +174,19 @@ fn is_value_unfrozen_raw<'tcx>(\n             // I chose this way because unfrozen enums as assoc consts are rare (or, hopefully, none).\n             err == ErrorHandled::TooGeneric\n         },\n-        |val| val.map_or(false, |val| inner(cx, Const::from_value(cx.tcx, val, ty))),\n+        |val| inner(cx, mir::ConstantKind::from_value(val, ty)),\n     )\n }\n \n fn is_value_unfrozen_poly<'tcx>(cx: &LateContext<'tcx>, body_id: BodyId, ty: Ty<'tcx>) -> bool {\n-    let result = cx.tcx.const_eval_poly_for_typeck(body_id.hir_id.owner.to_def_id());\n+    let result = cx.tcx.const_eval_poly(body_id.hir_id.owner.to_def_id());\n     is_value_unfrozen_raw(cx, result, ty)\n }\n \n fn is_value_unfrozen_expr<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId, def_id: DefId, ty: Ty<'tcx>) -> bool {\n     let substs = cx.typeck_results().node_substs(hir_id);\n \n-    let result = cx.tcx.const_eval_resolve_for_typeck(\n+    let result = cx.tcx.const_eval_resolve(\n         cx.param_env,\n         ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs),\n         None,"}, {"sha": "ec323806fbf93cd79adefcb83b0806544cf016ad", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 74, "deletions": 51, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=5c95a3db2ac54c94b037e0b1b84d29b12ccf8e7a", "patch": "@@ -7,6 +7,8 @@ use rustc_data_structures::sync::Lrc;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, Item, ItemKind, Node, QPath, UnOp};\n use rustc_lint::LateContext;\n+use rustc_middle::mir;\n+use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n use rustc_middle::ty::{self, EarlyBinder, FloatTy, ScalarInt, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug};\n@@ -422,13 +424,13 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                 let result = self\n                     .lcx\n                     .tcx\n-                    .const_eval_resolve_for_typeck(\n+                    .const_eval_resolve(\n                         self.param_env,\n                         ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs),\n                         None,\n                     )\n                     .ok()\n-                    .and_then(|val| val.map(|val| rustc_middle::ty::Const::from_value(self.lcx.tcx, val, ty)))?;\n+                    .and_then(|val| Some(rustc_middle::mir::ConstantKind::from_value(val, ty)))?;\n                 let result = miri_to_const(self.lcx.tcx, result);\n                 if result.is_some() {\n                     self.needed_resolution = true;\n@@ -579,69 +581,90 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n     }\n }\n \n-pub fn miri_to_const<'tcx>(tcx: TyCtxt<'tcx>, result: ty::Const<'tcx>) -> Option<Constant> {\n-    match result.kind() {\n+fn try_const_to_constant<'tcx>(tcx: TyCtxt<'tcx>, c: ty::Const<'tcx>) -> Option<Constant> {\n+    match c.kind() {\n         ty::ConstKind::Value(valtree) => {\n-            match (valtree, result.ty().kind()) {\n-                (ty::ValTree::Leaf(int), ty::Bool) => Some(Constant::Bool(int == ScalarInt::TRUE)),\n-                (ty::ValTree::Leaf(int), ty::Uint(_) | ty::Int(_)) => Some(Constant::Int(int.assert_bits(int.size()))),\n-                (ty::ValTree::Leaf(int), ty::Float(FloatTy::F32)) => Some(Constant::F32(f32::from_bits(\n+            let const_val = tcx.valtree_to_const_val((c.ty(), valtree));\n+            miri_to_const(tcx, mir::ConstantKind::from_value(const_val, c.ty()))\n+        },\n+        _ => None,\n+    }\n+}\n+\n+pub fn miri_to_const<'tcx>(tcx: TyCtxt<'tcx>, result: mir::ConstantKind<'tcx>) -> Option<Constant> {\n+    use rustc_middle::mir::interpret::ConstValue;\n+    match result {\n+        mir::ConstantKind::Val(ConstValue::Scalar(Scalar::Int(int)), _) => {\n+            match result.ty().kind() {\n+                ty::Bool => Some(Constant::Bool(int == ScalarInt::TRUE)),\n+                ty::Uint(_) | ty::Int(_) => Some(Constant::Int(int.assert_bits(int.size()))),\n+                ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n                     int.try_into().expect(\"invalid f32 bit representation\"),\n                 ))),\n-                (ty::ValTree::Leaf(int), ty::Float(FloatTy::F64)) => Some(Constant::F64(f64::from_bits(\n+                ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(\n                     int.try_into().expect(\"invalid f64 bit representation\"),\n                 ))),\n-                (ty::ValTree::Leaf(int), ty::RawPtr(type_and_mut)) => {\n+                ty::RawPtr(type_and_mut) => {\n                     if let ty::Uint(_) = type_and_mut.ty.kind() {\n                         return Some(Constant::RawPtr(int.assert_bits(int.size())));\n                     }\n                     None\n                 },\n-                (ty::ValTree::Branch(_), ty::Ref(_, inner_ty, _)) if *inner_ty == tcx.types.str_ => valtree\n-                    .try_to_raw_bytes(tcx, result.ty())\n-                    .and_then(|bytes| String::from_utf8(bytes.to_owned()).ok().map(Constant::Str)),\n-                (ty::ValTree::Branch(_), ty::Array(arr_ty, len)) => match arr_ty.kind() {\n-                    ty::Float(float_ty) => {\n-                        let chunk_size = match float_ty {\n-                            FloatTy::F32 => 4,\n-                            FloatTy::F64 => 8,\n-                        };\n-\n-                        match miri_to_const(tcx, *len) {\n-                            Some(Constant::Int(_)) => valtree.try_to_raw_bytes(tcx, result.ty()).and_then(|bytes| {\n-                                bytes\n-                                    .to_owned()\n-                                    .chunks(chunk_size)\n-                                    .map(|chunk| match float_ty {\n-                                        FloatTy::F32 => {\n-                                            let float = f32::from_le_bytes(\n-                                                chunk\n-                                                    .try_into()\n-                                                    .expect(&format!(\"expected to construct f32 from {:?}\", chunk)),\n-                                            );\n-                                            Some(Constant::F32(float))\n-                                        },\n-                                        FloatTy::F64 => {\n-                                            let float = f64::from_le_bytes(\n-                                                chunk\n-                                                    .try_into()\n-                                                    .expect(&format!(\"expected to construct f64 from {:?}\", chunk)),\n-                                            );\n-                                            Some(Constant::F64(float))\n-                                        },\n-                                    })\n-                                    .collect::<Option<Vec<Constant>>>()\n-                                    .map(Constant::Vec)\n-                            }),\n-                            _ => None,\n-                        }\n-                    },\n-                    _ => None,\n-                },\n                 // FIXME: implement other conversions.\n                 _ => None,\n             }\n         },\n+        mir::ConstantKind::Val(ConstValue::Slice { data, start, end }, _) => match result.ty().kind() {\n+            ty::Ref(_, tam, _) => match tam.kind() {\n+                ty::Str => String::from_utf8(\n+                    data.inner()\n+                        .inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n+                        .to_owned(),\n+                )\n+                .ok()\n+                .map(Constant::Str),\n+                _ => None,\n+            },\n+            _ => None,\n+        },\n+        mir::ConstantKind::Val(ConstValue::ByRef { alloc, offset: _ }, _) => match result.ty().kind() {\n+            ty::Array(sub_type, len) => match sub_type.kind() {\n+                ty::Float(FloatTy::F32) => match try_const_to_constant(tcx, *len) {\n+                    Some(Constant::Int(len)) => alloc\n+                        .inner()\n+                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))\n+                        .to_owned()\n+                        .chunks(4)\n+                        .map(|chunk| {\n+                            Some(Constant::F32(f32::from_le_bytes(\n+                                chunk.try_into().expect(\"this shouldn't happen\"),\n+                            )))\n+                        })\n+                        .collect::<Option<Vec<Constant>>>()\n+                        .map(Constant::Vec),\n+                    _ => None,\n+                },\n+                ty::Float(FloatTy::F64) => match try_const_to_constant(tcx, *len) {\n+                    Some(Constant::Int(len)) => alloc\n+                        .inner()\n+                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * len as usize))\n+                        .to_owned()\n+                        .chunks(8)\n+                        .map(|chunk| {\n+                            Some(Constant::F64(f64::from_le_bytes(\n+                                chunk.try_into().expect(\"this shouldn't happen\"),\n+                            )))\n+                        })\n+                        .collect::<Option<Vec<Constant>>>()\n+                        .map(Constant::Vec),\n+                    _ => None,\n+                },\n+                // FIXME: implement other array type conversions.\n+                _ => None,\n+            },\n+            _ => None,\n+        },\n+        // FIXME: implement other conversions.\n         _ => None,\n     }\n }"}]}