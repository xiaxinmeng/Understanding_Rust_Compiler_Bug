{"sha": "47f24a881bb05293c4d922218d9dfed7e29511cd", "node_id": "C_kwDOAAsO6NoAKDQ3ZjI0YTg4MWJiMDUyOTNjNGQ5MjIyMThkOWRmZWQ3ZTI5NTExY2Q", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-03-21T15:26:23Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-03-21T15:27:25Z"}, "message": "new solver cleanup + coherence", "tree": {"sha": "2b21c0b522bba2112ff0185a0d75e521af151d0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b21c0b522bba2112ff0185a0d75e521af151d0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47f24a881bb05293c4d922218d9dfed7e29511cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47f24a881bb05293c4d922218d9dfed7e29511cd", "html_url": "https://github.com/rust-lang/rust/commit/47f24a881bb05293c4d922218d9dfed7e29511cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47f24a881bb05293c4d922218d9dfed7e29511cd/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "url": "https://api.github.com/repos/rust-lang/rust/commits/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34", "html_url": "https://github.com/rust-lang/rust/commit/a01b4cc9f375f1b95fa8195daeea938d3d9c4c34"}], "stats": {"total": 255, "additions": 203, "deletions": 52}, "files": [{"sha": "f47f4cbdb4db7a6e157c4b0795c3b9bc60ffece4", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -63,14 +63,13 @@ impl Certainty {\n             (Certainty::Yes, Certainty::Yes) => Certainty::Yes,\n             (Certainty::Yes, Certainty::Maybe(_)) => other,\n             (Certainty::Maybe(_), Certainty::Yes) => self,\n-            (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Overflow)) => {\n+            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(MaybeCause::Ambiguity)) => {\n                 Certainty::Maybe(MaybeCause::Overflow)\n             }\n-            // If at least one of the goals is ambiguous, hide the overflow as the ambiguous goal\n-            // may still result in failure.\n-            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(_))\n-            | (Certainty::Maybe(_), Certainty::Maybe(MaybeCause::Ambiguity)) => {\n-                Certainty::Maybe(MaybeCause::Ambiguity)\n+            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(MaybeCause::Overflow))\n+            | (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Ambiguity))\n+            | (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Overflow)) => {\n+                Certainty::Maybe(MaybeCause::Overflow)\n             }\n         }\n     }"}, {"sha": "8cb09108e83ca5e3bb4a53cf3cb882a0b82e2048", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -2,7 +2,8 @@\n \n #[cfg(doc)]\n use super::trait_goals::structural_traits::*;\n-use super::EvalCtxt;\n+use super::{EvalCtxt, SolverMode};\n+use crate::traits::coherence;\n use itertools::Itertools;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n@@ -87,6 +88,8 @@ pub(super) enum CandidateSource {\n pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n     fn self_ty(self) -> Ty<'tcx>;\n \n+    fn trait_ref(self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx>;\n+\n     fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self;\n \n     fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n@@ -244,15 +247,16 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         self.assemble_object_bound_candidates(goal, &mut candidates);\n \n+        self.assemble_coherence_unknowable_candidates(goal, &mut candidates);\n+\n         candidates\n     }\n \n     /// If the self type of a goal is a projection, computing the relevant candidates is difficult.\n     ///\n     /// To deal with this, we first try to normalize the self type and add the candidates for the normalized\n-    /// self type to the list of candidates in case that succeeds. Note that we can't just eagerly return in\n-    /// this case as projections as self types add\n-    // FIXME complete the unfinished sentence above\n+    /// self type to the list of candidates in case that succeeds. We also have to consider candidates with the\n+    /// projection as a self type as well\n     fn assemble_candidates_after_normalizing_self_ty<G: GoalKind<'tcx>>(\n         &mut self,\n         goal: Goal<'tcx, G>,\n@@ -468,25 +472,49 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    fn assemble_coherence_unknowable_candidates<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        match self.solver_mode() {\n+            SolverMode::Normal => return,\n+            SolverMode::Coherence => {\n+                let trait_ref = goal.predicate.trait_ref(self.tcx());\n+                match coherence::trait_ref_is_knowable(self.tcx(), trait_ref) {\n+                    Ok(()) => {}\n+                    Err(_) => match self\n+                        .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+                    {\n+                        Ok(result) => candidates\n+                            .push(Candidate { source: CandidateSource::BuiltinImpl, result }),\n+                        // FIXME: This will be reachable at some point if we're in\n+                        // `assemble_candidates_after_normalizing_self_ty` and we get a\n+                        // universe error. We'll deal with it at this point.\n+                        Err(NoSolution) => bug!(\"coherence candidate resulted in NoSolution\"),\n+                    },\n+                }\n+            }\n+        }\n+    }\n+\n     #[instrument(level = \"debug\", skip(self), ret)]\n-    pub(super) fn merge_candidates_and_discard_reservation_impls(\n+    pub(super) fn merge_candidates(\n         &mut self,\n         mut candidates: Vec<Candidate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         match candidates.len() {\n             0 => return Err(NoSolution),\n-            1 => return Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result),\n+            1 => return Ok(candidates.pop().unwrap().result),\n             _ => {}\n         }\n \n         if candidates.len() > 1 {\n             let mut i = 0;\n             'outer: while i < candidates.len() {\n                 for j in (0..candidates.len()).filter(|&j| i != j) {\n-                    if self.trait_candidate_should_be_dropped_in_favor_of(\n-                        &candidates[i],\n-                        &candidates[j],\n-                    ) {\n+                    if self.candidate_should_be_dropped_in_favor_of(&candidates[i], &candidates[j])\n+                    {\n                         debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n                         candidates.swap_remove(i);\n                         continue 'outer;\n@@ -511,11 +539,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             }\n         }\n \n-        // FIXME: What if there are >1 candidates left with the same response, and one is a reservation impl?\n-        Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result)\n+        Ok(candidates.pop().unwrap().result)\n     }\n \n-    fn trait_candidate_should_be_dropped_in_favor_of(\n+    fn candidate_should_be_dropped_in_favor_of(\n         &self,\n         candidate: &Candidate<'tcx>,\n         other: &Candidate<'tcx>,\n@@ -528,20 +555,4 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             | (CandidateSource::BuiltinImpl, _) => false,\n         }\n     }\n-\n-    fn discard_reservation_impl(&mut self, mut candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n-        if let CandidateSource::Impl(def_id) = candidate.source {\n-            if let ty::ImplPolarity::Reservation = self.tcx().impl_polarity(def_id) {\n-                debug!(\"Selected reservation impl\");\n-                // We assemble all candidates inside of a probe so by\n-                // making a new canonical response here our result will\n-                // have no constraints.\n-                candidate.result = self\n-                    .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n-                    .unwrap();\n-            }\n-        }\n-\n-        candidate\n-    }\n }"}, {"sha": "4b85be69e61bd436c7b54d1a636af24e904b59b8", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -17,6 +17,7 @@ use rustc_span::DUMMY_SP;\n use std::ops::ControlFlow;\n \n use super::search_graph::{self, OverflowHandler};\n+use super::SolverMode;\n use super::{search_graph::SearchGraph, Goal};\n \n pub struct EvalCtxt<'a, 'tcx> {\n@@ -78,7 +79,9 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n         &self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n     ) -> Result<(bool, Certainty), NoSolution> {\n-        let mut search_graph = search_graph::SearchGraph::new(self.tcx);\n+        let mode = if self.intercrate { SolverMode::Coherence } else { SolverMode::Normal };\n+\n+        let mut search_graph = search_graph::SearchGraph::new(self.tcx, mode);\n \n         let mut ecx = EvalCtxt {\n             search_graph: &mut search_graph,\n@@ -101,6 +104,10 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n }\n \n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n+    pub(super) fn solver_mode(&self) -> SolverMode {\n+        self.search_graph.solver_mode()\n+    }\n+\n     /// The entry point of the solver.\n     ///\n     /// This function deals with (coinductive) cycles, overflow, and caching"}, {"sha": "89f4056a58db42436eb204d98f1584e1a50f31dd", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -9,10 +9,6 @@\n //! FIXME(@lcnr): Write that section. If you read this before then ask me\n //! about it on zulip.\n \n-// FIXME: Instead of using `infcx.canonicalize_query` we have to add a new routine which\n-// preserves universes and creates a unique var (in the highest universe) for each\n-// appearance of a region.\n-\n // FIXME: uses of `infcx.at` need to enable deferred projection equality once that's implemented.\n \n use rustc_hir::def_id::DefId;\n@@ -41,6 +37,19 @@ mod trait_goals;\n pub use eval_ctxt::{EvalCtxt, InferCtxtEvalExt};\n pub use fulfill::FulfillmentCtxt;\n \n+#[derive(Debug, Clone, Copy)]\n+enum SolverMode {\n+    /// Ordinary trait solving, using everywhere except for coherence.\n+    Normal,\n+    /// Trait solving during coherence. There are a few notable differences\n+    /// between coherence and ordinary trait solving.\n+    ///\n+    /// Most importantly, trait solving during coherence must not be incomplete,\n+    /// i.e. return `Err(NoSolution)` for goals for which a solution exists.\n+    /// This means that we must not make any guesses or arbitrary choices.\n+    Coherence,\n+}\n+\n trait CanonicalResponseExt {\n     fn has_no_inference_or_external_constraints(&self) -> bool;\n }\n@@ -255,7 +264,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             return Err(NoSolution);\n         }\n \n-        // FIXME(-Ztreat-solver=next): We should instead try to find a `Certainty::Yes` response with\n+        // FIXME(-Ztrait-solver=next): We should instead try to find a `Certainty::Yes` response with\n         // a subset of the constraints that all the other responses have.\n         let one = candidates[0];\n         if candidates[1..].iter().all(|resp| resp == &one) {"}, {"sha": "998859966528b2e1b8a19cc31ff39855271f62e8", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -34,7 +34,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         // projection cache in the solver.\n         if self.term_is_fully_unconstrained(goal) {\n             let candidates = self.assemble_and_evaluate_candidates(goal);\n-            self.merge_candidates_and_discard_reservation_impls(candidates)\n+            self.merge_candidates(candidates)\n         } else {\n             let predicate = goal.predicate;\n             let unconstrained_rhs = self.next_term_infer_of_kind(predicate.term);\n@@ -56,6 +56,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         self.self_ty()\n     }\n \n+    fn trait_ref(self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n+        self.projection_ty.trait_ref(tcx)\n+    }\n+\n     fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n         self.with_self_ty(tcx, self_ty)\n     }"}, {"sha": "b94c44cbdd03811a0925b8eb8a112a451de6d39f", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -1,8 +1,9 @@\n mod cache;\n mod overflow;\n \n+pub(super) use overflow::OverflowHandler;\n+\n use self::cache::ProvisionalEntry;\n-pub(super) use crate::solve::search_graph::overflow::OverflowHandler;\n use cache::ProvisionalCache;\n use overflow::OverflowData;\n use rustc_index::vec::IndexVec;\n@@ -11,6 +12,8 @@ use rustc_middle::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryRes\n use rustc_middle::ty::TyCtxt;\n use std::{collections::hash_map::Entry, mem};\n \n+use super::SolverMode;\n+\n rustc_index::newtype_index! {\n     pub struct StackDepth {}\n }\n@@ -21,6 +24,7 @@ struct StackElem<'tcx> {\n }\n \n pub(super) struct SearchGraph<'tcx> {\n+    mode: SolverMode,\n     /// The stack of goals currently being computed.\n     ///\n     /// An element is *deeper* in the stack if its index is *lower*.\n@@ -30,14 +34,19 @@ pub(super) struct SearchGraph<'tcx> {\n }\n \n impl<'tcx> SearchGraph<'tcx> {\n-    pub(super) fn new(tcx: TyCtxt<'tcx>) -> SearchGraph<'tcx> {\n+    pub(super) fn new(tcx: TyCtxt<'tcx>, mode: SolverMode) -> SearchGraph<'tcx> {\n         Self {\n+            mode,\n             stack: Default::default(),\n             overflow_data: OverflowData::new(tcx),\n             provisional_cache: ProvisionalCache::empty(),\n         }\n     }\n \n+    pub(super) fn solver_mode(&self) -> SolverMode {\n+        self.mode\n+    }\n+\n     pub(super) fn is_empty(&self) -> bool {\n         self.stack.is_empty() && self.provisional_cache.is_empty()\n     }"}, {"sha": "2ebdfc8fe72a168e6747cd86a86b55e189100bbc", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -2,7 +2,7 @@\n \n use std::iter;\n \n-use super::{assembly, EvalCtxt};\n+use super::{assembly, EvalCtxt, SolverMode};\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n use rustc_infer::traits::query::NoSolution;\n@@ -20,6 +20,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         self.self_ty()\n     }\n \n+    fn trait_ref(self, _: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n+        self.trait_ref\n+    }\n+\n     fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n         self.with_self_ty(tcx, self_ty)\n     }\n@@ -43,6 +47,22 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             return Err(NoSolution);\n         }\n \n+        let impl_polarity = tcx.impl_polarity(impl_def_id);\n+        // An upper bound of the certainty of this goal, used to lower the certainty\n+        // of reservation impl to ambiguous during coherence.\n+        let maximal_certainty = match impl_polarity {\n+            ty::ImplPolarity::Positive | ty::ImplPolarity::Negative => {\n+                match impl_polarity == goal.predicate.polarity {\n+                    true => Certainty::Yes,\n+                    false => return Err(NoSolution),\n+                }\n+            }\n+            ty::ImplPolarity::Reservation => match ecx.solver_mode() {\n+                SolverMode::Normal => return Err(NoSolution),\n+                SolverMode::Coherence => Certainty::AMBIGUOUS,\n+            },\n+        };\n+\n         ecx.probe(|ecx| {\n             let impl_substs = ecx.fresh_substs_for_item(impl_def_id);\n             let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n@@ -55,7 +75,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                 .into_iter()\n                 .map(|pred| goal.with(tcx, pred));\n             ecx.add_goals(where_clause_bounds);\n-            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+\n+            ecx.evaluate_added_goals_and_make_canonical_response(maximal_certainty)\n         })\n     }\n \n@@ -547,6 +568,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         goal: Goal<'tcx, TraitPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         let candidates = self.assemble_and_evaluate_candidates(goal);\n-        self.merge_candidates_and_discard_reservation_impls(candidates)\n+        self.merge_candidates(candidates)\n     }\n }"}, {"sha": "2de420b52940ae32ec421a9dcf9b6d72010bde8c", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -4,7 +4,7 @@\n \n pub mod auto_trait;\n mod chalk_fulfill;\n-mod coherence;\n+pub(crate) mod coherence;\n pub mod const_evaluatable;\n mod engine;\n pub mod error_reporting;"}, {"sha": "11636bfeb55095bef82786977005e554f45b2dd9", "filename": "tests/ui/traits/new-solver/coherence/issue-102048.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.rs?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -0,0 +1,44 @@\n+// This must fail coherence.\n+//\n+// Getting this to pass was fairly difficult, so here's an explanation\n+// of what's happening:\n+//\n+// Normalizing projections currently tries to replace them with inference variables\n+// while emitting a nested `Projection` obligation. This cannot be done if the projection\n+// has bound variables which is the case here.\n+//\n+// So the projections stay until after normalization. When unifying two projections we\n+// currently treat them as if they are injective, so we **incorrectly** unify their\n+// substs. This means that coherence for the two impls ends up unifying `?T` and `?U`\n+// as it tries to unify `<?T as WithAssoc1<'a>>::Assoc` with `<?U as WithAssoc1<'a>>::Assoc`.\n+//\n+// `impl1` therefore has the projection `<?T as WithAssoc2<'a>>::Assoc` and we have the\n+// assumption `?T: for<'a> WithAssoc2<'a, Assoc = i32>` in the `param_env`, so we normalize\n+// that to `i32`. We then try to unify `i32` from `impl1` with `u32` from `impl2` which fails,\n+// causing coherence to consider these two impls distinct.\n+\n+// compile-flags: -Ztrait-solver=next\n+pub trait Trait<T> {}\n+\n+pub trait WithAssoc1<'a> {\n+    type Assoc;\n+}\n+pub trait WithAssoc2<'a> {\n+    type Assoc;\n+}\n+\n+// impl 1\n+impl<T, U> Trait<for<'a> fn(<T as WithAssoc1<'a>>::Assoc, <U as WithAssoc2<'a>>::Assoc)> for (T, U)\n+where\n+    T: for<'a> WithAssoc1<'a> + for<'a> WithAssoc2<'a, Assoc = i32>,\n+    U: for<'a> WithAssoc2<'a>,\n+{\n+}\n+\n+// impl 2\n+impl<T, U> Trait<for<'a> fn(<U as WithAssoc1<'a>>::Assoc, u32)> for (T, U) where\n+    U: for<'a> WithAssoc1<'a> //~^ ERROR conflicting implementations of trait\n+{\n+}\n+\n+fn main() {}"}, {"sha": "17a43838fe2754d9c6bd20e23375e6fcbf24aec9", "filename": "tests/ui/traits/new-solver/coherence/issue-102048.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fcoherence%2Fissue-102048.stderr?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -0,0 +1,12 @@\n+error[E0119]: conflicting implementations of trait `Trait<for<'a> fn(<_ as WithAssoc1<'a>>::Assoc, <_ as WithAssoc2<'a>>::Assoc)>` for type `(_, _)`\n+  --> $DIR/issue-102048.rs:39:1\n+   |\n+LL | impl<T, U> Trait<for<'a> fn(<T as WithAssoc1<'a>>::Assoc, <U as WithAssoc2<'a>>::Assoc)> for (T, U)\n+   | --------------------------------------------------------------------------------------------------- first implementation here\n+...\n+LL | impl<T, U> Trait<for<'a> fn(<U as WithAssoc1<'a>>::Assoc, u32)> for (T, U) where\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(_, _)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "e5a3c3f5cc4b79db1bfd9d367e22c929caaa9984", "filename": "tests/ui/traits/reservation-impl/coherence-conflict.next.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.next.stderr?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -0,0 +1,11 @@\n+error[E0119]: conflicting implementations of trait `OtherTrait` for type `()`\n+  --> $DIR/coherence-conflict.rs:12:1\n+   |\n+LL | impl OtherTrait for () {}\n+   | ---------------------- first implementation here\n+LL | impl<T: MyTrait> OtherTrait for T {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "393350ea3f12a52f2a4b3a104566d671d242fc47", "filename": "tests/ui/traits/reservation-impl/coherence-conflict.old.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.old.stderr?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -1,5 +1,5 @@\n error[E0119]: conflicting implementations of trait `OtherTrait` for type `()`\n-  --> $DIR/coherence-conflict.rs:11:1\n+  --> $DIR/coherence-conflict.rs:12:1\n    |\n LL | impl OtherTrait for () {}\n    | ---------------------- first implementation here", "previous_filename": "tests/ui/traits/reservation-impl/coherence-conflict.stderr"}, {"sha": "6bbd90f94dc392a121f8b875bc34884ae87e2559", "filename": "tests/ui/traits/reservation-impl/coherence-conflict.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fcoherence-conflict.rs?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -1,5 +1,6 @@\n // check that reservation impls are accounted for in negative reasoning.\n-\n+// revisions: old next\n+//[next] compile-flags: -Ztrait-solver=next\n #![feature(rustc_attrs)]\n \n trait MyTrait {}"}, {"sha": "542e3a28adf280889af0e8607e11d88a67da5985", "filename": "tests/ui/traits/reservation-impl/no-use.next.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.next.stderr?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `(): MyTrait` is not satisfied\n-  --> $DIR/no-use.rs:10:26\n+  --> $DIR/no-use.rs:11:26\n    |\n LL |     <() as MyTrait>::foo(&());\n    |     -------------------- ^^^ the trait `MyTrait` is not implemented for `()`", "previous_filename": "tests/ui/traits/reservation-impl/no-use.stderr"}, {"sha": "542e3a28adf280889af0e8607e11d88a67da5985", "filename": "tests/ui/traits/reservation-impl/no-use.old.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.old.stderr?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -0,0 +1,13 @@\n+error[E0277]: the trait bound `(): MyTrait` is not satisfied\n+  --> $DIR/no-use.rs:11:26\n+   |\n+LL |     <() as MyTrait>::foo(&());\n+   |     -------------------- ^^^ the trait `MyTrait` is not implemented for `()`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+   = help: the trait `MyTrait` is implemented for `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "864f1791fd0a79ab3d1d184b3f72813a51a9dba5", "filename": "tests/ui/traits/reservation-impl/no-use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fno-use.rs?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -1,5 +1,6 @@\n // check that reservation impls can't be used as normal impls in positive reasoning.\n-\n+// revisions: old next\n+//[next] compile-flags: -Ztrait-solver=next\n #![feature(rustc_attrs)]\n \n trait MyTrait { fn foo(&self); }"}, {"sha": "7787904d9b22d581ce12b00a566e4526dfcdd340", "filename": "tests/ui/traits/reservation-impl/non-lattice-ok.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Freservation-impl%2Fnon-lattice-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Freservation-impl%2Fnon-lattice-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fnon-lattice-ok.rs?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -30,6 +30,12 @@\n //\n // [ii]: https://smallcultfollowing.com/babysteps/blog/2016/09/24/intersection-impls/\n \n+\n+// check that reservation impls can't be used as normal impls in positive reasoning.\n+\n+// revisions: old next\n+//[next] compile-flags: -Ztrait-solver=next\n+\n #![feature(rustc_attrs, never_type)]\n \n trait MyTrait {}"}, {"sha": "8ff6645a2b3d38d3398470c80cf9bd4ef2d5edb0", "filename": "tests/ui/traits/reservation-impl/ok.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Freservation-impl%2Fok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f24a881bb05293c4d922218d9dfed7e29511cd/tests%2Fui%2Ftraits%2Freservation-impl%2Fok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Freservation-impl%2Fok.rs?ref=47f24a881bb05293c4d922218d9dfed7e29511cd", "patch": "@@ -3,6 +3,9 @@\n // rpass test for reservation impls. Not 100% required because `From` uses them,\n // but still.\n \n+// revisions: old next\n+//[next] compile-flags: -Ztrait-solver=next\n+\n #![feature(rustc_attrs)]\n \n use std::mem;"}]}