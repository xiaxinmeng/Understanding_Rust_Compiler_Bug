{"sha": "35204025be872e5c15334e73fa1d488aaa3d69f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1MjA0MDI1YmU4NzJlNWMxNTMzNGU3M2ZhMWQ0ODhhYWEzZDY5ZjU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-01T20:16:31Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-07T04:33:14Z"}, "message": "Improve `PrivateItemsInPublicInterfacesVisitor`", "tree": {"sha": "ae38017772dc74a8218594dd3fbb0e8ea8477fac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae38017772dc74a8218594dd3fbb0e8ea8477fac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35204025be872e5c15334e73fa1d488aaa3d69f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35204025be872e5c15334e73fa1d488aaa3d69f5", "html_url": "https://github.com/rust-lang/rust/commit/35204025be872e5c15334e73fa1d488aaa3d69f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35204025be872e5c15334e73fa1d488aaa3d69f5/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e", "html_url": "https://github.com/rust-lang/rust/commit/0d34c5dd8a03fc18e43c7ec279169681eaa2ec4e"}], "stats": {"total": 194, "additions": 109, "deletions": 85}, "files": [{"sha": "47e8f91b48c61bc22ad2aaa76d892c69c641b841", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35204025be872e5c15334e73fa1d488aaa3d69f5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35204025be872e5c15334e73fa1d488aaa3d69f5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=35204025be872e5c15334e73fa1d488aaa3d69f5", "patch": "@@ -302,14 +302,25 @@ impl Visibility {\n             Visibility::Restricted(module) => module,\n         };\n \n-        let mut block_ancestor = map.get_module_parent(block);\n+        let mut block_ancestor = block;\n         loop {\n             if block_ancestor == restriction { return true }\n             let block_ancestor_parent = map.get_module_parent(block_ancestor);\n             if block_ancestor_parent == block_ancestor { return false }\n             block_ancestor = block_ancestor_parent;\n         }\n     }\n+\n+    /// Returns true if this visibility is at least as accessible as the given visibility\n+    pub fn is_at_least(self, vis: Visibility, map: &ast_map::Map) -> bool {\n+        let vis_restriction = match vis {\n+            Visibility::Public => return self == Visibility::Public,\n+            Visibility::PrivateExternal => return true,\n+            Visibility::Restricted(module) => module,\n+        };\n+\n+        self.is_accessible_from(vis_restriction, map)\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "a6ce4cc3ee41a443997e7cf8bf2e3823d63bf351", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 97, "deletions": 84, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/35204025be872e5c15334e73fa1d488aaa3d69f5/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35204025be872e5c15334e73fa1d488aaa3d69f5/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=35204025be872e5c15334e73fa1d488aaa3d69f5", "patch": "@@ -936,27 +936,41 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n \n struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n     tcx: &'a TyCtxt<'tcx>,\n-    // Do not report an error when a private type is found\n-    is_quiet: bool,\n-    // Is private component found?\n-    is_public: bool,\n+    /// The visitor checks that each component type is at least this visible\n+    required_visibility: ty::Visibility,\n+    /// The visibility of the least visible component that has been visited\n+    min_visibility: ty::Visibility,\n     old_error_set: &'a NodeSet,\n }\n \n impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n-    // Check if the type alias contain private types when substituted\n-    fn is_public_type_alias(&self, item: &hir::Item, path: &hir::Path) -> bool {\n+    fn new(tcx: &'a TyCtxt<'tcx>, old_error_set: &'a NodeSet) -> Self {\n+        SearchInterfaceForPrivateItemsVisitor {\n+            tcx: tcx,\n+            min_visibility: ty::Visibility::Public,\n+            required_visibility: ty::Visibility::PrivateExternal,\n+            old_error_set: old_error_set,\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n+    // Return the visibility of the type alias's least visible component type when substituted\n+    fn substituted_alias_visibility(&self, item: &hir::Item, path: &hir::Path)\n+                                    -> Option<ty::Visibility> {\n         // We substitute type aliases only when determining impl publicity\n         // FIXME: This will probably change and all type aliases will be substituted,\n         // requires an amendment to RFC 136.\n-        if !self.is_quiet {\n-            return false\n+        if self.required_visibility != ty::Visibility::PrivateExternal {\n+            return None;\n         }\n         // Type alias is considered public if the aliased type is\n         // public, even if the type alias itself is private. So, something\n         // like `type A = u8; pub fn f() -> A {...}` doesn't cause an error.\n         if let hir::ItemTy(ref ty, ref generics) = item.node {\n-            let mut check = SearchInterfaceForPrivateItemsVisitor { is_public: true, ..*self };\n+            let mut check = SearchInterfaceForPrivateItemsVisitor {\n+                min_visibility: ty::Visibility::Public, ..*self\n+            };\n             check.visit_ty(ty);\n             // If a private type alias with default type parameters is used in public\n             // interface we must ensure, that the defaults are public if they are actually used.\n@@ -970,26 +984,23 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n                     check.visit_ty(default_ty);\n                 }\n             }\n-            check.is_public\n+            Some(check.min_visibility)\n         } else {\n-            false\n+            None\n         }\n     }\n }\n \n impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n-        if self.is_quiet && !self.is_public {\n-            // We are in quiet mode and a private type is already found, no need to proceed\n-            return\n-        }\n         if let hir::TyPath(_, ref path) = ty.node {\n             let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n             match def {\n                 Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n                     // Public\n                 }\n-                Def::AssociatedTy(..) if self.is_quiet => {\n+                Def::AssociatedTy(..)\n+                    if self.required_visibility == ty::Visibility::PrivateExternal => {\n                     // Conservatively approximate the whole type alias as public without\n                     // recursing into its components when determining impl publicity.\n                     // For example, `impl <Type as Trait>::Alias {...}` may be a public impl\n@@ -1003,21 +1014,24 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n                     // Non-local means public (private items can't leave their crate, modulo bugs)\n                     if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n                         let item = self.tcx.map.expect_item(node_id);\n-                        if item.vis != hir::Public && !self.is_public_type_alias(item, path) {\n-                            if !self.is_quiet {\n-                                if self.old_error_set.contains(&ty.id) {\n-                                    span_err!(self.tcx.sess, ty.span, E0446,\n-                                              \"private type in public interface\");\n-                                } else {\n-                                    self.tcx.sess.add_lint (\n-                                        lint::builtin::PRIVATE_IN_PUBLIC,\n-                                        node_id,\n-                                        ty.span,\n-                                        format!(\"private type in public interface\"),\n-                                    );\n-                                }\n+                        let vis = match self.substituted_alias_visibility(item, path) {\n+                            Some(vis) => vis,\n+                            None => ty::Visibility::from_hir(&item.vis, node_id, &self.tcx),\n+                        };\n+\n+                        if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n+                            self.min_visibility = vis;\n+                        }\n+                        if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n+                            if self.old_error_set.contains(&ty.id) {\n+                                span_err!(self.tcx.sess, ty.span, E0446,\n+                                          \"private type in public interface\");\n+                            } else {\n+                                self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                                       node_id,\n+                                                       ty.span,\n+                                                       format!(\"private type in public interface\"));\n                             }\n-                            self.is_public = false;\n                         }\n                     }\n                 }\n@@ -1029,28 +1043,26 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n     }\n \n     fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n-        if self.is_quiet && !self.is_public {\n-            // We are in quiet mode and a private type is already found, no need to proceed\n-            return\n-        }\n         // Non-local means public (private items can't leave their crate, modulo bugs)\n         let def_id = self.tcx.trait_ref_to_def_id(trait_ref);\n         if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n             let item = self.tcx.map.expect_item(node_id);\n-            if item.vis != hir::Public {\n-                if !self.is_quiet {\n-                    if self.old_error_set.contains(&trait_ref.ref_id) {\n-                        span_err!(self.tcx.sess, trait_ref.path.span, E0445,\n-                                  \"private trait in public interface\");\n-                    } else {\n-                        self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                               node_id,\n-                                               trait_ref.path.span,\n-                                               \"private trait in public interface (error E0445)\"\n-                                                    .to_string());\n-                    }\n+            let vis = ty::Visibility::from_hir(&item.vis, node_id, &self.tcx);\n+\n+            if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n+                self.min_visibility = vis;\n+            }\n+            if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n+                if self.old_error_set.contains(&trait_ref.ref_id) {\n+                    span_err!(self.tcx.sess, trait_ref.path.span, E0445,\n+                              \"private trait in public interface\");\n+                } else {\n+                    self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                           node_id,\n+                                           trait_ref.path.span,\n+                                           \"private trait in public interface (error E0445)\"\n+                                                .to_string());\n                 }\n-                self.is_public = false;\n             }\n         }\n \n@@ -1072,29 +1084,29 @@ struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     // A type is considered public if it doesn't contain any private components\n-    fn is_public_ty(&self, ty: &hir::Ty) -> bool {\n-        let mut check = SearchInterfaceForPrivateItemsVisitor {\n-            tcx: self.tcx, is_quiet: true, is_public: true, old_error_set: self.old_error_set\n-        };\n+    fn ty_visibility(&self, ty: &hir::Ty) -> ty::Visibility {\n+        let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n         check.visit_ty(ty);\n-        check.is_public\n+        check.min_visibility\n     }\n \n     // A trait reference is considered public if it doesn't contain any private components\n-    fn is_public_trait_ref(&self, trait_ref: &hir::TraitRef) -> bool {\n-        let mut check = SearchInterfaceForPrivateItemsVisitor {\n-            tcx: self.tcx, is_quiet: true, is_public: true, old_error_set: self.old_error_set\n-        };\n+    fn trait_ref_visibility(&self, trait_ref: &hir::TraitRef) -> ty::Visibility {\n+        let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n         check.visit_trait_ref(trait_ref);\n-        check.is_public\n+        check.min_visibility\n     }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let mut check = SearchInterfaceForPrivateItemsVisitor {\n-            tcx: self.tcx, is_quiet: false, is_public: true, old_error_set: self.old_error_set\n+        let min = |vis1: ty::Visibility, vis2| {\n+            if vis1.is_at_least(vis2, &self.tcx.map) { vis2 } else { vis1 }\n         };\n+\n+        let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n+        let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, &self.tcx);\n+\n         match item.node {\n             // Crates are always public\n             hir::ItemExternCrate(..) => {}\n@@ -1105,51 +1117,52 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n             // Subitems of these items have inherited publicity\n             hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n             hir::ItemEnum(..) | hir::ItemTrait(..) | hir::ItemTy(..) => {\n-                if item.vis == hir::Public {\n-                    check.visit_item(item);\n-                }\n+                check.required_visibility = item_visibility;\n+                check.visit_item(item);\n             }\n             // Subitems of foreign modules have their own publicity\n             hir::ItemForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n-                    if foreign_item.vis == hir::Public {\n-                        check.visit_foreign_item(foreign_item);\n-                    }\n+                    check.required_visibility =\n+                        ty::Visibility::from_hir(&foreign_item.vis, item.id, &self.tcx);\n+                    check.visit_foreign_item(foreign_item);\n                 }\n             }\n             // Subitems of structs have their own publicity\n             hir::ItemStruct(ref struct_def, ref generics) => {\n-                if item.vis == hir::Public {\n-                    check.visit_generics(generics);\n-                    for field in struct_def.fields() {\n-                        if field.vis == hir::Public {\n-                            check.visit_struct_field(field);\n-                        }\n-                    }\n+                check.required_visibility = item_visibility;\n+                check.visit_generics(generics);\n+\n+                for field in struct_def.fields() {\n+                    let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, &self.tcx);\n+                    check.required_visibility = min(item_visibility, field_visibility);\n+                    check.visit_struct_field(field);\n                 }\n             }\n             // The interface is empty\n             hir::ItemDefaultImpl(..) => {}\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity\n             hir::ItemImpl(_, _, ref generics, None, ref ty, ref impl_items) => {\n-                if self.is_public_ty(ty) {\n-                    check.visit_generics(generics);\n-                    for impl_item in impl_items {\n-                        if impl_item.vis == hir::Public {\n-                            check.visit_impl_item(impl_item);\n-                        }\n-                    }\n+                let ty_vis = self.ty_visibility(ty);\n+                check.required_visibility = ty_vis;\n+                check.visit_generics(generics);\n+\n+                for impl_item in impl_items {\n+                    let impl_item_vis =\n+                        ty::Visibility::from_hir(&impl_item.vis, item.id, &self.tcx);\n+                    check.required_visibility = min(impl_item_vis, ty_vis);\n+                    check.visit_impl_item(impl_item);\n                 }\n             }\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity\n             hir::ItemImpl(_, _, ref generics, Some(ref trait_ref), ref ty, ref impl_items) => {\n-                if self.is_public_ty(ty) && self.is_public_trait_ref(trait_ref) {\n-                    check.visit_generics(generics);\n-                    for impl_item in impl_items {\n-                        check.visit_impl_item(impl_item);\n-                    }\n+                let vis = min(self.ty_visibility(ty), self.trait_ref_visibility(trait_ref));\n+                check.required_visibility = vis;\n+                check.visit_generics(generics);\n+                for impl_item in impl_items {\n+                    check.visit_impl_item(impl_item);\n                 }\n             }\n         }"}]}