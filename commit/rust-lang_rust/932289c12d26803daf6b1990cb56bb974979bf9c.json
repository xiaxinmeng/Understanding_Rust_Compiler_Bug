{"sha": "932289c12d26803daf6b1990cb56bb974979bf9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzMjI4OWMxMmQyNjgwM2RhZjZiMTk5MGNiNTZiYjk3NDk3OWJmOWM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-08-04T08:25:13Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-11T05:41:15Z"}, "message": "rustc: introduce ty::Const { ConstVal, Ty }.", "tree": {"sha": "109e458382f70b300ed9210b10d2f6a5d9c7c41f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/109e458382f70b300ed9210b10d2f6a5d9c7c41f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/932289c12d26803daf6b1990cb56bb974979bf9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/932289c12d26803daf6b1990cb56bb974979bf9c", "html_url": "https://github.com/rust-lang/rust/commit/932289c12d26803daf6b1990cb56bb974979bf9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/932289c12d26803daf6b1990cb56bb974979bf9c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50076b00c2790a7941772cc97ee371e15b2cb776", "url": "https://api.github.com/repos/rust-lang/rust/commits/50076b00c2790a7941772cc97ee371e15b2cb776", "html_url": "https://github.com/rust-lang/rust/commit/50076b00c2790a7941772cc97ee371e15b2cb776"}], "stats": {"total": 603, "additions": 409, "deletions": 194}, "files": [{"sha": "c9fb754287fda3cbc4cd97cad89580fa8fd081e2", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -277,10 +277,10 @@ for ::middle::const_val::ConstVal<'gcx> {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            Float(ref value) => {\n+            Integral(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n-            Integral(ref value) => {\n+            Float(ref value) => {\n                 value.hash_stable(hcx, hasher);\n             }\n             Str(ref value) => {\n@@ -325,6 +325,11 @@ impl_stable_hash_for!(struct ::middle::const_val::ByteArray<'tcx> {\n     data\n });\n \n+impl_stable_hash_for!(struct ty::Const<'tcx> {\n+    ty,\n+    val\n+});\n+\n impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n \n impl_stable_hash_for!(struct ty::GeneratorInterior<'tcx> { witness });"}, {"sha": "01f050a1bd90a9c90d2ce4d4fd1ad2d0badc7edf", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -30,12 +30,12 @@ use syntax_pos::Span;\n \n use std::borrow::Cow;\n \n-pub type EvalResult<'tcx> = Result<&'tcx ConstVal<'tcx>, ConstEvalErr<'tcx>>;\n+pub type EvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ConstEvalErr<'tcx>>;\n \n #[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n pub enum ConstVal<'tcx> {\n-    Float(ConstFloat),\n     Integral(ConstInt),\n+    Float(ConstFloat),\n     Str(InternedString),\n     ByteStr(ByteArray<'tcx>),\n     Bool(bool),\n@@ -45,8 +45,6 @@ pub enum ConstVal<'tcx> {\n     Aggregate(ConstAggregate<'tcx>),\n }\n \n-impl<'tcx> serialize::UseSpecializedDecodable for &'tcx ConstVal<'tcx> {}\n-\n #[derive(Copy, Clone, Debug, Hash, RustcEncodable, Eq, PartialEq)]\n pub struct ByteArray<'tcx> {\n     pub data: &'tcx [u8],\n@@ -56,10 +54,10 @@ impl<'tcx> serialize::UseSpecializedDecodable for ByteArray<'tcx> {}\n \n #[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]\n pub enum ConstAggregate<'tcx> {\n-    Struct(&'tcx [(ast::Name, &'tcx ConstVal<'tcx>)]),\n-    Tuple(&'tcx [&'tcx ConstVal<'tcx>]),\n-    Array(&'tcx [&'tcx ConstVal<'tcx>]),\n-    Repeat(&'tcx ConstVal<'tcx>, u64),\n+    Struct(&'tcx [(ast::Name, &'tcx ty::Const<'tcx>)]),\n+    Tuple(&'tcx [&'tcx ty::Const<'tcx>]),\n+    Array(&'tcx [&'tcx ty::Const<'tcx>]),\n+    Repeat(&'tcx ty::Const<'tcx>, u64),\n }\n \n impl<'tcx> Encodable for ConstAggregate<'tcx> {\n@@ -259,7 +257,7 @@ pub fn eval_length(tcx: TyCtxt,\n     let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n     let substs = Substs::identity_for_item(tcx.global_tcx(), count_def_id);\n     match tcx.at(count_expr.span).const_eval(param_env.and((count_def_id, substs))) {\n-        Ok(&Integral(Usize(count))) => {\n+        Ok(&ty::Const { val: Integral(Usize(count)), .. }) => {\n             let val = count.as_u64(tcx.sess.target.uint_type);\n             assert_eq!(val as usize as u64, val);\n             Ok(val as usize)"}, {"sha": "1985dcbd1f73de928f9dfa14042bc0a54fcf6bb0", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -1187,11 +1187,15 @@ impl<'tcx> Operand<'tcx> {\n         substs: &'tcx Substs<'tcx>,\n         span: Span,\n     ) -> Self {\n+        let ty = tcx.type_of(def_id).subst(tcx, substs);\n         Operand::Constant(box Constant {\n             span,\n-            ty: tcx.type_of(def_id).subst(tcx, substs),\n+            ty,\n             literal: Literal::Value {\n-                value: tcx.mk_const(ConstVal::Function(def_id, substs))\n+                value: tcx.mk_const(ty::Const {\n+                    val: ConstVal::Function(def_id, substs),\n+                    ty\n+                })\n             },\n         })\n     }\n@@ -1480,7 +1484,7 @@ pub enum Literal<'tcx> {\n         substs: &'tcx Substs<'tcx>,\n     },\n     Value {\n-        value: &'tcx ConstVal<'tcx>,\n+        value: &'tcx ty::Const<'tcx>,\n     },\n     Promoted {\n         // Index into the `promoted` vector of `Mir`.\n@@ -1501,9 +1505,9 @@ impl<'tcx> Debug for Literal<'tcx> {\n             Item { def_id, substs } => {\n                 ppaux::parameterized(fmt, substs, def_id, &[])\n             }\n-            Value { ref value } => {\n+            Value { value } => {\n                 write!(fmt, \"const \")?;\n-                fmt_const_val(fmt, value)\n+                fmt_const_val(fmt, &value.val)\n             }\n             Promoted { index } => {\n                 write!(fmt, \"{:?}\", index)"}, {"sha": "22d93c1a276508b79a0cb954e61aac944e47b398", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::const_val::ConstVal;\n use hir::def_id::DefId;\n use ty::subst::Substs;\n use ty::{ClosureSubsts, Region, Ty, GeneratorInterior};\n@@ -214,6 +213,18 @@ macro_rules! make_mir_visitor {\n                 self.super_ty(ty);\n             }\n \n+            fn visit_region(&mut self,\n+                            region: & $($mutability)* ty::Region<'tcx>,\n+                            _: Location) {\n+                self.super_region(region);\n+            }\n+\n+            fn visit_const(&mut self,\n+                           constant: & $($mutability)* &'tcx ty::Const<'tcx>,\n+                           _: Location) {\n+                self.super_const(constant);\n+            }\n+\n             fn visit_substs(&mut self,\n                             substs: & $($mutability)* &'tcx Substs<'tcx>,\n                             _: Location) {\n@@ -232,12 +243,6 @@ macro_rules! make_mir_visitor {\n                 self.super_generator_interior(interior);\n             }\n \n-            fn visit_const_val(&mut self,\n-                               const_val: & $($mutability)* &'tcx ConstVal<'tcx>,\n-                               _: Location) {\n-                self.super_const_val(const_val);\n-            }\n-\n             fn visit_const_int(&mut self,\n                                const_int: &ConstInt,\n                                _: Location) {\n@@ -517,9 +522,10 @@ macro_rules! make_mir_visitor {\n                         self.visit_const_usize(length, location);\n                     }\n \n-                    Rvalue::Ref(r, bk, ref $($mutability)* path) => {\n+                    Rvalue::Ref(ref $($mutability)* r, bk, ref $($mutability)* path) => {\n+                        self.visit_region(r, location);\n                         self.visit_lvalue(path, LvalueContext::Borrow {\n-                            region: r,\n+                            region: *r,\n                             kind: bk\n                         }, location);\n                     }\n@@ -724,7 +730,7 @@ macro_rules! make_mir_visitor {\n                         self.visit_substs(substs, location);\n                     }\n                     Literal::Value { ref $($mutability)* value } => {\n-                        self.visit_const_val(value, location);\n+                        self.visit_const(value, location);\n                     }\n                     Literal::Promoted { index: _ } => {}\n                 }\n@@ -749,6 +755,12 @@ macro_rules! make_mir_visitor {\n             fn super_ty(&mut self, _ty: & $($mutability)* Ty<'tcx>) {\n             }\n \n+            fn super_region(&mut self, _region: & $($mutability)* ty::Region<'tcx>) {\n+            }\n+\n+            fn super_const(&mut self, _const: & $($mutability)* &'tcx ty::Const<'tcx>) {\n+            }\n+\n             fn super_substs(&mut self, _substs: & $($mutability)* &'tcx Substs<'tcx>) {\n             }\n \n@@ -760,9 +772,6 @@ macro_rules! make_mir_visitor {\n                                     _substs: & $($mutability)* ClosureSubsts<'tcx>) {\n             }\n \n-            fn super_const_val(&mut self, _const_val: & $($mutability)* &'tcx ConstVal<'tcx>) {\n-            }\n-\n             fn super_const_int(&mut self, _const_int: &ConstInt) {\n             }\n "}, {"sha": "8dee2675ee5ccfca855cd3f3dae8489290f26711", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -21,7 +21,6 @@ use hir::map as hir_map;\n use hir::map::DefPathHash;\n use lint::{self, Lint};\n use ich::{self, StableHashingContext, NodeIdHashingMode};\n-use middle::const_val::ConstVal;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n@@ -33,7 +32,7 @@ use ty::ReprOptions;\n use traits;\n use ty::{self, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n-use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorInterior, Region};\n+use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorInterior, Region, Const};\n use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n@@ -109,7 +108,7 @@ pub struct CtxtInterners<'tcx> {\n     region: RefCell<FxHashSet<Interned<'tcx, RegionKind>>>,\n     existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n     predicates: RefCell<FxHashSet<Interned<'tcx, Slice<Predicate<'tcx>>>>>,\n-    const_: RefCell<FxHashSet<Interned<'tcx, ConstVal<'tcx>>>>,\n+    const_: RefCell<FxHashSet<Interned<'tcx, Const<'tcx>>>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n@@ -945,21 +944,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn alloc_constval_slice(self, values: &[&'tcx ConstVal<'gcx>])\n-                                -> &'gcx [&'tcx ConstVal<'gcx>] {\n+    pub fn alloc_const_slice(self, values: &[&'tcx ty::Const<'tcx>])\n+                             -> &'tcx [&'tcx ty::Const<'tcx>] {\n         if values.is_empty() {\n             &[]\n         } else {\n-            self.global_interners.arena.alloc_slice(values)\n+            self.interners.arena.alloc_slice(values)\n         }\n     }\n \n-    pub fn alloc_name_constval_slice(self, values: &[(ast::Name, &'tcx ConstVal<'gcx>)])\n-                                     -> &'gcx [(ast::Name, &'tcx ConstVal<'gcx>)] {\n+    pub fn alloc_name_const_slice(self, values: &[(ast::Name, &'tcx ty::Const<'tcx>)])\n+                                  -> &'tcx [(ast::Name, &'tcx ty::Const<'tcx>)] {\n         if values.is_empty() {\n             &[]\n         } else {\n-            self.global_interners.arena.alloc_slice(values)\n+            self.interners.arena.alloc_slice(values)\n         }\n     }\n \n@@ -1216,13 +1215,10 @@ impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n-    type Lifted = &'tcx Substs<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n-        if self.len() == 0 {\n-            return Some(Slice::empty());\n-        }\n-        if tcx.interners.arena.in_arena(&self[..] as *const _) {\n+impl<'a, 'tcx> Lift<'tcx> for Region<'a> {\n+    type Lifted = Region<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Region<'tcx>> {\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n         }\n         // Also try in the global tcx if we're not that.\n@@ -1234,9 +1230,9 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for Region<'a> {\n-    type Lifted = Region<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Region<'tcx>> {\n+impl<'a, 'tcx> Lift<'tcx> for &'a Const<'a> {\n+    type Lifted = &'tcx Const<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Const<'tcx>> {\n         if tcx.interners.arena.in_arena(*self as *const _) {\n             return Some(unsafe { mem::transmute(*self) });\n         }\n@@ -1249,6 +1245,24 @@ impl<'a, 'tcx> Lift<'tcx> for Region<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n+    type Lifted = &'tcx Substs<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n+        if self.len() == 0 {\n+            return Some(Slice::empty());\n+        }\n+        if tcx.interners.arena.in_arena(&self[..] as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Ty<'a>> {\n     type Lifted = &'tcx Slice<Ty<'tcx>>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n@@ -1536,8 +1550,8 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Predicate<'lcx>]>\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<ConstVal<'lcx>> for Interned<'tcx, ConstVal<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a ConstVal<'lcx> {\n+impl<'tcx: 'lcx, 'lcx> Borrow<Const<'lcx>> for Interned<'tcx, Const<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a Const<'lcx> {\n         &self.0\n     }\n }\n@@ -1623,7 +1637,7 @@ direct_interners!('tcx,\n             _ => false\n         }\n     }) -> RegionKind,\n-    const_: mk_const(/*|c: &Const| keep_local(&c.ty)*/ |_| false) -> ConstVal<'tcx>\n+    const_: mk_const(|c: &Const| keep_local(&c.ty) || keep_local(&c.val)) -> Const<'tcx>\n );\n \n macro_rules! slice_interners {"}, {"sha": "7c8aca9a9b157276b42c5b2ba0dfdf58821b3595", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -64,7 +64,7 @@ pub use self::sty::{InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n pub use self::sty::{ClosureSubsts, GeneratorInterior, TypeAndMut};\n pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n-pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n+pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::RegionKind;\n pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n@@ -1601,7 +1601,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n                 let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n                 match tcx.const_eval(param_env.and((expr_did, substs))) {\n-                    Ok(&ConstVal::Integral(v)) => {\n+                    Ok(&ty::Const { val: ConstVal::Integral(v), .. }) => {\n                         discr = v;\n                     }\n                     err => {\n@@ -1641,7 +1641,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 ty::VariantDiscr::Explicit(expr_did) => {\n                     let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n                     match tcx.const_eval(param_env.and((expr_did, substs))) {\n-                        Ok(&ConstVal::Integral(v)) => {\n+                        Ok(&ty::Const { val: ConstVal::Integral(v), .. }) => {\n                             explicit_value = v;\n                             break;\n                         }"}, {"sha": "f260e20a3cd6cec1aedc8c4011834eb8701c179c", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use infer::type_variable;\n+use middle::const_val::{ConstVal, ConstAggregate};\n use ty::{self, Lift, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -1101,3 +1102,95 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> TypeFoldable<'tcx> for ConstVal<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            ConstVal::Integral(i) => ConstVal::Integral(i),\n+            ConstVal::Float(f) => ConstVal::Float(f),\n+            ConstVal::Str(s) => ConstVal::Str(s),\n+            ConstVal::ByteStr(b) => ConstVal::ByteStr(b),\n+            ConstVal::Bool(b) => ConstVal::Bool(b),\n+            ConstVal::Char(c) => ConstVal::Char(c),\n+            ConstVal::Variant(def_id) => ConstVal::Variant(def_id),\n+            ConstVal::Function(def_id, substs) => {\n+                ConstVal::Function(def_id, substs.fold_with(folder))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n+                let new_fields: Vec<_> = fields.iter().map(|&(name, v)| {\n+                    (name, v.fold_with(folder))\n+                }).collect();\n+                let fields = if new_fields == fields {\n+                    fields\n+                } else {\n+                    folder.tcx().alloc_name_const_slice(&new_fields)\n+                };\n+                ConstVal::Aggregate(ConstAggregate::Struct(fields))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) => {\n+                let new_fields: Vec<_> = fields.iter().map(|v| {\n+                    v.fold_with(folder)\n+                }).collect();\n+                let fields = if new_fields == fields {\n+                    fields\n+                } else {\n+                    folder.tcx().alloc_const_slice(&new_fields)\n+                };\n+                ConstVal::Aggregate(ConstAggregate::Tuple(fields))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n+                let new_fields: Vec<_> = fields.iter().map(|v| {\n+                    v.fold_with(folder)\n+                }).collect();\n+                let fields = if new_fields == fields {\n+                    fields\n+                } else {\n+                    folder.tcx().alloc_const_slice(&new_fields)\n+                };\n+                ConstVal::Aggregate(ConstAggregate::Array(fields))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Repeat(v, count)) => {\n+                let v = v.fold_with(folder);\n+                ConstVal::Aggregate(ConstAggregate::Repeat(v, count))\n+            }\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            ConstVal::Integral(_) |\n+            ConstVal::Float(_) |\n+            ConstVal::Str(_) |\n+            ConstVal::ByteStr(_) |\n+            ConstVal::Bool(_) |\n+            ConstVal::Char(_) |\n+            ConstVal::Variant(_) => false,\n+            ConstVal::Function(_, substs) => substs.visit_with(visitor),\n+            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n+                fields.iter().any(|&(_, v)| v.visit_with(visitor))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n+            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n+                fields.iter().any(|v| v.visit_with(visitor))\n+            }\n+            ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n+                v.visit_with(visitor)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let ty = self.ty.fold_with(folder);\n+        let val = self.val.fold_with(folder);\n+        folder.tcx().mk_const(ty::Const {\n+            ty,\n+            val\n+        })\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.ty.visit_with(visitor) || self.val.visit_with(visitor)\n+    }\n+}"}, {"sha": "f082e32ff6867e9235ad3f470d47ee46af388b5f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -12,6 +12,7 @@\n \n use hir::def_id::DefId;\n \n+use middle::const_val::ConstVal;\n use middle::region;\n use ty::subst::{Substs, Subst};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n@@ -1458,3 +1459,14 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n }\n+\n+/// Typed constant value.\n+#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n+pub struct Const<'tcx> {\n+    pub ty: Ty<'tcx>,\n+\n+    // FIXME(eddyb) Replace this with a miri value.\n+    pub val: ConstVal<'tcx>,\n+}\n+\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Const<'tcx> {}"}, {"sha": "b1e3dcf53f0d80242c57ec5d6f25054b90d21c56", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -182,13 +182,16 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         self.byte_array_map.entry(pat).or_insert_with(|| {\n             match pat.kind {\n                 box PatternKind::Constant {\n-                    value: &ConstVal::ByteStr(b)\n+                    value: &ty::Const { val: ConstVal::ByteStr(b), .. }\n                 } => {\n                     b.data.iter().map(|&b| &*pattern_arena.alloc(Pattern {\n                         ty: tcx.types.u8,\n                         span: pat.span,\n                         kind: box PatternKind::Constant {\n-                            value: tcx.mk_const(ConstVal::Integral(ConstInt::U8(b)))\n+                            value: tcx.mk_const(ty::Const {\n+                                val: ConstVal::Integral(ConstInt::U8(b)),\n+                                ty: tcx.types.u8\n+                            })\n                         }\n                     })).collect()\n                 }\n@@ -228,9 +231,9 @@ pub enum Constructor<'tcx> {\n     /// Enum variants.\n     Variant(DefId),\n     /// Literal values.\n-    ConstantValue(&'tcx ConstVal<'tcx>),\n+    ConstantValue(&'tcx ty::Const<'tcx>),\n     /// Ranges of literal values (`2...5` and `2..5`).\n-    ConstantRange(&'tcx ConstVal<'tcx>, &'tcx ConstVal<'tcx>, RangeEnd),\n+    ConstantRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n     /// Array patterns of length n.\n     Slice(usize),\n }\n@@ -406,7 +409,10 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     match pcx.ty.sty {\n         ty::TyBool => {\n             [true, false].iter().map(|&b| {\n-                ConstantValue(cx.tcx.mk_const(ConstVal::Bool(b)))\n+                ConstantValue(cx.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Bool(b),\n+                    ty: cx.tcx.types.bool\n+                }))\n             }).collect()\n         }\n         ty::TySlice(ref sub_ty) => {\n@@ -514,7 +520,7 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n \n     for row in patterns {\n         match *row.kind {\n-            PatternKind::Constant { value: &ConstVal::ByteStr(b) } => {\n+            PatternKind::Constant { value: &ty::Const { val: ConstVal::ByteStr(b), .. } } => {\n                 max_fixed_len = cmp::max(max_fixed_len, b.data.len());\n             }\n             PatternKind::Slice { ref prefix, slice: None, ref suffix } => {\n@@ -809,7 +815,7 @@ fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n                                     suffix: &[Pattern])\n                                     -> Result<bool, ErrorReported> {\n     let data = match *ctor {\n-        ConstantValue(&ConstVal::ByteStr(b)) => b.data,\n+        ConstantValue(&ty::Const { val: ConstVal::ByteStr(b), .. }) => b.data,\n         _ => bug!()\n     };\n \n@@ -823,7 +829,7 @@ fn slice_pat_covered_by_constructor(_tcx: TyCtxt, _span: Span,\n             data[data.len()-suffix.len()..].iter().zip(suffix))\n     {\n         match pat.kind {\n-            box PatternKind::Constant { value } => match *value {\n+            box PatternKind::Constant { value } => match value.val {\n                 ConstVal::Integral(ConstInt::U8(u)) => {\n                     if u != *ch {\n                         return Ok(false);\n@@ -847,22 +853,22 @@ fn constructor_covered_by_range(tcx: TyCtxt, span: Span,\n     let cmp_to = |c_to| compare_const_vals(tcx, span, c_to, to);\n     match *ctor {\n         ConstantValue(value) => {\n-            let to = cmp_to(value)?;\n+            let to = cmp_to(&value.val)?;\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n-            Ok(cmp_from(value)? && end)\n+            Ok(cmp_from(&value.val)? && end)\n         },\n         ConstantRange(from, to, RangeEnd::Included) => {\n-            let to = cmp_to(to)?;\n+            let to = cmp_to(&to.val)?;\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n-            Ok(cmp_from(from)? && end)\n+            Ok(cmp_from(&from.val)? && end)\n         },\n         ConstantRange(from, to, RangeEnd::Excluded) => {\n-            let to = cmp_to(to)?;\n+            let to = cmp_to(&to.val)?;\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Excluded && to == Ordering::Equal);\n-            Ok(cmp_from(from)? && end)\n+            Ok(cmp_from(&from.val)? && end)\n         }\n         Single => Ok(true),\n         _ => bug!(),\n@@ -924,7 +930,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n \n         PatternKind::Constant { value } => {\n             match *constructor {\n-                Slice(..) => match *value {\n+                Slice(..) => match value.val {\n                     ConstVal::ByteStr(b) => {\n                         if wild_patterns.len() == b.data.len() {\n                             Some(cx.lower_byte_str_pattern(pat))\n@@ -937,7 +943,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                 },\n                 _ => {\n                     match constructor_covered_by_range(\n-                        cx.tcx, pat.span, constructor, value, value, RangeEnd::Included\n+                        cx.tcx, pat.span, constructor, &value.val, &value.val, RangeEnd::Included\n                             ) {\n                         Ok(true) => Some(vec![]),\n                         Ok(false) => None,\n@@ -947,9 +953,9 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n             }\n         }\n \n-        PatternKind::Range { ref lo, ref hi, ref end } => {\n+        PatternKind::Range { lo, hi, ref end } => {\n             match constructor_covered_by_range(\n-                cx.tcx, pat.span, constructor, lo, hi, end.clone()\n+                cx.tcx, pat.span, constructor, &lo.val, &hi.val, end.clone()\n             ) {\n                 Ok(true) => Some(vec![]),\n                 Ok(false) => None,"}, {"sha": "2aa333c1f039c12b7ab63d1b3cb01236bd9acfde", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -89,7 +89,7 @@ pub struct ConstContext<'a, 'tcx: 'a> {\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     substs: &'tcx Substs<'tcx>,\n-    fn_args: Option<NodeMap<&'tcx ConstVal<'tcx>>>\n+    fn_args: Option<NodeMap<&'tcx ty::Const<'tcx>>>\n }\n \n impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n@@ -121,7 +121,8 @@ type CastResult<'tcx> = Result<ConstVal<'tcx>, ErrKind<'tcx>>;\n fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                                      e: &'tcx Expr) -> EvalResult<'tcx> {\n     let tcx = cx.tcx;\n-    let ety = cx.tables.expr_ty(e).subst(tcx, cx.substs);\n+    let ty = cx.tables.expr_ty(e).subst(tcx, cx.substs);\n+    let mk_const = |val| tcx.mk_const(ty::Const { val, ty });\n \n     let result = match e.node {\n       hir::ExprUnary(hir::UnNeg, ref inner) => {\n@@ -134,7 +135,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n             const I32_OVERFLOW: u128 = i32::min_value() as u32 as u128;\n             const I64_OVERFLOW: u128 = i64::min_value() as u64 as u128;\n             const I128_OVERFLOW: u128 = i128::min_value() as u128;\n-            let negated = match (&lit.node, &ety.sty) {\n+            let negated = match (&lit.node, &ty.sty) {\n                 (&LitKind::Int(I8_OVERFLOW, _), &ty::TyInt(IntTy::I8)) |\n                 (&LitKind::Int(I8_OVERFLOW, Signed(IntTy::I8)), _) => {\n                     Some(I8(i8::min_value()))\n@@ -179,17 +180,17 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                 _ => None\n             };\n             if let Some(i) = negated {\n-                return Ok(tcx.mk_const(Integral(i)));\n+                return Ok(mk_const(Integral(i)));\n             }\n         }\n-        tcx.mk_const(match *cx.eval(inner)? {\n+        mk_const(match cx.eval(inner)?.val {\n           Float(f) => Float(-f),\n           Integral(i) => Integral(math!(e, -i)),\n           const_val => signal!(e, NegateOn(const_val)),\n         })\n       }\n       hir::ExprUnary(hir::UnNot, ref inner) => {\n-        tcx.mk_const(match *cx.eval(inner)? {\n+        mk_const(match cx.eval(inner)?.val {\n           Integral(i) => Integral(math!(e, !i)),\n           Bool(b) => Bool(!b),\n           const_val => signal!(e, NotOn(const_val)),\n@@ -201,7 +202,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n         // gives us a type through a type-suffix, cast or const def type\n         // we need to re-eval the other value of the BinOp if it was\n         // not inferred\n-        tcx.mk_const(match (*cx.eval(a)?, *cx.eval(b)?) {\n+        mk_const(match (cx.eval(a)?.val, cx.eval(b)?.val) {\n           (Float(a), Float(b)) => {\n             use std::cmp::Ordering::*;\n             match op.node {\n@@ -275,11 +276,11 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n       hir::ExprCast(ref base, _) => {\n         let base_val = cx.eval(base)?;\n         let base_ty = cx.tables.expr_ty(base).subst(tcx, cx.substs);\n-        if ety == base_ty {\n+        if ty == base_ty {\n             base_val\n         } else {\n-            match cast_const(tcx, *base_val, ety) {\n-                Ok(val) => tcx.mk_const(val),\n+            match cast_const(tcx, base_val.val, ty) {\n+                Ok(val) => mk_const(val),\n                 Err(kind) => signal!(e, kind),\n             }\n         }\n@@ -301,13 +302,13 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                     }\n               },\n               Def::VariantCtor(variant_def, CtorKind::Const) => {\n-                tcx.mk_const(Variant(variant_def))\n+                mk_const(Variant(variant_def))\n               }\n               Def::VariantCtor(_, CtorKind::Fn) => {\n                   signal!(e, UnimplementedConstVal(\"enum variants\"));\n               }\n               Def::StructCtor(_, CtorKind::Const) => {\n-                  tcx.mk_const(Aggregate(Struct(&[])))\n+                  mk_const(Aggregate(Struct(&[])))\n               }\n               Def::StructCtor(_, CtorKind::Fn) => {\n                   signal!(e, UnimplementedConstVal(\"tuple struct constructors\"))\n@@ -320,13 +321,13 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                       signal!(e, NonConstPath);\n                   }\n               },\n-              Def::Method(id) | Def::Fn(id) => tcx.mk_const(Function(id, substs)),\n+              Def::Method(id) | Def::Fn(id) => mk_const(Function(id, substs)),\n               Def::Err => span_bug!(e.span, \"typeck error\"),\n               _ => signal!(e, NonConstPath),\n           }\n       }\n       hir::ExprCall(ref callee, ref args) => {\n-          let (def_id, substs) = match *cx.eval(callee)? {\n+          let (def_id, substs) = match cx.eval(callee)?.val {\n               Function(def_id, substs) => (def_id, substs),\n               _ => signal!(e, TypeckError),\n           };\n@@ -340,12 +341,12 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n             match &tcx.item_name(def_id)[..] {\n                 \"size_of\" => {\n                     let size = layout_of(substs.type_at(0))?.size(tcx).bytes();\n-                    return Ok(tcx.mk_const(Integral(Usize(ConstUsize::new(size,\n+                    return Ok(mk_const(Integral(Usize(ConstUsize::new(size,\n                         tcx.sess.target.uint_type).unwrap()))));\n                 }\n                 \"min_align_of\" => {\n                     let align = layout_of(substs.type_at(0))?.align(tcx).abi();\n-                    return Ok(tcx.mk_const(Integral(Usize(ConstUsize::new(align,\n+                    return Ok(mk_const(Integral(Usize(ConstUsize::new(align,\n                         tcx.sess.target.uint_type).unwrap()))));\n                 }\n                 _ => signal!(e, TypeckError)\n@@ -394,23 +395,23 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           };\n           callee_cx.eval(&body.value)?\n       },\n-      hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ety) {\n-          Ok(val) => tcx.mk_const(val),\n+      hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ty) {\n+          Ok(val) => mk_const(val),\n           Err(err) => signal!(e, err),\n       },\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => cx.eval(expr)?,\n-            None => tcx.mk_const(Aggregate(Tuple(&[]))),\n+            None => mk_const(Aggregate(Tuple(&[]))),\n         }\n       }\n       hir::ExprType(ref e, _) => cx.eval(e)?,\n       hir::ExprTup(ref fields) => {\n         let values = fields.iter().map(|e| cx.eval(e)).collect::<Result<Vec<_>, _>>()?;\n-        tcx.mk_const(Aggregate(Tuple(tcx.alloc_constval_slice(&values))))\n+        mk_const(Aggregate(Tuple(tcx.alloc_const_slice(&values))))\n       }\n       hir::ExprStruct(_, ref fields, _) => {\n-        tcx.mk_const(Aggregate(Struct(tcx.alloc_name_constval_slice(&fields.iter().map(|f| {\n+        mk_const(Aggregate(Struct(tcx.alloc_name_const_slice(&fields.iter().map(|f| {\n             cx.eval(&f.expr).map(|v| (f.name.node, v))\n         }).collect::<Result<Vec<_>, _>>()?))))\n       }\n@@ -419,12 +420,12 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n             signal!(e, IndexOpFeatureGated);\n         }\n         let arr = cx.eval(arr)?;\n-        let idx = match *cx.eval(idx)? {\n+        let idx = match cx.eval(idx)?.val {\n             Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n             _ => signal!(idx, IndexNotUsize),\n         };\n         assert_eq!(idx as usize as u64, idx);\n-        match *arr {\n+        match arr.val {\n             Aggregate(Array(v)) => {\n                 if let Some(&elem) = v.get(idx as usize) {\n                     elem\n@@ -444,32 +445,32 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                 signal!(e, IndexOutOfBounds { len: b.data.len() as u64, index: idx })\n             }\n             ByteStr(b) => {\n-                tcx.mk_const(Integral(U8(b.data[idx as usize])))\n+                mk_const(Integral(U8(b.data[idx as usize])))\n             },\n \n             _ => signal!(e, IndexedNonVec),\n         }\n       }\n       hir::ExprArray(ref v) => {\n         let values = v.iter().map(|e| cx.eval(e)).collect::<Result<Vec<_>, _>>()?;\n-        tcx.mk_const(Aggregate(Array(tcx.alloc_constval_slice(&values))))\n+        mk_const(Aggregate(Array(tcx.alloc_const_slice(&values))))\n       }\n       hir::ExprRepeat(ref elem, _) => {\n-          let n = match ety.sty {\n+          let n = match ty.sty {\n             ty::TyArray(_, n) => n as u64,\n             _ => span_bug!(e.span, \"typeck error\")\n           };\n-          tcx.mk_const(Aggregate(Repeat(cx.eval(elem)?, n)))\n+          mk_const(Aggregate(Repeat(cx.eval(elem)?, n)))\n       },\n       hir::ExprTupField(ref base, index) => {\n-        if let Aggregate(Tuple(fields)) = *cx.eval(base)? {\n+        if let Aggregate(Tuple(fields)) = cx.eval(base)?.val {\n             fields[index.node]\n         } else {\n             signal!(base, ExpectedConstTuple);\n         }\n       }\n       hir::ExprField(ref base, field_name) => {\n-        if let Aggregate(Struct(fields)) = *cx.eval(base)? {\n+        if let Aggregate(Struct(fields)) = cx.eval(base)?.val {\n             if let Some(&(_, f)) = fields.iter().find(|&&(name, _)| name == field_name.node) {\n                 f\n             } else {\n@@ -756,7 +757,7 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n                 return Err(ErrorReported);\n             }\n         };\n-        compare_const_vals(tcx, span, &a, &b)\n+        compare_const_vals(tcx, span, &a.val, &b.val)\n     }\n }\n "}, {"sha": "cf42d61e136ad900f7e9c840342b33fb513bafa1", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -83,12 +83,12 @@ pub enum PatternKind<'tcx> {\n     },\n \n     Constant {\n-        value: &'tcx ConstVal<'tcx>,\n+        value: &'tcx ty::Const<'tcx>,\n     },\n \n     Range {\n-        lo: &'tcx ConstVal<'tcx>,\n-        hi: &'tcx ConstVal<'tcx>,\n+        lo: &'tcx ty::Const<'tcx>,\n+        hi: &'tcx ty::Const<'tcx>,\n         end: RangeEnd,\n     },\n \n@@ -228,15 +228,15 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 write!(f, \"{}\", subpattern)\n             }\n             PatternKind::Constant { value } => {\n-                print_const_val(value, f)\n+                print_const_val(&value.val, f)\n             }\n             PatternKind::Range { lo, hi, end } => {\n-                print_const_val(lo, f)?;\n+                print_const_val(&lo.val, f)?;\n                 match end {\n                     RangeEnd::Included => write!(f, \"...\")?,\n                     RangeEnd::Excluded => write!(f, \"..\")?,\n                 }\n-                print_const_val(hi, f)\n+                print_const_val(&hi.val, f)\n             }\n             PatternKind::Slice { ref prefix, ref slice, ref suffix } |\n             PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n@@ -634,7 +634,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                                self.tables);\n         match const_cx.eval(expr) {\n             Ok(value) => {\n-                if let ConstVal::Variant(def_id) = *value {\n+                if let ConstVal::Variant(def_id) = value.val {\n                     let ty = self.tables.expr_ty(expr);\n                     self.lower_variant_or_leaf(Def::Variant(def_id), ty, vec![])\n                 } else {\n@@ -816,7 +816,7 @@ macro_rules! CloneImpls {\n }\n \n CloneImpls!{ <'tcx>\n-    Span, Field, Mutability, ast::Name, ast::NodeId, usize, &'tcx ConstVal<'tcx>,\n+    Span, Field, Mutability, ast::Name, ast::NodeId, usize, &'tcx ty::Const<'tcx>,\n     Region<'tcx>, Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n     &'tcx Substs<'tcx>, &'tcx Kind<'tcx>\n }"}, {"sha": "e6af47952b37196dd4c6bed72695007579ad6a1a", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -117,7 +117,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                                              cx.param_env.and(substs),\n                                                              cx.tables);\n                             match const_cx.eval(&r) {\n-                                Ok(&ConstVal::Integral(i)) => {\n+                                Ok(&ty::Const { val: ConstVal::Integral(i), .. }) => {\n                                     i.is_negative() ||\n                                     i.to_u64()\n                                         .map(|i| i >= bits)"}, {"sha": "689f9f5b244304b6a133a9055613747906dcbd64", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -16,7 +16,7 @@ use schema::*;\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n \n-use rustc::middle::const_val::{ByteArray, ConstVal};\n+use rustc::middle::const_val::ByteArray;\n use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -386,8 +386,8 @@ impl<'a, 'tcx> SpecializedDecoder<ByteArray<'tcx>> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<&'tcx ConstVal<'tcx>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<&'tcx ConstVal<'tcx>, Self::Error> {\n+impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Const<'tcx>> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n         Ok(self.tcx().mk_const(Decodable::decode(self)?))\n     }\n }"}, {"sha": "2bda4524d23af7a69b4fc4c2f581a674e3263c91", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -197,7 +197,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         span: expr_span,\n                         ty: this.hir.tcx().types.u32,\n                         literal: Literal::Value {\n-                            value: this.hir.tcx().mk_const(ConstVal::Integral(ConstInt::U32(0))),\n+                            value: this.hir.tcx().mk_const(ty::Const {\n+                                val: ConstVal::Integral(ConstInt::U32(0)),\n+                                ty: this.hir.tcx().types.u32\n+                            }),\n                         },\n                     }));\n                     box AggregateKind::Generator(closure_id, substs, interior)\n@@ -392,7 +395,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 };\n \n                 Literal::Value {\n-                    value: self.hir.tcx().mk_const(ConstVal::Integral(val))\n+                    value: self.hir.tcx().mk_const(ty::Const {\n+                        val: ConstVal::Integral(val),\n+                        ty\n+                    })\n                 }\n             }\n             _ => {\n@@ -427,7 +433,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 };\n \n                 Literal::Value {\n-                    value: self.hir.tcx().mk_const(ConstVal::Integral(val))\n+                    value: self.hir.tcx().mk_const(ty::Const {\n+                        val: ConstVal::Integral(val),\n+                        ty\n+                    })\n                 }\n             }\n             _ => {"}, {"sha": "f560fa426e22e2e380ff80ed0fd5ad2ddfba10d9", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -16,8 +16,7 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n-use rustc::middle::const_val::ConstVal;\n-use rustc::ty::{AdtDef, Ty};\n+use rustc::ty::{self, Ty};\n use rustc::mir::*;\n use rustc::hir;\n use hair::*;\n@@ -294,20 +293,20 @@ pub struct MatchPair<'pat, 'tcx:'pat> {\n enum TestKind<'tcx> {\n     // test the branches of enum\n     Switch {\n-        adt_def: &'tcx AdtDef,\n+        adt_def: &'tcx ty::AdtDef,\n         variants: BitVector,\n     },\n \n     // test the branches of enum\n     SwitchInt {\n         switch_ty: Ty<'tcx>,\n-        options: Vec<&'tcx ConstVal<'tcx>>,\n-        indices: FxHashMap<&'tcx ConstVal<'tcx>, usize>,\n+        options: Vec<&'tcx ty::Const<'tcx>>,\n+        indices: FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n     },\n \n     // test for equality\n     Eq {\n-        value: &'tcx ConstVal<'tcx>,\n+        value: &'tcx ty::Const<'tcx>,\n         ty: Ty<'tcx>,\n     },\n "}, {"sha": "965a443d9ac1bf55b2de7b7668e204803c954e12", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -112,8 +112,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      test_lvalue: &Lvalue<'tcx>,\n                                      candidate: &Candidate<'pat, 'tcx>,\n                                      switch_ty: Ty<'tcx>,\n-                                     options: &mut Vec<&'tcx ConstVal<'tcx>>,\n-                                     indices: &mut FxHashMap<&'tcx ConstVal<'tcx>, usize>)\n+                                     options: &mut Vec<&'tcx ty::Const<'tcx>>,\n+                                     indices: &mut FxHashMap<&'tcx ty::Const<'tcx>, usize>)\n                                      -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.lvalue == *test_lvalue) {\n@@ -228,7 +228,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     assert!(options.len() > 0 && options.len() <= 2);\n                     let (true_bb, false_bb) = (self.cfg.start_new_block(),\n                                                self.cfg.start_new_block());\n-                    let ret = match *options[0] {\n+                    let ret = match options[0].val {\n                         ConstVal::Bool(true) => vec![true_bb, false_bb],\n                         ConstVal::Bool(false) => vec![false_bb, true_bb],\n                         v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n@@ -245,7 +245,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                .chain(Some(otherwise))\n                                .collect();\n                     let values: Vec<_> = options.iter().map(|v|\n-                        v.to_const_int().expect(\"switching on integral\")\n+                        v.val.to_const_int().expect(\"switching on integral\")\n                     ).collect();\n                     (targets.clone(), TerminatorKind::SwitchInt {\n                         discr: Operand::Consume(lvalue.clone()),\n@@ -263,7 +263,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 // If we're using b\"...\" as a pattern, we need to insert an\n                 // unsizing coercion, as the byte string has the type &[u8; N].\n-                let expect = if let ConstVal::ByteStr(bytes) = *value {\n+                let expect = if let ConstVal::ByteStr(bytes) = value.val {\n                     let tcx = self.hir.tcx();\n \n                     // Unsize the lvalue to &[u8], too, if necessary."}, {"sha": "bf9ad78481164ebbbc4c8613d343ad7b472f9f3d", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -61,7 +61,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             ty::TyChar => {\n                 Literal::Value {\n-                    value: self.hir.tcx().mk_const(ConstVal::Char('\\0'))\n+                    value: self.hir.tcx().mk_const(ty::Const {\n+                        val: ConstVal::Char('\\0'),\n+                        ty\n+                    })\n                 }\n             }\n             ty::TyUint(ity) => {\n@@ -79,7 +82,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 };\n \n                 Literal::Value {\n-                    value: self.hir.tcx().mk_const(ConstVal::Integral(val))\n+                    value: self.hir.tcx().mk_const(ty::Const {\n+                        val: ConstVal::Integral(val),\n+                        ty\n+                    })\n                 }\n             }\n             ty::TyInt(ity) => {\n@@ -97,7 +103,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 };\n \n                 Literal::Value {\n-                    value: self.hir.tcx().mk_const(ConstVal::Integral(val))\n+                    value: self.hir.tcx().mk_const(ty::Const {\n+                        val: ConstVal::Integral(val),\n+                        ty\n+                    })\n                 }\n             }\n             _ => {"}, {"sha": "be6f8c9e56c40b7a67db94bdf3a8b008440ef240", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -166,6 +166,26 @@ impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n         }\n     }\n \n+    fn visit_region(&mut self, region: &mut ty::Region<'tcx>, _: Location) {\n+        if let Some(lifted) = self.tcx.lift(region) {\n+            *region = lifted;\n+        } else {\n+            span_bug!(self.span,\n+                      \"found region `{:?}` with inference types/regions in MIR\",\n+                      region);\n+        }\n+    }\n+\n+    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _: Location) {\n+        if let Some(lifted) = self.tcx.lift(constant) {\n+            *constant = lifted;\n+        } else {\n+            span_bug!(self.span,\n+                      \"found constant `{:?}` with inference types/regions in MIR\",\n+                      constant);\n+        }\n+    }\n+\n     fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, _: Location) {\n         if let Some(lifted) = self.tcx.lift(substs) {\n             *substs = lifted;"}, {"sha": "23e6fbd2b7e23a0fc38eea52b0e2632e43b83022", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -473,7 +473,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let def_id = cx.tcx.hir.body_owner_def_id(count);\n             let substs = Substs::identity_for_item(cx.tcx.global_tcx(), def_id);\n             let count = match cx.tcx.at(c.span).const_eval(cx.param_env.and((def_id, substs))) {\n-                Ok(&ConstVal::Integral(ConstInt::Usize(u))) => u,\n+                Ok(&ty::Const { val: ConstVal::Integral(ConstInt::Usize(u)), .. }) => u,\n                 Ok(other) => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n                 Err(s) => cx.fatal_const_eval_err(&s, c.span, \"expression\")\n             };\n@@ -591,13 +591,17 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         (cx.tables().type_dependent_defs()[expr.hir_id].def_id(),\n          cx.tables().node_substs(expr.hir_id))\n     });\n+    let ty = cx.tcx().mk_fn_def(def_id, substs);\n     Expr {\n         temp_lifetime,\n-        ty: cx.tcx().mk_fn_def(def_id, substs),\n+        ty,\n         span: expr.span,\n         kind: ExprKind::Literal {\n             literal: Literal::Value {\n-                value: cx.tcx.mk_const(ConstVal::Function(def_id, substs)),\n+                value: cx.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Function(def_id, substs),\n+                    ty\n+                }),\n             },\n         },\n     }\n@@ -630,7 +634,10 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::StructCtor(def_id, CtorKind::Fn) |\n         Def::VariantCtor(def_id, CtorKind::Fn) => ExprKind::Literal {\n             literal: Literal::Value {\n-                value: cx.tcx.mk_const(ConstVal::Function(def_id, substs)),\n+                value: cx.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Function(def_id, substs),\n+                    ty: cx.tables().node_id_to_type(expr.hir_id)\n+                }),\n             },\n         },\n "}, {"sha": "85607c04c98c807bc2107a22d077dd81d0602c8c", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -115,7 +115,10 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         match ConstUsize::new(value, self.tcx.sess.target.uint_type) {\n             Ok(val) => {\n                 Literal::Value {\n-                    value: self.tcx.mk_const(ConstVal::Integral(ConstInt::Usize(val)))\n+                    value: self.tcx.mk_const(ty::Const {\n+                        val: ConstVal::Integral(ConstInt::Usize(val)),\n+                        ty: self.tcx.types.usize\n+                    })\n                 }\n             }\n             Err(_) => bug!(\"usize literal out of range for target\"),\n@@ -131,11 +134,21 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn true_literal(&mut self) -> Literal<'tcx> {\n-        Literal::Value { value: self.tcx.mk_const(ConstVal::Bool(true)) }\n+        Literal::Value {\n+            value: self.tcx.mk_const(ty::Const {\n+                val: ConstVal::Bool(true),\n+                ty: self.tcx.types.bool\n+            })\n+        }\n     }\n \n     pub fn false_literal(&mut self) -> Literal<'tcx> {\n-        Literal::Value { value: self.tcx.mk_const(ConstVal::Bool(false)) }\n+        Literal::Value {\n+            value: self.tcx.mk_const(ty::Const {\n+                val: ConstVal::Bool(false),\n+                ty: self.tcx.types.bool\n+            })\n+        }\n     }\n \n     pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> {\n@@ -186,7 +199,10 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 let method_ty = method_ty.subst(self.tcx, substs);\n                 return (method_ty,\n                         Literal::Value {\n-                            value: self.tcx.mk_const(ConstVal::Function(item.def_id, substs)),\n+                            value: self.tcx.mk_const(ty::Const {\n+                                val: ConstVal::Function(item.def_id, substs),\n+                                ty: method_ty\n+                            }),\n                         });\n             }\n         }"}, {"sha": "cc0ea5911a070c3517ec49e271d761794e85c078", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -403,11 +403,15 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         );\n \n         // `func == Clone::clone(&ty) -> ty`\n+        let func_ty = tcx.mk_fn_def(self.def_id, substs);\n         let func = Operand::Constant(box Constant {\n             span: self.span,\n-            ty: tcx.mk_fn_def(self.def_id, substs),\n+            ty: func_ty,\n             literal: Literal::Value {\n-                value: tcx.mk_const(ConstVal::Function(self.def_id, substs)),\n+                value: tcx.mk_const(ty::Const {\n+                    val: ConstVal::Function(self.def_id, substs),\n+                    ty: func_ty\n+                }),\n             },\n         });\n \n@@ -472,7 +476,10 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             span: self.span,\n             ty: self.tcx.types.usize,\n             literal: Literal::Value {\n-                value: self.tcx.mk_const(ConstVal::Integral(ConstInt::Usize(value)))\n+                value: self.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Integral(ConstInt::Usize(value)),\n+                    ty: self.tcx.types.usize,\n+                })\n             }\n         }\n     }\n@@ -706,17 +713,21 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n \n     let (callee, mut args) = match call_kind {\n         CallKind::Indirect => (rcvr, vec![]),\n-        CallKind::Direct(def_id) => (\n-            Operand::Constant(box Constant {\n+        CallKind::Direct(def_id) => {\n+            let ty = tcx.type_of(def_id);\n+            (Operand::Constant(box Constant {\n                 span,\n-                ty: tcx.type_of(def_id),\n+                ty,\n                 literal: Literal::Value {\n-                    value: tcx.mk_const(ConstVal::Function(def_id,\n-                        Substs::identity_for_item(tcx, def_id))),\n+                    value: tcx.mk_const(ty::Const {\n+                        val: ConstVal::Function(def_id,\n+                            Substs::identity_for_item(tcx, def_id)),\n+                        ty\n+                    }),\n                 },\n-            }),\n-            vec![rcvr]\n-        )\n+             }),\n+             vec![rcvr])\n+        }\n     };\n \n     if let Some(untuple_args) = untuple_args {"}, {"sha": "1077f3b0146168ccd48e1a0e166324306a8bbcdc", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -521,7 +521,10 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             span,\n             ty: self.tcx.types.bool,\n             literal: Literal::Value {\n-                value: self.tcx.mk_const(ConstVal::Bool(val))\n+                value: self.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Bool(val),\n+                    ty: self.tcx.types.bool\n+                })\n             }\n         })))\n     }"}, {"sha": "dc18cdd8f0dd6006e2270974f8cae06240319d0e", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -15,7 +15,7 @@\n //! \"types-as-contracts\"-validation, namely, AcquireValid, ReleaseValid, and EndRegion.\n \n use rustc::ty::subst::Substs;\n-use rustc::ty::{Ty, TyCtxt, ClosureSubsts};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::mir::*;\n use rustc::mir::visit::{MutVisitor, Lookup};\n use rustc::mir::transform::{MirPass, MirSource};\n@@ -37,38 +37,25 @@ impl<'a, 'tcx> EraseRegionsVisitor<'a, 'tcx> {\n impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: Lookup) {\n         if !self.in_validation_statement {\n-            *ty = self.tcx.erase_regions(&{*ty});\n+            *ty = self.tcx.erase_regions(ty);\n         }\n         self.super_ty(ty);\n     }\n \n-    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, _: Location) {\n-        *substs = self.tcx.erase_regions(&{*substs});\n+    fn visit_region(&mut self, region: &mut ty::Region<'tcx>, _: Location) {\n+        *region = self.tcx.types.re_erased;\n     }\n \n-    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n-        match *rvalue {\n-            Rvalue::Ref(ref mut r, _, _) => {\n-                *r = self.tcx.types.re_erased;\n-            }\n-            Rvalue::Use(..) |\n-            Rvalue::Repeat(..) |\n-            Rvalue::Len(..) |\n-            Rvalue::Cast(..) |\n-            Rvalue::BinaryOp(..) |\n-            Rvalue::CheckedBinaryOp(..) |\n-            Rvalue::UnaryOp(..) |\n-            Rvalue::Discriminant(..) |\n-            Rvalue::NullaryOp(..) |\n-            Rvalue::Aggregate(..) => {\n-                // These variants don't contain regions.\n-            }\n-        }\n-        self.super_rvalue(rvalue, location);\n+    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _: Location) {\n+        *constant = self.tcx.erase_regions(constant);\n+    }\n+\n+    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, _: Location) {\n+        *substs = self.tcx.erase_regions(substs);\n     }\n \n     fn visit_closure_substs(&mut self,\n-                            substs: &mut ClosureSubsts<'tcx>,\n+                            substs: &mut ty::ClosureSubsts<'tcx>,\n                             _: Location) {\n         *substs = self.tcx.erase_regions(substs);\n     }"}, {"sha": "a52656becd74534190b114501df7e4bff8d6be39", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -175,7 +175,10 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n             span: source_info.span,\n             ty: self.tcx.types.u32,\n             literal: Literal::Value {\n-                value: self.tcx.mk_const(ConstVal::Integral(ConstInt::U32(state_disc))),\n+                value: self.tcx.mk_const(ty::Const {\n+                    val: ConstVal::Integral(ConstInt::U32(state_disc)),\n+                    ty: self.tcx.types.u32\n+                }),\n             },\n         });\n         Statement {\n@@ -553,7 +556,10 @@ fn insert_panic_on_resume_after_return<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             span: mir.span,\n             ty: tcx.types.bool,\n             literal: Literal::Value {\n-                value: tcx.mk_const(ConstVal::Bool(false)),\n+                value: tcx.mk_const(ty::Const {\n+                    val: ConstVal::Bool(false),\n+                    ty: tcx.types.bool\n+                }),\n             },\n         }),\n         expected: true,\n@@ -603,7 +609,10 @@ fn create_generator_resume_function<'a, 'tcx>(\n             span: mir.span,\n             ty: tcx.types.bool,\n             literal: Literal::Value {\n-                value: tcx.mk_const(ConstVal::Bool(false)),\n+                value: tcx.mk_const(ty::Const {\n+                    val: ConstVal::Bool(false),\n+                    ty: tcx.types.bool\n+                }),\n             },\n         }),\n         expected: true,"}, {"sha": "0dff145ecbce94c547568b7651b91529fcf4079f", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -10,7 +10,7 @@\n \n //! A pass that simplifies branches when their condition is known.\n \n-use rustc::ty::TyCtxt;\n+use rustc::ty::{self, TyCtxt};\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::*;\n@@ -40,7 +40,7 @@ impl MirPass for SimplifyBranches {\n                 TerminatorKind::SwitchInt { discr: Operand::Constant(box Constant {\n                     literal: Literal::Value { ref value }, ..\n                 }), ref values, ref targets, .. } => {\n-                    if let Some(ref constint) = value.to_const_int() {\n+                    if let Some(ref constint) = value.val.to_const_int() {\n                         let (otherwise, targets) = targets.split_last().unwrap();\n                         let mut ret = TerminatorKind::Goto { target: *otherwise };\n                         for (v, t) in values.iter().zip(targets.iter()) {\n@@ -56,7 +56,7 @@ impl MirPass for SimplifyBranches {\n                 },\n                 TerminatorKind::Assert { target, cond: Operand::Constant(box Constant {\n                     literal: Literal::Value {\n-                        value: &ConstVal::Bool(cond)\n+                        value: &ty::Const { val: ConstVal::Bool(cond), .. }\n                     }, ..\n                 }), expected, .. } if cond == expected => {\n                     TerminatorKind::Goto { target: target }"}, {"sha": "3c77668e729c6f843e25742d4df0034bed246e90", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -572,7 +572,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         match operand {\n             &Operand::Constant(box Constant {\n                 literal: Literal::Value {\n-                    value: &ConstVal::Function(def_id, _), ..\n+                    value: &ty::Const { val: ConstVal::Function(def_id, _), .. }, ..\n                 }, ..\n             }) => {\n                 Some(def_id) == self.tcx().lang_items().box_free_fn()"}, {"sha": "4a11ac11680906c076346e0728e1e5ee06e1b819", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -923,7 +923,10 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             span: self.source_info.span,\n             ty: self.tcx().types.usize,\n             literal: Literal::Value {\n-                value: self.tcx().mk_const(ConstVal::Integral(self.tcx().const_usize(val)))\n+                value: self.tcx().mk_const(ty::Const {\n+                    val: ConstVal::Integral(self.tcx().const_usize(val)),\n+                    ty: self.tcx().types.usize\n+                })\n             }\n         })\n     }"}, {"sha": "91203a91be51d3e3637e5a4d0542a26948e8d690", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -13,15 +13,14 @@\n // completely accurate (some things might be counted twice, others missed).\n \n use rustc_const_math::{ConstUsize};\n-use rustc::middle::const_val::{ConstVal};\n use rustc::mir::{AggregateKind, AssertMessage, BasicBlock, BasicBlockData};\n use rustc::mir::{Constant, Literal, Location, LocalDecl};\n use rustc::mir::{Lvalue, LvalueElem, LvalueProjection};\n use rustc::mir::{Mir, Operand, ProjectionElem};\n use rustc::mir::{Rvalue, SourceInfo, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind, VisibilityScope, VisibilityScopeData};\n use rustc::mir::visit as mir_visit;\n-use rustc::ty::{ClosureSubsts, TyCtxt};\n+use rustc::ty::{self, ClosureSubsts, TyCtxt};\n use rustc::util::nodemap::{FxHashMap};\n \n struct NodeData {\n@@ -256,11 +255,11 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_closure_substs(substs);\n     }\n \n-    fn visit_const_val(&mut self,\n-                       const_val: &&'tcx ConstVal<'tcx>,\n-                       _: Location) {\n-        self.record(\"ConstVal\", const_val);\n-        self.super_const_val(const_val);\n+    fn visit_const(&mut self,\n+                   constant: &&'tcx ty::Const<'tcx>,\n+                   _: Location) {\n+        self.record(\"Const\", constant);\n+        self.super_const(constant);\n     }\n \n     fn visit_const_usize(&mut self,"}, {"sha": "1017ec6b3c3f85608e33a553e916e39d4fe25988", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -17,6 +17,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::mir::{self, Location, TerminatorKind, Literal};\n use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir::traversal;\n+use rustc::ty;\n use common;\n use super::MirContext;\n \n@@ -110,7 +111,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n             mir::TerminatorKind::Call {\n                 func: mir::Operand::Constant(box mir::Constant {\n                     literal: Literal::Value {\n-                        value: &ConstVal::Function(def_id, _), ..\n+                        value: &ty::Const { val: ConstVal::Function(def_id, _), .. }, ..\n                     }, ..\n                 }),\n                 ref args, .."}, {"sha": "21c935ae6381758fc4e0329bcdf959c629ceb685", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -522,7 +522,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         MirConstContext::new(self.ccx, mir, self.substs, IndexVec::new()).trans()\n                     }\n                     mir::Literal::Value { value } => {\n-                        Ok(Const::from_constval(self.ccx, value, ty))\n+                        Ok(Const::from_constval(self.ccx, &value.val, ty))\n                     }\n                 }\n             }\n@@ -971,7 +971,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 MirConstContext::new(bcx.ccx, mir, self.param_substs, IndexVec::new()).trans()\n             }\n             mir::Literal::Value { value } => {\n-                Ok(Const::from_constval(bcx.ccx, value, ty))\n+                Ok(Const::from_constval(bcx.ccx, &value.val, ty))\n             }\n         };\n "}, {"sha": "1735ec7cc698c29788d0cdc51a0aa3de97536420", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932289c12d26803daf6b1990cb56bb974979bf9c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=932289c12d26803daf6b1990cb56bb974979bf9c", "patch": "@@ -572,7 +572,7 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             match result {\n-                Ok(&ConstVal::Integral(x)) => Some(x),\n+                Ok(&ty::Const { val: ConstVal::Integral(x), .. }) => Some(x),\n                 _ => None\n             }\n         } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {"}]}