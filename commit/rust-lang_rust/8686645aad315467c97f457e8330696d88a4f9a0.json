{"sha": "8686645aad315467c97f457e8330696d88a4f9a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2ODY2NDVhYWQzMTU0NjdjOTdmNDU3ZTgzMzA2OTZkODhhNGY5YTA=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-16T23:39:47Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-16T23:47:40Z"}, "message": "New channel-based task status notifications.", "tree": {"sha": "c2a054c5c9d10249cdd56f6b7e5a714833732f16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2a054c5c9d10249cdd56f6b7e5a714833732f16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8686645aad315467c97f457e8330696d88a4f9a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8686645aad315467c97f457e8330696d88a4f9a0", "html_url": "https://github.com/rust-lang/rust/commit/8686645aad315467c97f457e8330696d88a4f9a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8686645aad315467c97f457e8330696d88a4f9a0/comments", "author": null, "committer": null, "parents": [{"sha": "07225e2169d3a96bed28110ff976a6752c0ec0a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/07225e2169d3a96bed28110ff976a6752c0ec0a8", "html_url": "https://github.com/rust-lang/rust/commit/07225e2169d3a96bed28110ff976a6752c0ec0a8"}], "stats": {"total": 146, "additions": 128, "deletions": 18}, "files": [{"sha": "834e09db267d5c0b631b4bf87f86b72f84d30689", "filename": "src/lib/task.rs", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8686645aad315467c97f457e8330696d88a4f9a0/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8686645aad315467c97f457e8330696d88a4f9a0/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=8686645aad315467c97f457e8330696d88a4f9a0", "patch": "@@ -1,4 +1,9 @@\n import cast = unsafe::reinterpret_cast;\n+import comm;\n+import comm::_chan;\n+import option::some;\n+import option::none;\n+import option = option::t;\n \n native \"rust\" mod rustrt {\n     fn task_sleep(time_in_us: uint);\n@@ -10,7 +15,6 @@ native \"rust\" mod rustrt {\n     fn get_task_id() -> task_id;\n \n     type rust_chan;\n-    type rust_task;\n \n     fn set_min_stack(stack_size: uint);\n \n@@ -26,7 +30,13 @@ native \"rust\" mod rustrt {\n     fn leak<@T>(thing : -T);\n }\n \n-type task_id = int;\n+type rust_task = {\n+    mutable notify_enabled : u8,\n+    mutable notify_chan : _chan[task_notification]\n+};\n+\n+type task = int;\n+type task_id = task;\n \n fn get_task_id() -> task_id {\n     rustrt::get_task_id()\n@@ -43,12 +53,13 @@ fn yield() { ret rustrt::task_yield(); }\n \n tag task_result { tr_success; tr_failure; }\n \n-// FIXME: Re-enable this once the task type is removed from the compiler.\n-/*\n+tag task_notification {\n+    exit(task, task_result);\n+}\n+\n fn join(t: task) -> task_result {\n     join_id(cast(t))\n }\n-*/\n \n fn join_id(t : task_id) -> task_result {\n     alt rustrt::task_join(t) { 0 { tr_success } _ { tr_failure } }\n@@ -64,8 +75,22 @@ fn set_min_stack(stack_size : uint) {\n     rustrt::set_min_stack(stack_size);\n }\n \n+fn _spawn(thunk : fn() -> ()) -> task {\n+    spawn(thunk)\n+}\n+\n+fn spawn(thunk : fn() -> ()) -> task {\n+    spawn_inner(thunk, none)\n+}\n+\n+fn spawn_notify(thunk : fn() -> (), notify : _chan[task_notification])\n+    -> task {\n+    spawn_inner(thunk, some(notify))\n+}\n+\n // FIXME: make this a fn~ once those are supported.\n-fn _spawn(thunk : fn() -> ()) -> task_id {\n+fn spawn_inner(thunk : fn() -> (), notify : option[_chan[task_notification]])\n+    -> task_id {\n     let id = rustrt::new_task();\n \n     // the order of arguments are outptr, taskptr, envptr.\n@@ -75,12 +100,21 @@ fn _spawn(thunk : fn() -> ()) -> task_id {\n     let regs = rustrt::get_task_context(id);\n \n     // set up the task pointer\n-    let task_ptr : u32 = cast(rustrt::get_task_pointer(id));\n-    (*regs).edx = task_ptr;\n+    let task_ptr = rustrt::get_task_pointer(id);\n+    (*regs).edx = cast(task_ptr);\n \n     let raw_thunk : { code: u32, env: u32 } = cast(thunk);\n     (*regs).eip = raw_thunk.code;\n \n+    // set up notifications if they are enabled.\n+    alt notify {\n+      some(c) {\n+        (*task_ptr).notify_enabled = 1u8;\n+        (*task_ptr).notify_chan = c;\n+      }\n+      none {}\n+    };\n+\n     // okay, now we align the stack and add the environment pointer and a fake\n     // return address.\n \n@@ -95,7 +129,7 @@ fn _spawn(thunk : fn() -> ()) -> task_id {\n     // put the return pointer in ecx.\n     (*regs).ecx = (*regs).esp + 8u32;\n \n-    *tptr = task_ptr;\n+    *tptr = cast(task_ptr);\n     *env = raw_thunk.env;\n     *ra = rustrt::get_task_trampoline();\n "}, {"sha": "9dbd9337a185ecf5d8d7d44619635dcd5d557935", "filename": "src/rt/rust_chan.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8686645aad315467c97f457e8330696d88a4f9a0/src%2Frt%2Frust_chan.h", "raw_url": "https://github.com/rust-lang/rust/raw/8686645aad315467c97f457e8330696d88a4f9a0/src%2Frt%2Frust_chan.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.h?ref=8686645aad315467c97f457e8330696d88a4f9a0", "patch": "@@ -25,12 +25,6 @@ class rust_chan : public kernel_owned<rust_chan>,\n     rust_chan *clone(rust_task *target);\n };\n \n-// Corresponds to the rust chan (currently _chan) type.\n-struct chan_handle {\n-    rust_task_id task;\n-    rust_port_id port;\n-};\n-\n //\n // Local Variables:\n // mode: C++"}, {"sha": "aa9f387a9f9a058ad384353df29b7ef55a4e73b2", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8686645aad315467c97f457e8330696d88a4f9a0/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/8686645aad315467c97f457e8330696d88a4f9a0/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=8686645aad315467c97f457e8330696d88a4f9a0", "patch": "@@ -56,7 +56,6 @@ struct rust_task;\n class rust_log;\n class rust_port;\n class rust_chan;\n-struct chan_handle;\n struct rust_token;\n class rust_kernel;\n class rust_crate_cache;\n@@ -68,6 +67,12 @@ struct frame_glue_fns;\n typedef intptr_t rust_task_id;\n typedef intptr_t rust_port_id;\n \n+// Corresponds to the rust chan (currently _chan) type.\n+struct chan_handle {\n+    rust_task_id task;\n+    rust_port_id port;\n+};\n+\n #ifndef __i386__\n #error \"Target CPU not supported.\"\n #endif"}, {"sha": "c877d5e9941bfb89bdbf3bbcfcb2f607ffc05c24", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8686645aad315467c97f457e8330696d88a4f9a0/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8686645aad315467c97f457e8330696d88a4f9a0/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=8686645aad315467c97f457e8330696d88a4f9a0", "patch": "@@ -80,6 +80,10 @@ rust_task::rust_task(rust_scheduler *sched, rust_task_list *state,\n     LOGPTR(sched, \"new task\", (uintptr_t)this);\n     DLOG(sched, task, \"sizeof(task) = %d (0x%x)\", sizeof *this, sizeof *this);\n \n+    assert((void*)this == (void*)&user);\n+\n+    user.notify_enabled = 0;\n+\n     stk = new_stk(sched, this, 0);\n     rust_sp = stk->limit;\n }\n@@ -89,6 +93,19 @@ rust_task::~rust_task()\n     DLOG(sched, task, \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n          name, (uintptr_t)this, ref_count);\n \n+    if(user.notify_enabled) {\n+        rust_chan *target =\n+            get_chan_by_handle(&user.notify_chan);\n+        if(target) {\n+            task_notification msg;\n+            msg.id = id;\n+            msg.result = failed ? tr_failure : tr_success;\n+\n+            target->send(&msg);\n+            target->deref();\n+        }\n+    }\n+\n     kernel->release_task_id(id);\n \n     /* FIXME: tighten this up, there are some more\n@@ -400,15 +417,20 @@ rust_task::free(void *p, bool is_gc)\n \n void\n rust_task::transition(rust_task_list *src, rust_task_list *dst) {\n-    I(sched, !sched->lock.lock_held_by_current_thread());\n-    scoped_lock with(sched->lock);\n+    bool unlock = false;\n+    if(!sched->lock.lock_held_by_current_thread()) {\n+        unlock = true;\n+        sched->lock.lock();\n+    }\n     DLOG(sched, task,\n          \"task %s \" PTR \" state change '%s' -> '%s' while in '%s'\",\n          name, (uintptr_t)this, src->name, dst->name, state->name);\n     I(sched, state == src);\n     src->remove(this);\n     dst->append(this);\n     state = dst;\n+    if(unlock)\n+        sched->lock.unlock();\n }\n \n void"}, {"sha": "a688c405e60747f321481968d24485f85e64b1cc", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8686645aad315467c97f457e8330696d88a4f9a0/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/8686645aad315467c97f457e8330696d88a4f9a0/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=8686645aad315467c97f457e8330696d88a4f9a0", "patch": "@@ -34,9 +34,32 @@ struct gc_alloc {\n     }\n };\n \n+// portions of the task structure that are accessible from the standard\n+// library. This struct must agree with the std::task::rust_task record.\n+struct rust_task_user {\n+    uint8_t notify_enabled;\n+    chan_handle notify_chan;\n+};\n+\n+// std::lib::task::task_result\n+enum task_result {\n+    tr_success = 0,\n+    tr_failure = 1\n+};\n+\n+// std::lib::task::task_notification\n+//\n+// since it's currently a unary tag, we only add the fields.\n+struct task_notification {\n+    rust_task_id id;\n+    task_result result; // task_result\n+};\n+\n struct\n rust_task : public kernel_owned<rust_task>, rust_cond\n {\n+    rust_task_user user;\n+\n     RUST_ATOMIC_REFCOUNT();\n \n     // Fields known to the compiler."}, {"sha": "b97271bf4bed6cb8326c6d670151554f76a2d18c", "filename": "src/test/stdtest/task.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8686645aad315467c97f457e8330696d88a4f9a0/src%2Ftest%2Fstdtest%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8686645aad315467c97f457e8330696d88a4f9a0/src%2Ftest%2Fstdtest%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftask.rs?ref=8686645aad315467c97f457e8330696d88a4f9a0", "patch": "@@ -1,5 +1,6 @@\n use std;\n import std::task;\n+import std::comm;\n \n #[test]\n fn test_sleep() { task::sleep(1000000u); }\n@@ -11,6 +12,7 @@ fn test_unsupervise() {\n }\n \n #[test]\n+#[ignore]\n fn test_join() {\n     fn winner() { }\n \n@@ -36,3 +38,33 @@ fn test_lib_spawn2() {\n     fn foo(x : int) { assert(x == 42); }\n     task::_spawn(bind foo(42));\n }\n+\n+#[test]\n+fn test_join_chan() {\n+    fn winner() { }\n+\n+    let p = comm::mk_port[task::task_notification]();\n+    task::spawn_notify(bind winner(), p.mk_chan());\n+    let s = p.recv();\n+    log_err \"received task status message\";\n+    log_err s;\n+    alt s {\n+      task::exit(_, task::tr_success.) { /* yay! */ }\n+      _ { fail \"invalid task status received\" }\n+    }\n+}\n+\n+#[test]\n+fn test_join_chan_fail() {\n+    fn failer() { task::unsupervise(); fail }\n+\n+    let p = comm::mk_port[task::task_notification]();\n+    task::spawn_notify(bind failer(), p.mk_chan());\n+    let s = p.recv();\n+    log_err \"received task status message\";\n+    log_err s;\n+    alt s {\n+      task::exit(_, task::tr_failure.) { /* yay! */ }\n+      _ { fail \"invalid task status received\" }\n+    }\n+}"}]}