{"sha": "e38639fe123194200842b3e18e0c2313b0372a8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzODYzOWZlMTIzMTk0MjAwODQyYjNlMThlMGMyMzEzYjAzNzJhOGM=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-10-15T00:52:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-15T00:52:37Z"}, "message": "Rollup merge of #65332 - RalfJung:fmt, r=cramertj\n\nstd::fmt: reorder docs\n\nThis moves the \"Formatting Parameters\" section up above right after the discussion of named and positional arguments. Then comes the \"Syntax\" section, summarizing the discussion of format string syntax.\nAnd only *then* we get to \"Formatting Traits\" -- that section has some *huge* code examples, so it really should not interrupt the discussion of the grammar. Also users are much more likely to come here to learn about the format string grammar than to come here to learn about the `Binary` trait.", "tree": {"sha": "8931c72cb79554adc09f897f9848210dafe4225c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8931c72cb79554adc09f897f9848210dafe4225c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e38639fe123194200842b3e18e0c2313b0372a8c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdpRhVCRBK7hj4Ov3rIwAAdHIIAJJAdpkqb+QGD7zv4adBZwIC\n1pOiokwP4Ca1CrSDpFQpJqwujEbNwn4ihXmoxk1fbT5dxENTNKOGv8ti0mKpN/+/\nJhGM5ejTu25HAOSYibYsG5Y6IRfYEr3/BwRUskX8oDyyBST5JnSvxV9XXlqTYmXJ\ndDUWbFgt4pRdW7JQOJUEXuKLidnoKx9O3ievvXYn6jIXfcKv1ZtZyai5w3doUM8E\nMTUWizlMNrgKsIiAN+/6iG6HHdbJaMTdmgYU73xqDe6PFONVsX3Y0yYJrVEKjXJt\nraXpC+omxF72eJebPnlZekQXLpDkOMTii6GlGeqVSYdQki2Wc7hSbsTLcFAbqeo=\n=J2m0\n-----END PGP SIGNATURE-----\n", "payload": "tree 8931c72cb79554adc09f897f9848210dafe4225c\nparent 6d28ed1ae6c3f44f03e30e4884d6701e36744246\nparent 504cc208448e5dd60186c6ff48d1f82438bc1e59\nauthor Tyler Mandry <tmandry@gmail.com> 1571100757 -0700\ncommitter GitHub <noreply@github.com> 1571100757 -0700\n\nRollup merge of #65332 - RalfJung:fmt, r=cramertj\n\nstd::fmt: reorder docs\n\nThis moves the \"Formatting Parameters\" section up above right after the discussion of named and positional arguments. Then comes the \"Syntax\" section, summarizing the discussion of format string syntax.\nAnd only *then* we get to \"Formatting Traits\" -- that section has some *huge* code examples, so it really should not interrupt the discussion of the grammar. Also users are much more likely to come here to learn about the format string grammar than to come here to learn about the `Binary` trait.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e38639fe123194200842b3e18e0c2313b0372a8c", "html_url": "https://github.com/rust-lang/rust/commit/e38639fe123194200842b3e18e0c2313b0372a8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e38639fe123194200842b3e18e0c2313b0372a8c/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d28ed1ae6c3f44f03e30e4884d6701e36744246", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d28ed1ae6c3f44f03e30e4884d6701e36744246", "html_url": "https://github.com/rust-lang/rust/commit/6d28ed1ae6c3f44f03e30e4884d6701e36744246"}, {"sha": "504cc208448e5dd60186c6ff48d1f82438bc1e59", "url": "https://api.github.com/repos/rust-lang/rust/commits/504cc208448e5dd60186c6ff48d1f82438bc1e59", "html_url": "https://github.com/rust-lang/rust/commit/504cc208448e5dd60186c6ff48d1f82438bc1e59"}], "stats": {"total": 366, "additions": 175, "deletions": 191}, "files": [{"sha": "1e39b7f822e99345c40cbcce0a2a633102451413", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 175, "deletions": 191, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/e38639fe123194200842b3e18e0c2313b0372a8c/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38639fe123194200842b3e18e0c2313b0372a8c/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=e38639fe123194200842b3e18e0c2313b0372a8c", "patch": "@@ -80,24 +80,187 @@\n //! arguments which have names. Like with positional parameters, it is not\n //! valid to provide named parameters that are unused by the format string.\n //!\n-//! ## Argument types\n+//! # Formatting Parameters\n+//!\n+//! Each argument being formatted can be transformed by a number of formatting\n+//! parameters (corresponding to `format_spec` in the syntax above). These\n+//! parameters affect the string representation of what's being formatted.\n+//!\n+//! ## Fill/Alignment\n+//!\n+//! The fill character is provided normally in conjunction with the\n+//! [`width`](#width)\n+//! parameter. This indicates that if the value being formatted is smaller than\n+//! `width` some extra characters will be printed around it. The extra\n+//! characters are specified by `fill`, and the alignment can be one of the\n+//! following options:\n+//!\n+//! * `<` - the argument is left-aligned in `width` columns\n+//! * `^` - the argument is center-aligned in `width` columns\n+//! * `>` - the argument is right-aligned in `width` columns\n+//!\n+//! Note that alignment may not be implemented by some types. In particular, it\n+//! is not generally implemented for the `Debug` trait.  A good way to ensure\n+//! padding is applied is to format your input, then use this resulting string\n+//! to pad your output.\n+//!\n+//! ## Sign/`#`/`0`\n+//!\n+//! These can all be interpreted as flags for a particular formatter.\n+//!\n+//! * `+` - This is intended for numeric types and indicates that the sign\n+//!         should always be printed. Positive signs are never printed by\n+//!         default, and the negative sign is only printed by default for the\n+//!         `Signed` trait. This flag indicates that the correct sign (`+` or `-`)\n+//!         should always be printed.\n+//! * `-` - Currently not used\n+//! * `#` - This flag is indicates that the \"alternate\" form of printing should\n+//!         be used. The alternate forms are:\n+//!     * `#?` - pretty-print the [`Debug`] formatting\n+//!     * `#x` - precedes the argument with a `0x`\n+//!     * `#X` - precedes the argument with a `0x`\n+//!     * `#b` - precedes the argument with a `0b`\n+//!     * `#o` - precedes the argument with a `0o`\n+//! * `0` - This is used to indicate for integer formats that the padding should\n+//!         both be done with a `0` character as well as be sign-aware. A format\n+//!         like `{:08}` would yield `00000001` for the integer `1`, while the\n+//!         same format would yield `-0000001` for the integer `-1`. Notice that\n+//!         the negative version has one fewer zero than the positive version.\n+//!         Note that padding zeroes are always placed after the sign (if any)\n+//!         and before the digits. When used together with the `#` flag, a similar\n+//!         rule applies: padding zeroes are inserted after the prefix but before\n+//!         the digits.\n+//!\n+//! ## Width\n+//!\n+//! This is a parameter for the \"minimum width\" that the format should take up.\n+//! If the value's string does not fill up this many characters, then the\n+//! padding specified by fill/alignment will be used to take up the required\n+//! space.\n+//!\n+//! The default [fill/alignment](#fillalignment) for non-numerics is a space and\n+//! left-aligned. The\n+//! defaults for numeric formatters is also a space but with right-alignment. If\n+//! the `0` flag is specified for numerics, then the implicit fill character is\n+//! `0`.\n+//!\n+//! The value for the width can also be provided as a [`usize`] in the list of\n+//! parameters by using the dollar syntax indicating that the second argument is\n+//! a [`usize`] specifying the width, for example:\n+//!\n+//! ```\n+//! // All of these print \"Hello x    !\"\n+//! println!(\"Hello {:5}!\", \"x\");\n+//! println!(\"Hello {:1$}!\", \"x\", 5);\n+//! println!(\"Hello {1:0$}!\", 5, \"x\");\n+//! println!(\"Hello {:width$}!\", \"x\", width = 5);\n+//! ```\n+//!\n+//! Referring to an argument with the dollar syntax does not affect the \"next\n+//! argument\" counter, so it's usually a good idea to refer to arguments by\n+//! position, or use named arguments.\n+//!\n+//! ## Precision\n+//!\n+//! For non-numeric types, this can be considered a \"maximum width\". If the resulting string is\n+//! longer than this width, then it is truncated down to this many characters and that truncated\n+//! value is emitted with proper `fill`, `alignment` and `width` if those parameters are set.\n+//!\n+//! For integral types, this is ignored.\n+//!\n+//! For floating-point types, this indicates how many digits after the decimal point should be\n+//! printed.\n+//!\n+//! There are three possible ways to specify the desired `precision`:\n+//!\n+//! 1. An integer `.N`:\n+//!\n+//!    the integer `N` itself is the precision.\n+//!\n+//! 2. An integer or name followed by dollar sign `.N$`:\n+//!\n+//!    use format *argument* `N` (which must be a `usize`) as the precision.\n+//!\n+//! 3. An asterisk `.*`:\n+//!\n+//!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n+//!    first input holds the `usize` precision, and the second holds the value to print. Note that\n+//!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n+//!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n+//!\n+//! For example, the following calls all print the same thing `Hello x is 0.01000`:\n+//!\n+//! ```\n+//! // Hello {arg 0 (\"x\")} is {arg 1 (0.01) with precision specified inline (5)}\n+//! println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n+//!\n+//! // Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n+//! println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n+//!\n+//! // Hello {arg 0 (\"x\")} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n+//! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (\"x\")} is {second of next two args (0.01) with precision\n+//! //                          specified in first of next two args (5)}\n+//! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (\"x\")} is {arg 2 (0.01) with precision\n+//! //                          specified in its predecessor (5)}\n+//! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (\"x\")} is {arg \"number\" (0.01) with precision specified\n+//! //                          in arg \"prec\" (5)}\n+//! println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n+//! ```\n //!\n-//! Each argument's type is dictated by the format string.\n-//! There are various parameters which require a particular type, however.\n-//! An example is the `{:.*}` syntax, which sets the number of decimal places\n-//! in floating-point types:\n+//! While these:\n //!\n //! ```\n-//! let formatted_number = format!(\"{:.*}\", 2, 1.234567);\n+//! println!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\n+//! println!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\n+//! println!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n+//! ```\n //!\n-//! assert_eq!(\"1.23\", formatted_number)\n+//! print two significantly different things:\n+//!\n+//! ```text\n+//! Hello, `1234.560` has 3 fractional digits\n+//! Hello, `123` has 3 characters\n+//! Hello, `     123` has 3 right-aligned characters\n //! ```\n //!\n-//! If this syntax is used, then the number of characters to print precedes the\n-//! actual object being formatted, and the number of characters must have the\n-//! type [`usize`].\n+//! # Escaping\n+//!\n+//! The literal characters `{` and `}` may be included in a string by preceding\n+//! them with the same character. For example, the `{` character is escaped with\n+//! `{{` and the `}` character is escaped with `}}`.\n+//!\n+//! # Syntax\n+//!\n+//! To summarize, you can find the full grammar of format strings.\n+//! The syntax for the formatting language used is drawn from other languages,\n+//! so it should not be too alien. Arguments are formatted with Python-like\n+//! syntax, meaning that arguments are surrounded by `{}` instead of the C-like\n+//! `%`. The actual grammar for the formatting syntax is:\n+//!\n+//! ```text\n+//! format_string := <text> [ maybe-format <text> ] *\n+//! maybe-format := '{' '{' | '}' '}' | <format>\n+//! format := '{' [ argument ] [ ':' format_spec ] '}'\n+//! argument := integer | identifier\n+//!\n+//! format_spec := [[fill]align][sign]['#']['0'][width]['.' precision][type]\n+//! fill := character\n+//! align := '<' | '^' | '>'\n+//! sign := '+' | '-'\n+//! width := count\n+//! precision := count | '*'\n+//! type := identifier | '?' | ''\n+//! count := parameter | integer\n+//! parameter := argument '$'\n+//! ```\n //!\n-//! ## Formatting traits\n+//! # Formatting traits\n //!\n //! When requesting that an argument be formatted with a particular type, you\n //! are actually requesting that an argument ascribes to a particular trait.\n@@ -220,7 +383,7 @@\n //! assert_eq!(format!(\"{} {:?}\", \"foo\\n\", \"bar\\n\"), \"foo\\n \\\"bar\\\\n\\\"\");\n //! ```\n //!\n-//! ## Related macros\n+//! # Related macros\n //!\n //! There are a number of related macros in the [`format!`] family. The ones that\n //! are currently implemented are:\n@@ -300,185 +463,6 @@\n //! it would internally pass around this structure until it has been determined\n //! where output should go to.\n //!\n-//! # Syntax\n-//!\n-//! The syntax for the formatting language used is drawn from other languages,\n-//! so it should not be too alien. Arguments are formatted with Python-like\n-//! syntax, meaning that arguments are surrounded by `{}` instead of the C-like\n-//! `%`. The actual grammar for the formatting syntax is:\n-//!\n-//! ```text\n-//! format_string := <text> [ maybe-format <text> ] *\n-//! maybe-format := '{' '{' | '}' '}' | <format>\n-//! format := '{' [ argument ] [ ':' format_spec ] '}'\n-//! argument := integer | identifier\n-//!\n-//! format_spec := [[fill]align][sign]['#']['0'][width]['.' precision][type]\n-//! fill := character\n-//! align := '<' | '^' | '>'\n-//! sign := '+' | '-'\n-//! width := count\n-//! precision := count | '*'\n-//! type := identifier | '?' | ''\n-//! count := parameter | integer\n-//! parameter := argument '$'\n-//! ```\n-//!\n-//! # Formatting Parameters\n-//!\n-//! Each argument being formatted can be transformed by a number of formatting\n-//! parameters (corresponding to `format_spec` in the syntax above). These\n-//! parameters affect the string representation of what's being formatted.\n-//!\n-//! ## Fill/Alignment\n-//!\n-//! The fill character is provided normally in conjunction with the\n-//! [`width`](#width)\n-//! parameter. This indicates that if the value being formatted is smaller than\n-//! `width` some extra characters will be printed around it. The extra\n-//! characters are specified by `fill`, and the alignment can be one of the\n-//! following options:\n-//!\n-//! * `<` - the argument is left-aligned in `width` columns\n-//! * `^` - the argument is center-aligned in `width` columns\n-//! * `>` - the argument is right-aligned in `width` columns\n-//!\n-//! Note that alignment may not be implemented by some types. In particular, it\n-//! is not generally implemented for the `Debug` trait.  A good way to ensure\n-//! padding is applied is to format your input, then use this resulting string\n-//! to pad your output.\n-//!\n-//! ## Sign/`#`/`0`\n-//!\n-//! These can all be interpreted as flags for a particular formatter.\n-//!\n-//! * `+` - This is intended for numeric types and indicates that the sign\n-//!         should always be printed. Positive signs are never printed by\n-//!         default, and the negative sign is only printed by default for the\n-//!         `Signed` trait. This flag indicates that the correct sign (`+` or `-`)\n-//!         should always be printed.\n-//! * `-` - Currently not used\n-//! * `#` - This flag is indicates that the \"alternate\" form of printing should\n-//!         be used. The alternate forms are:\n-//!     * `#?` - pretty-print the [`Debug`] formatting\n-//!     * `#x` - precedes the argument with a `0x`\n-//!     * `#X` - precedes the argument with a `0x`\n-//!     * `#b` - precedes the argument with a `0b`\n-//!     * `#o` - precedes the argument with a `0o`\n-//! * `0` - This is used to indicate for integer formats that the padding should\n-//!         both be done with a `0` character as well as be sign-aware. A format\n-//!         like `{:08}` would yield `00000001` for the integer `1`, while the\n-//!         same format would yield `-0000001` for the integer `-1`. Notice that\n-//!         the negative version has one fewer zero than the positive version.\n-//!         Note that padding zeroes are always placed after the sign (if any)\n-//!         and before the digits. When used together with the `#` flag, a similar\n-//!         rule applies: padding zeroes are inserted after the prefix but before\n-//!         the digits.\n-//!\n-//! ## Width\n-//!\n-//! This is a parameter for the \"minimum width\" that the format should take up.\n-//! If the value's string does not fill up this many characters, then the\n-//! padding specified by fill/alignment will be used to take up the required\n-//! space.\n-//!\n-//! The default [fill/alignment](#fillalignment) for non-numerics is a space and\n-//! left-aligned. The\n-//! defaults for numeric formatters is also a space but with right-alignment. If\n-//! the `0` flag is specified for numerics, then the implicit fill character is\n-//! `0`.\n-//!\n-//! The value for the width can also be provided as a [`usize`] in the list of\n-//! parameters by using the dollar syntax indicating that the second argument is\n-//! a [`usize`] specifying the width, for example:\n-//!\n-//! ```\n-//! // All of these print \"Hello x    !\"\n-//! println!(\"Hello {:5}!\", \"x\");\n-//! println!(\"Hello {:1$}!\", \"x\", 5);\n-//! println!(\"Hello {1:0$}!\", 5, \"x\");\n-//! println!(\"Hello {:width$}!\", \"x\", width = 5);\n-//! ```\n-//!\n-//! Referring to an argument with the dollar syntax does not affect the \"next\n-//! argument\" counter, so it's usually a good idea to refer to arguments by\n-//! position, or use named arguments.\n-//!\n-//! ## Precision\n-//!\n-//! For non-numeric types, this can be considered a \"maximum width\". If the resulting string is\n-//! longer than this width, then it is truncated down to this many characters and that truncated\n-//! value is emitted with proper `fill`, `alignment` and `width` if those parameters are set.\n-//!\n-//! For integral types, this is ignored.\n-//!\n-//! For floating-point types, this indicates how many digits after the decimal point should be\n-//! printed.\n-//!\n-//! There are three possible ways to specify the desired `precision`:\n-//!\n-//! 1. An integer `.N`:\n-//!\n-//!    the integer `N` itself is the precision.\n-//!\n-//! 2. An integer or name followed by dollar sign `.N$`:\n-//!\n-//!    use format *argument* `N` (which must be a `usize`) as the precision.\n-//!\n-//! 3. An asterisk `.*`:\n-//!\n-//!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n-//!    first input holds the `usize` precision, and the second holds the value to print. Note that\n-//!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n-//!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n-//!\n-//! For example, the following calls all print the same thing `Hello x is 0.01000`:\n-//!\n-//! ```\n-//! // Hello {arg 0 (\"x\")} is {arg 1 (0.01) with precision specified inline (5)}\n-//! println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n-//!\n-//! // Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision specified in arg 0 (5)}\n-//! println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n-//!\n-//! // Hello {arg 0 (\"x\")} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n-//! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n-//!\n-//! // Hello {next arg (\"x\")} is {second of next two args (0.01) with precision\n-//! //                          specified in first of next two args (5)}\n-//! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n-//!\n-//! // Hello {next arg (\"x\")} is {arg 2 (0.01) with precision\n-//! //                          specified in its predecessor (5)}\n-//! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n-//!\n-//! // Hello {next arg (\"x\")} is {arg \"number\" (0.01) with precision specified\n-//! //                          in arg \"prec\" (5)}\n-//! println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n-//! ```\n-//!\n-//! While these:\n-//!\n-//! ```\n-//! println!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\n-//! println!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\n-//! println!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n-//! ```\n-//!\n-//! print two significantly different things:\n-//!\n-//! ```text\n-//! Hello, `1234.560` has 3 fractional digits\n-//! Hello, `123` has 3 characters\n-//! Hello, `     123` has 3 right-aligned characters\n-//! ```\n-//!\n-//! # Escaping\n-//!\n-//! The literal characters `{` and `}` may be included in a string by preceding\n-//! them with the same character. For example, the `{` character is escaped with\n-//! `{{` and the `}` character is escaped with `}}`.\n-//!\n //! [`usize`]: ../../std/primitive.usize.html\n //! [`isize`]: ../../std/primitive.isize.html\n //! [`i8`]: ../../std/primitive.i8.html"}]}