{"sha": "d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwMWVkOGFkOGU1MTdlNDFkM2U0ZjVhMjViYTkyNmFiNzY5ZDdiMWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-11T15:26:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-11T15:26:57Z"}, "message": "Auto merge of #30676 - nikomatsakis:issue-29857, r=arielb1\n\nThis is an alternative to https://github.com/rust-lang/rust/pull/29954 for fixing #29857 that seems to me to be more inline with the general strategy around `TyError`. It also includes the fix for #30589 -- in fact, just the minimal change of making `ty_is_local` tolerate `TyError` avoids the ICE, but you get a lot of duplicate error reports, so in the case where the impl's trait reference already includes `TyError`, we just ignore the impl altogether.\n\ncc @arielb1 @sanxiyn\n\nFixes #29857.\nFixes #30589.", "tree": {"sha": "e94680913a2665bf32970678558b342abfe766c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e94680913a2665bf32970678558b342abfe766c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "html_url": "https://github.com/rust-lang/rust/commit/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cf69aa9513e477ec0872f9a324b7a63609a8843", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cf69aa9513e477ec0872f9a324b7a63609a8843", "html_url": "https://github.com/rust-lang/rust/commit/5cf69aa9513e477ec0872f9a324b7a63609a8843"}, {"sha": "b0f6a47a0f05af991d8b0e40b29ac8290ac845f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0f6a47a0f05af991d8b0e40b29ac8290ac845f5", "html_url": "https://github.com/rust-lang/rust/commit/b0f6a47a0f05af991d8b0e40b29ac8290ac845f5"}], "stats": {"total": 323, "additions": 271, "deletions": 52}, "files": [{"sha": "0f95aa74b6fd731f5f93720b23e09067219ffff5", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -63,9 +63,9 @@ fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n                                                                 b_def_id,\n                                                                 util::fresh_type_vars_for_impl);\n \n-    debug!(\"overlap: a_trait_ref={:?}\", a_trait_ref);\n+    debug!(\"overlap: a_trait_ref={:?} a_obligations={:?}\", a_trait_ref, a_obligations);\n \n-    debug!(\"overlap: b_trait_ref={:?}\", b_trait_ref);\n+    debug!(\"overlap: b_trait_ref={:?} b_obligations={:?}\", b_trait_ref, b_obligations);\n \n     // Do `a` and `b` unify? If not, no overlap.\n     if let Err(_) = infer::mk_eq_trait_refs(selcx.infcx(),\n@@ -330,8 +330,11 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n             tt.principal_def_id().is_local()\n         }\n \n-        ty::TyClosure(..) |\n         ty::TyError => {\n+            true\n+        }\n+\n+        ty::TyClosure(..) => {\n             tcx.sess.bug(\n                 &format!(\"ty_is_local invoked on unexpected type: {:?}\",\n                         ty))"}, {"sha": "e9d7b330d07acc17f15bbc29f093e63dd3812872", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -426,11 +426,25 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n     }\n }\n \n-/// in various error cases, we just set TyError and return an obligation\n-/// that, when fulfilled, will lead to an error.\n+/// If we are projecting `<T as Trait>::Item`, but `T: Trait` does not\n+/// hold. In various error cases, we cannot generate a valid\n+/// normalized projection. Therefore, we create an inference variable\n+/// return an associated obligation that, when fulfilled, will lead to\n+/// an error.\n ///\n-/// FIXME: the TyError created here can enter the obligation we create,\n-/// leading to error messages involving TyError.\n+/// Note that we used to return `TyError` here, but that was quite\n+/// dubious -- the premise was that an error would *eventually* be\n+/// reported, when the obligation was processed. But in general once\n+/// you see a `TyError` you are supposed to be able to assume that an\n+/// error *has been* reported, so that you can take whatever heuristic\n+/// paths you want to take. To make things worse, it was possible for\n+/// cycles to arise, where you basically had a setup like `<MyType<$0>\n+/// as Trait>::Foo == $0`. Here, normalizing `<MyType<$0> as\n+/// Trait>::Foo> to `[type error]` would lead to an obligation of\n+/// `<MyType<[type error]> as Trait>::Foo`.  We are supposed to report\n+/// an error for this obligation, but we legitimately should not,\n+/// because it contains `[type error]`. Yuck! (See issue #29857 for\n+/// one case where this arose.)\n fn normalize_to_error<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                                projection_ty: ty::ProjectionTy<'tcx>,\n                                cause: ObligationCause<'tcx>,\n@@ -441,8 +455,9 @@ fn normalize_to_error<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     let trait_obligation = Obligation { cause: cause,\n                                         recursion_depth: depth,\n                                         predicate: trait_ref.to_predicate() };\n+    let new_value = selcx.infcx().next_ty_var();\n     Normalized {\n-        value: selcx.tcx().types.err,\n+        value: new_value,\n         obligations: vec!(trait_obligation)\n     }\n }"}, {"sha": "f6d0da904a40f0bd15b197c854a0777da08aeaff", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -210,8 +210,6 @@ enum SelectionCandidate<'tcx> {\n     BuiltinObjectCandidate,\n \n     BuiltinUnsizeCandidate,\n-\n-    ErrorCandidate,\n }\n \n struct SelectionCandidateSet<'tcx> {\n@@ -753,8 +751,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                               stack: &TraitObligationStack<'o, 'tcx>)\n                                               -> SelectionResult<'tcx, SelectionCandidate<'tcx>>\n     {\n-        if stack.obligation.predicate.0.self_ty().references_error() {\n-            return Ok(Some(ErrorCandidate));\n+        if stack.obligation.predicate.references_error() {\n+            // If we encounter a `TyError`, we generally prefer the\n+            // most \"optimistic\" result in response -- that is, the\n+            // one least likely to report downstream errors. But\n+            // because this routine is shared by coherence and by\n+            // trait selection, there isn't an obvious \"right\" choice\n+            // here in that respect, so we opt to just return\n+            // ambiguity and let the upstream clients sort it out.\n+            return Ok(None);\n         }\n \n         if !self.is_knowable(stack) {\n@@ -1587,7 +1592,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     true\n                 },\n                 &ParamCandidate(..) => false,\n-                &ErrorCandidate => false // propagate errors\n             },\n             _ => false\n         }\n@@ -1998,10 +2002,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     try!(self.confirm_builtin_candidate(obligation, builtin_bound))))\n             }\n \n-            ErrorCandidate => {\n-                Ok(VtableBuiltin(VtableBuiltinData { nested: vec![] }))\n-            }\n-\n             ParamCandidate(param) => {\n                 let obligations = self.confirm_param_candidate(obligation, param);\n                 Ok(VtableParam(obligations))"}, {"sha": "8f64e85de4b0f4708d6b481d9b53c0b48139431f", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -69,6 +69,7 @@ use middle::ty::adjustment::{AutoAdjustment, AutoDerefRef, AdjustDerefRef};\n use middle::ty::adjustment::{AutoPtr, AutoUnsafe, AdjustReifyFnPointer};\n use middle::ty::adjustment::{AdjustUnsafeFnPointer};\n use middle::ty::{self, LvaluePreference, TypeAndMut, Ty};\n+use middle::ty::fold::TypeFoldable;\n use middle::ty::error::TypeError;\n use middle::ty::relate::RelateResult;\n use util::common::indent;\n@@ -110,10 +111,15 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                a,\n                b);\n \n+        let a = self.fcx.infcx().shallow_resolve(a);\n+\n+        // Just ignore error types.\n+        if a.references_error() || b.references_error() {\n+            return Ok(None);\n+        }\n+\n         // Consider coercing the subtype to a DST\n-        let unsize = self.unpack_actual_value(a, |a| {\n-            self.coerce_unsized(a, b)\n-        });\n+        let unsize = self.coerce_unsized(a, b);\n         if unsize.is_ok() {\n             return unsize;\n         }\n@@ -124,39 +130,33 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // See above for details.\n         match b.sty {\n             ty::TyRawPtr(mt_b) => {\n-                return self.unpack_actual_value(a, |a| {\n-                    self.coerce_unsafe_ptr(a, b, mt_b.mutbl)\n-                });\n+                return self.coerce_unsafe_ptr(a, b, mt_b.mutbl);\n             }\n \n             ty::TyRef(_, mt_b) => {\n-                return self.unpack_actual_value(a, |a| {\n-                    self.coerce_borrowed_pointer(expr_a, a, b, mt_b.mutbl)\n-                });\n+                return self.coerce_borrowed_pointer(expr_a, a, b, mt_b.mutbl);\n             }\n \n             _ => {}\n         }\n \n-        self.unpack_actual_value(a, |a| {\n-            match a.sty {\n-                ty::TyBareFn(Some(_), a_f) => {\n-                    // Function items are coercible to any closure\n-                    // type; function pointers are not (that would\n-                    // require double indirection).\n-                    self.coerce_from_fn_item(a, a_f, b)\n-                }\n-                ty::TyBareFn(None, a_f) => {\n-                    // We permit coercion of fn pointers to drop the\n-                    // unsafe qualifier.\n-                    self.coerce_from_fn_pointer(a, a_f, b)\n-                }\n-                _ => {\n-                    // Otherwise, just use subtyping rules.\n-                    self.subtype(a, b)\n-                }\n+        match a.sty {\n+            ty::TyBareFn(Some(_), a_f) => {\n+                // Function items are coercible to any closure\n+                // type; function pointers are not (that would\n+                // require double indirection).\n+                self.coerce_from_fn_item(a, a_f, b)\n             }\n-        })\n+            ty::TyBareFn(None, a_f) => {\n+                // We permit coercion of fn pointers to drop the\n+                // unsafe qualifier.\n+                self.coerce_from_fn_pointer(a, a_f, b)\n+            }\n+            _ => {\n+                // Otherwise, just use subtyping rules.\n+                self.subtype(a, b)\n+            }\n+        }\n     }\n \n     /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`."}, {"sha": "e644178ddd62f26bec6680ae47689213f15f95a1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -1038,6 +1038,9 @@ fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          t_cast: Ty<'tcx>,\n                                          t_expr: Ty<'tcx>,\n                                          id: ast::NodeId) {\n+    if t_cast.references_error() || t_expr.references_error() {\n+        return;\n+    }\n     let tstr = fcx.infcx().ty_to_string(t_cast);\n     let mut err = fcx.type_error_struct(span, |actual| {\n         format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n@@ -3511,9 +3514,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let t_cast = structurally_resolved_type(fcx, expr.span, t_cast);\n         check_expr_with_expectation(fcx, e, ExpectCastableToType(t_cast));\n         let t_expr = fcx.expr_ty(e);\n+        let t_cast = fcx.infcx().resolve_type_vars_if_possible(&t_cast);\n \n         // Eagerly check for some obvious errors.\n-        if t_expr.references_error() {\n+        if t_expr.references_error() || t_cast.references_error() {\n             fcx.write_error(id);\n         } else if !fcx.type_is_known_to_be_sized(t_cast, expr.span) {\n             report_cast_to_unsized_type(fcx, expr.span, t.span, e.span, t_cast, t_expr, id);"}, {"sha": "7465ff526b6de1398b569cbd55f74ef67e78e663", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -149,11 +149,23 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                    trait_ref,\n                    item.name);\n \n+            // Skip impls where one of the self type is an error type.\n+            // This occurs with e.g. resolve failures (#30589).\n+            if trait_ref.references_error() {\n+                return;\n+            }\n+\n             enforce_trait_manually_implementable(self.crate_context.tcx,\n                                                  item.span,\n                                                  trait_ref.def_id);\n             self.add_trait_impl(trait_ref, impl_did);\n         } else {\n+            // Skip inherent impls where the self type is an error\n+            // type. This occurs with e.g. resolve failures (#30589).\n+            if self_type.ty.references_error() {\n+                return;\n+            }\n+\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n             // the implementation does not have any associated traits."}, {"sha": "3de79454398387338cdf8498c8a94d8383692f7b", "filename": "src/test/compile-fail/coherence-projection-conflict-orphan.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-orphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-orphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-orphan.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+// Here we expect a coherence conflict because, even though `i32` does\n+// not implement `Iterator`, we cannot rely on that negative reasoning\n+// due to the orphan rules. Therefore, `A::Item` may yet turn out to\n+// be `i32`.\n+\n+pub trait Foo<P> {}\n+\n+pub trait Bar {\n+    type Output: 'static;\n+}\n+\n+impl Foo<i32> for i32 { } //~ ERROR E0119\n+\n+impl<A:Iterator> Foo<A::Item> for A { }\n+\n+fn main() {}"}, {"sha": "6880f3e9a3cc9aeecd0ad58182c3b493a03202c8", "filename": "src/test/compile-fail/coherence-projection-conflict-ty-param.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-ty-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-ty-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-ty-param.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Coherence error results because we do not know whether `T: Foo<P>` or not\n+// for the second impl.\n+\n+use std::marker::PhantomData;\n+\n+pub trait Foo<P> {}\n+\n+impl <P, T: Foo<P>> Foo<P> for Option<T> {} //~ ERROR E0119\n+\n+impl<T, U> Foo<T> for Option<U> { }\n+\n+fn main() {}"}, {"sha": "2236e71b53fff1cd7aaa516e972bbc97a88ab3a2", "filename": "src/test/compile-fail/coherence-projection-conflict.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::marker::PhantomData;\n+\n+pub trait Foo<P> {}\n+\n+pub trait Bar {\n+    type Output: 'static;\n+}\n+\n+impl Foo<i32> for i32 { } //~ ERROR E0119\n+\n+impl<A:Bar> Foo<A::Output> for A { }\n+\n+impl Bar for i32 {\n+    type Output = i32;\n+}\n+\n+fn main() {}"}, {"sha": "a52af0873a8231e936c9c6acdee561515c14b9f3", "filename": "src/test/compile-fail/coherence-projection-ok-orphan.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-ok-orphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-ok-orphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-ok-orphan.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+// Here we do not get a coherence conflict because `Baz: Iterator`\n+// does not hold and (due to the orphan rules), we can rely on that.\n+\n+pub trait Foo<P> {}\n+\n+pub trait Bar {\n+    type Output: 'static;\n+}\n+\n+struct Baz;\n+impl Foo<i32> for Baz { }\n+\n+impl<A:Iterator> Foo<A::Item> for A { }\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "af88f3744eaeb428c768276bfa282382ce5905ff", "filename": "src/test/compile-fail/coherence-projection-ok.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-ok.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+pub trait Foo<P> {}\n+\n+pub trait Bar {\n+    type Output: 'static;\n+}\n+\n+impl Foo<i32> for i32 { }\n+\n+impl<A:Bar> Foo<A::Output> for A { }\n+\n+impl Bar for i32 {\n+    type Output = u32;\n+}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "253285d3919c21937c4c5ebb4ee90fdfc7eb6a44", "filename": "src/test/compile-fail/const-eval-overflow-4b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -22,7 +22,7 @@ use std::{u8, u16, u32, u64, usize};\n const A_I8_T\n     : [u32; (i8::MAX as i8 + 1u8) as usize]\n     //~^ ERROR mismatched types\n-    //~| the trait `core::ops::Add<u8>` is not implemented for the type `i8`\n+    //~| ERROR the trait `core::ops::Add<u8>` is not implemented for the type `i8`\n     = [0; (i8::MAX as usize) + 1];\n \n fn main() {"}, {"sha": "53ad2416878942e4e6d6a8261f14cab53c5117a3", "filename": "src/test/compile-fail/issue-19692.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -12,7 +12,7 @@ struct Homura;\n \n fn akemi(homura: Homura) {\n     let Some(ref madoka) = Some(homura.kaname()); //~ ERROR no method named `kaname` found\n-    madoka.clone(); //~ ERROR the type of this value must be known in this context\n+    madoka.clone(); //~ ERROR the type of this value must be known\n }\n \n fn main() { }"}, {"sha": "ef6ce5c995bf3f91803e2c7362498f00138d9750", "filename": "src/test/compile-fail/issue-21950.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fissue-21950.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fissue-21950.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21950.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -16,5 +16,5 @@ fn main() {\n     let x = &10 as\n             &Add;\n             //~^ ERROR the type parameter `RHS` must be explicitly specified in an object type because its default value `Self` references the type `Self`\n-            //~^^ ERROR the value of the associated type `Output` (from the trait `core::ops::Add`) must be specified\n+            //~| ERROR the value of the associated type `Output` (from the trait `core::ops::Add`) must be specified\n }"}, {"sha": "7f9c7a292f2be0c7de7921b9ecbfcc483c35dabb", "filename": "src/test/compile-fail/issue-23966.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fissue-23966.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fissue-23966.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23966.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -9,5 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    \"\".chars().fold(|_, _| (), ()); //~ ERROR is not implemented for the type `()`\n+    \"\".chars().fold(|_, _| (), ());\n+    //~^ ERROR E0277\n+    //~| ERROR E0277\n }"}, {"sha": "4b0773140566c06fb1bf9923da9ac4b8715ef4ed", "filename": "src/test/compile-fail/issue-24352.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fissue-24352.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fissue-24352.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24352.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     1.0f64 - 1.0;\n-    1.0f64 - 1 //~ ERROR: is not implemented\n+    1.0f64 - 1 //~ ERROR E0277\n }"}, {"sha": "661579f52b6845e902544481cd873bfc03e76b0e", "filename": "src/test/compile-fail/issue-29857.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fissue-29857.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fissue-29857.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-29857.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#![feature(rustc_attrs)]\n+\n+use std::marker::PhantomData;\n+\n+pub trait Foo<P> {}\n+\n+impl <P, T: Foo<P>> Foo<P> for Option<T> {}\n+\n+pub struct Qux<T> (PhantomData<*mut T>);\n+\n+impl<T> Foo<*mut T> for Option<Qux<T>> {}\n+\n+pub trait Bar {\n+    type Output: 'static;\n+}\n+\n+impl<T: 'static, W: Bar<Output = T>> Foo<*mut T> for W {}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "32765d5acb4fefbb5d93f8daa1932fc51fc62916", "filename": "src/test/compile-fail/issue-30589.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fissue-30589.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fissue-30589.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30589.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+\n+impl fmt::Display for DecoderError { //~ ERROR E0412\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Missing data: {}\", self.0)\n+    }\n+}\n+fn main() {\n+}"}, {"sha": "54eb2a908295568ce1d49356b954d4cd959f02b2", "filename": "src/test/compile-fail/issue-3973.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs?ref=d01ed8ad8e517e41d3e4f5a25ba926ab769d7b1b", "patch": "@@ -31,6 +31,5 @@ impl ToString_ for Point {\n fn main() {\n     let p = Point::new(0.0, 0.0);\n     //~^ ERROR no associated item named `new` found for type `Point` in the current scope\n-    println!(\"{}\", p.to_string());\n-    //~^ ERROR the type of this value must be known in this context\n+    println!(\"{}\", p.to_string()); //~ ERROR type of this value must be known\n }"}]}