{"sha": "7134fc8de6c50b48af688c5c530d63c788215663", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMzRmYzhkZTZjNTBiNDhhZjY4OGM1YzUzMGQ2M2M3ODgyMTU2NjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-15T19:22:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-15T19:22:21Z"}, "message": "auto merge of #17983 : jakub-/rust/memoize-things, r=pcwalton", "tree": {"sha": "f23e0d10a3698a9d9735817c1dda6f309d4daae2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f23e0d10a3698a9d9735817c1dda6f309d4daae2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7134fc8de6c50b48af688c5c530d63c788215663", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7134fc8de6c50b48af688c5c530d63c788215663", "html_url": "https://github.com/rust-lang/rust/commit/7134fc8de6c50b48af688c5c530d63c788215663", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7134fc8de6c50b48af688c5c530d63c788215663/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4761c85b52ac9953a7ac1f89d9e09a79389b4fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4761c85b52ac9953a7ac1f89d9e09a79389b4fd", "html_url": "https://github.com/rust-lang/rust/commit/e4761c85b52ac9953a7ac1f89d9e09a79389b4fd"}, {"sha": "dbc4a4b53b91e687429db622626a6eb221252b04", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc4a4b53b91e687429db622626a6eb221252b04", "html_url": "https://github.com/rust-lang/rust/commit/dbc4a4b53b91e687429db622626a6eb221252b04"}], "stats": {"total": 372, "additions": 182, "deletions": 190}, "files": [{"sha": "6d5cd6061cfae9940e744eb9b63661b768129645", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7134fc8de6c50b48af688c5c530d63c788215663/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7134fc8de6c50b48af688c5c530d63c788215663/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=7134fc8de6c50b48af688c5c530d63c788215663", "patch": "@@ -29,12 +29,9 @@ This API is completely unstable and subject to change.\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![allow(deprecated)]\n-#![allow(unknown_features)]\n-#![feature(macro_rules, globs, struct_variant, quote)]\n-#![feature(default_type_params, phase, unsafe_destructor, slicing_syntax)]\n-\n+#![feature(default_type_params, globs, if_let, import_shadowing, macro_rules, phase, quote)]\n+#![feature(slicing_syntax, struct_variant, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(import_shadowing)]\n \n extern crate arena;\n extern crate debug;"}, {"sha": "06d3623006813e227f58263a1457ba839eafa173", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 124, "deletions": 183, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/7134fc8de6c50b48af688c5c530d63c788215663/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7134fc8de6c50b48af688c5c530d63c788215663/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7134fc8de6c50b48af688c5c530d63c788215663", "patch": "@@ -33,7 +33,7 @@ use middle;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n use util::ppaux::{trait_store_to_string, ty_to_string};\n use util::ppaux::{Repr, UserString};\n-use util::common::{indenter};\n+use util::common::{indenter, memoized, memoized_with_key};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet, FnvHashMap};\n \n use std::cell::{Cell, RefCell};\n@@ -2118,53 +2118,36 @@ pub fn type_needs_drop(cx: &ctxt, ty: t) -> bool {\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n pub fn type_needs_unwind_cleanup(cx: &ctxt, ty: t) -> bool {\n-    match cx.needs_unwind_cleanup_cache.borrow().find(&ty) {\n-        Some(&result) => return result,\n-        None => ()\n-    }\n+    return memoized(&cx.needs_unwind_cleanup_cache, ty, |ty| {\n+        type_needs_unwind_cleanup_(cx, ty, &mut HashSet::new())\n+    });\n \n-    let mut tycache = HashSet::new();\n-    let needs_unwind_cleanup =\n-        type_needs_unwind_cleanup_(cx, ty, &mut tycache);\n-    cx.needs_unwind_cleanup_cache.borrow_mut().insert(ty, needs_unwind_cleanup);\n-    needs_unwind_cleanup\n-}\n+    fn type_needs_unwind_cleanup_(cx: &ctxt, ty: t, tycache: &mut HashSet<t>) -> bool {\n+        // Prevent infinite recursion\n+        if !tycache.insert(ty) {\n+            return false;\n+        }\n \n-fn type_needs_unwind_cleanup_(cx: &ctxt, ty: t,\n-                              tycache: &mut HashSet<t>) -> bool {\n+        let mut needs_unwind_cleanup = false;\n+        maybe_walk_ty(ty, |ty| {\n+            needs_unwind_cleanup |= match get(ty).sty {\n+                ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) |\n+                ty_float(_) | ty_tup(_) | ty_ptr(_) => false,\n \n-    // Prevent infinite recursion\n-    if !tycache.insert(ty) {\n-        return false;\n-    }\n+                ty_enum(did, ref substs) =>\n+                    enum_variants(cx, did).iter().any(|v|\n+                        v.args.iter().any(|aty| {\n+                            let t = aty.subst(cx, substs);\n+                            type_needs_unwind_cleanup_(cx, t, tycache)\n+                        })\n+                    ),\n \n-    let mut needs_unwind_cleanup = false;\n-    maybe_walk_ty(ty, |ty| {\n-        let result = match get(ty).sty {\n-          ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-          ty_tup(_) | ty_ptr(_) => {\n-            true\n-          }\n-          ty_enum(did, ref substs) => {\n-            for v in (*enum_variants(cx, did)).iter() {\n-                for aty in v.args.iter() {\n-                    let t = aty.subst(cx, substs);\n-                    needs_unwind_cleanup |=\n-                        type_needs_unwind_cleanup_(cx, t, tycache);\n-                }\n-            }\n+                _ => true\n+            };\n             !needs_unwind_cleanup\n-          }\n-          _ => {\n-            needs_unwind_cleanup = true;\n-            false\n-          }\n-        };\n-\n-        result\n-    });\n-\n-    needs_unwind_cleanup\n+        });\n+        needs_unwind_cleanup\n+    }\n }\n \n /**\n@@ -2179,6 +2162,7 @@ fn type_needs_unwind_cleanup_(cx: &ctxt, ty: t,\n  * easier for me (nmatsakis) to think about what is contained within\n  * a type than to think about what is *not* contained within a type.\n  */\n+#[deriving(Clone)]\n pub struct TypeContents {\n     pub bits: u64\n }\n@@ -2359,18 +2343,9 @@ pub fn type_interior_is_unsafe(cx: &ctxt, t: ty::t) -> bool {\n }\n \n pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n-    let ty_id = type_id(ty);\n-\n-    match cx.tc_cache.borrow().find(&ty_id) {\n-        Some(tc) => { return *tc; }\n-        None => {}\n-    }\n-\n-    let mut cache = HashMap::new();\n-    let result = tc_ty(cx, ty, &mut cache);\n-\n-    cx.tc_cache.borrow_mut().insert(ty_id, result);\n-    return result;\n+    return memoized_with_key(&cx.tc_cache, ty, |ty| {\n+        tc_ty(cx, ty, &mut HashMap::new())\n+    }, |&ty| type_id(ty));\n \n     fn tc_ty(cx: &ctxt,\n              ty: t,\n@@ -4034,9 +4009,8 @@ pub fn impl_or_trait_item(cx: &ctxt, id: ast::DefId) -> ImplOrTraitItem {\n /// Returns true if the given ID refers to an associated type and false if it\n /// refers to anything else.\n pub fn is_associated_type(cx: &ctxt, id: ast::DefId) -> bool {\n-    let result = match cx.associated_types.borrow_mut().find(&id) {\n-        Some(result) => return *result,\n-        None if id.krate == ast::LOCAL_CRATE => {\n+    memoized(&cx.associated_types, id, |id: ast::DefId| {\n+        if id.krate == ast::LOCAL_CRATE {\n             match cx.impl_or_trait_items.borrow().find(&id) {\n                 Some(ref item) => {\n                     match **item {\n@@ -4046,14 +4020,10 @@ pub fn is_associated_type(cx: &ctxt, id: ast::DefId) -> bool {\n                 }\n                 None => false,\n             }\n-        }\n-        None => {\n+        } else {\n             csearch::is_associated_type(&cx.sess.cstore, id)\n         }\n-    };\n-\n-    cx.associated_types.borrow_mut().insert(id, result);\n-    result\n+    })\n }\n \n /// Returns the parameter index that the given associated type corresponds to.\n@@ -4111,35 +4081,29 @@ pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n }\n \n pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<Rc<TraitRef>> {\n-    match cx.impl_trait_cache.borrow().find(&id) {\n-        Some(ret) => { return ret.clone(); }\n-        None => {}\n-    }\n-\n-    let ret = if id.krate == ast::LOCAL_CRATE {\n-        debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n-        match cx.map.find(id.node) {\n-            Some(ast_map::NodeItem(item)) => {\n-                match item.node {\n-                    ast::ItemImpl(_, ref opt_trait, _, _) => {\n-                        match opt_trait {\n-                            &Some(ref t) => {\n-                                Some(ty::node_id_to_trait_ref(cx, t.ref_id))\n+    memoized(&cx.impl_trait_cache, id, |id: ast::DefId| {\n+        if id.krate == ast::LOCAL_CRATE {\n+            debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n+            match cx.map.find(id.node) {\n+                Some(ast_map::NodeItem(item)) => {\n+                    match item.node {\n+                        ast::ItemImpl(_, ref opt_trait, _, _) => {\n+                            match opt_trait {\n+                                &Some(ref t) => {\n+                                    Some(ty::node_id_to_trait_ref(cx, t.ref_id))\n+                                }\n+                                &None => None\n                             }\n-                            &None => None\n                         }\n+                        _ => None\n                     }\n-                    _ => None\n                 }\n+                _ => None\n             }\n-            _ => None\n+        } else {\n+            csearch::get_impl_trait(cx, id)\n         }\n-    } else {\n-        csearch::get_impl_trait(cx, id)\n-    };\n-\n-    cx.impl_trait_cache.borrow_mut().insert(id, ret.clone());\n-    ret\n+    })\n }\n \n pub fn trait_ref_to_def_id(tcx: &ctxt, tr: &ast::TraitRef) -> ast::DefId {\n@@ -4325,73 +4289,67 @@ pub fn type_is_empty(cx: &ctxt, t: t) -> bool {\n }\n \n pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n-    match cx.enum_var_cache.borrow().find(&id) {\n-        Some(variants) => return variants.clone(),\n-        _ => { /* fallthrough */ }\n-    }\n-\n-    let result = if ast::LOCAL_CRATE != id.krate {\n-        Rc::new(csearch::get_enum_variants(cx, id))\n-    } else {\n-        /*\n-          Although both this code and check_enum_variants in typeck/check\n-          call eval_const_expr, it should never get called twice for the same\n-          expr, since check_enum_variants also updates the enum_var_cache\n-         */\n-        match cx.map.get(id.node) {\n-            ast_map::NodeItem(ref item) => {\n-                match item.node {\n-                    ast::ItemEnum(ref enum_definition, _) => {\n-                        let mut last_discriminant: Option<Disr> = None;\n-                        Rc::new(enum_definition.variants.iter().map(|variant| {\n-\n-                            let mut discriminant = match last_discriminant {\n-                                Some(val) => val + 1,\n-                                None => INITIAL_DISCRIMINANT_VALUE\n-                            };\n-\n-                            match variant.node.disr_expr {\n-                                Some(ref e) => match const_eval::eval_const_expr_partial(cx, &**e) {\n-                                    Ok(const_eval::const_int(val)) => {\n-                                        discriminant = val as Disr\n-                                    }\n-                                    Ok(const_eval::const_uint(val)) => {\n-                                        discriminant = val as Disr\n-                                    }\n-                                    Ok(_) => {\n-                                        cx.sess\n-                                          .span_err(e.span,\n-                                                    \"expected signed integer constant\");\n-                                    }\n-                                    Err(ref err) => {\n-                                        cx.sess\n-                                          .span_err(e.span,\n-                                                    format!(\"expected constant: {}\",\n-                                                            *err).as_slice());\n-                                    }\n-                                },\n-                                None => {}\n-                            };\n-\n-                            last_discriminant = Some(discriminant);\n-                            Rc::new(VariantInfo::from_ast_variant(cx, &**variant,\n-                                                                  discriminant))\n-                        }).collect())\n-                    }\n-                    _ => {\n-                        cx.sess.bug(\"enum_variants: id not bound to an enum\")\n+    memoized(&cx.enum_var_cache, id, |id: ast::DefId| {\n+        if ast::LOCAL_CRATE != id.krate {\n+            Rc::new(csearch::get_enum_variants(cx, id))\n+        } else {\n+            /*\n+              Although both this code and check_enum_variants in typeck/check\n+              call eval_const_expr, it should never get called twice for the same\n+              expr, since check_enum_variants also updates the enum_var_cache\n+             */\n+            match cx.map.get(id.node) {\n+                ast_map::NodeItem(ref item) => {\n+                    match item.node {\n+                        ast::ItemEnum(ref enum_definition, _) => {\n+                            let mut last_discriminant: Option<Disr> = None;\n+                            Rc::new(enum_definition.variants.iter().map(|variant| {\n+\n+                                let mut discriminant = match last_discriminant {\n+                                    Some(val) => val + 1,\n+                                    None => INITIAL_DISCRIMINANT_VALUE\n+                                };\n+\n+                                match variant.node.disr_expr {\n+                                    Some(ref e) =>\n+                                        match const_eval::eval_const_expr_partial(cx, &**e) {\n+                                            Ok(const_eval::const_int(val)) => {\n+                                                discriminant = val as Disr\n+                                            }\n+                                            Ok(const_eval::const_uint(val)) => {\n+                                                discriminant = val as Disr\n+                                            }\n+                                            Ok(_) => {\n+                                                cx.sess\n+                                                  .span_err(e.span,\n+                                                            \"expected signed integer constant\");\n+                                            }\n+                                            Err(ref err) => {\n+                                                cx.sess\n+                                                  .span_err(e.span,\n+                                                            format!(\"expected constant: {}\",\n+                                                                    *err).as_slice());\n+                                            }\n+                                        },\n+                                    None => {}\n+                                };\n+\n+                                last_discriminant = Some(discriminant);\n+                                Rc::new(VariantInfo::from_ast_variant(cx, &**variant,\n+                                                                      discriminant))\n+                            }).collect())\n+                        }\n+                        _ => {\n+                            cx.sess.bug(\"enum_variants: id not bound to an enum\")\n+                        }\n                     }\n                 }\n+                _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n             }\n-            _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n         }\n-    };\n-\n-    cx.enum_var_cache.borrow_mut().insert(id, result.clone());\n-    result\n+    })\n }\n \n-\n // Returns information about the enum variant with the given ID:\n pub fn enum_variant_with_id(cx: &ctxt,\n                             enum_id: ast::DefId,\n@@ -4415,21 +4373,11 @@ pub fn lookup_item_type(cx: &ctxt,\n }\n \n /// Given the did of a trait, returns its canonical trait ref.\n-pub fn lookup_trait_def(cx: &ctxt, did: ast::DefId) -> Rc<ty::TraitDef> {\n-    let mut trait_defs = cx.trait_defs.borrow_mut();\n-    match trait_defs.find_copy(&did) {\n-        Some(trait_def) => {\n-            // The item is in this crate. The caller should have added it to the\n-            // type cache already\n-            trait_def\n-        }\n-        None => {\n-            assert!(did.krate != ast::LOCAL_CRATE);\n-            let trait_def = Rc::new(csearch::get_trait_def(cx, did));\n-            trait_defs.insert(did, trait_def.clone());\n-            trait_def\n-        }\n-    }\n+pub fn lookup_trait_def(cx: &ctxt, did: DefId) -> Rc<ty::TraitDef> {\n+    memoized(&cx.trait_defs, did, |did: DefId| {\n+        assert!(did.krate != ast::LOCAL_CRATE);\n+        Rc::new(csearch::get_trait_def(cx, did))\n+    })\n }\n \n /// Given a reference to a trait, returns the bounds declared on the\n@@ -4490,26 +4438,19 @@ pub fn lookup_simd(tcx: &ctxt, did: DefId) -> bool {\n \n /// Obtain the representation annotation for a struct definition.\n pub fn lookup_repr_hints(tcx: &ctxt, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n-    match tcx.repr_hint_cache.borrow().find(&did) {\n-        None => {}\n-        Some(ref hints) => return (*hints).clone(),\n-    }\n-\n-    let acc = if did.krate == LOCAL_CRATE {\n-        let mut acc = Vec::new();\n-        ty::each_attr(tcx, did, |meta| {\n-            acc.extend(attr::find_repr_attrs(tcx.sess.diagnostic(),\n-                                             meta).into_iter());\n-            true\n-        });\n-        acc\n-    } else {\n-        csearch::get_repr_attrs(&tcx.sess.cstore, did)\n-    };\n-\n-    let acc = Rc::new(acc);\n-    tcx.repr_hint_cache.borrow_mut().insert(did, acc.clone());\n-    acc\n+    memoized(&tcx.repr_hint_cache, did, |did: DefId| {\n+        Rc::new(if did.krate == LOCAL_CRATE {\n+            let mut acc = Vec::new();\n+            ty::each_attr(tcx, did, |meta| {\n+                acc.extend(attr::find_repr_attrs(tcx.sess.diagnostic(),\n+                                                 meta).into_iter());\n+                true\n+            });\n+            acc\n+        } else {\n+            csearch::get_repr_attrs(&tcx.sess.cstore, did)\n+        })\n+    })\n }\n \n // Look up a field ID, whether or not it's local"}, {"sha": "8ea9015c05d97d4d96ce5c44bad5cc05bc9e9c82", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7134fc8de6c50b48af688c5c530d63c788215663/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7134fc8de6c50b48af688c5c530d63c788215663/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=7134fc8de6c50b48af688c5c530d63c788215663", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,9 @@\n \n #![allow(non_camel_case_types)]\n \n-use std::hash::{Hash, Hasher};\n+use std::cell::RefCell;\n use std::collections::HashMap;\n+use std::hash::{Hash, Hasher};\n use syntax::ast;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -155,3 +156,56 @@ pub fn can_reach<S,H:Hasher<S>,T:Eq+Clone+Hash<S>>(\n     }\n     return false;\n }\n+\n+/// Memoizes a one-argument closure using the given RefCell containing\n+/// a type implementing MutableMap to serve as a cache.\n+///\n+/// In the future the signature of this function is expected to be:\n+/// ```\n+/// pub fn memoized<T: Clone, U: Clone, M: MutableMap<T, U>>(\n+///    cache: &RefCell<M>,\n+///    f: &|&: T| -> U\n+/// ) -> impl |&: T| -> U {\n+/// ```\n+/// but currently it is not possible.\n+///\n+/// # Example\n+/// ```\n+/// struct Context {\n+///    cache: RefCell<HashMap<uint, uint>>\n+/// }\n+///\n+/// fn factorial(ctxt: &Context, n: uint) -> uint {\n+///     memoized(&ctxt.cache, n, |n| match n {\n+///         0 | 1 => n,\n+///         _ => factorial(ctxt, n - 2) + factorial(ctxt, n - 1)\n+///     })\n+/// }\n+/// ```\n+#[inline(always)]\n+pub fn memoized<T: Clone, U: Clone, M: MutableMap<T, U>>(\n+    cache: &RefCell<M>,\n+    arg: T,\n+    f: |T| -> U\n+) -> U {\n+    memoized_with_key(cache, arg, f, |arg| arg.clone())\n+}\n+\n+#[inline(always)]\n+pub fn memoized_with_key<T, K, U: Clone, M: MutableMap<K, U>>(\n+    cache: &RefCell<M>,\n+    arg: T,\n+    f: |T| -> U,\n+    k: |&T| -> K\n+) -> U {\n+    let key = k(&arg);\n+    let result = cache.borrow().find(&key).map(|result| result.clone());\n+    match result {\n+        Some(result) => result,\n+        None => {\n+            let result = f(arg);\n+            cache.borrow_mut().insert(key, result.clone());\n+            result\n+        }\n+    }\n+}"}]}