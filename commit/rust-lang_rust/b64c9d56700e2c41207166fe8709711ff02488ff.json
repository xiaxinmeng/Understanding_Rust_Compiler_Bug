{"sha": "b64c9d56700e2c41207166fe8709711ff02488ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2NGM5ZDU2NzAwZTJjNDEyMDcxNjZmZTg3MDk3MTFmZjAyNDg4ZmY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-05-24T21:24:44Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-05-31T03:46:32Z"}, "message": "std: Clean out old unstable + deprecated APIs\n\nThese should all have been deprecated for at least one cycle, so this commit\ncleans them all out.", "tree": {"sha": "82e982ea6a6840e3f0f4d3d82a4d2ad24771200b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82e982ea6a6840e3f0f4d3d82a4d2ad24771200b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b64c9d56700e2c41207166fe8709711ff02488ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b64c9d56700e2c41207166fe8709711ff02488ff", "html_url": "https://github.com/rust-lang/rust/commit/b64c9d56700e2c41207166fe8709711ff02488ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b64c9d56700e2c41207166fe8709711ff02488ff/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a967611d8ffececb5ed0ecf6a205b464d7a5a31e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a967611d8ffececb5ed0ecf6a205b464d7a5a31e", "html_url": "https://github.com/rust-lang/rust/commit/a967611d8ffececb5ed0ecf6a205b464d7a5a31e"}], "stats": {"total": 1264, "additions": 52, "deletions": 1212}, "files": [{"sha": "d7c11f32404395db1b82cdac20348658d62ab828", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 0, "deletions": 239, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -112,11 +112,6 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n     }\n }\n \n-/// Deprecated, renamed to EncodeUtf16\n-#[unstable(feature = \"str_utf16\", issue = \"27714\")]\n-#[rustc_deprecated(since = \"1.8.0\", reason = \"renamed to EncodeUtf16\")]\n-pub type Utf16Units<'a> = EncodeUtf16<'a>;\n-\n /// External iterator for a string's UTF-16 code units.\n ///\n /// For use with the `std::iter` module.\n@@ -352,230 +347,6 @@ impl str {\n         core_str::StrExt::slice_mut_unchecked(self, begin, end)\n     }\n \n-    /// Given a byte position, returns the next `char` and its index.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 sequence.\n-    ///\n-    /// # Examples\n-    ///\n-    /// This example manually iterates through the code points of a string;\n-    /// this should normally be\n-    /// done by `.chars()` or `.char_indices()`.\n-    ///\n-    /// ```\n-    /// #![feature(str_char)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// use std::str::CharRange;\n-    ///\n-    /// let s = \"\u4e2d\u534eVie\u0323\u0302t Nam\";\n-    /// let mut i = 0;\n-    /// while i < s.len() {\n-    ///     let CharRange {ch, next} = s.char_range_at(i);\n-    ///     println!(\"{}: {}\", i, ch);\n-    ///     i = next;\n-    /// }\n-    /// ```\n-    ///\n-    /// This outputs:\n-    ///\n-    /// ```text\n-    /// 0: \u4e2d\n-    /// 3: \u534e\n-    /// 6: V\n-    /// 7: i\n-    /// 8: e\n-    /// 9:\n-    /// 11:\n-    /// 13: t\n-    /// 14:\n-    /// 15: N\n-    /// 16: a\n-    /// 17: m\n-    /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"often replaced by char_indices, this method may \\\n-                         be removed in favor of just char_at() or eventually \\\n-                         removed altogether\",\n-               issue = \"27754\")]\n-    #[inline]\n-    #[rustc_deprecated(reason = \"use slicing plus chars() plus len_utf8\",\n-                       since = \"1.9.0\")]\n-    #[allow(deprecated)]\n-    pub fn char_range_at(&self, start: usize) -> CharRange {\n-        core_str::StrExt::char_range_at(self, start)\n-    }\n-\n-    /// Given a byte position, returns the previous `char` and its position.\n-    ///\n-    /// Note that Unicode has many features, such as combining marks, ligatures,\n-    /// and direction marks, that need to be taken into account to correctly reverse a string.\n-    ///\n-    /// Returns 0 for next index if called on start index 0.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than the length of the string.\n-    /// If `i` is not an index following a valid UTF-8 sequence.\n-    ///\n-    /// # Examples\n-    ///\n-    /// This example manually iterates through the code points of a string;\n-    /// this should normally be\n-    /// done by `.chars().rev()` or `.char_indices()`.\n-    ///\n-    /// ```\n-    /// #![feature(str_char)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// use std::str::CharRange;\n-    ///\n-    /// let s = \"\u4e2d\u534eVie\u0323\u0302t Nam\";\n-    /// let mut i = s.len();\n-    /// while i > 0 {\n-    ///     let CharRange {ch, next} = s.char_range_at_reverse(i);\n-    ///     println!(\"{}: {}\", i, ch);\n-    ///     i = next;\n-    /// }\n-    /// ```\n-    ///\n-    /// This outputs:\n-    ///\n-    /// ```text\n-    /// 18: m\n-    /// 17: a\n-    /// 16: N\n-    /// 15:\n-    /// 14: t\n-    /// 13:\n-    /// 11:\n-    /// 9: e\n-    /// 8: i\n-    /// 7: V\n-    /// 6: \u534e\n-    /// 3: \u4e2d\n-    /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"often replaced by char_indices, this method may \\\n-                         be removed in favor of just char_at_reverse() or \\\n-                         eventually removed altogether\",\n-               issue = \"27754\")]\n-    #[inline]\n-    #[rustc_deprecated(reason = \"use slicing plus chars().rev() plus len_utf8\",\n-                       since = \"1.9.0\")]\n-    #[allow(deprecated)]\n-    pub fn char_range_at_reverse(&self, start: usize) -> CharRange {\n-        core_str::StrExt::char_range_at_reverse(self, start)\n-    }\n-\n-    /// Given a byte position, returns the `char` at that position.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 sequence.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(str_char)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// let s = \"ab\u03c0c\";\n-    /// assert_eq!(s.char_at(1), 'b');\n-    /// assert_eq!(s.char_at(2), '\u03c0');\n-    /// assert_eq!(s.char_at(4), 'c');\n-    /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"frequently replaced by the chars() iterator, this \\\n-                         method may be removed or possibly renamed in the \\\n-                         future; it is normally replaced by chars/char_indices \\\n-                         iterators or by getting the first char from a \\\n-                         subslice\",\n-               issue = \"27754\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    #[rustc_deprecated(reason = \"use slicing plus chars()\",\n-                       since = \"1.9.0\")]\n-    pub fn char_at(&self, i: usize) -> char {\n-        core_str::StrExt::char_at(self, i)\n-    }\n-\n-    /// Given a byte position, returns the `char` at that position, counting\n-    /// from the end.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than the length of the string.\n-    /// If `i` is not an index following a valid UTF-8 sequence.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(str_char)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// let s = \"ab\u03c0c\";\n-    /// assert_eq!(s.char_at_reverse(1), 'a');\n-    /// assert_eq!(s.char_at_reverse(2), 'b');\n-    /// assert_eq!(s.char_at_reverse(3), '\u03c0');\n-    /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"see char_at for more details, but reverse semantics \\\n-                         are also somewhat unclear, especially with which \\\n-                         cases generate panics\",\n-               issue = \"27754\")]\n-    #[inline]\n-    #[rustc_deprecated(reason = \"use slicing plus chars().rev()\",\n-                       since = \"1.9.0\")]\n-    #[allow(deprecated)]\n-    pub fn char_at_reverse(&self, i: usize) -> char {\n-        core_str::StrExt::char_at_reverse(self, i)\n-    }\n-\n-    /// Retrieves the first `char` from a `&str` and returns it.\n-    ///\n-    /// Note that a single Unicode character (grapheme cluster)\n-    /// can be composed of multiple `char`s.\n-    ///\n-    /// This does not allocate a new string; instead, it returns a slice that\n-    /// points one code point beyond the code point that was shifted.\n-    ///\n-    /// `None` is returned if the slice is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(str_char)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// let s = \"\u0141o\u0301dz\u0301\"; // \\u{141}o\\u{301}dz\\u{301}\n-    /// let (c, s1) = s.slice_shift_char().unwrap();\n-    ///\n-    /// assert_eq!(c, '\u0141');\n-    /// assert_eq!(s1, \"o\u0301dz\u0301\");\n-    ///\n-    /// let (c, s2) = s1.slice_shift_char().unwrap();\n-    ///\n-    /// assert_eq!(c, 'o');\n-    /// assert_eq!(s2, \"\\u{301}dz\\u{301}\");\n-    /// ```\n-    #[unstable(feature = \"str_char\",\n-               reason = \"awaiting conventions about shifting and slices and \\\n-                         may not be warranted with the existence of the chars \\\n-                         and/or char_indices iterators\",\n-               issue = \"27754\")]\n-    #[inline]\n-    #[rustc_deprecated(reason = \"use chars() plus Chars::as_str\",\n-                       since = \"1.9.0\")]\n-    #[allow(deprecated)]\n-    pub fn slice_shift_char(&self) -> Option<(char, &str)> {\n-        core_str::StrExt::slice_shift_char(self)\n-    }\n-\n     /// Divide one string slice into two at an index.\n     ///\n     /// The argument, `mid`, should be a byte offset from the start of the\n@@ -867,16 +638,6 @@ impl str {\n         core_str::StrExt::lines_any(self)\n     }\n \n-    /// Returns an iterator of `u16` over the string encoded as UTF-16.\n-    #[unstable(feature = \"str_utf16\",\n-               reason = \"this functionality may only be provided by libunicode\",\n-               issue = \"27714\")]\n-    #[rustc_deprecated(since = \"1.8.0\", reason = \"renamed to encode_utf16\")]\n-    #[allow(deprecated)]\n-    pub fn utf16_units(&self) -> Utf16Units {\n-        Utf16Units { encoder: Utf16Encoder::new(self[..].chars()) }\n-    }\n-\n     /// Returns an iterator of `u16` over the string encoded as UTF-16.\n     #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n     pub fn encode_utf16(&self) -> EncodeUtf16 {"}, {"sha": "e9754bc98aae12fe09fdae97bdbdb1760647bc71", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -25,7 +25,6 @@\n #![feature(pattern)]\n #![feature(rand)]\n #![feature(step_by)]\n-#![feature(str_char)]\n #![feature(str_escape)]\n #![feature(test)]\n #![feature(unboxed_closures)]"}, {"sha": "124b85bfca872bbfb15f26ca9897dee61ba72806", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -479,20 +479,6 @@ fn test_is_whitespace() {\n     assert!(!\"   _   \".chars().all(|c| c.is_whitespace()));\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn test_slice_shift_char() {\n-    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n-    assert_eq!(data.slice_shift_char(), Some(('\u0e1b', \"\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\")));\n-}\n-\n-#[test]\n-#[allow(deprecated)]\n-fn test_slice_shift_char_2() {\n-    let empty = \"\";\n-    assert_eq!(empty.slice_shift_char(), None);\n-}\n-\n #[test]\n fn test_is_utf8() {\n     // deny overlong encodings\n@@ -674,30 +660,6 @@ fn test_contains_char() {\n     assert!(!\"\".contains('a'));\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn test_char_at() {\n-    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-    let v = vec!['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n-    let mut pos = 0;\n-    for ch in &v {\n-        assert!(s.char_at(pos) == *ch);\n-        pos += ch.to_string().len();\n-    }\n-}\n-\n-#[test]\n-#[allow(deprecated)]\n-fn test_char_at_reverse() {\n-    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-    let v = vec!['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n-    let mut pos = s.len();\n-    for ch in v.iter().rev() {\n-        assert!(s.char_at_reverse(pos) == *ch);\n-        pos -= ch.to_string().len();\n-    }\n-}\n-\n #[test]\n fn test_split_at() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n@@ -764,26 +726,6 @@ fn test_total_ord() {\n     assert_eq!(\"22\".cmp(\"1234\"), Greater);\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn test_char_range_at() {\n-    let data = \"b\u00a2\u20ac\ud852\udf62\ud852\udf62\u20ac\u00a2b\";\n-    assert_eq!('b', data.char_range_at(0).ch);\n-    assert_eq!('\u00a2', data.char_range_at(1).ch);\n-    assert_eq!('\u20ac', data.char_range_at(3).ch);\n-    assert_eq!('\ud852\udf62', data.char_range_at(6).ch);\n-    assert_eq!('\ud852\udf62', data.char_range_at(10).ch);\n-    assert_eq!('\u20ac', data.char_range_at(14).ch);\n-    assert_eq!('\u00a2', data.char_range_at(17).ch);\n-    assert_eq!('b', data.char_range_at(19).ch);\n-}\n-\n-#[test]\n-#[allow(deprecated)]\n-fn test_char_range_at_reverse_underflow() {\n-    assert_eq!(\"abc\".char_range_at_reverse(0).next, 0);\n-}\n-\n #[test]\n fn test_iterator() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";"}, {"sha": "684c90d6ae67e116eb1cdcbad93cd53596daa87b", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -692,40 +692,6 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n             borrow: orig.borrow,\n         }\n     }\n-\n-    /// Make a new `Ref` for an optional component of the borrowed data, e.g. an\n-    /// enum variant.\n-    ///\n-    /// The `RefCell` is already immutably borrowed, so this cannot fail.\n-    ///\n-    /// This is an associated function that needs to be used as\n-    /// `Ref::filter_map(...)`.  A method would interfere with methods of the\n-    /// same name on the contents of a `RefCell` used through `Deref`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![feature(cell_extras)]\n-    /// use std::cell::{RefCell, Ref};\n-    ///\n-    /// let c = RefCell::new(Ok(5));\n-    /// let b1: Ref<Result<u32, ()>> = c.borrow();\n-    /// let b2: Ref<u32> = Ref::filter_map(b1, |o| o.as_ref().ok()).unwrap();\n-    /// assert_eq!(*b2, 5)\n-    /// ```\n-    #[unstable(feature = \"cell_extras\", reason = \"recently added\",\n-               issue = \"27746\")]\n-    #[rustc_deprecated(since = \"1.8.0\", reason = \"can be built on `Ref::map`: \\\n-        https://crates.io/crates/ref_filter_map\")]\n-    #[inline]\n-    pub fn filter_map<U: ?Sized, F>(orig: Ref<'b, T>, f: F) -> Option<Ref<'b, U>>\n-        where F: FnOnce(&T) -> Option<&U>\n-    {\n-        f(orig.value).map(move |new| Ref {\n-            value: new,\n-            borrow: orig.borrow,\n-        })\n-    }\n }\n \n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n@@ -765,47 +731,6 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n             borrow: orig.borrow,\n         }\n     }\n-\n-    /// Make a new `RefMut` for an optional component of the borrowed data, e.g.\n-    /// an enum variant.\n-    ///\n-    /// The `RefCell` is already mutably borrowed, so this cannot fail.\n-    ///\n-    /// This is an associated function that needs to be used as\n-    /// `RefMut::filter_map(...)`.  A method would interfere with methods of the\n-    /// same name on the contents of a `RefCell` used through `Deref`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![feature(cell_extras)]\n-    /// use std::cell::{RefCell, RefMut};\n-    ///\n-    /// let c = RefCell::new(Ok(5));\n-    /// {\n-    ///     let b1: RefMut<Result<u32, ()>> = c.borrow_mut();\n-    ///     let mut b2: RefMut<u32> = RefMut::filter_map(b1, |o| {\n-    ///         o.as_mut().ok()\n-    ///     }).unwrap();\n-    ///     assert_eq!(*b2, 5);\n-    ///     *b2 = 42;\n-    /// }\n-    /// assert_eq!(*c.borrow(), Ok(42));\n-    /// ```\n-    #[unstable(feature = \"cell_extras\", reason = \"recently added\",\n-               issue = \"27746\")]\n-    #[rustc_deprecated(since = \"1.8.0\", reason = \"can be built on `RefMut::map`: \\\n-        https://crates.io/crates/ref_filter_map\")]\n-    #[inline]\n-    pub fn filter_map<U: ?Sized, F>(orig: RefMut<'b, T>, f: F) -> Option<RefMut<'b, U>>\n-        where F: FnOnce(&mut T) -> Option<&mut U>\n-    {\n-        let RefMut { value, borrow } = orig;\n-        f(value).map(move |new| RefMut {\n-            value: new,\n-            borrow: borrow,\n-        })\n-    }\n }\n \n struct BorrowRefMut<'b> {"}, {"sha": "6b2122451db8fbf164190d84d485a09067229113", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -18,63 +18,6 @@\n //!\n //! Their definition should always match the ABI defined in `rustc::back::abi`.\n \n-use clone::Clone;\n-use marker::Copy;\n-use mem;\n-\n-/// The representation of a slice like `&[T]`.\n-///\n-/// This struct is guaranteed to have the layout of types like `&[T]`,\n-/// `&str`, and `Box<[T]>`, but is not the type of such slices\n-/// (e.g. the fields are not directly accessible on a `&[T]`) nor does\n-/// it control that layout (changing the definition will not change\n-/// the layout of a `&[T]`). It is only designed to be used by unsafe\n-/// code that needs to manipulate the low-level details.\n-///\n-/// However, it is not recommended to use this type for such code,\n-/// since there are alternatives which may be safer:\n-///\n-/// - Creating a slice from a data pointer and length can be done with\n-///   `std::slice::from_raw_parts` or `std::slice::from_raw_parts_mut`\n-///   instead of `std::mem::transmute`ing a value of type `Slice`.\n-/// - Extracting the data pointer and length from a slice can be\n-///   performed with the `as_ptr` (or `as_mut_ptr`) and `len`\n-///   methods.\n-///\n-/// If one does decide to convert a slice value to a `Slice`, the\n-/// `Repr` trait in this module provides a method for a safe\n-/// conversion from `&[T]` (and `&str`) to a `Slice`, more type-safe\n-/// than a call to `transmute`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(raw)]\n-///\n-/// use std::raw::{self, Repr};\n-///\n-/// let slice: &[u16] = &[1, 2, 3, 4];\n-///\n-/// let repr: raw::Slice<u16> = slice.repr();\n-/// println!(\"data pointer = {:?}, length = {}\", repr.data, repr.len);\n-/// ```\n-#[repr(C)]\n-#[allow(missing_debug_implementations)]\n-#[rustc_deprecated(reason = \"use raw accessors/constructors in `slice` module\",\n-                   since = \"1.9.0\")]\n-#[unstable(feature = \"raw\", issue = \"27751\")]\n-pub struct Slice<T> {\n-    pub data: *const T,\n-    pub len: usize,\n-}\n-\n-#[allow(deprecated)]\n-impl<T> Copy for Slice<T> {}\n-#[allow(deprecated)]\n-impl<T> Clone for Slice<T> {\n-    fn clone(&self) -> Slice<T> { *self }\n-}\n-\n /// The representation of a trait object like `&SomeTrait`.\n ///\n /// This struct has the same layout as types like `&SomeTrait` and\n@@ -154,22 +97,3 @@ pub struct TraitObject {\n     pub data: *mut (),\n     pub vtable: *mut (),\n }\n-\n-/// This trait is meant to map equivalences between raw structs and their\n-/// corresponding rust values.\n-#[rustc_deprecated(reason = \"use raw accessors/constructors in `slice` module\",\n-                   since = \"1.9.0\")]\n-#[unstable(feature = \"raw\", issue = \"27751\")]\n-pub unsafe trait Repr<T> {\n-    /// This function \"unwraps\" a rust value (without consuming it) into its raw\n-    /// struct representation. This can be used to read/write different values\n-    /// for the struct. This is a safe method because by default it does not\n-    /// enable write-access to the fields of the return value in safe code.\n-    #[inline]\n-    fn repr(&self) -> T { unsafe { mem::transmute_copy(&self) } }\n-}\n-\n-#[allow(deprecated)]\n-unsafe impl<T> Repr<Slice<T>> for [T] {}\n-#[allow(deprecated)]\n-unsafe impl Repr<Slice<u8>> for str {}"}, {"sha": "0e57068a616200f5b82e5856d43d1054ab52aa03", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 129, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -17,7 +17,7 @@\n use self::pattern::Pattern;\n use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n \n-use char::{self, CharExt};\n+use char;\n use clone::Clone;\n use convert::AsRef;\n use default::Default;\n@@ -1663,40 +1663,6 @@ pub trait StrExt {\n         where P::Searcher: ReverseSearcher<'a>;\n     #[stable(feature = \"is_char_boundary\", since = \"1.9.0\")]\n     fn is_char_boundary(&self, index: usize) -> bool;\n-    #[unstable(feature = \"str_char\",\n-               reason = \"often replaced by char_indices, this method may \\\n-                         be removed in favor of just char_at() or eventually \\\n-                         removed altogether\",\n-               issue = \"27754\")]\n-    #[rustc_deprecated(reason = \"use slicing plus chars() plus len_utf8\",\n-                       since = \"1.9.0\")]\n-    fn char_range_at(&self, start: usize) -> CharRange;\n-    #[unstable(feature = \"str_char\",\n-               reason = \"often replaced by char_indices, this method may \\\n-                         be removed in favor of just char_at_reverse() or \\\n-                         eventually removed altogether\",\n-               issue = \"27754\")]\n-    #[rustc_deprecated(reason = \"use slicing plus chars().rev() plus len_utf8\",\n-                       since = \"1.9.0\")]\n-    fn char_range_at_reverse(&self, start: usize) -> CharRange;\n-    #[unstable(feature = \"str_char\",\n-               reason = \"frequently replaced by the chars() iterator, this \\\n-                         method may be removed or possibly renamed in the \\\n-                         future; it is normally replaced by chars/char_indices \\\n-                         iterators or by getting the first char from a \\\n-                         subslice\",\n-               issue = \"27754\")]\n-    #[rustc_deprecated(reason = \"use slicing plus chars()\",\n-                       since = \"1.9.0\")]\n-    fn char_at(&self, i: usize) -> char;\n-    #[unstable(feature = \"str_char\",\n-               reason = \"see char_at for more details, but reverse semantics \\\n-                         are also somewhat unclear, especially with which \\\n-                         cases generate panics\",\n-               issue = \"27754\")]\n-    #[rustc_deprecated(reason = \"use slicing plus chars().rev()\",\n-                       since = \"1.9.0\")]\n-    fn char_at_reverse(&self, i: usize) -> char;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn as_bytes(&self) -> &[u8];\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -1709,14 +1675,6 @@ pub trait StrExt {\n     fn split_at(&self, mid: usize) -> (&str, &str);\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn split_at_mut(&mut self, mid: usize) -> (&mut str, &mut str);\n-    #[unstable(feature = \"str_char\",\n-               reason = \"awaiting conventions about shifting and slices and \\\n-                         may not be warranted with the existence of the chars \\\n-                         and/or char_indices iterators\",\n-               issue = \"27754\")]\n-    #[rustc_deprecated(reason = \"use chars() plus Chars::as_str\",\n-                       since = \"1.9.0\")]\n-    fn slice_shift_char(&self) -> Option<(char, &str)>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn as_ptr(&self) -> *const u8;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -1945,55 +1903,6 @@ impl StrExt for str {\n         }\n     }\n \n-    #[inline]\n-    fn char_range_at(&self, i: usize) -> CharRange {\n-        let (c, n) = char_range_at_raw(self.as_bytes(), i);\n-        CharRange { ch: unsafe { char::from_u32_unchecked(c) }, next: n }\n-    }\n-\n-    #[inline]\n-    fn char_range_at_reverse(&self, start: usize) -> CharRange {\n-        let mut prev = start;\n-\n-        prev = prev.saturating_sub(1);\n-        if self.as_bytes()[prev] < 128 {\n-            return CharRange{ch: self.as_bytes()[prev] as char, next: prev}\n-        }\n-\n-        // Multibyte case is a fn to allow char_range_at_reverse to inline cleanly\n-        fn multibyte_char_range_at_reverse(s: &str, mut i: usize) -> CharRange {\n-            // while there is a previous byte == 10......\n-            while i > 0 && s.as_bytes()[i] & !CONT_MASK == TAG_CONT_U8 {\n-                i -= 1;\n-            }\n-\n-            let first= s.as_bytes()[i];\n-            let w = UTF8_CHAR_WIDTH[first as usize];\n-            assert!(w != 0);\n-\n-            let mut val = utf8_first_byte(first, w as u32);\n-            val = utf8_acc_cont_byte(val, s.as_bytes()[i + 1]);\n-            if w > 2 { val = utf8_acc_cont_byte(val, s.as_bytes()[i + 2]); }\n-            if w > 3 { val = utf8_acc_cont_byte(val, s.as_bytes()[i + 3]); }\n-\n-            CharRange {ch: unsafe { char::from_u32_unchecked(val) }, next: i}\n-        }\n-\n-        multibyte_char_range_at_reverse(self, prev)\n-    }\n-\n-    #[inline]\n-    #[allow(deprecated)]\n-    fn char_at(&self, i: usize) -> char {\n-        self.char_range_at(i).ch\n-    }\n-\n-    #[inline]\n-    #[allow(deprecated)]\n-    fn char_at_reverse(&self, i: usize) -> char {\n-        self.char_range_at_reverse(i).ch\n-    }\n-\n     #[inline]\n     fn as_bytes(&self) -> &[u8] {\n         unsafe { mem::transmute(self) }\n@@ -2040,18 +1949,6 @@ impl StrExt for str {\n         }\n     }\n \n-    #[inline]\n-    #[allow(deprecated)]\n-    fn slice_shift_char(&self) -> Option<(char, &str)> {\n-        if self.is_empty() {\n-            None\n-        } else {\n-            let ch = self.char_at(0);\n-            let next_s = unsafe { self.slice_unchecked(ch.len_utf8(), self.len()) };\n-            Some((ch, next_s))\n-        }\n-    }\n-\n     #[inline]\n     fn as_ptr(&self) -> *const u8 {\n         self as *const str as *const u8\n@@ -2077,31 +1974,6 @@ impl AsRef<[u8]> for str {\n     }\n }\n \n-/// Pluck a code point out of a UTF-8-like byte slice and return the\n-/// index of the next code point.\n-#[inline]\n-fn char_range_at_raw(bytes: &[u8], i: usize) -> (u32, usize) {\n-    if bytes[i] < 128 {\n-        return (bytes[i] as u32, i + 1);\n-    }\n-\n-    // Multibyte case is a fn to allow char_range_at to inline cleanly\n-    fn multibyte_char_range_at(bytes: &[u8], i: usize) -> (u32, usize) {\n-        let first = bytes[i];\n-        let w = UTF8_CHAR_WIDTH[first as usize];\n-        assert!(w != 0);\n-\n-        let mut val = utf8_first_byte(first, w as u32);\n-        val = utf8_acc_cont_byte(val, bytes[i + 1]);\n-        if w > 2 { val = utf8_acc_cont_byte(val, bytes[i + 2]); }\n-        if w > 3 { val = utf8_acc_cont_byte(val, bytes[i + 3]); }\n-\n-        (val, i + w as usize)\n-    }\n-\n-    multibyte_char_range_at(bytes, i)\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Default for &'a str {\n     fn default() -> &'a str { \"\" }"}, {"sha": "a635620d12abd3618e3acda562b0c2ed49686153", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -158,20 +158,6 @@ fn ref_map_accessor() {\n     assert_eq!(*d, 7);\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn ref_filter_map_accessor() {\n-    struct X(RefCell<Result<u32, ()>>);\n-    impl X {\n-        fn accessor(&self) -> Option<Ref<u32>> {\n-            Ref::filter_map(self.0.borrow(), |r| r.as_ref().ok())\n-        }\n-    }\n-    let x = X(RefCell::new(Ok(7)));\n-    let d: Ref<u32> = x.accessor().unwrap();\n-    assert_eq!(*d, 7);\n-}\n-\n #[test]\n fn ref_mut_map_accessor() {\n     struct X(RefCell<(u32, char)>);\n@@ -189,24 +175,6 @@ fn ref_mut_map_accessor() {\n     assert_eq!(*x.0.borrow(), (8, 'z'));\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn ref_mut_filter_map_accessor() {\n-    struct X(RefCell<Result<u32, ()>>);\n-    impl X {\n-        fn accessor(&self) -> Option<RefMut<u32>> {\n-            RefMut::filter_map(self.0.borrow_mut(), |r| r.as_mut().ok())\n-        }\n-    }\n-    let x = X(RefCell::new(Ok(7)));\n-    {\n-        let mut d: RefMut<u32> = x.accessor().unwrap();\n-        assert_eq!(*d, 7);\n-        *d += 1;\n-    }\n-    assert_eq!(*x.0.borrow(), Ok(8));\n-}\n-\n #[test]\n fn as_unsafe_cell() {\n     let c1: Cell<usize> = Cell::new(0);"}, {"sha": "d8cadf09cb2a4c3a3c8ae9ea78b6ab0059627b04", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 1, "deletions": 95, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -25,21 +25,7 @@ use thread::Result;\n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub use panicking::{take_hook, set_hook, PanicInfo, Location};\n \n-///\n-#[rustc_deprecated(since = \"1.9.0\", reason = \"renamed to set_hook\")]\n-#[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n-pub fn set_handler<F>(handler: F) where F: Fn(&PanicInfo) + 'static + Sync + Send {\n-    set_hook(Box::new(handler))\n-}\n-\n-///\n-#[rustc_deprecated(since = \"1.9.0\", reason = \"renamed to take_hook\")]\n-#[unstable(feature = \"panic_handler\", reason = \"awaiting feedback\", issue = \"30449\")]\n-pub fn take_handler() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n-    take_hook()\n-}\n-\n-/// A marker trait which represents \"unwind safe\" types in Rust.\n+/// A marker trait which represents \"panic safe\" types in Rust.\n ///\n /// This trait is implemented by default for many types and behaves similarly in\n /// terms of inference of implementation to the `Send` and `Sync` traits. The\n@@ -117,14 +103,6 @@ pub fn take_handler() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n                             across an unwind boundary\"]\n pub trait UnwindSafe {}\n \n-/// Deprecated, renamed to UnwindSafe\n-#[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n-#[rustc_deprecated(reason = \"renamed to `UnwindSafe`\", since = \"1.9.0\")]\n-pub trait RecoverSafe {}\n-#[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n-#[allow(deprecated)]\n-impl<T: UnwindSafe> RecoverSafe for T {}\n-\n /// A marker trait representing types where a shared reference is considered\n /// unwind safe.\n ///\n@@ -202,11 +180,6 @@ pub struct AssertUnwindSafe<T>(\n     pub T\n );\n \n-/// Deprecated, renamed to `AssertUnwindSafe`\n-#[unstable(feature = \"recover\", issue = \"27719\")]\n-#[rustc_deprecated(reason = \"renamed to `AssertUnwindSafe`\", since = \"1.9.0\")]\n-pub struct AssertRecoverSafe<T>(pub T);\n-\n // Implementations of the `UnwindSafe` trait:\n //\n // * By default everything is unwind safe\n@@ -234,9 +207,6 @@ impl<T: ?Sized> UnwindSafe for Mutex<T> {}\n impl<T: ?Sized> UnwindSafe for RwLock<T> {}\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T> UnwindSafe for AssertUnwindSafe<T> {}\n-#[unstable(feature = \"recover\", issue = \"27719\")]\n-#[allow(deprecated)]\n-impl<T> UnwindSafe for AssertRecoverSafe<T> {}\n \n // not covered via the Shared impl above b/c the inner contents use\n // Cell/AtomicUsize, but the usage here is unwind safe so we can lift the\n@@ -256,9 +226,6 @@ impl RefUnwindSafe for .. {}\n impl<T: ?Sized> !RefUnwindSafe for UnsafeCell<T> {}\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T> RefUnwindSafe for AssertUnwindSafe<T> {}\n-#[unstable(feature = \"recover\", issue = \"27719\")]\n-#[allow(deprecated)]\n-impl<T> RefUnwindSafe for AssertRecoverSafe<T> {}\n \n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T> Deref for AssertUnwindSafe<T> {\n@@ -285,53 +252,6 @@ impl<R, F: FnOnce() -> R> FnOnce<()> for AssertUnwindSafe<F> {\n     }\n }\n \n-#[allow(deprecated)]\n-impl<T> AssertRecoverSafe<T> {\n-    /// Creates a new `AssertRecoverSafe` wrapper around the provided type.\n-    #[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n-    #[rustc_deprecated(reason = \"the type's field is now public, construct it directly\",\n-                       since = \"1.9.0\")]\n-    pub fn new(t: T) -> AssertRecoverSafe<T> {\n-        AssertRecoverSafe(t)\n-    }\n-\n-    /// Consumes the `AssertRecoverSafe`, returning the wrapped value.\n-    #[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n-    #[rustc_deprecated(reason = \"the type's field is now public, access it directly\",\n-                       since = \"1.9.0\")]\n-    pub fn into_inner(self) -> T {\n-        self.0\n-    }\n-}\n-\n-#[unstable(feature = \"recover\", issue = \"27719\")]\n-#[allow(deprecated)]\n-impl<T> Deref for AssertRecoverSafe<T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &T {\n-        &self.0\n-    }\n-}\n-\n-#[unstable(feature = \"recover\", issue = \"27719\")]\n-#[allow(deprecated)]\n-impl<T> DerefMut for AssertRecoverSafe<T> {\n-    fn deref_mut(&mut self) -> &mut T {\n-        &mut self.0\n-    }\n-}\n-\n-#[unstable(feature = \"recover\", issue = \"27719\")]\n-#[allow(deprecated)]\n-impl<R, F: FnOnce() -> R> FnOnce<()> for AssertRecoverSafe<F> {\n-    type Output = R;\n-\n-    extern \"rust-call\" fn call_once(self, _args: ()) -> R {\n-        (self.0)()\n-    }\n-}\n-\n /// Invokes a closure, capturing the cause of an unwinding panic if one occurs.\n ///\n /// This function will return `Ok` with the closure's result if the closure\n@@ -388,13 +308,6 @@ pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n     }\n }\n \n-/// Deprecated, renamed to `catch_unwind`\n-#[unstable(feature = \"recover\", reason = \"awaiting feedback\", issue = \"27719\")]\n-#[rustc_deprecated(reason = \"renamed to `catch_unwind`\", since = \"1.9.0\")]\n-pub fn recover<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n-    catch_unwind(f)\n-}\n-\n /// Triggers a panic without invoking the panic hook.\n ///\n /// This is designed to be used in conjunction with `catch_unwind` to, for\n@@ -424,10 +337,3 @@ pub fn recover<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n pub fn resume_unwind(payload: Box<Any + Send>) -> ! {\n     panicking::rust_panic(payload)\n }\n-\n-/// Deprecated, use resume_unwind instead\n-#[unstable(feature = \"panic_propagate\", reason = \"awaiting feedback\", issue = \"30752\")]\n-#[rustc_deprecated(reason = \"renamed to `resume_unwind`\", since = \"1.9.0\")]\n-pub fn propagate(payload: Box<Any + Send>) -> ! {\n-    resume_unwind(payload)\n-}"}, {"sha": "03d3483902dcf87b899aefcbe1f2a66ea07d2a30", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 104, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -468,42 +468,6 @@ impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> {\n             }\n         })\n     }\n-\n-    /// Transform this guard to hold a sub-borrow of the original data.\n-    ///\n-    /// Applies the supplied closure to the data, returning a new lock\n-    /// guard referencing the borrow returned by the closure.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// # #![feature(guard_map)]\n-    /// # use std::sync::{RwLockReadGuard, RwLock};\n-    /// let x = RwLock::new(vec![1, 2]);\n-    ///\n-    /// let y = RwLockReadGuard::map(x.read().unwrap(), |v| &v[0]);\n-    /// assert_eq!(*y, 1);\n-    /// ```\n-    #[unstable(feature = \"guard_map\",\n-               reason = \"recently added, needs RFC for stabilization,\n-                         questionable interaction with Condvar\",\n-               issue = \"27746\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"unsound on Mutex because of Condvar and \\\n-                                 RwLock may also with to be used with Condvar \\\n-                                 one day\")]\n-    pub fn map<U: ?Sized, F>(this: Self, cb: F) -> RwLockReadGuard<'rwlock, U>\n-        where F: FnOnce(&T) -> &U\n-    {\n-        let new = RwLockReadGuard {\n-            __lock: this.__lock,\n-            __data: cb(this.__data)\n-        };\n-\n-        mem::forget(this);\n-\n-        new\n-    }\n }\n \n #[allow(deprecated)]\n@@ -518,57 +482,6 @@ impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n             }\n         })\n     }\n-\n-    /// Transform this guard to hold a sub-borrow of the original data.\n-    ///\n-    /// Applies the supplied closure to the data, returning a new lock\n-    /// guard referencing the borrow returned by the closure.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// # #![feature(guard_map)]\n-    /// # use std::sync::{RwLockWriteGuard, RwLock};\n-    /// let x = RwLock::new(vec![1, 2]);\n-    ///\n-    /// {\n-    ///     let mut y = RwLockWriteGuard::map(x.write().unwrap(), |v| &mut v[0]);\n-    ///     assert_eq!(*y, 1);\n-    ///\n-    ///     *y = 10;\n-    /// }\n-    ///\n-    /// assert_eq!(&**x.read().unwrap(), &[10, 2]);\n-    /// ```\n-    #[unstable(feature = \"guard_map\",\n-               reason = \"recently added, needs RFC for stabilization,\n-                         questionable interaction with Condvar\",\n-               issue = \"27746\")]\n-    #[rustc_deprecated(since = \"1.8.0\",\n-                       reason = \"unsound on Mutex because of Condvar and \\\n-                                 RwLock may also with to be used with Condvar \\\n-                                 one day\")]\n-    pub fn map<U: ?Sized, F>(this: Self, cb: F) -> RwLockWriteGuard<'rwlock, U>\n-        where F: FnOnce(&mut T) -> &mut U\n-    {\n-        // Compute the new data while still owning the original lock\n-        // in order to correctly poison if the callback panics.\n-        let data = unsafe { ptr::read(&this.__data) };\n-        let new_data = cb(data);\n-\n-        // We don't want to unlock the lock by running the destructor of the\n-        // original lock, so just read the fields we need and forget it.\n-        let (poison, lock) = unsafe {\n-            (ptr::read(&this.__poison), ptr::read(&this.__lock))\n-        };\n-        mem::forget(this);\n-\n-        RwLockWriteGuard {\n-            __lock: lock,\n-            __data: new_data,\n-            __poison: poison\n-        }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -619,7 +532,7 @@ mod tests {\n     use rand::{self, Rng};\n     use sync::mpsc::channel;\n     use thread;\n-    use sync::{Arc, RwLock, StaticRwLock, TryLockError, RwLockWriteGuard};\n+    use sync::{Arc, RwLock, StaticRwLock, TryLockError};\n     use sync::atomic::{AtomicUsize, Ordering};\n \n     #[derive(Eq, PartialEq, Debug)]\n@@ -867,20 +780,4 @@ mod tests {\n             Ok(x) => panic!(\"get_mut of poisoned RwLock is Ok: {:?}\", x),\n         }\n     }\n-\n-    #[test]\n-    fn test_rwlock_write_map_poison() {\n-        let rwlock = Arc::new(RwLock::new(vec![1, 2]));\n-        let rwlock2 = rwlock.clone();\n-\n-        thread::spawn(move || {\n-            let _ = RwLockWriteGuard::map::<usize, _>(rwlock2.write().unwrap(), |_| panic!());\n-        }).join().unwrap_err();\n-\n-        match rwlock.read() {\n-            Ok(r) => panic!(\"Read lock on poisioned RwLock is Ok: {:?}\", &*r),\n-            Err(_) => {}\n-        };\n-    }\n }\n-"}, {"sha": "430ec5f94a6f85da5a0444ddfa0e73b4f52d9f33", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -34,21 +34,6 @@ pub trait CommandExt {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn gid(&mut self, id: u32) -> &mut process::Command;\n \n-    /// Create a new session (cf. `setsid(2)`) for the child process. This means\n-    /// that the child is the leader of a new process group. The parent process\n-    /// remains the child reaper of the new process.\n-    ///\n-    /// This is not enough to create a daemon process. The *init* process should\n-    /// be the child reaper of a daemon. This can be achieved if the parent\n-    /// process exit. Moreover, a daemon should not have a controlling terminal.\n-    /// To achieve this, a session leader (the child) must spawn another process\n-    /// (the daemon) in the same session.\n-    #[unstable(feature = \"process_session_leader\", reason = \"recently added\",\n-               issue = \"27811\")]\n-    #[rustc_deprecated(reason = \"use `before_exec` instead\",\n-                       since = \"1.9.0\")]\n-    fn session_leader(&mut self, on: bool) -> &mut process::Command;\n-\n     /// Schedules a closure to be run just before the `exec` function is\n     /// invoked.\n     ///\n@@ -112,11 +97,6 @@ impl CommandExt for process::Command {\n         self\n     }\n \n-    fn session_leader(&mut self, on: bool) -> &mut process::Command {\n-        self.as_inner_mut().session_leader(on);\n-        self\n-    }\n-\n     fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n         where F: FnMut() -> io::Result<()> + Send + Sync + 'static\n     {"}, {"sha": "98cfdcdf11041510049283485fac0d5a8a22b337", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -55,7 +55,6 @@ pub struct Command {\n     cwd: Option<CString>,\n     uid: Option<uid_t>,\n     gid: Option<gid_t>,\n-    session_leader: bool,\n     saw_nul: bool,\n     closures: Vec<Box<FnMut() -> io::Result<()> + Send + Sync>>,\n     stdin: Option<Stdio>,\n@@ -105,7 +104,6 @@ impl Command {\n             cwd: None,\n             uid: None,\n             gid: None,\n-            session_leader: false,\n             saw_nul: saw_nul,\n             closures: Vec::new(),\n             stdin: None,\n@@ -197,9 +195,6 @@ impl Command {\n     pub fn gid(&mut self, id: gid_t) {\n         self.gid = Some(id);\n     }\n-    pub fn session_leader(&mut self, session_leader: bool) {\n-        self.session_leader = session_leader;\n-    }\n \n     pub fn before_exec(&mut self,\n                        f: Box<FnMut() -> io::Result<()> + Send + Sync>) {\n@@ -367,12 +362,6 @@ impl Command {\n \n             t!(cvt(libc::setuid(u as uid_t)));\n         }\n-        if self.session_leader {\n-            // Don't check the error of setsid because it fails if we're the\n-            // process leader already. We just forked so it shouldn't return\n-            // error, but ignore it anyway.\n-            let _ = libc::setsid();\n-        }\n         if let Some(ref cwd) = self.cwd {\n             t!(cvt(libc::chdir(cwd.as_ptr())));\n         }"}, {"sha": "c8783a60c4117d23ee12211de55de900f111ec1e", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -183,25 +183,15 @@ use time::Duration;\n ////////////////////////////////////////////////////////////////////////////////\n \n #[macro_use] mod local;\n-#[macro_use] mod scoped_tls;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::local::{LocalKey, LocalKeyState};\n \n-#[unstable(feature = \"scoped_tls\",\n-           reason = \"scoped TLS has yet to have wide enough use to fully \\\n-                     consider stabilizing its interface\",\n-           issue = \"27715\")]\n-#[allow(deprecated)]\n-pub use self::scoped_tls::ScopedKey;\n-\n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n #[cfg(target_thread_local)]\n #[doc(hidden)] pub use self::local::elf::Key as __ElfLocalKeyInner;\n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n #[doc(hidden)] pub use self::local::os::Key as __OsLocalKeyInner;\n-#[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n-#[doc(hidden)] pub use self::scoped_tls::__KeyInner as __ScopedKeyInner;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Builder"}, {"sha": "dea58d016e4ca5568f8533a02abed51d3f1e2b77", "filename": "src/libstd/thread/scoped_tls.rs", "status": "removed", "additions": 0, "deletions": 298, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/a967611d8ffececb5ed0ecf6a205b464d7a5a31e/src%2Flibstd%2Fthread%2Fscoped_tls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a967611d8ffececb5ed0ecf6a205b464d7a5a31e/src%2Flibstd%2Fthread%2Fscoped_tls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fscoped_tls.rs?ref=a967611d8ffececb5ed0ecf6a205b464d7a5a31e", "patch": "@@ -1,298 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Scoped thread-local storage\n-//!\n-//! This module provides the ability to generate *scoped* thread-local\n-//! variables. In this sense, scoped indicates that thread local storage\n-//! actually stores a reference to a value, and this reference is only placed\n-//! in storage for a scoped amount of time.\n-//!\n-//! There are no restrictions on what types can be placed into a scoped\n-//! variable, but all scoped variables are initialized to the equivalent of\n-//! null. Scoped thread local storage is useful when a value is present for a known\n-//! period of time and it is not required to relinquish ownership of the\n-//! contents.\n-//!\n-//! # Examples\n-//!\n-//! ```\n-//! #![feature(scoped_tls)]\n-//!\n-//! scoped_thread_local!(static FOO: u32);\n-//!\n-//! // Initially each scoped slot is empty.\n-//! assert!(!FOO.is_set());\n-//!\n-//! // When inserting a value, the value is only in place for the duration\n-//! // of the closure specified.\n-//! FOO.set(&1, || {\n-//!     FOO.with(|slot| {\n-//!         assert_eq!(*slot, 1);\n-//!     });\n-//! });\n-//! ```\n-\n-#![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n-#![allow(deprecated)]\n-\n-#[doc(hidden)]\n-pub use self::imp::KeyInner as __KeyInner;\n-\n-/// Type representing a thread local storage key corresponding to a reference\n-/// to the type parameter `T`.\n-///\n-/// Keys are statically allocated and can contain a reference to an instance of\n-/// type `T` scoped to a particular lifetime. Keys provides two methods, `set`\n-/// and `with`, both of which currently use closures to control the scope of\n-/// their contents.\n-#[unstable(feature = \"scoped_tls\",\n-           reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n-                     stabilizing its interface\",\n-           issue = \"27715\")]\n-#[rustc_deprecated(since = \"1.8.0\",\n-                   reason = \"hasn't proven itself over LocalKey\")]\n-pub struct ScopedKey<T:'static> { inner: fn() -> &'static imp::KeyInner<T> }\n-\n-/// Declare a new scoped thread local storage key.\n-///\n-/// This macro declares a `static` item on which methods are used to get and\n-/// set the value stored within.\n-///\n-/// See [ScopedKey documentation](thread/struct.ScopedKey.html) for more\n-/// information.\n-#[unstable(feature = \"thread_local_internals\",\n-           reason = \"should not be necessary\",\n-           issue = \"0\")]\n-#[rustc_deprecated(since = \"1.8.0\",\n-                   reason = \"hasn't proven itself over LocalKey\")]\n-#[macro_export]\n-#[allow_internal_unstable]\n-macro_rules! scoped_thread_local {\n-    (static $name:ident: $t:ty) => (\n-        static $name: $crate::thread::ScopedKey<$t> =\n-            __scoped_thread_local_inner!($t);\n-    );\n-    (pub static $name:ident: $t:ty) => (\n-        pub static $name: $crate::thread::ScopedKey<$t> =\n-            __scoped_thread_local_inner!($t);\n-    );\n-}\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"thread_local_internals\",\n-           reason = \"should not be necessary\",\n-           issue = \"0\")]\n-#[rustc_deprecated(since = \"1.8.0\",\n-                   reason = \"hasn't proven itself over LocalKey\")]\n-#[macro_export]\n-#[allow_internal_unstable]\n-macro_rules! __scoped_thread_local_inner {\n-    ($t:ty) => {{\n-        #[cfg_attr(target_thread_local, thread_local)]\n-        static _KEY: $crate::thread::__ScopedKeyInner<$t> =\n-            $crate::thread::__ScopedKeyInner::new();\n-        fn _getit() -> &'static $crate::thread::__ScopedKeyInner<$t> { &_KEY }\n-        $crate::thread::ScopedKey::new(_getit)\n-    }}\n-}\n-\n-#[unstable(feature = \"scoped_tls\",\n-           reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n-                     stabilizing its interface\",\n-           issue = \"27715\")]\n-#[rustc_deprecated(since = \"1.8.0\",\n-                   reason = \"hasn't proven itself over LocalKey\")]\n-impl<T> ScopedKey<T> {\n-    #[doc(hidden)]\n-    pub const fn new(inner: fn() -> &'static imp::KeyInner<T>) -> ScopedKey<T> {\n-        ScopedKey { inner: inner }\n-    }\n-\n-    /// Inserts a value into this scoped thread local storage slot for a\n-    /// duration of a closure.\n-    ///\n-    /// While `cb` is running, the value `t` will be returned by `get` unless\n-    /// this function is called recursively inside of `cb`.\n-    ///\n-    /// Upon return, this function will restore the previous value, if any\n-    /// was available.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(scoped_tls)]\n-    ///\n-    /// scoped_thread_local!(static FOO: u32);\n-    ///\n-    /// FOO.set(&100, || {\n-    ///     let val = FOO.with(|v| *v);\n-    ///     assert_eq!(val, 100);\n-    ///\n-    ///     // set can be called recursively\n-    ///     FOO.set(&101, || {\n-    ///         // ...\n-    ///     });\n-    ///\n-    ///     // Recursive calls restore the previous value.\n-    ///     let val = FOO.with(|v| *v);\n-    ///     assert_eq!(val, 100);\n-    /// });\n-    /// ```\n-    pub fn set<R, F>(&'static self, t: &T, cb: F) -> R where\n-        F: FnOnce() -> R,\n-    {\n-        struct Reset<'a, T: 'a> {\n-            key: &'a imp::KeyInner<T>,\n-            val: *mut T,\n-        }\n-                impl<'a, T> Drop for Reset<'a, T> {\n-            fn drop(&mut self) {\n-                unsafe { self.key.set(self.val) }\n-            }\n-        }\n-\n-        let inner = (self.inner)();\n-        let prev = unsafe {\n-            let prev = inner.get();\n-            inner.set(t as *const T as *mut T);\n-            prev\n-        };\n-\n-        let _reset = Reset { key: inner, val: prev };\n-        cb()\n-    }\n-\n-    /// Gets a value out of this scoped variable.\n-    ///\n-    /// This function takes a closure which receives the value of this\n-    /// variable.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if `set` has not previously been called.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(scoped_tls)]\n-    ///\n-    /// scoped_thread_local!(static FOO: u32);\n-    ///\n-    /// FOO.with(|slot| {\n-    ///     // work with `slot`\n-    /// });\n-    /// ```\n-    pub fn with<R, F>(&'static self, cb: F) -> R where\n-        F: FnOnce(&T) -> R\n-    {\n-        unsafe {\n-            let ptr = (self.inner)().get();\n-            assert!(!ptr.is_null(), \"cannot access a scoped thread local \\\n-                                     variable without calling `set` first\");\n-            cb(&*ptr)\n-        }\n-    }\n-\n-    /// Test whether this TLS key has been `set` for the current thread.\n-    pub fn is_set(&'static self) -> bool {\n-        unsafe { !(self.inner)().get().is_null() }\n-    }\n-}\n-\n-#[cfg(target_thread_local)]\n-#[doc(hidden)]\n-mod imp {\n-    use cell::Cell;\n-    use ptr;\n-\n-    pub struct KeyInner<T> { inner: Cell<*mut T> }\n-\n-    unsafe impl<T> ::marker::Sync for KeyInner<T> { }\n-\n-    impl<T> KeyInner<T> {\n-        pub const fn new() -> KeyInner<T> {\n-            KeyInner { inner: Cell::new(ptr::null_mut()) }\n-        }\n-        pub unsafe fn set(&self, ptr: *mut T) { self.inner.set(ptr); }\n-        pub unsafe fn get(&self) -> *mut T { self.inner.get() }\n-    }\n-}\n-\n-#[cfg(not(target_thread_local))]\n-#[doc(hidden)]\n-mod imp {\n-    use cell::Cell;\n-    use marker;\n-    use sys_common::thread_local::StaticKey as OsStaticKey;\n-\n-    pub struct KeyInner<T> {\n-        pub inner: OsStaticKey,\n-        pub marker: marker::PhantomData<Cell<T>>,\n-    }\n-\n-    unsafe impl<T> marker::Sync for KeyInner<T> { }\n-\n-    impl<T> KeyInner<T> {\n-        pub const fn new() -> KeyInner<T> {\n-            KeyInner {\n-                inner: OsStaticKey::new(None),\n-                marker: marker::PhantomData\n-            }\n-        }\n-        pub unsafe fn set(&self, ptr: *mut T) { self.inner.set(ptr as *mut _) }\n-        pub unsafe fn get(&self) -> *mut T { self.inner.get() as *mut _ }\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    use cell::Cell;\n-\n-    scoped_thread_local!(static FOO: u32);\n-\n-    #[test]\n-    fn smoke() {\n-        scoped_thread_local!(static BAR: u32);\n-\n-        assert!(!BAR.is_set());\n-        BAR.set(&1, || {\n-            assert!(BAR.is_set());\n-            BAR.with(|slot| {\n-                assert_eq!(*slot, 1);\n-            });\n-        });\n-        assert!(!BAR.is_set());\n-    }\n-\n-    #[test]\n-    fn cell_allowed() {\n-        scoped_thread_local!(static BAR: Cell<u32>);\n-\n-        BAR.set(&Cell::new(1), || {\n-            BAR.with(|slot| {\n-                assert_eq!(slot.get(), 1);\n-            });\n-        });\n-    }\n-\n-    #[test]\n-    fn scope_item_allowed() {\n-        assert!(!FOO.is_set());\n-        FOO.set(&1, || {\n-            assert!(FOO.is_set());\n-            FOO.with(|slot| {\n-                assert_eq!(*slot, 1);\n-            });\n-        });\n-        assert!(!FOO.is_set());\n-    }\n-}"}, {"sha": "0e1508a1c4c28d130baf1813096a7c5ac2960cc8", "filename": "src/libstd/time/mod.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibstd%2Ftime%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Flibstd%2Ftime%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fmod.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -143,13 +143,6 @@ impl Instant {\n         self.0.sub_instant(&earlier.0)\n     }\n \n-    /// Deprecated, renamed to `duration_since`\n-    #[unstable(feature = \"time2_old\", issue = \"29866\")]\n-    #[rustc_deprecated(since = \"1.8.0\", reason = \"renamed to duration_since\")]\n-    pub fn duration_from_earlier(&self, earlier: Instant) -> Duration {\n-        self.0.sub_instant(&earlier.0)\n-    }\n-\n     /// Returns the amount of time elapsed since this instant was created.\n     ///\n     /// # Panics\n@@ -235,14 +228,6 @@ impl SystemTime {\n         self.0.sub_time(&earlier.0).map_err(SystemTimeError)\n     }\n \n-    /// Deprecated, renamed to `duration_since`\n-    #[unstable(feature = \"time2_old\", issue = \"29866\")]\n-    #[rustc_deprecated(since = \"1.8.0\", reason = \"renamed to duration_since\")]\n-    pub fn duration_from_earlier(&self, earlier: SystemTime)\n-                                 -> Result<Duration, SystemTimeError> {\n-        self.0.sub_time(&earlier.0).map_err(SystemTimeError)\n-    }\n-\n     /// Returns the amount of time elapsed since this system time was created.\n     ///\n     /// This function may fail as the underlying system clock is susceptible to"}, {"sha": "c6ce0c4c95b8bcbf97a3e0024e391ac4b9e34ccf", "filename": "src/test/compile-fail/issue-16338.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Fcompile-fail%2Fissue-16338.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Fcompile-fail%2Fissue-16338.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16338.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -8,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::raw::Slice;\n+struct Slice<T> {\n+    data: *const T,\n+    len: usize,\n+}\n \n fn main() {\n     let Slice { data: data, len: len } = \"foo\";\n     //~^ ERROR mismatched types\n     //~| expected type `&str`\n-    //~| found type `std::raw::Slice<_>`\n-    //~| expected &-ptr, found struct `std::raw::Slice`\n+    //~| found type `Slice<_>`\n+    //~| expected &-ptr, found struct `Slice`\n }"}, {"sha": "3060bbea43c3bf8ea0b2520ef1e8ba60136382ba", "filename": "src/test/compile-fail/issue-16401.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Fcompile-fail%2Fissue-16401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Fcompile-fail%2Fissue-16401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16401.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -8,15 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::raw::Slice;\n+struct Slice<T> {\n+    data: *const T,\n+    len: usize,\n+}\n \n fn main() {\n     match () {\n         Slice { data: data, len: len } => (),\n         //~^ ERROR mismatched types\n         //~| expected type `()`\n-        //~| found type `std::raw::Slice<_>`\n-        //~| expected (), found struct `std::raw::Slice`\n+        //~| found type `Slice<_>`\n+        //~| expected (), found struct `Slice`\n         _ => unreachable!()\n     }\n }"}, {"sha": "7107211fc914b47479b2569515fee614191cca08", "filename": "src/test/compile-fail/not-panic-safe-2.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -9,13 +9,12 @@\n // except according to those terms.\n \n #![allow(dead_code)]\n-#![feature(recover)]\n \n-use std::panic::RecoverSafe;\n+use std::panic::UnwindSafe;\n use std::rc::Rc;\n use std::cell::RefCell;\n \n-fn assert<T: RecoverSafe + ?Sized>() {}\n+fn assert<T: UnwindSafe + ?Sized>() {}\n \n fn main() {\n     assert::<Rc<RefCell<i32>>>();"}, {"sha": "76c34e4dc0b448613ddaef1d2041ad8bc15f18dd", "filename": "src/test/compile-fail/not-panic-safe-3.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -9,13 +9,12 @@\n // except according to those terms.\n \n #![allow(dead_code)]\n-#![feature(recover)]\n \n-use std::panic::RecoverSafe;\n+use std::panic::UnwindSafe;\n use std::sync::Arc;\n use std::cell::RefCell;\n \n-fn assert<T: RecoverSafe + ?Sized>() {}\n+fn assert<T: UnwindSafe + ?Sized>() {}\n \n fn main() {\n     assert::<Arc<RefCell<i32>>>();"}, {"sha": "177a43e2a7f71650a74955496b37f75cfc1b508f", "filename": "src/test/compile-fail/not-panic-safe-4.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -9,12 +9,11 @@\n // except according to those terms.\n \n #![allow(dead_code)]\n-#![feature(recover)]\n \n-use std::panic::RecoverSafe;\n+use std::panic::UnwindSafe;\n use std::cell::RefCell;\n \n-fn assert<T: RecoverSafe + ?Sized>() {}\n+fn assert<T: UnwindSafe + ?Sized>() {}\n \n fn main() {\n     assert::<&RefCell<i32>>();"}, {"sha": "627a0fe78cf06ae9bb8cb6c56fdbd637e4eb27e6", "filename": "src/test/compile-fail/not-panic-safe-5.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-5.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -9,12 +9,11 @@\n // except according to those terms.\n \n #![allow(dead_code)]\n-#![feature(recover)]\n \n-use std::panic::RecoverSafe;\n+use std::panic::UnwindSafe;\n use std::cell::UnsafeCell;\n \n-fn assert<T: RecoverSafe + ?Sized>() {}\n+fn assert<T: UnwindSafe + ?Sized>() {}\n \n fn main() {\n     assert::<*const UnsafeCell<i32>>(); //~ ERROR E0277"}, {"sha": "f03e1d545a8083786f324118f27ebc25eb9f9a94", "filename": "src/test/compile-fail/not-panic-safe-6.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -9,12 +9,11 @@\n // except according to those terms.\n \n #![allow(dead_code)]\n-#![feature(recover)]\n \n-use std::panic::RecoverSafe;\n+use std::panic::UnwindSafe;\n use std::cell::RefCell;\n \n-fn assert<T: RecoverSafe + ?Sized>() {}\n+fn assert<T: UnwindSafe + ?Sized>() {}\n \n fn main() {\n     assert::<*mut RefCell<i32>>();"}, {"sha": "b589544ae156359eb62e260d9f232856090ebf89", "filename": "src/test/run-fail/panic-set-handler.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Frun-fail%2Fpanic-set-handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Frun-fail%2Fpanic-set-handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-set-handler.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -10,13 +10,14 @@\n \n // error-pattern:greetings from the panic handler\n \n-#![feature(std_panic, panic_handler)]\n+#![feature(panic_handler)]\n+\n use std::panic;\n use std::io::{self, Write};\n \n fn main() {\n-    panic::set_handler(|i| {\n+    panic::set_hook(Box::new(|i| {\n         write!(io::stderr(), \"greetings from the panic handler\");\n-    });\n+    }));\n     panic!(\"foobar\");\n }"}, {"sha": "4c895ea52aa1d5b4e3bced9aaa6fb14f7319824c", "filename": "src/test/run-fail/panic-set-unset-handler.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Frun-fail%2Fpanic-set-unset-handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Frun-fail%2Fpanic-set-unset-handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-set-unset-handler.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -10,14 +10,15 @@\n \n // error-pattern:thread '<main>' panicked at 'foobar'\n \n-#![feature(std_panic, panic_handler)]\n+#![feature(panic_handler)]\n+\n use std::panic;\n use std::io::{self, Write};\n \n fn main() {\n-    panic::set_handler(|i| {\n+    panic::set_hook(Box::new(|i| {\n         write!(io::stderr(), \"greetings from the panic handler\");\n-    });\n-    panic::take_handler();\n+    }));\n+    panic::take_hook();\n     panic!(\"foobar\");\n }"}, {"sha": "58e57528e8a24e1527c9d22191fbceb7fa02309f", "filename": "src/test/run-fail/panic-take-handler-nop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Frun-fail%2Fpanic-take-handler-nop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Frun-fail%2Fpanic-take-handler-nop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-take-handler-nop.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -10,10 +10,11 @@\n \n // error-pattern:thread '<main>' panicked at 'foobar'\n \n-#![feature(std_panic, panic_handler)]\n+#![feature(panic_handler)]\n+\n use std::panic;\n \n fn main() {\n-    panic::take_handler();\n+    panic::take_hook();\n     panic!(\"foobar\");\n }"}, {"sha": "93d3345a8099121041059f62c9fbdf535ece6218", "filename": "src/test/run-pass/binary-heap-panic-safe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Frun-pass%2Fbinary-heap-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Frun-pass%2Fbinary-heap-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinary-heap-panic-safe.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(recover, rand, std_panic)]\n+#![feature(rand, std_panic)]\n \n use std::__rand::{thread_rng, Rng};\n-use std::panic::{self, AssertRecoverSafe};\n+use std::panic::{self, AssertUnwindSafe};\n \n use std::collections::BinaryHeap;\n use std::cmp;\n@@ -70,8 +70,8 @@ fn test_integrity() {\n             {\n                 // push the panicking item to the heap and catch the panic\n                 let thread_result = {\n-                    let mut heap_ref = AssertRecoverSafe(&mut heap);\n-                    panic::recover(move || {\n+                    let mut heap_ref = AssertUnwindSafe(&mut heap);\n+                    panic::catch_unwind(move || {\n                         heap_ref.push(panic_item);\n                     })\n                 };"}, {"sha": "0210017b47efb63f20519c12d648a24777f4f353", "filename": "src/test/run-pass/panic-recover-propagate.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Frun-pass%2Fpanic-recover-propagate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Frun-pass%2Fpanic-recover-propagate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-recover-propagate.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -10,25 +10,25 @@\n \n // ignore-emscripten no threads support\n \n-#![feature(std_panic, recover, panic_propagate, panic_handler, const_fn)]\n+#![feature(panic_handler)]\n \n-use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n use std::panic;\n use std::thread;\n \n-static A: AtomicUsize = AtomicUsize::new(0);\n+static A: AtomicUsize = ATOMIC_USIZE_INIT;\n \n fn main() {\n-    panic::set_handler(|_| {\n+    panic::set_hook(Box::new(|_| {\n         A.fetch_add(1, Ordering::SeqCst);\n-    });\n+    }));\n \n     let result = thread::spawn(|| {\n-        let result = panic::recover(|| {\n+        let result = panic::catch_unwind(|| {\n             panic!(\"hi there\");\n         });\n \n-        panic::propagate(result.unwrap_err());\n+        panic::resume_unwind(result.unwrap_err());\n     }).join();\n \n     let msg = *result.unwrap_err().downcast::<&'static str>().unwrap();"}, {"sha": "75a2e36ffb7a4a3f1ad0d5497fab556a5a0c4063", "filename": "src/test/run-pass/reachable-unnameable-items.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Frun-pass%2Freachable-unnameable-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Frun-pass%2Freachable-unnameable-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freachable-unnameable-items.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -10,8 +10,6 @@\n \n // aux-build:reachable-unnameable-items.rs\n \n-#![feature(recover)]\n-\n extern crate reachable_unnameable_items;\n use reachable_unnameable_items::*;\n \n@@ -37,5 +35,5 @@ fn main() {\n \n     let none = None;\n     function_accepting_unnameable_type(none);\n-    let _guard = std::panic::recover(|| none.unwrap().method_of_unnameable_type3());\n+    let _guard = std::panic::catch_unwind(|| none.unwrap().method_of_unnameable_type3());\n }"}, {"sha": "23d5a08e216443bf5e8a5b74c04fc4e5ab969491", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(std_panic, recover, start)]\n+#![feature(start)]\n \n use std::ffi::CStr;\n use std::process::{Command, Output};\n@@ -22,8 +22,8 @@ fn start(argc: isize, argv: *const *const u8) -> isize {\n             match **argv.offset(1) as char {\n                 '1' => {}\n                 '2' => println!(\"foo\"),\n-                '3' => assert!(panic::recover(|| {}).is_ok()),\n-                '4' => assert!(panic::recover(|| panic!()).is_err()),\n+                '3' => assert!(panic::catch_unwind(|| {}).is_ok()),\n+                '4' => assert!(panic::catch_unwind(|| panic!()).is_err()),\n                 '5' => assert!(Command::new(\"test\").spawn().is_err()),\n                 _ => panic!()\n             }"}, {"sha": "0f751501293f538cdda52298994a86599dc74363", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64c9d56700e2c41207166fe8709711ff02488ff/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=b64c9d56700e2c41207166fe8709711ff02488ff", "patch": "@@ -23,8 +23,6 @@ pub fn main() {\n     assert_eq!(s.chars().count(), 4);\n     assert_eq!(schs.len(), 4);\n     assert_eq!(schs.iter().cloned().collect::<String>(), s);\n-    assert_eq!(s.char_at(0), 'e');\n-    assert_eq!(s.char_at(1), '\u00e9');\n \n     assert!((str::from_utf8(s.as_bytes()).is_ok()));\n     // invalid prefix"}]}