{"sha": "4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiY2QxOWY2YmU1MWQ3ZmIyNmIwOTMwYzhhMzM1NGI5MjIyMTQzZmY=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-15T04:52:28Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-15T04:52:28Z"}, "message": "Convert ast::{pat,field_pat,local_,arm} into structs", "tree": {"sha": "6ba0d0ef21b56fdb6a4e800c01f17d91f6972006", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ba0d0ef21b56fdb6a4e800c01f17d91f6972006"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "html_url": "https://github.com/rust-lang/rust/commit/4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ea3136e84659773fea9e6f89cb7ddf76cee2324", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ea3136e84659773fea9e6f89cb7ddf76cee2324", "html_url": "https://github.com/rust-lang/rust/commit/3ea3136e84659773fea9e6f89cb7ddf76cee2324"}], "stats": {"total": 315, "additions": 185, "deletions": 130}, "files": [{"sha": "8d29ec211250473a108bbf9edd0fde84d5dcedf8", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "patch": "@@ -133,14 +133,19 @@ fn filter_stmt(cx: ctxt, &&stmt: @ast::stmt) ->\n     }\n }\n \n-fn fold_block(cx: ctxt, b: ast::blk_, fld: fold::ast_fold) ->\n-   ast::blk_ {\n+fn fold_block(\n+    cx: ctxt,\n+    b: ast::blk_,\n+    fld: fold::ast_fold\n+) -> ast::blk_ {\n     let filtered_stmts = vec::filter_map(b.stmts, |a| filter_stmt(cx, *a));\n-    return {view_items: /*bad*/copy b.view_items,\n-         stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(*x)),\n-         expr: option::map(&b.expr, |x| fld.fold_expr(*x)),\n-         id: b.id,\n-         rules: b.rules};\n+    ast::blk_ {\n+        view_items: /*bad*/copy b.view_items,\n+        stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(*x)),\n+        expr: option::map(&b.expr, |x| fld.fold_expr(*x)),\n+        id: b.id,\n+        rules: b.rules,\n+    }\n }\n \n fn item_in_cfg(cx: ctxt, item: @ast::item) -> bool {"}, {"sha": "32faeea464db2243e0f98ae1c7b8e73995080b3b", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "patch": "@@ -469,7 +469,7 @@ fn mk_test_wrapper(cx: test_ctxt,\n         cf: ast::return_val\n     };\n \n-    let wrapper_body: ast::blk = nospan({\n+    let wrapper_body = nospan(ast::blk_ {\n         view_items: ~[],\n         stmts: ~[@call_stmt],\n         expr: option::None,"}, {"sha": "0edce246dbd763d8083a8505570adf165b464ade", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "patch": "@@ -267,7 +267,10 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n             }\n         };\n         // XXX: Bad copy.\n-        let blk_sans_items = { stmts: stmts_sans_items,.. copy blk };\n+        let blk_sans_items = ast::blk_ {\n+            stmts: stmts_sans_items,\n+            .. copy blk\n+        };\n         fold::noop_fold_block(blk_sans_items, fld)\n     }\n "}, {"sha": "ab70e8e55568fd1bdfbb8e0622a7b2730cdda22a", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "patch": "@@ -478,7 +478,7 @@ fn ctor_arity(cx: @MatchCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n }\n \n fn wild() -> @pat {\n-    @{id: 0, node: pat_wild, span: ast_util::dummy_sp()}\n+    @pat {id: 0, node: pat_wild, span: ast_util::dummy_sp()}\n }\n \n fn specialize(cx: @MatchCheckCtxt, r: ~[@pat], ctor_id: ctor, arity: uint,"}, {"sha": "dcc5e2b83c167af909781c8fa2ebff025c9fe613", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "patch": "@@ -499,7 +499,7 @@ fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n     let _indenter = indenter();\n \n     let tcx = bcx.tcx();\n-    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, tcx.def_map, m, col, val) |p| {\n         match /*bad*/copy p.node {\n             ast::pat_enum(_, subpats) => {\n@@ -600,7 +600,7 @@ fn enter_rec_or_struct(bcx: block, dm: DefMap, m: &[@Match/&r], col: uint,\n            bcx.val_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match /*bad*/copy p.node {\n             ast::pat_rec(fpats, _) | ast::pat_struct(_, fpats, _) => {\n@@ -632,7 +632,7 @@ fn enter_tup(bcx: block, dm: DefMap, m: &[@Match/&r],\n            bcx.val_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match /*bad*/copy p.node {\n             ast::pat_tup(elts) => {\n@@ -657,7 +657,7 @@ fn enter_tuple_struct(bcx: block, dm: DefMap, m: &[@Match/&r], col: uint,\n            bcx.val_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match /*bad*/copy p.node {\n             ast::pat_enum(_, Some(elts)) => Some(elts),\n@@ -680,7 +680,7 @@ fn enter_box(bcx: block, dm: DefMap, m: &[@Match/&r],\n            bcx.val_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n             ast::pat_box(sub) => {\n@@ -705,7 +705,7 @@ fn enter_uniq(bcx: block, dm: DefMap, m: &[@Match/&r],\n            bcx.val_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n             ast::pat_uniq(sub) => {\n@@ -730,7 +730,7 @@ fn enter_region(bcx: block, dm: DefMap, m: &[@Match/&r],\n            bcx.val_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::pat { id: 0, node: ast::pat_wild, span: dummy_sp() };\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n             ast::pat_region(sub) => {"}, {"sha": "c3f2eac8a2aa4307fa416fb5a715d09b427923f2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "patch": "@@ -323,11 +323,18 @@ struct blk_ {\n \n #[auto_encode]\n #[auto_decode]\n-type pat = {id: node_id, node: pat_, span: span};\n+struct pat {\n+    id: node_id,\n+    node: pat_,\n+    span: span,\n+}\n \n #[auto_encode]\n #[auto_decode]\n-type field_pat = {ident: ident, pat: @pat};\n+struct field_pat {\n+    ident: ident,\n+    pat: @pat,\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -637,8 +644,13 @@ enum stmt_ {\n // a refinement on pat.\n #[auto_encode]\n #[auto_decode]\n-type local_ =  {is_mutbl: bool, ty: @Ty, pat: @pat,\n-                init: Option<@expr>, id: node_id};\n+struct local_ {\n+    is_mutbl: bool,\n+    ty: @Ty,\n+    pat: @pat,\n+    init: Option<@expr>,\n+    id: node_id,\n+}\n \n type local = spanned<local_>;\n \n@@ -650,7 +662,11 @@ enum decl_ { decl_local(~[@local]), decl_item(@item), }\n \n #[auto_encode]\n #[auto_decode]\n-type arm = {pats: ~[@pat], guard: Option<@expr>, body: blk};\n+struct arm {\n+    pats: ~[@pat],\n+    guard: Option<@expr>,\n+    body: blk,\n+}\n \n #[auto_encode]\n #[auto_decode]"}, {"sha": "d744a3e01ccf8a4fcc86d8e298576eb89c2550cd", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "patch": "@@ -312,9 +312,9 @@ fn ident_to_path(s: span, +i: ident) -> @path {\n }\n \n fn ident_to_pat(id: node_id, s: span, +i: ident) -> @pat {\n-    @{id: id,\n-      node: pat_ident(bind_by_value, ident_to_path(s, i), None),\n-      span: s}\n+    @ast::pat { id: id,\n+                node: pat_ident(bind_by_value, ident_to_path(s, i), None),\n+                span: s }\n }\n \n pure fn is_unguarded(a: &arm) -> bool {"}, {"sha": "fcb11f426478079334326bb0a4133c9b489dc884", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "patch": "@@ -317,11 +317,14 @@ priv impl ext_ctxt {\n     }\n \n     fn binder_pat(span: span, nm: ast::ident) -> @ast::pat {\n-        @{id: self.next_id(),\n-          node: ast::pat_ident(ast::bind_by_ref(ast::m_imm),\n-                               self.path(span, ~[nm]),\n-                               None),\n-          span: span}\n+        @ast::pat {\n+            id: self.next_id(),\n+            node: ast::pat_ident(\n+                ast::bind_by_ref(ast::m_imm),\n+                self.path(span, ~[nm]),\n+                None),\n+            span: span,\n+        }\n     }\n \n     fn stmt(expr: @ast::expr) -> @ast::stmt {\n@@ -579,12 +582,14 @@ fn mk_ser_method(\n     let ser_inputs = ~[{\n         mode: ast::infer(cx.next_id()),\n         ty: ty_s,\n-        pat: @{id: cx.next_id(),\n-               node: ast::pat_ident(\n-                    ast::bind_by_value,\n-                    ast_util::ident_to_path(span, cx.ident_of(~\"__s\")),\n-                    None),\n-               span: span},\n+        pat: @ast::pat {\n+            id: cx.next_id(),\n+            node: ast::pat_ident(\n+                ast::bind_by_value,\n+                ast_util::ident_to_path(span, cx.ident_of(~\"__s\")),\n+                None),\n+            span: span,\n+        },\n         id: cx.next_id(),\n     }];\n \n@@ -640,12 +645,14 @@ fn mk_deser_method(\n     let deser_inputs = ~[{\n         mode: ast::infer(cx.next_id()),\n         ty: ty_d,\n-        pat: @{id: cx.next_id(),\n-               node: ast::pat_ident(\n-                    ast::bind_by_value,\n-                    ast_util::ident_to_path(span, cx.ident_of(~\"__d\")),\n-                    None),\n-               span: span},\n+        pat: @ast::pat {\n+            id: cx.next_id(),\n+            node: ast::pat_ident(\n+                ast::bind_by_value,\n+                ast_util::ident_to_path(span, cx.ident_of(~\"__d\")),\n+                None),\n+            span: span,\n+        },\n         id: cx.next_id(),\n     }];\n \n@@ -967,7 +974,7 @@ fn ser_variant(\n         )\n     };\n \n-    let pat = @{\n+    let pat = @ast::pat {\n         id: cx.next_id(),\n         node: pat_node,\n         span: span,\n@@ -1020,7 +1027,7 @@ fn ser_variant(\n         ]\n     );\n \n-    { pats: ~[pat], guard: None, body: cx.expr_blk(body) }\n+    ast::arm { pats: ~[pat], guard: None, body: cx.expr_blk(body) }\n }\n \n fn mk_enum_ser_body(\n@@ -1132,21 +1139,25 @@ fn mk_enum_deser_body(\n                 fail ~\"enum variants unimplemented\",\n         };\n \n-        let pat = @{\n+        let pat = @ast::pat {\n             id: cx.next_id(),\n             node: ast::pat_lit(cx.lit_uint(span, v_idx)),\n             span: span,\n         };\n \n-        {\n+        ast::arm {\n             pats: ~[pat],\n             guard: None,\n             body: cx.expr_blk(body),\n         }\n     };\n \n-    let impossible_case = {\n-        pats: ~[@{ id: cx.next_id(), node: ast::pat_wild, span: span}],\n+    let impossible_case = ast::arm {\n+        pats: ~[@ast::pat {\n+            id: cx.next_id(),\n+            node: ast::pat_wild,\n+            span: span,\n+        }],\n         guard: None,\n \n         // FIXME(#3198): proper error message\n@@ -1167,13 +1178,14 @@ fn mk_enum_deser_body(\n                         node: ast::ty_infer,\n                         span: span\n                     },\n-                    pat: @{id: cx.next_id(),\n-                           node: ast::pat_ident(\n-                                ast::bind_by_value,\n-                                ast_util::ident_to_path(span,\n-                                                        cx.ident_of(~\"i\")),\n-                                None),\n-                           span: span},\n+                    pat: @ast::pat {\n+                        id: cx.next_id(),\n+                        node: ast::pat_ident(\n+                            ast::bind_by_value,\n+                            ast_util::ident_to_path(span, cx.ident_of(~\"i\")),\n+                            None),\n+                        span: span,\n+                    },\n                     id: cx.next_id(),\n                 }],\n                 output: @{"}, {"sha": "72c13747bf18b7f9b97598ad38444930791dafbf", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "patch": "@@ -181,18 +181,25 @@ fn mk_glob_use(cx: ext_ctxt, sp: span,\n fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n             ident: ast::ident, ex: @ast::expr) -> @ast::stmt {\n \n-    let pat : @ast::pat = @{id: cx.next_id(),\n-                            node: ast::pat_ident(ast::bind_by_value,\n-                                                 mk_raw_path(sp, ~[ident]),\n-                                                 None),\n-                           span: sp};\n+    let pat = @ast::pat {\n+        id: cx.next_id(),\n+        node: ast::pat_ident(\n+            ast::bind_by_value,\n+            mk_raw_path(sp, ~[ident]),\n+            None),\n+        span: sp,\n+    };\n     let ty : @ast::Ty = @{ id: cx.next_id(), node: ast::ty_infer, span: sp };\n-    let local : @ast::local = @ast::spanned { node: { is_mutbl: mutbl,\n-                                                      ty: ty,\n-                                                      pat: pat,\n-                                                      init: Some(ex),\n-                                                      id: cx.next_id()},\n-                                              span: sp};\n+    let local = @ast::spanned {\n+        node: ast::local_ {\n+            is_mutbl: mutbl,\n+            ty: ty,\n+            pat: pat,\n+            init: Some(ex),\n+            id: cx.next_id(),\n+        },\n+        span: sp,\n+    };\n     let decl = ast::spanned {node: ast::decl_local(~[local]), span: sp};\n     @ast::spanned { node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n }\n@@ -243,7 +250,7 @@ fn mk_managed(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_unary(ast::box(ast::m_imm), e))\n }\n fn mk_pat(cx: ext_ctxt, span: span, +pat: ast::pat_) -> @ast::pat {\n-    @{ id: cx.next_id(), node: move pat, span: span }\n+    @ast::pat { id: cx.next_id(), node: pat, span: span }\n }\n fn mk_pat_ident(cx: ext_ctxt, span: span, ident: ast::ident) -> @ast::pat {\n     let path = mk_raw_path(span, ~[ ident ]);"}, {"sha": "2148ad0cdb6e82491a3e14fbd865187cc34c649a", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "patch": "@@ -374,22 +374,17 @@ fn create_enum_variant_pattern(cx: ext_ctxt,\n                                              prefix,\n                                              struct_def.fields.len());\n \n-            let field_pats = dvec::DVec();\n-            for struct_def.fields.eachi |i, struct_field| {\n+            let field_pats = do struct_def.fields.mapi |i, struct_field| {\n                 let ident = match struct_field.node.kind {\n                     named_field(ident, _, _) => ident,\n                     unnamed_field => {\n                         cx.span_bug(span, ~\"unexpected unnamed field\");\n                     }\n                 };\n-                field_pats.push({ ident: ident, pat: subpats[i] });\n-            }\n-            let field_pats = dvec::unwrap(move field_pats);\n+                ast::field_pat { ident: ident, pat: subpats[i] }\n+            };\n \n-            return build::mk_pat_struct(cx,\n-                                        span,\n-                                        matching_path,\n-                                        move field_pats);\n+            build::mk_pat_struct(cx, span, matching_path, field_pats)\n         }\n         enum_variant_kind(*) => {\n             cx.span_unimpl(span, ~\"enum variants for `deriving`\");\n@@ -732,7 +727,7 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n                                                          matching_body_expr);\n \n         // Create the matching arm.\n-        let matching_arm = {\n+        let matching_arm = ast::arm {\n             pats: ~[ matching_pat ],\n             guard: None,\n             body: move matching_body_block\n@@ -743,7 +738,7 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n         // variant then there will always be a match.\n         if enum_definition.variants.len() > 1 {\n             // Create the nonmatching pattern.\n-            let nonmatching_pat = @{\n+            let nonmatching_pat = @ast::pat {\n                 id: cx.next_id(),\n                 node: pat_wild,\n                 span: span\n@@ -757,12 +752,12 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n                                        nonmatching_expr);\n \n             // Create the nonmatching arm.\n-            let nonmatching_arm = {\n+            let nonmatching_arm = ast::arm {\n                 pats: ~[ nonmatching_pat ],\n                 guard: None,\n-                body: move nonmatching_body_block\n+                body: nonmatching_body_block,\n             };\n-            other_arms.push(move nonmatching_arm);\n+            other_arms.push(nonmatching_arm);\n         }\n \n         // Create the self pattern.\n@@ -784,10 +779,10 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n                                                             other_match_expr);\n \n         // Create the self arm.\n-        let self_arm = {\n+        let self_arm = ast::arm {\n             pats: ~[ self_pat ],\n             guard: None,\n-            body: move other_match_body_block\n+            body: other_match_body_block,\n         };\n         self_arms.push(move self_arm);\n     }\n@@ -813,8 +808,7 @@ fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n                                           enum_definition: &enum_def)\n                                        -> @method {\n     // Create the arms of the match in the method body.\n-    let arms = dvec::DVec();\n-    for enum_definition.variants.eachi |i, variant| {\n+    let arms = do enum_definition.variants.mapi |i, variant| {\n         // Create the matching pattern.\n         let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n \n@@ -850,24 +844,22 @@ fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n         let match_body_block = build::mk_block_(cx, span, move stmts);\n \n         // Create the arm.\n-        let arm = {\n+        ast::arm {\n             pats: ~[ pat ],\n             guard: None,\n-            body: move match_body_block\n-        };\n-        arms.push(move arm);\n-    }\n+            body: match_body_block,\n+        }\n+    };\n \n     // Create the method body.\n     let self_ident = cx.ident_of(~\"self\");\n     let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n     let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let arms = dvec::unwrap(move arms);\n-    let self_match_expr = expr_match(self_expr, move arms);\n-    let self_match_expr = build::mk_expr(cx, span, move self_match_expr);\n+    let self_match_expr = expr_match(self_expr, arms);\n+    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n     let self_match_stmt = build::mk_stmt(cx, span, self_match_expr);\n \n     // Create the method.\n-    return create_iter_bytes_method(cx, span, ~[ self_match_stmt ]);\n+    create_iter_bytes_method(cx, span, ~[ self_match_stmt ])\n }\n "}, {"sha": "29d27e53d689ad252f09fc4a1f6822efa258cd1a", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "patch": "@@ -181,15 +181,19 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     }\n \n     fn arg(name: ident, ty: @ast::Ty) -> ast::arg {\n-        {mode: ast::infer(self.next_id()),\n-         ty: ty,\n-         pat: @{id: self.next_id(),\n+        {\n+            mode: ast::infer(self.next_id()),\n+            ty: ty,\n+            pat: @ast::pat {\n+                id: self.next_id(),\n                 node: ast::pat_ident(\n                     ast::bind_by_value,\n                     ast_util::ident_to_path(dummy_sp(), name),\n                     None),\n-                span: dummy_sp()},\n-         id: self.next_id()}\n+                span: dummy_sp(),\n+            },\n+            id: self.next_id(),\n+        }\n     }\n \n     fn block(+stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk {"}, {"sha": "c1d5e6094fcbced6e8ba423bddc14f4ec73a566d", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "patch": "@@ -339,9 +339,11 @@ fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n }\n \n fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n-    return {pats: vec::map(a.pats, |x| fld.fold_pat(*x)),\n-         guard: option::map(&a.guard, |x| fld.fold_expr(*x)),\n-         body: fld.fold_block(a.body)};\n+    arm {\n+        pats: vec::map(a.pats, |x| fld.fold_pat(*x)),\n+        guard: option::map(&a.guard, |x| fld.fold_expr(*x)),\n+        body: fld.fold_block(a.body),\n+    }\n }\n \n fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n@@ -358,20 +360,22 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n                        |pats| vec::map(*pats, |x| fld.fold_pat(*x))))\n           }\n           pat_rec(fields, etc) => {\n-            let mut fs = ~[];\n-            for fields.each |f| {\n-                fs.push({ident: /* FIXME (#2543) */ copy f.ident,\n-                         pat: fld.fold_pat(f.pat)});\n-            }\n+            let fs = do fields.map |f| {\n+                ast::field_pat {\n+                    ident: /* FIXME (#2543) */ copy f.ident,\n+                    pat: fld.fold_pat(f.pat),\n+                }\n+            };\n             pat_rec(fs, etc)\n           }\n           pat_struct(pth, fields, etc) => {\n             let pth_ = fld.fold_path(pth);\n-            let mut fs = ~[];\n-            for fields.each |f| {\n-                fs.push({ident: /* FIXME (#2543) */ copy f.ident,\n-                         pat: fld.fold_pat(f.pat)});\n-            }\n+            let fs = do fields.map |f| {\n+                ast::field_pat {\n+                    ident: /* FIXME (#2543) */ copy f.ident,\n+                    pat: fld.fold_pat(f.pat)\n+                }\n+            };\n             pat_struct(pth_, fs, etc)\n           }\n           pat_tup(elts) => pat_tup(vec::map(elts, |x| fld.fold_pat(*x))),\n@@ -634,11 +638,13 @@ fn noop_fold_path(&&p: path, fld: ast_fold) -> path {\n }\n \n fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n-    return {is_mutbl: l.is_mutbl,\n-         ty: fld.fold_ty(l.ty),\n-         pat: fld.fold_pat(l.pat),\n-         init: l.init.map(|e| fld.fold_expr(*e)),\n-         id: fld.new_id(l.id)};\n+    local_ {\n+        is_mutbl: l.is_mutbl,\n+        ty: fld.fold_ty(l.ty),\n+        pat: fld.fold_pat(l.pat),\n+        init: l.init.map(|e| fld.fold_expr(*e)),\n+        id: fld.new_id(l.id),\n+    }\n }\n \n /* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n@@ -731,9 +737,11 @@ impl ast_fold_fns: ast_fold {\n     }\n     fn fold_pat(&&x: @pat) -> @pat {\n         let (n, s) =  (self.fold_pat)(x.node, x.span, self as ast_fold);\n-        return @{id: (self.new_id)(x.id),\n-              node: n,\n-              span: (self.new_span)(s)};\n+        @pat {\n+            id: (self.new_id)(x.id),\n+            node: n,\n+            span: (self.new_span)(s),\n+        }\n     }\n     fn fold_decl(&&x: @decl) -> @decl {\n         let (n, s) = (self.fold_decl)(x.node, x.span, self as ast_fold);"}, {"sha": "770c942059eeb3e902868518283840a795262633", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bcd19f6be51d7fb26b0930c8a3354b9222143ff/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4bcd19f6be51d7fb26b0930c8a3354b9222143ff", "patch": "@@ -1769,7 +1769,7 @@ impl Parser {\n                 span: expr.span,\n             };\n \n-            arms.push({pats: pats, guard: guard, body: blk});\n+            arms.push(ast::arm { pats: pats, guard: guard, body: blk });\n         }\n         let mut hi = self.span.hi;\n         self.bump();\n@@ -1833,9 +1833,9 @@ impl Parser {\n             let subpat = self.parse_pat(refutable);\n             if is_tail {\n                 match subpat {\n-                    @{ node: pat_wild, _ } => (),\n-                    @{ node: pat_ident(_, _, _), _ } => (),\n-                    @{ span, _ } => self.span_fatal(\n+                    @ast::pat { node: pat_wild, _ } => (),\n+                    @ast::pat { node: pat_ident(_, _, _), _ } => (),\n+                    @ast::pat { span, _ } => self.span_fatal(\n                         span, ~\"expected an identifier or `_`\"\n                     )\n                 }\n@@ -1881,13 +1881,13 @@ impl Parser {\n                 self.bump();\n                 subpat = self.parse_pat(refutable);\n             } else {\n-                subpat = @{\n+                subpat = @ast::pat {\n                     id: self.get_id(),\n                     node: pat_ident(bind_infer, fieldpath, None),\n                     span: self.last_span\n                 };\n             }\n-            fields.push({ident: fieldname, pat: subpat});\n+            fields.push(ast::field_pat { ident: fieldname, pat: subpat });\n         }\n         return (fields, etc);\n     }\n@@ -2092,7 +2092,7 @@ impl Parser {\n             hi = self.span.hi;\n           }\n         }\n-        return @{id: self.get_id(), node: pat, span: mk_sp(lo, hi)};\n+        @ast::pat { id: self.get_id(), node: pat, span: mk_sp(lo, hi) }\n     }\n \n     fn parse_pat_ident(refutable: bool,\n@@ -2131,9 +2131,17 @@ impl Parser {\n                        span: mk_sp(lo, lo)};\n         if self.eat(token::COLON) { ty = self.parse_ty(false); }\n         let init = if allow_init { self.parse_initializer() } else { None };\n-        return @spanned(lo, self.last_span.hi,\n-                     {is_mutbl: is_mutbl, ty: ty, pat: pat,\n-                      init: init, id: self.get_id()});\n+        @spanned(\n+            lo,\n+            self.last_span.hi,\n+            ast::local_ {\n+                is_mutbl: is_mutbl,\n+                ty: ty,\n+                pat: pat,\n+                init: init,\n+                id: self.get_id(),\n+            }\n+        )\n     }\n \n     fn parse_let() -> @decl {"}]}