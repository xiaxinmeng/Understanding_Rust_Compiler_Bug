{"sha": "a66e01369da407e785f884f6b1b837506b41da6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NmUwMTM2OWRhNDA3ZTc4NWY4ODRmNmIxYjgzNzUwNmI0MWRhNmE=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-10-24T21:38:49Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2012-10-24T21:38:49Z"}, "message": "Merge pull request #3852 from veddan/type-limits\n\nLint pass like GCC's -Wtype-limits (#3833)", "tree": {"sha": "527c9dca7a485e664d4f1ca193f72a25c08ad68f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/527c9dca7a485e664d4f1ca193f72a25c08ad68f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a66e01369da407e785f884f6b1b837506b41da6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a66e01369da407e785f884f6b1b837506b41da6a", "html_url": "https://github.com/rust-lang/rust/commit/a66e01369da407e785f884f6b1b837506b41da6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a66e01369da407e785f884f6b1b837506b41da6a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "686840eb32bd2ca04a031e6a3c1d66b941ff8229", "url": "https://api.github.com/repos/rust-lang/rust/commits/686840eb32bd2ca04a031e6a3c1d66b941ff8229", "html_url": "https://github.com/rust-lang/rust/commit/686840eb32bd2ca04a031e6a3c1d66b941ff8229"}, {"sha": "0707780eace5bafa07c114319b9a0d774f196da4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0707780eace5bafa07c114319b9a0d774f196da4", "html_url": "https://github.com/rust-lang/rust/commit/0707780eace5bafa07c114319b9a0d774f196da4"}], "stats": {"total": 148, "additions": 148, "deletions": 0}, "files": [{"sha": "192b2924cb14df25fbfbf09bde985e956e0ffdab", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/a66e01369da407e785f884f6b1b837506b41da6a/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a66e01369da407e785f884f6b1b837506b41da6a/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=a66e01369da407e785f884f6b1b837506b41da6a", "patch": "@@ -54,6 +54,7 @@ enum lint {\n     deprecated_pattern,\n     non_camel_case_types,\n     structural_records,\n+    type_limits,\n \n     managed_heap_memory,\n     owned_heap_memory,\n@@ -186,6 +187,11 @@ fn get_lint_dict() -> lint_dict {\n            desc: ~\"allow legacy modes\",\n            default: forbid}),\n \n+        (~\"type_limits\",\n+         @{lint: type_limits,\n+           desc: ~\"comparisons made useless by limits of the types involved\",\n+           default: warn})\n+\n         /* FIXME(#3266)--make liveness warnings lintable\n         (~\"unused_variable\",\n          @{lint: unused_variable,\n@@ -397,6 +403,7 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n     check_item_heap(cx, i);\n     check_item_structural_records(cx, i);\n     check_item_deprecated_modes(cx, i);\n+    check_item_type_limits(cx, i);\n }\n \n // Take a visitor, and modify it so that it will not proceed past subitems.\n@@ -430,6 +437,122 @@ fn check_item_while_true(cx: ty::ctxt, it: @ast::item) {\n     visit::visit_item(it, (), visit);\n }\n \n+fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n+    pure fn is_valid<T: cmp::Ord>(binop: ast::binop, v: T,\n+            min: T, max: T) -> bool {\n+        match binop {\n+            ast::lt => v <= max,\n+            ast::le => v < max,\n+            ast::gt => v >= min,\n+            ast::ge => v > min,\n+            ast::eq | ast::ne => v >= min && v <= max,\n+            _ => fail\n+        }\n+    }\n+\n+    pure fn rev_binop(binop: ast::binop) -> ast::binop {\n+        match binop {\n+            ast::lt => ast::gt,\n+            ast::le => ast::ge,\n+            ast::gt => ast::lt,\n+            ast::ge => ast::le,\n+            _ => binop\n+        }\n+    }\n+\n+    pure fn int_ty_range(int_ty: ast::int_ty) -> (i64, i64) {\n+        match int_ty {\n+            ast::ty_i =>    (int::min_value as i64, int::max_value as i64),\n+            ast::ty_char => (u32::min_value as i64, u32::max_value as i64),\n+            ast::ty_i8 =>   (i8::min_value  as i64, i8::max_value  as i64),\n+            ast::ty_i16 =>  (i16::min_value as i64, i16::max_value as i64),\n+            ast::ty_i32 =>  (i32::min_value as i64, i32::max_value as i64),\n+            ast::ty_i64 =>  (i64::min_value,        i64::max_value)\n+        }\n+    }\n+\n+    pure fn uint_ty_range(uint_ty: ast::uint_ty) -> (u64, u64) {\n+        match uint_ty {\n+            ast::ty_u =>   (uint::min_value as u64, uint::max_value as u64),\n+            ast::ty_u8 =>  (u8::min_value   as u64, u8::max_value   as u64),\n+            ast::ty_u16 => (u16::min_value  as u64, u16::max_value  as u64),\n+            ast::ty_u32 => (u32::min_value  as u64, u32::max_value  as u64),\n+            ast::ty_u64 => (u64::min_value,         u64::max_value)\n+        }\n+    }\n+\n+    fn check_limits(cx: ty::ctxt, binop: ast::binop, l: &ast::expr,\n+                    r: &ast::expr) -> bool {\n+        let (lit, expr, swap) = match (l.node, r.node) {\n+            (ast::expr_lit(_), _) => (l, r, true),\n+            (_, ast::expr_lit(_)) => (r, l, false),\n+            _ => return true\n+        };\n+        // Normalize the binop so that the literal is always on the RHS in\n+        // the comparison\n+        let norm_binop = if (swap) {\n+            rev_binop(binop)\n+        } else {\n+            binop\n+        };\n+        match ty::get(ty::expr_ty(cx, @*expr)).sty {\n+            ty::ty_int(int_ty) => {\n+                let (min, max) = int_ty_range(int_ty);\n+                let lit_val: i64 = match lit.node {\n+                    ast::expr_lit(@li) => match li.node {\n+                        ast::lit_int(v, _) => v,\n+                        ast::lit_uint(v, _) => v as i64,\n+                        ast::lit_int_unsuffixed(v) => v,\n+                        _ => return true\n+                    },\n+                    _ => fail\n+                };\n+                is_valid(norm_binop, lit_val, min, max)\n+            }\n+            ty::ty_uint(uint_ty) => {\n+                let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n+                let lit_val: u64 = match lit.node {\n+                    ast::expr_lit(@li) => match li.node {\n+                        ast::lit_int(v, _) => v as u64,\n+                        ast::lit_uint(v, _) => v,\n+                        ast::lit_int_unsuffixed(v) => v as u64,\n+                        _ => return true\n+                    },\n+                    _ => fail\n+                };\n+                is_valid(norm_binop, lit_val, min, max)\n+            }\n+            _ => true\n+        }\n+    }\n+\n+    pure fn is_comparison(binop: ast::binop) -> bool {\n+        match binop {\n+            ast::eq | ast::lt | ast::le |\n+            ast::ne | ast::ge | ast::gt => true,\n+            _ => false\n+        }\n+    }\n+\n+    let visit = item_stopping_visitor(visit::mk_simple_visitor(@{\n+        visit_expr: fn@(e: @ast::expr) {\n+            match e.node {\n+                ast::expr_binary(binop, @l, @r) => {\n+                    if is_comparison(binop)\n+                       && !check_limits(cx, binop, &l, &r) {\n+                        cx.sess.span_lint(\n+                            type_limits, e.id, it.id, e.span,\n+                            ~\"comparison is useless due to type limits\");\n+                    }\n+                }\n+                _ => ()\n+            }\n+        },\n+        .. *visit::default_simple_visitor()\n+    }));\n+    visit::visit_item(it, (), visit);\n+}\n+\n fn check_item_structural_records(cx: ty::ctxt, it: @ast::item) {\n     let visit = item_stopping_visitor(visit::mk_simple_visitor(@{\n         visit_expr: fn@(e: @ast::expr) {"}, {"sha": "14bffdca241bed88a69d86cd71f625c6b49f641e", "filename": "src/test/compile-fail/lint-type-limits.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a66e01369da407e785f884f6b1b837506b41da6a/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a66e01369da407e785f884f6b1b837506b41da6a/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-limits.rs?ref=a66e01369da407e785f884f6b1b837506b41da6a", "patch": "@@ -0,0 +1,25 @@\n+// compile-flags: -D type-limits\n+fn main() { }\n+\n+fn foo() {\n+    let mut i = 100u;\n+    while i >= 0 { //~ ERROR comparison is useless due to type limits\n+        i -= 1;\n+    }\n+}\n+\n+fn bar() -> i8 {\n+    return 123;\n+}\n+\n+fn baz() -> bool {\n+    128 > bar() //~ ERROR comparison is useless due to type limits\n+}\n+\n+fn qux() {\n+    let mut i = 1i8;\n+    while 200 != i { //~ ERROR comparison is useless due to type limits\n+        i += 1;\n+    }\n+}\n+"}]}