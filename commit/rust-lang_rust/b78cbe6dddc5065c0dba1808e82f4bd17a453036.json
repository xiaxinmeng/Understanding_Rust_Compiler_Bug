{"sha": "b78cbe6dddc5065c0dba1808e82f4bd17a453036", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3OGNiZTZkZGRjNTA2NWMwZGJhMTgwOGU4MmY0YmQxN2E0NTMwMzY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-03T23:49:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-03T23:49:08Z"}, "message": "Rollup merge of #59663 - matklad:borrow, r=dtolnay\n\nBe more direct about borrow contract\n\nI always was confused by the difference between Borrow and AsRef, despite the fact that I've read all available docs at least a dozen of times.\n\nI finally grokked the difference between the two when I realized the Borrow invariant:\n\n> If you implement Borrow, you **must** make sure that Eq, Ord and Hash implementations are equivalent for borrowed and owned data\n\nMy problem was that this invariant is not stated explicitly in documentation, and instead some  vague and philosophical notions are used.\n\nSo I suggest to mention the requirements of `Borrow` very explicitly: instead of \"use Borrow when X and use AsRef when Y\", let's phrase this as `Borrow` differs from `AsRef` in `W`, so that's why `Borrow` is for `X` and `AsRef` is for `Y`.\n\nNote that this change could be seen as tightening contract of the Borrow. Let's say Alice has written the following code:\n\n```rust\n#[derive(PartialEq, Eq, Hash, PartialOrd, Ord)]\nstruct Person {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Borrow<str> for Person {\n      fn borrow(&self) -> &str { self.first_name.as_str() }\n}\n```\n\nNow Bob uses this `Person` struct, puts it into `HashMap` and tries to look it up using `&str` for the first name. Bob's code naturally fails.\n\nThe question is, who is to blame: Alice, who has written the impl, or Bob, who uses the HashMap. If I read the current docs literally, I would say that `Bob` is to blame: `Eq` and `Hash` bounds appear on HashMap, so it is the HashMap which requires that they are consistent. By using a type for which the `Borrow` impl does not yield well-behaved `Eq`, Bob is violating contract of HashMap.\n\nIf, as this PR proposes, we unconditionally require that Eq & friends for borrow should be valid, then the blame shifts to Alice, which I think is more reasonable.\n\ncloses https://github.com/rust-lang/rust/issues/44868", "tree": {"sha": "ce496b2a6dae0f290f28aaca0354626c52001b7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce496b2a6dae0f290f28aaca0354626c52001b7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b78cbe6dddc5065c0dba1808e82f4bd17a453036", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcpUZ0CRBK7hj4Ov3rIwAAdHIIADZkFlJFaCDGQ3YVT1nqrZXd\nsNOnPPF1ddP/IivFSPty6JSrJyVkDZbeefOX4U4qu9I4ftv1Iju6Vhz/yd7wLXyY\nHO5EVsXAXYB7SbRBvIppq8c8HTxOYpUP70aQBg1t+yScSNE4ITpwOc1K+RzuH8px\nVoIaCEJMCHgkjP4/W+4XsTrCCrAaX7urZk/xkQMljqI1BbzUx7H1Biaa4hiLjVRK\nkjFEsb9pHJ46Zflsjfm4UH2i/JEUQpq3yCib0w+p9JU+OK74HN+yyOGyJFWgrgVS\ng35OdZdI1QcECJO4L49JxjfbZnhZXOmXOE2sq68BGc9JQNH2UTl02QfVf0We/GU=\n=XDC0\n-----END PGP SIGNATURE-----\n", "payload": "tree ce496b2a6dae0f290f28aaca0354626c52001b7c\nparent dcccab56bab29439fd154fd8114a3679a1ed5b3d\nparent 1cfed0d452d739b502c73904d61a1f4496b1acf5\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1554335348 +0200\ncommitter GitHub <noreply@github.com> 1554335348 +0200\n\nRollup merge of #59663 - matklad:borrow, r=dtolnay\n\nBe more direct about borrow contract\n\nI always was confused by the difference between Borrow and AsRef, despite the fact that I've read all available docs at least a dozen of times.\n\nI finally grokked the difference between the two when I realized the Borrow invariant:\n\n> If you implement Borrow, you **must** make sure that Eq, Ord and Hash implementations are equivalent for borrowed and owned data\n\nMy problem was that this invariant is not stated explicitly in documentation, and instead some  vague and philosophical notions are used.\n\nSo I suggest to mention the requirements of `Borrow` very explicitly: instead of \"use Borrow when X and use AsRef when Y\", let's phrase this as `Borrow` differs from `AsRef` in `W`, so that's why `Borrow` is for `X` and `AsRef` is for `Y`.\n\nNote that this change could be seen as tightening contract of the Borrow. Let's say Alice has written the following code:\n\n```rust\n#[derive(PartialEq, Eq, Hash, PartialOrd, Ord)]\nstruct Person {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Borrow<str> for Person {\n      fn borrow(&self) -> &str { self.first_name.as_str() }\n}\n```\n\nNow Bob uses this `Person` struct, puts it into `HashMap` and tries to look it up using `&str` for the first name. Bob's code naturally fails.\n\nThe question is, who is to blame: Alice, who has written the impl, or Bob, who uses the HashMap. If I read the current docs literally, I would say that `Bob` is to blame: `Eq` and `Hash` bounds appear on HashMap, so it is the HashMap which requires that they are consistent. By using a type for which the `Borrow` impl does not yield well-behaved `Eq`, Bob is violating contract of HashMap.\n\nIf, as this PR proposes, we unconditionally require that Eq & friends for borrow should be valid, then the blame shifts to Alice, which I think is more reasonable.\n\ncloses https://github.com/rust-lang/rust/issues/44868\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b78cbe6dddc5065c0dba1808e82f4bd17a453036", "html_url": "https://github.com/rust-lang/rust/commit/b78cbe6dddc5065c0dba1808e82f4bd17a453036", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b78cbe6dddc5065c0dba1808e82f4bd17a453036/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcccab56bab29439fd154fd8114a3679a1ed5b3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcccab56bab29439fd154fd8114a3679a1ed5b3d", "html_url": "https://github.com/rust-lang/rust/commit/dcccab56bab29439fd154fd8114a3679a1ed5b3d"}, {"sha": "1cfed0d452d739b502c73904d61a1f4496b1acf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cfed0d452d739b502c73904d61a1f4496b1acf5", "html_url": "https://github.com/rust-lang/rust/commit/1cfed0d452d739b502c73904d61a1f4496b1acf5"}], "stats": {"total": 14, "additions": 10, "deletions": 4}, "files": [{"sha": "4d58aaca941833ac047d7282c25261bfad9e329c", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b78cbe6dddc5065c0dba1808e82f4bd17a453036/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b78cbe6dddc5065c0dba1808e82f4bd17a453036/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=b78cbe6dddc5065c0dba1808e82f4bd17a453036", "patch": "@@ -32,6 +32,10 @@\n /// on the identical behavior of these additional trait implementations.\n /// These traits will likely appear as additional trait bounds.\n ///\n+/// In particular `Eq`, `Ord` and `Hash` must be equivalent for\n+/// borrowed and owned values: `x.borrow() == y.borrow()` should give the\n+/// same result as `x == y`.\n+///\n /// If generic code merely needs to work for all types that can\n /// provide a reference to related type `T`, it is often better to use\n /// [`AsRef<T>`] as more types can safely implement it."}, {"sha": "7b9e19e36a293be5a2af5b1f996a94c275452610", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b78cbe6dddc5065c0dba1808e82f4bd17a453036/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b78cbe6dddc5065c0dba1808e82f4bd17a453036/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=b78cbe6dddc5065c0dba1808e82f4bd17a453036", "patch": "@@ -105,11 +105,13 @@ pub const fn identity<T>(x: T) -> T { x }\n /// `&T` or write a custom function.\n ///\n ///\n-/// `AsRef` is very similar to, but serves a slightly different purpose than [`Borrow`]:\n+/// `AsRef` has the same signature as [`Borrow`], but `Borrow` is different in few aspects:\n ///\n-/// - Use `AsRef` when the goal is to simply convert into a reference\n-/// - Use `Borrow` when the goal is related to writing code that is agnostic to\n-///   the type of borrow and whether it is a reference or value\n+/// - Unlike `AsRef`, `Borrow` has a blanket impl for any `T`, and can be used to accept either\n+///   a reference or a value.\n+/// - `Borrow` also requires that `Hash`, `Eq` and `Ord` for borrowed value are\n+///   equivalent to those of the owned value. For this reason, if you want to\n+///   borrow only a single field of a struct you can implement `AsRef`, but not `Borrow`.\n ///\n /// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n ///"}]}