{"sha": "5804a306868aee5ff0a3d7829db7924978317f0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MDRhMzA2ODY4YWVlNWZmMGEzZDc4MjlkYjc5MjQ5NzgzMTdmMGU=", "commit": {"author": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-20T15:57:36Z"}, "committer": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-26T22:21:52Z"}, "message": "Warn on pattern bindings that have the same name as a variant\n\n...of the type being matched.\n\nThis change will result in a better diagnostic for code like the following:\n\n```rust\nenum Enum {\n    Foo,\n    Bar\n}\n\nfn f(x: Enum) {\n    match x {\n        Foo => (),\n        Bar => ()\n    }\n}\n```\n\nwhich would currently simply fail with an unreachable pattern error\non the 2nd arm.\n\nThe user is advised to either use a qualified path in the patterns\nor import the variants explicitly into the scope.", "tree": {"sha": "f269799695b88cd0d00df02549ad77bfa7faf5b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f269799695b88cd0d00df02549ad77bfa7faf5b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5804a306868aee5ff0a3d7829db7924978317f0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5804a306868aee5ff0a3d7829db7924978317f0e", "html_url": "https://github.com/rust-lang/rust/commit/5804a306868aee5ff0a3d7829db7924978317f0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5804a306868aee5ff0a3d7829db7924978317f0e/comments", "author": null, "committer": null, "parents": [{"sha": "6faff24ec85744de092a7d7c2378370f65d623bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6faff24ec85744de092a7d7c2378370f65d623bb", "html_url": "https://github.com/rust-lang/rust/commit/6faff24ec85744de092a7d7c2378370f65d623bb"}], "stats": {"total": 129, "additions": 100, "deletions": 29}, "files": [{"sha": "28504210a3f39cdf067b49e076c28ff8a826748f", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5804a306868aee5ff0a3d7829db7924978317f0e/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5804a306868aee5ff0a3d7829db7924978317f0e/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=5804a306868aee5ff0a3d7829db7924978317f0e", "patch": "@@ -145,5 +145,6 @@ register_diagnostics!(\n     E0166,\n     E0167,\n     E0168,\n-    E0169\n+    E0169,\n+    E0170\n )"}, {"sha": "ed119081f78c7913a3a840d368c37b5e6c415d73", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 58, "deletions": 26, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5804a306868aee5ff0a3d7829db7924978317f0e/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5804a306868aee5ff0a3d7829db7924978317f0e/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5804a306868aee5ff0a3d7829db7924978317f0e", "patch": "@@ -153,19 +153,14 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n     visit::walk_expr(cx, ex);\n     match ex.node {\n         ast::ExprMatch(ref scrut, ref arms, source) => {\n-            // First, check legality of move bindings.\n             for arm in arms.iter() {\n+                // First, check legality of move bindings.\n                 check_legality_of_move_bindings(cx,\n                                                 arm.guard.is_some(),\n                                                 arm.pats.as_slice());\n-                for pat in arm.pats.iter() {\n-                    check_legality_of_bindings_in_at_patterns(cx, &**pat);\n-                }\n-            }\n \n-            // Second, if there is a guard on each arm, make sure it isn't\n-            // assigning or borrowing anything mutably.\n-            for arm in arms.iter() {\n+                // Second, if there is a guard on each arm, make sure it isn't\n+                // assigning or borrowing anything mutably.\n                 match arm.guard {\n                     Some(ref guard) => check_for_mutation_in_guard(cx, &**guard),\n                     None => {}\n@@ -179,13 +174,23 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 }).collect(), arm.guard.as_ref().map(|e| &**e))\n             }).collect::<Vec<(Vec<P<Pat>>, Option<&ast::Expr>)>>();\n \n+            // Bail out early if inlining failed.\n             if static_inliner.failed {\n                 return;\n             }\n \n-            // Third, check if there are any references to NaN that we should warn about.\n-            for &(ref pats, _) in inlined_arms.iter() {\n-                check_for_static_nan(cx, pats.as_slice());\n+            for pat in inlined_arms\n+                .iter()\n+                .flat_map(|&(ref pats, _)| pats.iter()) {\n+                // Third, check legality of move bindings.\n+                check_legality_of_bindings_in_at_patterns(cx, &**pat);\n+\n+                // Fourth, check if there are any references to NaN that we should warn about.\n+                check_for_static_nan(cx, &**pat);\n+\n+                // Fifth, check if for any of the patterns that match an enumerated type\n+                // are bindings with the same name as one of the variants of said type.\n+                check_for_bindings_named_the_same_as_variants(cx, &**pat);\n             }\n \n             // Fourth, check for unreachable arms.\n@@ -239,21 +244,49 @@ fn is_expr_const_nan(tcx: &ty::ctxt, expr: &ast::Expr) -> bool {\n     }\n }\n \n-// Check that we do not match against a static NaN (#6804)\n-fn check_for_static_nan(cx: &MatchCheckCtxt, pats: &[P<Pat>]) {\n-    for pat in pats.iter() {\n-        walk_pat(&**pat, |p| {\n-            match p.node {\n-                ast::PatLit(ref expr) if is_expr_const_nan(cx.tcx, &**expr) => {\n-                    span_warn!(cx.tcx.sess, p.span, E0003,\n-                        \"unmatchable NaN in pattern, \\\n-                            use the is_nan method in a guard instead\");\n+fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat) {\n+    walk_pat(pat, |p| {\n+        match p.node {\n+            ast::PatIdent(ast::BindByValue(ast::MutImmutable), ident, None) => {\n+                let pat_ty = ty::pat_ty(cx.tcx, p);\n+                if let ty::ty_enum(def_id, _) = pat_ty.sty {\n+                    let def = cx.tcx.def_map.borrow().get(&p.id).cloned();\n+                    if let Some(DefLocal(_)) = def {\n+                        if ty::enum_variants(cx.tcx, def_id).iter().any(|variant|\n+                            token::get_name(variant.name) == token::get_name(ident.node.name)\n+                                && variant.args.len() == 0\n+                        ) {\n+                            span_warn!(cx.tcx.sess, p.span, E0170,\n+                                \"pattern binding `{}` is named the same as one \\\n+                                 of the variants of the type `{}`\",\n+                                token::get_ident(ident.node).get(), ty_to_string(cx.tcx, pat_ty));\n+                            span_help!(cx.tcx.sess, p.span,\n+                                \"if you meant to match on a variant, \\\n+                                 consider making the path in the pattern qualified: `{}::{}`\",\n+                                ty_to_string(cx.tcx, pat_ty), token::get_ident(ident.node).get());\n+                        }\n+                    }\n                 }\n-                _ => ()\n             }\n-            true\n-        });\n-    }\n+            _ => ()\n+        }\n+        true\n+    });\n+}\n+\n+// Check that we do not match against a static NaN (#6804)\n+fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n+    walk_pat(pat, |p| {\n+        match p.node {\n+            ast::PatLit(ref expr) if is_expr_const_nan(cx.tcx, &**expr) => {\n+                span_warn!(cx.tcx.sess, p.span, E0003,\n+                    \"unmatchable NaN in pattern, \\\n+                        use the is_nan method in a guard instead\");\n+            }\n+            _ => ()\n+        }\n+        true\n+    });\n }\n \n // Check for unreachable patterns\n@@ -414,8 +447,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n                 &Variant(vid) =>\n                     (vid, ty::enum_variant_with_id(cx.tcx, cid, vid).arg_names.is_some()),\n                 _ =>\n-                    (cid, ty::lookup_struct_fields(cx.tcx, cid).iter()\n-                        .any(|field| field.name != token::special_idents::unnamed_field.name))\n+                    (cid, !ty::is_tuple_struct(cx.tcx, cid))\n             };\n             if is_structure {\n                 let fields = ty::lookup_struct_fields(cx.tcx, vid);"}, {"sha": "47907ac2be9b8e4f778eb14a779ead0716a3391e", "filename": "src/test/compile-fail/issue-12116.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5804a306868aee5ff0a3d7829db7924978317f0e/src%2Ftest%2Fcompile-fail%2Fissue-12116.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5804a306868aee5ff0a3d7829db7924978317f0e/src%2Ftest%2Fcompile-fail%2Fissue-12116.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12116.rs?ref=5804a306868aee5ff0a3d7829db7924978317f0e", "patch": "@@ -17,7 +17,8 @@ fn tail(source_list: &IntList) -> IntList {\n     match source_list {\n         &IntList::Cons(val, box ref next_list) => tail(next_list),\n         &IntList::Cons(val, box Nil)           => IntList::Cons(val, box Nil),\n-        //~^ ERROR: unreachable pattern\n+//~^ ERROR unreachable pattern\n+//~^^ WARN pattern binding `Nil` is named the same as one of the variants of the type `IntList`\n         _                          => panic!()\n     }\n }"}, {"sha": "e79be99a346fa8692251b9c0508ba47bee897653", "filename": "src/test/compile-fail/issue-14221.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5804a306868aee5ff0a3d7829db7924978317f0e/src%2Ftest%2Fcompile-fail%2Fissue-14221.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5804a306868aee5ff0a3d7829db7924978317f0e/src%2Ftest%2Fcompile-fail%2Fissue-14221.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14221.rs?ref=5804a306868aee5ff0a3d7829db7924978317f0e", "patch": "@@ -17,7 +17,9 @@ pub mod b {\n     pub fn key(e: ::E) -> &'static str {\n         match e {\n             A => \"A\",\n+//~^ WARN pattern binding `A` is named the same as one of the variants of the type `E`\n             B => \"B\", //~ ERROR: unreachable pattern\n+//~^ WARN pattern binding `B` is named the same as one of the variants of the type `E`\n         }\n     }\n }"}, {"sha": "eb5c475e7ef4fdca3aff442ad5b272be419d0a99", "filename": "src/test/compile-fail/lint-uppercase-variables.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5804a306868aee5ff0a3d7829db7924978317f0e/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5804a306868aee5ff0a3d7829db7924978317f0e/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs?ref=5804a306868aee5ff0a3d7829db7924978317f0e", "patch": "@@ -33,7 +33,8 @@ fn main() {\n     match f.read(&mut buff) {\n         Ok(cnt) => println!(\"read this many bytes: {}\", cnt),\n         Err(IoError{ kind: EndOfFile, .. }) => println!(\"Got end of file: {}\", EndOfFile.to_string()),\n-        //~^ ERROR variable `EndOfFile` should have a snake case name such as `end_of_file`\n+//~^ ERROR variable `EndOfFile` should have a snake case name such as `end_of_file`\n+//~^^ WARN `EndOfFile` is named the same as one of the variants of the type `std::io::IoErrorKind`\n     }\n \n     test(1);"}, {"sha": "cee5c808f9982c9f2abffb676db472df666c8f89", "filename": "src/test/run-pass/issue-19100.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5804a306868aee5ff0a3d7829db7924978317f0e/src%2Ftest%2Frun-pass%2Fissue-19100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5804a306868aee5ff0a3d7829db7924978317f0e/src%2Ftest%2Frun-pass%2Fissue-19100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19100.rs?ref=5804a306868aee5ff0a3d7829db7924978317f0e", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Foo {\n+    Bar,\n+    Baz\n+}\n+\n+impl Foo {\n+    fn foo(&self) {\n+        match self {\n+            &\n+Bar if true\n+//~^ WARN pattern binding `Bar` is named the same as one of the variants of the type `Foo`\n+//~^^ HELP to match on a variant, consider making the path in the pattern qualified: `Foo::Bar`\n+=> println!(\"bar\"),\n+            &\n+Baz if false\n+//~^ WARN pattern binding `Baz` is named the same as one of the variants of the type `Foo`\n+//~^^ HELP to match on a variant, consider making the path in the pattern qualified: `Foo::Baz`\n+=> println!(\"baz\"),\n+_ => ()\n+        }\n+    }\n+}\n+\n+fn main() {}"}]}