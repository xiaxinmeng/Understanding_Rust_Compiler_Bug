{"sha": "16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2YmJmNGFiN2YxMzJlNmU1ZTUzMThkY2NkZWY5YTVkNzFhZmRkN2Y=", "commit": {"author": {"name": "Mikhail Rakhmanov", "email": "rakhmanov.m@gmail.com", "date": "2020-06-13T06:42:15Z"}, "committer": {"name": "Mikhail Rakhmanov", "email": "rakhmanov.m@gmail.com", "date": "2020-06-13T06:42:15Z"}, "message": "Merge branch 'master' into keyword_completion\n\n# Conflicts:\n#\tdocs/user/generated_features.adoc", "tree": {"sha": "4b79fa8c046be56b02427ba843e70cdf3ac05767", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b79fa8c046be56b02427ba843e70cdf3ac05767"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "html_url": "https://github.com/rust-lang/rust/commit/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/comments", "author": {"login": "mcrakhman", "id": 16068868, "node_id": "MDQ6VXNlcjE2MDY4ODY4", "avatar_url": "https://avatars.githubusercontent.com/u/16068868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcrakhman", "html_url": "https://github.com/mcrakhman", "followers_url": "https://api.github.com/users/mcrakhman/followers", "following_url": "https://api.github.com/users/mcrakhman/following{/other_user}", "gists_url": "https://api.github.com/users/mcrakhman/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcrakhman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcrakhman/subscriptions", "organizations_url": "https://api.github.com/users/mcrakhman/orgs", "repos_url": "https://api.github.com/users/mcrakhman/repos", "events_url": "https://api.github.com/users/mcrakhman/events{/privacy}", "received_events_url": "https://api.github.com/users/mcrakhman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcrakhman", "id": 16068868, "node_id": "MDQ6VXNlcjE2MDY4ODY4", "avatar_url": "https://avatars.githubusercontent.com/u/16068868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcrakhman", "html_url": "https://github.com/mcrakhman", "followers_url": "https://api.github.com/users/mcrakhman/followers", "following_url": "https://api.github.com/users/mcrakhman/following{/other_user}", "gists_url": "https://api.github.com/users/mcrakhman/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcrakhman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcrakhman/subscriptions", "organizations_url": "https://api.github.com/users/mcrakhman/orgs", "repos_url": "https://api.github.com/users/mcrakhman/repos", "events_url": "https://api.github.com/users/mcrakhman/events{/privacy}", "received_events_url": "https://api.github.com/users/mcrakhman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eeb8b9e236796da8734ba81a49164864497f7226", "url": "https://api.github.com/repos/rust-lang/rust/commits/eeb8b9e236796da8734ba81a49164864497f7226", "html_url": "https://github.com/rust-lang/rust/commit/eeb8b9e236796da8734ba81a49164864497f7226"}, {"sha": "b56ad148db0c69eb279c225f45d324b4e80e7367", "url": "https://api.github.com/repos/rust-lang/rust/commits/b56ad148db0c69eb279c225f45d324b4e80e7367", "html_url": "https://github.com/rust-lang/rust/commit/b56ad148db0c69eb279c225f45d324b4e80e7367"}], "stats": {"total": 11269, "additions": 7387, "deletions": 3882}, "files": [{"sha": "aef0fac3397fdf8b3549df237953e0b69522d0ab", "filename": ".gitignore", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -8,3 +8,5 @@ crates/*/target\n *.iml\n .vscode/settings.json\n *.html\n+generated_assists.adoc\n+generated_features.adoc"}, {"sha": "308e36836fa8bc106fc083cade8bfd10051ddd73", "filename": "Cargo.lock", "status": "modified", "additions": 47, "deletions": 36, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -113,8 +113,9 @@ checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.10.1-dev\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=329b7f3fdd2431ed6f6778cde53f22374c7d094c#329b7f3fdd2431ed6f6778cde53f22374c7d094c\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5b9bd01eab87277d973183a1d2e56bace1c11f8242c52c20636fb7dddf343ac9\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -124,8 +125,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-engine\"\n-version = \"0.10.1-dev\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=329b7f3fdd2431ed6f6778cde53f22374c7d094c#329b7f3fdd2431ed6f6778cde53f22374c7d094c\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6c7a637c3d17ed555aef16e16952a5d1e127bd55178cc30be22afeb92da90c7d\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -134,17 +136,19 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.10.1-dev\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=329b7f3fdd2431ed6f6778cde53f22374c7d094c#329b7f3fdd2431ed6f6778cde53f22374c7d094c\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"595e5735ded16c3f3dc348f7b15bbb2521a0080b1863cac38ad5271589944670\"\n dependencies = [\n  \"chalk-derive\",\n  \"lazy_static\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.10.1-dev\"\n-source = \"git+https://github.com/rust-lang/chalk.git?rev=329b7f3fdd2431ed6f6778cde53f22374c7d094c#329b7f3fdd2431ed6f6778cde53f22374c7d094c\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5d9d938139db425867a30cc0cfec0269406d8238d0571d829041eaa7a8455d11\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-engine\",\n@@ -243,12 +247,13 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-queue\"\n-version = \"0.2.2\"\n+version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab6bffe714b6bb07e42f201352c34f51fefd355ace793f9e638ebd52d23f98d2\"\n+checksum = \"774ba60a54c213d409d5353bda12d49cd68d14e45036a285234c8d6f91f92570\"\n dependencies = [\n  \"cfg-if\",\n  \"crossbeam-utils\",\n+ \"maybe-uninit\",\n ]\n \n [[package]]\n@@ -462,18 +467,18 @@ dependencies = [\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.3.2\"\n+version = \"1.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"076f042c5b7b98f31d205f1249267e12a6518c1481e9dae9764af19b707d2292\"\n+checksum = \"c398b2b113b55809ceb9ee3e753fcbac793f1956663f3c36549c1346015c2afe\"\n dependencies = [\n  \"autocfg\",\n ]\n \n [[package]]\n name = \"inotify\"\n-version = \"0.7.0\"\n+version = \"0.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"24e40d6fd5d64e2082e0c796495c8ef5ad667a96d03e5aaa0becfd9d47bcbfb8\"\n+checksum = \"4816c66d2c8ae673df83366c18341538f234a26d65a9ecea5c348b453ac1d02f\"\n dependencies = [\n  \"bitflags\",\n  \"inotify-sys\",\n@@ -561,9 +566,9 @@ dependencies = [\n \n [[package]]\n name = \"jod-thread\"\n-version = \"0.1.1\"\n+version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4022656272c3e564a7cdebcaaba6518d844b0d0c1836597196efb5bfeb98bb49\"\n+checksum = \"8b23360e99b8717f20aaa4598f5a6541efbe30630039fbc7706cf954a87947ae\"\n \n [[package]]\n name = \"kernel32-sys\"\n@@ -809,19 +814,19 @@ dependencies = [\n \n [[package]]\n name = \"paste\"\n-version = \"0.1.15\"\n+version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d53181dcd37421c08d3b69f887784956674d09c3f9a47a04fece2b130a5b346b\"\n+checksum = \"d508492eeb1e5c38ee696371bf7b9fc33c83d46a7d451606b96458fbbbdc2dec\"\n dependencies = [\n  \"paste-impl\",\n  \"proc-macro-hack\",\n ]\n \n [[package]]\n name = \"paste-impl\"\n-version = \"0.1.15\"\n+version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"05ca490fa1c034a71412b4d1edcb904ec5a0981a4426c9eb2128c0fda7a68d17\"\n+checksum = \"84f328a6a63192b333fce5fbb4be79db6758a4d518dfac6d54412f1492f72d32\"\n dependencies = [\n  \"proc-macro-hack\",\n  \"proc-macro2\",\n@@ -871,18 +876,18 @@ checksum = \"7e0456befd48169b9f13ef0f0ad46d492cf9d2dbb918bcf38e01eed4ce3ec5e4\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.17\"\n+version = \"1.0.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1502d12e458c49a4c9cbff560d0fe0060c252bc29799ed94ca2ed4bb665a0101\"\n+checksum = \"beae6331a816b1f65d04c45b078fd8e6c93e8071771f41b8163255bbd8d7c8fa\"\n dependencies = [\n  \"unicode-xid\",\n ]\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.6\"\n+version = \"1.0.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"54a21852a652ad6f610c9510194f398ff6f8692e334fd1145fed931f7fbe44ea\"\n+checksum = \"aa563d17ecb180e500da1cfd2b028310ac758de548efdd203e18f283af693f37\"\n dependencies = [\n  \"proc-macro2\",\n ]\n@@ -977,7 +982,10 @@ dependencies = [\n  \"anymap\",\n  \"drop_bomb\",\n  \"either\",\n+ \"fst\",\n+ \"indexmap\",\n  \"insta\",\n+ \"itertools\",\n  \"log\",\n  \"once_cell\",\n  \"ra_arena\",\n@@ -1006,6 +1014,7 @@ dependencies = [\n  \"ra_prof\",\n  \"ra_syntax\",\n  \"ra_tt\",\n+ \"rustc-hash\",\n  \"test_utils\",\n ]\n \n@@ -1119,6 +1128,7 @@ dependencies = [\n  \"memmap\",\n  \"ra_mbe\",\n  \"ra_proc_macro\",\n+ \"ra_toolchain\",\n  \"ra_tt\",\n  \"serde_derive\",\n  \"test_utils\",\n@@ -1400,9 +1410,9 @@ checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n \n [[package]]\n name = \"ryu\"\n-version = \"1.0.4\"\n+version = \"1.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ed3d612bc64430efeb3f7ee6ef26d590dce0c43249217bddc62112540c7941e1\"\n+checksum = \"71d301d4193d031abdd79ff7e3dd721168a9572ef3fe51a1517aba235bd8f86e\"\n \n [[package]]\n name = \"salsa\"\n@@ -1511,9 +1521,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.53\"\n+version = \"1.0.55\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"993948e75b189211a9b31a7528f950c6adc21f9720b6438ff80a7fa2f864cea2\"\n+checksum = \"ec2c5d7e739bc07a3e73381a39d61fdb5f671c60c1df26a130690665803d8226\"\n dependencies = [\n  \"itoa\",\n  \"ryu\",\n@@ -1533,9 +1543,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_yaml\"\n-version = \"0.8.12\"\n+version = \"0.8.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"16c7a592a1ec97c9c1c68d75b6e537dcbf60c7618e038e7841e00af1d9ccf0c4\"\n+checksum = \"ae3e2dd40a7cdc18ca80db804b7f461a39bb721160a85c9a1fa30134bf3c02a5\"\n dependencies = [\n  \"dtoa\",\n  \"linked-hash-map\",\n@@ -1576,9 +1586,9 @@ checksum = \"ab16ced94dbd8a46c82fd81e3ed9a8727dac2977ea869d217bcc4ea1f122e81f\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.29\"\n+version = \"1.0.31\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bb37da98a55b1d08529362d9cbb863be17556873df2585904ab9d2bc951291d0\"\n+checksum = \"b5304cfdf27365b7585c25d4af91b35016ed21ef88f17ced89c7093b43dba8b6\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1587,9 +1597,9 @@ dependencies = [\n \n [[package]]\n name = \"synstructure\"\n-version = \"0.12.3\"\n+version = \"0.12.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"67656ea1dc1b41b1451851562ea232ec2e5a80242139f7e679ceccfb5d61f545\"\n+checksum = \"b834f2d66f734cb897113e34aaff2f1ab4719ca946f9a7358dba8f8064148701\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1639,6 +1649,7 @@ dependencies = [\n  \"relative-path\",\n  \"rustc-hash\",\n  \"serde_json\",\n+ \"stdx\",\n  \"text-size\",\n ]\n \n@@ -1797,9 +1808,9 @@ dependencies = [\n \n [[package]]\n name = \"yaml-rust\"\n-version = \"0.4.3\"\n+version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"65923dd1784f44da1d2c3dbbc5e822045628c590ba72123e1c73d3c230c4434d\"\n+checksum = \"39f0c922f1a334134dc2f7a8b67dc5d25f0735263feec974345ff706bcf20b0d\"\n dependencies = [\n  \"linked-hash-map\",\n ]"}, {"sha": "edd8255f44a1e4201769f67aa4b95c654524427a", "filename": "crates/ra_assists/src/assist_context.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_context.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,5 +1,7 @@\n //! See `AssistContext`\n \n+use std::mem;\n+\n use algo::find_covering_element;\n use hir::Semantics;\n use ra_db::{FileId, FileRange};\n@@ -170,13 +172,32 @@ impl Assists {\n \n pub(crate) struct AssistBuilder {\n     edit: TextEditBuilder,\n-    file: FileId,\n+    file_id: FileId,\n     is_snippet: bool,\n+    edits: Vec<SourceFileEdit>,\n }\n \n impl AssistBuilder {\n-    pub(crate) fn new(file: FileId) -> AssistBuilder {\n-        AssistBuilder { edit: TextEditBuilder::default(), file, is_snippet: false }\n+    pub(crate) fn new(file_id: FileId) -> AssistBuilder {\n+        AssistBuilder {\n+            edit: TextEditBuilder::default(),\n+            file_id,\n+            is_snippet: false,\n+            edits: Vec::new(),\n+        }\n+    }\n+\n+    pub(crate) fn edit_file(&mut self, file_id: FileId) {\n+        self.file_id = file_id;\n+    }\n+\n+    fn commit(&mut self) {\n+        let edit = mem::take(&mut self.edit).finish();\n+        if !edit.is_empty() {\n+            let new_edit = SourceFileEdit { file_id: self.file_id, edit };\n+            assert!(!self.edits.iter().any(|it| it.file_id == new_edit.file_id));\n+            self.edits.push(new_edit);\n+        }\n     }\n \n     /// Remove specified `range` of text.\n@@ -234,21 +255,15 @@ impl AssistBuilder {\n         algo::diff(&node, &new).into_text_edit(&mut self.edit)\n     }\n \n-    // FIXME: better API\n-    pub(crate) fn set_file(&mut self, assist_file: FileId) {\n-        self.file = assist_file;\n-    }\n-\n     // FIXME: kill this API\n     /// Get access to the raw `TextEditBuilder`.\n     pub(crate) fn text_edit_builder(&mut self) -> &mut TextEditBuilder {\n         &mut self.edit\n     }\n \n-    fn finish(self) -> SourceChange {\n-        let edit = self.edit.finish();\n-        let source_file_edit = SourceFileEdit { file_id: self.file, edit };\n-        let mut res: SourceChange = source_file_edit.into();\n+    fn finish(mut self) -> SourceChange {\n+        self.commit();\n+        let mut res: SourceChange = mem::take(&mut self.edits).into();\n         if self.is_snippet {\n             res.is_snippet = true;\n         }"}, {"sha": "90b06a62595c8f4d2afe16e45ea83764dbaf1b4c", "filename": "crates/ra_assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -195,7 +195,7 @@ struct Test<K, T = u8> {\n }\n \n fn main() {\n-    let test<|> = Test { t: 23, k: 33 };\n+    let test<|> = Test { t: 23u8, k: 33 };\n }\"#,\n             r#\"\n struct Test<K, T = u8> {\n@@ -204,7 +204,7 @@ struct Test<K, T = u8> {\n }\n \n fn main() {\n-    let test: Test<i32> = Test { t: 23, k: 33 };\n+    let test: Test<i32> = Test { t: 23u8, k: 33 };\n }\"#,\n         );\n     }"}, {"sha": "1cfbd75aa11cb86a1c30a4399f5fde0f89f17b64", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -64,7 +64,7 @@ pub(crate) fn add_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let target = call.syntax().text_range();\n     acc.add(AssistId(\"add_function\"), \"Add function\", target, |builder| {\n         let function_template = function_builder.render();\n-        builder.set_file(function_template.file);\n+        builder.edit_file(function_template.file);\n         let new_fn = function_template.to_string(ctx.config.snippet_cap);\n         match ctx.config.snippet_cap {\n             Some(cap) => builder.insert_snippet(cap, function_template.insert_offset, new_fn),"}, {"sha": "5092bf3366714370e4b6899047c899d842f44ffd", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 102, "deletions": 1, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -130,7 +130,7 @@ impl AutoImportAssets {\n     fn search_for_imports(&self, db: &RootDatabase) -> BTreeSet<ModPath> {\n         let _p = profile(\"auto_import::search_for_imports\");\n         let current_crate = self.module_with_name_to_import.krate();\n-        ImportsLocator::new(db)\n+        ImportsLocator::new(db, current_crate)\n             .find_imports(&self.get_search_query())\n             .into_iter()\n             .filter_map(|candidate| match &self.import_candidate {\n@@ -841,4 +841,105 @@ fn main() {\n             \",\n         )\n     }\n+\n+    #[test]\n+    fn dep_import() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+                    //- /lib.rs crate:dep\n+                    pub struct Struct;\n+\n+                    //- /main.rs crate:main deps:dep\n+                    fn main() {\n+                        Struct<|>\n+                    }\",\n+            r\"use dep::Struct;\n+\n+fn main() {\n+    Struct\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn whole_segment() {\n+        // Tests that only imports whose last segment matches the identifier get suggested.\n+        check_assist(\n+            auto_import,\n+            r\"\n+                    //- /lib.rs crate:dep\n+                    pub mod fmt {\n+                        pub trait Display {}\n+                    }\n+\n+                    pub fn panic_fmt() {}\n+\n+                    //- /main.rs crate:main deps:dep\n+                    struct S;\n+\n+                    impl f<|>mt::Display for S {}\",\n+            r\"use dep::fmt;\n+\n+struct S;\n+impl fmt::Display for S {}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn macro_generated() {\n+        // Tests that macro-generated items are suggested from external crates.\n+        check_assist(\n+            auto_import,\n+            r\"\n+                    //- /lib.rs crate:dep\n+\n+                    macro_rules! mac {\n+                        () => {\n+                            pub struct Cheese;\n+                        };\n+                    }\n+\n+                    mac!();\n+\n+                    //- /main.rs crate:main deps:dep\n+\n+                    fn main() {\n+                        Cheese<|>;\n+                    }\",\n+            r\"use dep::Cheese;\n+\n+fn main() {\n+    Cheese;\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn casing() {\n+        // Tests that differently cased names don't interfere and we only suggest the matching one.\n+        check_assist(\n+            auto_import,\n+            r\"\n+                    //- /lib.rs crate:dep\n+\n+                    pub struct FMT;\n+                    pub struct fmt;\n+\n+                    //- /main.rs crate:main deps:dep\n+\n+                    fn main() {\n+                        FMT<|>;\n+                    }\",\n+            r\"use dep::FMT;\n+\n+fn main() {\n+    FMT;\n+}\n+\",\n+        );\n+    }\n }"}, {"sha": "dfade743215c33e85ffbf7a4f6b238ab9c3d5cd0", "filename": "crates/ra_assists/src/handlers/early_return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -154,7 +154,7 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n             parent_block: &ast::BlockExpr,\n             if_expr: &ast::IfExpr,\n         ) -> SyntaxNode {\n-            let then_block_items = then_block.dedent(IndentLevel::from(1));\n+            let then_block_items = then_block.dedent(IndentLevel(1));\n             let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n             let end_of_then =\n                 if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {"}, {"sha": "44db7917a60e371ae761a73bbd8783aa56ec9b23", "filename": "crates/ra_assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,320 @@\n+use hir::{EnumVariant, Module, ModuleDef, Name};\n+use ra_db::FileId;\n+use ra_fmt::leading_indent;\n+use ra_ide_db::{defs::Definition, search::Reference, RootDatabase};\n+use ra_syntax::{\n+    algo::find_node_at_offset,\n+    ast::{self, ArgListOwner, AstNode, NameOwner, VisibilityOwner},\n+    SourceFile, SyntaxNode, TextRange, TextSize,\n+};\n+use rustc_hash::FxHashSet;\n+\n+use crate::{\n+    assist_context::AssistBuilder, utils::insert_use_statement, AssistContext, AssistId, Assists,\n+};\n+\n+// Assist: extract_struct_from_enum_variant\n+//\n+// Extracts a struct from enum variant.\n+//\n+// ```\n+// enum A { <|>One(u32, u32) }\n+// ```\n+// ->\n+// ```\n+// struct One(pub u32, pub u32);\n+//\n+// enum A { One(One) }\n+// ```\n+pub(crate) fn extract_struct_from_enum_variant(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+) -> Option<()> {\n+    let variant = ctx.find_node_at_offset::<ast::EnumVariant>()?;\n+    let field_list = match variant.kind() {\n+        ast::StructKind::Tuple(field_list) => field_list,\n+        _ => return None,\n+    };\n+    let variant_name = variant.name()?.to_string();\n+    let variant_hir = ctx.sema.to_def(&variant)?;\n+    if existing_struct_def(ctx.db, &variant_name, &variant_hir) {\n+        return None;\n+    }\n+    let enum_ast = variant.parent_enum();\n+    let visibility = enum_ast.visibility();\n+    let enum_hir = ctx.sema.to_def(&enum_ast)?;\n+    let variant_hir_name = variant_hir.name(ctx.db);\n+    let enum_module_def = ModuleDef::from(enum_hir);\n+    let current_module = enum_hir.module(ctx.db);\n+    let target = variant.syntax().text_range();\n+    acc.add(\n+        AssistId(\"extract_struct_from_enum_variant\"),\n+        \"Extract struct from enum variant\",\n+        target,\n+        |builder| {\n+            let definition = Definition::ModuleDef(ModuleDef::EnumVariant(variant_hir));\n+            let res = definition.find_usages(&ctx.db, None);\n+            let start_offset = variant.parent_enum().syntax().text_range().start();\n+            let mut visited_modules_set = FxHashSet::default();\n+            visited_modules_set.insert(current_module);\n+            for reference in res {\n+                let source_file = ctx.sema.parse(reference.file_range.file_id);\n+                update_reference(\n+                    ctx,\n+                    builder,\n+                    reference,\n+                    &source_file,\n+                    &enum_module_def,\n+                    &variant_hir_name,\n+                    &mut visited_modules_set,\n+                );\n+            }\n+            extract_struct_def(\n+                builder,\n+                enum_ast.syntax(),\n+                &variant_name,\n+                &field_list.to_string(),\n+                start_offset,\n+                ctx.frange.file_id,\n+                &visibility,\n+            );\n+            let list_range = field_list.syntax().text_range();\n+            update_variant(builder, &variant_name, ctx.frange.file_id, list_range);\n+        },\n+    )\n+}\n+\n+fn existing_struct_def(db: &RootDatabase, variant_name: &str, variant: &EnumVariant) -> bool {\n+    variant\n+        .parent_enum(db)\n+        .module(db)\n+        .scope(db, None)\n+        .into_iter()\n+        .any(|(name, _)| name.to_string() == variant_name.to_string())\n+}\n+\n+fn insert_import(\n+    ctx: &AssistContext,\n+    builder: &mut AssistBuilder,\n+    path: &ast::PathExpr,\n+    module: &Module,\n+    enum_module_def: &ModuleDef,\n+    variant_hir_name: &Name,\n+) -> Option<()> {\n+    let db = ctx.db;\n+    let mod_path = module.find_use_path(db, enum_module_def.clone());\n+    if let Some(mut mod_path) = mod_path {\n+        mod_path.segments.pop();\n+        mod_path.segments.push(variant_hir_name.clone());\n+        insert_use_statement(path.syntax(), &mod_path, ctx, builder.text_edit_builder());\n+    }\n+    Some(())\n+}\n+\n+fn extract_struct_def(\n+    builder: &mut AssistBuilder,\n+    enum_ast: &SyntaxNode,\n+    variant_name: &str,\n+    variant_list: &str,\n+    start_offset: TextSize,\n+    file_id: FileId,\n+    visibility: &Option<ast::Visibility>,\n+) -> Option<()> {\n+    let visibility_string = if let Some(visibility) = visibility {\n+        format!(\"{} \", visibility.to_string())\n+    } else {\n+        \"\".to_string()\n+    };\n+    let indent = if let Some(indent) = leading_indent(enum_ast) {\n+        indent.to_string()\n+    } else {\n+        \"\".to_string()\n+    };\n+    let struct_def = format!(\n+        r#\"{}struct {}{};\n+\n+{}\"#,\n+        visibility_string,\n+        variant_name,\n+        list_with_visibility(variant_list),\n+        indent\n+    );\n+    builder.edit_file(file_id);\n+    builder.insert(start_offset, struct_def);\n+    Some(())\n+}\n+\n+fn update_variant(\n+    builder: &mut AssistBuilder,\n+    variant_name: &str,\n+    file_id: FileId,\n+    list_range: TextRange,\n+) -> Option<()> {\n+    let inside_variant_range = TextRange::new(\n+        list_range.start().checked_add(TextSize::from(1))?,\n+        list_range.end().checked_sub(TextSize::from(1))?,\n+    );\n+    builder.edit_file(file_id);\n+    builder.replace(inside_variant_range, variant_name);\n+    Some(())\n+}\n+\n+fn update_reference(\n+    ctx: &AssistContext,\n+    builder: &mut AssistBuilder,\n+    reference: Reference,\n+    source_file: &SourceFile,\n+    enum_module_def: &ModuleDef,\n+    variant_hir_name: &Name,\n+    visited_modules_set: &mut FxHashSet<Module>,\n+) -> Option<()> {\n+    let path_expr: ast::PathExpr = find_node_at_offset::<ast::PathExpr>(\n+        source_file.syntax(),\n+        reference.file_range.range.start(),\n+    )?;\n+    let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n+    let list = call.arg_list()?;\n+    let segment = path_expr.path()?.segment()?;\n+    let module = ctx.sema.scope(&path_expr.syntax()).module()?;\n+    let list_range = list.syntax().text_range();\n+    let inside_list_range = TextRange::new(\n+        list_range.start().checked_add(TextSize::from(1))?,\n+        list_range.end().checked_sub(TextSize::from(1))?,\n+    );\n+    builder.edit_file(reference.file_range.file_id);\n+    if !visited_modules_set.contains(&module) {\n+        if insert_import(ctx, builder, &path_expr, &module, enum_module_def, variant_hir_name)\n+            .is_some()\n+        {\n+            visited_modules_set.insert(module);\n+        }\n+    }\n+    builder.replace(inside_list_range, format!(\"{}{}\", segment, list));\n+    Some(())\n+}\n+\n+fn list_with_visibility(list: &str) -> String {\n+    list.split(',')\n+        .map(|part| {\n+            let index = if part.chars().next().unwrap() == '(' { 1usize } else { 0 };\n+            let mut mod_part = part.trim().to_string();\n+            mod_part.insert_str(index, \"pub \");\n+            mod_part\n+        })\n+        .collect::<Vec<String>>()\n+        .join(\", \")\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    use crate::{\n+        tests::{check_assist, check_assist_not_applicable},\n+        utils::FamousDefs,\n+    };\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_extract_struct_several_fields() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            \"enum A { <|>One(u32, u32) }\",\n+            r#\"struct One(pub u32, pub u32);\n+\n+enum A { One(One) }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_struct_one_field() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            \"enum A { <|>One(u32) }\",\n+            r#\"struct One(pub u32);\n+\n+enum A { One(One) }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_struct_pub_visibility() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            \"pub enum A { <|>One(u32, u32) }\",\n+            r#\"pub struct One(pub u32, pub u32);\n+\n+pub enum A { One(One) }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_struct_with_complex_imports() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            r#\"mod my_mod {\n+    fn another_fn() {\n+        let m = my_other_mod::MyEnum::MyField(1, 1);\n+    }\n+\n+    pub mod my_other_mod {\n+        fn another_fn() {\n+            let m = MyEnum::MyField(1, 1);\n+        }\n+\n+        pub enum MyEnum {\n+            <|>MyField(u8, u8),\n+        }\n+    }\n+}\n+\n+fn another_fn() {\n+    let m = my_mod::my_other_mod::MyEnum::MyField(1, 1);\n+}\"#,\n+            r#\"use my_mod::my_other_mod::MyField;\n+\n+mod my_mod {\n+    use my_other_mod::MyField;\n+\n+    fn another_fn() {\n+        let m = my_other_mod::MyEnum::MyField(MyField(1, 1));\n+    }\n+\n+    pub mod my_other_mod {\n+        fn another_fn() {\n+            let m = MyEnum::MyField(MyField(1, 1));\n+        }\n+\n+        pub struct MyField(pub u8, pub u8);\n+\n+        pub enum MyEnum {\n+            MyField(MyField),\n+        }\n+    }\n+}\n+\n+fn another_fn() {\n+    let m = my_mod::my_other_mod::MyEnum::MyField(MyField(1, 1));\n+}\"#,\n+        );\n+    }\n+\n+    fn check_not_applicable(ra_fixture: &str) {\n+        let fixture =\n+            format!(\"//- main.rs crate:main deps:core\\n{}\\n{}\", ra_fixture, FamousDefs::FIXTURE);\n+        check_assist_not_applicable(extract_struct_from_enum_variant, &fixture)\n+    }\n+\n+    #[test]\n+    fn test_extract_enum_not_applicable_for_element_with_no_fields() {\n+        check_not_applicable(\"enum A { <|>One }\");\n+    }\n+\n+    #[test]\n+    fn test_extract_enum_not_applicable_if_struct_exists() {\n+        check_not_applicable(\n+            r#\"struct One;\n+        enum A { <|>One(u8) }\"#,\n+        );\n+    }\n+}"}, {"sha": "531b3560f2e4024ee7605eb5f6329da62c88bfa5", "filename": "crates/ra_assists/src/handlers/fix_visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -63,7 +63,7 @@ fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext) -> O\n     };\n \n     acc.add(AssistId(\"fix_visibility\"), assist_label, target, |builder| {\n-        builder.set_file(target_file);\n+        builder.edit_file(target_file);\n         match ctx.config.snippet_cap {\n             Some(cap) => builder.insert_snippet(cap, offset, format!(\"$0{} \", missing_visibility)),\n             None => builder.insert(offset, format!(\"{} \", missing_visibility)),\n@@ -106,7 +106,7 @@ fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext) ->\n         format!(\"Change visibility of {}.{} to {}\", parent_name, target_name, missing_visibility);\n \n     acc.add(AssistId(\"fix_visibility\"), assist_label, target, |builder| {\n-        builder.set_file(target_file);\n+        builder.edit_file(target_file);\n         match ctx.config.snippet_cap {\n             Some(cap) => builder.insert_snippet(cap, offset, format!(\"$0{} \", missing_visibility)),\n             None => builder.insert(offset, format!(\"{} \", missing_visibility)),"}, {"sha": "28fcbc9ba62e55bd9c2b19a9b04d6fd534999040", "filename": "crates/ra_assists/src/handlers/introduce_named_lifetime.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -41,8 +41,6 @@ pub(crate) fn introduce_named_lifetime(acc: &mut Assists, ctx: &AssistContext) -\n     if let Some(fn_def) = lifetime_token.ancestors().find_map(ast::FnDef::cast) {\n         generate_fn_def_assist(acc, &fn_def, lifetime_token.text_range())\n     } else if let Some(impl_def) = lifetime_token.ancestors().find_map(ast::ImplDef::cast) {\n-        // only allow naming the last anonymous lifetime\n-        lifetime_token.next_token().filter(|tok| tok.kind() == SyntaxKind::R_ANGLE)?;\n         generate_impl_def_assist(acc, &impl_def, lifetime_token.text_range())\n     } else {\n         None\n@@ -190,6 +188,23 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_impl_with_other_type_param() {\n+        check_assist(\n+            introduce_named_lifetime,\n+            \"impl<I> fmt::Display for SepByBuilder<'_<|>, I>\n+        where\n+            I: Iterator,\n+            I::Item: fmt::Display,\n+        {\",\n+            \"impl<I, 'a> fmt::Display for SepByBuilder<'a, I>\n+        where\n+            I: Iterator,\n+            I::Item: fmt::Display,\n+        {\",\n+        )\n+    }\n+\n     #[test]\n     fn test_example_case_cursor_before_tick() {\n         check_assist("}, {"sha": "dfcd787de5854a77b534cd8242bfd7f867437ed4", "filename": "crates/ra_assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -51,6 +51,7 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext)\n     acc.add(AssistId(\"replace_if_let_with_match\"), \"Replace with match\", target, move |edit| {\n         let match_expr = {\n             let then_arm = {\n+                let then_block = then_block.reset_indent().indent(IndentLevel(1));\n                 let then_expr = unwrap_trivial_block(then_block);\n                 make::match_arm(vec![pat.clone()], then_expr)\n             };\n@@ -64,8 +65,8 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext)\n                 let else_expr = unwrap_trivial_block(else_block);\n                 make::match_arm(vec![pattern], else_expr)\n             };\n-            make::expr_match(expr, make::match_arm_list(vec![then_arm, else_arm]))\n-                .indent(IndentLevel::from_node(if_expr.syntax()))\n+            let match_expr = make::expr_match(expr, make::match_arm_list(vec![then_arm, else_arm]));\n+            match_expr.indent(IndentLevel::from_node(if_expr.syntax()))\n         };\n \n         edit.replace_ast::<ast::Expr>(if_expr.into(), match_expr);\n@@ -213,4 +214,36 @@ fn foo(x: Result<i32, ()>) {\n            \"#,\n         );\n     }\n+\n+    #[test]\n+    fn nested_indent() {\n+        check_assist(\n+            replace_if_let_with_match,\n+            r#\"\n+fn main() {\n+    if true {\n+        <|>if let Ok(rel_path) = path.strip_prefix(root_path) {\n+            let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n+            Some((*id, rel_path))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    if true {\n+        match path.strip_prefix(root_path) {\n+            Ok(rel_path) => {\n+                let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n+                Some((*id, rel_path))\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\"#,\n+        )\n+    }\n }"}, {"sha": "1fb13f48141911eee4544679cd257f39755e7ae3", "filename": "crates/ra_assists/src/handlers/unwrap_block.rs", "status": "modified", "additions": 85, "deletions": 79, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,7 +1,10 @@\n use ra_fmt::unwrap_trivial_block;\n use ra_syntax::{\n-    ast::{self, ElseBranch, Expr, LoopBodyOwner},\n-    match_ast, AstNode, TextRange, T,\n+    ast::{\n+        self,\n+        edit::{AstNodeEdit, IndentLevel},\n+    },\n+    AstNode, TextRange, T,\n };\n \n use crate::{AssistContext, AssistId, Assists};\n@@ -24,94 +27,73 @@ use crate::{AssistContext, AssistId, Assists};\n // }\n // ```\n pub(crate) fn unwrap_block(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let l_curly_token = ctx.find_token_at_offset(T!['{'])?;\n-    let block = ast::BlockExpr::cast(l_curly_token.parent())?;\n-    let parent = block.syntax().parent()?;\n     let assist_id = AssistId(\"unwrap_block\");\n     let assist_label = \"Unwrap block\";\n \n-    let (expr, expr_to_unwrap) = match_ast! {\n-        match parent {\n-            ast::ForExpr(for_expr) => {\n-                let block_expr = for_expr.loop_body()?;\n-                let expr_to_unwrap = extract_expr(ctx.frange.range, block_expr)?;\n-                (ast::Expr::ForExpr(for_expr), expr_to_unwrap)\n-            },\n-            ast::WhileExpr(while_expr) => {\n-                let block_expr = while_expr.loop_body()?;\n-                let expr_to_unwrap = extract_expr(ctx.frange.range, block_expr)?;\n-                (ast::Expr::WhileExpr(while_expr), expr_to_unwrap)\n-            },\n-            ast::LoopExpr(loop_expr) => {\n-                let block_expr = loop_expr.loop_body()?;\n-                let expr_to_unwrap = extract_expr(ctx.frange.range, block_expr)?;\n-                (ast::Expr::LoopExpr(loop_expr), expr_to_unwrap)\n-            },\n-            ast::IfExpr(if_expr) => {\n-                let mut resp = None;\n-\n-                let then_branch = if_expr.then_branch()?;\n-                if then_branch.l_curly_token()?.text_range().contains_range(ctx.frange.range) {\n-                    if let Some(ancestor) = if_expr.syntax().parent().and_then(ast::IfExpr::cast) {\n-                        // For `else if` blocks\n-                        let ancestor_then_branch = ancestor.then_branch()?;\n-                        let l_curly_token = then_branch.l_curly_token()?;\n-\n-                        let target = then_branch.syntax().text_range();\n-                        return acc.add(assist_id, assist_label, target, |edit| {\n-                            let range_to_del_else_if = TextRange::new(ancestor_then_branch.syntax().text_range().end(), l_curly_token.text_range().start());\n-                            let range_to_del_rest = TextRange::new(then_branch.syntax().text_range().end(), if_expr.syntax().text_range().end());\n-\n-                            edit.delete(range_to_del_rest);\n-                            edit.delete(range_to_del_else_if);\n-                            edit.replace(target, update_expr_string(then_branch.to_string(), &[' ', '{']));\n-                        });\n-                    } else {\n-                        resp = Some((ast::Expr::IfExpr(if_expr.clone()), Expr::BlockExpr(then_branch)));\n-                    }\n-                } else if let Some(else_branch) = if_expr.else_branch() {\n-                    match else_branch {\n-                        ElseBranch::Block(else_block) => {\n-                            let l_curly_token = else_block.l_curly_token()?;\n-                            if l_curly_token.text_range().contains_range(ctx.frange.range) {\n-                                let target = else_block.syntax().text_range();\n-                                return acc.add(assist_id, assist_label, target, |edit| {\n-                                    let range_to_del = TextRange::new(then_branch.syntax().text_range().end(), l_curly_token.text_range().start());\n-\n-                                    edit.delete(range_to_del);\n-                                    edit.replace(target, update_expr_string(else_block.to_string(), &[' ', '{']));\n-                                });\n-                            }\n-                        },\n-                        ElseBranch::IfExpr(_) => {},\n-                    }\n-                }\n+    let l_curly_token = ctx.find_token_at_offset(T!['{'])?;\n+    let mut block = ast::BlockExpr::cast(l_curly_token.parent())?;\n+    let mut parent = block.syntax().parent()?;\n+    if ast::MatchArm::can_cast(parent.kind()) {\n+        parent = parent.ancestors().find(|it| ast::MatchExpr::can_cast(it.kind()))?\n+    }\n \n-                resp?\n-            },\n-            _ => return None,\n+    let parent = ast::Expr::cast(parent)?;\n+\n+    match parent.clone() {\n+        ast::Expr::ForExpr(_) | ast::Expr::WhileExpr(_) | ast::Expr::LoopExpr(_) => (),\n+        ast::Expr::MatchExpr(_) => block = block.dedent(IndentLevel(1)),\n+        ast::Expr::IfExpr(if_expr) => {\n+            let then_branch = if_expr.then_branch()?;\n+            if then_branch == block {\n+                if let Some(ancestor) = if_expr.syntax().parent().and_then(ast::IfExpr::cast) {\n+                    // For `else if` blocks\n+                    let ancestor_then_branch = ancestor.then_branch()?;\n+\n+                    let target = then_branch.syntax().text_range();\n+                    return acc.add(assist_id, assist_label, target, |edit| {\n+                        let range_to_del_else_if = TextRange::new(\n+                            ancestor_then_branch.syntax().text_range().end(),\n+                            l_curly_token.text_range().start(),\n+                        );\n+                        let range_to_del_rest = TextRange::new(\n+                            then_branch.syntax().text_range().end(),\n+                            if_expr.syntax().text_range().end(),\n+                        );\n+\n+                        edit.delete(range_to_del_rest);\n+                        edit.delete(range_to_del_else_if);\n+                        edit.replace(\n+                            target,\n+                            update_expr_string(then_branch.to_string(), &[' ', '{']),\n+                        );\n+                    });\n+                }\n+            } else {\n+                let target = block.syntax().text_range();\n+                return acc.add(assist_id, assist_label, target, |edit| {\n+                    let range_to_del = TextRange::new(\n+                        then_branch.syntax().text_range().end(),\n+                        l_curly_token.text_range().start(),\n+                    );\n+\n+                    edit.delete(range_to_del);\n+                    edit.replace(target, update_expr_string(block.to_string(), &[' ', '{']));\n+                });\n+            }\n         }\n+        _ => return None,\n     };\n \n-    let target = expr_to_unwrap.syntax().text_range();\n-    acc.add(assist_id, assist_label, target, |edit| {\n-        edit.replace(\n-            expr.syntax().text_range(),\n-            update_expr_string(expr_to_unwrap.to_string(), &[' ', '{', '\\n']),\n+    let unwrapped = unwrap_trivial_block(block);\n+    let target = unwrapped.syntax().text_range();\n+    acc.add(assist_id, assist_label, target, |builder| {\n+        builder.replace(\n+            parent.syntax().text_range(),\n+            update_expr_string(unwrapped.to_string(), &[' ', '{', '\\n']),\n         );\n     })\n }\n \n-fn extract_expr(cursor_range: TextRange, block: ast::BlockExpr) -> Option<ast::Expr> {\n-    let cursor_in_range = block.l_curly_token()?.text_range().contains_range(cursor_range);\n-\n-    if cursor_in_range {\n-        Some(unwrap_trivial_block(block))\n-    } else {\n-        None\n-    }\n-}\n-\n fn update_expr_string(expr_str: String, trim_start_pat: &[char]) -> String {\n     let expr_string = expr_str.trim_start_matches(trim_start_pat);\n     let mut expr_string_lines: Vec<&str> = expr_string.lines().collect();\n@@ -489,6 +471,30 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn unwrap_match_arm() {\n+        check_assist(\n+            unwrap_block,\n+            r#\"\n+fn main() {\n+    match rel_path {\n+        Ok(rel_path) => {<|>\n+            let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n+            Some((*id, rel_path))\n+        }\n+        Err(_) => None,\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n+    Some((*id, rel_path))\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn simple_if_in_while_bad_cursor_position() {\n         check_assist_not_applicable("}, {"sha": "185428bd5593c75c4dc241e0707c7bdedd36fdc5", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -115,6 +115,7 @@ mod handlers {\n     mod change_return_type_to_result;\n     mod change_visibility;\n     mod early_return;\n+    mod extract_struct_from_enum_variant;\n     mod fill_match_arms;\n     mod fix_visibility;\n     mod flip_binexpr;\n@@ -155,6 +156,7 @@ mod handlers {\n             change_return_type_to_result::change_return_type_to_result,\n             change_visibility::change_visibility,\n             early_return::convert_to_guarded_return,\n+            extract_struct_from_enum_variant::extract_struct_from_enum_variant,\n             fill_match_arms::fill_match_arms,\n             fix_visibility::fix_visibility,\n             flip_binexpr::flip_binexpr,"}, {"sha": "40a223727c1fa580dd3e15acd7df94581cf856e4", "filename": "crates/ra_assists/src/tests/generated.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -337,6 +337,21 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_extract_struct_from_enum_variant() {\n+    check_doc_test(\n+        \"extract_struct_from_enum_variant\",\n+        r#####\"\n+enum A { <|>One(u32, u32) }\n+\"#####,\n+        r#####\"\n+struct One(pub u32, pub u32);\n+\n+enum A { One(One) }\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_fill_match_arms() {\n     check_doc_test("}, {"sha": "bf26048f2adb86dfee8c092f5ca4e8e6e86d7e78", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -15,12 +15,10 @@ use std::{\n \n use ra_cfg::CfgOptions;\n use ra_syntax::SmolStr;\n-use rustc_hash::FxHashMap;\n-use rustc_hash::FxHashSet;\n+use ra_tt::TokenExpander;\n+use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{RelativePath, RelativePathBuf};\n-use fmt::Display;\n-use ra_tt::TokenExpander;\n \n /// `FileId` is an integer which uniquely identifies a file. File paths are\n /// messy and system-dependent, so most of the code should work directly with\n@@ -111,7 +109,7 @@ impl CrateName {\n     }\n }\n \n-impl Display for CrateName {\n+impl fmt::Display for CrateName {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.0)\n     }\n@@ -337,15 +335,11 @@ impl Env {\n }\n \n impl ExternSource {\n-    pub fn extern_path(&self, path: impl AsRef<Path>) -> Option<(ExternSourceId, RelativePathBuf)> {\n-        let path = path.as_ref();\n+    pub fn extern_path(&self, path: &Path) -> Option<(ExternSourceId, RelativePathBuf)> {\n         self.extern_paths.iter().find_map(|(root_path, id)| {\n-            if let Ok(rel_path) = path.strip_prefix(root_path) {\n-                let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n-                Some((*id, rel_path))\n-            } else {\n-                None\n-            }\n+            let rel_path = path.strip_prefix(root_path).ok()?;\n+            let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n+            Some((*id, rel_path))\n         })\n     }\n "}, {"sha": "80ddb6058afb06fd5b6ee8b812ab3bd677163f9d", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -7,12 +7,13 @@ use std::{panic, sync::Arc};\n \n use ra_prof::profile;\n use ra_syntax::{ast, Parse, SourceFile, TextRange, TextSize};\n+use rustc_hash::FxHashSet;\n \n pub use crate::{\n     cancellation::Canceled,\n     input::{\n-        CrateGraph, CrateId, CrateName, Dependency, Edition, Env, ExternSource, ExternSourceId,\n-        FileId, ProcMacroId, SourceRoot, SourceRootId,\n+        CrateData, CrateGraph, CrateId, CrateName, Dependency, Edition, Env, ExternSource,\n+        ExternSourceId, FileId, ProcMacroId, SourceRoot, SourceRootId,\n     },\n };\n pub use relative_path::{RelativePath, RelativePathBuf};\n@@ -89,15 +90,13 @@ pub const DEFAULT_LRU_CAP: usize = 128;\n pub trait FileLoader {\n     /// Text of the file.\n     fn file_text(&self, file_id: FileId) -> Arc<String>;\n-    fn resolve_relative_path(&self, anchor: FileId, relative_path: &RelativePath)\n-        -> Option<FileId>;\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<Vec<CrateId>>;\n-\n-    fn resolve_extern_path(\n-        &self,\n-        extern_id: ExternSourceId,\n-        relative_path: &RelativePath,\n-    ) -> Option<FileId>;\n+    /// Note that we intentionally accept a `&str` and not a `&Path` here. This\n+    /// method exists to handle `#[path = \"/some/path.rs\"] mod foo;` and such,\n+    /// so the input is guaranteed to be utf-8 string. We might introduce\n+    /// `struct StrPath(str)` for clarity some day, but it's a bit messy, so we\n+    /// get by with a `&str` for the time being.\n+    fn resolve_path(&self, anchor: FileId, path: &str) -> Option<FileId>;\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>>;\n }\n \n /// Database which stores all significant input facts: source code and project\n@@ -135,16 +134,21 @@ pub trait SourceDatabaseExt: SourceDatabase {\n     #[salsa::input]\n     fn source_root(&self, id: SourceRootId) -> Arc<SourceRoot>;\n \n-    fn source_root_crates(&self, id: SourceRootId) -> Arc<Vec<CrateId>>;\n+    fn source_root_crates(&self, id: SourceRootId) -> Arc<FxHashSet<CrateId>>;\n }\n \n fn source_root_crates(\n     db: &(impl SourceDatabaseExt + SourceDatabase),\n     id: SourceRootId,\n-) -> Arc<Vec<CrateId>> {\n-    let root = db.source_root(id);\n+) -> Arc<FxHashSet<CrateId>> {\n     let graph = db.crate_graph();\n-    let res = root.walk().filter_map(|it| graph.crate_id_for_crate_root(it)).collect::<Vec<_>>();\n+    let res = graph\n+        .iter()\n+        .filter(|&krate| {\n+            let root_file = graph[krate].root_file_id;\n+            db.file_source_root(root_file) == id\n+        })\n+        .collect::<FxHashSet<_>>();\n     Arc::new(res)\n }\n \n@@ -155,33 +159,30 @@ impl<T: SourceDatabaseExt> FileLoader for FileLoaderDelegate<&'_ T> {\n     fn file_text(&self, file_id: FileId) -> Arc<String> {\n         SourceDatabaseExt::file_text(self.0, file_id)\n     }\n-    fn resolve_relative_path(\n-        &self,\n-        anchor: FileId,\n-        relative_path: &RelativePath,\n-    ) -> Option<FileId> {\n-        let path = {\n-            let mut path = self.0.file_relative_path(anchor);\n-            assert!(path.pop());\n-            path.push(relative_path);\n-            path.normalize()\n-        };\n-        let source_root = self.0.file_source_root(anchor);\n-        let source_root = self.0.source_root(source_root);\n-        source_root.file_by_relative_path(&path)\n+    fn resolve_path(&self, anchor: FileId, path: &str) -> Option<FileId> {\n+        // FIXME: this *somehow* should be platform agnostic...\n+        if std::path::Path::new(path).is_absolute() {\n+            let krate = *self.relevant_crates(anchor).iter().next()?;\n+            let (extern_source_id, relative_file) =\n+                self.0.crate_graph()[krate].extern_source.extern_path(path.as_ref())?;\n+\n+            let source_root = self.0.source_root(SourceRootId(extern_source_id.0));\n+            source_root.file_by_relative_path(&relative_file)\n+        } else {\n+            let rel_path = {\n+                let mut rel_path = self.0.file_relative_path(anchor);\n+                assert!(rel_path.pop());\n+                rel_path.push(path);\n+                rel_path.normalize()\n+            };\n+            let source_root = self.0.file_source_root(anchor);\n+            let source_root = self.0.source_root(source_root);\n+            source_root.file_by_relative_path(&rel_path)\n+        }\n     }\n \n-    fn relevant_crates(&self, file_id: FileId) -> Arc<Vec<CrateId>> {\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n         let source_root = self.0.file_source_root(file_id);\n         self.0.source_root_crates(source_root)\n     }\n-\n-    fn resolve_extern_path(\n-        &self,\n-        extern_id: ExternSourceId,\n-        relative_path: &RelativePath,\n-    ) -> Option<FileId> {\n-        let source_root = self.0.source_root(SourceRootId(extern_id.0));\n-        source_root.file_by_relative_path(&relative_path)\n-    }\n }"}, {"sha": "6c41705298bd11f5f6cd9ea392207dabeb2f6765", "filename": "crates/ra_flycheck/src/lib.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Flib.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -18,8 +18,17 @@ pub use cargo_metadata::diagnostic::{\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum FlycheckConfig {\n-    CargoCommand { command: String, all_targets: bool, all_features: bool, extra_args: Vec<String> },\n-    CustomCommand { command: String, args: Vec<String> },\n+    CargoCommand {\n+        command: String,\n+        all_targets: bool,\n+        all_features: bool,\n+        features: Vec<String>,\n+        extra_args: Vec<String>,\n+    },\n+    CustomCommand {\n+        command: String,\n+        args: Vec<String>,\n+    },\n }\n \n /// Flycheck wraps the shared state and communication machinery used for\n@@ -188,7 +197,13 @@ impl FlycheckThread {\n         self.check_process = None;\n \n         let mut cmd = match &self.config {\n-            FlycheckConfig::CargoCommand { command, all_targets, all_features, extra_args } => {\n+            FlycheckConfig::CargoCommand {\n+                command,\n+                all_targets,\n+                all_features,\n+                extra_args,\n+                features,\n+            } => {\n                 let mut cmd = Command::new(ra_toolchain::cargo());\n                 cmd.arg(command);\n                 cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n@@ -198,6 +213,9 @@ impl FlycheckThread {\n                 }\n                 if *all_features {\n                     cmd.arg(\"--all-features\");\n+                } else if !features.is_empty() {\n+                    cmd.arg(\"--features\");\n+                    cmd.arg(features.join(\" \"));\n                 }\n                 cmd.args(extra_args);\n                 cmd"}, {"sha": "1a9f6cc768b6386e80720907de66eade9d9b9eb1", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -9,6 +9,7 @@ use hir_def::{\n     builtin_type::BuiltinType,\n     docs::Documentation,\n     expr::{BindingAnnotation, Pat, PatId},\n+    import_map,\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n     type_ref::{Mutability, TypeRef},\n@@ -98,6 +99,23 @@ impl Crate {\n         db.crate_graph()[self.id].display_name.as_ref().cloned()\n     }\n \n+    pub fn query_external_importables(\n+        self,\n+        db: &dyn DefDatabase,\n+        query: &str,\n+    ) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> {\n+        import_map::search_dependencies(\n+            db,\n+            self.into(),\n+            import_map::Query::new(query).anchor_end().case_sensitive().limit(40),\n+        )\n+        .into_iter()\n+        .map(|item| match item {\n+            ItemInNs::Types(mod_id) | ItemInNs::Values(mod_id) => Either::Left(mod_id.into()),\n+            ItemInNs::Macros(mac_id) => Either::Right(mac_id.into()),\n+        })\n+    }\n+\n     pub fn all(db: &dyn HirDatabase) -> Vec<Crate> {\n         db.crate_graph().iter().map(|id| Crate { id }).collect()\n     }\n@@ -637,6 +655,10 @@ impl Function {\n         db.function_data(self.id).params.clone()\n     }\n \n+    pub fn is_unsafe(self, db: &dyn HirDatabase) -> bool {\n+        db.function_data(self.id).is_unsafe\n+    }\n+\n     pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n         let _p = profile(\"Function::diagnostics\");\n         let infer = db.infer(self.id.into());\n@@ -1190,6 +1212,10 @@ impl Type {\n         )\n     }\n \n+    pub fn is_raw_ptr(&self) -> bool {\n+        matches!(&self.ty.value, Ty::Apply(ApplicationTy { ctor: TypeCtor::RawPtr(..), .. }))\n+    }\n+\n     pub fn contains_unknown(&self) -> bool {\n         return go(&self.ty.value);\n "}, {"sha": "b6b665de1f29225872b460661a777f54b3b9703e", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -3,11 +3,11 @@\n pub use hir_def::db::{\n     AttrsQuery, BodyQuery, BodyWithSourceMapQuery, ConstDataQuery, CrateDefMapQueryQuery,\n     CrateLangItemsQuery, DefDatabase, DefDatabaseStorage, DocumentationQuery, EnumDataQuery,\n-    ExprScopesQuery, FunctionDataQuery, GenericParamsQuery, ImplDataQuery, InternConstQuery,\n-    InternDatabase, InternDatabaseStorage, InternEnumQuery, InternFunctionQuery, InternImplQuery,\n-    InternStaticQuery, InternStructQuery, InternTraitQuery, InternTypeAliasQuery, InternUnionQuery,\n-    LangItemQuery, ModuleLangItemsQuery, RawItemsQuery, StaticDataQuery, StructDataQuery,\n-    TraitDataQuery, TypeAliasDataQuery, UnionDataQuery,\n+    ExprScopesQuery, FunctionDataQuery, GenericParamsQuery, ImplDataQuery, ImportMapQuery,\n+    InternConstQuery, InternDatabase, InternDatabaseStorage, InternEnumQuery, InternFunctionQuery,\n+    InternImplQuery, InternStaticQuery, InternStructQuery, InternTraitQuery, InternTypeAliasQuery,\n+    InternUnionQuery, LangItemQuery, ModuleLangItemsQuery, RawItemsQuery, StaticDataQuery,\n+    StructDataQuery, TraitDataQuery, TypeAliasDataQuery, UnionDataQuery,\n };\n pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, InternEagerExpansionQuery, InternMacroQuery,\n@@ -18,8 +18,8 @@ pub use hir_ty::db::{\n     GenericDefaultsQuery, GenericPredicatesForParamQuery, GenericPredicatesQuery, HirDatabase,\n     HirDatabaseStorage, ImplDatumQuery, ImplSelfTyQuery, ImplTraitQuery, ImplsForTraitQuery,\n     ImplsInCrateQuery, InferQueryQuery, InternAssocTyValueQuery, InternChalkImplQuery,\n-    InternTypeCtorQuery, InternTypeParamIdQuery, StructDatumQuery, TraitDatumQuery,\n-    TraitSolveQuery, TyQuery, ValueTyQuery,\n+    InternTypeCtorQuery, InternTypeParamIdQuery, ReturnTypeImplTraitsQuery, StructDatumQuery,\n+    TraitDatumQuery, TraitSolveQuery, TyQuery, ValueTyQuery,\n };\n \n #[test]"}, {"sha": "a232a58567ce65aa6099124f9d299ec03866026f", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -122,8 +122,9 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         let macro_call =\n             self.find_file(actual_macro_call.syntax().clone()).with_value(actual_macro_call);\n         let sa = self.analyze2(macro_call.map(|it| it.syntax()), None);\n+        let krate = sa.resolver.krate()?;\n         let macro_call_id = macro_call\n-            .as_call_id(self.db, |path| sa.resolver.resolve_path_as_macro(self.db, &path))?;\n+            .as_call_id(self.db, krate, |path| sa.resolver.resolve_path_as_macro(self.db, &path))?;\n         hir_expand::db::expand_hypothetical(self.db, macro_call_id, hypothetical_args, token_to_map)\n     }\n "}, {"sha": "7c6bbea13c2941a29c226ff7a61b4a16a7cb46a5", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -307,7 +307,8 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         macro_call: InFile<&ast::MacroCall>,\n     ) -> Option<HirFileId> {\n-        let macro_call_id = macro_call.as_call_id(db.upcast(), |path| {\n+        let krate = self.resolver.krate()?;\n+        let macro_call_id = macro_call.as_call_id(db.upcast(), krate, |path| {\n             self.resolver.resolve_path_as_macro(db.upcast(), &path)\n         })?;\n         Some(macro_call_id.as_file())"}, {"sha": "ef1f65ee0655ad26a9c5a7d9289fdcff3a2787a1", "filename": "crates/ra_hir_def/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -14,6 +14,9 @@ rustc-hash = \"1.1.0\"\n either = \"1.5.3\"\n anymap = \"0.12.1\"\n drop_bomb = \"0.1.4\"\n+fst = { version = \"0.4\", default-features = false }\n+itertools = \"0.9.0\"\n+indexmap = \"1.4.0\"\n \n stdx = { path = \"../stdx\" }\n "}, {"sha": "2eeba057299185a1b1ad308052308740de4645e9", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -87,12 +87,18 @@ impl Attrs {\n     }\n \n     pub(crate) fn new(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Attrs {\n+        let docs = ast::CommentIter::from_syntax_node(owner.syntax()).doc_comment_text().map(\n+            |docs_text| Attr {\n+                input: Some(AttrInput::Literal(SmolStr::new(docs_text))),\n+                path: ModPath::from(hir_expand::name!(doc)),\n+            },\n+        );\n         let mut attrs = owner.attrs().peekable();\n         let entries = if attrs.peek().is_none() {\n             // Avoid heap allocation\n             None\n         } else {\n-            Some(attrs.flat_map(|ast| Attr::from_src(ast, hygiene)).collect())\n+            Some(attrs.flat_map(|ast| Attr::from_src(ast, hygiene)).chain(docs).collect())\n         };\n         Attrs { entries }\n     }"}, {"sha": "4f2350915dcb76ec3ce6009b6e3a792f8aacacfa", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -97,7 +97,7 @@ impl Expander {\n \n         let macro_call = InFile::new(self.current_file_id, &macro_call);\n \n-        if let Some(call_id) = macro_call.as_call_id(db, |path| {\n+        if let Some(call_id) = macro_call.as_call_id(db, self.crate_def_map.krate, |path| {\n             if let Some(local_scope) = local_scope {\n                 if let Some(def) = path.as_ident().and_then(|n| local_scope.get_legacy_macro(n)) {\n                     return Some(def);"}, {"sha": "53599e74a26643d9c4352ec8709216468685d4d3", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -34,6 +34,7 @@ pub struct FunctionData {\n     /// True if the first param is `self`. This is relevant to decide whether this\n     /// can be called as a method.\n     pub has_self_param: bool,\n+    pub is_unsafe: bool,\n     pub visibility: RawVisibility,\n }\n \n@@ -85,17 +86,20 @@ impl FunctionData {\n             ret_type\n         };\n \n+        let is_unsafe = src.value.unsafe_token().is_some();\n+\n         let vis_default = RawVisibility::default_for_container(loc.container);\n         let visibility =\n             RawVisibility::from_ast_with_default(db, vis_default, src.map(|s| s.visibility()));\n \n-        let sig = FunctionData { name, params, ret_type, has_self_param, visibility, attrs };\n+        let sig =\n+            FunctionData { name, params, ret_type, has_self_param, is_unsafe, visibility, attrs };\n         Arc::new(sig)\n     }\n }\n \n fn desugar_future_path(orig: TypeRef) -> Path {\n-    let path = path![std::future::Future];\n+    let path = path![core::future::Future];\n     let mut generic_args: Vec<_> = std::iter::repeat(None).take(path.segments.len() - 1).collect();\n     let mut last = GenericArgs::empty();\n     last.bindings.push(AssociatedTypeBinding {"}, {"sha": "10cc26480f365271c801cfd3e29559fbc8b0a835", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,7 +1,7 @@\n //! Defines database & queries for name resolution.\n use std::sync::Arc;\n \n-use hir_expand::{db::AstDatabase, name::Name, HirFileId};\n+use hir_expand::{db::AstDatabase, HirFileId};\n use ra_db::{salsa, CrateId, SourceDatabase, Upcast};\n use ra_prof::profile;\n use ra_syntax::SmolStr;\n@@ -12,13 +12,10 @@ use crate::{\n     body::{scope::ExprScopes, Body, BodySourceMap},\n     data::{ConstData, FunctionData, ImplData, StaticData, TraitData, TypeAliasData},\n     docs::Documentation,\n-    find_path,\n     generics::GenericParams,\n-    item_scope::ItemInNs,\n+    import_map::ImportMap,\n     lang_item::{LangItemTarget, LangItems},\n     nameres::{raw::RawItems, CrateDefMap},\n-    path::ModPath,\n-    visibility::Visibility,\n     AttrDefId, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, FunctionId, FunctionLoc,\n     GenericDefId, ImplId, ImplLoc, ModuleId, StaticId, StaticLoc, StructId, StructLoc, TraitId,\n     TraitLoc, TypeAliasId, TypeAliasLoc, UnionId, UnionLoc,\n@@ -113,15 +110,8 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(Documentation::documentation_query)]\n     fn documentation(&self, def: AttrDefId) -> Option<Documentation>;\n \n-    #[salsa::invoke(find_path::importable_locations_of_query)]\n-    fn importable_locations_of(\n-        &self,\n-        item: ItemInNs,\n-        krate: CrateId,\n-    ) -> Arc<[(ModuleId, Name, Visibility)]>;\n-\n-    #[salsa::invoke(find_path::find_path_inner_query)]\n-    fn find_path_inner(&self, item: ItemInNs, from: ModuleId, max_len: usize) -> Option<ModPath>;\n+    #[salsa::invoke(ImportMap::import_map_query)]\n+    fn import_map(&self, krate: CrateId) -> Arc<ImportMap>;\n }\n \n fn crate_def_map_wait(db: &impl DefDatabase, krate: CrateId) -> Arc<CrateDefMap> {"}, {"sha": "2630b3d895e60db1c6a07ffaee6cb233b37d490e", "filename": "crates/ra_hir_def/src/docs.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdocs.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -29,6 +29,13 @@ impl Documentation {\n         Documentation(s.into())\n     }\n \n+    pub fn from_ast<N>(node: &N) -> Option<Documentation>\n+    where\n+        N: ast::DocCommentsOwner + ast::AttrsOwner,\n+    {\n+        docs_from_ast(node)\n+    }\n+\n     pub fn as_str(&self) -> &str {\n         &*self.0\n     }\n@@ -70,6 +77,45 @@ impl Documentation {\n     }\n }\n \n-pub(crate) fn docs_from_ast(node: &impl ast::DocCommentsOwner) -> Option<Documentation> {\n-    node.doc_comment_text().map(|it| Documentation::new(&it))\n+pub(crate) fn docs_from_ast<N>(node: &N) -> Option<Documentation>\n+where\n+    N: ast::DocCommentsOwner + ast::AttrsOwner,\n+{\n+    let doc_comment_text = node.doc_comment_text();\n+    let doc_attr_text = expand_doc_attrs(node);\n+    let docs = merge_doc_comments_and_attrs(doc_comment_text, doc_attr_text);\n+    docs.map(|it| Documentation::new(&it))\n+}\n+\n+fn merge_doc_comments_and_attrs(\n+    doc_comment_text: Option<String>,\n+    doc_attr_text: Option<String>,\n+) -> Option<String> {\n+    match (doc_comment_text, doc_attr_text) {\n+        (Some(mut comment_text), Some(attr_text)) => {\n+            comment_text.push_str(\"\\n\\n\");\n+            comment_text.push_str(&attr_text);\n+            Some(comment_text)\n+        }\n+        (Some(comment_text), None) => Some(comment_text),\n+        (None, Some(attr_text)) => Some(attr_text),\n+        (None, None) => None,\n+    }\n+}\n+\n+fn expand_doc_attrs(owner: &dyn ast::AttrsOwner) -> Option<String> {\n+    let mut docs = String::new();\n+    for attr in owner.attrs() {\n+        if let Some((\"doc\", value)) =\n+            attr.as_simple_key_value().as_ref().map(|(k, v)| (k.as_str(), v.as_str()))\n+        {\n+            docs.push_str(value);\n+            docs.push_str(\"\\n\\n\");\n+        }\n+    }\n+    if docs.is_empty() {\n+        None\n+    } else {\n+        Some(docs.trim_end_matches(\"\\n\\n\").to_owned())\n+    }\n }"}, {"sha": "06701a8309e78454b006129fa862558031fc8482", "filename": "crates/ra_hir_def/src/find_path.rs", "status": "modified", "additions": 163, "deletions": 84, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,17 +1,16 @@\n //! An algorithm to find a path to refer to a certain item.\n \n-use std::sync::Arc;\n-\n use hir_expand::name::{known, AsName, Name};\n use ra_prof::profile;\n+use rustc_hash::FxHashSet;\n use test_utils::mark;\n \n use crate::{\n     db::DefDatabase,\n     item_scope::ItemInNs,\n     path::{ModPath, PathKind},\n     visibility::Visibility,\n-    CrateId, ModuleDefId, ModuleId,\n+    ModuleDefId, ModuleId,\n };\n \n // FIXME: handle local items\n@@ -20,7 +19,7 @@ use crate::{\n /// *from where* you're referring to the item, hence the `from` parameter.\n pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n     let _p = profile(\"find_path\");\n-    db.find_path_inner(item, from, MAX_PATH_LEN)\n+    find_path_inner(db, item, from, MAX_PATH_LEN)\n }\n \n const MAX_PATH_LEN: usize = 15;\n@@ -36,20 +35,9 @@ impl ModPath {\n         let first_segment = self.segments.first();\n         first_segment == Some(&known::alloc) || first_segment == Some(&known::core)\n     }\n-\n-    fn len(&self) -> usize {\n-        self.segments.len()\n-            + match self.kind {\n-                PathKind::Plain => 0,\n-                PathKind::Super(i) => i as usize,\n-                PathKind::Crate => 1,\n-                PathKind::Abs => 0,\n-                PathKind::DollarCrate(_) => 1,\n-            }\n-    }\n }\n \n-pub(crate) fn find_path_inner_query(\n+fn find_path_inner(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n@@ -133,31 +121,67 @@ pub(crate) fn find_path_inner_query(\n     }\n \n     // - otherwise, look for modules containing (reexporting) it and import it from one of those\n+\n     let crate_root = ModuleId { local_id: def_map.root, krate: from.krate };\n     let crate_attrs = db.attrs(crate_root.into());\n     let prefer_no_std = crate_attrs.by_key(\"no_std\").exists();\n-    let importable_locations = find_importable_locations(db, item, from);\n     let mut best_path = None;\n     let mut best_path_len = max_len;\n-    for (module_id, name) in importable_locations {\n-        let mut path = match db.find_path_inner(\n-            ItemInNs::Types(ModuleDefId::ModuleId(module_id)),\n-            from,\n-            best_path_len - 1,\n-        ) {\n-            None => continue,\n-            Some(path) => path,\n-        };\n-        path.segments.push(name);\n \n-        let new_path = if let Some(best_path) = best_path {\n-            select_best_path(best_path, path, prefer_no_std)\n-        } else {\n-            path\n-        };\n-        best_path_len = new_path.len();\n-        best_path = Some(new_path);\n+    if item.krate(db) == Some(from.krate) {\n+        // Item was defined in the same crate that wants to import it. It cannot be found in any\n+        // dependency in this case.\n+\n+        let local_imports = find_local_import_locations(db, item, from);\n+        for (module_id, name) in local_imports {\n+            if let Some(mut path) = find_path_inner(\n+                db,\n+                ItemInNs::Types(ModuleDefId::ModuleId(module_id)),\n+                from,\n+                best_path_len - 1,\n+            ) {\n+                path.segments.push(name);\n+\n+                let new_path = if let Some(best_path) = best_path {\n+                    select_best_path(best_path, path, prefer_no_std)\n+                } else {\n+                    path\n+                };\n+                best_path_len = new_path.len();\n+                best_path = Some(new_path);\n+            }\n+        }\n+    } else {\n+        // Item was defined in some upstream crate. This means that it must be exported from one,\n+        // too (unless we can't name it at all). It could *also* be (re)exported by the same crate\n+        // that wants to import it here, but we always prefer to use the external path here.\n+\n+        let crate_graph = db.crate_graph();\n+        let extern_paths = crate_graph[from.krate].dependencies.iter().filter_map(|dep| {\n+            let import_map = db.import_map(dep.crate_id);\n+            import_map.import_info_for(item).and_then(|info| {\n+                // Determine best path for containing module and append last segment from `info`.\n+                let mut path = find_path_inner(\n+                    db,\n+                    ItemInNs::Types(ModuleDefId::ModuleId(info.container)),\n+                    from,\n+                    best_path_len - 1,\n+                )?;\n+                path.segments.push(info.path.segments.last().unwrap().clone());\n+                Some(path)\n+            })\n+        });\n+\n+        for path in extern_paths {\n+            let new_path = if let Some(best_path) = best_path {\n+                select_best_path(best_path, path, prefer_no_std)\n+            } else {\n+                path\n+            };\n+            best_path = Some(new_path);\n+        }\n     }\n+\n     best_path\n }\n \n@@ -185,69 +209,86 @@ fn select_best_path(old_path: ModPath, new_path: ModPath, prefer_no_std: bool) -\n     }\n }\n \n-fn find_importable_locations(\n+/// Finds locations in `from.krate` from which `item` can be imported by `from`.\n+fn find_local_import_locations(\n     db: &dyn DefDatabase,\n     item: ItemInNs,\n     from: ModuleId,\n ) -> Vec<(ModuleId, Name)> {\n-    let crate_graph = db.crate_graph();\n-    let mut result = Vec::new();\n-    // We only look in the crate from which we are importing, and the direct\n-    // dependencies. We cannot refer to names from transitive dependencies\n-    // directly (only through reexports in direct dependencies).\n-    for krate in Some(from.krate)\n-        .into_iter()\n-        .chain(crate_graph[from.krate].dependencies.iter().map(|dep| dep.crate_id))\n-    {\n-        result.extend(\n-            db.importable_locations_of(item, krate)\n-                .iter()\n-                .filter(|(_, _, vis)| vis.is_visible_from(db, from))\n-                .map(|(m, n, _)| (*m, n.clone())),\n-        );\n-    }\n-    result\n-}\n+    let _p = profile(\"find_local_import_locations\");\n+\n+    // `from` can import anything below `from` with visibility of at least `from`, and anything\n+    // above `from` with any visibility. That means we do not need to descend into private siblings\n+    // of `from` (and similar).\n+\n+    let def_map = db.crate_def_map(from.krate);\n+\n+    // Compute the initial worklist. We start with all direct child modules of `from` as well as all\n+    // of its (recursive) parent modules.\n+    let data = &def_map.modules[from.local_id];\n+    let mut worklist = data\n+        .children\n+        .values()\n+        .map(|child| ModuleId { krate: from.krate, local_id: *child })\n+        .collect::<Vec<_>>();\n+    let mut parent = data.parent;\n+    while let Some(p) = parent {\n+        worklist.push(ModuleId { krate: from.krate, local_id: p });\n+        parent = def_map.modules[p].parent;\n+    }\n+\n+    let mut seen: FxHashSet<_> = FxHashSet::default();\n+\n+    let mut locations = Vec::new();\n+    while let Some(module) = worklist.pop() {\n+        if !seen.insert(module) {\n+            continue; // already processed this module\n+        }\n+\n+        let ext_def_map;\n+        let data = if module.krate == from.krate {\n+            &def_map[module.local_id]\n+        } else {\n+            // The crate might reexport a module defined in another crate.\n+            ext_def_map = db.crate_def_map(module.krate);\n+            &ext_def_map[module.local_id]\n+        };\n \n-/// Collects all locations from which we might import the item in a particular\n-/// crate. These include the original definition of the item, and any\n-/// non-private `use`s.\n-///\n-/// Note that the crate doesn't need to be the one in which the item is defined;\n-/// it might be re-exported in other crates.\n-pub(crate) fn importable_locations_of_query(\n-    db: &dyn DefDatabase,\n-    item: ItemInNs,\n-    krate: CrateId,\n-) -> Arc<[(ModuleId, Name, Visibility)]> {\n-    let _p = profile(\"importable_locations_of_query\");\n-    let def_map = db.crate_def_map(krate);\n-    let mut result = Vec::new();\n-    for (local_id, data) in def_map.modules.iter() {\n         if let Some((name, vis)) = data.scope.name_of(item) {\n-            let is_private = if let Visibility::Module(private_to) = vis {\n-                private_to.local_id == local_id\n-            } else {\n-                false\n-            };\n-            let is_original_def = if let Some(module_def_id) = item.as_module_def_id() {\n-                data.scope.declarations().any(|it| it == module_def_id)\n-            } else {\n-                false\n-            };\n-            if is_private && !is_original_def {\n+            if vis.is_visible_from(db, from) {\n+                let is_private = if let Visibility::Module(private_to) = vis {\n+                    private_to.local_id == module.local_id\n+                } else {\n+                    false\n+                };\n+                let is_original_def = if let Some(module_def_id) = item.as_module_def_id() {\n+                    data.scope.declarations().any(|it| it == module_def_id)\n+                } else {\n+                    false\n+                };\n+\n                 // Ignore private imports. these could be used if we are\n                 // in a submodule of this module, but that's usually not\n                 // what the user wants; and if this module can import\n                 // the item and we're a submodule of it, so can we.\n                 // Also this keeps the cached data smaller.\n-                continue;\n+                if !is_private || is_original_def {\n+                    locations.push((module, name.clone()));\n+                }\n+            }\n+        }\n+\n+        // Descend into all modules visible from `from`.\n+        for (_, per_ns) in data.scope.entries() {\n+            if let Some((ModuleDefId::ModuleId(module), vis)) = per_ns.take_types_vis() {\n+                if vis.is_visible_from(db, from) {\n+                    worklist.push(module);\n+                }\n             }\n-            result.push((ModuleId { krate, local_id }, name.clone(), vis));\n         }\n     }\n \n-    Arc::from(result)\n+    locations\n }\n \n #[cfg(test)]\n@@ -264,8 +305,8 @@ mod tests {\n     /// `code` needs to contain a cursor marker; checks that `find_path` for the\n     /// item the `path` refers to returns that same path when called from the\n     /// module the cursor is in.\n-    fn check_found_path(code: &str, path: &str) {\n-        let (db, pos) = TestDB::with_position(code);\n+    fn check_found_path(ra_fixture: &str, path: &str) {\n+        let (db, pos) = TestDB::with_position(ra_fixture);\n         let module = db.module_for_file(pos.file_id);\n         let parsed_path_file = ra_syntax::SourceFile::parse(&format!(\"use {};\", path));\n         let ast_path = parsed_path_file\n@@ -395,6 +436,44 @@ mod tests {\n         check_found_path(code, \"std_renamed::S\");\n     }\n \n+    #[test]\n+    fn partially_imported() {\n+        // Tests that short paths are used even for external items, when parts of the path are\n+        // already in scope.\n+        check_found_path(\n+            r#\"\n+            //- /main.rs crate:main deps:ra_syntax\n+\n+            use ra_syntax::ast;\n+            <|>\n+\n+            //- /lib.rs crate:ra_syntax\n+            pub mod ast {\n+                pub enum ModuleItem {\n+                    A, B, C,\n+                }\n+            }\n+        \"#,\n+            \"ast::ModuleItem\",\n+        );\n+\n+        check_found_path(\n+            r#\"\n+            //- /main.rs crate:main deps:ra_syntax\n+\n+            <|>\n+\n+            //- /lib.rs crate:ra_syntax\n+            pub mod ast {\n+                pub enum ModuleItem {\n+                    A, B, C,\n+                }\n+            }\n+        \"#,\n+            \"ra_syntax::ast::ModuleItem\",\n+        );\n+    }\n+\n     #[test]\n     fn same_crate_reexport() {\n         let code = r#\""}, {"sha": "68e20d06b8b16b1948cc5ea1387babb986b6ef89", "filename": "crates/ra_hir_def/src/import_map.rs", "status": "added", "additions": 679, "deletions": 0, "changes": 679, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,679 @@\n+//! A map of all publicly exported items in a crate.\n+\n+use std::{cmp::Ordering, fmt, hash::BuildHasherDefault, sync::Arc};\n+\n+use fst::{self, Streamer};\n+use indexmap::{map::Entry, IndexMap};\n+use ra_db::CrateId;\n+use rustc_hash::FxHasher;\n+\n+use crate::{\n+    db::DefDatabase,\n+    item_scope::ItemInNs,\n+    path::{ModPath, PathKind},\n+    visibility::Visibility,\n+    ModuleDefId, ModuleId,\n+};\n+\n+type FxIndexMap<K, V> = IndexMap<K, V, BuildHasherDefault<FxHasher>>;\n+\n+/// Item import details stored in the `ImportMap`.\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct ImportInfo {\n+    /// A path that can be used to import the item, relative to the crate's root.\n+    pub path: ModPath,\n+    /// The module containing this item.\n+    pub container: ModuleId,\n+}\n+\n+/// A map from publicly exported items to the path needed to import/name them from a downstream\n+/// crate.\n+///\n+/// Reexports of items are taken into account, ie. if something is exported under multiple\n+/// names, the one with the shortest import path will be used.\n+///\n+/// Note that all paths are relative to the containing crate's root, so the crate name still needs\n+/// to be prepended to the `ModPath` before the path is valid.\n+pub struct ImportMap {\n+    map: FxIndexMap<ItemInNs, ImportInfo>,\n+\n+    /// List of keys stored in `map`, sorted lexicographically by their `ModPath`. Indexed by the\n+    /// values returned by running `fst`.\n+    ///\n+    /// Since a path can refer to multiple items due to namespacing, we store all items with the\n+    /// same path right after each other. This allows us to find all items after the FST gives us\n+    /// the index of the first one.\n+    importables: Vec<ItemInNs>,\n+    fst: fst::Map<Vec<u8>>,\n+}\n+\n+impl ImportMap {\n+    pub fn import_map_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<Self> {\n+        let _p = ra_prof::profile(\"import_map_query\");\n+        let def_map = db.crate_def_map(krate);\n+        let mut import_map = FxIndexMap::with_capacity_and_hasher(64, Default::default());\n+\n+        // We look only into modules that are public(ly reexported), starting with the crate root.\n+        let empty = ModPath { kind: PathKind::Plain, segments: vec![] };\n+        let root = ModuleId { krate, local_id: def_map.root };\n+        let mut worklist = vec![(root, empty)];\n+        while let Some((module, mod_path)) = worklist.pop() {\n+            let ext_def_map;\n+            let mod_data = if module.krate == krate {\n+                &def_map[module.local_id]\n+            } else {\n+                // The crate might reexport a module defined in another crate.\n+                ext_def_map = db.crate_def_map(module.krate);\n+                &ext_def_map[module.local_id]\n+            };\n+\n+            let visible_items = mod_data.scope.entries().filter_map(|(name, per_ns)| {\n+                let per_ns = per_ns.filter_visibility(|vis| vis == Visibility::Public);\n+                if per_ns.is_none() {\n+                    None\n+                } else {\n+                    Some((name, per_ns))\n+                }\n+            });\n+\n+            for (name, per_ns) in visible_items {\n+                let mk_path = || {\n+                    let mut path = mod_path.clone();\n+                    path.segments.push(name.clone());\n+                    path\n+                };\n+\n+                for item in per_ns.iter_items() {\n+                    let path = mk_path();\n+                    match import_map.entry(item) {\n+                        Entry::Vacant(entry) => {\n+                            entry.insert(ImportInfo { path, container: module });\n+                        }\n+                        Entry::Occupied(mut entry) => {\n+                            // If the new path is shorter, prefer that one.\n+                            if path.len() < entry.get().path.len() {\n+                                *entry.get_mut() = ImportInfo { path, container: module };\n+                            } else {\n+                                continue;\n+                            }\n+                        }\n+                    }\n+\n+                    // If we've just added a path to a module, descend into it. We might traverse\n+                    // modules multiple times, but only if the new path to it is shorter than the\n+                    // first (else we `continue` above).\n+                    if let Some(ModuleDefId::ModuleId(mod_id)) = item.as_module_def_id() {\n+                        worklist.push((mod_id, mk_path()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut importables = import_map.iter().collect::<Vec<_>>();\n+\n+        importables.sort_by(cmp);\n+\n+        // Build the FST, taking care not to insert duplicate values.\n+\n+        let mut builder = fst::MapBuilder::memory();\n+        let mut last_batch_start = 0;\n+\n+        for idx in 0..importables.len() {\n+            if let Some(next_item) = importables.get(idx + 1) {\n+                if cmp(&importables[last_batch_start], next_item) == Ordering::Equal {\n+                    continue;\n+                }\n+            }\n+\n+            let start = last_batch_start;\n+            last_batch_start = idx + 1;\n+\n+            let key = fst_path(&importables[start].1.path);\n+\n+            builder.insert(key, start as u64).unwrap();\n+        }\n+\n+        let fst = fst::Map::new(builder.into_inner().unwrap()).unwrap();\n+        let importables = importables.iter().map(|(item, _)| **item).collect();\n+\n+        Arc::new(Self { map: import_map, fst, importables })\n+    }\n+\n+    /// Returns the `ModPath` needed to import/mention `item`, relative to this crate's root.\n+    pub fn path_of(&self, item: ItemInNs) -> Option<&ModPath> {\n+        Some(&self.map.get(&item)?.path)\n+    }\n+\n+    pub fn import_info_for(&self, item: ItemInNs) -> Option<&ImportInfo> {\n+        self.map.get(&item)\n+    }\n+}\n+\n+impl PartialEq for ImportMap {\n+    fn eq(&self, other: &Self) -> bool {\n+        // `fst` and `importables` are built from `map`, so we don't need to compare them.\n+        self.map == other.map\n+    }\n+}\n+\n+impl Eq for ImportMap {}\n+\n+impl fmt::Debug for ImportMap {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut importable_paths: Vec<_> = self\n+            .map\n+            .iter()\n+            .map(|(item, info)| {\n+                let ns = match item {\n+                    ItemInNs::Types(_) => \"t\",\n+                    ItemInNs::Values(_) => \"v\",\n+                    ItemInNs::Macros(_) => \"m\",\n+                };\n+                format!(\"- {} ({})\", info.path, ns)\n+            })\n+            .collect();\n+\n+        importable_paths.sort();\n+        f.write_str(&importable_paths.join(\"\\n\"))\n+    }\n+}\n+\n+fn fst_path(path: &ModPath) -> String {\n+    let mut s = path.to_string();\n+    s.make_ascii_lowercase();\n+    s\n+}\n+\n+fn cmp((_, lhs): &(&ItemInNs, &ImportInfo), (_, rhs): &(&ItemInNs, &ImportInfo)) -> Ordering {\n+    let lhs_str = fst_path(&lhs.path);\n+    let rhs_str = fst_path(&rhs.path);\n+    lhs_str.cmp(&rhs_str)\n+}\n+\n+#[derive(Debug)]\n+pub struct Query {\n+    query: String,\n+    lowercased: String,\n+    anchor_end: bool,\n+    case_sensitive: bool,\n+    limit: usize,\n+}\n+\n+impl Query {\n+    pub fn new(query: &str) -> Self {\n+        Self {\n+            lowercased: query.to_lowercase(),\n+            query: query.to_string(),\n+            anchor_end: false,\n+            case_sensitive: false,\n+            limit: usize::max_value(),\n+        }\n+    }\n+\n+    /// Only returns items whose paths end with the (case-insensitive) query string as their last\n+    /// segment.\n+    pub fn anchor_end(self) -> Self {\n+        Self { anchor_end: true, ..self }\n+    }\n+\n+    /// Limits the returned number of items to `limit`.\n+    pub fn limit(self, limit: usize) -> Self {\n+        Self { limit, ..self }\n+    }\n+\n+    /// Respect casing of the query string when matching.\n+    pub fn case_sensitive(self) -> Self {\n+        Self { case_sensitive: true, ..self }\n+    }\n+}\n+\n+/// Searches dependencies of `krate` for an importable path matching `query`.\n+///\n+/// This returns a list of items that could be imported from dependencies of `krate`.\n+pub fn search_dependencies<'a>(\n+    db: &'a dyn DefDatabase,\n+    krate: CrateId,\n+    query: Query,\n+) -> Vec<ItemInNs> {\n+    let _p = ra_prof::profile(\"search_dependencies\").detail(|| format!(\"{:?}\", query));\n+\n+    let graph = db.crate_graph();\n+    let import_maps: Vec<_> =\n+        graph[krate].dependencies.iter().map(|dep| db.import_map(dep.crate_id)).collect();\n+\n+    let automaton = fst::automaton::Subsequence::new(&query.lowercased);\n+\n+    let mut op = fst::map::OpBuilder::new();\n+    for map in &import_maps {\n+        op = op.add(map.fst.search(&automaton));\n+    }\n+\n+    let mut stream = op.union();\n+    let mut res = Vec::new();\n+    while let Some((_, indexed_values)) = stream.next() {\n+        for indexed_value in indexed_values {\n+            let import_map = &import_maps[indexed_value.index];\n+            let importables = &import_map.importables[indexed_value.value as usize..];\n+\n+            // Path shared by the importable items in this group.\n+            let path = &import_map.map[&importables[0]].path;\n+\n+            if query.anchor_end {\n+                // Last segment must match query.\n+                let last = path.segments.last().unwrap().to_string();\n+                if last.to_lowercase() != query.lowercased {\n+                    continue;\n+                }\n+            }\n+\n+            // Add the items from this `ModPath` group. Those are all subsequent items in\n+            // `importables` whose paths match `path`.\n+            let iter = importables.iter().copied().take_while(|item| {\n+                let item_path = &import_map.map[item].path;\n+                fst_path(item_path) == fst_path(path)\n+            });\n+\n+            if query.case_sensitive {\n+                // FIXME: This does not do a subsequence match.\n+                res.extend(iter.filter(|item| {\n+                    let item_path = &import_map.map[item].path;\n+                    item_path.to_string().contains(&query.query)\n+                }));\n+            } else {\n+                res.extend(iter);\n+            }\n+\n+            if res.len() >= query.limit {\n+                res.truncate(query.limit);\n+                return res;\n+            }\n+        }\n+    }\n+\n+    res\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::test_db::TestDB;\n+    use insta::assert_snapshot;\n+    use itertools::Itertools;\n+    use ra_db::fixture::WithFixture;\n+    use ra_db::{SourceDatabase, Upcast};\n+\n+    fn import_map(ra_fixture: &str) -> String {\n+        let db = TestDB::with_files(ra_fixture);\n+        let crate_graph = db.crate_graph();\n+\n+        let s = crate_graph\n+            .iter()\n+            .filter_map(|krate| {\n+                let cdata = &crate_graph[krate];\n+                let name = cdata.display_name.as_ref()?;\n+\n+                let map = db.import_map(krate);\n+\n+                Some(format!(\"{}:\\n{:?}\", name, map))\n+            })\n+            .join(\"\\n\");\n+        s\n+    }\n+\n+    fn search_dependencies_of(ra_fixture: &str, krate_name: &str, query: Query) -> String {\n+        let db = TestDB::with_files(ra_fixture);\n+        let crate_graph = db.crate_graph();\n+        let krate = crate_graph\n+            .iter()\n+            .find(|krate| {\n+                crate_graph[*krate].display_name.as_ref().map(|n| n.to_string())\n+                    == Some(krate_name.to_string())\n+            })\n+            .unwrap();\n+\n+        search_dependencies(db.upcast(), krate, query)\n+            .into_iter()\n+            .filter_map(|item| {\n+                let mark = match item {\n+                    ItemInNs::Types(_) => \"t\",\n+                    ItemInNs::Values(_) => \"v\",\n+                    ItemInNs::Macros(_) => \"m\",\n+                };\n+                item.krate(db.upcast()).map(|krate| {\n+                    let map = db.import_map(krate);\n+                    let path = map.path_of(item).unwrap();\n+                    format!(\n+                        \"{}::{} ({})\",\n+                        crate_graph[krate].display_name.as_ref().unwrap(),\n+                        path,\n+                        mark\n+                    )\n+                })\n+            })\n+            .join(\"\\n\")\n+    }\n+\n+    #[test]\n+    fn smoke() {\n+        let map = import_map(\n+            r\"\n+            //- /main.rs crate:main deps:lib\n+\n+            mod private {\n+                pub use lib::Pub;\n+                pub struct InPrivateModule;\n+            }\n+\n+            pub mod publ1 {\n+                use lib::Pub;\n+            }\n+\n+            pub mod real_pub {\n+                pub use lib::Pub;\n+            }\n+            pub mod real_pu2 { // same path length as above\n+                pub use lib::Pub;\n+            }\n+\n+            //- /lib.rs crate:lib\n+            pub struct Pub {}\n+            pub struct Pub2; // t + v\n+            struct Priv;\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        main:\n+        - publ1 (t)\n+        - real_pu2 (t)\n+        - real_pub (t)\n+        - real_pub::Pub (t)\n+        lib:\n+        - Pub (t)\n+        - Pub2 (t)\n+        - Pub2 (v)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn prefers_shortest_path() {\n+        let map = import_map(\n+            r\"\n+            //- /main.rs crate:main\n+\n+            pub mod sub {\n+                pub mod subsub {\n+                    pub struct Def {}\n+                }\n+\n+                pub use super::sub::subsub::Def;\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        main:\n+        - sub (t)\n+        - sub::Def (t)\n+        - sub::subsub (t)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn type_reexport_cross_crate() {\n+        // Reexports need to be visible from a crate, even if the original crate exports the item\n+        // at a shorter path.\n+        let map = import_map(\n+            r\"\n+            //- /main.rs crate:main deps:lib\n+            pub mod m {\n+                pub use lib::S;\n+            }\n+            //- /lib.rs crate:lib\n+            pub struct S;\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        main:\n+        - m (t)\n+        - m::S (t)\n+        - m::S (v)\n+        lib:\n+        - S (t)\n+        - S (v)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn macro_reexport() {\n+        let map = import_map(\n+            r\"\n+            //- /main.rs crate:main deps:lib\n+            pub mod m {\n+                pub use lib::pub_macro;\n+            }\n+            //- /lib.rs crate:lib\n+            #[macro_export]\n+            macro_rules! pub_macro {\n+                () => {};\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        main:\n+        - m (t)\n+        - m::pub_macro (m)\n+        lib:\n+        - pub_macro (m)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn module_reexport() {\n+        // Reexporting modules from a dependency adds all contents to the import map.\n+        let map = import_map(\n+            r\"\n+            //- /main.rs crate:main deps:lib\n+            pub use lib::module as reexported_module;\n+            //- /lib.rs crate:lib\n+            pub mod module {\n+                pub struct S;\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        main:\n+        - reexported_module (t)\n+        - reexported_module::S (t)\n+        - reexported_module::S (v)\n+        lib:\n+        - module (t)\n+        - module::S (t)\n+        - module::S (v)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn cyclic_module_reexport() {\n+        // A cyclic reexport does not hang.\n+        let map = import_map(\n+            r\"\n+            //- /lib.rs crate:lib\n+            pub mod module {\n+                pub struct S;\n+                pub use super::sub::*;\n+            }\n+\n+            pub mod sub {\n+                pub use super::module;\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        lib:\n+        - module (t)\n+        - module::S (t)\n+        - module::S (v)\n+        - sub (t)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn private_macro() {\n+        let map = import_map(\n+            r\"\n+            //- /lib.rs crate:lib\n+            macro_rules! private_macro {\n+                () => {};\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        lib:\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn namespacing() {\n+        let map = import_map(\n+            r\"\n+            //- /lib.rs crate:lib\n+            pub struct Thing;     // t + v\n+            #[macro_export]\n+            macro_rules! Thing {  // m\n+                () => {};\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        lib:\n+        - Thing (m)\n+        - Thing (t)\n+        - Thing (v)\n+        \"###);\n+\n+        let map = import_map(\n+            r\"\n+            //- /lib.rs crate:lib\n+            pub mod Thing {}      // t\n+            #[macro_export]\n+            macro_rules! Thing {  // m\n+                () => {};\n+            }\n+        \",\n+        );\n+\n+        assert_snapshot!(map, @r###\"\n+        lib:\n+        - Thing (m)\n+        - Thing (t)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn search() {\n+        let ra_fixture = r#\"\n+            //- /main.rs crate:main deps:dep\n+            //- /dep.rs crate:dep deps:tdep\n+            use tdep::fmt as fmt_dep;\n+            pub mod fmt {\n+                pub trait Display {\n+                    fn fmt();\n+                }\n+            }\n+            #[macro_export]\n+            macro_rules! Fmt {\n+                () => {};\n+            }\n+            pub struct Fmt;\n+\n+            pub fn format() {}\n+            pub fn no() {}\n+\n+            //- /tdep.rs crate:tdep\n+            pub mod fmt {\n+                pub struct NotImportableFromMain;\n+            }\n+        \"#;\n+\n+        let res = search_dependencies_of(ra_fixture, \"main\", Query::new(\"fmt\"));\n+        assert_snapshot!(res, @r###\"\n+        dep::fmt (t)\n+        dep::Fmt (t)\n+        dep::Fmt (v)\n+        dep::Fmt (m)\n+        dep::fmt::Display (t)\n+        dep::format (v)\n+        \"###);\n+\n+        let res = search_dependencies_of(ra_fixture, \"main\", Query::new(\"fmt\").anchor_end());\n+        assert_snapshot!(res, @r###\"\n+        dep::fmt (t)\n+        dep::Fmt (t)\n+        dep::Fmt (v)\n+        dep::Fmt (m)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn search_casing() {\n+        let ra_fixture = r#\"\n+            //- /main.rs crate:main deps:dep\n+            //- /dep.rs crate:dep\n+\n+            pub struct fmt;\n+            pub struct FMT;\n+        \"#;\n+\n+        let res = search_dependencies_of(ra_fixture, \"main\", Query::new(\"FMT\"));\n+\n+        assert_snapshot!(res, @r###\"\n+        dep::fmt (t)\n+        dep::fmt (v)\n+        dep::FMT (t)\n+        dep::FMT (v)\n+        \"###);\n+\n+        let res = search_dependencies_of(ra_fixture, \"main\", Query::new(\"FMT\").case_sensitive());\n+\n+        assert_snapshot!(res, @r###\"\n+        dep::FMT (t)\n+        dep::FMT (v)\n+        \"###);\n+    }\n+\n+    #[test]\n+    fn search_limit() {\n+        let res = search_dependencies_of(\n+            r#\"\n+        //- /main.rs crate:main deps:dep\n+        //- /dep.rs crate:dep\n+        pub mod fmt {\n+            pub trait Display {\n+                fn fmt();\n+            }\n+        }\n+        #[macro_export]\n+        macro_rules! Fmt {\n+            () => {};\n+        }\n+        pub struct Fmt;\n+\n+        pub fn format() {}\n+        pub fn no() {}\n+    \"#,\n+            \"main\",\n+            Query::new(\"\").limit(2),\n+        );\n+        assert_snapshot!(res, @r###\"\n+        dep::fmt (t)\n+        dep::Fmt (t)\n+        \"###);\n+    }\n+}"}, {"sha": "b03ba939a5a575a0b49965297c10164a5bb8f95b", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -3,11 +3,12 @@\n \n use hir_expand::name::Name;\n use once_cell::sync::Lazy;\n+use ra_db::CrateId;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, ImplId, MacroDefId, ModuleDefId,\n-    TraitId,\n+    db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, HasModule, ImplId,\n+    Lookup, MacroDefId, ModuleDefId, TraitId,\n };\n \n #[derive(Debug, Default, PartialEq, Eq)]\n@@ -203,4 +204,22 @@ impl ItemInNs {\n             ItemInNs::Macros(_) => None,\n         }\n     }\n+\n+    /// Returns the crate defining this item (or `None` if `self` is built-in).\n+    pub fn krate(&self, db: &dyn DefDatabase) -> Option<CrateId> {\n+        Some(match self {\n+            ItemInNs::Types(did) | ItemInNs::Values(did) => match did {\n+                ModuleDefId::ModuleId(id) => id.krate,\n+                ModuleDefId::FunctionId(id) => id.lookup(db).module(db).krate,\n+                ModuleDefId::AdtId(id) => id.module(db).krate,\n+                ModuleDefId::EnumVariantId(id) => id.parent.lookup(db).container.module(db).krate,\n+                ModuleDefId::ConstId(id) => id.lookup(db).container.module(db).krate,\n+                ModuleDefId::StaticId(id) => id.lookup(db).container.module(db).krate,\n+                ModuleDefId::TraitId(id) => id.lookup(db).container.module(db).krate,\n+                ModuleDefId::TypeAliasId(id) => id.lookup(db).module(db).krate,\n+                ModuleDefId::BuiltinType(_) => return None,\n+            },\n+            ItemInNs::Macros(id) => return id.krate,\n+        })\n+    }\n }"}, {"sha": "edc59e5a80f4ca549f590b36ebddb04771d19710", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -43,6 +43,7 @@ pub mod child_by_source;\n \n pub mod visibility;\n pub mod find_path;\n+pub mod import_map;\n \n #[cfg(test)]\n mod test_db;\n@@ -416,6 +417,7 @@ pub trait AsMacroCall {\n     fn as_call_id(\n         &self,\n         db: &dyn db::DefDatabase,\n+        krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Option<MacroCallId>;\n }\n@@ -424,13 +426,14 @@ impl AsMacroCall for InFile<&ast::MacroCall> {\n     fn as_call_id(\n         &self,\n         db: &dyn db::DefDatabase,\n+        krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Option<MacroCallId> {\n         let ast_id = AstId::new(self.file_id, db.ast_id_map(self.file_id).ast_id(self.value));\n         let h = Hygiene::new(db.upcast(), self.file_id);\n         let path = path::ModPath::from_src(self.value.path()?, &h)?;\n \n-        AstIdWithPath::new(ast_id.file_id, ast_id.value, path).as_call_id(db, resolver)\n+        AstIdWithPath::new(ast_id.file_id, ast_id.value, path).as_call_id(db, krate, resolver)\n     }\n }\n \n@@ -451,6 +454,7 @@ impl AsMacroCall for AstIdWithPath<ast::MacroCall> {\n     fn as_call_id(\n         &self,\n         db: &dyn db::DefDatabase,\n+        krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Option<MacroCallId> {\n         let def: MacroDefId = resolver(self.path.clone())?;\n@@ -460,13 +464,13 @@ impl AsMacroCall for AstIdWithPath<ast::MacroCall> {\n             let hygiene = Hygiene::new(db.upcast(), self.ast_id.file_id);\n \n             Some(\n-                expand_eager_macro(db.upcast(), macro_call, def, &|path: ast::Path| {\n+                expand_eager_macro(db.upcast(), krate, macro_call, def, &|path: ast::Path| {\n                     resolver(path::ModPath::from_src(path, &hygiene)?)\n                 })?\n                 .into(),\n             )\n         } else {\n-            Some(def.as_lazy_macro(db.upcast(), MacroCallKind::FnLike(self.ast_id)).into())\n+            Some(def.as_lazy_macro(db.upcast(), krate, MacroCallKind::FnLike(self.ast_id)).into())\n         }\n     }\n }\n@@ -475,12 +479,14 @@ impl AsMacroCall for AstIdWithPath<ast::ModuleItem> {\n     fn as_call_id(\n         &self,\n         db: &dyn db::DefDatabase,\n+        krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Option<MacroCallId> {\n         let def = resolver(self.path.clone())?;\n         Some(\n             def.as_lazy_macro(\n                 db.upcast(),\n+                krate,\n                 MacroCallKind::Attr(self.ast_id, self.path.segments.last()?.to_string()),\n             )\n             .into(),"}, {"sha": "976e5e5850f14e721deae0f802c8c3a898221bc3", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -571,16 +571,18 @@ impl DefCollector<'_> {\n                 return false;\n             }\n \n-            if let Some(call_id) = directive.ast_id.as_call_id(self.db, |path| {\n-                let resolved_res = self.def_map.resolve_path_fp_with_macro(\n-                    self.db,\n-                    ResolveMode::Other,\n-                    directive.module_id,\n-                    &path,\n-                    BuiltinShadowMode::Module,\n-                );\n-                resolved_res.resolved_def.take_macros()\n-            }) {\n+            if let Some(call_id) =\n+                directive.ast_id.as_call_id(self.db, self.def_map.krate, |path| {\n+                    let resolved_res = self.def_map.resolve_path_fp_with_macro(\n+                        self.db,\n+                        ResolveMode::Other,\n+                        directive.module_id,\n+                        &path,\n+                        BuiltinShadowMode::Module,\n+                    );\n+                    resolved_res.resolved_def.take_macros()\n+                })\n+            {\n                 resolved.push((directive.module_id, call_id, directive.depth));\n                 res = ReachedFixedPoint::No;\n                 return false;\n@@ -589,9 +591,10 @@ impl DefCollector<'_> {\n             true\n         });\n         attribute_macros.retain(|directive| {\n-            if let Some(call_id) = directive\n-                .ast_id\n-                .as_call_id(self.db, |path| self.resolve_attribute_macro(&directive, &path))\n+            if let Some(call_id) =\n+                directive.ast_id.as_call_id(self.db, self.def_map.krate, |path| {\n+                    self.resolve_attribute_macro(&directive, &path)\n+                })\n             {\n                 resolved.push((directive.module_id, call_id, 0));\n                 res = ReachedFixedPoint::No;\n@@ -957,11 +960,13 @@ impl ModCollector<'_, '_> {\n         }\n \n         // Case 2: try to resolve in legacy scope and expand macro_rules\n-        if let Some(macro_call_id) = ast_id.as_call_id(self.def_collector.db, |path| {\n-            path.as_ident().and_then(|name| {\n-                self.def_collector.def_map[self.module_id].scope.get_legacy_macro(&name)\n+        if let Some(macro_call_id) =\n+            ast_id.as_call_id(self.def_collector.db, self.def_collector.def_map.krate, |path| {\n+                path.as_ident().and_then(|name| {\n+                    self.def_collector.def_map[self.module_id].scope.get_legacy_macro(&name)\n+                })\n             })\n-        }) {\n+        {\n             self.def_collector.unexpanded_macros.push(MacroDirective {\n                 module_id: self.module_id,\n                 ast_id,"}, {"sha": "cede4a6fc9e363305c67a47aa6ed37eef660cb7e", "filename": "crates/ra_hir_def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -61,7 +61,7 @@ impl ModDir {\n         };\n \n         for candidate in candidate_files.iter() {\n-            if let Some(file_id) = db.resolve_relative_path(file_id, candidate) {\n+            if let Some(file_id) = db.resolve_path(file_id, candidate.as_str()) {\n                 let mut root_non_dir_owner = false;\n                 let mut mod_path = RelativePathBuf::new();\n                 if !(candidate.ends_with(\"mod.rs\") || attr_path.is_some()) {"}, {"sha": "ba16442bd5177d966ba5289b4b5c2c9b49d9ec3f", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -76,6 +76,19 @@ impl ModPath {\n         }\n     }\n \n+    /// Returns the number of segments in the path (counting special segments like `$crate` and\n+    /// `super`).\n+    pub fn len(&self) -> usize {\n+        self.segments.len()\n+            + match self.kind {\n+                PathKind::Plain => 0,\n+                PathKind::Super(i) => i as usize,\n+                PathKind::Crate => 1,\n+                PathKind::Abs => 0,\n+                PathKind::DollarCrate(_) => 1,\n+            }\n+    }\n+\n     pub fn is_ident(&self) -> bool {\n         self.kind == PathKind::Plain && self.segments.len() == 1\n     }\n@@ -273,7 +286,7 @@ impl From<Name> for ModPath {\n impl Display for ModPath {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut first_segment = true;\n-        let mut add_segment = |s| {\n+        let mut add_segment = |s| -> fmt::Result {\n             if !first_segment {\n                 f.write_str(\"::\")?;\n             }\n@@ -310,16 +323,16 @@ pub use hir_expand::name as __name;\n \n #[macro_export]\n macro_rules! __known_path {\n-    (std::iter::IntoIterator) => {};\n-    (std::result::Result) => {};\n-    (std::ops::Range) => {};\n-    (std::ops::RangeFrom) => {};\n-    (std::ops::RangeFull) => {};\n-    (std::ops::RangeTo) => {};\n-    (std::ops::RangeToInclusive) => {};\n-    (std::ops::RangeInclusive) => {};\n-    (std::future::Future) => {};\n-    (std::ops::Try) => {};\n+    (core::iter::IntoIterator) => {};\n+    (core::result::Result) => {};\n+    (core::ops::Range) => {};\n+    (core::ops::RangeFrom) => {};\n+    (core::ops::RangeFull) => {};\n+    (core::ops::RangeTo) => {};\n+    (core::ops::RangeToInclusive) => {};\n+    (core::ops::RangeInclusive) => {};\n+    (core::future::Future) => {};\n+    (core::ops::Try) => {};\n     ($path:path) => {\n         compile_error!(\"Please register your known path in the path module\")\n     };"}, {"sha": "74665c58851c909417bbd2efe9a24b180b1a39dc", "filename": "crates/ra_hir_def/src/per_ns.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -5,7 +5,7 @@\n \n use hir_expand::MacroDefId;\n \n-use crate::{visibility::Visibility, ModuleDefId};\n+use crate::{item_scope::ItemInNs, visibility::Visibility, ModuleDefId};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub struct PerNs {\n@@ -84,4 +84,12 @@ impl PerNs {\n             macros: self.macros.or(other.macros),\n         }\n     }\n+\n+    pub fn iter_items(self) -> impl Iterator<Item = ItemInNs> {\n+        self.types\n+            .map(|it| ItemInNs::Types(it.0))\n+            .into_iter()\n+            .chain(self.values.map(|it| ItemInNs::Values(it.0)).into_iter())\n+            .chain(self.macros.map(|it| ItemInNs::Macros(it.0)).into_iter())\n+    }\n }"}, {"sha": "4581d87453b2ee166dea46038a42ebc0ffd3ddd5", "filename": "crates/ra_hir_def/src/test_db.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftest_db.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -6,9 +6,8 @@ use std::{\n };\n \n use hir_expand::db::AstDatabase;\n-use ra_db::{\n-    salsa, CrateId, ExternSourceId, FileId, FileLoader, FileLoaderDelegate, RelativePath, Upcast,\n-};\n+use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, Upcast};\n+use rustc_hash::FxHashSet;\n \n use crate::db::DefDatabase;\n \n@@ -58,24 +57,12 @@ impl FileLoader for TestDB {\n     fn file_text(&self, file_id: FileId) -> Arc<String> {\n         FileLoaderDelegate(self).file_text(file_id)\n     }\n-    fn resolve_relative_path(\n-        &self,\n-        anchor: FileId,\n-        relative_path: &RelativePath,\n-    ) -> Option<FileId> {\n-        FileLoaderDelegate(self).resolve_relative_path(anchor, relative_path)\n+    fn resolve_path(&self, anchor: FileId, path: &str) -> Option<FileId> {\n+        FileLoaderDelegate(self).resolve_path(anchor, path)\n     }\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<Vec<CrateId>> {\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n         FileLoaderDelegate(self).relevant_crates(file_id)\n     }\n-\n-    fn resolve_extern_path(\n-        &self,\n-        extern_id: ExternSourceId,\n-        relative_path: &RelativePath,\n-    ) -> Option<FileId> {\n-        FileLoaderDelegate(self).resolve_extern_path(extern_id, relative_path)\n-    }\n }\n \n impl TestDB {"}, {"sha": "e5c9f3e997a7ee4a8221389003a6748a7f74ab02", "filename": "crates/ra_hir_expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2FCargo.toml?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -10,6 +10,7 @@ doctest = false\n [dependencies]\n log = \"0.4.8\"\n either = \"1.5.3\"\n+rustc-hash = \"1.0.0\"\n \n ra_arena = { path = \"../ra_arena\" }\n ra_db = { path = \"../ra_db\" }"}, {"sha": "26b667b55715e791c0bc9bd020e3027c42989ea8", "filename": "crates/ra_hir_expand/src/builtin_derive.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -8,8 +8,7 @@ use ra_syntax::{\n     match_ast,\n };\n \n-use crate::db::AstDatabase;\n-use crate::{name, quote, LazyMacroId, MacroCallId, MacroDefId, MacroDefKind};\n+use crate::{db::AstDatabase, name, quote, LazyMacroId, MacroDefId, MacroDefKind};\n \n macro_rules! register_builtin {\n     ( $($trait:ident => $expand:ident),* ) => {\n@@ -156,23 +155,13 @@ fn expand_simple_derive(\n fn find_builtin_crate(db: &dyn AstDatabase, id: LazyMacroId) -> tt::TokenTree {\n     // FIXME: make hygiene works for builtin derive macro\n     // such that $crate can be used here.\n-\n-    let m: MacroCallId = id.into();\n-    let file_id = m.as_file().original_file(db);\n     let cg = db.crate_graph();\n-    let krates = db.relevant_crates(file_id);\n-    let krate = match krates.get(0) {\n-        Some(krate) => krate,\n-        None => {\n-            let tt = quote! { core };\n-            return tt.token_trees[0].clone();\n-        }\n-    };\n+    let krate = db.lookup_intern_macro(id).krate;\n \n     // XXX\n     //  All crates except core itself should have a dependency on core,\n     //  We detect `core` by seeing whether it doesn't have such a dependency.\n-    let tt = if cg[*krate].dependencies.iter().any(|dep| dep.name == \"core\") {\n+    let tt = if cg[krate].dependencies.iter().any(|dep| dep.name == \"core\") {\n         quote! { core }\n     } else {\n         quote! { crate }\n@@ -264,10 +253,12 @@ fn partial_ord_expand(\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-    use crate::{test_db::TestDB, AstId, MacroCallId, MacroCallKind, MacroCallLoc};\n     use name::{known, Name};\n-    use ra_db::{fixture::WithFixture, SourceDatabase};\n+    use ra_db::{fixture::WithFixture, CrateId, SourceDatabase};\n+\n+    use crate::{test_db::TestDB, AstId, MacroCallId, MacroCallKind, MacroCallLoc};\n+\n+    use super::*;\n \n     fn expand_builtin_derive(s: &str, name: Name) -> String {\n         let def = find_builtin_derive(&name).unwrap();\n@@ -291,7 +282,11 @@ mod tests {\n \n         let attr_id = AstId::new(file_id.into(), ast_id_map.ast_id(&items[0]));\n \n-        let loc = MacroCallLoc { def, kind: MacroCallKind::Attr(attr_id, name.to_string()) };\n+        let loc = MacroCallLoc {\n+            def,\n+            krate: CrateId(0),\n+            kind: MacroCallKind::Attr(attr_id, name.to_string()),\n+        };\n \n         let id: MacroCallId = db.intern_macro(loc).into();\n         let parsed = db.parse_or_expand(id.as_file()).unwrap();"}, {"sha": "b50eb347c8e42b3e021f3a21e4684d3d59d89cb6", "filename": "crates/ra_hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,15 +1,14 @@\n //! Builtin macro\n-use crate::db::AstDatabase;\n use crate::{\n-    ast::{self, AstToken, HasStringValue},\n-    name, AstId, CrateId, MacroDefId, MacroDefKind, TextSize,\n+    db::AstDatabase, name, quote, AstId, CrateId, EagerMacroId, LazyMacroId, MacroCallId,\n+    MacroDefId, MacroDefKind, TextSize,\n };\n \n-use crate::{quote, EagerMacroId, LazyMacroId, MacroCallId};\n use either::Either;\n use mbe::parse_to_token_tree;\n-use ra_db::{FileId, RelativePath};\n+use ra_db::FileId;\n use ra_parser::FragmentKind;\n+use ra_syntax::ast::{self, AstToken, HasStringValue};\n \n macro_rules! register_builtin {\n     ( LAZY: $(($name:ident, $kind: ident) => $expand:ident),* , EAGER: $(($e_name:ident, $e_kind: ident) => $e_expand:ident),*  ) => {\n@@ -295,19 +294,13 @@ fn concat_expand(\n \n fn relative_file(db: &dyn AstDatabase, call_id: MacroCallId, path: &str) -> Option<FileId> {\n     let call_site = call_id.as_file().original_file(db);\n-\n-    // Handle trivial case\n-    if let Some(res) = db.resolve_relative_path(call_site, &RelativePath::new(&path)) {\n-        // Prevent include itself\n-        return if res == call_site { None } else { Some(res) };\n+    let res = db.resolve_path(call_site, path)?;\n+    // Prevent include itself\n+    if res == call_site {\n+        None\n+    } else {\n+        Some(res)\n     }\n-\n-    // Extern paths ?\n-    let krate = *db.relevant_crates(call_site).get(0)?;\n-    let (extern_source_id, relative_file) =\n-        db.crate_graph()[krate].extern_source.extern_path(path)?;\n-\n-    db.resolve_extern_path(extern_source_id, &relative_file)\n }\n \n fn parse_string(tt: &tt::Subtree) -> Result<String, mbe::ExpandError> {\n@@ -339,10 +332,7 @@ fn include_expand(\n }\n \n fn get_env_inner(db: &dyn AstDatabase, arg_id: EagerMacroId, key: &str) -> Option<String> {\n-    let call_id: MacroCallId = arg_id.into();\n-    let original_file = call_id.as_file().original_file(db);\n-\n-    let krate = *db.relevant_crates(original_file).get(0)?;\n+    let krate = db.lookup_intern_eager_expansion(arg_id).krate;\n     db.crate_graph()[krate].env.get(key)\n }\n \n@@ -401,6 +391,7 @@ mod tests {\n \n         let expander = find_by_name(&macro_calls[0].name().unwrap().as_name()).unwrap();\n \n+        let krate = CrateId(0);\n         let file_id = match expander {\n             Either::Left(expander) => {\n                 // the first one should be a macro_rules\n@@ -413,6 +404,7 @@ mod tests {\n \n                 let loc = MacroCallLoc {\n                     def,\n+                    krate,\n                     kind: MacroCallKind::FnLike(AstId::new(\n                         file_id.into(),\n                         ast_id_map.ast_id(&macro_calls[1]),\n@@ -425,7 +417,7 @@ mod tests {\n             Either::Right(expander) => {\n                 // the first one should be a macro_rules\n                 let def = MacroDefId {\n-                    krate: Some(CrateId(0)),\n+                    krate: Some(krate),\n                     ast_id: Some(AstId::new(file_id.into(), ast_id_map.ast_id(&macro_calls[0]))),\n                     kind: MacroDefKind::BuiltInEager(expander),\n                     local_inner: false,\n@@ -439,6 +431,7 @@ mod tests {\n                         def,\n                         fragment: FragmentKind::Expr,\n                         subtree: Arc::new(parsed_args.clone()),\n+                        krate,\n                         file_id: file_id.into(),\n                     }\n                 });\n@@ -448,6 +441,7 @@ mod tests {\n                     def,\n                     fragment,\n                     subtree: Arc::new(subtree),\n+                    krate,\n                     file_id: file_id.into(),\n                 };\n "}, {"sha": "302d2b3e099c67afd2c2eb46beda4b0b142ef59c", "filename": "crates/ra_hir_expand/src/eager.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Feager.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -25,12 +25,14 @@ use crate::{\n     EagerCallLoc, EagerMacroId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n \n+use ra_db::CrateId;\n use ra_parser::FragmentKind;\n use ra_syntax::{algo::SyntaxRewriter, SyntaxNode};\n use std::sync::Arc;\n \n pub fn expand_eager_macro(\n     db: &dyn AstDatabase,\n+    krate: CrateId,\n     macro_call: InFile<ast::MacroCall>,\n     def: MacroDefId,\n     resolver: &dyn Fn(ast::Path) -> Option<MacroDefId>,\n@@ -47,6 +49,7 @@ pub fn expand_eager_macro(\n             def,\n             fragment: FragmentKind::Expr,\n             subtree: Arc::new(parsed_args.clone()),\n+            krate,\n             file_id: macro_call.file_id,\n         }\n     });\n@@ -56,14 +59,20 @@ pub fn expand_eager_macro(\n     let result = eager_macro_recur(\n         db,\n         InFile::new(arg_file_id.as_file(), parsed_args.syntax_node()),\n+        krate,\n         resolver,\n     )?;\n     let subtree = to_subtree(&result)?;\n \n     if let MacroDefKind::BuiltInEager(eager) = def.kind {\n         let (subtree, fragment) = eager.expand(db, arg_id, &subtree).ok()?;\n-        let eager =\n-            EagerCallLoc { def, fragment, subtree: Arc::new(subtree), file_id: macro_call.file_id };\n+        let eager = EagerCallLoc {\n+            def,\n+            fragment,\n+            subtree: Arc::new(subtree),\n+            krate,\n+            file_id: macro_call.file_id,\n+        };\n \n         Some(db.intern_eager_expansion(eager))\n     } else {\n@@ -81,18 +90,20 @@ fn lazy_expand(\n     db: &dyn AstDatabase,\n     def: &MacroDefId,\n     macro_call: InFile<ast::MacroCall>,\n+    krate: CrateId,\n ) -> Option<InFile<SyntaxNode>> {\n     let ast_id = db.ast_id_map(macro_call.file_id).ast_id(&macro_call.value);\n \n     let id: MacroCallId =\n-        def.as_lazy_macro(db, MacroCallKind::FnLike(macro_call.with_value(ast_id))).into();\n+        def.as_lazy_macro(db, krate, MacroCallKind::FnLike(macro_call.with_value(ast_id))).into();\n \n     db.parse_or_expand(id.as_file()).map(|node| InFile::new(id.as_file(), node))\n }\n \n fn eager_macro_recur(\n     db: &dyn AstDatabase,\n     curr: InFile<SyntaxNode>,\n+    krate: CrateId,\n     macro_resolver: &dyn Fn(ast::Path) -> Option<MacroDefId>,\n ) -> Option<SyntaxNode> {\n     let original = curr.value.clone();\n@@ -105,18 +116,23 @@ fn eager_macro_recur(\n         let def: MacroDefId = macro_resolver(child.path()?)?;\n         let insert = match def.kind {\n             MacroDefKind::BuiltInEager(_) => {\n-                let id: MacroCallId =\n-                    expand_eager_macro(db, curr.with_value(child.clone()), def, macro_resolver)?\n-                        .into();\n+                let id: MacroCallId = expand_eager_macro(\n+                    db,\n+                    krate,\n+                    curr.with_value(child.clone()),\n+                    def,\n+                    macro_resolver,\n+                )?\n+                .into();\n                 db.parse_or_expand(id.as_file())?\n             }\n             MacroDefKind::Declarative\n             | MacroDefKind::BuiltIn(_)\n             | MacroDefKind::BuiltInDerive(_)\n             | MacroDefKind::CustomDerive(_) => {\n-                let expanded = lazy_expand(db, &def, curr.with_value(child.clone()))?;\n+                let expanded = lazy_expand(db, &def, curr.with_value(child.clone()), krate)?;\n                 // replace macro inside\n-                eager_macro_recur(db, expanded, macro_resolver)?\n+                eager_macro_recur(db, expanded, krate, macro_resolver)?\n             }\n         };\n "}, {"sha": "5eac2605b9c10e36eccc8e7e3e9e9e74e24c1e89", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -209,8 +209,13 @@ pub struct MacroDefId {\n }\n \n impl MacroDefId {\n-    pub fn as_lazy_macro(self, db: &dyn db::AstDatabase, kind: MacroCallKind) -> LazyMacroId {\n-        db.intern_macro(MacroCallLoc { def: self, kind })\n+    pub fn as_lazy_macro(\n+        self,\n+        db: &dyn db::AstDatabase,\n+        krate: CrateId,\n+        kind: MacroCallKind,\n+    ) -> LazyMacroId {\n+        db.intern_macro(MacroCallLoc { def: self, krate, kind })\n     }\n }\n \n@@ -227,6 +232,7 @@ pub enum MacroDefKind {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCallLoc {\n     pub(crate) def: MacroDefId,\n+    pub(crate) krate: CrateId,\n     pub(crate) kind: MacroCallKind,\n }\n \n@@ -274,6 +280,7 @@ pub struct EagerCallLoc {\n     pub(crate) def: MacroDefId,\n     pub(crate) fragment: FragmentKind,\n     pub(crate) subtree: Arc<tt::Subtree>,\n+    pub(crate) krate: CrateId,\n     pub(crate) file_id: HirFileId,\n }\n "}, {"sha": "660bdfe3365b2f20182ede8f1c4abd356e049669", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -153,6 +153,7 @@ pub mod known {\n         str,\n         // Special names\n         macro_rules,\n+        doc,\n         // Components of known path (value or mod name)\n         std,\n         core,"}, {"sha": "09fc18c360f5b7edb4d3dbf3e6abb2bdfd4aa4c4", "filename": "crates/ra_hir_expand/src/test_db.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_expand%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_expand%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Ftest_db.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -5,7 +5,8 @@ use std::{\n     sync::{Arc, Mutex},\n };\n \n-use ra_db::{salsa, CrateId, ExternSourceId, FileId, FileLoader, FileLoaderDelegate, RelativePath};\n+use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate};\n+use rustc_hash::FxHashSet;\n \n #[salsa::database(\n     ra_db::SourceDatabaseExtStorage,\n@@ -41,21 +42,10 @@ impl FileLoader for TestDB {\n     fn file_text(&self, file_id: FileId) -> Arc<String> {\n         FileLoaderDelegate(self).file_text(file_id)\n     }\n-    fn resolve_relative_path(\n-        &self,\n-        anchor: FileId,\n-        relative_path: &RelativePath,\n-    ) -> Option<FileId> {\n-        FileLoaderDelegate(self).resolve_relative_path(anchor, relative_path)\n+    fn resolve_path(&self, anchor: FileId, path: &str) -> Option<FileId> {\n+        FileLoaderDelegate(self).resolve_path(anchor, path)\n     }\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<Vec<CrateId>> {\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n         FileLoaderDelegate(self).relevant_crates(file_id)\n     }\n-    fn resolve_extern_path(\n-        &self,\n-        anchor: ExternSourceId,\n-        relative_path: &RelativePath,\n-    ) -> Option<FileId> {\n-        FileLoaderDelegate(self).resolve_extern_path(anchor, relative_path)\n-    }\n }"}, {"sha": "112fcd07e7c6def39ef7c03cdf3896150587fe22", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -27,8 +27,8 @@ test_utils = { path = \"../test_utils\" }\n \n scoped-tls = \"1\"\n \n-chalk-solve =   { git = \"https://github.com/rust-lang/chalk.git\", rev = \"329b7f3fdd2431ed6f6778cde53f22374c7d094c\" }\n-chalk-ir =      { git = \"https://github.com/rust-lang/chalk.git\", rev = \"329b7f3fdd2431ed6f6778cde53f22374c7d094c\" }\n+chalk-solve = \"0.11\"\n+chalk-ir = \"0.11\"\n \n [dev-dependencies]\n insta = \"0.16.0\""}, {"sha": "bf71d38d6b23258382dd78bb89b52bb0d82d608c", "filename": "crates/ra_hir_ty/src/db.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -3,8 +3,8 @@\n use std::sync::Arc;\n \n use hir_def::{\n-    db::DefDatabase, DefWithBodyId, GenericDefId, ImplId, LocalFieldId, TraitId, TypeParamId,\n-    VariantId,\n+    db::DefDatabase, DefWithBodyId, FunctionId, GenericDefId, ImplId, LocalFieldId, TraitId,\n+    TypeParamId, VariantId,\n };\n use ra_arena::map::ArenaMap;\n use ra_db::{impl_intern_key, salsa, CrateId, Upcast};\n@@ -13,8 +13,8 @@ use ra_prof::profile;\n use crate::{\n     method_resolution::{CrateImplDefs, TyFingerprint},\n     traits::{chalk, AssocTyValue, Impl},\n-    Binders, CallableDef, GenericPredicate, InferenceResult, PolyFnSig, Substs, TraitRef, Ty,\n-    TyDefId, TypeCtor, ValueTyDefId,\n+    Binders, CallableDef, GenericPredicate, InferenceResult, OpaqueTyId, PolyFnSig,\n+    ReturnTypeImplTraits, Substs, TraitRef, Ty, TyDefId, TypeCtor, ValueTyDefId,\n };\n use hir_expand::name::Name;\n \n@@ -48,6 +48,12 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::callable_item_sig)]\n     fn callable_item_signature(&self, def: CallableDef) -> PolyFnSig;\n \n+    #[salsa::invoke(crate::lower::return_type_impl_traits)]\n+    fn return_type_impl_traits(\n+        &self,\n+        def: FunctionId,\n+    ) -> Option<Arc<Binders<ReturnTypeImplTraits>>>;\n+\n     #[salsa::invoke(crate::lower::generic_predicates_for_param_query)]\n     #[salsa::cycle(crate::lower::generic_predicates_for_param_recover)]\n     fn generic_predicates_for_param(\n@@ -80,6 +86,8 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::interned]\n     fn intern_type_param_id(&self, param_id: TypeParamId) -> GlobalTypeParamId;\n     #[salsa::interned]\n+    fn intern_impl_trait_id(&self, id: OpaqueTyId) -> InternedOpaqueTyId;\n+    #[salsa::interned]\n     fn intern_chalk_impl(&self, impl_: Impl) -> crate::traits::GlobalImplId;\n     #[salsa::interned]\n     fn intern_assoc_ty_value(&self, assoc_ty_value: AssocTyValue) -> crate::traits::AssocTyValueId;\n@@ -142,3 +150,7 @@ fn hir_database_is_object_safe() {\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct GlobalTypeParamId(salsa::InternId);\n impl_intern_key!(GlobalTypeParamId);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct InternedOpaqueTyId(salsa::InternId);\n+impl_intern_key!(InternedOpaqueTyId);"}, {"sha": "3c97e13545e3f538464bf2ace92f5468e74d03a0", "filename": "crates/ra_hir_ty/src/display.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdisplay.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -4,7 +4,7 @@ use std::fmt;\n \n use crate::{\n     db::HirDatabase, utils::generics, ApplicationTy, CallableDef, FnSig, GenericPredicate,\n-    Obligation, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+    Obligation, OpaqueTyId, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n use hir_def::{\n     find_path, generics::TypeParamProvenance, item_scope::ItemInNs, AdtId, AssocContainerId,\n@@ -359,6 +359,21 @@ impl HirDisplay for ApplicationTy {\n                     write!(f, \">\")?;\n                 }\n             }\n+            TypeCtor::OpaqueType(opaque_ty_id) => {\n+                let bounds = match opaque_ty_id {\n+                    OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n+                        let datas =\n+                            f.db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n+                        let data = (*datas)\n+                            .as_ref()\n+                            .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                        data.clone().subst(&self.parameters)\n+                    }\n+                };\n+                write!(f, \"impl \")?;\n+                write_bounds_like_dyn_trait(&bounds.value, f)?;\n+                // FIXME: it would maybe be good to distinguish this from the alias type (when debug printing), and to show the substitution\n+            }\n             TypeCtor::Closure { .. } => {\n                 let sig = self.parameters[0].callable_sig(f.db);\n                 if let Some(sig) = sig {\n@@ -427,14 +442,24 @@ impl HirDisplay for Ty {\n                 }\n             }\n             Ty::Bound(idx) => write!(f, \"?{}.{}\", idx.debruijn.depth(), idx.index)?,\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                match self {\n-                    Ty::Dyn(_) => write!(f, \"dyn \")?,\n-                    Ty::Opaque(_) => write!(f, \"impl \")?,\n-                    _ => unreachable!(),\n-                };\n+            Ty::Dyn(predicates) => {\n+                write!(f, \"dyn \")?;\n                 write_bounds_like_dyn_trait(predicates, f)?;\n             }\n+            Ty::Opaque(opaque_ty) => {\n+                let bounds = match opaque_ty.opaque_ty_id {\n+                    OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n+                        let datas =\n+                            f.db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n+                        let data = (*datas)\n+                            .as_ref()\n+                            .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n+                        data.clone().subst(&opaque_ty.parameters)\n+                    }\n+                };\n+                write!(f, \"impl \")?;\n+                write_bounds_like_dyn_trait(&bounds.value, f)?;\n+            }\n             Ty::Unknown => write!(f, \"{{unknown}}\")?,\n             Ty::Infer(..) => write!(f, \"_\")?,\n         }"}, {"sha": "7db928dded28396bdd39b0819172299d816eb393", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -226,17 +226,19 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             None => return,\n         };\n \n-        let std_result_path = path![std::result::Result];\n+        let core_result_path = path![core::result::Result];\n \n         let resolver = self.func.resolver(db.upcast());\n-        let std_result_enum = match resolver.resolve_known_enum(db.upcast(), &std_result_path) {\n+        let core_result_enum = match resolver.resolve_known_enum(db.upcast(), &core_result_path) {\n             Some(it) => it,\n             _ => return,\n         };\n \n-        let std_result_ctor = TypeCtor::Adt(AdtId::EnumId(std_result_enum));\n+        let core_result_ctor = TypeCtor::Adt(AdtId::EnumId(core_result_enum));\n         let params = match &mismatch.expected {\n-            Ty::Apply(ApplicationTy { ctor, parameters }) if ctor == &std_result_ctor => parameters,\n+            Ty::Apply(ApplicationTy { ctor, parameters }) if ctor == &core_result_ctor => {\n+                parameters\n+            }\n             _ => return,\n         };\n "}, {"sha": "3719f76a6e21af67df1aadba1450b2259b0ddc21", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 13, "deletions": 39, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -39,8 +39,7 @@ use ra_syntax::SmolStr;\n use super::{\n     primitive::{FloatTy, IntTy},\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n-    ApplicationTy, GenericPredicate, InEnvironment, ProjectionTy, Substs, TraitEnvironment,\n-    TraitRef, Ty, TypeCtor, TypeWalk, Uncertain,\n+    InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n use crate::{\n     db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode,\n@@ -312,12 +311,6 @@ impl<'a> InferenceContext<'a> {\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n         match ty {\n             Ty::Unknown => self.table.new_type_var(),\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Int(Uncertain::Unknown), .. }) => {\n-                self.table.new_integer_var()\n-            }\n-            Ty::Apply(ApplicationTy { ctor: TypeCtor::Float(Uncertain::Unknown), .. }) => {\n-                self.table.new_float_var()\n-            }\n             _ => ty,\n         }\n     }\n@@ -383,25 +376,6 @@ impl<'a> InferenceContext<'a> {\n     ) -> Ty {\n         match assoc_ty {\n             Some(res_assoc_ty) => {\n-                // FIXME:\n-                // Check if inner_ty is is `impl Trait` and contained input TypeAlias id\n-                // this is a workaround while Chalk assoc type projection doesn't always work yet,\n-                // but once that is fixed I don't think we should keep this\n-                // (we'll probably change how associated types are resolved anyway)\n-                if let Ty::Opaque(ref predicates) = inner_ty {\n-                    for p in predicates.iter() {\n-                        if let GenericPredicate::Projection(projection) = p {\n-                            if projection.projection_ty.associated_ty == res_assoc_ty {\n-                                if let ty_app!(_, params) = &projection.ty {\n-                                    if params.len() == 0 {\n-                                        return projection.ty.clone();\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-\n                 let ty = self.table.new_type_var();\n                 let builder = Substs::build_for_def(self.db, res_assoc_ty)\n                     .push(inner_ty)\n@@ -458,13 +432,13 @@ impl<'a> InferenceContext<'a> {\n             };\n         return match resolution {\n             TypeNs::AdtId(AdtId::StructId(strukt)) => {\n-                let substs = Ty::substs_from_path(&ctx, path, strukt.into());\n+                let substs = Ty::substs_from_path(&ctx, path, strukt.into(), true);\n                 let ty = self.db.ty(strukt.into());\n                 let ty = self.insert_type_vars(ty.subst(&substs));\n                 forbid_unresolved_segments((ty, Some(strukt.into())), unresolved)\n             }\n             TypeNs::EnumVariantId(var) => {\n-                let substs = Ty::substs_from_path(&ctx, path, var.into());\n+                let substs = Ty::substs_from_path(&ctx, path, var.into(), true);\n                 let ty = self.db.ty(var.parent.into());\n                 let ty = self.insert_type_vars(ty.subst(&substs));\n                 forbid_unresolved_segments((ty, Some(var.into())), unresolved)\n@@ -581,13 +555,13 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n-        let path = path![std::iter::IntoIterator];\n+        let path = path![core::iter::IntoIterator];\n         let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Item])\n     }\n \n     fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n-        let path = path![std::ops::Try];\n+        let path = path![core::ops::Try];\n         let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Ok])\n     }\n@@ -613,37 +587,37 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_range_full(&self) -> Option<AdtId> {\n-        let path = path![std::ops::RangeFull];\n+        let path = path![core::ops::RangeFull];\n         let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range(&self) -> Option<AdtId> {\n-        let path = path![std::ops::Range];\n+        let path = path![core::ops::Range];\n         let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_inclusive(&self) -> Option<AdtId> {\n-        let path = path![std::ops::RangeInclusive];\n+        let path = path![core::ops::RangeInclusive];\n         let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_from(&self) -> Option<AdtId> {\n-        let path = path![std::ops::RangeFrom];\n+        let path = path![core::ops::RangeFrom];\n         let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_to(&self) -> Option<AdtId> {\n-        let path = path![std::ops::RangeTo];\n+        let path = path![core::ops::RangeTo];\n         let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n \n     fn resolve_range_to_inclusive(&self) -> Option<AdtId> {\n-        let path = path![std::ops::RangeToInclusive];\n+        let path = path![core::ops::RangeToInclusive];\n         let struct_ = self.resolver.resolve_known_struct(self.db.upcast(), &path)?;\n         Some(struct_.into())\n     }\n@@ -683,8 +657,8 @@ impl InferTy {\n     fn fallback_value(self) -> Ty {\n         match self {\n             InferTy::TypeVar(..) => Ty::Unknown,\n-            InferTy::IntVar(..) => Ty::simple(TypeCtor::Int(Uncertain::Known(IntTy::i32()))),\n-            InferTy::FloatVar(..) => Ty::simple(TypeCtor::Float(Uncertain::Known(FloatTy::f64()))),\n+            InferTy::IntVar(..) => Ty::simple(TypeCtor::Int(IntTy::i32())),\n+            InferTy::FloatVar(..) => Ty::simple(TypeCtor::Float(FloatTy::f64())),\n             InferTy::MaybeNeverTypeVar(..) => Ty::simple(TypeCtor::Never),\n         }\n     }"}, {"sha": "9fd310f69a79d5fd0ba27027de31623ed074f24b", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -18,7 +18,7 @@ use crate::{\n     traits::InEnvironment,\n     utils::{generics, variant_data, Generics},\n     ApplicationTy, Binders, CallableDef, InferTy, IntTy, Mutability, Obligation, Rawness, Substs,\n-    TraitRef, Ty, TypeCtor, Uncertain,\n+    TraitRef, Ty, TypeCtor,\n };\n \n use super::{\n@@ -426,15 +426,7 @@ impl<'a> InferenceContext<'a> {\n                         match &inner_ty {\n                             // Fast path for builtins\n                             Ty::Apply(ApplicationTy {\n-                                ctor:\n-                                    TypeCtor::Int(Uncertain::Known(IntTy {\n-                                        signedness: Signedness::Signed,\n-                                        ..\n-                                    })),\n-                                ..\n-                            })\n-                            | Ty::Apply(ApplicationTy {\n-                                ctor: TypeCtor::Int(Uncertain::Unknown),\n+                                ctor: TypeCtor::Int(IntTy { signedness: Signedness::Signed, .. }),\n                                 ..\n                             })\n                             | Ty::Apply(ApplicationTy { ctor: TypeCtor::Float(_), .. })\n@@ -577,9 +569,7 @@ impl<'a> InferenceContext<'a> {\n                         );\n                         self.infer_expr(\n                             *repeat,\n-                            &Expectation::has_type(Ty::simple(TypeCtor::Int(Uncertain::Known(\n-                                IntTy::usize(),\n-                            )))),\n+                            &Expectation::has_type(Ty::simple(TypeCtor::Int(IntTy::usize()))),\n                         );\n                     }\n                 }\n@@ -592,13 +582,19 @@ impl<'a> InferenceContext<'a> {\n                     Ty::apply_one(TypeCtor::Ref(Mutability::Shared), Ty::simple(TypeCtor::Str))\n                 }\n                 Literal::ByteString(..) => {\n-                    let byte_type = Ty::simple(TypeCtor::Int(Uncertain::Known(IntTy::u8())));\n+                    let byte_type = Ty::simple(TypeCtor::Int(IntTy::u8()));\n                     let array_type = Ty::apply_one(TypeCtor::Array, byte_type);\n                     Ty::apply_one(TypeCtor::Ref(Mutability::Shared), array_type)\n                 }\n                 Literal::Char(..) => Ty::simple(TypeCtor::Char),\n-                Literal::Int(_v, ty) => Ty::simple(TypeCtor::Int((*ty).into())),\n-                Literal::Float(_v, ty) => Ty::simple(TypeCtor::Float((*ty).into())),\n+                Literal::Int(_v, ty) => match ty {\n+                    Some(int_ty) => Ty::simple(TypeCtor::Int((*int_ty).into())),\n+                    None => self.table.new_integer_var(),\n+                },\n+                Literal::Float(_v, ty) => match ty {\n+                    Some(float_ty) => Ty::simple(TypeCtor::Float((*float_ty).into())),\n+                    None => self.table.new_float_var(),\n+                },\n             },\n         };\n         // use a new type variable if we got Ty::Unknown here"}, {"sha": "1ad0d8397166599e1e36c345a645de7ea36595a8", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -95,7 +95,7 @@ impl<'a> InferenceContext<'a> {\n         // self_subst is just for the parent\n         let parent_substs = self_subst.unwrap_or_else(Substs::empty);\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n-        let substs = Ty::substs_from_path(&ctx, path, typable);\n+        let substs = Ty::substs_from_path(&ctx, path, typable, true);\n         let full_substs = Substs::builder(substs.len())\n             .use_parent_substs(&parent_substs)\n             .fill(substs.0[parent_substs.len()..].iter().cloned())\n@@ -141,6 +141,7 @@ impl<'a> InferenceContext<'a> {\n                     def,\n                     resolved_segment,\n                     remaining_segments_for_ty,\n+                    true,\n                 );\n                 if let Ty::Unknown = ty {\n                     return None;"}, {"sha": "2b9372b4b1bc91da1ad131066df2b9b50cf4e6d3", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 92, "deletions": 12, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -58,7 +58,7 @@ use ra_db::{impl_intern_key, salsa, CrateId};\n \n use crate::{\n     db::HirDatabase,\n-    primitive::{FloatTy, IntTy, Uncertain},\n+    primitive::{FloatTy, IntTy},\n     utils::{generics, make_mut_slice, Generics},\n };\n use display::HirDisplay;\n@@ -87,10 +87,10 @@ pub enum TypeCtor {\n     Char,\n \n     /// A primitive integer type. For example, `i32`.\n-    Int(Uncertain<IntTy>),\n+    Int(IntTy),\n \n     /// A primitive floating-point type. For example, `f64`.\n-    Float(Uncertain<FloatTy>),\n+    Float(FloatTy),\n \n     /// Structures, enumerations and unions.\n     Adt(AdtId),\n@@ -147,6 +147,12 @@ pub enum TypeCtor {\n     /// an **application type** like `(Iterator::Item)<T>`.\n     AssociatedType(TypeAliasId),\n \n+    /// This represents a placeholder for an opaque type in situations where we\n+    /// don't know the hidden type (i.e. currently almost always). This is\n+    /// analogous to the `AssociatedType` type constructor. As with that one,\n+    /// these are only produced by Chalk.\n+    OpaqueType(OpaqueTyId),\n+\n     /// The type of a specific closure.\n     ///\n     /// The closure signature is stored in a `FnPtr` type in the first type\n@@ -194,6 +200,14 @@ impl TypeCtor {\n                 let generic_params = generics(db.upcast(), type_alias.into());\n                 generic_params.len()\n             }\n+            TypeCtor::OpaqueType(opaque_ty_id) => {\n+                match opaque_ty_id {\n+                    OpaqueTyId::ReturnTypeImplTrait(func, _) => {\n+                        let generic_params = generics(db.upcast(), func.into());\n+                        generic_params.len()\n+                    }\n+                }\n+            }\n             TypeCtor::FnPtr { num_args } => num_args as usize + 1,\n             TypeCtor::Tuple { cardinality } => cardinality as usize,\n         }\n@@ -220,6 +234,11 @@ impl TypeCtor {\n             TypeCtor::AssociatedType(type_alias) => {\n                 Some(type_alias.lookup(db.upcast()).module(db.upcast()).krate)\n             }\n+            TypeCtor::OpaqueType(opaque_ty_id) => match opaque_ty_id {\n+                OpaqueTyId::ReturnTypeImplTrait(func, _) => {\n+                    Some(func.lookup(db.upcast()).module(db.upcast()).krate)\n+                }\n+            },\n         }\n     }\n \n@@ -241,6 +260,7 @@ impl TypeCtor {\n             TypeCtor::Adt(adt) => Some(adt.into()),\n             TypeCtor::FnDef(callable) => Some(callable.into()),\n             TypeCtor::AssociatedType(type_alias) => Some(type_alias.into()),\n+            TypeCtor::OpaqueType(_impl_trait_id) => None,\n         }\n     }\n }\n@@ -254,6 +274,12 @@ pub struct ApplicationTy {\n     pub parameters: Substs,\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct OpaqueTy {\n+    pub opaque_ty_id: OpaqueTyId,\n+    pub parameters: Substs,\n+}\n+\n /// A \"projection\" type corresponds to an (unnormalized)\n /// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n /// trait and all its parameters are fully known.\n@@ -308,6 +334,12 @@ pub enum Ty {\n     /// trait and all its parameters are fully known.\n     Projection(ProjectionTy),\n \n+    /// An opaque type (`impl Trait`).\n+    ///\n+    /// This is currently only used for return type impl trait; each instance of\n+    /// `impl Trait` in a return type gets its own ID.\n+    Opaque(OpaqueTy),\n+\n     /// A placeholder for a type parameter; for example, `T` in `fn f<T>(x: T)\n     /// {}` when we're type-checking the body of that function. In this\n     /// situation, we know this stands for *some* type, but don't know the exact\n@@ -332,12 +364,6 @@ pub enum Ty {\n     /// didn't seem worth the overhead yet.\n     Dyn(Arc<[GenericPredicate]>),\n \n-    /// An opaque type (`impl Trait`).\n-    ///\n-    /// The predicates are quantified over the `Self` type; see `Ty::Dyn` for\n-    /// more.\n-    Opaque(Arc<[GenericPredicate]>),\n-\n     /// A placeholder for a type which could not be computed; this is propagated\n     /// to avoid useless error messages. Doubles as a placeholder where type\n     /// variables are inserted before type checking, since we want to try to\n@@ -490,7 +516,7 @@ impl Deref for Substs {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Binders<T> {\n     pub num_binders: usize,\n     pub value: T,\n@@ -534,6 +560,20 @@ impl<T: TypeWalk> Binders<T> {\n     }\n }\n \n+impl<T: TypeWalk> TypeWalk for Binders<T> {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.value.walk(f);\n+    }\n+\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        self.value.walk_mut_binders(f, binders.shifted_in())\n+    }\n+}\n+\n /// A trait with type parameters. This includes the `Self`, so this represents a concrete type implementing the trait.\n /// Name to be bikeshedded: TraitBound? TraitImplements?\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -947,11 +987,16 @@ impl TypeWalk for Ty {\n                     t.walk(f);\n                 }\n             }\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+            Ty::Dyn(predicates) => {\n                 for p in predicates.iter() {\n                     p.walk(f);\n                 }\n             }\n+            Ty::Opaque(o_ty) => {\n+                for t in o_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n             Ty::Placeholder { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self);\n@@ -969,13 +1014,48 @@ impl TypeWalk for Ty {\n             Ty::Projection(p_ty) => {\n                 p_ty.parameters.walk_mut_binders(f, binders);\n             }\n-            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+            Ty::Dyn(predicates) => {\n                 for p in make_mut_slice(predicates) {\n                     p.walk_mut_binders(f, binders.shifted_in());\n                 }\n             }\n+            Ty::Opaque(o_ty) => {\n+                o_ty.parameters.walk_mut_binders(f, binders);\n+            }\n             Ty::Placeholder { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self, binders);\n     }\n }\n+\n+impl<T: TypeWalk> TypeWalk for Vec<T> {\n+    fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        for t in self {\n+            t.walk(f);\n+        }\n+    }\n+    fn walk_mut_binders(\n+        &mut self,\n+        f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n+        binders: DebruijnIndex,\n+    ) {\n+        for t in self {\n+            t.walk_mut_binders(f, binders);\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum OpaqueTyId {\n+    ReturnTypeImplTrait(hir_def::FunctionId, u16),\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct ReturnTypeImplTraits {\n+    pub(crate) impl_traits: Vec<ReturnTypeImplTrait>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub(crate) struct ReturnTypeImplTrait {\n+    pub(crate) bounds: Binders<Vec<GenericPredicate>>,\n+}"}, {"sha": "42713928f451b813c2b8d6e9b03d2ec26140f148", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 168, "deletions": 46, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -21,8 +21,10 @@ use hir_def::{\n     HasModule, ImplId, LocalFieldId, Lookup, StaticId, StructId, TraitId, TypeAliasId, TypeParamId,\n     UnionId, VariantId,\n };\n+use hir_expand::name::Name;\n use ra_arena::map::ArenaMap;\n use ra_db::CrateId;\n+use test_utils::mark;\n \n use crate::{\n     db::HirDatabase,\n@@ -31,10 +33,10 @@ use crate::{\n         all_super_trait_refs, associated_type_by_name_including_super_traits, generics,\n         make_mut_slice, variant_data,\n     },\n-    Binders, BoundVar, DebruijnIndex, FnSig, GenericPredicate, PolyFnSig, ProjectionPredicate,\n-    ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n+    Binders, BoundVar, DebruijnIndex, FnSig, GenericPredicate, OpaqueTy, OpaqueTyId, PolyFnSig,\n+    ProjectionPredicate, ProjectionTy, ReturnTypeImplTrait, ReturnTypeImplTraits, Substs,\n+    TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n-use hir_expand::name::Name;\n \n #[derive(Debug)]\n pub struct TyLoweringContext<'a> {\n@@ -47,7 +49,16 @@ pub struct TyLoweringContext<'a> {\n     /// possible currently, so this should be fine for now.\n     pub type_param_mode: TypeParamLoweringMode,\n     pub impl_trait_mode: ImplTraitLoweringMode,\n-    pub impl_trait_counter: std::cell::Cell<u16>,\n+    impl_trait_counter: std::cell::Cell<u16>,\n+    /// When turning `impl Trait` into opaque types, we have to collect the\n+    /// bounds at the same time to get the IDs correct (without becoming too\n+    /// complicated). I don't like using interior mutability (as for the\n+    /// counter), but I've tried and failed to make the lifetimes work for\n+    /// passing around a `&mut TyLoweringContext`. The core problem is that\n+    /// we're grouping the mutable data (the counter and this field) together\n+    /// with the immutable context (the references to the DB and resolver).\n+    /// Splitting this up would be a possible fix.\n+    opaque_type_data: std::cell::RefCell<Vec<ReturnTypeImplTrait>>,\n }\n \n impl<'a> TyLoweringContext<'a> {\n@@ -56,26 +67,42 @@ impl<'a> TyLoweringContext<'a> {\n         let impl_trait_mode = ImplTraitLoweringMode::Disallowed;\n         let type_param_mode = TypeParamLoweringMode::Placeholder;\n         let in_binders = DebruijnIndex::INNERMOST;\n-        Self { db, resolver, in_binders, impl_trait_mode, impl_trait_counter, type_param_mode }\n+        let opaque_type_data = std::cell::RefCell::new(Vec::new());\n+        Self {\n+            db,\n+            resolver,\n+            in_binders,\n+            impl_trait_mode,\n+            impl_trait_counter,\n+            type_param_mode,\n+            opaque_type_data,\n+        }\n     }\n \n-    pub fn with_shifted_in<T>(\n+    pub fn with_debruijn<T>(\n         &self,\n         debruijn: DebruijnIndex,\n         f: impl FnOnce(&TyLoweringContext) -> T,\n     ) -> T {\n+        let opaque_ty_data_vec = self.opaque_type_data.replace(Vec::new());\n         let new_ctx = Self {\n-            in_binders: self.in_binders.shifted_in_from(debruijn),\n+            in_binders: debruijn,\n             impl_trait_counter: std::cell::Cell::new(self.impl_trait_counter.get()),\n+            opaque_type_data: std::cell::RefCell::new(opaque_ty_data_vec),\n             ..*self\n         };\n         let result = f(&new_ctx);\n         self.impl_trait_counter.set(new_ctx.impl_trait_counter.get());\n+        self.opaque_type_data.replace(new_ctx.opaque_type_data.into_inner());\n         result\n     }\n \n-    pub fn shifted_in(self, debruijn: DebruijnIndex) -> Self {\n-        Self { in_binders: self.in_binders.shifted_in_from(debruijn), ..self }\n+    pub fn with_shifted_in<T>(\n+        &self,\n+        debruijn: DebruijnIndex,\n+        f: impl FnOnce(&TyLoweringContext) -> T,\n+    ) -> T {\n+        self.with_debruijn(self.in_binders.shifted_in_from(debruijn), f)\n     }\n \n     pub fn with_impl_trait_mode(self, impl_trait_mode: ImplTraitLoweringMode) -> Self {\n@@ -167,20 +194,44 @@ impl Ty {\n             TypeRef::ImplTrait(bounds) => {\n                 match ctx.impl_trait_mode {\n                     ImplTraitLoweringMode::Opaque => {\n-                        let self_ty = Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n-                        let predicates = ctx.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n-                            bounds\n-                                .iter()\n-                                .flat_map(|b| {\n-                                    GenericPredicate::from_type_bound(ctx, b, self_ty.clone())\n-                                })\n-                                .collect()\n-                        });\n-                        Ty::Opaque(predicates)\n+                        let idx = ctx.impl_trait_counter.get();\n+                        ctx.impl_trait_counter.set(idx + 1);\n+\n+                        assert!(idx as usize == ctx.opaque_type_data.borrow().len());\n+                        // this dance is to make sure the data is in the right\n+                        // place even if we encounter more opaque types while\n+                        // lowering the bounds\n+                        ctx.opaque_type_data\n+                            .borrow_mut()\n+                            .push(ReturnTypeImplTrait { bounds: Binders::new(1, Vec::new()) });\n+                        // We don't want to lower the bounds inside the binders\n+                        // we're currently in, because they don't end up inside\n+                        // those binders. E.g. when we have `impl Trait<impl\n+                        // OtherTrait<T>>`, the `impl OtherTrait<T>` can't refer\n+                        // to the self parameter from `impl Trait`, and the\n+                        // bounds aren't actually stored nested within each\n+                        // other, but separately. So if the `T` refers to a type\n+                        // parameter of the outer function, it's just one binder\n+                        // away instead of two.\n+                        let actual_opaque_type_data = ctx\n+                            .with_debruijn(DebruijnIndex::INNERMOST, |ctx| {\n+                                ReturnTypeImplTrait::from_hir(ctx, &bounds)\n+                            });\n+                        ctx.opaque_type_data.borrow_mut()[idx as usize] = actual_opaque_type_data;\n+\n+                        let func = match ctx.resolver.generic_def() {\n+                            Some(GenericDefId::FunctionId(f)) => f,\n+                            _ => panic!(\"opaque impl trait lowering in non-function\"),\n+                        };\n+                        let impl_trait_id = OpaqueTyId::ReturnTypeImplTrait(func, idx);\n+                        let generics = generics(ctx.db.upcast(), func.into());\n+                        let parameters = Substs::bound_vars(&generics, ctx.in_binders);\n+                        Ty::Opaque(OpaqueTy { opaque_ty_id: impl_trait_id, parameters })\n                     }\n                     ImplTraitLoweringMode::Param => {\n                         let idx = ctx.impl_trait_counter.get();\n-                        ctx.impl_trait_counter.set(idx + 1);\n+                        // FIXME we're probably doing something wrong here\n+                        ctx.impl_trait_counter.set(idx + count_impl_traits(type_ref) as u16);\n                         if let Some(def) = ctx.resolver.generic_def() {\n                             let generics = generics(ctx.db.upcast(), def);\n                             let param = generics\n@@ -197,7 +248,8 @@ impl Ty {\n                     }\n                     ImplTraitLoweringMode::Variable => {\n                         let idx = ctx.impl_trait_counter.get();\n-                        ctx.impl_trait_counter.set(idx + 1);\n+                        // FIXME we're probably doing something wrong here\n+                        ctx.impl_trait_counter.set(idx + count_impl_traits(type_ref) as u16);\n                         let (parent_params, self_params, list_params, _impl_trait_params) =\n                             if let Some(def) = ctx.resolver.generic_def() {\n                                 let generics = generics(ctx.db.upcast(), def);\n@@ -271,6 +323,7 @@ impl Ty {\n         resolution: TypeNs,\n         resolved_segment: PathSegment<'_>,\n         remaining_segments: PathSegments<'_>,\n+        infer_args: bool,\n     ) -> (Ty, Option<TypeNs>) {\n         let ty = match resolution {\n             TypeNs::TraitId(trait_) => {\n@@ -348,9 +401,15 @@ impl Ty {\n                 ctx.db.ty(adt.into()).subst(&substs)\n             }\n \n-            TypeNs::AdtId(it) => Ty::from_hir_path_inner(ctx, resolved_segment, it.into()),\n-            TypeNs::BuiltinType(it) => Ty::from_hir_path_inner(ctx, resolved_segment, it.into()),\n-            TypeNs::TypeAliasId(it) => Ty::from_hir_path_inner(ctx, resolved_segment, it.into()),\n+            TypeNs::AdtId(it) => {\n+                Ty::from_hir_path_inner(ctx, resolved_segment, it.into(), infer_args)\n+            }\n+            TypeNs::BuiltinType(it) => {\n+                Ty::from_hir_path_inner(ctx, resolved_segment, it.into(), infer_args)\n+            }\n+            TypeNs::TypeAliasId(it) => {\n+                Ty::from_hir_path_inner(ctx, resolved_segment, it.into(), infer_args)\n+            }\n             // FIXME: report error\n             TypeNs::EnumVariantId(_) => return (Ty::Unknown, None),\n         };\n@@ -376,7 +435,13 @@ impl Ty {\n             ),\n             Some(i) => (path.segments().get(i - 1).unwrap(), path.segments().skip(i)),\n         };\n-        Ty::from_partly_resolved_hir_path(ctx, resolution, resolved_segment, remaining_segments)\n+        Ty::from_partly_resolved_hir_path(\n+            ctx,\n+            resolution,\n+            resolved_segment,\n+            remaining_segments,\n+            false,\n+        )\n     }\n \n     fn select_associated_type(\n@@ -422,13 +487,14 @@ impl Ty {\n         ctx: &TyLoweringContext<'_>,\n         segment: PathSegment<'_>,\n         typable: TyDefId,\n+        infer_args: bool,\n     ) -> Ty {\n         let generic_def = match typable {\n             TyDefId::BuiltinType(_) => None,\n             TyDefId::AdtId(it) => Some(it.into()),\n             TyDefId::TypeAliasId(it) => Some(it.into()),\n         };\n-        let substs = substs_from_path_segment(ctx, segment, generic_def, false);\n+        let substs = substs_from_path_segment(ctx, segment, generic_def, infer_args);\n         ctx.db.ty(typable).subst(&substs)\n     }\n \n@@ -441,6 +507,7 @@ impl Ty {\n         // `ValueTyDefId` is just a convenient way to pass generics and\n         // special-case enum variants\n         resolved: ValueTyDefId,\n+        infer_args: bool,\n     ) -> Substs {\n         let last = path.segments().last().expect(\"path should have at least one segment\");\n         let (segment, generic_def) = match resolved {\n@@ -463,22 +530,27 @@ impl Ty {\n                 (segment, Some(var.parent.into()))\n             }\n         };\n-        substs_from_path_segment(ctx, segment, generic_def, false)\n+        substs_from_path_segment(ctx, segment, generic_def, infer_args)\n     }\n }\n \n-pub(super) fn substs_from_path_segment(\n+fn substs_from_path_segment(\n     ctx: &TyLoweringContext<'_>,\n     segment: PathSegment<'_>,\n     def_generic: Option<GenericDefId>,\n-    _add_self_param: bool,\n+    infer_args: bool,\n ) -> Substs {\n     let mut substs = Vec::new();\n     let def_generics = def_generic.map(|def| generics(ctx.db.upcast(), def));\n \n     let (parent_params, self_params, type_params, impl_trait_params) =\n         def_generics.map_or((0, 0, 0, 0), |g| g.provenance_split());\n+    let total_len = parent_params + self_params + type_params + impl_trait_params;\n+\n     substs.extend(iter::repeat(Ty::Unknown).take(parent_params));\n+\n+    let mut had_explicit_args = false;\n+\n     if let Some(generic_args) = &segment.args_and_bindings {\n         if !generic_args.has_self_type {\n             substs.extend(iter::repeat(Ty::Unknown).take(self_params));\n@@ -490,31 +562,35 @@ pub(super) fn substs_from_path_segment(\n         for arg in generic_args.args.iter().skip(skip).take(expected_num) {\n             match arg {\n                 GenericArg::Type(type_ref) => {\n+                    had_explicit_args = true;\n                     let ty = Ty::from_hir(ctx, type_ref);\n                     substs.push(ty);\n                 }\n             }\n         }\n     }\n-    let total_len = parent_params + self_params + type_params + impl_trait_params;\n-    // add placeholders for args that were not provided\n-    for _ in substs.len()..total_len {\n-        substs.push(Ty::Unknown);\n-    }\n-    assert_eq!(substs.len(), total_len);\n \n-    // handle defaults\n-    if let Some(def_generic) = def_generic {\n-        let default_substs = ctx.db.generic_defaults(def_generic);\n-        assert_eq!(substs.len(), default_substs.len());\n+    // handle defaults. In expression or pattern path segments without\n+    // explicitly specified type arguments, missing type arguments are inferred\n+    // (i.e. defaults aren't used).\n+    if !infer_args || had_explicit_args {\n+        if let Some(def_generic) = def_generic {\n+            let default_substs = ctx.db.generic_defaults(def_generic);\n+            assert_eq!(total_len, default_substs.len());\n \n-        for (i, default_ty) in default_substs.iter().enumerate() {\n-            if substs[i] == Ty::Unknown {\n-                substs[i] = default_ty.clone();\n+            for default_ty in default_substs.iter().skip(substs.len()) {\n+                substs.push(default_ty.clone());\n             }\n         }\n     }\n \n+    // add placeholders for args that were not provided\n+    // FIXME: emit diagnostics in contexts where this is not allowed\n+    for _ in substs.len()..total_len {\n+        substs.push(Ty::Unknown);\n+    }\n+    assert_eq!(substs.len(), total_len);\n+\n     Substs(substs.into())\n }\n \n@@ -563,9 +639,7 @@ impl TraitRef {\n         segment: PathSegment<'_>,\n         resolved: TraitId,\n     ) -> Substs {\n-        let has_self_param =\n-            segment.args_and_bindings.as_ref().map(|a| a.has_self_type).unwrap_or(false);\n-        substs_from_path_segment(ctx, segment, Some(resolved.into()), !has_self_param)\n+        substs_from_path_segment(ctx, segment, Some(resolved.into()), false)\n     }\n \n     pub(crate) fn from_type_bound(\n@@ -663,6 +737,30 @@ fn assoc_type_bindings_from_type_bound<'a>(\n         })\n }\n \n+impl ReturnTypeImplTrait {\n+    fn from_hir(ctx: &TyLoweringContext, bounds: &[TypeBound]) -> Self {\n+        mark::hit!(lower_rpit);\n+        let self_ty = Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n+        let predicates = ctx.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n+            bounds\n+                .iter()\n+                .flat_map(|b| GenericPredicate::from_type_bound(ctx, b, self_ty.clone()))\n+                .collect()\n+        });\n+        ReturnTypeImplTrait { bounds: Binders::new(1, predicates) }\n+    }\n+}\n+\n+fn count_impl_traits(type_ref: &TypeRef) -> usize {\n+    let mut count = 0;\n+    type_ref.walk(&mut |type_ref| {\n+        if matches!(type_ref, TypeRef::ImplTrait(_)) {\n+            count += 1;\n+        }\n+    });\n+    count\n+}\n+\n /// Build the signature of a callable item (function, struct or enum variant).\n pub fn callable_item_sig(db: &dyn HirDatabase, def: CallableDef) -> PolyFnSig {\n     match def {\n@@ -864,7 +962,9 @@ fn fn_sig_for_fn(db: &dyn HirDatabase, def: FunctionId) -> PolyFnSig {\n         .with_impl_trait_mode(ImplTraitLoweringMode::Variable)\n         .with_type_param_mode(TypeParamLoweringMode::Variable);\n     let params = data.params.iter().map(|tr| Ty::from_hir(&ctx_params, tr)).collect::<Vec<_>>();\n-    let ctx_ret = ctx_params.with_impl_trait_mode(ImplTraitLoweringMode::Opaque);\n+    let ctx_ret = TyLoweringContext::new(db, &resolver)\n+        .with_impl_trait_mode(ImplTraitLoweringMode::Opaque)\n+        .with_type_param_mode(TypeParamLoweringMode::Variable);\n     let ret = Ty::from_hir(&ctx_ret, &data.ret_type);\n     let generics = generics(db.upcast(), def.into());\n     let num_binders = generics.len();\n@@ -1084,3 +1184,25 @@ pub(crate) fn impl_trait_query(db: &dyn HirDatabase, impl_id: ImplId) -> Option<\n         TraitRef::from_hir(&ctx, target_trait, Some(self_ty.value))?,\n     ))\n }\n+\n+pub(crate) fn return_type_impl_traits(\n+    db: &impl HirDatabase,\n+    def: hir_def::FunctionId,\n+) -> Option<Arc<Binders<ReturnTypeImplTraits>>> {\n+    // FIXME unify with fn_sig_for_fn instead of doing lowering twice, maybe\n+    let data = db.function_data(def);\n+    let resolver = def.resolver(db.upcast());\n+    let ctx_ret = TyLoweringContext::new(db, &resolver)\n+        .with_impl_trait_mode(ImplTraitLoweringMode::Opaque)\n+        .with_type_param_mode(TypeParamLoweringMode::Variable);\n+    let _ret = Ty::from_hir(&ctx_ret, &data.ret_type);\n+    let generics = generics(db.upcast(), def.into());\n+    let num_binders = generics.len();\n+    let return_type_impl_traits =\n+        ReturnTypeImplTraits { impl_traits: ctx_ret.opaque_type_data.into_inner() };\n+    if return_type_impl_traits.impl_traits.is_empty() {\n+        None\n+    } else {\n+        Some(Arc::new(Binders::new(num_binders, return_type_impl_traits)))\n+    }\n+}"}, {"sha": "e83b394566b1b8573202eea06c29356e15eb7f79", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -16,12 +16,8 @@ use rustc_hash::{FxHashMap, FxHashSet};\n \n use super::Substs;\n use crate::{\n-    autoderef,\n-    db::HirDatabase,\n-    primitive::{FloatBitness, Uncertain},\n-    utils::all_super_traits,\n-    ApplicationTy, Canonical, DebruijnIndex, InEnvironment, TraitEnvironment, TraitRef, Ty,\n-    TypeCtor, TypeWalk,\n+    autoderef, db::HirDatabase, primitive::FloatBitness, utils::all_super_traits, ApplicationTy,\n+    Canonical, DebruijnIndex, InEnvironment, TraitEnvironment, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n \n /// This is used as a key for indexing impls.\n@@ -147,12 +143,12 @@ impl Ty {\n                 }\n                 TypeCtor::Bool => lang_item_crate!(\"bool\"),\n                 TypeCtor::Char => lang_item_crate!(\"char\"),\n-                TypeCtor::Float(Uncertain::Known(f)) => match f.bitness {\n+                TypeCtor::Float(f) => match f.bitness {\n                     // There are two lang items: one in libcore (fXX) and one in libstd (fXX_runtime)\n                     FloatBitness::X32 => lang_item_crate!(\"f32\", \"f32_runtime\"),\n                     FloatBitness::X64 => lang_item_crate!(\"f64\", \"f64_runtime\"),\n                 },\n-                TypeCtor::Int(Uncertain::Known(i)) => lang_item_crate!(i.ty_to_string()),\n+                TypeCtor::Int(i) => lang_item_crate!(i.ty_to_string()),\n                 TypeCtor::Str => lang_item_crate!(\"str_alloc\", \"str\"),\n                 TypeCtor::Slice => lang_item_crate!(\"slice_alloc\", \"slice\"),\n                 TypeCtor::RawPtr(Mutability::Shared) => lang_item_crate!(\"const_ptr\"),"}, {"sha": "37966b709848cc38c4bd08940f115fa25d48bcd2", "filename": "crates/ra_hir_ty/src/primitive.rs", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fprimitive.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -7,42 +7,6 @@ use std::fmt;\n \n pub use hir_def::builtin_type::{BuiltinFloat, BuiltinInt, FloatBitness, IntBitness, Signedness};\n \n-#[derive(Clone, Copy, Eq, PartialEq, Hash, Debug)]\n-pub enum Uncertain<T> {\n-    Unknown,\n-    Known(T),\n-}\n-\n-impl From<IntTy> for Uncertain<IntTy> {\n-    fn from(ty: IntTy) -> Self {\n-        Uncertain::Known(ty)\n-    }\n-}\n-\n-impl fmt::Display for Uncertain<IntTy> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Uncertain::Unknown => write!(f, \"{{integer}}\"),\n-            Uncertain::Known(ty) => write!(f, \"{}\", ty),\n-        }\n-    }\n-}\n-\n-impl From<FloatTy> for Uncertain<FloatTy> {\n-    fn from(ty: FloatTy) -> Self {\n-        Uncertain::Known(ty)\n-    }\n-}\n-\n-impl fmt::Display for Uncertain<FloatTy> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Uncertain::Unknown => write!(f, \"{{float}}\"),\n-            Uncertain::Known(ty) => write!(f, \"{}\", ty),\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, Eq, PartialEq, Hash)]\n pub struct IntTy {\n     pub signedness: Signedness,\n@@ -173,21 +137,3 @@ impl From<BuiltinFloat> for FloatTy {\n         FloatTy { bitness: t.bitness }\n     }\n }\n-\n-impl From<Option<BuiltinInt>> for Uncertain<IntTy> {\n-    fn from(t: Option<BuiltinInt>) -> Self {\n-        match t {\n-            None => Uncertain::Unknown,\n-            Some(t) => Uncertain::Known(t.into()),\n-        }\n-    }\n-}\n-\n-impl From<Option<BuiltinFloat>> for Uncertain<FloatTy> {\n-    fn from(t: Option<BuiltinFloat>) -> Self {\n-        match t {\n-            None => Uncertain::Unknown,\n-            Some(t) => Uncertain::Known(t.into()),\n-        }\n-    }\n-}"}, {"sha": "ad04e3e0f908511b98f5ee199e40b1f65e80926c", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -7,9 +7,8 @@ use std::{\n \n use hir_def::{db::DefDatabase, AssocItemId, ModuleDefId, ModuleId};\n use hir_expand::{db::AstDatabase, diagnostics::DiagnosticSink};\n-use ra_db::{\n-    salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath, SourceDatabase, Upcast,\n-};\n+use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, SourceDatabase, Upcast};\n+use rustc_hash::FxHashSet;\n use stdx::format_to;\n \n use crate::{db::HirDatabase, diagnostics::Diagnostic, expr::ExprValidator};\n@@ -72,23 +71,12 @@ impl FileLoader for TestDB {\n     fn file_text(&self, file_id: FileId) -> Arc<String> {\n         FileLoaderDelegate(self).file_text(file_id)\n     }\n-    fn resolve_relative_path(\n-        &self,\n-        anchor: FileId,\n-        relative_path: &RelativePath,\n-    ) -> Option<FileId> {\n-        FileLoaderDelegate(self).resolve_relative_path(anchor, relative_path)\n+    fn resolve_path(&self, anchor: FileId, path: &str) -> Option<FileId> {\n+        FileLoaderDelegate(self).resolve_path(anchor, path)\n     }\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<Vec<CrateId>> {\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n         FileLoaderDelegate(self).relevant_crates(file_id)\n     }\n-    fn resolve_extern_path(\n-        &self,\n-        extern_id: ra_db::ExternSourceId,\n-        relative_path: &RelativePath,\n-    ) -> Option<FileId> {\n-        FileLoaderDelegate(self).resolve_extern_path(extern_id, relative_path)\n-    }\n }\n \n impl TestDB {"}, {"sha": "5dfa0a014599fd75386563be0b39438663447f81", "filename": "crates/ra_hir_ty/src/tests/display_source_code.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -29,7 +29,7 @@ fn omit_default_type_parameters() {\n         //- /main.rs\n         struct Foo<T = u8> { t: T }\n         fn main() {\n-            let foo = Foo { t: 5 };\n+            let foo = Foo { t: 5u8 };\n             foo<|>;\n         }\n         \",\n@@ -41,7 +41,7 @@ fn omit_default_type_parameters() {\n         //- /main.rs\n         struct Foo<K, T = u8> { k: K, t: T }\n         fn main() {\n-            let foo = Foo { k: 400, t: 5 };\n+            let foo = Foo { k: 400, t: 5u8 };\n             foo<|>;\n         }\n         \","}, {"sha": "804297315c4d539e49441057ae9e67399d0ff51b", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -183,60 +183,6 @@ fn test() {\n     );\n }\n \n-#[test]\n-fn infer_associated_method_generics_with_default_param() {\n-    assert_snapshot!(\n-        infer(r#\"\n-struct Gen<T=u32> {\n-    val: T\n-}\n-\n-impl<T> Gen<T> {\n-    pub fn make() -> Gen<T> {\n-        loop { }\n-    }\n-}\n-\n-fn test() {\n-    let a = Gen::make();\n-}\n-\"#),\n-        @r###\"\n-    80..104 '{     ...     }': Gen<T>\n-    90..98 'loop { }': !\n-    95..98 '{ }': ()\n-    118..146 '{     ...e(); }': ()\n-    128..129 'a': Gen<u32>\n-    132..141 'Gen::make': fn make<u32>() -> Gen<u32>\n-    132..143 'Gen::make()': Gen<u32>\n-    \"###\n-    );\n-}\n-\n-#[test]\n-fn infer_associated_method_generics_with_default_tuple_param() {\n-    let t = type_at(\n-        r#\"\n-//- /main.rs\n-struct Gen<T=()> {\n-    val: T\n-}\n-\n-impl<T> Gen<T> {\n-    pub fn make() -> Gen<T> {\n-        loop { }\n-    }\n-}\n-\n-fn test() {\n-    let a = Gen::make();\n-    a.val<|>;\n-}\n-\"#,\n-    );\n-    assert_eq!(t, \"()\");\n-}\n-\n #[test]\n fn infer_associated_method_generics_without_args() {\n     assert_snapshot!("}, {"sha": "37659cd02c8171281a953addbe3ce2b5dc696a07", "filename": "crates/ra_hir_ty/src/tests/simple.rs", "status": "modified", "additions": 110, "deletions": 2, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -95,7 +95,7 @@ fn foo() {\n fn infer_ranges() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs crate:main deps:core\n fn test() {\n     let a = ..;\n     let b = 1..;\n@@ -108,7 +108,7 @@ fn test() {\n     t<|>;\n }\n \n-//- /std.rs crate:std\n+//- /core.rs crate:core\n #[prelude_import] use prelude::*;\n mod prelude {}\n \n@@ -1997,3 +1997,111 @@ fn foo() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn generic_default() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Thing<T = ()> { t: T }\n+enum OtherThing<T = ()> {\n+    One { t: T },\n+    Two(T),\n+}\n+\n+fn test(t1: Thing, t2: OtherThing, t3: Thing<i32>, t4: OtherThing<i32>) {\n+    t1.t;\n+    t3.t;\n+    match t2 {\n+        OtherThing::One { t } => { t; },\n+        OtherThing::Two(t) => { t; },\n+    }\n+    match t4 {\n+        OtherThing::One { t } => { t; },\n+        OtherThing::Two(t) => { t; },\n+    }\n+}\n+\"#),\n+        @r###\"\n+    98..100 't1': Thing<()>\n+    109..111 't2': OtherThing<()>\n+    125..127 't3': Thing<i32>\n+    141..143 't4': OtherThing<i32>\n+    162..385 '{     ...   } }': ()\n+    168..170 't1': Thing<()>\n+    168..172 't1.t': ()\n+    178..180 't3': Thing<i32>\n+    178..182 't3.t': i32\n+    188..283 'match ...     }': ()\n+    194..196 't2': OtherThing<()>\n+    207..228 'OtherT... { t }': OtherThing<()>\n+    225..226 't': ()\n+    232..238 '{ t; }': ()\n+    234..235 't': ()\n+    248..266 'OtherT...Two(t)': OtherThing<()>\n+    264..265 't': ()\n+    270..276 '{ t; }': ()\n+    272..273 't': ()\n+    288..383 'match ...     }': ()\n+    294..296 't4': OtherThing<i32>\n+    307..328 'OtherT... { t }': OtherThing<i32>\n+    325..326 't': i32\n+    332..338 '{ t; }': ()\n+    334..335 't': i32\n+    348..366 'OtherT...Two(t)': OtherThing<i32>\n+    364..365 't': i32\n+    370..376 '{ t; }': ()\n+    372..373 't': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn generic_default_in_struct_literal() {\n+    assert_snapshot!(\n+        infer(r#\"\n+struct Thing<T = ()> { t: T }\n+enum OtherThing<T = ()> {\n+    One { t: T },\n+    Two(T),\n+}\n+\n+fn test() {\n+    let x = Thing { t: loop {} };\n+    let y = Thing { t: () };\n+    let z = Thing { t: 1i32 };\n+    if let Thing { t } = z {\n+        t;\n+    }\n+\n+    let a = OtherThing::One { t: 1i32 };\n+    let b = OtherThing::Two(1i32);\n+}\n+\"#),\n+        @r###\"\n+    100..320 '{     ...32); }': ()\n+    110..111 'x': Thing<!>\n+    114..134 'Thing ...p {} }': Thing<!>\n+    125..132 'loop {}': !\n+    130..132 '{}': ()\n+    144..145 'y': Thing<()>\n+    148..163 'Thing { t: () }': Thing<()>\n+    159..161 '()': ()\n+    173..174 'z': Thing<i32>\n+    177..194 'Thing ...1i32 }': Thing<i32>\n+    188..192 '1i32': i32\n+    200..241 'if let...     }': ()\n+    207..218 'Thing { t }': Thing<i32>\n+    215..216 't': i32\n+    221..222 'z': Thing<i32>\n+    223..241 '{     ...     }': ()\n+    233..234 't': i32\n+    251..252 'a': OtherThing<i32>\n+    255..282 'OtherT...1i32 }': OtherThing<i32>\n+    276..280 '1i32': i32\n+    292..293 'b': OtherThing<i32>\n+    296..311 'OtherThing::Two': Two<i32>(i32) -> OtherThing<i32>\n+    296..317 'OtherT...(1i32)': OtherThing<i32>\n+    312..316 '1i32': i32\n+    \"###\n+    );\n+}"}, {"sha": "e81193a3c30af12e6a06cf0821f8f9e49b239d46", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 132, "deletions": 42, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -10,7 +10,7 @@ use super::{infer, infer_with_mismatches, type_at, type_at_pos};\n fn infer_await() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs crate:main deps:core\n \n struct IntFuture;\n \n@@ -24,7 +24,7 @@ fn test() {\n     v<|>;\n }\n \n-//- /std.rs crate:std\n+//- /core.rs crate:core\n #[prelude_import] use future::*;\n mod future {\n     #[lang = \"future_trait\"]\n@@ -42,7 +42,7 @@ mod future {\n fn infer_async() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs crate:main deps:core\n \n async fn foo() -> u64 {\n     128\n@@ -54,7 +54,7 @@ fn test() {\n     v<|>;\n }\n \n-//- /std.rs crate:std\n+//- /core.rs crate:core\n #[prelude_import] use future::*;\n mod future {\n     #[lang = \"future_trait\"]\n@@ -72,7 +72,7 @@ mod future {\n fn infer_desugar_async() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs crate:main deps:core\n \n async fn foo() -> u64 {\n     128\n@@ -83,7 +83,7 @@ fn test() {\n     r<|>;\n }\n \n-//- /std.rs crate:std\n+//- /core.rs crate:core\n #[prelude_import] use future::*;\n mod future {\n     trait Future {\n@@ -100,15 +100,15 @@ mod future {\n fn infer_try() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs crate:main deps:core\n \n fn test() {\n     let r: Result<i32, u64> = Result::Ok(1);\n     let v = r?;\n     v<|>;\n }\n \n-//- /std.rs crate:std\n+//- /core.rs crate:core\n \n #[prelude_import] use ops::*;\n mod ops {\n@@ -140,9 +140,9 @@ mod result {\n fn infer_for_loop() {\n     let (db, pos) = TestDB::with_position(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs crate:main deps:core,alloc\n \n-use std::collections::Vec;\n+use alloc::collections::Vec;\n \n fn test() {\n     let v = Vec::new();\n@@ -152,7 +152,7 @@ fn test() {\n     }\n }\n \n-//- /std.rs crate:std\n+//- /core.rs crate:core\n \n #[prelude_import] use iter::*;\n mod iter {\n@@ -161,14 +161,16 @@ mod iter {\n     }\n }\n \n+//- /alloc.rs crate:alloc deps:core\n+\n mod collections {\n     struct Vec<T> {}\n     impl<T> Vec<T> {\n         fn new() -> Self { Vec {} }\n         fn push(&mut self, t: T) { }\n     }\n \n-    impl<T> crate::iter::IntoIterator for Vec<T> {\n+    impl<T> IntoIterator for Vec<T> {\n         type Item=T;\n     }\n }\n@@ -1110,7 +1112,6 @@ fn test() {\n }\n \n #[test]\n-#[ignore]\n fn impl_trait() {\n     assert_snapshot!(\n         infer(r#\"\n@@ -1160,6 +1161,95 @@ fn test(x: impl Trait<u64>, y: &impl Trait<u64>) {\n     );\n }\n \n+#[test]\n+fn simple_return_pos_impl_trait() {\n+    mark::check!(lower_rpit);\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+}\n+fn bar() -> impl Trait<u64> { loop {} }\n+\n+fn test() {\n+    let a = bar();\n+    a.foo();\n+}\n+\"#),\n+        @r###\"\n+    30..34 'self': &Self\n+    72..83 '{ loop {} }': !\n+    74..81 'loop {}': !\n+    79..81 '{}': ()\n+    95..130 '{     ...o(); }': ()\n+    105..106 'a': impl Trait<u64>\n+    109..112 'bar': fn bar() -> impl Trait<u64>\n+    109..114 'bar()': impl Trait<u64>\n+    120..121 'a': impl Trait<u64>\n+    120..127 'a.foo()': u64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn more_return_pos_impl_trait() {\n+    assert_snapshot!(\n+        infer(r#\"\n+trait Iterator {\n+    type Item;\n+    fn next(&mut self) -> Self::Item;\n+}\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+}\n+fn bar() -> (impl Iterator<Item = impl Trait<u32>>, impl Trait<u64>) { loop {} }\n+fn baz<T>(t: T) -> (impl Iterator<Item = impl Trait<T>>, impl Trait<T>) { loop {} }\n+\n+fn test() {\n+    let (a, b) = bar();\n+    a.next().foo();\n+    b.foo();\n+    let (c, d) = baz(1u128);\n+    c.next().foo();\n+    d.foo();\n+}\n+\"#),\n+        @r###\"\n+    50..54 'self': &mut Self\n+    102..106 'self': &Self\n+    185..196 '{ loop {} }': ({unknown}, {unknown})\n+    187..194 'loop {}': !\n+    192..194 '{}': ()\n+    207..208 't': T\n+    269..280 '{ loop {} }': ({unknown}, {unknown})\n+    271..278 'loop {}': !\n+    276..278 '{}': ()\n+    292..414 '{     ...o(); }': ()\n+    302..308 '(a, b)': (impl Iterator<Item = impl Trait<u32>>, impl Trait<u64>)\n+    303..304 'a': impl Iterator<Item = impl Trait<u32>>\n+    306..307 'b': impl Trait<u64>\n+    311..314 'bar': fn bar() -> (impl Iterator<Item = impl Trait<u32>>, impl Trait<u64>)\n+    311..316 'bar()': (impl Iterator<Item = impl Trait<u32>>, impl Trait<u64>)\n+    322..323 'a': impl Iterator<Item = impl Trait<u32>>\n+    322..330 'a.next()': impl Trait<u32>\n+    322..336 'a.next().foo()': u32\n+    342..343 'b': impl Trait<u64>\n+    342..349 'b.foo()': u64\n+    359..365 '(c, d)': (impl Iterator<Item = impl Trait<u128>>, impl Trait<u128>)\n+    360..361 'c': impl Iterator<Item = impl Trait<u128>>\n+    363..364 'd': impl Trait<u128>\n+    368..371 'baz': fn baz<u128>(u128) -> (impl Iterator<Item = impl Trait<u128>>, impl Trait<u128>)\n+    368..378 'baz(1u128)': (impl Iterator<Item = impl Trait<u128>>, impl Trait<u128>)\n+    372..377 '1u128': u128\n+    384..385 'c': impl Iterator<Item = impl Trait<u128>>\n+    384..392 'c.next()': impl Trait<u128>\n+    384..398 'c.next().foo()': u128\n+    404..405 'd': impl Trait<u128>\n+    404..411 'd.foo()': u128\n+    \"###\n+    );\n+}\n+\n #[test]\n fn dyn_trait() {\n     assert_snapshot!(\n@@ -1718,33 +1808,33 @@ fn test() {\n }\n \"#),\n         @r###\"\n-65..69 'self': &Self\n-166..170 'self': Self\n-172..176 'args': Args\n-240..244 'self': &Foo\n-255..257 '{}': ()\n-335..336 'f': F\n-355..357 '{}': ()\n-444..690 '{     ...o(); }': ()\n-454..459 'lazy1': Lazy<Foo, fn() -> T>\n-476..485 'Lazy::new': fn new<Foo, fn() -> T>(fn() -> T) -> Lazy<Foo, fn() -> T>\n-476..493 'Lazy::...| Foo)': Lazy<Foo, fn() -> T>\n-486..492 '|| Foo': || -> T\n-489..492 'Foo': Foo\n-503..505 'r1': {unknown}\n-508..513 'lazy1': Lazy<Foo, fn() -> T>\n-508..519 'lazy1.foo()': {unknown}\n-561..576 'make_foo_fn_ptr': fn() -> Foo\n-592..603 'make_foo_fn': fn make_foo_fn() -> Foo\n-613..618 'lazy2': Lazy<Foo, fn() -> T>\n-635..644 'Lazy::new': fn new<Foo, fn() -> T>(fn() -> T) -> Lazy<Foo, fn() -> T>\n-635..661 'Lazy::...n_ptr)': Lazy<Foo, fn() -> T>\n-645..660 'make_foo_fn_ptr': fn() -> Foo\n-671..673 'r2': {unknown}\n-676..681 'lazy2': Lazy<Foo, fn() -> T>\n-676..687 'lazy2.foo()': {unknown}\n-550..552 '{}': ()\n-\"###\n+    65..69 'self': &Self\n+    166..170 'self': Self\n+    172..176 'args': Args\n+    240..244 'self': &Foo\n+    255..257 '{}': ()\n+    335..336 'f': F\n+    355..357 '{}': ()\n+    444..690 '{     ...o(); }': ()\n+    454..459 'lazy1': Lazy<Foo, || -> Foo>\n+    476..485 'Lazy::new': fn new<Foo, || -> Foo>(|| -> Foo) -> Lazy<Foo, || -> Foo>\n+    476..493 'Lazy::...| Foo)': Lazy<Foo, || -> Foo>\n+    486..492 '|| Foo': || -> Foo\n+    489..492 'Foo': Foo\n+    503..505 'r1': usize\n+    508..513 'lazy1': Lazy<Foo, || -> Foo>\n+    508..519 'lazy1.foo()': usize\n+    561..576 'make_foo_fn_ptr': fn() -> Foo\n+    592..603 'make_foo_fn': fn make_foo_fn() -> Foo\n+    613..618 'lazy2': Lazy<Foo, fn() -> Foo>\n+    635..644 'Lazy::new': fn new<Foo, fn() -> Foo>(fn() -> Foo) -> Lazy<Foo, fn() -> Foo>\n+    635..661 'Lazy::...n_ptr)': Lazy<Foo, fn() -> Foo>\n+    645..660 'make_foo_fn_ptr': fn() -> Foo\n+    671..673 'r2': {unknown}\n+    676..681 'lazy2': Lazy<Foo, fn() -> Foo>\n+    676..687 'lazy2.foo()': {unknown}\n+    550..552 '{}': ()\n+    \"###\n     );\n }\n \n@@ -2758,12 +2848,12 @@ fn test() {\n fn integer_range_iterate() {\n     let t = type_at(\n         r#\"\n-//- /main.rs crate:main deps:std\n+//- /main.rs crate:main deps:core\n fn test() {\n     for x in 0..100 { x<|>; }\n }\n \n-//- /std.rs crate:std\n+//- /core.rs crate:core\n pub mod ops {\n     pub struct Range<Idx> {\n         pub start: Idx,"}, {"sha": "a72a82f5a23a49cdfa85555952f389599cad44e1", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -4,7 +4,7 @@ use std::sync::Arc;\n use log::debug;\n \n use chalk_ir::{fold::shift::Shift, GenericArg, TypeName};\n-use chalk_solve::rust_ir::{self, WellKnownTrait};\n+use chalk_solve::rust_ir::{self, OpaqueTyDatumBound, WellKnownTrait};\n \n use hir_def::{\n     lang_item::{lang_attr, LangItemTarget},\n@@ -100,6 +100,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     fn associated_ty_value(&self, id: AssociatedTyValueId) -> Arc<AssociatedTyValue> {\n         self.db.associated_ty_value(self.krate, id)\n     }\n+\n     fn custom_clauses(&self) -> Vec<chalk_ir::ProgramClause<Interner>> {\n         vec![]\n     }\n@@ -130,11 +131,34 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         self.db.program_clauses_for_chalk_env(self.krate, environment.clone())\n     }\n \n-    fn opaque_ty_data(\n-        &self,\n-        _id: chalk_ir::OpaqueTyId<Interner>,\n-    ) -> Arc<rust_ir::OpaqueTyDatum<Interner>> {\n-        unimplemented!()\n+    fn opaque_ty_data(&self, id: chalk_ir::OpaqueTyId<Interner>) -> Arc<OpaqueTyDatum> {\n+        let interned_id = crate::db::InternedOpaqueTyId::from(id);\n+        let full_id = self.db.lookup_intern_impl_trait_id(interned_id);\n+        let (func, idx) = match full_id {\n+            crate::OpaqueTyId::ReturnTypeImplTrait(func, idx) => (func, idx),\n+        };\n+        let datas =\n+            self.db.return_type_impl_traits(func).expect(\"impl trait id without impl traits\");\n+        let data = &datas.value.impl_traits[idx as usize];\n+        let bound = OpaqueTyDatumBound {\n+            bounds: make_binders(\n+                data.bounds\n+                    .value\n+                    .iter()\n+                    .cloned()\n+                    .filter(|b| !b.is_error())\n+                    .map(|b| b.to_chalk(self.db))\n+                    .collect(),\n+                1,\n+            ),\n+        };\n+        let num_vars = datas.num_binders;\n+        Arc::new(OpaqueTyDatum { opaque_ty_id: id, bound: make_binders(bound, num_vars) })\n+    }\n+\n+    fn hidden_opaque_type(&self, _id: chalk_ir::OpaqueTyId<Interner>) -> chalk_ir::Ty<Interner> {\n+        // FIXME: actually provide the hidden type; it is relevant for auto traits\n+        Ty::Unknown.to_chalk(self.db)\n     }\n \n     fn force_impl_for(\n@@ -150,10 +174,6 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         // FIXME: implement actual object safety\n         true\n     }\n-\n-    fn hidden_opaque_type(&self, _id: chalk_ir::OpaqueTyId<Interner>) -> chalk_ir::Ty<Interner> {\n-        Ty::Unknown.to_chalk(self.db)\n-    }\n }\n \n pub(crate) fn program_clauses_for_chalk_env_query(\n@@ -460,6 +480,18 @@ impl From<crate::traits::GlobalImplId> for ImplId {\n     }\n }\n \n+impl From<OpaqueTyId> for crate::db::InternedOpaqueTyId {\n+    fn from(id: OpaqueTyId) -> Self {\n+        InternKey::from_intern_id(id.0)\n+    }\n+}\n+\n+impl From<crate::db::InternedOpaqueTyId> for OpaqueTyId {\n+    fn from(id: crate::db::InternedOpaqueTyId) -> Self {\n+        chalk_ir::OpaqueTyId(id.as_intern_id())\n+    }\n+}\n+\n impl From<rust_ir::AssociatedTyValueId<Interner>> for crate::traits::AssocTyValueId {\n     fn from(id: rust_ir::AssociatedTyValueId<Interner>) -> Self {\n         Self::from_intern_id(id.0)"}, {"sha": "56aab640c85f4667b682971e6a2fbc98369b914f", "filename": "crates/ra_hir_ty/src/traits/chalk/interner.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -22,6 +22,8 @@ pub type AssociatedTyValueId = chalk_solve::rust_ir::AssociatedTyValueId<Interne\n pub type AssociatedTyValue = chalk_solve::rust_ir::AssociatedTyValue<Interner>;\n pub type FnDefId = chalk_ir::FnDefId<Interner>;\n pub type FnDefDatum = chalk_solve::rust_ir::FnDefDatum<Interner>;\n+pub type OpaqueTyId = chalk_ir::OpaqueTyId<Interner>;\n+pub type OpaqueTyDatum = chalk_solve::rust_ir::OpaqueTyDatum<Interner>;\n \n impl chalk_ir::interner::Interner for Interner {\n     type InternedType = Box<chalk_ir::TyData<Self>>; // FIXME use Arc?"}, {"sha": "18e5c9c16fcab27cb86ac1231e62b186b3f6dd58", "filename": "crates/ra_hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 56, "deletions": 18, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -14,10 +14,10 @@ use ra_db::salsa::InternKey;\n \n use crate::{\n     db::HirDatabase,\n-    primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness, Uncertain},\n+    primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness},\n     traits::{builtin, AssocTyValue, Canonical, Impl, Obligation},\n-    ApplicationTy, CallableDef, GenericPredicate, InEnvironment, ProjectionPredicate, ProjectionTy,\n-    Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n+    ApplicationTy, CallableDef, GenericPredicate, InEnvironment, OpaqueTy, OpaqueTyId,\n+    ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeCtor,\n };\n \n use super::interner::*;\n@@ -68,7 +68,16 @@ impl ToChalk for Ty {\n                 let bounded_ty = chalk_ir::DynTy { bounds: make_binders(where_clauses, 1) };\n                 chalk_ir::TyData::Dyn(bounded_ty).intern(&Interner)\n             }\n-            Ty::Opaque(_) | Ty::Unknown => {\n+            Ty::Opaque(opaque_ty) => {\n+                let opaque_ty_id = opaque_ty.opaque_ty_id.to_chalk(db);\n+                let substitution = opaque_ty.parameters.to_chalk(db);\n+                chalk_ir::TyData::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n+                    opaque_ty_id,\n+                    substitution,\n+                }))\n+                .intern(&Interner)\n+            }\n+            Ty::Unknown => {\n                 let substitution = chalk_ir::Substitution::empty(&Interner);\n                 let name = TypeName::Error;\n                 chalk_ir::ApplicationTy { name, substitution }.cast(&Interner).intern(&Interner)\n@@ -98,7 +107,11 @@ impl ToChalk for Ty {\n                 let parameters = from_chalk(db, proj.substitution);\n                 Ty::Projection(ProjectionTy { associated_ty, parameters })\n             }\n-            chalk_ir::TyData::Alias(chalk_ir::AliasTy::Opaque(_)) => unimplemented!(),\n+            chalk_ir::TyData::Alias(chalk_ir::AliasTy::Opaque(opaque_ty)) => {\n+                let impl_trait_id = from_chalk(db, opaque_ty.opaque_ty_id);\n+                let parameters = from_chalk(db, opaque_ty.substitution);\n+                Ty::Opaque(OpaqueTy { opaque_ty_id: impl_trait_id, parameters })\n+            }\n             chalk_ir::TyData::Function(chalk_ir::Fn { num_binders: _, substitution }) => {\n                 let parameters: Substs = from_chalk(db, substitution);\n                 Ty::Apply(ApplicationTy {\n@@ -204,6 +217,21 @@ impl ToChalk for hir_def::TraitId {\n     }\n }\n \n+impl ToChalk for OpaqueTyId {\n+    type Chalk = chalk_ir::OpaqueTyId<Interner>;\n+\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::OpaqueTyId<Interner> {\n+        db.intern_impl_trait_id(self).into()\n+    }\n+\n+    fn from_chalk(\n+        db: &dyn HirDatabase,\n+        opaque_ty_id: chalk_ir::OpaqueTyId<Interner>,\n+    ) -> OpaqueTyId {\n+        db.lookup_intern_impl_trait_id(opaque_ty_id.into())\n+    }\n+}\n+\n impl ToChalk for TypeCtor {\n     type Chalk = TypeName<Interner>;\n \n@@ -214,13 +242,18 @@ impl ToChalk for TypeCtor {\n                 TypeName::AssociatedType(type_id)\n             }\n \n+            TypeCtor::OpaqueType(impl_trait_id) => {\n+                let id = impl_trait_id.to_chalk(db);\n+                TypeName::OpaqueType(id)\n+            }\n+\n             TypeCtor::Bool => TypeName::Scalar(Scalar::Bool),\n             TypeCtor::Char => TypeName::Scalar(Scalar::Char),\n-            TypeCtor::Int(Uncertain::Known(int_ty)) => TypeName::Scalar(int_ty_to_chalk(int_ty)),\n-            TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X32 })) => {\n+            TypeCtor::Int(int_ty) => TypeName::Scalar(int_ty_to_chalk(int_ty)),\n+            TypeCtor::Float(FloatTy { bitness: FloatBitness::X32 }) => {\n                 TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F32))\n             }\n-            TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X64 })) => {\n+            TypeCtor::Float(FloatTy { bitness: FloatBitness::X64 }) => {\n                 TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F64))\n             }\n \n@@ -235,9 +268,7 @@ impl ToChalk for TypeCtor {\n             }\n             TypeCtor::Never => TypeName::Never,\n \n-            TypeCtor::Int(Uncertain::Unknown)\n-            | TypeCtor::Float(Uncertain::Unknown)\n-            | TypeCtor::Adt(_)\n+            TypeCtor::Adt(_)\n             | TypeCtor::Array\n             | TypeCtor::FnPtr { .. }\n             | TypeCtor::Closure { .. } => {\n@@ -252,23 +283,25 @@ impl ToChalk for TypeCtor {\n         match type_name {\n             TypeName::Adt(struct_id) => db.lookup_intern_type_ctor(struct_id.into()),\n             TypeName::AssociatedType(type_id) => TypeCtor::AssociatedType(from_chalk(db, type_id)),\n-            TypeName::OpaqueType(_) => unreachable!(),\n+            TypeName::OpaqueType(opaque_type_id) => {\n+                TypeCtor::OpaqueType(from_chalk(db, opaque_type_id))\n+            }\n \n             TypeName::Scalar(Scalar::Bool) => TypeCtor::Bool,\n             TypeName::Scalar(Scalar::Char) => TypeCtor::Char,\n-            TypeName::Scalar(Scalar::Int(int_ty)) => TypeCtor::Int(Uncertain::Known(IntTy {\n+            TypeName::Scalar(Scalar::Int(int_ty)) => TypeCtor::Int(IntTy {\n                 signedness: Signedness::Signed,\n                 bitness: bitness_from_chalk_int(int_ty),\n-            })),\n-            TypeName::Scalar(Scalar::Uint(uint_ty)) => TypeCtor::Int(Uncertain::Known(IntTy {\n+            }),\n+            TypeName::Scalar(Scalar::Uint(uint_ty)) => TypeCtor::Int(IntTy {\n                 signedness: Signedness::Unsigned,\n                 bitness: bitness_from_chalk_uint(uint_ty),\n-            })),\n+            }),\n             TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F32)) => {\n-                TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X32 }))\n+                TypeCtor::Float(FloatTy { bitness: FloatBitness::X32 })\n             }\n             TypeName::Scalar(Scalar::Float(chalk_ir::FloatTy::F64)) => {\n-                TypeCtor::Float(Uncertain::Known(FloatTy { bitness: FloatBitness::X64 }))\n+                TypeCtor::Float(FloatTy { bitness: FloatBitness::X64 })\n             }\n             TypeName::Tuple(cardinality) => TypeCtor::Tuple { cardinality: cardinality as u16 },\n             TypeName::Raw(mutability) => TypeCtor::RawPtr(from_chalk(db, mutability)),\n@@ -447,6 +480,11 @@ impl ToChalk for GenericPredicate {\n                 let ty = from_chalk(db, projection_eq.ty);\n                 GenericPredicate::Projection(ProjectionPredicate { projection_ty, ty })\n             }\n+\n+            chalk_ir::WhereClause::LifetimeOutlives(_) => {\n+                // we shouldn't get these from Chalk\n+                panic!(\"encountered LifetimeOutlives from Chalk\")\n+            }\n         }\n     }\n }"}, {"sha": "556af70989fe8fe00de104e4e1fb9e78af638c76", "filename": "crates/ra_hir_ty/src/traits/chalk/tls.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -69,6 +69,11 @@ impl DebugContext<'_> {\n                 let name = self.0.type_alias_data(type_alias).name.clone();\n                 write!(f, \"{}::{}\", trait_name, name)?;\n             }\n+            TypeCtor::OpaqueType(opaque_ty_id) => match opaque_ty_id {\n+                crate::OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n+                    write!(f, \"{{impl trait {} of {:?}}}\", idx, func)?;\n+                }\n+            },\n             TypeCtor::Closure { def, expr } => {\n                 write!(f, \"{{closure {:?} in \", expr.into_raw())?;\n                 match def {"}, {"sha": "e1fcf379d76e54829d09c164e0dffe9deff6bcfb", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -126,3 +126,81 @@ pub(crate) fn completions(\n \n     Some(acc)\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::completion_config::CompletionConfig;\n+    use crate::mock_analysis::analysis_and_position;\n+\n+    struct DetailAndDocumentation<'a> {\n+        detail: &'a str,\n+        documentation: &'a str,\n+    }\n+\n+    fn check_detail_and_documentation(fixture: &str, expected: DetailAndDocumentation) {\n+        let (analysis, position) = analysis_and_position(fixture);\n+        let config = CompletionConfig::default();\n+        let completions = analysis.completions(&config, position).unwrap().unwrap();\n+        for item in completions {\n+            if item.detail() == Some(expected.detail) {\n+                let opt = item.documentation();\n+                let doc = opt.as_ref().map(|it| it.as_str());\n+                assert_eq!(doc, Some(expected.documentation));\n+                return;\n+            }\n+        }\n+        panic!(\"completion detail not found: {}\", expected.detail)\n+    }\n+\n+    #[test]\n+    fn test_completion_detail_from_macro_generated_struct_fn_doc_attr() {\n+        check_detail_and_documentation(\n+            r#\"\n+            //- /lib.rs\n+            macro_rules! bar {\n+                () => {\n+                    struct Bar;\n+                    impl Bar {\n+                        #[doc = \"Do the foo\"]\n+                        fn foo(&self) {}\n+                    }\n+                }\n+            }\n+\n+            bar!();\n+\n+            fn foo() {\n+                let bar = Bar;\n+                bar.fo<|>;\n+            }\n+            \"#,\n+            DetailAndDocumentation { detail: \"fn foo(&self)\", documentation: \"Do the foo\" },\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_detail_from_macro_generated_struct_fn_doc_comment() {\n+        check_detail_and_documentation(\n+            r#\"\n+            //- /lib.rs\n+            macro_rules! bar {\n+                () => {\n+                    struct Bar;\n+                    impl Bar {\n+                        /// Do the foo\n+                        fn foo(&self) {}\n+                    }\n+                }\n+            }\n+\n+            bar!();\n+\n+            fn foo() {\n+                let bar = Bar;\n+                bar.fo<|>;\n+            }\n+            \"#,\n+            DetailAndDocumentation { detail: \"fn foo(&self)\", documentation: \" Do the foo\" },\n+        );\n+    }\n+}"}, {"sha": "e1bfd72f96af4d310332b70473b66b01bb2a7d5d", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -21,7 +21,7 @@ use ra_syntax::{\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n \n-use crate::{Diagnostic, FileId, FileSystemEdit, Fix, SourceChange, SourceFileEdit};\n+use crate::{Diagnostic, FileId, FileSystemEdit, Fix, SourceFileEdit};\n \n #[derive(Debug, Copy, Clone)]\n pub enum Severity {\n@@ -115,7 +115,7 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n         let node = d.ast(db);\n         let replacement = format!(\"Ok({})\", node.syntax());\n         let edit = TextEdit::replace(node.syntax().text_range(), replacement);\n-        let source_change = SourceChange::source_file_edit_from(file_id, edit);\n+        let source_change = SourceFileEdit { file_id, edit }.into();\n         let fix = Fix::new(\"Wrap with ok\", source_change);\n         res.borrow_mut().push(Diagnostic {\n             range: sema.diagnostics_range(d).range,\n@@ -187,7 +187,8 @@ fn check_struct_shorthand_initialization(\n         if let (Some(name_ref), Some(expr)) = (record_field.name_ref(), record_field.expr()) {\n             let field_name = name_ref.syntax().text().to_string();\n             let field_expr = expr.syntax().text().to_string();\n-            if field_name == field_expr {\n+            let field_name_is_tup_index = name_ref.as_tuple_field().is_some();\n+            if field_name == field_expr && !field_name_is_tup_index {\n                 let mut edit_builder = TextEditBuilder::default();\n                 edit_builder.delete(record_field.syntax().text_range());\n                 edit_builder.insert(record_field.syntax().text_range().start(), field_name);\n@@ -321,29 +322,26 @@ mod tests {\n     fn test_wrap_return_type() {\n         let before = r#\"\n             //- /main.rs\n-            use std::{string::String, result::Result::{self, Ok, Err}};\n+            use core::result::Result::{self, Ok, Err};\n \n-            fn div(x: i32, y: i32) -> Result<i32, String> {\n+            fn div(x: i32, y: i32) -> Result<i32, ()> {\n                 if y == 0 {\n-                    return Err(\"div by zero\".into());\n+                    return Err(());\n                 }\n                 x / y<|>\n             }\n \n-            //- /std/lib.rs\n-            pub mod string {\n-                pub struct String { }\n-            }\n+            //- /core/lib.rs\n             pub mod result {\n                 pub enum Result<T, E> { Ok(T), Err(E) }\n             }\n         \"#;\n         let after = r#\"\n-            use std::{string::String, result::Result::{self, Ok, Err}};\n+            use core::result::Result::{self, Ok, Err};\n \n-            fn div(x: i32, y: i32) -> Result<i32, String> {\n+            fn div(x: i32, y: i32) -> Result<i32, ()> {\n                 if y == 0 {\n-                    return Err(\"div by zero\".into());\n+                    return Err(());\n                 }\n                 Ok(x / y)\n             }\n@@ -355,7 +353,7 @@ mod tests {\n     fn test_wrap_return_type_handles_generic_functions() {\n         let before = r#\"\n             //- /main.rs\n-            use std::result::Result::{self, Ok, Err};\n+            use core::result::Result::{self, Ok, Err};\n \n             fn div<T>(x: T) -> Result<T, i32> {\n                 if x == 0 {\n@@ -364,13 +362,13 @@ mod tests {\n                 <|>x\n             }\n \n-            //- /std/lib.rs\n+            //- /core/lib.rs\n             pub mod result {\n                 pub enum Result<T, E> { Ok(T), Err(E) }\n             }\n         \"#;\n         let after = r#\"\n-            use std::result::Result::{self, Ok, Err};\n+            use core::result::Result::{self, Ok, Err};\n \n             fn div<T>(x: T) -> Result<T, i32> {\n                 if x == 0 {\n@@ -386,32 +384,29 @@ mod tests {\n     fn test_wrap_return_type_handles_type_aliases() {\n         let before = r#\"\n             //- /main.rs\n-            use std::{string::String, result::Result::{self, Ok, Err}};\n+            use core::result::Result::{self, Ok, Err};\n \n-            type MyResult<T> = Result<T, String>;\n+            type MyResult<T> = Result<T, ()>;\n \n             fn div(x: i32, y: i32) -> MyResult<i32> {\n                 if y == 0 {\n-                    return Err(\"div by zero\".into());\n+                    return Err(());\n                 }\n                 x <|>/ y\n             }\n \n-            //- /std/lib.rs\n-            pub mod string {\n-                pub struct String { }\n-            }\n+            //- /core/lib.rs\n             pub mod result {\n                 pub enum Result<T, E> { Ok(T), Err(E) }\n             }\n         \"#;\n         let after = r#\"\n-            use std::{string::String, result::Result::{self, Ok, Err}};\n+            use core::result::Result::{self, Ok, Err};\n \n-            type MyResult<T> = Result<T, String>;\n+            type MyResult<T> = Result<T, ()>;\n             fn div(x: i32, y: i32) -> MyResult<i32> {\n                 if y == 0 {\n-                    return Err(\"div by zero\".into());\n+                    return Err(());\n                 }\n                 Ok(x / y)\n             }\n@@ -423,16 +418,13 @@ mod tests {\n     fn test_wrap_return_type_not_applicable_when_expr_type_does_not_match_ok_type() {\n         let content = r#\"\n             //- /main.rs\n-            use std::{string::String, result::Result::{self, Ok, Err}};\n+            use core::result::Result::{self, Ok, Err};\n \n-            fn foo() -> Result<String, i32> {\n+            fn foo() -> Result<(), i32> {\n                 0<|>\n             }\n \n-            //- /std/lib.rs\n-            pub mod string {\n-                pub struct String { }\n-            }\n+            //- /core/lib.rs\n             pub mod result {\n                 pub enum Result<T, E> { Ok(T), Err(E) }\n             }\n@@ -444,7 +436,7 @@ mod tests {\n     fn test_wrap_return_type_not_applicable_when_return_type_is_not_result() {\n         let content = r#\"\n             //- /main.rs\n-            use std::{string::String, result::Result::{self, Ok, Err}};\n+            use core::result::Result::{self, Ok, Err};\n \n             enum SomeOtherEnum {\n                 Ok(i32),\n@@ -455,10 +447,7 @@ mod tests {\n                 0<|>\n             }\n \n-            //- /std/lib.rs\n-            pub mod string {\n-                pub struct String { }\n-            }\n+            //- /core/lib.rs\n             pub mod result {\n                 pub enum Result<T, E> { Ok(T), Err(E) }\n             }\n@@ -731,6 +720,18 @@ mod tests {\n         \"#,\n             check_struct_shorthand_initialization,\n         );\n+        check_not_applicable(\n+            r#\"\n+            struct A(usize);\n+\n+            fn main() {\n+                A {\n+                    0: 0\n+                }\n+            }\n+        \"#,\n+            check_struct_shorthand_initialization,\n+        );\n \n         check_apply(\n             r#\""}, {"sha": "ca8a6a650994c38f24da8ec16d9f98fe0d5aad21", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -10,7 +10,7 @@ use std::{\n use hir::{Docs, Documentation, HasSource, HirDisplay};\n use ra_ide_db::RootDatabase;\n use ra_syntax::ast::{self, AstNode, NameOwner, VisibilityOwner};\n-use stdx::SepBy;\n+use stdx::{split1, SepBy};\n \n use crate::display::{generic_parameters, where_predicates};\n \n@@ -207,7 +207,16 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n                     res.push(raw_param);\n                 }\n \n-                res.extend(param_list.params().map(|param| param.syntax().text().to_string()));\n+                // macro-generated functions are missing whitespace\n+                fn fmt_param(param: ast::Param) -> String {\n+                    let text = param.syntax().text().to_string();\n+                    match split1(&text, ':') {\n+                        Some((left, right)) => format!(\"{}: {}\", left.trim(), right.trim()),\n+                        _ => text,\n+                    }\n+                }\n+\n+                res.extend(param_list.params().map(fmt_param));\n                 res_types.extend(param_list.params().map(|param| {\n                     let param_text = param.syntax().text().to_string();\n                     match param_text.split(':').nth(1).and_then(|it| it.get(1..)) {"}, {"sha": "c7bb1e69f8a575765da2aeb9b82d7dbb25904577", "filename": "crates/ra_ide/src/display/navigation_target.rs", "status": "modified", "additions": 23, "deletions": 43, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -92,15 +92,16 @@ impl NavigationTarget {\n         let name = module.name(db).map(|it| it.to_string().into()).unwrap_or_default();\n         if let Some(src) = module.declaration_source(db) {\n             let frange = original_range(db, src.as_ref().map(|it| it.syntax()));\n-            return NavigationTarget::from_syntax(\n+            let mut res = NavigationTarget::from_syntax(\n                 frange.file_id,\n                 name,\n                 None,\n                 frange.range,\n                 src.value.syntax().kind(),\n-                src.value.doc_comment_text(),\n-                src.value.short_label(),\n             );\n+            res.docs = src.value.doc_comment_text();\n+            res.description = src.value.short_label();\n+            return res;\n         }\n         module.to_nav(db)\n     }\n@@ -130,11 +131,9 @@ impl NavigationTarget {\n     }\n \n     /// Allows `NavigationTarget` to be created from a `NameOwner`\n-    fn from_named(\n+    pub(crate) fn from_named(\n         db: &RootDatabase,\n         node: InFile<&dyn ast::NameOwner>,\n-        docs: Option<String>,\n-        description: Option<String>,\n     ) -> NavigationTarget {\n         //FIXME: use `_` instead of empty string\n         let name = node.value.name().map(|it| it.text().clone()).unwrap_or_default();\n@@ -148,8 +147,6 @@ impl NavigationTarget {\n             focus_range,\n             frange.range,\n             node.value.syntax().kind(),\n-            docs,\n-            description,\n         )\n     }\n \n@@ -159,8 +156,6 @@ impl NavigationTarget {\n         focus_range: Option<TextRange>,\n         full_range: TextRange,\n         kind: SyntaxKind,\n-        docs: Option<String>,\n-        description: Option<String>,\n     ) -> NavigationTarget {\n         NavigationTarget {\n             file_id,\n@@ -169,8 +164,8 @@ impl NavigationTarget {\n             full_range,\n             focus_range,\n             container_name: None,\n-            description,\n-            docs,\n+            description: None,\n+            docs: None,\n         }\n     }\n }\n@@ -238,12 +233,11 @@ where\n {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n         let src = self.source(db);\n-        NavigationTarget::from_named(\n-            db,\n-            src.as_ref().map(|it| it as &dyn ast::NameOwner),\n-            src.value.doc_comment_text(),\n-            src.value.short_label(),\n-        )\n+        let mut res =\n+            NavigationTarget::from_named(db, src.as_ref().map(|it| it as &dyn ast::NameOwner));\n+        res.docs = src.value.doc_comment_text();\n+        res.description = src.value.short_label();\n+        res\n     }\n }\n \n@@ -258,15 +252,7 @@ impl ToNav for hir::Module {\n             }\n         };\n         let frange = original_range(db, src.with_value(syntax));\n-        NavigationTarget::from_syntax(\n-            frange.file_id,\n-            name,\n-            focus,\n-            frange.range,\n-            syntax.kind(),\n-            None,\n-            None,\n-        )\n+        NavigationTarget::from_syntax(frange.file_id, name, focus, frange.range, syntax.kind())\n     }\n }\n \n@@ -285,8 +271,6 @@ impl ToNav for hir::ImplDef {\n             None,\n             frange.range,\n             src.value.syntax().kind(),\n-            None,\n-            None,\n         )\n     }\n }\n@@ -296,12 +280,12 @@ impl ToNav for hir::Field {\n         let src = self.source(db);\n \n         match &src.value {\n-            FieldSource::Named(it) => NavigationTarget::from_named(\n-                db,\n-                src.with_value(it),\n-                it.doc_comment_text(),\n-                it.short_label(),\n-            ),\n+            FieldSource::Named(it) => {\n+                let mut res = NavigationTarget::from_named(db, src.with_value(it));\n+                res.docs = it.doc_comment_text();\n+                res.description = it.short_label();\n+                res\n+            }\n             FieldSource::Pos(it) => {\n                 let frange = original_range(db, src.with_value(it.syntax()));\n                 NavigationTarget::from_syntax(\n@@ -310,8 +294,6 @@ impl ToNav for hir::Field {\n                     None,\n                     frange.range,\n                     it.syntax().kind(),\n-                    None,\n-                    None,\n                 )\n             }\n         }\n@@ -322,12 +304,10 @@ impl ToNav for hir::MacroDef {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n         let src = self.source(db);\n         log::debug!(\"nav target {:#?}\", src.value.syntax());\n-        NavigationTarget::from_named(\n-            db,\n-            src.as_ref().map(|it| it as &dyn ast::NameOwner),\n-            src.value.doc_comment_text(),\n-            None,\n-        )\n+        let mut res =\n+            NavigationTarget::from_named(db, src.as_ref().map(|it| it as &dyn ast::NameOwner));\n+        res.docs = src.value.doc_comment_text();\n+        res\n     }\n }\n "}, {"sha": "0798d2c3617044f02b9a902889073af29e320cf6", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,6 +1,6 @@\n use hir::Semantics;\n use ra_ide_db::{\n-    defs::{classify_name, classify_name_ref},\n+    defs::{classify_name, classify_name_ref, NameClass},\n     symbol_index, RootDatabase,\n };\n use ra_syntax::{\n@@ -39,7 +39,10 @@ pub(crate) fn goto_definition(\n                 reference_definition(&sema, &name_ref).to_vec()\n             },\n             ast::Name(name) => {\n-                let def = classify_name(&sema, &name)?.definition();\n+                let def = match classify_name(&sema, &name)? {\n+                    NameClass::Definition(def) | NameClass::ConstReference(def) => def,\n+                    NameClass::FieldShorthand { local: _, field } => field,\n+                };\n                 let nav = def.try_to_nav(sema.db)?;\n                 vec![nav]\n             },\n@@ -886,4 +889,23 @@ mod tests {\n             \"x\",\n         )\n     }\n+\n+    #[test]\n+    fn goto_def_for_enum_variant_field() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            enum Foo {\n+                Bar { x: i32 }\n+            }\n+            fn baz(foo: Foo) {\n+                match foo {\n+                    Foo::Bar { x<|> } => x\n+                };\n+            }\n+            \",\n+            \"x RECORD_FIELD_DEF FileId(1) 21..27 21..22\",\n+            \"x: i32|x\",\n+        );\n+    }\n }"}, {"sha": "ad78b767120c1c34cf4961881372a0a000b1a46c", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 385, "deletions": 26, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,31 +1,64 @@\n use std::iter::once;\n \n use hir::{\n-    Adt, AsAssocItem, AssocItemContainer, FieldSource, HasSource, HirDisplay, ModuleDef,\n-    ModuleSource, Semantics,\n+    Adt, AsAssocItem, AssocItemContainer, Documentation, FieldSource, HasSource, HirDisplay,\n+    ModuleDef, ModuleSource, Semantics,\n };\n use itertools::Itertools;\n use ra_db::SourceDatabase;\n use ra_ide_db::{\n     defs::{classify_name, classify_name_ref, Definition},\n     RootDatabase,\n };\n-use ra_syntax::{\n-    ast::{self, DocCommentsOwner},\n-    match_ast, AstNode,\n-    SyntaxKind::*,\n-    SyntaxToken, TokenAtOffset,\n-};\n+use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset};\n \n use crate::{\n-    display::{macro_label, rust_code_markup, rust_code_markup_with_doc, ShortLabel},\n-    FilePosition, RangeInfo,\n+    display::{macro_label, rust_code_markup, rust_code_markup_with_doc, ShortLabel, ToNav},\n+    runnables::runnable,\n+    FileId, FilePosition, NavigationTarget, RangeInfo, Runnable,\n };\n+use test_utils::mark;\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct HoverConfig {\n+    pub implementations: bool,\n+    pub run: bool,\n+    pub debug: bool,\n+}\n+\n+impl Default for HoverConfig {\n+    fn default() -> Self {\n+        Self { implementations: true, run: true, debug: true }\n+    }\n+}\n+\n+impl HoverConfig {\n+    pub const NO_ACTIONS: Self = Self { implementations: false, run: false, debug: false };\n+\n+    pub fn any(&self) -> bool {\n+        self.implementations || self.runnable()\n+    }\n+\n+    pub fn none(&self) -> bool {\n+        !self.any()\n+    }\n+\n+    pub fn runnable(&self) -> bool {\n+        self.run || self.debug\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub enum HoverAction {\n+    Runnable(Runnable),\n+    Implementaion(FilePosition),\n+}\n \n /// Contains the results when hovering over an item\n #[derive(Debug, Default)]\n pub struct HoverResult {\n     results: Vec<String>,\n+    actions: Vec<HoverAction>,\n }\n \n impl HoverResult {\n@@ -53,10 +86,20 @@ impl HoverResult {\n         &self.results\n     }\n \n+    pub fn actions(&self) -> &[HoverAction] {\n+        &self.actions\n+    }\n+\n+    pub fn push_action(&mut self, action: HoverAction) {\n+        self.actions.push(action);\n+    }\n+\n     /// Returns the results converted into markup\n     /// for displaying in a UI\n+    ///\n+    /// Does not process actions!\n     pub fn to_markup(&self) -> String {\n-        self.results.join(\"\\n\\n---\\n\")\n+        self.results.join(\"\\n\\n___\\n\")\n     }\n }\n \n@@ -87,6 +130,14 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         res.extend(hover_text_from_name_kind(db, name_kind));\n \n         if !res.is_empty() {\n+            if let Some(action) = show_implementations_action(db, name_kind) {\n+                res.push_action(action);\n+            }\n+\n+            if let Some(action) = runnable_action(&sema, name_kind, position.file_id) {\n+                res.push_action(action);\n+            }\n+\n             return Some(RangeInfo::new(range, res));\n         }\n     }\n@@ -117,6 +168,56 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n     Some(RangeInfo::new(range, res))\n }\n \n+fn show_implementations_action(db: &RootDatabase, def: Definition) -> Option<HoverAction> {\n+    fn to_action(nav_target: NavigationTarget) -> HoverAction {\n+        HoverAction::Implementaion(FilePosition {\n+            file_id: nav_target.file_id(),\n+            offset: nav_target.range().start(),\n+        })\n+    }\n+\n+    match def {\n+        Definition::ModuleDef(it) => match it {\n+            ModuleDef::Adt(Adt::Struct(it)) => Some(to_action(it.to_nav(db))),\n+            ModuleDef::Adt(Adt::Union(it)) => Some(to_action(it.to_nav(db))),\n+            ModuleDef::Adt(Adt::Enum(it)) => Some(to_action(it.to_nav(db))),\n+            ModuleDef::Trait(it) => Some(to_action(it.to_nav(db))),\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn runnable_action(\n+    sema: &Semantics<RootDatabase>,\n+    def: Definition,\n+    file_id: FileId,\n+) -> Option<HoverAction> {\n+    match def {\n+        Definition::ModuleDef(it) => match it {\n+            ModuleDef::Module(it) => match it.definition_source(sema.db).value {\n+                ModuleSource::Module(it) => runnable(&sema, it.syntax().clone(), file_id)\n+                    .map(|it| HoverAction::Runnable(it)),\n+                _ => None,\n+            },\n+            ModuleDef::Function(it) => {\n+                let src = it.source(sema.db);\n+                if src.file_id != file_id.into() {\n+                    mark::hit!(hover_macro_generated_struct_fn_doc_comment);\n+                    mark::hit!(hover_macro_generated_struct_fn_doc_attr);\n+\n+                    return None;\n+                }\n+\n+                runnable(&sema, src.value.syntax().clone(), file_id)\n+                    .map(|it| HoverAction::Runnable(it))\n+            }\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+}\n+\n fn hover_text(\n     docs: Option<String>,\n     desc: Option<String>,\n@@ -169,21 +270,24 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<Strin\n     return match def {\n         Definition::Macro(it) => {\n             let src = it.source(db);\n-            hover_text(src.value.doc_comment_text(), Some(macro_label(&src.value)), mod_path)\n+            let docs = Documentation::from_ast(&src.value).map(Into::into);\n+            hover_text(docs, Some(macro_label(&src.value)), mod_path)\n         }\n         Definition::Field(it) => {\n             let src = it.source(db);\n             match src.value {\n                 FieldSource::Named(it) => {\n-                    hover_text(it.doc_comment_text(), it.short_label(), mod_path)\n+                    let docs = Documentation::from_ast(&it).map(Into::into);\n+                    hover_text(docs, it.short_label(), mod_path)\n                 }\n                 _ => None,\n             }\n         }\n         Definition::ModuleDef(it) => match it {\n             ModuleDef::Module(it) => match it.definition_source(db).value {\n                 ModuleSource::Module(it) => {\n-                    hover_text(it.doc_comment_text(), it.short_label(), mod_path)\n+                    let docs = Documentation::from_ast(&it).map(Into::into);\n+                    hover_text(docs, it.short_label(), mod_path)\n                 }\n                 _ => None,\n             },\n@@ -208,10 +312,11 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<Strin\n     fn from_def_source<A, D>(db: &RootDatabase, def: D, mod_path: Option<String>) -> Option<String>\n     where\n         D: HasSource<Ast = A>,\n-        A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel,\n+        A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel + ast::AttrsOwner,\n     {\n         let src = def.source(db);\n-        hover_text(src.value.doc_comment_text(), src.value.short_label(), mod_path)\n+        let docs = Documentation::from_ast(&src.value).map(Into::into);\n+        hover_text(docs, src.value.short_label(), mod_path)\n     }\n }\n \n@@ -229,6 +334,9 @@ fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n \n #[cfg(test)]\n mod tests {\n+    use super::*;\n+    use insta::assert_debug_snapshot;\n+\n     use ra_db::FileLoader;\n     use ra_syntax::TextRange;\n \n@@ -242,7 +350,15 @@ mod tests {\n         s.map(trim_markup)\n     }\n \n-    fn check_hover_result(fixture: &str, expected: &[&str]) -> String {\n+    fn assert_impl_action(action: &HoverAction, position: u32) {\n+        let offset = match action {\n+            HoverAction::Implementaion(pos) => pos.offset,\n+            it => panic!(\"Unexpected hover action: {:#?}\", it),\n+        };\n+        assert_eq!(offset, position.into());\n+    }\n+\n+    fn check_hover_result(fixture: &str, expected: &[&str]) -> (String, Vec<HoverAction>) {\n         let (analysis, position) = analysis_and_position(fixture);\n         let hover = analysis.hover(position).unwrap().unwrap();\n         let mut results = Vec::from(hover.info.results());\n@@ -257,7 +373,7 @@ mod tests {\n         assert_eq!(hover.info.len(), expected.len());\n \n         let content = analysis.db.file_text(position.file_id);\n-        content[hover.range].to_string()\n+        (content[hover.range].to_string(), hover.info.actions().to_vec())\n     }\n \n     fn check_hover_no_result(fixture: &str) {\n@@ -458,7 +574,7 @@ struct Test<K, T = u8> {\n }\n \n fn main() {\n-    let zz<|> = Test { t: 23, k: 33 };\n+    let zz<|> = Test { t: 23u8, k: 33 };\n }\"#,\n             &[\"Test<i32, u8>\"],\n         );\n@@ -747,7 +863,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n \n     #[test]\n     fn test_hover_through_macro() {\n-        let hover_on = check_hover_result(\n+        let (hover_on, _) = check_hover_result(\n             \"\n             //- /lib.rs\n             macro_rules! id {\n@@ -768,7 +884,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n \n     #[test]\n     fn test_hover_through_expr_in_macro() {\n-        let hover_on = check_hover_result(\n+        let (hover_on, _) = check_hover_result(\n             \"\n             //- /lib.rs\n             macro_rules! id {\n@@ -786,7 +902,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n \n     #[test]\n     fn test_hover_through_expr_in_macro_recursive() {\n-        let hover_on = check_hover_result(\n+        let (hover_on, _) = check_hover_result(\n             \"\n             //- /lib.rs\n             macro_rules! id_deep {\n@@ -807,7 +923,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n \n     #[test]\n     fn test_hover_through_func_in_macro_recursive() {\n-        let hover_on = check_hover_result(\n+        let (hover_on, _) = check_hover_result(\n             \"\n             //- /lib.rs\n             macro_rules! id_deep {\n@@ -831,7 +947,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n \n     #[test]\n     fn test_hover_through_literal_string_in_macro() {\n-        let hover_on = check_hover_result(\n+        let (hover_on, _) = check_hover_result(\n             r#\"\n             //- /lib.rs\n             macro_rules! arr {\n@@ -850,7 +966,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n \n     #[test]\n     fn test_hover_through_assert_macro() {\n-        let hover_on = check_hover_result(\n+        let (hover_on, _) = check_hover_result(\n             r#\"\n             //- /lib.rs\n             #[rustc_builtin_macro]\n@@ -926,13 +1042,14 @@ fn func(foo: i32) { if true { <|>foo; }; }\n \n     #[test]\n     fn test_hover_trait_show_qualifiers() {\n-        check_hover_result(\n+        let (_, actions) = check_hover_result(\n             \"\n             //- /lib.rs\n             unsafe trait foo<|>() {}\n             \",\n             &[\"unsafe trait foo\"],\n         );\n+        assert_impl_action(&actions[0], 13);\n     }\n \n     #[test]\n@@ -951,4 +1068,246 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             &[\"mod my\"],\n         );\n     }\n+\n+    #[test]\n+    fn test_hover_struct_doc_comment() {\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+            /// bar docs\n+            struct Bar;\n+\n+            fn foo() {\n+                let bar = Ba<|>r;\n+            }\n+            \"#,\n+            &[\"struct Bar\\n```\\n___\\n\\nbar docs\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_struct_doc_attr() {\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+            #[doc = \"bar docs\"]\n+            struct Bar;\n+\n+            fn foo() {\n+                let bar = Ba<|>r;\n+            }\n+            \"#,\n+            &[\"struct Bar\\n```\\n___\\n\\nbar docs\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_struct_doc_attr_multiple_and_mixed() {\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+            /// bar docs 0\n+            #[doc = \"bar docs 1\"]\n+            #[doc = \"bar docs 2\"]\n+            struct Bar;\n+\n+            fn foo() {\n+                let bar = Ba<|>r;\n+            }\n+            \"#,\n+            &[\"struct Bar\\n```\\n___\\n\\nbar docs 0\\n\\nbar docs 1\\n\\nbar docs 2\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_macro_generated_struct_fn_doc_comment() {\n+        mark::check!(hover_macro_generated_struct_fn_doc_comment);\n+\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+            macro_rules! bar {\n+                () => {\n+                    struct Bar;\n+                    impl Bar {\n+                        /// Do the foo\n+                        fn foo(&self) {}\n+                    }\n+                }\n+            }\n+\n+            bar!();\n+\n+            fn foo() {\n+                let bar = Bar;\n+                bar.fo<|>o();\n+            }\n+            \"#,\n+            &[\"Bar\\n```\\n\\n```rust\\nfn foo(&self)\\n```\\n___\\n\\n Do the foo\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_macro_generated_struct_fn_doc_attr() {\n+        mark::check!(hover_macro_generated_struct_fn_doc_attr);\n+\n+        check_hover_result(\n+            r#\"\n+            //- /lib.rs\n+            macro_rules! bar {\n+                () => {\n+                    struct Bar;\n+                    impl Bar {\n+                        #[doc = \"Do the foo\"]\n+                        fn foo(&self) {}\n+                    }\n+                }\n+            }\n+\n+            bar!();\n+\n+            fn foo() {\n+                let bar = Bar;\n+                bar.fo<|>o();\n+            }\n+            \"#,\n+            &[\"Bar\\n```\\n\\n```rust\\nfn foo(&self)\\n```\\n___\\n\\nDo the foo\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hover_trait_has_impl_action() {\n+        let (_, actions) = check_hover_result(\n+            \"\n+            //- /lib.rs\n+            trait foo<|>() {}\n+            \",\n+            &[\"trait foo\"],\n+        );\n+        assert_impl_action(&actions[0], 6);\n+    }\n+\n+    #[test]\n+    fn test_hover_struct_has_impl_action() {\n+        let (_, actions) = check_hover_result(\n+            \"\n+            //- /lib.rs\n+            struct foo<|>() {}\n+            \",\n+            &[\"struct foo\"],\n+        );\n+        assert_impl_action(&actions[0], 7);\n+    }\n+\n+    #[test]\n+    fn test_hover_union_has_impl_action() {\n+        let (_, actions) = check_hover_result(\n+            \"\n+            //- /lib.rs\n+            union foo<|>() {}\n+            \",\n+            &[\"union foo\"],\n+        );\n+        assert_impl_action(&actions[0], 6);\n+    }\n+\n+    #[test]\n+    fn test_hover_enum_has_impl_action() {\n+        let (_, actions) = check_hover_result(\n+            \"\n+            //- /lib.rs\n+            enum foo<|>() {\n+                A,\n+                B\n+            }\n+            \",\n+            &[\"enum foo\"],\n+        );\n+        assert_impl_action(&actions[0], 5);\n+    }\n+\n+    #[test]\n+    fn test_hover_test_has_action() {\n+        let (_, actions) = check_hover_result(\n+            \"\n+            //- /lib.rs\n+            #[test]\n+            fn foo_<|>test() {}\n+            \",\n+            &[\"fn foo_test()\"],\n+        );\n+        assert_debug_snapshot!(actions,\n+            @r###\"\n+            [\n+                Runnable(\n+                    Runnable {\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                1,\n+                            ),\n+                            full_range: 0..24,\n+                            name: \"foo_test\",\n+                            kind: FN_DEF,\n+                            focus_range: Some(\n+                                11..19,\n+                            ),\n+                            container_name: None,\n+                            description: None,\n+                            docs: None,\n+                        },\n+                        kind: Test {\n+                            test_id: Path(\n+                                \"foo_test\",\n+                            ),\n+                            attr: TestAttr {\n+                                ignore: false,\n+                            },\n+                        },\n+                        cfg_exprs: [],\n+                    },\n+                ),\n+            ]\n+            \"###);\n+    }\n+\n+    #[test]\n+    fn test_hover_test_mod_has_action() {\n+        let (_, actions) = check_hover_result(\n+            \"\n+            //- /lib.rs\n+            mod tests<|> {\n+                #[test]\n+                fn foo_test() {}\n+            }\n+            \",\n+            &[\"mod tests\"],\n+        );\n+        assert_debug_snapshot!(actions,\n+            @r###\"\n+            [\n+                Runnable(\n+                    Runnable {\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                1,\n+                            ),\n+                            full_range: 0..46,\n+                            name: \"tests\",\n+                            kind: MODULE,\n+                            focus_range: Some(\n+                                4..9,\n+                            ),\n+                            container_name: None,\n+                            description: None,\n+                            docs: None,\n+                        },\n+                        kind: TestMod {\n+                            path: \"tests\",\n+                        },\n+                        cfg_exprs: [],\n+                    },\n+                ),\n+            ]\n+            \"###);\n+    }\n }"}, {"sha": "7eb2cef735f49d61f3c91123cd3a260cd669199f", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -149,11 +149,10 @@ fn get_param_name_hints(\n         ast::Expr::MethodCallExpr(expr) => expr.arg_list()?.args(),\n         _ => return None,\n     };\n-    let args_count = args.clone().count();\n \n     let fn_signature = get_fn_signature(sema, &expr)?;\n     let n_params_to_skip =\n-        if fn_signature.has_self_param && fn_signature.parameter_names.len() > args_count {\n+        if fn_signature.has_self_param && matches!(&expr, ast::Expr::MethodCallExpr(_)) {\n             1\n         } else {\n             0\n@@ -416,7 +415,7 @@ struct Test<K, T = u8> {\n }\n \n fn main() {\n-    let zz = Test { t: 23, k: 33 };\n+    let zz = Test { t: 23u8, k: 33 };\n     let zz_ref = &zz;\n }\"#,\n         );\n@@ -429,7 +428,7 @@ fn main() {\n                 label: \"Test<i32>\",\n             },\n             InlayHint {\n-                range: 105..111,\n+                range: 107..113,\n                 kind: TypeHint,\n                 label: \"&Test<i32>\",\n             },"}, {"sha": "28f6867672c034b623db8bcc4d6cd2b941864139", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -66,7 +66,7 @@ pub use crate::{\n     display::{file_structure, FunctionSignature, NavigationTarget, StructureNode},\n     expand_macro::ExpandedMacro,\n     folding_ranges::{Fold, FoldKind},\n-    hover::HoverResult,\n+    hover::{HoverAction, HoverConfig, HoverResult},\n     inlay_hints::{InlayHint, InlayHintsConfig, InlayKind},\n     references::{Declaration, Reference, ReferenceAccess, ReferenceKind, ReferenceSearchResult},\n     runnables::{Runnable, RunnableKind, TestId},\n@@ -77,7 +77,7 @@ pub use crate::{\n };\n \n pub use hir::Documentation;\n-pub use ra_assists::{AssistConfig, AssistId};\n+pub use ra_assists::{Assist, AssistConfig, AssistId, ResolvedAssist};\n pub use ra_db::{\n     Canceled, CrateGraph, CrateId, Edition, FileId, FilePosition, FileRange, SourceRootId,\n };\n@@ -142,14 +142,6 @@ pub struct AnalysisHost {\n     db: RootDatabase,\n }\n \n-#[derive(Debug)]\n-pub struct Assist {\n-    pub id: AssistId,\n-    pub label: String,\n-    pub group_label: Option<String>,\n-    pub source_change: SourceChange,\n-}\n-\n impl AnalysisHost {\n     pub fn new(lru_capacity: Option<usize>) -> AnalysisHost {\n         AnalysisHost { db: RootDatabase::new(lru_capacity) }\n@@ -470,20 +462,23 @@ impl Analysis {\n         self.with_db(|db| completion::completions(db, config, position).map(Into::into))\n     }\n \n-    /// Computes assists (aka code actions aka intentions) for the given\n+    /// Computes resolved assists with source changes for the given position.\n+    pub fn resolved_assists(\n+        &self,\n+        config: &AssistConfig,\n+        frange: FileRange,\n+    ) -> Cancelable<Vec<ResolvedAssist>> {\n+        self.with_db(|db| ra_assists::Assist::resolved(db, config, frange))\n+    }\n+\n+    /// Computes unresolved assists (aka code actions aka intentions) for the given\n     /// position.\n-    pub fn assists(&self, config: &AssistConfig, frange: FileRange) -> Cancelable<Vec<Assist>> {\n-        self.with_db(|db| {\n-            ra_assists::Assist::resolved(db, config, frange)\n-                .into_iter()\n-                .map(|assist| Assist {\n-                    id: assist.assist.id,\n-                    label: assist.assist.label,\n-                    group_label: assist.assist.group.map(|it| it.0),\n-                    source_change: assist.source_change,\n-                })\n-                .collect()\n-        })\n+    pub fn unresolved_assists(\n+        &self,\n+        config: &AssistConfig,\n+        frange: FileRange,\n+    ) -> Cancelable<Vec<Assist>> {\n+        self.with_db(|db| Assist::unresolved(db, config, frange))\n     }\n \n     /// Computes the set of diagnostics for the given file.\n@@ -508,7 +503,7 @@ impl Analysis {\n     ) -> Cancelable<Result<SourceChange, SsrError>> {\n         self.with_db(|db| {\n             let edits = ssr::parse_search_replace(query, parse_only, db)?;\n-            Ok(SourceChange::source_file_edits(edits))\n+            Ok(SourceChange::from(edits))\n         })\n     }\n "}, {"sha": "915d4f4d3b56da932cd6393ce63e3336f1019413", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -171,7 +171,7 @@ fn rename_to_self(db: &RootDatabase, position: FilePosition) -> Option<RangeInfo\n         ),\n     });\n \n-    Some(RangeInfo::new(range, SourceChange::source_file_edits(edits)))\n+    Some(RangeInfo::new(range, SourceChange::from(edits)))\n }\n \n fn text_edit_from_self_param(\n@@ -234,7 +234,7 @@ fn rename_self_to_param(\n     let range = ast::SelfParam::cast(self_token.parent())\n         .map_or(self_token.text_range(), |p| p.syntax().text_range());\n \n-    Some(RangeInfo::new(range, SourceChange::source_file_edits(edits)))\n+    Some(RangeInfo::new(range, SourceChange::from(edits)))\n }\n \n fn rename_reference(\n@@ -253,7 +253,7 @@ fn rename_reference(\n         return None;\n     }\n \n-    Some(RangeInfo::new(range, SourceChange::source_file_edits(edit)))\n+    Some(RangeInfo::new(range, SourceChange::from(edit)))\n }\n \n #[cfg(test)]"}, {"sha": "fc57dc33d78d7af0bd6b1bba2f9b9f048e96b004", "filename": "crates/ra_ide/src/runnables.rs", "status": "modified", "additions": 310, "deletions": 32, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Frunnables.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,39 +1,39 @@\n+use std::fmt;\n+\n use hir::{AsAssocItem, Attrs, HirFileId, InFile, Semantics};\n use itertools::Itertools;\n+use ra_cfg::CfgExpr;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n-    ast::{self, AstNode, AttrsOwner, ModuleItemOwner, NameOwner},\n-    match_ast, SyntaxNode, TextRange,\n+    ast::{self, AstNode, AttrsOwner, DocCommentsOwner, ModuleItemOwner, NameOwner},\n+    match_ast, SyntaxNode,\n };\n \n-use crate::FileId;\n-use ast::DocCommentsOwner;\n-use ra_cfg::CfgExpr;\n-use std::fmt::Display;\n+use crate::{display::ToNav, FileId, NavigationTarget};\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct Runnable {\n-    pub range: TextRange,\n+    pub nav: NavigationTarget,\n     pub kind: RunnableKind,\n     pub cfg_exprs: Vec<CfgExpr>,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub enum TestId {\n     Name(String),\n     Path(String),\n }\n \n-impl Display for TestId {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+impl fmt::Display for TestId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n             TestId::Name(name) => write!(f, \"{}\", name),\n             TestId::Path(path) => write!(f, \"{}\", path),\n         }\n     }\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub enum RunnableKind {\n     Test { test_id: TestId, attr: TestAttr },\n     TestMod { path: String },\n@@ -42,6 +42,42 @@ pub enum RunnableKind {\n     Bin,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n+pub struct RunnableAction {\n+    pub run_title: &'static str,\n+    pub debugee: bool,\n+}\n+\n+const TEST: RunnableAction = RunnableAction { run_title: \"\u25b6\\u{fe0e} Run Test\", debugee: true };\n+const DOCTEST: RunnableAction =\n+    RunnableAction { run_title: \"\u25b6\\u{fe0e} Run Doctest\", debugee: false };\n+const BENCH: RunnableAction = RunnableAction { run_title: \"\u25b6\\u{fe0e} Run Bench\", debugee: true };\n+const BIN: RunnableAction = RunnableAction { run_title: \"\u25b6\\u{fe0e} Run\", debugee: true };\n+\n+impl Runnable {\n+    // test package::module::testname\n+    pub fn label(&self, target: Option<String>) -> String {\n+        match &self.kind {\n+            RunnableKind::Test { test_id, .. } => format!(\"test {}\", test_id),\n+            RunnableKind::TestMod { path } => format!(\"test-mod {}\", path),\n+            RunnableKind::Bench { test_id } => format!(\"bench {}\", test_id),\n+            RunnableKind::DocTest { test_id, .. } => format!(\"doctest {}\", test_id),\n+            RunnableKind::Bin => {\n+                target.map_or_else(|| \"run binary\".to_string(), |t| format!(\"run {}\", t))\n+            }\n+        }\n+    }\n+\n+    pub fn action(&self) -> &'static RunnableAction {\n+        match &self.kind {\n+            RunnableKind::Test { .. } | RunnableKind::TestMod { .. } => &TEST,\n+            RunnableKind::DocTest { .. } => &DOCTEST,\n+            RunnableKind::Bench { .. } => &BENCH,\n+            RunnableKind::Bin => &BIN,\n+        }\n+    }\n+}\n+\n // Feature: Run\n //\n // Shows a popup suggesting to run a test/benchmark/binary **at the current cursor\n@@ -59,7 +95,11 @@ pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n     source_file.syntax().descendants().filter_map(|i| runnable(&sema, i, file_id)).collect()\n }\n \n-fn runnable(sema: &Semantics<RootDatabase>, item: SyntaxNode, file_id: FileId) -> Option<Runnable> {\n+pub(crate) fn runnable(\n+    sema: &Semantics<RootDatabase>,\n+    item: SyntaxNode,\n+    file_id: FileId,\n+) -> Option<Runnable> {\n     match_ast! {\n         match item {\n             ast::FnDef(it) => runnable_fn(sema, it, file_id),\n@@ -131,10 +171,11 @@ fn runnable_fn(\n     let cfg_exprs =\n         attrs.by_key(\"cfg\").tt_values().map(|subtree| ra_cfg::parse_cfg(subtree)).collect();\n \n-    Some(Runnable { range: fn_def.syntax().text_range(), kind, cfg_exprs })\n+    let nav = NavigationTarget::from_named(sema.db, InFile::new(file_id.into(), &fn_def));\n+    Some(Runnable { nav, kind, cfg_exprs })\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Copy, Clone)]\n pub struct TestAttr {\n     pub ignore: bool,\n }\n@@ -183,7 +224,6 @@ fn runnable_mod(\n     if !has_test_function {\n         return None;\n     }\n-    let range = module.syntax().text_range();\n     let module_def = sema.to_def(&module)?;\n \n     let path = module_def\n@@ -197,7 +237,8 @@ fn runnable_mod(\n     let cfg_exprs =\n         attrs.by_key(\"cfg\").tt_values().map(|subtree| ra_cfg::parse_cfg(subtree)).collect();\n \n-    Some(Runnable { range, kind: RunnableKind::TestMod { path }, cfg_exprs })\n+    let nav = module_def.to_nav(sema.db);\n+    Some(Runnable { nav, kind: RunnableKind::TestMod { path }, cfg_exprs })\n }\n \n #[cfg(test)]\n@@ -206,6 +247,15 @@ mod tests {\n \n     use crate::mock_analysis::analysis_and_position;\n \n+    use super::{Runnable, RunnableAction, BENCH, BIN, DOCTEST, TEST};\n+\n+    fn assert_actions(runnables: &[Runnable], actions: &[&RunnableAction]) {\n+        assert_eq!(\n+            actions,\n+            runnables.into_iter().map(|it| it.action()).collect::<Vec<_>>().as_slice()\n+        );\n+    }\n+\n     #[test]\n     fn test_runnables() {\n         let (analysis, pos) = analysis_and_position(\n@@ -220,19 +270,48 @@ mod tests {\n         #[test]\n         #[ignore]\n         fn test_foo() {}\n+\n+        #[bench]\n+        fn bench() {}\n         \"#,\n         );\n         let runnables = analysis.runnables(pos.file_id).unwrap();\n         assert_debug_snapshot!(&runnables,\n         @r###\"\n         [\n             Runnable {\n-                range: 1..21,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 1..21,\n+                    name: \"main\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        12..16,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Bin,\n                 cfg_exprs: [],\n             },\n             Runnable {\n-                range: 22..46,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 22..46,\n+                    name: \"test_foo\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        33..41,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Test {\n                     test_id: Path(\n                         \"test_foo\",\n@@ -244,7 +323,20 @@ mod tests {\n                 cfg_exprs: [],\n             },\n             Runnable {\n-                range: 47..81,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 47..81,\n+                    name: \"test_foo\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        68..76,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Test {\n                     test_id: Path(\n                         \"test_foo\",\n@@ -255,9 +347,32 @@ mod tests {\n                 },\n                 cfg_exprs: [],\n             },\n+            Runnable {\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 82..104,\n+                    name: \"bench\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        94..99,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n+                kind: Bench {\n+                    test_id: Path(\n+                        \"bench\",\n+                    ),\n+                },\n+                cfg_exprs: [],\n+            },\n         ]\n         \"###\n                 );\n+        assert_actions(&runnables, &[&BIN, &TEST, &TEST, &BENCH]);\n     }\n \n     #[test]\n@@ -279,12 +394,38 @@ mod tests {\n         @r###\"\n         [\n             Runnable {\n-                range: 1..21,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 1..21,\n+                    name: \"main\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        12..16,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Bin,\n                 cfg_exprs: [],\n             },\n             Runnable {\n-                range: 22..64,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 22..64,\n+                    name: \"foo\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        56..59,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: DocTest {\n                     test_id: Path(\n                         \"foo\",\n@@ -295,6 +436,7 @@ mod tests {\n         ]\n         \"###\n                 );\n+        assert_actions(&runnables, &[&BIN, &DOCTEST]);\n     }\n \n     #[test]\n@@ -319,12 +461,38 @@ mod tests {\n         @r###\"\n         [\n             Runnable {\n-                range: 1..21,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 1..21,\n+                    name: \"main\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        12..16,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Bin,\n                 cfg_exprs: [],\n             },\n             Runnable {\n-                range: 51..105,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 51..105,\n+                    name: \"foo\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        97..100,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: DocTest {\n                     test_id: Path(\n                         \"Data::foo\",\n@@ -335,6 +503,7 @@ mod tests {\n         ]\n         \"###\n                 );\n+        assert_actions(&runnables, &[&BIN, &DOCTEST]);\n     }\n \n     #[test]\n@@ -354,14 +523,40 @@ mod tests {\n         @r###\"\n         [\n             Runnable {\n-                range: 1..59,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 1..59,\n+                    name: \"test_mod\",\n+                    kind: MODULE,\n+                    focus_range: Some(\n+                        13..21,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: TestMod {\n                     path: \"test_mod\",\n                 },\n                 cfg_exprs: [],\n             },\n             Runnable {\n-                range: 28..57,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 28..57,\n+                    name: \"test_foo1\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        43..52,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Test {\n                     test_id: Path(\n                         \"test_mod::test_foo1\",\n@@ -375,6 +570,7 @@ mod tests {\n         ]\n         \"###\n                 );\n+        assert_actions(&runnables, &[&TEST, &TEST]);\n     }\n \n     #[test]\n@@ -396,14 +592,40 @@ mod tests {\n         @r###\"\n         [\n             Runnable {\n-                range: 23..85,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 23..85,\n+                    name: \"test_mod\",\n+                    kind: MODULE,\n+                    focus_range: Some(\n+                        27..35,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: TestMod {\n                     path: \"foo::test_mod\",\n                 },\n                 cfg_exprs: [],\n             },\n             Runnable {\n-                range: 46..79,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 46..79,\n+                    name: \"test_foo1\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        65..74,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Test {\n                     test_id: Path(\n                         \"foo::test_mod::test_foo1\",\n@@ -417,6 +639,7 @@ mod tests {\n         ]\n         \"###\n                 );\n+        assert_actions(&runnables, &[&TEST, &TEST]);\n     }\n \n     #[test]\n@@ -440,14 +663,40 @@ mod tests {\n         @r###\"\n         [\n             Runnable {\n-                range: 41..115,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 41..115,\n+                    name: \"test_mod\",\n+                    kind: MODULE,\n+                    focus_range: Some(\n+                        45..53,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: TestMod {\n                     path: \"foo::bar::test_mod\",\n                 },\n                 cfg_exprs: [],\n             },\n             Runnable {\n-                range: 68..105,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 68..105,\n+                    name: \"test_foo1\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        91..100,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Test {\n                     test_id: Path(\n                         \"foo::bar::test_mod::test_foo1\",\n@@ -461,6 +710,7 @@ mod tests {\n         ]\n         \"###\n                 );\n+        assert_actions(&runnables, &[&TEST, &TEST]);\n     }\n \n     #[test]\n@@ -479,7 +729,20 @@ mod tests {\n         @r###\"\n         [\n             Runnable {\n-                range: 1..58,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 1..58,\n+                    name: \"test_foo1\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        44..53,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Test {\n                     test_id: Path(\n                         \"test_foo1\",\n@@ -498,6 +761,7 @@ mod tests {\n         ]\n         \"###\n                 );\n+        assert_actions(&runnables, &[&TEST]);\n     }\n \n     #[test]\n@@ -516,7 +780,20 @@ mod tests {\n         @r###\"\n         [\n             Runnable {\n-                range: 1..80,\n+                nav: NavigationTarget {\n+                    file_id: FileId(\n+                        1,\n+                    ),\n+                    full_range: 1..80,\n+                    name: \"test_foo1\",\n+                    kind: FN_DEF,\n+                    focus_range: Some(\n+                        66..75,\n+                    ),\n+                    container_name: None,\n+                    description: None,\n+                    docs: None,\n+                },\n                 kind: Test {\n                     test_id: Path(\n                         \"test_foo1\",\n@@ -543,6 +820,7 @@ mod tests {\n         ]\n         \"###\n                 );\n+        assert_actions(&runnables, &[&TEST]);\n     }\n \n     #[test]"}, {"sha": "0ae8c7efcd6b249eb26ac34c5b54543994414d1a", "filename": "crates/ra_ide/src/snapshots/highlight_doctest.html", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_doctest.html", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_doctest.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_doctest.html?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,71 @@\n+\n+<style>\n+body                { margin: 0; }\n+pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n+\n+.lifetime           { color: #DFAF8F; font-style: italic; }\n+.comment            { color: #7F9F7F; }\n+.struct, .enum      { color: #7CB8BB; }\n+.enum_variant       { color: #BDE0F3; }\n+.string_literal     { color: #CC9393; }\n+.field              { color: #94BFF3; }\n+.function           { color: #93E0E3; }\n+.function.unsafe    { color: #BC8383; }\n+.operator.unsafe    { color: #BC8383; }\n+.parameter          { color: #94BFF3; }\n+.text               { color: #DCDCCC; }\n+.type               { color: #7CB8BB; }\n+.builtin_type       { color: #8CD0D3; }\n+.type_param         { color: #DFAF8F; }\n+.attribute          { color: #94BFF3; }\n+.numeric_literal    { color: #BFEBBF; }\n+.bool_literal       { color: #BFE6EB; }\n+.macro              { color: #94BFF3; }\n+.module             { color: #AFD8AF; }\n+.variable           { color: #DCDCCC; }\n+.format_specifier   { color: #CC696B; }\n+.mutable            { text-decoration: underline; }\n+\n+.keyword            { color: #F0DFAF; font-weight: bold; }\n+.keyword.unsafe     { color: #BC8383; font-weight: bold; }\n+.control            { font-style: italic; }\n+</style>\n+<pre><code><span class=\"keyword\">impl</span> <span class=\"unresolved_reference\">Foo</span> {\n+    <span class=\"comment\">/// Constructs a new `Foo`.</span>\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// # Examples</span>\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// ```</span>\n+    <span class=\"comment\">/// #</span> <span class=\"attribute\">#![</span><span class=\"function attribute\">allow</span><span class=\"attribute\">(unused_mut)]</span>\n+    <span class=\"comment\">/// </span><span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable declaration mutable\">foo</span>: <span class=\"unresolved_reference\">Foo</span> = <span class=\"unresolved_reference\">Foo</span>::<span class=\"unresolved_reference\">new</span>();\n+    <span class=\"comment\">/// ```</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">const</span> <span class=\"keyword\">fn</span> <span class=\"function declaration\">new</span>() -&gt; <span class=\"unresolved_reference\">Foo</span> {\n+        <span class=\"unresolved_reference\">Foo</span> { }\n+    }\n+\n+    <span class=\"comment\">/// `bar` method on `Foo`.</span>\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// # Examples</span>\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// ```</span>\n+    <span class=\"comment\">/// </span><span class=\"keyword\">let</span> <span class=\"variable declaration\">foo</span> = <span class=\"unresolved_reference\">Foo</span>::<span class=\"unresolved_reference\">new</span>();\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// </span><span class=\"comment\">// calls bar on foo</span>\n+    <span class=\"comment\">/// </span><span class=\"macro\">assert!</span>(foo.bar());\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// </span><span class=\"comment\">/* multi-line\n+    </span><span class=\"comment\">/// </span><span class=\"comment\">       comment */</span>\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// </span><span class=\"keyword\">let</span> <span class=\"variable declaration\">multi_line_string</span> = <span class=\"string_literal\">\"Foo\n+    </span><span class=\"comment\">/// </span><span class=\"string_literal\">  bar\n+    </span><span class=\"comment\">/// </span><span class=\"string_literal\">         \"</span>;\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// ```</span>\n+    <span class=\"comment\">///</span>\n+    <span class=\"comment\">/// ```</span>\n+    <span class=\"comment\">/// </span><span class=\"keyword\">let</span> <span class=\"variable declaration\">foobar</span> = <span class=\"unresolved_reference\">Foo</span>::<span class=\"unresolved_reference\">new</span>().<span class=\"unresolved_reference\">bar</span>();\n+    <span class=\"comment\">/// ```</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">fn</span> <span class=\"function declaration\">foo</span>(&<span class=\"self_keyword\">self</span>) -&gt; <span class=\"builtin_type\">bool</span> {\n+        <span class=\"bool_literal\">true</span>\n+    }\n+}</code></pre>\n\\ No newline at end of file"}, {"sha": "dec06eb518f5d520c8650647f381025695017750", "filename": "crates/ra_ide/src/snapshots/highlight_injection.html", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_injection.html", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_injection.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_injection.html?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -10,6 +10,8 @@\n .string_literal     { color: #CC9393; }\n .field              { color: #94BFF3; }\n .function           { color: #93E0E3; }\n+.function.unsafe    { color: #BC8383; }\n+.operator.unsafe    { color: #BC8383; }\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }"}, {"sha": "849eb3b7349ba13e1fc4a8990a354f37caa7ff6a", "filename": "crates/ra_ide/src/snapshots/highlight_strings.html", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -10,6 +10,8 @@\n .string_literal     { color: #CC9393; }\n .field              { color: #94BFF3; }\n .function           { color: #93E0E3; }\n+.function.unsafe    { color: #BC8383; }\n+.operator.unsafe    { color: #BC8383; }\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }\n@@ -52,6 +54,7 @@\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"format_specifier\">{</span><span class=\"variable\">argument</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">\"</span>, argument = <span class=\"string_literal\">\"test\"</span>);   <span class=\"comment\">// =&gt; \"test\"</span>\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"format_specifier\">{</span><span class=\"variable\">name</span><span class=\"format_specifier\">}</span><span class=\"string_literal\"> </span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">\"</span>, <span class=\"numeric_literal\">1</span>, name = <span class=\"numeric_literal\">2</span>);          <span class=\"comment\">// =&gt; \"2 1\"</span>\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"format_specifier\">{</span><span class=\"variable\">a</span><span class=\"format_specifier\">}</span><span class=\"string_literal\"> </span><span class=\"format_specifier\">{</span><span class=\"variable\">c</span><span class=\"format_specifier\">}</span><span class=\"string_literal\"> </span><span class=\"format_specifier\">{</span><span class=\"variable\">b</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">\"</span>, a=<span class=\"string_literal\">\"a\"</span>, b=<span class=\"char_literal\">'b'</span>, c=<span class=\"numeric_literal\">3</span>);  <span class=\"comment\">// =&gt; \"a 3 b\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"{{</span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">}}\"</span>, <span class=\"numeric_literal\">2</span>);                       <span class=\"comment\">// =&gt; \"{2}\"</span>\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">:</span><span class=\"numeric_literal\">5</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>);\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">:</span><span class=\"numeric_literal\">1</span><span class=\"format_specifier\">$</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>, <span class=\"numeric_literal\">5</span>);\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"format_specifier\">{</span><span class=\"numeric_literal\">1</span><span class=\"format_specifier\">:</span><span class=\"numeric_literal\">0</span><span class=\"format_specifier\">$</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"numeric_literal\">5</span>, <span class=\"string_literal\">\"x\"</span>);\n@@ -61,7 +64,7 @@\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">:</span><span class=\"format_specifier\">^</span><span class=\"numeric_literal\">5</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>);\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">:</span><span class=\"format_specifier\">&gt;</span><span class=\"numeric_literal\">5</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>);\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">:</span><span class=\"format_specifier\">+</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"numeric_literal\">5</span>);\n-    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">:</span><span class=\"format_specifier\">#</span><span class=\"variable\">x</span><span class=\"string_literal\">}!\"</span>, <span class=\"numeric_literal\">27</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">:</span><span class=\"format_specifier\">#</span><span class=\"variable\">x</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"numeric_literal\">27</span>);\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">:</span><span class=\"numeric_literal\">0</span><span class=\"numeric_literal\">5</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"numeric_literal\">5</span>);\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">:</span><span class=\"numeric_literal\">0</span><span class=\"numeric_literal\">5</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">!\"</span>, -<span class=\"numeric_literal\">5</span>);\n     <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">:</span><span class=\"format_specifier\">#</span><span class=\"numeric_literal\">0</span><span class=\"numeric_literal\">10</span><span class=\"variable\">x</span><span class=\"format_specifier\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"numeric_literal\">27</span>);"}, {"sha": "bd24e6e381efddea512a0247dc8fca59d4665288", "filename": "crates/ra_ide/src/snapshots/highlight_unsafe.html", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_unsafe.html", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_unsafe.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_unsafe.html?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,49 @@\n+\n+<style>\n+body                { margin: 0; }\n+pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n+\n+.lifetime           { color: #DFAF8F; font-style: italic; }\n+.comment            { color: #7F9F7F; }\n+.struct, .enum      { color: #7CB8BB; }\n+.enum_variant       { color: #BDE0F3; }\n+.string_literal     { color: #CC9393; }\n+.field              { color: #94BFF3; }\n+.function           { color: #93E0E3; }\n+.function.unsafe    { color: #BC8383; }\n+.operator.unsafe    { color: #BC8383; }\n+.parameter          { color: #94BFF3; }\n+.text               { color: #DCDCCC; }\n+.type               { color: #7CB8BB; }\n+.builtin_type       { color: #8CD0D3; }\n+.type_param         { color: #DFAF8F; }\n+.attribute          { color: #94BFF3; }\n+.numeric_literal    { color: #BFEBBF; }\n+.bool_literal       { color: #BFE6EB; }\n+.macro              { color: #94BFF3; }\n+.module             { color: #AFD8AF; }\n+.variable           { color: #DCDCCC; }\n+.format_specifier   { color: #CC696B; }\n+.mutable            { text-decoration: underline; }\n+\n+.keyword            { color: #F0DFAF; font-weight: bold; }\n+.keyword.unsafe     { color: #BC8383; font-weight: bold; }\n+.control            { font-style: italic; }\n+</style>\n+<pre><code><span class=\"keyword unsafe\">unsafe</span> <span class=\"keyword\">fn</span> <span class=\"function declaration unsafe\">unsafe_fn</span>() {}\n+\n+<span class=\"keyword\">struct</span> <span class=\"struct declaration\">HasUnsafeFn</span>;\n+\n+<span class=\"keyword\">impl</span> <span class=\"struct\">HasUnsafeFn</span> {\n+    <span class=\"keyword unsafe\">unsafe</span> <span class=\"keyword\">fn</span> <span class=\"function declaration unsafe\">unsafe_method</span>(&<span class=\"self_keyword\">self</span>) {}\n+}\n+\n+<span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span>() {\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">x</span> = &<span class=\"numeric_literal\">5</span> <span class=\"keyword\">as</span> *<span class=\"keyword\">const</span> <span class=\"builtin_type\">usize</span>;\n+    <span class=\"keyword unsafe\">unsafe</span> {\n+        <span class=\"function unsafe\">unsafe_fn</span>();\n+        <span class=\"struct\">HasUnsafeFn</span>.<span class=\"function unsafe\">unsafe_method</span>();\n+        <span class=\"keyword\">let</span> <span class=\"variable declaration\">y</span> = <span class=\"operator unsafe\">*</span>(<span class=\"variable\">x</span>);\n+        <span class=\"keyword\">let</span> <span class=\"variable declaration\">z</span> = -<span class=\"variable\">x</span>;\n+    }\n+}</code></pre>\n\\ No newline at end of file"}, {"sha": "33548d43ccd581921f4ebb8deb04d44751f35eba", "filename": "crates/ra_ide/src/snapshots/highlighting.html", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlighting.html?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -10,6 +10,8 @@\n .string_literal     { color: #CC9393; }\n .field              { color: #94BFF3; }\n .function           { color: #93E0E3; }\n+.function.unsafe    { color: #BC8383; }\n+.operator.unsafe    { color: #BC8383; }\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }\n@@ -82,7 +84,9 @@\n     <span class=\"keyword\">let</span> <span class=\"variable declaration mutable\">y</span> = &<span class=\"keyword\">mut</span> <span class=\"variable mutable\">x</span>;\n     <span class=\"keyword\">let</span> <span class=\"variable declaration\">z</span> = &<span class=\"variable mutable\">y</span>;\n \n-    <span class=\"variable mutable\">y</span>;\n+    <span class=\"keyword\">let</span> <span class=\"struct\">Foo</span> { <span class=\"field\">x</span>: <span class=\"variable declaration\">z</span>, <span class=\"field\">y</span> } = <span class=\"struct\">Foo</span> { <span class=\"field\">x</span>: <span class=\"variable\">z</span>, <span class=\"field\">y</span> };\n+\n+    <span class=\"variable\">y</span>;\n }\n \n <span class=\"keyword\">enum</span> <span class=\"enum declaration\">Option</span>&lt;<span class=\"type_param declaration\">T</span>&gt; {"}, {"sha": "1ab06182c040f589a99011cde9397e7fdb06fd46", "filename": "crates/ra_ide/src/snapshots/rainbow_highlighting.html", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Frainbow_highlighting.html?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -10,6 +10,8 @@\n .string_literal     { color: #CC9393; }\n .field              { color: #94BFF3; }\n .function           { color: #93E0E3; }\n+.function.unsafe    { color: #BC8383; }\n+.operator.unsafe    { color: #BC8383; }\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }"}, {"sha": "ab45c364a81f56f2f5a6f9c46ea6223ac800cf28", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 101, "deletions": 47, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,5 +1,6 @@\n mod tags;\n mod html;\n+mod injection;\n #[cfg(test)]\n mod tests;\n \n@@ -10,14 +11,14 @@ use ra_ide_db::{\n };\n use ra_prof::profile;\n use ra_syntax::{\n-    ast::{self, HasFormatSpecifier, HasQuotes, HasStringValue},\n+    ast::{self, HasFormatSpecifier},\n     AstNode, AstToken, Direction, NodeOrToken, SyntaxElement,\n     SyntaxKind::*,\n-    SyntaxToken, TextRange, WalkEvent, T,\n+    TextRange, WalkEvent, T,\n };\n use rustc_hash::FxHashMap;\n \n-use crate::{call_info::ActiveParameter, Analysis, FileId};\n+use crate::FileId;\n \n use ast::FormatSpecifier;\n pub(crate) use html::highlight_as_html;\n@@ -123,6 +124,23 @@ pub(crate) fn highlight(\n             _ => (),\n         }\n \n+        // Check for Rust code in documentation\n+        match &event {\n+            WalkEvent::Leave(NodeOrToken::Node(node)) => {\n+                if let Some((doctest, range_mapping, new_comments)) =\n+                    injection::extract_doc_comments(node)\n+                {\n+                    injection::highlight_doc_comment(\n+                        doctest,\n+                        range_mapping,\n+                        new_comments,\n+                        &mut stack,\n+                    );\n+                }\n+            }\n+            _ => (),\n+        }\n+\n         let element = match event {\n             WalkEvent::Enter(it) => it,\n             WalkEvent::Leave(_) => continue,\n@@ -173,7 +191,7 @@ pub(crate) fn highlight(\n \n         if let Some(token) = element.as_token().cloned().and_then(ast::RawString::cast) {\n             let expanded = element_to_highlight.as_token().unwrap().clone();\n-            if highlight_injection(&mut stack, &sema, token, expanded).is_some() {\n+            if injection::highlight_injection(&mut stack, &sema, token, expanded).is_some() {\n                 continue;\n             }\n         }\n@@ -259,9 +277,8 @@ impl HighlightedRangeStack {\n             let mut parent = prev.pop().unwrap();\n             for ele in children {\n                 assert!(parent.range.contains_range(ele.range));\n-                let mut cloned = parent.clone();\n-                parent.range = TextRange::new(parent.range.start(), ele.range.start());\n-                cloned.range = TextRange::new(ele.range.end(), cloned.range.end());\n+\n+                let cloned = Self::intersect(&mut parent, &ele);\n                 if !parent.range.is_empty() {\n                     prev.push(parent);\n                 }\n@@ -274,6 +291,62 @@ impl HighlightedRangeStack {\n         }\n     }\n \n+    /// Intersects the `HighlightedRange` `parent` with `child`.\n+    /// `parent` is mutated in place, becoming the range before `child`.\n+    /// Returns the range (of the same type as `parent`) *after* `child`.\n+    fn intersect(parent: &mut HighlightedRange, child: &HighlightedRange) -> HighlightedRange {\n+        assert!(parent.range.contains_range(child.range));\n+\n+        let mut cloned = parent.clone();\n+        parent.range = TextRange::new(parent.range.start(), child.range.start());\n+        cloned.range = TextRange::new(child.range.end(), cloned.range.end());\n+\n+        cloned\n+    }\n+\n+    /// Similar to `pop`, but can modify arbitrary prior ranges (where `pop`)\n+    /// can only modify the last range currently on the stack.\n+    /// Can be used to do injections that span multiple ranges, like the\n+    /// doctest injection below.\n+    /// If `delete` is set to true, the parent range is deleted instead of\n+    /// intersected.\n+    ///\n+    /// Note that `pop` can be simulated by `pop_and_inject(false)` but the\n+    /// latter is computationally more expensive.\n+    fn pop_and_inject(&mut self, delete: bool) {\n+        let mut children = self.stack.pop().unwrap();\n+        let prev = self.stack.last_mut().unwrap();\n+        children.sort_by_key(|range| range.range.start());\n+        prev.sort_by_key(|range| range.range.start());\n+\n+        for child in children {\n+            if let Some(idx) =\n+                prev.iter().position(|parent| parent.range.contains_range(child.range))\n+            {\n+                let cloned = Self::intersect(&mut prev[idx], &child);\n+                let insert_idx = if delete || prev[idx].range.is_empty() {\n+                    prev.remove(idx);\n+                    idx\n+                } else {\n+                    idx + 1\n+                };\n+                prev.insert(insert_idx, child);\n+                if !delete && !cloned.range.is_empty() {\n+                    prev.insert(insert_idx + 1, cloned);\n+                }\n+            } else if let Some(_idx) =\n+                prev.iter().position(|parent| parent.range.contains(child.range.start()))\n+            {\n+                unreachable!(\"child range should be completely contained in parent range\");\n+            } else {\n+                let idx = prev\n+                    .binary_search_by_key(&child.range.start(), |range| range.range.start())\n+                    .unwrap_or_else(|x| x);\n+                prev.insert(idx, child);\n+            }\n+        }\n+    }\n+\n     fn add(&mut self, range: HighlightedRange) {\n         self.stack\n             .last_mut()\n@@ -363,6 +436,7 @@ fn highlight_element(\n                     highlight_name(db, def) | HighlightModifier::Definition\n                 }\n                 Some(NameClass::ConstReference(def)) => highlight_name(db, def),\n+                Some(NameClass::FieldShorthand { .. }) => HighlightTag::Field.into(),\n                 None => highlight_name_by_syntax(name) | HighlightModifier::Definition,\n             }\n         }\n@@ -406,6 +480,19 @@ fn highlight_element(\n                 _ => h,\n             }\n         }\n+        T![*] => {\n+            let prefix_expr = element.parent().and_then(ast::PrefixExpr::cast)?;\n+\n+            let expr = prefix_expr.expr()?;\n+            let ty = sema.type_of_expr(&expr)?;\n+            if !ty.is_raw_ptr() {\n+                return None;\n+            }\n+\n+            let mut h = Highlight::new(HighlightTag::Operator);\n+            h |= HighlightModifier::Unsafe;\n+            h\n+        }\n \n         k if k.is_keyword() => {\n             let h = Highlight::new(HighlightTag::Keyword);\n@@ -458,7 +545,13 @@ fn highlight_name(db: &RootDatabase, def: Definition) -> Highlight {\n         Definition::Field(_) => HighlightTag::Field,\n         Definition::ModuleDef(def) => match def {\n             hir::ModuleDef::Module(_) => HighlightTag::Module,\n-            hir::ModuleDef::Function(_) => HighlightTag::Function,\n+            hir::ModuleDef::Function(func) => {\n+                let mut h = HighlightTag::Function.into();\n+                if func.is_unsafe(db) {\n+                    h |= HighlightModifier::Unsafe;\n+                }\n+                return h;\n+            }\n             hir::ModuleDef::Adt(hir::Adt::Struct(_)) => HighlightTag::Struct,\n             hir::ModuleDef::Adt(hir::Adt::Enum(_)) => HighlightTag::Enum,\n             hir::ModuleDef::Adt(hir::Adt::Union(_)) => HighlightTag::Union,\n@@ -516,42 +609,3 @@ fn highlight_name_by_syntax(name: ast::Name) -> Highlight {\n \n     tag.into()\n }\n-\n-fn highlight_injection(\n-    acc: &mut HighlightedRangeStack,\n-    sema: &Semantics<RootDatabase>,\n-    literal: ast::RawString,\n-    expanded: SyntaxToken,\n-) -> Option<()> {\n-    let active_parameter = ActiveParameter::at_token(&sema, expanded)?;\n-    if !active_parameter.name.starts_with(\"ra_fixture\") {\n-        return None;\n-    }\n-    let value = literal.value()?;\n-    let (analysis, tmp_file_id) = Analysis::from_single_file(value);\n-\n-    if let Some(range) = literal.open_quote_text_range() {\n-        acc.add(HighlightedRange {\n-            range,\n-            highlight: HighlightTag::StringLiteral.into(),\n-            binding_hash: None,\n-        })\n-    }\n-\n-    for mut h in analysis.highlight(tmp_file_id).unwrap() {\n-        if let Some(r) = literal.map_range_up(h.range) {\n-            h.range = r;\n-            acc.add(h)\n-        }\n-    }\n-\n-    if let Some(range) = literal.close_quote_text_range() {\n-        acc.add(HighlightedRange {\n-            range,\n-            highlight: HighlightTag::StringLiteral.into(),\n-            binding_hash: None,\n-        })\n-    }\n-\n-    Some(())\n-}"}, {"sha": "5bada6252c0f906aedd5a0deb02091ebeb436577", "filename": "crates/ra_ide/src/syntax_highlighting/html.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -69,6 +69,8 @@ pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padd\n .string_literal     { color: #CC9393; }\n .field              { color: #94BFF3; }\n .function           { color: #93E0E3; }\n+.function.unsafe    { color: #BC8383; }\n+.operator.unsafe    { color: #BC8383; }\n .parameter          { color: #94BFF3; }\n .text               { color: #DCDCCC; }\n .type               { color: #7CB8BB; }"}, {"sha": "3575a0fc6e9f84c6d4a4c77bd0df00d50ab48579", "filename": "crates/ra_ide/src/syntax_highlighting/injection.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,168 @@\n+//! Syntax highlighting injections such as highlighting of documentation tests.\n+\n+use std::{collections::BTreeMap, convert::TryFrom};\n+\n+use ast::{HasQuotes, HasStringValue};\n+use hir::Semantics;\n+use ra_syntax::{ast, AstToken, SyntaxNode, SyntaxToken, TextRange, TextSize};\n+use stdx::SepBy;\n+\n+use crate::{call_info::ActiveParameter, Analysis, HighlightTag, HighlightedRange, RootDatabase};\n+\n+use super::HighlightedRangeStack;\n+\n+pub(super) fn highlight_injection(\n+    acc: &mut HighlightedRangeStack,\n+    sema: &Semantics<RootDatabase>,\n+    literal: ast::RawString,\n+    expanded: SyntaxToken,\n+) -> Option<()> {\n+    let active_parameter = ActiveParameter::at_token(&sema, expanded)?;\n+    if !active_parameter.name.starts_with(\"ra_fixture\") {\n+        return None;\n+    }\n+    let value = literal.value()?;\n+    let (analysis, tmp_file_id) = Analysis::from_single_file(value);\n+\n+    if let Some(range) = literal.open_quote_text_range() {\n+        acc.add(HighlightedRange {\n+            range,\n+            highlight: HighlightTag::StringLiteral.into(),\n+            binding_hash: None,\n+        })\n+    }\n+\n+    for mut h in analysis.highlight(tmp_file_id).unwrap() {\n+        if let Some(r) = literal.map_range_up(h.range) {\n+            h.range = r;\n+            acc.add(h)\n+        }\n+    }\n+\n+    if let Some(range) = literal.close_quote_text_range() {\n+        acc.add(HighlightedRange {\n+            range,\n+            highlight: HighlightTag::StringLiteral.into(),\n+            binding_hash: None,\n+        })\n+    }\n+\n+    Some(())\n+}\n+\n+/// Mapping from extracted documentation code to original code\n+type RangesMap = BTreeMap<TextSize, TextSize>;\n+\n+/// Extracts Rust code from documentation comments as well as a mapping from\n+/// the extracted source code back to the original source ranges.\n+/// Lastly, a vector of new comment highlight ranges (spanning only the\n+/// comment prefix) is returned which is used in the syntax highlighting\n+/// injection to replace the previous (line-spanning) comment ranges.\n+pub(super) fn extract_doc_comments(\n+    node: &SyntaxNode,\n+) -> Option<(String, RangesMap, Vec<HighlightedRange>)> {\n+    // wrap the doctest into function body to get correct syntax highlighting\n+    let prefix = \"fn doctest() {\\n\";\n+    let suffix = \"}\\n\";\n+    // Mapping from extracted documentation code to original code\n+    let mut range_mapping: RangesMap = BTreeMap::new();\n+    let mut line_start = TextSize::try_from(prefix.len()).unwrap();\n+    let mut is_doctest = false;\n+    // Replace the original, line-spanning comment ranges by new, only comment-prefix\n+    // spanning comment ranges.\n+    let mut new_comments = Vec::new();\n+    let doctest = node\n+        .children_with_tokens()\n+        .filter_map(|el| el.into_token().and_then(ast::Comment::cast))\n+        .filter(|comment| comment.kind().doc.is_some())\n+        .filter(|comment| {\n+            if comment.text().contains(\"```\") {\n+                is_doctest = !is_doctest;\n+                false\n+            } else {\n+                is_doctest\n+            }\n+        })\n+        .map(|comment| {\n+            let prefix_len = comment.prefix().len();\n+            let line: &str = comment.text().as_str();\n+            let range = comment.syntax().text_range();\n+\n+            // whitespace after comment is ignored\n+            let pos = if let Some(ws) = line.chars().nth(prefix_len).filter(|c| c.is_whitespace()) {\n+                prefix_len + ws.len_utf8()\n+            } else {\n+                prefix_len\n+            };\n+\n+            // lines marked with `#` should be ignored in output, we skip the `#` char\n+            let pos = if let Some(ws) = line.chars().nth(pos).filter(|&c| c == '#') {\n+                pos + ws.len_utf8()\n+            } else {\n+                pos\n+            };\n+\n+            range_mapping.insert(line_start, range.start() + TextSize::try_from(pos).unwrap());\n+            new_comments.push(HighlightedRange {\n+                range: TextRange::new(\n+                    range.start(),\n+                    range.start() + TextSize::try_from(pos).unwrap(),\n+                ),\n+                highlight: HighlightTag::Comment.into(),\n+                binding_hash: None,\n+            });\n+            line_start += range.len() - TextSize::try_from(pos).unwrap();\n+            line_start += TextSize::try_from('\\n'.len_utf8()).unwrap();\n+\n+            line[pos..].to_owned()\n+        })\n+        .sep_by(\"\\n\")\n+        .to_string();\n+\n+    if doctest.is_empty() {\n+        return None;\n+    }\n+\n+    let doctest = format!(\"{}{}{}\", prefix, doctest, suffix);\n+    Some((doctest, range_mapping, new_comments))\n+}\n+\n+/// Injection of syntax highlighting of doctests.\n+pub(super) fn highlight_doc_comment(\n+    text: String,\n+    range_mapping: RangesMap,\n+    new_comments: Vec<HighlightedRange>,\n+    stack: &mut HighlightedRangeStack,\n+) {\n+    let (analysis, tmp_file_id) = Analysis::from_single_file(text);\n+\n+    stack.push();\n+    for mut h in analysis.highlight(tmp_file_id).unwrap() {\n+        // Determine start offset and end offset in case of multi-line ranges\n+        let mut start_offset = None;\n+        let mut end_offset = None;\n+        for (line_start, orig_line_start) in range_mapping.range(..h.range.end()).rev() {\n+            if line_start <= &h.range.start() {\n+                start_offset.get_or_insert(orig_line_start - line_start);\n+                break;\n+            } else {\n+                end_offset.get_or_insert(orig_line_start - line_start);\n+            }\n+        }\n+        if let Some(start_offset) = start_offset {\n+            h.range = TextRange::new(\n+                h.range.start() + start_offset,\n+                h.range.end() + end_offset.unwrap_or(start_offset),\n+            );\n+            stack.add(h);\n+        }\n+    }\n+\n+    // Inject the comment prefix highlight ranges\n+    stack.push();\n+    for comment in new_comments {\n+        stack.add(comment);\n+    }\n+    stack.pop_and_inject(false);\n+    stack.pop_and_inject(true);\n+}"}, {"sha": "94f466966a3a642899fbac6109125482dc6ff76c", "filename": "crates/ra_ide/src/syntax_highlighting/tags.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -24,12 +24,14 @@ pub enum HighlightTag {\n     Enum,\n     EnumVariant,\n     Field,\n+    FormatSpecifier,\n     Function,\n     Keyword,\n     Lifetime,\n     Macro,\n     Module,\n     NumericLiteral,\n+    Operator,\n     SelfKeyword,\n     SelfType,\n     Static,\n@@ -41,8 +43,6 @@ pub enum HighlightTag {\n     Union,\n     Local,\n     UnresolvedReference,\n-    FormatSpecifier,\n-    Operator,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n@@ -72,12 +72,14 @@ impl HighlightTag {\n             HighlightTag::Enum => \"enum\",\n             HighlightTag::EnumVariant => \"enum_variant\",\n             HighlightTag::Field => \"field\",\n+            HighlightTag::FormatSpecifier => \"format_specifier\",\n             HighlightTag::Function => \"function\",\n             HighlightTag::Keyword => \"keyword\",\n             HighlightTag::Lifetime => \"lifetime\",\n             HighlightTag::Macro => \"macro\",\n             HighlightTag::Module => \"module\",\n             HighlightTag::NumericLiteral => \"numeric_literal\",\n+            HighlightTag::Operator => \"operator\",\n             HighlightTag::SelfKeyword => \"self_keyword\",\n             HighlightTag::SelfType => \"self_type\",\n             HighlightTag::Static => \"static\",\n@@ -89,8 +91,6 @@ impl HighlightTag {\n             HighlightTag::Union => \"union\",\n             HighlightTag::Local => \"variable\",\n             HighlightTag::UnresolvedReference => \"unresolved_reference\",\n-            HighlightTag::FormatSpecifier => \"format_specifier\",\n-            HighlightTag::Operator => \"operator\",\n         }\n     }\n }"}, {"sha": "949bf59a0d24a8437cf63c0bd99a24ddb94a903e", "filename": "crates/ra_ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 101, "deletions": 22, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -9,7 +9,7 @@ use crate::{\n \n #[test]\n fn test_highlighting() {\n-    let (analysis, file_id) = single_file(\n+    check_highlighting(\n         r#\"\n #[derive(Clone, Debug)]\n struct Foo {\n@@ -65,6 +65,8 @@ fn main() {\n     let y = &mut x;\n     let z = &y;\n \n+    let Foo { x: z, y } = Foo { x: z, y };\n+\n     y;\n }\n \n@@ -84,17 +86,14 @@ impl<T> Option<T> {\n }\n \"#\n         .trim(),\n+        \"crates/ra_ide/src/snapshots/highlighting.html\",\n+        false,\n     );\n-    let dst_file = project_dir().join(\"crates/ra_ide/src/snapshots/highlighting.html\");\n-    let actual_html = &analysis.highlight_as_html(file_id, false).unwrap();\n-    let expected_html = &read_text(&dst_file);\n-    fs::write(dst_file, &actual_html).unwrap();\n-    assert_eq_text!(expected_html, actual_html);\n }\n \n #[test]\n fn test_rainbow_highlighting() {\n-    let (analysis, file_id) = single_file(\n+    check_highlighting(\n         r#\"\n fn main() {\n     let hello = \"hello\";\n@@ -110,12 +109,9 @@ fn bar() {\n }\n \"#\n         .trim(),\n+        \"crates/ra_ide/src/snapshots/rainbow_highlighting.html\",\n+        true,\n     );\n-    let dst_file = project_dir().join(\"crates/ra_ide/src/snapshots/rainbow_highlighting.html\");\n-    let actual_html = &analysis.highlight_as_html(file_id, true).unwrap();\n-    let expected_html = &read_text(&dst_file);\n-    fs::write(dst_file, &actual_html).unwrap();\n-    assert_eq_text!(expected_html, actual_html);\n }\n \n #[test]\n@@ -153,7 +149,7 @@ fn test_ranges() {\n \n #[test]\n fn test_flattening() {\n-    let (analysis, file_id) = single_file(\n+    check_highlighting(\n         r##\"\n fn fixture(ra_fixture: &str) {}\n \n@@ -167,13 +163,9 @@ fn main() {\n     );\n }\"##\n         .trim(),\n+        \"crates/ra_ide/src/snapshots/highlight_injection.html\",\n+        false,\n     );\n-\n-    let dst_file = project_dir().join(\"crates/ra_ide/src/snapshots/highlight_injection.html\");\n-    let actual_html = &analysis.highlight_as_html(file_id, false).unwrap();\n-    let expected_html = &read_text(&dst_file);\n-    fs::write(dst_file, &actual_html).unwrap();\n-    assert_eq_text!(expected_html, actual_html);\n }\n \n #[test]\n@@ -192,7 +184,7 @@ macro_rules! test {}\n fn test_string_highlighting() {\n     // The format string detection is based on macro-expansion,\n     // thus, we have to copy the macro definition from `std`\n-    let (analysis, file_id) = single_file(\n+    check_highlighting(\n         r#\"\n macro_rules! println {\n     ($($arg:tt)*) => ({\n@@ -218,6 +210,7 @@ fn main() {\n     println!(\"{argument}\", argument = \"test\");   // => \"test\"\n     println!(\"{name} {}\", 1, name = 2);          // => \"2 1\"\n     println!(\"{a} {c} {b}\", a=\"a\", b='b', c=3);  // => \"a 3 b\"\n+    println!(\"{{{}}}\", 2);                       // => \"{2}\"\n     println!(\"Hello {:5}!\", \"x\");\n     println!(\"Hello {:1$}!\", \"x\", 5);\n     println!(\"Hello {1:0$}!\", 5, \"x\");\n@@ -249,10 +242,96 @@ fn main() {\n     println!(\"{\u043d\u0438\u0447\u043e\u0441\u0438}\", \u043d\u0438\u0447\u043e\u0441\u0438 = 92);\n }\"#\n         .trim(),\n+        \"crates/ra_ide/src/snapshots/highlight_strings.html\",\n+        false,\n     );\n+}\n+\n+#[test]\n+fn test_unsafe_highlighting() {\n+    check_highlighting(\n+        r#\"\n+unsafe fn unsafe_fn() {}\n+\n+struct HasUnsafeFn;\n+\n+impl HasUnsafeFn {\n+    unsafe fn unsafe_method(&self) {}\n+}\n+\n+fn main() {\n+    let x = &5 as *const usize;\n+    unsafe {\n+        unsafe_fn();\n+        HasUnsafeFn.unsafe_method();\n+        let y = *(x);\n+        let z = -x;\n+    }\n+}\n+\"#\n+        .trim(),\n+        \"crates/ra_ide/src/snapshots/highlight_unsafe.html\",\n+        false,\n+    );\n+}\n+\n+#[test]\n+fn test_highlight_doctest() {\n+    check_highlighting(\n+        r#\"\n+impl Foo {\n+    /// Constructs a new `Foo`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![allow(unused_mut)]\n+    /// let mut foo: Foo = Foo::new();\n+    /// ```\n+    pub const fn new() -> Foo {\n+        Foo { }\n+    }\n+\n+    /// `bar` method on `Foo`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let foo = Foo::new();\n+    ///\n+    /// // calls bar on foo\n+    /// assert!(foo.bar());\n+    ///\n+    /// /* multi-line\n+    ///        comment */\n+    ///\n+    /// let multi_line_string = \"Foo\n+    ///   bar\n+    ///          \";\n+    ///\n+    /// ```\n+    ///\n+    /// ```\n+    /// let foobar = Foo::new().bar();\n+    /// ```\n+    pub fn foo(&self) -> bool {\n+        true\n+    }\n+}\n+\"#\n+        .trim(),\n+        \"crates/ra_ide/src/snapshots/highlight_doctest.html\",\n+        false,\n+    )\n+}\n \n-    let dst_file = project_dir().join(\"crates/ra_ide/src/snapshots/highlight_strings.html\");\n-    let actual_html = &analysis.highlight_as_html(file_id, false).unwrap();\n+/// Highlights the code given by the `ra_fixture` argument, renders the\n+/// result as HTML, and compares it with the HTML file given as `snapshot`.\n+/// Note that the `snapshot` file is overwritten by the rendered HTML.\n+fn check_highlighting(ra_fixture: &str, snapshot: &str, rainbow: bool) {\n+    let (analysis, file_id) = single_file(ra_fixture);\n+    let dst_file = project_dir().join(snapshot);\n+    let actual_html = &analysis.highlight_as_html(file_id, rainbow).unwrap();\n     let expected_html = &read_text(&dst_file);\n     fs::write(dst_file, &actual_html).unwrap();\n     assert_eq_text!(expected_html, actual_html);"}, {"sha": "83776d2b6d34a3641a5c0cdfa483f1c4a9ce9dcc", "filename": "crates/ra_ide/src/typing.rs", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftyping.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -17,11 +17,13 @@ mod on_enter;\n \n use ra_db::{FilePosition, SourceDatabase};\n use ra_fmt::leading_indent;\n-use ra_ide_db::RootDatabase;\n+use ra_ide_db::{source_change::SourceFileEdit, RootDatabase};\n use ra_syntax::{\n     algo::find_node_at_offset,\n     ast::{self, AstToken},\n-    AstNode, SourceFile, TextRange, TextSize,\n+    AstNode, SourceFile,\n+    SyntaxKind::{FIELD_EXPR, METHOD_CALL_EXPR},\n+    TextRange, TextSize,\n };\n \n use ra_text_edit::TextEdit;\n@@ -47,8 +49,8 @@ pub(crate) fn on_char_typed(\n     assert!(TRIGGER_CHARS.contains(char_typed));\n     let file = &db.parse(position.file_id).tree();\n     assert_eq!(file.syntax().text().char_at(position.offset), Some(char_typed));\n-    let text_edit = on_char_typed_inner(file, position.offset, char_typed)?;\n-    Some(SourceChange::source_file_edit_from(position.file_id, text_edit))\n+    let edit = on_char_typed_inner(file, position.offset, char_typed)?;\n+    Some(SourceFileEdit { file_id: position.file_id, edit }.into())\n }\n \n fn on_char_typed_inner(file: &SourceFile, offset: TextSize, char_typed: char) -> Option<TextEdit> {\n@@ -98,9 +100,12 @@ fn on_dot_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {\n     };\n     let current_indent_len = TextSize::of(current_indent);\n \n+    let parent = whitespace.syntax().parent();\n     // Make sure dot is a part of call chain\n-    let field_expr = ast::FieldExpr::cast(whitespace.syntax().parent())?;\n-    let prev_indent = leading_indent(field_expr.syntax())?;\n+    if !matches!(parent.kind(), FIELD_EXPR | METHOD_CALL_EXPR) {\n+        return None;\n+    }\n+    let prev_indent = leading_indent(&parent)?;\n     let target_indent = format!(\"    {}\", prev_indent);\n     let target_indent_len = TextSize::of(&target_indent);\n     if current_indent_len == target_indent_len {\n@@ -143,11 +148,11 @@ mod tests {\n         })\n     }\n \n-    fn type_char(char_typed: char, before: &str, after: &str) {\n-        let actual = do_type_char(char_typed, before)\n+    fn type_char(char_typed: char, ra_fixture_before: &str, ra_fixture_after: &str) {\n+        let actual = do_type_char(char_typed, ra_fixture_before)\n             .unwrap_or_else(|| panic!(\"typing `{}` did nothing\", char_typed));\n \n-        assert_eq_text!(after, &actual);\n+        assert_eq_text!(ra_fixture_after, &actual);\n     }\n \n     fn type_char_noop(char_typed: char, before: &str) {\n@@ -248,6 +253,27 @@ fn foo() {\n         )\n     }\n \n+    #[test]\n+    fn indents_new_chain_call_with_let() {\n+        type_char(\n+            '.',\n+            r#\"\n+fn main() {\n+    let _ = foo\n+    <|>\n+    bar()\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let _ = foo\n+        .\n+    bar()\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn indents_continued_chain_call() {\n         type_char("}, {"sha": "2fc796a859228a9767cae733b0f7fb0cea507b03", "filename": "crates/ra_ide_db/src/change.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fchange.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -16,7 +16,7 @@ use rustc_hash::FxHashMap;\n \n use crate::{\n     symbol_index::{SymbolIndex, SymbolsDatabase},\n-    DebugData, RootDatabase,\n+    RootDatabase,\n };\n \n #[derive(Default)]\n@@ -26,7 +26,6 @@ pub struct AnalysisChange {\n     files_changed: Vec<(FileId, Arc<String>)>,\n     libraries_added: Vec<LibraryData>,\n     crate_graph: Option<CrateGraph>,\n-    debug_data: DebugData,\n }\n \n impl fmt::Debug for AnalysisChange {\n@@ -87,10 +86,6 @@ impl AnalysisChange {\n     pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n         self.crate_graph = Some(graph);\n     }\n-\n-    pub fn set_debug_root_path(&mut self, source_root_id: SourceRootId, path: String) {\n-        self.debug_data.root_paths.insert(source_root_id, path);\n-    }\n }\n \n #[derive(Debug)]\n@@ -218,8 +213,6 @@ impl RootDatabase {\n         if let Some(crate_graph) = change.crate_graph {\n             self.set_crate_graph_with_durability(Arc::new(crate_graph), Durability::HIGH)\n         }\n-\n-        Arc::make_mut(&mut self.debug_data).merge(change.debug_data)\n     }\n \n     fn apply_root_change(&mut self, root_id: SourceRootId, root_change: RootChange) {\n@@ -334,6 +327,7 @@ impl RootDatabase {\n             hir::db::CrateLangItemsQuery\n             hir::db::LangItemQuery\n             hir::db::DocumentationQuery\n+            hir::db::ImportMapQuery\n \n             // InternDatabase\n             hir::db::InternFunctionQuery\n@@ -369,6 +363,7 @@ impl RootDatabase {\n             hir::db::ImplDatumQuery\n             hir::db::AssociatedTyValueQuery\n             hir::db::TraitSolveQuery\n+            hir::db::ReturnTypeImplTraitsQuery\n \n             // SymbolsDatabase\n             crate::symbol_index::FileSymbolsQuery"}, {"sha": "3ef5e74b6997c07d9cad2606ba7486a69ca476ab", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -18,7 +18,7 @@ use ra_syntax::{\n use crate::RootDatabase;\n \n // FIXME: a more precise name would probably be `Symbol`?\n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n pub enum Definition {\n     Macro(MacroDef),\n     Field(Field),\n@@ -78,42 +78,45 @@ impl Definition {\n     }\n }\n \n+#[derive(Debug)]\n pub enum NameClass {\n     Definition(Definition),\n     /// `None` in `if let None = Some(82) {}`\n     ConstReference(Definition),\n+    FieldShorthand {\n+        local: Local,\n+        field: Definition,\n+    },\n }\n \n impl NameClass {\n     pub fn into_definition(self) -> Option<Definition> {\n         match self {\n             NameClass::Definition(it) => Some(it),\n             NameClass::ConstReference(_) => None,\n+            NameClass::FieldShorthand { local, field: _ } => Some(Definition::Local(local)),\n         }\n     }\n \n     pub fn definition(self) -> Definition {\n         match self {\n             NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n+            NameClass::FieldShorthand { local: _, field } => field,\n         }\n     }\n }\n \n pub fn classify_name(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option<NameClass> {\n     let _p = profile(\"classify_name\");\n \n-    if let Some(bind_pat) = name.syntax().parent().and_then(ast::BindPat::cast) {\n+    let parent = name.syntax().parent()?;\n+\n+    if let Some(bind_pat) = ast::BindPat::cast(parent.clone()) {\n         if let Some(def) = sema.resolve_bind_pat_to_const(&bind_pat) {\n             return Some(NameClass::ConstReference(Definition::ModuleDef(def)));\n         }\n     }\n \n-    classify_name_inner(sema, name).map(NameClass::Definition)\n-}\n-\n-fn classify_name_inner(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option<Definition> {\n-    let parent = name.syntax().parent()?;\n-\n     match_ast! {\n         match parent {\n             ast::Alias(it) => {\n@@ -123,63 +126,73 @@ fn classify_name_inner(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Opti\n                 let name_ref = path_segment.name_ref()?;\n                 let name_ref_class = classify_name_ref(sema, &name_ref)?;\n \n-                Some(name_ref_class.definition())\n+                Some(NameClass::Definition(name_ref_class.definition()))\n             },\n             ast::BindPat(it) => {\n                 let local = sema.to_def(&it)?;\n-                Some(Definition::Local(local))\n+\n+                if let Some(record_field_pat) = it.syntax().parent().and_then(ast::RecordFieldPat::cast) {\n+                    if record_field_pat.name_ref().is_none() {\n+                        if let Some(field) = sema.resolve_record_field_pat(&record_field_pat) {\n+                            let field = Definition::Field(field);\n+                            return Some(NameClass::FieldShorthand { local, field });\n+                        }\n+                    }\n+                }\n+\n+                Some(NameClass::Definition(Definition::Local(local)))\n             },\n             ast::RecordFieldDef(it) => {\n                 let field: hir::Field = sema.to_def(&it)?;\n-                Some(Definition::Field(field))\n+                Some(NameClass::Definition(Definition::Field(field)))\n             },\n             ast::Module(it) => {\n                 let def = sema.to_def(&it)?;\n-                Some(Definition::ModuleDef(def.into()))\n+                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n             },\n             ast::StructDef(it) => {\n                 let def: hir::Struct = sema.to_def(&it)?;\n-                Some(Definition::ModuleDef(def.into()))\n+                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n             },\n             ast::UnionDef(it) => {\n                 let def: hir::Union = sema.to_def(&it)?;\n-                Some(Definition::ModuleDef(def.into()))\n+                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n             },\n             ast::EnumDef(it) => {\n                 let def: hir::Enum = sema.to_def(&it)?;\n-                Some(Definition::ModuleDef(def.into()))\n+                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n             },\n             ast::TraitDef(it) => {\n                 let def: hir::Trait = sema.to_def(&it)?;\n-                Some(Definition::ModuleDef(def.into()))\n+                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n             },\n             ast::StaticDef(it) => {\n                 let def: hir::Static = sema.to_def(&it)?;\n-                Some(Definition::ModuleDef(def.into()))\n+                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n             },\n             ast::EnumVariant(it) => {\n                 let def: hir::EnumVariant = sema.to_def(&it)?;\n-                Some(Definition::ModuleDef(def.into()))\n+                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n             },\n             ast::FnDef(it) => {\n                 let def: hir::Function = sema.to_def(&it)?;\n-                Some(Definition::ModuleDef(def.into()))\n+                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n             },\n             ast::ConstDef(it) => {\n                 let def: hir::Const = sema.to_def(&it)?;\n-                Some(Definition::ModuleDef(def.into()))\n+                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n             },\n             ast::TypeAliasDef(it) => {\n                 let def: hir::TypeAlias = sema.to_def(&it)?;\n-                Some(Definition::ModuleDef(def.into()))\n+                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n             },\n             ast::MacroCall(it) => {\n                 let def = sema.to_def(&it)?;\n-                Some(Definition::Macro(def))\n+                Some(NameClass::Definition(Definition::Macro(def)))\n             },\n             ast::TypeParam(it) => {\n                 let def = sema.to_def(&it)?;\n-                Some(Definition::TypeParam(def))\n+                Some(NameClass::Definition(Definition::TypeParam(def)))\n             },\n             _ => None,\n         }"}, {"sha": "fff112e661034c3ffda72a122639422c899343b6", "filename": "crates/ra_ide_db/src/imports_locator.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,7 +1,7 @@\n //! This module contains an import search funcionality that is provided to the ra_assists module.\n //! Later, this should be moved away to a separate crate that is accessible from the ra_assists module.\n \n-use hir::{MacroDef, ModuleDef, Semantics};\n+use hir::{Crate, MacroDef, ModuleDef, Semantics};\n use ra_prof::profile;\n use ra_syntax::{ast, AstNode, SyntaxKind::NAME};\n \n@@ -11,44 +11,46 @@ use crate::{\n     RootDatabase,\n };\n use either::Either;\n+use rustc_hash::FxHashSet;\n \n pub struct ImportsLocator<'a> {\n     sema: Semantics<'a, RootDatabase>,\n+    krate: Crate,\n }\n \n impl<'a> ImportsLocator<'a> {\n-    pub fn new(db: &'a RootDatabase) -> Self {\n-        Self { sema: Semantics::new(db) }\n+    pub fn new(db: &'a RootDatabase, krate: Crate) -> Self {\n+        Self { sema: Semantics::new(db), krate }\n     }\n \n     pub fn find_imports(&mut self, name_to_import: &str) -> Vec<Either<ModuleDef, MacroDef>> {\n         let _p = profile(\"search_for_imports\");\n         let db = self.sema.db;\n \n-        let project_results = {\n-            let mut query = Query::new(name_to_import.to_string());\n-            query.exact();\n-            query.limit(40);\n-            symbol_index::world_symbols(db, query)\n-        };\n-        let lib_results = {\n+        // Query dependencies first.\n+        let mut candidates: FxHashSet<_> =\n+            self.krate.query_external_importables(db, name_to_import).collect();\n+\n+        // Query the local crate using the symbol index.\n+        let local_results = {\n             let mut query = Query::new(name_to_import.to_string());\n-            query.libs();\n             query.exact();\n             query.limit(40);\n-            symbol_index::world_symbols(db, query)\n+            symbol_index::crate_symbols(db, self.krate.into(), query)\n         };\n \n-        project_results\n-            .into_iter()\n-            .chain(lib_results.into_iter())\n-            .filter_map(|import_candidate| self.get_name_definition(&import_candidate))\n-            .filter_map(|name_definition_to_import| match name_definition_to_import {\n-                Definition::ModuleDef(module_def) => Some(Either::Left(module_def)),\n-                Definition::Macro(macro_def) => Some(Either::Right(macro_def)),\n-                _ => None,\n-            })\n-            .collect()\n+        candidates.extend(\n+            local_results\n+                .into_iter()\n+                .filter_map(|import_candidate| self.get_name_definition(&import_candidate))\n+                .filter_map(|name_definition_to_import| match name_definition_to_import {\n+                    Definition::ModuleDef(module_def) => Some(Either::Left(module_def)),\n+                    Definition::Macro(macro_def) => Some(Either::Right(macro_def)),\n+                    _ => None,\n+                }),\n+        );\n+\n+        candidates.into_iter().collect()\n     }\n \n     fn get_name_definition(&mut self, import_candidate: &FileSymbol) -> Option<Definition> {"}, {"sha": "a808de4f113509a549f97d50c4db759d7e0b55e4", "filename": "crates/ra_ide_db/src/lib.rs", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Flib.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -16,10 +16,10 @@ use std::sync::Arc;\n use hir::db::{AstDatabase, DefDatabase};\n use ra_db::{\n     salsa::{self, Database, Durability},\n-    Canceled, CheckCanceled, CrateId, FileId, FileLoader, FileLoaderDelegate, RelativePath,\n-    SourceDatabase, SourceRootId, Upcast,\n+    Canceled, CheckCanceled, CrateId, FileId, FileLoader, FileLoaderDelegate, SourceDatabase,\n+    Upcast,\n };\n-use rustc_hash::FxHashMap;\n+use rustc_hash::FxHashSet;\n \n use crate::{line_index::LineIndex, symbol_index::SymbolsDatabase};\n \n@@ -36,7 +36,6 @@ use crate::{line_index::LineIndex, symbol_index::SymbolsDatabase};\n #[derive(Debug)]\n pub struct RootDatabase {\n     runtime: salsa::Runtime<RootDatabase>,\n-    pub(crate) debug_data: Arc<DebugData>,\n     pub last_gc: crate::wasm_shims::Instant,\n     pub last_gc_check: crate::wasm_shims::Instant,\n }\n@@ -57,23 +56,12 @@ impl FileLoader for RootDatabase {\n     fn file_text(&self, file_id: FileId) -> Arc<String> {\n         FileLoaderDelegate(self).file_text(file_id)\n     }\n-    fn resolve_relative_path(\n-        &self,\n-        anchor: FileId,\n-        relative_path: &RelativePath,\n-    ) -> Option<FileId> {\n-        FileLoaderDelegate(self).resolve_relative_path(anchor, relative_path)\n+    fn resolve_path(&self, anchor: FileId, path: &str) -> Option<FileId> {\n+        FileLoaderDelegate(self).resolve_path(anchor, path)\n     }\n-    fn relevant_crates(&self, file_id: FileId) -> Arc<Vec<CrateId>> {\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n         FileLoaderDelegate(self).relevant_crates(file_id)\n     }\n-    fn resolve_extern_path(\n-        &self,\n-        extern_id: ra_db::ExternSourceId,\n-        relative_path: &RelativePath,\n-    ) -> Option<FileId> {\n-        FileLoaderDelegate(self).resolve_extern_path(extern_id, relative_path)\n-    }\n }\n \n impl salsa::Database for RootDatabase {\n@@ -109,7 +97,6 @@ impl RootDatabase {\n             runtime: salsa::Runtime::default(),\n             last_gc: crate::wasm_shims::Instant::now(),\n             last_gc_check: crate::wasm_shims::Instant::now(),\n-            debug_data: Default::default(),\n         };\n         db.set_crate_graph_with_durability(Default::default(), Durability::HIGH);\n         db.set_local_roots_with_durability(Default::default(), Durability::HIGH);\n@@ -132,7 +119,6 @@ impl salsa::ParallelDatabase for RootDatabase {\n             runtime: self.runtime.snapshot(self),\n             last_gc: self.last_gc,\n             last_gc_check: self.last_gc_check,\n-            debug_data: Arc::clone(&self.debug_data),\n         })\n     }\n }\n@@ -146,14 +132,3 @@ fn line_index(db: &impl LineIndexDatabase, file_id: FileId) -> Arc<LineIndex> {\n     let text = db.file_text(file_id);\n     Arc::new(LineIndex::new(&*text))\n }\n-\n-#[derive(Debug, Default, Clone)]\n-pub(crate) struct DebugData {\n-    pub(crate) root_paths: FxHashMap<SourceRootId, String>,\n-}\n-\n-impl DebugData {\n-    pub(crate) fn merge(&mut self, other: DebugData) {\n-        self.root_paths.extend(other.root_paths.into_iter());\n-    }\n-}"}, {"sha": "f40ae8304a42f953ad32f6224de750d126129e01", "filename": "crates/ra_ide_db/src/source_change.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide_db%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide_db%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsource_change.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -22,17 +22,6 @@ impl SourceChange {\n     ) -> Self {\n         SourceChange { source_file_edits, file_system_edits, is_snippet: false }\n     }\n-\n-    /// Creates a new SourceChange with the given label,\n-    /// containing only the given `SourceFileEdits`.\n-    pub fn source_file_edits(edits: Vec<SourceFileEdit>) -> Self {\n-        SourceChange { source_file_edits: edits, file_system_edits: vec![], is_snippet: false }\n-    }\n-    /// Creates a new SourceChange with the given label\n-    /// from the given `FileId` and `TextEdit`\n-    pub fn source_file_edit_from(file_id: FileId, edit: TextEdit) -> Self {\n-        SourceFileEdit { file_id, edit }.into()\n-    }\n }\n \n #[derive(Debug, Clone)]\n@@ -43,11 +32,13 @@ pub struct SourceFileEdit {\n \n impl From<SourceFileEdit> for SourceChange {\n     fn from(edit: SourceFileEdit) -> SourceChange {\n-        SourceChange {\n-            source_file_edits: vec![edit],\n-            file_system_edits: Vec::new(),\n-            is_snippet: false,\n-        }\n+        vec![edit].into()\n+    }\n+}\n+\n+impl From<Vec<SourceFileEdit>> for SourceChange {\n+    fn from(source_file_edits: Vec<SourceFileEdit>) -> SourceChange {\n+        SourceChange { source_file_edits, file_system_edits: Vec::new(), is_snippet: false }\n     }\n }\n "}, {"sha": "aab91897320acd2da070551c94f36554b7db2253", "filename": "crates/ra_ide_db/src/symbol_index.rs", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -29,9 +29,10 @@ use std::{\n };\n \n use fst::{self, Streamer};\n+use hir::db::DefDatabase;\n use ra_db::{\n     salsa::{self, ParallelDatabase},\n-    FileId, SourceDatabaseExt, SourceRootId,\n+    CrateId, FileId, SourceDatabaseExt, SourceRootId,\n };\n use ra_syntax::{\n     ast::{self, NameOwner},\n@@ -110,6 +111,14 @@ fn file_symbols(db: &impl SymbolsDatabase, file_id: FileId) -> Arc<SymbolIndex>\n     Arc::new(SymbolIndex::new(symbols))\n }\n \n+/// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n+struct Snap(salsa::Snapshot<RootDatabase>);\n+impl Clone for Snap {\n+    fn clone(&self) -> Snap {\n+        Snap(self.0.snapshot())\n+    }\n+}\n+\n // Feature: Workspace Symbol\n //\n // Uses fuzzy-search to find types, modules and functions by name across your\n@@ -132,13 +141,7 @@ fn file_symbols(db: &impl SymbolsDatabase, file_id: FileId) -> Arc<SymbolIndex>\n // | VS Code | kbd:[Ctrl+T]\n // |===\n pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {\n-    /// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n-    struct Snap(salsa::Snapshot<RootDatabase>);\n-    impl Clone for Snap {\n-        fn clone(&self) -> Snap {\n-            Snap(self.0.snapshot())\n-        }\n-    }\n+    let _p = ra_prof::profile(\"world_symbols\").detail(|| query.query.clone());\n \n     let buf: Vec<Arc<SymbolIndex>> = if query.libs {\n         let snap = Snap(db.snapshot());\n@@ -173,6 +176,33 @@ pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {\n     query.search(&buf)\n }\n \n+pub fn crate_symbols(db: &RootDatabase, krate: CrateId, query: Query) -> Vec<FileSymbol> {\n+    // FIXME(#4842): This now depends on CrateDefMap, why not build the entire symbol index from\n+    // that instead?\n+\n+    let def_map = db.crate_def_map(krate);\n+    let mut files = Vec::new();\n+    let mut modules = vec![def_map.root];\n+    while let Some(module) = modules.pop() {\n+        let data = &def_map[module];\n+        files.extend(data.origin.file_id());\n+        modules.extend(data.children.values());\n+    }\n+\n+    let snap = Snap(db.snapshot());\n+\n+    #[cfg(not(feature = \"wasm\"))]\n+    let buf = files\n+        .par_iter()\n+        .map_with(snap, |db, &file_id| db.0.file_symbols(file_id))\n+        .collect::<Vec<_>>();\n+\n+    #[cfg(feature = \"wasm\")]\n+    let buf = files.iter().map(|&file_id| snap.0.file_symbols(file_id)).collect::<Vec<_>>();\n+\n+    query.search(&buf)\n+}\n+\n pub fn index_resolve(db: &RootDatabase, name_ref: &ast::NameRef) -> Vec<FileSymbol> {\n     let name = name_ref.text();\n     let mut query = Query::new(name.to_string());\n@@ -298,9 +328,6 @@ impl Query {\n         let mut stream = op.union();\n         let mut res = Vec::new();\n         while let Some((_, indexed_values)) = stream.next() {\n-            if res.len() >= self.limit {\n-                break;\n-            }\n             for indexed_value in indexed_values {\n                 let symbol_index = &indices[indexed_value.index];\n                 let (start, end) = SymbolIndex::map_value_to_range(indexed_value.value);\n@@ -312,7 +339,11 @@ impl Query {\n                     if self.exact && symbol.name != self.query {\n                         continue;\n                     }\n+\n                     res.push(symbol.clone());\n+                    if res.len() >= self.limit {\n+                        return res;\n+                    }\n                 }\n             }\n         }"}, {"sha": "293baecf6a2c1b87f62d6d12b6cf6293110f6493", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -18,9 +18,10 @@\n //! // fn foo() {}\n //! ```\n //!\n-//! After adding a new inline-test, run `cargo collect-tests` to extract\n-//! it as a standalone text-fixture into `tests/data/parser/inline`, and\n-//! run `cargo test` once to create the \"gold\" value.\n+//! After adding a new inline-test, run `cargo xtask codegen` to\n+//! extract it as a standalone text-fixture into\n+//! `crates/ra_syntax/test_data/parser/`, and run `cargo test` once to\n+//! create the \"gold\" value.\n //!\n //! Coding convention: rules like `where_clause` always produce either a\n //! node or an error, rules like `opt_where_clause` may produce nothing."}, {"sha": "97642bc244999bc537d903a4178611558ac06b4f", "filename": "crates/ra_parser/src/grammar/items.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -118,7 +118,22 @@ pub(super) fn maybe_item(p: &mut Parser, m: Marker, flavor: ItemFlavor) -> Resul\n         && p.at_contextual_kw(\"default\")\n         && (match p.nth(1) {\n             T![impl] => true,\n-            T![fn] | T![type] => {\n+            T![unsafe] => {\n+                // test default_unsafe_impl\n+                // default unsafe impl Foo {}\n+\n+                // test default_unsafe_fn\n+                // impl T for Foo {\n+                //     default unsafe fn foo() {}\n+                // }\n+                if p.nth(2) == T![impl] || p.nth(2) == T![fn] {\n+                    p.bump_remap(T![default]);\n+                    p.bump(T![unsafe]);\n+                    has_mods = true;\n+                }\n+                false\n+            }\n+            T![fn] | T![type] | T![const] => {\n                 if let ItemFlavor::Mod = flavor {\n                     true\n                 } else {\n@@ -198,6 +213,9 @@ pub(super) fn maybe_item(p: &mut Parser, m: Marker, flavor: ItemFlavor) -> Resul\n         //     default type T = Bar;\n         //     default fn foo() {}\n         // }\n+        T![const] => {\n+            consts::const_def(p, m);\n+        }\n \n         // test unsafe_default_impl\n         // unsafe default impl Foo {}"}, {"sha": "428aa711e161aa0b7ee0ee6a91489d29ccf9ca42", "filename": "crates/ra_parser/src/grammar/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -3,7 +3,7 @@\n use super::*;\n \n pub(super) const PATH_FIRST: TokenSet =\n-    token_set![IDENT, SELF_KW, SUPER_KW, CRATE_KW, COLON, L_ANGLE];\n+    token_set![IDENT, T![self], T![super], T![crate], T![:], T![<]];\n \n pub(super) fn is_path_start(p: &Parser) -> bool {\n     is_use_path_start(p) || p.at(T![<])"}, {"sha": "427c0eb49c2fd04c67b09352ffd5917d2ab17af5", "filename": "crates/ra_parser/src/grammar/patterns.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -4,7 +4,7 @@ use super::*;\n \n pub(super) const PATTERN_FIRST: TokenSet = expressions::LITERAL_FIRST\n     .union(paths::PATH_FIRST)\n-    .union(token_set![BOX_KW, REF_KW, MUT_KW, L_PAREN, L_BRACK, AMP, UNDERSCORE, MINUS, DOT]);\n+    .union(token_set![T![box], T![ref], T![mut], T!['('], T!['['], T![&], T![_], T![-], T![.]]);\n \n pub(crate) fn pattern(p: &mut Parser) {\n     pattern_r(p, PAT_RECOVERY_SET);\n@@ -88,7 +88,9 @@ fn atom_pat(p: &mut Parser, recovery_set: TokenSet) -> Option<CompletedMarker> {\n             _ => bind_pat(p, true),\n         },\n \n-        _ if paths::is_use_path_start(p) => path_or_macro_pat(p),\n+        // test type_path_in_pattern\n+        // fn main() { let <_>::Foo = (); }\n+        _ if paths::is_path_start(p) => path_or_macro_pat(p),\n         _ if is_literal_pat_start(p) => literal_pat(p),\n \n         T![.] if p.at(T![..]) => dot_dot_pat(p),\n@@ -138,7 +140,7 @@ fn literal_pat(p: &mut Parser) -> CompletedMarker {\n //     let Bar(..) = ();\n // }\n fn path_or_macro_pat(p: &mut Parser) -> CompletedMarker {\n-    assert!(paths::is_use_path_start(p));\n+    assert!(paths::is_path_start(p));\n     let m = p.start();\n     paths::expr_path(p);\n     let kind = match p.current() {"}, {"sha": "325d566adee09c70a219ddb0455a680eb200901d", "filename": "crates/ra_parser/src/grammar/type_params.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -191,10 +191,14 @@ fn where_predicate(p: &mut Parser) {\n         }\n         _ => {\n             // test where_pred_for\n-            // fn test<F>()\n+            // fn for_trait<F>()\n             // where\n             //    for<'a> F: Fn(&'a str)\n             // { }\n+            if p.at(T![for]) {\n+                types::for_binder(p);\n+            }\n+\n             types::type_(p);\n \n             if p.at(T![:]) {"}, {"sha": "9e8e3bd97f829d3c41d1d05fcbc1c085f05026b4", "filename": "crates/ra_parser/src/grammar/types.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -216,19 +216,21 @@ pub(super) fn for_binder(p: &mut Parser) {\n \n // test for_type\n // type A = for<'a> fn() -> ();\n-// fn foo<T>(_t: &T) where for<'a> &'a T: Iterator {}\n-// fn bar<T>(_t: &T) where for<'a> &'a mut T: Iterator {}\n-// fn baz<T>(_t: &T) where for<'a> <&'a T as Baz>::Foo: Iterator {}\n+// type B = for<'a> unsafe extern \"C\" fn(&'a ()) -> ();\n+// type Obj = for<'a> PartialEq<&'a i32>;\n pub(super) fn for_type(p: &mut Parser) {\n     assert!(p.at(T![for]));\n     let m = p.start();\n     for_binder(p);\n     match p.current() {\n-        T![fn] | T![unsafe] | T![extern] => fn_pointer_type(p),\n-        T![&] => reference_type(p),\n-        _ if paths::is_path_start(p) => path_type_(p, false),\n-        _ => p.error(\"expected a path\"),\n+        T![fn] | T![unsafe] | T![extern] => {}\n+        // OK: legacy trait object format\n+        _ if paths::is_use_path_start(p) => {}\n+        _ => {\n+            p.error(\"expected a function pointer or path\");\n+        }\n     }\n+    type_no_bounds(p);\n     m.complete(p, FOR_TYPE);\n }\n "}, {"sha": "5821029450f5b0062bdbab907c684695c7f8609d", "filename": "crates/ra_proc_macro_srv/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_proc_macro_srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_proc_macro_srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2FCargo.toml?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -22,3 +22,4 @@ cargo_metadata = \"0.10.0\"\n difference = \"2.0.0\"\n # used as proc macro test target\n serde_derive = \"1.0.106\"\n+ra_toolchain = { path = \"../ra_toolchain\" }"}, {"sha": "8d85f2d8a77521d40c396c3fb55a9f0a22853694", "filename": "crates/ra_proc_macro_srv/src/tests/utils.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -2,7 +2,6 @@\n \n use crate::dylib;\n use crate::ProcMacroSrv;\n-pub use difference::Changeset as __Changeset;\n use ra_proc_macro::ListMacrosTask;\n use std::str::FromStr;\n use test_utils::assert_eq_text;\n@@ -13,7 +12,7 @@ mod fixtures {\n \n     // Use current project metadata to get the proc-macro dylib path\n     pub fn dylib_path(crate_name: &str, version: &str) -> std::path::PathBuf {\n-        let command = Command::new(\"cargo\")\n+        let command = Command::new(ra_toolchain::cargo())\n             .args(&[\"check\", \"--message-format\", \"json\"])\n             .output()\n             .unwrap()"}, {"sha": "4b7444039e7b9b448126b7e5f09f21f7659d18ac", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -64,7 +64,7 @@ impl Default for CargoConfig {\n     fn default() -> Self {\n         CargoConfig {\n             no_default_features: false,\n-            all_features: true,\n+            all_features: false,\n             features: Vec::new(),\n             load_out_dirs_from_check: false,\n             target: None,"}, {"sha": "ee2de4c2569165561ccaab17ac1d86f7c88ee4aa", "filename": "crates/ra_project_model/src/json_project.rs", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fjson_project.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -2,9 +2,16 @@\n \n use std::path::PathBuf;\n \n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashSet;\n use serde::Deserialize;\n \n+/// Roots and crates that compose this Rust project.\n+#[derive(Clone, Debug, Deserialize)]\n+pub struct JsonProject {\n+    pub(crate) roots: Vec<Root>,\n+    pub(crate) crates: Vec<Crate>,\n+}\n+\n /// A root points to the directory which contains Rust crates. rust-analyzer watches all files in\n /// all roots. Roots might be nested.\n #[derive(Clone, Debug, Deserialize)]\n@@ -20,8 +27,10 @@ pub struct Crate {\n     pub(crate) root_module: PathBuf,\n     pub(crate) edition: Edition,\n     pub(crate) deps: Vec<Dep>,\n-    pub(crate) atom_cfgs: FxHashSet<String>,\n-    pub(crate) key_value_cfgs: FxHashMap<String, String>,\n+\n+    #[serde(default)]\n+    pub(crate) cfg: FxHashSet<String>,\n+\n     pub(crate) out_dir: Option<PathBuf>,\n     pub(crate) proc_macro_dylib_path: Option<PathBuf>,\n }\n@@ -48,9 +57,39 @@ pub struct Dep {\n     pub(crate) name: String,\n }\n \n-/// Roots and crates that compose this Rust project.\n-#[derive(Clone, Debug, Deserialize)]\n-pub struct JsonProject {\n-    pub(crate) roots: Vec<Root>,\n-    pub(crate) crates: Vec<Crate>,\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use serde_json::json;\n+\n+    #[test]\n+    fn test_crate_deserialization() {\n+        let raw_json = json!(    {\n+            \"crate_id\": 2,\n+            \"root_module\": \"this/is/a/file/path.rs\",\n+            \"deps\": [\n+              {\n+                \"crate\": 1,\n+                \"name\": \"some_dep_crate\"\n+              },\n+            ],\n+            \"edition\": \"2015\",\n+            \"cfg\": [\n+              \"atom_1\",\n+              \"atom_2\",\n+              \"feature=feature_1\",\n+              \"feature=feature_2\",\n+              \"other=value\",\n+            ],\n+\n+        });\n+\n+        let krate: Crate = serde_json::from_value(raw_json).unwrap();\n+\n+        assert!(krate.cfg.contains(&\"atom_1\".to_string()));\n+        assert!(krate.cfg.contains(&\"atom_2\".to_string()));\n+        assert!(krate.cfg.contains(&\"feature=feature_1\".to_string()));\n+        assert!(krate.cfg.contains(&\"feature=feature_2\".to_string()));\n+        assert!(krate.cfg.contains(&\"other=value\".to_string()));\n+    }\n }"}, {"sha": "cb0e27dce21763ad0e0b7e493be3e677df625e73", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 64, "deletions": 47, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -14,7 +14,7 @@ use std::{\n use anyhow::{bail, Context, Result};\n use ra_cfg::CfgOptions;\n use ra_db::{CrateGraph, CrateName, Edition, Env, ExternSource, ExternSourceId, FileId};\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use serde_json::from_reader;\n \n pub use crate::{\n@@ -32,6 +32,12 @@ pub enum ProjectWorkspace {\n     Json { project: JsonProject },\n }\n \n+impl From<JsonProject> for ProjectWorkspace {\n+    fn from(project: JsonProject) -> ProjectWorkspace {\n+        ProjectWorkspace::Json { project }\n+    }\n+}\n+\n /// `PackageRoot` describes a package root folder.\n /// Which may be an external dependency, or a member of\n /// the current workspace.\n@@ -41,41 +47,45 @@ pub struct PackageRoot {\n     path: PathBuf,\n     /// Is a member of the current workspace\n     is_member: bool,\n+    out_dir: Option<PathBuf>,\n }\n impl PackageRoot {\n     pub fn new_member(path: PathBuf) -> PackageRoot {\n-        Self { path, is_member: true }\n+        Self { path, is_member: true, out_dir: None }\n     }\n     pub fn new_non_member(path: PathBuf) -> PackageRoot {\n-        Self { path, is_member: false }\n+        Self { path, is_member: false, out_dir: None }\n     }\n     pub fn path(&self) -> &Path {\n         &self.path\n     }\n+    pub fn out_dir(&self) -> Option<&Path> {\n+        self.out_dir.as_deref()\n+    }\n     pub fn is_member(&self) -> bool {\n         self.is_member\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum ProjectRoot {\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n+pub enum ProjectManifest {\n     ProjectJson(PathBuf),\n     CargoToml(PathBuf),\n }\n \n-impl ProjectRoot {\n-    pub fn from_manifest_file(path: PathBuf) -> Result<ProjectRoot> {\n+impl ProjectManifest {\n+    pub fn from_manifest_file(path: PathBuf) -> Result<ProjectManifest> {\n         if path.ends_with(\"rust-project.json\") {\n-            return Ok(ProjectRoot::ProjectJson(path));\n+            return Ok(ProjectManifest::ProjectJson(path));\n         }\n         if path.ends_with(\"Cargo.toml\") {\n-            return Ok(ProjectRoot::CargoToml(path));\n+            return Ok(ProjectManifest::CargoToml(path));\n         }\n         bail!(\"project root must point to Cargo.toml or rust-project.json: {}\", path.display())\n     }\n \n-    pub fn discover_single(path: &Path) -> Result<ProjectRoot> {\n-        let mut candidates = ProjectRoot::discover(path)?;\n+    pub fn discover_single(path: &Path) -> Result<ProjectManifest> {\n+        let mut candidates = ProjectManifest::discover(path)?;\n         let res = match candidates.pop() {\n             None => bail!(\"no projects\"),\n             Some(it) => it,\n@@ -87,12 +97,12 @@ impl ProjectRoot {\n         Ok(res)\n     }\n \n-    pub fn discover(path: &Path) -> io::Result<Vec<ProjectRoot>> {\n+    pub fn discover(path: &Path) -> io::Result<Vec<ProjectManifest>> {\n         if let Some(project_json) = find_in_parent_dirs(path, \"rust-project.json\") {\n-            return Ok(vec![ProjectRoot::ProjectJson(project_json)]);\n+            return Ok(vec![ProjectManifest::ProjectJson(project_json)]);\n         }\n         return find_cargo_toml(path)\n-            .map(|paths| paths.into_iter().map(ProjectRoot::CargoToml).collect());\n+            .map(|paths| paths.into_iter().map(ProjectManifest::CargoToml).collect());\n \n         fn find_cargo_toml(path: &Path) -> io::Result<Vec<PathBuf>> {\n             match find_in_parent_dirs(path, \"Cargo.toml\") {\n@@ -128,16 +138,28 @@ impl ProjectRoot {\n                 .collect()\n         }\n     }\n+\n+    pub fn discover_all(paths: &[impl AsRef<Path>]) -> Vec<ProjectManifest> {\n+        let mut res = paths\n+            .iter()\n+            .filter_map(|it| ProjectManifest::discover(it.as_ref()).ok())\n+            .flatten()\n+            .collect::<FxHashSet<_>>()\n+            .into_iter()\n+            .collect::<Vec<_>>();\n+        res.sort();\n+        res\n+    }\n }\n \n impl ProjectWorkspace {\n     pub fn load(\n-        root: ProjectRoot,\n+        manifest: ProjectManifest,\n         cargo_features: &CargoConfig,\n         with_sysroot: bool,\n     ) -> Result<ProjectWorkspace> {\n-        let res = match root {\n-            ProjectRoot::ProjectJson(project_json) => {\n+        let res = match manifest {\n+            ProjectManifest::ProjectJson(project_json) => {\n                 let file = File::open(&project_json).with_context(|| {\n                     format!(\"Failed to open json file {}\", project_json.display())\n                 })?;\n@@ -148,7 +170,7 @@ impl ProjectWorkspace {\n                     })?,\n                 }\n             }\n-            ProjectRoot::CargoToml(cargo_toml) => {\n+            ProjectManifest::CargoToml(cargo_toml) => {\n                 let cargo = CargoWorkspace::from_cargo_metadata(&cargo_toml, cargo_features)\n                     .with_context(|| {\n                         format!(\n@@ -186,6 +208,7 @@ impl ProjectWorkspace {\n                 .map(|pkg| PackageRoot {\n                     path: cargo[pkg].root().to_path_buf(),\n                     is_member: cargo[pkg].is_member,\n+                    out_dir: cargo[pkg].out_dir.clone(),\n                 })\n                 .chain(sysroot.crates().map(|krate| {\n                     PackageRoot::new_non_member(sysroot[krate].root_dir().to_path_buf())\n@@ -194,17 +217,6 @@ impl ProjectWorkspace {\n         }\n     }\n \n-    pub fn out_dirs(&self) -> Vec<PathBuf> {\n-        match self {\n-            ProjectWorkspace::Json { project } => {\n-                project.crates.iter().filter_map(|krate| krate.out_dir.as_ref()).cloned().collect()\n-            }\n-            ProjectWorkspace::Cargo { cargo, sysroot: _ } => {\n-                cargo.packages().filter_map(|pkg| cargo[pkg].out_dir.as_ref()).cloned().collect()\n-            }\n-        }\n-    }\n-\n     pub fn proc_macro_dylib_paths(&self) -> Vec<PathBuf> {\n         match self {\n             ProjectWorkspace::Json { project } => project\n@@ -232,7 +244,7 @@ impl ProjectWorkspace {\n \n     pub fn to_crate_graph(\n         &self,\n-        default_cfg_options: &CfgOptions,\n+        target: Option<&str>,\n         extern_source_roots: &FxHashMap<PathBuf, ExternSourceId>,\n         proc_macro_client: &ProcMacroClient,\n         load: &mut dyn FnMut(&Path) -> Option<FileId>,\n@@ -251,12 +263,16 @@ impl ProjectWorkspace {\n                             json_project::Edition::Edition2018 => Edition::Edition2018,\n                         };\n                         let cfg_options = {\n-                            let mut opts = default_cfg_options.clone();\n-                            for name in &krate.atom_cfgs {\n-                                opts.insert_atom(name.into());\n-                            }\n-                            for (key, value) in &krate.key_value_cfgs {\n-                                opts.insert_key_value(key.into(), value.into());\n+                            let mut opts = CfgOptions::default();\n+                            for cfg in &krate.cfg {\n+                                match cfg.find('=') {\n+                                    None => opts.insert_atom(cfg.into()),\n+                                    Some(pos) => {\n+                                        let key = &cfg[..pos];\n+                                        let value = cfg[pos + 1..].trim_matches('\"');\n+                                        opts.insert_key_value(key.into(), value.into());\n+                                    }\n+                                }\n                             }\n                             opts\n                         };\n@@ -315,18 +331,13 @@ impl ProjectWorkspace {\n                 }\n             }\n             ProjectWorkspace::Cargo { cargo, sysroot } => {\n+                let mut cfg_options = get_rustc_cfg_options(target);\n+\n                 let sysroot_crates: FxHashMap<_, _> = sysroot\n                     .crates()\n                     .filter_map(|krate| {\n                         let file_id = load(&sysroot[krate].root)?;\n \n-                        // Crates from sysroot have `cfg(test)` disabled\n-                        let cfg_options = {\n-                            let mut opts = default_cfg_options.clone();\n-                            opts.remove_atom(\"test\");\n-                            opts\n-                        };\n-\n                         let env = Env::default();\n                         let extern_source = ExternSource::default();\n                         let proc_macro = vec![];\n@@ -337,7 +348,7 @@ impl ProjectWorkspace {\n                             file_id,\n                             Edition::Edition2018,\n                             Some(crate_name),\n-                            cfg_options,\n+                            cfg_options.clone(),\n                             env,\n                             extern_source,\n                             proc_macro,\n@@ -368,6 +379,10 @@ impl ProjectWorkspace {\n \n                 let mut pkg_to_lib_crate = FxHashMap::default();\n                 let mut pkg_crates = FxHashMap::default();\n+\n+                // Add test cfg for non-sysroot crates\n+                cfg_options.insert_atom(\"test\".into());\n+\n                 // Next, create crates for each package, target pair\n                 for pkg in cargo.packages() {\n                     let mut lib_tgt = None;\n@@ -376,7 +391,7 @@ impl ProjectWorkspace {\n                         if let Some(file_id) = load(root) {\n                             let edition = cargo[pkg].edition;\n                             let cfg_options = {\n-                                let mut opts = default_cfg_options.clone();\n+                                let mut opts = cfg_options.clone();\n                                 for feature in cargo[pkg].features.iter() {\n                                     opts.insert_key_value(\"feature\".into(), feature.into());\n                                 }\n@@ -533,7 +548,7 @@ impl ProjectWorkspace {\n     }\n }\n \n-pub fn get_rustc_cfg_options(target: Option<&String>) -> CfgOptions {\n+fn get_rustc_cfg_options(target: Option<&str>) -> CfgOptions {\n     let mut cfg_options = CfgOptions::default();\n \n     // Some nightly-only cfgs, which are required for stdlib\n@@ -551,7 +566,7 @@ pub fn get_rustc_cfg_options(target: Option<&String>) -> CfgOptions {\n         let mut cmd = Command::new(ra_toolchain::rustc());\n         cmd.args(&[\"--print\", \"cfg\", \"-O\"]);\n         if let Some(target) = target {\n-            cmd.args(&[\"--target\", target.as_str()]);\n+            cmd.args(&[\"--target\", target]);\n         }\n         let output = output(cmd)?;\n         Ok(String::from_utf8(output.stdout)?)\n@@ -573,6 +588,8 @@ pub fn get_rustc_cfg_options(target: Option<&String>) -> CfgOptions {\n         Err(e) => log::error!(\"failed to get rustc cfgs: {:#}\", e),\n     }\n \n+    cfg_options.insert_atom(\"debug_assertions\".into());\n+\n     cfg_options\n }\n "}, {"sha": "9d02aeef3fa2a7659e90428f9b86daa845eed37a", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -75,7 +75,7 @@ impl<N> AstChildren<N> {\n impl<N: AstNode> Iterator for AstChildren<N> {\n     type Item = N;\n     fn next(&mut self) -> Option<N> {\n-        self.inner.by_ref().find_map(N::cast)\n+        self.inner.find_map(N::cast)\n     }\n }\n \n@@ -285,6 +285,8 @@ where\n     let pred = predicates.next().unwrap();\n     let mut bounds = pred.type_bound_list().unwrap().bounds();\n \n+    assert!(pred.for_token().is_none());\n+    assert!(pred.type_param_list().is_none());\n     assert_eq!(\"T\", pred.type_ref().unwrap().syntax().text().to_string());\n     assert_bound(\"Clone\", bounds.next());\n     assert_bound(\"Copy\", bounds.next());\n@@ -322,6 +324,8 @@ where\n     let pred = predicates.next().unwrap();\n     let mut bounds = pred.type_bound_list().unwrap().bounds();\n \n-    assert_eq!(\"for<'a> F\", pred.type_ref().unwrap().syntax().text().to_string());\n+    assert!(pred.for_token().is_some());\n+    assert_eq!(\"<'a>\", pred.type_param_list().unwrap().syntax().text().to_string());\n+    assert_eq!(\"F\", pred.type_ref().unwrap().syntax().text().to_string());\n     assert_bound(\"Fn(&'a str)\", bounds.next());\n }"}, {"sha": "2ef173a03970d737e0fc7c2bf21abdeaf008ee0a", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -579,12 +579,17 @@ pub trait AstNodeEdit: AstNode + Clone + Sized {\n         rewriter.rewrite_ast(self)\n     }\n     #[must_use]\n-    fn indent(&self, indent: IndentLevel) -> Self {\n-        Self::cast(indent.increase_indent(self.syntax().clone())).unwrap()\n+    fn indent(&self, level: IndentLevel) -> Self {\n+        Self::cast(level.increase_indent(self.syntax().clone())).unwrap()\n     }\n     #[must_use]\n-    fn dedent(&self, indent: IndentLevel) -> Self {\n-        Self::cast(indent.decrease_indent(self.syntax().clone())).unwrap()\n+    fn dedent(&self, level: IndentLevel) -> Self {\n+        Self::cast(level.decrease_indent(self.syntax().clone())).unwrap()\n+    }\n+    #[must_use]\n+    fn reset_indent(&self) -> Self {\n+        let level = IndentLevel::from_node(self.syntax());\n+        self.dedent(level)\n     }\n }\n "}, {"sha": "58141da11426579788040106a2395307fdaa58a8", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 139, "deletions": 137, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -2052,6 +2052,8 @@ pub struct WherePred {\n }\n impl ast::TypeBoundsOwner for WherePred {}\n impl WherePred {\n+    pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n+    pub fn type_param_list(&self) -> Option<TypeParamList> { support::child(&self.syntax) }\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n         support::token(&self.syntax, T![lifetime])\n     }\n@@ -4849,687 +4851,687 @@ impl AstNode for FieldDefList {\n     }\n }\n impl std::fmt::Display for NominalDef {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for GenericParam {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for GenericArg {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TypeRef {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ModuleItem {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for AssocItem {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ExternItem {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for Expr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for Pat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for RecordInnerPat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for AttrInput {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for Stmt {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for FieldDefList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for SourceFile {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for FnDef {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for RetType {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for StructDef {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for UnionDef {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for RecordFieldDefList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for RecordFieldDef {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TupleFieldDefList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TupleFieldDef {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for EnumDef {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for EnumVariantList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for EnumVariant {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TraitDef {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for Module {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ItemList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ConstDef {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for StaticDef {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TypeAliasDef {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ImplDef {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ParenType {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TupleType {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for NeverType {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for PathType {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for PointerType {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ArrayType {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for SliceType {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ReferenceType {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for PlaceholderType {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for FnPointerType {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ForType {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ImplTraitType {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for DynTraitType {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TupleExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ArrayExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ParenExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for PathExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for LambdaExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for IfExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for LoopExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for EffectExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ForExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for WhileExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ContinueExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for BreakExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for Label {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for BlockExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ReturnExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for CallExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for MethodCallExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for IndexExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for FieldExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for AwaitExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TryExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for CastExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for RefExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for PrefixExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for BoxExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for RangeExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for BinExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for Literal {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for MatchExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for MatchArmList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for MatchArm {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for MatchGuard {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for RecordLit {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for RecordFieldList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for RecordField {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for OrPat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ParenPat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for RefPat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for BoxPat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for BindPat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for PlaceholderPat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for DotDotPat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for PathPat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for SlicePat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for RangePat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for LiteralPat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for MacroPat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for RecordPat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for RecordFieldPatList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for RecordFieldPat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TupleStructPat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TuplePat {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for Visibility {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for Name {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for NameRef {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for MacroCall {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for Attr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TokenTree {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TypeParamList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TypeParam {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ConstParam {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for LifetimeParam {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TypeBound {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TypeBoundList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for WherePred {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for WhereClause {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for Abi {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ExprStmt {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for LetStmt {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for Condition {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ParamList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for SelfParam {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for Param {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for UseItem {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for UseTree {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for Alias {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for UseTreeList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ExternCrateItem {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ArgList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for Path {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for PathSegment {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TypeArgList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for TypeArg {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for AssocTypeArg {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for LifetimeArg {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ConstArg {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for MacroItems {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for MacroStmts {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ExternItemList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for ExternBlock {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for MetaItem {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n impl std::fmt::Display for MacroDef {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }"}, {"sha": "abadd0b61c6f3dd7f3c8d0a1004e4a5d878c10f0", "filename": "crates/ra_syntax/src/ast/generated/tokens.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -11,7 +11,7 @@ pub struct Whitespace {\n     pub(crate) syntax: SyntaxToken,\n }\n impl std::fmt::Display for Whitespace {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(&self.syntax, f)\n     }\n }\n@@ -32,7 +32,7 @@ pub struct Comment {\n     pub(crate) syntax: SyntaxToken,\n }\n impl std::fmt::Display for Comment {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(&self.syntax, f)\n     }\n }\n@@ -53,7 +53,7 @@ pub struct String {\n     pub(crate) syntax: SyntaxToken,\n }\n impl std::fmt::Display for String {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(&self.syntax, f)\n     }\n }\n@@ -74,7 +74,7 @@ pub struct RawString {\n     pub(crate) syntax: SyntaxToken,\n }\n impl std::fmt::Display for RawString {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(&self.syntax, f)\n     }\n }"}, {"sha": "2e72d49275893b5f1cf25a6a0b354e88800dd491", "filename": "crates/ra_syntax/src/ast/tokens.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -84,7 +84,7 @@ impl Whitespace {\n }\n \n pub struct QuoteOffsets {\n-    pub quotes: [TextRange; 2],\n+    pub quotes: (TextRange, TextRange),\n     pub contents: TextRange,\n }\n \n@@ -103,7 +103,7 @@ impl QuoteOffsets {\n         let end = TextSize::of(literal);\n \n         let res = QuoteOffsets {\n-            quotes: [TextRange::new(start, left_quote), TextRange::new(right_quote, end)],\n+            quotes: (TextRange::new(start, left_quote), TextRange::new(right_quote, end)),\n             contents: TextRange::new(left_quote, right_quote),\n         };\n         Some(res)\n@@ -116,17 +116,17 @@ pub trait HasQuotes: AstToken {\n         let offsets = QuoteOffsets::new(text)?;\n         let o = self.syntax().text_range().start();\n         let offsets = QuoteOffsets {\n-            quotes: [offsets.quotes[0] + o, offsets.quotes[1] + o],\n+            quotes: (offsets.quotes.0 + o, offsets.quotes.1 + o),\n             contents: offsets.contents + o,\n         };\n         Some(offsets)\n     }\n     fn open_quote_text_range(&self) -> Option<TextRange> {\n-        self.quote_offsets().map(|it| it.quotes[0])\n+        self.quote_offsets().map(|it| it.quotes.0)\n     }\n \n     fn close_quote_text_range(&self) -> Option<TextRange> {\n-        self.quote_offsets().map(|it| it.quotes[1])\n+        self.quote_offsets().map(|it| it.quotes.1)\n     }\n \n     fn text_range_between_quotes(&self) -> Option<TextRange> {\n@@ -335,16 +335,26 @@ pub trait HasFormatSpecifier: AstToken {\n                             }\n                             c if c == '_' || c.is_alphabetic() => {\n                                 read_identifier(&mut chars, &mut callback);\n-                                if chars.peek().and_then(|next| next.1.as_ref().ok()).copied()\n-                                    != Some('$')\n-                                {\n-                                    continue;\n-                                }\n-                                skip_char_and_emit(\n-                                    &mut chars,\n-                                    FormatSpecifier::DollarSign,\n-                                    &mut callback,\n-                                );\n+                                // can be either width (indicated by dollar sign, or type in which case\n+                                // the next sign has to be `}`)\n+                                let next =\n+                                    chars.peek().and_then(|next| next.1.as_ref().ok()).copied();\n+                                match next {\n+                                    Some('$') => skip_char_and_emit(\n+                                        &mut chars,\n+                                        FormatSpecifier::DollarSign,\n+                                        &mut callback,\n+                                    ),\n+                                    Some('}') => {\n+                                        skip_char_and_emit(\n+                                            &mut chars,\n+                                            FormatSpecifier::Close,\n+                                            &mut callback,\n+                                        );\n+                                        continue;\n+                                    }\n+                                    _ => continue,\n+                                };\n                             }\n                             _ => {}\n                         }\n@@ -416,17 +426,11 @@ pub trait HasFormatSpecifier: AstToken {\n                         }\n                     }\n \n-                    let mut cloned = chars.clone().take(2);\n-                    let first = cloned.next().and_then(|next| next.1.as_ref().ok()).copied();\n-                    let second = cloned.next().and_then(|next| next.1.as_ref().ok()).copied();\n-                    if first != Some('}') {\n-                        continue;\n-                    }\n-                    if second == Some('}') {\n-                        // Escaped format end specifier, `}}`\n+                    if let Some((_, Ok('}'))) = chars.peek() {\n+                        skip_char_and_emit(&mut chars, FormatSpecifier::Close, &mut callback);\n+                    } else {\n                         continue;\n                     }\n-                    skip_char_and_emit(&mut chars, FormatSpecifier::Close, &mut callback);\n                 }\n                 _ => {\n                     while let Some((_, Ok(next_char))) = chars.peek() {"}, {"sha": "a8f2454fd96e861209a9345911cef983ce41ace4", "filename": "crates/ra_syntax/src/ast/traits.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftraits.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -83,13 +83,22 @@ pub trait DocCommentsOwner: AstNode {\n         CommentIter { iter: self.syntax().children_with_tokens() }\n     }\n \n+    fn doc_comment_text(&self) -> Option<String> {\n+        self.doc_comments().doc_comment_text()\n+    }\n+}\n+\n+impl CommentIter {\n+    pub fn from_syntax_node(syntax_node: &ast::SyntaxNode) -> CommentIter {\n+        CommentIter { iter: syntax_node.children_with_tokens() }\n+    }\n+\n     /// Returns the textual content of a doc comment block as a single string.\n     /// That is, strips leading `///` (+ optional 1 character of whitespace),\n     /// trailing `*/`, trailing whitespace and then joins the lines.\n-    fn doc_comment_text(&self) -> Option<String> {\n+    pub fn doc_comment_text(self) -> Option<String> {\n         let mut has_comments = false;\n         let docs = self\n-            .doc_comments()\n             .filter(|comment| comment.kind().doc.is_some())\n             .map(|comment| {\n                 has_comments = true;"}, {"sha": "48610a5ebbe2ae29c2cfc439c03a982ad96f944a", "filename": "crates/ra_syntax/test_data/parser/err/0024_many_type_parens.rast", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.rast", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.rast?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -180,44 +180,45 @@ SOURCE_FILE@0..240\n       EXPR_STMT@150..180\n         TUPLE_EXPR@150..180\n           L_PAREN@150..151 \"(\"\n-          BIN_EXPR@151..180\n-            BIN_EXPR@151..178\n-              BIN_EXPR@151..169\n-                BIN_EXPR@151..167\n-                  BIN_EXPR@151..164\n-                    FOR_EXPR@151..157\n-                      FOR_KW@151..154 \"for\"\n-                      ERROR@154..155\n-                        L_ANGLE@154..155 \"<\"\n-                      ERROR@155..157\n-                        LIFETIME@155..157 \"\\'a\"\n-                    R_ANGLE@157..158 \">\"\n-                    WHITESPACE@158..159 \" \"\n+          FOR_EXPR@151..180\n+            FOR_KW@151..154 \"for\"\n+            PATH_PAT@154..158\n+              PATH@154..158\n+                PATH_SEGMENT@154..158\n+                  L_ANGLE@154..155 \"<\"\n+                  ERROR@155..157\n+                    LIFETIME@155..157 \"\\'a\"\n+                  R_ANGLE@157..158 \">\"\n+            WHITESPACE@158..159 \" \"\n+            BIN_EXPR@159..180\n+              BIN_EXPR@159..178\n+                BIN_EXPR@159..169\n+                  BIN_EXPR@159..167\n                     PATH_EXPR@159..164\n                       PATH@159..164\n                         PATH_SEGMENT@159..164\n                           NAME_REF@159..164\n                             IDENT@159..164 \"Trait\"\n-                  L_ANGLE@164..165 \"<\"\n-                  ERROR@165..167\n-                    LIFETIME@165..167 \"\\'a\"\n-                R_ANGLE@167..168 \">\"\n-                ERROR@168..169\n-                  R_PAREN@168..169 \")\"\n-              WHITESPACE@169..170 \" \"\n-              PLUS@170..171 \"+\"\n-              WHITESPACE@171..172 \" \"\n-              PAREN_EXPR@172..178\n-                L_PAREN@172..173 \"(\"\n-                PATH_EXPR@173..177\n-                  PATH@173..177\n-                    PATH_SEGMENT@173..177\n-                      NAME_REF@173..177\n-                        IDENT@173..177 \"Copy\"\n-                R_PAREN@177..178 \")\"\n-            R_ANGLE@178..179 \">\"\n-            ERROR@179..180\n-              SEMICOLON@179..180 \";\"\n+                    L_ANGLE@164..165 \"<\"\n+                    ERROR@165..167\n+                      LIFETIME@165..167 \"\\'a\"\n+                  R_ANGLE@167..168 \">\"\n+                  ERROR@168..169\n+                    R_PAREN@168..169 \")\"\n+                WHITESPACE@169..170 \" \"\n+                PLUS@170..171 \"+\"\n+                WHITESPACE@171..172 \" \"\n+                PAREN_EXPR@172..178\n+                  L_PAREN@172..173 \"(\"\n+                  PATH_EXPR@173..177\n+                    PATH@173..177\n+                      PATH_SEGMENT@173..177\n+                        NAME_REF@173..177\n+                          IDENT@173..177 \"Copy\"\n+                  R_PAREN@177..178 \")\"\n+              R_ANGLE@178..179 \">\"\n+              ERROR@179..180\n+                SEMICOLON@179..180 \";\"\n       WHITESPACE@180..185 \"\\n    \"\n       LET_STMT@185..235\n         LET_KW@185..188 \"let\"\n@@ -302,13 +303,12 @@ error 146..146: expected expression\n error 147..147: expected SEMICOLON\n error 148..148: expected expression\n error 149..149: expected SEMICOLON\n-error 154..154: expected pattern\n-error 155..155: expected IN_KW\n-error 155..155: expected expression\n-error 157..157: expected a block\n+error 155..155: expected type\n+error 158..158: expected IN_KW\n error 165..165: expected expression\n error 168..168: expected expression\n error 179..179: expected expression\n+error 180..180: expected a block\n error 180..180: expected COMMA\n error 180..180: expected expression\n error 180..180: expected R_PAREN"}, {"sha": "4d6461d1e195da553feb721bd4c344c7e8a86c51", "filename": "crates/ra_syntax/test_data/parser/err/0027_incomplere_where_for.rast", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0027_incomplere_where_for.rast", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0027_incomplere_where_for.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0027_incomplere_where_for.rast?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -12,17 +12,16 @@ SOURCE_FILE@0..30\n       WHERE_KW@13..18 \"where\"\n       WHITESPACE@18..19 \" \"\n       WHERE_PRED@19..26\n-        FOR_TYPE@19..26\n-          FOR_KW@19..22 \"for\"\n-          TYPE_PARAM_LIST@22..26\n-            L_ANGLE@22..23 \"<\"\n-            LIFETIME_PARAM@23..25\n-              LIFETIME@23..25 \"\\'a\"\n-            R_ANGLE@25..26 \">\"\n+        FOR_KW@19..22 \"for\"\n+        TYPE_PARAM_LIST@22..26\n+          L_ANGLE@22..23 \"<\"\n+          LIFETIME_PARAM@23..25\n+            LIFETIME@23..25 \"\\'a\"\n+          R_ANGLE@25..26 \">\"\n     WHITESPACE@26..27 \"\\n\"\n     BLOCK_EXPR@27..29\n       L_CURLY@27..28 \"{\"\n       R_CURLY@28..29 \"}\"\n   WHITESPACE@29..30 \"\\n\"\n-error 26..26: expected a path\n+error 26..26: expected type\n error 26..26: expected colon"}, {"sha": "8eb583ef85ccc70d005978c839226c86834e89ef", "filename": "crates/ra_syntax/test_data/parser/err/0043_default_const.rast", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0043_default_const.rast", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0043_default_const.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0043_default_const.rast?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,40 @@\n+SOURCE_FILE@0..39\n+  TRAIT_DEF@0..38\n+    TRAIT_KW@0..5 \"trait\"\n+    WHITESPACE@5..6 \" \"\n+    NAME@6..7\n+      IDENT@6..7 \"T\"\n+    WHITESPACE@7..8 \" \"\n+    ITEM_LIST@8..38\n+      L_CURLY@8..9 \"{\"\n+      WHITESPACE@9..12 \"\\n  \"\n+      MACRO_CALL@12..19\n+        PATH@12..19\n+          PATH_SEGMENT@12..19\n+            NAME_REF@12..19\n+              IDENT@12..19 \"default\"\n+      WHITESPACE@19..20 \" \"\n+      CONST_DEF@20..36\n+        CONST_KW@20..25 \"const\"\n+        WHITESPACE@25..26 \" \"\n+        NAME@26..27\n+          IDENT@26..27 \"f\"\n+        COLON@27..28 \":\"\n+        WHITESPACE@28..29 \" \"\n+        PATH_TYPE@29..31\n+          PATH@29..31\n+            PATH_SEGMENT@29..31\n+              NAME_REF@29..31\n+                IDENT@29..31 \"u8\"\n+        WHITESPACE@31..32 \" \"\n+        EQ@32..33 \"=\"\n+        WHITESPACE@33..34 \" \"\n+        LITERAL@34..35\n+          INT_NUMBER@34..35 \"0\"\n+        SEMICOLON@35..36 \";\"\n+      WHITESPACE@36..37 \"\\n\"\n+      R_CURLY@37..38 \"}\"\n+  WHITESPACE@38..39 \"\\n\"\n+error 19..19: expected BANG\n+error 19..19: expected `{`, `[`, `(`\n+error 19..19: expected SEMICOLON"}, {"sha": "80f15474a5d0dcc39ba6dd4ccee087b96edbf172", "filename": "crates/ra_syntax/test_data/parser/err/0043_default_const.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0043_default_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0043_default_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0043_default_const.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,3 @@\n+trait T {\n+  default const f: u8 = 0;\n+}"}, {"sha": "cb90f28bc74a5bb79d7296eaa183ad0f25eddd59", "filename": "crates/ra_syntax/test_data/parser/err/0044_unexpected_for_type.rast", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0044_unexpected_for_type.rast", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0044_unexpected_for_type.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0044_unexpected_for_type.rast?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,240 @@\n+SOURCE_FILE@0..239\n+  TYPE_ALIAS_DEF@0..30\n+    TYPE_KW@0..4 \"type\"\n+    WHITESPACE@4..5 \" \"\n+    NAME@5..11\n+      IDENT@5..11 \"ForRef\"\n+    WHITESPACE@11..12 \" \"\n+    EQ@12..13 \"=\"\n+    WHITESPACE@13..14 \" \"\n+    FOR_TYPE@14..29\n+      FOR_KW@14..17 \"for\"\n+      TYPE_PARAM_LIST@17..21\n+        L_ANGLE@17..18 \"<\"\n+        LIFETIME_PARAM@18..20\n+          LIFETIME@18..20 \"\\'a\"\n+        R_ANGLE@20..21 \">\"\n+      WHITESPACE@21..22 \" \"\n+      REFERENCE_TYPE@22..29\n+        AMP@22..23 \"&\"\n+        LIFETIME@23..25 \"\\'a\"\n+        WHITESPACE@25..26 \" \"\n+        PATH_TYPE@26..29\n+          PATH@26..29\n+            PATH_SEGMENT@26..29\n+              NAME_REF@26..29\n+                IDENT@26..29 \"u32\"\n+    SEMICOLON@29..30 \";\"\n+  WHITESPACE@30..31 \"\\n\"\n+  TYPE_ALIAS_DEF@31..64\n+    TYPE_KW@31..35 \"type\"\n+    WHITESPACE@35..36 \" \"\n+    NAME@36..42\n+      IDENT@36..42 \"ForTup\"\n+    WHITESPACE@42..43 \" \"\n+    EQ@43..44 \"=\"\n+    WHITESPACE@44..45 \" \"\n+    FOR_TYPE@45..63\n+      FOR_KW@45..48 \"for\"\n+      TYPE_PARAM_LIST@48..52\n+        L_ANGLE@48..49 \"<\"\n+        LIFETIME_PARAM@49..51\n+          LIFETIME@49..51 \"\\'a\"\n+        R_ANGLE@51..52 \">\"\n+      WHITESPACE@52..53 \" \"\n+      TUPLE_TYPE@53..63\n+        L_PAREN@53..54 \"(\"\n+        REFERENCE_TYPE@54..61\n+          AMP@54..55 \"&\"\n+          LIFETIME@55..57 \"\\'a\"\n+          WHITESPACE@57..58 \" \"\n+          PATH_TYPE@58..61\n+            PATH@58..61\n+              PATH_SEGMENT@58..61\n+                NAME_REF@58..61\n+                  IDENT@58..61 \"u32\"\n+        COMMA@61..62 \",\"\n+        R_PAREN@62..63 \")\"\n+    SEMICOLON@63..64 \";\"\n+  WHITESPACE@64..65 \"\\n\"\n+  TYPE_ALIAS_DEF@65..95\n+    TYPE_KW@65..69 \"type\"\n+    WHITESPACE@69..70 \" \"\n+    NAME@70..78\n+      IDENT@70..78 \"ForSlice\"\n+    WHITESPACE@78..79 \" \"\n+    EQ@79..80 \"=\"\n+    WHITESPACE@80..81 \" \"\n+    FOR_TYPE@81..94\n+      FOR_KW@81..84 \"for\"\n+      TYPE_PARAM_LIST@84..88\n+        L_ANGLE@84..85 \"<\"\n+        LIFETIME_PARAM@85..87\n+          LIFETIME@85..87 \"\\'a\"\n+        R_ANGLE@87..88 \">\"\n+      WHITESPACE@88..89 \" \"\n+      SLICE_TYPE@89..94\n+        L_BRACK@89..90 \"[\"\n+        PATH_TYPE@90..93\n+          PATH@90..93\n+            PATH_SEGMENT@90..93\n+              NAME_REF@90..93\n+                IDENT@90..93 \"u32\"\n+        R_BRACK@93..94 \"]\"\n+    SEMICOLON@94..95 \";\"\n+  WHITESPACE@95..96 \"\\n\"\n+  TYPE_ALIAS_DEF@96..149\n+    TYPE_KW@96..100 \"type\"\n+    WHITESPACE@100..101 \" \"\n+    NAME@101..109\n+      IDENT@101..109 \"ForForFn\"\n+    WHITESPACE@109..110 \" \"\n+    EQ@110..111 \"=\"\n+    WHITESPACE@111..112 \" \"\n+    FOR_TYPE@112..148\n+      FOR_KW@112..115 \"for\"\n+      TYPE_PARAM_LIST@115..119\n+        L_ANGLE@115..116 \"<\"\n+        LIFETIME_PARAM@116..118\n+          LIFETIME@116..118 \"\\'a\"\n+        R_ANGLE@118..119 \">\"\n+      WHITESPACE@119..120 \" \"\n+      FOR_TYPE@120..148\n+        FOR_KW@120..123 \"for\"\n+        TYPE_PARAM_LIST@123..127\n+          L_ANGLE@123..124 \"<\"\n+          LIFETIME_PARAM@124..126\n+            LIFETIME@124..126 \"\\'b\"\n+          R_ANGLE@126..127 \">\"\n+        WHITESPACE@127..128 \" \"\n+        FN_POINTER_TYPE@128..148\n+          FN_KW@128..130 \"fn\"\n+          PARAM_LIST@130..148\n+            L_PAREN@130..131 \"(\"\n+            PARAM@131..138\n+              REFERENCE_TYPE@131..138\n+                AMP@131..132 \"&\"\n+                LIFETIME@132..134 \"\\'a\"\n+                WHITESPACE@134..135 \" \"\n+                PATH_TYPE@135..138\n+                  PATH@135..138\n+                    PATH_SEGMENT@135..138\n+                      NAME_REF@135..138\n+                        IDENT@135..138 \"i32\"\n+            COMMA@138..139 \",\"\n+            WHITESPACE@139..140 \" \"\n+            PARAM@140..147\n+              REFERENCE_TYPE@140..147\n+                AMP@140..141 \"&\"\n+                LIFETIME@141..143 \"\\'b\"\n+                WHITESPACE@143..144 \" \"\n+                PATH_TYPE@144..147\n+                  PATH@144..147\n+                    PATH_SEGMENT@144..147\n+                      NAME_REF@144..147\n+                        IDENT@144..147 \"i32\"\n+            R_PAREN@147..148 \")\"\n+    SEMICOLON@148..149 \";\"\n+  WHITESPACE@149..150 \"\\n\"\n+  FN_DEF@150..238\n+    FN_KW@150..152 \"fn\"\n+    WHITESPACE@152..153 \" \"\n+    NAME@153..164\n+      IDENT@153..164 \"for_for_for\"\n+    TYPE_PARAM_LIST@164..167\n+      L_ANGLE@164..165 \"<\"\n+      TYPE_PARAM@165..166\n+        NAME@165..166\n+          IDENT@165..166 \"T\"\n+      R_ANGLE@166..167 \">\"\n+    PARAM_LIST@167..169\n+      L_PAREN@167..168 \"(\"\n+      R_PAREN@168..169 \")\"\n+    WHITESPACE@169..170 \"\\n\"\n+    WHERE_CLAUSE@170..234\n+      WHERE_KW@170..175 \"where\"\n+      WHITESPACE@175..180 \"\\n    \"\n+      WHERE_PRED@180..233\n+        FOR_KW@180..183 \"for\"\n+        TYPE_PARAM_LIST@183..187\n+          L_ANGLE@183..184 \"<\"\n+          LIFETIME_PARAM@184..186\n+            LIFETIME@184..186 \"\\'a\"\n+          R_ANGLE@186..187 \">\"\n+        WHITESPACE@187..188 \" \"\n+        FOR_TYPE@188..227\n+          FOR_KW@188..191 \"for\"\n+          TYPE_PARAM_LIST@191..195\n+            L_ANGLE@191..192 \"<\"\n+            LIFETIME_PARAM@192..194\n+              LIFETIME@192..194 \"\\'b\"\n+            R_ANGLE@194..195 \">\"\n+          WHITESPACE@195..196 \" \"\n+          FOR_TYPE@196..227\n+            FOR_KW@196..199 \"for\"\n+            TYPE_PARAM_LIST@199..203\n+              L_ANGLE@199..200 \"<\"\n+              LIFETIME_PARAM@200..202\n+                LIFETIME@200..202 \"\\'c\"\n+              R_ANGLE@202..203 \">\"\n+            WHITESPACE@203..204 \" \"\n+            FN_POINTER_TYPE@204..227\n+              FN_KW@204..206 \"fn\"\n+              PARAM_LIST@206..227\n+                L_PAREN@206..207 \"(\"\n+                PARAM@207..212\n+                  REFERENCE_TYPE@207..212\n+                    AMP@207..208 \"&\"\n+                    LIFETIME@208..210 \"\\'a\"\n+                    WHITESPACE@210..211 \" \"\n+                    PATH_TYPE@211..212\n+                      PATH@211..212\n+                        PATH_SEGMENT@211..212\n+                          NAME_REF@211..212\n+                            IDENT@211..212 \"T\"\n+                COMMA@212..213 \",\"\n+                WHITESPACE@213..214 \" \"\n+                PARAM@214..219\n+                  REFERENCE_TYPE@214..219\n+                    AMP@214..215 \"&\"\n+                    LIFETIME@215..217 \"\\'b\"\n+                    WHITESPACE@217..218 \" \"\n+                    PATH_TYPE@218..219\n+                      PATH@218..219\n+                        PATH_SEGMENT@218..219\n+                          NAME_REF@218..219\n+                            IDENT@218..219 \"T\"\n+                COMMA@219..220 \",\"\n+                WHITESPACE@220..221 \" \"\n+                PARAM@221..226\n+                  REFERENCE_TYPE@221..226\n+                    AMP@221..222 \"&\"\n+                    LIFETIME@222..224 \"\\'c\"\n+                    WHITESPACE@224..225 \" \"\n+                    PATH_TYPE@225..226\n+                      PATH@225..226\n+                        PATH_SEGMENT@225..226\n+                          NAME_REF@225..226\n+                            IDENT@225..226 \"T\"\n+                R_PAREN@226..227 \")\"\n+        COLON@227..228 \":\"\n+        WHITESPACE@228..229 \" \"\n+        TYPE_BOUND_LIST@229..233\n+          TYPE_BOUND@229..233\n+            PATH_TYPE@229..233\n+              PATH@229..233\n+                PATH_SEGMENT@229..233\n+                  NAME_REF@229..233\n+                    IDENT@229..233 \"Copy\"\n+      COMMA@233..234 \",\"\n+    WHITESPACE@234..235 \"\\n\"\n+    BLOCK_EXPR@235..238\n+      L_CURLY@235..236 \"{\"\n+      WHITESPACE@236..237 \"\\n\"\n+      R_CURLY@237..238 \"}\"\n+  WHITESPACE@238..239 \"\\n\"\n+error 21..21: expected a function pointer or path\n+error 52..52: expected a function pointer or path\n+error 88..88: expected a function pointer or path\n+error 119..119: expected a function pointer or path\n+error 195..195: expected a function pointer or path"}, {"sha": "0e9f8ccb4f84bc978f2ee9715f6c18dc5dd66df7", "filename": "crates/ra_syntax/test_data/parser/err/0044_unexpected_for_type.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0044_unexpected_for_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0044_unexpected_for_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Ferr%2F0044_unexpected_for_type.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,9 @@\n+type ForRef = for<'a> &'a u32;\n+type ForTup = for<'a> (&'a u32,);\n+type ForSlice = for<'a> [u32];\n+type ForForFn = for<'a> for<'b> fn(&'a i32, &'b i32);\n+fn for_for_for<T>()\n+where\n+    for<'a> for<'b> for<'c> fn(&'a T, &'b T, &'c T): Copy,\n+{\n+}"}, {"sha": "53f7ebaf9a724bce2117a965d437556e91125894", "filename": "crates/ra_syntax/test_data/parser/inline/err/0010_wrong_order_fns.rast", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0010_wrong_order_fns.rast", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0010_wrong_order_fns.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Ferr%2F0010_wrong_order_fns.rast?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -17,23 +17,29 @@ SOURCE_FILE@0..50\n       L_CURLY@22..23 \"{\"\n       R_CURLY@23..24 \"}\"\n   WHITESPACE@24..25 \"\\n\"\n-  ERROR@25..31\n+  CONST_DEF@25..46\n     UNSAFE_KW@25..31 \"unsafe\"\n-  WHITESPACE@31..32 \" \"\n-  FN_DEF@32..49\n+    WHITESPACE@31..32 \" \"\n     CONST_KW@32..37 \"const\"\n     WHITESPACE@37..38 \" \"\n-    FN_KW@38..40 \"fn\"\n+    ERROR@38..40\n+      FN_KW@38..40 \"fn\"\n     WHITESPACE@40..41 \" \"\n-    NAME@41..44\n-      IDENT@41..44 \"bar\"\n-    PARAM_LIST@44..46\n-      L_PAREN@44..45 \"(\"\n-      R_PAREN@45..46 \")\"\n-    WHITESPACE@46..47 \" \"\n-    BLOCK_EXPR@47..49\n-      L_CURLY@47..48 \"{\"\n-      R_CURLY@48..49 \"}\"\n+    PATH_TYPE@41..46\n+      PATH@41..46\n+        PATH_SEGMENT@41..46\n+          NAME_REF@41..44\n+            IDENT@41..44 \"bar\"\n+          PARAM_LIST@44..46\n+            L_PAREN@44..45 \"(\"\n+            R_PAREN@45..46 \")\"\n+  WHITESPACE@46..47 \" \"\n+  ERROR@47..49\n+    L_CURLY@47..48 \"{\"\n+    R_CURLY@48..49 \"}\"\n   WHITESPACE@49..50 \"\\n\"\n error 6..6: expected existential, fn, trait or impl\n-error 31..31: expected existential, fn, trait or impl\n+error 38..38: expected a name\n+error 40..40: expected COLON\n+error 46..46: expected SEMICOLON\n+error 47..47: expected an item"}, {"sha": "cd0892451d9e9819a6b2a2bc04ae7ff83ffdb446", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0003_where_pred_for.rast", "status": "modified", "additions": 58, "deletions": 59, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0003_where_pred_for.rast", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0003_where_pred_for.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0003_where_pred_for.rast?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,61 +1,60 @@\n-SOURCE_FILE@0..49\n-  FN_DEF@0..48\n+SOURCE_FILE@0..54\n+  FN_DEF@0..53\n     FN_KW@0..2 \"fn\"\n     WHITESPACE@2..3 \" \"\n-    NAME@3..7\n-      IDENT@3..7 \"test\"\n-    TYPE_PARAM_LIST@7..10\n-      L_ANGLE@7..8 \"<\"\n-      TYPE_PARAM@8..9\n-        NAME@8..9\n-          IDENT@8..9 \"F\"\n-      R_ANGLE@9..10 \">\"\n-    PARAM_LIST@10..12\n-      L_PAREN@10..11 \"(\"\n-      R_PAREN@11..12 \")\"\n-    WHITESPACE@12..13 \"\\n\"\n-    WHERE_CLAUSE@13..44\n-      WHERE_KW@13..18 \"where\"\n-      WHITESPACE@18..22 \"\\n   \"\n-      WHERE_PRED@22..44\n-        FOR_TYPE@22..31\n-          FOR_KW@22..25 \"for\"\n-          TYPE_PARAM_LIST@25..29\n-            L_ANGLE@25..26 \"<\"\n-            LIFETIME_PARAM@26..28\n-              LIFETIME@26..28 \"\\'a\"\n-            R_ANGLE@28..29 \">\"\n-          WHITESPACE@29..30 \" \"\n-          PATH_TYPE@30..31\n-            PATH@30..31\n-              PATH_SEGMENT@30..31\n-                NAME_REF@30..31\n-                  IDENT@30..31 \"F\"\n-        COLON@31..32 \":\"\n-        WHITESPACE@32..33 \" \"\n-        TYPE_BOUND_LIST@33..44\n-          TYPE_BOUND@33..44\n-            PATH_TYPE@33..44\n-              PATH@33..44\n-                PATH_SEGMENT@33..44\n-                  NAME_REF@33..35\n-                    IDENT@33..35 \"Fn\"\n-                  PARAM_LIST@35..44\n-                    L_PAREN@35..36 \"(\"\n-                    PARAM@36..43\n-                      REFERENCE_TYPE@36..43\n-                        AMP@36..37 \"&\"\n-                        LIFETIME@37..39 \"\\'a\"\n-                        WHITESPACE@39..40 \" \"\n-                        PATH_TYPE@40..43\n-                          PATH@40..43\n-                            PATH_SEGMENT@40..43\n-                              NAME_REF@40..43\n-                                IDENT@40..43 \"str\"\n-                    R_PAREN@43..44 \")\"\n-    WHITESPACE@44..45 \"\\n\"\n-    BLOCK_EXPR@45..48\n-      L_CURLY@45..46 \"{\"\n-      WHITESPACE@46..47 \" \"\n-      R_CURLY@47..48 \"}\"\n-  WHITESPACE@48..49 \"\\n\"\n+    NAME@3..12\n+      IDENT@3..12 \"for_trait\"\n+    TYPE_PARAM_LIST@12..15\n+      L_ANGLE@12..13 \"<\"\n+      TYPE_PARAM@13..14\n+        NAME@13..14\n+          IDENT@13..14 \"F\"\n+      R_ANGLE@14..15 \">\"\n+    PARAM_LIST@15..17\n+      L_PAREN@15..16 \"(\"\n+      R_PAREN@16..17 \")\"\n+    WHITESPACE@17..18 \"\\n\"\n+    WHERE_CLAUSE@18..49\n+      WHERE_KW@18..23 \"where\"\n+      WHITESPACE@23..27 \"\\n   \"\n+      WHERE_PRED@27..49\n+        FOR_KW@27..30 \"for\"\n+        TYPE_PARAM_LIST@30..34\n+          L_ANGLE@30..31 \"<\"\n+          LIFETIME_PARAM@31..33\n+            LIFETIME@31..33 \"\\'a\"\n+          R_ANGLE@33..34 \">\"\n+        WHITESPACE@34..35 \" \"\n+        PATH_TYPE@35..36\n+          PATH@35..36\n+            PATH_SEGMENT@35..36\n+              NAME_REF@35..36\n+                IDENT@35..36 \"F\"\n+        COLON@36..37 \":\"\n+        WHITESPACE@37..38 \" \"\n+        TYPE_BOUND_LIST@38..49\n+          TYPE_BOUND@38..49\n+            PATH_TYPE@38..49\n+              PATH@38..49\n+                PATH_SEGMENT@38..49\n+                  NAME_REF@38..40\n+                    IDENT@38..40 \"Fn\"\n+                  PARAM_LIST@40..49\n+                    L_PAREN@40..41 \"(\"\n+                    PARAM@41..48\n+                      REFERENCE_TYPE@41..48\n+                        AMP@41..42 \"&\"\n+                        LIFETIME@42..44 \"\\'a\"\n+                        WHITESPACE@44..45 \" \"\n+                        PATH_TYPE@45..48\n+                          PATH@45..48\n+                            PATH_SEGMENT@45..48\n+                              NAME_REF@45..48\n+                                IDENT@45..48 \"str\"\n+                    R_PAREN@48..49 \")\"\n+    WHITESPACE@49..50 \"\\n\"\n+    BLOCK_EXPR@50..53\n+      L_CURLY@50..51 \"{\"\n+      WHITESPACE@51..52 \" \"\n+      R_CURLY@52..53 \"}\"\n+  WHITESPACE@53..54 \"\\n\""}, {"sha": "423bc105bd7b4ad54fad0ffa9a912f32a99ab282", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0003_where_pred_for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0003_where_pred_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0003_where_pred_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0003_where_pred_for.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,4 +1,4 @@\n-fn test<F>()\n+fn for_trait<F>()\n where\n    for<'a> F: Fn(&'a str)\n { }"}, {"sha": "b26ac2d365b99e32fc04a11879f94470bca83ba2", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0081_for_type.rast", "status": "modified", "additions": 82, "deletions": 210, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0081_for_type.rast", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0081_for_type.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0081_for_type.rast?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,4 +1,4 @@\n-SOURCE_FILE@0..200\n+SOURCE_FILE@0..121\n   TYPE_ALIAS_DEF@0..28\n     TYPE_KW@0..4 \"type\"\n     WHITESPACE@4..5 \" \"\n@@ -29,212 +29,84 @@ SOURCE_FILE@0..200\n             R_PAREN@26..27 \")\"\n     SEMICOLON@27..28 \";\"\n   WHITESPACE@28..29 \"\\n\"\n-  FN_DEF@29..79\n-    FN_KW@29..31 \"fn\"\n-    WHITESPACE@31..32 \" \"\n-    NAME@32..35\n-      IDENT@32..35 \"foo\"\n-    TYPE_PARAM_LIST@35..38\n-      L_ANGLE@35..36 \"<\"\n-      TYPE_PARAM@36..37\n-        NAME@36..37\n-          IDENT@36..37 \"T\"\n-      R_ANGLE@37..38 \">\"\n-    PARAM_LIST@38..46\n-      L_PAREN@38..39 \"(\"\n-      PARAM@39..45\n-        BIND_PAT@39..41\n-          NAME@39..41\n-            IDENT@39..41 \"_t\"\n-        COLON@41..42 \":\"\n-        WHITESPACE@42..43 \" \"\n-        REFERENCE_TYPE@43..45\n-          AMP@43..44 \"&\"\n-          PATH_TYPE@44..45\n-            PATH@44..45\n-              PATH_SEGMENT@44..45\n-                NAME_REF@44..45\n-                  IDENT@44..45 \"T\"\n-      R_PAREN@45..46 \")\"\n-    WHITESPACE@46..47 \" \"\n-    WHERE_CLAUSE@47..76\n-      WHERE_KW@47..52 \"where\"\n-      WHITESPACE@52..53 \" \"\n-      WHERE_PRED@53..76\n-        FOR_TYPE@53..66\n-          FOR_KW@53..56 \"for\"\n-          TYPE_PARAM_LIST@56..60\n-            L_ANGLE@56..57 \"<\"\n-            LIFETIME_PARAM@57..59\n-              LIFETIME@57..59 \"\\'a\"\n-            R_ANGLE@59..60 \">\"\n-          WHITESPACE@60..61 \" \"\n-          REFERENCE_TYPE@61..66\n-            AMP@61..62 \"&\"\n-            LIFETIME@62..64 \"\\'a\"\n-            WHITESPACE@64..65 \" \"\n-            PATH_TYPE@65..66\n-              PATH@65..66\n-                PATH_SEGMENT@65..66\n-                  NAME_REF@65..66\n-                    IDENT@65..66 \"T\"\n-        COLON@66..67 \":\"\n-        WHITESPACE@67..68 \" \"\n-        TYPE_BOUND_LIST@68..76\n-          TYPE_BOUND@68..76\n-            PATH_TYPE@68..76\n-              PATH@68..76\n-                PATH_SEGMENT@68..76\n-                  NAME_REF@68..76\n-                    IDENT@68..76 \"Iterator\"\n-    WHITESPACE@76..77 \" \"\n-    BLOCK_EXPR@77..79\n-      L_CURLY@77..78 \"{\"\n-      R_CURLY@78..79 \"}\"\n-  WHITESPACE@79..80 \"\\n\"\n-  FN_DEF@80..134\n-    FN_KW@80..82 \"fn\"\n-    WHITESPACE@82..83 \" \"\n-    NAME@83..86\n-      IDENT@83..86 \"bar\"\n-    TYPE_PARAM_LIST@86..89\n-      L_ANGLE@86..87 \"<\"\n-      TYPE_PARAM@87..88\n-        NAME@87..88\n-          IDENT@87..88 \"T\"\n-      R_ANGLE@88..89 \">\"\n-    PARAM_LIST@89..97\n-      L_PAREN@89..90 \"(\"\n-      PARAM@90..96\n-        BIND_PAT@90..92\n-          NAME@90..92\n-            IDENT@90..92 \"_t\"\n-        COLON@92..93 \":\"\n-        WHITESPACE@93..94 \" \"\n-        REFERENCE_TYPE@94..96\n-          AMP@94..95 \"&\"\n-          PATH_TYPE@95..96\n-            PATH@95..96\n-              PATH_SEGMENT@95..96\n-                NAME_REF@95..96\n-                  IDENT@95..96 \"T\"\n-      R_PAREN@96..97 \")\"\n-    WHITESPACE@97..98 \" \"\n-    WHERE_CLAUSE@98..131\n-      WHERE_KW@98..103 \"where\"\n-      WHITESPACE@103..104 \" \"\n-      WHERE_PRED@104..131\n-        FOR_TYPE@104..121\n-          FOR_KW@104..107 \"for\"\n-          TYPE_PARAM_LIST@107..111\n-            L_ANGLE@107..108 \"<\"\n-            LIFETIME_PARAM@108..110\n-              LIFETIME@108..110 \"\\'a\"\n-            R_ANGLE@110..111 \">\"\n-          WHITESPACE@111..112 \" \"\n-          REFERENCE_TYPE@112..121\n-            AMP@112..113 \"&\"\n-            LIFETIME@113..115 \"\\'a\"\n-            WHITESPACE@115..116 \" \"\n-            MUT_KW@116..119 \"mut\"\n-            WHITESPACE@119..120 \" \"\n-            PATH_TYPE@120..121\n-              PATH@120..121\n-                PATH_SEGMENT@120..121\n-                  NAME_REF@120..121\n-                    IDENT@120..121 \"T\"\n-        COLON@121..122 \":\"\n-        WHITESPACE@122..123 \" \"\n-        TYPE_BOUND_LIST@123..131\n-          TYPE_BOUND@123..131\n-            PATH_TYPE@123..131\n-              PATH@123..131\n-                PATH_SEGMENT@123..131\n-                  NAME_REF@123..131\n-                    IDENT@123..131 \"Iterator\"\n-    WHITESPACE@131..132 \" \"\n-    BLOCK_EXPR@132..134\n-      L_CURLY@132..133 \"{\"\n-      R_CURLY@133..134 \"}\"\n-  WHITESPACE@134..135 \"\\n\"\n-  FN_DEF@135..199\n-    FN_KW@135..137 \"fn\"\n-    WHITESPACE@137..138 \" \"\n-    NAME@138..141\n-      IDENT@138..141 \"baz\"\n-    TYPE_PARAM_LIST@141..144\n-      L_ANGLE@141..142 \"<\"\n-      TYPE_PARAM@142..143\n-        NAME@142..143\n-          IDENT@142..143 \"T\"\n-      R_ANGLE@143..144 \">\"\n-    PARAM_LIST@144..152\n-      L_PAREN@144..145 \"(\"\n-      PARAM@145..151\n-        BIND_PAT@145..147\n-          NAME@145..147\n-            IDENT@145..147 \"_t\"\n-        COLON@147..148 \":\"\n-        WHITESPACE@148..149 \" \"\n-        REFERENCE_TYPE@149..151\n-          AMP@149..150 \"&\"\n-          PATH_TYPE@150..151\n-            PATH@150..151\n-              PATH_SEGMENT@150..151\n-                NAME_REF@150..151\n-                  IDENT@150..151 \"T\"\n-      R_PAREN@151..152 \")\"\n-    WHITESPACE@152..153 \" \"\n-    WHERE_CLAUSE@153..196\n-      WHERE_KW@153..158 \"where\"\n-      WHITESPACE@158..159 \" \"\n-      WHERE_PRED@159..196\n-        FOR_TYPE@159..186\n-          FOR_KW@159..162 \"for\"\n-          TYPE_PARAM_LIST@162..166\n-            L_ANGLE@162..163 \"<\"\n-            LIFETIME_PARAM@163..165\n-              LIFETIME@163..165 \"\\'a\"\n-            R_ANGLE@165..166 \">\"\n-          WHITESPACE@166..167 \" \"\n-          PATH_TYPE@167..186\n-            PATH@167..186\n-              PATH@167..181\n-                PATH_SEGMENT@167..181\n-                  L_ANGLE@167..168 \"<\"\n-                  REFERENCE_TYPE@168..173\n-                    AMP@168..169 \"&\"\n-                    LIFETIME@169..171 \"\\'a\"\n-                    WHITESPACE@171..172 \" \"\n-                    PATH_TYPE@172..173\n-                      PATH@172..173\n-                        PATH_SEGMENT@172..173\n-                          NAME_REF@172..173\n-                            IDENT@172..173 \"T\"\n-                  WHITESPACE@173..174 \" \"\n-                  AS_KW@174..176 \"as\"\n-                  WHITESPACE@176..177 \" \"\n-                  PATH_TYPE@177..180\n-                    PATH@177..180\n-                      PATH_SEGMENT@177..180\n-                        NAME_REF@177..180\n-                          IDENT@177..180 \"Baz\"\n-                  R_ANGLE@180..181 \">\"\n-              COLON2@181..183 \"::\"\n-              PATH_SEGMENT@183..186\n-                NAME_REF@183..186\n-                  IDENT@183..186 \"Foo\"\n-        COLON@186..187 \":\"\n-        WHITESPACE@187..188 \" \"\n-        TYPE_BOUND_LIST@188..196\n-          TYPE_BOUND@188..196\n-            PATH_TYPE@188..196\n-              PATH@188..196\n-                PATH_SEGMENT@188..196\n-                  NAME_REF@188..196\n-                    IDENT@188..196 \"Iterator\"\n-    WHITESPACE@196..197 \" \"\n-    BLOCK_EXPR@197..199\n-      L_CURLY@197..198 \"{\"\n-      R_CURLY@198..199 \"}\"\n-  WHITESPACE@199..200 \"\\n\"\n+  TYPE_ALIAS_DEF@29..81\n+    TYPE_KW@29..33 \"type\"\n+    WHITESPACE@33..34 \" \"\n+    NAME@34..35\n+      IDENT@34..35 \"B\"\n+    WHITESPACE@35..36 \" \"\n+    EQ@36..37 \"=\"\n+    WHITESPACE@37..38 \" \"\n+    FOR_TYPE@38..80\n+      FOR_KW@38..41 \"for\"\n+      TYPE_PARAM_LIST@41..45\n+        L_ANGLE@41..42 \"<\"\n+        LIFETIME_PARAM@42..44\n+          LIFETIME@42..44 \"\\'a\"\n+        R_ANGLE@44..45 \">\"\n+      WHITESPACE@45..46 \" \"\n+      FN_POINTER_TYPE@46..80\n+        UNSAFE_KW@46..52 \"unsafe\"\n+        WHITESPACE@52..53 \" \"\n+        ABI@53..63\n+          EXTERN_KW@53..59 \"extern\"\n+          WHITESPACE@59..60 \" \"\n+          STRING@60..63 \"\\\"C\\\"\"\n+        WHITESPACE@63..64 \" \"\n+        FN_KW@64..66 \"fn\"\n+        PARAM_LIST@66..74\n+          L_PAREN@66..67 \"(\"\n+          PARAM@67..73\n+            REFERENCE_TYPE@67..73\n+              AMP@67..68 \"&\"\n+              LIFETIME@68..70 \"\\'a\"\n+              WHITESPACE@70..71 \" \"\n+              TUPLE_TYPE@71..73\n+                L_PAREN@71..72 \"(\"\n+                R_PAREN@72..73 \")\"\n+          R_PAREN@73..74 \")\"\n+        WHITESPACE@74..75 \" \"\n+        RET_TYPE@75..80\n+          THIN_ARROW@75..77 \"->\"\n+          WHITESPACE@77..78 \" \"\n+          TUPLE_TYPE@78..80\n+            L_PAREN@78..79 \"(\"\n+            R_PAREN@79..80 \")\"\n+    SEMICOLON@80..81 \";\"\n+  WHITESPACE@81..82 \"\\n\"\n+  TYPE_ALIAS_DEF@82..120\n+    TYPE_KW@82..86 \"type\"\n+    WHITESPACE@86..87 \" \"\n+    NAME@87..90\n+      IDENT@87..90 \"Obj\"\n+    WHITESPACE@90..91 \" \"\n+    EQ@91..92 \"=\"\n+    WHITESPACE@92..93 \" \"\n+    FOR_TYPE@93..119\n+      FOR_KW@93..96 \"for\"\n+      TYPE_PARAM_LIST@96..100\n+        L_ANGLE@96..97 \"<\"\n+        LIFETIME_PARAM@97..99\n+          LIFETIME@97..99 \"\\'a\"\n+        R_ANGLE@99..100 \">\"\n+      WHITESPACE@100..101 \" \"\n+      PATH_TYPE@101..119\n+        PATH@101..119\n+          PATH_SEGMENT@101..119\n+            NAME_REF@101..110\n+              IDENT@101..110 \"PartialEq\"\n+            TYPE_ARG_LIST@110..119\n+              L_ANGLE@110..111 \"<\"\n+              TYPE_ARG@111..118\n+                REFERENCE_TYPE@111..118\n+                  AMP@111..112 \"&\"\n+                  LIFETIME@112..114 \"\\'a\"\n+                  WHITESPACE@114..115 \" \"\n+                  PATH_TYPE@115..118\n+                    PATH@115..118\n+                      PATH_SEGMENT@115..118\n+                        NAME_REF@115..118\n+                          IDENT@115..118 \"i32\"\n+              R_ANGLE@118..119 \">\"\n+    SEMICOLON@119..120 \";\"\n+  WHITESPACE@120..121 \"\\n\""}, {"sha": "8ac7b9e103800399c838a5214094b25299e552c5", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0081_for_type.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0081_for_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0081_for_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0081_for_type.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,4 +1,3 @@\n type A = for<'a> fn() -> ();\n-fn foo<T>(_t: &T) where for<'a> &'a T: Iterator {}\n-fn bar<T>(_t: &T) where for<'a> &'a mut T: Iterator {}\n-fn baz<T>(_t: &T) where for<'a> <&'a T as Baz>::Foo: Iterator {}\n+type B = for<'a> unsafe extern \"C\" fn(&'a ()) -> ();\n+type Obj = for<'a> PartialEq<&'a i32>;"}, {"sha": "adb6159f4725d6b747cfb667a43d882cf11d773d", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0163_default_unsafe_fn.rast", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0163_default_unsafe_fn.rast", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0163_default_unsafe_fn.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0163_default_unsafe_fn.rast?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,40 @@\n+SOURCE_FILE@0..50\n+  IMPL_DEF@0..49\n+    IMPL_KW@0..4 \"impl\"\n+    WHITESPACE@4..5 \" \"\n+    PATH_TYPE@5..6\n+      PATH@5..6\n+        PATH_SEGMENT@5..6\n+          NAME_REF@5..6\n+            IDENT@5..6 \"T\"\n+    WHITESPACE@6..7 \" \"\n+    FOR_KW@7..10 \"for\"\n+    WHITESPACE@10..11 \" \"\n+    PATH_TYPE@11..14\n+      PATH@11..14\n+        PATH_SEGMENT@11..14\n+          NAME_REF@11..14\n+            IDENT@11..14 \"Foo\"\n+    WHITESPACE@14..15 \" \"\n+    ITEM_LIST@15..49\n+      L_CURLY@15..16 \"{\"\n+      WHITESPACE@16..21 \"\\n    \"\n+      FN_DEF@21..47\n+        DEFAULT_KW@21..28 \"default\"\n+        WHITESPACE@28..29 \" \"\n+        UNSAFE_KW@29..35 \"unsafe\"\n+        WHITESPACE@35..36 \" \"\n+        FN_KW@36..38 \"fn\"\n+        WHITESPACE@38..39 \" \"\n+        NAME@39..42\n+          IDENT@39..42 \"foo\"\n+        PARAM_LIST@42..44\n+          L_PAREN@42..43 \"(\"\n+          R_PAREN@43..44 \")\"\n+        WHITESPACE@44..45 \" \"\n+        BLOCK_EXPR@45..47\n+          L_CURLY@45..46 \"{\"\n+          R_CURLY@46..47 \"}\"\n+      WHITESPACE@47..48 \"\\n\"\n+      R_CURLY@48..49 \"}\"\n+  WHITESPACE@49..50 \"\\n\""}, {"sha": "12926cd8a1b408b365566265f66b170ba194b0de", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0163_default_unsafe_fn.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0163_default_unsafe_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0163_default_unsafe_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0163_default_unsafe_fn.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,3 @@\n+impl T for Foo {\n+    default unsafe fn foo() {}\n+}"}, {"sha": "a9eda56681121e1b9d746e2d278c5d95906873ad", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0163_default_unsafe_impl.rast", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0163_default_unsafe_impl.rast", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0163_default_unsafe_impl.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0163_default_unsafe_impl.rast?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,18 @@\n+SOURCE_FILE@0..27\n+  IMPL_DEF@0..26\n+    DEFAULT_KW@0..7 \"default\"\n+    WHITESPACE@7..8 \" \"\n+    UNSAFE_KW@8..14 \"unsafe\"\n+    WHITESPACE@14..15 \" \"\n+    IMPL_KW@15..19 \"impl\"\n+    WHITESPACE@19..20 \" \"\n+    PATH_TYPE@20..23\n+      PATH@20..23\n+        PATH_SEGMENT@20..23\n+          NAME_REF@20..23\n+            IDENT@20..23 \"Foo\"\n+    WHITESPACE@23..24 \" \"\n+    ITEM_LIST@24..26\n+      L_CURLY@24..25 \"{\"\n+      R_CURLY@25..26 \"}\"\n+  WHITESPACE@26..27 \"\\n\""}, {"sha": "ba0998ff4d997263ff4cb8a00a5620c61144c888", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0163_default_unsafe_impl.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0163_default_unsafe_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0163_default_unsafe_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0163_default_unsafe_impl.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1 @@\n+default unsafe impl Foo {}"}, {"sha": "8688992750d61d79b57dbdacdf0227dc0bc8559d", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0164_type_path_in_pattern.rast", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0164_type_path_in_pattern.rast", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0164_type_path_in_pattern.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0164_type_path_in_pattern.rast?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,38 @@\n+SOURCE_FILE@0..33\n+  FN_DEF@0..32\n+    FN_KW@0..2 \"fn\"\n+    WHITESPACE@2..3 \" \"\n+    NAME@3..7\n+      IDENT@3..7 \"main\"\n+    PARAM_LIST@7..9\n+      L_PAREN@7..8 \"(\"\n+      R_PAREN@8..9 \")\"\n+    WHITESPACE@9..10 \" \"\n+    BLOCK_EXPR@10..32\n+      L_CURLY@10..11 \"{\"\n+      WHITESPACE@11..12 \" \"\n+      LET_STMT@12..30\n+        LET_KW@12..15 \"let\"\n+        WHITESPACE@15..16 \" \"\n+        PATH_PAT@16..24\n+          PATH@16..24\n+            PATH@16..19\n+              PATH_SEGMENT@16..19\n+                L_ANGLE@16..17 \"<\"\n+                PLACEHOLDER_TYPE@17..18\n+                  UNDERSCORE@17..18 \"_\"\n+                R_ANGLE@18..19 \">\"\n+            COLON2@19..21 \"::\"\n+            PATH_SEGMENT@21..24\n+              NAME_REF@21..24\n+                IDENT@21..24 \"Foo\"\n+        WHITESPACE@24..25 \" \"\n+        EQ@25..26 \"=\"\n+        WHITESPACE@26..27 \" \"\n+        TUPLE_EXPR@27..29\n+          L_PAREN@27..28 \"(\"\n+          R_PAREN@28..29 \")\"\n+        SEMICOLON@29..30 \";\"\n+      WHITESPACE@30..31 \" \"\n+      R_CURLY@31..32 \"}\"\n+  WHITESPACE@32..33 \"\\n\""}, {"sha": "ebe26834d883feedb5b51c3516cacfe5ff12c1ef", "filename": "crates/ra_syntax/test_data/parser/inline/ok/0164_type_path_in_pattern.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0164_type_path_in_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0164_type_path_in_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Finline%2Fok%2F0164_type_path_in_pattern.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1 @@\n+fn main() { let <_>::Foo = (); }"}, {"sha": "dab0247ee6fa25a2bc8b1774fc6f322fdc89ac7e", "filename": "crates/ra_syntax/test_data/parser/ok/0066_default_const.rast", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0066_default_const.rast", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0066_default_const.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0066_default_const.rast?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,44 @@\n+SOURCE_FILE@0..46\n+  IMPL_DEF@0..45\n+    IMPL_KW@0..4 \"impl\"\n+    WHITESPACE@4..5 \" \"\n+    PATH_TYPE@5..6\n+      PATH@5..6\n+        PATH_SEGMENT@5..6\n+          NAME_REF@5..6\n+            IDENT@5..6 \"T\"\n+    WHITESPACE@6..7 \" \"\n+    FOR_KW@7..10 \"for\"\n+    WHITESPACE@10..11 \" \"\n+    PATH_TYPE@11..14\n+      PATH@11..14\n+        PATH_SEGMENT@11..14\n+          NAME_REF@11..14\n+            IDENT@11..14 \"Foo\"\n+    WHITESPACE@14..15 \" \"\n+    ITEM_LIST@15..45\n+      L_CURLY@15..16 \"{\"\n+      WHITESPACE@16..19 \"\\n  \"\n+      CONST_DEF@19..43\n+        DEFAULT_KW@19..26 \"default\"\n+        WHITESPACE@26..27 \" \"\n+        CONST_KW@27..32 \"const\"\n+        WHITESPACE@32..33 \" \"\n+        NAME@33..34\n+          IDENT@33..34 \"f\"\n+        COLON@34..35 \":\"\n+        WHITESPACE@35..36 \" \"\n+        PATH_TYPE@36..38\n+          PATH@36..38\n+            PATH_SEGMENT@36..38\n+              NAME_REF@36..38\n+                IDENT@36..38 \"u8\"\n+        WHITESPACE@38..39 \" \"\n+        EQ@39..40 \"=\"\n+        WHITESPACE@40..41 \" \"\n+        LITERAL@41..42\n+          INT_NUMBER@41..42 \"0\"\n+        SEMICOLON@42..43 \";\"\n+      WHITESPACE@43..44 \"\\n\"\n+      R_CURLY@44..45 \"}\"\n+  WHITESPACE@45..46 \"\\n\""}, {"sha": "dfb3b92dca7969fc598249b48aa500a0c00444f5", "filename": "crates/ra_syntax/test_data/parser/ok/0066_default_const.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0066_default_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0066_default_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0066_default_const.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,3 @@\n+impl T for Foo {\n+  default const f: u8 = 0;\n+}"}, {"sha": "5035851031f62069ab2780d9138c953b1d5fd64d", "filename": "crates/ra_syntax/test_data/parser/ok/0067_where_for_pred.rast", "status": "added", "additions": 392, "deletions": 0, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0067_where_for_pred.rast", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0067_where_for_pred.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0067_where_for_pred.rast?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,392 @@\n+SOURCE_FILE@0..374\n+  FN_DEF@0..55\n+    FN_KW@0..2 \"fn\"\n+    WHITESPACE@2..3 \" \"\n+    NAME@3..12\n+      IDENT@3..12 \"for_trait\"\n+    TYPE_PARAM_LIST@12..15\n+      L_ANGLE@12..13 \"<\"\n+      TYPE_PARAM@13..14\n+        NAME@13..14\n+          IDENT@13..14 \"F\"\n+      R_ANGLE@14..15 \">\"\n+    PARAM_LIST@15..17\n+      L_PAREN@15..16 \"(\"\n+      R_PAREN@16..17 \")\"\n+    WHITESPACE@17..18 \"\\n\"\n+    WHERE_CLAUSE@18..51\n+      WHERE_KW@18..23 \"where\"\n+      WHITESPACE@23..28 \"\\n    \"\n+      WHERE_PRED@28..50\n+        FOR_KW@28..31 \"for\"\n+        TYPE_PARAM_LIST@31..35\n+          L_ANGLE@31..32 \"<\"\n+          LIFETIME_PARAM@32..34\n+            LIFETIME@32..34 \"\\'a\"\n+          R_ANGLE@34..35 \">\"\n+        WHITESPACE@35..36 \" \"\n+        PATH_TYPE@36..37\n+          PATH@36..37\n+            PATH_SEGMENT@36..37\n+              NAME_REF@36..37\n+                IDENT@36..37 \"F\"\n+        COLON@37..38 \":\"\n+        WHITESPACE@38..39 \" \"\n+        TYPE_BOUND_LIST@39..50\n+          TYPE_BOUND@39..50\n+            PATH_TYPE@39..50\n+              PATH@39..50\n+                PATH_SEGMENT@39..50\n+                  NAME_REF@39..41\n+                    IDENT@39..41 \"Fn\"\n+                  PARAM_LIST@41..50\n+                    L_PAREN@41..42 \"(\"\n+                    PARAM@42..49\n+                      REFERENCE_TYPE@42..49\n+                        AMP@42..43 \"&\"\n+                        LIFETIME@43..45 \"\\'a\"\n+                        WHITESPACE@45..46 \" \"\n+                        PATH_TYPE@46..49\n+                          PATH@46..49\n+                            PATH_SEGMENT@46..49\n+                              NAME_REF@46..49\n+                                IDENT@46..49 \"str\"\n+                    R_PAREN@49..50 \")\"\n+      COMMA@50..51 \",\"\n+    WHITESPACE@51..52 \"\\n\"\n+    BLOCK_EXPR@52..55\n+      L_CURLY@52..53 \"{\"\n+      WHITESPACE@53..54 \"\\n\"\n+      R_CURLY@54..55 \"}\"\n+  WHITESPACE@55..56 \"\\n\"\n+  FN_DEF@56..107\n+    FN_KW@56..58 \"fn\"\n+    WHITESPACE@58..59 \" \"\n+    NAME@59..66\n+      IDENT@59..66 \"for_ref\"\n+    TYPE_PARAM_LIST@66..69\n+      L_ANGLE@66..67 \"<\"\n+      TYPE_PARAM@67..68\n+        NAME@67..68\n+          IDENT@67..68 \"F\"\n+      R_ANGLE@68..69 \">\"\n+    PARAM_LIST@69..71\n+      L_PAREN@69..70 \"(\"\n+      R_PAREN@70..71 \")\"\n+    WHITESPACE@71..72 \"\\n\"\n+    WHERE_CLAUSE@72..103\n+      WHERE_KW@72..77 \"where\"\n+      WHITESPACE@77..82 \"\\n    \"\n+      WHERE_PRED@82..102\n+        FOR_KW@82..85 \"for\"\n+        TYPE_PARAM_LIST@85..89\n+          L_ANGLE@85..86 \"<\"\n+          LIFETIME_PARAM@86..88\n+            LIFETIME@86..88 \"\\'a\"\n+          R_ANGLE@88..89 \">\"\n+        WHITESPACE@89..90 \" \"\n+        REFERENCE_TYPE@90..95\n+          AMP@90..91 \"&\"\n+          LIFETIME@91..93 \"\\'a\"\n+          WHITESPACE@93..94 \" \"\n+          PATH_TYPE@94..95\n+            PATH@94..95\n+              PATH_SEGMENT@94..95\n+                NAME_REF@94..95\n+                  IDENT@94..95 \"F\"\n+        COLON@95..96 \":\"\n+        WHITESPACE@96..97 \" \"\n+        TYPE_BOUND_LIST@97..102\n+          TYPE_BOUND@97..102\n+            PATH_TYPE@97..102\n+              PATH@97..102\n+                PATH_SEGMENT@97..102\n+                  NAME_REF@97..102\n+                    IDENT@97..102 \"Debug\"\n+      COMMA@102..103 \",\"\n+    WHITESPACE@103..104 \"\\n\"\n+    BLOCK_EXPR@104..107\n+      L_CURLY@104..105 \"{\"\n+      WHITESPACE@105..106 \"\\n\"\n+      R_CURLY@106..107 \"}\"\n+  WHITESPACE@107..108 \"\\n\"\n+  FN_DEF@108..170\n+    FN_KW@108..110 \"fn\"\n+    WHITESPACE@110..111 \" \"\n+    NAME@111..121\n+      IDENT@111..121 \"for_parens\"\n+    TYPE_PARAM_LIST@121..124\n+      L_ANGLE@121..122 \"<\"\n+      TYPE_PARAM@122..123\n+        NAME@122..123\n+          IDENT@122..123 \"F\"\n+      R_ANGLE@123..124 \">\"\n+    PARAM_LIST@124..126\n+      L_PAREN@124..125 \"(\"\n+      R_PAREN@125..126 \")\"\n+    WHITESPACE@126..127 \"\\n\"\n+    WHERE_CLAUSE@127..166\n+      WHERE_KW@127..132 \"where\"\n+      WHITESPACE@132..137 \"\\n    \"\n+      WHERE_PRED@137..165\n+        FOR_KW@137..140 \"for\"\n+        TYPE_PARAM_LIST@140..144\n+          L_ANGLE@140..141 \"<\"\n+          LIFETIME_PARAM@141..143\n+            LIFETIME@141..143 \"\\'a\"\n+          R_ANGLE@143..144 \">\"\n+        WHITESPACE@144..145 \" \"\n+        PAREN_TYPE@145..152\n+          L_PAREN@145..146 \"(\"\n+          REFERENCE_TYPE@146..151\n+            AMP@146..147 \"&\"\n+            LIFETIME@147..149 \"\\'a\"\n+            WHITESPACE@149..150 \" \"\n+            PATH_TYPE@150..151\n+              PATH@150..151\n+                PATH_SEGMENT@150..151\n+                  NAME_REF@150..151\n+                    IDENT@150..151 \"F\"\n+          R_PAREN@151..152 \")\"\n+        COLON@152..153 \":\"\n+        WHITESPACE@153..154 \" \"\n+        TYPE_BOUND_LIST@154..165\n+          TYPE_BOUND@154..165\n+            PATH_TYPE@154..165\n+              PATH@154..165\n+                PATH_SEGMENT@154..165\n+                  NAME_REF@154..156\n+                    IDENT@154..156 \"Fn\"\n+                  PARAM_LIST@156..165\n+                    L_PAREN@156..157 \"(\"\n+                    PARAM@157..164\n+                      REFERENCE_TYPE@157..164\n+                        AMP@157..158 \"&\"\n+                        LIFETIME@158..160 \"\\'a\"\n+                        WHITESPACE@160..161 \" \"\n+                        PATH_TYPE@161..164\n+                          PATH@161..164\n+                            PATH_SEGMENT@161..164\n+                              NAME_REF@161..164\n+                                IDENT@161..164 \"str\"\n+                    R_PAREN@164..165 \")\"\n+      COMMA@165..166 \",\"\n+    WHITESPACE@166..167 \"\\n\"\n+    BLOCK_EXPR@167..170\n+      L_CURLY@167..168 \"{\"\n+      WHITESPACE@168..169 \"\\n\"\n+      R_CURLY@169..170 \"}\"\n+  WHITESPACE@170..171 \"\\n\"\n+  FN_DEF@171..223\n+    FN_KW@171..173 \"fn\"\n+    WHITESPACE@173..174 \" \"\n+    NAME@174..183\n+      IDENT@174..183 \"for_slice\"\n+    TYPE_PARAM_LIST@183..186\n+      L_ANGLE@183..184 \"<\"\n+      TYPE_PARAM@184..185\n+        NAME@184..185\n+          IDENT@184..185 \"F\"\n+      R_ANGLE@185..186 \">\"\n+    PARAM_LIST@186..188\n+      L_PAREN@186..187 \"(\"\n+      R_PAREN@187..188 \")\"\n+    WHITESPACE@188..189 \"\\n\"\n+    WHERE_CLAUSE@189..219\n+      WHERE_KW@189..194 \"where\"\n+      WHITESPACE@194..199 \"\\n    \"\n+      WHERE_PRED@199..218\n+        FOR_KW@199..202 \"for\"\n+        TYPE_PARAM_LIST@202..206\n+          L_ANGLE@202..203 \"<\"\n+          LIFETIME_PARAM@203..205\n+            LIFETIME@203..205 \"\\'a\"\n+          R_ANGLE@205..206 \">\"\n+        WHITESPACE@206..207 \" \"\n+        SLICE_TYPE@207..214\n+          L_BRACK@207..208 \"[\"\n+          REFERENCE_TYPE@208..213\n+            AMP@208..209 \"&\"\n+            LIFETIME@209..211 \"\\'a\"\n+            WHITESPACE@211..212 \" \"\n+            PATH_TYPE@212..213\n+              PATH@212..213\n+                PATH_SEGMENT@212..213\n+                  NAME_REF@212..213\n+                    IDENT@212..213 \"F\"\n+          R_BRACK@213..214 \"]\"\n+        COLON@214..215 \":\"\n+        WHITESPACE@215..216 \" \"\n+        TYPE_BOUND_LIST@216..218\n+          TYPE_BOUND@216..218\n+            PATH_TYPE@216..218\n+              PATH@216..218\n+                PATH_SEGMENT@216..218\n+                  NAME_REF@216..218\n+                    IDENT@216..218 \"Eq\"\n+      COMMA@218..219 \",\"\n+    WHITESPACE@219..220 \"\\n\"\n+    BLOCK_EXPR@220..223\n+      L_CURLY@220..221 \"{\"\n+      WHITESPACE@221..222 \"\\n\"\n+      R_CURLY@222..223 \"}\"\n+  WHITESPACE@223..224 \"\\n\"\n+  FN_DEF@224..300\n+    FN_KW@224..226 \"fn\"\n+    WHITESPACE@226..227 \" \"\n+    NAME@227..236\n+      IDENT@227..236 \"for_qpath\"\n+    TYPE_PARAM_LIST@236..239\n+      L_ANGLE@236..237 \"<\"\n+      TYPE_PARAM@237..238\n+        NAME@237..238\n+          IDENT@237..238 \"T\"\n+      R_ANGLE@238..239 \">\"\n+    PARAM_LIST@239..247\n+      L_PAREN@239..240 \"(\"\n+      PARAM@240..246\n+        BIND_PAT@240..242\n+          NAME@240..242\n+            IDENT@240..242 \"_t\"\n+        COLON@242..243 \":\"\n+        WHITESPACE@243..244 \" \"\n+        REFERENCE_TYPE@244..246\n+          AMP@244..245 \"&\"\n+          PATH_TYPE@245..246\n+            PATH@245..246\n+              PATH_SEGMENT@245..246\n+                NAME_REF@245..246\n+                  IDENT@245..246 \"T\"\n+      R_PAREN@246..247 \")\"\n+    WHITESPACE@247..248 \"\\n\"\n+    WHERE_CLAUSE@248..296\n+      WHERE_KW@248..253 \"where\"\n+      WHITESPACE@253..258 \"\\n    \"\n+      WHERE_PRED@258..295\n+        FOR_KW@258..261 \"for\"\n+        TYPE_PARAM_LIST@261..265\n+          L_ANGLE@261..262 \"<\"\n+          LIFETIME_PARAM@262..264\n+            LIFETIME@262..264 \"\\'a\"\n+          R_ANGLE@264..265 \">\"\n+        WHITESPACE@265..266 \" \"\n+        PATH_TYPE@266..285\n+          PATH@266..285\n+            PATH@266..280\n+              PATH_SEGMENT@266..280\n+                L_ANGLE@266..267 \"<\"\n+                REFERENCE_TYPE@267..272\n+                  AMP@267..268 \"&\"\n+                  LIFETIME@268..270 \"\\'a\"\n+                  WHITESPACE@270..271 \" \"\n+                  PATH_TYPE@271..272\n+                    PATH@271..272\n+                      PATH_SEGMENT@271..272\n+                        NAME_REF@271..272\n+                          IDENT@271..272 \"T\"\n+                WHITESPACE@272..273 \" \"\n+                AS_KW@273..275 \"as\"\n+                WHITESPACE@275..276 \" \"\n+                PATH_TYPE@276..279\n+                  PATH@276..279\n+                    PATH_SEGMENT@276..279\n+                      NAME_REF@276..279\n+                        IDENT@276..279 \"Baz\"\n+                R_ANGLE@279..280 \">\"\n+            COLON2@280..282 \"::\"\n+            PATH_SEGMENT@282..285\n+              NAME_REF@282..285\n+                IDENT@282..285 \"Foo\"\n+        COLON@285..286 \":\"\n+        WHITESPACE@286..287 \" \"\n+        TYPE_BOUND_LIST@287..295\n+          TYPE_BOUND@287..295\n+            PATH_TYPE@287..295\n+              PATH@287..295\n+                PATH_SEGMENT@287..295\n+                  NAME_REF@287..295\n+                    IDENT@287..295 \"Iterator\"\n+      COMMA@295..296 \",\"\n+    WHITESPACE@296..297 \"\\n\"\n+    BLOCK_EXPR@297..300\n+      L_CURLY@297..298 \"{\"\n+      WHITESPACE@298..299 \"\\n\"\n+      R_CURLY@299..300 \"}\"\n+  WHITESPACE@300..301 \"\\n\"\n+  FN_DEF@301..373\n+    FN_KW@301..303 \"fn\"\n+    WHITESPACE@303..304 \" \"\n+    NAME@304..314\n+      IDENT@304..314 \"for_for_fn\"\n+    TYPE_PARAM_LIST@314..317\n+      L_ANGLE@314..315 \"<\"\n+      TYPE_PARAM@315..316\n+        NAME@315..316\n+          IDENT@315..316 \"T\"\n+      R_ANGLE@316..317 \">\"\n+    PARAM_LIST@317..319\n+      L_PAREN@317..318 \"(\"\n+      R_PAREN@318..319 \")\"\n+    WHITESPACE@319..320 \"\\n\"\n+    WHERE_CLAUSE@320..369\n+      WHERE_KW@320..325 \"where\"\n+      WHITESPACE@325..330 \"\\n    \"\n+      WHERE_PRED@330..368\n+        FOR_KW@330..333 \"for\"\n+        TYPE_PARAM_LIST@333..337\n+          L_ANGLE@333..334 \"<\"\n+          LIFETIME_PARAM@334..336\n+            LIFETIME@334..336 \"\\'a\"\n+          R_ANGLE@336..337 \">\"\n+        WHITESPACE@337..338 \" \"\n+        FOR_TYPE@338..362\n+          FOR_KW@338..341 \"for\"\n+          TYPE_PARAM_LIST@341..345\n+            L_ANGLE@341..342 \"<\"\n+            LIFETIME_PARAM@342..344\n+              LIFETIME@342..344 \"\\'b\"\n+            R_ANGLE@344..345 \">\"\n+          WHITESPACE@345..346 \" \"\n+          FN_POINTER_TYPE@346..362\n+            FN_KW@346..348 \"fn\"\n+            PARAM_LIST@348..362\n+              L_PAREN@348..349 \"(\"\n+              PARAM@349..354\n+                REFERENCE_TYPE@349..354\n+                  AMP@349..350 \"&\"\n+                  LIFETIME@350..352 \"\\'a\"\n+                  WHITESPACE@352..353 \" \"\n+                  PATH_TYPE@353..354\n+                    PATH@353..354\n+                      PATH_SEGMENT@353..354\n+                        NAME_REF@353..354\n+                          IDENT@353..354 \"T\"\n+              COMMA@354..355 \",\"\n+              WHITESPACE@355..356 \" \"\n+              PARAM@356..361\n+                REFERENCE_TYPE@356..361\n+                  AMP@356..357 \"&\"\n+                  LIFETIME@357..359 \"\\'b\"\n+                  WHITESPACE@359..360 \" \"\n+                  PATH_TYPE@360..361\n+                    PATH@360..361\n+                      PATH_SEGMENT@360..361\n+                        NAME_REF@360..361\n+                          IDENT@360..361 \"T\"\n+              R_PAREN@361..362 \")\"\n+        COLON@362..363 \":\"\n+        WHITESPACE@363..364 \" \"\n+        TYPE_BOUND_LIST@364..368\n+          TYPE_BOUND@364..368\n+            PATH_TYPE@364..368\n+              PATH@364..368\n+                PATH_SEGMENT@364..368\n+                  NAME_REF@364..368\n+                    IDENT@364..368 \"Copy\"\n+      COMMA@368..369 \",\"\n+    WHITESPACE@369..370 \"\\n\"\n+    BLOCK_EXPR@370..373\n+      L_CURLY@370..371 \"{\"\n+      WHITESPACE@371..372 \"\\n\"\n+      R_CURLY@372..373 \"}\"\n+  WHITESPACE@373..374 \"\\n\""}, {"sha": "9058c46190c4da2d68d7c75904d43efad394b93f", "filename": "crates/ra_syntax/test_data/parser/ok/0067_where_for_pred.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0067_where_for_pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0067_where_for_pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Fparser%2Fok%2F0067_where_for_pred.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,30 @@\n+fn for_trait<F>()\n+where\n+    for<'a> F: Fn(&'a str),\n+{\n+}\n+fn for_ref<F>()\n+where\n+    for<'a> &'a F: Debug,\n+{\n+}\n+fn for_parens<F>()\n+where\n+    for<'a> (&'a F): Fn(&'a str),\n+{\n+}\n+fn for_slice<F>()\n+where\n+    for<'a> [&'a F]: Eq,\n+{\n+}\n+fn for_qpath<T>(_t: &T)\n+where\n+    for<'a> <&'a T as Baz>::Foo: Iterator,\n+{\n+}\n+fn for_for_fn<T>()\n+where\n+    for<'a> for<'b> fn(&'a T, &'b T): Copy,\n+{\n+}"}, {"sha": "458089e5392217aaa46ec2d6a4cdafc83d4cbd83", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -10,7 +10,7 @@ doctest = false\n \n [[bin]]\n name = \"rust-analyzer\"\n-path = \"./src/bin/main.rs\"\n+path = \"src/bin/main.rs\"\n \n [dependencies]\n anyhow = \"1.0.26\"\n@@ -32,7 +32,7 @@ threadpool = \"1.7.1\"\n \n stdx = { path = \"../stdx\" }\n \n-lsp-server = \"0.3.1\"\n+lsp-server = \"0.3.2\"\n ra_flycheck = { path = \"../ra_flycheck\" }\n ra_ide = { path = \"../ra_ide\" }\n ra_prof = { path = \"../ra_prof\" }"}, {"sha": "8d071ab1ca2b8fac88f216bd2b39f3470cbe987c", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -4,9 +4,14 @@\n mod args;\n \n use lsp_server::Connection;\n-use rust_analyzer::{cli, config::Config, from_json, Result};\n+use rust_analyzer::{\n+    cli,\n+    config::{Config, LinkedProject},\n+    from_json, Result,\n+};\n \n use crate::args::HelpPrinted;\n+use ra_project_model::ProjectManifest;\n \n fn main() -> Result<()> {\n     setup_logging()?;\n@@ -97,28 +102,38 @@ fn run_server() -> Result<()> {\n         log::info!(\"Client '{}' {}\", client_info.name, client_info.version.unwrap_or_default());\n     }\n \n-    let cwd = std::env::current_dir()?;\n-    let root = initialize_params.root_uri.and_then(|it| it.to_file_path().ok()).unwrap_or(cwd);\n-\n-    let workspace_roots = initialize_params\n-        .workspace_folders\n-        .map(|workspaces| {\n-            workspaces.into_iter().filter_map(|it| it.uri.to_file_path().ok()).collect::<Vec<_>>()\n-        })\n-        .filter(|workspaces| !workspaces.is_empty())\n-        .unwrap_or_else(|| vec![root]);\n-\n     let config = {\n         let mut config = Config::default();\n         if let Some(value) = &initialize_params.initialization_options {\n             config.update(value);\n         }\n         config.update_caps(&initialize_params.capabilities);\n \n+        if config.linked_projects.is_empty() {\n+            let cwd = std::env::current_dir()?;\n+            let root =\n+                initialize_params.root_uri.and_then(|it| it.to_file_path().ok()).unwrap_or(cwd);\n+            let workspace_roots = initialize_params\n+                .workspace_folders\n+                .map(|workspaces| {\n+                    workspaces\n+                        .into_iter()\n+                        .filter_map(|it| it.uri.to_file_path().ok())\n+                        .collect::<Vec<_>>()\n+                })\n+                .filter(|workspaces| !workspaces.is_empty())\n+                .unwrap_or_else(|| vec![root]);\n+\n+            config.linked_projects = ProjectManifest::discover_all(&workspace_roots)\n+                .into_iter()\n+                .map(LinkedProject::from)\n+                .collect();\n+        }\n+\n         config\n     };\n \n-    rust_analyzer::main_loop(workspace_roots, config, connection)?;\n+    rust_analyzer::main_loop(config, connection)?;\n \n     log::info!(\"shutting down IO...\");\n     io_threads.join()?;"}, {"sha": "673795e781e679dc675284b1f552ce4663fdd0e3", "filename": "crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -87,6 +87,9 @@ pub fn server_capabilities(client_caps: &ClientCapabilities) -> ServerCapabiliti\n             \"ssr\": true,\n             \"onEnter\": true,\n             \"parentModule\": true,\n+            \"runnables\": {\n+                \"kinds\": [ \"cargo\" ],\n+            },\n         })),\n     }\n }"}, {"sha": "44f856f6b457d2de9af1a1f85fd376eb32383538", "filename": "crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 82, "deletions": 7, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,10 +1,10 @@\n //! See `CargoTargetSpec`\n \n+use ra_cfg::CfgExpr;\n use ra_ide::{FileId, RunnableKind, TestId};\n use ra_project_model::{self, ProjectWorkspace, TargetKind};\n \n-use crate::{world::WorldSnapshot, Result};\n-use ra_syntax::SmolStr;\n+use crate::{global_state::GlobalStateSnapshot, Result};\n \n /// Abstract representation of Cargo target.\n ///\n@@ -21,7 +21,7 @@ impl CargoTargetSpec {\n     pub(crate) fn runnable_args(\n         spec: Option<CargoTargetSpec>,\n         kind: &RunnableKind,\n-        features_needed: &Vec<SmolStr>,\n+        cfgs: &[CfgExpr],\n     ) -> Result<(Vec<String>, Vec<String>)> {\n         let mut args = Vec::new();\n         let mut extra_args = Vec::new();\n@@ -76,16 +76,20 @@ impl CargoTargetSpec {\n             }\n         }\n \n-        features_needed.iter().for_each(|feature| {\n+        let mut features = Vec::new();\n+        for cfg in cfgs {\n+            required_features(cfg, &mut features);\n+        }\n+        for feature in features {\n             args.push(\"--features\".to_string());\n-            args.push(feature.to_string());\n-        });\n+            args.push(feature);\n+        }\n \n         Ok((args, extra_args))\n     }\n \n     pub(crate) fn for_file(\n-        world: &WorldSnapshot,\n+        world: &GlobalStateSnapshot,\n         file_id: FileId,\n     ) -> Result<Option<CargoTargetSpec>> {\n         let &crate_id = match world.analysis().crate_for(file_id)?.first() {\n@@ -140,3 +144,74 @@ impl CargoTargetSpec {\n         }\n     }\n }\n+\n+/// Fill minimal features needed\n+fn required_features(cfg_expr: &CfgExpr, features: &mut Vec<String>) {\n+    match cfg_expr {\n+        CfgExpr::KeyValue { key, value } if key == \"feature\" => features.push(value.to_string()),\n+        CfgExpr::All(preds) => {\n+            preds.iter().for_each(|cfg| required_features(cfg, features));\n+        }\n+        CfgExpr::Any(preds) => {\n+            for cfg in preds {\n+                let len_features = features.len();\n+                required_features(cfg, features);\n+                if len_features != features.len() {\n+                    break;\n+                }\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use mbe::{ast_to_token_tree, TokenMap};\n+    use ra_cfg::parse_cfg;\n+    use ra_syntax::{\n+        ast::{self, AstNode},\n+        SmolStr,\n+    };\n+\n+    fn get_token_tree_generated(input: &str) -> (tt::Subtree, TokenMap) {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        ast_to_token_tree(&tt).unwrap()\n+    }\n+\n+    #[test]\n+    fn test_cfg_expr_minimal_features_needed() {\n+        let (subtree, _) = get_token_tree_generated(r#\"#![cfg(feature = \"baz\")]\"#);\n+        let cfg_expr = parse_cfg(&subtree);\n+        let mut min_features = vec![];\n+        required_features(&cfg_expr, &mut min_features);\n+\n+        assert_eq!(min_features, vec![SmolStr::new(\"baz\")]);\n+\n+        let (subtree, _) =\n+            get_token_tree_generated(r#\"#![cfg(all(feature = \"baz\", feature = \"foo\"))]\"#);\n+        let cfg_expr = parse_cfg(&subtree);\n+\n+        let mut min_features = vec![];\n+        required_features(&cfg_expr, &mut min_features);\n+        assert_eq!(min_features, vec![SmolStr::new(\"baz\"), SmolStr::new(\"foo\")]);\n+\n+        let (subtree, _) =\n+            get_token_tree_generated(r#\"#![cfg(any(feature = \"baz\", feature = \"foo\", unix))]\"#);\n+        let cfg_expr = parse_cfg(&subtree);\n+\n+        let mut min_features = vec![];\n+        required_features(&cfg_expr, &mut min_features);\n+        assert_eq!(min_features, vec![SmolStr::new(\"baz\")]);\n+\n+        let (subtree, _) = get_token_tree_generated(r#\"#![cfg(foo)]\"#);\n+        let cfg_expr = parse_cfg(&subtree);\n+\n+        let mut min_features = vec![];\n+        required_features(&cfg_expr, &mut min_features);\n+        assert!(min_features.is_empty());\n+    }\n+}"}, {"sha": "97367d7c60e9af4e5dbe6aa54c7de6cb288f7d6f", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 24, "deletions": 40, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -8,7 +8,7 @@ use crossbeam_channel::{unbounded, Receiver};\n use ra_db::{ExternSourceId, FileId, SourceRootId};\n use ra_ide::{AnalysisChange, AnalysisHost};\n use ra_project_model::{\n-    get_rustc_cfg_options, CargoConfig, PackageRoot, ProcMacroClient, ProjectRoot, ProjectWorkspace,\n+    CargoConfig, PackageRoot, ProcMacroClient, ProjectManifest, ProjectWorkspace,\n };\n use ra_vfs::{RootEntry, Vfs, VfsChange, VfsTask, Watch};\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -28,36 +28,36 @@ pub fn load_cargo(\n     with_proc_macro: bool,\n ) -> Result<(AnalysisHost, FxHashMap<SourceRootId, PackageRoot>)> {\n     let root = std::env::current_dir()?.join(root);\n-    let root = ProjectRoot::discover_single(&root)?;\n+    let root = ProjectManifest::discover_single(&root)?;\n     let ws = ProjectWorkspace::load(\n         root,\n         &CargoConfig { load_out_dirs_from_check, ..Default::default() },\n         true,\n     )?;\n \n     let mut extern_dirs = FxHashSet::default();\n-    extern_dirs.extend(ws.out_dirs());\n-\n-    let mut project_roots = ws.to_roots();\n-    project_roots.extend(extern_dirs.iter().cloned().map(PackageRoot::new_non_member));\n \n     let (sender, receiver) = unbounded();\n     let sender = Box::new(move |t| sender.send(t).unwrap());\n-    let (mut vfs, roots) = Vfs::new(\n-        project_roots\n-            .iter()\n-            .map(|pkg_root| {\n-                RootEntry::new(\n-                    pkg_root.path().to_owned(),\n-                    RustPackageFilterBuilder::default()\n-                        .set_member(pkg_root.is_member())\n-                        .into_vfs_filter(),\n-                )\n-            })\n-            .collect(),\n-        sender,\n-        Watch(false),\n-    );\n+\n+    let mut roots = Vec::new();\n+    let project_roots = ws.to_roots();\n+    for root in &project_roots {\n+        roots.push(RootEntry::new(\n+            root.path().to_owned(),\n+            RustPackageFilterBuilder::default().set_member(root.is_member()).into_vfs_filter(),\n+        ));\n+\n+        if let Some(out_dir) = root.out_dir() {\n+            extern_dirs.insert(out_dir.to_path_buf());\n+            roots.push(RootEntry::new(\n+                out_dir.to_owned(),\n+                RustPackageFilterBuilder::default().set_member(root.is_member()).into_vfs_filter(),\n+            ))\n+        }\n+    }\n+\n+    let (mut vfs, roots) = Vfs::new(roots, sender, Watch(false));\n \n     let source_roots = roots\n         .into_iter()\n@@ -111,10 +111,6 @@ pub(crate) fn load(\n                         vfs.root2path(root)\n                     );\n                     analysis_change.add_root(source_root_id, is_local);\n-                    analysis_change.set_debug_root_path(\n-                        source_root_id,\n-                        source_roots[&source_root_id].path().display().to_string(),\n-                    );\n \n                     let vfs_root_path = vfs.root2path(root);\n                     if extern_dirs.contains(&vfs_root_path) {\n@@ -147,26 +143,14 @@ pub(crate) fn load(\n         }\n     }\n \n-    // FIXME: cfg options?\n-    let default_cfg_options = {\n-        let mut opts = get_rustc_cfg_options(None);\n-        opts.insert_atom(\"test\".into());\n-        opts.insert_atom(\"debug_assertion\".into());\n-        opts\n-    };\n-\n-    let crate_graph = ws.to_crate_graph(\n-        &default_cfg_options,\n-        &extern_source_roots,\n-        proc_macro_client,\n-        &mut |path: &Path| {\n+    let crate_graph =\n+        ws.to_crate_graph(None, &extern_source_roots, proc_macro_client, &mut |path: &Path| {\n             // Some path from metadata will be non canonicalized, e.g. /foo/../bar/lib.rs\n             let path = path.canonicalize().ok()?;\n             let vfs_file = vfs.load(&path);\n             log::debug!(\"vfs file {:?} -> {:?}\", path, vfs_file);\n             vfs_file.map(vfs_file_to_id)\n-        },\n-    );\n+        });\n     log::debug!(\"crate graph: {:?}\", crate_graph);\n     analysis_change.set_crate_graph(crate_graph);\n "}, {"sha": "1253db836162aaf5673f61a21835d15f7d62a8e6", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 73, "deletions": 11, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -11,15 +11,14 @@ use std::{ffi::OsString, path::PathBuf};\n \n use lsp_types::ClientCapabilities;\n use ra_flycheck::FlycheckConfig;\n-use ra_ide::{AssistConfig, CompletionConfig, InlayHintsConfig};\n-use ra_project_model::CargoConfig;\n+use ra_ide::{AssistConfig, CompletionConfig, HoverConfig, InlayHintsConfig};\n+use ra_project_model::{CargoConfig, JsonProject, ProjectManifest};\n use serde::Deserialize;\n \n #[derive(Debug, Clone)]\n pub struct Config {\n     pub client_caps: ClientCapsConfig,\n \n-    pub with_sysroot: bool,\n     pub publish_diagnostics: bool,\n     pub lru_capacity: Option<usize>,\n     pub proc_macro_srv: Option<(PathBuf, Vec<OsString>)>,\n@@ -35,6 +34,28 @@ pub struct Config {\n     pub assist: AssistConfig,\n     pub call_info_full: bool,\n     pub lens: LensConfig,\n+    pub hover: HoverConfig,\n+\n+    pub with_sysroot: bool,\n+    pub linked_projects: Vec<LinkedProject>,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub enum LinkedProject {\n+    ProjectManifest(ProjectManifest),\n+    JsonProject(JsonProject),\n+}\n+\n+impl From<ProjectManifest> for LinkedProject {\n+    fn from(v: ProjectManifest) -> Self {\n+        LinkedProject::ProjectManifest(v)\n+    }\n+}\n+\n+impl From<JsonProject> for LinkedProject {\n+    fn from(v: JsonProject) -> Self {\n+        LinkedProject::JsonProject(v)\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -103,6 +124,8 @@ pub struct ClientCapsConfig {\n     pub code_action_literals: bool,\n     pub work_done_progress: bool,\n     pub code_action_group: bool,\n+    pub resolve_code_action: bool,\n+    pub hover_actions: bool,\n }\n \n impl Default for Config {\n@@ -122,8 +145,9 @@ impl Default for Config {\n             check: Some(FlycheckConfig::CargoCommand {\n                 command: \"check\".to_string(),\n                 all_targets: true,\n-                all_features: true,\n+                all_features: false,\n                 extra_args: Vec::new(),\n+                features: Vec::new(),\n             }),\n \n             inlay_hints: InlayHintsConfig {\n@@ -141,6 +165,8 @@ impl Default for Config {\n             assist: AssistConfig::default(),\n             call_info_full: true,\n             lens: LensConfig::default(),\n+            hover: HoverConfig::default(),\n+            linked_projects: Vec::new(),\n         }\n     }\n }\n@@ -209,13 +235,14 @@ impl Config {\n                 }\n                 // otherwise configure command customizations\n                 _ => {\n-                    if let Some(FlycheckConfig::CargoCommand { command, extra_args, all_targets, all_features })\n+                    if let Some(FlycheckConfig::CargoCommand { command, extra_args, all_targets, all_features, features })\n                         = &mut self.check\n                     {\n                         set(value, \"/checkOnSave/extraArgs\", extra_args);\n                         set(value, \"/checkOnSave/command\", command);\n                         set(value, \"/checkOnSave/allTargets\", all_targets);\n-                        set(value, \"/checkOnSave/allFeatures\", all_features);\n+                        *all_features = get(value, \"/checkOnSave/allFeatures\").unwrap_or(self.cargo.all_features);\n+                        *features = get(value, \"/checkOnSave/features\").unwrap_or(self.cargo.features.clone());\n                     }\n                 }\n             };\n@@ -240,6 +267,32 @@ impl Config {\n             self.lens = LensConfig::NO_LENS;\n         }\n \n+        if let Some(linked_projects) = get::<Vec<ManifestOrJsonProject>>(value, \"/linkedProjects\") {\n+            if !linked_projects.is_empty() {\n+                self.linked_projects.clear();\n+                for linked_project in linked_projects {\n+                    let linked_project = match linked_project {\n+                        ManifestOrJsonProject::Manifest(it) => match ProjectManifest::from_manifest_file(it) {\n+                            Ok(it) => it.into(),\n+                            Err(_) => continue,\n+                        }\n+                        ManifestOrJsonProject::JsonProject(it) => it.into(),\n+                    };\n+                    self.linked_projects.push(linked_project);\n+                }\n+            }\n+        }\n+\n+        let mut use_hover_actions = false;\n+        set(value, \"/hoverActions/enable\", &mut use_hover_actions);\n+        if use_hover_actions {\n+            set(value, \"/hoverActions/implementations\", &mut self.hover.implementations);\n+            set(value, \"/hoverActions/run\", &mut self.hover.run);\n+            set(value, \"/hoverActions/debug\", &mut self.hover.debug);\n+        } else {\n+            self.hover = HoverConfig::NO_ACTIONS;\n+        }\n+\n         log::info!(\"Config::update() = {:#?}\", self);\n \n         fn get<'a, T: Deserialize<'a>>(value: &'a serde_json::Value, pointer: &str) -> Option<T> {\n@@ -293,13 +346,22 @@ impl Config {\n \n         self.assist.allow_snippets(false);\n         if let Some(experimental) = &caps.experimental {\n-            let snippet_text_edit =\n-                experimental.get(\"snippetTextEdit\").and_then(|it| it.as_bool()) == Some(true);\n+            let get_bool =\n+                |index: &str| experimental.get(index).and_then(|it| it.as_bool()) == Some(true);\n+\n+            let snippet_text_edit = get_bool(\"snippetTextEdit\");\n             self.assist.allow_snippets(snippet_text_edit);\n \n-            let code_action_group =\n-                experimental.get(\"codeActionGroup\").and_then(|it| it.as_bool()) == Some(true);\n-            self.client_caps.code_action_group = code_action_group\n+            self.client_caps.code_action_group = get_bool(\"codeActionGroup\");\n+            self.client_caps.resolve_code_action = get_bool(\"resolveCodeAction\");\n+            self.client_caps.hover_actions = get_bool(\"hoverActions\");\n         }\n     }\n }\n+\n+#[derive(Deserialize)]\n+#[serde(untagged)]\n+enum ManifestOrJsonProject {\n+    Manifest(PathBuf),\n+    JsonProject(JsonProject),\n+}"}, {"sha": "272057b47ea668cadc03335b799d010ae046f54c", "filename": "crates/rust-analyzer/src/diagnostics/snapshots/rust_analyzer__diagnostics__to_proto__tests__snap_multi_line_fix.snap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_multi_line_fix.snap", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_multi_line_fix.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_multi_line_fix.snap?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -65,6 +65,7 @@ expression: diag\n         fixes: [\n             CodeAction {\n                 title: \"return the expression directly\",\n+                id: None,\n                 group: None,\n                 kind: Some(\n                     \"quickfix\","}, {"sha": "f0273315e932706b572d3b667faacb8ecdd929a3", "filename": "crates/rust-analyzer/src/diagnostics/snapshots/rust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -29,7 +29,7 @@ expression: diag\n                 },\n             },\n             severity: Some(\n-                Warning,\n+                Hint,\n             ),\n             code: Some(\n                 String(\n@@ -50,6 +50,7 @@ expression: diag\n         fixes: [\n             CodeAction {\n                 title: \"consider prefixing with an underscore\",\n+                id: None,\n                 group: None,\n                 kind: Some(\n                     \"quickfix\","}, {"sha": "04e286780c18313a62dc47092d0d2aad6f442a9d", "filename": "crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -145,6 +145,7 @@ fn map_rust_child_diagnostic(\n     } else {\n         MappedRustChildDiagnostic::SuggestedFix(lsp_ext::CodeAction {\n             title: rd.message.clone(),\n+            id: None,\n             group: None,\n             kind: Some(\"quickfix\".to_string()),\n             edit: Some(lsp_ext::SnippetWorkspaceEdit {\n@@ -183,7 +184,7 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n         return Vec::new();\n     }\n \n-    let severity = map_level_to_severity(rd.level);\n+    let mut severity = map_level_to_severity(rd.level);\n \n     let mut source = String::from(\"rustc\");\n     let mut code = rd.code.as_ref().map(|c| c.code.clone());\n@@ -225,6 +226,7 @@ pub(crate) fn map_rust_diagnostic_to_lsp(\n     }\n \n     if is_unused_or_unnecessary(rd) {\n+        severity = Some(DiagnosticSeverity::Hint);\n         tags.push(DiagnosticTag::Unnecessary);\n     }\n "}, {"sha": "206673829c489b5fc9ac2da597c934d7e81cb0db", "filename": "crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -3,7 +3,7 @@ use ra_db::{FileId, FilePosition, FileRange};\n use ra_ide::{LineCol, LineIndex};\n use ra_syntax::{TextRange, TextSize};\n \n-use crate::{world::WorldSnapshot, Result};\n+use crate::{global_state::GlobalStateSnapshot, Result};\n \n pub(crate) fn offset(line_index: &LineIndex, position: lsp_types::Position) -> TextSize {\n     let line_col = LineCol { line: position.line as u32, col_utf16: position.character as u32 };\n@@ -16,12 +16,12 @@ pub(crate) fn text_range(line_index: &LineIndex, range: lsp_types::Range) -> Tex\n     TextRange::new(start, end)\n }\n \n-pub(crate) fn file_id(world: &WorldSnapshot, url: &lsp_types::Url) -> Result<FileId> {\n+pub(crate) fn file_id(world: &GlobalStateSnapshot, url: &lsp_types::Url) -> Result<FileId> {\n     world.uri_to_file_id(url)\n }\n \n pub(crate) fn file_position(\n-    world: &WorldSnapshot,\n+    world: &GlobalStateSnapshot,\n     tdpp: lsp_types::TextDocumentPositionParams,\n ) -> Result<FilePosition> {\n     let file_id = file_id(world, &tdpp.text_document.uri)?;\n@@ -31,7 +31,7 @@ pub(crate) fn file_position(\n }\n \n pub(crate) fn file_range(\n-    world: &WorldSnapshot,\n+    world: &GlobalStateSnapshot,\n     text_document_identifier: lsp_types::TextDocumentIdentifier,\n     range: lsp_types::Range,\n ) -> Result<FileRange> {"}, {"sha": "21116e165e72e72c797629a0b7dc291ebccd5636", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "renamed", "additions": 33, "deletions": 39, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -15,7 +15,7 @@ use ra_flycheck::{Flycheck, FlycheckConfig};\n use ra_ide::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId, LibraryData, SourceRootId,\n };\n-use ra_project_model::{get_rustc_cfg_options, ProcMacroClient, ProjectWorkspace};\n+use ra_project_model::{ProcMacroClient, ProjectWorkspace};\n use ra_vfs::{LineEndings, RootEntry, Vfs, VfsChange, VfsFile, VfsRoot, VfsTask, Watch};\n use relative_path::RelativePathBuf;\n use stdx::format_to;\n@@ -50,15 +50,15 @@ fn create_flycheck(workspaces: &[ProjectWorkspace], config: &FlycheckConfig) ->\n         })\n }\n \n-/// `WorldState` is the primary mutable state of the language server\n+/// `GlobalState` is the primary mutable state of the language server\n ///\n /// The most interesting components are `vfs`, which stores a consistent\n /// snapshot of the file systems, and `analysis_host`, which stores our\n /// incremental salsa database.\n #[derive(Debug)]\n-pub struct WorldState {\n+pub struct GlobalState {\n     pub config: Config,\n-    pub roots: Vec<PathBuf>,\n+    pub local_roots: Vec<PathBuf>,\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis_host: AnalysisHost,\n     pub vfs: Arc<RwLock<Vfs>>,\n@@ -70,7 +70,7 @@ pub struct WorldState {\n }\n \n /// An immutable snapshot of the world's state at a point in time.\n-pub struct WorldSnapshot {\n+pub struct GlobalStateSnapshot {\n     pub config: Config,\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,\n     pub analysis: Analysis,\n@@ -79,39 +79,42 @@ pub struct WorldSnapshot {\n     vfs: Arc<RwLock<Vfs>>,\n }\n \n-impl WorldState {\n+impl GlobalState {\n     pub fn new(\n-        folder_roots: Vec<PathBuf>,\n         workspaces: Vec<ProjectWorkspace>,\n         lru_capacity: Option<usize>,\n         exclude_globs: &[Glob],\n         watch: Watch,\n         config: Config,\n-    ) -> WorldState {\n+    ) -> GlobalState {\n         let mut change = AnalysisChange::new();\n \n-        let extern_dirs: FxHashSet<_> =\n-            workspaces.iter().flat_map(ProjectWorkspace::out_dirs).collect();\n+        let mut extern_dirs: FxHashSet<PathBuf> = FxHashSet::default();\n \n+        let mut local_roots = Vec::new();\n         let roots: Vec<_> = {\n             let create_filter = |is_member| {\n                 RustPackageFilterBuilder::default()\n                     .set_member(is_member)\n                     .exclude(exclude_globs.iter().cloned())\n                     .into_vfs_filter()\n             };\n-            folder_roots\n-                .iter()\n-                .map(|path| RootEntry::new(path.clone(), create_filter(true)))\n-                .chain(workspaces.iter().flat_map(ProjectWorkspace::to_roots).map(|pkg_root| {\n-                    RootEntry::new(pkg_root.path().to_owned(), create_filter(pkg_root.is_member()))\n-                }))\n-                .chain(\n-                    extern_dirs\n-                        .iter()\n-                        .map(|path| RootEntry::new(path.to_owned(), create_filter(false))),\n-                )\n-                .collect()\n+            let mut roots = Vec::new();\n+            for root in workspaces.iter().flat_map(ProjectWorkspace::to_roots) {\n+                let path = root.path().to_owned();\n+                if root.is_member() {\n+                    local_roots.push(path.clone());\n+                }\n+                roots.push(RootEntry::new(path, create_filter(root.is_member())));\n+                if let Some(out_dir) = root.out_dir() {\n+                    extern_dirs.insert(out_dir.to_path_buf());\n+                    roots.push(RootEntry::new(\n+                        out_dir.to_path_buf(),\n+                        create_filter(root.is_member()),\n+                    ))\n+                }\n+            }\n+            roots\n         };\n \n         let (task_sender, task_receiver) = unbounded();\n@@ -121,24 +124,15 @@ impl WorldState {\n         let mut extern_source_roots = FxHashMap::default();\n         for r in vfs_roots {\n             let vfs_root_path = vfs.root2path(r);\n-            let is_local = folder_roots.iter().any(|it| vfs_root_path.starts_with(it));\n+            let is_local = local_roots.iter().any(|it| vfs_root_path.starts_with(it));\n             change.add_root(SourceRootId(r.0), is_local);\n-            change.set_debug_root_path(SourceRootId(r.0), vfs_root_path.display().to_string());\n \n             // FIXME: add path2root in vfs to simpily this logic\n             if extern_dirs.contains(&vfs_root_path) {\n                 extern_source_roots.insert(vfs_root_path, ExternSourceId(r.0));\n             }\n         }\n \n-        // FIXME: Read default cfgs from config\n-        let default_cfg_options = {\n-            let mut opts = get_rustc_cfg_options(config.cargo.target.as_ref());\n-            opts.insert_atom(\"test\".into());\n-            opts.insert_atom(\"debug_assertion\".into());\n-            opts\n-        };\n-\n         let proc_macro_client = match &config.proc_macro_srv {\n             None => ProcMacroClient::dummy(),\n             Some((path, args)) => match ProcMacroClient::extern_process(path.into(), args) {\n@@ -164,7 +158,7 @@ impl WorldState {\n         };\n         for ws in workspaces.iter() {\n             crate_graph.extend(ws.to_crate_graph(\n-                &default_cfg_options,\n+                config.cargo.target.as_deref(),\n                 &extern_source_roots,\n                 &proc_macro_client,\n                 &mut load,\n@@ -176,9 +170,9 @@ impl WorldState {\n \n         let mut analysis_host = AnalysisHost::new(lru_capacity);\n         analysis_host.apply_change(change);\n-        WorldState {\n+        GlobalState {\n             config,\n-            roots: folder_roots,\n+            local_roots,\n             workspaces: Arc::new(workspaces),\n             analysis_host,\n             vfs: Arc::new(RwLock::new(vfs)),\n@@ -216,7 +210,7 @@ impl WorldState {\n             match c {\n                 VfsChange::AddRoot { root, files } => {\n                     let root_path = self.vfs.read().root2path(root);\n-                    let is_local = self.roots.iter().any(|r| root_path.starts_with(r));\n+                    let is_local = self.local_roots.iter().any(|r| root_path.starts_with(r));\n                     if is_local {\n                         *roots_scanned += 1;\n                         for (file, path, text) in files {\n@@ -251,8 +245,8 @@ impl WorldState {\n         self.analysis_host.apply_change(change);\n     }\n \n-    pub fn snapshot(&self) -> WorldSnapshot {\n-        WorldSnapshot {\n+    pub fn snapshot(&self) -> GlobalStateSnapshot {\n+        GlobalStateSnapshot {\n             config: self.config.clone(),\n             workspaces: Arc::clone(&self.workspaces),\n             analysis: self.analysis_host.analysis(),\n@@ -275,7 +269,7 @@ impl WorldState {\n     }\n }\n \n-impl WorldSnapshot {\n+impl GlobalStateSnapshot {\n     pub fn analysis(&self) -> &Analysis {\n         &self.analysis\n     }", "previous_filename": "crates/rust-analyzer/src/world.rs"}, {"sha": "609cb69d3bff6174a15502db7dfd1f19900bb034", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -26,7 +26,7 @@ mod main_loop;\n mod markdown;\n pub mod lsp_ext;\n pub mod config;\n-mod world;\n+mod global_state;\n mod diagnostics;\n mod semantic_tokens;\n "}, {"sha": "1371f6cb4a416d334fd72ea310de0f412d7875d3", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 72, "deletions": 8, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -4,7 +4,6 @@ use std::{collections::HashMap, path::PathBuf};\n \n use lsp_types::request::Request;\n use lsp_types::{Position, Range, TextDocumentIdentifier};\n-use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n \n pub enum AnalyzerStatus {}\n@@ -98,6 +97,22 @@ pub struct JoinLinesParams {\n     pub ranges: Vec<Range>,\n }\n \n+pub enum ResolveCodeActionRequest {}\n+\n+impl Request for ResolveCodeActionRequest {\n+    type Params = ResolveCodeActionParams;\n+    type Result = Option<SnippetWorkspaceEdit>;\n+    const METHOD: &'static str = \"experimental/resolveCodeAction\";\n+}\n+\n+/// Params for the ResolveCodeActionRequest\n+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct ResolveCodeActionParams {\n+    pub code_action_params: lsp_types::CodeActionParams,\n+    pub id: String,\n+}\n+\n pub enum OnEnter {}\n \n impl Request for OnEnter {\n@@ -111,7 +126,7 @@ pub enum Runnables {}\n impl Request for Runnables {\n     type Params = RunnablesParams;\n     type Result = Vec<Runnable>;\n-    const METHOD: &'static str = \"rust-analyzer/runnables\";\n+    const METHOD: &'static str = \"experimental/runnables\";\n }\n \n #[derive(Serialize, Deserialize, Debug)]\n@@ -124,13 +139,28 @@ pub struct RunnablesParams {\n #[derive(Deserialize, Serialize, Debug)]\n #[serde(rename_all = \"camelCase\")]\n pub struct Runnable {\n-    pub range: Range,\n     pub label: String,\n-    pub bin: String,\n-    pub args: Vec<String>,\n-    pub extra_args: Vec<String>,\n-    pub env: FxHashMap<String, String>,\n-    pub cwd: Option<PathBuf>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub location: Option<lsp_types::LocationLink>,\n+    pub kind: RunnableKind,\n+    pub args: CargoRunnable,\n+}\n+\n+#[derive(Serialize, Deserialize, Debug)]\n+#[serde(rename_all = \"lowercase\")]\n+pub enum RunnableKind {\n+    Cargo,\n+}\n+\n+#[derive(Deserialize, Serialize, Debug)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct CargoRunnable {\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub workspace_root: Option<PathBuf>,\n+    // command, --package and --lib stuff\n+    pub cargo_args: Vec<String>,\n+    // stuff after --\n+    pub executable_args: Vec<String>,\n }\n \n pub enum InlayHints {}\n@@ -188,6 +218,8 @@ impl Request for CodeActionRequest {\n pub struct CodeAction {\n     pub title: String,\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub id: Option<String>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n     pub group: Option<String>,\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n     pub kind: Option<String>,\n@@ -228,3 +260,35 @@ pub struct SnippetTextEdit {\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n     pub insert_text_format: Option<lsp_types::InsertTextFormat>,\n }\n+\n+pub enum HoverRequest {}\n+\n+impl Request for HoverRequest {\n+    type Params = lsp_types::HoverParams;\n+    type Result = Option<Hover>;\n+    const METHOD: &'static str = \"textDocument/hover\";\n+}\n+\n+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]\n+pub struct Hover {\n+    #[serde(flatten)]\n+    pub hover: lsp_types::Hover,\n+    #[serde(skip_serializing_if = \"Vec::is_empty\")]\n+    pub actions: Vec<CommandLinkGroup>,\n+}\n+\n+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]\n+pub struct CommandLinkGroup {\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub title: Option<String>,\n+    pub commands: Vec<CommandLink>,\n+}\n+\n+// LSP v3.15 Command does not have a `tooltip` field, vscode supports one.\n+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]\n+pub struct CommandLink {\n+    #[serde(flatten)]\n+    pub command: lsp_types::Command,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub tooltip: Option<String>,\n+}"}, {"sha": "752dbf145298add27dddd11e7f4a0802880587fe", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 73, "deletions": 77, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -12,13 +12,11 @@ use std::{\n     fmt,\n     ops::Range,\n     panic,\n-    path::PathBuf,\n     sync::Arc,\n     time::{Duration, Instant},\n };\n \n use crossbeam_channel::{never, select, unbounded, RecvError, Sender};\n-use itertools::Itertools;\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n use lsp_types::{\n     DidChangeTextDocumentParams, NumberOrString, TextDocumentContentChangeEvent, WorkDoneProgress,\n@@ -36,14 +34,15 @@ use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n \n use crate::{\n-    config::{Config, FilesWatcher},\n+    config::{Config, FilesWatcher, LinkedProject},\n     diagnostics::{to_proto::url_from_path_with_drive_lowercasing, DiagnosticTask},\n-    from_proto, lsp_ext,\n+    from_proto,\n+    global_state::{GlobalState, GlobalStateSnapshot},\n+    lsp_ext,\n     main_loop::{\n         pending_requests::{PendingRequest, PendingRequests},\n         subscriptions::Subscriptions,\n     },\n-    world::{WorldSnapshot, WorldState},\n     Result,\n };\n \n@@ -69,7 +68,7 @@ impl fmt::Display for LspError {\n \n impl Error for LspError {}\n \n-pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection) -> Result<()> {\n+pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n     log::info!(\"initial config: {:#?}\", config);\n \n     // Windows scheduler implements priority boosts: if thread waits for an\n@@ -92,43 +91,37 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n     }\n \n     let mut loop_state = LoopState::default();\n-    let mut world_state = {\n+    let mut global_state = {\n         let workspaces = {\n-            // FIXME: support dynamic workspace loading.\n-            let project_roots: FxHashSet<_> = ws_roots\n-                .iter()\n-                .filter_map(|it| ra_project_model::ProjectRoot::discover(it).ok())\n-                .flatten()\n-                .collect();\n-\n-            if project_roots.is_empty() && config.notifications.cargo_toml_not_found {\n+            if config.linked_projects.is_empty() && config.notifications.cargo_toml_not_found {\n                 show_message(\n                     lsp_types::MessageType::Error,\n-                    format!(\n-                        \"rust-analyzer failed to discover workspace, no Cargo.toml found, dirs searched: {}\",\n-                        ws_roots.iter().format_with(\", \", |it, f| f(&it.display()))\n-                    ),\n+                    \"rust-analyzer failed to discover workspace\".to_string(),\n                     &connection.sender,\n                 );\n             };\n \n-            project_roots\n-                .into_iter()\n-                .filter_map(|root| {\n-                    ra_project_model::ProjectWorkspace::load(\n-                        root,\n-                        &config.cargo,\n-                        config.with_sysroot,\n-                    )\n-                    .map_err(|err| {\n-                        log::error!(\"failed to load workspace: {:#}\", err);\n-                        show_message(\n-                            lsp_types::MessageType::Error,\n-                            format!(\"rust-analyzer failed to load workspace: {:#}\", err),\n-                            &connection.sender,\n-                        );\n-                    })\n-                    .ok()\n+            config\n+                .linked_projects\n+                .iter()\n+                .filter_map(|project| match project {\n+                    LinkedProject::ProjectManifest(manifest) => {\n+                        ra_project_model::ProjectWorkspace::load(\n+                            manifest.clone(),\n+                            &config.cargo,\n+                            config.with_sysroot,\n+                        )\n+                        .map_err(|err| {\n+                            log::error!(\"failed to load workspace: {:#}\", err);\n+                            show_message(\n+                                lsp_types::MessageType::Error,\n+                                format!(\"rust-analyzer failed to load workspace: {:#}\", err),\n+                                &connection.sender,\n+                            );\n+                        })\n+                        .ok()\n+                    }\n+                    LinkedProject::JsonProject(it) => Some(it.clone().into()),\n                 })\n                 .collect::<Vec<_>>()\n         };\n@@ -163,8 +156,7 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n             connection.sender.send(request.into()).unwrap();\n         }\n \n-        WorldState::new(\n-            ws_roots,\n+        GlobalState::new(\n             workspaces,\n             config.lru_capacity,\n             &globs,\n@@ -173,7 +165,7 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n         )\n     };\n \n-    loop_state.roots_total = world_state.vfs.read().n_roots();\n+    loop_state.roots_total = global_state.vfs.read().n_roots();\n \n     let pool = ThreadPool::default();\n     let (task_sender, task_receiver) = unbounded::<Task>();\n@@ -191,12 +183,12 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n                     Err(RecvError) => return Err(\"client exited without shutdown\".into()),\n                 },\n                 recv(task_receiver) -> task => Event::Task(task.unwrap()),\n-                recv(world_state.task_receiver) -> task => match task {\n+                recv(global_state.task_receiver) -> task => match task {\n                     Ok(task) => Event::Vfs(task),\n                     Err(RecvError) => return Err(\"vfs died\".into()),\n                 },\n                 recv(libdata_receiver) -> data => Event::Lib(data.unwrap()),\n-                recv(world_state.flycheck.as_ref().map_or(&never(), |it| &it.task_recv)) -> task => match task {\n+                recv(global_state.flycheck.as_ref().map_or(&never(), |it| &it.task_recv)) -> task => match task {\n                     Ok(task) => Event::CheckWatcher(task),\n                     Err(RecvError) => return Err(\"check watcher died\".into()),\n                 }\n@@ -211,16 +203,16 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n                 &task_sender,\n                 &libdata_sender,\n                 &connection,\n-                &mut world_state,\n+                &mut global_state,\n                 &mut loop_state,\n                 event,\n             )?;\n         }\n     }\n-    world_state.analysis_host.request_cancellation();\n+    global_state.analysis_host.request_cancellation();\n     log::info!(\"waiting for tasks to finish...\");\n     task_receiver.into_iter().for_each(|task| {\n-        on_task(task, &connection.sender, &mut loop_state.pending_requests, &mut world_state)\n+        on_task(task, &connection.sender, &mut loop_state.pending_requests, &mut global_state)\n     });\n     libdata_receiver.into_iter().for_each(drop);\n     log::info!(\"...tasks have finished\");\n@@ -229,7 +221,7 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n     drop(pool);\n     log::info!(\"...threadpool has finished\");\n \n-    let vfs = Arc::try_unwrap(world_state.vfs).expect(\"all snapshots should be dead\");\n+    let vfs = Arc::try_unwrap(global_state.vfs).expect(\"all snapshots should be dead\");\n     drop(vfs);\n \n     Ok(())\n@@ -320,7 +312,7 @@ fn loop_turn(\n     task_sender: &Sender<Task>,\n     libdata_sender: &Sender<LibraryData>,\n     connection: &Connection,\n-    world_state: &mut WorldState,\n+    global_state: &mut GlobalState,\n     loop_state: &mut LoopState,\n     event: Event,\n ) -> Result<()> {\n@@ -336,22 +328,22 @@ fn loop_turn(\n \n     match event {\n         Event::Task(task) => {\n-            on_task(task, &connection.sender, &mut loop_state.pending_requests, world_state);\n-            world_state.maybe_collect_garbage();\n+            on_task(task, &connection.sender, &mut loop_state.pending_requests, global_state);\n+            global_state.maybe_collect_garbage();\n         }\n         Event::Vfs(task) => {\n-            world_state.vfs.write().handle_task(task);\n+            global_state.vfs.write().handle_task(task);\n         }\n         Event::Lib(lib) => {\n-            world_state.add_lib(lib);\n-            world_state.maybe_collect_garbage();\n+            global_state.add_lib(lib);\n+            global_state.maybe_collect_garbage();\n             loop_state.in_flight_libraries -= 1;\n             loop_state.roots_scanned += 1;\n         }\n-        Event::CheckWatcher(task) => on_check_task(task, world_state, task_sender)?,\n+        Event::CheckWatcher(task) => on_check_task(task, global_state, task_sender)?,\n         Event::Msg(msg) => match msg {\n             Message::Request(req) => on_request(\n-                world_state,\n+                global_state,\n                 &mut loop_state.pending_requests,\n                 pool,\n                 task_sender,\n@@ -360,7 +352,7 @@ fn loop_turn(\n                 req,\n             )?,\n             Message::Notification(not) => {\n-                on_notification(&connection.sender, world_state, loop_state, not)?;\n+                on_notification(&connection.sender, global_state, loop_state, not)?;\n             }\n             Message::Response(resp) => {\n                 let removed = loop_state.pending_responses.remove(&resp.id);\n@@ -379,9 +371,9 @@ fn loop_turn(\n                         }\n                         (None, Some(configs)) => {\n                             if let Some(new_config) = configs.get(0) {\n-                                let mut config = world_state.config.clone();\n+                                let mut config = global_state.config.clone();\n                                 config.update(&new_config);\n-                                world_state.update_configuration(config);\n+                                global_state.update_configuration(config);\n                             }\n                         }\n                         (None, None) => {\n@@ -394,7 +386,7 @@ fn loop_turn(\n     };\n \n     let mut state_changed = false;\n-    if let Some(changes) = world_state.process_changes(&mut loop_state.roots_scanned) {\n+    if let Some(changes) = global_state.process_changes(&mut loop_state.roots_scanned) {\n         state_changed = true;\n         loop_state.pending_libraries.extend(changes);\n     }\n@@ -416,7 +408,7 @@ fn loop_turn(\n     }\n \n     let show_progress =\n-        !loop_state.workspace_loaded && world_state.config.client_caps.work_done_progress;\n+        !loop_state.workspace_loaded && global_state.config.client_caps.work_done_progress;\n \n     if !loop_state.workspace_loaded\n         && loop_state.roots_scanned == loop_state.roots_total\n@@ -425,7 +417,7 @@ fn loop_turn(\n     {\n         state_changed = true;\n         loop_state.workspace_loaded = true;\n-        if let Some(flycheck) = &world_state.flycheck {\n+        if let Some(flycheck) = &global_state.flycheck {\n             flycheck.update();\n         }\n     }\n@@ -437,13 +429,13 @@ fn loop_turn(\n     if state_changed && loop_state.workspace_loaded {\n         update_file_notifications_on_threadpool(\n             pool,\n-            world_state.snapshot(),\n+            global_state.snapshot(),\n             task_sender.clone(),\n             loop_state.subscriptions.subscriptions(),\n         );\n         pool.execute({\n             let subs = loop_state.subscriptions.subscriptions();\n-            let snap = world_state.snapshot();\n+            let snap = global_state.snapshot();\n             move || snap.analysis().prime_caches(subs).unwrap_or_else(|_: Canceled| ())\n         });\n     }\n@@ -467,7 +459,7 @@ fn on_task(\n     task: Task,\n     msg_sender: &Sender<Message>,\n     pending_requests: &mut PendingRequests,\n-    state: &mut WorldState,\n+    state: &mut GlobalState,\n ) {\n     match task {\n         Task::Respond(response) => {\n@@ -485,7 +477,7 @@ fn on_task(\n }\n \n fn on_request(\n-    world: &mut WorldState,\n+    global_state: &mut GlobalState,\n     pending_requests: &mut PendingRequests,\n     pool: &ThreadPool,\n     task_sender: &Sender<Task>,\n@@ -496,7 +488,7 @@ fn on_request(\n     let mut pool_dispatcher = PoolDispatcher {\n         req: Some(req),\n         pool,\n-        world,\n+        global_state,\n         task_sender,\n         msg_sender,\n         pending_requests,\n@@ -517,6 +509,8 @@ fn on_request(\n         .on::<lsp_ext::Runnables>(handlers::handle_runnables)?\n         .on::<lsp_ext::InlayHints>(handlers::handle_inlay_hints)?\n         .on::<lsp_ext::CodeActionRequest>(handlers::handle_code_action)?\n+        .on::<lsp_ext::ResolveCodeActionRequest>(handlers::handle_resolve_code_action)?\n+        .on::<lsp_ext::HoverRequest>(handlers::handle_hover)?\n         .on::<lsp_types::request::OnTypeFormatting>(handlers::handle_on_type_formatting)?\n         .on::<lsp_types::request::DocumentSymbolRequest>(handlers::handle_document_symbol)?\n         .on::<lsp_types::request::WorkspaceSymbol>(handlers::handle_workspace_symbol)?\n@@ -528,7 +522,6 @@ fn on_request(\n         .on::<lsp_types::request::CodeLensResolve>(handlers::handle_code_lens_resolve)?\n         .on::<lsp_types::request::FoldingRangeRequest>(handlers::handle_folding_range)?\n         .on::<lsp_types::request::SignatureHelpRequest>(handlers::handle_signature_help)?\n-        .on::<lsp_types::request::HoverRequest>(handlers::handle_hover)?\n         .on::<lsp_types::request::PrepareRenameRequest>(handlers::handle_prepare_rename)?\n         .on::<lsp_types::request::Rename>(handlers::handle_rename)?\n         .on::<lsp_types::request::References>(handlers::handle_references)?\n@@ -552,7 +545,7 @@ fn on_request(\n \n fn on_notification(\n     msg_sender: &Sender<Message>,\n-    state: &mut WorldState,\n+    state: &mut GlobalState,\n     loop_state: &mut LoopState,\n     not: Notification,\n ) -> Result<()> {\n@@ -726,7 +719,7 @@ fn apply_document_changes(\n \n fn on_check_task(\n     task: CheckTask,\n-    world_state: &mut WorldState,\n+    global_state: &mut GlobalState,\n     task_sender: &Sender<Task>,\n ) -> Result<()> {\n     match task {\n@@ -745,7 +738,7 @@ fn on_check_task(\n                     .uri\n                     .to_file_path()\n                     .map_err(|()| format!(\"invalid uri: {}\", diag.location.uri))?;\n-                let file_id = match world_state.vfs.read().path2file(&path) {\n+                let file_id = match global_state.vfs.read().path2file(&path) {\n                     Some(file) => FileId(file.0),\n                     None => {\n                         log::error!(\n@@ -765,7 +758,7 @@ fn on_check_task(\n         }\n \n         CheckTask::Status(status) => {\n-            if world_state.config.client_caps.work_done_progress {\n+            if global_state.config.client_caps.work_done_progress {\n                 let progress = match status {\n                     Status::Being => {\n                         lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n@@ -804,7 +797,7 @@ fn on_check_task(\n     Ok(())\n }\n \n-fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state: &mut WorldState) {\n+fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state: &mut GlobalState) {\n     let subscriptions = state.diagnostics.handle_task(task);\n \n     for file_id in subscriptions {\n@@ -879,7 +872,7 @@ fn send_startup_progress(sender: &Sender<Message>, loop_state: &mut LoopState) {\n struct PoolDispatcher<'a> {\n     req: Option<Request>,\n     pool: &'a ThreadPool,\n-    world: &'a mut WorldState,\n+    global_state: &'a mut GlobalState,\n     pending_requests: &'a mut PendingRequests,\n     msg_sender: &'a Sender<Message>,\n     task_sender: &'a Sender<Task>,\n@@ -890,7 +883,7 @@ impl<'a> PoolDispatcher<'a> {\n     /// Dispatches the request onto the current thread\n     fn on_sync<R>(\n         &mut self,\n-        f: fn(&mut WorldState, R::Params) -> Result<R::Result>,\n+        f: fn(&mut GlobalState, R::Params) -> Result<R::Result>,\n     ) -> Result<&mut Self>\n     where\n         R: lsp_types::request::Request + 'static,\n@@ -903,18 +896,21 @@ impl<'a> PoolDispatcher<'a> {\n                 return Ok(self);\n             }\n         };\n-        let world = panic::AssertUnwindSafe(&mut *self.world);\n+        let world = panic::AssertUnwindSafe(&mut *self.global_state);\n         let task = panic::catch_unwind(move || {\n             let result = f(world.0, params);\n             result_to_task::<R>(id, result)\n         })\n         .map_err(|_| format!(\"sync task {:?} panicked\", R::METHOD))?;\n-        on_task(task, self.msg_sender, self.pending_requests, self.world);\n+        on_task(task, self.msg_sender, self.pending_requests, self.global_state);\n         Ok(self)\n     }\n \n     /// Dispatches the request onto thread pool\n-    fn on<R>(&mut self, f: fn(WorldSnapshot, R::Params) -> Result<R::Result>) -> Result<&mut Self>\n+    fn on<R>(\n+        &mut self,\n+        f: fn(GlobalStateSnapshot, R::Params) -> Result<R::Result>,\n+    ) -> Result<&mut Self>\n     where\n         R: lsp_types::request::Request + 'static,\n         R::Params: DeserializeOwned + Send + 'static,\n@@ -928,7 +924,7 @@ impl<'a> PoolDispatcher<'a> {\n         };\n \n         self.pool.execute({\n-            let world = self.world.snapshot();\n+            let world = self.global_state.snapshot();\n             let sender = self.task_sender.clone();\n             move || {\n                 let result = f(world, params);\n@@ -1012,7 +1008,7 @@ where\n \n fn update_file_notifications_on_threadpool(\n     pool: &ThreadPool,\n-    world: WorldSnapshot,\n+    world: GlobalStateSnapshot,\n     task_sender: Sender<Task>,\n     subscriptions: Vec<FileId>,\n ) {"}, {"sha": "a41adf8b0b51bad07b767c436bdabe4d6e8ee721", "filename": "crates/rust-analyzer/src/main_loop/handlers.rs", "status": "modified", "additions": 418, "deletions": 384, "changes": 802, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -12,40 +12,37 @@ use lsp_types::{\n     CallHierarchyIncomingCall, CallHierarchyIncomingCallsParams, CallHierarchyItem,\n     CallHierarchyOutgoingCall, CallHierarchyOutgoingCallsParams, CallHierarchyPrepareParams,\n     CodeLens, Command, CompletionItem, Diagnostic, DocumentFormattingParams, DocumentHighlight,\n-    DocumentSymbol, FoldingRange, FoldingRangeParams, Hover, HoverContents, Location,\n-    MarkupContent, MarkupKind, Position, PrepareRenameResponse, Range, RenameParams,\n-    SemanticTokensParams, SemanticTokensRangeParams, SemanticTokensRangeResult,\n-    SemanticTokensResult, SymbolInformation, TextDocumentIdentifier, Url, WorkspaceEdit,\n+    DocumentSymbol, FoldingRange, FoldingRangeParams, HoverContents, Location, MarkupContent,\n+    MarkupKind, Position, PrepareRenameResponse, Range, RenameParams, SemanticTokensParams,\n+    SemanticTokensRangeParams, SemanticTokensRangeResult, SemanticTokensResult, SymbolInformation,\n+    TextDocumentIdentifier, Url, WorkspaceEdit,\n };\n-use ra_cfg::CfgExpr;\n use ra_ide::{\n-    FileId, FilePosition, FileRange, Query, RangeInfo, Runnable, RunnableKind, SearchScope,\n-    TextEdit,\n+    FileId, FilePosition, FileRange, HoverAction, Query, RangeInfo, Runnable, RunnableKind,\n+    SearchScope, TextEdit,\n };\n use ra_prof::profile;\n use ra_project_model::TargetKind;\n-use ra_syntax::{AstNode, SmolStr, SyntaxKind, TextRange, TextSize};\n-use rustc_hash::FxHashMap;\n+use ra_syntax::{AstNode, SyntaxKind, TextRange, TextSize};\n use serde::{Deserialize, Serialize};\n use serde_json::to_value;\n-use stdx::format_to;\n+use stdx::{format_to, split1};\n \n use crate::{\n     cargo_target_spec::CargoTargetSpec,\n     config::RustfmtConfig,\n     diagnostics::DiagnosticTask,\n     from_json, from_proto,\n+    global_state::GlobalStateSnapshot,\n     lsp_ext::{self, InlayHint, InlayHintsParams},\n-    to_proto,\n-    world::WorldSnapshot,\n-    LspError, Result,\n+    to_proto, LspError, Result,\n };\n \n-pub fn handle_analyzer_status(world: WorldSnapshot, _: ()) -> Result<String> {\n+pub fn handle_analyzer_status(snap: GlobalStateSnapshot, _: ()) -> Result<String> {\n     let _p = profile(\"handle_analyzer_status\");\n-    let mut buf = world.status();\n+    let mut buf = snap.status();\n     format_to!(buf, \"\\n\\nrequests:\\n\");\n-    let requests = world.latest_requests.read();\n+    let requests = snap.latest_requests.read();\n     for (is_last, r) in requests.iter() {\n         let mark = if is_last { \"*\" } else { \" \" };\n         format_to!(buf, \"{}{:4} {:<36}{}ms\\n\", mark, r.id, r.method, r.duration.as_millis());\n@@ -54,37 +51,37 @@ pub fn handle_analyzer_status(world: WorldSnapshot, _: ()) -> Result<String> {\n }\n \n pub fn handle_syntax_tree(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::SyntaxTreeParams,\n ) -> Result<String> {\n     let _p = profile(\"handle_syntax_tree\");\n-    let id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(id)?;\n+    let id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(id)?;\n     let text_range = params.range.map(|r| from_proto::text_range(&line_index, r));\n-    let res = world.analysis().syntax_tree(id, text_range)?;\n+    let res = snap.analysis().syntax_tree(id, text_range)?;\n     Ok(res)\n }\n \n pub fn handle_expand_macro(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::ExpandMacroParams,\n ) -> Result<Option<lsp_ext::ExpandedMacro>> {\n     let _p = profile(\"handle_expand_macro\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let offset = from_proto::offset(&line_index, params.position);\n \n-    let res = world.analysis().expand_macro(FilePosition { file_id, offset })?;\n+    let res = snap.analysis().expand_macro(FilePosition { file_id, offset })?;\n     Ok(res.map(|it| lsp_ext::ExpandedMacro { name: it.name, expansion: it.expansion }))\n }\n \n pub fn handle_selection_range(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::SelectionRangeParams,\n ) -> Result<Option<Vec<lsp_types::SelectionRange>>> {\n     let _p = profile(\"handle_selection_range\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let res: Result<Vec<lsp_types::SelectionRange>> = params\n         .positions\n         .into_iter()\n@@ -96,7 +93,7 @@ pub fn handle_selection_range(\n                 loop {\n                     ranges.push(range);\n                     let frange = FileRange { file_id, range };\n-                    let next = world.analysis().extend_selection(frange)?;\n+                    let next = snap.analysis().extend_selection(frange)?;\n                     if next == range {\n                         break;\n                     } else {\n@@ -122,18 +119,18 @@ pub fn handle_selection_range(\n }\n \n pub fn handle_matching_brace(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::MatchingBraceParams,\n ) -> Result<Vec<Position>> {\n     let _p = profile(\"handle_matching_brace\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let res = params\n         .positions\n         .into_iter()\n         .map(|position| {\n             let offset = from_proto::offset(&line_index, position);\n-            let offset = match world.analysis().matching_brace(FilePosition { file_id, offset }) {\n+            let offset = match snap.analysis().matching_brace(FilePosition { file_id, offset }) {\n                 Ok(Some(matching_brace_offset)) => matching_brace_offset,\n                 Err(_) | Ok(None) => offset,\n             };\n@@ -144,17 +141,17 @@ pub fn handle_matching_brace(\n }\n \n pub fn handle_join_lines(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::JoinLinesParams,\n ) -> Result<Vec<lsp_types::TextEdit>> {\n     let _p = profile(\"handle_join_lines\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let line_endings = world.file_line_endings(file_id);\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_endings = snap.file_line_endings(file_id);\n     let mut res = TextEdit::default();\n     for range in params.ranges {\n         let range = from_proto::text_range(&line_index, range);\n-        let edit = world.analysis().join_lines(FileRange { file_id, range })?;\n+        let edit = snap.analysis().join_lines(FileRange { file_id, range })?;\n         match res.union(edit) {\n             Ok(()) => (),\n             Err(_edit) => {\n@@ -167,37 +164,37 @@ pub fn handle_join_lines(\n }\n \n pub fn handle_on_enter(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentPositionParams,\n ) -> Result<Option<Vec<lsp_ext::SnippetTextEdit>>> {\n     let _p = profile(\"handle_on_enter\");\n-    let position = from_proto::file_position(&world, params)?;\n-    let edit = match world.analysis().on_enter(position)? {\n+    let position = from_proto::file_position(&snap, params)?;\n+    let edit = match snap.analysis().on_enter(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n-    let line_endings = world.file_line_endings(position.file_id);\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_endings = snap.file_line_endings(position.file_id);\n     let edit = to_proto::snippet_text_edit_vec(&line_index, line_endings, true, edit);\n     Ok(Some(edit))\n }\n \n // Don't forget to add new trigger characters to `ServerCapabilities` in `caps.rs`.\n pub fn handle_on_type_formatting(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::DocumentOnTypeFormattingParams,\n ) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n     let _p = profile(\"handle_on_type_formatting\");\n-    let mut position = from_proto::file_position(&world, params.text_document_position)?;\n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n-    let line_endings = world.file_line_endings(position.file_id);\n+    let mut position = from_proto::file_position(&snap, params.text_document_position)?;\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_endings = snap.file_line_endings(position.file_id);\n \n     // in `ra_ide`, the `on_type` invariant is that\n     // `text.char_at(position) == typed_char`.\n     position.offset -= TextSize::of('.');\n     let char_typed = params.ch.chars().next().unwrap_or('\\0');\n     assert!({\n-        let text = world.analysis().file_text(position.file_id)?;\n+        let text = snap.analysis().file_text(position.file_id)?;\n         text[usize::from(position.offset)..].starts_with(char_typed)\n     });\n \n@@ -209,7 +206,7 @@ pub fn handle_on_type_formatting(\n         return Ok(None);\n     }\n \n-    let edit = world.analysis().on_char_typed(position, char_typed)?;\n+    let edit = snap.analysis().on_char_typed(position, char_typed)?;\n     let mut edit = match edit {\n         Some(it) => it,\n         None => return Ok(None),\n@@ -223,16 +220,16 @@ pub fn handle_on_type_formatting(\n }\n \n pub fn handle_document_symbol(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::DocumentSymbolParams,\n ) -> Result<Option<lsp_types::DocumentSymbolResponse>> {\n     let _p = profile(\"handle_document_symbol\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n \n     let mut parents: Vec<(DocumentSymbol, Option<usize>)> = Vec::new();\n \n-    for symbol in world.analysis().file_structure(file_id)? {\n+    for symbol in snap.analysis().file_structure(file_id)? {\n         let doc_symbol = DocumentSymbol {\n             name: symbol.label,\n             detail: symbol.detail,\n@@ -258,10 +255,10 @@ pub fn handle_document_symbol(\n         }\n     }\n \n-    let res = if world.config.client_caps.hierarchical_symbols {\n+    let res = if snap.config.client_caps.hierarchical_symbols {\n         document_symbols.into()\n     } else {\n-        let url = to_proto::url(&world, file_id)?;\n+        let url = to_proto::url(&snap, file_id)?;\n         let mut symbol_information = Vec::<SymbolInformation>::new();\n         for symbol in document_symbols {\n             flatten_document_symbol(&symbol, None, &url, &mut symbol_information);\n@@ -291,7 +288,7 @@ pub fn handle_document_symbol(\n }\n \n pub fn handle_workspace_symbol(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::WorkspaceSymbolParams,\n ) -> Result<Option<Vec<SymbolInformation>>> {\n     let _p = profile(\"handle_workspace_symbol\");\n@@ -309,22 +306,22 @@ pub fn handle_workspace_symbol(\n         q.limit(128);\n         q\n     };\n-    let mut res = exec_query(&world, query)?;\n+    let mut res = exec_query(&snap, query)?;\n     if res.is_empty() && !all_symbols {\n         let mut query = Query::new(params.query);\n         query.limit(128);\n-        res = exec_query(&world, query)?;\n+        res = exec_query(&snap, query)?;\n     }\n \n     return Ok(Some(res));\n \n-    fn exec_query(world: &WorldSnapshot, query: Query) -> Result<Vec<SymbolInformation>> {\n+    fn exec_query(snap: &GlobalStateSnapshot, query: Query) -> Result<Vec<SymbolInformation>> {\n         let mut res = Vec::new();\n-        for nav in world.analysis().symbol_search(query)? {\n+        for nav in snap.analysis().symbol_search(query)? {\n             let info = SymbolInformation {\n                 name: nav.name().to_string(),\n                 kind: to_proto::symbol_kind(nav.kind()),\n-                location: to_proto::location(world, nav.file_range())?,\n+                location: to_proto::location(snap, nav.file_range())?,\n                 container_name: nav.container_name().map(|v| v.to_string()),\n                 deprecated: None,\n             };\n@@ -335,131 +332,132 @@ pub fn handle_workspace_symbol(\n }\n \n pub fn handle_goto_definition(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::GotoDefinitionParams,\n ) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n     let _p = profile(\"handle_goto_definition\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let nav_info = match world.analysis().goto_definition(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let nav_info = match snap.analysis().goto_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n     let src = FileRange { file_id: position.file_id, range: nav_info.range };\n-    let res = to_proto::goto_definition_response(&world, Some(src), nav_info.info)?;\n+    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n     Ok(Some(res))\n }\n \n pub fn handle_goto_implementation(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::request::GotoImplementationParams,\n ) -> Result<Option<lsp_types::request::GotoImplementationResponse>> {\n     let _p = profile(\"handle_goto_implementation\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let nav_info = match world.analysis().goto_implementation(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let nav_info = match snap.analysis().goto_implementation(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n     let src = FileRange { file_id: position.file_id, range: nav_info.range };\n-    let res = to_proto::goto_definition_response(&world, Some(src), nav_info.info)?;\n+    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n     Ok(Some(res))\n }\n \n pub fn handle_goto_type_definition(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::request::GotoTypeDefinitionParams,\n ) -> Result<Option<lsp_types::request::GotoTypeDefinitionResponse>> {\n     let _p = profile(\"handle_goto_type_definition\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let nav_info = match world.analysis().goto_type_definition(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let nav_info = match snap.analysis().goto_type_definition(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n     let src = FileRange { file_id: position.file_id, range: nav_info.range };\n-    let res = to_proto::goto_definition_response(&world, Some(src), nav_info.info)?;\n+    let res = to_proto::goto_definition_response(&snap, Some(src), nav_info.info)?;\n     Ok(Some(res))\n }\n \n pub fn handle_parent_module(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentPositionParams,\n ) -> Result<Option<lsp_types::GotoDefinitionResponse>> {\n     let _p = profile(\"handle_parent_module\");\n-    let position = from_proto::file_position(&world, params)?;\n-    let navs = world.analysis().parent_module(position)?;\n-    let res = to_proto::goto_definition_response(&world, None, navs)?;\n+    let position = from_proto::file_position(&snap, params)?;\n+    let navs = snap.analysis().parent_module(position)?;\n+    let res = to_proto::goto_definition_response(&snap, None, navs)?;\n     Ok(Some(res))\n }\n \n pub fn handle_runnables(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::RunnablesParams,\n ) -> Result<Vec<lsp_ext::Runnable>> {\n     let _p = profile(\"handle_runnables\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let offset = params.position.map(|it| from_proto::offset(&line_index, it));\n     let mut res = Vec::new();\n-    let workspace_root = world.workspace_root_for(file_id);\n-    let cargo_spec = CargoTargetSpec::for_file(&world, file_id)?;\n-    for runnable in world.analysis().runnables(file_id)? {\n+    let workspace_root = snap.workspace_root_for(file_id);\n+    let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n+    for runnable in snap.analysis().runnables(file_id)? {\n         if let Some(offset) = offset {\n-            if !runnable.range.contains_inclusive(offset) {\n+            if !runnable.nav.full_range().contains_inclusive(offset) {\n                 continue;\n             }\n         }\n-        // Do not suggest binary run on other target than binary\n-        if let RunnableKind::Bin = runnable.kind {\n-            if let Some(spec) = &cargo_spec {\n-                match spec.target_kind {\n-                    TargetKind::Bin => {}\n-                    _ => continue,\n-                }\n-            }\n+        if should_skip_target(&runnable, cargo_spec.as_ref()) {\n+            continue;\n         }\n-        res.push(to_lsp_runnable(&world, file_id, runnable)?);\n+\n+        res.push(to_proto::runnable(&snap, file_id, runnable)?);\n     }\n \n     // Add `cargo check` and `cargo test` for the whole package\n     match cargo_spec {\n         Some(spec) => {\n             for &cmd in [\"check\", \"test\"].iter() {\n                 res.push(lsp_ext::Runnable {\n-                    range: Default::default(),\n                     label: format!(\"cargo {} -p {}\", cmd, spec.package),\n-                    bin: \"cargo\".to_string(),\n-                    args: vec![cmd.to_string(), \"--package\".to_string(), spec.package.clone()],\n-                    extra_args: Vec::new(),\n-                    env: FxHashMap::default(),\n-                    cwd: workspace_root.map(|root| root.to_owned()),\n+                    location: None,\n+                    kind: lsp_ext::RunnableKind::Cargo,\n+                    args: lsp_ext::CargoRunnable {\n+                        workspace_root: workspace_root.map(|root| root.to_owned()),\n+                        cargo_args: vec![\n+                            cmd.to_string(),\n+                            \"--package\".to_string(),\n+                            spec.package.clone(),\n+                        ],\n+                        executable_args: Vec::new(),\n+                    },\n                 })\n             }\n         }\n         None => {\n             res.push(lsp_ext::Runnable {\n-                range: Default::default(),\n                 label: \"cargo check --workspace\".to_string(),\n-                bin: \"cargo\".to_string(),\n-                args: vec![\"check\".to_string(), \"--workspace\".to_string()],\n-                extra_args: Vec::new(),\n-                env: FxHashMap::default(),\n-                cwd: workspace_root.map(|root| root.to_owned()),\n+                location: None,\n+                kind: lsp_ext::RunnableKind::Cargo,\n+                args: lsp_ext::CargoRunnable {\n+                    workspace_root: workspace_root.map(|root| root.to_owned()),\n+                    cargo_args: vec![\"check\".to_string(), \"--workspace\".to_string()],\n+                    executable_args: Vec::new(),\n+                },\n             });\n         }\n     }\n     Ok(res)\n }\n \n pub fn handle_completion(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::CompletionParams,\n ) -> Result<Option<lsp_types::CompletionResponse>> {\n     let _p = profile(\"handle_completion\");\n-    let position = from_proto::file_position(&world, params.text_document_position)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position)?;\n     let completion_triggered_after_single_colon = {\n         let mut res = false;\n         if let Some(ctx) = params.context {\n             if ctx.trigger_character.unwrap_or_default() == \":\" {\n-                let source_file = world.analysis().parse(position.file_id)?;\n+                let source_file = snap.analysis().parse(position.file_id)?;\n                 let syntax = source_file.syntax();\n                 let text = syntax.text();\n                 if let Some(next_char) = text.char_at(position.offset) {\n@@ -477,12 +475,12 @@ pub fn handle_completion(\n         return Ok(None);\n     }\n \n-    let items = match world.analysis().completions(&world.config.completion, position)? {\n+    let items = match snap.analysis().completions(&snap.config.completion, position)? {\n         None => return Ok(None),\n         Some(items) => items,\n     };\n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n-    let line_endings = world.file_line_endings(position.file_id);\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n+    let line_endings = snap.file_line_endings(position.file_id);\n     let items: Vec<CompletionItem> = items\n         .into_iter()\n         .map(|item| to_proto::completion_item(&line_index, line_endings, item))\n@@ -492,15 +490,15 @@ pub fn handle_completion(\n }\n \n pub fn handle_folding_range(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: FoldingRangeParams,\n ) -> Result<Option<Vec<FoldingRange>>> {\n     let _p = profile(\"handle_folding_range\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let folds = world.analysis().folding_ranges(file_id)?;\n-    let text = world.analysis().file_text(file_id)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let line_folding_only = world.config.client_caps.line_folding_only;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let folds = snap.analysis().folding_ranges(file_id)?;\n+    let text = snap.analysis().file_text(file_id)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let line_folding_only = snap.config.client_caps.line_folding_only;\n     let res = folds\n         .into_iter()\n         .map(|it| to_proto::folding_range(&*text, &line_index, line_folding_only, it))\n@@ -509,16 +507,16 @@ pub fn handle_folding_range(\n }\n \n pub fn handle_signature_help(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::SignatureHelpParams,\n ) -> Result<Option<lsp_types::SignatureHelp>> {\n     let _p = profile(\"handle_signature_help\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let call_info = match world.analysis().call_info(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let call_info = match snap.analysis().call_info(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let concise = !world.config.call_info_full;\n+    let concise = !snap.config.call_info_full;\n     let mut active_parameter = call_info.active_parameter.map(|it| it as i64);\n     if concise && call_info.signature.has_self_param {\n         active_parameter = active_parameter.map(|it| it.saturating_sub(1));\n@@ -532,46 +530,56 @@ pub fn handle_signature_help(\n     }))\n }\n \n-pub fn handle_hover(world: WorldSnapshot, params: lsp_types::HoverParams) -> Result<Option<Hover>> {\n+pub fn handle_hover(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::HoverParams,\n+) -> Result<Option<lsp_ext::Hover>> {\n     let _p = profile(\"handle_hover\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let info = match world.analysis().hover(position)? {\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let info = match snap.analysis().hover(position)? {\n         None => return Ok(None),\n         Some(info) => info,\n     };\n-    let line_index = world.analysis.file_line_index(position.file_id)?;\n+    let line_index = snap.analysis.file_line_index(position.file_id)?;\n     let range = to_proto::range(&line_index, info.range);\n-    let res = Hover {\n-        contents: HoverContents::Markup(MarkupContent {\n-            kind: MarkupKind::Markdown,\n-            value: crate::markdown::format_docs(&info.info.to_markup()),\n-        }),\n-        range: Some(range),\n+    let hover = lsp_ext::Hover {\n+        hover: lsp_types::Hover {\n+            contents: HoverContents::Markup(MarkupContent {\n+                kind: MarkupKind::Markdown,\n+                value: crate::markdown::format_docs(&info.info.to_markup()),\n+            }),\n+            range: Some(range),\n+        },\n+        actions: prepare_hover_actions(&snap, position.file_id, info.info.actions()),\n     };\n-    Ok(Some(res))\n+\n+    Ok(Some(hover))\n }\n \n pub fn handle_prepare_rename(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentPositionParams,\n ) -> Result<Option<PrepareRenameResponse>> {\n     let _p = profile(\"handle_prepare_rename\");\n-    let position = from_proto::file_position(&world, params)?;\n+    let position = from_proto::file_position(&snap, params)?;\n \n-    let optional_change = world.analysis().rename(position, \"dummy\")?;\n+    let optional_change = snap.analysis().rename(position, \"dummy\")?;\n     let range = match optional_change {\n         None => return Ok(None),\n         Some(it) => it.range,\n     };\n \n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n     let range = to_proto::range(&line_index, range);\n     Ok(Some(PrepareRenameResponse::Range(range)))\n }\n \n-pub fn handle_rename(world: WorldSnapshot, params: RenameParams) -> Result<Option<WorkspaceEdit>> {\n+pub fn handle_rename(\n+    snap: GlobalStateSnapshot,\n+    params: RenameParams,\n+) -> Result<Option<WorkspaceEdit>> {\n     let _p = profile(\"handle_rename\");\n-    let position = from_proto::file_position(&world, params.text_document_position)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position)?;\n \n     if params.new_name.is_empty() {\n         return Err(LspError::new(\n@@ -581,61 +589,61 @@ pub fn handle_rename(world: WorldSnapshot, params: RenameParams) -> Result<Optio\n         .into());\n     }\n \n-    let optional_change = world.analysis().rename(position, &*params.new_name)?;\n+    let optional_change = snap.analysis().rename(position, &*params.new_name)?;\n     let source_change = match optional_change {\n         None => return Ok(None),\n         Some(it) => it.info,\n     };\n-    let workspace_edit = to_proto::workspace_edit(&world, source_change)?;\n+    let workspace_edit = to_proto::workspace_edit(&snap, source_change)?;\n     Ok(Some(workspace_edit))\n }\n \n pub fn handle_references(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::ReferenceParams,\n ) -> Result<Option<Vec<Location>>> {\n     let _p = profile(\"handle_references\");\n-    let position = from_proto::file_position(&world, params.text_document_position)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position)?;\n \n-    let refs = match world.analysis().find_all_refs(position, None)? {\n+    let refs = match snap.analysis().find_all_refs(position, None)? {\n         None => return Ok(None),\n         Some(refs) => refs,\n     };\n \n     let locations = if params.context.include_declaration {\n         refs.into_iter()\n-            .filter_map(|reference| to_proto::location(&world, reference.file_range).ok())\n+            .filter_map(|reference| to_proto::location(&snap, reference.file_range).ok())\n             .collect()\n     } else {\n         // Only iterate over the references if include_declaration was false\n         refs.references()\n             .iter()\n-            .filter_map(|reference| to_proto::location(&world, reference.file_range).ok())\n+            .filter_map(|reference| to_proto::location(&snap, reference.file_range).ok())\n             .collect()\n     };\n \n     Ok(Some(locations))\n }\n \n pub fn handle_formatting(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: DocumentFormattingParams,\n ) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n     let _p = profile(\"handle_formatting\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let file = world.analysis().file_text(file_id)?;\n-    let crate_ids = world.analysis().crate_for(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let file = snap.analysis().file_text(file_id)?;\n+    let crate_ids = snap.analysis().crate_for(file_id)?;\n \n-    let file_line_index = world.analysis().file_line_index(file_id)?;\n+    let file_line_index = snap.analysis().file_line_index(file_id)?;\n     let end_position = to_proto::position(&file_line_index, TextSize::of(file.as_str()));\n \n-    let mut rustfmt = match &world.config.rustfmt {\n+    let mut rustfmt = match &snap.config.rustfmt {\n         RustfmtConfig::Rustfmt { extra_args } => {\n             let mut cmd = process::Command::new(\"rustfmt\");\n             cmd.args(extra_args);\n             if let Some(&crate_id) = crate_ids.first() {\n                 // Assume all crates are in the same edition\n-                let edition = world.analysis().crate_edition(crate_id)?;\n+                let edition = snap.analysis().crate_edition(crate_id)?;\n                 cmd.arg(\"--edition\");\n                 cmd.arg(edition.to_string());\n             }\n@@ -693,136 +701,145 @@ pub fn handle_formatting(\n     }]))\n }\n \n-pub fn handle_code_action(\n-    world: WorldSnapshot,\n-    params: lsp_types::CodeActionParams,\n-) -> Result<Option<Vec<lsp_ext::CodeAction>>> {\n-    let _p = profile(\"handle_code_action\");\n-    // We intentionally don't support command-based actions, as those either\n-    // requires custom client-code anyway, or requires server-initiated edits.\n-    // Server initiated edits break causality, so we avoid those as well.\n-    if !world.config.client_caps.code_action_literals {\n-        return Ok(None);\n-    }\n-\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+fn handle_fixes(\n+    snap: &GlobalStateSnapshot,\n+    params: &lsp_types::CodeActionParams,\n+    res: &mut Vec<lsp_ext::CodeAction>,\n+) -> Result<()> {\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n     let range = from_proto::text_range(&line_index, params.range);\n-    let frange = FileRange { file_id, range };\n-\n-    let diagnostics = world.analysis().diagnostics(file_id)?;\n-    let mut res: Vec<lsp_ext::CodeAction> = Vec::new();\n+    let diagnostics = snap.analysis().diagnostics(file_id)?;\n \n     let fixes_from_diagnostics = diagnostics\n         .into_iter()\n         .filter_map(|d| Some((d.range, d.fix?)))\n         .filter(|(diag_range, _fix)| diag_range.intersect(range).is_some())\n         .map(|(_range, fix)| fix);\n-\n     for fix in fixes_from_diagnostics {\n         let title = fix.label;\n-        let edit = to_proto::snippet_workspace_edit(&world, fix.source_change)?;\n-        let action =\n-            lsp_ext::CodeAction { title, group: None, kind: None, edit: Some(edit), command: None };\n+        let edit = to_proto::snippet_workspace_edit(&snap, fix.source_change)?;\n+        let action = lsp_ext::CodeAction {\n+            title,\n+            id: None,\n+            group: None,\n+            kind: Some(lsp_types::code_action_kind::QUICKFIX.into()),\n+            edit: Some(edit),\n+            command: None,\n+        };\n         res.push(action);\n     }\n \n-    for fix in world.check_fixes.get(&file_id).into_iter().flatten() {\n+    for fix in snap.check_fixes.get(&file_id).into_iter().flatten() {\n         let fix_range = from_proto::text_range(&line_index, fix.range);\n         if fix_range.intersect(range).is_none() {\n             continue;\n         }\n         res.push(fix.action.clone());\n     }\n+    Ok(())\n+}\n \n-    for assist in world.analysis().assists(&world.config.assist, frange)?.into_iter() {\n-        res.push(to_proto::code_action(&world, assist)?.into());\n+pub fn handle_code_action(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::CodeActionParams,\n+) -> Result<Option<Vec<lsp_ext::CodeAction>>> {\n+    let _p = profile(\"handle_code_action\");\n+    // We intentionally don't support command-based actions, as those either\n+    // requires custom client-code anyway, or requires server-initiated edits.\n+    // Server initiated edits break causality, so we avoid those as well.\n+    if !snap.config.client_caps.code_action_literals {\n+        return Ok(None);\n+    }\n+\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let range = from_proto::text_range(&line_index, params.range);\n+    let frange = FileRange { file_id, range };\n+    let mut res: Vec<lsp_ext::CodeAction> = Vec::new();\n+\n+    handle_fixes(&snap, &params, &mut res)?;\n+\n+    if snap.config.client_caps.resolve_code_action {\n+        for (index, assist) in\n+            snap.analysis().unresolved_assists(&snap.config.assist, frange)?.into_iter().enumerate()\n+        {\n+            res.push(to_proto::unresolved_code_action(&snap, assist, index)?);\n+        }\n+    } else {\n+        for assist in snap.analysis().resolved_assists(&snap.config.assist, frange)?.into_iter() {\n+            res.push(to_proto::resolved_code_action(&snap, assist)?);\n+        }\n     }\n+\n     Ok(Some(res))\n }\n \n+pub fn handle_resolve_code_action(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_ext::ResolveCodeActionParams,\n+) -> Result<Option<lsp_ext::SnippetWorkspaceEdit>> {\n+    let _p = profile(\"handle_resolve_code_action\");\n+    let file_id = from_proto::file_id(&snap, &params.code_action_params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let range = from_proto::text_range(&line_index, params.code_action_params.range);\n+    let frange = FileRange { file_id, range };\n+\n+    let assists = snap.analysis().resolved_assists(&snap.config.assist, frange)?;\n+    let (id_string, index) = split1(&params.id, ':').unwrap();\n+    let index = index.parse::<usize>().unwrap();\n+    let assist = &assists[index];\n+    assert!(assist.assist.id.0 == id_string);\n+    Ok(to_proto::resolved_code_action(&snap, assist.clone())?.edit)\n+}\n+\n pub fn handle_code_lens(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::CodeLensParams,\n ) -> Result<Option<Vec<CodeLens>>> {\n     let _p = profile(\"handle_code_lens\");\n     let mut lenses: Vec<CodeLens> = Default::default();\n \n-    if world.config.lens.none() {\n+    if snap.config.lens.none() {\n         // early return before any db query!\n         return Ok(Some(lenses));\n     }\n \n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let cargo_spec = CargoTargetSpec::for_file(&world, file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n \n-    if world.config.lens.runnable() {\n+    if snap.config.lens.runnable() {\n         // Gather runnables\n-        for runnable in world.analysis().runnables(file_id)? {\n-            let (run_title, debugee) = match &runnable.kind {\n-                RunnableKind::Test { .. } | RunnableKind::TestMod { .. } => {\n-                    (\"\u25b6\\u{fe0e} Run Test\", true)\n-                }\n-                RunnableKind::DocTest { .. } => {\n-                    // cargo does not support -no-run for doctests\n-                    (\"\u25b6\\u{fe0e} Run Doctest\", false)\n-                }\n-                RunnableKind::Bench { .. } => {\n-                    // Nothing wrong with bench debugging\n-                    (\"Run Bench\", true)\n-                }\n-                RunnableKind::Bin => {\n-                    // Do not suggest binary run on other target than binary\n-                    match &cargo_spec {\n-                        Some(spec) => match spec.target_kind {\n-                            TargetKind::Bin => (\"Run\", true),\n-                            _ => continue,\n-                        },\n-                        None => continue,\n-                    }\n-                }\n-            };\n+        for runnable in snap.analysis().runnables(file_id)? {\n+            if should_skip_target(&runnable, cargo_spec.as_ref()) {\n+                continue;\n+            }\n \n-            let mut r = to_lsp_runnable(&world, file_id, runnable)?;\n-            if world.config.lens.run {\n+            let action = runnable.action();\n+            let range = to_proto::range(&line_index, runnable.nav.range());\n+            let r = to_proto::runnable(&snap, file_id, runnable)?;\n+            if snap.config.lens.run {\n                 let lens = CodeLens {\n-                    range: r.range,\n-                    command: Some(Command {\n-                        title: run_title.to_string(),\n-                        command: \"rust-analyzer.runSingle\".into(),\n-                        arguments: Some(vec![to_value(&r).unwrap()]),\n-                    }),\n+                    range,\n+                    command: Some(run_single_command(&r, action.run_title)),\n                     data: None,\n                 };\n                 lenses.push(lens);\n             }\n \n-            if debugee && world.config.lens.debug {\n-                if r.args[0] == \"run\" {\n-                    r.args[0] = \"build\".into();\n-                } else {\n-                    r.args.push(\"--no-run\".into());\n-                }\n-                let debug_lens = CodeLens {\n-                    range: r.range,\n-                    command: Some(Command {\n-                        title: \"Debug\".into(),\n-                        command: \"rust-analyzer.debugSingle\".into(),\n-                        arguments: Some(vec![to_value(r).unwrap()]),\n-                    }),\n-                    data: None,\n-                };\n+            if action.debugee && snap.config.lens.debug {\n+                let debug_lens =\n+                    CodeLens { range, command: Some(debug_single_command(&r)), data: None };\n                 lenses.push(debug_lens);\n             }\n         }\n     }\n \n-    if world.config.lens.impementations {\n+    if snap.config.lens.impementations {\n         // Handle impls\n         lenses.extend(\n-            world\n-                .analysis()\n+            snap.analysis()\n                 .file_structure(file_id)?\n                 .into_iter()\n                 .filter(|it| match it.kind {\n@@ -857,14 +874,17 @@ enum CodeLensResolveData {\n     Impls(lsp_types::request::GotoImplementationParams),\n }\n \n-pub fn handle_code_lens_resolve(world: WorldSnapshot, code_lens: CodeLens) -> Result<CodeLens> {\n+pub fn handle_code_lens_resolve(\n+    snap: GlobalStateSnapshot,\n+    code_lens: CodeLens,\n+) -> Result<CodeLens> {\n     let _p = profile(\"handle_code_lens_resolve\");\n     let data = code_lens.data.unwrap();\n     let resolve = from_json::<Option<CodeLensResolveData>>(\"CodeLensResolveData\", data)?;\n     match resolve {\n         Some(CodeLensResolveData::Impls(lens_params)) => {\n             let locations: Vec<Location> =\n-                match handle_goto_implementation(world, lens_params.clone())? {\n+                match handle_goto_implementation(snap, lens_params.clone())? {\n                     Some(lsp_types::GotoDefinitionResponse::Scalar(loc)) => vec![loc],\n                     Some(lsp_types::GotoDefinitionResponse::Array(locs)) => locs,\n                     Some(lsp_types::GotoDefinitionResponse::Link(links)) => links\n@@ -874,24 +894,13 @@ pub fn handle_code_lens_resolve(world: WorldSnapshot, code_lens: CodeLens) -> Re\n                     _ => vec![],\n                 };\n \n-            let title = if locations.len() == 1 {\n-                \"1 implementation\".into()\n-            } else {\n-                format!(\"{} implementations\", locations.len())\n-            };\n-\n-            // We cannot use the 'editor.action.showReferences' command directly\n-            // because that command requires vscode types which we convert in the handler\n-            // on the client side.\n-            let cmd = Command {\n+            let title = implementation_title(locations.len());\n+            let cmd = show_references_command(\n                 title,\n-                command: \"rust-analyzer.showReferences\".into(),\n-                arguments: Some(vec![\n-                    to_value(&lens_params.text_document_position_params.text_document.uri).unwrap(),\n-                    to_value(code_lens.range.start).unwrap(),\n-                    to_value(locations).unwrap(),\n-                ]),\n-            };\n+                &lens_params.text_document_position_params.text_document.uri,\n+                code_lens.range.start,\n+                locations,\n+            );\n             Ok(CodeLens { range: code_lens.range, command: Some(cmd), data: None })\n         }\n         None => Ok(CodeLens {\n@@ -903,14 +912,14 @@ pub fn handle_code_lens_resolve(world: WorldSnapshot, code_lens: CodeLens) -> Re\n }\n \n pub fn handle_document_highlight(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_types::DocumentHighlightParams,\n ) -> Result<Option<Vec<DocumentHighlight>>> {\n     let _p = profile(\"handle_document_highlight\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n-    let line_index = world.analysis().file_line_index(position.file_id)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n+    let line_index = snap.analysis().file_line_index(position.file_id)?;\n \n-    let refs = match world\n+    let refs = match snap\n         .analysis()\n         .find_all_refs(position, Some(SearchScope::single_file(position.file_id)))?\n     {\n@@ -930,19 +939,19 @@ pub fn handle_document_highlight(\n }\n \n pub fn handle_ssr(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: lsp_ext::SsrParams,\n ) -> Result<lsp_types::WorkspaceEdit> {\n     let _p = profile(\"handle_ssr\");\n     let source_change =\n-        world.analysis().structural_search_replace(&params.query, params.parse_only)??;\n-    to_proto::workspace_edit(&world, source_change)\n+        snap.analysis().structural_search_replace(&params.query, params.parse_only)??;\n+    to_proto::workspace_edit(&snap, source_change)\n }\n \n-pub fn publish_diagnostics(world: &WorldSnapshot, file_id: FileId) -> Result<DiagnosticTask> {\n+pub fn publish_diagnostics(snap: &GlobalStateSnapshot, file_id: FileId) -> Result<DiagnosticTask> {\n     let _p = profile(\"publish_diagnostics\");\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let diagnostics: Vec<Diagnostic> = world\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n+    let diagnostics: Vec<Diagnostic> = snap\n         .analysis()\n         .diagnostics(file_id)?\n         .into_iter()\n@@ -959,87 +968,29 @@ pub fn publish_diagnostics(world: &WorldSnapshot, file_id: FileId) -> Result<Dia\n     Ok(DiagnosticTask::SetNative(file_id, diagnostics))\n }\n \n-fn to_lsp_runnable(\n-    world: &WorldSnapshot,\n-    file_id: FileId,\n-    runnable: Runnable,\n-) -> Result<lsp_ext::Runnable> {\n-    let spec = CargoTargetSpec::for_file(world, file_id)?;\n-    let target = spec.as_ref().map(|s| s.target.clone());\n-    let mut features_needed = vec![];\n-    for cfg_expr in &runnable.cfg_exprs {\n-        collect_minimal_features_needed(cfg_expr, &mut features_needed);\n-    }\n-    let (args, extra_args) =\n-        CargoTargetSpec::runnable_args(spec, &runnable.kind, &features_needed)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let label = match &runnable.kind {\n-        RunnableKind::Test { test_id, .. } => format!(\"test {}\", test_id),\n-        RunnableKind::TestMod { path } => format!(\"test-mod {}\", path),\n-        RunnableKind::Bench { test_id } => format!(\"bench {}\", test_id),\n-        RunnableKind::DocTest { test_id, .. } => format!(\"doctest {}\", test_id),\n-        RunnableKind::Bin => {\n-            target.map_or_else(|| \"run binary\".to_string(), |t| format!(\"run {}\", t))\n-        }\n-    };\n-    Ok(lsp_ext::Runnable {\n-        range: to_proto::range(&line_index, runnable.range),\n-        label,\n-        bin: \"cargo\".to_string(),\n-        args,\n-        extra_args,\n-        env: {\n-            let mut m = FxHashMap::default();\n-            m.insert(\"RUST_BACKTRACE\".to_string(), \"short\".to_string());\n-            m\n-        },\n-        cwd: world.workspace_root_for(file_id).map(|root| root.to_owned()),\n-    })\n-}\n-\n-/// Fill minimal features needed\n-fn collect_minimal_features_needed(cfg_expr: &CfgExpr, features: &mut Vec<SmolStr>) {\n-    match cfg_expr {\n-        CfgExpr::KeyValue { key, value } if key == \"feature\" => features.push(value.clone()),\n-        CfgExpr::All(preds) => {\n-            preds.iter().for_each(|cfg| collect_minimal_features_needed(cfg, features));\n-        }\n-        CfgExpr::Any(preds) => {\n-            for cfg in preds {\n-                let len_features = features.len();\n-                collect_minimal_features_needed(cfg, features);\n-                if len_features != features.len() {\n-                    break;\n-                }\n-            }\n-        }\n-        _ => {}\n-    }\n-}\n-\n pub fn handle_inlay_hints(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: InlayHintsParams,\n ) -> Result<Vec<InlayHint>> {\n     let _p = profile(\"handle_inlay_hints\");\n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let analysis = world.analysis();\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let analysis = snap.analysis();\n     let line_index = analysis.file_line_index(file_id)?;\n     Ok(analysis\n-        .inlay_hints(file_id, &world.config.inlay_hints)?\n+        .inlay_hints(file_id, &snap.config.inlay_hints)?\n         .into_iter()\n         .map(|it| to_proto::inlay_int(&line_index, it))\n         .collect())\n }\n \n pub fn handle_call_hierarchy_prepare(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: CallHierarchyPrepareParams,\n ) -> Result<Option<Vec<CallHierarchyItem>>> {\n     let _p = profile(\"handle_call_hierarchy_prepare\");\n-    let position = from_proto::file_position(&world, params.text_document_position_params)?;\n+    let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n \n-    let nav_info = match world.analysis().call_hierarchy(position)? {\n+    let nav_info = match snap.analysis().call_hierarchy(position)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -1048,24 +999,24 @@ pub fn handle_call_hierarchy_prepare(\n     let res = navs\n         .into_iter()\n         .filter(|it| it.kind() == SyntaxKind::FN_DEF)\n-        .map(|it| to_proto::call_hierarchy_item(&world, it))\n+        .map(|it| to_proto::call_hierarchy_item(&snap, it))\n         .collect::<Result<Vec<_>>>()?;\n \n     Ok(Some(res))\n }\n \n pub fn handle_call_hierarchy_incoming(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: CallHierarchyIncomingCallsParams,\n ) -> Result<Option<Vec<CallHierarchyIncomingCall>>> {\n     let _p = profile(\"handle_call_hierarchy_incoming\");\n     let item = params.item;\n \n     let doc = TextDocumentIdentifier::new(item.uri);\n-    let frange = from_proto::file_range(&world, doc, item.range)?;\n+    let frange = from_proto::file_range(&snap, doc, item.range)?;\n     let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n-    let call_items = match world.analysis().incoming_calls(fpos)? {\n+    let call_items = match snap.analysis().incoming_calls(fpos)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -1074,8 +1025,8 @@ pub fn handle_call_hierarchy_incoming(\n \n     for call_item in call_items.into_iter() {\n         let file_id = call_item.target.file_id();\n-        let line_index = world.analysis().file_line_index(file_id)?;\n-        let item = to_proto::call_hierarchy_item(&world, call_item.target)?;\n+        let line_index = snap.analysis().file_line_index(file_id)?;\n+        let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;\n         res.push(CallHierarchyIncomingCall {\n             from: item,\n             from_ranges: call_item\n@@ -1090,17 +1041,17 @@ pub fn handle_call_hierarchy_incoming(\n }\n \n pub fn handle_call_hierarchy_outgoing(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: CallHierarchyOutgoingCallsParams,\n ) -> Result<Option<Vec<CallHierarchyOutgoingCall>>> {\n     let _p = profile(\"handle_call_hierarchy_outgoing\");\n     let item = params.item;\n \n     let doc = TextDocumentIdentifier::new(item.uri);\n-    let frange = from_proto::file_range(&world, doc, item.range)?;\n+    let frange = from_proto::file_range(&snap, doc, item.range)?;\n     let fpos = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n-    let call_items = match world.analysis().outgoing_calls(fpos)? {\n+    let call_items = match snap.analysis().outgoing_calls(fpos)? {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -1109,8 +1060,8 @@ pub fn handle_call_hierarchy_outgoing(\n \n     for call_item in call_items.into_iter() {\n         let file_id = call_item.target.file_id();\n-        let line_index = world.analysis().file_line_index(file_id)?;\n-        let item = to_proto::call_hierarchy_item(&world, call_item.target)?;\n+        let line_index = snap.analysis().file_line_index(file_id)?;\n+        let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;\n         res.push(CallHierarchyOutgoingCall {\n             to: item,\n             from_ranges: call_item\n@@ -1125,82 +1076,165 @@ pub fn handle_call_hierarchy_outgoing(\n }\n \n pub fn handle_semantic_tokens(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: SemanticTokensParams,\n ) -> Result<Option<SemanticTokensResult>> {\n     let _p = profile(\"handle_semantic_tokens\");\n \n-    let file_id = from_proto::file_id(&world, &params.text_document.uri)?;\n-    let text = world.analysis().file_text(file_id)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n+    let text = snap.analysis().file_text(file_id)?;\n+    let line_index = snap.analysis().file_line_index(file_id)?;\n \n-    let highlights = world.analysis().highlight(file_id)?;\n+    let highlights = snap.analysis().highlight(file_id)?;\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n     Ok(Some(semantic_tokens.into()))\n }\n \n pub fn handle_semantic_tokens_range(\n-    world: WorldSnapshot,\n+    snap: GlobalStateSnapshot,\n     params: SemanticTokensRangeParams,\n ) -> Result<Option<SemanticTokensRangeResult>> {\n     let _p = profile(\"handle_semantic_tokens_range\");\n \n-    let frange = from_proto::file_range(&world, params.text_document, params.range)?;\n-    let text = world.analysis().file_text(frange.file_id)?;\n-    let line_index = world.analysis().file_line_index(frange.file_id)?;\n+    let frange = from_proto::file_range(&snap, params.text_document, params.range)?;\n+    let text = snap.analysis().file_text(frange.file_id)?;\n+    let line_index = snap.analysis().file_line_index(frange.file_id)?;\n \n-    let highlights = world.analysis().highlight_range(frange)?;\n+    let highlights = snap.analysis().highlight_range(frange)?;\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n     Ok(Some(semantic_tokens.into()))\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n+fn implementation_title(count: usize) -> String {\n+    if count == 1 {\n+        \"1 implementation\".into()\n+    } else {\n+        format!(\"{} implementations\", count)\n+    }\n+}\n \n-    use mbe::{ast_to_token_tree, TokenMap};\n-    use ra_cfg::parse_cfg;\n-    use ra_syntax::{\n-        ast::{self, AstNode},\n-        SmolStr,\n-    };\n+fn show_references_command(\n+    title: String,\n+    uri: &lsp_types::Url,\n+    position: lsp_types::Position,\n+    locations: Vec<lsp_types::Location>,\n+) -> Command {\n+    // We cannot use the 'editor.action.showReferences' command directly\n+    // because that command requires vscode types which we convert in the handler\n+    // on the client side.\n+\n+    Command {\n+        title,\n+        command: \"rust-analyzer.showReferences\".into(),\n+        arguments: Some(vec![\n+            to_value(uri).unwrap(),\n+            to_value(position).unwrap(),\n+            to_value(locations).unwrap(),\n+        ]),\n+    }\n+}\n \n-    fn get_token_tree_generated(input: &str) -> (tt::Subtree, TokenMap) {\n-        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n-        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n-        ast_to_token_tree(&tt).unwrap()\n+fn run_single_command(runnable: &lsp_ext::Runnable, title: &str) -> Command {\n+    Command {\n+        title: title.to_string(),\n+        command: \"rust-analyzer.runSingle\".into(),\n+        arguments: Some(vec![to_value(runnable).unwrap()]),\n     }\n+}\n \n-    #[test]\n-    fn test_cfg_expr_minimal_features_needed() {\n-        let (subtree, _) = get_token_tree_generated(r#\"#![cfg(feature = \"baz\")]\"#);\n-        let cfg_expr = parse_cfg(&subtree);\n-        let mut min_features = vec![];\n-        collect_minimal_features_needed(&cfg_expr, &mut min_features);\n+fn debug_single_command(runnable: &lsp_ext::Runnable) -> Command {\n+    Command {\n+        title: \"Debug\".into(),\n+        command: \"rust-analyzer.debugSingle\".into(),\n+        arguments: Some(vec![to_value(runnable).unwrap()]),\n+    }\n+}\n \n-        assert_eq!(min_features, vec![SmolStr::new(\"baz\")]);\n+fn to_command_link(command: Command, tooltip: String) -> lsp_ext::CommandLink {\n+    lsp_ext::CommandLink { tooltip: Some(tooltip), command }\n+}\n \n-        let (subtree, _) =\n-            get_token_tree_generated(r#\"#![cfg(all(feature = \"baz\", feature = \"foo\"))]\"#);\n-        let cfg_expr = parse_cfg(&subtree);\n+fn show_impl_command_link(\n+    snap: &GlobalStateSnapshot,\n+    position: &FilePosition,\n+) -> Option<lsp_ext::CommandLinkGroup> {\n+    if snap.config.hover.implementations {\n+        if let Some(nav_data) = snap.analysis().goto_implementation(*position).unwrap_or(None) {\n+            let uri = to_proto::url(snap, position.file_id).ok()?;\n+            let line_index = snap.analysis().file_line_index(position.file_id).ok()?;\n+            let position = to_proto::position(&line_index, position.offset);\n+            let locations: Vec<_> = nav_data\n+                .info\n+                .iter()\n+                .filter_map(|it| to_proto::location(snap, it.file_range()).ok())\n+                .collect();\n+            let title = implementation_title(locations.len());\n+            let command = show_references_command(title, &uri, position, locations);\n+\n+            return Some(lsp_ext::CommandLinkGroup {\n+                commands: vec![to_command_link(command, \"Go to implementations\".into())],\n+                ..Default::default()\n+            });\n+        }\n+    }\n+    None\n+}\n \n-        let mut min_features = vec![];\n-        collect_minimal_features_needed(&cfg_expr, &mut min_features);\n-        assert_eq!(min_features, vec![SmolStr::new(\"baz\"), SmolStr::new(\"foo\")]);\n+fn to_runnable_action(\n+    snap: &GlobalStateSnapshot,\n+    file_id: FileId,\n+    runnable: Runnable,\n+) -> Option<lsp_ext::CommandLinkGroup> {\n+    let cargo_spec = CargoTargetSpec::for_file(&snap, file_id).ok()?;\n+    if should_skip_target(&runnable, cargo_spec.as_ref()) {\n+        return None;\n+    }\n \n-        let (subtree, _) =\n-            get_token_tree_generated(r#\"#![cfg(any(feature = \"baz\", feature = \"foo\", unix))]\"#);\n-        let cfg_expr = parse_cfg(&subtree);\n+    let action: &'static _ = runnable.action();\n+    to_proto::runnable(snap, file_id, runnable).ok().map(|r| {\n+        let mut group = lsp_ext::CommandLinkGroup::default();\n \n-        let mut min_features = vec![];\n-        collect_minimal_features_needed(&cfg_expr, &mut min_features);\n-        assert_eq!(min_features, vec![SmolStr::new(\"baz\")]);\n+        if snap.config.hover.run {\n+            let run_command = run_single_command(&r, action.run_title);\n+            group.commands.push(to_command_link(run_command, r.label.clone()));\n+        }\n \n-        let (subtree, _) = get_token_tree_generated(r#\"#![cfg(foo)]\"#);\n-        let cfg_expr = parse_cfg(&subtree);\n+        if snap.config.hover.debug {\n+            let dbg_command = debug_single_command(&r);\n+            group.commands.push(to_command_link(dbg_command, r.label));\n+        }\n+\n+        group\n+    })\n+}\n+\n+fn prepare_hover_actions(\n+    snap: &GlobalStateSnapshot,\n+    file_id: FileId,\n+    actions: &[HoverAction],\n+) -> Vec<lsp_ext::CommandLinkGroup> {\n+    if snap.config.hover.none() || !snap.config.client_caps.hover_actions {\n+        return Vec::new();\n+    }\n \n-        let mut min_features = vec![];\n-        collect_minimal_features_needed(&cfg_expr, &mut min_features);\n-        assert!(min_features.is_empty());\n+    actions\n+        .iter()\n+        .filter_map(|it| match it {\n+            HoverAction::Implementaion(position) => show_impl_command_link(snap, position),\n+            HoverAction::Runnable(r) => to_runnable_action(snap, file_id, r.clone()),\n+        })\n+        .collect()\n+}\n+\n+fn should_skip_target(runnable: &Runnable, cargo_spec: Option<&CargoTargetSpec>) -> bool {\n+    match runnable.kind {\n+        RunnableKind::Bin => {\n+            // Do not suggest binary run on other target than binary\n+            match &cargo_spec {\n+                Some(spec) => spec.target_kind != TargetKind::Bin,\n+                None => true,\n+            }\n+        }\n+        _ => false,\n     }\n }"}, {"sha": "710df1fbdec4e7d3e530b8c2d64fbe083bd5641e", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 87, "deletions": 38, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -3,13 +3,16 @@ use ra_db::{FileId, FileRange};\n use ra_ide::{\n     Assist, CompletionItem, CompletionItemKind, Documentation, FileSystemEdit, Fold, FoldKind,\n     FunctionSignature, Highlight, HighlightModifier, HighlightTag, HighlightedRange, Indel,\n-    InlayHint, InlayKind, InsertTextFormat, LineIndex, NavigationTarget, ReferenceAccess, Severity,\n-    SourceChange, SourceFileEdit, TextEdit,\n+    InlayHint, InlayKind, InsertTextFormat, LineIndex, NavigationTarget, ReferenceAccess,\n+    ResolvedAssist, Runnable, Severity, SourceChange, SourceFileEdit, TextEdit,\n };\n use ra_syntax::{SyntaxKind, TextRange, TextSize};\n use ra_vfs::LineEndings;\n \n-use crate::{lsp_ext, semantic_tokens, world::WorldSnapshot, Result};\n+use crate::{\n+    cargo_target_spec::CargoTargetSpec, global_state::GlobalStateSnapshot, lsp_ext,\n+    semantic_tokens, Result,\n+};\n \n pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::Position {\n     let line_col = line_index.line_col(offset);\n@@ -382,41 +385,44 @@ pub(crate) fn folding_range(\n     }\n }\n \n-pub(crate) fn url(world: &WorldSnapshot, file_id: FileId) -> Result<lsp_types::Url> {\n-    world.file_id_to_uri(file_id)\n+pub(crate) fn url(snap: &GlobalStateSnapshot, file_id: FileId) -> Result<lsp_types::Url> {\n+    snap.file_id_to_uri(file_id)\n }\n \n pub(crate) fn versioned_text_document_identifier(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     file_id: FileId,\n     version: Option<i64>,\n ) -> Result<lsp_types::VersionedTextDocumentIdentifier> {\n-    let res = lsp_types::VersionedTextDocumentIdentifier { uri: url(world, file_id)?, version };\n+    let res = lsp_types::VersionedTextDocumentIdentifier { uri: url(snap, file_id)?, version };\n     Ok(res)\n }\n \n-pub(crate) fn location(world: &WorldSnapshot, frange: FileRange) -> Result<lsp_types::Location> {\n-    let url = url(world, frange.file_id)?;\n-    let line_index = world.analysis().file_line_index(frange.file_id)?;\n+pub(crate) fn location(\n+    snap: &GlobalStateSnapshot,\n+    frange: FileRange,\n+) -> Result<lsp_types::Location> {\n+    let url = url(snap, frange.file_id)?;\n+    let line_index = snap.analysis().file_line_index(frange.file_id)?;\n     let range = range(&line_index, frange.range);\n     let loc = lsp_types::Location::new(url, range);\n     Ok(loc)\n }\n \n pub(crate) fn location_link(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     src: Option<FileRange>,\n     target: NavigationTarget,\n ) -> Result<lsp_types::LocationLink> {\n     let origin_selection_range = match src {\n         Some(src) => {\n-            let line_index = world.analysis().file_line_index(src.file_id)?;\n+            let line_index = snap.analysis().file_line_index(src.file_id)?;\n             let range = range(&line_index, src.range);\n             Some(range)\n         }\n         None => None,\n     };\n-    let (target_uri, target_range, target_selection_range) = location_info(world, target)?;\n+    let (target_uri, target_range, target_selection_range) = location_info(snap, target)?;\n     let res = lsp_types::LocationLink {\n         origin_selection_range,\n         target_uri,\n@@ -427,35 +433,35 @@ pub(crate) fn location_link(\n }\n \n fn location_info(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     target: NavigationTarget,\n ) -> Result<(lsp_types::Url, lsp_types::Range, lsp_types::Range)> {\n-    let line_index = world.analysis().file_line_index(target.file_id())?;\n+    let line_index = snap.analysis().file_line_index(target.file_id())?;\n \n-    let target_uri = url(world, target.file_id())?;\n+    let target_uri = url(snap, target.file_id())?;\n     let target_range = range(&line_index, target.full_range());\n     let target_selection_range =\n         target.focus_range().map(|it| range(&line_index, it)).unwrap_or(target_range);\n     Ok((target_uri, target_range, target_selection_range))\n }\n \n pub(crate) fn goto_definition_response(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     src: Option<FileRange>,\n     targets: Vec<NavigationTarget>,\n ) -> Result<lsp_types::GotoDefinitionResponse> {\n-    if world.config.client_caps.location_link {\n+    if snap.config.client_caps.location_link {\n         let links = targets\n             .into_iter()\n-            .map(|nav| location_link(world, src, nav))\n+            .map(|nav| location_link(snap, src, nav))\n             .collect::<Result<Vec<_>>>()?;\n         Ok(links.into())\n     } else {\n         let locations = targets\n             .into_iter()\n             .map(|nav| {\n                 location(\n-                    world,\n+                    snap,\n                     FileRange {\n                         file_id: nav.file_id(),\n                         range: nav.focus_range().unwrap_or(nav.range()),\n@@ -468,13 +474,13 @@ pub(crate) fn goto_definition_response(\n }\n \n pub(crate) fn snippet_text_document_edit(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     is_snippet: bool,\n     source_file_edit: SourceFileEdit,\n ) -> Result<lsp_ext::SnippetTextDocumentEdit> {\n-    let text_document = versioned_text_document_identifier(world, source_file_edit.file_id, None)?;\n-    let line_index = world.analysis().file_line_index(source_file_edit.file_id)?;\n-    let line_endings = world.file_line_endings(source_file_edit.file_id);\n+    let text_document = versioned_text_document_identifier(snap, source_file_edit.file_id, None)?;\n+    let line_index = snap.analysis().file_line_index(source_file_edit.file_id)?;\n+    let line_endings = snap.file_line_endings(source_file_edit.file_id);\n     let edits = source_file_edit\n         .edit\n         .into_iter()\n@@ -484,34 +490,34 @@ pub(crate) fn snippet_text_document_edit(\n }\n \n pub(crate) fn resource_op(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     file_system_edit: FileSystemEdit,\n ) -> Result<lsp_types::ResourceOp> {\n     let res = match file_system_edit {\n         FileSystemEdit::CreateFile { source_root, path } => {\n-            let uri = world.path_to_uri(source_root, &path)?;\n+            let uri = snap.path_to_uri(source_root, &path)?;\n             lsp_types::ResourceOp::Create(lsp_types::CreateFile { uri, options: None })\n         }\n         FileSystemEdit::MoveFile { src, dst_source_root, dst_path } => {\n-            let old_uri = world.file_id_to_uri(src)?;\n-            let new_uri = world.path_to_uri(dst_source_root, &dst_path)?;\n+            let old_uri = snap.file_id_to_uri(src)?;\n+            let new_uri = snap.path_to_uri(dst_source_root, &dst_path)?;\n             lsp_types::ResourceOp::Rename(lsp_types::RenameFile { old_uri, new_uri, options: None })\n         }\n     };\n     Ok(res)\n }\n \n pub(crate) fn snippet_workspace_edit(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     source_change: SourceChange,\n ) -> Result<lsp_ext::SnippetWorkspaceEdit> {\n     let mut document_changes: Vec<lsp_ext::SnippetDocumentChangeOperation> = Vec::new();\n     for op in source_change.file_system_edits {\n-        let op = resource_op(&world, op)?;\n+        let op = resource_op(&snap, op)?;\n         document_changes.push(lsp_ext::SnippetDocumentChangeOperation::Op(op));\n     }\n     for edit in source_change.source_file_edits {\n-        let edit = snippet_text_document_edit(&world, source_change.is_snippet, edit)?;\n+        let edit = snippet_text_document_edit(&snap, source_change.is_snippet, edit)?;\n         document_changes.push(lsp_ext::SnippetDocumentChangeOperation::Edit(edit));\n     }\n     let workspace_edit =\n@@ -520,11 +526,11 @@ pub(crate) fn snippet_workspace_edit(\n }\n \n pub(crate) fn workspace_edit(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     source_change: SourceChange,\n ) -> Result<lsp_types::WorkspaceEdit> {\n     assert!(!source_change.is_snippet);\n-    snippet_workspace_edit(world, source_change).map(|it| it.into())\n+    snippet_workspace_edit(snap, source_change).map(|it| it.into())\n }\n \n impl From<lsp_ext::SnippetWorkspaceEdit> for lsp_types::WorkspaceEdit {\n@@ -563,13 +569,13 @@ impl From<lsp_ext::SnippetWorkspaceEdit> for lsp_types::WorkspaceEdit {\n }\n \n pub fn call_hierarchy_item(\n-    world: &WorldSnapshot,\n+    snap: &GlobalStateSnapshot,\n     target: NavigationTarget,\n ) -> Result<lsp_types::CallHierarchyItem> {\n     let name = target.name().to_string();\n     let detail = target.description().map(|it| it.to_string());\n     let kind = symbol_kind(target.kind());\n-    let (uri, range, selection_range) = location_info(world, target)?;\n+    let (uri, range, selection_range) = location_info(snap, target)?;\n     Ok(lsp_types::CallHierarchyItem { name, kind, tags: None, detail, uri, range, selection_range })\n }\n \n@@ -617,13 +623,56 @@ fn main() <fold>{\n     }\n }\n \n-pub(crate) fn code_action(world: &WorldSnapshot, assist: Assist) -> Result<lsp_ext::CodeAction> {\n+pub(crate) fn unresolved_code_action(\n+    snap: &GlobalStateSnapshot,\n+    assist: Assist,\n+    index: usize,\n+) -> Result<lsp_ext::CodeAction> {\n     let res = lsp_ext::CodeAction {\n         title: assist.label,\n-        group: if world.config.client_caps.code_action_group { assist.group_label } else { None },\n+        id: Some(format!(\"{}:{}\", assist.id.0.to_owned(), index.to_string())),\n+        group: assist.group.filter(|_| snap.config.client_caps.code_action_group).map(|gr| gr.0),\n         kind: Some(String::new()),\n-        edit: Some(snippet_workspace_edit(world, assist.source_change)?),\n+        edit: None,\n         command: None,\n     };\n     Ok(res)\n }\n+\n+pub(crate) fn resolved_code_action(\n+    snap: &GlobalStateSnapshot,\n+    assist: ResolvedAssist,\n+) -> Result<lsp_ext::CodeAction> {\n+    let change = assist.source_change;\n+    unresolved_code_action(snap, assist.assist, 0).and_then(|it| {\n+        Ok(lsp_ext::CodeAction {\n+            id: None,\n+            edit: Some(snippet_workspace_edit(snap, change)?),\n+            ..it\n+        })\n+    })\n+}\n+\n+pub(crate) fn runnable(\n+    snap: &GlobalStateSnapshot,\n+    file_id: FileId,\n+    runnable: Runnable,\n+) -> Result<lsp_ext::Runnable> {\n+    let spec = CargoTargetSpec::for_file(snap, file_id)?;\n+    let target = spec.as_ref().map(|s| s.target.clone());\n+    let (cargo_args, executable_args) =\n+        CargoTargetSpec::runnable_args(spec, &runnable.kind, &runnable.cfg_exprs)?;\n+    let label = runnable.label(target);\n+    let location = location_link(snap, None, runnable.nav)?;\n+\n+    Ok(lsp_ext::Runnable {\n+        label,\n+        location: Some(location),\n+        kind: lsp_ext::RunnableKind::Cargo,\n+        args: lsp_ext::CargoRunnable {\n+            workspace_root: snap.workspace_root_for(file_id).map(|root| root.to_owned()),\n+            cargo_args,\n+            executable_args,\n+        },\n+    })\n+}"}, {"sha": "0e2a83c6a0e762a32651e566074f8d5f250b70e0", "filename": "crates/rust-analyzer/tests/heavy_tests/main.rs", "status": "modified", "additions": 59, "deletions": 139, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fmain.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -4,9 +4,7 @@ use std::{collections::HashMap, path::PathBuf, time::Instant};\n \n use lsp_types::{\n     notification::DidOpenTextDocument,\n-    request::{\n-        CodeActionRequest, Completion, Formatting, GotoDefinition, GotoTypeDefinition, HoverRequest,\n-    },\n+    request::{CodeActionRequest, Completion, Formatting, GotoTypeDefinition, HoverRequest},\n     CodeActionContext, CodeActionParams, CompletionParams, DidOpenTextDocumentParams,\n     DocumentFormattingParams, FormattingOptions, GotoDefinitionParams, HoverParams,\n     PartialResultParams, Position, Range, TextDocumentItem, TextDocumentPositionParams,\n@@ -58,52 +56,6 @@ use std::collections::Spam;\n     eprintln!(\"completion took {:?}\", completion_start.elapsed());\n }\n \n-#[test]\n-fn test_runnables_no_project() {\n-    if skip_slow_tests() {\n-        return;\n-    }\n-\n-    let server = project(\n-        r\"\n-//- lib.rs\n-#[test]\n-fn foo() {\n-}\n-\",\n-    );\n-    server.wait_until_workspace_is_loaded();\n-    server.request::<Runnables>(\n-        RunnablesParams { text_document: server.doc_id(\"lib.rs\"), position: None },\n-        json!([\n-          {\n-            \"args\": [ \"test\" ],\n-            \"extraArgs\": [ \"foo\", \"--nocapture\" ],\n-            \"bin\": \"cargo\",\n-            \"env\": { \"RUST_BACKTRACE\": \"short\" },\n-            \"cwd\": null,\n-            \"label\": \"test foo\",\n-            \"range\": {\n-              \"end\": { \"character\": 1, \"line\": 2 },\n-              \"start\": { \"character\": 0, \"line\": 0 }\n-            }\n-          },\n-          {\n-            \"args\": [\"check\", \"--workspace\"],\n-            \"extraArgs\": [],\n-            \"bin\": \"cargo\",\n-            \"env\": {},\n-            \"cwd\": null,\n-            \"label\": \"cargo check --workspace\",\n-            \"range\": {\n-              \"end\": { \"character\": 0, \"line\": 0 },\n-              \"start\": { \"character\": 0, \"line\": 0 }\n-            }\n-          }\n-        ]),\n-    );\n-}\n-\n #[test]\n fn test_runnables_project() {\n     if skip_slow_tests() {\n@@ -138,42 +90,44 @@ fn main() {}\n     server.request::<Runnables>(\n         RunnablesParams { text_document: server.doc_id(\"foo/tests/spam.rs\"), position: None },\n         json!([\n-            {\n-              \"args\": [ \"test\", \"--package\", \"foo\", \"--test\", \"spam\" ],\n-              \"extraArgs\": [ \"test_eggs\", \"--exact\", \"--nocapture\" ],\n-              \"bin\": \"cargo\",\n-              \"env\": { \"RUST_BACKTRACE\": \"short\" },\n-              \"label\": \"test test_eggs\",\n-              \"range\": {\n+          {\n+            \"args\": {\n+              \"cargoArgs\": [\"test\", \"--package\", \"foo\", \"--test\", \"spam\"],\n+              \"executableArgs\": [\"test_eggs\", \"--exact\", \"--nocapture\"],\n+              \"workspaceRoot\": server.path().join(\"foo\")\n+            },\n+            \"kind\": \"cargo\",\n+            \"label\": \"test test_eggs\",\n+            \"location\": {\n+              \"targetRange\": {\n                 \"end\": { \"character\": 17, \"line\": 1 },\n                 \"start\": { \"character\": 0, \"line\": 0 }\n               },\n-              \"cwd\": server.path().join(\"foo\")\n-            },\n-            {\n-              \"args\": [ \"check\", \"--package\", \"foo\" ],\n-              \"extraArgs\": [],\n-              \"bin\": \"cargo\",\n-              \"env\": {},\n-              \"label\": \"cargo check -p foo\",\n-              \"range\": {\n-                \"end\": { \"character\": 0, \"line\": 0 },\n-                \"start\": { \"character\": 0, \"line\": 0 }\n+              \"targetSelectionRange\": {\n+                \"end\": { \"character\": 12, \"line\": 1 },\n+                \"start\": { \"character\": 3, \"line\": 1 }\n               },\n-              \"cwd\": server.path().join(\"foo\")\n-            },\n-            {\n-              \"args\": [ \"test\", \"--package\", \"foo\" ],\n-              \"extraArgs\": [],\n-              \"bin\": \"cargo\",\n-              \"env\": {},\n-              \"label\": \"cargo test -p foo\",\n-              \"range\": {\n-                \"end\": { \"character\": 0, \"line\": 0 },\n-                \"start\": { \"character\": 0, \"line\": 0 }\n-              },\n-              \"cwd\": server.path().join(\"foo\")\n+              \"targetUri\": \"file:///[..]/tests/spam.rs\"\n             }\n+          },\n+          {\n+            \"args\": {\n+              \"cargoArgs\": [\"check\", \"--package\", \"foo\"],\n+              \"executableArgs\": [],\n+              \"workspaceRoot\": server.path().join(\"foo\")\n+            },\n+            \"kind\": \"cargo\",\n+            \"label\": \"cargo check -p foo\"\n+          },\n+          {\n+            \"args\": {\n+              \"cargoArgs\": [\"test\", \"--package\", \"foo\"],\n+              \"executableArgs\": [],\n+              \"workspaceRoot\": server.path().join(\"foo\")\n+            },\n+            \"kind\": \"cargo\",\n+            \"label\": \"cargo test -p foo\"\n+          }\n         ]),\n     );\n }\n@@ -342,6 +296,7 @@ fn main() {}\n                 }\n               ]\n             },\n+            \"kind\": \"quickfix\",\n             \"title\": \"Create module\"\n         }]),\n     );\n@@ -374,8 +329,7 @@ fn test_missing_module_code_action_in_json_project() {\n             \"root_module\": path.join(\"src/lib.rs\"),\n             \"deps\": [],\n             \"edition\": \"2015\",\n-            \"atom_cfgs\": [],\n-            \"key_value_cfgs\": {}\n+            \"cfg\": [ \"cfg_atom_1\", \"feature=cfg_1\"],\n         } ]\n     });\n \n@@ -413,6 +367,7 @@ fn main() {{}}\n                 }\n               ]\n             },\n+            \"kind\": \"quickfix\",\n             \"title\": \"Create module\"\n         }]),\n     );\n@@ -550,6 +505,10 @@ fn main() {\n     println!(\"cargo:rerun-if-changed=build.rs\");\n }\n //- src/main.rs\n+#[rustc_builtin_macro] macro_rules! include {}\n+#[rustc_builtin_macro] macro_rules! concat {}\n+#[rustc_builtin_macro] macro_rules! env {}\n+\n include!(concat!(env!(\"OUT_DIR\"), \"/hello.rs\"));\n \n #[cfg(atom_cfg)]\n@@ -564,65 +523,44 @@ struct B;\n fn main() {\n     let va = A;\n     let vb = B;\n-    message();\n+    let should_be_str = message();\n }\n-\n-fn main() { message(); }\n \"###,\n     )\n     .with_config(|config| {\n         config.cargo.load_out_dirs_from_check = true;\n     })\n     .server();\n     server.wait_until_workspace_is_loaded();\n-    let res = server.send_request::<GotoDefinition>(GotoDefinitionParams {\n+    let res = server.send_request::<HoverRequest>(HoverParams {\n         text_document_position_params: TextDocumentPositionParams::new(\n             server.doc_id(\"src/main.rs\"),\n-            Position::new(14, 8),\n+            Position::new(18, 10),\n         ),\n         work_done_progress_params: Default::default(),\n-        partial_result_params: Default::default(),\n     });\n-    assert!(format!(\"{}\", res).contains(\"hello.rs\"));\n+    assert!(res.to_string().contains(\"&str\"));\n     server.request::<GotoTypeDefinition>(\n         GotoDefinitionParams {\n             text_document_position_params: TextDocumentPositionParams::new(\n                 server.doc_id(\"src/main.rs\"),\n-                Position::new(12, 9),\n+                Position::new(16, 9),\n             ),\n             work_done_progress_params: Default::default(),\n             partial_result_params: Default::default(),\n         },\n         json!([{\n             \"originSelectionRange\": {\n-                \"end\": {\n-                    \"character\": 10,\n-                    \"line\": 12\n-                },\n-                \"start\": {\n-                    \"character\": 8,\n-                    \"line\": 12\n-                }\n+                \"end\": { \"character\": 10, \"line\": 16 },\n+                \"start\": { \"character\": 8, \"line\": 16 }\n             },\n             \"targetRange\": {\n-                \"end\": {\n-                    \"character\": 9,\n-                    \"line\": 3\n-                },\n-                \"start\": {\n-                    \"character\": 0,\n-                    \"line\": 2\n-                }\n+                \"end\": { \"character\": 9, \"line\": 7 },\n+                \"start\": { \"character\": 0, \"line\": 6 }\n             },\n             \"targetSelectionRange\": {\n-                \"end\": {\n-                    \"character\": 8,\n-                    \"line\": 3\n-                },\n-                \"start\": {\n-                    \"character\": 7,\n-                    \"line\": 3\n-                }\n+                \"end\": { \"character\": 8, \"line\": 7 },\n+                \"start\": { \"character\": 7, \"line\": 7 }\n             },\n             \"targetUri\": \"file:///[..]src/main.rs\"\n         }]),\n@@ -631,41 +569,23 @@ fn main() { message(); }\n         GotoDefinitionParams {\n             text_document_position_params: TextDocumentPositionParams::new(\n                 server.doc_id(\"src/main.rs\"),\n-                Position::new(13, 9),\n+                Position::new(17, 9),\n             ),\n             work_done_progress_params: Default::default(),\n             partial_result_params: Default::default(),\n         },\n         json!([{\n             \"originSelectionRange\": {\n-                \"end\": {\n-                    \"character\": 10,\n-                    \"line\": 13\n-                },\n-                \"start\": {\n-                    \"character\": 8,\n-                    \"line\":13\n-                }\n+                \"end\": { \"character\": 10, \"line\": 17 },\n+                \"start\": { \"character\": 8, \"line\": 17 }\n             },\n             \"targetRange\": {\n-                \"end\": {\n-                    \"character\": 9,\n-                    \"line\": 7\n-                },\n-                \"start\": {\n-                    \"character\": 0,\n-                    \"line\":6\n-                }\n+                \"end\": { \"character\": 9, \"line\": 11 },\n+                \"start\": { \"character\": 0, \"line\":10 }\n             },\n             \"targetSelectionRange\": {\n-                \"end\": {\n-                    \"character\": 8,\n-                    \"line\": 7\n-                },\n-                \"start\": {\n-                    \"character\": 7,\n-                    \"line\": 7\n-                }\n+                \"end\": { \"character\": 8, \"line\": 11 },\n+                \"start\": { \"character\": 7, \"line\": 11 }\n             },\n             \"targetUri\": \"file:///[..]src/main.rs\"\n         }]),"}, {"sha": "30d03b622b91f13c28091efb4faa5d487cfeb345", "filename": "crates/rust-analyzer/tests/heavy_tests/support.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -19,8 +19,9 @@ use serde_json::{to_string_pretty, Value};\n use tempfile::TempDir;\n use test_utils::{find_mismatch, parse_fixture};\n \n+use ra_project_model::ProjectManifest;\n use rust_analyzer::{\n-    config::{ClientCapsConfig, Config},\n+    config::{ClientCapsConfig, Config, LinkedProject},\n     main_loop,\n };\n \n@@ -42,7 +43,7 @@ impl<'a> Project<'a> {\n         self\n     }\n \n-    pub fn root(mut self, path: &str) -> Project<'a> {\n+    pub(crate) fn root(mut self, path: &str) -> Project<'a> {\n         self.roots.push(path.into());\n         self\n     }\n@@ -74,7 +75,16 @@ impl<'a> Project<'a> {\n             paths.push((path, entry.text));\n         }\n \n-        let roots = self.roots.into_iter().map(|root| tmp_dir.path().join(root)).collect();\n+        let mut roots =\n+            self.roots.into_iter().map(|root| tmp_dir.path().join(root)).collect::<Vec<_>>();\n+        if roots.is_empty() {\n+            roots.push(tmp_dir.path().to_path_buf());\n+        }\n+        let linked_projects = roots\n+            .into_iter()\n+            .map(|it| ProjectManifest::discover_single(&it).unwrap())\n+            .map(LinkedProject::from)\n+            .collect::<Vec<_>>();\n \n         let mut config = Config {\n             client_caps: ClientCapsConfig {\n@@ -84,14 +94,15 @@ impl<'a> Project<'a> {\n                 ..Default::default()\n             },\n             with_sysroot: self.with_sysroot,\n+            linked_projects,\n             ..Config::default()\n         };\n \n         if let Some(f) = &self.config {\n             f(&mut config)\n         }\n \n-        Server::new(tmp_dir, config, roots, paths)\n+        Server::new(tmp_dir, config, paths)\n     }\n }\n \n@@ -109,20 +120,12 @@ pub struct Server {\n }\n \n impl Server {\n-    fn new(\n-        dir: TempDir,\n-        config: Config,\n-        roots: Vec<PathBuf>,\n-        files: Vec<(PathBuf, String)>,\n-    ) -> Server {\n-        let path = dir.path().to_path_buf();\n-\n-        let roots = if roots.is_empty() { vec![path] } else { roots };\n+    fn new(dir: TempDir, config: Config, files: Vec<(PathBuf, String)>) -> Server {\n         let (connection, client) = Connection::memory();\n \n         let _thread = jod_thread::Builder::new()\n             .name(\"test server\".to_string())\n-            .spawn(move || main_loop(roots, config, connection).unwrap())\n+            .spawn(move || main_loop(config, connection).unwrap())\n             .expect(\"failed to spawn a thread\");\n \n         let res ="}, {"sha": "c0356344ca24e94f75a75d1fb08f225241f7a261", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -124,3 +124,8 @@ pub fn replace(buf: &mut String, from: char, to: &str) {\n     // FIXME: do this in place.\n     *buf = buf.replace(from, to)\n }\n+\n+pub fn split1(haystack: &str, delim: char) -> Option<(&str, &str)> {\n+    let idx = haystack.find(delim)?;\n+    Some((&haystack[..idx], &haystack[idx + delim.len_utf8()..]))\n+}"}, {"sha": "8840bf36ae325c79b39eaccaaa2ebdd56fa709d2", "filename": "crates/test_utils/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Ftest_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Ftest_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2FCargo.toml?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -14,4 +14,5 @@ serde_json = \"1.0.48\"\n relative-path = \"1.0.0\"\n rustc-hash = \"1.1.0\"\n \n-ra_cfg = { path = \"../ra_cfg\" }\n\\ No newline at end of file\n+ra_cfg = { path = \"../ra_cfg\" }\n+stdx = { path = \"../stdx\" }\n\\ No newline at end of file"}, {"sha": "2141bfc202779a705eb7da0f378b2a94b61896d8", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -15,6 +15,7 @@ use std::{\n };\n \n pub use ra_cfg::CfgOptions;\n+use stdx::split1;\n \n pub use relative_path::{RelativePath, RelativePathBuf};\n pub use rustc_hash::FxHashMap;\n@@ -332,11 +333,6 @@ fn parse_meta(meta: &str) -> FixtureMeta {\n     FixtureMeta::File(FileMeta { path, crate_name: krate, deps, edition, cfg, env })\n }\n \n-fn split1(haystack: &str, delim: char) -> Option<(&str, &str)> {\n-    let idx = haystack.find(delim)?;\n-    Some((&haystack[..idx], &haystack[idx + delim.len_utf8()..]))\n-}\n-\n /// Adjusts the indentation of the first line to the minimum indentation of the rest of the lines.\n /// This allows fixtures to start off in a different indentation, e.g. to align the first line with\n /// the other lines visually:"}, {"sha": "ef5ffbf597ae9a9aad9275e7e68809f23a54bc95", "filename": "docs/dev/README.md", "status": "modified", "additions": 203, "deletions": 6, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -30,7 +30,7 @@ https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0\n \n * [good-first-issue](https://github.com/rust-analyzer/rust-analyzer/labels/good%20first%20issue)\n   are good issues to get into the project.\n-* [E-mentor](https://github.com/rust-analyzer/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-mentor)\n+* [E-has-instructions](https://github.com/rust-analyzer/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-has-instructions)\n   issues have links to the code in question and tests.\n * [E-easy](https://github.com/rust-analyzer/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-easy),\n   [E-medium](https://github.com/rust-analyzer/rust-analyzer/issues?q=is%3Aopen+is%3Aissue+label%3AE-medium),\n@@ -55,7 +55,7 @@ You can run `cargo xtask install-pre-commit-hook` to install git-hook to run rus\n All Rust code lives in the `crates` top-level directory, and is organized as a\n single Cargo workspace. The `editors` top-level directory contains code for\n integrating with editors. Currently, it contains the plugin for VS Code (in\n-typescript). The `docs` top-level directory contains both developer and user\n+TypeScript). The `docs` top-level directory contains both developer and user\n documentation.\n \n We have some automation infra in Rust in the `xtask` package. It contains\n@@ -79,8 +79,8 @@ possible. There's **\"Run Extension (Debug Build)\"** launch configuration for thi\n In general, I use one of the following workflows for fixing bugs and\n implementing features.\n \n-If the problem concerns only internal parts of rust-analyzer (ie, I don't need\n-to touch `rust-analyzer` crate or typescript code), there is a unit-test for it.\n+If the problem concerns only internal parts of rust-analyzer (i.e. I don't need\n+to touch `rust-analyzer` crate or TypeScript code), there is a unit-test for it.\n So, I use **Rust Analyzer: Run** action in VS Code to run this single test, and\n then just do printf-driven development/debugging. As a sanity check after I'm\n done, I use `cargo xtask install --server` and **Reload Window** action in VS\n@@ -117,6 +117,203 @@ Additionally, I use `cargo run --release -p rust-analyzer -- analysis-stats\n path/to/some/rust/crate` to run a batch analysis. This is primarily useful for\n performance optimizations, or for bug minimization.\n \n+# Code Style & Review Process\n+\n+Our approach to \"clean code\" is two fold:\n+\n+* We generally don't block PRs on style changes.\n+* At the same time, all code in rust-analyzer is constantly refactored.\n+\n+It is explicitly OK for reviewer to flag only some nits in the PR, and than send a follow up cleanup PR for things which are easier to explain by example, cc-ing the original author.\n+Sending small cleanup PRs (like rename a single local variable) is encouraged.\n+\n+## Scale of Changes\n+\n+Everyone knows that it's better to send small & focused pull requests.\n+The problem is, sometimes you *have* to, eg, rewrite the whole compiler, and that just doesn't fit into a set of isolated PRs.\n+\n+The main thing too keep an eye on is the boundaries between various components.\n+There are three kinds of changes:\n+\n+1. Internals of a single component are changed.\n+   Specifically, you don't change any `pub` items.\n+   A good example here would be an addition of a new assist.\n+\n+2. API of a component is expanded.\n+   Specifically, you add a new `pub` function which wasn't there before.\n+   A good example here would be expansion of assist API, for example, to implement lazy assists or assists groups.\n+\n+3. A new dependency between components is introduced.\n+   Specifically, you add a `pub use` reexport from another crate or you add a new line to `[dependencies]` section of `Cargo.toml`.\n+   A good example here would be adding reference search capability to the assists crates.\n+\n+For the first group, the change is generally merged as long as:\n+\n+* it works for the happy case,\n+* it has tests,\n+* it doesn't panic for unhappy case.\n+\n+For the second group, the change would be subjected to quite a bit of scrutiny and iteration.\n+The new API needs to be right (or at least easy to change later).\n+The actual implementation doesn't matter that much.\n+It's very important to minimize the amount of changed lines of code for changes of the second kind.\n+Often, you start doing change of the first kind, only to realise that you need to elevate to a change of the second kind.\n+In this case, we'll probably ask you to split API changes into a separate PR.\n+\n+Changes of the third group should be pretty rare, so we don't specify any specific process for them.\n+That said, adding an innocent-looking `pub use` is a very simple way to break encapsulation, keep an eye on it!\n+\n+Note: if you enjoyed this abstract hand-waving about boundaries, you might appreciate\n+https://www.tedinski.com/2018/02/06/system-boundaries.html\n+\n+## Order of Imports\n+\n+We separate import groups with blank lines\n+\n+```rust\n+mod x;\n+mod y;\n+\n+use std::{ ... }\n+\n+use crate_foo::{ ... }\n+use crate_bar::{ ... }\n+\n+use crate::{}\n+\n+use super::{} // but prefer `use crate::`\n+```\n+\n+## Import Style\n+\n+Items from `hir` and `ast` should be used qualified:\n+\n+```rust\n+// Good\n+use ra_syntax::ast;\n+\n+fn frobnicate(func: hir::Function, strukt: ast::StructDef) {}\n+\n+// Not as good\n+use hir::Function;\n+use ra_syntax::ast::StructDef;\n+\n+fn frobnicate(func: Function, strukt: StructDef) {}\n+```\n+\n+Avoid local `use MyEnum::*` imports.\n+\n+Prefer `use crate::foo::bar` to `use super::bar`.\n+\n+## Order of Items\n+\n+Optimize for the reader who sees the file for the first time, and wants to get the general idea about what's going on.\n+People read things from top to bottom, so place most important things first.\n+\n+Specifically, if all items except one are private, always put the non-private item on top.\n+\n+Put `struct`s and `enum`s first, functions and impls last.\n+\n+Do\n+\n+```rust\n+// Good\n+struct Foo {\n+  bars: Vec<Bar>\n+}\n+\n+struct Bar;\n+```\n+\n+rather than\n+\n+```rust\n+// Not as good\n+struct Bar;\n+\n+struct Foo {\n+  bars: Vec<Bar>\n+}\n+```\n+\n+## Documentation\n+\n+For `.md` and `.adoc` files, prefer a sentence-per-line format, don't wrap lines.\n+If the line is too long, you want to split the sentence in two :-)\n+\n+## Preconditions\n+\n+Function preconditions should generally be expressed in types and provided by the caller (rather than checked by callee):\n+\n+```rust\n+// Good\n+fn frbonicate(walrus: Walrus) {\n+  ...\n+}\n+\n+// Not as good\n+fn frobnicate(walrus: Option<Walrus>) {\n+  let walrus = match walrus {\n+    Some(it) => it,\n+    None => return,\n+  };\n+  ...\n+}\n+```\n+\n+## Commit Style\n+\n+We don't have specific rules around git history hygiene.\n+Maintaining clean git history is encouraged, but not enforced.\n+We use rebase workflow, it's OK to rewrite history during PR review process.\n+\n+Avoid @mentioning people in commit messages, as such messages create a lot of duplicate notification traffic during rebases.\n+\n+# Architecture Invariants\n+\n+This section tries to document high-level design constraints, which are not\n+always obvious from the low-level code.\n+\n+## Incomplete syntax trees\n+\n+Syntax trees are by design incomplete and do not enforce well-formedness.\n+If ast method returns an `Option`, it *can* be `None` at runtime, even if this is forbidden by the grammar.\n+\n+## LSP independence\n+\n+rust-analyzer is independent from LSP.\n+It provides features for a hypothetical perfect Rust-specific IDE client.\n+Internal representations are lowered to LSP in the `rust-analyzer` crate (the only crate which is allowed to use LSP types).\n+\n+## IDE/Compiler split\n+\n+There's a semi-hard split between \"compiler\" and \"IDE\", at the `ra_hir` crate.\n+Compiler derives new facts about source code.\n+It explicitly acknowledges that not all info is available (i.e. you can't look at types during name resolution).\n+\n+IDE assumes that all information is available at all times.\n+\n+IDE should use only types from `ra_hir`, and should not depend on the underling compiler types.\n+`ra_hir` is a facade.\n+\n+## IDE API\n+\n+The main IDE crate (`ra_ide`) uses \"Plain Old Data\" for the API.\n+Rather than talking in definitions and references, it talks in Strings and textual offsets.\n+In general, API is centered around UI concerns -- the result of the call is what the user sees in the editor, and not what the compiler sees underneath.\n+The results are 100% Rust specific though.\n+\n+## Parser Tests\n+\n+Test for parser (`ra_parser`) live in `ra_syntax` crate (see `test_data` direcotory).\n+There are two kinds of tests:\n+\n+* Manually written test cases in `parser/ok` and `parser/err`\n+* \"Inline\" tests in `parser/inline` (these are generated) from comments in `ra_parser` crate.\n+\n+The purpose of inline tests is not to achieve full coverage by test cases, but to explain to the reader of the code what each particular `if` and `match` is responsible for.\n+If you are tempted to add a large inline test, it might be a good idea to leave only the simplest example in place, and move the test to a manual `parser/ok` test.\n+\n # Logging\n \n Logging is done by both rust-analyzer and VS Code, so it might be tricky to\n@@ -159,8 +356,8 @@ There's also two VS Code commands which might be of interest:\n   rust code that it refers to and the rust editor will also highlight the proper\n   text range.\n \n-  If you press <kbd>Ctrl</kbd> (i.e. trigger goto definition) in the inspected\n-  Rust source file the syntax tree read-only editor should scroll to and select the\n+  If you trigger Go to Definition in the inspected Rust source file,\n+  the syntax tree read-only editor should scroll to and select the\n   appropriate syntax node token.\n \n   ![demo](https://user-images.githubusercontent.com/36276403/78225773-6636a480-74d3-11ea-9d9f-1c9d42da03b0.png)"}, {"sha": "a0847dad3a8f158a4d17b281286df12c00fb9de0", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 96, "deletions": 26, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -97,6 +97,30 @@ Invoking code action at this position will yield two code actions for importing\n * Is a fixed two-level structure enough?\n * Should we devise a general way to encode custom interaction protocols for GUI refactorings?\n \n+## Lazy assists with `ResolveCodeAction`\n+\n+**Issue:** https://github.com/microsoft/language-server-protocol/issues/787\n+\n+**Client Capability** `{ \"resolveCodeAction\": boolean }`\n+\n+If this capability is set, the assists will be computed lazily. Thus `CodeAction` returned from the server will only contain `id` but not `edit` or `command` fields. The only exclusion from the rule is the diagnostic edits.\n+\n+After the client got the id, it should then call `experimental/resolveCodeAction` command on the server and provide the following payload:\n+\n+```typescript\n+interface ResolveCodeActionParams {\n+    id: string;\n+    codeActionParams: lc.CodeActionParams;\n+}\n+```\n+\n+As a result of the command call the client will get the respective workspace edit (`lc.WorkspaceEdit`).\n+\n+### Unresolved Questions\n+\n+* Apply smarter filtering for ids?\n+* Upon `resolveCodeAction` command only call the assits which should be resolved and not all of them?\n+\n ## Parent Module\n \n **Issue:** https://github.com/microsoft/language-server-protocol/issues/1002\n@@ -311,6 +335,50 @@ Moreover, it would be cool if editors didn't need to implement even basic langua\n   This is how `SelectionRange` request works.\n * Alternatively, should we perhaps flag certain `SelectionRange`s as being brace pairs?\n \n+## Runnables\n+\n+**Issue:** https://github.com/microsoft/language-server-protocol/issues/944\n+\n+**Server Capability:** `{ \"runnables\": { \"kinds\": string[] } }`\n+\n+This request is send from client to server to get the list of things that can be run (tests, binaries, `cargo check -p`).\n+\n+**Method:** `experimental/runnables`\n+\n+**Request:**\n+\n+```typescript\n+interface RunnablesParams {\n+    textDocument: TextDocumentIdentifier;\n+    /// If null, compute runnables for the whole file.\n+    position?: Position;\n+}\n+```\n+\n+**Response:** `Runnable[]`\n+\n+```typescript\n+interface Runnable {\n+    label: string;\n+    /// If this Runnable is associated with a specific function/module, etc, the location of this item\n+    location?: LocationLink;\n+    /// Running things is necessary technology specific, `kind` needs to be advertised via server capabilities,\n+    // the type of `args` is specific to `kind`. The actual running is handled by the client.\n+    kind: string;\n+    args: any;\n+}\n+```\n+\n+rust-analyzer supports only one `kind`, `\"cargo\"`. The `args` for `\"cargo\"` look like this:\n+\n+```typescript\n+{\n+    workspaceRoot?: string;\n+    cargoArgs: string[];\n+    executableArgs: string[];\n+}\n+```\n+\n ## Analyzer Status\n \n **Method:** `rust-analyzer/analyzerStatus`\n@@ -400,38 +468,40 @@ interface InlayHint {\n }\n ```\n \n-## Runnables\n-\n-**Method:** `rust-analyzer/runnables`\n+## Hover Actions\n \n-This request is send from client to server to get the list of things that can be run (tests, binaries, `cargo check -p`).\n-Note that we plan to move this request to `experimental/runnables`, as it is not really Rust-specific, but the current API is not necessary the right one.\n-Upstream issue: https://github.com/microsoft/language-server-protocol/issues/944\n+**Client Capability:** `{ \"hoverActions\": boolean }`\n \n-**Request:**\n+If this capability is set, `Hover` request returned from the server might contain an additional field, `actions`:\n \n ```typescript\n-interface RunnablesParams {\n-    textDocument: TextDocumentIdentifier;\n-    /// If null, compute runnables for the whole file.\n-    position?: Position;\n+interface Hover {\n+    ...\n+    actions?: CommandLinkGroup[];\n }\n-```\n \n-**Response:** `Runnable[]`\n+interface CommandLink extends Command {\n+    /**\n+     * A tooltip for the command, when represented in the UI.\n+     */\n+    tooltip?: string;\n+}\n \n-```typescript\n-interface Runnable {\n-    /// The range this runnable is applicable for.\n-    range: lc.Range;\n-    /// The label to show in the UI.\n-    label: string;\n-    /// The following fields describe a process to spawn.\n-    bin: string;\n-    args: string[];\n-    /// Args for cargo after `--`.\n-    extraArgs: string[];\n-    env: { [key: string]: string };\n-    cwd: string | null;\n+interface CommandLinkGroup {\n+    title?: string;\n+    commands: CommandLink[];\n }\n ```\n+\n+Such actions on the client side are appended to a hover bottom as command links:\n+```\n+  +-----------------------------+\n+  | Hover content               |\n+  |                             |\n+  +-----------------------------+\n+  | _Action1_ | _Action2_       |  <- first group, no TITLE\n+  +-----------------------------+\n+  | TITLE _Action1_ | _Action2_ |  <- second group\n+  +-----------------------------+\n+  ...\n+```\n\\ No newline at end of file"}, {"sha": "4d2fb31d4840fe50f9a86ffeb8ebd9a62500bb7f", "filename": "docs/user/generated_assists.adoc", "status": "removed", "additions": 0, "deletions": 1015, "changes": 1015, "blob_url": "https://github.com/rust-lang/rust/blob/eeb8b9e236796da8734ba81a49164864497f7226/docs%2Fuser%2Fgenerated_assists.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/eeb8b9e236796da8734ba81a49164864497f7226/docs%2Fuser%2Fgenerated_assists.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_assists.adoc?ref=eeb8b9e236796da8734ba81a49164864497f7226", "patch": "@@ -1,1015 +0,0 @@\n-[discrete]\n-=== `add_custom_impl`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_custom_impl.rs#L14[add_custom_impl.rs]\n-\n-Adds impl block for derived trait.\n-\n-.Before\n-```rust\n-#[derive(Deb\u2503ug, Display)]\n-struct S;\n-```\n-\n-.After\n-```rust\n-#[derive(Display)]\n-struct S;\n-\n-impl Debug for S {\n-    $0\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_derive`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_derive.rs#L9[add_derive.rs]\n-\n-Adds a new `#[derive()]` clause to a struct or enum.\n-\n-.Before\n-```rust\n-struct Point {\n-    x: u32,\n-    y: u32,\u2503\n-}\n-```\n-\n-.After\n-```rust\n-#[derive($0)]\n-struct Point {\n-    x: u32,\n-    y: u32,\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_explicit_type`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_explicit_type.rs#L9[add_explicit_type.rs]\n-\n-Specify type for a let binding.\n-\n-.Before\n-```rust\n-fn main() {\n-    let x\u2503 = 92;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    let x: i32 = 92;\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_from_impl_for_enum`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_from_impl_for_enum.rs#L7[add_from_impl_for_enum.rs]\n-\n-Adds a From impl for an enum variant with one tuple field.\n-\n-.Before\n-```rust\n-enum A { \u2503One(u32) }\n-```\n-\n-.After\n-```rust\n-enum A { One(u32) }\n-\n-impl From<u32> for A {\n-    fn from(v: u32) -> Self {\n-        A::One(v)\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_function`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_function.rs#L19[add_function.rs]\n-\n-Adds a stub function with a signature matching the function under the cursor.\n-\n-.Before\n-```rust\n-struct Baz;\n-fn baz() -> Baz { Baz }\n-fn foo() {\n-    bar\u2503(\"\", baz());\n-}\n-\n-```\n-\n-.After\n-```rust\n-struct Baz;\n-fn baz() -> Baz { Baz }\n-fn foo() {\n-    bar(\"\", baz());\n-}\n-\n-fn bar(arg: &str, baz: Baz) {\n-    ${0:todo!()}\n-}\n-\n-```\n-\n-\n-[discrete]\n-=== `add_hash`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/raw_string.rs#L65[raw_string.rs]\n-\n-Adds a hash to a raw string literal.\n-\n-.Before\n-```rust\n-fn main() {\n-    r#\"Hello,\u2503 World!\"#;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    r##\"Hello, World!\"##;\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_impl`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_impl.rs#L6[add_impl.rs]\n-\n-Adds a new inherent impl for a type.\n-\n-.Before\n-```rust\n-struct Ctx<T: Clone> {\n-    data: T,\u2503\n-}\n-```\n-\n-.After\n-```rust\n-struct Ctx<T: Clone> {\n-    data: T,\n-}\n-\n-impl<T: Clone> Ctx<T> {\n-    $0\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_impl_default_members`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_missing_impl_members.rs#L64[add_missing_impl_members.rs]\n-\n-Adds scaffold for overriding default impl members.\n-\n-.Before\n-```rust\n-trait Trait {\n-    Type X;\n-    fn foo(&self);\n-    fn bar(&self) {}\n-}\n-\n-impl Trait for () {\n-    Type X = ();\n-    fn foo(&self) {}\u2503\n-\n-}\n-```\n-\n-.After\n-```rust\n-trait Trait {\n-    Type X;\n-    fn foo(&self);\n-    fn bar(&self) {}\n-}\n-\n-impl Trait for () {\n-    Type X = ();\n-    fn foo(&self) {}\n-    $0fn bar(&self) {}\n-\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_impl_missing_members`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_missing_impl_members.rs#L24[add_missing_impl_members.rs]\n-\n-Adds scaffold for required impl members.\n-\n-.Before\n-```rust\n-trait Trait<T> {\n-    Type X;\n-    fn foo(&self) -> T;\n-    fn bar(&self) {}\n-}\n-\n-impl Trait<u32> for () {\u2503\n-\n-}\n-```\n-\n-.After\n-```rust\n-trait Trait<T> {\n-    Type X;\n-    fn foo(&self) -> T;\n-    fn bar(&self) {}\n-}\n-\n-impl Trait<u32> for () {\n-    fn foo(&self) -> u32 {\n-        ${0:todo!()}\n-    }\n-\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_new`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_new.rs#L12[add_new.rs]\n-\n-Adds a new inherent impl for a type.\n-\n-.Before\n-```rust\n-struct Ctx<T: Clone> {\n-     data: T,\u2503\n-}\n-```\n-\n-.After\n-```rust\n-struct Ctx<T: Clone> {\n-     data: T,\n-}\n-\n-impl<T: Clone> Ctx<T> {\n-    fn $0new(data: T) -> Self { Self { data } }\n-}\n-\n-```\n-\n-\n-[discrete]\n-=== `add_turbo_fish`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_turbo_fish.rs#L10[add_turbo_fish.rs]\n-\n-Adds `::<_>` to a call of a generic method or function.\n-\n-.Before\n-```rust\n-fn make<T>() -> T { todo!() }\n-fn main() {\n-    let x = make\u2503();\n-}\n-```\n-\n-.After\n-```rust\n-fn make<T>() -> T { todo!() }\n-fn main() {\n-    let x = make::<${0:_}>();\n-}\n-```\n-\n-\n-[discrete]\n-=== `apply_demorgan`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/apply_demorgan.rs#L5[apply_demorgan.rs]\n-\n-Apply [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws).\n-This transforms expressions of the form `!l || !r` into `!(l && r)`.\n-This also works with `&&`. This assist can only be applied with the cursor\n-on either `||` or `&&`, with both operands being a negation of some kind.\n-This means something of the form `!x` or `x != y`.\n-\n-.Before\n-```rust\n-fn main() {\n-    if x != 4 ||\u2503 !y {}\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    if !(x == 4 && y) {}\n-}\n-```\n-\n-\n-[discrete]\n-=== `auto_import`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/auto_import.rs#L18[auto_import.rs]\n-\n-If the name is unresolved, provides all possible imports for it.\n-\n-.Before\n-```rust\n-fn main() {\n-    let map = HashMap\u2503::new();\n-}\n-```\n-\n-.After\n-```rust\n-use std::collections::HashMap;\n-\n-fn main() {\n-    let map = HashMap::new();\n-}\n-```\n-\n-\n-[discrete]\n-=== `change_return_type_to_result`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/change_return_type_to_result.rs#L8[change_return_type_to_result.rs]\n-\n-Change the function's return type to Result.\n-\n-.Before\n-```rust\n-fn foo() -> i32\u2503 { 42i32 }\n-```\n-\n-.After\n-```rust\n-fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\n-```\n-\n-\n-[discrete]\n-=== `change_visibility`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/change_visibility.rs#L14[change_visibility.rs]\n-\n-Adds or changes existing visibility specifier.\n-\n-.Before\n-```rust\n-\u2503fn frobnicate() {}\n-```\n-\n-.After\n-```rust\n-pub(crate) fn frobnicate() {}\n-```\n-\n-\n-[discrete]\n-=== `convert_to_guarded_return`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/early_return.rs#L21[early_return.rs]\n-\n-Replace a large conditional with a guarded return.\n-\n-.Before\n-```rust\n-fn main() {\n-    \u2503if cond {\n-        foo();\n-        bar();\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    if !cond {\n-        return;\n-    }\n-    foo();\n-    bar();\n-}\n-```\n-\n-\n-[discrete]\n-=== `fill_match_arms`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/fill_match_arms.rs#L14[fill_match_arms.rs]\n-\n-Adds missing clauses to a `match` expression.\n-\n-.Before\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        \u2503\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        $0Action::Move { distance } => {}\n-        Action::Stop => {}\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `fix_visibility`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/fix_visibility.rs#L13[fix_visibility.rs]\n-\n-Makes inaccessible item public.\n-\n-.Before\n-```rust\n-mod m {\n-    fn frobnicate() {}\n-}\n-fn main() {\n-    m::frobnicate\u2503() {}\n-}\n-```\n-\n-.After\n-```rust\n-mod m {\n-    $0pub(crate) fn frobnicate() {}\n-}\n-fn main() {\n-    m::frobnicate() {}\n-}\n-```\n-\n-\n-[discrete]\n-=== `flip_binexpr`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/flip_binexpr.rs#L5[flip_binexpr.rs]\n-\n-Flips operands of a binary expression.\n-\n-.Before\n-```rust\n-fn main() {\n-    let _ = 90 +\u2503 2;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    let _ = 2 + 90;\n-}\n-```\n-\n-\n-[discrete]\n-=== `flip_comma`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/flip_comma.rs#L5[flip_comma.rs]\n-\n-Flips two comma-separated items.\n-\n-.Before\n-```rust\n-fn main() {\n-    ((1, 2),\u2503 (3, 4));\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    ((3, 4), (1, 2));\n-}\n-```\n-\n-\n-[discrete]\n-=== `flip_trait_bound`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/flip_trait_bound.rs#L9[flip_trait_bound.rs]\n-\n-Flips two trait bounds.\n-\n-.Before\n-```rust\n-fn foo<T: Clone +\u2503 Copy>() { }\n-```\n-\n-.After\n-```rust\n-fn foo<T: Copy + Clone>() { }\n-```\n-\n-\n-[discrete]\n-=== `inline_local_variable`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/inline_local_variable.rs#L13[inline_local_variable.rs]\n-\n-Inlines local variable.\n-\n-.Before\n-```rust\n-fn main() {\n-    let x\u2503 = 1 + 2;\n-    x * 4;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    (1 + 2) * 4;\n-}\n-```\n-\n-\n-[discrete]\n-=== `introduce_named_lifetime`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/introduce_named_lifetime.rs#L12[introduce_named_lifetime.rs]\n-\n-Change an anonymous lifetime to a named lifetime.\n-\n-.Before\n-```rust\n-impl Cursor<'_\u2503> {\n-    fn node(self) -> &SyntaxNode {\n-        match self {\n-            Cursor::Replace(node) | Cursor::Before(node) => node,\n-        }\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-impl<'a> Cursor<'a> {\n-    fn node(self) -> &SyntaxNode {\n-        match self {\n-            Cursor::Replace(node) | Cursor::Before(node) => node,\n-        }\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `introduce_variable`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/introduce_variable.rs#L14[introduce_variable.rs]\n-\n-Extracts subexpression into a variable.\n-\n-.Before\n-```rust\n-fn main() {\n-    \u2503(1 + 2)\u2503 * 4;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    let $0var_name = (1 + 2);\n-    var_name * 4;\n-}\n-```\n-\n-\n-[discrete]\n-=== `invert_if`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/invert_if.rs#L12[invert_if.rs]\n-\n-Apply invert_if\n-This transforms if expressions of the form `if !x {A} else {B}` into `if x {B} else {A}`\n-This also works with `!=`. This assist can only be applied with the cursor\n-on `if`.\n-\n-.Before\n-```rust\n-fn main() {\n-    if\u2503 !y { A } else { B }\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    if y { B } else { A }\n-}\n-```\n-\n-\n-[discrete]\n-=== `make_raw_string`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/raw_string.rs#L10[raw_string.rs]\n-\n-Adds `r#` to a plain string literal.\n-\n-.Before\n-```rust\n-fn main() {\n-    \"Hello,\u2503 World!\";\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    r#\"Hello, World!\"#;\n-}\n-```\n-\n-\n-[discrete]\n-=== `make_usual_string`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/raw_string.rs#L39[raw_string.rs]\n-\n-Turns a raw string into a plain string.\n-\n-.Before\n-```rust\n-fn main() {\n-    r#\"Hello,\u2503 \"World!\"\"#;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    \"Hello, \\\"World!\\\"\";\n-}\n-```\n-\n-\n-[discrete]\n-=== `merge_imports`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/merge_imports.rs#L14[merge_imports.rs]\n-\n-Merges two imports with a common prefix.\n-\n-.Before\n-```rust\n-use std::\u2503fmt::Formatter;\n-use std::io;\n-```\n-\n-.After\n-```rust\n-use std::{fmt::Formatter, io};\n-```\n-\n-\n-[discrete]\n-=== `merge_match_arms`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/merge_match_arms.rs#L11[merge_match_arms.rs]\n-\n-Merges identical match arms.\n-\n-.Before\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        \u2503Action::Move(..) => foo(),\n-        Action::Stop => foo(),\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move(..) | Action::Stop => foo(),\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `move_arm_cond_to_match_guard`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/move_guard.rs#L56[move_guard.rs]\n-\n-Moves if expression from match arm body into a guard.\n-\n-.Before\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } => \u2503if distance > 10 { foo() },\n-        _ => (),\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } if distance > 10 => foo(),\n-        _ => (),\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `move_bounds_to_where_clause`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/move_bounds.rs#L10[move_bounds.rs]\n-\n-Moves inline type bounds to a where clause.\n-\n-.Before\n-```rust\n-fn apply<T, U, \u2503F: FnOnce(T) -> U>(f: F, x: T) -> U {\n-    f(x)\n-}\n-```\n-\n-.After\n-```rust\n-fn apply<T, U, F>(f: F, x: T) -> U where F: FnOnce(T) -> U {\n-    f(x)\n-}\n-```\n-\n-\n-[discrete]\n-=== `move_guard_to_arm_body`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/move_guard.rs#L8[move_guard.rs]\n-\n-Moves match guard into match arm body.\n-\n-.Before\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } \u2503if distance > 10 => foo(),\n-        _ => (),\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } => if distance > 10 { foo() },\n-        _ => (),\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `remove_dbg`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/remove_dbg.rs#L8[remove_dbg.rs]\n-\n-Removes `dbg!()` macro call.\n-\n-.Before\n-```rust\n-fn main() {\n-    \u2503dbg!(92);\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    92;\n-}\n-```\n-\n-\n-[discrete]\n-=== `remove_hash`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/raw_string.rs#L89[raw_string.rs]\n-\n-Removes a hash from a raw string literal.\n-\n-.Before\n-```rust\n-fn main() {\n-    r#\"Hello,\u2503 World!\"#;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    r\"Hello, World!\";\n-}\n-```\n-\n-\n-[discrete]\n-=== `remove_mut`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/remove_mut.rs#L5[remove_mut.rs]\n-\n-Removes the `mut` keyword.\n-\n-.Before\n-```rust\n-impl Walrus {\n-    fn feed(&mut\u2503 self, amount: u32) {}\n-}\n-```\n-\n-.After\n-```rust\n-impl Walrus {\n-    fn feed(&self, amount: u32) {}\n-}\n-```\n-\n-\n-[discrete]\n-=== `reorder_fields`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/reorder_fields.rs#L10[reorder_fields.rs]\n-\n-Reorder the fields of record literals and record patterns in the same order as in\n-the definition.\n-\n-.Before\n-```rust\n-struct Foo {foo: i32, bar: i32};\n-const test: Foo = \u2503Foo {bar: 0, foo: 1}\n-```\n-\n-.After\n-```rust\n-struct Foo {foo: i32, bar: i32};\n-const test: Foo = Foo {foo: 1, bar: 0}\n-```\n-\n-\n-[discrete]\n-=== `replace_if_let_with_match`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/replace_if_let_with_match.rs#L13[replace_if_let_with_match.rs]\n-\n-Replaces `if let` with an else branch with a `match` expression.\n-\n-.Before\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    \u2503if let Action::Move { distance } = action {\n-        foo(distance)\n-    } else {\n-        bar()\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } => foo(distance),\n-        _ => bar(),\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `replace_let_with_if_let`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/replace_let_with_if_let.rs#L14[replace_let_with_if_let.rs]\n-\n-Replaces `let` with an `if-let`.\n-\n-.Before\n-```rust\n-\n-fn main(action: Action) {\n-    \u2503let x = compute();\n-}\n-\n-fn compute() -> Option<i32> { None }\n-```\n-\n-.After\n-```rust\n-\n-fn main(action: Action) {\n-    if let Some(x) = compute() {\n-    }\n-}\n-\n-fn compute() -> Option<i32> { None }\n-```\n-\n-\n-[discrete]\n-=== `replace_qualified_name_with_use`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/replace_qualified_name_with_use.rs#L6[replace_qualified_name_with_use.rs]\n-\n-Adds a use statement for a given fully-qualified name.\n-\n-.Before\n-```rust\n-fn process(map: std::collections::\u2503HashMap<String, String>) {}\n-```\n-\n-.After\n-```rust\n-use std::collections::HashMap;\n-\n-fn process(map: HashMap<String, String>) {}\n-```\n-\n-\n-[discrete]\n-=== `replace_unwrap_with_match`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/replace_unwrap_with_match.rs#L17[replace_unwrap_with_match.rs]\n-\n-Replaces `unwrap` a `match` expression. Works for Result and Option.\n-\n-.Before\n-```rust\n-enum Result<T, E> { Ok(T), Err(E) }\n-fn main() {\n-    let x: Result<i32, i32> = Result::Ok(92);\n-    let y = x.\u2503unwrap();\n-}\n-```\n-\n-.After\n-```rust\n-enum Result<T, E> { Ok(T), Err(E) }\n-fn main() {\n-    let x: Result<i32, i32> = Result::Ok(92);\n-    let y = match x {\n-        Ok(a) => a,\n-        $0_ => unreachable!(),\n-    };\n-}\n-```\n-\n-\n-[discrete]\n-=== `split_import`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/split_import.rs#L7[split_import.rs]\n-\n-Wraps the tail of import into braces.\n-\n-.Before\n-```rust\n-use std::\u2503collections::HashMap;\n-```\n-\n-.After\n-```rust\n-use std::{collections::HashMap};\n-```\n-\n-\n-[discrete]\n-=== `unwrap_block`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/unwrap_block.rs#L9[unwrap_block.rs]\n-\n-This assist removes if...else, for, while and loop control statements to just keep the body.\n-\n-.Before\n-```rust\n-fn foo() {\n-    if true {\u2503\n-        println!(\"foo\");\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-fn foo() {\n-    println!(\"foo\");\n-}\n-```"}, {"sha": "23a071cf1b423c39310a5fd0a5add77ac81b05f4", "filename": "docs/user/generated_features.adoc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/docs%2Fuser%2Fgenerated_features.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/docs%2Fuser%2Fgenerated_features.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_features.adoc?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -76,7 +76,7 @@ Navigates to the type of an identifier.\n \n \n === Hover\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/hover.rs#L63[hover.rs]\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/hover.rs#L106[hover.rs]\n \n Shows additional information, like type of an expression or documentation for definition when \"focusing\" code.\n Focusing is usually hovering with a mouse, but can also be triggered with a shortcut.\n@@ -177,7 +177,7 @@ braces, so it won't confuse generics with comparisons.\n \n \n === On Typing Assists\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/typing.rs#L35[typing.rs]\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/typing.rs#L37[typing.rs]\n \n Some features trigger on typing certain characters:\n \n@@ -199,7 +199,7 @@ Navigates to the parent module of the current module.\n \n \n === Run\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/runnables.rs#L45[runnables.rs]\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/runnables.rs#L81[runnables.rs]\n \n Shows a popup suggesting to run a test/benchmark/binary **at the current cursor\n location**. Super useful for repeatedly running just a single test. Do bind this\n@@ -213,7 +213,7 @@ to a shortcut!\n \n \n === Semantic Syntax Highlighting\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/syntax_highlighting.rs#L33[syntax_highlighting.rs]\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/syntax_highlighting.rs#L34[syntax_highlighting.rs]\n \n rust-analyzer highlights the code semantically.\n For example, `bar` in `foo::Bar` might be colored differently depending on whether `Bar` is an enum or a trait.\n@@ -275,7 +275,7 @@ String::from((y + 5).foo(z))\n \n \n === Workspace Symbol\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide_db/src/symbol_index.rs#L113[symbol_index.rs]\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide_db/src/symbol_index.rs#L122[symbol_index.rs]\n \n Uses fuzzy-search to find types, modules and functions by name across your\n project and dependencies. This is **the** most useful feature, which improves code"}, {"sha": "ea714f49addf05145defc3a20bfe303c66f1fd5c", "filename": "docs/user/manual.adoc", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/docs%2Fuser%2Fmanual.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/docs%2Fuser%2Fmanual.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fmanual.adoc?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -269,6 +269,57 @@ Gnome Builder currently has support for RLS, and there's no way to configure the\n 1. Rename, symlink or copy the `rust-analyzer` binary to `rls` and place it somewhere Builder can find (in `PATH`, or under `~/.cargo/bin`).\n 2. Enable the Rust Builder plugin.\n \n+== Non-Cargo Based Projects\n+\n+rust-analyzer does not require Cargo.\n+However, if you use some other build system, you'll have to describe the structure of your project for rust-analyzer in the `rust-project.json` format:\n+\n+[source,TypeScript]\n+----\n+interface JsonProject {\n+   /// The set of paths containing the crates for this project.\n+   /// Any `Crate` must be nested inside some `root`.\n+   roots: string[];\n+   /// The set of crates comprising the current project.\n+   /// Must include all transitive dependencies as well as sysroot crate (libstd, libcore and such).\n+   crates: Crate[];\n+}\n+\n+interface Crate {\n+    /// Path to the root module of the crate.\n+    root_module: string;\n+    /// Edition of the crate.\n+    edition: \"2015\" | \"2018\";\n+    /// Dependencies\n+    deps: Dep[];\n+    /// The set of cfgs activated for a given crate, like `[\"unix\", \"feature=foo\", \"feature=bar\"]`.\n+    cfg: string[];\n+\n+    /// value of the OUT_DIR env variable.\n+    out_dir?: string;\n+    /// For proc-macro crates, path to compiles proc-macro (.so file).\n+    proc_macro_dylib_path?: string;\n+}\n+\n+interface Dep {\n+    /// Index of a crate in the `crates` array.\n+    crate: number,\n+    /// Name as should appear in the (implicit) `extern crate name` declaration.\n+    name: string,\n+}\n+----\n+\n+This format is provisional and subject to change.\n+Specifically, the `roots` setup will be different eventually.\n+\n+There are tree ways to feed `rust-project.json` to rust-analyzer:\n+\n+* Place `rust-project.json` file at the root of the project, and rust-anlayzer will discover it.\n+* Specify `\"rust-analyzer.linkedProjects\": [ \"path/to/rust-project.json\" ]` in the settings (and make sure that your LSP client sends settings as a part of initialize request).\n+* Specify `\"rust-analyzer.linkedProjects\": [ { \"roots\": [...], \"crates\": [...] }]` inline.\n+\n+See https://github.com/rust-analyzer/rust-project.json-example for a small example.\n+\n == Features\n \n include::./generated_features.adoc[]"}, {"sha": "e2027970db86b7d7635f0c73b371d0fb6b174d19", "filename": "editors/code/package.json", "status": "modified", "additions": 57, "deletions": 7, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -238,7 +238,7 @@\n                 },\n                 \"rust-analyzer.cargo.allFeatures\": {\n                     \"type\": \"boolean\",\n-                    \"default\": true,\n+                    \"default\": false,\n                     \"description\": \"Activate all available features\"\n                 },\n                 \"rust-analyzer.cargo.features\": {\n@@ -318,9 +318,23 @@\n                     \"markdownDescription\": \"Check all targets and tests (will be passed as `--all-targets`)\"\n                 },\n                 \"rust-analyzer.checkOnSave.allFeatures\": {\n-                    \"type\": \"boolean\",\n-                    \"default\": true,\n-                    \"markdownDescription\": \"Check with all features (will be passed as `--all-features`)\"\n+                    \"type\": [\n+                        \"null\",\n+                        \"boolean\"\n+                    ],\n+                    \"default\": null,\n+                    \"markdownDescription\": \"Check with all features (will be passed as `--all-features`). Defaults to `rust-analyzer.cargo.allFeatures`.\"\n+                },\n+                \"rust-analyzer.checkOnSave.features\": {\n+                    \"type\": [\n+                        \"null\",\n+                        \"array\"\n+                    ],\n+                    \"items\": {\n+                        \"type\": \"string\"\n+                    },\n+                    \"default\": null,\n+                    \"description\": \"List of features to activate. Defaults to `rust-analyzer.cargo.features`.\"\n                 },\n                 \"rust-analyzer.inlayHints.enable\": {\n                     \"type\": \"boolean\",\n@@ -462,17 +476,53 @@\n                     \"default\": true\n                 },\n                 \"rust-analyzer.lens.run\": {\n-                    \"markdownDescription\": \"Whether to show Run lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n+                    \"markdownDescription\": \"Whether to show `Run` lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n                     \"type\": \"boolean\",\n                     \"default\": true\n                 },\n                 \"rust-analyzer.lens.debug\": {\n-                    \"markdownDescription\": \"Whether to show Debug lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n+                    \"markdownDescription\": \"Whether to show `Debug` lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n                     \"type\": \"boolean\",\n                     \"default\": true\n                 },\n                 \"rust-analyzer.lens.implementations\": {\n-                    \"markdownDescription\": \"Whether to show Implementations lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n+                    \"markdownDescription\": \"Whether to show `Implementations` lens. Only applies when `#rust-analyzer.lens.enable#` is set.\",\n+                    \"type\": \"boolean\",\n+                    \"default\": true\n+                },\n+                \"rust-analyzer.hoverActions.enable\": {\n+                    \"description\": \"Whether to show HoverActions in Rust files.\",\n+                    \"type\": \"boolean\",\n+                    \"default\": true\n+                },\n+                \"rust-analyzer.hoverActions.implementations\": {\n+                    \"markdownDescription\": \"Whether to show `Implementations` action. Only applies when `#rust-analyzer.hoverActions.enable#` is set.\",\n+                    \"type\": \"boolean\",\n+                    \"default\": true\n+                },\n+                \"rust-analyzer.hoverActions.run\": {\n+                    \"markdownDescription\": \"Whether to show `Run` action. Only applies when `#rust-analyzer.hoverActions.enable#` is set.\",\n+                    \"type\": \"boolean\",\n+                    \"default\": true\n+                },\n+                \"rust-analyzer.hoverActions.debug\": {\n+                    \"markdownDescription\": \"Whether to show `Debug` action. Only applies when `#rust-analyzer.hoverActions.enable#` is set.\",\n+                    \"type\": \"boolean\",\n+                    \"default\": true\n+                },\n+                \"rust-analyzer.linkedProjects\": {\n+                    \"markdownDescription\": \"Disable project auto-discovery in favor of explicitly specified set of projects.  \\nElements must be paths pointing to Cargo.toml, rust-project.json, or JSON objects in rust-project.json format\",\n+                    \"type\": \"array\",\n+                    \"items\": {\n+                        \"type\": [\n+                            \"string\",\n+                            \"object\"\n+                        ]\n+                    },\n+                    \"default\": null\n+                },\n+                \"rust-analyzer.withSysroot\": {\n+                    \"markdownDescription\": \"Internal config for debugging, disables loading of sysroot crates\",\n                     \"type\": \"boolean\",\n                     \"default\": true\n                 }"}, {"sha": "65ad573d8c919ec4e1577a72d60e2150cca94524", "filename": "editors/code/src/client.ts", "status": "modified", "additions": 70, "deletions": 36, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fclient.ts?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,8 +1,25 @@\n import * as lc from 'vscode-languageclient';\n import * as vscode from 'vscode';\n+import * as ra from '../src/lsp_ext';\n+import * as Is from 'vscode-languageclient/lib/utils/is';\n \n import { CallHierarchyFeature } from 'vscode-languageclient/lib/callHierarchy.proposed';\n import { SemanticTokensFeature, DocumentSemanticsTokensSignature } from 'vscode-languageclient/lib/semanticTokens.proposed';\n+import { assert } from './util';\n+\n+function renderCommand(cmd: ra.CommandLink) {\n+    return `[${cmd.title}](command:${cmd.command}?${encodeURIComponent(JSON.stringify(cmd.arguments))} '${cmd.tooltip!}')`;\n+}\n+\n+function renderHoverActions(actions: ra.CommandLinkGroup[]): vscode.MarkdownString {\n+    const text = actions.map(group =>\n+        (group.title ? (group.title + \" \") : \"\") + group.commands.map(renderCommand).join(' | ')\n+    ).join('___');\n+\n+    const result = new vscode.MarkdownString(text);\n+    result.isTrusted = true;\n+    return result;\n+}\n \n export function createClient(serverPath: string, cwd: string): lc.LanguageClient {\n     // '.' Is the fallback if no folder is open\n@@ -32,6 +49,25 @@ export function createClient(serverPath: string, cwd: string): lc.LanguageClient\n                 if (res === undefined) throw new Error('busy');\n                 return res;\n             },\n+            async provideHover(document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken, _next: lc.ProvideHoverSignature) {\n+                return client.sendRequest(lc.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(\n+                    (result) => {\n+                        const hover = client.protocol2CodeConverter.asHover(result);\n+                        if (hover) {\n+                            const actions = (<any>result).actions;\n+                            if (actions) {\n+                                hover.contents.push(renderHoverActions(actions));\n+                            }\n+                        }\n+                        return hover;\n+                    },\n+                    (error) => {\n+                        client.logFailedRequest(lc.HoverRequest.type, error);\n+                        return Promise.resolve(null);\n+                    });\n+            },\n+            // Using custom handling of CodeActions where each code action is resloved lazily\n+            // That's why we are not waiting for any command or edits\n             async provideCodeActions(document: vscode.TextDocument, range: vscode.Range, context: vscode.CodeActionContext, token: vscode.CancellationToken, _next: lc.ProvideCodeActionsSignature) {\n                 const params: lc.CodeActionParams = {\n                     textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),\n@@ -43,32 +79,36 @@ export function createClient(serverPath: string, cwd: string): lc.LanguageClient\n                     const result: (vscode.CodeAction | vscode.Command)[] = [];\n                     const groups = new Map<string, { index: number; items: vscode.CodeAction[] }>();\n                     for (const item of values) {\n+                        // In our case we expect to get code edits only from diagnostics\n                         if (lc.CodeAction.is(item)) {\n+                            assert(!item.command, \"We don't expect to receive commands in CodeActions\");\n                             const action = client.protocol2CodeConverter.asCodeAction(item);\n-                            const group = actionGroup(item);\n-                            if (isSnippetEdit(item) || group) {\n-                                action.command = {\n-                                    command: \"rust-analyzer.applySnippetWorkspaceEdit\",\n-                                    title: \"\",\n-                                    arguments: [action.edit],\n-                                };\n-                                action.edit = undefined;\n-                            }\n-\n-                            if (group) {\n-                                let entry = groups.get(group);\n-                                if (!entry) {\n-                                    entry = { index: result.length, items: [] };\n-                                    groups.set(group, entry);\n-                                    result.push(action);\n-                                }\n-                                entry.items.push(action);\n-                            } else {\n+                            result.push(action);\n+                            continue;\n+                        }\n+                        assert(isCodeActionWithoutEditsAndCommands(item), \"We don't expect edits or commands here\");\n+                        const action = new vscode.CodeAction(item.title);\n+                        const group = (item as any).group;\n+                        const id = (item as any).id;\n+                        const resolveParams: ra.ResolveCodeActionParams = {\n+                            id: id,\n+                            codeActionParams: params\n+                        };\n+                        action.command = {\n+                            command: \"rust-analyzer.resolveCodeAction\",\n+                            title: item.title,\n+                            arguments: [resolveParams],\n+                        };\n+                        if (group) {\n+                            let entry = groups.get(group);\n+                            if (!entry) {\n+                                entry = { index: result.length, items: [] };\n+                                groups.set(group, entry);\n                                 result.push(action);\n                             }\n+                            entry.items.push(action);\n                         } else {\n-                            const command = client.protocol2CodeConverter.asCommand(item);\n-                            result.push(command);\n+                            result.push(action);\n                         }\n                     }\n                     for (const [group, { index, items }] of groups) {\n@@ -80,7 +120,7 @@ export function createClient(serverPath: string, cwd: string): lc.LanguageClient\n                                 command: \"rust-analyzer.applyActionGroup\",\n                                 title: \"\",\n                                 arguments: [items.map((item) => {\n-                                    return { label: item.title, edit: item.command!!.arguments!![0] };\n+                                    return { label: item.title, arguments: item.command!!.arguments!![0] };\n                                 })],\n                             };\n                             result[index] = action;\n@@ -119,24 +159,18 @@ class ExperimentalFeatures implements lc.StaticFeature {\n         const caps: any = capabilities.experimental ?? {};\n         caps.snippetTextEdit = true;\n         caps.codeActionGroup = true;\n+        caps.resolveCodeAction = true;\n+        caps.hoverActions = true;\n         capabilities.experimental = caps;\n     }\n     initialize(_capabilities: lc.ServerCapabilities<any>, _documentSelector: lc.DocumentSelector | undefined): void {\n     }\n }\n \n-function isSnippetEdit(action: lc.CodeAction): boolean {\n-    const documentChanges = action.edit?.documentChanges ?? [];\n-    for (const edit of documentChanges) {\n-        if (lc.TextDocumentEdit.is(edit)) {\n-            if (edit.edits.some((indel) => (indel as any).insertTextFormat === lc.InsertTextFormat.Snippet)) {\n-                return true;\n-            }\n-        }\n-    }\n-    return false;\n-}\n-\n-function actionGroup(action: lc.CodeAction): string | undefined {\n-    return (action as any).group;\n+function isCodeActionWithoutEditsAndCommands(value: any): boolean {\n+    const candidate: lc.CodeAction = value;\n+    return candidate && Is.string(candidate.title) &&\n+        (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, lc.Diagnostic.is)) &&\n+        (candidate.kind === void 0 || Is.string(candidate.kind)) &&\n+        (candidate.edit === void 0 && candidate.command === void 0);\n }"}, {"sha": "3e9c3aa0e59be26f82658bd984c7f54d2f6be1a6", "filename": "editors/code/src/commands.ts", "status": "modified", "additions": 77, "deletions": 16, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands.ts?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -8,6 +8,7 @@ import { spawnSync } from 'child_process';\n import { RunnableQuickPick, selectRunnable, createTask } from './run';\n import { AstInspector } from './ast_inspector';\n import { isRustDocument, sleep, isRustEditor } from './util';\n+import { startDebugSession, makeDebugConfig } from './debug';\n \n export * from './ast_inspector';\n export * from './run';\n@@ -197,20 +198,6 @@ export function toggleInlayHints(ctx: Ctx): Cmd {\n     };\n }\n \n-export function run(ctx: Ctx): Cmd {\n-    let prevRunnable: RunnableQuickPick | undefined;\n-\n-    return async () => {\n-        const item = await selectRunnable(ctx, prevRunnable);\n-        if (!item) return;\n-\n-        item.detail = 'rerun';\n-        prevRunnable = item;\n-        const task = createTask(item.runnable);\n-        return await vscode.tasks.executeTask(task);\n-    };\n-}\n-\n // Opens the virtual file that will show the syntax tree\n //\n // The contents of the file come from the `TextDocumentContentProvider`\n@@ -356,10 +343,25 @@ export function showReferences(ctx: Ctx): Cmd {\n }\n \n export function applyActionGroup(_ctx: Ctx): Cmd {\n-    return async (actions: { label: string; edit: vscode.WorkspaceEdit }[]) => {\n+    return async (actions: { label: string; arguments: ra.ResolveCodeActionParams }[]) => {\n         const selectedAction = await vscode.window.showQuickPick(actions);\n         if (!selectedAction) return;\n-        await applySnippetWorkspaceEdit(selectedAction.edit);\n+        vscode.commands.executeCommand(\n+            'rust-analyzer.resolveCodeAction',\n+            selectedAction.arguments,\n+        );\n+    };\n+}\n+\n+export function resolveCodeAction(ctx: Ctx): Cmd {\n+    const client = ctx.client;\n+    return async (params: ra.ResolveCodeActionParams) => {\n+        const item: lc.WorkspaceEdit = await client.sendRequest(ra.resolveCodeAction, params);\n+        if (!item) {\n+            return;\n+        }\n+        const edit = client.protocol2CodeConverter.asWorkspaceEdit(item);\n+        await applySnippetWorkspaceEdit(edit);\n     };\n }\n \n@@ -368,3 +370,62 @@ export function applySnippetWorkspaceEditCommand(_ctx: Ctx): Cmd {\n         await applySnippetWorkspaceEdit(edit);\n     };\n }\n+\n+export function run(ctx: Ctx): Cmd {\n+    let prevRunnable: RunnableQuickPick | undefined;\n+\n+    return async () => {\n+        const item = await selectRunnable(ctx, prevRunnable);\n+        if (!item) return;\n+\n+        item.detail = 'rerun';\n+        prevRunnable = item;\n+        const task = createTask(item.runnable);\n+        return await vscode.tasks.executeTask(task);\n+    };\n+}\n+\n+export function runSingle(ctx: Ctx): Cmd {\n+    return async (runnable: ra.Runnable) => {\n+        const editor = ctx.activeRustEditor;\n+        if (!editor) return;\n+\n+        const task = createTask(runnable);\n+        task.group = vscode.TaskGroup.Build;\n+        task.presentationOptions = {\n+            reveal: vscode.TaskRevealKind.Always,\n+            panel: vscode.TaskPanelKind.Dedicated,\n+            clear: true,\n+        };\n+\n+        return vscode.tasks.executeTask(task);\n+    };\n+}\n+\n+export function debug(ctx: Ctx): Cmd {\n+    let prevDebuggee: RunnableQuickPick | undefined;\n+\n+    return async () => {\n+        const item = await selectRunnable(ctx, prevDebuggee, true);\n+        if (!item) return;\n+\n+        item.detail = 'restart';\n+        prevDebuggee = item;\n+        return await startDebugSession(ctx, item.runnable);\n+    };\n+}\n+\n+export function debugSingle(ctx: Ctx): Cmd {\n+    return async (config: ra.Runnable) => {\n+        await startDebugSession(ctx, config);\n+    };\n+}\n+\n+export function newDebugConfig(ctx: Ctx): Cmd {\n+    return async () => {\n+        const item = await selectRunnable(ctx, undefined, true, false);\n+        if (!item) return;\n+\n+        await makeDebugConfig(ctx, item.runnable);\n+    };\n+}"}, {"sha": "d8f0037d4c9516b27b71eb1a86443a7093ad6600", "filename": "editors/code/src/config.ts", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fconfig.ts?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -16,10 +16,8 @@ export class Config {\n         \"files\",\n         \"highlighting\",\n         \"updates.channel\",\n-        \"lens.enable\",\n-        \"lens.run\",\n-        \"lens.debug\",\n-        \"lens.implementations\",\n+        \"lens\", // works as lens.*\n+        \"hoverActions\", // works as hoverActions.*\n     ]\n         .map(opt => `${this.rootSection}.${opt}`);\n \n@@ -132,4 +130,11 @@ export class Config {\n             implementations: this.get<boolean>(\"lens.implementations\"),\n         };\n     }\n+\n+    get hoverActions() {\n+        return {\n+            enable: this.get<boolean>(\"hoverActions.enable\"),\n+            implementations: this.get<boolean>(\"hoverActions.implementations\"),\n+        };\n+    }\n }"}, {"sha": "a0c9b3ab2e64a04414e6641b14e7fc74bbae44c5", "filename": "editors/code/src/debug.ts", "status": "modified", "additions": 72, "deletions": 49, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Fdebug.ts", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Fdebug.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fdebug.ts?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -3,46 +3,59 @@ import * as vscode from 'vscode';\n import * as path from 'path';\n import * as ra from './lsp_ext';\n \n-import { Cargo } from './cargo';\n+import { Cargo } from './toolchain';\n import { Ctx } from \"./ctx\";\n \n const debugOutput = vscode.window.createOutputChannel(\"Debug\");\n type DebugConfigProvider = (config: ra.Runnable, executable: string, sourceFileMap?: Record<string, string>) => vscode.DebugConfiguration;\n \n-function getLldbDebugConfig(config: ra.Runnable, executable: string, sourceFileMap?: Record<string, string>): vscode.DebugConfiguration {\n-    return {\n-        type: \"lldb\",\n-        request: \"launch\",\n-        name: config.label,\n-        program: executable,\n-        args: config.extraArgs,\n-        cwd: config.cwd,\n-        sourceMap: sourceFileMap,\n-        sourceLanguages: [\"rust\"]\n-    };\n-}\n+export async function makeDebugConfig(ctx: Ctx, runnable: ra.Runnable): Promise<void> {\n+    const scope = ctx.activeRustEditor?.document.uri;\n+    if (!scope) return;\n \n-function getCppvsDebugConfig(config: ra.Runnable, executable: string, sourceFileMap?: Record<string, string>): vscode.DebugConfiguration {\n-    return {\n-        type: (os.platform() === \"win32\") ? \"cppvsdbg\" : \"cppdbg\",\n-        request: \"launch\",\n-        name: config.label,\n-        program: executable,\n-        args: config.extraArgs,\n-        cwd: config.cwd,\n-        sourceFileMap: sourceFileMap,\n-    };\n+    const debugConfig = await getDebugConfiguration(ctx, runnable);\n+    if (!debugConfig) return;\n+\n+    const wsLaunchSection = vscode.workspace.getConfiguration(\"launch\", scope);\n+    const configurations = wsLaunchSection.get<any[]>(\"configurations\") || [];\n+\n+    const index = configurations.findIndex(c => c.name === debugConfig.name);\n+    if (index !== -1) {\n+        const answer = await vscode.window.showErrorMessage(`Launch configuration '${debugConfig.name}' already exists!`, 'Cancel', 'Update');\n+        if (answer === \"Cancel\") return;\n+\n+        configurations[index] = debugConfig;\n+    } else {\n+        configurations.push(debugConfig);\n+    }\n+\n+    await wsLaunchSection.update(\"configurations\", configurations);\n }\n \n-async function getDebugExecutable(config: ra.Runnable): Promise<string> {\n-    const cargo = new Cargo(config.cwd || '.', debugOutput);\n-    const executable = await cargo.executableFromArgs(config.args);\n+export async function startDebugSession(ctx: Ctx, runnable: ra.Runnable): Promise<boolean> {\n+    let debugConfig: vscode.DebugConfiguration | undefined = undefined;\n+    let message = \"\";\n \n-    // if we are here, there were no compilation errors.\n-    return executable;\n+    const wsLaunchSection = vscode.workspace.getConfiguration(\"launch\");\n+    const configurations = wsLaunchSection.get<any[]>(\"configurations\") || [];\n+\n+    const index = configurations.findIndex(c => c.name === runnable.label);\n+    if (-1 !== index) {\n+        debugConfig = configurations[index];\n+        message = \" (from launch.json)\";\n+        debugOutput.clear();\n+    } else {\n+        debugConfig = await getDebugConfiguration(ctx, runnable);\n+    }\n+\n+    if (!debugConfig) return false;\n+\n+    debugOutput.appendLine(`Launching debug configuration${message}:`);\n+    debugOutput.appendLine(JSON.stringify(debugConfig, null, 2));\n+    return vscode.debug.startDebugging(undefined, debugConfig);\n }\n \n-export async function getDebugConfiguration(ctx: Ctx, config: ra.Runnable): Promise<vscode.DebugConfiguration | undefined> {\n+async function getDebugConfiguration(ctx: Ctx, runnable: ra.Runnable): Promise<vscode.DebugConfiguration | undefined> {\n     const editor = ctx.activeRustEditor;\n     if (!editor) return;\n \n@@ -78,8 +91,8 @@ export async function getDebugConfiguration(ctx: Ctx, config: ra.Runnable): Prom\n         return path.normalize(p).replace(wsFolder, '${workspaceRoot}');\n     }\n \n-    const executable = await getDebugExecutable(config);\n-    const debugConfig = knownEngines[debugEngine.id](config, simplifyPath(executable), debugOptions.sourceFileMap);\n+    const executable = await getDebugExecutable(runnable);\n+    const debugConfig = knownEngines[debugEngine.id](runnable, simplifyPath(executable), debugOptions.sourceFileMap);\n     if (debugConfig.type in debugOptions.engineSettings) {\n         const settingsMap = (debugOptions.engineSettings as any)[debugConfig.type];\n         for (var key in settingsMap) {\n@@ -100,25 +113,35 @@ export async function getDebugConfiguration(ctx: Ctx, config: ra.Runnable): Prom\n     return debugConfig;\n }\n \n-export async function startDebugSession(ctx: Ctx, config: ra.Runnable): Promise<boolean> {\n-    let debugConfig: vscode.DebugConfiguration | undefined = undefined;\n-    let message = \"\";\n-\n-    const wsLaunchSection = vscode.workspace.getConfiguration(\"launch\");\n-    const configurations = wsLaunchSection.get<any[]>(\"configurations\") || [];\n+async function getDebugExecutable(runnable: ra.Runnable): Promise<string> {\n+    const cargo = new Cargo(runnable.args.workspaceRoot || '.', debugOutput);\n+    const executable = await cargo.executableFromArgs(runnable.args.cargoArgs);\n \n-    const index = configurations.findIndex(c => c.name === config.label);\n-    if (-1 !== index) {\n-        debugConfig = configurations[index];\n-        message = \" (from launch.json)\";\n-        debugOutput.clear();\n-    } else {\n-        debugConfig = await getDebugConfiguration(ctx, config);\n-    }\n+    // if we are here, there were no compilation errors.\n+    return executable;\n+}\n \n-    if (!debugConfig) return false;\n+function getLldbDebugConfig(runnable: ra.Runnable, executable: string, sourceFileMap?: Record<string, string>): vscode.DebugConfiguration {\n+    return {\n+        type: \"lldb\",\n+        request: \"launch\",\n+        name: runnable.label,\n+        program: executable,\n+        args: runnable.args.executableArgs,\n+        cwd: runnable.args.workspaceRoot,\n+        sourceMap: sourceFileMap,\n+        sourceLanguages: [\"rust\"]\n+    };\n+}\n \n-    debugOutput.appendLine(`Launching debug configuration${message}:`);\n-    debugOutput.appendLine(JSON.stringify(debugConfig, null, 2));\n-    return vscode.debug.startDebugging(undefined, debugConfig);\n+function getCppvsDebugConfig(runnable: ra.Runnable, executable: string, sourceFileMap?: Record<string, string>): vscode.DebugConfiguration {\n+    return {\n+        type: (os.platform() === \"win32\") ? \"cppvsdbg\" : \"cppdbg\",\n+        request: \"launch\",\n+        name: runnable.label,\n+        program: executable,\n+        args: runnable.args.executableArgs,\n+        cwd: runnable.args.workspaceRoot,\n+        sourceFileMap: sourceFileMap,\n+    };\n }"}, {"sha": "e16ea799ce015bef81a14cb22785e24cd2eee351", "filename": "editors/code/src/lsp_ext.ts", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -33,6 +33,12 @@ export const matchingBrace = new lc.RequestType<MatchingBraceParams, lc.Position\n \n export const parentModule = new lc.RequestType<lc.TextDocumentPositionParams, lc.LocationLink[], void>(\"experimental/parentModule\");\n \n+export interface ResolveCodeActionParams {\n+    id: string;\n+    codeActionParams: lc.CodeActionParams;\n+}\n+export const resolveCodeAction = new lc.RequestType<ResolveCodeActionParams, lc.WorkspaceEdit, unknown>('experimental/resolveCodeAction');\n+\n export interface JoinLinesParams {\n     textDocument: lc.TextDocumentIdentifier;\n     ranges: lc.Range[];\n@@ -45,16 +51,18 @@ export interface RunnablesParams {\n     textDocument: lc.TextDocumentIdentifier;\n     position: lc.Position | null;\n }\n+\n export interface Runnable {\n-    range: lc.Range;\n     label: string;\n-    bin: string;\n-    args: string[];\n-    extraArgs: string[];\n-    env: { [key: string]: string };\n-    cwd: string | null;\n+    location?: lc.LocationLink;\n+    kind: \"cargo\";\n+    args: {\n+        workspaceRoot?: string;\n+        cargoArgs: string[];\n+        executableArgs: string[];\n+    };\n }\n-export const runnables = new lc.RequestType<RunnablesParams, Runnable[], void>(\"rust-analyzer/runnables\");\n+export const runnables = new lc.RequestType<RunnablesParams, Runnable[], void>(\"experimental/runnables\");\n \n export type InlayHint = InlayHint.TypeHint | InlayHint.ParamHint | InlayHint.ChainingHint;\n \n@@ -82,3 +90,15 @@ export interface SsrParams {\n     parseOnly: boolean;\n }\n export const ssr = new lc.RequestType<SsrParams, lc.WorkspaceEdit, void>('experimental/ssr');\n+\n+export interface CommandLink extends lc.Command {\n+    /**\n+     * A tooltip for the command, when represented in the UI.\n+     */\n+    tooltip?: string;\n+}\n+\n+export interface CommandLinkGroup {\n+    title?: string;\n+    commands: CommandLink[];\n+}"}, {"sha": "a92c676fa2dd7ddda1b9f5047c9ad9e58707349b", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -98,6 +98,7 @@ export async function activate(context: vscode.ExtensionContext) {\n     ctx.registerCommand('debugSingle', commands.debugSingle);\n     ctx.registerCommand('showReferences', commands.showReferences);\n     ctx.registerCommand('applySnippetWorkspaceEdit', commands.applySnippetWorkspaceEditCommand);\n+    ctx.registerCommand('resolveCodeAction', commands.resolveCodeAction);\n     ctx.registerCommand('applyActionGroup', commands.applyActionGroup);\n \n     ctx.pushCleanup(activateTaskProvider(workspaceFolder));"}, {"sha": "bb060cfe155419802c218a49aa9990b880fe2248", "filename": "editors/code/src/run.ts", "status": "modified", "additions": 19, "deletions": 77, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Frun.ts", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Frun.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Frun.ts?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,9 +1,10 @@\n import * as vscode from 'vscode';\n import * as lc from 'vscode-languageclient';\n import * as ra from './lsp_ext';\n+import * as toolchain from \"./toolchain\";\n \n-import { Ctx, Cmd } from './ctx';\n-import { startDebugSession, getDebugConfiguration } from './debug';\n+import { Ctx } from './ctx';\n+import { makeDebugConfig } from './debug';\n \n const quickPickButtons = [{ iconPath: new vscode.ThemeIcon(\"save\"), tooltip: \"Save as a launch.json configurtation.\" }];\n \n@@ -64,7 +65,7 @@ export async function selectRunnable(ctx: Ctx, prevRunnable?: RunnableQuickPick,\n             quickPick.onDidHide(() => close()),\n             quickPick.onDidAccept(() => close(quickPick.selectedItems[0])),\n             quickPick.onDidTriggerButton((_button) => {\n-                (async () => await makeDebugConfig(ctx, quickPick.activeItems[0]))();\n+                (async () => await makeDebugConfig(ctx, quickPick.activeItems[0].runnable))();\n                 close();\n             }),\n             quickPick.onDidChangeActive((active) => {\n@@ -83,74 +84,6 @@ export async function selectRunnable(ctx: Ctx, prevRunnable?: RunnableQuickPick,\n     });\n }\n \n-export function runSingle(ctx: Ctx): Cmd {\n-    return async (runnable: ra.Runnable) => {\n-        const editor = ctx.activeRustEditor;\n-        if (!editor) return;\n-\n-        const task = createTask(runnable);\n-        task.group = vscode.TaskGroup.Build;\n-        task.presentationOptions = {\n-            reveal: vscode.TaskRevealKind.Always,\n-            panel: vscode.TaskPanelKind.Dedicated,\n-            clear: true,\n-        };\n-\n-        return vscode.tasks.executeTask(task);\n-    };\n-}\n-\n-export function debug(ctx: Ctx): Cmd {\n-    let prevDebuggee: RunnableQuickPick | undefined;\n-\n-    return async () => {\n-        const item = await selectRunnable(ctx, prevDebuggee, true);\n-        if (!item) return;\n-\n-        item.detail = 'restart';\n-        prevDebuggee = item;\n-        return await startDebugSession(ctx, item.runnable);\n-    };\n-}\n-\n-export function debugSingle(ctx: Ctx): Cmd {\n-    return async (config: ra.Runnable) => {\n-        await startDebugSession(ctx, config);\n-    };\n-}\n-\n-async function makeDebugConfig(ctx: Ctx, item: RunnableQuickPick): Promise<void> {\n-    const scope = ctx.activeRustEditor?.document.uri;\n-    if (!scope) return;\n-\n-    const debugConfig = await getDebugConfiguration(ctx, item.runnable);\n-    if (!debugConfig) return;\n-\n-    const wsLaunchSection = vscode.workspace.getConfiguration(\"launch\", scope);\n-    const configurations = wsLaunchSection.get<any[]>(\"configurations\") || [];\n-\n-    const index = configurations.findIndex(c => c.name === debugConfig.name);\n-    if (index !== -1) {\n-        const answer = await vscode.window.showErrorMessage(`Launch configuration '${debugConfig.name}' already exists!`, 'Cancel', 'Update');\n-        if (answer === \"Cancel\") return;\n-\n-        configurations[index] = debugConfig;\n-    } else {\n-        configurations.push(debugConfig);\n-    }\n-\n-    await wsLaunchSection.update(\"configurations\", configurations);\n-}\n-\n-export function newDebugConfig(ctx: Ctx): Cmd {\n-    return async () => {\n-        const item = await selectRunnable(ctx, undefined, true, false);\n-        if (!item) return;\n-\n-        await makeDebugConfig(ctx, item);\n-    };\n-}\n-\n export class RunnableQuickPick implements vscode.QuickPickItem {\n     public label: string;\n     public description?: string | undefined;\n@@ -170,18 +103,27 @@ interface CargoTaskDefinition extends vscode.TaskDefinition {\n     env?: { [key: string]: string };\n }\n \n-export function createTask(spec: ra.Runnable): vscode.Task {\n+export function createTask(runnable: ra.Runnable): vscode.Task {\n     const TASK_SOURCE = 'Rust';\n+\n+    let command;\n+    switch (runnable.kind) {\n+        case \"cargo\": command = toolchain.getPathForExecutable(\"cargo\");\n+    }\n+    const args = [...runnable.args.cargoArgs]; // should be a copy!\n+    if (runnable.args.executableArgs.length > 0) {\n+        args.push('--', ...runnable.args.executableArgs);\n+    }\n     const definition: CargoTaskDefinition = {\n         type: 'cargo',\n-        label: spec.label,\n-        command: spec.bin,\n-        args: spec.extraArgs ? [...spec.args, '--', ...spec.extraArgs] : spec.args,\n-        env: Object.assign({}, process.env, spec.env),\n+        label: runnable.label,\n+        command,\n+        args,\n+        env: Object.assign({}, process.env as { [key: string]: string }, { \"RUST_BACKTRACE\": \"short\" }),\n     };\n \n     const execOption: vscode.ShellExecutionOptions = {\n-        cwd: spec.cwd || '.',\n+        cwd: runnable.args.workspaceRoot || '.',\n         env: definition.env,\n     };\n     const exec = new vscode.ShellExecution("}, {"sha": "9748824df38ffb662312d258308122fb40d023cf", "filename": "editors/code/src/tasks.ts", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Ftasks.ts", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Ftasks.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftasks.ts?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,4 +1,5 @@\n import * as vscode from 'vscode';\n+import * as toolchain from \"./toolchain\";\n \n // This ends up as the `type` key in tasks.json. RLS also uses `cargo` and\n // our configuration should be compatible with it so use the same key.\n@@ -24,6 +25,8 @@ class CargoTaskProvider implements vscode.TaskProvider {\n         // set of tasks that always exist. These tasks cannot be removed in\n         // tasks.json - only tweaked.\n \n+        const cargoPath = toolchain.cargoPath();\n+\n         return [\n             { command: 'build', group: vscode.TaskGroup.Build },\n             { command: 'check', group: vscode.TaskGroup.Build },\n@@ -46,7 +49,7 @@ class CargoTaskProvider implements vscode.TaskProvider {\n                     `cargo ${command}`,\n                     'rust',\n                     // What to do when this command is executed.\n-                    new vscode.ShellExecution('cargo', [command]),\n+                    new vscode.ShellExecution(cargoPath, [command]),\n                     // Problem matchers.\n                     ['$rustc'],\n                 );\n@@ -80,4 +83,4 @@ class CargoTaskProvider implements vscode.TaskProvider {\n export function activateTaskProvider(target: vscode.WorkspaceFolder): vscode.Disposable {\n     const provider = new CargoTaskProvider(target);\n     return vscode.tasks.registerTaskProvider(TASK_TYPE, provider);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "80a7915e90e8972d30581ef419fc56ab8ce48526", "filename": "editors/code/src/toolchain.ts", "status": "renamed", "additions": 70, "deletions": 47, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Ftoolchain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Ftoolchain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftoolchain.ts?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,9 +1,10 @@\n import * as cp from 'child_process';\n import * as os from 'os';\n import * as path from 'path';\n+import * as fs from 'fs';\n import * as readline from 'readline';\n import { OutputChannel } from 'vscode';\n-import { isValidExecutable } from './util';\n+import { log, memoize } from './util';\n \n interface CompilationArtifact {\n     fileName: string;\n@@ -17,33 +18,34 @@ export interface ArtifactSpec {\n     filter?: (artifacts: CompilationArtifact[]) => CompilationArtifact[];\n }\n \n-export function artifactSpec(args: readonly string[]): ArtifactSpec {\n-    const cargoArgs = [...args, \"--message-format=json\"];\n+export class Cargo {\n+    constructor(readonly rootFolder: string, readonly output: OutputChannel) { }\n \n-    // arguments for a runnable from the quick pick should be updated.\n-    // see crates\\rust-analyzer\\src\\main_loop\\handlers.rs, handle_code_lens\n-    switch (cargoArgs[0]) {\n-        case \"run\": cargoArgs[0] = \"build\"; break;\n-        case \"test\": {\n-            if (!cargoArgs.includes(\"--no-run\")) {\n-                cargoArgs.push(\"--no-run\");\n+    // Made public for testing purposes\n+    static artifactSpec(args: readonly string[]): ArtifactSpec {\n+        const cargoArgs = [...args, \"--message-format=json\"];\n+\n+        // arguments for a runnable from the quick pick should be updated.\n+        // see crates\\rust-analyzer\\src\\main_loop\\handlers.rs, handle_code_lens\n+        switch (cargoArgs[0]) {\n+            case \"run\": cargoArgs[0] = \"build\"; break;\n+            case \"test\": {\n+                if (!cargoArgs.includes(\"--no-run\")) {\n+                    cargoArgs.push(\"--no-run\");\n+                }\n+                break;\n             }\n-            break;\n         }\n-    }\n \n-    const result: ArtifactSpec = { cargoArgs: cargoArgs };\n-    if (cargoArgs[0] === \"test\") {\n-        // for instance, `crates\\rust-analyzer\\tests\\heavy_tests\\main.rs` tests\n-        // produce 2 artifacts: {\"kind\": \"bin\"} and {\"kind\": \"test\"}\n-        result.filter = (artifacts) => artifacts.filter(it => it.isTest);\n-    }\n-\n-    return result;\n-}\n+        const result: ArtifactSpec = { cargoArgs: cargoArgs };\n+        if (cargoArgs[0] === \"test\") {\n+            // for instance, `crates\\rust-analyzer\\tests\\heavy_tests\\main.rs` tests\n+            // produce 2 artifacts: {\"kind\": \"bin\"} and {\"kind\": \"test\"}\n+            result.filter = (artifacts) => artifacts.filter(it => it.isTest);\n+        }\n \n-export class Cargo {\n-    constructor(readonly rootFolder: string, readonly output: OutputChannel) { }\n+        return result;\n+    }\n \n     private async getArtifacts(spec: ArtifactSpec): Promise<CompilationArtifact[]> {\n         const artifacts: CompilationArtifact[] = [];\n@@ -77,7 +79,7 @@ export class Cargo {\n     }\n \n     async executableFromArgs(args: readonly string[]): Promise<string> {\n-        const artifacts = await this.getArtifacts(artifactSpec(args));\n+        const artifacts = await this.getArtifacts(Cargo.artifactSpec(args));\n \n         if (artifacts.length === 0) {\n             throw new Error('No compilation artifacts');\n@@ -94,14 +96,7 @@ export class Cargo {\n         onStderrString: (data: string) => void\n     ): Promise<number> {\n         return new Promise((resolve, reject) => {\n-            let cargoPath;\n-            try {\n-                cargoPath = getCargoPathOrFail();\n-            } catch (err) {\n-                return reject(err);\n-            }\n-\n-            const cargo = cp.spawn(cargoPath, cargoArgs, {\n+            const cargo = cp.spawn(cargoPath(), cargoArgs, {\n                 stdio: ['ignore', 'pipe', 'pipe'],\n                 cwd: this.rootFolder\n             });\n@@ -126,26 +121,54 @@ export class Cargo {\n     }\n }\n \n-// Mirrors `ra_env::get_path_for_executable` implementation\n-function getCargoPathOrFail(): string {\n-    const envVar = process.env.CARGO;\n-    const executableName = \"cargo\";\n+/** Mirrors `ra_toolchain::cargo()` implementation */\n+export function cargoPath(): string {\n+    return getPathForExecutable(\"cargo\");\n+}\n+\n+/** Mirrors `ra_toolchain::get_path_for_executable()` implementation */\n+export const getPathForExecutable = memoize(\n+    // We apply caching to decrease file-system interactions\n+    (executableName: \"cargo\" | \"rustc\" | \"rustup\"): string => {\n+        {\n+            const envVar = process.env[executableName.toUpperCase()];\n+            if (envVar) return envVar;\n+        }\n+\n+        if (lookupInPath(executableName)) return executableName;\n \n-    if (envVar) {\n-        if (isValidExecutable(envVar)) return envVar;\n+        try {\n+            // hmm, `os.homedir()` seems to be infallible\n+            // it is not mentioned in docs and cannot be infered by the type signature...\n+            const standardPath = path.join(os.homedir(), \".cargo\", \"bin\", executableName);\n \n-        throw new Error(`\\`${envVar}\\` environment variable points to something that's not a valid executable`);\n+            if (isFile(standardPath)) return standardPath;\n+        } catch (err) {\n+            log.error(\"Failed to read the fs info\", err);\n+        }\n+        return executableName;\n     }\n+);\n \n-    if (isValidExecutable(executableName)) return executableName;\n+function lookupInPath(exec: string): boolean {\n+    const paths = process.env.PATH ?? \"\";;\n \n-    const standardLocation = path.join(os.homedir(), '.cargo', 'bin', executableName);\n+    const candidates = paths.split(path.delimiter).flatMap(dirInPath => {\n+        const candidate = path.join(dirInPath, exec);\n+        return os.type() === \"Windows_NT\"\n+            ? [candidate, `${candidate}.exe`]\n+            : [candidate];\n+    });\n \n-    if (isValidExecutable(standardLocation)) return standardLocation;\n+    return candidates.some(isFile);\n+}\n \n-    throw new Error(\n-        `Failed to find \\`${executableName}\\` executable. ` +\n-        `Make sure \\`${executableName}\\` is in \\`$PATH\\`, ` +\n-        `or set \\`${envVar}\\` to point to a valid executable.`\n-    );\n+function isFile(suspectPath: string): boolean {\n+    // It is not mentionned in docs, but `statSync()` throws an error when\n+    // the path doesn't exist\n+    try {\n+        return fs.statSync(suspectPath).isFile();\n+    } catch {\n+        return false;\n+    }\n }", "previous_filename": "editors/code/src/cargo.ts"}, {"sha": "fe3fb71cd7dc28c0b9493e61d81856e174d66ac2", "filename": "editors/code/src/util.ts", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Futil.ts", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Fsrc%2Futil.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futil.ts?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -99,3 +99,21 @@ export function isValidExecutable(path: string): boolean {\n export function setContextValue(key: string, value: any): Thenable<void> {\n     return vscode.commands.executeCommand('setContext', key, value);\n }\n+\n+/**\n+ * Returns a higher-order function that caches the results of invoking the\n+ * underlying function.\n+ */\n+export function memoize<Ret, TThis, Param extends string>(func: (this: TThis, arg: Param) => Ret) {\n+    const cache = new Map<string, Ret>();\n+\n+    return function(this: TThis, arg: Param) {\n+        const cached = cache.get(arg);\n+        if (cached) return cached;\n+\n+        const result = func.call(this, arg);\n+        cache.set(arg, result);\n+\n+        return result;\n+    };\n+}"}, {"sha": "68794d53ede11b9c1f062500460d24f7b2f99470", "filename": "editors/code/tests/unit/launch_config.test.ts", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Ftests%2Funit%2Flaunch_config.test.ts", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/editors%2Fcode%2Ftests%2Funit%2Flaunch_config.test.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Ftests%2Funit%2Flaunch_config.test.ts?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1,25 +1,25 @@\n import * as assert from 'assert';\n-import * as cargo from '../../src/cargo';\n+import { Cargo } from '../../src/toolchain';\n \n suite('Launch configuration', () => {\n \n     suite('Lens', () => {\n         test('A binary', async () => {\n-            const args = cargo.artifactSpec([\"build\", \"--package\", \"pkg_name\", \"--bin\", \"pkg_name\"]);\n+            const args = Cargo.artifactSpec([\"build\", \"--package\", \"pkg_name\", \"--bin\", \"pkg_name\"]);\n \n             assert.deepEqual(args.cargoArgs, [\"build\", \"--package\", \"pkg_name\", \"--bin\", \"pkg_name\", \"--message-format=json\"]);\n             assert.deepEqual(args.filter, undefined);\n         });\n \n         test('One of Multiple Binaries', async () => {\n-            const args = cargo.artifactSpec([\"build\", \"--package\", \"pkg_name\", \"--bin\", \"bin1\"]);\n+            const args = Cargo.artifactSpec([\"build\", \"--package\", \"pkg_name\", \"--bin\", \"bin1\"]);\n \n             assert.deepEqual(args.cargoArgs, [\"build\", \"--package\", \"pkg_name\", \"--bin\", \"bin1\", \"--message-format=json\"]);\n             assert.deepEqual(args.filter, undefined);\n         });\n \n         test('A test', async () => {\n-            const args = cargo.artifactSpec([\"test\", \"--package\", \"pkg_name\", \"--lib\", \"--no-run\"]);\n+            const args = Cargo.artifactSpec([\"test\", \"--package\", \"pkg_name\", \"--lib\", \"--no-run\"]);\n \n             assert.deepEqual(args.cargoArgs, [\"test\", \"--package\", \"pkg_name\", \"--lib\", \"--no-run\", \"--message-format=json\"]);\n             assert.notDeepEqual(args.filter, undefined);\n@@ -28,22 +28,22 @@ suite('Launch configuration', () => {\n \n     suite('QuickPick', () => {\n         test('A binary', async () => {\n-            const args = cargo.artifactSpec([\"run\", \"--package\", \"pkg_name\", \"--bin\", \"pkg_name\"]);\n+            const args = Cargo.artifactSpec([\"run\", \"--package\", \"pkg_name\", \"--bin\", \"pkg_name\"]);\n \n             assert.deepEqual(args.cargoArgs, [\"build\", \"--package\", \"pkg_name\", \"--bin\", \"pkg_name\", \"--message-format=json\"]);\n             assert.deepEqual(args.filter, undefined);\n         });\n \n \n         test('One of Multiple Binaries', async () => {\n-            const args = cargo.artifactSpec([\"run\", \"--package\", \"pkg_name\", \"--bin\", \"bin2\"]);\n+            const args = Cargo.artifactSpec([\"run\", \"--package\", \"pkg_name\", \"--bin\", \"bin2\"]);\n \n             assert.deepEqual(args.cargoArgs, [\"build\", \"--package\", \"pkg_name\", \"--bin\", \"bin2\", \"--message-format=json\"]);\n             assert.deepEqual(args.filter, undefined);\n         });\n \n         test('A test', async () => {\n-            const args = cargo.artifactSpec([\"test\", \"--package\", \"pkg_name\", \"--lib\"]);\n+            const args = Cargo.artifactSpec([\"test\", \"--package\", \"pkg_name\", \"--lib\"]);\n \n             assert.deepEqual(args.cargoArgs, [\"test\", \"--package\", \"pkg_name\", \"--lib\", \"--message-format=json\", \"--no-run\"]);\n             assert.notDeepEqual(args.filter, undefined);"}, {"sha": "392648d7133d6c623ffed187d35074a822eca894", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -1707,7 +1707,7 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n         /// ```\n         ///\n         /// [Reference](https://doc.rust-lang.org/reference/items/generics.html#where-clauses)\n-        struct WherePred: TypeBoundsOwner { T![lifetime], TypeRef }\n+        struct WherePred: TypeBoundsOwner { T![for], TypeParamList, T![lifetime], TypeRef }\n \n         /// Where clause.\n         ///"}, {"sha": "f5f4b964a4c1a2a16c05b6b25821965ead780807", "filename": "xtask/src/codegen.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/xtask%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/xtask%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -18,8 +18,10 @@ use std::{\n use crate::{not_bash::fs2, project_root, Result};\n \n pub use self::{\n-    gen_assists_docs::generate_assists_docs, gen_feature_docs::generate_feature_docs,\n-    gen_parser_tests::generate_parser_tests, gen_syntax::generate_syntax,\n+    gen_assists_docs::{generate_assists_docs, generate_assists_tests},\n+    gen_feature_docs::generate_feature_docs,\n+    gen_parser_tests::generate_parser_tests,\n+    gen_syntax::generate_syntax,\n };\n \n const GRAMMAR_DIR: &str = \"crates/ra_parser/src/grammar\";"}, {"sha": "526941f73aceb05338fe7dc7d0b234796ce0e8de", "filename": "xtask/src/codegen/gen_assists_docs.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -7,16 +7,17 @@ use crate::{\n     project_root, rust_files, Result,\n };\n \n-pub fn generate_assists_docs(mode: Mode) -> Result<()> {\n+pub fn generate_assists_tests(mode: Mode) -> Result<()> {\n     let assists = Assist::collect()?;\n-    generate_tests(&assists, mode)?;\n+    generate_tests(&assists, mode)\n+}\n \n+pub fn generate_assists_docs(mode: Mode) -> Result<()> {\n+    let assists = Assist::collect()?;\n     let contents = assists.into_iter().map(|it| it.to_string()).collect::<Vec<_>>().join(\"\\n\\n\");\n     let contents = contents.trim().to_string() + \"\\n\";\n     let dst = project_root().join(\"docs/user/generated_assists.adoc\");\n-    codegen::update(&dst, &contents, mode)?;\n-\n-    Ok(())\n+    codegen::update(&dst, &contents, mode)\n }\n \n #[derive(Debug)]"}, {"sha": "745a25862b6890a2b09a74ad756be5f74a6062d6", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -40,7 +40,7 @@ fn generate_tokens(grammar: AstSrc<'_>) -> Result<String> {\n                 pub(crate) syntax: SyntaxToken,\n             }\n             impl std::fmt::Display for #name {\n-                fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n                     std::fmt::Display::fmt(&self.syntax, f)\n                 }\n             }\n@@ -68,7 +68,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n         .iter()\n         .map(|node| {\n             let name = format_ident!(\"{}\", node.name);\n-            let kind = format_ident!(\"{}\", to_upper_snake_case(&name.to_string()));\n+            let kind = format_ident!(\"{}\", to_upper_snake_case(node.name));\n             let traits = node.traits.iter().map(|trait_name| {\n                 let trait_name = format_ident!(\"{}\", trait_name);\n                 quote!(impl ast::#trait_name for #name {})\n@@ -199,7 +199,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n         enum_names.chain(node_names.clone()).map(|it| format_ident!(\"{}\", it)).map(|name| {\n             quote! {\n                 impl std::fmt::Display for #name {\n-                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n                         std::fmt::Display::fmt(self.syntax(), f)\n                     }\n                 }"}, {"sha": "747654c1fcb2317058f5ad6caf4bf866d5eaa5ef", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 2, "deletions": 53, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -4,6 +4,7 @@\n \n pub mod not_bash;\n pub mod install;\n+pub mod release;\n pub mod dist;\n pub mod pre_commit;\n \n@@ -19,7 +20,7 @@ use walkdir::{DirEntry, WalkDir};\n \n use crate::{\n     codegen::Mode,\n-    not_bash::{date_iso, fs2, pushd, pushenv, rm_rf, run},\n+    not_bash::{fs2, pushd, pushenv, rm_rf, run},\n };\n \n pub use anyhow::{bail, Context as _, Result};\n@@ -153,58 +154,6 @@ pub fn run_pre_cache() -> Result<()> {\n     Ok(())\n }\n \n-pub fn run_release(dry_run: bool) -> Result<()> {\n-    if !dry_run {\n-        run!(\"git switch release\")?;\n-        run!(\"git fetch upstream --tags --force\")?;\n-        run!(\"git reset --hard tags/nightly\")?;\n-        run!(\"git push\")?;\n-    }\n-\n-    let website_root = project_root().join(\"../rust-analyzer.github.io\");\n-    let changelog_dir = website_root.join(\"./thisweek/_posts\");\n-\n-    let today = date_iso()?;\n-    let commit = run!(\"git rev-parse HEAD\")?;\n-    let changelog_n = fs2::read_dir(changelog_dir.as_path())?.count();\n-\n-    let contents = format!(\n-        \"\\\n-= Changelog #{}\n-:sectanchors:\n-:page-layout: post\n-\n-Commit: commit:{}[] +\n-Release: release:{}[]\n-\n-== New Features\n-\n-* pr:[] .\n-\n-== Fixes\n-\n-== Internal Improvements\n-\",\n-        changelog_n, commit, today\n-    );\n-\n-    let path = changelog_dir.join(format!(\"{}-changelog-{}.adoc\", today, changelog_n));\n-    fs2::write(&path, &contents)?;\n-\n-    for &adoc in [\"manual.adoc\", \"generated_features.adoc\", \"generated_assists.adoc\"].iter() {\n-        let src = project_root().join(\"./docs/user/\").join(adoc);\n-        let dst = website_root.join(adoc);\n-        fs2::copy(src, dst)?;\n-    }\n-\n-    let tags = run!(\"git tag --list\"; echo = false)?;\n-    let prev_tag = tags.lines().filter(|line| is_release_tag(line)).last().unwrap();\n-\n-    println!(\"\\n    git log {}..HEAD --merges --reverse\", prev_tag);\n-\n-    Ok(())\n-}\n-\n fn is_release_tag(tag: &str) -> bool {\n     tag.len() == \"2020-02-24\".len() && tag.starts_with(|c: char| c.is_ascii_digit())\n }"}, {"sha": "f7a79362d95f2e3f721b926a15fdeb80f34e1c97", "filename": "xtask/src/main.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -16,8 +16,9 @@ use xtask::{\n     dist::run_dist,\n     install::{ClientOpt, InstallCmd, ServerOpt},\n     not_bash::pushd,\n-    pre_commit, project_root, run_clippy, run_fuzzer, run_pre_cache, run_release, run_rustfmt,\n-    Result,\n+    pre_commit, project_root,\n+    release::ReleaseCmd,\n+    run_clippy, run_fuzzer, run_pre_cache, run_rustfmt, Result,\n };\n \n fn main() -> Result<()> {\n@@ -74,6 +75,7 @@ FLAGS:\n             args.finish()?;\n             codegen::generate_syntax(Mode::Overwrite)?;\n             codegen::generate_parser_tests(Mode::Overwrite)?;\n+            codegen::generate_assists_tests(Mode::Overwrite)?;\n             codegen::generate_assists_docs(Mode::Overwrite)?;\n             codegen::generate_feature_docs(Mode::Overwrite)?;\n             Ok(())\n@@ -101,7 +103,7 @@ FLAGS:\n         \"release\" => {\n             let dry_run = args.contains(\"--dry-run\");\n             args.finish()?;\n-            run_release(dry_run)\n+            ReleaseCmd { dry_run }.run()\n         }\n         \"dist\" => {\n             let nightly = args.contains(\"--nightly\");"}, {"sha": "36c912184f0cdd28f56deb16102e6f75bdb977f9", "filename": "xtask/src/release.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/xtask%2Fsrc%2Frelease.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/xtask%2Fsrc%2Frelease.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Frelease.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -0,0 +1,67 @@\n+use crate::{\n+    codegen, is_release_tag,\n+    not_bash::{date_iso, fs2, run},\n+    project_root, Mode, Result,\n+};\n+\n+pub struct ReleaseCmd {\n+    pub dry_run: bool,\n+}\n+\n+impl ReleaseCmd {\n+    pub fn run(self) -> Result<()> {\n+        if !self.dry_run {\n+            run!(\"git switch release\")?;\n+            run!(\"git fetch upstream --tags --force\")?;\n+            run!(\"git reset --hard tags/nightly\")?;\n+            run!(\"git push\")?;\n+        }\n+        codegen::generate_assists_docs(Mode::Overwrite)?;\n+        codegen::generate_feature_docs(Mode::Overwrite)?;\n+\n+        let website_root = project_root().join(\"../rust-analyzer.github.io\");\n+        let changelog_dir = website_root.join(\"./thisweek/_posts\");\n+\n+        let today = date_iso()?;\n+        let commit = run!(\"git rev-parse HEAD\")?;\n+        let changelog_n = fs2::read_dir(changelog_dir.as_path())?.count();\n+\n+        let contents = format!(\n+            \"\\\n+    = Changelog #{}\n+    :sectanchors:\n+    :page-layout: post\n+\n+    Commit: commit:{}[] +\n+    Release: release:{}[]\n+\n+    == New Features\n+\n+    * pr:[] .\n+\n+    == Fixes\n+\n+    == Internal Improvements\n+    \",\n+            changelog_n, commit, today\n+        );\n+\n+        let path = changelog_dir.join(format!(\"{}-changelog-{}.adoc\", today, changelog_n));\n+        fs2::write(&path, &contents)?;\n+\n+        for &adoc in [\"manual.adoc\", \"generated_features.adoc\", \"generated_assists.adoc\"].iter() {\n+            let src = project_root().join(\"./docs/user/\").join(adoc);\n+            let dst = website_root.join(adoc);\n+            fs2::copy(src, dst)?;\n+        }\n+\n+        let tags = run!(\"git tag --list\"; echo = false)?;\n+        let prev_tag = tags.lines().filter(|line| is_release_tag(line)).last().unwrap();\n+\n+        let git_log = run!(\"git log {}..HEAD --merges --reverse\", prev_tag; echo = false)?;\n+        let git_log_dst = website_root.join(\"git.log\");\n+        fs2::write(git_log_dst, &git_log)?;\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "d38ac7f17e78e818069db71dd0e3b07a6dd22f22", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=16bbf4ab7f132e6e5e5318dccdef9a5d71afdd7f", "patch": "@@ -25,18 +25,11 @@ fn generated_tests_are_fresh() {\n \n #[test]\n fn generated_assists_are_fresh() {\n-    if let Err(error) = codegen::generate_assists_docs(Mode::Verify) {\n+    if let Err(error) = codegen::generate_assists_tests(Mode::Verify) {\n         panic!(\"{}. Please update assists by running `cargo xtask codegen`\", error);\n     }\n }\n \n-#[test]\n-fn generated_features_are_fresh() {\n-    if let Err(error) = codegen::generate_feature_docs(Mode::Verify) {\n-        panic!(\"{}. Please update features by running `cargo xtask codegen`\", error);\n-    }\n-}\n-\n #[test]\n fn check_code_formatting() {\n     if let Err(error) = run_rustfmt(Mode::Verify) {\n@@ -180,13 +173,11 @@ impl TidyDocs {\n }\n \n fn is_exclude_dir(p: &Path, dirs_to_exclude: &[&str]) -> bool {\n-    let mut cur_path = p;\n-    while let Some(path) = cur_path.parent() {\n-        if dirs_to_exclude.iter().any(|dir| path.ends_with(dir)) {\n-            return true;\n-        }\n-        cur_path = path;\n-    }\n-\n-    false\n+    p.strip_prefix(project_root())\n+        .unwrap()\n+        .components()\n+        .rev()\n+        .skip(1)\n+        .filter_map(|it| it.as_os_str().to_str())\n+        .any(|it| dirs_to_exclude.contains(&it))\n }"}]}