{"sha": "7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5NzlkZDYwODllZTVjYmEzOWNmYmU2ZTg4MGEzZWRlYjdmZmY3ODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-07T17:55:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-07T17:55:37Z"}, "message": "Auto merge of #32016 - nikomatsakis:incr-comp-save, r=mw\n\nSave/load incremental compilation dep graph\n\nContains the code to serialize/deserialize the dep graph to disk between executions. We also hash the item contents and compare to the new hashes. Also includes a unit test harness. There are definitely some known limitations, such as https://github.com/rust-lang/rust/issues/32014 and https://github.com/rust-lang/rust/issues/32015, but I am leaving those for follow-up work.\n\nNote that this PR builds on https://github.com/rust-lang/rust/pull/32007, so the overlapping commits can be excluded from review.\n\nr? @michaelwoerister", "tree": {"sha": "53f7316a403f28fa203c315a14ed0a23047deab1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53f7316a403f28fa203c315a14ed0a23047deab1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "html_url": "https://github.com/rust-lang/rust/commit/7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "470ca1c3ff33cd046f71a5453f8f520da4cd387e", "url": "https://api.github.com/repos/rust-lang/rust/commits/470ca1c3ff33cd046f71a5453f8f520da4cd387e", "html_url": "https://github.com/rust-lang/rust/commit/470ca1c3ff33cd046f71a5453f8f520da4cd387e"}, {"sha": "9eaae920117594f5bddab1f46f406e5402e8cc8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9eaae920117594f5bddab1f46f406e5402e8cc8a", "html_url": "https://github.com/rust-lang/rust/commit/9eaae920117594f5bddab1f46f406e5402e8cc8a"}], "stats": {"total": 2765, "additions": 2053, "deletions": 712}, "files": [{"sha": "dafda75f5fe7d883ba564bd2b5003828ab1486c3", "filename": "mk/crates.mk", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -58,7 +58,7 @@ RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n                 rustc_data_structures rustc_platform_intrinsics \\\n                 rustc_plugin rustc_metadata rustc_passes rustc_save_analysis \\\n-                rustc_const_eval rustc_const_math\n+                rustc_const_eval rustc_const_math rustc_incremental\n HOST_CRATES := syntax syntax_ext $(RUSTC_CRATES) rustdoc fmt_macros \\\n \t\tflate arena graphviz rbml log serialize\n TOOLS := compiletest rustdoc rustc rustbook error_index_generator\n@@ -105,7 +105,8 @@ DEPS_rustc_data_structures := std log serialize\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n                      rustc_typeck rustc_mir rustc_resolve log syntax serialize rustc_llvm \\\n \t             rustc_trans rustc_privacy rustc_lint rustc_plugin \\\n-                     rustc_metadata syntax_ext rustc_passes rustc_save_analysis rustc_const_eval\n+                     rustc_metadata syntax_ext rustc_passes rustc_save_analysis rustc_const_eval \\\n+                     rustc_incremental\n DEPS_rustc_lint := rustc log syntax rustc_const_eval\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n DEPS_rustc_metadata := rustc syntax rbml rustc_const_math\n@@ -117,7 +118,8 @@ DEPS_rustc_plugin := rustc rustc_metadata syntax rustc_mir\n DEPS_rustc_privacy := rustc log syntax\n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back rustc_mir \\\n                     log syntax serialize rustc_llvm rustc_platform_intrinsics \\\n-                    rustc_const_math rustc_const_eval\n+                    rustc_const_math rustc_const_eval rustc_incremental\n+DEPS_rustc_incremental := rbml rustc serialize rustc_data_structures\n DEPS_rustc_save_analysis := rustc log syntax\n DEPS_rustc_typeck := rustc syntax rustc_platform_intrinsics rustc_const_math \\\n                      rustc_const_eval"}, {"sha": "20736165b73b0beb9b441cf6f640da17687a3d55", "filename": "mk/tests.mk", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -305,6 +305,7 @@ check-stage$(1)-T-$(2)-H-$(3)-exec: \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-doc-crates-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-debuginfo-gdb-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-debuginfo-lldb-exec \\\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-incremental-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-doc-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-pretty-exec\n \n@@ -481,6 +482,7 @@ DEBUGINFO_LLDB_RS := $(call rwildcard,$(S)src/test/debuginfo/,*.rs)\n CODEGEN_RS := $(call rwildcard,$(S)src/test/codegen/,*.rs)\n CODEGEN_CC := $(call rwildcard,$(S)src/test/codegen/,*.cc)\n CODEGEN_UNITS_RS := $(call rwildcard,$(S)src/test/codegen-units/,*.rs)\n+INCREMENTAL_RS := $(call rwildcard,$(S)src/test/incremental/,*.rs)\n RUSTDOCCK_RS := $(call rwildcard,$(S)src/test/rustdoc/,*.rs)\n \n RPASS_TESTS := $(RPASS_RS)\n@@ -496,6 +498,7 @@ DEBUGINFO_GDB_TESTS := $(DEBUGINFO_GDB_RS)\n DEBUGINFO_LLDB_TESTS := $(DEBUGINFO_LLDB_RS)\n CODEGEN_TESTS := $(CODEGEN_RS) $(CODEGEN_CC)\n CODEGEN_UNITS_TESTS := $(CODEGEN_UNITS_RS)\n+INCREMENTAL_TESTS := $(INCREMENTAL_RS)\n RUSTDOCCK_TESTS := $(RUSTDOCCK_RS)\n \n CTEST_SRC_BASE_rpass = run-pass\n@@ -558,6 +561,11 @@ CTEST_BUILD_BASE_codegen-units = codegen-units\n CTEST_MODE_codegen-units = codegen-units\n CTEST_RUNTOOL_codegen-units = $(CTEST_RUNTOOL)\n \n+CTEST_SRC_BASE_incremental = incremental\n+CTEST_BUILD_BASE_incremental = incremental\n+CTEST_MODE_incremental = incremental\n+CTEST_RUNTOOL_incremental = $(CTEST_RUNTOOL)\n+\n CTEST_SRC_BASE_rustdocck = rustdoc\n CTEST_BUILD_BASE_rustdocck = rustdoc\n CTEST_MODE_rustdocck = rustdoc\n@@ -681,6 +689,7 @@ CTEST_DEPS_debuginfo-lldb_$(1)-T-$(2)-H-$(3) = $$(DEBUGINFO_LLDB_TESTS) \\\n                                                $(S)src/etc/lldb_rust_formatters.py\n CTEST_DEPS_codegen_$(1)-T-$(2)-H-$(3) = $$(CODEGEN_TESTS)\n CTEST_DEPS_codegen-units_$(1)-T-$(2)-H-$(3) = $$(CODEGEN_UNITS_TESTS)\n+CTEST_DEPS_incremental_$(1)-T-$(2)-H-$(3) = $$(INCREMENTAL_TESTS)\n CTEST_DEPS_rustdocck_$(1)-T-$(2)-H-$(3) = $$(RUSTDOCCK_TESTS) \\\n \t\t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) \\\n \t\t$(S)src/etc/htmldocck.py\n@@ -747,7 +756,7 @@ endif\n endef\n \n CTEST_NAMES = rpass rpass-valgrind rpass-full rfail-full cfail-full rfail cfail pfail \\\n-\tdebuginfo-gdb debuginfo-lldb codegen codegen-units rustdocck\n+\tdebuginfo-gdb debuginfo-lldb codegen codegen-units rustdocck incremental\n \n $(foreach host,$(CFG_HOST), \\\n  $(eval $(foreach target,$(CFG_TARGET), \\\n@@ -945,6 +954,7 @@ TEST_GROUPS = \\\n \tdebuginfo-lldb \\\n \tcodegen \\\n \tcodegen-units \\\n+\tincremental \\\n \tdoc \\\n \t$(foreach docname,$(DOC_NAMES),doc-$(docname)) \\\n \tpretty \\"}, {"sha": "a6960ff17854ecf27f0bda277f3e4c702f484f65", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -25,7 +25,8 @@ pub enum Mode {\n     DebugInfoLldb,\n     Codegen,\n     Rustdoc,\n-    CodegenUnits\n+    CodegenUnits,\n+    Incremental,\n }\n \n impl FromStr for Mode {\n@@ -43,6 +44,7 @@ impl FromStr for Mode {\n           \"codegen\" => Ok(Codegen),\n           \"rustdoc\" => Ok(Rustdoc),\n           \"codegen-units\" => Ok(CodegenUnits),\n+          \"incremental\" => Ok(Incremental),\n           _ => Err(()),\n         }\n     }\n@@ -62,6 +64,7 @@ impl fmt::Display for Mode {\n             Codegen => \"codegen\",\n             Rustdoc => \"rustdoc\",\n             CodegenUnits => \"codegen-units\",\n+            Incremental => \"incremental\",\n         }, f)\n     }\n }"}, {"sha": "1c06b2a23d54dde779f98c7cda5b7708d3f37979", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -71,7 +71,8 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n           reqopt(\"\", \"aux-base\", \"directory to find auxiliary test files\", \"PATH\"),\n           reqopt(\"\", \"stage-id\", \"the target-stage identifier\", \"stageN-TARGET\"),\n           reqopt(\"\", \"mode\", \"which sort of compile tests to run\",\n-                 \"(compile-fail|parse-fail|run-fail|run-pass|run-pass-valgrind|pretty|debug-info)\"),\n+                 \"(compile-fail|parse-fail|run-fail|run-pass|\\\n+                  run-pass-valgrind|pretty|debug-info|incremental)\"),\n           optflag(\"\", \"ignored\", \"run tests marked as ignored\"),\n           optopt(\"\", \"runtool\", \"supervisor program to run tests under \\\n                                  (eg. emulator, valgrind)\", \"PROGRAM\"),"}, {"sha": "994f45da14626eb5a37c7e5945ba2a6620ab76e6", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -11,6 +11,7 @@\n use common::Config;\n use common::{CompileFail, ParseFail, Pretty, RunFail, RunPass, RunPassValgrind};\n use common::{Codegen, DebugInfoLldb, DebugInfoGdb, Rustdoc, CodegenUnits};\n+use common::{Incremental};\n use errors::{self, ErrorKind};\n use header::TestProps;\n use header;\n@@ -59,6 +60,7 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n         Codegen => run_codegen_test(&config, &props, &testpaths),\n         Rustdoc => run_rustdoc_test(&config, &props, &testpaths),\n         CodegenUnits => run_codegen_units_test(&config, &props, &testpaths),\n+        Incremental => run_incremental_test(&config, &props, &testpaths),\n     }\n }\n \n@@ -1966,3 +1968,67 @@ fn run_codegen_units_test(config: &Config, props: &TestProps, testpaths: &TestPa\n         panic!();\n     }\n }\n+\n+fn run_incremental_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+    // Basic plan for a test incremental/foo/bar.rs:\n+    // - load list of revisions pass1, fail2, pass3\n+    //   - each should begin with `rpass`, `rfail`, or `cfail`\n+    //   - if `rpass`, expect compile and execution to succeed\n+    //   - if `cfail`, expect compilation to fail\n+    //   - if `rfail`, expect execution to fail\n+    // - create a directory build/foo/bar.incremental\n+    // - compile foo/bar.rs with -Z incremental=.../foo/bar.incremental and -C pass1\n+    //   - because name of revision starts with \"pass\", expect success\n+    // - compile foo/bar.rs with -Z incremental=.../foo/bar.incremental and -C fail2\n+    //   - because name of revision starts with \"fail\", expect an error\n+    //   - load expected errors as usual, but filter for those that end in `[fail2]`\n+    // - compile foo/bar.rs with -Z incremental=.../foo/bar.incremental and -C pass3\n+    //   - because name of revision starts with \"pass\", expect success\n+    // - execute build/foo/bar.exe and save output\n+    //\n+    // FIXME -- use non-incremental mode as an oracle? That doesn't apply\n+    // to #[rustc_dirty] and clean tests I guess\n+\n+    assert!(!props.revisions.is_empty(), \"incremental tests require a list of revisions\");\n+\n+    let output_base_name = output_base_name(config, testpaths);\n+\n+    // Create the incremental workproduct directory.\n+    let incremental_dir = output_base_name.with_extension(\"incremental\");\n+    if incremental_dir.exists() {\n+        fs::remove_dir_all(&incremental_dir).unwrap();\n+    }\n+    fs::create_dir_all(&incremental_dir).unwrap();\n+\n+    if config.verbose {\n+        print!(\"incremental_dir={}\", incremental_dir.display());\n+    }\n+\n+    for revision in &props.revisions {\n+        let mut revision_props = props.clone();\n+        header::load_props_into(&mut revision_props, &testpaths.file, Some(&revision));\n+\n+        revision_props.compile_flags.extend(vec![\n+            format!(\"-Z\"),\n+            format!(\"incremental={}\", incremental_dir.display()),\n+            format!(\"--cfg\"),\n+            format!(\"{}\", revision),\n+        ]);\n+\n+        if config.verbose {\n+            print!(\"revision={:?} revision_props={:#?}\", revision, revision_props);\n+        }\n+\n+        if revision.starts_with(\"rpass\") {\n+            run_rpass_test_revision(config, &revision_props, testpaths, Some(&revision));\n+        } else if revision.starts_with(\"rfail\") {\n+            run_rfail_test_revision(config, &revision_props, testpaths, Some(&revision));\n+        } else if revision.starts_with(\"cfail\") {\n+            run_cfail_test_revision(config, &revision_props, testpaths, Some(&revision));\n+        } else {\n+            fatal(\n+                Some(revision),\n+                \"revision name must begin with rpass, rfail, or cfail\");\n+        }\n+    }\n+}"}, {"sha": "446313f7037f3d4470419f17cc54c7bc08c379c1", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,207 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt::Debug;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub enum DepNode<D: Clone + Debug> {\n+    // The `D` type is \"how definitions are identified\".\n+    // During compilation, it is always `DefId`, but when serializing\n+    // it is mapped to `DefPath`.\n+\n+    // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n+    // distinct from the krate module). This is basically a hash of\n+    // the entire krate, so if you read from `Krate` (e.g., by calling\n+    // `tcx.map.krate()`), we will have to assume that any change\n+    // means that you need to be recompiled. This is because the\n+    // `Krate` value gives you access to all other items. To avoid\n+    // this fate, do not call `tcx.map.krate()`; instead, prefer\n+    // wrappers like `tcx.visit_all_items_in_krate()`.  If there is no\n+    // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n+    // access to the krate, but you must remember to add suitable\n+    // edges yourself for the individual items that you read.\n+    Krate,\n+\n+    // Represents the HIR node with the given node-id\n+    Hir(D),\n+\n+    // Represents different phases in the compiler.\n+    CrateReader,\n+    CollectLanguageItems,\n+    CheckStaticRecursion,\n+    ResolveLifetimes,\n+    RegionResolveCrate,\n+    CheckLoops,\n+    PluginRegistrar,\n+    StabilityIndex,\n+    CollectItem(D),\n+    Coherence,\n+    EffectCheck,\n+    Liveness,\n+    Resolve,\n+    EntryPoint,\n+    CheckEntryFn,\n+    CoherenceCheckImpl(D),\n+    CoherenceOverlapCheck(D),\n+    CoherenceOverlapCheckSpecial(D),\n+    CoherenceOverlapInherentCheck(D),\n+    CoherenceOrphanCheck(D),\n+    Variance,\n+    WfCheck(D),\n+    TypeckItemType(D),\n+    TypeckItemBody(D),\n+    Dropck,\n+    DropckImpl(D),\n+    CheckConst(D),\n+    Privacy,\n+    IntrinsicCheck(D),\n+    MatchCheck(D),\n+    MirMapConstruction(D),\n+    MirTypeck(D),\n+    BorrowCheck(D),\n+    RvalueCheck(D),\n+    Reachability,\n+    DeadCheck,\n+    StabilityCheck,\n+    LateLintCheck,\n+    IntrinsicUseCheck,\n+    TransCrate,\n+    TransCrateItem(D),\n+    TransInlinedItem(D),\n+    TransWriteMetadata,\n+\n+    // Nodes representing bits of computed IR in the tcx. Each shared\n+    // table in the tcx (or elsewhere) maps to one of these\n+    // nodes. Often we map multiple tables to the same node if there\n+    // is no point in distinguishing them (e.g., both the type and\n+    // predicates for an item wind up in `ItemSignature`). Other\n+    // times, such as `ImplItems` vs `TraitItemDefIds`, tables which\n+    // might be mergable are kept distinct because the sets of def-ids\n+    // to which they apply are disjoint, and hence we might as well\n+    // have distinct labels for easier debugging.\n+    ImplOrTraitItems(D),\n+    ItemSignature(D),\n+    FieldTy(D),\n+    TraitItemDefIds(D),\n+    InherentImpls(D),\n+    ImplItems(D),\n+\n+    // The set of impls for a given trait. Ultimately, it would be\n+    // nice to get more fine-grained here (e.g., to include a\n+    // simplified type), but we can't do that until we restructure the\n+    // HIR to distinguish the *header* of an impl from its body.  This\n+    // is because changes to the header may change the self-type of\n+    // the impl and hence would require us to be more conservative\n+    // than changes in the impl body.\n+    TraitImpls(D),\n+\n+    // Nodes representing caches. To properly handle a true cache, we\n+    // don't use a DepTrackingMap, but rather we push a task node.\n+    // Otherwise the write into the map would be incorrectly\n+    // attributed to the first task that happened to fill the cache,\n+    // which would yield an overly conservative dep-graph.\n+    TraitItems(D),\n+    ReprHints(D),\n+    TraitSelect(D),\n+}\n+\n+impl<D: Clone + Debug> DepNode<D> {\n+    /// Used in testing\n+    pub fn from_label_string(label: &str, data: D) -> Result<DepNode<D>, ()> {\n+        macro_rules! check {\n+            ($($name:ident,)*) => {\n+                match label {\n+                    $(stringify!($name) => Ok(DepNode::$name(data)),)*\n+                    _ => Err(())\n+                }\n+            }\n+        }\n+\n+        check! {\n+            CollectItem,\n+            BorrowCheck,\n+            TransCrateItem,\n+            TypeckItemType,\n+            TypeckItemBody,\n+            ImplOrTraitItems,\n+            ItemSignature,\n+            FieldTy,\n+            TraitItemDefIds,\n+            InherentImpls,\n+            ImplItems,\n+            TraitImpls,\n+            ReprHints,\n+        }\n+    }\n+\n+    pub fn map_def<E, OP>(&self, mut op: OP) -> Option<DepNode<E>>\n+        where OP: FnMut(&D) -> Option<E>, E: Clone + Debug\n+    {\n+        use self::DepNode::*;\n+\n+        match *self {\n+            Krate => Some(Krate),\n+            CrateReader => Some(CrateReader),\n+            CollectLanguageItems => Some(CollectLanguageItems),\n+            CheckStaticRecursion => Some(CheckStaticRecursion),\n+            ResolveLifetimes => Some(ResolveLifetimes),\n+            RegionResolveCrate => Some(RegionResolveCrate),\n+            CheckLoops => Some(CheckLoops),\n+            PluginRegistrar => Some(PluginRegistrar),\n+            StabilityIndex => Some(StabilityIndex),\n+            Coherence => Some(Coherence),\n+            EffectCheck => Some(EffectCheck),\n+            Liveness => Some(Liveness),\n+            Resolve => Some(Resolve),\n+            EntryPoint => Some(EntryPoint),\n+            CheckEntryFn => Some(CheckEntryFn),\n+            Variance => Some(Variance),\n+            Dropck => Some(Dropck),\n+            Privacy => Some(Privacy),\n+            Reachability => Some(Reachability),\n+            DeadCheck => Some(DeadCheck),\n+            StabilityCheck => Some(StabilityCheck),\n+            LateLintCheck => Some(LateLintCheck),\n+            IntrinsicUseCheck => Some(IntrinsicUseCheck),\n+            TransCrate => Some(TransCrate),\n+            TransWriteMetadata => Some(TransWriteMetadata),\n+            Hir(ref d) => op(d).map(Hir),\n+            CollectItem(ref d) => op(d).map(CollectItem),\n+            CoherenceCheckImpl(ref d) => op(d).map(CoherenceCheckImpl),\n+            CoherenceOverlapCheck(ref d) => op(d).map(CoherenceOverlapCheck),\n+            CoherenceOverlapCheckSpecial(ref d) => op(d).map(CoherenceOverlapCheckSpecial),\n+            CoherenceOverlapInherentCheck(ref d) => op(d).map(CoherenceOverlapInherentCheck),\n+            CoherenceOrphanCheck(ref d) => op(d).map(CoherenceOrphanCheck),\n+            WfCheck(ref d) => op(d).map(WfCheck),\n+            TypeckItemType(ref d) => op(d).map(TypeckItemType),\n+            TypeckItemBody(ref d) => op(d).map(TypeckItemBody),\n+            DropckImpl(ref d) => op(d).map(DropckImpl),\n+            CheckConst(ref d) => op(d).map(CheckConst),\n+            IntrinsicCheck(ref d) => op(d).map(IntrinsicCheck),\n+            MatchCheck(ref d) => op(d).map(MatchCheck),\n+            MirMapConstruction(ref d) => op(d).map(MirMapConstruction),\n+            MirTypeck(ref d) => op(d).map(MirTypeck),\n+            BorrowCheck(ref d) => op(d).map(BorrowCheck),\n+            RvalueCheck(ref d) => op(d).map(RvalueCheck),\n+            TransCrateItem(ref d) => op(d).map(TransCrateItem),\n+            TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n+            ImplOrTraitItems(ref d) => op(d).map(ImplOrTraitItems),\n+            ItemSignature(ref d) => op(d).map(ItemSignature),\n+            FieldTy(ref d) => op(d).map(FieldTy),\n+            TraitItemDefIds(ref d) => op(d).map(TraitItemDefIds),\n+            InherentImpls(ref d) => op(d).map(InherentImpls),\n+            ImplItems(ref d) => op(d).map(ImplItems),\n+            TraitImpls(ref d) => op(d).map(TraitImpls),\n+            TraitItems(ref d) => op(d).map(TraitItems),\n+            ReprHints(ref d) => op(d).map(ReprHints),\n+            TraitSelect(ref d) => op(d).map(TraitSelect),\n+        }\n+    }\n+}"}, {"sha": "922d32a3067969f626a299f4a19d01ddbc83f69b", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use hir::def_id::DefId;\n use rustc_data_structures::fnv::FnvHashMap;\n use std::cell::RefCell;\n use std::ops::Index;\n@@ -29,7 +30,7 @@ pub struct DepTrackingMap<M: DepTrackingMapConfig> {\n pub trait DepTrackingMapConfig {\n     type Key: Eq + Hash + Clone;\n     type Value: Clone;\n-    fn to_dep_node(key: &Self::Key) -> DepNode;\n+    fn to_dep_node(key: &Self::Key) -> DepNode<DefId>;\n }\n \n impl<M: DepTrackingMapConfig> DepTrackingMap<M> {"}, {"sha": "10f3d21f2af6d37eeb265f293278785543b99dfb", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -9,11 +9,13 @@\n // except according to those terms.\n \n use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n+use std::fmt::Debug;\n+use std::hash::Hash;\n use super::{DepGraphQuery, DepNode};\n \n-pub struct DepGraphEdges {\n-    nodes: Vec<DepNode>,\n-    indices: FnvHashMap<DepNode, IdIndex>,\n+pub struct DepGraphEdges<D: Clone + Debug + Eq + Hash> {\n+    nodes: Vec<DepNode<D>>,\n+    indices: FnvHashMap<DepNode<D>, IdIndex>,\n     edges: FnvHashSet<(IdIndex, IdIndex)>,\n     open_nodes: Vec<OpenNode>,\n }\n@@ -40,8 +42,8 @@ enum OpenNode {\n     Ignore,\n }\n \n-impl DepGraphEdges {\n-    pub fn new() -> DepGraphEdges {\n+impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n+    pub fn new() -> DepGraphEdges<D> {\n         DepGraphEdges {\n             nodes: vec![],\n             indices: FnvHashMap(),\n@@ -50,12 +52,12 @@ impl DepGraphEdges {\n         }\n     }\n \n-    fn id(&self, index: IdIndex) -> DepNode {\n-        self.nodes[index.index()]\n+    fn id(&self, index: IdIndex) -> DepNode<D> {\n+        self.nodes[index.index()].clone()\n     }\n \n     /// Creates a node for `id` in the graph.\n-    fn make_node(&mut self, id: DepNode) -> IdIndex {\n+    fn make_node(&mut self, id: DepNode<D>) -> IdIndex {\n         if let Some(&i) = self.indices.get(&id) {\n             return i;\n         }\n@@ -80,7 +82,7 @@ impl DepGraphEdges {\n         assert_eq!(popped_node, OpenNode::Ignore);\n     }\n \n-    pub fn push_task(&mut self, key: DepNode) {\n+    pub fn push_task(&mut self, key: DepNode<D>) {\n         let top_node = self.current_node();\n \n         let new_node = self.make_node(key);\n@@ -93,23 +95,23 @@ impl DepGraphEdges {\n         }\n     }\n \n-    pub fn pop_task(&mut self, key: DepNode) {\n+    pub fn pop_task(&mut self, key: DepNode<D>) {\n         let popped_node = self.open_nodes.pop().unwrap();\n         assert_eq!(OpenNode::Node(self.indices[&key]), popped_node);\n     }\n \n     /// Indicates that the current task `C` reads `v` by adding an\n     /// edge from `v` to `C`. If there is no current task, panics. If\n     /// you want to suppress this edge, use `ignore`.\n-    pub fn read(&mut self, v: DepNode) {\n+    pub fn read(&mut self, v: DepNode<D>) {\n         let source = self.make_node(v);\n         self.add_edge_from_current_node(|current| (source, current))\n     }\n \n     /// Indicates that the current task `C` writes `v` by adding an\n     /// edge from `C` to `v`. If there is no current task, panics. If\n     /// you want to suppress this edge, use `ignore`.\n-    pub fn write(&mut self, v: DepNode) {\n+    pub fn write(&mut self, v: DepNode<D>) {\n         let target = self.make_node(v);\n         self.add_edge_from_current_node(|current| (current, target))\n     }\n@@ -153,7 +155,7 @@ impl DepGraphEdges {\n         }\n     }\n \n-    pub fn query(&self) -> DepGraphQuery {\n+    pub fn query(&self) -> DepGraphQuery<D> {\n         let edges: Vec<_> = self.edges.iter()\n                                       .map(|&(i, j)| (self.id(i), self.id(j)))\n                                       .collect();"}, {"sha": "741ad65c29fda373a9bb17129c16299f5b6f6871", "filename": "src/librustc/dep_graph/graph.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::def_id::DefId;\n+use std::rc::Rc;\n+\n+use super::dep_node::DepNode;\n+use super::query::DepGraphQuery;\n+use super::raii;\n+use super::thread::{DepGraphThreadData, DepMessage};\n+\n+#[derive(Clone)]\n+pub struct DepGraph {\n+    data: Rc<DepGraphThreadData>\n+}\n+\n+impl DepGraph {\n+    pub fn new(enabled: bool) -> DepGraph {\n+        DepGraph {\n+            data: Rc::new(DepGraphThreadData::new(enabled))\n+        }\n+    }\n+\n+    /// True if we are actually building a dep-graph. If this returns false,\n+    /// then the other methods on this `DepGraph` will have no net effect.\n+    #[inline]\n+    pub fn enabled(&self) -> bool {\n+        self.data.enabled()\n+    }\n+\n+    pub fn query(&self) -> DepGraphQuery<DefId> {\n+        self.data.query()\n+    }\n+\n+    pub fn in_ignore<'graph>(&'graph self) -> raii::IgnoreTask<'graph> {\n+        raii::IgnoreTask::new(&self.data)\n+    }\n+\n+    pub fn in_task<'graph>(&'graph self, key: DepNode<DefId>) -> raii::DepTask<'graph> {\n+        raii::DepTask::new(&self.data, key)\n+    }\n+\n+    pub fn with_ignore<OP,R>(&self, op: OP) -> R\n+        where OP: FnOnce() -> R\n+    {\n+        let _task = self.in_ignore();\n+        op()\n+    }\n+\n+    pub fn with_task<OP,R>(&self, key: DepNode<DefId>, op: OP) -> R\n+        where OP: FnOnce() -> R\n+    {\n+        let _task = self.in_task(key);\n+        op()\n+    }\n+\n+    pub fn read(&self, v: DepNode<DefId>) {\n+        self.data.enqueue(DepMessage::Read(v));\n+    }\n+\n+    pub fn write(&self, v: DepNode<DefId>) {\n+        self.data.enqueue(DepMessage::Write(v));\n+    }\n+}"}, {"sha": "49481dcb79672faecec8a671dc2f05c515b8b5c3", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 6, "deletions": 200, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -8,211 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::thread::{DepGraphThreadData, DepMessage};\n-use hir::def_id::DefId;\n-use syntax::ast::NodeId;\n-use ty::TyCtxt;\n-use hir;\n-use hir::intravisit::Visitor;\n-use std::rc::Rc;\n-\n+mod dep_node;\n mod dep_tracking_map;\n mod edges;\n+mod graph;\n mod query;\n mod raii;\n mod thread;\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum DepNode {\n-    // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n-    // distinct from the krate module). This is basically a hash of\n-    // the entire krate, so if you read from `Krate` (e.g., by calling\n-    // `tcx.map.krate()`), we will have to assume that any change\n-    // means that you need to be recompiled. This is because the\n-    // `Krate` value gives you access to all other items. To avoid\n-    // this fate, do not call `tcx.map.krate()`; instead, prefer\n-    // wrappers like `tcx.visit_all_items_in_krate()`.  If there is no\n-    // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n-    // access to the krate, but you must remember to add suitable\n-    // edges yourself for the individual items that you read.\n-    Krate,\n-\n-    // Represents the HIR node with the given node-id\n-    Hir(DefId),\n-\n-    // Represents different phases in the compiler.\n-    CrateReader,\n-    CollectLanguageItems,\n-    CheckStaticRecursion,\n-    ResolveLifetimes,\n-    RegionResolveCrate,\n-    CheckLoops,\n-    PluginRegistrar,\n-    StabilityIndex,\n-    CollectItem(DefId),\n-    Coherence,\n-    EffectCheck,\n-    Liveness,\n-    Resolve,\n-    EntryPoint,\n-    CheckEntryFn,\n-    CoherenceCheckImpl(DefId),\n-    CoherenceOverlapCheck(DefId),\n-    CoherenceOverlapCheckSpecial(DefId),\n-    CoherenceOverlapInherentCheck(DefId),\n-    CoherenceOrphanCheck(DefId),\n-    Variance,\n-    WfCheck(DefId),\n-    TypeckItemType(DefId),\n-    TypeckItemBody(DefId),\n-    Dropck,\n-    DropckImpl(DefId),\n-    CheckConst(DefId),\n-    Privacy,\n-    IntrinsicCheck(DefId),\n-    MatchCheck(DefId),\n-    MirMapConstruction(DefId),\n-    MirTypeck(NodeId),\n-    BorrowCheck(DefId),\n-    RvalueCheck(DefId),\n-    Reachability,\n-    DeadCheck,\n-    StabilityCheck,\n-    LateLintCheck,\n-    IntrinsicUseCheck,\n-    TransCrate,\n-    TransCrateItem(DefId),\n-    TransInlinedItem(DefId),\n-    TransWriteMetadata,\n-\n-    // Nodes representing bits of computed IR in the tcx. Each shared\n-    // table in the tcx (or elsewhere) maps to one of these\n-    // nodes. Often we map multiple tables to the same node if there\n-    // is no point in distinguishing them (e.g., both the type and\n-    // predicates for an item wind up in `ItemSignature`). Other\n-    // times, such as `ImplItems` vs `TraitItemDefIds`, tables which\n-    // might be mergable are kept distinct because the sets of def-ids\n-    // to which they apply are disjoint, and hence we might as well\n-    // have distinct labels for easier debugging.\n-    ImplOrTraitItems(DefId),\n-    ItemSignature(DefId),\n-    FieldTy(DefId),\n-    TraitItemDefIds(DefId),\n-    InherentImpls(DefId),\n-    ImplItems(DefId),\n-\n-    // The set of impls for a given trait. Ultimately, it would be\n-    // nice to get more fine-grained here (e.g., to include a\n-    // simplified type), but we can't do that until we restructure the\n-    // HIR to distinguish the *header* of an impl from its body.  This\n-    // is because changes to the header may change the self-type of\n-    // the impl and hence would require us to be more conservative\n-    // than changes in the impl body.\n-    TraitImpls(DefId),\n-\n-    // Nodes representing caches. To properly handle a true cache, we\n-    // don't use a DepTrackingMap, but rather we push a task node.\n-    // Otherwise the write into the map would be incorrectly\n-    // attributed to the first task that happened to fill the cache,\n-    // which would yield an overly conservative dep-graph.\n-    TraitItems(DefId),\n-    ReprHints(DefId),\n-    TraitSelect(DefId),\n-}\n-\n-#[derive(Clone)]\n-pub struct DepGraph {\n-    data: Rc<DepGraphThreadData>\n-}\n-\n-impl DepGraph {\n-    pub fn new(enabled: bool) -> DepGraph {\n-        DepGraph {\n-            data: Rc::new(DepGraphThreadData::new(enabled))\n-        }\n-    }\n-\n-    /// True if we are actually building a dep-graph. If this returns false,\n-    /// then the other methods on this `DepGraph` will have no net effect.\n-    #[inline]\n-    pub fn enabled(&self) -> bool {\n-        self.data.enabled()\n-    }\n-\n-    pub fn query(&self) -> DepGraphQuery {\n-        self.data.query()\n-    }\n-\n-    pub fn in_ignore<'graph>(&'graph self) -> raii::IgnoreTask<'graph> {\n-        raii::IgnoreTask::new(&self.data)\n-    }\n-\n-    pub fn in_task<'graph>(&'graph self, key: DepNode) -> raii::DepTask<'graph> {\n-        raii::DepTask::new(&self.data, key)\n-    }\n-\n-    pub fn with_ignore<OP,R>(&self, op: OP) -> R\n-        where OP: FnOnce() -> R\n-    {\n-        let _task = self.in_ignore();\n-        op()\n-    }\n-\n-    pub fn with_task<OP,R>(&self, key: DepNode, op: OP) -> R\n-        where OP: FnOnce() -> R\n-    {\n-        let _task = self.in_task(key);\n-        op()\n-    }\n-\n-    pub fn read(&self, v: DepNode) {\n-        self.data.enqueue(DepMessage::Read(v));\n-    }\n-\n-    pub fn write(&self, v: DepNode) {\n-        self.data.enqueue(DepMessage::Write(v));\n-    }\n-}\n+mod visit;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n-\n+pub use self::dep_node::DepNode;\n+pub use self::graph::DepGraph;\n pub use self::query::DepGraphQuery;\n-\n-/// Visit all the items in the krate in some order. When visiting a\n-/// particular item, first create a dep-node by calling `dep_node_fn`\n-/// and push that onto the dep-graph stack of tasks, and also create a\n-/// read edge from the corresponding AST node. This is used in\n-/// compiler passes to automatically record the item that they are\n-/// working on.\n-pub fn visit_all_items_in_krate<'tcx,V,F>(tcx: &TyCtxt<'tcx>,\n-                                          mut dep_node_fn: F,\n-                                          visitor: &mut V)\n-    where F: FnMut(DefId) -> DepNode, V: Visitor<'tcx>\n-{\n-    struct TrackingVisitor<'visit, 'tcx: 'visit, F: 'visit, V: 'visit> {\n-        tcx: &'visit TyCtxt<'tcx>,\n-        dep_node_fn: &'visit mut F,\n-        visitor: &'visit mut V\n-    }\n-\n-    impl<'visit, 'tcx, F, V> Visitor<'tcx> for TrackingVisitor<'visit, 'tcx, F, V>\n-        where F: FnMut(DefId) -> DepNode, V: Visitor<'tcx>\n-    {\n-        fn visit_item(&mut self, i: &'tcx hir::Item) {\n-            let item_def_id = self.tcx.map.local_def_id(i.id);\n-            let task_id = (self.dep_node_fn)(item_def_id);\n-            let _task = self.tcx.dep_graph.in_task(task_id);\n-            debug!(\"Started task {:?}\", task_id);\n-            self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n-            self.visitor.visit_item(i)\n-        }\n-    }\n-\n-    let krate = tcx.dep_graph.with_ignore(|| tcx.map.krate());\n-    let mut tracking_visitor = TrackingVisitor {\n-        tcx: tcx,\n-        dep_node_fn: &mut dep_node_fn,\n-        visitor: visitor\n-    };\n-    krate.visit_all_items(&mut tracking_visitor)\n-}\n+pub use self::visit::visit_all_items_in_krate;"}, {"sha": "acc6660da6e8934ae144aa78e6d4456490681d48", "filename": "src/librustc/dep_graph/query.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fquery.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -10,16 +10,20 @@\n \n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::graph::{Graph, NodeIndex};\n+use std::fmt::Debug;\n+use std::hash::Hash;\n \n use super::DepNode;\n \n-pub struct DepGraphQuery {\n-    pub graph: Graph<DepNode, ()>,\n-    pub indices: FnvHashMap<DepNode, NodeIndex>,\n+pub struct DepGraphQuery<D: Clone + Debug + Hash + Eq> {\n+    pub graph: Graph<DepNode<D>, ()>,\n+    pub indices: FnvHashMap<DepNode<D>, NodeIndex>,\n }\n \n-impl DepGraphQuery {\n-    pub fn new(nodes: &[DepNode], edges: &[(DepNode, DepNode)]) -> DepGraphQuery {\n+impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n+    pub fn new(nodes: &[DepNode<D>],\n+               edges: &[(DepNode<D>, DepNode<D>)])\n+               -> DepGraphQuery<D> {\n         let mut graph = Graph::new();\n         let mut indices = FnvHashMap();\n         for node in nodes {\n@@ -39,27 +43,43 @@ impl DepGraphQuery {\n         }\n     }\n \n-    pub fn nodes(&self) -> Vec<DepNode> {\n+    pub fn contains_node(&self, node: &DepNode<D>) -> bool {\n+        self.indices.contains_key(&node)\n+    }\n+\n+    pub fn nodes(&self) -> Vec<DepNode<D>> {\n         self.graph.all_nodes()\n                   .iter()\n                   .map(|n| n.data.clone())\n                   .collect()\n     }\n \n-    pub fn edges(&self) -> Vec<(DepNode,DepNode)> {\n+    pub fn edges(&self) -> Vec<(DepNode<D>,DepNode<D>)> {\n         self.graph.all_edges()\n                   .iter()\n                   .map(|edge| (edge.source(), edge.target()))\n-                  .map(|(s, t)| (self.graph.node_data(s).clone(), self.graph.node_data(t).clone()))\n+                  .map(|(s, t)| (self.graph.node_data(s).clone(),\n+                                 self.graph.node_data(t).clone()))\n                   .collect()\n     }\n \n     /// All nodes reachable from `node`. In other words, things that\n     /// will have to be recomputed if `node` changes.\n-    pub fn dependents(&self, node: DepNode) -> Vec<DepNode> {\n+    pub fn transitive_dependents(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n         if let Some(&index) = self.indices.get(&node) {\n             self.graph.depth_traverse(index)\n-                      .map(|dependent_node| self.graph.node_data(dependent_node).clone())\n+                      .map(|s| self.graph.node_data(s).clone())\n+                      .collect()\n+        } else {\n+            vec![]\n+        }\n+    }\n+\n+    /// Just the outgoing edges from `node`.\n+    pub fn immediate_dependents(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n+        if let Some(&index) = self.indices.get(&node) {\n+            self.graph.successor_nodes(index)\n+                      .map(|s| self.graph.node_data(s).clone())\n                       .collect()\n         } else {\n             vec![]"}, {"sha": "13151d169fc3f78843405d5a1829ec9d2823d985", "filename": "src/librustc/dep_graph/raii.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -8,16 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use hir::def_id::DefId;\n use super::DepNode;\n use super::thread::{DepGraphThreadData, DepMessage};\n \n pub struct DepTask<'graph> {\n     data: &'graph DepGraphThreadData,\n-    key: DepNode,\n+    key: DepNode<DefId>,\n }\n \n impl<'graph> DepTask<'graph> {\n-    pub fn new(data: &'graph DepGraphThreadData, key: DepNode) -> DepTask<'graph> {\n+    pub fn new(data: &'graph DepGraphThreadData, key: DepNode<DefId>)\n+               -> DepTask<'graph> {\n         data.enqueue(DepMessage::PushTask(key));\n         DepTask { data: data, key: key }\n     }"}, {"sha": "5b0e4a909c8d3d7aeeade5edc26361eb2da149ae", "filename": "src/librustc/dep_graph/thread.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -18,6 +18,7 @@\n //! to accumulate more messages. This way we only ever have two vectors\n //! allocated (and both have a fairly large capacity).\n \n+use hir::def_id::DefId;\n use rustc_data_structures::veccell::VecCell;\n use std::cell::Cell;\n use std::sync::mpsc::{self, Sender, Receiver};\n@@ -28,10 +29,10 @@ use super::DepNode;\n use super::edges::DepGraphEdges;\n \n pub enum DepMessage {\n-    Read(DepNode),\n-    Write(DepNode),\n-    PushTask(DepNode),\n-    PopTask(DepNode),\n+    Read(DepNode<DefId>),\n+    Write(DepNode<DefId>),\n+    PushTask(DepNode<DefId>),\n+    PopTask(DepNode<DefId>),\n     PushIgnore,\n     PopIgnore,\n     Query,\n@@ -57,7 +58,7 @@ pub struct DepGraphThreadData {\n     swap_out: Sender<Vec<DepMessage>>,\n \n     // where to receive query results\n-    query_in: Receiver<DepGraphQuery>,\n+    query_in: Receiver<DepGraphQuery<DefId>>,\n }\n \n const INITIAL_CAPACITY: usize = 2048;\n@@ -105,7 +106,7 @@ impl DepGraphThreadData {\n         self.swap_out.send(old_messages).unwrap();\n     }\n \n-    pub fn query(&self) -> DepGraphQuery {\n+    pub fn query(&self) -> DepGraphQuery<DefId> {\n         assert!(self.enabled, \"cannot query if dep graph construction not enabled\");\n         self.enqueue(DepMessage::Query);\n         self.swap();\n@@ -155,7 +156,7 @@ impl DepGraphThreadData {\n /// Definition of the depgraph thread.\n pub fn main(swap_in: Receiver<Vec<DepMessage>>,\n             swap_out: Sender<Vec<DepMessage>>,\n-            query_out: Sender<DepGraphQuery>) {\n+            query_out: Sender<DepGraphQuery<DefId>>) {\n     let mut edges = DepGraphEdges::new();\n \n     // the compiler thread always expects a fresh buffer to be"}, {"sha": "cdc16216798abd444ca7b7ada1368f96faad48ca", "filename": "src/librustc/dep_graph/visit.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir;\n+use hir::def_id::DefId;\n+use hir::intravisit::Visitor;\n+use ty::TyCtxt;\n+\n+use super::dep_node::DepNode;\n+\n+\n+/// Visit all the items in the krate in some order. When visiting a\n+/// particular item, first create a dep-node by calling `dep_node_fn`\n+/// and push that onto the dep-graph stack of tasks, and also create a\n+/// read edge from the corresponding AST node. This is used in\n+/// compiler passes to automatically record the item that they are\n+/// working on.\n+pub fn visit_all_items_in_krate<'tcx,V,F>(tcx: &TyCtxt<'tcx>,\n+                                          mut dep_node_fn: F,\n+                                          visitor: &mut V)\n+    where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'tcx>\n+{\n+    struct TrackingVisitor<'visit, 'tcx: 'visit, F: 'visit, V: 'visit> {\n+        tcx: &'visit TyCtxt<'tcx>,\n+        dep_node_fn: &'visit mut F,\n+        visitor: &'visit mut V\n+    }\n+\n+    impl<'visit, 'tcx, F, V> Visitor<'tcx> for TrackingVisitor<'visit, 'tcx, F, V>\n+        where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'tcx>\n+    {\n+        fn visit_item(&mut self, i: &'tcx hir::Item) {\n+            let item_def_id = self.tcx.map.local_def_id(i.id);\n+            let task_id = (self.dep_node_fn)(item_def_id);\n+            let _task = self.tcx.dep_graph.in_task(task_id);\n+            debug!(\"Started task {:?}\", task_id);\n+            self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n+            self.visitor.visit_item(i)\n+        }\n+    }\n+\n+    let krate = tcx.dep_graph.with_ignore(|| tcx.map.krate());\n+    let mut tracking_visitor = TrackingVisitor {\n+        tcx: tcx,\n+        dep_node_fn: &mut dep_node_fn,\n+        visitor: visitor\n+    };\n+    krate.visit_all_items(&mut tracking_visitor)\n+}"}, {"sha": "2e26fe5057e2f6913bad177ded8c74e75a652f7f", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -203,17 +203,56 @@ impl Definitions {\n         }\n     }\n \n+    pub fn retrace_path(&self, path: &DefPath) -> Option<DefIndex> {\n+        debug!(\"retrace_path(path={:?})\", path);\n+\n+        // we assume that we only want to retrace paths relative to\n+        // the crate root\n+        assert!(path.is_local());\n+\n+        let root_key = DefKey {\n+            parent: None,\n+            disambiguated_data: DisambiguatedDefPathData {\n+                data: DefPathData::CrateRoot,\n+                disambiguator: 0,\n+            },\n+        };\n+        let root_id = self.key_map[&root_key];\n+\n+        debug!(\"retrace_path: root_id={:?}\", root_id);\n+\n+        let mut id = root_id;\n+        for data in &path.data {\n+            let key = DefKey { parent: Some(id), disambiguated_data: data.clone() };\n+            debug!(\"key = {:?}\", key);\n+            id = match self.key_map.get(&key) {\n+                Some(&id) => id,\n+                None => return None\n+            };\n+        }\n+\n+        Some(id)\n+    }\n+\n     pub fn create_def_with_parent(&mut self,\n                                   parent: Option<DefIndex>,\n                                   node_id: ast::NodeId,\n                                   data: DefPathData)\n                                   -> DefIndex {\n+        debug!(\"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n+               parent, node_id, data);\n+\n         assert!(!self.node_map.contains_key(&node_id),\n                 \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n                 node_id,\n                 data,\n                 self.data[self.node_map[&node_id].as_usize()]);\n \n+        assert!(parent.is_some() ^ match data {\n+            DefPathData::CrateRoot | DefPathData::InlinedRoot(_) => true,\n+            _ => false,\n+        });\n+\n         // Find a unique DefKey. This basically means incrementing the disambiguator\n         // until we get no match.\n         let mut key = DefKey {\n@@ -228,12 +267,17 @@ impl Definitions {\n             key.disambiguated_data.disambiguator += 1;\n         }\n \n+        debug!(\"create_def_with_parent: after disambiguation, key = {:?}\", key);\n+\n         // Create the definition.\n         let index = DefIndex::new(self.data.len());\n         self.data.push(DefData { key: key.clone(), node_id: node_id });\n+        debug!(\"create_def_with_parent: node_map[{:?}] = {:?}\", node_id, index);\n         self.node_map.insert(node_id, index);\n+        debug!(\"create_def_with_parent: key_map[{:?}] = {:?}\", key, index);\n         self.key_map.insert(key, index);\n \n+\n         index\n     }\n }"}, {"sha": "7b8ddee0e23cbb9e582fc35c492afe4d675c41aa", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -208,7 +208,7 @@ impl<'ast> Map<'ast> {\n         self.dep_graph.read(self.dep_node(id));\n     }\n \n-    fn dep_node(&self, id0: NodeId) -> DepNode {\n+    fn dep_node(&self, id0: NodeId) -> DepNode<DefId> {\n         let map = self.map.borrow();\n         let mut id = id0;\n         loop {\n@@ -282,6 +282,11 @@ impl<'ast> Map<'ast> {\n         self.definitions.borrow().def_path(def_id.index)\n     }\n \n+    pub fn retrace_path(&self, path: &DefPath) -> Option<DefId> {\n+        self.definitions.borrow().retrace_path(path)\n+                                 .map(DefId::local)\n+    }\n+\n     pub fn local_def_id(&self, node: NodeId) -> DefId {\n         self.opt_local_def_id(node).unwrap_or_else(|| {\n             bug!(\"local_def_id: no entry for `{}`, which has a map of `{:?}`\","}, {"sha": "08c3d70034a0de516ea5cf918c6f653de869c2c6", "filename": "src/librustc/hir/svh.rs", "status": "modified", "additions": 11, "deletions": 363, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fhir%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fhir%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fsvh.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -47,63 +47,23 @@\n //! Original issue: https://github.com/rust-lang/rust/issues/10207\n \n use std::fmt;\n-use std::hash::{Hash, SipHasher, Hasher};\n-use hir;\n-use hir::intravisit as visit;\n \n #[derive(Clone, PartialEq, Debug)]\n pub struct Svh {\n     hash: String,\n }\n \n impl Svh {\n-    pub fn new(hash: &str) -> Svh {\n+    /// Create a new `Svh` given the hash. If you actually want to\n+    /// compute the SVH from some HIR, you want the `calculate_svh`\n+    /// function found in `librustc_trans`.\n+    pub fn new(hash: String) -> Svh {\n         assert!(hash.len() == 16);\n-        Svh { hash: hash.to_string() }\n+        Svh { hash: hash }\n     }\n \n-    pub fn as_str<'a>(&'a self) -> &'a str {\n-        &self.hash\n-    }\n-\n-    pub fn calculate(crate_disambiguator: &str, krate: &hir::Crate) -> Svh {\n-        // FIXME (#14132): This is better than it used to be, but it still not\n-        // ideal. We now attempt to hash only the relevant portions of the\n-        // Crate AST as well as the top-level crate attributes. (However,\n-        // the hashing of the crate attributes should be double-checked\n-        // to ensure it is not incorporating implementation artifacts into\n-        // the hash that are not otherwise visible.)\n-\n-        // FIXME: this should use SHA1, not SipHash. SipHash is not built to\n-        //        avoid collisions.\n-        let mut state = SipHasher::new();\n-\n-        \"crate_disambiguator\".hash(&mut state);\n-        crate_disambiguator.len().hash(&mut state);\n-        crate_disambiguator.hash(&mut state);\n-\n-        {\n-            let mut visit = svh_visitor::make(&mut state, krate);\n-            visit::walk_crate(&mut visit, krate);\n-        }\n-\n-        // FIXME (#14132): This hash is still sensitive to e.g. the\n-        // spans of the crate Attributes and their underlying\n-        // MetaItems; we should make ContentHashable impl for those\n-        // types and then use hash_content.  But, since all crate\n-        // attributes should appear near beginning of the file, it is\n-        // not such a big deal to be sensitive to their spans for now.\n-        //\n-        // We hash only the MetaItems instead of the entire Attribute\n-        // to avoid hashing the AttrId\n-        for attr in &krate.attrs {\n-            attr.node.value.hash(&mut state);\n-        }\n-\n-        let hash = state.finish();\n-        return Svh {\n-            hash: (0..64).step_by(4).map(|i| hex(hash >> i)).collect()\n-        };\n+    pub fn from_hash(hash: u64) -> Svh {\n+        return Svh::new((0..64).step_by(4).map(|i| hex(hash >> i)).collect());\n \n         fn hex(b: u64) -> char {\n             let b = (b & 0xf) as u8;\n@@ -114,326 +74,14 @@ impl Svh {\n             b as char\n         }\n     }\n+\n+    pub fn as_str<'a>(&'a self) -> &'a str {\n+        &self.hash\n+    }\n }\n \n impl fmt::Display for Svh {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(self.as_str())\n     }\n }\n-\n-// FIXME (#14132): Even this SVH computation still has implementation\n-// artifacts: namely, the order of item declaration will affect the\n-// hash computation, but for many kinds of items the order of\n-// declaration should be irrelevant to the ABI.\n-\n-mod svh_visitor {\n-    pub use self::SawExprComponent::*;\n-    pub use self::SawStmtComponent::*;\n-    use self::SawAbiComponent::*;\n-    use syntax::ast::{self, Name, NodeId};\n-    use syntax::codemap::Span;\n-    use syntax::parse::token;\n-    use hir::intravisit as visit;\n-    use hir::intravisit::{Visitor, FnKind};\n-    use hir::*;\n-    use hir;\n-\n-    use std::hash::{Hash, SipHasher};\n-\n-    pub struct StrictVersionHashVisitor<'a> {\n-        pub krate: &'a Crate,\n-        pub st: &'a mut SipHasher,\n-    }\n-\n-    pub fn make<'a>(st: &'a mut SipHasher, krate: &'a Crate) -> StrictVersionHashVisitor<'a> {\n-        StrictVersionHashVisitor { st: st, krate: krate }\n-    }\n-\n-    // To off-load the bulk of the hash-computation on #[derive(Hash)],\n-    // we define a set of enums corresponding to the content that our\n-    // crate visitor will encounter as it traverses the ast.\n-    //\n-    // The important invariant is that all of the Saw*Component enums\n-    // do not carry any Spans, Names, or Idents.\n-    //\n-    // Not carrying any Names/Idents is the important fix for problem\n-    // noted on PR #13948: using the ident.name as the basis for a\n-    // hash leads to unstable SVH, because ident.name is just an index\n-    // into intern table (i.e. essentially a random address), not\n-    // computed from the name content.\n-    //\n-    // With the below enums, the SVH computation is not sensitive to\n-    // artifacts of how rustc was invoked nor of how the source code\n-    // was laid out.  (Or at least it is *less* sensitive.)\n-\n-    // This enum represents the different potential bits of code the\n-    // visitor could encounter that could affect the ABI for the crate,\n-    // and assigns each a distinct tag to feed into the hash computation.\n-    #[derive(Hash)]\n-    enum SawAbiComponent<'a> {\n-\n-        // FIXME (#14132): should we include (some function of)\n-        // ident.ctxt as well?\n-        SawIdent(token::InternedString),\n-        SawStructDef(token::InternedString),\n-\n-        SawLifetime(token::InternedString),\n-        SawLifetimeDef(token::InternedString),\n-\n-        SawMod,\n-        SawForeignItem,\n-        SawItem,\n-        SawDecl,\n-        SawTy,\n-        SawGenerics,\n-        SawFn,\n-        SawTraitItem,\n-        SawImplItem,\n-        SawStructField,\n-        SawVariant,\n-        SawExplicitSelf,\n-        SawPath,\n-        SawBlock,\n-        SawPat,\n-        SawLocal,\n-        SawArm,\n-        SawExpr(SawExprComponent<'a>),\n-        SawStmt(SawStmtComponent),\n-    }\n-\n-    /// SawExprComponent carries all of the information that we want\n-    /// to include in the hash that *won't* be covered by the\n-    /// subsequent recursive traversal of the expression's\n-    /// substructure by the visitor.\n-    ///\n-    /// We know every Expr_ variant is covered by a variant because\n-    /// `fn saw_expr` maps each to some case below.  Ensuring that\n-    /// each variant carries an appropriate payload has to be verified\n-    /// by hand.\n-    ///\n-    /// (However, getting that *exactly* right is not so important\n-    /// because the SVH is just a developer convenience; there is no\n-    /// guarantee of collision-freedom, hash collisions are just\n-    /// (hopefully) unlikely.)\n-    #[derive(Hash)]\n-    pub enum SawExprComponent<'a> {\n-\n-        SawExprLoop(Option<token::InternedString>),\n-        SawExprField(token::InternedString),\n-        SawExprTupField(usize),\n-        SawExprBreak(Option<token::InternedString>),\n-        SawExprAgain(Option<token::InternedString>),\n-\n-        SawExprBox,\n-        SawExprVec,\n-        SawExprCall,\n-        SawExprMethodCall,\n-        SawExprTup,\n-        SawExprBinary(hir::BinOp_),\n-        SawExprUnary(hir::UnOp),\n-        SawExprLit(ast::LitKind),\n-        SawExprCast,\n-        SawExprType,\n-        SawExprIf,\n-        SawExprWhile,\n-        SawExprMatch,\n-        SawExprClosure,\n-        SawExprBlock,\n-        SawExprAssign,\n-        SawExprAssignOp(hir::BinOp_),\n-        SawExprIndex,\n-        SawExprPath(Option<usize>),\n-        SawExprAddrOf(hir::Mutability),\n-        SawExprRet,\n-        SawExprInlineAsm(&'a hir::InlineAsm),\n-        SawExprStruct,\n-        SawExprRepeat,\n-    }\n-\n-    fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n-        match *node {\n-            ExprBox(..)              => SawExprBox,\n-            ExprVec(..)              => SawExprVec,\n-            ExprCall(..)             => SawExprCall,\n-            ExprMethodCall(..)       => SawExprMethodCall,\n-            ExprTup(..)              => SawExprTup,\n-            ExprBinary(op, _, _)     => SawExprBinary(op.node),\n-            ExprUnary(op, _)         => SawExprUnary(op),\n-            ExprLit(ref lit)         => SawExprLit(lit.node.clone()),\n-            ExprCast(..)             => SawExprCast,\n-            ExprType(..)             => SawExprType,\n-            ExprIf(..)               => SawExprIf,\n-            ExprWhile(..)            => SawExprWhile,\n-            ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.name.as_str())),\n-            ExprMatch(..)            => SawExprMatch,\n-            ExprClosure(..)          => SawExprClosure,\n-            ExprBlock(..)            => SawExprBlock,\n-            ExprAssign(..)           => SawExprAssign,\n-            ExprAssignOp(op, _, _)   => SawExprAssignOp(op.node),\n-            ExprField(_, name)       => SawExprField(name.node.as_str()),\n-            ExprTupField(_, id)      => SawExprTupField(id.node),\n-            ExprIndex(..)            => SawExprIndex,\n-            ExprPath(ref qself, _)   => SawExprPath(qself.as_ref().map(|q| q.position)),\n-            ExprAddrOf(m, _)         => SawExprAddrOf(m),\n-            ExprBreak(id)            => SawExprBreak(id.map(|id| id.node.name.as_str())),\n-            ExprAgain(id)            => SawExprAgain(id.map(|id| id.node.name.as_str())),\n-            ExprRet(..)              => SawExprRet,\n-            ExprInlineAsm(ref a,_,_) => SawExprInlineAsm(a),\n-            ExprStruct(..)           => SawExprStruct,\n-            ExprRepeat(..)           => SawExprRepeat,\n-        }\n-    }\n-\n-    /// SawStmtComponent is analogous to SawExprComponent, but for statements.\n-    #[derive(Hash)]\n-    pub enum SawStmtComponent {\n-        SawStmtDecl,\n-        SawStmtExpr,\n-        SawStmtSemi,\n-    }\n-\n-    fn saw_stmt(node: &Stmt_) -> SawStmtComponent {\n-        match *node {\n-            StmtDecl(..) => SawStmtDecl,\n-            StmtExpr(..) => SawStmtExpr,\n-            StmtSemi(..) => SawStmtSemi,\n-        }\n-    }\n-\n-    impl<'a> Visitor<'a> for StrictVersionHashVisitor<'a> {\n-        fn visit_nested_item(&mut self, item: ItemId) {\n-            self.visit_item(self.krate.item(item.id))\n-        }\n-\n-        fn visit_variant_data(&mut self, s: &'a VariantData, name: Name,\n-                              g: &'a Generics, _: NodeId, _: Span) {\n-            SawStructDef(name.as_str()).hash(self.st);\n-            visit::walk_generics(self, g);\n-            visit::walk_struct_def(self, s)\n-        }\n-\n-        fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n-            SawVariant.hash(self.st);\n-            // walk_variant does not call walk_generics, so do it here.\n-            visit::walk_generics(self, g);\n-            visit::walk_variant(self, v, g, item_id)\n-        }\n-\n-        // All of the remaining methods just record (in the hash\n-        // SipHasher) that the visitor saw that particular variant\n-        // (with its payload), and continue walking as the default\n-        // visitor would.\n-        //\n-        // Some of the implementations have some notes as to how one\n-        // might try to make their SVH computation less discerning\n-        // (e.g. by incorporating reachability analysis).  But\n-        // currently all of their implementations are uniform and\n-        // uninteresting.\n-        //\n-        // (If you edit a method such that it deviates from the\n-        // pattern, please move that method up above this comment.)\n-\n-        fn visit_name(&mut self, _: Span, name: Name) {\n-            SawIdent(name.as_str()).hash(self.st);\n-        }\n-\n-        fn visit_lifetime(&mut self, l: &'a Lifetime) {\n-            SawLifetime(l.name.as_str()).hash(self.st);\n-        }\n-\n-        fn visit_lifetime_def(&mut self, l: &'a LifetimeDef) {\n-            SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n-        }\n-\n-        // We do recursively walk the bodies of functions/methods\n-        // (rather than omitting their bodies from the hash) since\n-        // monomorphization and cross-crate inlining generally implies\n-        // that a change to a crate body will require downstream\n-        // crates to be recompiled.\n-        fn visit_expr(&mut self, ex: &'a Expr) {\n-            SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n-        }\n-\n-        fn visit_stmt(&mut self, s: &'a Stmt) {\n-            SawStmt(saw_stmt(&s.node)).hash(self.st); visit::walk_stmt(self, s)\n-        }\n-\n-        fn visit_foreign_item(&mut self, i: &'a ForeignItem) {\n-            // FIXME (#14132) ideally we would incorporate privacy (or\n-            // perhaps reachability) somewhere here, so foreign items\n-            // that do not leak into downstream crates would not be\n-            // part of the ABI.\n-            SawForeignItem.hash(self.st); visit::walk_foreign_item(self, i)\n-        }\n-\n-        fn visit_item(&mut self, i: &'a Item) {\n-            // FIXME (#14132) ideally would incorporate reachability\n-            // analysis somewhere here, so items that never leak into\n-            // downstream crates (e.g. via monomorphisation or\n-            // inlining) would not be part of the ABI.\n-            SawItem.hash(self.st); visit::walk_item(self, i)\n-        }\n-\n-        fn visit_mod(&mut self, m: &'a Mod, _s: Span, _n: NodeId) {\n-            SawMod.hash(self.st); visit::walk_mod(self, m)\n-        }\n-\n-        fn visit_decl(&mut self, d: &'a Decl) {\n-            SawDecl.hash(self.st); visit::walk_decl(self, d)\n-        }\n-\n-        fn visit_ty(&mut self, t: &'a Ty) {\n-            SawTy.hash(self.st); visit::walk_ty(self, t)\n-        }\n-\n-        fn visit_generics(&mut self, g: &'a Generics) {\n-            SawGenerics.hash(self.st); visit::walk_generics(self, g)\n-        }\n-\n-        fn visit_fn(&mut self, fk: FnKind<'a>, fd: &'a FnDecl,\n-                    b: &'a Block, s: Span, _: NodeId) {\n-            SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s)\n-        }\n-\n-        fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n-            SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n-        }\n-\n-        fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n-            SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n-        }\n-\n-        fn visit_struct_field(&mut self, s: &'a StructField) {\n-            SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n-        }\n-\n-        fn visit_explicit_self(&mut self, es: &'a ExplicitSelf) {\n-            SawExplicitSelf.hash(self.st); visit::walk_explicit_self(self, es)\n-        }\n-\n-        fn visit_path(&mut self, path: &'a Path, _: ast::NodeId) {\n-            SawPath.hash(self.st); visit::walk_path(self, path)\n-        }\n-\n-        fn visit_path_list_item(&mut self, prefix: &'a Path, item: &'a PathListItem) {\n-            SawPath.hash(self.st); visit::walk_path_list_item(self, prefix, item)\n-        }\n-\n-        fn visit_block(&mut self, b: &'a Block) {\n-            SawBlock.hash(self.st); visit::walk_block(self, b)\n-        }\n-\n-        fn visit_pat(&mut self, p: &'a Pat) {\n-            SawPat.hash(self.st); visit::walk_pat(self, p)\n-        }\n-\n-        fn visit_local(&mut self, l: &'a Local) {\n-            SawLocal.hash(self.st); visit::walk_local(self, l)\n-        }\n-\n-        fn visit_arm(&mut self, a: &'a Arm) {\n-            SawArm.hash(self.st); visit::walk_arm(self, a)\n-        }\n-    }\n-}"}, {"sha": "574c927bd75d2cca969fbe58db01866c46cd0896", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -139,11 +139,9 @@ pub struct Options {\n     pub continue_parse_after_error: bool,\n     pub mir_opt_level: usize,\n \n-    /// if true, build up the dep-graph\n-    pub build_dep_graph: bool,\n-\n-    /// if true, -Z dump-dep-graph was passed to dump out the dep-graph\n-    pub dump_dep_graph: bool,\n+    /// if Some, enable incremental compilation, using the given\n+    /// directory to store intermediate results\n+    pub incremental: Option<PathBuf>,\n \n     pub no_analysis: bool,\n     pub debugging_opts: DebuggingOptions,\n@@ -260,8 +258,7 @@ pub fn basic_options() -> Options {\n         treat_err_as_bug: false,\n         continue_parse_after_error: false,\n         mir_opt_level: 1,\n-        build_dep_graph: false,\n-        dump_dep_graph: false,\n+        incremental: None,\n         no_analysis: false,\n         debugging_opts: basic_debugging_options(),\n         prints: Vec::new(),\n@@ -276,6 +273,15 @@ pub fn basic_options() -> Options {\n     }\n }\n \n+impl Options {\n+    /// True if there is a reason to build the dep graph.\n+    pub fn build_dep_graph(&self) -> bool {\n+        self.incremental.is_some() ||\n+            self.debugging_opts.dump_dep_graph ||\n+            self.debugging_opts.query_dep_graph\n+    }\n+}\n+\n // The type of entry function, so\n // users can have their own entry\n // functions that don't start a\n@@ -635,10 +641,12 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"treat all errors that occur as bugs\"),\n     continue_parse_after_error: bool = (false, parse_bool,\n           \"attempt to recover from parse errors (experimental)\"),\n-    incr_comp: bool = (false, parse_bool,\n+    incremental: Option<String> = (None, parse_opt_string,\n           \"enable incremental compilation (experimental)\"),\n     dump_dep_graph: bool = (false, parse_bool,\n           \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n+    query_dep_graph: bool = (false, parse_bool,\n+          \"enable queries of the dependency graph for regression testing\"),\n     no_analysis: bool = (false, parse_bool,\n           \"parse and expand the source, but run no analysis\"),\n     extra_plugins: Vec<String> = (Vec::new(), parse_list,\n@@ -1050,8 +1058,6 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let treat_err_as_bug = debugging_opts.treat_err_as_bug;\n     let continue_parse_after_error = debugging_opts.continue_parse_after_error;\n     let mir_opt_level = debugging_opts.mir_opt_level.unwrap_or(1);\n-    let incremental_compilation = debugging_opts.incr_comp;\n-    let dump_dep_graph = debugging_opts.dump_dep_graph;\n     let no_analysis = debugging_opts.no_analysis;\n \n     let mut output_types = HashMap::new();\n@@ -1211,6 +1217,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let crate_name = matches.opt_str(\"crate-name\");\n \n+    let incremental = debugging_opts.incremental.as_ref().map(|m| PathBuf::from(m));\n+\n     Options {\n         crate_types: crate_types,\n         gc: gc,\n@@ -1230,8 +1238,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         treat_err_as_bug: treat_err_as_bug,\n         continue_parse_after_error: continue_parse_after_error,\n         mir_opt_level: mir_opt_level,\n-        build_dep_graph: incremental_compilation || dump_dep_graph,\n-        dump_dep_graph: dump_dep_graph,\n+        incremental: incremental,\n         no_analysis: no_analysis,\n         debugging_opts: debugging_opts,\n         prints: prints,"}, {"sha": "88327ab19a5cb66350a06e707fa9954766d62b55", "filename": "src/librustc/ty/ivar.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fty%2Fivar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fty%2Fivar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fivar.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use dep_graph::DepNode;\n+use hir::def_id::DefId;\n use ty::{Ty, TyS};\n use ty::tls;\n \n@@ -46,7 +47,7 @@ impl<'tcx, 'lt> TyIVar<'tcx, 'lt> {\n     }\n \n     #[inline]\n-    pub fn get(&self, dep_node: DepNode) -> Option<Ty<'tcx>> {\n+    pub fn get(&self, dep_node: DepNode<DefId>) -> Option<Ty<'tcx>> {\n         tls::with(|tcx| tcx.dep_graph.read(dep_node));\n         self.untracked_get()\n     }\n@@ -61,11 +62,11 @@ impl<'tcx, 'lt> TyIVar<'tcx, 'lt> {\n     }\n \n     #[inline]\n-    pub fn unwrap(&self, dep_node: DepNode) -> Ty<'tcx> {\n+    pub fn unwrap(&self, dep_node: DepNode<DefId>) -> Ty<'tcx> {\n         self.get(dep_node).unwrap()\n     }\n \n-    pub fn fulfill(&self, dep_node: DepNode, value: Ty<'lt>) {\n+    pub fn fulfill(&self, dep_node: DepNode<DefId>, value: Ty<'lt>) {\n         tls::with(|tcx| tcx.dep_graph.write(dep_node));\n \n         // Invariant (A) is fulfilled, because by (B), every alias"}, {"sha": "57b1dd66bea9d353185e7ab3f2f43304e589cf30", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -24,7 +24,7 @@ macro_rules! dep_map_ty {\n         impl<'tcx> DepTrackingMapConfig for $ty_name<'tcx> {\n             type Key = $key;\n             type Value = $value;\n-            fn to_dep_node(key: &$key) -> DepNode { DepNode::$node_name(*key) }\n+            fn to_dep_node(key: &$key) -> DepNode<DefId> { DepNode::$node_name(*key) }\n         }\n     }\n }"}, {"sha": "cba3a9e2ebb5ccfadf418572c2a398ae25e9def7", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -937,7 +937,7 @@ impl<'tcx> TraitPredicate<'tcx> {\n     }\n \n     /// Creates the dep-node for selecting/evaluating this trait reference.\n-    fn dep_node(&self) -> DepNode {\n+    fn dep_node(&self) -> DepNode<DefId> {\n         DepNode::TraitSelect(self.def_id())\n     }\n \n@@ -956,7 +956,7 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n         self.0.def_id()\n     }\n \n-    pub fn dep_node(&self) -> DepNode {\n+    pub fn dep_node(&self) -> DepNode<DefId> {\n         // ok to skip binder since depnode does not care about regions\n         self.0.dep_node()\n     }\n@@ -2716,7 +2716,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn visit_all_items_in_krate<V,F>(&self,\n                                          dep_node_fn: F,\n                                          visitor: &mut V)\n-        where F: FnMut(DefId) -> DepNode, V: Visitor<'tcx>\n+        where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'tcx>\n     {\n         dep_graph::visit_all_items_in_krate(self, dep_node_fn, visitor);\n     }"}, {"sha": "4533946d26ea404fb0d9daae4d4e584cb9f96357", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -23,6 +23,7 @@ rustc_mir = { path = \"../librustc_mir\" }\n rustc_plugin = { path = \"../librustc_plugin\" }\n rustc_passes = { path = \"../librustc_passes\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n+rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n rustc_trans = { path = \"../librustc_trans\" }"}, {"sha": "67c52bb6c36d780eb73719cf3b3a1693edb3bf11", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -24,6 +24,7 @@ use rustc::util::common::time;\n use rustc::util::nodemap::NodeSet;\n use rustc_back::sha2::{Sha256, Digest};\n use rustc_borrowck as borrowck;\n+use rustc_incremental;\n use rustc_resolve as resolve;\n use rustc_metadata::macro_import;\n use rustc_metadata::creader::LocalCrateReader;\n@@ -121,7 +122,7 @@ pub fn compile_input(sess: &Session,\n         let expanded_crate = assign_node_ids(sess, expanded_crate);\n         // Lower ast -> hir.\n         let lcx = LoweringContext::new(sess, Some(&expanded_crate));\n-        let dep_graph = DepGraph::new(sess.opts.build_dep_graph);\n+        let dep_graph = DepGraph::new(sess.opts.build_dep_graph());\n         let mut hir_forest = time(sess.time_passes(),\n                                   \"lowering ast -> hir\",\n                                   || hir_map::Forest::new(lower_crate(&lcx, &expanded_crate),\n@@ -828,6 +829,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                index,\n                                name,\n                                |tcx| {\n+        time(time_passes,\n+             \"load_dep_graph\",\n+             || rustc_incremental::load_dep_graph(tcx));\n+\n         // passes are timed inside typeck\n         try_with_f!(typeck::check_crate(tcx, trait_map), (tcx, None, analysis));\n \n@@ -952,9 +957,20 @@ pub fn phase_4_translate_to_llvm<'tcx>(tcx: &TyCtxt<'tcx>,\n         passes.run_passes(tcx, &mut mir_map);\n     });\n \n+    let translation =\n+        time(time_passes,\n+             \"translation\",\n+             move || trans::trans_crate(tcx, &mir_map, analysis));\n+\n     time(time_passes,\n-         \"translation\",\n-         move || trans::trans_crate(tcx, &mir_map, analysis))\n+         \"assert dep graph\",\n+         move || rustc_incremental::assert_dep_graph(tcx));\n+\n+    time(time_passes,\n+         \"serialize dep graph\",\n+         move || rustc_incremental::save_dep_graph(tcx));\n+\n+    translation\n }\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file"}, {"sha": "769449b96d2b1ed66e424576abf8cf779acaedbc", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -45,6 +45,7 @@ extern crate rustc_passes;\n extern crate rustc_lint;\n extern crate rustc_plugin;\n extern crate rustc_privacy;\n+extern crate rustc_incremental;\n extern crate rustc_metadata;\n extern crate rustc_mir;\n extern crate rustc_resolve;"}, {"sha": "927e4126472f637cfb402e80b6291443b891eb45", "filename": "src/librustc_incremental/Cargo.toml", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,18 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_incremental\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_incremental\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+graphviz = { path = \"../libgraphviz\" }\n+rbml = { path = \"../librbml\" }\n+rustc = { path = \"../librustc\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+serialize = { path = \"../libserialize\" }\n+log = { path = \"../liblog\" }\n+syntax = { path = \"../libsyntax\" }"}, {"sha": "88d8ed8d58118b6bb2d81dea749ac710807628f9", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "renamed", "additions": 67, "deletions": 63, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -13,12 +13,17 @@\n //! will dump graphs in graphviz form to disk, and it searches for\n //! `#[rustc_if_this_changed]` and `#[rustc_then_this_would_need]`\n //! annotations. These annotations can be used to test whether paths\n-//! exist in the graph. We report errors on each\n-//! `rustc_if_this_changed` annotation. If a path exists in all\n-//! cases, then we would report \"all path(s) exist\". Otherwise, we\n-//! report: \"no path to `foo`\" for each case where no path exists.\n-//! `compile-fail` tests can then be used to check when paths exist or\n-//! do not.\n+//! exist in the graph. These checks run after trans, so they view the\n+//! the final state of the dependency graph. Note that there are\n+//! similar assertions found in `persist::dirty_clean` which check the\n+//! **initial** state of the dependency graph, just after it has been\n+//! loaded from disk.\n+//!\n+//! In this code, we report errors on each `rustc_if_this_changed`\n+//! annotation. If a path exists in all cases, then we would report\n+//! \"all path(s) exist\". Otherwise, we report: \"no path to `foo`\" for\n+//! each case where no path exists.  `compile-fail` tests can then be\n+//! used to check when paths exist or do not.\n //!\n //! The full form of the `rustc_if_this_changed` annotation is\n //! `#[rustc_if_this_changed(id)]`. The `\"id\"` is optional and\n@@ -61,7 +66,7 @@ const ID: &'static str = \"id\";\n pub fn assert_dep_graph(tcx: &TyCtxt) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n-    if tcx.sess.opts.dump_dep_graph {\n+    if tcx.sess.opts.debugging_opts.dump_dep_graph {\n         dump_graph(tcx);\n     }\n \n@@ -74,14 +79,23 @@ pub fn assert_dep_graph(tcx: &TyCtxt) {\n         (visitor.if_this_changed, visitor.then_this_would_need)\n     };\n \n+    if !if_this_changed.is_empty() || !then_this_would_need.is_empty() {\n+        assert!(tcx.sess.opts.debugging_opts.query_dep_graph,\n+                \"cannot use the `#[{}]` or `#[{}]` annotations \\\n+                 without supplying `-Z query-dep-graph`\",\n+                IF_THIS_CHANGED, THEN_THIS_WOULD_NEED);\n+    }\n+\n     // Check paths.\n     check_paths(tcx, &if_this_changed, &then_this_would_need);\n }\n \n-type SourceHashMap = FnvHashMap<InternedString,\n-                                FnvHashSet<(Span, DefId, DepNode)>>;\n-type TargetHashMap = FnvHashMap<InternedString,\n-                                FnvHashSet<(Span, InternedString, ast::NodeId, DepNode)>>;\n+type SourceHashMap =\n+    FnvHashMap<InternedString,\n+               FnvHashSet<(Span, DefId, DepNode<DefId>)>>;\n+type TargetHashMap =\n+    FnvHashMap<InternedString,\n+               FnvHashSet<(Span, InternedString, ast::NodeId, DepNode<DefId>)>>;\n \n struct IfThisChanged<'a, 'tcx:'a> {\n     tcx: &'a TyCtxt<'tcx>,\n@@ -124,34 +138,21 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                         }\n                     }\n                 }\n-                let dep_node_str = dep_node_interned.as_ref().map(|s| &**s);\n-                macro_rules! match_depnode_name {\n-                    ($input:expr, $def_id:expr, match { $($variant:ident,)* } else $y:expr) => {\n-                        match $input {\n-                            $(Some(stringify!($variant)) => DepNode::$variant($def_id),)*\n-                            _ => $y\n+                let dep_node = match dep_node_interned {\n+                    Some(ref n) => {\n+                        match DepNode::from_label_string(&n[..], def_id) {\n+                            Ok(n) => n,\n+                            Err(()) => {\n+                                self.tcx.sess.span_fatal(\n+                                    attr.span,\n+                                    &format!(\"unrecognized DepNode variant {:?}\", n));\n+                            }\n                         }\n                     }\n-                }\n-                let dep_node = match_depnode_name! {\n-                    dep_node_str, def_id, match {\n-                        CollectItem,\n-                        BorrowCheck,\n-                        TransCrateItem,\n-                        TypeckItemType,\n-                        TypeckItemBody,\n-                        ImplOrTraitItems,\n-                        ItemSignature,\n-                        FieldTy,\n-                        TraitItemDefIds,\n-                        InherentImpls,\n-                        ImplItems,\n-                        TraitImpls,\n-                        ReprHints,\n-                    } else {\n+                    None => {\n                         self.tcx.sess.span_fatal(\n                             attr.span,\n-                            &format!(\"unrecognized DepNode variant {:?}\", dep_node_str));\n+                            &format!(\"missing DepNode variant\"));\n                     }\n                 };\n                 let id = id.unwrap_or(InternedString::new(ID));\n@@ -194,7 +195,7 @@ fn check_paths(tcx: &TyCtxt,\n         };\n \n         for &(_, source_def_id, source_dep_node) in sources {\n-            let dependents = query.dependents(source_dep_node);\n+            let dependents = query.transitive_dependents(source_dep_node);\n             for &(target_span, ref target_pass, _, ref target_dep_node) in targets {\n                 if !dependents.contains(&target_dep_node) {\n                     tcx.sess.span_err(\n@@ -251,49 +252,52 @@ fn dump_graph(tcx: &TyCtxt) {\n     }\n }\n \n-pub struct GraphvizDepGraph(FnvHashSet<DepNode>, Vec<(DepNode, DepNode)>);\n+pub struct GraphvizDepGraph(FnvHashSet<DepNode<DefId>>,\n+                            Vec<(DepNode<DefId>, DepNode<DefId>)>);\n \n impl<'a, 'tcx> dot::GraphWalk<'a> for GraphvizDepGraph {\n-    type Node = DepNode;\n-    type Edge = (DepNode, DepNode);\n-    fn nodes(&self) -> dot::Nodes<DepNode> {\n+    type Node = DepNode<DefId>;\n+    type Edge = (DepNode<DefId>, DepNode<DefId>);\n+    fn nodes(&self) -> dot::Nodes<DepNode<DefId>> {\n         let nodes: Vec<_> = self.0.iter().cloned().collect();\n         nodes.into_cow()\n     }\n-    fn edges(&self) -> dot::Edges<(DepNode, DepNode)> {\n+    fn edges(&self) -> dot::Edges<(DepNode<DefId>, DepNode<DefId>)> {\n         self.1[..].into_cow()\n     }\n-    fn source(&self, edge: &(DepNode, DepNode)) -> DepNode {\n+    fn source(&self, edge: &(DepNode<DefId>, DepNode<DefId>)) -> DepNode<DefId> {\n         edge.0\n     }\n-    fn target(&self, edge: &(DepNode, DepNode)) -> DepNode {\n+    fn target(&self, edge: &(DepNode<DefId>, DepNode<DefId>)) -> DepNode<DefId> {\n         edge.1\n     }\n }\n \n impl<'a, 'tcx> dot::Labeller<'a> for GraphvizDepGraph {\n-    type Node = DepNode;\n-    type Edge = (DepNode, DepNode);\n+    type Node = DepNode<DefId>;\n+    type Edge = (DepNode<DefId>, DepNode<DefId>);\n     fn graph_id(&self) -> dot::Id {\n         dot::Id::new(\"DependencyGraph\").unwrap()\n     }\n-    fn node_id(&self, n: &DepNode) -> dot::Id {\n+    fn node_id(&self, n: &DepNode<DefId>) -> dot::Id {\n         let s: String =\n             format!(\"{:?}\", n).chars()\n                               .map(|c| if c == '_' || c.is_alphanumeric() { c } else { '_' })\n                               .collect();\n         debug!(\"n={:?} s={:?}\", n, s);\n         dot::Id::new(s).unwrap()\n     }\n-    fn node_label(&self, n: &DepNode) -> dot::LabelText {\n+    fn node_label(&self, n: &DepNode<DefId>) -> dot::LabelText {\n         dot::LabelText::label(format!(\"{:?}\", n))\n     }\n }\n \n // Given an optional filter like `\"x,y,z\"`, returns either `None` (no\n // filter) or the set of nodes whose labels contain all of those\n // substrings.\n-fn node_set(query: &DepGraphQuery, filter: &str) -> Option<FnvHashSet<DepNode>> {\n+fn node_set(query: &DepGraphQuery<DefId>, filter: &str)\n+            -> Option<FnvHashSet<DepNode<DefId>>>\n+{\n     debug!(\"node_set(filter={:?})\", filter);\n \n     if filter.trim().is_empty() {\n@@ -313,10 +317,10 @@ fn node_set(query: &DepGraphQuery, filter: &str) -> Option<FnvHashSet<DepNode>>\n         .collect())\n }\n \n-fn filter_nodes(query: &DepGraphQuery,\n-                sources: &Option<FnvHashSet<DepNode>>,\n-                targets: &Option<FnvHashSet<DepNode>>)\n-                -> FnvHashSet<DepNode>\n+fn filter_nodes(query: &DepGraphQuery<DefId>,\n+                sources: &Option<FnvHashSet<DepNode<DefId>>>,\n+                targets: &Option<FnvHashSet<DepNode<DefId>>>)\n+                -> FnvHashSet<DepNode<DefId>>\n {\n     if let &Some(ref sources) = sources {\n         if let &Some(ref targets) = targets {\n@@ -331,10 +335,10 @@ fn filter_nodes(query: &DepGraphQuery,\n     }\n }\n \n-fn walk_nodes(query: &DepGraphQuery,\n-              starts: &FnvHashSet<DepNode>,\n+fn walk_nodes(query: &DepGraphQuery<DefId>,\n+              starts: &FnvHashSet<DepNode<DefId>>,\n               direction: Direction)\n-              -> FnvHashSet<DepNode>\n+              -> FnvHashSet<DepNode<DefId>>\n {\n     let mut set = FnvHashSet();\n     for start in starts {\n@@ -355,10 +359,10 @@ fn walk_nodes(query: &DepGraphQuery,\n     set\n }\n \n-fn walk_between(query: &DepGraphQuery,\n-                sources: &FnvHashSet<DepNode>,\n-                targets: &FnvHashSet<DepNode>)\n-                -> FnvHashSet<DepNode>\n+fn walk_between(query: &DepGraphQuery<DefId>,\n+                sources: &FnvHashSet<DepNode<DefId>>,\n+                targets: &FnvHashSet<DepNode<DefId>>)\n+                -> FnvHashSet<DepNode<DefId>>\n {\n     // This is a bit tricky. We want to include a node only if it is:\n     // (a) reachable from a source and (b) will reach a target. And we\n@@ -386,7 +390,7 @@ fn walk_between(query: &DepGraphQuery,\n                 })\n                 .collect();\n \n-    fn recurse(query: &DepGraphQuery,\n+    fn recurse(query: &DepGraphQuery<DefId>,\n                node_states: &mut [State],\n                node: NodeIndex)\n                -> bool\n@@ -423,9 +427,9 @@ fn walk_between(query: &DepGraphQuery,\n     }\n }\n \n-fn filter_edges(query: &DepGraphQuery,\n-                nodes: &FnvHashSet<DepNode>)\n-                -> Vec<(DepNode, DepNode)>\n+fn filter_edges(query: &DepGraphQuery<DefId>,\n+                nodes: &FnvHashSet<DepNode<DefId>>)\n+                -> Vec<(DepNode<DefId>, DepNode<DefId>)>\n {\n     query.edges()\n          .into_iter()", "previous_filename": "src/librustc_trans/assert_dep_graph.rs"}, {"sha": "ab1c6f5ace176033428b114ec2480320883e8712", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "added", "additions": 422, "deletions": 0, "changes": 422, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,422 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Calculation of a Strict Version Hash for crates.  For a length\n+//! comment explaining the general idea, see `librustc/middle/svh.rs`.\n+\n+use std::hash::{Hash, SipHasher, Hasher};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::svh::Svh;\n+use rustc::ty;\n+use rustc::hir::intravisit::{self, Visitor};\n+\n+use self::svh_visitor::StrictVersionHashVisitor;\n+\n+pub trait SvhCalculate {\n+    /// Calculate the SVH for an entire krate.\n+    fn calculate_krate_hash(&self) -> Svh;\n+\n+    /// Calculate the SVH for a particular item.\n+    fn calculate_item_hash(&self, def_id: DefId) -> u64;\n+}\n+\n+impl<'tcx> SvhCalculate for ty::TyCtxt<'tcx> {\n+    fn calculate_krate_hash(&self) -> Svh {\n+        // FIXME (#14132): This is better than it used to be, but it still not\n+        // ideal. We now attempt to hash only the relevant portions of the\n+        // Crate AST as well as the top-level crate attributes. (However,\n+        // the hashing of the crate attributes should be double-checked\n+        // to ensure it is not incorporating implementation artifacts into\n+        // the hash that are not otherwise visible.)\n+\n+        let crate_disambiguator = self.sess.crate_disambiguator.get();\n+        let krate = self.map.krate();\n+\n+        // FIXME: this should use SHA1, not SipHash. SipHash is not built to\n+        //        avoid collisions.\n+        let mut state = SipHasher::new();\n+        debug!(\"state: {:?}\", state);\n+\n+        // FIXME(#32753) -- at (*) we `to_le` for endianness, but is\n+        // this enough, and does it matter anyway?\n+        \"crate_disambiguator\".hash(&mut state);\n+        crate_disambiguator.as_str().len().to_le().hash(&mut state); // (*)\n+        crate_disambiguator.as_str().hash(&mut state);\n+\n+        debug!(\"crate_disambiguator: {:?}\", crate_disambiguator.as_str());\n+        debug!(\"state: {:?}\", state);\n+\n+        {\n+            let mut visit = StrictVersionHashVisitor::new(&mut state, self);\n+            krate.visit_all_items(&mut visit);\n+        }\n+\n+        // FIXME (#14132): This hash is still sensitive to e.g. the\n+        // spans of the crate Attributes and their underlying\n+        // MetaItems; we should make ContentHashable impl for those\n+        // types and then use hash_content.  But, since all crate\n+        // attributes should appear near beginning of the file, it is\n+        // not such a big deal to be sensitive to their spans for now.\n+        //\n+        // We hash only the MetaItems instead of the entire Attribute\n+        // to avoid hashing the AttrId\n+        for attr in &krate.attrs {\n+            debug!(\"krate attr {:?}\", attr);\n+            attr.node.value.hash(&mut state);\n+        }\n+\n+        Svh::from_hash(state.finish())\n+    }\n+\n+    fn calculate_item_hash(&self, def_id: DefId) -> u64 {\n+        assert!(def_id.is_local());\n+\n+        let mut state = SipHasher::new();\n+\n+        {\n+            let mut visit = StrictVersionHashVisitor::new(&mut state, self);\n+            if def_id.index == CRATE_DEF_INDEX {\n+                // the crate root itself is not registered in the map\n+                // as an item, so we have to fetch it this way\n+                let krate = self.map.krate();\n+                intravisit::walk_crate(&mut visit, krate);\n+            } else {\n+                let node_id = self.map.as_local_node_id(def_id).unwrap();\n+                visit.visit_item(self.map.expect_item(node_id));\n+            }\n+        }\n+\n+        state.finish()\n+    }\n+}\n+\n+// FIXME (#14132): Even this SVH computation still has implementation\n+// artifacts: namely, the order of item declaration will affect the\n+// hash computation, but for many kinds of items the order of\n+// declaration should be irrelevant to the ABI.\n+\n+mod svh_visitor {\n+    pub use self::SawExprComponent::*;\n+    pub use self::SawStmtComponent::*;\n+    use self::SawAbiComponent::*;\n+    use syntax::ast::{self, Name, NodeId};\n+    use syntax::codemap::Span;\n+    use syntax::parse::token;\n+    use rustc::ty;\n+    use rustc::hir;\n+    use rustc::hir::*;\n+    use rustc::hir::intravisit as visit;\n+    use rustc::hir::intravisit::{Visitor, FnKind};\n+\n+    use std::hash::{Hash, SipHasher};\n+\n+    pub struct StrictVersionHashVisitor<'a, 'tcx: 'a> {\n+        pub tcx: &'a ty::TyCtxt<'tcx>,\n+        pub st: &'a mut SipHasher,\n+    }\n+\n+    impl<'a, 'tcx> StrictVersionHashVisitor<'a, 'tcx> {\n+        pub fn new(st: &'a mut SipHasher,\n+                   tcx: &'a ty::TyCtxt<'tcx>)\n+                   -> Self {\n+            StrictVersionHashVisitor { st: st, tcx: tcx }\n+        }\n+    }\n+\n+    // To off-load the bulk of the hash-computation on #[derive(Hash)],\n+    // we define a set of enums corresponding to the content that our\n+    // crate visitor will encounter as it traverses the ast.\n+    //\n+    // The important invariant is that all of the Saw*Component enums\n+    // do not carry any Spans, Names, or Idents.\n+    //\n+    // Not carrying any Names/Idents is the important fix for problem\n+    // noted on PR #13948: using the ident.name as the basis for a\n+    // hash leads to unstable SVH, because ident.name is just an index\n+    // into intern table (i.e. essentially a random address), not\n+    // computed from the name content.\n+    //\n+    // With the below enums, the SVH computation is not sensitive to\n+    // artifacts of how rustc was invoked nor of how the source code\n+    // was laid out.  (Or at least it is *less* sensitive.)\n+\n+    // This enum represents the different potential bits of code the\n+    // visitor could encounter that could affect the ABI for the crate,\n+    // and assigns each a distinct tag to feed into the hash computation.\n+    #[derive(Hash)]\n+    enum SawAbiComponent<'a> {\n+\n+        // FIXME (#14132): should we include (some function of)\n+        // ident.ctxt as well?\n+        SawIdent(token::InternedString),\n+        SawStructDef(token::InternedString),\n+\n+        SawLifetime(token::InternedString),\n+        SawLifetimeDef(token::InternedString),\n+\n+        SawMod,\n+        SawForeignItem,\n+        SawItem,\n+        SawDecl,\n+        SawTy,\n+        SawGenerics,\n+        SawFn,\n+        SawTraitItem,\n+        SawImplItem,\n+        SawStructField,\n+        SawVariant,\n+        SawExplicitSelf,\n+        SawPath,\n+        SawBlock,\n+        SawPat,\n+        SawLocal,\n+        SawArm,\n+        SawExpr(SawExprComponent<'a>),\n+        SawStmt(SawStmtComponent),\n+    }\n+\n+    /// SawExprComponent carries all of the information that we want\n+    /// to include in the hash that *won't* be covered by the\n+    /// subsequent recursive traversal of the expression's\n+    /// substructure by the visitor.\n+    ///\n+    /// We know every Expr_ variant is covered by a variant because\n+    /// `fn saw_expr` maps each to some case below.  Ensuring that\n+    /// each variant carries an appropriate payload has to be verified\n+    /// by hand.\n+    ///\n+    /// (However, getting that *exactly* right is not so important\n+    /// because the SVH is just a developer convenience; there is no\n+    /// guarantee of collision-freedom, hash collisions are just\n+    /// (hopefully) unlikely.)\n+    #[derive(Hash)]\n+    pub enum SawExprComponent<'a> {\n+\n+        SawExprLoop(Option<token::InternedString>),\n+        SawExprField(token::InternedString),\n+        SawExprTupField(usize),\n+        SawExprBreak(Option<token::InternedString>),\n+        SawExprAgain(Option<token::InternedString>),\n+\n+        SawExprBox,\n+        SawExprVec,\n+        SawExprCall,\n+        SawExprMethodCall,\n+        SawExprTup,\n+        SawExprBinary(hir::BinOp_),\n+        SawExprUnary(hir::UnOp),\n+        SawExprLit(ast::LitKind),\n+        SawExprCast,\n+        SawExprType,\n+        SawExprIf,\n+        SawExprWhile,\n+        SawExprMatch,\n+        SawExprClosure,\n+        SawExprBlock,\n+        SawExprAssign,\n+        SawExprAssignOp(hir::BinOp_),\n+        SawExprIndex,\n+        SawExprPath(Option<usize>),\n+        SawExprAddrOf(hir::Mutability),\n+        SawExprRet,\n+        SawExprInlineAsm(&'a hir::InlineAsm),\n+        SawExprStruct,\n+        SawExprRepeat,\n+    }\n+\n+    fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {\n+        match *node {\n+            ExprBox(..)              => SawExprBox,\n+            ExprVec(..)              => SawExprVec,\n+            ExprCall(..)             => SawExprCall,\n+            ExprMethodCall(..)       => SawExprMethodCall,\n+            ExprTup(..)              => SawExprTup,\n+            ExprBinary(op, _, _)     => SawExprBinary(op.node),\n+            ExprUnary(op, _)         => SawExprUnary(op),\n+            ExprLit(ref lit)         => SawExprLit(lit.node.clone()),\n+            ExprCast(..)             => SawExprCast,\n+            ExprType(..)             => SawExprType,\n+            ExprIf(..)               => SawExprIf,\n+            ExprWhile(..)            => SawExprWhile,\n+            ExprLoop(_, id)          => SawExprLoop(id.map(|id| id.name.as_str())),\n+            ExprMatch(..)            => SawExprMatch,\n+            ExprClosure(..)          => SawExprClosure,\n+            ExprBlock(..)            => SawExprBlock,\n+            ExprAssign(..)           => SawExprAssign,\n+            ExprAssignOp(op, _, _)   => SawExprAssignOp(op.node),\n+            ExprField(_, name)       => SawExprField(name.node.as_str()),\n+            ExprTupField(_, id)      => SawExprTupField(id.node),\n+            ExprIndex(..)            => SawExprIndex,\n+            ExprPath(ref qself, _)   => SawExprPath(qself.as_ref().map(|q| q.position)),\n+            ExprAddrOf(m, _)         => SawExprAddrOf(m),\n+            ExprBreak(id)            => SawExprBreak(id.map(|id| id.node.name.as_str())),\n+            ExprAgain(id)            => SawExprAgain(id.map(|id| id.node.name.as_str())),\n+            ExprRet(..)              => SawExprRet,\n+            ExprInlineAsm(ref a,_,_) => SawExprInlineAsm(a),\n+            ExprStruct(..)           => SawExprStruct,\n+            ExprRepeat(..)           => SawExprRepeat,\n+        }\n+    }\n+\n+    /// SawStmtComponent is analogous to SawExprComponent, but for statements.\n+    #[derive(Hash)]\n+    pub enum SawStmtComponent {\n+        SawStmtDecl,\n+        SawStmtExpr,\n+        SawStmtSemi,\n+    }\n+\n+    fn saw_stmt(node: &Stmt_) -> SawStmtComponent {\n+        match *node {\n+            StmtDecl(..) => SawStmtDecl,\n+            StmtExpr(..) => SawStmtExpr,\n+            StmtSemi(..) => SawStmtSemi,\n+        }\n+    }\n+\n+    impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n+        fn visit_nested_item(&mut self, item: ItemId) {\n+            debug!(\"visit_nested_item: {:?} st={:?}\", item, self.st);\n+            let def_path = self.tcx.map.def_path_from_id(item.id);\n+            def_path.hash(self.st);\n+        }\n+\n+        fn visit_variant_data(&mut self, s: &'a VariantData, name: Name,\n+                              g: &'a Generics, _: NodeId, _: Span) {\n+            SawStructDef(name.as_str()).hash(self.st);\n+            visit::walk_generics(self, g);\n+            visit::walk_struct_def(self, s)\n+        }\n+\n+        fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n+            SawVariant.hash(self.st);\n+            // walk_variant does not call walk_generics, so do it here.\n+            visit::walk_generics(self, g);\n+            visit::walk_variant(self, v, g, item_id)\n+        }\n+\n+        // All of the remaining methods just record (in the hash\n+        // SipHasher) that the visitor saw that particular variant\n+        // (with its payload), and continue walking as the default\n+        // visitor would.\n+        //\n+        // Some of the implementations have some notes as to how one\n+        // might try to make their SVH computation less discerning\n+        // (e.g. by incorporating reachability analysis).  But\n+        // currently all of their implementations are uniform and\n+        // uninteresting.\n+        //\n+        // (If you edit a method such that it deviates from the\n+        // pattern, please move that method up above this comment.)\n+\n+        fn visit_name(&mut self, _: Span, name: Name) {\n+            SawIdent(name.as_str()).hash(self.st);\n+        }\n+\n+        fn visit_lifetime(&mut self, l: &'a Lifetime) {\n+            SawLifetime(l.name.as_str()).hash(self.st);\n+        }\n+\n+        fn visit_lifetime_def(&mut self, l: &'a LifetimeDef) {\n+            SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n+        }\n+\n+        // We do recursively walk the bodies of functions/methods\n+        // (rather than omitting their bodies from the hash) since\n+        // monomorphization and cross-crate inlining generally implies\n+        // that a change to a crate body will require downstream\n+        // crates to be recompiled.\n+        fn visit_expr(&mut self, ex: &'a Expr) {\n+            SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n+        }\n+\n+        fn visit_stmt(&mut self, s: &'a Stmt) {\n+            SawStmt(saw_stmt(&s.node)).hash(self.st); visit::walk_stmt(self, s)\n+        }\n+\n+        fn visit_foreign_item(&mut self, i: &'a ForeignItem) {\n+            // FIXME (#14132) ideally we would incorporate privacy (or\n+            // perhaps reachability) somewhere here, so foreign items\n+            // that do not leak into downstream crates would not be\n+            // part of the ABI.\n+            SawForeignItem.hash(self.st); visit::walk_foreign_item(self, i)\n+        }\n+\n+        fn visit_item(&mut self, i: &'a Item) {\n+            debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n+            // FIXME (#14132) ideally would incorporate reachability\n+            // analysis somewhere here, so items that never leak into\n+            // downstream crates (e.g. via monomorphisation or\n+            // inlining) would not be part of the ABI.\n+            SawItem.hash(self.st); visit::walk_item(self, i)\n+        }\n+\n+        fn visit_mod(&mut self, m: &'a Mod, _s: Span, _n: NodeId) {\n+            SawMod.hash(self.st); visit::walk_mod(self, m)\n+        }\n+\n+        fn visit_decl(&mut self, d: &'a Decl) {\n+            SawDecl.hash(self.st); visit::walk_decl(self, d)\n+        }\n+\n+        fn visit_ty(&mut self, t: &'a Ty) {\n+            SawTy.hash(self.st); visit::walk_ty(self, t)\n+        }\n+\n+        fn visit_generics(&mut self, g: &'a Generics) {\n+            SawGenerics.hash(self.st); visit::walk_generics(self, g)\n+        }\n+\n+        fn visit_fn(&mut self, fk: FnKind<'a>, fd: &'a FnDecl,\n+                    b: &'a Block, s: Span, _: NodeId) {\n+            SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s)\n+        }\n+\n+        fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n+            SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n+        }\n+\n+        fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n+            SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n+        }\n+\n+        fn visit_struct_field(&mut self, s: &'a StructField) {\n+            SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n+        }\n+\n+        fn visit_explicit_self(&mut self, es: &'a ExplicitSelf) {\n+            SawExplicitSelf.hash(self.st); visit::walk_explicit_self(self, es)\n+        }\n+\n+        fn visit_path(&mut self, path: &'a Path, _: ast::NodeId) {\n+            SawPath.hash(self.st); visit::walk_path(self, path)\n+        }\n+\n+        fn visit_path_list_item(&mut self, prefix: &'a Path, item: &'a PathListItem) {\n+            SawPath.hash(self.st); visit::walk_path_list_item(self, prefix, item)\n+        }\n+\n+        fn visit_block(&mut self, b: &'a Block) {\n+            SawBlock.hash(self.st); visit::walk_block(self, b)\n+        }\n+\n+        fn visit_pat(&mut self, p: &'a Pat) {\n+            SawPat.hash(self.st); visit::walk_pat(self, p)\n+        }\n+\n+        fn visit_local(&mut self, l: &'a Local) {\n+            SawLocal.hash(self.st); visit::walk_local(self, l)\n+        }\n+\n+        fn visit_arm(&mut self, a: &'a Arm) {\n+            SawArm.hash(self.st); visit::walk_arm(self, a)\n+        }\n+    }\n+}"}, {"sha": "005146d91eae46d7862b639e9669eecdc954b5d6", "filename": "src/librustc_incremental/lib.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Support for serializing the dep-graph and reloading it.\n+\n+#![crate_name = \"rustc_incremental\"]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![cfg_attr(not(stage0), deny(warnings))]\n+\n+#![feature(rustc_private)]\n+#![feature(staged_api)]\n+\n+extern crate graphviz;\n+extern crate rbml;\n+#[macro_use] extern crate rustc;\n+extern crate rustc_data_structures;\n+extern crate serialize as rustc_serialize;\n+\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate syntax;\n+\n+mod assert_dep_graph;\n+mod calculate_svh;\n+mod persist;\n+\n+pub use assert_dep_graph::assert_dep_graph;\n+pub use calculate_svh::SvhCalculate;\n+pub use persist::load_dep_graph;\n+pub use persist::save_dep_graph;"}, {"sha": "95e09400016395e34fccef4ad3305e64b033c81b", "filename": "src/librustc_incremental/persist/README.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2FREADME.md?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,13 @@\n+This is the code to load/save the dependency graph. Loading is assumed\n+to run early in compilation, and saving at the very end. When loading,\n+the basic idea is that we will load up the dependency graph from the\n+previous compilation and compare the hashes of our HIR nodes to the\n+hashes of the HIR nodes that existed at the time. For each node whose\n+hash has changed, or which no longer exists in the new HIR, we can\n+remove that node from the old graph along with any nodes that depend\n+on it. Then we add what's left to the new graph (if any such nodes or\n+edges already exist, then there would be no effect, but since we do\n+this first thing, they do not).\n+\n+\n+"}, {"sha": "8be8bd60b23673e231ab842cc186e6a5437a4974", "filename": "src/librustc_incremental/persist/data.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The data that we will serialize and deserialize.\n+\n+use rustc::dep_graph::DepNode;\n+use rustc_serialize::{Decoder as RustcDecoder,\n+                      Encodable as RustcEncodable, Encoder as RustcEncoder};\n+\n+use super::directory::DefPathIndex;\n+\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedDepGraph {\n+    pub nodes: Vec<DepNode<DefPathIndex>>,\n+    pub edges: Vec<SerializedEdge>,\n+    pub hashes: Vec<SerializedHash>,\n+}\n+\n+pub type SerializedEdge = (DepNode<DefPathIndex>, DepNode<DefPathIndex>);\n+\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedHash {\n+    pub index: DefPathIndex,\n+\n+    /// the hash itself, computed by `calculate_item_hash`\n+    pub hash: u64,\n+}\n+"}, {"sha": "0d0054cadc692a08d07322b1cd14c9f39fd89814", "filename": "src/librustc_incremental/persist/directory.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,118 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code to convert a DefId into a DefPath (when serializing) and then\n+//! back again (when deserializing). Note that the new DefId\n+//! necessarily will not be the same as the old (and of course the\n+//! item might even be removed in the meantime).\n+\n+use rustc::dep_graph::DepNode;\n+use rustc::hir::map::DefPath;\n+use rustc::hir::def_id::DefId;\n+use rustc::ty;\n+use rustc::util::nodemap::DefIdMap;\n+use rustc_serialize::{Decoder as RustcDecoder,\n+                      Encodable as RustcEncodable, Encoder as RustcEncoder};\n+use std::fmt::{self, Debug};\n+\n+/// Index into the DefIdDirectory\n+#[derive(Copy, Clone, Debug, PartialOrd, Ord, Hash, PartialEq, Eq,\n+         RustcEncodable, RustcDecodable)]\n+pub struct DefPathIndex {\n+    index: u32\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct DefIdDirectory {\n+    // N.B. don't use Removable here because these def-ids are loaded\n+    // directly without remapping, so loading them should not fail.\n+    paths: Vec<DefPath>\n+}\n+\n+impl DefIdDirectory {\n+    pub fn new() -> DefIdDirectory {\n+        DefIdDirectory { paths: vec![] }\n+    }\n+\n+    pub fn retrace(&self, tcx: &ty::TyCtxt) -> RetracedDefIdDirectory {\n+        let ids = self.paths.iter()\n+                            .map(|path| tcx.map.retrace_path(path))\n+                            .collect();\n+        RetracedDefIdDirectory { ids: ids }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct RetracedDefIdDirectory {\n+    ids: Vec<Option<DefId>>\n+}\n+\n+impl RetracedDefIdDirectory {\n+    pub fn def_id(&self, index: DefPathIndex) -> Option<DefId> {\n+        self.ids[index.index as usize]\n+    }\n+\n+    pub fn map(&self, node: DepNode<DefPathIndex>) -> Option<DepNode<DefId>> {\n+        node.map_def(|&index| self.def_id(index))\n+    }\n+}\n+\n+pub struct DefIdDirectoryBuilder<'a,'tcx:'a> {\n+    tcx: &'a ty::TyCtxt<'tcx>,\n+    hash: DefIdMap<Option<DefPathIndex>>,\n+    directory: DefIdDirectory,\n+}\n+\n+impl<'a,'tcx> DefIdDirectoryBuilder<'a,'tcx> {\n+    pub fn new(tcx: &'a ty::TyCtxt<'tcx>) -> DefIdDirectoryBuilder<'a, 'tcx> {\n+        DefIdDirectoryBuilder {\n+            tcx: tcx,\n+            hash: DefIdMap(),\n+            directory: DefIdDirectory::new()\n+        }\n+    }\n+\n+    pub fn add(&mut self, def_id: DefId) -> Option<DefPathIndex> {\n+        if !def_id.is_local() {\n+            // FIXME(#32015) clarify story about cross-crate dep tracking\n+            return None;\n+        }\n+\n+        let tcx = self.tcx;\n+        let paths = &mut self.directory.paths;\n+        self.hash.entry(def_id)\n+                 .or_insert_with(|| {\n+                     let def_path = tcx.def_path(def_id);\n+                     if !def_path.is_local() {\n+                         return None;\n+                     }\n+                     let index = paths.len() as u32;\n+                     paths.push(def_path);\n+                     Some(DefPathIndex { index: index })\n+                 })\n+                 .clone()\n+    }\n+\n+    pub fn map(&mut self, node: DepNode<DefId>) -> Option<DepNode<DefPathIndex>> {\n+        node.map_def(|&def_id| self.add(def_id))\n+    }\n+\n+    pub fn into_directory(self) -> DefIdDirectory {\n+        self.directory\n+    }\n+}\n+\n+impl Debug for DefIdDirectory {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        fmt.debug_list()\n+           .entries(self.paths.iter().enumerate())\n+           .finish()\n+    }\n+}"}, {"sha": "35fa69520b67fb5014674bfdd7ae9863bc42cb59", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,151 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Debugging code to test the state of the dependency graph just\n+//! after it is loaded from disk. For each node marked with\n+//! `#[rustc_clean]` or `#[rustc_dirty]`, we will check that a\n+//! suitable node for that item either appears or does not appear in\n+//! the dep-graph, as appropriate:\n+//!\n+//! - `#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rev2\")]` if we are\n+//!   in `#[cfg(rev2)]`, then there MUST NOT be a node\n+//!   `DepNode::TypeckItemBody(X)` where `X` is the def-id of the\n+//!   current node.\n+//! - `#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rev2\")]` same as above,\n+//!   except that the node MUST exist.\n+//!\n+//! Errors are reported if we are in the suitable configuration but\n+//! the required condition is not met.\n+\n+use rustc::dep_graph::{DepGraphQuery, DepNode};\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::intravisit::Visitor;\n+use syntax::ast::{self, Attribute, MetaItem};\n+use syntax::attr::AttrMetaMethods;\n+use syntax::parse::token::InternedString;\n+use rustc::ty;\n+\n+const DIRTY: &'static str = \"rustc_dirty\";\n+const CLEAN: &'static str = \"rustc_clean\";\n+const LABEL: &'static str = \"label\";\n+const CFG: &'static str = \"cfg\";\n+\n+pub fn check_dirty_clean_annotations(tcx: &ty::TyCtxt) {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+    let query = tcx.dep_graph.query();\n+    let krate = tcx.map.krate();\n+    krate.visit_all_items(&mut DirtyCleanVisitor {\n+        tcx: tcx,\n+        query: &query,\n+    });\n+}\n+\n+pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n+    tcx: &'a ty::TyCtxt<'tcx>,\n+    query: &'a DepGraphQuery<DefId>,\n+}\n+\n+impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n+    fn expect_associated_value(&self, item: &MetaItem) -> InternedString {\n+        if let Some(value) = item.value_str() {\n+            value\n+        } else {\n+            self.tcx.sess.span_fatal(\n+                item.span,\n+                &format!(\"associated value expected for `{}`\", item.name()));\n+        }\n+    }\n+\n+    /// Given a `#[rustc_dirty]` or `#[rustc_clean]` attribute, scan\n+    /// for a `cfg=\"foo\"` attribute and check whether we have a cfg\n+    /// flag called `foo`.\n+    fn check_config(&self, attr: &ast::Attribute) -> bool {\n+        debug!(\"check_config(attr={:?})\", attr);\n+        let config = &self.tcx.map.krate().config;\n+        debug!(\"check_config: config={:?}\", config);\n+        for item in attr.meta_item_list().unwrap_or(&[]) {\n+            if item.check_name(CFG) {\n+                let value = self.expect_associated_value(item);\n+                debug!(\"check_config: searching for cfg {:?}\", value);\n+                for cfg in &config[..] {\n+                    if cfg.check_name(&value[..]) {\n+                        debug!(\"check_config: matched {:?}\", cfg);\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        debug!(\"check_config: no match found\");\n+        return false;\n+    }\n+\n+    fn dep_node(&self, attr: &Attribute, def_id: DefId) -> DepNode<DefId> {\n+        for item in attr.meta_item_list().unwrap_or(&[]) {\n+            if item.check_name(LABEL) {\n+                let value = self.expect_associated_value(item);\n+                match DepNode::from_label_string(&value[..], def_id) {\n+                    Ok(def_id) => return def_id,\n+                    Err(()) => {\n+                        self.tcx.sess.span_fatal(\n+                            item.span,\n+                            &format!(\"dep-node label `{}` not recognized\", value));\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.tcx.sess.span_fatal(attr.span, \"no `label` found\");\n+    }\n+\n+    fn dep_node_str(&self, dep_node: DepNode<DefId>) -> DepNode<String> {\n+        dep_node.map_def(|&def_id| Some(self.tcx.item_path_str(def_id))).unwrap()\n+    }\n+\n+    fn assert_dirty(&self, item: &hir::Item, dep_node: DepNode<DefId>) {\n+        debug!(\"assert_dirty({:?})\", dep_node);\n+\n+        if self.query.contains_node(&dep_node) {\n+            let dep_node_str = self.dep_node_str(dep_node);\n+            self.tcx.sess.span_err(\n+                item.span,\n+                &format!(\"`{:?}` found in dep graph, but should be dirty\", dep_node_str));\n+        }\n+    }\n+\n+    fn assert_clean(&self, item: &hir::Item, dep_node: DepNode<DefId>) {\n+        debug!(\"assert_clean({:?})\", dep_node);\n+\n+        if !self.query.contains_node(&dep_node) {\n+            let dep_node_str = self.dep_node_str(dep_node);\n+            self.tcx.sess.span_err(\n+                item.span,\n+                &format!(\"`{:?}` not found in dep graph, but should be clean\", dep_node_str));\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        let def_id = self.tcx.map.local_def_id(item.id);\n+        for attr in self.tcx.get_attrs(def_id).iter() {\n+            if attr.check_name(DIRTY) {\n+                if self.check_config(attr) {\n+                    self.assert_dirty(item, self.dep_node(attr, def_id));\n+                }\n+            } else if attr.check_name(CLEAN) {\n+                if self.check_config(attr) {\n+                    self.assert_clean(item, self.dep_node(attr, def_id));\n+                }\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "196c4511b0f1dc1d2f7b16d9f0b7947f78be15cd", "filename": "src/librustc_incremental/persist/load.rs", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,214 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Code to save/load the dep-graph from files.\n+\n+use calculate_svh::SvhCalculate;\n+use rbml::Error;\n+use rbml::opaque::Decoder;\n+use rustc::dep_graph::DepNode;\n+use rustc::hir::def_id::DefId;\n+use rustc::ty;\n+use rustc_data_structures::fnv::FnvHashSet;\n+use rustc_serialize::Decodable as RustcDecodable;\n+use std::io::Read;\n+use std::fs::File;\n+use std::path::Path;\n+\n+use super::data::*;\n+use super::directory::*;\n+use super::dirty_clean;\n+use super::util::*;\n+\n+type DirtyNodes = FnvHashSet<DepNode<DefId>>;\n+\n+type CleanEdges = Vec<(DepNode<DefId>, DepNode<DefId>)>;\n+\n+/// If we are in incremental mode, and a previous dep-graph exists,\n+/// then load up those nodes/edges that are still valid into the\n+/// dep-graph for this session. (This is assumed to be running very\n+/// early in compilation, before we've really done any work, but\n+/// actually it doesn't matter all that much.) See `README.md` for\n+/// more general overview.\n+pub fn load_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>) {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+\n+    if let Some(dep_graph) = dep_graph_path(tcx) {\n+        // FIXME(#32754) lock file?\n+        load_dep_graph_if_exists(tcx, &dep_graph);\n+        dirty_clean::check_dirty_clean_annotations(tcx);\n+    }\n+}\n+\n+pub fn load_dep_graph_if_exists<'tcx>(tcx: &ty::TyCtxt<'tcx>, path: &Path) {\n+    if !path.exists() {\n+        return;\n+    }\n+\n+    let mut data = vec![];\n+    match\n+        File::open(path)\n+        .and_then(|mut file| file.read_to_end(&mut data))\n+    {\n+        Ok(_) => { }\n+        Err(err) => {\n+            tcx.sess.err(\n+                &format!(\"could not load dep-graph from `{}`: {}\",\n+                         path.display(), err));\n+            return;\n+        }\n+    }\n+\n+    match decode_dep_graph(tcx, &data) {\n+        Ok(dirty) => dirty,\n+        Err(err) => {\n+            bug!(\"decoding error in dep-graph from `{}`: {}\", path.display(), err);\n+        }\n+    }\n+}\n+\n+pub fn decode_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>, data: &[u8])\n+                              -> Result<(), Error>\n+{\n+    // Deserialize the directory and dep-graph.\n+    let mut decoder = Decoder::new(data, 0);\n+    let directory = try!(DefIdDirectory::decode(&mut decoder));\n+    let serialized_dep_graph = try!(SerializedDepGraph::decode(&mut decoder));\n+\n+    debug!(\"decode_dep_graph: directory = {:#?}\", directory);\n+    debug!(\"decode_dep_graph: serialized_dep_graph = {:#?}\", serialized_dep_graph);\n+\n+    // Retrace the paths in the directory to find their current location (if any).\n+    let retraced = directory.retrace(tcx);\n+\n+    debug!(\"decode_dep_graph: retraced = {:#?}\", retraced);\n+\n+    // Compute the set of Hir nodes whose data has changed.\n+    let mut dirty_nodes =\n+        initial_dirty_nodes(tcx, &serialized_dep_graph.hashes, &retraced);\n+\n+    debug!(\"decode_dep_graph: initial dirty_nodes = {:#?}\", dirty_nodes);\n+\n+    // Find all DepNodes reachable from that core set. This loop\n+    // iterates repeatedly over the list of edges whose source is not\n+    // known to be dirty (`clean_edges`). If it finds an edge whose\n+    // source is dirty, it removes it from that list and adds the\n+    // target to `dirty_nodes`. It stops when it reaches a fixed\n+    // point.\n+    let clean_edges = compute_clean_edges(&serialized_dep_graph.edges,\n+                                          &retraced,\n+                                          &mut dirty_nodes);\n+\n+    // Add synthetic `foo->foo` edges for each clean node `foo` that\n+    // we had before. This is sort of a hack to create clean nodes in\n+    // the graph, since the existence of a node is a signal that the\n+    // work it represents need not be repeated.\n+    let clean_nodes =\n+        serialized_dep_graph.nodes\n+                            .iter()\n+                            .filter_map(|&node| retraced.map(node))\n+                            .filter(|node| !dirty_nodes.contains(node))\n+                            .map(|node| (node, node));\n+\n+    // Add nodes and edges that are not dirty into our main graph.\n+    let dep_graph = tcx.dep_graph.clone();\n+    for (source, target) in clean_edges.into_iter().chain(clean_nodes) {\n+        let _task = dep_graph.in_task(target);\n+        dep_graph.read(source);\n+\n+        debug!(\"decode_dep_graph: clean edge: {:?} -> {:?}\", source, target);\n+    }\n+\n+    Ok(())\n+}\n+\n+fn initial_dirty_nodes<'tcx>(tcx: &ty::TyCtxt<'tcx>,\n+                             hashed_items: &[SerializedHash],\n+                             retraced: &RetracedDefIdDirectory)\n+                             -> DirtyNodes {\n+    let mut items_removed = false;\n+    let mut dirty_nodes = FnvHashSet();\n+    for hashed_item in hashed_items {\n+        match retraced.def_id(hashed_item.index) {\n+            Some(def_id) => {\n+                // FIXME(#32753) -- should we use a distinct hash here\n+                let current_hash = tcx.calculate_item_hash(def_id);\n+                debug!(\"initial_dirty_nodes: hash of {:?} is {:?}, was {:?}\",\n+                       def_id, current_hash, hashed_item.hash);\n+                if current_hash != hashed_item.hash {\n+                    dirty_nodes.insert(DepNode::Hir(def_id));\n+                }\n+            }\n+            None => {\n+                items_removed = true;\n+            }\n+        }\n+    }\n+\n+    // If any of the items in the krate have changed, then we consider\n+    // the meta-node `Krate` to be dirty, since that means something\n+    // which (potentially) read the contents of every single item.\n+    if items_removed || !dirty_nodes.is_empty() {\n+        dirty_nodes.insert(DepNode::Krate);\n+    }\n+\n+    dirty_nodes\n+}\n+\n+fn compute_clean_edges(serialized_edges: &[(SerializedEdge)],\n+                       retraced: &RetracedDefIdDirectory,\n+                       dirty_nodes: &mut DirtyNodes)\n+                       -> CleanEdges {\n+    // Build up an initial list of edges. Include an edge (source,\n+    // target) if neither node has been removed. If the source has\n+    // been removed, add target to the list of dirty nodes.\n+    let mut clean_edges = Vec::with_capacity(serialized_edges.len());\n+    for &(serialized_source, serialized_target) in serialized_edges {\n+        if let Some(target) = retraced.map(serialized_target) {\n+            if let Some(source) = retraced.map(serialized_source) {\n+                clean_edges.push((source, target))\n+            } else {\n+                // source removed, target must be dirty\n+                dirty_nodes.insert(target);\n+            }\n+        } else {\n+            // target removed, ignore the edge\n+        }\n+    }\n+\n+    debug!(\"compute_clean_edges: dirty_nodes={:#?}\", dirty_nodes);\n+\n+    // Propagate dirty marks by iterating repeatedly over\n+    // `clean_edges`. If we find an edge `(source, target)` where\n+    // `source` is dirty, add `target` to the list of dirty nodes and\n+    // remove it. Keep doing this until we find no more dirty nodes.\n+    let mut previous_size = 0;\n+    while dirty_nodes.len() > previous_size {\n+        debug!(\"compute_clean_edges: previous_size={}\", previous_size);\n+        previous_size = dirty_nodes.len();\n+        let mut i = 0;\n+        while i < clean_edges.len() {\n+            if dirty_nodes.contains(&clean_edges[i].0) {\n+                let (source, target) = clean_edges.swap_remove(i);\n+                debug!(\"compute_clean_edges: dirty source {:?} -> {:?}\",\n+                       source, target);\n+                dirty_nodes.insert(target);\n+            } else if dirty_nodes.contains(&clean_edges[i].1) {\n+                let (source, target) = clean_edges.swap_remove(i);\n+                debug!(\"compute_clean_edges: dirty target {:?} -> {:?}\",\n+                       source, target);\n+            } else {\n+                i += 1;\n+            }\n+        }\n+    }\n+\n+    clean_edges\n+}"}, {"sha": "8d04fd30a1920e0bab4a74e4345bfbe6aa4e06f8", "filename": "src/librustc_incremental/persist/mod.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! When in incremental mode, this pass dumps out the dependency graph\n+//! into the given directory. At the same time, it also hashes the\n+//! various HIR nodes.\n+\n+mod data;\n+mod directory;\n+mod dirty_clean;\n+mod load;\n+mod save;\n+mod util;\n+\n+pub use self::load::load_dep_graph;\n+pub use self::save::save_dep_graph;"}, {"sha": "d88f9e42b08ce12a7c136095d6a3d3deadccf5f2", "filename": "src/librustc_incremental/persist/save.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,136 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use calculate_svh::SvhCalculate;\n+use rbml::opaque::Encoder;\n+use rustc::dep_graph::DepNode;\n+use rustc::ty;\n+use rustc_serialize::{Encodable as RustcEncodable};\n+use std::io::{self, Cursor, Write};\n+use std::fs::{self, File};\n+\n+use super::data::*;\n+use super::directory::*;\n+use super::util::*;\n+\n+pub fn save_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>) {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+\n+    if let Some(dep_graph) = dep_graph_path(tcx) {\n+        // FIXME(#32754) lock file?\n+\n+        // delete the old dep-graph, if any\n+        if dep_graph.exists() {\n+            match fs::remove_file(&dep_graph) {\n+                Ok(()) => { }\n+                Err(err) => {\n+                    tcx.sess.err(\n+                        &format!(\"unable to delete old dep-graph at `{}`: {}\",\n+                                 dep_graph.display(), err));\n+                    return;\n+                }\n+            }\n+        }\n+\n+        // generate the data in a memory buffer\n+        let mut wr = Cursor::new(Vec::new());\n+        match encode_dep_graph(tcx, &mut Encoder::new(&mut wr)) {\n+            Ok(()) => { }\n+            Err(err) => {\n+                tcx.sess.err(\n+                    &format!(\"could not encode dep-graph to `{}`: {}\",\n+                             dep_graph.display(), err));\n+                return;\n+            }\n+        }\n+\n+        // write the data out\n+        let data = wr.into_inner();\n+        match\n+            File::create(&dep_graph)\n+            .and_then(|mut file| file.write_all(&data))\n+        {\n+            Ok(_) => { }\n+            Err(err) => {\n+                tcx.sess.err(\n+                    &format!(\"failed to write dep-graph to `{}`: {}\",\n+                             dep_graph.display(), err));\n+                return;\n+            }\n+        }\n+    }\n+}\n+\n+pub fn encode_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>,\n+                              encoder: &mut Encoder)\n+                              -> io::Result<()>\n+{\n+    // Here we take advantage of how RBML allows us to skip around\n+    // and encode the depgraph as a two-part structure:\n+    //\n+    // ```\n+    // <dep-graph>[SerializedDepGraph]</dep-graph> // tag 0\n+    // <directory>[DefIdDirectory]</directory>     // tag 1\n+    // ```\n+    //\n+    // Then later we can load the directory by skipping to find tag 1.\n+\n+    let query = tcx.dep_graph.query();\n+\n+    let mut builder = DefIdDirectoryBuilder::new(tcx);\n+\n+    // Create hashes for things we can persist.\n+    let hashes =\n+        query.nodes()\n+             .into_iter()\n+             .filter_map(|dep_node| match dep_node {\n+                 DepNode::Hir(def_id) => {\n+                     assert!(def_id.is_local());\n+                     builder.add(def_id)\n+                            .map(|index| {\n+                                // FIXME(#32753) -- should we use a distinct hash here\n+                                let hash = tcx.calculate_item_hash(def_id);\n+                                SerializedHash { index: index, hash: hash }\n+                            })\n+                 }\n+                 _ => None\n+             })\n+             .collect();\n+\n+    // Create the serialized dep-graph, dropping nodes that are\n+    // from other crates or from inlined items.\n+    //\n+    // FIXME(#32015) fix handling of other crates\n+    let graph = SerializedDepGraph {\n+        nodes: query.nodes().into_iter()\n+                            .flat_map(|node| builder.map(node))\n+                            .collect(),\n+        edges: query.edges().into_iter()\n+                            .flat_map(|(source_node, target_node)| {\n+                                builder.map(source_node)\n+                                       .and_then(|source| {\n+                                           builder.map(target_node)\n+                                                  .map(|target| (source, target))\n+                                       })\n+                            })\n+                            .collect(),\n+        hashes: hashes,\n+    };\n+\n+    debug!(\"graph = {:#?}\", graph);\n+\n+    // Encode the directory and then the graph data.\n+    let directory = builder.into_directory();\n+    try!(directory.encode(encoder));\n+    try!(graph.encode(encoder));\n+\n+    Ok(())\n+}\n+"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/librustc_incremental/persist/serialize.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fserialize.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788"}, {"sha": "9b4e5997efe42c3dca6f12daa8ea395840ea6622", "filename": "src/librustc_incremental/persist/util.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Futil.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty;\n+use std::fs;\n+use std::path::PathBuf;\n+\n+pub fn dep_graph_path<'tcx>(tcx: &ty::TyCtxt<'tcx>) -> Option<PathBuf> {\n+    // For now, just save/load dep-graph from\n+    // directory/dep_graph.rbml\n+    tcx.sess.opts.incremental.as_ref().and_then(|incr_dir| {\n+        match fs::create_dir_all(&incr_dir){\n+            Ok(()) => {}\n+            Err(err) => {\n+                tcx.sess.err(\n+                    &format!(\"could not create the directory `{}`: {}\",\n+                             incr_dir.display(), err));\n+                return None;\n+            }\n+        }\n+\n+        Some(incr_dir.join(\"dep_graph.rbml\"))\n+    })\n+}\n+"}, {"sha": "6a634d061fa92f86778d3d022dca31e1ebda7cd4", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -1242,7 +1242,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n \n     reader::tagged_docs(depsdoc, tag_crate_dep).enumerate().map(|(crate_num, depdoc)| {\n         let name = docstr(depdoc, tag_crate_dep_crate_name);\n-        let hash = Svh::new(&docstr(depdoc, tag_crate_dep_hash));\n+        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash));\n         let doc = reader::get_doc(depdoc, tag_crate_dep_explicitly_linked);\n         let explicitly_linked = reader::doc_as_u8(doc) != 0;\n         CrateDep {\n@@ -1266,14 +1266,14 @@ fn list_crate_deps(data: &[u8], out: &mut io::Write) -> io::Result<()> {\n pub fn maybe_get_crate_hash(data: &[u8]) -> Option<Svh> {\n     let cratedoc = rbml::Doc::new(data);\n     reader::maybe_get_doc(cratedoc, tag_crate_hash).map(|doc| {\n-        Svh::new(doc.as_str_slice())\n+        Svh::new(doc.as_str_slice().to_string())\n     })\n }\n \n pub fn get_crate_hash(data: &[u8]) -> Svh {\n     let cratedoc = rbml::Doc::new(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n-    Svh::new(hashdoc.as_str_slice())\n+    Svh::new(hashdoc.as_str_slice().to_string())\n }\n \n pub fn maybe_get_crate_name(data: &[u8]) -> Option<&str> {"}, {"sha": "11ac1fa8f82a18e30a7116198afc42695a4d7838", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -584,7 +584,8 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n             // broken MIR, so try not to report duplicate errors.\n             return;\n         }\n-        let _task = tcx.dep_graph.in_task(DepNode::MirTypeck(id));\n+        let def_id = tcx.map.local_def_id(id);\n+        let _task = tcx.dep_graph.in_task(DepNode::MirTypeck(def_id));\n         let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n         let infcx = infer::new_infer_ctxt(tcx,\n                                           &tcx.tables,"}, {"sha": "ccb430fbb782fe3d8e777319e6645177ba610f8b", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -18,6 +18,7 @@ rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }"}, {"sha": "4e77b2bc06940b78c1312addb2edd098b07f62bd", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -13,7 +13,6 @@ use super::linker::{Linker, GnuLinker, MsvcLinker};\n use super::rpath::RPathConfig;\n use super::rpath;\n use super::msvc;\n-use super::svh::Svh;\n use session::config;\n use session::config::NoDebugInfo;\n use session::config::{OutputFilenames, Input, OutputType};\n@@ -26,8 +25,10 @@ use middle::dependency_format::Linkage;\n use CrateTranslation;\n use util::common::time;\n use util::fs::fix_windows_verbatim_for_gcc;\n+use rustc::ty::TyCtxt;\n use rustc_back::tempdir::TempDir;\n \n+use rustc_incremental::SvhCalculate;\n use std::ascii;\n use std::char;\n use std::env;\n@@ -43,8 +44,6 @@ use syntax::ast;\n use syntax::codemap::Span;\n use syntax::attr::AttrMetaMethods;\n \n-use rustc::hir;\n-\n // RLIB LLVM-BYTECODE OBJECT LAYOUT\n // Version 1\n // Bytes    Data\n@@ -122,15 +121,15 @@ pub fn find_crate_name(sess: Option<&Session>,\n     }\n \n     \"rust_out\".to_string()\n+\n }\n \n-pub fn build_link_meta(sess: &Session,\n-                       krate: &hir::Crate,\n+pub fn build_link_meta(tcx: &TyCtxt,\n                        name: &str)\n                        -> LinkMeta {\n     let r = LinkMeta {\n         crate_name: name.to_owned(),\n-        crate_hash: Svh::calculate(&sess.crate_disambiguator.get().as_str(), krate),\n+        crate_hash: tcx.calculate_krate_hash(),\n     };\n     info!(\"{:?}\", r);\n     return r;"}, {"sha": "17230eff6e639aa382f89c98d252a7a99950a83e", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -54,7 +54,6 @@ use session::Session;\n use _match;\n use abi::{self, Abi, FnType};\n use adt;\n-use assert_dep_graph;\n use attributes;\n use build::*;\n use builder::{Builder, noname};\n@@ -2730,7 +2729,7 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n     }\n \n-    let link_meta = link::build_link_meta(&tcx.sess, krate, name);\n+    let link_meta = link::build_link_meta(&tcx, name);\n \n     let codegen_units = tcx.sess.opts.cg.codegen_units;\n     let shared_ccx = SharedCrateContext::new(&link_meta.crate_name,\n@@ -2856,8 +2855,6 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n     };\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n-    assert_dep_graph::assert_dep_graph(tcx);\n-\n     CrateTranslation {\n         modules: modules,\n         metadata_module: metadata_module,"}, {"sha": "c1802a5f0a9c2c3114ce887353dad818bd4968e3", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -179,7 +179,7 @@ pub struct TraitSelectionCache<'tcx> {\n impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n     type Key = ty::PolyTraitRef<'tcx>;\n     type Value = traits::Vtable<'tcx, ()>;\n-    fn to_dep_node(key: &ty::PolyTraitRef<'tcx>) -> DepNode {\n+    fn to_dep_node(key: &ty::PolyTraitRef<'tcx>) -> DepNode<DefId> {\n         ty::tls::with(|tcx| {\n             let lifted_key = tcx.lift(key).unwrap();\n             lifted_key.to_poly_trait_predicate().dep_node()"}, {"sha": "cb421b6be472b077a3be091b2d1030cb6a002f84", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -46,6 +46,7 @@ extern crate libc;\n #[macro_use] extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n+extern crate rustc_incremental;\n pub extern crate rustc_llvm as llvm;\n extern crate rustc_mir;\n extern crate rustc_platform_intrinsics as intrinsics;\n@@ -85,7 +86,6 @@ mod macros;\n mod abi;\n mod adt;\n mod asm;\n-mod assert_dep_graph;\n mod attributes;\n mod base;\n mod basic_block;"}, {"sha": "f08d3c685bb55a48e1ad02af0fbdf069d8b60708", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -356,6 +356,14 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                        \"the `#[rustc_if_this_changed]` attribute \\\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\")),\n+    (\"rustc_dirty\", Whitelisted, Gated(\"rustc_attrs\",\n+                                       \"the `#[rustc_dirty]` attribute \\\n+                                        is just used for rustc unit tests \\\n+                                        and will never be stable\")),\n+    (\"rustc_clean\", Whitelisted, Gated(\"rustc_attrs\",\n+                                       \"the `#[rustc_clean]` attribute \\\n+                                        is just used for rustc unit tests \\\n+                                        and will never be stable\")),\n     (\"rustc_symbol_name\", Whitelisted, Gated(\"rustc_attrs\",\n                                        \"internal rustc attributes will never be stable\")),\n     (\"rustc_item_path\", Whitelisted, Gated(\"rustc_attrs\","}, {"sha": "b56be9e5683a851a5576eb93152faf1eba7e0e91", "filename": "src/test/compile-fail/dep-graph-assoc-type-trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fcompile-fail%2Fdep-graph-assoc-type-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fcompile-fail%2Fdep-graph-assoc-type-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-assoc-type-trans.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -11,7 +11,7 @@\n // Test that when a trait impl changes, fns whose body uses that trait\n // must also be recompiled.\n \n-// compile-flags: -Z incr-comp\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n #![allow(warnings)]"}, {"sha": "0d6954ab9df6229e5390d647b1c0aabf62fc39c1", "filename": "src/test/compile-fail/dep-graph-caller-callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fcompile-fail%2Fdep-graph-caller-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fcompile-fail%2Fdep-graph-caller-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-caller-callee.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -11,7 +11,7 @@\n // Test that immediate callers have to change when callee changes, but\n // not callers' callers.\n \n-// compile-flags: -Z incr-comp\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n #![allow(dead_code)]"}, {"sha": "235fc5051d780f78a50b91a8c06bfd8c063acbb8", "filename": "src/test/compile-fail/dep-graph-struct-signature.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -11,7 +11,7 @@\n // Test cases where a changing struct appears in the signature of fns\n // and methods.\n \n-// compile-flags: -Z incr-comp\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n #![allow(dead_code)]"}, {"sha": "1afecd80ff5ad05309bc0b9c88b04cc43aff5c23", "filename": "src/test/compile-fail/dep-graph-trait-impl-two-traits-same-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits-same-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits-same-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits-same-method.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -11,7 +11,7 @@\n // Test that adding an impl to a trait `Foo` DOES affect functions\n // that only use `Bar` if they have methods in common.\n \n-// compile-flags: -Z incr-comp\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n #![allow(dead_code)]"}, {"sha": "2ec7573cb81dc133e32acfcbd7281fe53247d394", "filename": "src/test/compile-fail/dep-graph-trait-impl-two-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -11,7 +11,7 @@\n // Test that adding an impl to a trait `Foo` does not affect functions\n // that only use `Bar`, so long as they do not have methods in common.\n \n-// compile-flags: -Z incr-comp\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n #![allow(warnings)]"}, {"sha": "d87d7a6be1c280f65018f3bbbecec38514bd6a8e", "filename": "src/test/compile-fail/dep-graph-trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -11,7 +11,7 @@\n // Test that when a trait impl changes, fns whose body uses that trait\n // must also be recompiled.\n \n-// compile-flags: -Z incr-comp\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n #![allow(warnings)]"}, {"sha": "079f2b52fd462a21c1107363fdca4636b34d6736", "filename": "src/test/compile-fail/dep-graph-unrelated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fcompile-fail%2Fdep-graph-unrelated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fcompile-fail%2Fdep-graph-unrelated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-unrelated.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -10,7 +10,7 @@\n \n // Test that two unrelated functions have no trans dependency.\n \n-// compile-flags: -Z incr-comp\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n #![allow(dead_code)]"}, {"sha": "9a3097831c5631712d47788d7a6a8160c7c3f40e", "filename": "src/test/incremental/dirty_clean.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fincremental%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fincremental%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fdirty_clean.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: rpass1 cfail2\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+\n+// Sanity check for the dirty-clean system. Give the opposite\n+// annotations that we expect to see, so that we check that errors are\n+// reported.\n+\n+fn main() { }\n+\n+mod x {\n+    #[cfg(rpass1)]\n+    pub fn x() -> usize {\n+        22\n+    }\n+\n+    #[cfg(cfail2)]\n+    pub fn x() -> u32 {\n+        22\n+    }\n+}\n+\n+mod y {\n+    use x;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"TransCrateItem\", cfg=\"cfail2\")]\n+    pub fn y() {\n+        //[cfail2]~^ ERROR `TypeckItemBody(\"y::y\")` not found in dep graph, but should be clean\n+        //[cfail2]~| ERROR `TransCrateItem(\"y::y\")` not found in dep graph, but should be clean\n+        x::x();\n+    }\n+}\n+\n+mod z {\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"TransCrateItem\", cfg=\"cfail2\")]\n+    pub fn z() {\n+        //[cfail2]~^ ERROR `TypeckItemBody(\"z::z\")` found in dep graph, but should be dirty\n+        //[cfail2]~| ERROR `TransCrateItem(\"z::z\")` found in dep graph, but should be dirty\n+    }\n+}"}, {"sha": "f98ae188bad9f2647bfb6aeb066caac4eaa01ca2", "filename": "src/test/incremental/hello_world.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fincremental%2Fhello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fincremental%2Fhello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhello_world.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: rpass1 rpass2\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+\n+fn main() { }\n+\n+mod x {\n+    #[cfg(rpass1)]\n+    pub fn x() -> i32 {\n+        1\n+    }\n+\n+    #[cfg(rpass2)]\n+    pub fn x() -> i32 {\n+        2\n+    }\n+}\n+\n+mod y {\n+    use x;\n+\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn y() {\n+        x::x();\n+    }\n+}\n+\n+mod z {\n+    use y;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn z() {\n+        y::y();\n+    }\n+}"}, {"sha": "0aa728b94dda9634e818fdc6909f14a72454d52c", "filename": "src/test/incremental/string_constant.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fincremental%2Fstring_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Fincremental%2Fstring_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstring_constant.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: rpass1 rpass2\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+\n+// Here the only thing which changes is the string constant in `x`.\n+// Therefore, the compiler deduces (correctly) that typeck is not\n+// needed even for callers of `x`.\n+//\n+// It is not entirely clear why `TransCrateItem` invalidates `y` and\n+// `z`, actually, I think it's because of the structure of\n+// trans. -nmatsakis\n+\n+fn main() { }\n+\n+mod x {\n+    #[cfg(rpass1)]\n+    pub fn x() {\n+        println!(\"1\");\n+    }\n+\n+    #[cfg(rpass2)]\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_dirty(label=\"TransCrateItem\", cfg=\"rpass2\")]\n+    pub fn x() {\n+        println!(\"2\");\n+    }\n+}\n+\n+mod y {\n+    use x;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TransCrateItem\", cfg=\"rpass2\")]\n+    pub fn y() {\n+        x::x();\n+    }\n+}\n+\n+mod z {\n+    use y;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TransCrateItem\", cfg=\"rpass2\")]\n+    pub fn z() {\n+        y::y();\n+    }\n+}"}, {"sha": "12cc475f121f6fbe0608ee73c8e8c9e0fae53733", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7979dd6089ee5cba39cfbe6e880a3edeb7fff788/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "patch": "@@ -239,7 +239,7 @@ fn compile_program(input: &str, sysroot: PathBuf)\n \n         let krate = driver::assign_node_ids(&sess, krate);\n         let lcx = LoweringContext::new(&sess, Some(&krate));\n-        let dep_graph = DepGraph::new(sess.opts.build_dep_graph);\n+        let dep_graph = DepGraph::new(sess.opts.build_dep_graph());\n         let mut hir_forest = ast_map::Forest::new(lower_crate(&lcx, &krate), dep_graph);\n         let arenas = ty::CtxtArenas::new();\n         let ast_map = driver::make_map(&sess, &mut hir_forest);"}]}