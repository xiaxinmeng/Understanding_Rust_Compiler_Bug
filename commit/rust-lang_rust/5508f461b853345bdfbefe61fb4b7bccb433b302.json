{"sha": "5508f461b853345bdfbefe61fb4b7bccb433b302", "node_id": "C_kwDOAAsO6NoAKDU1MDhmNDYxYjg1MzM0NWJkZmJlZmU2MWZiNGI3YmNjYjQzM2IzMDI", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-06T18:37:37Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-03-16T17:49:19Z"}, "message": "Use `DroplessArena` when allocating `ResolvedPat`s\nFix tuple handling in `match_same_arms`", "tree": {"sha": "6c6dff3acb98b9447e772e0139015ccbefda15a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c6dff3acb98b9447e772e0139015ccbefda15a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5508f461b853345bdfbefe61fb4b7bccb433b302", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5508f461b853345bdfbefe61fb4b7bccb433b302", "html_url": "https://github.com/rust-lang/rust/commit/5508f461b853345bdfbefe61fb4b7bccb433b302", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5508f461b853345bdfbefe61fb4b7bccb433b302/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b37317b028cd0d4b60126e0bcf1402e60018f891", "url": "https://api.github.com/repos/rust-lang/rust/commits/b37317b028cd0d4b60126e0bcf1402e60018f891", "html_url": "https://github.com/rust-lang/rust/commit/b37317b028cd0d4b60126e0bcf1402e60018f891"}], "stats": {"total": 145, "additions": 86, "deletions": 59}, "files": [{"sha": "703aa458f44e5a074ac0cd3a1cc33b1573444223", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5508f461b853345bdfbefe61fb4b7bccb433b302/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5508f461b853345bdfbefe61fb4b7bccb433b302/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=5508f461b853345bdfbefe61fb4b7bccb433b302", "patch": "@@ -637,12 +637,6 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                 loop {\n                     match parser.parse_item(ForceCollect::No) {\n                         Ok(Some(item)) => match &item.kind {\n-                            // Tests with one of these items are ignored\n-                            ItemKind::Static(..)\n-                            | ItemKind::Const(..)\n-                            | ItemKind::ExternCrate(..)\n-                            | ItemKind::ForeignMod(..) => return false,\n-                            // We found a main function ...\n                             ItemKind::Fn(box Fn {\n                                 sig, body: Some(block), ..\n                             }) if item.ident.name == sym::main => {\n@@ -661,8 +655,13 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                                     return false;\n                                 }\n                             },\n-                            // Another function was found; this case is ignored too\n-                            ItemKind::Fn(..) => return false,\n+                            // Tests with one of these items are ignored\n+                            ItemKind::Static(..)\n+                            | ItemKind::Const(..)\n+                            | ItemKind::ExternCrate(..)\n+                            | ItemKind::ForeignMod(..)\n+                            // Another function was found; this case is ignored\n+                            | ItemKind::Fn(..) => return false,\n                             _ => {},\n                         },\n                         Ok(None) => break,"}, {"sha": "f2a07999144482e48231ba3e4bf19edbf4d71d77", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5508f461b853345bdfbefe61fb4b7bccb433b302/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5508f461b853345bdfbefe61fb4b7bccb433b302/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=5508f461b853345bdfbefe61fb4b7bccb433b302", "patch": "@@ -23,6 +23,7 @@\n \n // FIXME: switch to something more ergonomic here, once available.\n // (Currently there is no way to opt into sysroot crates without `extern crate`.)\n+extern crate rustc_arena;\n extern crate rustc_ast;\n extern crate rustc_ast_pretty;\n extern crate rustc_attr;"}, {"sha": "0afac347d0805be8190341cd661026513622fed6", "filename": "clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 78, "deletions": 51, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/5508f461b853345bdfbefe61fb4b7bccb433b302/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5508f461b853345bdfbefe61fb4b7bccb433b302/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=5508f461b853345bdfbefe61fb4b7bccb433b302", "patch": "@@ -1,10 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::{path_to_local, search_same, SpanlessEq, SpanlessHash};\n+use core::iter;\n+use rustc_arena::DroplessArena;\n use rustc_ast::ast::LitKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{Arm, Expr, ExprKind, HirId, HirIdMap, HirIdSet, Pat, PatKind, RangeEnd};\n use rustc_lint::LateContext;\n+use rustc_middle::ty;\n use rustc_span::Symbol;\n use std::collections::hash_map::Entry;\n \n@@ -17,7 +20,8 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n         h.finish()\n     };\n \n-    let resolved_pats: Vec<_> = arms.iter().map(|a| ResolvedPat::from_pat(cx, a.pat)).collect();\n+    let arena = DroplessArena::default();\n+    let resolved_pats: Vec<_> = arms.iter().map(|a| ResolvedPat::from_pat(cx, &arena, a.pat)).collect();\n \n     // The furthast forwards a pattern can move without semantic changes\n     let forwards_blocking_idxs: Vec<_> = resolved_pats\n@@ -128,21 +132,22 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n     }\n }\n \n-#[derive(Debug)]\n-enum ResolvedPat<'hir> {\n+#[derive(Clone, Copy)]\n+enum ResolvedPat<'hir, 'arena> {\n     Wild,\n-    Struct(Option<DefId>, Vec<(Symbol, ResolvedPat<'hir>)>),\n-    Sequence(Option<DefId>, Vec<ResolvedPat<'hir>>, Option<usize>),\n-    Or(Vec<ResolvedPat<'hir>>),\n+    Struct(Option<DefId>, &'arena [(Symbol, Self)]),\n+    Tuple(Option<DefId>, &'arena [Self]),\n+    Or(&'arena [Self]),\n     Path(Option<DefId>),\n     LitStr(Symbol),\n     LitBytes(&'hir [u8]),\n     LitInt(u128),\n     LitBool(bool),\n     Range(PatRange),\n+    Slice(&'arena [Self], &'arena [Self], bool),\n }\n \n-#[derive(Debug)]\n+#[derive(Clone, Copy)]\n struct PatRange {\n     start: u128,\n     end: u128,\n@@ -177,28 +182,66 @@ impl PatRange {\n     }\n }\n \n-impl<'hir> ResolvedPat<'hir> {\n-    fn from_pat(cx: &LateContext<'_>, pat: &'hir Pat<'_>) -> Self {\n+#[allow(clippy::similar_names)]\n+impl<'hir, 'arena> ResolvedPat<'hir, 'arena> {\n+    #[allow(clippy::too_many_lines)]\n+    fn from_pat(cx: &LateContext<'_>, arena: &'arena DroplessArena, pat: &'hir Pat<'_>) -> Self {\n         match pat.kind {\n             PatKind::Wild | PatKind::Binding(.., None) => Self::Wild,\n-            PatKind::Binding(.., Some(pat)) | PatKind::Box(pat) | PatKind::Ref(pat, _) => Self::from_pat(cx, pat),\n+            PatKind::Binding(.., Some(pat)) | PatKind::Box(pat) | PatKind::Ref(pat, _) => {\n+                Self::from_pat(cx, arena, pat)\n+            },\n             PatKind::Struct(ref path, fields, _) => {\n-                let mut fields: Vec<_> = fields\n-                    .iter()\n-                    .map(|f| (f.ident.name, Self::from_pat(cx, f.pat)))\n-                    .collect();\n+                let fields =\n+                    arena.alloc_from_iter(fields.iter().map(|f| (f.ident.name, Self::from_pat(cx, arena, f.pat))));\n                 fields.sort_by_key(|&(name, _)| name);\n                 Self::Struct(cx.qpath_res(path, pat.hir_id).opt_def_id(), fields)\n             },\n-            PatKind::TupleStruct(ref path, pats, wild_idx) => Self::Sequence(\n-                cx.qpath_res(path, pat.hir_id).opt_def_id(),\n-                pats.iter().map(|pat| Self::from_pat(cx, pat)).collect(),\n-                wild_idx,\n-            ),\n-            PatKind::Or(pats) => Self::Or(pats.iter().map(|pat| Self::from_pat(cx, pat)).collect()),\n+            PatKind::TupleStruct(ref path, pats, wild_idx) => {\n+                let adt = match cx.typeck_results().pat_ty(pat).ty_adt_def() {\n+                    Some(x) => x,\n+                    None => return Self::Wild,\n+                };\n+                let (var_id, variant) = if adt.is_enum() {\n+                    match cx.qpath_res(path, pat.hir_id).opt_def_id() {\n+                        Some(x) => (Some(x), adt.variant_with_ctor_id(x)),\n+                        None => return Self::Wild,\n+                    }\n+                } else {\n+                    (None, adt.non_enum_variant())\n+                };\n+                let (front, back) = match wild_idx {\n+                    Some(i) => pats.split_at(i),\n+                    None => (pats, [].as_slice()),\n+                };\n+                let pats = arena.alloc_from_iter(\n+                    front\n+                        .iter()\n+                        .map(|pat| Self::from_pat(cx, arena, pat))\n+                        .chain(iter::repeat_with(|| Self::Wild).take(variant.fields.len() - pats.len()))\n+                        .chain(back.iter().map(|pat| Self::from_pat(cx, arena, pat))),\n+                );\n+                Self::Tuple(var_id, pats)\n+            },\n+            PatKind::Or(pats) => Self::Or(arena.alloc_from_iter(pats.iter().map(|pat| Self::from_pat(cx, arena, pat)))),\n             PatKind::Path(ref path) => Self::Path(cx.qpath_res(path, pat.hir_id).opt_def_id()),\n             PatKind::Tuple(pats, wild_idx) => {\n-                Self::Sequence(None, pats.iter().map(|pat| Self::from_pat(cx, pat)).collect(), wild_idx)\n+                let field_count = match cx.typeck_results().pat_ty(pat).kind() {\n+                    ty::Tuple(subs) => subs.len(),\n+                    _ => return Self::Wild,\n+                };\n+                let (front, back) = match wild_idx {\n+                    Some(i) => pats.split_at(i),\n+                    None => (pats, [].as_slice()),\n+                };\n+                let pats = arena.alloc_from_iter(\n+                    front\n+                        .iter()\n+                        .map(|pat| Self::from_pat(cx, arena, pat))\n+                        .chain(iter::repeat_with(|| Self::Wild).take(field_count - pats.len()))\n+                        .chain(back.iter().map(|pat| Self::from_pat(cx, arena, pat))),\n+                );\n+                Self::Tuple(None, pats)\n             },\n             PatKind::Lit(e) => match &e.kind {\n                 ExprKind::Lit(lit) => match lit.node {\n@@ -239,23 +282,22 @@ impl<'hir> ResolvedPat<'hir> {\n                 };\n                 Self::Range(PatRange { start, end, bounds })\n             },\n-            PatKind::Slice(pats, wild, pats2) => Self::Sequence(\n-                None,\n-                pats.iter()\n-                    .chain(pats2.iter())\n-                    .map(|pat| Self::from_pat(cx, pat))\n-                    .collect(),\n-                wild.map(|_| pats.len()),\n+            PatKind::Slice(front, wild_pat, back) => Self::Slice(\n+                arena.alloc_from_iter(front.iter().map(|pat| Self::from_pat(cx, arena, pat))),\n+                arena.alloc_from_iter(back.iter().map(|pat| Self::from_pat(cx, arena, pat))),\n+                wild_pat.is_some(),\n             ),\n         }\n     }\n \n     /// Checks if two patterns overlap in the values they can match assuming they are for the same\n     /// type.\n     fn can_also_match(&self, other: &Self) -> bool {\n-        match (self, other) {\n+        match (*self, *other) {\n             (Self::Wild, _) | (_, Self::Wild) => true,\n-            (Self::Or(pats), other) | (other, Self::Or(pats)) => pats.iter().any(|pat| pat.can_also_match(other)),\n+            (Self::Or(pats), ref other) | (ref other, Self::Or(pats)) => {\n+                pats.iter().any(|pat| pat.can_also_match(other))\n+            },\n             (Self::Struct(lpath, lfields), Self::Struct(rpath, rfields)) => {\n                 if lpath != rpath {\n                     return false;\n@@ -287,39 +329,24 @@ impl<'hir> ResolvedPat<'hir> {\n                 }\n                 true\n             },\n-            (Self::Sequence(lpath, lpats, lwild_idx), Self::Sequence(rpath, rpats, rwild_idx)) => {\n+            (Self::Tuple(lpath, lpats), Self::Tuple(rpath, rpats)) => {\n                 if lpath != rpath {\n                     return false;\n                 }\n-\n-                let (lpats_start, lpats_end) = lwild_idx\n-                    .or(*rwild_idx)\n-                    .map_or((&**lpats, [].as_slice()), |idx| lpats.split_at(idx));\n-                let (rpats_start, rpats_end) = rwild_idx\n-                    .or(*lwild_idx)\n-                    .map_or((&**rpats, [].as_slice()), |idx| rpats.split_at(idx));\n-\n-                lpats_start\n-                    .iter()\n-                    .zip(rpats_start.iter())\n-                    .all(|(lpat, rpat)| lpat.can_also_match(rpat))\n-                    // `lpats_end` and `rpats_end` lengths may be disjointed, so start from the end and ignore any\n-                    // extras.\n-                    && lpats_end\n+                lpats\n                     .iter()\n-                    .rev()\n-                    .zip(rpats_end.iter().rev())\n+                    .zip(rpats.iter())\n                     .all(|(lpat, rpat)| lpat.can_also_match(rpat))\n             },\n             (Self::Path(x), Self::Path(y)) => x == y,\n             (Self::LitStr(x), Self::LitStr(y)) => x == y,\n             (Self::LitBytes(x), Self::LitBytes(y)) => x == y,\n             (Self::LitInt(x), Self::LitInt(y)) => x == y,\n             (Self::LitBool(x), Self::LitBool(y)) => x == y,\n-            (Self::Range(x), Self::Range(y)) => x.overlaps(y),\n-            (Self::Range(range), Self::LitInt(x)) | (Self::LitInt(x), Self::Range(range)) => range.contains(*x),\n+            (Self::Range(ref x), Self::Range(ref y)) => x.overlaps(y),\n+            (Self::Range(ref range), Self::LitInt(x)) | (Self::LitInt(x), Self::Range(ref range)) => range.contains(x),\n \n-            // Todo: Lit* with Path, Range with Path, LitBytes with Sequence\n+            // Todo: Lit* with Path, Range with Path, LitBytes with Slice, Slice with Slice\n             _ => true,\n         }\n     }"}]}