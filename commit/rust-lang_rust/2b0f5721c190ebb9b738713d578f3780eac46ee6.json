{"sha": "2b0f5721c190ebb9b738713d578f3780eac46ee6", "node_id": "C_kwDOAAsO6NoAKDJiMGY1NzIxYzE5MGViYjliNzM4NzEzZDU3OGYzNzgwZWFjNDZlZTY", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-03-29T13:36:17Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-04-10T07:16:33Z"}, "message": "prioritize param-env candidates", "tree": {"sha": "184ef3bba09fbc3f59c9e72269ab6b7a904d9187", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/184ef3bba09fbc3f59c9e72269ab6b7a904d9187"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b0f5721c190ebb9b738713d578f3780eac46ee6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b0f5721c190ebb9b738713d578f3780eac46ee6", "html_url": "https://github.com/rust-lang/rust/commit/2b0f5721c190ebb9b738713d578f3780eac46ee6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b0f5721c190ebb9b738713d578f3780eac46ee6/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "749b487be49b793dd713c429042b33262208f4f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/749b487be49b793dd713c429042b33262208f4f9", "html_url": "https://github.com/rust-lang/rust/commit/749b487be49b793dd713c429042b33262208f4f9"}], "stats": {"total": 233, "additions": 148, "deletions": 85}, "files": [{"sha": "b5b712c367d08d36147ab99664e182d5516c116a", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b0f5721c190ebb9b738713d578f3780eac46ee6/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b0f5721c190ebb9b738713d578f3780eac46ee6/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=2b0f5721c190ebb9b738713d578f3780eac46ee6", "patch": "@@ -80,6 +80,18 @@ impl CanonicalVarValues<'_> {\n             }\n         })\n     }\n+\n+    pub fn is_identity_modulo_regions(&self) -> bool {\n+        self.var_values.iter().enumerate().all(|(bv, arg)| match arg.unpack() {\n+            ty::GenericArgKind::Lifetime(_) => true,\n+            ty::GenericArgKind::Type(ty) => {\n+                matches!(*ty.kind(), ty::Bound(ty::INNERMOST, bt) if bt.var.as_usize() == bv)\n+            }\n+            ty::GenericArgKind::Const(ct) => {\n+                matches!(ct.kind(), ty::ConstKind::Bound(ty::INNERMOST, bc) if bc.as_usize() == bv)\n+            }\n+        })\n+    }\n }\n \n /// When we canonicalize a value to form a query, we wind up replacing"}, {"sha": "7c9a69f03987a22de71f9b710a8261c9e14e1f99", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 26, "deletions": 46, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2b0f5721c190ebb9b738713d578f3780eac46ee6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b0f5721c190ebb9b738713d578f3780eac46ee6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=2b0f5721c190ebb9b738713d578f3780eac46ee6", "patch": "@@ -4,8 +4,8 @@ use super::search_graph::OverflowHandler;\n #[cfg(doc)]\n use super::trait_goals::structural_traits::*;\n use super::{EvalCtxt, SolverMode};\n+use crate::solve::CanonicalResponseExt;\n use crate::traits::coherence;\n-use itertools::Itertools;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n@@ -547,61 +547,41 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    /// If there are multiple ways to prove a trait or projection goal, we have\n+    /// to somehow try to merge the candidates into one. If that fails, we return\n+    /// ambiguity.\n     #[instrument(level = \"debug\", skip(self), ret)]\n     pub(super) fn merge_candidates(\n         &mut self,\n         mut candidates: Vec<Candidate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        match candidates.len() {\n-            0 => return Err(NoSolution),\n-            1 => return Ok(candidates.pop().unwrap().result),\n-            _ => {}\n+        // First try merging all candidates. This is complete and fully sound.\n+        let responses = candidates.iter().map(|c| c.result).collect::<Vec<_>>();\n+        if let Some(result) = self.try_merge_responses(&responses) {\n+            return Ok(result);\n         }\n \n-        if candidates.len() > 1 {\n-            let mut i = 0;\n-            'outer: while i < candidates.len() {\n-                for j in (0..candidates.len()).filter(|&j| i != j) {\n-                    if self.candidate_should_be_dropped_in_favor_of(&candidates[i], &candidates[j])\n-                    {\n-                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n-                        candidates.swap_remove(i);\n-                        continue 'outer;\n+        // We then check whether we should prioritize `ParamEnv` candidates.\n+        //\n+        // Doing so is incomplete and would therefore be unsound during coherence.\n+        match self.solver_mode() {\n+            SolverMode::Coherence => (),\n+            // Prioritize `ParamEnv` candidates only if they do not guide inference.\n+            //\n+            // This is still incomplete as we may add incorrect region bounds.\n+            SolverMode::Normal => {\n+                let param_env_responses = candidates\n+                    .iter()\n+                    .filter(|c| matches!(c.source, CandidateSource::ParamEnv(_)))\n+                    .map(|c| c.result)\n+                    .collect::<Vec<_>>();\n+                if let Some(result) = self.try_merge_responses(&param_env_responses) {\n+                    if result.has_only_region_constraints() {\n+                        return Ok(result);\n                     }\n                 }\n-\n-                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n-                i += 1;\n-            }\n-\n-            // If there are *STILL* multiple candidates that have *different* response\n-            // results, give up and report ambiguity.\n-            if candidates.len() > 1 && !candidates.iter().map(|cand| cand.result).all_equal() {\n-                let certainty = if candidates.iter().all(|x| {\n-                    matches!(x.result.value.certainty, Certainty::Maybe(MaybeCause::Overflow))\n-                }) {\n-                    Certainty::Maybe(MaybeCause::Overflow)\n-                } else {\n-                    Certainty::AMBIGUOUS\n-                };\n-                return self.evaluate_added_goals_and_make_canonical_response(certainty);\n             }\n         }\n-\n-        Ok(candidates.pop().unwrap().result)\n-    }\n-\n-    fn candidate_should_be_dropped_in_favor_of(\n-        &self,\n-        candidate: &Candidate<'tcx>,\n-        other: &Candidate<'tcx>,\n-    ) -> bool {\n-        // FIXME: implement this\n-        match (candidate.source, other.source) {\n-            (CandidateSource::Impl(_), _)\n-            | (CandidateSource::ParamEnv(_), _)\n-            | (CandidateSource::AliasBound, _)\n-            | (CandidateSource::BuiltinImpl, _) => false,\n-        }\n+        self.flounder(&responses)\n     }\n }"}, {"sha": "2ee91a2da385b79037d5e1a6b842014229729a04", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 57, "deletions": 32, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/2b0f5721c190ebb9b738713d578f3780eac46ee6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b0f5721c190ebb9b738713d578f3780eac46ee6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=2b0f5721c190ebb9b738713d578f3780eac46ee6", "patch": "@@ -46,6 +46,8 @@ enum SolverMode {\n \n trait CanonicalResponseExt {\n     fn has_no_inference_or_external_constraints(&self) -> bool;\n+\n+    fn has_only_region_constraints(&self) -> bool;\n }\n \n impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n@@ -54,6 +56,11 @@ impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n             && self.value.var_values.is_identity()\n             && self.value.external_constraints.opaque_types.is_empty()\n     }\n+\n+    fn has_only_region_constraints(&self) -> bool {\n+        self.value.var_values.is_identity_modulo_regions()\n+            && self.value.external_constraints.opaque_types.is_empty()\n+    }\n }\n \n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n@@ -221,12 +228,17 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             (Some(alias_lhs), Some(alias_rhs)) => {\n                 debug!(\"both sides are aliases\");\n \n-                let candidates = vec![\n-                    // LHS normalizes-to RHS\n-                    evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No),\n-                    // RHS normalizes-to RHS\n-                    evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes),\n-                    // Relate via substs\n+                let mut candidates = Vec::new();\n+                // LHS normalizes-to RHS\n+                candidates.extend(\n+                    evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No).ok(),\n+                );\n+                // RHS normalizes-to RHS\n+                candidates.extend(\n+                    evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes).ok(),\n+                );\n+                // Relate via substs\n+                candidates.extend(\n                     self.probe(|ecx| {\n                         let span = tracing::span!(\n                             tracing::Level::DEBUG,\n@@ -247,11 +259,16 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                         }\n \n                         ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                    }),\n-                ];\n+                    })\n+                    .ok(),\n+                );\n                 debug!(?candidates);\n \n-                self.try_merge_responses(candidates.into_iter())\n+                if let Some(merged) = self.try_merge_responses(&candidates) {\n+                    Ok(merged)\n+                } else {\n+                    self.flounder(&candidates)\n+                }\n             }\n         }\n     }\n@@ -289,43 +306,51 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         debug!(\"added_goals={:?}\", &self.nested_goals.goals[current_len..]);\n     }\n \n-    #[instrument(level = \"debug\", skip(self, responses))]\n+    /// Try to merge multiple possible ways to prove a goal, if that is not possible returns `None`.\n+    ///\n+    /// In this case we tend to flounder and return ambiguity by calling `[EvalCtxt::flounder]`.\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn try_merge_responses(\n         &mut self,\n-        responses: impl Iterator<Item = QueryResult<'tcx>>,\n-    ) -> QueryResult<'tcx> {\n-        let candidates = responses.into_iter().flatten().collect::<Box<[_]>>();\n-\n-        if candidates.is_empty() {\n-            return Err(NoSolution);\n+        responses: &[CanonicalResponse<'tcx>],\n+    ) -> Option<CanonicalResponse<'tcx>> {\n+        if responses.is_empty() {\n+            return None;\n         }\n \n         // FIXME(-Ztrait-solver=next): We should instead try to find a `Certainty::Yes` response with\n         // a subset of the constraints that all the other responses have.\n-        let one = candidates[0];\n-        if candidates[1..].iter().all(|resp| resp == &one) {\n-            return Ok(one);\n+        let one = responses[0];\n+        if responses[1..].iter().all(|&resp| resp == one) {\n+            return Some(one);\n         }\n \n-        if let Some(response) = candidates.iter().find(|response| {\n-            response.value.certainty == Certainty::Yes\n-                && response.has_no_inference_or_external_constraints()\n-        }) {\n-            return Ok(*response);\n-        }\n+        responses\n+            .iter()\n+            .find(|response| {\n+                response.value.certainty == Certainty::Yes\n+                    && response.has_no_inference_or_external_constraints()\n+            })\n+            .copied()\n+    }\n \n-        let certainty = candidates.iter().fold(Certainty::AMBIGUOUS, |certainty, response| {\n+    /// If we fail to merge responses we flounder and return overflow or ambiguity.\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn flounder(&mut self, responses: &[CanonicalResponse<'tcx>]) -> QueryResult<'tcx> {\n+        if responses.is_empty() {\n+            return Err(NoSolution);\n+        }\n+        let certainty = responses.iter().fold(Certainty::AMBIGUOUS, |certainty, response| {\n             certainty.unify_and(response.value.certainty)\n         });\n-        // FIXME(-Ztrait-solver=next): We should take the intersection of the constraints on all the\n-        // responses and use that for the constraints of this ambiguous response.\n-        debug!(\">1 response, bailing with {certainty:?}\");\n+\n         let response = self.evaluate_added_goals_and_make_canonical_response(certainty);\n-        if let Ok(response) = &response {\n+        if let Ok(response) = response {\n             assert!(response.has_no_inference_or_external_constraints());\n+            Ok(response)\n+        } else {\n+            bug!(\"failed to make floundered response: {responses:?}\");\n         }\n-\n-        response\n     }\n }\n "}, {"sha": "531203d9c64f7875366240e5a33d0a1dbf9cfd87", "filename": "tests/ui/traits/new-solver/alias_eq_dont_use_normalizes_to_if_substs_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b0f5721c190ebb9b738713d578f3780eac46ee6/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b0f5721c190ebb9b738713d578f3780eac46ee6/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.rs?ref=2b0f5721c190ebb9b738713d578f3780eac46ee6", "patch": "@@ -1,7 +1,7 @@\n // compile-flags: -Ztrait-solver=next\n \n // check that when computing `alias-eq(<() as Foo<u16, T>>::Assoc, <() as Foo<?0, T>>::Assoc)`\n-//  we do not infer `?0 = u8` via the `for<STOP> (): Foo<u8, STOP>` impl or `?0 = u16` by\n+// we do not infer `?0 = u8` via the `for<STOP> (): Foo<u8, STOP>` impl or `?0 = u16` by\n // relating substs as either could be a valid solution.\n \n trait Foo<T, STOP> {"}, {"sha": "6f8164f3a40f0aaffec91eb308f1571de92c42e9", "filename": "tests/ui/traits/new-solver/prefer-candidate-no-constraints.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2b0f5721c190ebb9b738713d578f3780eac46ee6/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-candidate-no-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b0f5721c190ebb9b738713d578f3780eac46ee6/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-candidate-no-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-candidate-no-constraints.rs?ref=2b0f5721c190ebb9b738713d578f3780eac46ee6", "patch": "@@ -0,0 +1,22 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait Foo {}\n+\n+impl<T> Foo for T {}\n+\n+trait Bar {}\n+\n+struct Wrapper<'a, T>(&'a T);\n+\n+impl<'a, T> Bar for Wrapper<'a, T> where &'a T: Foo {}\n+// We need to satisfy `&'a T: Foo` when checking that this impl is WF\n+// that can either be satisfied via the param-env, or via an impl.\n+//\n+// When satisfied via the param-env, since each lifetime is canonicalized\n+// separately, we end up getting extra region constraints.\n+//\n+// However, when satisfied via the impl, there are no region constraints,\n+// and we can short-circuit a response with no external constraints.\n+\n+fn main() {}"}, {"sha": "909b33ec3d5a508b19c1a85c6cac37da9ba2f2b7", "filename": "tests/ui/traits/new-solver/prefer-param-env-on-ambiguity.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b0f5721c190ebb9b738713d578f3780eac46ee6/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-param-env-on-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b0f5721c190ebb9b738713d578f3780eac46ee6/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-param-env-on-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fprefer-param-env-on-ambiguity.rs?ref=2b0f5721c190ebb9b738713d578f3780eac46ee6", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait Foo<'a> {}\n+trait Bar<'a> {}\n+\n+impl<'a, T: Bar<'a>> Foo<'a> for T {}\n+impl<T> Bar<'static> for T {}\n+\n+fn main() {}"}, {"sha": "e3a92e85e17e4a846a965cda0d8c4ccf525c08b3", "filename": "tests/ui/traits/new-solver/recursive-self-normalization-2.stderr", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2b0f5721c190ebb9b738713d578f3780eac46ee6/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b0f5721c190ebb9b738713d578f3780eac46ee6/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.stderr?ref=2b0f5721c190ebb9b738713d578f3780eac46ee6", "patch": "@@ -1,9 +1,16 @@\n-error[E0282]: type annotations needed\n+error[E0283]: type annotations needed: cannot satisfy `<T as Foo1>::Assoc1: Bar`\n   --> $DIR/recursive-self-normalization-2.rs:15:5\n    |\n LL |     needs_bar::<T::Assoc1>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `S` declared on the function `needs_bar`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: cannot satisfy `<T as Foo1>::Assoc1: Bar`\n+note: required by a bound in `needs_bar`\n+  --> $DIR/recursive-self-normalization-2.rs:12:17\n+   |\n+LL | fn needs_bar<S: Bar>() {}\n+   |                 ^^^ required by this bound in `needs_bar`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0282`.\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "773007aebaa63aa0d03236b81dbc7d8c771aae45", "filename": "tests/ui/traits/new-solver/recursive-self-normalization.stderr", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2b0f5721c190ebb9b738713d578f3780eac46ee6/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b0f5721c190ebb9b738713d578f3780eac46ee6/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.stderr?ref=2b0f5721c190ebb9b738713d578f3780eac46ee6", "patch": "@@ -1,9 +1,16 @@\n-error[E0282]: type annotations needed\n+error[E0283]: type annotations needed: cannot satisfy `<T as Foo>::Assoc: Bar`\n   --> $DIR/recursive-self-normalization.rs:11:5\n    |\n LL |     needs_bar::<T::Assoc>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `S` declared on the function `needs_bar`\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: cannot satisfy `<T as Foo>::Assoc: Bar`\n+note: required by a bound in `needs_bar`\n+  --> $DIR/recursive-self-normalization.rs:8:17\n+   |\n+LL | fn needs_bar<S: Bar>() {}\n+   |                 ^^^ required by this bound in `needs_bar`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0282`.\n+For more information about this error, try `rustc --explain E0283`."}]}