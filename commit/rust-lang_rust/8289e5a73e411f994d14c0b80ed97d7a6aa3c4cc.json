{"sha": "8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyODllNWE3M2U0MTFmOTk0ZDE0YzBiODBlZDk3ZDdhNmFhM2M0Y2M=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-14T14:51:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-21T21:26:53Z"}, "message": "introduce `is_foreign_item` query\n\nThis may seem like overkill, but it's exactly what we want/need for\nincremental compilation I think. In particular, while generating code\nfor some codegen unit X, we can wind up querying about any number of\nexternal items, and we only want to be forced to rebuild X is some of\nthose changed from a foreign item to otherwise. Factoring this into a\nquery means we would re-run only if some `false` became `true` (or vice\nversa).", "tree": {"sha": "0d90e12a9734e47a51616e1e1a0627d9c6a91d57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d90e12a9734e47a51616e1e1a0627d9c6a91d57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc", "html_url": "https://github.com/rust-lang/rust/commit/8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1785bca5137fad1f26e4d3c347cbb68408a28fa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1785bca5137fad1f26e4d3c347cbb68408a28fa9", "html_url": "https://github.com/rust-lang/rust/commit/1785bca5137fad1f26e4d3c347cbb68408a28fa9"}], "stats": {"total": 40, "additions": 30, "deletions": 10}, "files": [{"sha": "224e9751e73d0e9d3b55d728c999fee1137946be", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc", "patch": "@@ -88,6 +88,7 @@ pub enum DepNode<D: Clone + Debug> {\n     // predicates for an item wind up in `ItemSignature`).\n     AssociatedItems(D),\n     ItemSignature(D),\n+    IsForeignItem(D),\n     TypeParamPredicates((D, D)),\n     SizedConstraint(D),\n     AdtDestructor(D),\n@@ -171,6 +172,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransCrateItem,\n             AssociatedItems,\n             ItemSignature,\n+            IsForeignItem,\n             AssociatedItemDefIds,\n             InherentImpls,\n             TypeckTables,\n@@ -221,6 +223,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n             AssociatedItems(ref d) => op(d).map(AssociatedItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n+            IsForeignItem(ref d) => op(d).map(IsForeignItem),\n             TypeParamPredicates((ref item, ref param)) => {\n                 Some(TypeParamPredicates((try_opt!(op(item)), try_opt!(op(param)))))\n             }"}, {"sha": "1cb3de3fa01e99b50fb8ae176235f6635afd7377", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc", "patch": "@@ -380,6 +380,9 @@ define_maps! { <'tcx>\n     pub adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n     pub adt_sized_constraint: SizedConstraint(DefId) -> Ty<'tcx>,\n \n+    /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n+    pub is_foreign_item: IsForeignItem(DefId) -> bool,\n+\n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n     pub variances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>>,"}, {"sha": "3cff063a8f56812c3465a8e32217d556042c3a6b", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc", "patch": "@@ -111,6 +111,7 @@ provide! { <'tcx> tcx, def_id, cdata\n     closure_kind => { cdata.closure_kind(def_id.index) }\n     closure_type => { cdata.closure_ty(def_id.index, tcx) }\n     inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n+    is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n }\n \n impl CrateStore for cstore::CStore {"}, {"sha": "d4d9015d08fc24d35036feeb1426daa788c95032", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc", "patch": "@@ -14,18 +14,18 @@\n //! and methods are represented as just a fn ptr and not a full\n //! closure.\n \n-use llvm::{self, ValueRef};\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::Substs;\n use attributes;\n use common::{self, CrateContext};\n-use monomorphize;\n use consts;\n use declare;\n-use monomorphize::Instance;\n+use llvm::{self, ValueRef};\n+use monomorphize::{self, Instance};\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::subst::Substs;\n+use syntax_pos::DUMMY_SP;\n use trans_item::TransItem;\n use type_of;\n-use rustc::ty::TypeFoldable;\n \n /// Translates a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n@@ -102,15 +102,17 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let attrs = instance.def.attrs(ccx.tcx());\n         attributes::from_fn_attrs(ccx, &attrs, llfn);\n \n-        let is_local_def = ccx.shared().translation_items().borrow()\n-                              .contains(&TransItem::Fn(instance));\n-        if is_local_def {\n-            // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n+        // Perhaps questionable, but we assume that anything defined\n+        // *in Rust code* may unwind. Foreign items like `extern \"C\" {\n+        // fn foo(); }` are assumed not to unwind **unless** they have\n+        // a `#[unwind]` attribute.\n+        if !ty::queries::is_foreign_item::get(tcx, DUMMY_SP, instance.def_id()) {\n             attributes::unwind(llfn, true);\n             unsafe {\n                 llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n             }\n         }\n+\n         if ccx.use_dll_storage_attrs() &&\n             ccx.sess().cstore.is_dllimport_foreign_item(instance.def_id())\n         {"}, {"sha": "855d156f6f26ac0d29c38ae8d5e3d513741439e6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=8289e5a73e411f994d14c0b80ed97d7a6aa3c4cc", "patch": "@@ -99,6 +99,7 @@ pub fn provide(providers: &mut Providers) {\n         trait_def,\n         adt_def,\n         impl_trait_ref,\n+        is_foreign_item,\n         ..*providers\n     };\n }\n@@ -1530,3 +1531,13 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n     let substs = Substs::identity_for_item(tcx, def_id);\n     tcx.mk_fn_def(def_id, substs, fty)\n }\n+\n+fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             def_id: DefId)\n+                             -> bool {\n+    match tcx.hir.get_if_local(def_id) {\n+        Some(hir_map::NodeForeignItem(..)) => true,\n+        Some(_) => false,\n+        _ => bug!(\"is_foreign_item applied to non-local def-id {:?}\", def_id)\n+    }\n+}"}]}