{"sha": "a12a32ab652d63e342f482566c767042609ab1a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExMmEzMmFiNjUyZDYzZTM0MmY0ODI1NjZjNzY3MDQyNjA5YWIxYTY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-10-30T19:55:38Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-11-06T18:04:23Z"}, "message": "review comments", "tree": {"sha": "43e693197ffbb8cb9711ec275bd559ae134a5fef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43e693197ffbb8cb9711ec275bd559ae134a5fef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a12a32ab652d63e342f482566c767042609ab1a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a12a32ab652d63e342f482566c767042609ab1a6", "html_url": "https://github.com/rust-lang/rust/commit/a12a32ab652d63e342f482566c767042609ab1a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a12a32ab652d63e342f482566c767042609ab1a6/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f545a50ee483f1d1a513ed2c73622646528236ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/f545a50ee483f1d1a513ed2c73622646528236ae", "html_url": "https://github.com/rust-lang/rust/commit/f545a50ee483f1d1a513ed2c73622646528236ae"}], "stats": {"total": 241, "additions": 121, "deletions": 120}, "files": [{"sha": "77713312ceca41dbb1e8329cf461b1b16215fd68", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a12a32ab652d63e342f482566c767042609ab1a6", "patch": "@@ -1075,6 +1075,13 @@ impl Mutability {\n             MutImmutable => MutMutable,\n         }\n     }\n+\n+    pub fn prefix_str(&self) -> &'static str {\n+        match self {\n+            MutMutable => \"mut \",\n+            MutImmutable => \"\",\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n@@ -2175,6 +2182,15 @@ pub enum Unsafety {\n     Normal,\n }\n \n+impl Unsafety {\n+    pub fn prefix_str(&self) -> &'static str {\n+        match self {\n+            Unsafety::Unsafe => \"unsafe \",\n+            Unsafety::Normal => \"\",\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Constness {\n     Const,"}, {"sha": "a25c111b598719df27e48746902b8082df2087b5", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=a12a32ab652d63e342f482566c767042609ab1a6", "patch": "@@ -1734,9 +1734,7 @@ impl<'a> State<'a> {\n                     _ => false,\n                 };\n                 self.s.word(\"&\");\n-                if mutbl == hir::MutMutable {\n-                    self.s.word(\"mut \");\n-                }\n+                self.s.word(mutbl.prefix_str());\n                 if is_range_inner {\n                     self.popen();\n                 }"}, {"sha": "38edef50c966275d2e8c2965e308c5783bdc184f", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a12a32ab652d63e342f482566c767042609ab1a6", "patch": "@@ -897,11 +897,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             } else {\n                 r.push(' ');\n             }\n-            s.push_highlighted(format!(\n-                \"&{}{}\",\n-                r,\n-                if mutbl == hir::MutMutable { \"mut \" } else { \"\" }\n-            ));\n+            s.push_highlighted(format!(\"&{}{}\", r, mutbl.prefix_str()));\n             s.push_normal(ty.to_string());\n         }\n "}, {"sha": "0b6060e0eb01ccb07f64f13da5cf40ec7a173ba8", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=a12a32ab652d63e342f482566c767042609ab1a6", "patch": "@@ -80,9 +80,7 @@ impl DefPathBasedNames<'tcx> {\n             }\n             ty::Ref(_, inner_type, mutbl) => {\n                 output.push('&');\n-                if mutbl == hir::MutMutable {\n-                    output.push_str(\"mut \");\n-                }\n+                output.push_str(mutbl.prefix_str());\n \n                 self.push_type_name(inner_type, output, debug);\n             }\n@@ -114,9 +112,7 @@ impl DefPathBasedNames<'tcx> {\n             ty::Foreign(did) => self.push_def_path(did, output),\n             ty::FnDef(..) | ty::FnPtr(_) => {\n                 let sig = t.fn_sig(self.tcx);\n-                if sig.unsafety() == hir::Unsafety::Unsafe {\n-                    output.push_str(\"unsafe \");\n-                }\n+                output.push_str(sig.unsafety().prefix_str());\n \n                 let abi = sig.abi();\n                 if abi != ::rustc_target::spec::abi::Abi::Rust {"}, {"sha": "c4785621985c36743712eed3bf616008e505d385", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=a12a32ab652d63e342f482566c767042609ab1a6", "patch": "@@ -1666,8 +1666,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::TypeAndMut<'tcx> {\n-        p!(write(\"{}\", if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" }),\n-            print(self.ty))\n+        p!(write(\"{}\", self.mutbl.prefix_str()), print(self.ty))\n     }\n \n     ty::ExistentialTraitRef<'tcx> {\n@@ -1693,9 +1692,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::FnSig<'tcx> {\n-        if self.unsafety == hir::Unsafety::Unsafe {\n-            p!(write(\"unsafe \"));\n-        }\n+        p!(write(\"{}\", self.unsafety.prefix_str()));\n \n         if self.abi != Abi::Rust {\n             p!(write(\"extern {} \", self.abi));"}, {"sha": "b9fa53d638fcbd1f00009c105b9c163c4052fc91", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=a12a32ab652d63e342f482566c767042609ab1a6", "patch": "@@ -76,9 +76,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n             if !cpp_like_names {\n                 output.push('&');\n             }\n-            if mutbl == hir::MutMutable {\n-                output.push_str(\"mut \");\n-            }\n+            output.push_str(mutbl.prefix_str());\n \n             push_debuginfo_type_name(tcx, inner_type, true, output, visited);\n \n@@ -140,9 +138,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n \n \n             let sig = t.fn_sig(tcx);\n-            if sig.unsafety() == hir::Unsafety::Unsafe {\n-                output.push_str(\"unsafe \");\n-            }\n+            output.push_str(sig.unsafety().prefix_str());\n \n             let abi = sig.abi();\n             if abi != rustc_target::spec::abi::Abi::Rust {"}, {"sha": "477ad10460f6b8445cf71c6427e5e870033bc771", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=a12a32ab652d63e342f482566c767042609ab1a6", "patch": "@@ -293,10 +293,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n                 match self.ty.kind {\n                     ty::Adt(def, _) if def.is_box() => write!(f, \"box \")?,\n                     ty::Ref(_, _, mutbl) => {\n-                        write!(f, \"&\")?;\n-                        if mutbl == hir::MutMutable {\n-                            write!(f, \"mut \")?;\n-                        }\n+                        write!(f, \"&{}\", mutbl.prefix_str())?;\n                     }\n                     _ => bug!(\"{} is a bad Deref pattern type\", self.ty)\n                 }"}, {"sha": "ded655c1ae32af5918b47c3367e704280996661b", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=a12a32ab652d63e342f482566c767042609ab1a6", "patch": "@@ -341,10 +341,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                                          tstr);\n         match self.expr_ty.kind {\n             ty::Ref(_, _, mt) => {\n-                let mtstr = match mt {\n-                    hir::MutMutable => \"mut \",\n-                    hir::MutImmutable => \"\",\n-                };\n+                let mtstr = mt.prefix_str();\n                 if self.cast_ty.is_trait() {\n                     match fcx.tcx.sess.source_map().span_to_snippet(self.cast_span) {\n                         Ok(s) => {"}, {"sha": "bc1189e443e2843b6f847249e9edeeeade6cb3cc", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=a12a32ab652d63e342f482566c767042609ab1a6", "patch": "@@ -1723,7 +1723,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n-crate fn ty_kind_suggestion(ty: Ty<'_>) -> Option<&'static str> {\n+pub(super) fn ty_kind_suggestion(ty: Ty<'_>) -> Option<&'static str> {\n     Some(match ty.kind {\n         ty::Bool => \"true\",\n         ty::Char => \"'a'\","}, {"sha": "845fc231429c8a285809fca6eacc294981fdfd9e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 94, "deletions": 86, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a12a32ab652d63e342f482566c767042609ab1a6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a12a32ab652d63e342f482566c767042609ab1a6", "patch": "@@ -127,7 +127,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::source_map::{DUMMY_SP, original_sp};\n-use syntax::symbol::{kw, sym};\n+use syntax::symbol::{kw, sym, Ident};\n use syntax::util::parser::ExprPrecedence;\n \n use std::cell::{Cell, RefCell, Ref, RefMut};\n@@ -1925,34 +1925,7 @@ fn check_impl_items_against_trait<'tcx>(\n     }\n \n     if !missing_items.is_empty() {\n-        let mut err = struct_span_err!(tcx.sess, impl_span, E0046,\n-            \"not all trait items implemented, missing: `{}`\",\n-            missing_items.iter()\n-                .map(|trait_item| trait_item.ident.to_string())\n-                .collect::<Vec<_>>().join(\"`, `\"));\n-        err.span_label(impl_span, format!(\"missing `{}` in implementation\",\n-                missing_items.iter()\n-                    .map(|trait_item| trait_item.ident.to_string())\n-                    .collect::<Vec<_>>().join(\"`, `\")));\n-\n-        // `Span` before impl block closing brace.\n-        let hi = full_impl_span.hi() - BytePos(1);\n-        let sugg_sp = full_impl_span.with_lo(hi).with_hi(hi);\n-        let indentation = tcx.sess.source_map().span_to_margin(sugg_sp).unwrap_or(0);\n-        let padding: String = (0..indentation).map(|_| \" \").collect();\n-        for trait_item in missing_items {\n-            let snippet = suggestion_signature(&trait_item, tcx);\n-            let code = format!(\"{}{}\\n{}\", padding, snippet, padding);\n-            let msg = format!(\"implement the missing item: `{}`\", snippet);\n-            let appl = Applicability::HasPlaceholders;\n-            if let Some(span) = tcx.hir().span_if_local(trait_item.def_id) {\n-                err.span_label(span, format!(\"`{}` from trait\", trait_item.ident));\n-                err.tool_only_span_suggestion(sugg_sp, &msg, code, appl);\n-            } else {\n-                err.span_suggestion_hidden(sugg_sp, &msg, code, appl);\n-            }\n-        }\n-        err.emit();\n+        missing_items_err(tcx, impl_span, &missing_items, full_impl_span);\n     }\n \n     if !invalidated_items.is_empty() {\n@@ -1965,11 +1938,100 @@ fn check_impl_items_against_trait<'tcx>(\n             invalidator.ident,\n             invalidated_items.iter()\n                 .map(|name| name.to_string())\n-                .collect::<Vec<_>>().join(\"`, `\"))\n+                .collect::<Vec<_>>().join(\"`, `\")\n+        )\n+    }\n+}\n+\n+fn missing_items_err(\n+    tcx: TyCtxt<'_>,\n+    impl_span: Span,\n+    missing_items: &[ty::AssocItem],\n+    full_impl_span: Span,\n+) {\n+    let missing_items_msg = missing_items.iter()\n+        .map(|trait_item| trait_item.ident.to_string())\n+        .collect::<Vec<_>>().join(\"`, `\");\n+\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        impl_span,\n+        E0046,\n+        \"not all trait items implemented, missing: `{}`\",\n+        missing_items_msg\n+    );\n+    err.span_label(impl_span, format!(\"missing `{}` in implementation\", missing_items_msg));\n+\n+    // `Span` before impl block closing brace.\n+    let hi = full_impl_span.hi() - BytePos(1);\n+    // Point at the place right before the closing brace of the relevant `impl` to suggest\n+    // adding the associated item at the end of its body.\n+    let sugg_sp = full_impl_span.with_lo(hi).with_hi(hi);\n+    // Obtain the level of indentation ending in `sugg_sp`.\n+    let indentation = tcx.sess.source_map().span_to_margin(sugg_sp).unwrap_or(0);\n+    // Make the whitespace that will make the suggestion have the right indentation.\n+    let padding: String = (0..indentation).map(|_| \" \").collect();\n+\n+    for trait_item in missing_items {\n+        let snippet = suggestion_signature(&trait_item, tcx);\n+        let code = format!(\"{}{}\\n{}\", padding, snippet, padding);\n+        let msg = format!(\"implement the missing item: `{}`\", snippet);\n+        let appl = Applicability::HasPlaceholders;\n+        if let Some(span) = tcx.hir().span_if_local(trait_item.def_id) {\n+            err.span_label(span, format!(\"`{}` from trait\", trait_item.ident));\n+            err.tool_only_span_suggestion(sugg_sp, &msg, code, appl);\n+        } else {\n+            err.span_suggestion_hidden(sugg_sp, &msg, code, appl);\n+        }\n     }\n+    err.emit();\n+}\n+\n+/// Return placeholder code for the given function.\n+fn fn_sig_suggestion(sig: &ty::FnSig<'_>, ident: Ident) -> String {\n+    let args = sig.inputs()\n+        .iter()\n+        .map(|ty| Some(match ty.kind {\n+            ty::Param(param) if param.name == kw::SelfUpper => \"self\".to_string(),\n+            ty::Ref(reg, ref_ty, mutability) => {\n+                let reg = match &format!(\"{}\", reg)[..] {\n+                    \"'_\" | \"\" => String::new(),\n+                    reg => format!(\"{} \", reg),\n+                };\n+                match ref_ty.kind {\n+                    ty::Param(param) if param.name == kw::SelfUpper => {\n+                        format!(\"&{}{}self\", reg, mutability.prefix_str())\n+                    }\n+                    _ => format!(\"_: {:?}\", ty),\n+                }\n+            }\n+            _ => format!(\"_: {:?}\", ty),\n+        }))\n+        .chain(std::iter::once(if sig.c_variadic {\n+            Some(\"...\".to_string())\n+        } else {\n+            None\n+        }))\n+        .filter_map(|arg| arg)\n+        .collect::<Vec<String>>()\n+        .join(\", \");\n+    let output = sig.output();\n+    let output = if !output.is_unit() {\n+        format!(\" -> {:?}\", output)\n+    } else {\n+        String::new()\n+    };\n+\n+    let unsafety = sig.unsafety.prefix_str();\n+    // FIXME: this is not entirely correct, as the lifetimes from borrowed params will\n+    // not be present in the `fn` definition, not will we account for renamed\n+    // lifetimes between the `impl` and the `trait`, but this should be good enough to\n+    // fill in a significant portion of the missing code, and other subsequent\n+    // suggestions can help the user fix the code.\n+    format!(\"{}fn {}({}){} {{ unimplemented!() }}\", unsafety, ident, args, output)\n }\n \n-/// Given a `ty::AssocItem` and a `TyCtxt`, return placeholder code for that associated item.\n+/// Return placeholder code for the given associated item.\n /// Similar to `ty::AssocItem::suggestion`, but appropriate for use as the code snippet of a\n /// structured suggestion.\n fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n@@ -1979,61 +2041,7 @@ fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n             // late-bound regions, and we don't want method signatures to show up\n             // `as for<'r> fn(&'r MyType)`.  Pretty-printing handles late-bound\n             // regions just fine, showing `fn(&MyType)`.\n-            let sig = tcx.fn_sig(assoc.def_id);\n-            let unsafety = match sig.unsafety() {\n-                hir::Unsafety::Unsafe => \"unsafe \",\n-                _ => \"\",\n-            };\n-            let args = sig.inputs()\n-                .skip_binder()\n-                .iter()\n-                .map(|ty| Some(match ty.kind {\n-                    ty::Param(param) if param.name == kw::SelfUpper => {\n-                        \"self\".to_string()\n-                    }\n-                    ty::Ref(reg, ref_ty, mutability) => {\n-                        let mutability = match mutability {\n-                            hir::Mutability::MutMutable => \"mut \",\n-                            _ => \"\",\n-                        };\n-                        let mut reg = format!(\"{}\", reg);\n-                        if &reg[..] == \"'_\" {\n-                            reg = \"\".to_string();\n-                        }\n-                        if &reg[..] != \"\" {\n-                            reg = format!(\"{} \", reg);\n-                        }\n-                        match ref_ty.kind {\n-                            ty::Param(param)\n-                            if param.name == kw::SelfUpper => {\n-                                format!(\"&{}{}self\", reg, mutability)\n-                            }\n-                            _ => format!(\"_: {:?}\", ty),\n-                        }\n-\n-                    }\n-                    _ => format!(\"_: {:?}\", ty),\n-                }))\n-                .chain(std::iter::once(if sig.c_variadic() {\n-                    Some(\"...\".to_string())\n-                } else {\n-                    None\n-                }))\n-                .filter_map(|arg| arg)\n-                .collect::<Vec<String>>()\n-                .join(\", \");\n-            let output = sig.output();\n-            let output = if !output.skip_binder().is_unit() {\n-                format!(\" -> {:?}\", output.skip_binder())\n-            } else {\n-                String::new()\n-            };\n-            // FIXME: this is not entirely correct, as the lifetimes from borrowed params will\n-            // not be present in the `fn` definition, not will we account for renamed\n-            // lifetimes between the `impl` and the `trait`, but this should be good enough to\n-            // fill in a significant portion of the missing code, and other subsequent\n-            // suggestions can help the user fix the code.\n-            format!(\"{}fn {}({}){} {{ unimplemented!() }}\", unsafety, assoc.ident, args, output)\n+            fn_sig_suggestion(tcx.fn_sig(assoc.def_id).skip_binder(), assoc.ident)\n         }\n         ty::AssocKind::Type => format!(\"type {} = Type;\", assoc.ident),\n         // FIXME(type_alias_impl_trait): we should print bounds here too."}]}