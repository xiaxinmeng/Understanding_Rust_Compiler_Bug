{"sha": "81fe85710d7f749c87494c4b968861adc67a9c4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZmU4NTcxMGQ3Zjc0OWM4NzQ5NGM0Yjk2ODg2MWFkYzY3YTljNGE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-22T16:42:52Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-22T17:38:02Z"}, "message": "make mbe::TokenTree private to module", "tree": {"sha": "12e130752be215d19b53be21de0d667c6ddd299a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12e130752be215d19b53be21de0d667c6ddd299a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81fe85710d7f749c87494c4b968861adc67a9c4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81fe85710d7f749c87494c4b968861adc67a9c4a", "html_url": "https://github.com/rust-lang/rust/commit/81fe85710d7f749c87494c4b968861adc67a9c4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81fe85710d7f749c87494c4b968861adc67a9c4a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "983569732d24df434c644dd1764e9c5e4ecfd081", "url": "https://api.github.com/repos/rust-lang/rust/commits/983569732d24df434c644dd1764e9c5e4ecfd081", "html_url": "https://github.com/rust-lang/rust/commit/983569732d24df434c644dd1764e9c5e4ecfd081"}], "stats": {"total": 52, "additions": 26, "deletions": 26}, "files": [{"sha": "a87da791c9b4f6de2971f5905c782172503b33d7", "filename": "src/libsyntax/ext/mbe.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/81fe85710d7f749c87494c4b968861adc67a9c4a/src%2Flibsyntax%2Fext%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fe85710d7f749c87494c4b968861adc67a9c4a/src%2Flibsyntax%2Fext%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe.rs?ref=81fe85710d7f749c87494c4b968861adc67a9c4a", "patch": "@@ -20,14 +20,14 @@ use rustc_data_structures::sync::Lrc;\n /// Contains the sub-token-trees of a \"delimited\" token tree, such as the contents of `(`. Note\n /// that the delimiter itself might be `NoDelim`.\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n-crate struct Delimited {\n-    crate delim: token::DelimToken,\n-    crate tts: Vec<TokenTree>,\n+struct Delimited {\n+    delim: token::DelimToken,\n+    tts: Vec<TokenTree>,\n }\n \n impl Delimited {\n     /// Returns a `self::TokenTree` with a `Span` corresponding to the opening delimiter.\n-    crate fn open_tt(&self, span: Span) -> TokenTree {\n+    fn open_tt(&self, span: Span) -> TokenTree {\n         let open_span = if span.is_dummy() {\n             span\n         } else {\n@@ -37,7 +37,7 @@ impl Delimited {\n     }\n \n     /// Returns a `self::TokenTree` with a `Span` corresponding to the closing delimiter.\n-    crate fn close_tt(&self, span: Span) -> TokenTree {\n+    fn close_tt(&self, span: Span) -> TokenTree {\n         let close_span = if span.is_dummy() {\n             span\n         } else {\n@@ -48,33 +48,33 @@ impl Delimited {\n }\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n-crate struct SequenceRepetition {\n+struct SequenceRepetition {\n     /// The sequence of token trees\n-    crate tts: Vec<TokenTree>,\n+    tts: Vec<TokenTree>,\n     /// The optional separator\n-    crate separator: Option<Token>,\n+    separator: Option<Token>,\n     /// Whether the sequence can be repeated zero (*), or one or more times (+)\n-    crate kleene: KleeneToken,\n+    kleene: KleeneToken,\n     /// The number of `Match`s that appear in the sequence (and subsequences)\n-    crate num_captures: usize,\n+    num_captures: usize,\n }\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n-crate struct KleeneToken {\n-    crate span: Span,\n-    crate op: KleeneOp,\n+struct KleeneToken {\n+    span: Span,\n+    op: KleeneOp,\n }\n \n impl KleeneToken {\n-    crate fn new(op: KleeneOp, span: Span) -> KleeneToken {\n+    fn new(op: KleeneOp, span: Span) -> KleeneToken {\n         KleeneToken { span, op }\n     }\n }\n \n /// A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star)\n /// for token sequences.\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-crate enum KleeneOp {\n+enum KleeneOp {\n     /// Kleene star (`*`) for zero or more repetitions\n     ZeroOrMore,\n     /// Kleene plus (`+`) for one or more repetitions\n@@ -86,7 +86,7 @@ crate enum KleeneOp {\n /// Similar to `tokenstream::TokenTree`, except that `$i`, `$i:ident`, and `$(...)`\n /// are \"first-class\" token trees. Useful for parsing macros.\n #[derive(Debug, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n-crate enum TokenTree {\n+enum TokenTree {\n     Token(Token),\n     Delimited(DelimSpan, Lrc<Delimited>),\n     /// A kleene-style repetition sequence\n@@ -103,7 +103,7 @@ crate enum TokenTree {\n \n impl TokenTree {\n     /// Return the number of tokens in the tree.\n-    crate fn len(&self) -> usize {\n+    fn len(&self) -> usize {\n         match *self {\n             TokenTree::Delimited(_, ref delimed) => match delimed.delim {\n                 token::NoDelim => delimed.tts.len(),\n@@ -115,23 +115,23 @@ impl TokenTree {\n     }\n \n     /// Returns `true` if the given token tree is delimited.\n-    crate fn is_delimited(&self) -> bool {\n+    fn is_delimited(&self) -> bool {\n         match *self {\n             TokenTree::Delimited(..) => true,\n             _ => false,\n         }\n     }\n \n     /// Returns `true` if the given token tree is a token of the given kind.\n-    crate fn is_token(&self, expected_kind: &TokenKind) -> bool {\n+    fn is_token(&self, expected_kind: &TokenKind) -> bool {\n         match self {\n             TokenTree::Token(Token { kind: actual_kind, .. }) => actual_kind == expected_kind,\n             _ => false,\n         }\n     }\n \n     /// Gets the `index`-th sub-token-tree. This only makes sense for delimited trees and sequences.\n-    crate fn get_tt(&self, index: usize) -> TokenTree {\n+    fn get_tt(&self, index: usize) -> TokenTree {\n         match (self, index) {\n             (&TokenTree::Delimited(_, ref delimed), _) if delimed.delim == token::NoDelim => {\n                 delimed.tts[index].clone()\n@@ -151,7 +151,7 @@ impl TokenTree {\n     }\n \n     /// Retrieves the `TokenTree`'s span.\n-    crate fn span(&self) -> Span {\n+    fn span(&self) -> Span {\n         match *self {\n             TokenTree::Token(Token { span, .. })\n             | TokenTree::MetaVar(span, _)\n@@ -160,7 +160,7 @@ impl TokenTree {\n         }\n     }\n \n-    crate fn token(kind: TokenKind, span: Span) -> TokenTree {\n+    fn token(kind: TokenKind, span: Span) -> TokenTree {\n         TokenTree::Token(Token::new(kind, span))\n     }\n }"}, {"sha": "97074f5cbe46c995015052001076b8e0d5c0aceb", "filename": "src/libsyntax/ext/mbe/macro_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81fe85710d7f749c87494c4b968861adc67a9c4a/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fe85710d7f749c87494c4b968861adc67a9c4a/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_check.rs?ref=81fe85710d7f749c87494c4b968861adc67a9c4a", "patch": "@@ -196,7 +196,7 @@ struct MacroState<'a> {\n /// - `node_id` is used to emit lints\n /// - `span` is used when no spans are available\n /// - `lhses` and `rhses` should have the same length and represent the macro definition\n-crate fn check_meta_variables(\n+pub(super) fn check_meta_variables(\n     sess: &ParseSess,\n     node_id: NodeId,\n     span: Span,"}, {"sha": "b51384d3b15e10b80941956246505c175cbf0a34", "filename": "src/libsyntax/ext/mbe/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81fe85710d7f749c87494c4b968861adc67a9c4a/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fe85710d7f749c87494c4b968861adc67a9c4a/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fmacro_parser.rs?ref=81fe85710d7f749c87494c4b968861adc67a9c4a", "patch": "@@ -282,7 +282,7 @@ crate enum ParseResult<T> {\n crate type NamedParseResult = ParseResult<FxHashMap<Ident, NamedMatch>>;\n \n /// Count how many metavars are named in the given matcher `ms`.\n-crate fn count_names(ms: &[TokenTree]) -> usize {\n+pub(super) fn count_names(ms: &[TokenTree]) -> usize {\n     ms.iter().fold(0, |count, elt| {\n         count + match *elt {\n             TokenTree::Sequence(_, ref seq) => seq.num_captures,\n@@ -648,7 +648,7 @@ fn inner_parse_loop<'root, 'tt>(\n /// - `directory`: Information about the file locations (needed for the black-box parser)\n /// - `recurse_into_modules`: Whether or not to recurse into modules (needed for the black-box\n ///   parser)\n-crate fn parse(\n+pub(super) fn parse(\n     sess: &ParseSess,\n     tts: TokenStream,\n     ms: &[TokenTree],"}, {"sha": "3952e29a5f0d1fbdb489a1912bb186173fecdf53", "filename": "src/libsyntax/ext/mbe/quoted.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81fe85710d7f749c87494c4b968861adc67a9c4a/src%2Flibsyntax%2Fext%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fe85710d7f749c87494c4b968861adc67a9c4a/src%2Flibsyntax%2Fext%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmbe%2Fquoted.rs?ref=81fe85710d7f749c87494c4b968861adc67a9c4a", "patch": "@@ -35,7 +35,7 @@ use std::iter::Peekable;\n /// # Returns\n ///\n /// A collection of `self::TokenTree`. There may also be some errors emitted to `sess`.\n-crate fn parse(\n+pub(super) fn parse(\n     input: tokenstream::TokenStream,\n     expect_matchers: bool,\n     sess: &ParseSess,"}]}