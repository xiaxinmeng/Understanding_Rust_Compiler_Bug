{"sha": "453979462a2cba1c32b61f96a18c125805827291", "node_id": "C_kwDOAAsO6NoAKDQ1Mzk3OTQ2MmEyY2JhMWMzMmI2MWY5NmExOGMxMjU4MDU4MjcyOTE", "commit": {"author": {"name": "Jacob Hoffman-Andrews", "email": "github@hoffman-andrews.com", "date": "2022-05-16T04:09:55Z"}, "committer": {"name": "Jacob Hoffman-Andrews", "email": "github@hoffman-andrews.com", "date": "2022-05-17T16:26:18Z"}, "message": "rustdoc: make search.js a module\n\nPreviously, search.js relied on the DOM and the `window` object. It can now be\nloaded in the absence of the DOM, for instance by Node. The same is true of\nsearch-index.js.\n\nThis allows removing a lot of code from src/tools/rustdoc-js/tester.js that\ntried to parse search.js and extract specific functions that were needed for\ntesting.", "tree": {"sha": "7dd23e9b2b007bb96f658549e14eacc5336b47fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dd23e9b2b007bb96f658549e14eacc5336b47fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/453979462a2cba1c32b61f96a18c125805827291", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/453979462a2cba1c32b61f96a18c125805827291", "html_url": "https://github.com/rust-lang/rust/commit/453979462a2cba1c32b61f96a18c125805827291", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/453979462a2cba1c32b61f96a18c125805827291/comments", "author": {"login": "jsha", "id": 220205, "node_id": "MDQ6VXNlcjIyMDIwNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/220205?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsha", "html_url": "https://github.com/jsha", "followers_url": "https://api.github.com/users/jsha/followers", "following_url": "https://api.github.com/users/jsha/following{/other_user}", "gists_url": "https://api.github.com/users/jsha/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsha/subscriptions", "organizations_url": "https://api.github.com/users/jsha/orgs", "repos_url": "https://api.github.com/users/jsha/repos", "events_url": "https://api.github.com/users/jsha/events{/privacy}", "received_events_url": "https://api.github.com/users/jsha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsha", "id": 220205, "node_id": "MDQ6VXNlcjIyMDIwNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/220205?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsha", "html_url": "https://github.com/jsha", "followers_url": "https://api.github.com/users/jsha/followers", "following_url": "https://api.github.com/users/jsha/following{/other_user}", "gists_url": "https://api.github.com/users/jsha/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsha/subscriptions", "organizations_url": "https://api.github.com/users/jsha/orgs", "repos_url": "https://api.github.com/users/jsha/repos", "events_url": "https://api.github.com/users/jsha/events{/privacy}", "received_events_url": "https://api.github.com/users/jsha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29e972dc608a0a2cb639decda1c9f30cb029e423", "url": "https://api.github.com/repos/rust-lang/rust/commits/29e972dc608a0a2cb639decda1c9f30cb029e423", "html_url": "https://github.com/rust-lang/rust/commit/29e972dc608a0a2cb639decda1c9f30cb029e423"}], "stats": {"total": 430, "additions": 117, "deletions": 313}, "files": [{"sha": "ece659284d177ed3043fdb1728b37f1f5cd9f6ef", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/453979462a2cba1c32b61f96a18c125805827291/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/453979462a2cba1c32b61f96a18c125805827291/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=453979462a2cba1c32b61f96a18c125805827291", "patch": "@@ -438,7 +438,13 @@ pub(super) fn write_shared(\n     write_crate(\"search-index.js\", &|| {\n         let mut v = String::from(\"var searchIndex = JSON.parse('{\\\\\\n\");\n         v.push_str(&all_indexes.join(\",\\\\\\n\"));\n-        v.push_str(\"\\\\\\n}');\\nif (window.initSearch) {window.initSearch(searchIndex)};\");\n+        v.push_str(\n+            r#\"\\\n+}');\n+if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};\n+if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};\n+\"#,\n+        );\n         Ok(v.into_bytes())\n     })?;\n "}, {"sha": "80d904b843e6df4da811881c5832c5e1fcc9ab4d", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 66, "deletions": 46, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/453979462a2cba1c32b61f96a18c125805827291/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/453979462a2cba1c32b61f96a18c125805827291/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=453979462a2cba1c32b61f96a18c125805827291", "patch": "@@ -1,5 +1,5 @@\n-/* global addClass, getNakedUrl, getSettingValue, hasOwnPropertyRustdoc, initSearch, onEach */\n-/* global onEachLazy, removeClass, searchState, browserSupportsHistoryApi */\n+/* global addClass, getNakedUrl, getSettingValue */\n+/* global onEachLazy, removeClass, searchState, browserSupportsHistoryApi, exports */\n \n \"use strict\";\n \n@@ -38,6 +38,11 @@ const itemTypes = [\n // used for special search precedence\n const TY_PRIMITIVE = itemTypes.indexOf(\"primitive\");\n const TY_KEYWORD = itemTypes.indexOf(\"keyword\");\n+const ROOT_PATH = typeof window !== \"undefined\" ? window.rootPath : \"../\";\n+\n+function hasOwnPropertyRustdoc(obj, property) {\n+    return Object.prototype.hasOwnProperty.call(obj, property);\n+}\n \n // In the search display, allows to switch between tabs.\n function printTab(nb) {\n@@ -106,7 +111,7 @@ function levenshtein(s1, s2) {\n     return s1_len + s2_len;\n }\n \n-window.initSearch = rawSearchIndex => {\n+function initSearch(rawSearchIndex) {\n     const MAX_LEV_DISTANCE = 3;\n     const MAX_RESULTS = 200;\n     const GENERICS_DATA = 2;\n@@ -120,15 +125,6 @@ window.initSearch = rawSearchIndex => {\n     let searchIndex;\n     let currentResults;\n     const ALIASES = Object.create(null);\n-    const params = searchState.getQueryStringParams();\n-\n-    // Populate search bar with query string search term when provided,\n-    // but only if the input bar is empty. This avoid the obnoxious issue\n-    // where you start trying to do a search, and the index loads, and\n-    // suddenly your search is gone!\n-    if (searchState.input.value === \"\") {\n-        searchState.input.value = params.search || \"\";\n-    }\n \n     function isWhitespace(c) {\n         return \" \\t\\n\\r\".indexOf(c) !== -1;\n@@ -726,10 +722,11 @@ window.initSearch = rawSearchIndex => {\n      * @param  {ParsedQuery} parsedQuery - The parsed user query\n      * @param  {Object} searchWords      - The list of search words to query against\n      * @param  {Object} [filterCrates]   - Crate to search in if defined\n+     * @param  {Object} [currentCrate]   - Current crate, to rank results from this crate higher\n      *\n      * @return {ResultsTable}\n      */\n-    function execQuery(parsedQuery, searchWords, filterCrates) {\n+    function execQuery(parsedQuery, searchWords, filterCrates, currentCrate) {\n         const results_others = {}, results_in_args = {}, results_returned = {};\n \n         function transformResults(results) {\n@@ -761,7 +758,7 @@ window.initSearch = rawSearchIndex => {\n             return out;\n         }\n \n-        function sortResults(results, isType) {\n+        function sortResults(results, isType, preferredCrate) {\n             const userQuery = parsedQuery.userQuery;\n             const ar = [];\n             for (const entry in results) {\n@@ -796,9 +793,9 @@ window.initSearch = rawSearchIndex => {\n                     return a - b;\n                 }\n \n-                // sort by crate (non-current crate goes later)\n-                a = (aaa.item.crate !== window.currentCrate);\n-                b = (bbb.item.crate !== window.currentCrate);\n+                // sort by crate (current crate comes first)\n+                a = (aaa.item.crate !== preferredCrate);\n+                b = (bbb.item.crate !== preferredCrate);\n                 if (a !== b) {\n                     return a - b;\n                 }\n@@ -1178,7 +1175,7 @@ window.initSearch = rawSearchIndex => {\n             };\n         }\n \n-        function handleAliases(ret, query, filterCrates) {\n+        function handleAliases(ret, query, filterCrates, currentCrate) {\n             const lowerQuery = query.toLowerCase();\n             // We separate aliases and crate aliases because we want to have current crate\n             // aliases to be before the others in the displayed results.\n@@ -1194,7 +1191,7 @@ window.initSearch = rawSearchIndex => {\n             } else {\n                 Object.keys(ALIASES).forEach(crate => {\n                     if (ALIASES[crate][lowerQuery]) {\n-                        const pushTo = crate === window.currentCrate ? crateAliases : aliases;\n+                        const pushTo = crate === currentCrate ? crateAliases : aliases;\n                         const query_aliases = ALIASES[crate][lowerQuery];\n                         for (const alias of query_aliases) {\n                             pushTo.push(createAliasFromItem(searchIndex[alias]));\n@@ -1226,8 +1223,9 @@ window.initSearch = rawSearchIndex => {\n                     ret.others.pop();\n                 }\n             };\n-            onEach(aliases, pushFunc);\n-            onEach(crateAliases, pushFunc);\n+\n+            aliases.forEach(pushFunc);\n+            crateAliases.forEach(pushFunc);\n         }\n \n         /**\n@@ -1444,11 +1442,11 @@ window.initSearch = rawSearchIndex => {\n         }\n \n         const ret = createQueryResults(\n-            sortResults(results_in_args, true),\n-            sortResults(results_returned, true),\n-            sortResults(results_others, false),\n+            sortResults(results_in_args, true, currentCrate),\n+            sortResults(results_returned, true, currentCrate),\n+            sortResults(results_others, false, currentCrate),\n             parsedQuery);\n-        handleAliases(ret, parsedQuery.original.replace(/\"/g, \"\"), filterCrates);\n+        handleAliases(ret, parsedQuery.original.replace(/\"/g, \"\"), filterCrates, currentCrate);\n         if (parsedQuery.error !== null && ret.others.length !== 0) {\n             // It means some doc aliases were found so let's \"remove\" the error!\n             ret.query.error = null;\n@@ -1521,18 +1519,18 @@ window.initSearch = rawSearchIndex => {\n \n         if (type === \"mod\") {\n             displayPath = path + \"::\";\n-            href = window.rootPath + path.replace(/::/g, \"/\") + \"/\" +\n-                   name + \"/index.html\";\n+            href = ROOT_PATH + path.replace(/::/g, \"/\") + \"/\" +\n+                name + \"/index.html\";\n         } else if (type === \"import\") {\n             displayPath = item.path + \"::\";\n-            href = window.rootPath + item.path.replace(/::/g, \"/\") + \"/index.html#reexport.\" + name;\n+            href = ROOT_PATH + item.path.replace(/::/g, \"/\") + \"/index.html#reexport.\" + name;\n         } else if (type === \"primitive\" || type === \"keyword\") {\n             displayPath = \"\";\n-            href = window.rootPath + path.replace(/::/g, \"/\") +\n-                   \"/\" + type + \".\" + name + \".html\";\n+            href = ROOT_PATH + path.replace(/::/g, \"/\") +\n+                \"/\" + type + \".\" + name + \".html\";\n         } else if (type === \"externcrate\") {\n             displayPath = \"\";\n-            href = window.rootPath + name + \"/index.html\";\n+            href = ROOT_PATH + name + \"/index.html\";\n         } else if (item.parent !== undefined) {\n             const myparent = item.parent;\n             let anchor = \"#\" + type + \".\" + name;\n@@ -1555,14 +1553,14 @@ window.initSearch = rawSearchIndex => {\n             } else {\n                 displayPath = path + \"::\" + myparent.name + \"::\";\n             }\n-            href = window.rootPath + path.replace(/::/g, \"/\") +\n-                   \"/\" + pageType +\n-                   \".\" + pageName +\n-                   \".html\" + anchor;\n+            href = ROOT_PATH + path.replace(/::/g, \"/\") +\n+                \"/\" + pageType +\n+                \".\" + pageName +\n+                \".html\" + anchor;\n         } else {\n             displayPath = item.path + \"::\";\n-            href = window.rootPath + item.path.replace(/::/g, \"/\") +\n-                   \"/\" + type + \".\" + name + \".html\";\n+            href = ROOT_PATH + item.path.replace(/::/g, \"/\") +\n+                \"/\" + type + \".\" + name + \".html\";\n         }\n         return [displayPath, href];\n     }\n@@ -1835,7 +1833,7 @@ window.initSearch = rawSearchIndex => {\n         }\n \n         showResults(\n-            execQuery(query, searchWords, filterCrates),\n+            execQuery(query, searchWords, filterCrates, window.currentCrate),\n             params.go_to_first,\n             filterCrates);\n     }\n@@ -2015,6 +2013,16 @@ window.initSearch = rawSearchIndex => {\n     }\n \n     function registerSearchEvents() {\n+        const params = searchState.getQueryStringParams();\n+\n+        // Populate search bar with query string search term when provided,\n+        // but only if the input bar is empty. This avoid the obnoxious issue\n+        // where you start trying to do a search, and the index loads, and\n+        // suddenly your search is gone!\n+        if (searchState.input.value === \"\") {\n+            searchState.input.value = params.search || \"\";\n+        }\n+\n         const searchAfter500ms = () => {\n             searchState.clearInputTimeout();\n             if (searchState.input.value.length === 0) {\n@@ -2167,20 +2175,32 @@ window.initSearch = rawSearchIndex => {\n      *  @type {Array<string>}\n      */\n     const searchWords = buildIndex(rawSearchIndex);\n-    registerSearchEvents();\n-\n-    function runSearchIfNeeded() {\n+    if (typeof window !== \"undefined\") {\n+        registerSearchEvents();\n         // If there's a search term in the URL, execute the search now.\n-        if (searchState.getQueryStringParams().search) {\n+        if (window.searchState.getQueryStringParams().search) {\n             search();\n         }\n     }\n \n-    runSearchIfNeeded();\n-};\n+    if (typeof exports !== \"undefined\") {\n+        exports.initSearch = initSearch;\n+        exports.execQuery = execQuery;\n+        exports.parseQuery = parseQuery;\n+    }\n+    return searchWords;\n+}\n \n-if (window.searchIndex !== undefined) {\n-    initSearch(window.searchIndex);\n+if (typeof window !== \"undefined\") {\n+    window.initSearch = initSearch;\n+    if (window.searchIndex !== undefined) {\n+        initSearch(window.searchIndex);\n+    }\n+} else {\n+    // Running in Node, not a browser. Run initSearch just to produce the\n+    // exports.\n+    initSearch({});\n }\n \n+\n })();"}, {"sha": "948885cd30a598d601724e25be322525206654bf", "filename": "src/librustdoc/html/static/js/storage.js", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/453979462a2cba1c32b61f96a18c125805827291/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js", "raw_url": "https://github.com/rust-lang/rust/raw/453979462a2cba1c32b61f96a18c125805827291/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js?ref=453979462a2cba1c32b61f96a18c125805827291", "patch": "@@ -100,11 +100,6 @@ function onEachLazy(lazyArray, func, reversed) {\n         reversed);\n }\n \n-// eslint-disable-next-line no-unused-vars\n-function hasOwnPropertyRustdoc(obj, property) {\n-    return Object.prototype.hasOwnProperty.call(obj, property);\n-}\n-\n function updateLocalStorage(name, value) {\n     try {\n         window.localStorage.setItem(\"rustdoc-\" + name, value);"}, {"sha": "df3185758bfc087e23bda0b6828dd86fb0665ede", "filename": "src/tools/rustdoc-js/tester.js", "status": "modified", "additions": 44, "deletions": 261, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/453979462a2cba1c32b61f96a18c125805827291/src%2Ftools%2Frustdoc-js%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/453979462a2cba1c32b61f96a18c125805827291/src%2Ftools%2Frustdoc-js%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-js%2Ftester.js?ref=453979462a2cba1c32b61f96a18c125805827291", "patch": "@@ -1,182 +1,6 @@\n const fs = require('fs');\n const path = require('path');\n \n-function getNextStep(content, pos, stop) {\n-    while (pos < content.length && content[pos] !== stop &&\n-           (content[pos] === ' ' || content[pos] === '\\t' || content[pos] === '\\n')) {\n-        pos += 1;\n-    }\n-    if (pos >= content.length) {\n-        return null;\n-    }\n-    if (content[pos] !== stop) {\n-        return pos * -1;\n-    }\n-    return pos;\n-}\n-\n-// Stupid function extractor based on indent. Doesn't support block\n-// comments. If someone puts a ' or an \" in a block comment this\n-// will blow up. Template strings are not tested and might also be\n-// broken.\n-function extractFunction(content, functionName) {\n-    var level = 0;\n-    var splitter = \"function \" + functionName + \"(\";\n-    var stop;\n-    var pos, start;\n-\n-    while (true) {\n-        start = content.indexOf(splitter);\n-        if (start === -1) {\n-            break;\n-        }\n-        pos = start;\n-        while (pos < content.length && content[pos] !== ')') {\n-            pos += 1;\n-        }\n-        if (pos >= content.length) {\n-            break;\n-        }\n-        pos = getNextStep(content, pos + 1, '{');\n-        if (pos === null) {\n-            break;\n-        } else if (pos < 0) {\n-            content = content.slice(-pos);\n-            continue;\n-        }\n-        while (pos < content.length) {\n-            // Eat single-line comments\n-            if (content[pos] === '/' && pos > 0 && content[pos - 1] === '/') {\n-                do {\n-                    pos += 1;\n-                } while (pos < content.length && content[pos] !== '\\n');\n-\n-            // Eat multiline comment.\n-            } else if (content[pos] === '*' && pos > 0 && content[pos - 1] === '/') {\n-                do {\n-                    pos += 1;\n-                } while (pos < content.length && content[pos] !== '/' && content[pos - 1] !== '*');\n-\n-            // Eat quoted strings\n-            } else if ((content[pos] === '\"' || content[pos] === \"'\" || content[pos] === \"`\") &&\n-                       (pos === 0 || content[pos - 1] !== '/')) {\n-                stop = content[pos];\n-                do {\n-                    if (content[pos] === '\\\\') {\n-                        pos += 1;\n-                    }\n-                    pos += 1;\n-                } while (pos < content.length && content[pos] !== stop);\n-\n-            // Otherwise, check for block level.\n-            } else if (content[pos] === '{') {\n-                level += 1;\n-            } else if (content[pos] === '}') {\n-                level -= 1;\n-                if (level === 0) {\n-                    return content.slice(start, pos + 1);\n-                }\n-            }\n-            pos += 1;\n-        }\n-        content = content.slice(start + 1);\n-    }\n-    return null;\n-}\n-\n-// Stupid function extractor for array.\n-function extractArrayVariable(content, arrayName, kind) {\n-    if (typeof kind === \"undefined\") {\n-        kind = \"let \";\n-    }\n-    var splitter = kind + arrayName;\n-    while (true) {\n-        var start = content.indexOf(splitter);\n-        if (start === -1) {\n-            break;\n-        }\n-        var pos = getNextStep(content, start, '=');\n-        if (pos === null) {\n-            break;\n-        } else if (pos < 0) {\n-            content = content.slice(-pos);\n-            continue;\n-        }\n-        pos = getNextStep(content, pos, '[');\n-        if (pos === null) {\n-            break;\n-        } else if (pos < 0) {\n-            content = content.slice(-pos);\n-            continue;\n-        }\n-        while (pos < content.length) {\n-            if (content[pos] === '\"' || content[pos] === \"'\") {\n-                var stop = content[pos];\n-                do {\n-                    if (content[pos] === '\\\\') {\n-                        pos += 2;\n-                    } else {\n-                        pos += 1;\n-                    }\n-                } while (pos < content.length &&\n-                         (content[pos] !== stop || content[pos - 1] === '\\\\'));\n-            } else if (content[pos] === ']' &&\n-                       pos + 1 < content.length &&\n-                       content[pos + 1] === ';') {\n-                return content.slice(start, pos + 2);\n-            }\n-            pos += 1;\n-        }\n-        content = content.slice(start + 1);\n-    }\n-    if (kind === \"let \") {\n-        return extractArrayVariable(content, arrayName, \"const \");\n-    }\n-    return null;\n-}\n-\n-// Stupid function extractor for variable.\n-function extractVariable(content, varName, kind) {\n-    if (typeof kind === \"undefined\") {\n-        kind = \"let \";\n-    }\n-    var splitter = kind + varName;\n-    while (true) {\n-        var start = content.indexOf(splitter);\n-        if (start === -1) {\n-            break;\n-        }\n-        var pos = getNextStep(content, start, '=');\n-        if (pos === null) {\n-            break;\n-        } else if (pos < 0) {\n-            content = content.slice(-pos);\n-            continue;\n-        }\n-        while (pos < content.length) {\n-            if (content[pos] === '\"' || content[pos] === \"'\") {\n-                var stop = content[pos];\n-                do {\n-                    if (content[pos] === '\\\\') {\n-                        pos += 2;\n-                    } else {\n-                        pos += 1;\n-                    }\n-                } while (pos < content.length &&\n-                         (content[pos] !== stop || content[pos - 1] === '\\\\'));\n-            } else if (content[pos] === ';' || content[pos] === ',') {\n-                return content.slice(start, pos + 1);\n-            }\n-            pos += 1;\n-        }\n-        content = content.slice(start + 1);\n-    }\n-    if (kind === \"let \") {\n-        return extractVariable(content, varName, \"const \");\n-    }\n-    return null;\n-}\n-\n function loadContent(content) {\n     var Module = module.constructor;\n     var m = new Module();\n@@ -194,20 +18,6 @@ function readFile(filePath) {\n     return fs.readFileSync(filePath, 'utf8');\n }\n \n-function loadThings(thingsToLoad, kindOfLoad, funcToCall, fileContent) {\n-    var content = '';\n-    for (var i = 0; i < thingsToLoad.length; ++i) {\n-        var tmp = funcToCall(fileContent, thingsToLoad[i]);\n-        if (tmp === null) {\n-            console.log('unable to find ' + kindOfLoad + ' \"' + thingsToLoad[i] + '\"');\n-            process.exit(1);\n-        }\n-        content += tmp;\n-        content += 'exports.' + thingsToLoad[i] + ' = ' + thingsToLoad[i] + ';';\n-    }\n-    return content;\n-}\n-\n function contentToDiffLine(key, value) {\n     return `\"${key}\": \"${value}\",`;\n }\n@@ -264,46 +74,6 @@ function lookForEntry(entry, data) {\n     return null;\n }\n \n-function loadSearchJsAndIndex(searchJs, searchIndex, storageJs, crate) {\n-    if (searchIndex[searchIndex.length - 1].length === 0) {\n-        searchIndex.pop();\n-    }\n-    searchIndex.pop();\n-    var fullSearchIndex = searchIndex.join(\"\\n\") + '\\nexports.rawSearchIndex = searchIndex;';\n-    searchIndex = loadContent(fullSearchIndex);\n-    var finalJS = \"\";\n-\n-    var arraysToLoad = [\"itemTypes\"];\n-    var variablesToLoad = [\"MAX_LEV_DISTANCE\", \"MAX_RESULTS\", \"NO_TYPE_FILTER\",\n-                           \"GENERICS_DATA\", \"NAME\", \"INPUTS_DATA\", \"OUTPUT_DATA\",\n-                           \"TY_PRIMITIVE\", \"TY_KEYWORD\",\n-                           \"levenshtein_row2\"];\n-    // execQuery first parameter is built in getQuery (which takes in the search input).\n-    // execQuery last parameter is built in buildIndex.\n-    // buildIndex requires the hashmap from search-index.\n-    var functionsToLoad = [\"buildHrefAndPath\", \"pathSplitter\", \"levenshtein\", \"validateResult\",\n-                           \"buildIndex\", \"execQuery\", \"parseQuery\", \"createQueryResults\",\n-                           \"isWhitespace\", \"isSpecialStartCharacter\", \"isStopCharacter\",\n-                           \"parseInput\", \"getItemsBefore\", \"getNextElem\", \"createQueryElement\",\n-                           \"isReturnArrow\", \"isPathStart\", \"getStringElem\", \"newParsedQuery\",\n-                           \"itemTypeFromName\", \"isEndCharacter\", \"isErrorCharacter\",\n-                           \"isIdentCharacter\", \"isSeparatorCharacter\", \"getIdentEndPosition\",\n-                           \"checkExtraTypeFilterCharacters\", \"isWhitespaceCharacter\"];\n-\n-    const functions = [\"hasOwnPropertyRustdoc\", \"onEach\"];\n-    ALIASES = {};\n-    finalJS += 'window = { \"currentCrate\": \"' + crate + '\", rootPath: \"../\" };\\n';\n-    finalJS += loadThings(functions, 'function', extractFunction, storageJs);\n-    finalJS += loadThings(arraysToLoad, 'array', extractArrayVariable, searchJs);\n-    finalJS += loadThings(variablesToLoad, 'variable', extractVariable, searchJs);\n-    finalJS += loadThings(functionsToLoad, 'function', extractFunction, searchJs);\n-\n-    var loaded = loadContent(finalJS);\n-    var index = loaded.buildIndex(searchIndex.rawSearchIndex);\n-\n-    return [loaded, index];\n-}\n-\n // This function checks if `expected` has all the required fields needed for the checks.\n function checkNeededFields(fullPath, expected, error_text, queryName, position) {\n     let fieldsToCheck;\n@@ -359,8 +129,7 @@ function valueCheck(fullPath, expected, result, error_text, queryName) {\n                 'compared to EXPECTED');\n         }\n     } else if (expected !== null && typeof expected !== \"undefined\" &&\n-               expected.constructor == Object)\n-    {\n+               expected.constructor == Object) {\n         for (const key in expected) {\n             if (!expected.hasOwnProperty(key)) {\n                 continue;\n@@ -382,21 +151,20 @@ function valueCheck(fullPath, expected, result, error_text, queryName) {\n     }\n }\n \n-function runParser(query, expected, loaded, loadedFile, queryName) {\n+function runParser(query, expected, parseQuery, queryName) {\n     var error_text = [];\n     checkNeededFields(\"\", expected, error_text, queryName, null);\n     if (error_text.length === 0) {\n-        valueCheck('', expected, loaded.parseQuery(query), error_text, queryName);\n+        valueCheck('', expected, parseQuery(query), error_text, queryName);\n     }\n     return error_text;\n }\n \n-function runSearch(query, expected, index, loaded, loadedFile, queryName) {\n-    const filter_crate = loadedFile.FILTER_CRATE;\n+function runSearch(query, expected, doSearch, loadedFile, queryName) {\n     const ignore_order = loadedFile.ignore_order;\n     const exact_check = loadedFile.exact_check;\n \n-    var results = loaded.execQuery(loaded.parseQuery(query), index, filter_crate);\n+    var results = doSearch(query, loadedFile.FILTER_CRATE);\n     var error_text = [];\n \n     for (var key in expected) {\n@@ -488,7 +256,7 @@ function runCheck(loadedFile, key, callback) {\n     return 0;\n }\n \n-function runChecks(testFile, loaded, index) {\n+function runChecks(testFile, doSearch, parseQuery) {\n     var checkExpected = false;\n     var checkParsed = false;\n     var testFileContent = readFile(testFile) + 'exports.QUERY = QUERY;';\n@@ -518,24 +286,40 @@ function runChecks(testFile, loaded, index) {\n \n     if (checkExpected) {\n         res += runCheck(loadedFile, \"EXPECTED\", (query, expected, text) => {\n-            return runSearch(query, expected, index, loaded, loadedFile, text);\n+            return runSearch(query, expected, doSearch, loadedFile, text);\n         });\n     }\n     if (checkParsed) {\n         res += runCheck(loadedFile, \"PARSED\", (query, expected, text) => {\n-            return runParser(query, expected, loaded, loadedFile, text);\n+            return runParser(query, expected, parseQuery, text);\n         });\n     }\n     return res;\n }\n \n-function load_files(doc_folder, resource_suffix, crate) {\n-    var searchJs = readFile(path.join(doc_folder, \"search\" + resource_suffix + \".js\"));\n-    var storageJs = readFile(path.join(doc_folder, \"storage\" + resource_suffix + \".js\"));\n-    var searchIndex = readFile(\n-        path.join(doc_folder, \"search-index\" + resource_suffix + \".js\")).split(\"\\n\");\n-\n-    return loadSearchJsAndIndex(searchJs, searchIndex, storageJs, crate);\n+/**\n+ * Load searchNNN.js and search-indexNNN.js.\n+ *\n+ * @param {string} doc_folder      - Path to a folder generated by running rustdoc\n+ * @param {string} resource_suffix - Version number between filename and .js, e.g. \"1.59.0\"\n+ * @returns {Object}               - Object containing two keys: `doSearch`, which runs a search\n+ *   with the loaded index and returns a table of results; and `parseQuery`, which is the\n+ *   `parseQuery` function exported from the search module.\n+ */\n+function loadSearchJS(doc_folder, resource_suffix) {\n+    const searchJs = path.join(doc_folder, \"search\" + resource_suffix + \".js\");\n+    const searchIndexJs = path.join(doc_folder, \"search-index\" + resource_suffix + \".js\");\n+    const searchIndex = require(searchIndexJs);\n+    const searchModule = require(searchJs);\n+    const searchWords = searchModule.initSearch(searchIndex.searchIndex);\n+\n+    return {\n+        doSearch: function (queryStr, filterCrate, currentCrate) {\n+            return searchModule.execQuery(searchModule.parseQuery(queryStr), searchWords,\n+                filterCrate, currentCrate);\n+        },\n+        parseQuery: searchModule.parseQuery,\n+    }\n }\n \n function showHelp() {\n@@ -598,35 +382,34 @@ function parseOptions(args) {\n     return null;\n }\n \n-function checkFile(test_file, opts, loaded, index) {\n-    const test_name = path.basename(test_file, \".js\");\n-\n-    process.stdout.write('Checking \"' + test_name + '\" ... ');\n-    return runChecks(test_file, loaded, index);\n-}\n-\n function main(argv) {\n     var opts = parseOptions(argv.slice(2));\n     if (opts === null) {\n         return 1;\n     }\n \n-    var [loaded, index] = load_files(\n+    let parseAndSearch = loadSearchJS(\n         opts[\"doc_folder\"],\n-        opts[\"resource_suffix\"],\n-        opts[\"crate_name\"]);\n+        opts[\"resource_suffix\"]);\n     var errors = 0;\n \n+    let doSearch = function (queryStr, filterCrate) {\n+        return parseAndSearch.doSearch(queryStr, filterCrate, opts[\"crate_name\"]);\n+    };\n+\n     if (opts[\"test_file\"].length !== 0) {\n-        opts[\"test_file\"].forEach(function(file) {\n-            errors += checkFile(file, opts, loaded, index);\n+        opts[\"test_file\"].forEach(function (file) {\n+            process.stdout.write(`Testing ${file} ... `);\n+            errors += runChecks(file, doSearch, parseAndSearch.parseQuery);\n         });\n     } else if (opts[\"test_folder\"].length !== 0) {\n-        fs.readdirSync(opts[\"test_folder\"]).forEach(function(file) {\n+        fs.readdirSync(opts[\"test_folder\"]).forEach(function (file) {\n             if (!file.endsWith(\".js\")) {\n                 return;\n             }\n-            errors += checkFile(path.join(opts[\"test_folder\"], file), opts, loaded, index);\n+            process.stdout.write(`Testing ${file} ... `);\n+            errors += runChecks(path.join(opts[\"test_folder\"], file), doSearch,\n+                    parseAndSearch.parseQuery);\n         });\n     }\n     return errors > 0 ? 1 : 0;"}]}