{"sha": "0e2f9b948564708085373fc28d91b4524c821fa3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMmY5Yjk0ODU2NDcwODA4NTM3M2ZjMjhkOTFiNDUyNGM4MjFmYTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-06T04:21:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-06T04:21:49Z"}, "message": "auto merge of #18388 : nikomatsakis/rust/fn-trait-hierarchy, r=acrichto\n\nAdd blanket impls to allow the various `Fn` traits to be interconverted.\r\n\r\nFixes #18387.", "tree": {"sha": "097f212af1f62c477746d7cc7bbc16d7a4574f80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/097f212af1f62c477746d7cc7bbc16d7a4574f80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e2f9b948564708085373fc28d91b4524c821fa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e2f9b948564708085373fc28d91b4524c821fa3", "html_url": "https://github.com/rust-lang/rust/commit/0e2f9b948564708085373fc28d91b4524c821fa3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e2f9b948564708085373fc28d91b4524c821fa3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63c4f22f2bf9f1c070311cdc08c6ceb279434733", "url": "https://api.github.com/repos/rust-lang/rust/commits/63c4f22f2bf9f1c070311cdc08c6ceb279434733", "html_url": "https://github.com/rust-lang/rust/commit/63c4f22f2bf9f1c070311cdc08c6ceb279434733"}, {"sha": "cf753a2dc7c060bcbf6d9241032cf57e597393eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf753a2dc7c060bcbf6d9241032cf57e597393eb", "html_url": "https://github.com/rust-lang/rust/commit/cf753a2dc7c060bcbf6d9241032cf57e597393eb"}], "stats": {"total": 407, "additions": 313, "deletions": 94}, "files": [{"sha": "ac735492be4a5408a2afdc3b79b56ca4c9737604", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 50, "deletions": 20, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=0e2f9b948564708085373fc28d91b4524c821fa3", "patch": "@@ -866,34 +866,64 @@ pub trait FnOnce<Args,Result> {\n     extern \"rust-call\" fn call_once(self, args: Args) -> Result;\n }\n \n-macro_rules! def_fn_mut(\n+impl<F,A,R> FnMut<A,R> for F\n+    where F : Fn<A,R>\n+{\n+    extern \"rust-call\" fn call_mut(&mut self, args: A) -> R {\n+        self.call(args)\n+    }\n+}\n+\n+impl<F,A,R> FnOnce<A,R> for F\n+    where F : FnMut<A,R>\n+{\n+    extern \"rust-call\" fn call_once(mut self, args: A) -> R {\n+        self.call_mut(args)\n+    }\n+}\n+\n+\n+impl<Result> Fn<(),Result> for extern \"Rust\" fn() -> Result {\n+    #[allow(non_snake_case)]\n+    extern \"rust-call\" fn call(&self, _args: ()) -> Result {\n+        (*self)()\n+    }\n+}\n+\n+impl<Result,A0> Fn<(A0,),Result> for extern \"Rust\" fn(A0) -> Result {\n+    #[allow(non_snake_case)]\n+    extern \"rust-call\" fn call(&self, args: (A0,)) -> Result {\n+        let (a0,) = args;\n+        (*self)(a0)\n+    }\n+}\n+\n+macro_rules! def_fn(\n     ($($args:ident)*) => (\n         impl<Result$(,$args)*>\n-        FnMut<($($args,)*),Result>\n+        Fn<($($args,)*),Result>\n         for extern \"Rust\" fn($($args: $args,)*) -> Result {\n             #[allow(non_snake_case)]\n-            extern \"rust-call\" fn call_mut(&mut self, args: ($($args,)*)) -> Result {\n+            extern \"rust-call\" fn call(&self, args: ($($args,)*)) -> Result {\n                 let ($($args,)*) = args;\n                 (*self)($($args,)*)\n             }\n         }\n     )\n )\n \n-def_fn_mut!()\n-def_fn_mut!(A0)\n-def_fn_mut!(A0 A1)\n-def_fn_mut!(A0 A1 A2)\n-def_fn_mut!(A0 A1 A2 A3)\n-def_fn_mut!(A0 A1 A2 A3 A4)\n-def_fn_mut!(A0 A1 A2 A3 A4 A5)\n-def_fn_mut!(A0 A1 A2 A3 A4 A5 A6)\n-def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7)\n-def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7 A8)\n-def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9)\n-def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10)\n-def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11)\n-def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12)\n-def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13)\n-def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14)\n-def_fn_mut!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15)\n+def_fn!(A0 A1)\n+def_fn!(A0 A1 A2)\n+def_fn!(A0 A1 A2 A3)\n+def_fn!(A0 A1 A2 A3 A4)\n+def_fn!(A0 A1 A2 A3 A4 A5)\n+def_fn!(A0 A1 A2 A3 A4 A5 A6)\n+def_fn!(A0 A1 A2 A3 A4 A5 A6 A7)\n+def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8)\n+def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9)\n+def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10)\n+def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11)\n+def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12)\n+def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13)\n+def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14)\n+def_fn!(A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14 A15)"}, {"sha": "09490f9bdf7e951c77afcbd48c8c771e7e50bb98", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=0e2f9b948564708085373fc28d91b4524c821fa3", "patch": "@@ -43,7 +43,7 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n     // Determine whether `impl2` can provide an implementation for those\n     // same types.\n     let param_env = ty::empty_parameter_environment();\n-    let mut selcx = SelectionContext::new(infcx, &param_env, infcx.tcx);\n+    let mut selcx = SelectionContext::intercrate(infcx, &param_env, infcx.tcx);\n     let obligation = Obligation::misc(DUMMY_SP, impl1_trait_ref);\n     debug!(\"impl_can_satisfy obligation={}\", obligation.repr(infcx.tcx));\n     selcx.evaluate_impl(impl2_def_id, &obligation)"}, {"sha": "09bd0f52985b1799334e4f6e47d83dae9c2ab66b", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 86, "deletions": 62, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=0e2f9b948564708085373fc28d91b4524c821fa3", "patch": "@@ -45,6 +45,22 @@ pub struct SelectionContext<'cx, 'tcx:'cx> {\n     /// which is important for checking for trait bounds that\n     /// recursively require themselves.\n     skolemizer: TypeSkolemizer<'cx, 'tcx>,\n+\n+    /// If true, indicates that the evaluation should be conservative\n+    /// and consider the possibility of types outside this crate.\n+    /// This comes up primarily when resolving ambiguity. Imagine\n+    /// there is some trait reference `$0 : Bar` where `$0` is an\n+    /// inference variable. If `intercrate` is true, then we can never\n+    /// say for sure that this reference is not implemented, even if\n+    /// there are *no impls at all for `Bar`*, because `$0` could be\n+    /// bound to some type that in a downstream crate that implements\n+    /// `Bar`. This is the suitable mode for coherence. Elsewhere,\n+    /// though, we set this to false, because we are only interested\n+    /// in types that the user could actually have written --- in\n+    /// other words, we consider `$0 : Bar` to be unimplemented if\n+    /// there is no type that the user could *actually name* that\n+    /// would satisfy it. This avoids crippling inference, basically.\n+    intercrate: bool,\n }\n \n // A stack that walks back up the stack frame.\n@@ -142,6 +158,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             param_env: param_env,\n             typer: typer,\n             skolemizer: infcx.skolemizer(),\n+            intercrate: false,\n+        }\n+    }\n+\n+    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>,\n+                      param_env: &'cx ty::ParameterEnvironment,\n+                      typer: &'cx Typer<'tcx>)\n+                      -> SelectionContext<'cx, 'tcx> {\n+        SelectionContext {\n+            infcx: infcx,\n+            param_env: param_env,\n+            typer: typer,\n+            skolemizer: infcx.skolemizer(),\n+            intercrate: true,\n         }\n     }\n \n@@ -214,44 +244,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // The result is \"true\" if the obligation *may* hold and \"false\" if\n     // we can be sure it does not.\n \n-    pub fn evaluate_obligation_intercrate(&mut self,\n-                                          obligation: &Obligation)\n-                                          -> bool\n+    pub fn evaluate_obligation(&mut self,\n+                               obligation: &Obligation)\n+                               -> bool\n     {\n         /*!\n          * Evaluates whether the obligation `obligation` can be\n-         * satisfied (by any means). This \"intercrate\" version allows\n-         * for the possibility that unbound type variables may be\n-         * instantiated with types from another crate. This is\n-         * important for coherence. In practice this means that\n-         * unbound type variables must always be considered ambiguous.\n+         * satisfied (by any means).\n          */\n \n-        debug!(\"evaluate_obligation_intercrate({})\",\n+        debug!(\"evaluate_obligation({})\",\n                obligation.repr(self.tcx()));\n \n         let stack = self.push_stack(None, obligation);\n-        self.evaluate_stack_intercrate(&stack).may_apply()\n-    }\n-\n-    pub fn evaluate_obligation_intracrate(&mut self,\n-                                            obligation: &Obligation)\n-                                            -> bool\n-    {\n-        /*!\n-         * Evaluates whether the obligation `obligation` can be\n-         * satisfied (by any means). This \"intracrate\" version does\n-         * not allow for the possibility that unbound type variables\n-         * may be instantiated with types from another crate; hence,\n-         * if there are unbound inputs but no crates locally visible,\n-         * it considers the result to be unimplemented.\n-         */\n-\n-        debug!(\"evaluate_obligation_intracrate({})\",\n-               obligation.repr(self.tcx()));\n-\n-        let stack = self.push_stack(None, obligation);\n-        self.evaluate_stack_intracrate(&stack).may_apply()\n+        self.evaluate_stack(&stack).may_apply()\n     }\n \n     fn evaluate_builtin_bound_recursively(&mut self,\n@@ -288,46 +294,53 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let stack = self.push_stack(previous_stack.map(|x| x), obligation);\n \n-        // FIXME(#17901) -- Intercrate vs intracrate resolution is a\n-        // tricky question here. For coherence, we want\n-        // intercrate. Also, there was a nasty cycle around impls like\n-        // `impl<T:Eq> Eq for Vec<T>` (which would wind up checking\n-        // whether `$0:Eq`, where $0 was the value substituted for\n-        // `T`, which could then be checked against the very same\n-        // impl). This problem is avoided by the stricter rules around\n-        // unbound type variables by intercrate. I suspect that in the\n-        // latter case a more fine-grained rule would suffice (i.e.,\n-        // consider it ambiguous if even 1 impl matches, no need to\n-        // figure out which one, but call it unimplemented if 0 impls\n-        // match).\n-        let result = self.evaluate_stack_intercrate(&stack);\n+        let result = self.evaluate_stack(&stack);\n \n         debug!(\"result: {}\", result);\n         result\n     }\n \n-    fn evaluate_stack_intercrate(&mut self,\n+    fn evaluate_stack(&mut self,\n                       stack: &ObligationStack)\n                       -> EvaluationResult\n     {\n-        // Whenever any of the types are unbound, there can always be\n-        // an impl.  Even if there are no impls in this crate, perhaps\n-        // the type would be unified with something from another crate\n-        // that does provide an impl.\n+        // In intercrate mode, whenever any of the types are unbound,\n+        // there can always be an impl. Even if there are no impls in\n+        // this crate, perhaps the type would be unified with\n+        // something from another crate that does provide an impl.\n+        //\n+        // In intracrate mode, we must still be conservative. The reason is\n+        // that we want to avoid cycles. Imagine an impl like:\n+        //\n+        //     impl<T:Eq> Eq for Vec<T>\n+        //\n+        // and a trait reference like `$0 : Eq` where `$0` is an\n+        // unbound variable. When we evaluate this trait-reference, we\n+        // will unify `$0` with `Vec<$1>` (for some fresh variable\n+        // `$1`), on the condition that `$1 : Eq`. We will then wind\n+        // up with many candidates (since that are other `Eq` impls\n+        // that apply) and try to winnow things down. This results in\n+        // a recurssive evaluation that `$1 : Eq` -- as you can\n+        // imagine, this is just where we started. To avoid that, we\n+        // check for unbound variables and return an ambiguous (hence possible)\n+        // match if we've seen this trait before.\n+        //\n+        // This suffices to allow chains like `FnMut` implemented in\n+        // terms of `Fn` etc, but we could probably make this more\n+        // precise still.\n         let input_types = stack.skol_trait_ref.input_types();\n-        if input_types.iter().any(|&t| ty::type_is_skolemized(t)) {\n-            debug!(\"evaluate_stack_intercrate({}) --> unbound argument, must be ambiguous\",\n+        let unbound_input_types = input_types.iter().any(|&t| ty::type_is_skolemized(t));\n+        if\n+            unbound_input_types &&\n+             (self.intercrate ||\n+              stack.iter().skip(1).any(\n+                  |prev| stack.skol_trait_ref.def_id == prev.skol_trait_ref.def_id))\n+        {\n+            debug!(\"evaluate_stack_intracrate({}) --> unbound argument, recursion -->  ambiguous\",\n                    stack.skol_trait_ref.repr(self.tcx()));\n             return EvaluatedToAmbig;\n         }\n \n-        self.evaluate_stack_intracrate(stack)\n-    }\n-\n-    fn evaluate_stack_intracrate(&mut self,\n-                                 stack: &ObligationStack)\n-                                 -> EvaluationResult\n-    {\n         // If there is any previous entry on the stack that precisely\n         // matches this obligation, then we can assume that the\n         // obligation is satisfied for now (still all other conditions\n@@ -592,7 +605,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Err(_) => { return Err(()); }\n             }\n \n-            if self.evaluate_obligation_intracrate(obligation) {\n+            if self.evaluate_obligation(obligation) {\n                 Ok(())\n             } else {\n                 Err(())\n@@ -804,12 +817,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                                           &candidates[i],\n                                                                           &candidates[j]));\n                 if is_dup {\n-                    debug!(\"Dropping candidate #{}/#{}: {}\",\n+                    debug!(\"Dropping candidate #{}/{}: {}\",\n                            i, candidates.len(), candidates[i].repr(self.tcx()));\n                     candidates.swap_remove(i);\n                 } else {\n-                    debug!(\"Retaining candidate #{}/#{}\",\n-                           i, candidates.len());\n+                    debug!(\"Retaining candidate #{}/{}: {}\",\n+                           i, candidates.len(), candidates[i].repr(self.tcx()));\n                     i += 1;\n                 }\n             }\n@@ -828,7 +841,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // be the case that you could still satisfy the obligation\n         // from another crate by instantiating the type variables with\n         // a type from another crate that does have an impl. This case\n-        // is checked for in `evaluate_obligation` (and hence users\n+        // is checked for in `evaluate_stack` (and hence users\n         // who might care about this case, like coherence, should use\n         // that function).\n         if candidates.len() == 0 {\n@@ -849,6 +862,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // global cache. We want the cache that is specific to this\n         // scope whenever where clauses might affect the result.\n \n+        // Avoid using the master cache during coherence and just rely\n+        // on the local cache. This effectively disables caching\n+        // during coherence. It is really just a simplification to\n+        // avoid us having to fear that coherence results \"pollute\"\n+        // the master cache. Since coherence executes pretty quickly,\n+        // it's not worth going to more trouble to increase the\n+        // hit-rate I don't think.\n+        if self.intercrate {\n+            return &self.param_env.selection_cache;\n+        }\n+\n         // If the trait refers to any parameters in scope, then use\n         // the cache of the param-environment.\n         if"}, {"sha": "f854bc52acd7b3a009c4f230f58ff527f8b5483b", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=0e2f9b948564708085373fc28d91b4524c821fa3", "patch": "@@ -235,7 +235,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(\n     let mut selcx = traits::SelectionContext::new(fcx.infcx(),\n                                                   &fcx.inh.param_env,\n                                                   fcx);\n-    if !selcx.evaluate_obligation_intracrate(&obligation) {\n+    if !selcx.evaluate_obligation(&obligation) {\n         debug!(\"--> Cannot match obligation\");\n         return None; // Cannot be matched, no such method resolution is possible.\n     }"}, {"sha": "bcb875a6aa830de52350c615ddf051b11c8858cf", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=0e2f9b948564708085373fc28d91b4524c821fa3", "patch": "@@ -2147,11 +2147,11 @@ fn try_overloaded_call<'a>(fcx: &FnCtxt,\n         _ => {}\n     }\n \n-    // Try `FnOnce`, then `FnMut`, then `Fn`.\n+    // Try the options that are least restrictive on the caller first.\n     for &(maybe_function_trait, method_name) in [\n-        (fcx.tcx().lang_items.fn_once_trait(), token::intern(\"call_once\")),\n+        (fcx.tcx().lang_items.fn_trait(), token::intern(\"call\")),\n         (fcx.tcx().lang_items.fn_mut_trait(), token::intern(\"call_mut\")),\n-        (fcx.tcx().lang_items.fn_trait(), token::intern(\"call\"))\n+        (fcx.tcx().lang_items.fn_once_trait(), token::intern(\"call_once\")),\n     ].iter() {\n         let function_trait = match maybe_function_trait {\n             None => continue,\n@@ -3493,6 +3493,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             ast::FnOnceUnboxedClosureKind => ty::FnOnceUnboxedClosureKind,\n         };\n \n+        debug!(\"unboxed_closure for {} --> sig={} kind={}\",\n+               local_def(expr.id).repr(fcx.tcx()),\n+               fn_ty.sig.repr(fcx.tcx()),\n+               kind);\n+\n         let unboxed_closure = ty::UnboxedClosure {\n             closure_type: fn_ty,\n             kind: kind,"}, {"sha": "20d7262432f0c82de9c1d7e811a8fe03e1bf12d0", "filename": "src/test/compile-fail/unboxed-closures-fnmut-as-fn.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs?ref=0e2f9b948564708085373fc28d91b4524c821fa3", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks that the Fn trait hierarchy rules do not permit\n+// Fn to be used where FnMut is implemented.\n+\n+#![feature(unboxed_closure_sugar)]\n+#![feature(overloaded_calls)]\n+\n+use std::ops::{Fn,FnMut,FnOnce};\n+\n+struct S;\n+\n+impl FnMut<(int,),int> for S {\n+    extern \"rust-call\" fn call_mut(&mut self, (x,): (int,)) -> int {\n+        x * x\n+    }\n+}\n+\n+fn call_it<F:Fn(int)->int>(f: &F, x: int) -> int {\n+    f.call((x,))\n+}\n+\n+fn main() {\n+    let x = call_it(&S, 22); //~ ERROR not implemented\n+}\n+"}, {"sha": "4fa72b383067d5bca025e40a3492549ce980c8d0", "filename": "src/test/compile-fail/unboxed-closures-static-call-wrong-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs?ref=0e2f9b948564708085373fc28d91b4524c821fa3", "patch": "@@ -12,6 +12,6 @@\n \n fn main() {\n     let mut_ = |&mut: x| x;\n-    mut_.call_once((0i, )); //~ ERROR type `closure` does not implement\n+    mut_.call((0i, )); //~ ERROR type `closure` does not implement\n }\n "}, {"sha": "5a22490b6d6168cd280816954de0803a0ba03031", "filename": "src/test/compile-fail/unboxed-closures-vtable-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs?ref=0e2f9b948564708085373fc28d91b4524c821fa3", "patch": "@@ -18,7 +18,7 @@ fn call_it<F:FnMut<(int,int),int>>(y: int, mut f: F) -> int {\n \n pub fn main() {\n     let f = |&mut: x: uint, y: int| -> int { (x as int) + y };\n-    let z = call_it(3, f);  //~ ERROR type mismatch\n+    let z = call_it(3, f);  //~ ERROR not implemented\n     println!(\"{}\", z);\n }\n "}, {"sha": "e15fe8ad049b032ae25527b54be522071a6f3b0a", "filename": "src/test/compile-fail/unboxed-closures-wrong-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs?ref=0e2f9b948564708085373fc28d91b4524c821fa3", "patch": "@@ -10,13 +10,13 @@\n \n #![feature(lang_items, overloaded_calls, unboxed_closures)]\n \n-fn c<F:FnOnce(int, int) -> int>(f: F) -> int {\n+fn c<F:Fn(int, int) -> int>(f: F) -> int {\n     f(5, 6)\n }\n \n fn main() {\n     let z: int = 7;\n-    assert_eq!(c(|&: x: int, y| x + y + z), 10);\n+    assert_eq!(c(|&mut: x: int, y| x + y + z), 10);\n     //~^ ERROR not implemented\n }\n "}, {"sha": "f36594cb401450b683707ae717c752eafefe1499", "filename": "src/test/run-pass/issue-16668.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Frun-pass%2Fissue-16668.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Frun-pass%2Fissue-16668.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16668.rs?ref=0e2f9b948564708085373fc28d91b4524c821fa3", "patch": "@@ -20,8 +20,8 @@ impl<'a, I, O: 'a> Parser<'a, I, O> {\n     fn compose<K: 'a>(mut self, mut rhs: Parser<'a, O, K>) -> Parser<'a, I, K> {\n         Parser {\n             parse: box move |&mut: x: I| {\n-                match self.parse.call_mut((x,)) {\n-                    Ok(r) => rhs.parse.call_mut((r,)),\n+                match (*self.parse).call_mut((x,)) {\n+                    Ok(r) => (*rhs.parse).call_mut((r,)),\n                     Err(e) => Err(e)\n                 }\n             }"}, {"sha": "82d51ba1f16456e5c120ea9efbba223e1220cd8a", "filename": "src/test/run-pass/unboxed-closures-extern-fn.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Frun-pass%2Funboxed-closures-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Frun-pass%2Funboxed-closures-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-extern-fn.rs?ref=0e2f9b948564708085373fc28d91b4524c821fa3", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks that extern fn points implement the full range of Fn traits.\n+\n+#![feature(unboxed_closure_sugar)]\n+#![feature(overloaded_calls)]\n+\n+use std::ops::{Fn,FnMut,FnOnce};\n+\n+fn square(x: int) -> int { x * x }\n+\n+fn call_it<F:Fn(int)->int>(f: &F, x: int) -> int {\n+    f.call((x,))\n+}\n+\n+fn call_it_mut<F:FnMut(int)->int>(f: &mut F, x: int) -> int {\n+    f.call_mut((x,))\n+}\n+\n+fn call_it_once<F:FnOnce(int)->int>(f: F, x: int) -> int {\n+    f.call_once((x,))\n+}\n+\n+fn main() {\n+    let x = call_it(&square, 22);\n+    let y = call_it_mut(&mut square, 22);\n+    let z = call_it_once(square, 22);\n+    assert_eq!(x, square(22));\n+    assert_eq!(y, square(22));\n+    assert_eq!(z, square(22));\n+}\n+"}, {"sha": "90272636bc59db86ba0e96517980a8c8a481dc8e", "filename": "src/test/run-pass/unboxed-closures-fn-as-fnmut-and-fnonce.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Frun-pass%2Funboxed-closures-fn-as-fnmut-and-fnonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Frun-pass%2Funboxed-closures-fn-as-fnmut-and-fnonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-fn-as-fnmut-and-fnonce.rs?ref=0e2f9b948564708085373fc28d91b4524c821fa3", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks that the Fn trait hierarchy rules permit\n+// any Fn trait to be used where Fn is implemented.\n+\n+#![feature(unboxed_closure_sugar)]\n+#![feature(overloaded_calls)]\n+\n+use std::ops::{Fn,FnMut,FnOnce};\n+\n+struct S;\n+\n+impl Fn<(int,),int> for S {\n+    extern \"rust-call\" fn call(&self, (x,): (int,)) -> int {\n+        x * x\n+    }\n+}\n+\n+fn call_it<F:Fn(int)->int>(f: &F, x: int) -> int {\n+    f.call((x,))\n+}\n+\n+fn call_it_mut<F:FnMut(int)->int>(f: &mut F, x: int) -> int {\n+    f.call_mut((x,))\n+}\n+\n+fn call_it_once<F:FnOnce(int)->int>(f: F, x: int) -> int {\n+    f.call_once((x,))\n+}\n+\n+fn main() {\n+    let x = call_it(&S, 22);\n+    let y = call_it_mut(&mut S, 22);\n+    let z = call_it_once(S, 22);\n+    assert_eq!(x, y);\n+    assert_eq!(y, z);\n+}\n+"}, {"sha": "bd01910a210ab5f3b123eaf3ba6171d1453a9cdd", "filename": "src/test/run-pass/unboxed-closures-fnmut-as-fnonce.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Frun-pass%2Funboxed-closures-fnmut-as-fnonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Frun-pass%2Funboxed-closures-fnmut-as-fnonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-fnmut-as-fnonce.rs?ref=0e2f9b948564708085373fc28d91b4524c821fa3", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks that the Fn trait hierarchy rules permit\n+// FnMut or FnOnce to be used where FnMut is implemented.\n+\n+#![feature(unboxed_closure_sugar)]\n+#![feature(overloaded_calls)]\n+\n+use std::ops::{FnMut,FnOnce};\n+\n+struct S;\n+\n+impl FnMut<(int,),int> for S {\n+    extern \"rust-call\" fn call_mut(&mut self, (x,): (int,)) -> int {\n+        x * x\n+    }\n+}\n+\n+fn call_it_mut<F:FnMut(int)->int>(f: &mut F, x: int) -> int {\n+    f.call_mut((x,))\n+}\n+\n+fn call_it_once<F:FnOnce(int)->int>(f: F, x: int) -> int {\n+    f.call_once((x,))\n+}\n+\n+fn main() {\n+    let y = call_it_mut(&mut S, 22);\n+    let z = call_it_once(S, 22);\n+    assert_eq!(y, z);\n+}\n+"}, {"sha": "b0947f46a86ae9b6ef6842b0c03792aa352b0a3f", "filename": "src/test/run-pass/unboxed-closures-manual-impl.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs?ref=0e2f9b948564708085373fc28d91b4524c821fa3", "previous_filename": "src/test/run-pass/fn-trait-sugar.rs"}, {"sha": "f2eddd84af83252009bc8e96f81fcaa1329e8f6a", "filename": "src/test/run-pass/unboxed-closures-zero-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Frun-pass%2Funboxed-closures-zero-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2f9b948564708085373fc28d91b4524c821fa3/src%2Ftest%2Frun-pass%2Funboxed-closures-zero-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-zero-args.rs?ref=0e2f9b948564708085373fc28d91b4524c821fa3", "patch": "@@ -12,6 +12,6 @@\n \n fn main() {\n     let mut zero = |&mut:| {};\n-    zero.call_mut(());\n+    let () = zero.call_mut(());\n }\n "}]}