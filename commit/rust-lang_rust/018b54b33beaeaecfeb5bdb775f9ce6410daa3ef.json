{"sha": "018b54b33beaeaecfeb5bdb775f9ce6410daa3ef", "node_id": "C_kwDOAAsO6NoAKDAxOGI1NGIzM2JlYWVhZWNmZWI1YmRiNzc1ZjljZTY0MTBkYWEzZWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-12T00:21:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-12T00:21:28Z"}, "message": "Auto merge of #9458 - Alexendoo:expr-field-visitor, r=giraffate\n\nUse `visit_expr_field` for `ParamPosition`\n\nA small change to make it a little simpler\n\nchangelog: none", "tree": {"sha": "b4997080aa8052c39d143d935232e8a20fabfa11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4997080aa8052c39d143d935232e8a20fabfa11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/018b54b33beaeaecfeb5bdb775f9ce6410daa3ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/018b54b33beaeaecfeb5bdb775f9ce6410daa3ef", "html_url": "https://github.com/rust-lang/rust/commit/018b54b33beaeaecfeb5bdb775f9ce6410daa3ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/018b54b33beaeaecfeb5bdb775f9ce6410daa3ef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69f6009f855e33b5685f5b4c4fff479cee53410f", "url": "https://api.github.com/repos/rust-lang/rust/commits/69f6009f855e33b5685f5b4c4fff479cee53410f", "html_url": "https://github.com/rust-lang/rust/commit/69f6009f855e33b5685f5b4c4fff479cee53410f"}, {"sha": "1b245e7e0e83d387ab9d2cc7a157b081ba5d0ef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b245e7e0e83d387ab9d2cc7a157b081ba5d0ef2", "html_url": "https://github.com/rust-lang/rust/commit/1b245e7e0e83d387ab9d2cc7a157b081ba5d0ef2"}], "stats": {"total": 87, "additions": 36, "deletions": 51}, "files": [{"sha": "058a15590ab259d3c8d470ec68eb950515c9c1a1", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 36, "deletions": 51, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/018b54b33beaeaecfeb5bdb775f9ce6410daa3ef/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018b54b33beaeaecfeb5bdb775f9ce6410daa3ef/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=018b54b33beaeaecfeb5bdb775f9ce6410daa3ef", "patch": "@@ -8,7 +8,7 @@ use arrayvec::ArrayVec;\n use itertools::{izip, Either, Itertools};\n use rustc_ast::ast::LitKind;\n use rustc_hir::intravisit::Visitor;\n-use rustc_hir::{self as hir, Expr, ExprKind, HirId, Node, QPath};\n+use rustc_hir::{self as hir, Expr, ExprField, ExprKind, HirId, Node, QPath};\n use rustc_lexer::unescape::unescape_literal;\n use rustc_lexer::{tokenize, unescape, LiteralKind, TokenKind};\n use rustc_lint::LateContext;\n@@ -485,64 +485,49 @@ struct ParamPosition {\n     precision: Option<usize>,\n }\n \n-/// Parses the `fmt` arg of `Arguments::new_v1_formatted(pieces, args, fmt, _)`\n-fn parse_rt_fmt<'tcx>(fmt_arg: &'tcx Expr<'tcx>) -> Option<impl Iterator<Item = ParamPosition> + 'tcx> {\n-    fn parse_count(expr: &Expr<'_>) -> Option<usize> {\n-        // ::core::fmt::rt::v1::Count::Param(1usize),\n-        if let ExprKind::Call(ctor, [val]) = expr.kind\n-            && let ExprKind::Path(QPath::Resolved(_, path)) = ctor.kind\n-            && path.segments.last()?.ident.name == sym::Param\n-            && let ExprKind::Lit(lit) = &val.kind\n-            && let LitKind::Int(pos, _) = lit.node\n-        {\n-            Some(pos as usize)\n-        } else {\n-            None\n+impl<'tcx> Visitor<'tcx> for ParamPosition {\n+    fn visit_expr_field(&mut self, field: &'tcx ExprField<'tcx>) {\n+        fn parse_count(expr: &Expr<'_>) -> Option<usize> {\n+            // ::core::fmt::rt::v1::Count::Param(1usize),\n+            if let ExprKind::Call(ctor, [val]) = expr.kind\n+                && let ExprKind::Path(QPath::Resolved(_, path)) = ctor.kind\n+                && path.segments.last()?.ident.name == sym::Param\n+                && let ExprKind::Lit(lit) = &val.kind\n+                && let LitKind::Int(pos, _) = lit.node\n+            {\n+                Some(pos as usize)\n+            } else {\n+                None\n+            }\n+        }\n+\n+        match field.ident.name {\n+            sym::position => {\n+                if let ExprKind::Lit(lit) = &field.expr.kind\n+                    && let LitKind::Int(pos, _) = lit.node\n+                {\n+                    self.value = pos as usize;\n+                }\n+            },\n+            sym::precision => {\n+                self.precision = parse_count(field.expr);\n+            },\n+            sym::width => {\n+                self.width = parse_count(field.expr);\n+            },\n+            _ => {},\n         }\n     }\n+}\n \n+/// Parses the `fmt` arg of `Arguments::new_v1_formatted(pieces, args, fmt, _)`\n+fn parse_rt_fmt<'tcx>(fmt_arg: &'tcx Expr<'tcx>) -> Option<impl Iterator<Item = ParamPosition> + 'tcx> {\n     if let ExprKind::AddrOf(.., array) = fmt_arg.kind\n         && let ExprKind::Array(specs) = array.kind\n     {\n         Some(specs.iter().map(|spec| {\n             let mut position = ParamPosition::default();\n-\n-            // ::core::fmt::rt::v1::Argument {\n-            //     position: 0usize,\n-            //     format: ::core::fmt::rt::v1::FormatSpec {\n-            //         ..\n-            //         precision: ::core::fmt::rt::v1::Count::Implied,\n-            //         width: ::core::fmt::rt::v1::Count::Implied,\n-            //     },\n-            // }\n-\n-            // TODO: this can be made much nicer next sync with `Visitor::visit_expr_field`\n-            if let ExprKind::Struct(_, fields, _) = spec.kind {\n-                for field in fields {\n-                    match (field.ident.name, &field.expr.kind) {\n-                        (sym::position, ExprKind::Lit(lit)) => {\n-                            if let LitKind::Int(pos, _) = lit.node {\n-                                position.value = pos as usize;\n-                            }\n-                        },\n-                        (sym::format, &ExprKind::Struct(_, spec_fields, _)) => {\n-                            for spec_field in spec_fields {\n-                                match spec_field.ident.name {\n-                                    sym::precision => {\n-                                        position.precision = parse_count(spec_field.expr);\n-                                    },\n-                                    sym::width => {\n-                                        position.width = parse_count(spec_field.expr);\n-                                    },\n-                                    _ => {},\n-                                }\n-                            }\n-                        },\n-                        _ => {},\n-                    }\n-                }\n-            }\n-\n+            position.visit_expr(spec);\n             position\n         }))\n     } else {"}]}