{"sha": "1b9ab8939efc1a38a7a5398a069517466fd88d38", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiOWFiODkzOWVmYzFhMzhhN2E1Mzk4YTA2OTUxNzQ2NmZkODhkMzg=", "commit": {"author": {"name": "Linus F\u00e4rnstrand", "email": "faern@faern.net", "date": "2018-05-29T09:42:13Z"}, "committer": {"name": "Linus F\u00e4rnstrand", "email": "faern@faern.net", "date": "2018-06-02T10:03:10Z"}, "message": "Make most integer operations const fns", "tree": {"sha": "0798053635624823b0588e3d030c1b354f7ebd75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0798053635624823b0588e3d030c1b354f7ebd75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b9ab8939efc1a38a7a5398a069517466fd88d38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b9ab8939efc1a38a7a5398a069517466fd88d38", "html_url": "https://github.com/rust-lang/rust/commit/1b9ab8939efc1a38a7a5398a069517466fd88d38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b9ab8939efc1a38a7a5398a069517466fd88d38/comments", "author": {"login": "faern", "id": 332294, "node_id": "MDQ6VXNlcjMzMjI5NA==", "avatar_url": "https://avatars.githubusercontent.com/u/332294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/faern", "html_url": "https://github.com/faern", "followers_url": "https://api.github.com/users/faern/followers", "following_url": "https://api.github.com/users/faern/following{/other_user}", "gists_url": "https://api.github.com/users/faern/gists{/gist_id}", "starred_url": "https://api.github.com/users/faern/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/faern/subscriptions", "organizations_url": "https://api.github.com/users/faern/orgs", "repos_url": "https://api.github.com/users/faern/repos", "events_url": "https://api.github.com/users/faern/events{/privacy}", "received_events_url": "https://api.github.com/users/faern/received_events", "type": "User", "site_admin": false}, "committer": {"login": "faern", "id": 332294, "node_id": "MDQ6VXNlcjMzMjI5NA==", "avatar_url": "https://avatars.githubusercontent.com/u/332294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/faern", "html_url": "https://github.com/faern", "followers_url": "https://api.github.com/users/faern/followers", "following_url": "https://api.github.com/users/faern/following{/other_user}", "gists_url": "https://api.github.com/users/faern/gists{/gist_id}", "starred_url": "https://api.github.com/users/faern/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/faern/subscriptions", "organizations_url": "https://api.github.com/users/faern/orgs", "repos_url": "https://api.github.com/users/faern/repos", "events_url": "https://api.github.com/users/faern/events{/privacy}", "received_events_url": "https://api.github.com/users/faern/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2954cb511922173b714aa930f6bd1721d40fa02d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2954cb511922173b714aa930f6bd1721d40fa02d", "html_url": "https://github.com/rust-lang/rust/commit/2954cb511922173b714aa930f6bd1721d40fa02d"}], "stats": {"total": 155, "additions": 115, "deletions": 40}, "files": [{"sha": "71a727f4c017b5a2c7bcc17f553825ee21dae195", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b9ab8939efc1a38a7a5398a069517466fd88d38/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b9ab8939efc1a38a7a5398a069517466fd88d38/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=1b9ab8939efc1a38a7a5398a069517466fd88d38", "patch": "@@ -81,6 +81,7 @@\n #![feature(cfg_target_has_atomic)]\n #![feature(concat_idents)]\n #![feature(const_fn)]\n+#![feature(const_int_ops)]\n #![feature(core_float)]\n #![feature(custom_attribute)]\n #![feature(doc_cfg)]"}, {"sha": "60fdd4a3642f6e88225ca803ccece9fda8147689", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 114, "deletions": 40, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/1b9ab8939efc1a38a7a5398a069517466fd88d38/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b9ab8939efc1a38a7a5398a069517466fd88d38/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=1b9ab8939efc1a38a7a5398a069517466fd88d38", "patch": "@@ -267,8 +267,9 @@ $EndFeature, \"\n ```\n \"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n-            pub fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n+            pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n         }\n \n         doc_comment! {\n@@ -282,8 +283,9 @@ Basic usage:\n \", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value().count_zeros(), 1);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n-            pub fn count_zeros(self) -> u32 {\n+            pub const fn count_zeros(self) -> u32 {\n                 (!self).count_ones()\n             }\n         }\n@@ -302,8 +304,9 @@ assert_eq!(n.leading_zeros(), 0);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n-            pub fn leading_zeros(self) -> u32 {\n+            pub const fn leading_zeros(self) -> u32 {\n                 (self as $UnsignedT).leading_zeros()\n             }\n         }\n@@ -322,8 +325,9 @@ assert_eq!(n.trailing_zeros(), 2);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n-            pub fn trailing_zeros(self) -> u32 {\n+            pub const fn trailing_zeros(self) -> u32 {\n                 (self as $UnsignedT).trailing_zeros()\n             }\n         }\n@@ -396,8 +400,9 @@ $EndFeature, \"\n         /// assert_eq!(m, 21760);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[rustc_const_unstable(feature = \"const_int_ops\")]\n         #[inline]\n-        pub fn swap_bytes(self) -> Self {\n+        pub const fn swap_bytes(self) -> Self {\n             (self as $UnsignedT).swap_bytes() as Self\n         }\n \n@@ -447,9 +452,17 @@ if cfg!(target_endian = \\\"big\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n-            pub fn from_be(x: Self) -> Self {\n-                if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n+            pub const fn from_be(x: Self) -> Self {\n+                #[cfg(target_endian = \"big\")]\n+                {\n+                    x\n+                }\n+                #[cfg(not(target_endian = \"big\"))]\n+                {\n+                    x.swap_bytes()\n+                }\n             }\n         }\n \n@@ -473,9 +486,17 @@ if cfg!(target_endian = \\\"little\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n-            pub fn from_le(x: Self) -> Self {\n-                if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n+            pub const fn from_le(x: Self) -> Self {\n+                #[cfg(target_endian = \"little\")]\n+                {\n+                    x\n+                }\n+                #[cfg(not(target_endian = \"little\"))]\n+                {\n+                    x.swap_bytes()\n+                }\n             }\n         }\n \n@@ -499,9 +520,17 @@ if cfg!(target_endian = \\\"big\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n-            pub fn to_be(self) -> Self { // or not to be?\n-                if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n+            pub const fn to_be(self) -> Self { // or not to be?\n+                #[cfg(target_endian = \"big\")]\n+                {\n+                    self\n+                }\n+                #[cfg(not(target_endian = \"big\"))]\n+                {\n+                    self.swap_bytes()\n+                }\n             }\n         }\n \n@@ -525,9 +554,17 @@ if cfg!(target_endian = \\\"little\\\") {\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n-            pub fn to_le(self) -> Self {\n-                if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n+            pub const fn to_le(self) -> Self {\n+                #[cfg(target_endian = \"little\")]\n+                {\n+                    self\n+                }\n+                #[cfg(not(target_endian = \"little\"))]\n+                {\n+                    self.swap_bytes()\n+                }\n             }\n         }\n \n@@ -1943,6 +1980,19 @@ impl isize {\n     int_impl! { isize, i64, u64, 64, -9223372036854775808, 9223372036854775807, \"\", \"\" }\n }\n \n+// Emits the correct `cttz` call, depending on the size of the type.\n+macro_rules! uint_cttz_call {\n+    // As of LLVM 3.6 the codegen for the zero-safe cttz8 intrinsic\n+    // emits two conditional moves on x86_64. By promoting the value to\n+    // u16 and setting bit 8, we get better code without any conditional\n+    // operations.\n+    // FIXME: There's a LLVM patch (http://reviews.llvm.org/D9284)\n+    // pending, remove this workaround once LLVM generates better code\n+    // for cttz8.\n+    ($value:expr, 8) => { intrinsics::cttz($value as u16 | 0x100) };\n+    ($value:expr, $_BITS:expr) => { intrinsics::cttz($value) }\n+}\n+\n // `Int` + `UnsignedInt` implemented for unsigned integers\n macro_rules! uint_impl {\n     ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr, $Feature:expr, $EndFeature:expr) => {\n@@ -2020,8 +2070,9 @@ Basic usage:\n assert_eq!(n.count_ones(), 3);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n-            pub fn count_ones(self) -> u32 {\n+            pub const fn count_ones(self) -> u32 {\n                 unsafe { intrinsics::ctpop(self as $ActualT) as u32 }\n             }\n         }\n@@ -2037,8 +2088,9 @@ Basic usage:\n \", $Feature, \"assert_eq!(\", stringify!($SelfT), \"::max_value().count_zeros(), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n-            pub fn count_zeros(self) -> u32 {\n+            pub const fn count_zeros(self) -> u32 {\n                 (!self).count_ones()\n             }\n         }\n@@ -2056,8 +2108,9 @@ Basic usage:\n assert_eq!(n.leading_zeros(), 2);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n-            pub fn leading_zeros(self) -> u32 {\n+            pub const fn leading_zeros(self) -> u32 {\n                 unsafe { intrinsics::ctlz(self as $ActualT) as u32 }\n             }\n         }\n@@ -2076,22 +2129,10 @@ Basic usage:\n assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n-            pub fn trailing_zeros(self) -> u32 {\n-                // As of LLVM 3.6 the codegen for the zero-safe cttz8 intrinsic\n-                // emits two conditional moves on x86_64. By promoting the value to\n-                // u16 and setting bit 8, we get better code without any conditional\n-                // operations.\n-                // FIXME: There's a LLVM patch (http://reviews.llvm.org/D9284)\n-                // pending, remove this workaround once LLVM generates better code\n-                // for cttz8.\n-                unsafe {\n-                    if $BITS == 8 {\n-                        intrinsics::cttz(self as u16 | 0x100) as u32\n-                    } else {\n-                        intrinsics::cttz(self) as u32\n-                    }\n-                }\n+            pub const fn trailing_zeros(self) -> u32 {\n+                unsafe { uint_cttz_call!(self, $BITS) as u32 }\n             }\n         }\n \n@@ -2167,8 +2208,9 @@ assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n         /// assert_eq!(m, 21760);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[rustc_const_unstable(feature = \"const_int_ops\")]\n         #[inline]\n-        pub fn swap_bytes(self) -> Self {\n+        pub const fn swap_bytes(self) -> Self {\n             unsafe { intrinsics::bswap(self as $ActualT) as Self }\n         }\n \n@@ -2218,9 +2260,17 @@ if cfg!(target_endian = \\\"big\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n-            pub fn from_be(x: Self) -> Self {\n-                if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n+            pub const fn from_be(x: Self) -> Self {\n+                #[cfg(target_endian = \"big\")]\n+                {\n+                    x\n+                }\n+                #[cfg(not(target_endian = \"big\"))]\n+                {\n+                    x.swap_bytes()\n+                }\n             }\n         }\n \n@@ -2244,9 +2294,17 @@ if cfg!(target_endian = \\\"little\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n-            pub fn from_le(x: Self) -> Self {\n-                if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n+            pub const fn from_le(x: Self) -> Self {\n+                #[cfg(target_endian = \"little\")]\n+                {\n+                    x\n+                }\n+                #[cfg(not(target_endian = \"little\"))]\n+                {\n+                    x.swap_bytes()\n+                }\n             }\n         }\n \n@@ -2270,9 +2328,17 @@ if cfg!(target_endian = \\\"big\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n-            pub fn to_be(self) -> Self { // or not to be?\n-                if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n+            pub const fn to_be(self) -> Self { // or not to be?\n+                #[cfg(target_endian = \"big\")]\n+                {\n+                    self\n+                }\n+                #[cfg(not(target_endian = \"big\"))]\n+                {\n+                    self.swap_bytes()\n+                }\n             }\n         }\n \n@@ -2296,9 +2362,17 @@ if cfg!(target_endian = \\\"little\\\") {\n }\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n-            pub fn to_le(self) -> Self {\n-                if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n+            pub const fn to_le(self) -> Self {\n+                #[cfg(target_endian = \"little\")]\n+                {\n+                    self\n+                }\n+                #[cfg(not(target_endian = \"little\"))]\n+                {\n+                    self.swap_bytes()\n+                }\n             }\n         }\n "}]}