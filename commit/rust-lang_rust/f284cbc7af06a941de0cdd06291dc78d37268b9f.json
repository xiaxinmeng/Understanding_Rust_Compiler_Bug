{"sha": "f284cbc7af06a941de0cdd06291dc78d37268b9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyODRjYmM3YWYwNmE5NDFkZTBjZGQwNjI5MWRjNzhkMzcyNjhiOWY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-09-24T20:05:02Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-09-24T20:05:02Z"}, "message": "Cleanup interfaces of Name, SyntaxContext and Ident\nMake sure Name, SyntaxContext and Ident are passed by value\nMake sure Idents don't serve as keys (or parts of keys) in maps, Ident comparison is not well defined", "tree": {"sha": "94b287ceb5755130191c61dbefd317da66ccd4be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94b287ceb5755130191c61dbefd317da66ccd4be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f284cbc7af06a941de0cdd06291dc78d37268b9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f284cbc7af06a941de0cdd06291dc78d37268b9f", "html_url": "https://github.com/rust-lang/rust/commit/f284cbc7af06a941de0cdd06291dc78d37268b9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f284cbc7af06a941de0cdd06291dc78d37268b9f/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40ce80484c636e525ac796a81f38a96c0ca8bf09", "url": "https://api.github.com/repos/rust-lang/rust/commits/40ce80484c636e525ac796a81f38a96c0ca8bf09", "html_url": "https://github.com/rust-lang/rust/commit/40ce80484c636e525ac796a81f38a96c0ca8bf09"}], "stats": {"total": 449, "additions": 195, "deletions": 254}, "files": [{"sha": "b7714a7e3c5dd96ec94ec4c2e9e86f2310d2d247", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -35,7 +35,7 @@ use syntax::parse::lexer::TokenAndSpan;\n \n fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n     fn id() -> token::Token {\n-        token::Ident(ast::Ident { name: Name(0), ctxt: 0, }, token::Plain)\n+        token::Ident(ast::Ident::with_empty_ctxt(Name(0))), token::Plain)\n     }\n \n     let mut res = HashMap::new();\n@@ -75,7 +75,7 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"RPAREN\"            => token::CloseDelim(token::Paren),\n             \"SLASH\"             => token::BinOp(token::Slash),\n             \"COMMA\"             => token::Comma,\n-            \"LIFETIME\"          => token::Lifetime(ast::Ident { name: Name(0), ctxt: 0 }),\n+            \"LIFETIME\"          => token::Lifetime(ast::Ident::with_empty_ctxt(Name(0))),\n             \"CARET\"             => token::BinOp(token::Caret),\n             \"TILDE\"             => token::Tilde,\n             \"IDENT\"             => id(),\n@@ -208,9 +208,9 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>, surrogate_\n         token::Literal(token::ByteStr(..), n)    => token::Literal(token::ByteStr(nm), n),\n         token::Literal(token::ByteStrRaw(..), n) => token::Literal(token::ByteStrRaw(fix(content),\n                                                                                 count(content)), n),\n-        token::Ident(..)           => token::Ident(ast::Ident { name: nm, ctxt: 0 },\n+        token::Ident(..)           => token::Ident(ast::Ident::with_empty_ctxt(nm)),\n                                                    token::ModName),\n-        token::Lifetime(..)        => token::Lifetime(ast::Ident { name: nm, ctxt: 0 }),\n+        token::Lifetime(..)        => token::Lifetime(ast::Ident::with_empty_ctxt(nm)),\n         ref t => t.clone()\n     };\n "}, {"sha": "9acd13f0a043906cc9e14e2e8a700705e00085e9", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -482,7 +482,7 @@ impl<'a> CrateReader<'a> {\n                 let span = mk_sp(lo, p.last_span.hi);\n                 p.abort_if_errors();\n                 macros.push(ast::MacroDef {\n-                    ident: name.ident(),\n+                    ident: ast::Ident::with_empty_ctxt(name),\n                     attrs: attrs,\n                     id: ast::DUMMY_NODE_ID,\n                     span: span,"}, {"sha": "3cfcb52f9030fd6ac152e6f453639a202734b378", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -85,7 +85,7 @@ fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {\n                 EntryPointType::MainAttr\n-            } else if item.name == \"main\" {\n+            } else if item.name.as_str() == \"main\" {\n                 if depth == 1 {\n                     // This is a top-level function so can be 'main'\n                     EntryPointType::MainNamed"}, {"sha": "b3e287f6d7d5d7cf13e39ac7194dbe006093d130", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n             ty::TyBareFn(_, ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n-        intrinsic && self.tcx.item_name(def_id) == \"transmute\"\n+        intrinsic && self.tcx.item_name(def_id).as_str() == \"transmute\"\n     }\n \n     fn check_transmute(&self, span: Span, from: Ty<'tcx>, to: Ty<'tcx>, id: ast::NodeId) {"}, {"sha": "0ffa5d7a5e338620849353c73df08bb178c75c08", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -211,7 +211,7 @@ pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> hir::Path {\n     tcx.with_path(id, |path| hir::Path {\n         global: false,\n         segments: path.last().map(|elem| hir::PathSegment {\n-            identifier: ast::Ident::new(elem.name()),\n+            identifier: ast::Ident::with_empty_ctxt(elem.name()),\n             parameters: hir::PathParameters::none(),\n         }).into_iter().collect(),\n         span: DUMMY_SP,"}, {"sha": "596686f32cbc33a8282fd8352e484f869af05ac5", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -336,7 +336,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n         // When compiling with --test we don't enforce stability on the\n         // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n         // name `__test`\n-        if item.span == DUMMY_SP && item.name == \"__test\" { return }\n+        if item.span == DUMMY_SP && item.name.as_str() == \"__test\" { return }\n \n         check_item(self.tcx, item, true,\n                    &mut |id, sp, stab| self.check(id, sp, stab));"}, {"sha": "59f914895ae59e34183a7a7622ccfe4a792d2a51", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -15,7 +15,6 @@ use rustc::middle::ty;\n use std::cell::RefCell;\n use syntax::ast;\n use syntax::codemap;\n-use rustc_front::print::pprust;\n use rustc_front::hir;\n \n pub struct MoveErrorCollector<'tcx> {\n@@ -159,7 +158,6 @@ fn note_move_destination(bccx: &BorrowckCtxt,\n                          move_to_span: codemap::Span,\n                          pat_name: ast::Name,\n                          is_first_note: bool) {\n-    let pat_name = pprust::name_to_string(pat_name);\n     if is_first_note {\n         bccx.span_note(\n             move_to_span,"}, {"sha": "f0fa1ff70c6f398dc55581fb712fa082cc60c3ac", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -380,7 +380,7 @@ impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n                 try!(pp::space(&mut s.s));\n                 // FIXME #16420: this doesn't display the connections\n                 // between syntax contexts\n-                s.synth_comment(format!(\"{}#{}\", nm, ctxt))\n+                s.synth_comment(format!(\"{}#{}\", nm, ctxt.0))\n             }\n             pprust::NodeName(&ast::Name(nm)) => {\n                 try!(pp::space(&mut s.s));"}, {"sha": "c883ff4fd1b201d37f0c6de892f6504b028c6cd5", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -631,15 +631,13 @@ pub enum Expr_ {\n     ///\n     /// `if expr { block } else { expr }`\n     ExprIf(P<Expr>, P<Block>, Option<P<Expr>>),\n-    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n     ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind."}, {"sha": "a5cfcead6a1ded94132ebc62fa0dea6d3f409015", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -2171,7 +2171,6 @@ impl<'a> State<'a> {\n             hir::ViewPathSimple(name, ref path) => {\n                 try!(self.print_path(path, false, 0));\n \n-                // FIXME(#6993) can't compare identifiers directly here\n                 if path.segments.last().unwrap().identifier.name != name {\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\"as\"));"}, {"sha": "989ea104a5dac1c97367ebaba4924602ac84655e", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -50,7 +50,7 @@ impl UnusedMut {\n                 let name = path1.node;\n                 if let hir::BindByValue(hir::MutMutable) = mode {\n                     if !name.as_str().starts_with(\"_\") {\n-                        match mutables.entry(name.usize()) {\n+                        match mutables.entry(name.0 as usize) {\n                             Vacant(entry) => { entry.insert(vec![id]); },\n                             Occupied(mut entry) => { entry.get_mut().push(id); },\n                         }"}, {"sha": "c61f75723c7bd937c13e7d8f0e3fc72ab3a2ca24", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -3710,7 +3710,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 false // Stop advancing\n                             });\n \n-                            if method_scope && special_names::self_ == path_name {\n+                            if method_scope && special_names::self_.as_str() == &path_name[..] {\n                                 resolve_error(\n                                     self,\n                                     expr.span,"}, {"sha": "99d7685f7c8f290dbd770a4685fdecdfb172f3f7", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -537,7 +537,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         fn get_binding(this: &mut Resolver,\n                                        import_resolution: &ImportResolution,\n                                        namespace: Namespace,\n-                                       source: &Name)\n+                                       source: Name)\n                                     -> NamespaceResult {\n \n                             // Import resolutions must be declared with \"pub\"\n@@ -560,7 +560,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                     let id = import_resolution.id(namespace);\n                                     // track used imports and extern crates as well\n                                     this.used_imports.insert((id, namespace));\n-                                    this.record_import_use(id, *source);\n+                                    this.record_import_use(id, source);\n                                     match target_module.def_id.get() {\n                                         Some(DefId{krate: kid, ..}) => {\n                                             this.used_crates.insert(kid);\n@@ -578,14 +578,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                             value_result = get_binding(self.resolver,\n                                                        import_resolution,\n                                                        ValueNS,\n-                                                       &source);\n+                                                       source);\n                             value_used_reexport = import_resolution.is_public;\n                         }\n                         if type_result.is_unknown() {\n                             type_result = get_binding(self.resolver,\n                                                       import_resolution,\n                                                       TypeNS,\n-                                                      &source);\n+                                                      source);\n                             type_used_reexport = import_resolution.is_public;\n                         }\n "}, {"sha": "f25429ee904693becb24f525214fa5686b6f7976", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -444,7 +444,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n     fn process_const(&mut self,\n                      id: ast::NodeId,\n-                     name: &ast::Name,\n+                     name: ast::Name,\n                      span: Span,\n                      typ: &ast::Ty,\n                      expr: &ast::Expr) {\n@@ -988,7 +988,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n         match trait_item.node {\n             ast::ConstTraitItem(ref ty, Some(ref expr)) => {\n-                self.process_const(trait_item.id, &trait_item.ident.name,\n+                self.process_const(trait_item.id, trait_item.ident.name,\n                                    trait_item.span, &*ty, &*expr);\n             }\n             ast::MethodTraitItem(ref sig, ref body) => {\n@@ -1006,7 +1006,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n         match impl_item.node {\n             ast::ConstImplItem(ref ty, ref expr) => {\n-                self.process_const(impl_item.id, &impl_item.ident.name,\n+                self.process_const(impl_item.id, impl_item.ident.name,\n                                    impl_item.span, &ty, &expr);\n             }\n             ast::MethodImplItem(ref sig, ref body) => {"}, {"sha": "78f631371c093f980070834ec7acffef13dbe3cd", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -168,7 +168,7 @@ pub fn return_type_is_void(ccx: &CrateContext, ty: Ty) -> bool {\n /// Generates a unique symbol based off the name given. This is used to create\n /// unique symbols for things like closures.\n pub fn gensym_name(name: &str) -> PathElem {\n-    let num = token::gensym(name).usize();\n+    let num = token::gensym(name).0;\n     // use one colon which will get translated to a period by the mangler, and\n     // we're guaranteed that `num` is globally unique for this crate.\n     PathName(token::gensym(&format!(\"{}:{}\", name, num)))\n@@ -829,7 +829,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n                                                 !null_terminated as Bool);\n \n         let gsym = token::gensym(\"str\");\n-        let sym = format!(\"str{}\", gsym.usize());\n+        let sym = format!(\"str{}\", gsym.0);\n         let g = declare::define_global(cx, &sym[..], val_ty(sc)).unwrap_or_else(||{\n             cx.sess().bug(&format!(\"symbol `{}` is already defined\", sym));\n         });"}, {"sha": "225731cc0f5926751ccb2163d275243a514ec963", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -116,7 +116,7 @@ fn addr_of_mut(ccx: &CrateContext,\n         // FIXME: this totally needs a better name generation scheme, perhaps a simple global\n         // counter? Also most other uses of gensym in trans.\n         let gsym = token::gensym(\"_\");\n-        let name = format!(\"{}{}\", kind, gsym.usize());\n+        let name = format!(\"{}{}\", kind, gsym.0);\n         let gv = declare::define_global(ccx, &name[..], val_ty(cv)).unwrap_or_else(||{\n             ccx.sess().bug(&format!(\"symbol `{}` is already defined\", name));\n         });"}, {"sha": "9d8950c594b1f05270d79af11f8c21dee5feecb2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -838,7 +838,7 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         Position::ArgumentNamed(s) if s == \"Self\" => (),\n                         // So is `{A}` if A is a type parameter\n                         Position::ArgumentNamed(s) => match types.iter().find(|t| {\n-                            t.name == s\n+                            t.name.as_str() == s\n                         }) {\n                             Some(_) => (),\n                             None => {"}, {"sha": "5559e010dd70b2150d8332a96953367af15b154e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 51, "deletions": 88, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -67,46 +67,67 @@ use std::fmt;\n use std::rc::Rc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n-// FIXME #6993: in librustc, uses of \"ident\" should be replaced\n-// by just \"Name\".\n+/// A name is a part of an identifier, representing a string or gensym. It's\n+/// the result of interning.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct Name(pub u32);\n+\n+/// A SyntaxContext represents a chain of macro-expandings\n+/// and renamings. Each macro expansion corresponds to\n+/// a fresh u32. This u32 is a reference to a table stored\n+// in thread-local storage.\n+// The special value EMPTY_CTXT is used to indicate an empty\n+// syntax context.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub struct SyntaxContext(pub u32);\n \n /// An identifier contains a Name (index into the interner\n /// table) and a SyntaxContext to track renaming and\n-/// macro expansion per Flatt et al., \"Macros\n-/// That Work Together\"\n-#[derive(Clone, Copy, Hash, PartialOrd, Eq, Ord)]\n+/// macro expansion per Flatt et al., \"Macros That Work Together\"\n+#[derive(Clone, Copy, Eq, Hash)]\n pub struct Ident {\n     pub name: Name,\n     pub ctxt: SyntaxContext\n }\n \n-impl Ident {\n-    /// Construct an identifier with the given name and an empty context:\n-    pub fn new(name: Name) -> Ident { Ident {name: name, ctxt: EMPTY_CTXT}}\n+impl Name {\n+    pub fn as_str(self) -> token::InternedString {\n+        token::InternedString::new_from_name(self)\n+    }\n }\n \n-impl fmt::Debug for Ident {\n+impl fmt::Debug for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}#{}\", self.name, self.ctxt)\n+        write!(f, \"{}({})\", self, self.0)\n     }\n }\n \n-impl fmt::Display for Ident {\n+impl fmt::Display for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.name, f)\n+        fmt::Display::fmt(&self.as_str(), f)\n     }\n }\n \n-impl fmt::Debug for Name {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let Name(nm) = *self;\n-        write!(f, \"{}({})\", self, nm)\n+impl Encodable for Name {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_str(&self.as_str())\n     }\n }\n \n-impl fmt::Display for Name {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.as_str(), f)\n+impl Decodable for Name {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Name, D::Error> {\n+        Ok(token::intern(&try!(d.read_str())[..]))\n+    }\n+}\n+\n+pub const EMPTY_CTXT : SyntaxContext = SyntaxContext(0);\n+\n+impl Ident {\n+    pub fn new(name: Name, ctxt: SyntaxContext) -> Ident {\n+        Ident {name: name, ctxt: ctxt}\n+    }\n+    pub fn with_empty_ctxt(name: Name) -> Ident {\n+        Ident {name: name, ctxt: EMPTY_CTXT}\n     }\n }\n \n@@ -119,74 +140,27 @@ impl PartialEq for Ident {\n             // idents that have different contexts. You can't fix this without\n             // knowing whether the comparison should be hygienic or non-hygienic.\n             // if it should be non-hygienic (most things are), just compare the\n-            // 'name' fields of the idents. Or, even better, replace the idents\n-            // with Name's.\n+            // 'name' fields of the idents.\n             //\n             // On the other hand, if the comparison does need to be hygienic,\n             // one example and its non-hygienic counterpart would be:\n             //      syntax::parse::token::Token::mtwt_eq\n             //      syntax::ext::tt::macro_parser::token_name_eq\n-            panic!(\"not allowed to compare these idents: {:?}, {:?}. \\\n-                   Probably related to issue \\\\#6993\", self, other);\n+            panic!(\"idents with different contexts are compared with operator `==`: \\\n+                {:?}, {:?}.\", self, other);\n         }\n     }\n }\n \n-/// A SyntaxContext represents a chain of macro-expandings\n-/// and renamings. Each macro expansion corresponds to\n-/// a fresh u32\n-\n-// I'm representing this syntax context as an index into\n-// a table, in order to work around a compiler bug\n-// that's causing unreleased memory to cause core dumps\n-// and also perhaps to save some work in destructor checks.\n-// the special uint '0' will be used to indicate an empty\n-// syntax context.\n-\n-// this uint is a reference to a table stored in thread-local\n-// storage.\n-pub type SyntaxContext = u32;\n-pub const EMPTY_CTXT : SyntaxContext = 0;\n-pub const ILLEGAL_CTXT : SyntaxContext = 1;\n-\n-/// A name is a part of an identifier, representing a string or gensym. It's\n-/// the result of interning.\n-#[derive(Eq, Ord, PartialEq, PartialOrd, Hash, Clone, Copy)]\n-pub struct Name(pub u32);\n-\n-impl<T: AsRef<str>> PartialEq<T> for Name {\n-    fn eq(&self, other: &T) -> bool {\n-        self.as_str() == other.as_ref()\n-    }\n-}\n-\n-impl Name {\n-    pub fn as_str(&self) -> token::InternedString {\n-        token::InternedString::new_from_name(*self)\n-    }\n-\n-    pub fn usize(&self) -> usize {\n-        let Name(nm) = *self;\n-        nm as usize\n-    }\n-\n-    pub fn ident(&self) -> Ident {\n-        Ident { name: *self, ctxt: 0 }\n-    }\n-}\n-\n-/// A mark represents a unique id associated with a macro expansion\n-pub type Mrk = u32;\n-\n-impl Encodable for Name {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&self.as_str())\n+impl fmt::Debug for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}#{}\", self.name, self.ctxt.0)\n     }\n }\n \n-impl Decodable for Name {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Name, D::Error> {\n-        Ok(token::intern(&try!(d.read_str())[..]))\n+impl fmt::Display for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.name, f)\n     }\n }\n \n@@ -202,8 +176,8 @@ impl Decodable for Ident {\n     }\n }\n \n-/// Function name (not all functions have names)\n-pub type FnIdent = Option<Ident>;\n+/// A mark represents a unique id associated with a macro expansion\n+pub type Mrk = u32;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n@@ -841,19 +815,16 @@ pub enum Expr_ {\n     ///\n     /// This is desugared to a `match` expression.\n     ExprIfLet(P<Pat>, P<Expr>, P<Block>, Option<P<Expr>>),\n-    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     /// A while loop, with an optional label\n     ///\n     /// `'label: while expr { block }`\n     ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n-    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     /// A while-let loop, with an optional label\n     ///\n     /// `'label: while let pat = expr { block }`\n     ///\n     /// This is desugared to a combination of `loop` and `match` expressions.\n     ExprWhileLet(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n-    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     /// A for loop, with an optional label\n     ///\n     /// `'label: for pat in expr { block }`\n@@ -863,7 +834,6 @@ pub enum Expr_ {\n     /// Conditionless loop (can be exited with break, continue, or return)\n     ///\n     /// `'label: loop { block }`\n-    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n@@ -1223,13 +1193,6 @@ pub struct MutTy {\n     pub mutbl: Mutability,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct TypeField {\n-    pub ident: Ident,\n-    pub mt: MutTy,\n-    pub span: Span,\n-}\n-\n /// Represents a method's signature in a trait declaration,\n /// or in an implementation.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]"}, {"sha": "db5939f0a02b96048b9f11f5f9f83dfd15582cf3", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -577,21 +577,21 @@ mod tests {\n     use ast::*;\n     use super::*;\n \n-    fn ident_to_segment(id : &Ident) -> PathSegment {\n-        PathSegment {identifier: id.clone(),\n+    fn ident_to_segment(id: Ident) -> PathSegment {\n+        PathSegment {identifier: id,\n                      parameters: PathParameters::none()}\n     }\n \n     #[test] fn idents_name_eq_test() {\n         assert!(segments_name_eq(\n-            &[Ident{name:Name(3),ctxt:4}, Ident{name:Name(78),ctxt:82}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>(),\n-            &[Ident{name:Name(3),ctxt:104}, Ident{name:Name(78),ctxt:182}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()));\n+            &[Ident::new(Name(3),SyntaxContext(4)), Ident::new(Name(78),SyntaxContext(82))]\n+                .iter().cloned().map(ident_to_segment).collect::<Vec<PathSegment>>(),\n+            &[Ident::new(Name(3),SyntaxContext(104)), Ident::new(Name(78),SyntaxContext(182))]\n+                .iter().cloned().map(ident_to_segment).collect::<Vec<PathSegment>>()));\n         assert!(!segments_name_eq(\n-            &[Ident{name:Name(3),ctxt:4}, Ident{name:Name(78),ctxt:82}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>(),\n-            &[Ident{name:Name(3),ctxt:104}, Ident{name:Name(77),ctxt:182}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()));\n+            &[Ident::new(Name(3),SyntaxContext(4)), Ident::new(Name(78),SyntaxContext(82))]\n+                .iter().cloned().map(ident_to_segment).collect::<Vec<PathSegment>>(),\n+            &[Ident::new(Name(3),SyntaxContext(104)), Ident::new(Name(77),SyntaxContext(182))]\n+                .iter().cloned().map(ident_to_segment).collect::<Vec<PathSegment>>()));\n     }\n }"}, {"sha": "1f8c726bf6880d4ab8c51ee30cc945b151331535", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -1083,7 +1083,6 @@ pub struct MalformedCodemapPositions {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use std::rc::Rc;\n \n     #[test]\n     fn t1 () {"}, {"sha": "6b4a5538501866b4aa8f613c6537d7d80f7bbb99", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -842,7 +842,7 @@ pub fn expect<T, M>(diag: &SpanHandler, opt: Option<T>, msg: M) -> T where\n #[cfg(test)]\n mod test {\n     use super::{EmitterWriter, Level};\n-    use codemap::{mk_sp, CodeMap, BytePos};\n+    use codemap::{mk_sp, CodeMap};\n     use std::sync::{Arc, Mutex};\n     use std::io::{self, Write};\n     use std::str::from_utf8;"}, {"sha": "a276765e2161692ab636ec3ea164ad443219b32e", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -138,7 +138,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n             ));\n         }\n     });\n-    let sym = Ident::new(token::gensym(&format!(\n+    let sym = Ident::with_empty_ctxt(token::gensym(&format!(\n         \"__register_diagnostic_{}\", code\n     )));\n     MacEager::items(SmallVector::many(vec!["}, {"sha": "ddc4443a77c9d7aa290aeb0511613560de3d5179", "filename": "src/libsyntax/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fentry.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -28,7 +28,7 @@ pub fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {\n                 EntryPointType::MainAttr\n-            } else if item.ident.name == \"main\" {\n+            } else if item.ident.name.as_str() == \"main\" {\n                 if depth == 1 {\n                     // This is a top-level function so can be 'main'\n                     EntryPointType::MainNamed"}, {"sha": "aaaca8bd4d8e2229d922832ceddda8df0ed6d0fe", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -646,7 +646,7 @@ impl<'a> ExtCtxt<'a> {\n         loop {\n             if self.codemap().with_expn_info(expn_id, |info| {\n                 info.map_or(None, |i| {\n-                    if i.callee.name() == \"include\" {\n+                    if i.callee.name().as_str() == \"include\" {\n                         // Stop going up the backtrace once include! is encountered\n                         return None;\n                     }\n@@ -899,9 +899,9 @@ impl SyntaxEnv {\n         unreachable!()\n     }\n \n-    pub fn find(&self, k: &Name) -> Option<Rc<SyntaxExtension>> {\n+    pub fn find(&self, k: Name) -> Option<Rc<SyntaxExtension>> {\n         for frame in self.chain.iter().rev() {\n-            match frame.map.get(k) {\n+            match frame.map.get(&k) {\n                 Some(v) => return Some(v.clone()),\n                 None => {}\n             }"}, {"sha": "5b35b870c305a879d6664ad9c84f868fda071a93", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -73,7 +73,6 @@ pub trait AstBuilder {\n \n     fn ty_vars(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n     fn ty_vars_global(&self, ty_params: &OwnedSlice<ast::TyParam>) -> Vec<P<ast::Ty>> ;\n-    fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField;\n \n     fn typaram(&self,\n                span: Span,\n@@ -443,14 +442,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                           Vec::new()))\n     }\n \n-    fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField {\n-        ast::TypeField {\n-            ident: name,\n-            mt: ast::MutTy { ty: ty, mutbl: ast::MutImmutable },\n-            span: span,\n-        }\n-    }\n-\n     fn ty_infer(&self, span: Span) -> P<ast::Ty> {\n         self.ty(span, ast::TyInfer)\n     }"}, {"sha": "d3075b49acd1259d76ede1ec3e22cce8419e8ed7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -524,7 +524,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac,\n         return None;\n     }\n     let extname = pth.segments[0].identifier.name;\n-    match fld.cx.syntax_env.find(&extname) {\n+    match fld.cx.syntax_env.find(extname) {\n         None => {\n             fld.cx.span_err(\n                 pth.span,\n@@ -593,7 +593,7 @@ fn expand_loop_block(loop_block: P<Block>,\n                      fld: &mut MacroExpander) -> (P<Block>, Option<Ident>) {\n     match opt_ident {\n         Some(label) => {\n-            let new_label = fresh_name(&label);\n+            let new_label = fresh_name(label);\n             let rename = (label, new_label);\n \n             // The rename *must not* be added to the pending list of current\n@@ -689,7 +689,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n \n     let fm = fresh_mark();\n     let items = {\n-        let expanded = match fld.cx.syntax_env.find(&extname) {\n+        let expanded = match fld.cx.syntax_env.find(extname) {\n             None => {\n                 fld.cx.span_err(path_span,\n                                 &format!(\"macro undefined: '{}!'\",\n@@ -892,7 +892,7 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n                     // generate fresh names, push them to a new pending list\n                     let idents = pattern_bindings(&*expanded_pat);\n                     let mut new_pending_renames =\n-                        idents.iter().map(|ident| (*ident, fresh_name(ident))).collect();\n+                        idents.iter().map(|ident| (*ident, fresh_name(*ident))).collect();\n                     // rewrite the pattern using the new names (the old\n                     // ones have already been applied):\n                     let rewritten_pat = {\n@@ -951,7 +951,7 @@ fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     // all of the pats must have the same set of bindings, so use the\n     // first one to extract them and generate new names:\n     let idents = pattern_bindings(&*expanded_pats[0]);\n-    let new_renames = idents.into_iter().map(|id| (id, fresh_name(&id))).collect();\n+    let new_renames = idents.into_iter().map(|id| (id, fresh_name(id))).collect();\n     // apply the renaming, but only to the PatIdents:\n     let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n     let rewritten_pats = expanded_pats.move_map(|pat| rename_pats_fld.fold_pat(pat));\n@@ -1061,7 +1061,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n             return DummyResult::raw_pat(span);\n         }\n         let extname = pth.segments[0].identifier.name;\n-        let marked_after = match fld.cx.syntax_env.find(&extname) {\n+        let marked_after = match fld.cx.syntax_env.find(extname) {\n             None => {\n                 fld.cx.span_err(pth.span,\n                                 &format!(\"macro undefined: '{}!'\",\n@@ -1134,10 +1134,7 @@ pub struct IdentRenamer<'a> {\n \n impl<'a> Folder for IdentRenamer<'a> {\n     fn fold_ident(&mut self, id: Ident) -> Ident {\n-        Ident {\n-            name: id.name,\n-            ctxt: mtwt::apply_renames(self.renames, id.ctxt),\n-        }\n+        Ident::new(id.name, mtwt::apply_renames(self.renames, id.ctxt))\n     }\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n         fold::noop_fold_mac(mac, self)\n@@ -1161,8 +1158,8 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n \n         pat.map(|ast::Pat {id, node, span}| match node {\n             ast::PatIdent(binding_mode, Spanned{span: sp, node: ident}, sub) => {\n-                let new_ident = Ident{name: ident.name,\n-                                      ctxt: mtwt::apply_renames(self.renames, ident.ctxt)};\n+                let new_ident = Ident::new(ident.name,\n+                                           mtwt::apply_renames(self.renames, ident.ctxt));\n                 let new_node =\n                     ast::PatIdent(binding_mode,\n                                   Spanned{span: self.new_span(sp), node: new_ident},\n@@ -1254,7 +1251,7 @@ macro_rules! partition {\n                     fld: &MacroExpander)\n                      -> (Vec<ast::Attribute>, Vec<ast::Attribute>) {\n             attrs.iter().cloned().partition(|attr| {\n-                match fld.cx.syntax_env.find(&intern(&attr.name())) {\n+                match fld.cx.syntax_env.find(intern(&attr.name())) {\n                     Some(rc) => match *rc {\n                         $variant(..) => true,\n                         _ => false\n@@ -1276,7 +1273,7 @@ fn expand_decorators(a: Annotatable,\n {\n     for attr in a.attrs() {\n         let mname = intern(&attr.name());\n-        match fld.cx.syntax_env.find(&mname) {\n+        match fld.cx.syntax_env.find(mname) {\n             Some(rc) => match *rc {\n                 MultiDecorator(ref dec) => {\n                     attr::mark_used(&attr);\n@@ -1327,7 +1324,7 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n     for attr in &modifiers {\n         let mname = intern(&attr.name());\n \n-        match fld.cx.syntax_env.find(&mname) {\n+        match fld.cx.syntax_env.find(mname) {\n             Some(rc) => match *rc {\n                 MultiModifier(ref mac) => {\n                     attr::mark_used(attr);\n@@ -1407,7 +1404,7 @@ fn expand_and_rename_fn_decl_and_block(fn_decl: P<ast::FnDecl>, block: P<ast::Bl\n     let expanded_decl = fld.fold_fn_decl(fn_decl);\n     let idents = fn_decl_arg_bindings(&*expanded_decl);\n     let renames =\n-        idents.iter().map(|id : &ast::Ident| (*id,fresh_name(id))).collect();\n+        idents.iter().map(|id| (*id,fresh_name(*id))).collect();\n     // first, a renamer for the PatIdents, for the fn_decl:\n     let mut rename_pat_fld = PatIdentRenamer{renames: &renames};\n     let rewritten_fn_decl = rename_pat_fld.fold_fn_decl(expanded_decl);\n@@ -1628,10 +1625,7 @@ struct Marker { mark: Mrk }\n \n impl Folder for Marker {\n     fn fold_ident(&mut self, id: Ident) -> Ident {\n-        ast::Ident {\n-            name: id.name,\n-            ctxt: mtwt::apply_mark(self.mark, id.ctxt)\n-        }\n+        ast::Ident::new(id.name, mtwt::apply_mark(self.mark, id.ctxt))\n     }\n     fn fold_mac(&mut self, Spanned {node, span}: ast::Mac) -> ast::Mac {\n         Spanned {\n@@ -2104,7 +2098,7 @@ foo_module!();\n         // find the xx binding\n         let bindings = crate_bindings(&cr);\n         let cxbinds: Vec<&ast::Ident> =\n-            bindings.iter().filter(|b| b.name == \"xx\").collect();\n+            bindings.iter().filter(|b| b.name.as_str() == \"xx\").collect();\n         let cxbinds: &[&ast::Ident] = &cxbinds[..];\n         let cxbind = match (cxbinds.len(), cxbinds.get(0)) {\n             (1, Some(b)) => *b,\n@@ -2116,7 +2110,7 @@ foo_module!();\n         // the xx binding should bind all of the xx varrefs:\n         for (idx,v) in varrefs.iter().filter(|p| {\n             p.segments.len() == 1\n-            && p.segments[0].identifier.name == \"xx\"\n+            && p.segments[0].identifier.name.as_str() == \"xx\"\n         }).enumerate() {\n             if mtwt::resolve(v.segments[0].identifier) != resolved_binding {\n                 println!(\"uh oh, xx binding didn't match xx varref:\");"}, {"sha": "21b4c77b9f867283591338bd0199bcb81524b2fa", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -35,7 +35,7 @@ use std::collections::HashMap;\n pub struct SCTable {\n     table: RefCell<Vec<SyntaxContext_>>,\n     mark_memo: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n-    rename_memo: RefCell<HashMap<(SyntaxContext,Ident,Name),SyntaxContext>>,\n+    rename_memo: RefCell<HashMap<(SyntaxContext,Name,SyntaxContext,Name),SyntaxContext>>,\n }\n \n #[derive(PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, Clone)]\n@@ -66,8 +66,9 @@ pub fn apply_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n /// Extend a syntax context with a given mark and sctable (explicit memoization)\n fn apply_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxContext {\n     let key = (ctxt, m);\n-    * table.mark_memo.borrow_mut().entry(key)\n-        .or_insert_with(|| idx_push(&mut *table.table.borrow_mut(), Mark(m, ctxt)))\n+    *table.mark_memo.borrow_mut().entry(key).or_insert_with(|| {\n+        SyntaxContext(idx_push(&mut *table.table.borrow_mut(), Mark(m, ctxt)))\n+    })\n }\n \n /// Extend a syntax context with a given rename\n@@ -81,10 +82,11 @@ fn apply_rename_internal(id: Ident,\n                        to: Name,\n                        ctxt: SyntaxContext,\n                        table: &SCTable) -> SyntaxContext {\n-    let key = (ctxt, id, to);\n+    let key = (ctxt, id.name, id.ctxt, to);\n \n-    * table.rename_memo.borrow_mut().entry(key)\n-        .or_insert_with(|| idx_push(&mut *table.table.borrow_mut(), Rename(id, to, ctxt)))\n+    *table.rename_memo.borrow_mut().entry(key).or_insert_with(|| {\n+            SyntaxContext(idx_push(&mut *table.table.borrow_mut(), Rename(id, to, ctxt)))\n+    })\n }\n \n /// Apply a list of renamings to a context\n@@ -185,20 +187,20 @@ fn resolve_internal(id: Ident,\n     }\n \n     let resolved = {\n-        let result = (*table.table.borrow())[id.ctxt as usize];\n+        let result = (*table.table.borrow())[id.ctxt.0 as usize];\n         match result {\n             EmptyCtxt => id.name,\n             // ignore marks here:\n             Mark(_,subctxt) =>\n-                resolve_internal(Ident{name:id.name, ctxt: subctxt},\n+                resolve_internal(Ident::new(id.name, subctxt),\n                                  table, resolve_table),\n             // do the rename if necessary:\n             Rename(Ident{name, ctxt}, toname, subctxt) => {\n                 let resolvedfrom =\n-                    resolve_internal(Ident{name:name, ctxt:ctxt},\n+                    resolve_internal(Ident::new(name, ctxt),\n                                      table, resolve_table);\n                 let resolvedthis =\n-                    resolve_internal(Ident{name:id.name, ctxt:subctxt},\n+                    resolve_internal(Ident::new(id.name, subctxt),\n                                      table, resolve_table);\n                 if (resolvedthis == resolvedfrom)\n                     && (marksof_internal(ctxt, resolvedthis, table)\n@@ -229,7 +231,7 @@ fn marksof_internal(ctxt: SyntaxContext,\n     let mut result = Vec::new();\n     let mut loopvar = ctxt;\n     loop {\n-        let table_entry = (*table.table.borrow())[loopvar as usize];\n+        let table_entry = (*table.table.borrow())[loopvar.0 as usize];\n         match table_entry {\n             EmptyCtxt => {\n                 return result;\n@@ -256,7 +258,7 @@ fn marksof_internal(ctxt: SyntaxContext,\n /// FAILS when outside is not a mark.\n pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n     with_sctable(|sctable| {\n-        match (*sctable.table.borrow())[ctxt as usize] {\n+        match (*sctable.table.borrow())[ctxt.0 as usize] {\n             Mark(mrk, _) => mrk,\n             _ => panic!(\"can't retrieve outer mark when outside is not a mark\")\n         }\n@@ -302,7 +304,7 @@ mod tests {\n     }\n \n     fn id(n: u32, s: SyntaxContext) -> Ident {\n-        Ident {name: Name(n), ctxt: s}\n+        Ident::new(Name(n), s)\n     }\n \n     // because of the SCTable, I now need a tidy way of\n@@ -328,7 +330,7 @@ mod tests {\n         let mut result = Vec::new();\n         loop {\n             let table = table.table.borrow();\n-            match (*table)[sc as usize] {\n+            match (*table)[sc.0 as usize] {\n                 EmptyCtxt => {return result;},\n                 Mark(mrk,tail) => {\n                     result.push(M(mrk));\n@@ -349,15 +351,15 @@ mod tests {\n     fn test_unfold_refold(){\n         let mut t = new_sctable_internal();\n \n-        let test_sc = vec!(M(3),R(id(101,0),Name(14)),M(9));\n-        assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),4);\n+        let test_sc = vec!(M(3),R(id(101,EMPTY_CTXT),Name(14)),M(9));\n+        assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),SyntaxContext(4));\n         {\n             let table = t.table.borrow();\n-            assert!((*table)[2] == Mark(9,0));\n-            assert!((*table)[3] == Rename(id(101,0),Name(14),2));\n-            assert!((*table)[4] == Mark(3,3));\n+            assert!((*table)[2] == Mark(9,EMPTY_CTXT));\n+            assert!((*table)[3] == Rename(id(101,EMPTY_CTXT),Name(14),SyntaxContext(2)));\n+            assert!((*table)[4] == Mark(3,SyntaxContext(3)));\n         }\n-        assert_eq!(refold_test_sc(4,&t),test_sc);\n+        assert_eq!(refold_test_sc(SyntaxContext(4),&t),test_sc);\n     }\n \n     // extend a syntax context with a sequence of marks given\n@@ -371,11 +373,11 @@ mod tests {\n     #[test] fn unfold_marks_test() {\n         let mut t = new_sctable_internal();\n \n-        assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),3);\n+        assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),SyntaxContext(3));\n         {\n             let table = t.table.borrow();\n-            assert!((*table)[2] == Mark(7,0));\n-            assert!((*table)[3] == Mark(3,2));\n+            assert!((*table)[2] == Mark(7,EMPTY_CTXT));\n+            assert!((*table)[3] == Mark(3,SyntaxContext(2)));\n         }\n     }\n \n@@ -396,7 +398,7 @@ mod tests {\n          assert_eq! (marksof_internal (ans, stopname,&t), [16]);}\n         // rename where stop doesn't match:\n         { let chain = vec!(M(9),\n-                        R(id(name1.usize() as u32,\n+                        R(id(name1.0,\n                              apply_mark_internal (4, EMPTY_CTXT,&mut t)),\n                           Name(100101102)),\n                         M(14));\n@@ -405,7 +407,7 @@ mod tests {\n         // rename where stop does match\n         { let name1sc = apply_mark_internal(4, EMPTY_CTXT, &mut t);\n          let chain = vec!(M(9),\n-                       R(id(name1.usize() as u32, name1sc),\n+                       R(id(name1.0, name1sc),\n                          stopname),\n                        M(14));\n          let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n@@ -474,10 +476,10 @@ mod tests {\n     #[test]\n     fn hashing_tests () {\n         let mut t = new_sctable_internal();\n-        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),2);\n-        assert_eq!(apply_mark_internal(13,EMPTY_CTXT,&mut t),3);\n+        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(2));\n+        assert_eq!(apply_mark_internal(13,EMPTY_CTXT,&mut t),SyntaxContext(3));\n         // using the same one again should result in the same index:\n-        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),2);\n+        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(2));\n         // I'm assuming that the rename table will behave the same....\n     }\n \n@@ -496,10 +498,10 @@ mod tests {\n \n     #[test]\n     fn new_resolves_test() {\n-        let renames = vec!((Ident{name:Name(23),ctxt:EMPTY_CTXT},Name(24)),\n-                           (Ident{name:Name(29),ctxt:EMPTY_CTXT},Name(29)));\n+        let renames = vec!((Ident::with_empty_ctxt(Name(23)),Name(24)),\n+                           (Ident::with_empty_ctxt(Name(29)),Name(29)));\n         let new_ctxt1 = apply_renames(&renames,EMPTY_CTXT);\n-        assert_eq!(resolve(Ident{name:Name(23),ctxt:new_ctxt1}),Name(24));\n-        assert_eq!(resolve(Ident{name:Name(29),ctxt:new_ctxt1}),Name(29));\n+        assert_eq!(resolve(Ident::new(Name(23),new_ctxt1)),Name(24));\n+        assert_eq!(resolve(Ident::new(Name(29),new_ctxt1)),Name(29));\n     }\n }"}, {"sha": "e9a5d9148241d3fdc70505dfd394bdc23eb5e339", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -464,7 +464,7 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         ($name: expr, $suffix: expr, $($args: expr),*) => {{\n             let inner = cx.expr_call(sp, mk_token_path(cx, sp, $name), vec![$($args),*]);\n             let suffix = match $suffix {\n-                Some(name) => cx.expr_some(sp, mk_name(cx, sp, ast::Ident::new(name))),\n+                Some(name) => cx.expr_some(sp, mk_name(cx, sp, ast::Ident::with_empty_ctxt(name))),\n                 None => cx.expr_none(sp)\n             };\n             cx.expr_call(sp, mk_token_path(cx, sp, \"Literal\"), vec![inner, suffix])\n@@ -489,31 +489,32 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         }\n \n         token::Literal(token::Byte(i), suf) => {\n-            let e_byte = mk_name(cx, sp, i.ident());\n+            let e_byte = mk_name(cx, sp, ast::Ident::with_empty_ctxt(i));\n             return mk_lit!(\"Byte\", suf, e_byte);\n         }\n \n         token::Literal(token::Char(i), suf) => {\n-            let e_char = mk_name(cx, sp, i.ident());\n+            let e_char = mk_name(cx, sp, ast::Ident::with_empty_ctxt(i));\n             return mk_lit!(\"Char\", suf, e_char);\n         }\n \n         token::Literal(token::Integer(i), suf) => {\n-            let e_int = mk_name(cx, sp, i.ident());\n+            let e_int = mk_name(cx, sp, ast::Ident::with_empty_ctxt(i));\n             return mk_lit!(\"Integer\", suf, e_int);\n         }\n \n         token::Literal(token::Float(fident), suf) => {\n-            let e_fident = mk_name(cx, sp, fident.ident());\n+            let e_fident = mk_name(cx, sp, ast::Ident::with_empty_ctxt(fident));\n             return mk_lit!(\"Float\", suf, e_fident);\n         }\n \n         token::Literal(token::Str_(ident), suf) => {\n-            return mk_lit!(\"Str_\", suf, mk_name(cx, sp, ident.ident()))\n+            return mk_lit!(\"Str_\", suf, mk_name(cx, sp, ast::Ident::with_empty_ctxt(ident)))\n         }\n \n         token::Literal(token::StrRaw(ident, n), suf) => {\n-            return mk_lit!(\"StrRaw\", suf, mk_name(cx, sp, ident.ident()), cx.expr_usize(sp, n))\n+            return mk_lit!(\"StrRaw\", suf, mk_name(cx, sp, ast::Ident::with_empty_ctxt(ident)),\n+                           cx.expr_usize(sp, n))\n         }\n \n         token::Ident(ident, style) => {\n@@ -535,7 +536,7 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         token::DocComment(ident) => {\n             return cx.expr_call(sp,\n                                 mk_token_path(cx, sp, \"DocComment\"),\n-                                vec!(mk_name(cx, sp, ident.ident())));\n+                                vec!(mk_name(cx, sp, ast::Ident::with_empty_ctxt(ident))));\n         }\n \n         token::MatchNt(name, kind, namep, kindp) => {"}, {"sha": "01fd4608ecb361cbd8e5de12de4f8e445dd39875", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -79,7 +79,7 @@ pub use self::ParseResult::*;\n use self::TokenTreeOrTokenTreeVec::*;\n \n use ast;\n-use ast::{TokenTree, Ident};\n+use ast::{TokenTree, Name};\n use ast::{TtDelimited, TtSequence, TtToken};\n use codemap::{BytePos, mk_sp, Span};\n use codemap;\n@@ -202,9 +202,9 @@ pub enum NamedMatch {\n }\n \n pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n-            -> HashMap<Ident, Rc<NamedMatch>> {\n+            -> HashMap<Name, Rc<NamedMatch>> {\n     fn n_rec(p_s: &ParseSess, m: &TokenTree, res: &[Rc<NamedMatch>],\n-             ret_val: &mut HashMap<Ident, Rc<NamedMatch>>, idx: &mut usize) {\n+             ret_val: &mut HashMap<Name, Rc<NamedMatch>>, idx: &mut usize) {\n         match m {\n             &TtSequence(_, ref seq) => {\n                 for next_m in &seq.tts {\n@@ -217,7 +217,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                 }\n             }\n             &TtToken(sp, MatchNt(bind_name, _, _, _)) => {\n-                match ret_val.entry(bind_name) {\n+                match ret_val.entry(bind_name.name) {\n                     Vacant(spot) => {\n                         spot.insert(res[*idx].clone());\n                         *idx += 1;\n@@ -246,7 +246,7 @@ pub enum ParseResult<T> {\n     Error(codemap::Span, String)\n }\n \n-pub type NamedParseResult = ParseResult<HashMap<Ident, Rc<NamedMatch>>>;\n+pub type NamedParseResult = ParseResult<HashMap<Name, Rc<NamedMatch>>>;\n pub type PositionalParseResult = ParseResult<Vec<Rc<NamedMatch>>>;\n \n /// Perform a token equality check, ignoring syntax context (that is, an"}, {"sha": "0a95f24a7210df8eb63c6ea86f913ccbc3036a8c", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -282,7 +282,7 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n     };\n \n     // Extract the arguments:\n-    let lhses = match **argument_map.get(&lhs_nm).unwrap() {\n+    let lhses = match **argument_map.get(&lhs_nm.name).unwrap() {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n     };\n@@ -291,7 +291,7 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n         check_lhs_nt_follows(cx, &**lhs, def.span);\n     }\n \n-    let rhses = match **argument_map.get(&rhs_nm).unwrap() {\n+    let rhses = match **argument_map.get(&rhs_nm.name).unwrap() {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n     };\n@@ -510,14 +510,14 @@ fn is_in_follow(_: &ExtCtxt, tok: &Token, frag: &str) -> Result<bool, String> {\n             \"pat\" => {\n                 match *tok {\n                     FatArrow | Comma | Eq => Ok(true),\n-                    Ident(i, _) if i.name == \"if\" || i.name == \"in\" => Ok(true),\n+                    Ident(i, _) if i.name.as_str() == \"if\" || i.name.as_str() == \"in\" => Ok(true),\n                     _ => Ok(false)\n                 }\n             },\n             \"path\" | \"ty\" => {\n                 match *tok {\n                     Comma | FatArrow | Colon | Eq | Gt | Semi => Ok(true),\n-                    Ident(i, _) if i.name == \"as\" => Ok(true),\n+                    Ident(i, _) if i.name.as_str() == \"as\" => Ok(true),\n                     _ => Ok(false)\n                 }\n             },"}, {"sha": "d1e48eda4ffd2f46b774fe6c3e5e39dd022767df", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -10,7 +10,7 @@\n use self::LockstepIterSize::*;\n \n use ast;\n-use ast::{TokenTree, TtDelimited, TtToken, TtSequence, Ident};\n+use ast::{TokenTree, TtDelimited, TtToken, TtSequence, Ident, Name};\n use codemap::{Span, DUMMY_SP};\n use diagnostic::SpanHandler;\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n@@ -38,7 +38,7 @@ pub struct TtReader<'a> {\n     /// the unzipped tree:\n     stack: Vec<TtFrame>,\n     /* for MBE-style macro transcription */\n-    interpolations: HashMap<Ident, Rc<NamedMatch>>,\n+    interpolations: HashMap<Name, Rc<NamedMatch>>,\n     imported_from: Option<Ident>,\n \n     // Some => return imported_from as the next token\n@@ -56,7 +56,7 @@ pub struct TtReader<'a> {\n /// `src` contains no `TtSequence`s, `MatchNt`s or `SubstNt`s, `interp` can\n /// (and should) be None.\n pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n-                         interp: Option<HashMap<Ident, Rc<NamedMatch>>>,\n+                         interp: Option<HashMap<Name, Rc<NamedMatch>>>,\n                          imported_from: Option<Ident>,\n                          src: Vec<ast::TokenTree>)\n                          -> TtReader<'a> {\n@@ -70,7 +70,7 @@ pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n /// `src` contains no `TtSequence`s, `MatchNt`s or `SubstNt`s, `interp` can\n /// (and should) be None.\n pub fn new_tt_reader_with_doc_flag<'a>(sp_diag: &'a SpanHandler,\n-                                       interp: Option<HashMap<Ident, Rc<NamedMatch>>>,\n+                                       interp: Option<HashMap<Name, Rc<NamedMatch>>>,\n                                        imported_from: Option<Ident>,\n                                        src: Vec<ast::TokenTree>,\n                                        desugar_doc_comments: bool)\n@@ -117,7 +117,7 @@ fn lookup_cur_matched_by_matched(r: &TtReader, start: Rc<NamedMatch>) -> Rc<Name\n }\n \n fn lookup_cur_matched(r: &TtReader, name: Ident) -> Option<Rc<NamedMatch>> {\n-    let matched_opt = r.interpolations.get(&name).cloned();\n+    let matched_opt = r.interpolations.get(&name.name).cloned();\n     matched_opt.map(|s| lookup_cur_matched_by_matched(r, s))\n }\n "}, {"sha": "a802b0ecd8167a18ca38a78e9bc7f5caf454d9f5", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -35,7 +35,7 @@ use codemap::{CodeMap, Span};\n use diagnostic::SpanHandler;\n use visit;\n use visit::{FnKind, Visitor};\n-use parse::token::{self, InternedString};\n+use parse::token::InternedString;\n \n use std::ascii::AsciiExt;\n use std::cmp;\n@@ -667,7 +667,7 @@ struct MacroVisitor<'a> {\n impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n     fn visit_mac(&mut self, mac: &ast::Mac) {\n         let path = &mac.node.path;\n-        let id = path.segments.last().unwrap().identifier;\n+        let name = path.segments.last().unwrap().identifier.name.as_str();\n \n         // Issue 22234: If you add a new case here, make sure to also\n         // add code to catch the macro during or after expansion.\n@@ -677,19 +677,19 @@ impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n         // catch uses of these macros within conditionally-compiled\n         // code, e.g. `#[cfg]`-guarded functions.\n \n-        if id == token::str_to_ident(\"asm\") {\n+        if name == \"asm\" {\n             self.context.gate_feature(\"asm\", path.span, EXPLAIN_ASM);\n         }\n \n-        else if id == token::str_to_ident(\"log_syntax\") {\n+        else if name == \"log_syntax\" {\n             self.context.gate_feature(\"log_syntax\", path.span, EXPLAIN_LOG_SYNTAX);\n         }\n \n-        else if id == token::str_to_ident(\"trace_macros\") {\n+        else if name == \"trace_macros\" {\n             self.context.gate_feature(\"trace_macros\", path.span, EXPLAIN_TRACE_MACROS);\n         }\n \n-        else if id == token::str_to_ident(\"concat_idents\") {\n+        else if name == \"concat_idents\" {\n             self.context.gate_feature(\"concat_idents\", path.span, EXPLAIN_CONCAT_IDENTS);\n         }\n     }"}, {"sha": "015cf60f0cfdb4c9b50cd99c1e7881f8a0c95fbf", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -40,7 +40,7 @@ impl<'a> ParserAttr for Parser<'a> {\n               token::DocComment(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n                     attr::mk_attr_id(),\n-                    self.id_to_interned_str(s.ident()),\n+                    self.id_to_interned_str(ast::Ident::with_empty_ctxt(s)),\n                     self.span.lo,\n                     self.span.hi\n                 );\n@@ -137,9 +137,8 @@ impl<'a> ParserAttr for Parser<'a> {\n                 token::DocComment(s) => {\n                     // we need to get the position of this token before we bump.\n                     let Span { lo, hi, .. } = self.span;\n-                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(),\n-                                                         self.id_to_interned_str(s.ident()),\n-                                                         lo, hi);\n+                    let str = self.id_to_interned_str(ast::Ident::with_empty_ctxt(s));\n+                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), str, lo, hi);\n                     if attr.node.style == ast::AttrInner {\n                         attrs.push(attr);\n                         panictry!(self.bump());"}, {"sha": "5beec702f8cfb1ab08412bc32a898debab885e86", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -744,8 +744,8 @@ mod tests {\n                 Some(&ast::TtToken(_, token::Ident(name_zip, token::Plain))),\n                 Some(&ast::TtDelimited(_, ref macro_delimed)),\n             )\n-            if name_macro_rules.name == \"macro_rules\"\n-            && name_zip.name == \"zip\" => {\n+            if name_macro_rules.name.as_str() == \"macro_rules\"\n+            && name_zip.name.as_str() == \"zip\" => {\n                 let tts = &macro_delimed.tts[..];\n                 match (tts.len(), tts.get(0), tts.get(1), tts.get(2)) {\n                     (\n@@ -763,7 +763,7 @@ mod tests {\n                                 Some(&ast::TtToken(_, token::Ident(ident, token::Plain))),\n                             )\n                             if first_delimed.delim == token::Paren\n-                            && ident.name == \"a\" => {},\n+                            && ident.name.as_str() == \"a\" => {},\n                             _ => panic!(\"value 3: {:?}\", **first_delimed),\n                         }\n                         let tts = &second_delimed.tts[..];\n@@ -774,7 +774,7 @@ mod tests {\n                                 Some(&ast::TtToken(_, token::Ident(ident, token::Plain))),\n                             )\n                             if second_delimed.delim == token::Paren\n-                            && ident.name == \"a\" => {},\n+                            && ident.name.as_str() == \"a\" => {},\n                             _ => panic!(\"value 4: {:?}\", **second_delimed),\n                         }\n                     },"}, {"sha": "9d12a9217e99d9f8498069f1bcc4be74c614cc79", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -4715,7 +4715,7 @@ impl<'a> Parser<'a> {\n             (fields, None)\n         // Tuple-style struct definition with optional where-clause.\n         } else if self.token == token::OpenDelim(token::Paren) {\n-            let fields = try!(self.parse_tuple_struct_body(&class_name, &mut generics));\n+            let fields = try!(self.parse_tuple_struct_body(class_name, &mut generics));\n             (fields, Some(ast::DUMMY_NODE_ID))\n         } else {\n             let token_str = self.this_token_to_string();\n@@ -4750,7 +4750,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn parse_tuple_struct_body(&mut self,\n-                                   class_name: &ast::Ident,\n+                                   class_name: ast::Ident,\n                                    generics: &mut ast::Generics)\n                                    -> PResult<Vec<StructField>> {\n         // This is the case where we find `struct Foo<T>(T) where T: Copy;`\n@@ -5780,10 +5780,10 @@ impl<'a> Parser<'a> {\n                                                  Option<ast::Name>)>> {\n         let ret = match self.token {\n             token::Literal(token::Str_(s), suf) => {\n-                (self.id_to_interned_str(s.ident()), ast::CookedStr, suf)\n+                (self.id_to_interned_str(ast::Ident::with_empty_ctxt(s)), ast::CookedStr, suf)\n             }\n             token::Literal(token::StrRaw(s, n), suf) => {\n-                (self.id_to_interned_str(s.ident()), ast::RawStr(n), suf)\n+                (self.id_to_interned_str(ast::Ident::with_empty_ctxt(s)), ast::RawStr(n), suf)\n             }\n             _ => return Ok(None)\n         };"}, {"sha": "ba24dc3c0a74ec155fbc4d870741374560da667d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -453,7 +453,7 @@ macro_rules! declare_special_idents_and_keywords {(\n             #[allow(non_upper_case_globals)]\n             pub const $si_static: ast::Ident = ast::Ident {\n                 name: ast::Name($si_name),\n-                ctxt: 0,\n+                ctxt: ast::EMPTY_CTXT,\n             };\n          )*\n     }\n@@ -462,7 +462,7 @@ macro_rules! declare_special_idents_and_keywords {(\n         use ast;\n         $(\n             #[allow(non_upper_case_globals)]\n-            pub const $si_static: ast::Name =  ast::Name($si_name);\n+            pub const $si_static: ast::Name = ast::Name($si_name);\n         )*\n     }\n \n@@ -729,19 +729,19 @@ pub fn gensym(s: &str) -> ast::Name {\n /// Maps a string to an identifier with an empty syntax context.\n #[inline]\n pub fn str_to_ident(s: &str) -> ast::Ident {\n-    ast::Ident::new(intern(s))\n+    ast::Ident::with_empty_ctxt(intern(s))\n }\n \n /// Maps a string to a gensym'ed identifier.\n #[inline]\n pub fn gensym_ident(s: &str) -> ast::Ident {\n-    ast::Ident::new(gensym(s))\n+    ast::Ident::with_empty_ctxt(gensym(s))\n }\n \n // create a fresh name that maps to the same string as the old one.\n // note that this guarantees that str_ptr_eq(ident_to_string(src),interner_get(fresh_name(src)));\n // that is, that the new name and the old one are connected to ptr_eq strings.\n-pub fn fresh_name(src: &ast::Ident) -> ast::Name {\n+pub fn fresh_name(src: ast::Ident) -> ast::Name {\n     let interner = get_ident_interner();\n     interner.gensym_copy(src.name)\n     // following: debug version. Could work in final except that it's incompatible with\n@@ -753,7 +753,7 @@ pub fn fresh_name(src: &ast::Ident) -> ast::Name {\n \n // create a fresh mark.\n pub fn fresh_mark() -> ast::Mrk {\n-    gensym(\"mark\").usize() as u32\n+    gensym(\"mark\").0\n }\n \n #[cfg(test)]\n@@ -763,7 +763,7 @@ mod tests {\n     use ext::mtwt;\n \n     fn mark_ident(id : ast::Ident, m : ast::Mrk) -> ast::Ident {\n-        ast::Ident { name: id.name, ctxt:mtwt::apply_mark(m, id.ctxt) }\n+        ast::Ident::new(id.name, mtwt::apply_mark(m, id.ctxt))\n     }\n \n     #[test] fn mtwt_token_eq_test() {"}, {"sha": "7c87e03f241b1c70692f5f80f61569c517384e41", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -297,7 +297,7 @@ pub fn token_to_string(tok: &Token) -> String {\n             token::NtBlock(ref e)       => block_to_string(&**e),\n             token::NtStmt(ref e)        => stmt_to_string(&**e),\n             token::NtPat(ref e)         => pat_to_string(&**e),\n-            token::NtIdent(ref e, _)    => ident_to_string(&**e),\n+            token::NtIdent(ref e, _)    => ident_to_string(**e),\n             token::NtTT(ref e)          => tt_to_string(&**e),\n             token::NtArm(ref e)         => arm_to_string(&*e),\n             token::NtImplItem(ref e)    => impl_item_to_string(&**e),\n@@ -376,8 +376,8 @@ pub fn path_to_string(p: &ast::Path) -> String {\n     to_string(|s| s.print_path(p, false, 0))\n }\n \n-pub fn ident_to_string(id: &ast::Ident) -> String {\n-    to_string(|s| s.print_ident(*id))\n+pub fn ident_to_string(id: ast::Ident) -> String {\n+    to_string(|s| s.print_ident(id))\n }\n \n pub fn fun_to_string(decl: &ast::FnDecl,\n@@ -2854,7 +2854,6 @@ impl<'a> State<'a> {\n             ast::ViewPathSimple(ident, ref path) => {\n                 try!(self.print_path(path, false, 0));\n \n-                // FIXME(#6993) can't compare identifiers directly here\n                 if path.segments.last().unwrap().identifier.name !=\n                         ident.name {\n                     try!(space(&mut self.s));"}, {"sha": "6e9c161293de27359ef5fb91e3a79ff1f93242e2", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -69,7 +69,7 @@ impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n \n     pub fn get(&self, idx: Name) -> T {\n         let vect = self.vect.borrow();\n-        (*vect)[idx.usize()].clone()\n+        (*vect)[idx.0 as usize].clone()\n     }\n \n     pub fn len(&self) -> usize {\n@@ -196,13 +196,13 @@ impl StrInterner {\n         let new_idx = Name(self.len() as u32);\n         // leave out of map to avoid colliding\n         let mut vect = self.vect.borrow_mut();\n-        let existing = (*vect)[idx.usize()].clone();\n+        let existing = (*vect)[idx.0 as usize].clone();\n         vect.push(existing);\n         new_idx\n     }\n \n     pub fn get(&self, idx: Name) -> RcStr {\n-        (*self.vect.borrow())[idx.usize()].clone()\n+        (*self.vect.borrow())[idx.0 as usize].clone()\n     }\n \n     pub fn len(&self) -> usize {"}, {"sha": "a0036745d90a432f3be9ea1d83780e5bf1a0e5e3", "filename": "src/test/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -35,7 +35,7 @@ impl LintPass for Pass {\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n-        if it.ident.name == \"lintme\" {\n+        if it.ident.name.as_str() == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n     }"}, {"sha": "296d1e431f4ca20dcd037189745db0c130cff6d0", "filename": "src/test/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -33,7 +33,7 @@ fn expand_mbe_matches(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n \n     let mac_expr = match TokenTree::parse(cx, &mbe_matcher[..], args) {\n         Success(map) => {\n-            match (&*map[&str_to_ident(\"matched\")], &*map[&str_to_ident(\"pat\")]) {\n+            match (&*map[&str_to_ident(\"matched\").name], &*map[&str_to_ident(\"pat\").name]) {\n                 (&MatchedNonterminal(NtExpr(ref matched_expr)),\n                  &MatchedSeq(ref pats, seq_sp)) => {\n                     let pats: Vec<P<Pat>> = pats.iter().map(|pat_nt|"}, {"sha": "b6400c68f536739a068b52c4fbd5902d5f53d6e6", "filename": "src/test/run-pass/backtrace-debuginfo.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -16,7 +16,6 @@\n // \"enable\" to 0 instead.\n // compile-flags:-g -Cllvm-args=-enable-tail-merge=0\n // ignore-pretty as this critically relies on line numbers\n-// ignore-windows\n \n use std::io;\n use std::io::prelude::*;"}, {"sha": "5d65f9eb2be0fe3eb8b17738cdfdf248ebf0d288", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f284cbc7af06a941de0cdd06291dc78d37268b9f/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=f284cbc7af06a941de0cdd06291dc78d37268b9f", "patch": "@@ -11,7 +11,6 @@\n // no-pretty-expanded FIXME #15189\n // ignore-android FIXME #17520\n // ignore-msvc FIXME #28133\n-// ignore-windows\n \n use std::env;\n use std::process::{Command, Stdio};"}]}