{"sha": "6284190ef9918e05cb9147a2a81100ddcb06fea8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyODQxOTBlZjk5MThlMDVjYjkxNDdhMmE4MTEwMGRkY2IwNmZlYTg=", "commit": {"author": {"name": "Stefan Plantikow", "email": "stefan.plantikow@googlemail.com", "date": "2012-01-04T23:11:25Z"}, "committer": {"name": "Stefan Plantikow", "email": "stefan.plantikow@googlemail.com", "date": "2012-01-05T01:07:12Z"}, "message": "Merge branch 'master' into kmath\n\nConflicts:\n\tsrc/libcore/cmath.rs", "tree": {"sha": "e5e8075a4de03db9c4efee2b6d994343a674b3b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5e8075a4de03db9c4efee2b6d994343a674b3b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6284190ef9918e05cb9147a2a81100ddcb06fea8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6284190ef9918e05cb9147a2a81100ddcb06fea8", "html_url": "https://github.com/rust-lang/rust/commit/6284190ef9918e05cb9147a2a81100ddcb06fea8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6284190ef9918e05cb9147a2a81100ddcb06fea8/comments", "author": {"login": "boggle", "id": 50886, "node_id": "MDQ6VXNlcjUwODg2", "avatar_url": "https://avatars.githubusercontent.com/u/50886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boggle", "html_url": "https://github.com/boggle", "followers_url": "https://api.github.com/users/boggle/followers", "following_url": "https://api.github.com/users/boggle/following{/other_user}", "gists_url": "https://api.github.com/users/boggle/gists{/gist_id}", "starred_url": "https://api.github.com/users/boggle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boggle/subscriptions", "organizations_url": "https://api.github.com/users/boggle/orgs", "repos_url": "https://api.github.com/users/boggle/repos", "events_url": "https://api.github.com/users/boggle/events{/privacy}", "received_events_url": "https://api.github.com/users/boggle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "boggle", "id": 50886, "node_id": "MDQ6VXNlcjUwODg2", "avatar_url": "https://avatars.githubusercontent.com/u/50886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boggle", "html_url": "https://github.com/boggle", "followers_url": "https://api.github.com/users/boggle/followers", "following_url": "https://api.github.com/users/boggle/following{/other_user}", "gists_url": "https://api.github.com/users/boggle/gists{/gist_id}", "starred_url": "https://api.github.com/users/boggle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boggle/subscriptions", "organizations_url": "https://api.github.com/users/boggle/orgs", "repos_url": "https://api.github.com/users/boggle/repos", "events_url": "https://api.github.com/users/boggle/events{/privacy}", "received_events_url": "https://api.github.com/users/boggle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16405386f0a843167e234d8d54855a537b0f261d", "url": "https://api.github.com/repos/rust-lang/rust/commits/16405386f0a843167e234d8d54855a537b0f261d", "html_url": "https://github.com/rust-lang/rust/commit/16405386f0a843167e234d8d54855a537b0f261d"}, {"sha": "3971b520bcdd556ff78120c77ffd13785e1c3695", "url": "https://api.github.com/repos/rust-lang/rust/commits/3971b520bcdd556ff78120c77ffd13785e1c3695", "html_url": "https://github.com/rust-lang/rust/commit/3971b520bcdd556ff78120c77ffd13785e1c3695"}], "stats": {"total": 3580, "additions": 2814, "deletions": 766}, "files": [{"sha": "33233231fec8f1678f836060a8f10b661ab2fbd1", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -26,6 +26,7 @@ Jeffrey Yasskin <jyasskin@gmail.com>\n Jesse Ruderman <jruderman@gmail.com>\n Josh Matthews <josh@joshmatthews.net>\n Joshua Wise <joshua@joshuawise.com>\n+Jyun-Yan You <jyyou@cs.nctu.edu.tw>\n Kelly Wilson <wilsonk@cpsc.ucalgary.ca>\n Lennart Kudling\n Lindsey Kuper <lkuper@mozilla.com>"}, {"sha": "927fc62c4af732a735bd85e397cd042e2e5bd2dd", "filename": "configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/configure", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -212,7 +212,7 @@ case $CFG_CPUTYPE in\n         CFG_CPUTYPE=arm\n         ;;\n \n-    x86_64 | x86-64 | x64)\n+    x86_64 | x86-64 | x64 | amd64)\n         CFG_CPUTYPE=x86_64\n         ;;\n "}, {"sha": "d388a1411204e51aaf9c6a9928f113dbb7e6d93d", "filename": "doc/tutorial/args.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/doc%2Ftutorial%2Fargs.md", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/doc%2Ftutorial%2Fargs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fargs.md?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -105,7 +105,7 @@ de-initialized on the caller side, and give ownership of it to the\n called function. This is written `-`.\n \n Finally, the default passing styles (by-value for non-structural\n-types, by-reference for structural ones) are written `+` for by-value\n+types, by-reference for structural ones) are written `++` for by-value\n and `&&` for by(-immutable)-reference. It is sometimes necessary to\n override the defaults. We'll talk more about this when discussing\n [generics][gens]."}, {"sha": "98a175dd3f0201bde67cda38156647804f4694f7", "filename": "mk/libuv/x86_64/freebsd/Makefile", "status": "added", "additions": 353, "deletions": 0, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/mk%2Flibuv%2Fx86_64%2Ffreebsd%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/mk%2Flibuv%2Fx86_64%2Ffreebsd%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fx86_64%2Ffreebsd%2FMakefile?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,353 @@\n+# We borrow heavily from the kernel build setup, though we are simpler since\n+# we don't have Kconfig tweaking settings on us.\n+\n+# The implicit make rules have it looking for RCS files, among other things.\n+# We instead explicitly write all the rules we care about.\n+# It's even quicker (saves ~200ms) to pass -r on the command line.\n+MAKEFLAGS=-r\n+\n+# The source directory tree.\n+srcdir := ../../../..\n+\n+# The name of the builddir.\n+builddir_name ?= out\n+\n+# The V=1 flag on command line makes us verbosely print command lines.\n+ifdef V\n+  quiet=\n+else\n+  quiet=quiet_\n+endif\n+\n+# Specify BUILDTYPE=Release on the command line for a release build.\n+BUILDTYPE ?= Default\n+\n+# Directory all our build output goes into.\n+# Note that this must be two directories beneath src/ for unit tests to pass,\n+# as they reach into the src/ directory for data with relative paths.\n+builddir ?= $(builddir_name)/$(BUILDTYPE)\n+abs_builddir := $(abspath $(builddir))\n+depsdir := $(builddir)/.deps\n+\n+# Object output directory.\n+obj := $(builddir)/obj\n+abs_obj := $(abspath $(obj))\n+\n+# We build up a list of every single one of the targets so we can slurp in the\n+# generated dependency rule Makefiles in one pass.\n+all_deps :=\n+\n+\n+\n+# C++ apps need to be linked with g++.\n+#\n+# Note: flock is used to seralize linking. Linking is a memory-intensive\n+# process so running parallel links can often lead to thrashing.  To disable\n+# the serialization, override LINK via an envrionment variable as follows:\n+#\n+#   export LINK=g++\n+#\n+# This will allow make to invoke N linker processes as specified in -jN.\n+LINK ?= lockf $(builddir)/linker.lock $(CXX)\n+\n+CC.target ?= $(CC)\n+CFLAGS.target ?= $(CFLAGS)\n+CXX.target ?= $(CXX)\n+CXXFLAGS.target ?= $(CXXFLAGS)\n+LINK.target ?= $(LINK)\n+LDFLAGS.target ?= $(LDFLAGS) \n+AR.target ?= $(AR)\n+ARFLAGS.target ?= crs\n+\n+# N.B.: the logic of which commands to run should match the computation done\n+# in gyp's make.py where ARFLAGS.host etc. is computed.\n+# TODO(evan): move all cross-compilation logic to gyp-time so we don't need\n+# to replicate this environment fallback in make as well.\n+CC.host ?= gcc\n+CFLAGS.host ?=\n+CXX.host ?= g++\n+CXXFLAGS.host ?=\n+LINK.host ?= g++\n+LDFLAGS.host ?=\n+AR.host ?= ar\n+ARFLAGS.host := crs\n+\n+# Define a dir function that can handle spaces.\n+# http://www.gnu.org/software/make/manual/make.html#Syntax-of-Functions\n+# \"leading spaces cannot appear in the text of the first argument as written.\n+# These characters can be put into the argument value by variable substitution.\"\n+empty :=\n+space := $(empty) $(empty)\n+\n+# http://stackoverflow.com/questions/1189781/using-make-dir-or-notdir-on-a-path-with-spaces\n+replace_spaces = $(subst $(space),?,$1)\n+unreplace_spaces = $(subst ?,$(space),$1)\n+dirx = $(call unreplace_spaces,$(dir $(call replace_spaces,$1)))\n+\n+# Flags to make gcc output dependency info.  Note that you need to be\n+# careful here to use the flags that ccache and distcc can understand.\n+# We write to a dep file on the side first and then rename at the end\n+# so we can't end up with a broken dep file.\n+depfile = $(depsdir)/$(call replace_spaces,$@).d\n+DEPFLAGS = -MMD -MF $(depfile).raw\n+\n+# We have to fixup the deps output in a few ways.\n+# (1) the file output should mention the proper .o file.\n+# ccache or distcc lose the path to the target, so we convert a rule of\n+# the form:\n+#   foobar.o: DEP1 DEP2\n+# into\n+#   path/to/foobar.o: DEP1 DEP2\n+# (2) we want missing files not to cause us to fail to build.\n+# We want to rewrite\n+#   foobar.o: DEP1 DEP2 \\\n+#               DEP3\n+# to\n+#   DEP1:\n+#   DEP2:\n+#   DEP3:\n+# so if the files are missing, they're just considered phony rules.\n+# We have to do some pretty insane escaping to get those backslashes\n+# and dollar signs past make, the shell, and sed at the same time.\n+# Doesn't work with spaces, but that's fine: .d files have spaces in\n+# their names replaced with other characters.\n+define fixup_dep\n+# The depfile may not exist if the input file didn't have any #includes.\n+touch $(depfile).raw\n+# Fixup path as in (1).\n+sed -e \"s|^$(notdir $@)|$@|\" $(depfile).raw >> $(depfile)\n+# Add extra rules as in (2).\n+# We remove slashes and replace spaces with new lines;\n+# remove blank lines;\n+# delete the first line and append a colon to the remaining lines.\n+sed -e 's|\\\\||' -e 'y| |\\n|' $(depfile).raw |\\\n+  grep -v '^$$'                             |\\\n+  sed -e 1d -e 's|$$|:|'                     \\\n+    >> $(depfile)\n+rm $(depfile).raw\n+endef\n+\n+# Command definitions:\n+# - cmd_foo is the actual command to run;\n+# - quiet_cmd_foo is the brief-output summary of the command.\n+\n+quiet_cmd_cc = CC($(TOOLSET)) $@\n+cmd_cc = $(CC.$(TOOLSET)) $(GYP_CFLAGS) $(DEPFLAGS) $(CFLAGS.$(TOOLSET)) -c -o $@ $<\n+\n+quiet_cmd_cxx = CXX($(TOOLSET)) $@\n+cmd_cxx = $(CXX.$(TOOLSET)) $(GYP_CXXFLAGS) $(DEPFLAGS) $(CXXFLAGS.$(TOOLSET)) -c -o $@ $<\n+\n+quiet_cmd_touch = TOUCH $@\n+cmd_touch = touch $@\n+\n+quiet_cmd_copy = COPY $@\n+# send stderr to /dev/null to ignore messages when linking directories.\n+cmd_copy = ln -f \"$<\" \"$@\" 2>/dev/null || (rm -rf \"$@\" && cp -af \"$<\" \"$@\")\n+\n+quiet_cmd_alink = AR($(TOOLSET)) $@\n+cmd_alink = rm -f $@ && $(AR.$(TOOLSET)) $(ARFLAGS.$(TOOLSET)) $@ $(filter %.o,$^)\n+\n+# Due to circular dependencies between libraries :(, we wrap the\n+# special \"figure out circular dependencies\" flags around the entire\n+# input list during linking.\n+quiet_cmd_link = LINK($(TOOLSET)) $@\n+cmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ -Wl,--start-group $(LD_INPUTS) -Wl,--end-group $(LIBS)\n+\n+# We support two kinds of shared objects (.so):\n+# 1) shared_library, which is just bundling together many dependent libraries\n+# into a link line.\n+# 2) loadable_module, which is generating a module intended for dlopen().\n+#\n+# They differ only slightly:\n+# In the former case, we want to package all dependent code into the .so.\n+# In the latter case, we want to package just the API exposed by the\n+# outermost module.\n+# This means shared_library uses --whole-archive, while loadable_module doesn't.\n+# (Note that --whole-archive is incompatible with the --start-group used in\n+# normal linking.)\n+\n+# Other shared-object link notes:\n+# - Set SONAME to the library filename so our binaries don't reference\n+# the local, absolute paths used on the link command-line.\n+quiet_cmd_solink = SOLINK($(TOOLSET)) $@\n+cmd_solink = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--whole-archive $(LD_INPUTS) -Wl,--no-whole-archive $(LIBS)\n+\n+quiet_cmd_solink_module = SOLINK_MODULE($(TOOLSET)) $@\n+cmd_solink_module = $(LINK.$(TOOLSET)) -shared $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -Wl,-soname=$(@F) -o $@ -Wl,--start-group $(filter-out FORCE_DO_CMD, $^) -Wl,--end-group $(LIBS)\n+\n+\n+# Define an escape_quotes function to escape single quotes.\n+# This allows us to handle quotes properly as long as we always use\n+# use single quotes and escape_quotes.\n+escape_quotes = $(subst ','\\'',$(1))\n+# This comment is here just to include a ' to unconfuse syntax highlighting.\n+# Define an escape_vars function to escape '$' variable syntax.\n+# This allows us to read/write command lines with shell variables (e.g.\n+# $LD_LIBRARY_PATH), without triggering make substitution.\n+escape_vars = $(subst $$,$$$$,$(1))\n+# Helper that expands to a shell command to echo a string exactly as it is in\n+# make. This uses printf instead of echo because printf's behaviour with respect\n+# to escape sequences is more portable than echo's across different shells\n+# (e.g., dash, bash).\n+exact_echo = printf '%s\\n' '$(call escape_quotes,$(1))'\n+\n+# Helper to compare the command we're about to run against the command\n+# we logged the last time we ran the command.  Produces an empty\n+# string (false) when the commands match.\n+# Tricky point: Make has no string-equality test function.\n+# The kernel uses the following, but it seems like it would have false\n+# positives, where one string reordered its arguments.\n+#   arg_check = $(strip $(filter-out $(cmd_$(1)), $(cmd_$@)) \\\n+#                       $(filter-out $(cmd_$@), $(cmd_$(1))))\n+# We instead substitute each for the empty string into the other, and\n+# say they're equal if both substitutions produce the empty string.\n+# .d files contain ? instead of spaces, take that into account.\n+command_changed = $(or $(subst $(cmd_$(1)),,$(cmd_$(call replace_spaces,$@))),\\\n+                       $(subst $(cmd_$(call replace_spaces,$@)),,$(cmd_$(1))))\n+\n+# Helper that is non-empty when a prerequisite changes.\n+# Normally make does this implicitly, but we force rules to always run\n+# so we can check their command lines.\n+#   $? -- new prerequisites\n+#   $| -- order-only dependencies\n+prereq_changed = $(filter-out FORCE_DO_CMD,$(filter-out $|,$?))\n+\n+# Helper that executes all postbuilds, and deletes the output file when done\n+# if any of the postbuilds failed.\n+define do_postbuilds\n+  @E=0;\\\n+  for p in $(POSTBUILDS); do\\\n+    eval $$p;\\\n+    F=$$?;\\\n+    if [ $$F -ne 0 ]; then\\\n+      E=$$F;\\\n+    fi;\\\n+  done;\\\n+  if [ $$E -ne 0 ]; then\\\n+    rm -rf \"$@\";\\\n+    exit $$E;\\\n+  fi\n+endef\n+\n+# do_cmd: run a command via the above cmd_foo names, if necessary.\n+# Should always run for a given target to handle command-line changes.\n+# Second argument, if non-zero, makes it do asm/C/C++ dependency munging.\n+# Third argument, if non-zero, makes it do POSTBUILDS processing.\n+# Note: We intentionally do NOT call dirx for depfile, since it contains ? for\n+# spaces already and dirx strips the ? characters.\n+define do_cmd\n+$(if $(or $(command_changed),$(prereq_changed)),\n+  @$(call exact_echo,  $($(quiet)cmd_$(1)))\n+  @mkdir -p \"$(call dirx,$@)\" \"$(dir $(depfile))\"\n+  $(if $(findstring flock,$(word 1,$(cmd_$1))),\n+    @$(cmd_$(1))\n+    @echo \"  $(quiet_cmd_$(1)): Finished\",\n+    @$(cmd_$(1))\n+  )\n+  @$(call exact_echo,$(call escape_vars,cmd_$(call replace_spaces,$@) := $(cmd_$(1)))) > $(depfile)\n+  @$(if $(2),$(fixup_dep))\n+  $(if $(and $(3), $(POSTBUILDS)),\n+    $(call do_postbuilds)\n+  )\n+)\n+endef\n+\n+# Declare the \"all\" target first so it is the default,\n+# even though we don't have the deps yet.\n+.PHONY: all\n+all:\n+\n+# Use FORCE_DO_CMD to force a target to run.  Should be coupled with\n+# do_cmd.\n+.PHONY: FORCE_DO_CMD\n+FORCE_DO_CMD:\n+\n+TOOLSET := target\n+# Suffix rules, putting all outputs into $(obj).\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.cc FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.cpp FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.cxx FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.S FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(srcdir)/%.s FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# Try building from generated source, too.\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.cc FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.cpp FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.cxx FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.S FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj).$(TOOLSET)/%.s FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.cc FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.cpp FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.cxx FORCE_DO_CMD\n+\t@$(call do_cmd,cxx,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.S FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+$(obj).$(TOOLSET)/%.o: $(obj)/%.s FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+\n+ifeq ($(strip $(foreach prefix,$(NO_LOAD),\\\n+    $(findstring $(join ^,$(prefix)),\\\n+                 $(join ^,src/libuv/run-benchmarks.target.mk)))),)\n+  include src/libuv/run-benchmarks.target.mk\n+endif\n+ifeq ($(strip $(foreach prefix,$(NO_LOAD),\\\n+    $(findstring $(join ^,$(prefix)),\\\n+                 $(join ^,src/libuv/run-tests.target.mk)))),)\n+  include src/libuv/run-tests.target.mk\n+endif\n+ifeq ($(strip $(foreach prefix,$(NO_LOAD),\\\n+    $(findstring $(join ^,$(prefix)),\\\n+                 $(join ^,src/libuv/uv.target.mk)))),)\n+  include src/libuv/uv.target.mk\n+endif\n+\n+quiet_cmd_regen_makefile = ACTION Regenerating $@\n+cmd_regen_makefile = ./src/libuv/build/gyp/gyp -fmake --ignore-environment \"--toplevel-dir=.\" \"--depth=.\" \"--generator-output=mk/libuv/x86_64/unix\" \"-Dlibrary=static_library\" \"-Dtarget_arch=x86_64\" \"-DOS=freebsd\" src/libuv/uv.gyp\n+Makefile: $(srcdir)/src/libuv/uv.gyp\n+#\t$(call do_cmd,regen_makefile)\n+\n+# \"all\" is a concatenation of the \"all\" targets from all the included\n+# sub-makefiles. This is just here to clarify.\n+all:\n+\n+# Add in dependency-tracking rules.  $(all_deps) is the list of every single\n+# target in our tree. Only consider the ones with .d (dependency) info:\n+d_files := $(wildcard $(foreach f,$(all_deps),$(depsdir)/$(f).d))\n+ifneq ($(d_files),)\n+  # Rather than include each individual .d file, concatenate them into a\n+  # single file which make is able to load faster.  We split this into\n+  # commands that take 1000 files at a time to avoid overflowing the\n+  # command line.\n+  $(shell cat $(wordlist 1,1000,$(d_files)) > $(depsdir)/all.deps)\n+\n+  ifneq ($(word 1001,$(d_files)),)\n+    $(error Found unprocessed dependency files (gyp didn't generate enough rules!))\n+  endif\n+\n+  # make looks for ways to re-generate included makefiles, but in our case, we\n+  # don't have a direct way. Explicitly telling make that it has nothing to do\n+  # for them makes it go faster.\n+  $(depsdir)/all.deps: ;\n+\n+  include $(depsdir)/all.deps\n+endif"}, {"sha": "333d5e04a2310ac30a9e71fedb8b6cdab5c78e51", "filename": "mk/libuv/x86_64/freebsd/src/libuv/run-benchmarks.target.mk", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/mk%2Flibuv%2Fx86_64%2Ffreebsd%2Fsrc%2Flibuv%2Frun-benchmarks.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/mk%2Flibuv%2Fx86_64%2Ffreebsd%2Fsrc%2Flibuv%2Frun-benchmarks.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fx86_64%2Ffreebsd%2Fsrc%2Flibuv%2Frun-benchmarks.target.mk?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,83 @@\n+# This file is generated by gyp; do not edit.\n+\n+TOOLSET := target\n+TARGET := run-benchmarks\n+DEFS_Default := '-D_LARGEFILE_SOURCE' \\\n+\t'-D_FILE_OFFSET_BITS=64' \\\n+\t'-D_GNU_SOURCE' \\\n+\t'-DEIO_STACKSIZE=262144'\n+\n+# Flags passed to all source files.\n+CFLAGS_Default := -pthread\n+\n+# Flags passed to only C files.\n+CFLAGS_C_Default := \n+\n+# Flags passed to only C++ files.\n+CFLAGS_CC_Default := \n+\n+INCS_Default := -I$(srcdir)/src/libuv/include\n+\n+OBJS := $(obj).target/$(TARGET)/src/libuv/test/benchmark-ares.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/benchmark-getaddrinfo.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/benchmark-ping-pongs.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/benchmark-pound.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/benchmark-pump.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/benchmark-sizes.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/benchmark-spawn.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/benchmark-tcp-write-batch.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/benchmark-udp-packet-storm.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/dns-server.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/echo-server.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/blackhole-server.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/run-benchmarks.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/runner.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/runner-unix.o\n+\n+# Add to the list of files we specially track dependencies for.\n+all_deps += $(OBJS)\n+\n+# Make sure our dependencies are built before any of us.\n+$(OBJS): | $(obj).target/src/libuv/libuv.a\n+\n+# CFLAGS et al overrides must be target-local.\n+# See \"Target-specific Variable Values\" in the GNU Make manual.\n+$(OBJS): TOOLSET := $(TOOLSET)\n+$(OBJS): GYP_CFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_C_$(BUILDTYPE))\n+$(OBJS): GYP_CXXFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_CC_$(BUILDTYPE))\n+\n+# Suffix rules, putting all outputs into $(obj).\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(srcdir)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# Try building from generated source, too.\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj).$(TOOLSET)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# End of this set of suffix rules\n+### Rules for final target.\n+LDFLAGS_Default := \n+\n+LIBS := \n+\n+$(builddir)/run-benchmarks: GYP_LDFLAGS := $(LDFLAGS_$(BUILDTYPE))\n+$(builddir)/run-benchmarks: LIBS := $(LIBS)\n+$(builddir)/run-benchmarks: LD_INPUTS := $(OBJS) $(obj).target/src/libuv/libuv.a\n+$(builddir)/run-benchmarks: TOOLSET := $(TOOLSET)\n+$(builddir)/run-benchmarks: $(OBJS) $(obj).target/src/libuv/libuv.a FORCE_DO_CMD\n+\t$(call do_cmd,link)\n+\n+all_deps += $(builddir)/run-benchmarks\n+# Add target alias\n+.PHONY: run-benchmarks\n+run-benchmarks: $(builddir)/run-benchmarks\n+\n+# Add executable to \"all\" target.\n+.PHONY: all\n+all: $(builddir)/run-benchmarks\n+"}, {"sha": "7eb08d192d1bb85fc48cd7924a093d4e72cffa3c", "filename": "mk/libuv/x86_64/freebsd/src/libuv/run-tests.target.mk", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/mk%2Flibuv%2Fx86_64%2Ffreebsd%2Fsrc%2Flibuv%2Frun-tests.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/mk%2Flibuv%2Fx86_64%2Ffreebsd%2Fsrc%2Flibuv%2Frun-tests.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fx86_64%2Ffreebsd%2Fsrc%2Flibuv%2Frun-tests.target.mk?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,117 @@\n+# This file is generated by gyp; do not edit.\n+\n+TOOLSET := target\n+TARGET := run-tests\n+DEFS_Default := '-D_LARGEFILE_SOURCE' \\\n+\t'-D_FILE_OFFSET_BITS=64' \\\n+\t'-D_GNU_SOURCE' \\\n+\t'-DEIO_STACKSIZE=262144'\n+\n+# Flags passed to all source files.\n+CFLAGS_Default := -pthread\n+\n+# Flags passed to only C files.\n+CFLAGS_C_Default := \n+\n+# Flags passed to only C++ files.\n+CFLAGS_CC_Default := \n+\n+INCS_Default := -I$(srcdir)/src/libuv/include\n+\n+OBJS := $(obj).target/$(TARGET)/src/libuv/test/blackhole-server.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/echo-server.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/run-tests.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/runner.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-get-loadavg.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-async.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-error.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-callback-stack.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-connection-fail.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-delayed-accept.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-fail-always.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-fs.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-fs-event.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-get-currentexe.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-get-memory.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-getaddrinfo.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-gethostbyname.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-getsockname.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-hrtime.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-idle.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-ipc.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-loop-handles.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-multiple-listen.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-pass-always.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-ping-pong.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-pipe-bind-error.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-pipe-connect-error.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-ref.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-shutdown-eof.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-spawn.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-stdio-over-pipes.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-tcp-bind-error.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-tcp-bind6-error.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-tcp-close.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-tcp-flags.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-tcp-connect-error.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-tcp-connect6-error.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-tcp-write-error.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-tcp-write-to-half-open-connection.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-tcp-writealot.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-threadpool.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-timer-again.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-timer.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-tty.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-udp-dgram-too-big.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-udp-ipv6.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-udp-send-and-recv.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/test-udp-multicast-join.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/test/runner-unix.o\n+\n+# Add to the list of files we specially track dependencies for.\n+all_deps += $(OBJS)\n+\n+# Make sure our dependencies are built before any of us.\n+$(OBJS): | $(obj).target/src/libuv/libuv.a\n+\n+# CFLAGS et al overrides must be target-local.\n+# See \"Target-specific Variable Values\" in the GNU Make manual.\n+$(OBJS): TOOLSET := $(TOOLSET)\n+$(OBJS): GYP_CFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_C_$(BUILDTYPE))\n+$(OBJS): GYP_CXXFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_CC_$(BUILDTYPE))\n+\n+# Suffix rules, putting all outputs into $(obj).\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(srcdir)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# Try building from generated source, too.\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj).$(TOOLSET)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# End of this set of suffix rules\n+### Rules for final target.\n+LDFLAGS_Default := \n+\n+LIBS := \n+\n+$(builddir)/run-tests: GYP_LDFLAGS := $(LDFLAGS_$(BUILDTYPE))\n+$(builddir)/run-tests: LIBS := $(LIBS)\n+$(builddir)/run-tests: LD_INPUTS := $(OBJS) $(obj).target/src/libuv/libuv.a\n+$(builddir)/run-tests: TOOLSET := $(TOOLSET)\n+$(builddir)/run-tests: $(OBJS) $(obj).target/src/libuv/libuv.a FORCE_DO_CMD\n+\t$(call do_cmd,link)\n+\n+all_deps += $(builddir)/run-tests\n+# Add target alias\n+.PHONY: run-tests\n+run-tests: $(builddir)/run-tests\n+\n+# Add executable to \"all\" target.\n+.PHONY: all\n+all: $(builddir)/run-tests\n+"}, {"sha": "3842bae54b951d4e4d977d3f6f984e92be64f166", "filename": "mk/libuv/x86_64/freebsd/src/libuv/uv.Makefile", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/mk%2Flibuv%2Fx86_64%2Ffreebsd%2Fsrc%2Flibuv%2Fuv.Makefile", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/mk%2Flibuv%2Fx86_64%2Ffreebsd%2Fsrc%2Flibuv%2Fuv.Makefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fx86_64%2Ffreebsd%2Fsrc%2Flibuv%2Fuv.Makefile?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,6 @@\n+# This file is generated by gyp; do not edit.\n+\n+export builddir_name ?= mk/libuv/x86_64/unix/./src/libuv/out\n+.PHONY: all\n+all:\n+\t$(MAKE) -C ../.. uv run-benchmarks run-tests"}, {"sha": "f1b02252a037e0804f7206524cbe8e56d8a87445", "filename": "mk/libuv/x86_64/freebsd/src/libuv/uv.target.mk", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/mk%2Flibuv%2Fx86_64%2Ffreebsd%2Fsrc%2Flibuv%2Fuv.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/mk%2Flibuv%2Fx86_64%2Ffreebsd%2Fsrc%2Flibuv%2Fuv.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fx86_64%2Ffreebsd%2Fsrc%2Flibuv%2Fuv.target.mk?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,138 @@\n+# This file is generated by gyp; do not edit.\n+\n+TOOLSET := target\n+TARGET := uv\n+DEFS_Default := '-D_LARGEFILE_SOURCE' \\\n+\t'-D_FILE_OFFSET_BITS=64' \\\n+\t'-D_GNU_SOURCE' \\\n+\t'-DEIO_STACKSIZE=262144' \\\n+\t'-DHAVE_CONFIG_H' \\\n+\t'-DEV_CONFIG_H=\"config_freebsd.h\"' \\\n+\t'-DEIO_CONFIG_H=\"config_freebsd.h\"'\n+\n+# Flags passed to all source files.\n+CFLAGS_Default := -pthread \\\n+\t-g \\\n+\t--std=gnu89 \\\n+\t-pedantic \\\n+\t-Wall \\\n+\t-Wextra \\\n+\t-Wno-unused-parameter\n+\n+# Flags passed to only C files.\n+CFLAGS_C_Default := \n+\n+# Flags passed to only C++ files.\n+CFLAGS_CC_Default := \n+\n+INCS_Default := -I$(srcdir)/src/libuv/include \\\n+\t-I$(srcdir)/src/libuv/include/uv-private \\\n+\t-I$(srcdir)/src/libuv/src \\\n+\t-I$(srcdir)/src/libuv/src/unix/ev \\\n+\t-I$(srcdir)/src/libuv/src/ares/config_freebsd\n+\n+OBJS := $(obj).target/$(TARGET)/src/libuv/src/uv-common.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_cancel.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares__close_sockets.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_data.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_destroy.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_expand_name.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_expand_string.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_fds.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_free_hostent.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_free_string.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_gethostbyaddr.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_gethostbyname.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares__get_hostent.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_getnameinfo.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_getopt.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_getsock.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_init.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_library_init.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_llist.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_mkquery.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_nowarn.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_options.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_parse_aaaa_reply.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_parse_a_reply.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_parse_mx_reply.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_parse_ns_reply.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_parse_ptr_reply.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_parse_srv_reply.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_parse_txt_reply.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_process.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_query.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares__read_line.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_search.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_send.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_strcasecmp.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_strdup.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_strerror.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_timeout.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares__timeval.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_version.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/ares_writev.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/bitncmp.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/inet_net_pton.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/inet_ntop.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/ares/windows_port.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/unix/core.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/unix/uv-eio.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/unix/fs.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/unix/udp.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/unix/tcp.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/unix/pipe.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/unix/tty.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/unix/stream.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/unix/cares.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/unix/dl.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/unix/error.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/unix/process.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/unix/eio/eio.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/unix/ev/ev.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/unix/freebsd.o \\\n+\t$(obj).target/$(TARGET)/src/libuv/src/unix/kqueue.o\n+\n+# Add to the list of files we specially track dependencies for.\n+all_deps += $(OBJS)\n+\n+# CFLAGS et al overrides must be target-local.\n+# See \"Target-specific Variable Values\" in the GNU Make manual.\n+$(OBJS): TOOLSET := $(TOOLSET)\n+$(OBJS): GYP_CFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_C_$(BUILDTYPE))\n+$(OBJS): GYP_CXXFLAGS := $(DEFS_$(BUILDTYPE)) $(INCS_$(BUILDTYPE)) $(CFLAGS_$(BUILDTYPE)) $(CFLAGS_CC_$(BUILDTYPE))\n+\n+# Suffix rules, putting all outputs into $(obj).\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(srcdir)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# Try building from generated source, too.\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj).$(TOOLSET)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+$(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj)/%.c FORCE_DO_CMD\n+\t@$(call do_cmd,cc,1)\n+\n+# End of this set of suffix rules\n+### Rules for final target.\n+LDFLAGS_Default := \n+\n+LIBS := -lm\n+\n+$(obj).target/src/libuv/libuv.a: GYP_LDFLAGS := $(LDFLAGS_$(BUILDTYPE))\n+$(obj).target/src/libuv/libuv.a: LIBS := $(LIBS)\n+$(obj).target/src/libuv/libuv.a: TOOLSET := $(TOOLSET)\n+$(obj).target/src/libuv/libuv.a: $(OBJS) FORCE_DO_CMD\n+\t$(call do_cmd,alink)\n+\n+all_deps += $(obj).target/src/libuv/libuv.a\n+# Add target alias\n+.PHONY: uv\n+uv: $(obj).target/src/libuv/libuv.a\n+\n+# Add target alias to \"all\" target.\n+.PHONY: all\n+all: uv\n+"}, {"sha": "40a3dd8ebc6b959d257f4f0e8f6c6a50f1cbb587", "filename": "mk/platform.mk", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -24,14 +24,15 @@ endif\n ifneq ($(findstring freebsd,$(CFG_OSTYPE)),)\n   CFG_LIB_NAME=lib$(1).so\n   CFG_LIB_GLOB=lib$(1)-*.so\n-  CFG_GCCISH_CFLAGS += -fPIC -march=i686 -I/usr/local/include\n+  CFG_GCCISH_CFLAGS += -fPIC -I/usr/local/include\n   CFG_GCCISH_LINK_FLAGS += -shared -fPIC -lpthread -lrt\n-  ifeq ($(CFG_CPUTYPE), x86_64)\n-\tCFG_GCCISH_CFLAGS_i386 += -m32\n-\tCFG_GCCISH_LINK_FLAGS_i386 += -m32\n-\tCFG_GCCISH_CFLAGS_x86_64 += -m32\n-\tCFG_GCCISH_LINK_FLAGS_x86_64 += -m32\n-  endif\n+  CFG_GCCISH_DEF_FLAG := -Wl,--export-dynamic,--dynamic-list=\n+  CFG_GCCISH_PRE_LIB_FLAGS := -Wl,-whole-archive\n+  CFG_GCCISH_POST_LIB_FLAGS := -Wl,-no-whole-archive\n+  CFG_GCCISH_CFLAGS_i386 += -m32\n+  CFG_GCCISH_LINK_FLAGS_i386 += -m32\n+  CFG_GCCISH_CFLAGS_x86_64 += -m64\n+  CFG_GCCISH_LINK_FLAGS_x86_64 += -m64\n   CFG_UNIXY := 1\n   CFG_LDENV := LD_LIBRARY_PATH\n   CFG_DEF_SUFFIX := .bsd.def\n@@ -246,4 +247,4 @@ define CFG_MAKE_ASSEMBLER\n endef\n \n $(foreach target,$(CFG_TARGET_TRIPLES),\\\n-  $(eval $(call CFG_MAKE_ASSEMBLER,$(target))))\n\\ No newline at end of file\n+  $(eval $(call CFG_MAKE_ASSEMBLER,$(target))))"}, {"sha": "2eae42087290badf1ca360df307dc4aca2b1e710", "filename": "mk/rt.mk", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -119,6 +119,9 @@ ifeq ($$(CFG_WINDOWSY), 1)\n else ifeq ($(CFG_OSTYPE), apple-darwin)\n   LIBUV_OSTYPE_$(1) := mac\n   LIBUV_LIB_$(1) := rt/$(1)/libuv/Default/libuv.a\n+else ifeq ($(CFG_OSTYPE), unknown-freebsd)\n+  LIBUV_OSTYPE_$(1) := freebsd\n+  LIBUV_LIB_$(1) := rt/$(1)/libuv/Default/obj.target/src/libuv/libuv.a\n else\n   LIBUV_OSTYPE_$(1) := unix\n   LIBUV_LIB_$(1) := rt/$(1)/libuv/Default/obj.target/src/libuv/libuv.a\n@@ -174,6 +177,12 @@ $$(LIBUV_LIB_$(1)): $$(wildcard \\\n # These could go in rt.mk or rustllvm.mk, they're needed for both.\n \n # This regexp has a single $, escaped twice\n+%.bsd.def:    %.def.in $$(MKFILE_DEPS)\n+\t@$$(call E, def: $$@)\n+\t$$(Q)echo \"{\" > $$@\n+\t$$(Q)sed 's/.$$$$/&;/' $$< >> $$@\n+\t$$(Q)echo \"};\" >> $$@\n+\n %.linux.def:    %.def.in $$(MKFILE_DEPS)\n \t@$$(call E, def: $$@)\n \t$$(Q)echo \"{\" > $$@"}, {"sha": "8950618c2e6e6b90c177e9f8df76896b7a870e0d", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -34,7 +34,7 @@ fn llvm_err(sess: session::session, msg: str) unsafe {\n     let buf = llvm::LLVMRustGetLastError();\n     if buf == ptr::null() {\n         sess.fatal(msg);\n-    } else { sess.fatal(msg + \": \" + str::str_from_cstr(buf)); }\n+    } else { sess.fatal(msg + \": \" + str::from_cstr(buf)); }\n }\n \n fn load_intrinsics_bc(sess: session::session) -> option::t<ModuleRef> {\n@@ -566,7 +566,8 @@ fn link_binary(sess: session::session,\n         let rmlib =\n             bind fn (config: @session::config, filename: str) -> str {\n                      if config.os == session::os_macos ||\n-                            config.os == session::os_linux &&\n+                            (config.os == session::os_linux ||\n+                             config.os == session::os_freebsd) &&\n                                 str::find(filename, \"lib\") == 0 {\n                          ret str::slice(filename, 3u,\n                                         str::byte_len(filename));\n@@ -580,6 +581,7 @@ fn link_binary(sess: session::session,\n         ret alt config.os {\n               session::os_macos. { rmext(rmlib(filename)) }\n               session::os_linux. { rmext(rmlib(filename)) }\n+              session::os_freebsd. { rmext(rmlib(filename)) }\n               _ { rmext(filename) }\n             };\n     }\n@@ -657,6 +659,15 @@ fn link_binary(sess: session::session,\n         gcc_args += [\"-lrt\", \"-ldl\"];\n     }\n \n+    if sess.get_targ_cfg().os == session::os_freebsd {\n+        gcc_args += [\"-lrt\", \"-L/usr/local/lib\", \"-lexecinfo\",\n+                     \"-L/usr/local/lib/gcc46\",\n+                     \"-L/usr/local/lib/gcc44\", \"-lstdc++\",\n+                     \"-Wl,-z,origin\",\n+                     \"-Wl,-rpath,/usr/local/lib/gcc46\",\n+                     \"-Wl,-rpath,/usr/local/lib/gcc44\"];\n+    }\n+\n     // OS X 10.6 introduced 'compact unwind info', which is produced by the\n     // linker from the dwarf unwind info. Unfortunately, it does not seem to\n     // understand how to unwind our __morestack frame, so we have to turn it"}, {"sha": "fccacdcba801b1887072419e15ee3a3e6108bde2", "filename": "src/comp/back/rpath.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Frpath.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -105,6 +105,7 @@ fn get_rpath_relative_to_output(os: session::os,\n     // Mac doesn't appear to support $ORIGIN\n     let prefix = alt os {\n         session::os_linux. { \"$ORIGIN\" + fs::path_sep() }\n+        session::os_freebsd. { \"$ORIGIN\" + fs::path_sep() }\n         session::os_macos. { \"@executable_path\" + fs::path_sep() }\n     };\n \n@@ -191,6 +192,7 @@ fn minimize_rpaths(rpaths: [str]) -> [str] {\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n #[cfg(test)]\n mod test {\n     #[test]\n@@ -315,6 +317,14 @@ mod test {\n         assert res == \"$ORIGIN/../lib\";\n     }\n \n+    #[test]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn test_rpath_relative() {\n+        let res = get_rpath_relative_to_output(session::os_freebsd,\n+            \"/usr\", \"bin/rustc\", \"lib/libstd.so\");\n+        assert res == \"$ORIGIN/../lib\";\n+    }\n+\n     #[test]\n     #[cfg(target_os = \"macos\")]\n     fn test_rpath_relative() {"}, {"sha": "6e668b4c967c7c1efb0d352ab3533f4630b6d424", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -8,6 +8,7 @@ fn get_target_strs(target_os: session::os) -> target_strs::t {\n           session::os_macos. { \"__DATA,__note.rustc\" }\n           session::os_win32. { \".note.rustc\" }\n           session::os_linux. { \".note.rustc\" }\n+          session::os_freebsd. { \".note.rustc\" }\n         },\n \n         data_layout: alt target_os {\n@@ -24,12 +25,17 @@ fn get_target_strs(target_os: session::os) -> target_strs::t {\n           session::os_linux. {\n             \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\"\n           }\n+\n+          session::os_freebsd. {\n+            \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\"\n+          }\n         },\n \n         target_triple: alt target_os {\n           session::os_macos. { \"i686-apple-darwin\" }\n           session::os_win32. { \"i686-pc-mingw32\" }\n           session::os_linux. { \"i686-unknown-linux-gnu\" }\n+          session::os_freebsd. { \"i686-unknown-freebsd\" }\n         },\n \n         gcc_args: [\"-m32\"]"}, {"sha": "b02910be489d6072321f791e30231879fde8aeb4", "filename": "src/comp/back/x86_64.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86_64.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -8,6 +8,7 @@ fn get_target_strs(target_os: session::os) -> target_strs::t {\n           session::os_macos. { \"__DATA,__note.rustc\" }\n           session::os_win32. { \".note.rustc\" }\n           session::os_linux. { \".note.rustc\" }\n+          session::os_freebsd. { \".note.rustc\" }\n         },\n \n         data_layout: alt target_os {\n@@ -29,12 +30,19 @@ fn get_target_strs(target_os: session::os) -> target_strs::t {\n                 \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 \"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n           }\n+\n+          session::os_freebsd. {\n+            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n+                \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n+                \"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n+          }\n         },\n \n         target_triple: alt target_os {\n           session::os_macos. { \"x86_64-apple-darwin\" }\n           session::os_win32. { \"x86_64-pc-mingw32\" }\n           session::os_linux. { \"x86_64-unknown-linux-gnu\" }\n+          session::os_freebsd. { \"x86_64-unknown-freebsd\" }\n         },\n \n         gcc_args: [\"-m64\"]"}, {"sha": "b8a6ba2872937a9838403685587b57caa3d59feb", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -26,6 +26,7 @@ fn default_configuration(sess: session::session, argv0: str, input: str) ->\n           session::os_win32. { \"msvcrt.dll\" }\n           session::os_macos. { \"libc.dylib\" }\n           session::os_linux. { \"libc.so.6\" }\n+          session::os_freebsd. { \"libc.so.7\" }\n           _ { \"libc.so\" }\n         };\n \n@@ -172,8 +173,9 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n     time(time_passes, \"const checking\",\n          bind middle::check_const::check_crate(sess, crate));\n     let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars);\n-    let method_map = time(time_passes, \"typechecking\",\n-                          bind typeck::check_crate(ty_cx, impl_map, crate));\n+    let (method_map, dict_map) =\n+        time(time_passes, \"typechecking\",\n+             bind typeck::check_crate(ty_cx, impl_map, crate));\n     time(time_passes, \"block-use checking\",\n          bind middle::block_use::check_crate(ty_cx, crate));\n     time(time_passes, \"function usage\",\n@@ -201,7 +203,7 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n              bind trans::trans_crate(sess, crate, ty_cx,\n                                      outputs.obj_filename, exp_map, ast_map,\n                                      mut_map, copy_map, last_uses,\n-                                     method_map));\n+                                     method_map, dict_map));\n     time(time_passes, \"LLVM passes\",\n          bind link::write::run_passes(sess, llmod, outputs.obj_filename));\n \n@@ -294,6 +296,8 @@ fn get_os(triple: str) -> session::os {\n             session::os_macos\n         } else if str::find(triple, \"linux\") >= 0 {\n             session::os_linux\n+        } else if str::find(triple, \"freebsd\") >= 0 {\n+            session::os_freebsd\n         } else { early_error(\"Unknown operating system!\") };\n }\n "}, {"sha": "55f25a14f1d354ea2ff8b51a79e92aead655f383", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -9,7 +9,7 @@ import syntax::parse::parser::parse_sess;\n import util::filesearch;\n import back::target_strs;\n \n-tag os { os_win32; os_macos; os_linux; }\n+tag os { os_win32; os_macos; os_linux; os_freebsd; }\n \n tag arch { arch_x86; arch_x86_64; arch_arm; }\n "}, {"sha": "927e9879657106e103c170e9e7e7593c6c87221c", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -993,7 +993,8 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n       }\n       10 {\n         let el_ty = llvm::LLVMGetElementType(ty);\n-        ret \"[\" + type_to_str_inner(names, outer, el_ty) + \"]\";\n+        ret \"[\" + type_to_str_inner(names, outer, el_ty) + \" x \" +\n+            uint::str(llvm::LLVMGetArrayLength(ty)) + \"]\";\n       }\n       11 {\n         let i: uint = 0u;"}, {"sha": "21ead604d31d72b6053badc3aef301a6b60169e3", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -129,6 +129,7 @@ fn default_native_lib_naming(sess: session::session, static: bool) ->\n       session::os_win32. { ret {prefix: \"\", suffix: \".dll\"}; }\n       session::os_macos. { ret {prefix: \"lib\", suffix: \".dylib\"}; }\n       session::os_linux. { ret {prefix: \"lib\", suffix: \".so\"}; }\n+      session::os_freebsd. { ret {prefix: \"lib\", suffix: \".so\"}; }\n     }\n }\n \n@@ -215,7 +216,7 @@ fn get_metadata_section(sess: session::session,\n     let si = mk_section_iter(of.llof);\n     while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n         let name_buf = llvm::LLVMGetSectionName(si.llsi);\n-        let name = unsafe { str::str_from_cstr(name_buf) };\n+        let name = unsafe { str::from_cstr(name_buf) };\n         if str::eq(name, sess.get_targ_cfg().target_strs.meta_sect_name) {\n             let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n             let csz = llvm::LLVMGetSectionSize(si.llsi);"}, {"sha": "3da705f41efc60c221a0360241c014e486665160", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -72,6 +72,7 @@ fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n         let nm = decoder::lookup_item_name(cdata, did.node);\n         if alt name { some(n) { n == nm } none. { true } } {\n             result += [@{did: did,\n+                         iface_did: none::<ast::def_id>, // FIXME[impl]\n                          ident: nm,\n                          methods: decoder::lookup_impl_methods(\n                              cdata, did.node, did.crate)}];"}, {"sha": "49536b6e1c9eff3b1f358680f71830a326321bf0", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -117,23 +117,20 @@ fn item_type(item: ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n \n fn item_ty_param_bounds(item: ebml::doc, this_cnum: ast::crate_num,\n                         tcx: ty::ctxt, extres: external_resolver)\n-    -> [@[ty::param_bound]] {\n+    -> @[ty::param_bounds] {\n     let bounds = [];\n     let def_parser = bind parse_external_def_id(this_cnum, extres, _);\n     ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) {|p|\n         bounds += [tydecode::parse_bounds_data(@ebml::doc_data(p), this_cnum,\n                                                def_parser, tcx)];\n     }\n-    bounds\n+    @bounds\n }\n \n fn item_ty_param_count(item: ebml::doc) -> uint {\n     let n = 0u;\n-    ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) {|p|\n-        for byte in ebml::doc_data(p) {\n-            if byte as char == '.' { n += 1u; }\n-        }\n-    }\n+    ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds,\n+                      {|_p| n += 1u; });\n     n\n }\n \n@@ -212,8 +209,8 @@ fn get_type(data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n     let t = item_type(item, this_cnum, tcx, extres);\n     let tp_bounds = if family_has_type_params(item_family(item)) {\n         item_ty_param_bounds(item, this_cnum, tcx, extres)\n-    } else { [] };\n-    ret @{bounds: tp_bounds, ty: t};\n+    } else { @[] };\n+    ret {bounds: tp_bounds, ty: t};\n }\n \n fn get_type_param_count(data: @[u8], id: ast::node_id) -> uint {"}, {"sha": "4776b8af34d37558d9b4e57d9b9740cef129d03f", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -190,7 +190,7 @@ fn encode_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     for param in params {\n         ebml::start_tag(ebml_w, tag_items_data_item_ty_param_bounds);\n-        let bs = ecx.ccx.tcx.ty_param_bounds.get(local_def(param.id));\n+        let bs = ecx.ccx.tcx.ty_param_bounds.get(param.id);\n         tyencode::enc_bounds(io::new_writer(ebml_w.writer), ty_str_ctxt, bs);\n         ebml::end_tag(ebml_w);\n     }"}, {"sha": "1a083bf8fb63b45e6109b36145a69dd48b77dd39", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -202,9 +202,17 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n         st.pos = st.pos + 1u;\n         ret ty::mk_tag(st.tcx, def, params);\n       }\n+      'x' {\n+        assert (next(st) as char == '[');\n+        let def = parse_def(st, sd);\n+        let params: [ty::t] = [];\n+        while peek(st) as char != ']' { params += [parse_ty(st, sd)]; }\n+        st.pos = st.pos + 1u;\n+        ret ty::mk_iface(st.tcx, def, params);\n+      }\n       'p' {\n-        let bounds = parse_bounds(st, sd);\n-        ret ty::mk_param(st.tcx, parse_int(st) as uint, bounds);\n+        let did = parse_def(st, sd);\n+        ret ty::mk_param(st.tcx, parse_int(st) as uint, did);\n       }\n       '@' { ret ty::mk_box(st.tcx, parse_mt(st, sd)); }\n       '~' { ret ty::mk_uniq(st.tcx, parse_mt(st, sd)); }\n@@ -259,7 +267,7 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n             while peek(st) as char != '[' {\n                 name += str::unsafe_from_byte(next(st));\n             }\n-            methods += [{ident: name, tps: [],\n+            methods += [{ident: name, tps: @[],\n                          fty: {proto: proto with parse_ty_fn(st, sd)}}];\n         }\n         st.pos += 1u;\n@@ -401,8 +409,7 @@ fn parse_bounds_data(data: @[u8], crate_num: int, sd: str_def, tcx: ty::ctxt)\n \n fn parse_bounds(st: @pstate, sd: str_def) -> @[ty::param_bound] {\n     let bounds = [];\n-    while peek(st) as char == '.' {\n-        next(st);\n+    while peek(st) != 0u8 {\n         bounds += [alt next(st) as char {\n           'S' { ty::bound_send }\n           'C' { ty::bound_copy }"}, {"sha": "73d444727234951998f8e698ee71f6fda31ba843", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -126,6 +126,13 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         for t: ty::t in tys { enc_ty(w, cx, t); }\n         w.write_char(']');\n       }\n+      ty::ty_iface(def, tys) {\n+        w.write_str(\"x[\");\n+        w.write_str(cx.ds(def));\n+        w.write_char('|');\n+        for t: ty::t in tys { enc_ty(w, cx, t); }\n+        w.write_char(']');\n+      }\n       ty::ty_tup(ts) {\n         w.write_str(\"T[\");\n         for t in ts { enc_ty(w, cx, t); }\n@@ -176,9 +183,10 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         w.write_str(cx.ds(def));\n         w.write_char('|');\n       }\n-      ty::ty_param(id, bounds) {\n+      ty::ty_param(id, did) {\n         w.write_char('p');\n-        enc_bounds(w, cx, bounds);\n+        w.write_str(cx.ds(did));\n+        w.write_char('|');\n         w.write_str(uint::str(id));\n       }\n       ty::ty_type. { w.write_char('Y'); }\n@@ -265,7 +273,6 @@ fn enc_ty_constr(w: io::writer, cx: @ctxt, c: @ty::type_constr) {\n \n fn enc_bounds(w: io::writer, cx: @ctxt, bs: @[ty::param_bound]) {\n     for bound in *bs {\n-        w.write_char('.');\n         alt bound {\n           ty::bound_send. { w.write_char('S'); }\n           ty::bound_copy. { w.write_char('C'); }"}, {"sha": "00d5534bfecb7a5eaa4f81cde9780159cccdb7d4", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -44,6 +44,7 @@ fn check_crate(tcx: ty::ctxt, method_map: typeck::method_map,\n     let visit = visit::mk_vt(@{\n         visit_expr: check_expr,\n         visit_stmt: check_stmt,\n+        visit_block: check_block,\n         visit_fn: check_fn\n         with *visit::default_visitor()\n     });\n@@ -117,12 +118,18 @@ fn check_fn_cap_clause(cx: ctx,\n     }\n }\n \n-fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n+fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n+    alt b.node.expr {\n+      some(ex) { maybe_copy(cx, ex); }\n+      _ {}\n+    }\n+    visit::visit_block(b, cx, v);\n+}\n \n+fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n     alt e.node {\n       expr_assign(_, ex) | expr_assign_op(_, _, ex) |\n-      expr_block({node: {expr: some(ex), _}, _}) |\n-      expr_unary(box(_), ex) | expr_unary(uniq(_), ex) { maybe_copy(cx, ex); }\n+      expr_unary(box(_), ex) | expr_unary(uniq(_), ex) |\n       expr_ret(some(ex)) { maybe_copy(cx, ex); }\n       expr_copy(expr) { check_copy_ex(cx, expr, false); }\n       // Vector add copies.\n@@ -163,14 +170,14 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         alt substs.substs {\n           some(ts) {\n             let did = ast_util::def_id_of_def(cx.tcx.def_map.get(e.id));\n-            let kinds = vec::map(ty::lookup_item_type(cx.tcx, did).bounds,\n-                                 {|bs| ty::param_bounds_to_kind(bs)});\n+            let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n             let i = 0u;\n             for ty in ts {\n                 let kind = ty::type_kind(cx.tcx, ty);\n-                if !ty::kind_lteq(kinds[i], kind) {\n+                let p_kind = ty::param_bounds_to_kind(bounds[i]);\n+                if !ty::kind_lteq(p_kind, kind) {\n                     cx.tcx.sess.span_err(e.span, \"instantiating a \" +\n-                                         kind_to_str(kinds[i]) +\n+                                         kind_to_str(p_kind) +\n                                          \" type parameter with a \"\n                                          + kind_to_str(kind) + \" type\");\n                 }"}, {"sha": "78301c812023283ff9e209e82b31b75320c351c9", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -1,7 +1,7 @@\n import syntax::{visit, ast_util};\n import syntax::ast::*;\n import syntax::codemap::span;\n-import std::list::{list, nil, cons, tail};\n+import std::list::{is_not_empty, list, nil, cons, tail};\n import core::{vec, option};\n import std::list;\n \n@@ -63,6 +63,13 @@ fn find_last_uses(c: @crate, def_map: resolve::def_map,\n     ret mini_table;\n }\n \n+fn is_block(cx: ctx, id: node_id) -> bool {\n+    alt ty::struct(cx.tcx, ty::node_id_to_monotype(cx.tcx, id)) {\n+      ty::ty_fn({proto: proto_block., _}) { true }\n+      _ { false }\n+    }\n+}\n+\n fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n     alt ex.node {\n       expr_ret(oexpr) {\n@@ -135,9 +142,8 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n         let arg_ts = ty::ty_fn_args(cx.tcx, ty::expr_ty(cx.tcx, f));\n         for arg in args {\n             alt arg.node {\n-              //NDM--register captured as uses\n-              expr_fn(_, _, _, captured) { fns += [arg]; }\n-              expr_fn_block(_, _) { fns += [arg]; }\n+              expr_fn(proto_block., _, _, _) { fns += [arg]; }\n+              expr_fn_block(_, _) when is_block(cx, arg.id) { fns += [arg]; }\n               _ {\n                 alt arg_ts[i].mode {\n                   by_mut_ref. { clear_if_path(cx, arg, v, false); }\n@@ -163,6 +169,15 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n             visit::visit_fn(fk, decl, body, sp, id, cx, v);\n         });\n     } else {\n+        alt cx.tcx.freevars.find(id) {\n+          some(vars) {\n+            for v in *vars {\n+                clear_in_current(cx, ast_util::def_id_of_def(v.def).node,\n+                                 false);\n+            }\n+          }\n+          _ {}\n+        }\n         let old = nil;\n         cx.blocks <-> old;\n         visit::visit_fn(fk, decl, body, sp, id, cx, v);\n@@ -177,7 +192,9 @@ fn visit_block(tp: block_type, cx: ctx, visit: block()) {\n     visit();\n     local.second = true;\n     visit();\n-    cx.blocks = tail(cx.blocks);\n+    let cx_blocks = cx.blocks;\n+    check is_not_empty(cx_blocks);\n+    cx.blocks = tail(cx_blocks);\n     cx.current = join_branches(local.exits);\n }\n "}, {"sha": "29d29a32fba3472984510e73b100e9197f656ca9", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 70, "deletions": 33, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -37,7 +37,7 @@ tag scope {\n     scope_loop(@ast::local); // there's only 1 decl per loop.\n     scope_block(ast::blk, @mutable uint, @mutable uint);\n     scope_arm(ast::arm);\n-    scope_self(ast::node_id);\n+    scope_method(ast::node_id, [ast::ty_param]);\n }\n \n type scopes = list<scope>;\n@@ -142,6 +142,7 @@ type env =\n                     mutable data: [ast::node_id]},\n      mutable reported: [{ident: str, sc: scope}],\n      mutable ignored_imports: [node_id],\n+     mutable current_tp: option::t<uint>,\n      sess: session};\n \n \n@@ -168,6 +169,7 @@ fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n           used_imports: {mutable track: false, mutable data:  []},\n           mutable reported: [],\n           mutable ignored_imports: [],\n+          mutable current_tp: none,\n           sess: sess};\n     map_crate(e, crate);\n     resolve_imports(*e);\n@@ -266,6 +268,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n             let imp = follow_import(*e, sc, *path, vi.span);\n             if option::is_some(imp) {\n                 let glob = {def: option::get(imp), item: vi};\n+                check list::is_not_empty(sc);\n                 alt list::head(sc) {\n                   scope_item(i) {\n                     e.mod_map.get(i.id).glob_imports += [glob];\n@@ -335,6 +338,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           visit_pat: bind walk_pat(e, _, _, _),\n           visit_expr: bind walk_expr(e, _, _, _),\n           visit_ty: bind walk_ty(e, _, _, _),\n+          visit_ty_params: bind walk_tps(e, _, _, _),\n           visit_constr: bind walk_constr(e, _, _, _, _, _),\n           visit_fn: bind visit_fn_with_scope(e, _, _, _, _, _, _, _)\n           with *visit::default_visitor()};\n@@ -368,6 +372,20 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           _ { }\n         }\n     }\n+    fn walk_tps(e: @env, tps: [ast::ty_param], sc: scopes, v: vt<scopes>) {\n+        let outer_current_tp = e.current_tp, current = 0u;\n+        for tp in tps {\n+            e.current_tp = some(current);\n+            for bound in *tp.bounds {\n+                alt bound {\n+                  bound_iface(t) { v.visit_ty(t, sc, v); }\n+                  _ {}\n+                }\n+            }\n+            current += 1u;\n+        }\n+        e.current_tp = outer_current_tp;\n+    }\n     fn walk_constr(e: @env, p: @ast::path, sp: span, id: node_id, sc: scopes,\n                    _v: vt<scopes>) {\n         maybe_insert(e, id, lookup_path_strict(*e, sc, sp, p.node, ns_value));\n@@ -403,9 +421,17 @@ fn visit_item_with_scope(i: @ast::item, sc: scopes, v: vt<scopes>) {\n         alt ifce { some(ty) { v.visit_ty(ty, sc, v); } _ {} }\n         v.visit_ty(sty, sc, v);\n         for m in methods {\n-            v.visit_fn(visit::fk_method(m.ident, tps + m.tps),\n-                       m.decl, m.body, m.span,\n-                       m.id, sc, v);\n+            let msc = cons(scope_method(i.id, tps + m.tps), @sc);\n+            v.visit_fn(visit::fk_method(m.ident, []),\n+                       m.decl, m.body, m.span, m.id, msc, v);\n+        }\n+      }\n+      ast::item_iface(tps, methods) {\n+        visit::visit_ty_params(tps, sc, v);\n+        for m in methods {\n+            let msc = cons(scope_method(i.id, tps + m.tps), @sc);\n+            for a in m.decl.inputs { v.visit_ty(a.ty, msc, v); }\n+            v.visit_ty(m.decl.output, msc, v);\n         }\n       }\n       _ { visit::visit_item(i, sc, v); }\n@@ -436,8 +462,8 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n     // for f's constrs in the table.\n     for c: @ast::constr in decl.constraints { resolve_constr(e, c, sc, v); }\n     let scope = alt fk {\n-      visit::fk_item_fn(_, tps) | visit::fk_method(_, tps) |\n-      visit::fk_res(_, tps) {\n+      visit::fk_item_fn(_, tps) | visit::fk_res(_, tps) |\n+      visit::fk_method(_, tps) {\n         scope_bare_fn(decl, id, tps)\n       }\n       visit::fk_anon(_) | visit::fk_fn_block. {\n@@ -461,6 +487,7 @@ fn visit_block_with_scope(b: ast::blk, sc: scopes, v: vt<scopes>) {\n }\n \n fn visit_decl_with_scope(d: @decl, sc: scopes, v: vt<scopes>) {\n+    check list::is_not_empty(sc);\n     let loc_pos = alt list::head(sc) {\n       scope_block(_, _, pos) { pos }\n       _ { @mutable 0u }\n@@ -489,7 +516,7 @@ fn visit_expr_with_scope(x: @ast::expr, sc: scopes, v: vt<scopes>) {\n         v.visit_block(blk, new_sc, v);\n       }\n       ast::expr_anon_obj(_) {\n-        visit::visit_expr(x, cons(scope_self(x.id), @sc), v);\n+        visit::visit_expr(x, cons(scope_method(x.id, []), @sc), v);\n       }\n       _ { visit::visit_expr(x, sc, v); }\n     }\n@@ -796,17 +823,14 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n           scope_item(it) {\n             alt it.node {\n               ast::item_obj(ob, ty_params, _) {\n-                ret lookup_in_obj(name, ob, ty_params, ns, it.id);\n+                ret lookup_in_obj(e, name, ob, ty_params, ns, it.id);\n               }\n-              ast::item_impl(ty_params, _, _, _) {\n-                if (name == \"self\" && ns == ns_value) {\n-                    ret some(ast::def_self(local_def(it.id)));\n-                }\n-                if ns == ns_type { ret lookup_in_ty_params(name, ty_params); }\n+              ast::item_impl(tps, _, _, _) {\n+                if ns == ns_type { ret lookup_in_ty_params(e, name, tps); }\n               }\n               ast::item_iface(tps, _) | ast::item_tag(_, tps) |\n               ast::item_ty(_, tps) {\n-                if ns == ns_type { ret lookup_in_ty_params(name, tps); }\n+                if ns == ns_type { ret lookup_in_ty_params(e, name, tps); }\n               }\n               ast::item_mod(_) {\n                 ret lookup_in_local_mod(e, it.id, sp, name, ns, inside);\n@@ -817,21 +841,23 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n               _ { }\n             }\n           }\n-          scope_self(id) {\n+          scope_method(id, tps) {\n             if (name == \"self\" && ns == ns_value) {\n                 ret some(ast::def_self(local_def(id)));\n+            } else if ns == ns_type {\n+                ret lookup_in_ty_params(e, name, tps);\n             }\n           }\n           scope_native_item(it) {\n             alt it.node {\n               ast::native_item_fn(decl, ty_params) {\n-                ret lookup_in_fn(name, decl, ty_params, ns);\n+                ret lookup_in_fn(e, name, decl, ty_params, ns);\n               }\n             }\n           }\n           scope_bare_fn(decl, _, ty_params) |\n           scope_fn_expr(decl, _, ty_params) {\n-            ret lookup_in_fn(name, decl, ty_params, ns);\n+            ret lookup_in_fn(e, name, decl, ty_params, ns);\n           }\n           scope_loop(local) {\n             if ns == ns_value {\n@@ -906,13 +932,13 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n     e.sess.bug(\"reached unreachable code in lookup_in_scope\"); // sigh\n }\n \n-fn lookup_in_ty_params(name: ident, ty_params: [ast::ty_param]) ->\n-   option::t<def> {\n+fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param])\n+    -> option::t<def> {\n     let n = 0u;\n     for tp: ast::ty_param in ty_params {\n-        if str::eq(tp.ident, name) {\n-            ret some(ast::def_ty_param(local_def(tp.id), n));\n-        }\n+        if str::eq(tp.ident, name) && alt e.current_tp {\n+            some(cur) { n < cur } none. { true }\n+        } { ret some(ast::def_ty_param(local_def(tp.id), n)); }\n         n += 1u;\n     }\n     ret none::<def>;\n@@ -927,7 +953,8 @@ fn lookup_in_pat(name: ident, pat: @ast::pat) -> option::t<def_id> {\n     ret found;\n }\n \n-fn lookup_in_fn(name: ident, decl: ast::fn_decl, ty_params: [ast::ty_param],\n+fn lookup_in_fn(e: env, name: ident, decl: ast::fn_decl,\n+                ty_params: [ast::ty_param],\n                 ns: namespace) -> option::t<def> {\n     alt ns {\n       ns_value. {\n@@ -938,12 +965,13 @@ fn lookup_in_fn(name: ident, decl: ast::fn_decl, ty_params: [ast::ty_param],\n         }\n         ret none::<def>;\n       }\n-      ns_type. { ret lookup_in_ty_params(name, ty_params); }\n+      ns_type. { ret lookup_in_ty_params(e, name, ty_params); }\n       _ { ret none::<def>; }\n     }\n }\n \n-fn lookup_in_obj(name: ident, ob: ast::_obj, ty_params: [ast::ty_param],\n+fn lookup_in_obj(e: env, name: ident, ob: ast::_obj,\n+                 ty_params: [ast::ty_param],\n                  ns: namespace, id: node_id) -> option::t<def> {\n     alt ns {\n       ns_value. {\n@@ -955,7 +983,7 @@ fn lookup_in_obj(name: ident, ob: ast::_obj, ty_params: [ast::ty_param],\n         }\n         ret none::<def>;\n       }\n-      ns_type. { ret lookup_in_ty_params(name, ty_params); }\n+      ns_type. { ret lookup_in_ty_params(e, name, ty_params); }\n       _ { ret none::<def>; }\n     }\n }\n@@ -1701,7 +1729,8 @@ fn check_exports(e: @env) {\n // Impl resolution\n \n type method_info = {did: def_id, n_tps: uint, ident: ast::ident};\n-type _impl = {did: def_id, ident: ast::ident, methods: [@method_info]};\n+type _impl = {did: def_id, iface_did: option::t<def_id>,\n+              ident: ast::ident, methods: [@method_info]};\n type iscopes = list<@[@_impl]>;\n \n fn resolve_impls(e: @env, c: @ast::crate) {\n@@ -1757,14 +1786,20 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n     }\n }\n \n-fn find_impls_in_item(i: @ast::item, &impls: [@_impl],\n+fn find_impls_in_item(e: env, i: @ast::item, &impls: [@_impl],\n                       name: option::t<ident>,\n                       ck_exports: option::t<ast::_mod>) {\n     alt i.node {\n-      ast::item_impl(_, _, _, mthds) {\n+      ast::item_impl(_, ifce, _, mthds) {\n         if alt name { some(n) { n == i.ident } _ { true } } &&\n            alt ck_exports { some(m) { is_exported(i.ident, m) } _ { true } } {\n             impls += [@{did: local_def(i.id),\n+                        iface_did: alt ifce {\n+                            some(@{node: ast::ty_path(_, id), _}) {\n+                                some(def_id_of_def(e.def_map.get(id)))\n+                            }\n+                            _ { none }\n+                        },\n                         ident: i.ident,\n                         methods: vec::map(mthds, {|m|\n                             @{did: local_def(m.id),\n@@ -1788,7 +1823,7 @@ fn find_impls_in_mod(e: env, m: def, &impls: [@_impl],\n             cached = if defid.crate == ast::local_crate {\n                 let tmp = [];\n                 for i in option::get(e.mod_map.get(defid.node).m).items {\n-                    find_impls_in_item(i, tmp, name, none);\n+                    find_impls_in_item(e, i, tmp, name, none);\n                 }\n                 @tmp\n             } else {\n@@ -1816,7 +1851,7 @@ fn visit_block_with_impl_scope(e: @env, b: ast::blk, sc: iscopes,\n     for st in b.node.stmts {\n         alt st.node {\n           ast::stmt_decl(@{node: ast::decl_item(i), _}, _) {\n-            find_impls_in_item(i, impls, none, none);\n+            find_impls_in_item(*e, i, impls, none, none);\n           }\n           _ {}\n         }\n@@ -1829,13 +1864,15 @@ fn visit_mod_with_impl_scope(e: @env, m: ast::_mod, s: span, sc: iscopes,\n                              v: vt<iscopes>) {\n     let impls = [];\n     for vi in m.view_items { find_impls_in_view_item(*e, vi, impls, sc); }\n-    for i in m.items { find_impls_in_item(i, impls, none, none); }\n+    for i in m.items { find_impls_in_item(*e, i, impls, none, none); }\n     visit::visit_mod(m, s, vec::len(impls) > 0u ? cons(@impls, @sc) : sc, v);\n }\n \n fn resolve_impl_in_expr(e: @env, x: @ast::expr, sc: iscopes, v: vt<iscopes>) {\n     alt x.node {\n-      ast::expr_field(_, _, _) { e.impl_map.insert(x.id, sc); }\n+      ast::expr_field(_, _, _) | ast::expr_path(_) {\n+        e.impl_map.insert(x.id, sc);\n+      }\n       _ {}\n     }\n     visit::visit_expr(x, sc, v);"}, {"sha": "f78e0ffef85b62625129245792b90bd28ddc3141", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -450,7 +450,7 @@ fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n         let did = ccx.shape_cx.tag_order[i];\n         let variants = ty::tag_variants(ccx.tcx, did);\n         let item_tyt = ty::lookup_item_type(ccx.tcx, did);\n-        let ty_param_count = vec::len(item_tyt.bounds);\n+        let ty_param_count = vec::len(*item_tyt.bounds);\n \n         for v: ty::variant_info in *variants {\n             offsets += [vec::len(data) as u16];"}, {"sha": "c279c0a9b49d60c252cb8c48fa6cdfac5ba917e5", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 196, "deletions": 184, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -13,7 +13,6 @@\n //     but many TypeRefs correspond to one ty::t; for instance, tup(int, int,\n //     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n \n-import core::{either, str, int, uint, option, vec};\n import std::{map, time};\n import std::map::hashmap;\n import std::map::{new_int_hash, new_str_hash};\n@@ -81,13 +80,12 @@ fn type_of_explicit_args(cx: @crate_ctxt, sp: span, inputs: [ty::arg]) ->\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn type_of_fn(cx: @crate_ctxt, sp: span,\n-              is_method: bool, inputs: [ty::arg],\n-              output: ty::t, ty_param_count: uint)\n-   : non_ty_var(cx, output) -> TypeRef {\n+fn type_of_fn(cx: @crate_ctxt, sp: span, is_method: bool, inputs: [ty::arg],\n+              output: ty::t, params: [ty::param_bounds]) -> TypeRef {\n     let atys: [TypeRef] = [];\n \n     // Arg 0: Output pointer.\n+    check non_ty_var(cx, output);\n     let out_ty = T_ptr(type_of_inner(cx, sp, output));\n     atys += [out_ty];\n \n@@ -100,8 +98,15 @@ fn type_of_fn(cx: @crate_ctxt, sp: span,\n \n     // Args >2: ty params, if not acquired via capture...\n     if !is_method {\n-        let i = 0u;\n-        while i < ty_param_count { atys += [T_ptr(cx.tydesc_type)]; i += 1u; }\n+        for bounds in params {\n+            atys += [T_ptr(cx.tydesc_type)];\n+            for bound in *bounds {\n+                alt bound {\n+                  ty::bound_iface(_) { atys += [T_ptr(T_dict())]; }\n+                  _ {}\n+                }\n+            }\n+        }\n     }\n     // ... then explicit args.\n     atys += type_of_explicit_args(cx, sp, inputs);\n@@ -110,15 +115,13 @@ fn type_of_fn(cx: @crate_ctxt, sp: span,\n \n // Given a function type and a count of ty params, construct an llvm type\n fn type_of_fn_from_ty(cx: @crate_ctxt, sp: span, fty: ty::t,\n-                      ty_param_count: uint)\n-    : returns_non_ty_var(cx, fty) -> TypeRef {\n+                      param_bounds: [ty::param_bounds]) -> TypeRef {\n     // FIXME: Check should be unnecessary, b/c it's implied\n     // by returns_non_ty_var(t). Make that a postcondition\n     // (see Issue #586)\n     let ret_ty = ty::ty_fn_ret(cx.tcx, fty);\n-    check non_ty_var(cx, ret_ty);\n     ret type_of_fn(cx, sp, false, ty::ty_fn_args(cx.tcx, fty),\n-                   ret_ty, ty_param_count);\n+                   ret_ty, param_bounds);\n }\n \n fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n@@ -169,12 +172,10 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n         T_struct(tys)\n       }\n       ty::ty_fn(_) {\n-        // FIXME: could be a constraint on ty_fn\n-        check returns_non_ty_var(cx, t);\n-        T_fn_pair(cx, type_of_fn_from_ty(cx, sp, t, 0u))\n+        T_fn_pair(cx, type_of_fn_from_ty(cx, sp, t, []))\n       }\n       ty::ty_native_fn(args, out) {\n-        let nft = native_fn_wrapper_type(cx, sp, 0u, t);\n+        let nft = native_fn_wrapper_type(cx, sp, [], t);\n         T_fn_pair(cx, nft)\n       }\n       ty::ty_obj(meths) { cx.rust_object_type }\n@@ -204,6 +205,11 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n       ty::ty_opaque_closure. {\n         T_opaque_closure(cx)\n       }\n+      ty::ty_constr(subt,_) {\n+        // FIXME: could be a constraint on ty_fn\n+          check non_ty_var(cx, subt);\n+          type_of_inner(cx, sp, subt)\n+      }\n       _ {\n         fail \"type_of_inner not implemented for this kind of type\";\n       }\n@@ -233,8 +239,7 @@ fn type_of_ty_param_bounds_and_ty(lcx: @local_ctxt, sp: span,\n     let t = tpt.ty;\n     alt ty::struct(cx.tcx, t) {\n       ty::ty_fn(_) | ty::ty_native_fn(_, _) {\n-        check returns_non_ty_var(cx, t);\n-        ret type_of_fn_from_ty(cx, sp, t, vec::len(tpt.bounds));\n+        ret type_of_fn_from_ty(cx, sp, t, *tpt.bounds);\n       }\n       _ {\n         // fall through\n@@ -906,7 +911,10 @@ fn linearize_ty_params(cx: @block_ctxt, t: ty::t) ->\n           ty::ty_param(pid, _) {\n             let seen: bool = false;\n             for d: uint in r.defs { if d == pid { seen = true; } }\n-            if !seen { r.vals += [r.cx.fcx.lltydescs[pid]]; r.defs += [pid]; }\n+            if !seen {\n+                r.vals += [r.cx.fcx.lltyparams[pid].desc];\n+                r.defs += [pid];\n+            }\n           }\n           _ { }\n         }\n@@ -1042,8 +1050,9 @@ fn get_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n     alt ty::type_param(bcx_tcx(cx), t) {\n       some(id) {\n-        if id < vec::len(cx.fcx.lltydescs) {\n-            ret {kind: tk_param, result: rslt(cx, cx.fcx.lltydescs[id])};\n+        if id < vec::len(cx.fcx.lltyparams) {\n+            ret {kind: tk_param,\n+                 result: rslt(cx, cx.fcx.lltyparams[id].desc)};\n         } else {\n             bcx_tcx(cx).sess.span_bug(cx.sp,\n                                       \"Unbound typaram in get_tydesc: \" +\n@@ -1206,10 +1215,7 @@ fn make_generic_glue_inner(cx: @local_ctxt, sp: span, t: ty::t,\n         p += 1u;\n     }\n \n-    // FIXME: Implement some kind of freeze operation in the standard library.\n-    let lltydescs_frozen = [];\n-    for lltydesc: ValueRef in lltydescs { lltydescs_frozen += [lltydesc]; }\n-    fcx.lltydescs = lltydescs_frozen;\n+    fcx.lltyparams = vec::map_mut(lltydescs, {|d| {desc: d, dicts: none}});\n \n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n@@ -2559,10 +2565,13 @@ fn trans_do_while(cx: @block_ctxt, body: ast::blk, cond: @ast::expr) ->\n     ret next_cx;\n }\n \n-type generic_info =\n-    {item_type: ty::t,\n-     static_tis: [option::t<@tydesc_info>],\n-     tydescs: [ValueRef]};\n+type generic_info = {\n+    item_type: ty::t,\n+    static_tis: [option::t<@tydesc_info>],\n+    tydescs: [ValueRef],\n+    param_bounds: @[ty::param_bounds],\n+    origins: option::t<typeck::dict_res>\n+};\n \n tag lval_kind {\n     temporary; //< Temporary value passed by value if of immediate type\n@@ -2571,7 +2580,12 @@ tag lval_kind {\n }\n type local_var_result = {val: ValueRef, kind: lval_kind};\n type lval_result = {bcx: @block_ctxt, val: ValueRef, kind: lval_kind};\n-tag callee_env { obj_env(ValueRef); null_env; is_closure; }\n+tag callee_env {\n+    null_env;\n+    is_closure;\n+    obj_env(ValueRef);\n+    dict_env(ValueRef, ValueRef);\n+}\n type lval_maybe_callee = {bcx: @block_ctxt,\n                           val: ValueRef,\n                           kind: lval_kind,\n@@ -2608,18 +2622,19 @@ fn trans_external_path(cx: @block_ctxt, did: ast::def_id,\n \n fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n     -> lval_maybe_callee {\n-    let tpt = ty::lookup_item_type(bcx_tcx(bcx), fn_id);\n+    let ccx = bcx_ccx(bcx);\n+    let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n     let val = if fn_id.crate == ast::local_crate {\n         // Internal reference.\n-        assert (bcx_ccx(bcx).item_ids.contains_key(fn_id.node));\n-        bcx_ccx(bcx).item_ids.get(fn_id.node)\n+        assert (ccx.item_ids.contains_key(fn_id.node));\n+        ccx.item_ids.get(fn_id.node)\n     } else {\n         // External reference.\n         trans_external_path(bcx, fn_id, tpt)\n     };\n-    let tys = ty::node_id_to_type_params(bcx_tcx(bcx), id);\n+    let tys = ty::node_id_to_type_params(ccx.tcx, id);\n     let gen = none, bcx = bcx;\n-    if vec::len::<ty::t>(tys) != 0u {\n+    if vec::len(tys) != 0u {\n         let tydescs = [], tis = [];\n         for t in tys {\n             // TODO: Doesn't always escape.\n@@ -2629,7 +2644,11 @@ fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n             bcx = td.bcx;\n             tydescs += [td.val];\n         }\n-        gen = some({item_type: tpt.ty, static_tis: tis, tydescs: tydescs});\n+        gen = some({item_type: tpt.ty,\n+                    static_tis: tis,\n+                    tydescs: tydescs,\n+                    param_bounds: tpt.bounds,\n+                    origins: ccx.dict_map.find(id)});\n     }\n     ret {bcx: bcx, val: val, kind: owned, env: null_env, generic: gen};\n }\n@@ -2731,7 +2750,7 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n             ret lval_no_env(cx, ccx.consts.get(did.node), owned);\n         } else {\n             let tp = ty::node_id_to_monotype(ccx.tcx, id);\n-            let val = trans_external_path(cx, did, @{bounds: [], ty: tp});\n+            let val = trans_external_path(cx, did, {bounds: @[], ty: tp});\n             ret lval_no_env(cx, load_if_immediate(cx, val, tp), owned_imm);\n         }\n       }\n@@ -2764,10 +2783,8 @@ fn trans_object_field_inner(bcx: @block_ctxt, o: ValueRef,\n     let fn_ty: ty::t = ty::mk_fn(tcx, mths[ix].fty);\n     let ret_ty = ty::ty_fn_ret(tcx, fn_ty);\n     // FIXME: constrain ty_obj?\n-    check non_ty_var(ccx, ret_ty);\n-\n     let ll_fn_ty = type_of_fn(ccx, bcx.sp, true,\n-                              ty::ty_fn_args(tcx, fn_ty), ret_ty, 0u);\n+                              ty::ty_fn_args(tcx, fn_ty), ret_ty, []);\n     v = Load(bcx, PointerCast(bcx, v, T_ptr(T_ptr(ll_fn_ty))));\n     ret {bcx: bcx, mthptr: v, objptr: o};\n }\n@@ -2840,26 +2857,19 @@ fn expr_is_lval(bcx: @block_ctxt, e: @ast::expr) -> bool {\n     ty::expr_is_lval(ccx.method_map, ccx.tcx, e)\n }\n \n-// This is for impl methods, not obj methods.\n-fn trans_method_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,\n-                       did: ast::def_id) -> lval_maybe_callee {\n-    let tz = [], tr = [];\n-    let basety = ty::expr_ty(bcx_tcx(bcx), base);\n-    let {bcx, val} = trans_arg_expr(bcx, {mode: ast::by_ref, ty: basety},\n-                                    type_of_or_i8(bcx, basety), tz, tr, base);\n-    let val = PointerCast(bcx, val, T_opaque_boxed_closure_ptr(bcx_ccx(bcx)));\n-    {env: obj_env(val) with lval_static_fn(bcx, did, e.id)}\n-}\n-\n fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n     alt e.node {\n       ast::expr_path(p) { ret trans_path(bcx, p, e.id); }\n       ast::expr_field(base, ident, _) {\n         // Lval means this is a record field, so not a method\n         if !expr_is_lval(bcx, e) {\n             alt bcx_ccx(bcx).method_map.find(e.id) {\n-              some(did) { // An impl method\n-                ret trans_method_callee(bcx, e, base, did);\n+              some(typeck::method_static(did)) { // An impl method\n+                ret trans_impl::trans_static_callee(bcx, e, base, did);\n+              }\n+              some(typeck::method_param(iid, off, p, b)) {\n+                ret trans_impl::trans_dict_callee(\n+                    bcx, e, base, iid, off, p, b);\n               }\n               none. { // An object method\n                 let of = trans_object_field(bcx, base, ident);\n@@ -2930,7 +2940,7 @@ fn maybe_add_env(bcx: @block_ctxt, c: lval_maybe_callee)\n     -> (lval_kind, ValueRef) {\n     alt c.env {\n       is_closure. { (c.kind, c.val) }\n-      obj_env(_) {\n+      obj_env(_) | dict_env(_, _) {\n         fail \"Taking the value of a method does not work yet (issue #435)\";\n       }\n       null_env. {\n@@ -3143,7 +3153,23 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n     alt gen {\n       some(g) {\n         lazily_emit_all_generic_info_tydesc_glues(cx, g);\n-        lltydescs = g.tydescs;\n+        let i = 0u, n_orig = 0u;\n+        for param in *g.param_bounds {\n+            lltydescs += [g.tydescs[i]];\n+            for bound in *param {\n+                alt bound {\n+                  ty::bound_iface(_) {\n+                    let res = trans_impl::get_dict(\n+                        bcx, option::get(g.origins)[n_orig]);\n+                    lltydescs += [res.val];\n+                    bcx = res.bcx;\n+                    n_orig += 1u;\n+                  }\n+                  _ {}\n+                }\n+            }\n+            i += 1u;\n+        }\n         args = ty::ty_fn_args(tcx, g.item_type);\n         retty = ty::ty_fn_ret(tcx, g.item_type);\n       }\n@@ -3214,12 +3240,13 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     let bcx = f_res.bcx;\n \n     let faddr = f_res.val;\n-    let llenv;\n+    let llenv, dict_param = none;\n     alt f_res.env {\n       null_env. {\n         llenv = llvm::LLVMGetUndef(T_opaque_boxed_closure_ptr(bcx_ccx(cx)));\n       }\n       obj_env(e) { llenv = e; }\n+      dict_env(dict, e) { llenv = e; dict_param = some(dict); }\n       is_closure. {\n         // It's a closure. Have to fetch the elements\n         if f_res.kind == owned {\n@@ -3238,6 +3265,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n         trans_args(bcx, llenv, f_res.generic, args, fn_expr_ty, dest);\n     bcx = args_res.bcx;\n     let llargs = args_res.args;\n+    option::may(dict_param) {|dict| llargs = [dict] + llargs}\n     let llretslot = args_res.retslot;\n \n     /* If the block is terminated,\n@@ -3300,8 +3328,7 @@ fn invoke_(bcx: @block_ctxt, llfn: ValueRef, llargs: [ValueRef],\n     // cleanups to run\n     if bcx.unreachable { ret bcx; }\n     let normal_bcx = new_sub_block_ctxt(bcx, \"normal return\");\n-    invoker(bcx, llfn, llargs,\n-            normal_bcx.llbb,\n+    invoker(bcx, llfn, llargs, normal_bcx.llbb,\n             get_landing_pad(bcx, to_zero, to_revoke));\n     ret normal_bcx;\n }\n@@ -4345,7 +4372,7 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: span, llfndecl: ValueRef,\n           llobjfields: new_int_hash::<ValueRef>(),\n           lllocals: new_int_hash::<local_val>(),\n           llupvars: new_int_hash::<ValueRef>(),\n-          mutable lltydescs: [],\n+          mutable lltyparams: [],\n           derived_tydescs: ty::new_ty_hash(),\n           id: id,\n           ret_style: rstyle,\n@@ -4387,10 +4414,22 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n       obj_self(_) {}\n       _ {\n         for tp in ty_params {\n-            let llarg = llvm::LLVMGetParam(cx.llfn, arg_n);\n-            assert (llarg as int != 0);\n-            cx.lltydescs += [llarg];\n+            let lltydesc = llvm::LLVMGetParam(cx.llfn, arg_n), dicts = none;\n             arg_n += 1u;\n+            for bound in *fcx_tcx(cx).ty_param_bounds.get(tp.id) {\n+                alt bound {\n+                  ty::bound_iface(_) {\n+                    let dict = llvm::LLVMGetParam(cx.llfn, arg_n);\n+                    arg_n += 1u;\n+                    dicts = some(alt dicts {\n+                      none. { [dict] }\n+                      some(ds) { ds + [dict] }\n+                    });\n+                  }\n+                  _ {}\n+                }\n+            }\n+            cx.lltyparams += [{desc: lltydesc, dicts: dicts}];\n         }\n       }\n     }\n@@ -4479,7 +4518,7 @@ fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n         let lltyparam: ValueRef =\n             GEPi(bcx, obj_typarams, [0, i]);\n         lltyparam = Load(bcx, lltyparam);\n-        fcx.lltydescs += [lltyparam];\n+        fcx.lltyparams += [{desc: lltyparam, dicts: none}];\n         i += 1;\n     }\n     i = 0;\n@@ -4658,7 +4697,8 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n     let ty_param_substs: [ty::t] = [];\n     i = 0u;\n     for tp: ast::ty_param in ty_params {\n-        ty_param_substs += [ty::mk_param(ccx.tcx, i, @[])];\n+        ty_param_substs += [ty::mk_param(ccx.tcx, i,\n+                                         ast_util::local_def(tp.id))];\n         i += 1u;\n     }\n     let arg_tys = arg_tys_of_fn(ccx, variant.node.id);\n@@ -4700,20 +4740,6 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n     finish_fn(fcx, lltop);\n }\n \n-fn trans_impl(cx: @local_ctxt, name: ast::ident, methods: [@ast::method],\n-              id: ast::node_id, tps: [ast::ty_param]) {\n-    let sub_cx = extend_path(cx, name);\n-    for m in methods {\n-        alt cx.ccx.item_ids.find(m.id) {\n-          some(llfn) {\n-            trans_fn(extend_path(sub_cx, m.ident), m.span, m.decl, m.body,\n-                     llfn, impl_self(ty::node_id_to_monotype(cx.ccx.tcx, id)),\n-                     tps + m.tps, m.id);\n-          }\n-        }\n-    }\n-}\n-\n \n // FIXME: this should do some structural hash-consing to avoid\n // duplicate constants. I think. Maybe LLVM has a magical mode\n@@ -5013,8 +5039,8 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n                  with *extend_path(cx, item.ident)};\n         trans_obj(sub_cx, item.span, ob, ctor_id, tps);\n       }\n-      ast::item_impl(tps, _, _, ms) {\n-        trans_impl(cx, item.ident, ms, item.id, tps);\n+      ast::item_impl(tps, ifce, _, ms) {\n+        trans_impl::trans_impl(cx, item.ident, ms, item.id, tps, ifce);\n       }\n       ast::item_res(decl, tps, body, dtor_id, ctor_id) {\n         trans_res_ctor(cx, item.span, decl, ctor_id, tps);\n@@ -5080,13 +5106,17 @@ fn register_fn(ccx: @crate_ctxt, sp: span, path: [str], flav: str,\n     register_fn_full(ccx, sp, path, flav, ty_params, node_id, t);\n }\n \n+fn param_bounds(ccx: @crate_ctxt, tp: ast::ty_param) -> ty::param_bounds {\n+    ccx.tcx.ty_param_bounds.get(tp.id)\n+}\n+\n fn register_fn_full(ccx: @crate_ctxt, sp: span, path: [str], _flav: str,\n-                    ty_params: [ast::ty_param], node_id: ast::node_id,\n+                    tps: [ast::ty_param], node_id: ast::node_id,\n                     node_type: ty::t)\n     : returns_non_ty_var(ccx, node_type) {\n     let path = path;\n-    let llfty =\n-        type_of_fn_from_ty(ccx, sp, node_type, vec::len(ty_params));\n+    let llfty = type_of_fn_from_ty(ccx, sp, node_type,\n+                                   vec::map(tps, {|p| param_bounds(ccx, p)}));\n     let ps: str = mangle_exported_name(ccx, path, node_type);\n     let llfn: ValueRef = decl_cdecl_fn(ccx.llmod, ps, llfty);\n     ccx.item_ids.insert(node_id, llfn);\n@@ -5122,9 +5152,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n              ty: ty::mk_vec(ccx.tcx, {ty: unit_ty, mut: ast::imm})};\n         // FIXME: mk_nil should have a postcondition\n         let nt = ty::mk_nil(ccx.tcx);\n-        check non_ty_var(ccx, nt);\n-\n-        let llfty = type_of_fn(ccx, sp, false, [vecarg_ty], nt, 0u);\n+        let llfty = type_of_fn(ccx, sp, false, [vecarg_ty], nt, []);\n         let llfdecl = decl_fn(ccx.llmod, \"_rust_main\",\n                               lib::llvm::LLVMCCallConv, llfty);\n \n@@ -5152,6 +5180,8 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         fn main_name() -> str { ret \"main\"; }\n         #[cfg(target_os = \"linux\")]\n         fn main_name() -> str { ret \"main\"; }\n+        #[cfg(target_os = \"freebsd\")]\n+        fn main_name() -> str { ret \"main\"; }\n         let llfty = T_fn([ccx.int_type, ccx.int_type], ccx.int_type);\n         let llfn = decl_cdecl_fn(ccx.llmod, main_name(), llfty);\n         let llbb = str::as_buf(\"top\", {|buf|\n@@ -5215,12 +5245,12 @@ fn native_fn_ty_param_count(cx: @crate_ctxt, id: ast::node_id) -> uint {\n     ret count;\n }\n \n-fn native_fn_wrapper_type(cx: @crate_ctxt, sp: span, ty_param_count: uint,\n+fn native_fn_wrapper_type(cx: @crate_ctxt, sp: span,\n+                          param_bounds: [ty::param_bounds],\n                           x: ty::t) -> TypeRef {\n     alt ty::struct(cx.tcx, x) {\n       ty::ty_native_fn(args, out) {\n-        check non_ty_var(cx, out);\n-        ret type_of_fn(cx, sp, false, args, out, ty_param_count);\n+        ret type_of_fn(cx, sp, false, args, out, param_bounds);\n       }\n     }\n }\n@@ -5245,56 +5275,54 @@ fn collect_native_item(ccx: @crate_ctxt,\n                        _v: vt<[str]>) {\n     alt i.node {\n       ast::native_item_fn(_, tps) {\n-        if !ccx.obj_methods.contains_key(i.id) {\n-            let sp = i.span;\n-            let id = i.id;\n-            let node_type = node_id_type(ccx, id);\n-            let fn_abi =\n-                alt attr::get_meta_item_value_str_by_name(i.attrs, \"abi\") {\n-              option::none. {\n+        let sp = i.span;\n+        let id = i.id;\n+        let node_type = node_id_type(ccx, id);\n+        let fn_abi =\n+            alt attr::get_meta_item_value_str_by_name(i.attrs, \"abi\") {\n+            option::none. {\n                 // if abi isn't specified for this function, inherit from\n-                // its enclosing native module\n-                option::get(*abi)\n+                  // its enclosing native module\n+                  option::get(*abi)\n               }\n-              _ {\n-                alt attr::native_abi(i.attrs) {\n-                  either::right(abi_) { abi_ }\n-                  either::left(msg) { ccx.sess.span_fatal(i.span, msg) }\n+                _ {\n+                    alt attr::native_abi(i.attrs) {\n+                      either::right(abi_) { abi_ }\n+                      either::left(msg) { ccx.sess.span_fatal(i.span, msg) }\n+                    }\n                 }\n-              }\n             };\n-            alt fn_abi {\n-              ast::native_abi_rust_intrinsic. {\n-                // For intrinsics: link the function directly to the intrinsic\n-                // function itself.\n-                let num_ty_param = vec::len(tps);\n-                check returns_non_ty_var(ccx, node_type);\n-                let fn_type = type_of_fn_from_ty(ccx, sp, node_type,\n-                                                 num_ty_param);\n-                let ri_name = \"rust_intrinsic_\" + link_name(i);\n-                let llnativefn = get_extern_fn(\n-                    ccx.externs, ccx.llmod, ri_name,\n-                    lib::llvm::LLVMCCallConv, fn_type);\n-                ccx.item_ids.insert(id, llnativefn);\n-                ccx.item_symbols.insert(id, ri_name);\n-              }\n+        alt fn_abi {\n+          ast::native_abi_rust_intrinsic. {\n+            // For intrinsics: link the function directly to the intrinsic\n+            // function itself.\n+            let fn_type = type_of_fn_from_ty(\n+                ccx, sp, node_type,\n+                vec::map(tps, {|p| param_bounds(ccx, p)}));\n+            let ri_name = \"rust_intrinsic_\" + link_name(i);\n+            let llnativefn = get_extern_fn(\n+                ccx.externs, ccx.llmod, ri_name,\n+                lib::llvm::LLVMCCallConv, fn_type);\n+            ccx.item_ids.insert(id, llnativefn);\n+            ccx.item_symbols.insert(id, ri_name);\n+          }\n \n-              ast::native_abi_cdecl. | ast::native_abi_stdcall. {\n-                // For true external functions: create a rust wrapper\n-                // and link to that.  The rust wrapper will handle\n-                // switching to the C stack.\n-                let new_pt = pt + [i.ident];\n-                register_fn(ccx, i.span, new_pt, \"native fn\", tps, i.id);\n-              }\n-            }\n+          ast::native_abi_cdecl. | ast::native_abi_stdcall. {\n+            // For true external functions: create a rust wrapper\n+            // and link to that.  The rust wrapper will handle\n+            // switching to the C stack.\n+            let new_pt = pt + [i.ident];\n+            register_fn(ccx, i.span, new_pt, \"native fn\", tps, i.id);\n+          }\n         }\n       }\n       _ { }\n     }\n }\n \n-fn collect_item_1(ccx: @crate_ctxt, abi: @mutable option::t<ast::native_abi>,\n-                  i: @ast::item, &&pt: [str], v: vt<[str]>) {\n+fn collect_item(ccx: @crate_ctxt, abi: @mutable option::t<ast::native_abi>,\n+                i: @ast::item, &&pt: [str], v: vt<[str]>) {\n+    let new_pt = pt + [i.ident];\n     alt i.node {\n       ast::item_const(_, _) {\n         let typ = node_id_type(ccx, i.id);\n@@ -5319,26 +5347,11 @@ fn collect_item_1(ccx: @crate_ctxt, abi: @mutable option::t<ast::native_abi>,\n           }\n         }\n       }\n-      _ { }\n-    }\n-    visit::visit_item(i, pt + [i.ident], v);\n-}\n-\n-fn collect_item_2(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n-                  v: vt<[str]>) {\n-    let new_pt = pt + [i.ident];\n-    visit::visit_item(i, new_pt, v);\n-    alt i.node {\n       ast::item_fn(_, tps, _) {\n-        if !ccx.obj_methods.contains_key(i.id) {\n-            register_fn(ccx, i.span, new_pt, \"fn\", tps, i.id);\n-        }\n+        register_fn(ccx, i.span, new_pt, \"fn\", tps, i.id);\n       }\n       ast::item_obj(ob, tps, ctor_id) {\n         register_fn(ccx, i.span, new_pt, \"obj_ctor\", tps, ctor_id);\n-        for m: @ast::method in ob.methods {\n-            ccx.obj_methods.insert(m.id, ());\n-        }\n       }\n       ast::item_impl(tps, _, _, methods) {\n         let name = ccx.names.next(i.ident);\n@@ -5358,47 +5371,28 @@ fn collect_item_2(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n         check returns_non_ty_var(ccx, t);\n         register_fn_full(ccx, i.span, new_pt, \"res_dtor\", tps, i.id, t);\n       }\n-      _ { }\n-    }\n-}\n-\n-fn collect_items(ccx: @crate_ctxt, crate: @ast::crate) {\n-    let abi = @mutable none::<ast::native_abi>;\n-    let visitor0 = visit::default_visitor();\n-    let visitor1 =\n-        @{visit_native_item: bind collect_native_item(ccx, abi, _, _, _),\n-          visit_item: bind collect_item_1(ccx, abi, _, _, _) with *visitor0};\n-    let visitor2 =\n-        @{visit_item: bind collect_item_2(ccx, _, _, _) with *visitor0};\n-    visit::visit_crate(*crate, [], visit::mk_vt(visitor1));\n-    visit::visit_crate(*crate, [], visit::mk_vt(visitor2));\n-}\n-\n-fn collect_tag_ctor(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n-                    v: vt<[str]>) {\n-    let new_pt = pt + [i.ident];\n-    visit::visit_item(i, new_pt, v);\n-    alt i.node {\n       ast::item_tag(variants, tps) {\n-        for variant: ast::variant in variants {\n+        for variant in variants {\n             if vec::len(variant.node.args) != 0u {\n                 register_fn(ccx, i.span, new_pt + [variant.node.name],\n                             \"tag\", tps, variant.node.id);\n             }\n         }\n       }\n-      _ {/* fall through */ }\n+      _ { }\n     }\n+    visit::visit_item(i, new_pt, v);\n }\n \n-fn collect_tag_ctors(ccx: @crate_ctxt, crate: @ast::crate) {\n-    let visitor =\n-        @{visit_item: bind collect_tag_ctor(ccx, _, _, _)\n-             with *visit::default_visitor()};\n-    visit::visit_crate(*crate, [], visit::mk_vt(visitor));\n+fn collect_items(ccx: @crate_ctxt, crate: @ast::crate) {\n+    let abi = @mutable none::<ast::native_abi>;\n+    visit::visit_crate(*crate, [], visit::mk_vt(@{\n+        visit_native_item: bind collect_native_item(ccx, abi, _, _, _),\n+        visit_item: bind collect_item(ccx, abi, _, _, _)\n+        with *visit::default_visitor()\n+    }));\n }\n \n-\n // The constant translation pass.\n fn trans_constant(ccx: @crate_ctxt, it: @ast::item, &&pt: [str],\n                   v: vt<[str]>) {\n@@ -5407,15 +5401,12 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item, &&pt: [str],\n     alt it.node {\n       ast::item_tag(variants, _) {\n         let i = 0u;\n-        let n_variants = vec::len::<ast::variant>(variants);\n-        while i < n_variants {\n-            let variant = variants[i];\n-            let p = new_pt + [it.ident, variant.node.name, \"discrim\"];\n+        for variant in variants {\n+            let p = new_pt + [variant.node.name, \"discrim\"];\n             let s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n-            let discrim_gvar =\n-                str::as_buf(s, {|buf|\n-                    llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n-                });\n+            let discrim_gvar = str::as_buf(s, {|buf|\n+                llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n+            });\n             llvm::LLVMSetInitializer(discrim_gvar, C_int(ccx, i as int));\n             llvm::LLVMSetGlobalConstant(discrim_gvar, True);\n             ccx.discrims.insert(\n@@ -5424,6 +5415,28 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item, &&pt: [str],\n             i += 1u;\n         }\n       }\n+      ast::item_impl(tps, some(@{node: ast::ty_path(_, id), _}), _, ms) {\n+        let i_did = ast_util::def_id_of_def(ccx.tcx.def_map.get(id));\n+        let ty = ty::lookup_item_type(ccx.tcx, i_did).ty;\n+        // FIXME[impl] use the same name as used in collect_items, for\n+        // slightly more consistent symbol names?\n+        let new_pt = pt + [ccx.names.next(it.ident)];\n+        let extra_tps = vec::map(tps, {|p| param_bounds(ccx, p)});\n+        let tbl = C_struct(vec::map(*ty::iface_methods(ccx.tcx, i_did), {|im|\n+            alt vec::find(ms, {|m| m.ident == im.ident}) {\n+              some(m) {\n+                trans_impl::trans_wrapper(ccx, new_pt, extra_tps, m)\n+              }\n+            }\n+        }));\n+        let s = mangle_exported_name(ccx, new_pt + [\"!vtable\"], ty);\n+        let vt_gvar = str::as_buf(s, {|buf|\n+            llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n+        });\n+        llvm::LLVMSetInitializer(vt_gvar, tbl);\n+        llvm::LLVMSetGlobalConstant(vt_gvar, True);\n+        ccx.item_ids.insert(it.id, vt_gvar);\n+      }\n       _ { }\n     }\n }\n@@ -5601,7 +5614,8 @@ fn write_abi_version(ccx: @crate_ctxt) {\n fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n                output: str, emap: resolve::exp_map, amap: ast_map::map,\n                mut_map: mut::mut_map, copy_map: alias::copy_map,\n-               last_uses: last_use::last_uses, method_map: typeck::method_map)\n+               last_uses: last_use::last_uses, method_map: typeck::method_map,\n+               dict_map: typeck::dict_map)\n     -> (ModuleRef, link::link_meta) {\n     let sha = std::sha1::mk_sha1();\n     let link_meta = link::build_link_meta(sess, *crate, output, sha);\n@@ -5666,7 +5680,6 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           discrims: ast_util::new_def_id_hash::<ValueRef>(),\n           discrim_symbols: new_int_hash::<str>(),\n           consts: new_int_hash::<ValueRef>(),\n-          obj_methods: new_int_hash::<()>(),\n           tydescs: ty::new_ty_hash(),\n           module_data: new_str_hash::<ValueRef>(),\n           lltypes: ty::new_ty_hash(),\n@@ -5679,6 +5692,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           copy_map: copy_map,\n           last_uses: last_uses,\n           method_map: method_map,\n+          dict_map: dict_map,\n           stats:\n               {mutable n_static_tydescs: 0u,\n                mutable n_derived_tydescs: 0u,\n@@ -5702,7 +5716,6 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           dbg_cx: dbg_cx};\n     let cx = new_local_ctxt(ccx);\n     collect_items(ccx, crate);\n-    collect_tag_ctors(ccx, crate);\n     trans_constants(ccx, crate);\n     trans_mod(cx, crate.node.module);\n     fill_crate_map(ccx, crate_map);\n@@ -5720,7 +5733,6 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n         #error(\"n_null_glues: %u\", ccx.stats.n_null_glues);\n         #error(\"n_real_glues: %u\", ccx.stats.n_real_glues);\n \n-\n         for timing: {ident: str, time: int} in *ccx.stats.fn_times {\n             #error(\"time: %s took %d ms\", timing.ident, timing.time);\n         }"}, {"sha": "7759072f0288486b15b168cb9057344ac768213b", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 88, "deletions": 49, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -82,17 +82,21 @@ tag environment_value {\n // Given a closure ty, emits a corresponding tuple ty\n fn mk_closure_ty(tcx: ty::ctxt,\n                  ck: ty::closure_kind,\n-                 n_bound_tds: uint,\n+                 ty_params: [fn_ty_param],\n                  bound_data_ty: ty::t)\n     -> ty::t {\n     let tydesc_ty = alt ck {\n       ty::closure_block. | ty::closure_shared. { ty::mk_type(tcx) }\n       ty::closure_send. { ty::mk_send_type(tcx) }\n     };\n-    ret ty::mk_tup(tcx, [\n-        tydesc_ty,\n-        ty::mk_tup(tcx, vec::init_elt(tydesc_ty, n_bound_tds)),\n-        bound_data_ty]);\n+    let param_ptrs = [];\n+    for tp in ty_params {\n+        param_ptrs += [tydesc_ty];\n+        option::may(tp.dicts) {|dicts|\n+            for dict in dicts { param_ptrs += [tydesc_ty]; }\n+        }\n+    }\n+    ty::mk_tup(tcx, [tydesc_ty, ty::mk_tup(tcx, param_ptrs), bound_data_ty])\n }\n \n fn shared_opaque_closure_box_ty(tcx: ty::ctxt) -> ty::t {\n@@ -117,7 +121,7 @@ type closure_result = {\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n fn store_environment(\n-    bcx: @block_ctxt, lltydescs: [ValueRef],\n+    bcx: @block_ctxt, lltyparams: [fn_ty_param],\n     bound_values: [environment_value],\n     ck: ty::closure_kind)\n     -> closure_result {\n@@ -162,7 +166,7 @@ fn store_environment(\n     }\n     let bound_data_ty = ty::mk_tup(tcx, bound_tys);\n     let closure_ty =\n-        mk_closure_ty(tcx, ck, vec::len(lltydescs), bound_data_ty);\n+        mk_closure_ty(tcx, ck, lltyparams, bound_data_ty);\n \n     let temp_cleanups = [];\n \n@@ -210,7 +214,7 @@ fn store_environment(\n         // in the shape code.  Therefore, I am using\n         // tps_normal, which is what we used before.\n         //\n-        // let tps = tps_fn(vec::len(lltydescs));\n+        // let tps = tps_fn(vec::len(lltyparams));\n \n         let tps = tps_normal;\n         let {result:closure_td, _} =\n@@ -232,10 +236,19 @@ fn store_environment(\n     let {bcx:bcx, val:ty_params_slot} =\n         GEP_tup_like_1(bcx, closure_ty, closure,\n                        [0, abi::closure_elt_ty_params]);\n-    vec::iteri(lltydescs) { |i, td|\n-        let ty_param_slot = GEPi(bcx, ty_params_slot, [0, i as int]);\n-        let cloned_td = maybe_clone_tydesc(bcx, ck, td);\n-        Store(bcx, cloned_td, ty_param_slot);\n+    let off = 0;\n+\n+    for tp in lltyparams {\n+        let cloned_td = maybe_clone_tydesc(bcx, ck, tp.desc);\n+        Store(bcx, cloned_td, GEPi(bcx, ty_params_slot, [0, off]));\n+        off += 1;\n+        option::may(tp.dicts, {|dicts|\n+            for dict in dicts {\n+                let cast = PointerCast(bcx, dict, val_ty(cloned_td));\n+                Store(bcx, cast, GEPi(bcx, ty_params_slot, [0, off]));\n+                off += 1;\n+            }\n+        });\n     }\n \n     // Copy expr values into boxed bindings.\n@@ -316,7 +329,7 @@ fn build_closure(bcx0: @block_ctxt,\n           }\n         }\n     }\n-    ret store_environment(bcx, copy bcx.fcx.lltydescs, env_vals, ck);\n+    ret store_environment(bcx, copy bcx.fcx.lltyparams, env_vals, ck);\n }\n \n // Given an enclosing block context, a new function context, a closure type,\n@@ -338,13 +351,23 @@ fn load_environment(enclosing_cx: @block_ctxt,\n     // Populate the type parameters from the environment. We need to\n     // do this first because the tydescs are needed to index into\n     // the bindings if they are dynamically sized.\n-    let tydesc_count = vec::len(enclosing_cx.fcx.lltydescs);\n     let lltydescs = GEPi(bcx, llclosure,\n                          [0, abi::box_rc_field_body,\n                           abi::closure_elt_ty_params]);\n-    uint::range(0u, tydesc_count) { |i|\n-        let lltydescptr = GEPi(bcx, lltydescs, [0, i as int]);\n-        fcx.lltydescs += [Load(bcx, lltydescptr)];\n+    let off = 0;\n+    for tp in copy enclosing_cx.fcx.lltyparams {\n+        let tydesc = Load(bcx, GEPi(bcx, lltydescs, [0, off]));\n+        off += 1;\n+        let dicts = option::map(tp.dicts, {|dicts|\n+            let rslt = [];\n+            for dict in dicts {\n+                let dict = Load(bcx, GEPi(bcx, lltydescs, [0, off]));\n+                rslt += [PointerCast(bcx, dict, T_ptr(T_dict()))];\n+                off += 1;\n+            }\n+            rslt\n+        });\n+        fcx.lltyparams += [{desc: tydesc, dicts: dicts}];\n     }\n \n     // Populate the upvars from the environment.\n@@ -382,8 +405,7 @@ fn trans_expr_fn(bcx: @block_ctxt,\n     if dest == ignore { ret bcx; }\n     let ccx = bcx_ccx(bcx), bcx = bcx;\n     let fty = node_id_type(ccx, id);\n-    check returns_non_ty_var(ccx, fty);\n-    let llfnty = type_of_fn_from_ty(ccx, sp, fty, 0u);\n+    let llfnty = type_of_fn_from_ty(ccx, sp, fty, []);\n     let sub_cx = extend_path(bcx.fcx.lcx, ccx.names.next(\"anon\"));\n     let s = mangle_internal_name_by_path(ccx, sub_cx.path);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n@@ -436,19 +458,25 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n     }\n \n     // Figure out which tydescs we need to pass, if any.\n-    let outgoing_fty_real; // the type with typarams still in it\n-    let lltydescs: [ValueRef];\n-    alt f_res.generic {\n-      none. { outgoing_fty_real = outgoing_fty; lltydescs = []; }\n+    let (outgoing_fty_real, lltydescs, param_bounds) = alt f_res.generic {\n+      none. { (outgoing_fty, [], @[]) }\n       some(ginfo) {\n+        for bounds in *ginfo.param_bounds {\n+            for bound in *bounds {\n+                alt bound {\n+                  ty::bound_iface(_) {\n+                    fail \"FIXME[impl] binding bounded types not implemented\";\n+                  }\n+                  _ {}\n+                }\n+            }\n+        }\n         lazily_emit_all_generic_info_tydesc_glues(cx, ginfo);\n-        outgoing_fty_real = ginfo.item_type;\n-        lltydescs = ginfo.tydescs;\n+        (ginfo.item_type, ginfo.tydescs, ginfo.param_bounds)\n       }\n-    }\n+    };\n \n-    let ty_param_count = vec::len(lltydescs);\n-    if vec::len(bound) == 0u && ty_param_count == 0u {\n+    if vec::len(bound) == 0u && vec::len(lltydescs) == 0u {\n         // Trivial 'binding': just return the closure\n         let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n         bcx = lv.bcx;\n@@ -480,14 +508,14 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n \n     // Actually construct the closure\n     let {llbox, box_ty, bcx} = store_environment(\n-        bcx, lltydescs,\n+        bcx, vec::map(lltydescs, {|d| {desc: d, dicts: none}}),\n         env_vals + vec::map(bound, {|x| env_expr(x)}),\n         ty::closure_shared);\n \n     // Make thunk\n     let llthunk =\n         trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty_real, args,\n-                         box_ty, ty_param_count, target_res);\n+                         box_ty, *param_bounds, target_res);\n \n     // Fill the function pair\n     fill_fn_pair(bcx, get_dest_addr(dest), llthunk.val, llbox);\n@@ -558,7 +586,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n                     outgoing_fty: ty::t,\n                     args: [option::t<@ast::expr>],\n                     boxed_closure_ty: ty::t,\n-                    ty_param_count: uint,\n+                    param_bounds: [ty::param_bounds],\n                     target_fn: option::t<ValueRef>)\n     -> {val: ValueRef, ty: TypeRef} {\n     // If we supported constraints on record fields, we could make the\n@@ -606,7 +634,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     // our bound tydescs, we need to load tydescs out of the environment\n     // before derived tydescs are constructed. To do this, we load them\n     // in the load_env block.\n-    let load_env_bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n+    let l_bcx = new_raw_block_ctxt(fcx, fcx.llloadenv);\n \n     // The 'llenv' that will arrive in the thunk we're creating is an\n     // environment that will contain the values of its arguments and a pointer\n@@ -616,7 +644,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     // 'boxed_closure_ty', which was determined by trans_bind.\n     check (type_has_static_size(ccx, boxed_closure_ty));\n     let llclosure_ptr_ty = type_of(ccx, sp, boxed_closure_ty);\n-    let llclosure = PointerCast(load_env_bcx, fcx.llenv, llclosure_ptr_ty);\n+    let llclosure = PointerCast(l_bcx, fcx.llenv, llclosure_ptr_ty);\n \n     // \"target\", in this context, means the function that's having some of its\n     // arguments bound and that will be called inside the thunk we're\n@@ -667,19 +695,32 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     let llargs: [ValueRef] = [llretptr, lltargetenv];\n \n     // Copy in the type parameters.\n-    let i: uint = 0u;\n-    while i < ty_param_count {\n-        // Silly check\n-        check type_is_tup_like(load_env_bcx, boxed_closure_ty);\n-        let lltyparam_ptr =\n-            GEP_tup_like(load_env_bcx, boxed_closure_ty, llclosure,\n-                         [0, abi::box_rc_field_body,\n-                          abi::closure_elt_ty_params, i as int]);\n-        load_env_bcx = lltyparam_ptr.bcx;\n-        let td = Load(load_env_bcx, lltyparam_ptr.val);\n-        llargs += [td];\n-        fcx.lltydescs += [td];\n-        i += 1u;\n+    check type_is_tup_like(l_bcx, boxed_closure_ty);\n+    let {bcx: l_bcx, val: param_record} =\n+        GEP_tup_like(l_bcx, boxed_closure_ty, llclosure,\n+                     [0, abi::box_rc_field_body, abi::closure_elt_ty_params]);\n+    let off = 0;\n+    for param in param_bounds {\n+        let dsc = Load(l_bcx, GEPi(l_bcx, param_record, [0, off])),\n+            dicts = none;\n+        llargs += [dsc];\n+        off += 1;\n+        for bound in *param {\n+            alt bound {\n+              ty::bound_iface(_) {\n+                let dict = Load(l_bcx, GEPi(l_bcx, param_record, [0, off]));\n+                dict = PointerCast(l_bcx, dict, T_ptr(T_dict()));\n+                llargs += [dict];\n+                off += 1;\n+                dicts = some(alt dicts {\n+                  none. { [dict] }\n+                  some(ds) { ds + [dict] }\n+                });\n+              }\n+              _ {}\n+            }\n+        }\n+        fcx.lltyparams += [{desc: dsc, dicts: dicts}];\n     }\n \n     let a: uint = 2u; // retptr, env come first\n@@ -737,13 +778,11 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     // needs to take.\n     let ccx = bcx_ccx(bcx);\n \n-    check returns_non_ty_var(ccx, outgoing_fty);\n     let lltargetty =\n-        type_of_fn_from_ty(ccx, sp, outgoing_fty, ty_param_count);\n+        type_of_fn_from_ty(ccx, sp, outgoing_fty, param_bounds);\n     lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(lltargetty));\n     Call(bcx, lltargetfn, llargs);\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n     ret {val: llthunk, ty: llthunk_ty};\n }\n-"}, {"sha": "fa0810fcf912ce3f8f64dcddcc8149d445a1ed2f", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -92,7 +92,6 @@ type crate_ctxt =\n      discrims: hashmap<ast::def_id, ValueRef>,\n      discrim_symbols: hashmap<ast::node_id, str>,\n      consts: hashmap<ast::node_id, ValueRef>,\n-     obj_methods: hashmap<ast::node_id, ()>,\n      tydescs: hashmap<ty::t, @tydesc_info>,\n      module_data: hashmap<str, ValueRef>,\n      lltypes: hashmap<ty::t, TypeRef>,\n@@ -105,6 +104,7 @@ type crate_ctxt =\n      copy_map: alias::copy_map,\n      last_uses: last_use::last_uses,\n      method_map: typeck::method_map,\n+     dict_map: typeck::dict_map,\n      stats: stats,\n      upcalls: @upcall::upcalls,\n      rust_object_type: TypeRef,\n@@ -131,6 +131,8 @@ type val_self_pair = {v: ValueRef, t: ty::t};\n \n tag local_val { local_mem(ValueRef); local_imm(ValueRef); }\n \n+type fn_ty_param = {desc: ValueRef, dicts: option::t<[ValueRef]>};\n+\n // Function context.  Every LLVM function we create will have one of\n // these.\n type fn_ctxt =\n@@ -236,7 +238,7 @@ type fn_ctxt =\n      llobjfields: hashmap<ast::node_id, ValueRef>,\n      lllocals: hashmap<ast::node_id, local_val>,\n      llupvars: hashmap<ast::node_id, ValueRef>,\n-     mutable lltydescs: [ValueRef],\n+     mutable lltyparams: [fn_ty_param],\n      derived_tydescs: hashmap<ty::t, derived_tydesc_info>,\n      id: ast::node_id,\n      ret_style: ast::ret_style,\n@@ -320,13 +322,13 @@ fn get_res_dtor(ccx: @crate_ctxt, sp: span, did: ast::def_id, inner_t: ty::t)\n         }\n     }\n \n-    let params = csearch::get_type_param_count(ccx.sess.get_cstore(), did);\n+    let param_bounds = ty::lookup_item_type(ccx.tcx, did).bounds;\n     let nil_res = ty::mk_nil(ccx.tcx);\n     // FIXME: Silly check -- mk_nil should have a postcondition\n     check non_ty_var(ccx, nil_res);\n     let f_t = type_of_fn(ccx, sp, false,\n                          [{mode: ast::by_ref, ty: inner_t}],\n-                         nil_res, params);\n+                         nil_res, *param_bounds);\n     ret trans::get_extern_const(ccx.externs, ccx.llmod,\n                                 csearch::get_symbol(ccx.sess.get_cstore(),\n                                                     did), f_t);\n@@ -406,7 +408,7 @@ fn ty_str(tn: type_names, t: TypeRef) -> str {\n     ret lib::llvm::type_to_str(tn, t);\n }\n \n-fn val_ty(v: ValueRef) -> TypeRef { ret llvm::LLVMTypeOf(v); }\n+fn val_ty(&&v: ValueRef) -> TypeRef { ret llvm::LLVMTypeOf(v); }\n \n fn val_str(tn: type_names, v: ValueRef) -> str { ret ty_str(tn, val_ty(v)); }\n \n@@ -533,11 +535,9 @@ fn T_size_t(targ_cfg: @session::config) -> TypeRef {\n     ret T_int(targ_cfg);\n }\n \n-fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef {\n-    unsafe {\n-        ret llvm::LLVMFunctionType(output, to_ptr(inputs),\n-                                   vec::len::<TypeRef>(inputs), False);\n-    }\n+fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef unsafe {\n+    ret llvm::LLVMFunctionType(output, to_ptr(inputs),\n+                               vec::len::<TypeRef>(inputs), False);\n }\n \n fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n@@ -546,10 +546,8 @@ fn T_fn_pair(cx: @crate_ctxt, tfn: TypeRef) -> TypeRef {\n \n fn T_ptr(t: TypeRef) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n \n-fn T_struct(elts: [TypeRef]) -> TypeRef {\n-    unsafe {\n-        ret llvm::LLVMStructType(to_ptr(elts), vec::len(elts), False);\n-    }\n+fn T_struct(elts: [TypeRef]) -> TypeRef unsafe {\n+    ret llvm::LLVMStructType(to_ptr(elts), vec::len(elts), False);\n }\n \n fn T_named_struct(name: str) -> TypeRef {\n@@ -574,6 +572,12 @@ fn T_rust_object() -> TypeRef {\n     ret t;\n }\n \n+// A dict is, in reality, a vtable pointer followed by zero or more pointers\n+// to tydescs and other dicts that it closes over. But the types and number of\n+// those are rarely known to the code that needs to manipulate them, so they\n+// are described by this opaque type.\n+fn T_dict() -> TypeRef { T_array(T_ptr(T_i8()), 1u) }\n+\n fn T_task(targ_cfg: @session::config) -> TypeRef {\n     let t = T_named_struct(\"task\");\n "}, {"sha": "04bff49877f7194168172056e1284bf265cfc487", "filename": "src/comp/middle/trans_impl.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,172 @@\n+import trans::*;\n+import trans_common::*;\n+import trans_build::*;\n+import option::{some, none};\n+import syntax::{ast, ast_util};\n+import back::link;\n+import lib::llvm;\n+import llvm::llvm::{ValueRef, TypeRef, LLVMGetParam};\n+\n+fn trans_impl(cx: @local_ctxt, name: ast::ident, methods: [@ast::method],\n+              id: ast::node_id, tps: [ast::ty_param],\n+              _ifce: option::t<@ast::ty>) {\n+    let sub_cx = extend_path(cx, name);\n+    for m in methods {\n+        alt cx.ccx.item_ids.find(m.id) {\n+          some(llfn) {\n+            trans_fn(extend_path(sub_cx, m.ident), m.span, m.decl, m.body,\n+                     llfn, impl_self(ty::node_id_to_monotype(cx.ccx.tcx, id)),\n+                     tps + m.tps, m.id);\n+          }\n+        }\n+    }\n+}\n+\n+fn trans_self_arg(bcx: @block_ctxt, base: @ast::expr) -> result {\n+    let tz = [], tr = [];\n+    let basety = ty::expr_ty(bcx_tcx(bcx), base);\n+    let {bcx, val} = trans_arg_expr(bcx, {mode: ast::by_ref, ty: basety},\n+                                    T_ptr(type_of_or_i8(bcx, basety)), tz,\n+                                    tr, base);\n+    rslt(bcx, PointerCast(bcx, val, T_opaque_boxed_closure_ptr(bcx_ccx(bcx))))\n+}\n+\n+fn trans_static_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,\n+                       did: ast::def_id) -> lval_maybe_callee {\n+    let {bcx, val} = trans_self_arg(bcx, base);\n+    {env: obj_env(val) with lval_static_fn(bcx, did, e.id)}\n+}\n+\n+fn trans_dict_callee(bcx: @block_ctxt, e: @ast::expr, base: @ast::expr,\n+                     iface_id: ast::def_id, n_method: uint,\n+                     n_param: uint, n_bound: uint) -> lval_maybe_callee {\n+    let tcx = bcx_tcx(bcx);\n+    let {bcx, val} = trans_self_arg(bcx, base);\n+    let dict = option::get(bcx.fcx.lltyparams[n_param].dicts)[n_bound];\n+    let method = ty::iface_methods(tcx, iface_id)[n_method];\n+    let fty = ty::expr_ty(tcx, e);\n+    let bare_fn_ty = type_of_fn_from_ty(bcx_ccx(bcx), ast_util::dummy_sp(),\n+                                        fty, *method.tps);\n+    let {inputs: bare_inputs, output} = llfn_arg_tys(bare_fn_ty);\n+    let fn_ty = T_fn([val_ty(dict)] + bare_inputs, output);\n+    let vtable = PointerCast(bcx, Load(bcx, GEPi(bcx, dict, [0, 0])),\n+                             T_ptr(T_array(T_ptr(fn_ty), n_method + 1u)));\n+    let mptr = Load(bcx, GEPi(bcx, vtable, [0, n_method as int]));\n+    let generic = none;\n+    if vec::len(*method.tps) > 0u {\n+        let tydescs = [], tis = [];\n+        for t in ty::node_id_to_type_params(tcx, e.id) {\n+            // TODO: Doesn't always escape.\n+            let ti = none;\n+            let td = get_tydesc(bcx, t, true, tps_normal, ti).result;\n+            tis += [ti];\n+            tydescs += [td.val];\n+            bcx = td.bcx;\n+        }\n+        generic = some({item_type: fty,\n+                        static_tis: tis,\n+                        tydescs: tydescs,\n+                        param_bounds: method.tps,\n+                        origins: bcx_ccx(bcx).dict_map.find(e.id)});\n+    }\n+    {bcx: bcx, val: mptr, kind: owned,\n+     env: dict_env(dict, val),\n+     generic: generic}\n+}\n+\n+fn llfn_arg_tys(ft: TypeRef) -> {inputs: [TypeRef], output: TypeRef} {\n+    let out_ty = llvm::llvm::LLVMGetReturnType(ft);\n+    let n_args = llvm::llvm::LLVMCountParamTypes(ft);\n+    let args = vec::init_elt(0 as TypeRef, n_args);\n+    unsafe { llvm::llvm::LLVMGetParamTypes(ft, vec::to_ptr(args)); }\n+    {inputs: args, output: out_ty}\n+}\n+\n+fn trans_wrapper(ccx: @crate_ctxt, pt: [ast::ident],\n+                 extra_tps: [ty::param_bounds], m: @ast::method) -> ValueRef {\n+    let real_fn = ccx.item_ids.get(m.id);\n+    let {inputs: real_args, output: real_ret} =\n+        llfn_arg_tys(llvm::llvm::LLVMGetElementType(val_ty(real_fn)));\n+    let extra_ptrs = [];\n+    for tp in extra_tps {\n+        extra_ptrs += [T_ptr(ccx.tydesc_type)];\n+        for bound in *tp {\n+            alt bound {\n+              ty::bound_iface(_) { extra_ptrs += [T_ptr(T_dict())]; }\n+              _ {}\n+            }\n+        }\n+    }\n+    let env_ty = T_ptr(T_struct([T_ptr(T_i8())] + extra_ptrs));\n+    let n_extra_ptrs = vec::len(extra_ptrs);\n+\n+    let wrap_args = [T_ptr(T_dict())] + vec::slice(real_args, 0u, 2u) +\n+        vec::slice(real_args, 2u + vec::len(extra_ptrs), vec::len(real_args));\n+    let llfn_ty = T_fn(wrap_args, real_ret);\n+\n+    let lcx = @{path: pt + [\"wrapper\", m.ident], module_path: [],\n+                obj_typarams: [], obj_fields: [], ccx: ccx};\n+    let name = link::mangle_internal_name_by_path_and_seq(ccx, pt, m.ident);\n+    let llfn = decl_internal_cdecl_fn(ccx.llmod, name, llfn_ty);\n+    let fcx = new_fn_ctxt(lcx, ast_util::dummy_sp(), llfn);\n+    let bcx = new_top_block_ctxt(fcx), lltop = bcx.llbb;\n+\n+    let dict = PointerCast(bcx, LLVMGetParam(llfn, 0u), env_ty);\n+    // retptr, self\n+    let args = [LLVMGetParam(llfn, 1u), LLVMGetParam(llfn, 2u)], i = 0u;\n+    // saved tydescs/dicts\n+    while i < n_extra_ptrs {\n+        i += 1u;\n+        args += [load_inbounds(bcx, dict, [0, i as int])];\n+    }\n+    // the rest of the parameters\n+    let i = 3u, params_total = llvm::llvm::LLVMCountParamTypes(llfn_ty);\n+    while i < params_total {\n+        args += [LLVMGetParam(llfn, i)];\n+        i += 1u;\n+    }\n+    Call(bcx, ccx.item_ids.get(m.id), args);\n+    build_return(bcx);\n+    finish_fn(fcx, lltop);\n+    ret llfn;\n+}\n+\n+// FIXME[impl] cache these on the function level somehow\n+fn get_dict(bcx: @block_ctxt, origin: typeck::dict_origin) -> result {\n+    let bcx = bcx, ccx = bcx_ccx(bcx);\n+    alt origin {\n+      typeck::dict_static(impl_did, tys, sub_origins) {\n+        assert impl_did.crate == ast::local_crate; // FIXME[impl]\n+        let vtable = ccx.item_ids.get(impl_did.node);\n+        let impl_params = ty::lookup_item_type(ccx.tcx, impl_did).bounds;\n+        let ptrs = [vtable], i = 0u, origin = 0u, ti = none;\n+        for param in *impl_params {\n+            let rslt = get_tydesc(bcx, tys[i], false, tps_normal, ti).result;\n+            ptrs += [rslt.val];\n+            bcx = rslt.bcx;\n+            for bound in *param {\n+                alt bound {\n+                  ty::bound_iface(_) {\n+                    let res = get_dict(bcx, sub_origins[origin]);\n+                    ptrs += [res.val];\n+                    bcx = res.bcx;\n+                    origin += 1u;\n+                  }\n+                  _ {}\n+                }\n+            }\n+            i += 1u;\n+        }\n+        let pty = T_ptr(T_i8()), dict_ty = T_array(pty, vec::len(ptrs));\n+        let dict = alloca(bcx, dict_ty), i = 0;\n+        for ptr in ptrs {\n+            Store(bcx, PointerCast(bcx, ptr, pty), GEPi(bcx, dict, [0, i]));\n+            i += 1;\n+        }\n+        rslt(bcx, PointerCast(bcx, dict, T_ptr(T_dict())))\n+      }\n+      typeck::dict_param(n_param, n_bound) {\n+        rslt(bcx, option::get(bcx.fcx.lltyparams[n_param].dicts)[n_bound])\n+      }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "913cca74192aa72c01690983951b406093c18eb0", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -158,7 +158,7 @@ fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n         let typarams_ty: ty::t = ty::mk_tup(ccx.tcx, tps);\n         let i: int = 0;\n         for tp: ast::ty_param in ty_params {\n-            let typaram = bcx.fcx.lltydescs[i];\n+            let typaram = bcx.fcx.lltyparams[i].desc;\n             // Silly check\n             check type_is_tup_like(bcx, typarams_ty);\n             let capture =\n@@ -880,8 +880,9 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n       ty::ty_fn(f) {\n         let out = f.output;\n         check non_ty_var(ccx, out);\n-        llfnty = type_of_fn(ccx, m.span, true, f.inputs, out,\n-                            vec::len(ty_params));\n+        llfnty = type_of_fn(\n+            ccx, m.span, true, f.inputs, out,\n+            vec::map(ty_params, {|p| param_bounds(ccx, p)}));\n       }\n     }\n     let mcx: @local_ctxt =\n@@ -933,7 +934,8 @@ fn type_of_meth(ccx: @crate_ctxt, sp: span, m: @ty::method,\n                 tps: [ast::ty_param]) -> TypeRef {\n     let out_ty = m.fty.output;\n     check non_ty_var(ccx, out_ty);\n-    type_of_fn(ccx, sp, true, m.fty.inputs, out_ty, vec::len(tps))\n+    type_of_fn(ccx, sp, true, m.fty.inputs, out_ty,\n+               vec::map(tps, {|p| param_bounds(ccx, p)}))\n }\n \n //"}, {"sha": "10d311a5af91af81bad249521eee0932b1f2b901", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -50,12 +50,14 @@ fn comma_str(args: [@constr_arg_use]) -> str {\n fn constraint_to_str(tcx: ty::ctxt, c: sp_constr) -> str {\n     alt c.node {\n       ninit(id, i) {\n-        ret #fmt(\"init(%s id=%d [%s])\",\n+        ret #fmt(\"init(%s id=%d - arising from %s)\",\n                  i, id, tcx.sess.span_str(c.span));\n       }\n       npred(p, _, args) {\n-        ret path_to_str(p) + \"(\" + comma_str(args) + \")\" + \"[\" +\n-                tcx.sess.span_str(c.span) + \"]\";\n+          ret #fmt(\"%s(%s) - arising from %s\",\n+                   path_to_str(p),\n+                   comma_str(args),\n+                   tcx.sess.span_str(c.span));\n       }\n     }\n }"}, {"sha": "1a0a295ed459de49202afc2261b17ffedc1dcae0", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 62, "deletions": 57, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -18,7 +18,7 @@ import util::common::*;\n import syntax::util::interner;\n import util::ppaux::ty_to_str;\n import util::ppaux::ty_constr_to_str;\n-import util::ppaux::mode_str_1;\n+import util::ppaux::mode_str;\n import syntax::print::pprust::*;\n \n export node_id_to_monotype;\n@@ -185,7 +185,7 @@ export closure_kind;\n export closure_block;\n export closure_shared;\n export closure_send;\n-export param_bound, bound_copy, bound_send, bound_iface;\n+export param_bound, param_bounds, bound_copy, bound_send, bound_iface;\n export param_bounds_to_kind;\n \n // Data types\n@@ -194,7 +194,9 @@ type arg = {mode: mode, ty: t};\n \n type field = {ident: ast::ident, mt: mt};\n \n-type method = {ident: ast::ident, tps: [@[param_bound]], fty: fn_ty};\n+type param_bounds = @[param_bound];\n+\n+type method = {ident: ast::ident, tps: @[param_bounds], fty: fn_ty};\n \n type constr_table = hashmap<ast::node_id, [constr]>;\n \n@@ -218,9 +220,9 @@ type ctxt =\n       needs_drop_cache: hashmap<t, bool>,\n       kind_cache: hashmap<t, kind>,\n       ast_ty_to_ty_cache: hashmap<@ast::ty, option::t<t>>,\n-      tag_var_cache: hashmap<ast::def_id, @[variant_info]>,\n+      tag_var_cache: hashmap<def_id, @[variant_info]>,\n       iface_method_cache: hashmap<def_id, @[method]>,\n-      ty_param_bounds: hashmap<def_id, @[param_bound]>};\n+      ty_param_bounds: hashmap<ast::node_id, param_bounds>};\n \n type ty_ctxt = ctxt;\n \n@@ -268,7 +270,7 @@ tag sty {\n     ty_tup([t]);\n     ty_var(int); // type variable\n \n-    ty_param(uint, @[param_bound]); // fn/tag type param\n+    ty_param(uint, def_id); // fn/tag type param\n \n     ty_type; // type_desc*\n     ty_send_type; // type_desc* that has been cloned into exchange heap\n@@ -308,7 +310,7 @@ tag param_bound {\n     bound_iface(t);\n }\n \n-fn param_bounds_to_kind(bounds: @[param_bound]) -> kind {\n+fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n     let kind = kind_noncopyable;\n     for bound in *bounds {\n         alt bound {\n@@ -322,7 +324,7 @@ fn param_bounds_to_kind(bounds: @[param_bound]) -> kind {\n     kind\n }\n \n-type ty_param_bounds_and_ty = @{bounds: [@[param_bound]], ty: t};\n+type ty_param_bounds_and_ty = {bounds: @[param_bounds], ty: t};\n \n type type_cache = hashmap<ast::def_id, ty_param_bounds_and_ty>;\n \n@@ -439,7 +441,7 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n               map::mk_hashmap(ast_util::hash_ty, ast_util::eq_ty),\n           tag_var_cache: new_def_hash(),\n           iface_method_cache: new_def_hash(),\n-          ty_param_bounds: new_def_hash()};\n+          ty_param_bounds: map::new_int_hash()};\n     populate_type_store(cx);\n     ret cx;\n }\n@@ -624,7 +626,7 @@ fn mk_res(cx: ctxt, did: ast::def_id, inner: t, tps: [t]) -> t {\n \n fn mk_var(cx: ctxt, v: int) -> t { ret gen_ty(cx, ty_var(v)); }\n \n-fn mk_param(cx: ctxt, n: uint, k: @[param_bound]) -> t {\n+fn mk_param(cx: ctxt, n: uint, k: def_id) -> t {\n     ret gen_ty(cx, ty_param(n, k));\n }\n \n@@ -722,7 +724,7 @@ fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n \n tag fold_mode {\n     fm_var(fn@(int) -> t);\n-    fm_param(fn@(uint, @[param_bound]) -> t);\n+    fm_param(fn@(uint, def_id) -> t);\n     fm_general(fn@(t) -> t);\n }\n \n@@ -813,8 +815,14 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n       ty_var(id) {\n         alt fld { fm_var(folder) { ty = folder(id); } _ {/* no-op */ } }\n       }\n-      ty_param(id, k) {\n-        alt fld { fm_param(folder) { ty = folder(id, k); } _ {/* no-op */ } }\n+      ty_param(id, did) {\n+        alt fld { fm_param(folder) { ty = folder(id, did); } _ {} }\n+      }\n+      ty_constr(subty, cs) {\n+          ty = mk_constr(cx, fold_ty(cx, fld, subty), cs);\n+      }\n+      _ {\n+          cx.sess.fatal(\"Unsupported sort of type in fold_ty\");\n       }\n     }\n \n@@ -1083,7 +1091,9 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       }\n       // Resources are always noncopyable.\n       ty_res(did, inner, tps) { kind_noncopyable }\n-      ty_param(_, bounds) { param_bounds_to_kind(bounds) }\n+      ty_param(_, did) {\n+          param_bounds_to_kind(cx.ty_param_bounds.get(did.node))\n+      }\n       ty_constr(t, _) { type_kind(cx, t) }\n     };\n \n@@ -1131,7 +1141,7 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n     }\n }\n \n-pure fn type_has_dynamic_size(cx: ctxt, ty: t) -> bool {\n+pure fn type_has_dynamic_size(cx: ctxt, ty: t) -> bool unchecked {\n \n     /* type_structurally_contains can't be declared pure\n     because it takes a function argument. But it should be\n@@ -1141,15 +1151,9 @@ pure fn type_has_dynamic_size(cx: ctxt, ty: t) -> bool {\n     actually checkable. It seems to me like a lot of properties\n     that the type context tracks about types should be immutable.)\n     */\n-    unchecked{\n-        type_structurally_contains(cx, ty,\n-                                   fn (sty: sty) -> bool {\n-                                       ret alt sty {\n-                                             ty_param(_, _) { true }\n-                                             _ { false }\n-                                           };\n-                                   })\n-    }\n+    type_structurally_contains(cx, ty, fn (sty: sty) -> bool {\n+        alt sty { ty_param(_, _) { true } _ { false }}\n+    })\n }\n \n // Returns true for noncopyable types and types where a copy of a value can be\n@@ -1464,8 +1468,6 @@ fn constrs_eq(cs: [@constr], ds: [@constr]) -> bool {\n // Type lookups\n fn node_id_to_ty_param_substs_opt_and_ty(cx: ctxt, id: ast::node_id) ->\n    ty_param_substs_opt_and_ty {\n-\n-\n     // Pull out the node type table.\n     alt smallintmap::find(*cx.node_types, id as uint) {\n       none. {\n@@ -1737,6 +1739,7 @@ mod unify {\n     export ures_ok;\n     export ures_err;\n     export var_bindings;\n+    export precise, in_bindings;\n \n     tag result { ures_ok(t); ures_err(type_err); }\n     tag union_result { unres_ok; unres_err(type_err); }\n@@ -1747,7 +1750,11 @@ mod unify {\n     type var_bindings =\n         {sets: ufind::ufind, types: smallintmap::smallintmap<t>};\n \n-    type ctxt = {vb: option::t<@var_bindings>, tcx: ty_ctxt};\n+    tag unify_style {\n+        precise;\n+        in_bindings(@var_bindings);\n+    }\n+    type ctxt = {st: unify_style, tcx: ty_ctxt};\n \n     fn mk_var_bindings() -> @var_bindings {\n         ret @{sets: ufind::make(), types: smallintmap::mk::<t>()};\n@@ -1756,7 +1763,9 @@ mod unify {\n     // Unifies two sets.\n     fn union(cx: @ctxt, set_a: uint, set_b: uint,\n              variance: variance) -> union_result {\n-        let vb = option::get(cx.vb);\n+        let vb = alt cx.st {\n+            in_bindings(vb) { vb }\n+        };\n         ufind::grow(vb.sets, float::max(set_a, set_b) + 1u);\n         let root_a = ufind::find(vb.sets, set_a);\n         let root_b = ufind::find(vb.sets, set_b);\n@@ -1806,7 +1815,7 @@ mod unify {\n     fn record_var_binding(\n         cx: @ctxt, key: int, typ: t, variance: variance) -> result {\n \n-        let vb = option::get(cx.vb);\n+        let vb = alt cx.st { in_bindings(vb) { vb } };\n         ufind::grow(vb.sets, (key as uint) + 1u);\n         let root = ufind::find(vb.sets, key as uint);\n         let result_type = typ;\n@@ -2142,7 +2151,6 @@ mod unify {\n           // If the RHS is a variable type, then just do the\n           // appropriate binding.\n           ty::ty_var(actual_id) {\n-            assert option::is_some(cx.vb);\n             let actual_n = actual_id as uint;\n             alt struct(cx.tcx, expected) {\n               ty::ty_var(expected_id) {\n@@ -2167,7 +2175,6 @@ mod unify {\n         }\n         alt struct(cx.tcx, expected) {\n           ty::ty_var(expected_id) {\n-            assert option::is_some(cx.vb);\n             // Add a binding. (`actual` can't actually be a var here.)\n             alt record_var_binding_for_expected(\n                 cx, expected_id, actual,\n@@ -2205,7 +2212,14 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_param(_, _) { ret struct_cmp(cx, expected, actual); }\n+          ty::ty_param(expected_n, _) {\n+            alt struct(cx.tcx, actual) {\n+              ty::ty_param(actual_n, _) when expected_n == actual_n {\n+                ret ures_ok(expected);\n+              }\n+              _ { ret ures_err(terr_mismatch); }\n+            }\n+          }\n           ty::ty_tag(expected_id, expected_tps) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_tag(actual_id, actual_tps) {\n@@ -2477,9 +2491,9 @@ mod unify {\n           }\n         }\n     }\n-    fn unify(expected: t, actual: t, vb: option::t<@var_bindings>,\n+    fn unify(expected: t, actual: t, st: unify_style,\n              tcx: ty_ctxt) -> result {\n-        let cx = @{vb: vb, tcx: tcx};\n+        let cx = @{st: st, tcx: tcx};\n         ret unify_step(cx, expected, actual, covariant);\n     }\n     fn dump_var_bindings(tcx: ty_ctxt, vb: @var_bindings) {\n@@ -2552,7 +2566,7 @@ mod unify {\n }\n \n fn same_type(cx: ctxt, a: t, b: t) -> bool {\n-    alt unify::unify(a, b, none, cx) {\n+    alt unify::unify(a, b, unify::precise, cx) {\n       unify::ures_ok(_) { true }\n       _ { false }\n     }\n@@ -2602,8 +2616,8 @@ fn type_err_to_str(err: ty::type_err) -> str {\n                 \"' but found one with method '\" + a_meth + \"'\";\n       }\n       terr_mode_mismatch(e_mode, a_mode) {\n-        ret \"expected argument mode \" + mode_str_1(e_mode) + \" but found \" +\n-                mode_str_1(a_mode);\n+        ret \"expected argument mode \" + mode_str(e_mode) + \" but found \" +\n+                mode_str(a_mode);\n       }\n       terr_constr_len(e_len, a_len) {\n         ret \"Expected a type with \" + uint::str(e_len) +\n@@ -2621,35 +2635,26 @@ fn type_err_to_str(err: ty::type_err) -> str {\n \n // Converts type parameters in a type to type variables and returns the\n // resulting type along with a list of type variable IDs.\n-fn bind_params_in_type(sp: span, cx: ctxt, next_ty_var: fn@() -> int, typ: t,\n+fn bind_params_in_type(cx: ctxt, next_ty_var: block() -> int, typ: t,\n                        ty_param_count: uint) -> {ids: [int], ty: t} {\n-    let param_var_ids: @mutable [int] = @mutable [];\n-    let i = 0u;\n-    while i < ty_param_count { *param_var_ids += [next_ty_var()]; i += 1u; }\n-    fn binder(sp: span, cx: ctxt, param_var_ids: @mutable [int],\n-              _next_ty_var: fn@() -> int, index: uint,\n-              _bounds: @[param_bound]) -> t {\n-        if index < vec::len(*param_var_ids) {\n-            ret mk_var(cx, param_var_ids[index]);\n-        } else {\n-            cx.sess.span_fatal(sp, \"Unbound type parameter in callee's type\");\n-        }\n+    let param_var_ids = [], i = 0u;\n+    while i < ty_param_count { param_var_ids += [next_ty_var()]; i += 1u; }\n+    let param_var_ids = @param_var_ids;\n+    fn binder(cx: ctxt, param_var_ids: @[int], index: uint,\n+              _did: def_id) -> t {\n+        ret mk_var(cx, param_var_ids[index]);\n     }\n-    let new_typ =\n-        fold_ty(cx,\n-                fm_param(bind binder(sp, cx, param_var_ids, next_ty_var, _,\n-                                     _)), typ);\n-    ret {ids: *param_var_ids, ty: new_typ};\n+    {ids: *param_var_ids,\n+     ty: fold_ty(cx, fm_param(bind binder(cx, param_var_ids, _, _)), typ)}\n }\n \n \n // Replaces type parameters in the given type using the given list of\n // substitions.\n fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n     if !type_contains_params(cx, typ) { ret typ; }\n-    fn substituter(_cx: ctxt, substs: @[ty::t], idx: uint,\n-                   _bounds: @[param_bound])\n-       -> t {\n+    fn substituter(_cx: ctxt, substs: @[ty::t], idx: uint, _did: def_id)\n+        -> t {\n         // FIXME: bounds check can fail\n         ret substs[idx];\n     }"}, {"sha": "2becc452ebc082945484f50fe9d64a528964c8a3", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 427, "deletions": 117, "changes": 544, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -7,7 +7,7 @@ import driver::session;\n import util::common::*;\n import syntax::codemap::span;\n import middle::ty;\n-import middle::ty::{node_id_to_type, arg, bind_params_in_type, block_ty,\n+import middle::ty::{node_id_to_type, arg, block_ty,\n                     expr_ty, field, node_type_table, mk_nil,\n                     ty_param_substs_opt_and_ty, ty_param_bounds_and_ty};\n import util::ppaux::ty_to_str;\n@@ -18,9 +18,24 @@ import std::map::{hashmap, new_int_hash};\n import option::{none, some};\n import syntax::print::pprust::*;\n \n-export check_crate, method_map;\n+export check_crate, method_map, method_origin, method_static, method_param;\n+export dict_map, dict_res, dict_origin, dict_static, dict_param;\n \n-type method_map = hashmap<ast::node_id, ast::def_id>;\n+tag method_origin {\n+    method_static(ast::def_id);\n+    // iface id, method num, param num, bound num\n+    method_param(ast::def_id, uint, uint, uint);\n+}\n+type method_map = hashmap<ast::node_id, method_origin>;\n+\n+// Resolutions for bounds of all parameters, left to right, for a given path.\n+type dict_res = @[dict_origin];\n+tag dict_origin {\n+    dict_static(ast::def_id, [ty::t], dict_res);\n+    // Param number, bound number\n+    dict_param(uint, uint);\n+}\n+type dict_map = hashmap<ast::node_id, dict_res>;\n \n type ty_table = hashmap<ast::def_id, ty::t>;\n \n@@ -33,6 +48,7 @@ tag self_info {\n type crate_ctxt = {mutable self_infos: [self_info],\n                    impl_map: resolve::impl_map,\n                    method_map: method_map,\n+                   dict_map: dict_map,\n                    tcx: ty::ctxt};\n \n type fn_ctxt =\n@@ -76,22 +92,22 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n       ast::def_arg(id, _) {\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret @{bounds: [], ty: typ};\n+        ret {bounds: @[], ty: typ};\n       }\n       ast::def_local(id, _) {\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret @{bounds: [], ty: typ};\n+        ret {bounds: @[], ty: typ};\n       }\n       ast::def_obj_field(id, _) {\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret @{bounds: [], ty: typ};\n+        ret {bounds: @[], ty: typ};\n       }\n       ast::def_self(id) {\n         alt get_self_info(fcx.ccx) {\n           some(self_obj(_, obj_t)) | some(self_impl(obj_t)) {\n-            ret @{bounds: [], ty: obj_t};\n+            ret {bounds: @[], ty: obj_t};\n           }\n         }\n       }\n@@ -102,12 +118,12 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n       ast::def_binding(id) {\n         assert (fcx.locals.contains_key(id.node));\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n-        ret @{bounds: [], ty: typ};\n+        ret {bounds: @[], ty: typ};\n       }\n       ast::def_mod(_) {\n         // Hopefully part of a path.\n         // TODO: return a type that's more poisonous, perhaps?\n-        ret @{bounds: [], ty: ty::mk_nil(fcx.ccx.tcx)};\n+        ret {bounds: @[], ty: ty::mk_nil(fcx.ccx.tcx)};\n       }\n       ast::def_ty(_) {\n         fcx.ccx.tcx.sess.span_fatal(sp, \"expected value but found type\");\n@@ -122,16 +138,18 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n     }\n }\n \n+fn bind_params(fcx: @fn_ctxt, tp: ty::t, count: uint)\n+    -> {ids: [int], ty: ty::t} {\n+    ty::bind_params_in_type(fcx.ccx.tcx, {|| next_ty_var_id(fcx)}, tp, count)\n+}\n \n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n fn instantiate_path(fcx: @fn_ctxt, pth: @ast::path,\n                     tpt: ty_param_bounds_and_ty, sp: span)\n     -> ty_param_substs_opt_and_ty {\n-    let ty_param_count = vec::len(tpt.bounds);\n-    let bind_result =\n-        bind_params_in_type(sp, fcx.ccx.tcx, bind next_ty_var_id(fcx), tpt.ty,\n-                            ty_param_count);\n+    let ty_param_count = vec::len(*tpt.bounds);\n+    let bind_result = bind_params(fcx, tpt.ty, ty_param_count);\n     let ty_param_vars = bind_result.ids;\n     let ty_substs_opt;\n     let ty_substs_len = vec::len::<@ast::ty>(pth.node.types);\n@@ -282,13 +300,13 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         // \"foo = int\" like OCaml?\n \n         let ty_param_bounds_and_ty = getter(tcx, mode, id);\n-        if vec::len(ty_param_bounds_and_ty.bounds) == 0u {\n+        if vec::len(*ty_param_bounds_and_ty.bounds) == 0u {\n             ret ty_param_bounds_and_ty.ty;\n         }\n \n         // The typedef is type-parametric. Do the type substitution.\n         let param_bindings: [ty::t] = [];\n-        if vec::len(args) != vec::len(ty_param_bounds_and_ty.bounds) {\n+        if vec::len(args) != vec::len(*ty_param_bounds_and_ty.bounds) {\n             tcx.sess.span_fatal(sp, \"Wrong number of type arguments for a \\\n                                      polymorphic type\");\n         }\n@@ -343,7 +361,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n           }\n           some(ast::def_native_ty(id)) { typ = getter(tcx, mode, id).ty; }\n           some(ast::def_ty_param(id, n)) {\n-            typ = ty::mk_param(tcx, n, tcx.ty_param_bounds.get(id));\n+            typ = ty::mk_param(tcx, n, id);\n           }\n           some(_) {\n             tcx.sess.span_fatal(ast_ty.span,\n@@ -382,7 +400,7 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n     alt it.node {\n       ast::item_const(t, _) {\n         let typ = ast_ty_to_ty(tcx, mode, t);\n-        let tpt = @{bounds: [], ty: typ};\n+        let tpt = {bounds: @[], ty: typ};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n@@ -401,7 +419,7 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         }\n         // Tell ast_ty_to_ty() that we want to perform a recursive\n         // call to resolve any named types.\n-        let tpt = @{bounds: ty_param_bounds(tcx, mode, tps),\n+        let tpt = {bounds: ty_param_bounds(tcx, mode, tps),\n                    ty: ty::mk_named(tcx, ast_ty_to_ty(tcx, mode, t),\n                                     @it.ident)};\n         tcx.tcache.insert(local_def(it.id), tpt);\n@@ -413,7 +431,7 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         let t = ty::mk_named(tcx, ty::mk_res(tcx, local_def(it.id), t_arg.ty,\n                                              params),\n                              @it.ident);\n-        let t_res = @{bounds: bounds, ty: t};\n+        let t_res = {bounds: bounds, ty: t};\n         tcx.tcache.insert(local_def(it.id), t_res);\n         ret t_res;\n       }\n@@ -422,7 +440,7 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         let {bounds, params} = mk_ty_params(tcx, tps);\n         let t = ty::mk_named(tcx, ty::mk_tag(tcx, local_def(it.id), params),\n                              @it.ident);\n-        let tpt = @{bounds: bounds, ty: t};\n+        let tpt = {bounds: bounds, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n@@ -431,7 +449,7 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         let t = ty::mk_named(tcx, ty::mk_iface(tcx, local_def(it.id),\n                                                params),\n                              @it.ident);\n-        let tpt = @{bounds: bounds, ty: t};\n+        let tpt = {bounds: bounds, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ty::store_iface_methods(tcx, it.id, @vec::map(ms, {|m|\n             ty_of_ty_method(tcx, m_collect, m)\n@@ -455,7 +473,7 @@ fn ty_of_native_item(tcx: ty::ctxt, mode: mode, it: @ast::native_item)\n           none. { }\n         }\n         let t = ty::mk_native(tcx, ast_util::local_def(it.id));\n-        let tpt = @{bounds: [], ty: t};\n+        let tpt = {bounds: @[], ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n@@ -483,7 +501,7 @@ fn ty_of_fn(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n     -> ty::ty_param_bounds_and_ty {\n     let bounds = ty_param_bounds(tcx, mode, ty_params);\n     let tofd = ty_of_fn_decl(tcx, mode, ast::proto_bare, decl);\n-    let tpt = @{bounds: bounds, ty: ty::mk_fn(tcx, tofd)};\n+    let tpt = {bounds: bounds, ty: ty::mk_fn(tcx, tofd)};\n     tcx.tcache.insert(def_id, tpt);\n     ret tpt;\n }\n@@ -495,15 +513,15 @@ fn ty_of_native_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n     let output_ty = ast_ty_to_ty(tcx, mode, decl.output);\n \n     let t_fn = ty::mk_native_fn(tcx, input_tys, output_ty);\n-    let tpt = @{bounds: bounds, ty: t_fn};\n+    let tpt = {bounds: bounds, ty: t_fn};\n     tcx.tcache.insert(def_id, tpt);\n     ret tpt;\n }\n fn ty_param_bounds(tcx: ty::ctxt, mode: mode, params: [ast::ty_param])\n-    -> [@[ty::param_bound]] {\n+    -> @[ty::param_bounds] {\n     let result = [];\n     for param in params {\n-        result += [alt tcx.ty_param_bounds.find(local_def(param.id)) {\n+        result += [alt tcx.ty_param_bounds.find(param.id) {\n           some(bs) { bs }\n           none. {\n             let bounds = [];\n@@ -517,12 +535,12 @@ fn ty_param_bounds(tcx: ty::ctxt, mode: mode, params: [ast::ty_param])\n                 }];\n             }\n             let boxed = @bounds;\n-            tcx.ty_param_bounds.insert(local_def(param.id), boxed);\n+            tcx.ty_param_bounds.insert(param.id, boxed);\n             boxed\n           }\n         }];\n     }\n-    result\n+    @result\n }\n fn ty_of_method(tcx: ty::ctxt, mode: mode, m: @ast::method) -> ty::method {\n     {ident: m.ident, tps: ty_param_bounds(tcx, mode, m.tps),\n@@ -539,7 +557,7 @@ fn ty_of_obj(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n     let methods = vec::map(ob.methods, {|m| ty_of_method(tcx, mode, m)});\n     let t_obj = ty::mk_named(tcx, ty::mk_obj(tcx, ty::sort_methods(methods)),\n                              @id);\n-    ret @{bounds: bounds, ty: t_obj};\n+    ret {bounds: bounds, ty: t_obj};\n }\n fn ty_of_obj_ctor(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n             ctor_id: ast::node_id, ty_params: [ast::ty_param])\n@@ -553,7 +571,7 @@ fn ty_of_obj_ctor(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n     let t_fn = ty::mk_fn(tcx, {proto: ast::proto_shared(ast::sugar_normal),\n                                inputs: t_inputs, output: t_obj.ty,\n                                ret_style: ast::return_val, constraints: []});\n-    let tpt = @{bounds: ty_param_bounds(tcx, mode, ty_params), ty: t_fn};\n+    let tpt = {bounds: ty_param_bounds(tcx, mode, ty_params), ty: t_fn};\n     tcx.tcache.insert(local_def(ctor_id), tpt);\n     ret tpt;\n }\n@@ -622,11 +640,11 @@ mod write {\n }\n \n fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param])\n-    -> {bounds: [@[ty::param_bound]], params: [ty::t]} {\n+    -> {bounds: @[ty::param_bounds], params: [ty::t]} {\n     let i = 0u, bounds = ty_param_bounds(tcx, m_collect, atps);\n     {bounds: bounds,\n-     params: vec::map(atps, {|_atp|\n-         let t = ty::mk_param(tcx, i, bounds[i]);\n+     params: vec::map(atps, {|atp|\n+         let t = ty::mk_param(tcx, i, local_def(atp.id));\n          i += 1u;\n          t\n      })}\n@@ -674,7 +692,7 @@ mod collect {\n                            inputs: args, output: tag_ty,\n                            ret_style: ast::return_val, constraints: []})\n             };\n-            let tpt = @{bounds: ty_param_bounds(cx.tcx, m_collect, ty_params),\n+            let tpt = {bounds: ty_param_bounds(cx.tcx, m_collect, ty_params),\n                        ty: result_ty};\n             cx.tcx.tcache.insert(local_def(variant.node.id), tpt);\n             write::ty_only(cx.tcx, variant.node.id, result_ty);\n@@ -690,14 +708,15 @@ mod collect {\n             get_tag_variant_types(cx, tpt.ty, variants, ty_params);\n           }\n           ast::item_impl(tps, _, selfty, ms) {\n-            ty_param_bounds(cx.tcx, m_collect, tps);\n+            let i_bounds = ty_param_bounds(cx.tcx, m_collect, tps);\n             for m in ms {\n                 let bounds = ty_param_bounds(cx.tcx, m_collect, m.tps);\n                 let ty = ty::mk_fn(cx.tcx,\n                                    ty_of_fn_decl(cx.tcx, m_collect,\n                                                  ast::proto_bare, m.decl));\n-                cx.tcx.tcache.insert(local_def(m.id), @{bounds: bounds,\n-                                                       ty: ty});\n+                cx.tcx.tcache.insert(local_def(m.id),\n+                                     {bounds: @(*i_bounds + *bounds),\n+                                      ty: ty});\n                 write::ty_only(cx.tcx, m.id, ty);\n             }\n             write::ty_only(cx.tcx, it.id, ast_ty_to_ty(cx.tcx, m_collect,\n@@ -754,8 +773,7 @@ mod collect {\n             write::ty_only(cx.tcx, it.id, t_res);\n             write::ty_only(cx.tcx, ctor_id, t_ctor);\n             cx.tcx.tcache.insert(local_def(ctor_id),\n-                                 @{bounds: bounds,\n-                                  ty: t_ctor});\n+                                 {bounds: bounds, ty: t_ctor});\n             write::ty_only(cx.tcx, dtor_id, t_dtor);\n           }\n           _ {\n@@ -798,7 +816,8 @@ mod collect {\n mod unify {\n     fn unify(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) ->\n        ty::unify::result {\n-        ret ty::unify::unify(expected, actual, some(fcx.var_bindings),\n+        ret ty::unify::unify(expected, actual,\n+                             ty::unify::in_bindings(fcx.var_bindings),\n                              fcx.ccx.tcx);\n     }\n }\n@@ -1115,7 +1134,8 @@ fn gather_locals(ccx: @crate_ctxt,\n             alt ty_opt {\n               none. {/* nothing to do */ }\n               some(typ) {\n-                ty::unify::unify(ty::mk_var(tcx, var_id), typ, some(vb), tcx);\n+                ty::unify::unify(ty::mk_var(tcx, var_id), typ,\n+                                 ty::unify::in_bindings(vb), tcx);\n               }\n             }\n         };\n@@ -1465,39 +1485,92 @@ fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n     ret check_expr_with_unifier(fcx, expr, demand::simple, expected);\n }\n \n+fn impl_self_ty(tcx: ty::ctxt, did: ast::def_id) -> {n_tps: uint, ty: ty::t} {\n+    if did.crate == ast::local_crate {\n+        alt tcx.items.get(did.node) {\n+          ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n+                               _}) {\n+            {n_tps: vec::len(ts), ty: ast_ty_to_ty(tcx, m_check, st)}\n+          }\n+        }\n+    } else {\n+        let tpt = csearch::get_type(tcx, did);\n+        {n_tps: vec::len(*tpt.bounds), ty: tpt.ty}\n+    }\n+}\n+\n fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                  name: ast::ident, ty: ty::t, sp: span)\n-    -> option::t<{method: @resolve::method_info, ids: [int]}> {\n+    -> option::t<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n+                  origin: method_origin}> {\n+    let tcx = fcx.ccx.tcx;\n+\n+    // First, see whether this is an interface-bounded parameter\n+    alt ty::struct(tcx, ty) {\n+      ty::ty_param(n, did) {\n+        let bound_n = 0u;\n+        for bound in *tcx.ty_param_bounds.get(did.node) {\n+            alt bound {\n+              ty::bound_iface(t) {\n+                let (iid, tps) = alt ty::struct(tcx, t) {\n+                    ty::ty_iface(i, tps) { (i, tps) }\n+                    _ { cont; }\n+                };\n+                let ifce_methods = ty::iface_methods(tcx, iid);\n+                alt vec::position_pred(*ifce_methods, {|m| m.ident == name}) {\n+                  some(pos) {\n+                    let m = ifce_methods[pos];\n+                    ret some({method_ty: ty::mk_fn(tcx, m.fty),\n+                              n_tps: vec::len(*m.tps),\n+                              substs: tps,\n+                              origin: method_param(iid, pos, n, bound_n)});\n+                  }\n+                  _ {}\n+                }\n+                bound_n += 1u;\n+              }\n+              _ {}\n+            }\n+        }\n+        ret none;\n+      }\n+      _ {}\n+    }\n+\n+    fn ty_from_did(tcx: ty::ctxt, did: ast::def_id) -> ty::t {\n+        if did.crate == ast::local_crate {\n+            alt tcx.items.get(did.node) {\n+              ast_map::node_method(m) {\n+                let mt = ty_of_method(tcx, m_check, m);\n+                ty::mk_fn(tcx, mt.fty)\n+              }\n+            }\n+        } else { csearch::get_type(tcx, did).ty }\n+    }\n+\n     let result = none;\n     std::list::iter(isc) {|impls|\n         if option::is_some(result) { ret; }\n         for @{did, methods, _} in *impls {\n             alt vec::find(methods, {|m| m.ident == name}) {\n               some(m) {\n-                let (n_tps, self_ty) = if did.crate == ast::local_crate {\n-                    alt fcx.ccx.tcx.items.get(did.node) {\n-                      ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n-                                           _}) {\n-                        (vec::len(ts), ast_ty_to_ty_crate(fcx.ccx, st))\n-                      }\n-                    }\n-                } else {\n-                    let tpt = csearch::get_type(fcx.ccx.tcx, did);\n-                    (vec::len(tpt.bounds), tpt.ty)\n-                };\n+                let {n_tps, ty: self_ty} = impl_self_ty(tcx, did);\n                 let {ids, ty: self_ty} = if n_tps > 0u {\n-                    bind_params_in_type(ast_util::dummy_sp(), fcx.ccx.tcx,\n-                                        bind next_ty_var_id(fcx), self_ty,\n-                                        n_tps)\n+                    bind_params(fcx, self_ty, n_tps)\n                 } else { {ids: [], ty: self_ty} };\n                 alt unify::unify(fcx, ty, self_ty) {\n                   ures_ok(_) {\n                     if option::is_some(result) {\n                         // FIXME[impl] score specificity to resolve ambiguity?\n-                        fcx.ccx.tcx.sess.span_err(\n+                        tcx.sess.span_err(\n                             sp, \"multiple applicable methods in scope\");\n                     } else {\n-                        result = some({method: m, ids: ids});\n+                        result = some({\n+                            method_ty: ty_from_did(tcx, m.did),\n+                            n_tps: m.n_tps,\n+                            substs: vec::map(ids, {|id| ty::mk_var(tcx, id)}),\n+                            origin: method_static(m.did)\n+                        });\n                     }\n                   }\n                   _ {}\n@@ -1680,7 +1753,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let element_ty = demand::simple(fcx, local.span, element_ty,\n                                         ty::mk_var(fcx.ccx.tcx, locid));\n         let bot = check_decl_local(fcx, local);\n-        check_block(fcx, body);\n+        check_block_no_value(fcx, body);\n         // Unify type of decl with element type of the seq\n         demand::simple(fcx, local.span,\n                        ty::node_id_to_type(fcx.ccx.tcx, local.node.id),\n@@ -1695,22 +1768,27 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     fn check_then_else(fcx: @fn_ctxt, thn: ast::blk,\n                        elsopt: option::t<@ast::expr>, id: ast::node_id,\n                        _sp: span) -> bool {\n-        let then_bot = check_block(fcx, thn);\n-        let els_bot = false;\n-        let if_t =\n+        let (if_t, if_bot) =\n             alt elsopt {\n               some(els) {\n+                let thn_bot = check_block(fcx, thn);\n                 let thn_t = block_ty(fcx.ccx.tcx, thn);\n-                els_bot = check_expr_with(fcx, els, thn_t);\n-                let elsopt_t = expr_ty(fcx.ccx.tcx, els);\n-                if !ty::type_is_bot(fcx.ccx.tcx, elsopt_t) {\n-                    elsopt_t\n-                } else { thn_t }\n+                let els_bot = check_expr_with(fcx, els, thn_t);\n+                let els_t = expr_ty(fcx.ccx.tcx, els);\n+                let if_t = if !ty::type_is_bot(fcx.ccx.tcx, els_t) {\n+                    els_t\n+                } else {\n+                    thn_t\n+                };\n+                (if_t, thn_bot & els_bot)\n+              }\n+              none. {\n+                check_block_no_value(fcx, thn);\n+                (ty::mk_nil(fcx.ccx.tcx), false)\n               }\n-              none. { ty::mk_nil(fcx.ccx.tcx) }\n             };\n         write::ty_only_fixup(fcx, id, if_t);\n-        ret then_bot & els_bot;\n+        ret if_bot;\n     }\n \n     // Checks the compatibility\n@@ -1932,12 +2010,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_while(cond, body) {\n         bot = check_expr_with(fcx, cond, ty::mk_bool(tcx));\n-        check_block(fcx, body);\n+        check_block_no_value(fcx, body);\n         write::ty_only_fixup(fcx, id, ty::mk_nil(tcx));\n       }\n       ast::expr_do_while(body, cond) {\n         bot = check_expr_with(fcx, cond, ty::mk_bool(tcx)) |\n-              check_block(fcx, body);\n+              check_block_no_value(fcx, body);\n         write::ty_only_fixup(fcx, id, block_ty(tcx, body));\n       }\n       ast::expr_alt(expr, arms) {\n@@ -2153,7 +2231,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_field(base, field, tys) {\n         bot |= check_expr(fcx, base);\n-        let expr_t = expr_ty(tcx, base);\n+        let expr_t = structurally_resolved_type(fcx, expr.span,\n+                                                expr_ty(tcx, base));\n         let base_t = do_autoderef(fcx, expr.span, expr_t);\n         let handled = false, n_tys = vec::len(tys);\n         alt structure_of(fcx, expr.span, base_t) {\n@@ -2191,51 +2270,35 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         if !handled {\n             let iscope = fcx.ccx.impl_map.get(expr.id);\n             alt lookup_method(fcx, iscope, field, expr_t, expr.span) {\n-              some({method, ids}) {\n-                let fty = if method.did.crate == ast::local_crate {\n-                    alt tcx.items.get(method.did.node) {\n-                      ast_map::node_method(m) {\n-                        let mt = ty_of_method(tcx, m_check, m);\n-                        ty::mk_fn(tcx, mt.fty)\n-                      }\n-                    }\n-                } else { csearch::get_type(tcx, method.did).ty };\n-                let tvars = vec::map(ids, {|id| ty::mk_var(tcx, id)});\n-                let n_tps = vec::len(ids);\n-                if method.n_tps + n_tps  > 0u {\n-                    let b = bind_params_in_type(expr.span, tcx,\n-                                                bind next_ty_var_id(fcx), fty,\n-                                                n_tps + method.n_tps);\n-                    let _tvars = vec::map(b.ids, {|id| ty::mk_var(tcx, id)});\n-                    let i = 0;\n-                    for v in tvars {\n-                        demand::simple(fcx, expr.span, v, _tvars[i]);\n-                        i += 1;\n-                    }\n-                    tvars = _tvars;\n-                    fty = b.ty;\n+              some({method_ty: fty, n_tps: method_n_tps, substs, origin}) {\n+                let substs = substs, n_tps = vec::len(substs);\n+                if method_n_tps + n_tps > 0u {\n                     if n_tys > 0u {\n-                        if n_tys != method.n_tps {\n+                        if n_tys != method_n_tps {\n                             tcx.sess.span_fatal\n                                 (expr.span, \"incorrect number of type \\\n                                            parameters given for this method\");\n \n                         }\n-                        let i = 0u;\n                         for ty in tys {\n-                            let tvar = tvars[i + n_tps];\n-                            let t_subst = ast_ty_to_ty_crate(fcx.ccx, ty);\n-                            demand::simple(fcx, expr.span, tvar, t_subst);\n+                            substs += [ast_ty_to_ty_crate(fcx.ccx, ty)];\n+                        }\n+                    } else {\n+                        let i = 0u;\n+                        while i < method_n_tps {\n+                            substs += [ty::mk_var(tcx, next_ty_var_id(fcx))];\n                             i += 1u;\n                         }\n                     }\n+                    write::ty_fixup(fcx, id, {substs: some(substs), ty: fty});\n                 } else if n_tys > 0u {\n                     tcx.sess.span_fatal(expr.span,\n                                         \"this method does not take type \\\n                                          parameters\");\n+                } else {\n+                    write::ty_only_fixup(fcx, id, fty);\n                 }\n-                write::ty_fixup(fcx, id, {substs: some(tvars), ty: fty});\n-                fcx.ccx.method_map.insert(id, method.did);\n+                fcx.ccx.method_map.insert(id, origin);\n               }\n               none. {\n                 let t_err = resolve_type_vars_if_possible(fcx, expr_t);\n@@ -2437,6 +2500,16 @@ fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n     ret bot;\n }\n \n+fn check_block_no_value(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n+    let bot = check_block(fcx, blk);\n+    if !bot {\n+        let blkty = ty::node_id_to_monotype(fcx.ccx.tcx, blk.node.id);\n+        let nilty = ty::mk_nil(fcx.ccx.tcx);\n+        demand::simple(fcx, blk.span, nilty, blkty);\n+    }\n+    ret bot;\n+}\n+\n fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n     let fcx = alt blk.node.rules {\n       ast::unchecked_blk. { @{purity: ast::impure_fn with *fcx0} }\n@@ -2655,6 +2728,7 @@ fn check_fn(ccx: @crate_ctxt,\n     // If we have an enclosing function scope, our type variables will be\n     // resolved when the enclosing scope finishes up.\n     if option::is_none(old_fcx) {\n+        dict::resolve_in_block(fcx, body);\n         writeback::resolve_type_vars_in_block(fcx, body);\n     }\n }\n@@ -2663,16 +2737,40 @@ fn check_method(ccx: @crate_ctxt, method: @ast::method) {\n     check_fn(ccx, ast::proto_bare, method.decl, method.body, method.id, none);\n }\n \n+fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n+                       impl_tps: uint, if_m: ty::method, substs: [ty::t]) {\n+    if impl_m.tps != if_m.tps {\n+        tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n+                          \"` has an incompatible set of type parameters\");\n+    } else {\n+        let impl_fty = ty::mk_fn(tcx, impl_m.fty);\n+        // Add dummy substs for the parameters of the impl method\n+        let substs = substs + vec::init_fn({|i|\n+            ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n+        }, vec::len(*if_m.tps));\n+        let if_fty = ty::substitute_type_params(tcx, substs,\n+                                                ty::mk_fn(tcx, if_m.fty));\n+        alt ty::unify::unify(impl_fty, if_fty, ty::unify::precise, tcx) {\n+          ty::unify::ures_err(err) {\n+            tcx.sess.span_err(sp, \"method `\" + if_m.ident +\n+                              \"` has an incompatible type: \" +\n+                              ty::type_err_to_str(err));\n+          }\n+          _ {}\n+        }\n+    }\n+}\n+\n fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     alt it.node {\n       ast::item_const(_, e) { check_const(ccx, it.span, e, it.id); }\n-      ast::item_fn(decl, _, body) {\n+      ast::item_fn(decl, tps, body) {\n         check_fn(ccx, ast::proto_bare, decl, body, it.id, none);\n       }\n-      ast::item_res(decl, _, body, dtor_id, _) {\n+      ast::item_res(decl, tps, body, dtor_id, _) {\n         check_fn(ccx, ast::proto_bare, decl, body, dtor_id, none);\n       }\n-      ast::item_obj(ob, _, _) {\n+      ast::item_obj(ob, tps, _) {\n         // We're entering an object, so gather up the info we need.\n         ccx.self_infos += [self_obj(ob.fields,\n                                     ccx.tcx.tcache.get(local_def(it.id)).ty)];\n@@ -2681,7 +2779,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         // Now remove the info from the stack.\n         vec::pop(ccx.self_infos);\n       }\n-      ast::item_impl(_, ifce, ty, ms) {\n+      ast::item_impl(tps, ifce, ty, ms) {\n         ccx.self_infos += [self_impl(ast_ty_to_ty(ccx.tcx, m_check, ty))];\n         let my_methods = vec::map(ms, {|m|\n             check_method(ccx, m);\n@@ -2690,23 +2788,24 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         vec::pop(ccx.self_infos);\n         alt ifce {\n           some(ty) {\n-            alt ty::struct(ccx.tcx, ast_ty_to_ty(ccx.tcx, m_check, ty)) {\n+            let iface_ty = ast_ty_to_ty(ccx.tcx, m_check, ty);\n+            alt ty::struct(ccx.tcx, iface_ty) {\n               ty::ty_iface(did, tys) {\n                 for if_m in *ty::iface_methods(ccx.tcx, did) {\n                     alt vec::find(my_methods, {|m| if_m.ident == m.ident}) {\n                       some(m) {\n-                        if !ty::same_method(ccx.tcx, m, if_m) {\n-                            ccx.tcx.sess.span_err(\n-                                ty.span, \"method `\" + if_m.ident +\n-                                \"` has the wrong type\");\n-                        }\n+                        compare_impl_method(ccx.tcx, ty.span, m,\n+                                            vec::len(tps), if_m, tys);\n                       }\n                       none. {\n                         ccx.tcx.sess.span_err(ty.span, \"missing method `\" +\n                                               if_m.ident + \"`\");\n                       }\n                     }\n                 }\n+                let tpt = {bounds: ty_param_bounds(ccx.tcx, m_check, tps),\n+                           ty: iface_ty};\n+                ccx.tcx.tcache.insert(local_def(it.id), tpt);\n               }\n               _ {\n                 ccx.tcx.sess.span_err(ty.span, \"can only implement interface \\\n@@ -2721,6 +2820,29 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     }\n }\n \n+fn check_ty_params(ccx: @crate_ctxt, tps: [ast::ty_param]) {\n+    for tp in tps {\n+        let i = 0u;\n+        for bound in *tp.bounds {\n+            alt bound {\n+              ast::bound_iface(at) {\n+                let tbound = ccx.tcx.ty_param_bounds.get(tp.id)[i];\n+                let bound_ty = alt tbound { ty::bound_iface(t) { t } };\n+                alt ty::struct(ccx.tcx, bound_ty) {\n+                  ty::ty_iface(_, _) {}\n+                  _ {\n+                    ccx.tcx.sess.span_err(at.span, \"type parameter bounds \\\n+                                                    must be interface types\");\n+                  }\n+                }\n+              }\n+              _ {}\n+            }\n+            i += 1u;\n+        }\n+    }\n+}\n+\n fn arg_is_argv_ty(tcx: ty::ctxt, a: ty::arg) -> bool {\n     alt ty::struct(tcx, a.ty) {\n       ty::ty_vec(mt) {\n@@ -2769,21 +2891,209 @@ fn check_for_main_fn(tcx: ty::ctxt, crate: @ast::crate) {\n     }\n }\n \n+mod dict {\n+    fn has_iface_bounds(tps: [ty::param_bounds]) -> bool {\n+        vec::any(tps, {|bs|\n+            vec::any(*bs, {|b|\n+                alt b { ty::bound_iface(_) { true } _ { false } }\n+            })\n+        })\n+    }\n+\n+    fn lookup_dicts(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n+                    bounds: @[ty::param_bounds], tys: [ty::t])\n+        -> dict_res {\n+        let tcx = fcx.ccx.tcx, result = [], i = 0u;\n+        for ty in tys {\n+            for bound in *bounds[i] {\n+                alt bound {\n+                  ty::bound_iface(i_ty) {\n+                    let i_ty = ty::substitute_type_params(tcx, tys, i_ty);\n+                    result += [lookup_dict(fcx, isc, sp, ty, i_ty)];\n+                  }\n+                  _ {}\n+                }\n+            }\n+            i += 1u;\n+        }\n+        @result\n+    }\n+\n+    fn lookup_dict(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n+                   ty: ty::t, iface_ty: ty::t) -> dict_origin {\n+        let tcx = fcx.ccx.tcx;\n+        let (iface_id, iface_tps) = alt ty::struct(tcx, iface_ty) {\n+            ty::ty_iface(did, tps) { (did, tps) }\n+            _ { tcx.sess.abort_if_errors(); fail; }\n+        };\n+        let ty = fixup_ty(fcx, sp, ty);\n+        alt ty::struct(tcx, ty) {\n+          ty::ty_param(n, did) {\n+            let n_bound = 0u;\n+            for bound in *tcx.ty_param_bounds.get(did.node) {\n+                alt bound {\n+                  ty::bound_iface(ity) {\n+                    alt ty::struct(tcx, ity) {\n+                      ty::ty_iface(idid, _) {\n+                        if iface_id == idid { ret dict_param(n, n_bound); }\n+                      }\n+                    }\n+                    n_bound += 1u;\n+                  }\n+                  _ {}\n+                }\n+            }\n+          }\n+          _ {\n+            let found = none;\n+            std::list::iter(isc) {|impls|\n+                if option::is_some(found) { ret; }\n+                for im in *impls {\n+                    if im.iface_did == some(iface_id) {\n+                        let {n_tps, ty: self_ty} = impl_self_ty(tcx, im.did);\n+                        let {ids, ty: self_ty} = if n_tps > 0u {\n+                            bind_params(fcx, self_ty, n_tps)\n+                        } else { {ids: [], ty: self_ty} };\n+                        let vars = vec::map(ids, {|id| ty::mk_var(tcx, id)});\n+                        let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n+                        // FIXME[impl] don't do this in fcx (or make\n+                        // unify transactional by scrubbing bindings on fail)\n+                        alt unify::unify(fcx, ty, self_ty) {\n+                          ures_ok(_) {\n+                            if option::is_some(found) {\n+                                tcx.sess.span_err(\n+                                    sp, \"multiple applicable implementations \\\n+                                         in scope\");\n+                            } else {\n+                                connect_iface_tps(fcx, sp, vars, iface_tps,\n+                                                  im.did);\n+                                let params = vec::map(vars, {|t|\n+                                    fixup_ty(fcx, sp, t)});\n+                                let subres = lookup_dicts(fcx, isc, sp, im_bs,\n+                                                          params);\n+                                found = some(dict_static(im.did, params,\n+                                                         subres));\n+                            }\n+                          }\n+                          _ {}\n+                        }\n+                    }\n+                }\n+            }\n+            alt found {\n+              some(rslt) { ret rslt; }\n+              _ {}\n+            }\n+          }\n+        }\n+\n+        tcx.sess.span_fatal(\n+            sp, \"failed to find an implementation of interface \" +\n+            ty_to_str(tcx, iface_ty) + \" for \" +\n+            ty_to_str(tcx, ty));\n+    }\n+\n+    fn fixup_ty(fcx: @fn_ctxt, sp: span, ty: ty::t) -> ty::t {\n+        let tcx = fcx.ccx.tcx;\n+        alt ty::unify::fixup_vars(tcx, some(sp), fcx.var_bindings, ty) {\n+          fix_ok(new_type) { new_type }\n+          fix_err(vid) {\n+            tcx.sess.span_fatal(sp, \"could not determine a type for a \\\n+                                     bounded type parameter\");\n+          }\n+        }\n+    }\n+\n+    fn connect_iface_tps(fcx: @fn_ctxt, sp: span, impl_tys: [ty::t],\n+                         iface_tys: [ty::t], impl_did: ast::def_id) {\n+        let tcx = fcx.ccx.tcx;\n+        // FIXME[impl]\n+        assert impl_did.crate == ast::local_crate;\n+        let ity = alt tcx.items.get(impl_did.node) {\n+          ast_map::node_item(@{node: ast::item_impl(_, some(ity), _, _), _}) {\n+              ast_ty_to_ty(tcx, m_check, ity)\n+          }\n+        };\n+        let iface_ty = ty::substitute_type_params(tcx, impl_tys, ity);\n+        alt ty::struct(tcx, iface_ty) {\n+          ty::ty_iface(_, tps) {\n+            vec::iter2(tps, iface_tys,\n+                       {|a, b| demand::simple(fcx, sp, a, b);});\n+          }\n+        }\n+    }\n+\n+    fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n+        let cx = fcx.ccx;\n+        alt ex.node {\n+          ast::expr_path(_) {\n+            let substs = ty::node_id_to_ty_param_substs_opt_and_ty(\n+                cx.tcx, ex.id);\n+            alt substs.substs {\n+              some(ts) {\n+                let did = ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id));\n+                let item_ty = ty::lookup_item_type(cx.tcx, did);\n+                if has_iface_bounds(*item_ty.bounds) {\n+                    let impls = cx.impl_map.get(ex.id);\n+                    cx.dict_map.insert(ex.id, lookup_dicts(\n+                        fcx, impls, ex.span, item_ty.bounds, ts));\n+                }\n+              }\n+              _ {}\n+            }\n+          }\n+          // Must resolve bounds on methods with bounded params\n+          ast::expr_field(_, _, _) {\n+            alt cx.method_map.find(ex.id) {\n+              some(method_static(did)) {\n+                let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n+                if has_iface_bounds(*bounds) {\n+                    let ts = ty::node_id_to_type_params(cx.tcx, ex.id);\n+                    let iscs = cx.impl_map.get(ex.id);\n+                    cx.dict_map.insert(ex.id, lookup_dicts(\n+                        fcx, iscs, ex.span, bounds, ts));\n+                }\n+              }\n+              _ {}\n+            }\n+          }\n+          ast::expr_fn(ast::proto_block., _, _, _) {}\n+          ast::expr_fn(_, _, _, _) { ret; }\n+          _ {}\n+        }\n+        visit::visit_expr(ex, fcx, v);\n+    }\n+\n+    // Detect points where an interface-bounded type parameter is\n+    // instantiated, resolve the impls for the parameters.\n+    fn resolve_in_block(fcx: @fn_ctxt, bl: ast::blk) {\n+        visit::visit_block(bl, fcx, visit::mk_vt(@{\n+            visit_expr: resolve_expr,\n+            visit_item: fn(_i: @ast::item, &&_e: @fn_ctxt,\n+                           _v: visit::vt<@fn_ctxt>) {}\n+            with *visit::default_visitor()\n+        }));\n+    }\n+}\n+\n fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n-               crate: @ast::crate) -> method_map {\n+               crate: @ast::crate) -> (method_map, dict_map) {\n     collect::collect_item_types(tcx, crate);\n \n     let ccx = @{mutable self_infos: [],\n                 impl_map: impl_map,\n                 method_map: std::map::new_int_hash(),\n+                dict_map: std::map::new_int_hash(),\n                 tcx: tcx};\n-    let visit =\n-        visit::mk_simple_visitor(@{visit_item: bind check_item(ccx, _)\n-                                      with *visit::default_simple_visitor()});\n+    let visit = visit::mk_simple_visitor(@{\n+        visit_item: bind check_item(ccx, _),\n+        visit_ty_params: bind check_ty_params(ccx, _)\n+        with *visit::default_simple_visitor()\n+    });\n     visit::visit_crate(*crate, (), visit);\n     check_for_main_fn(tcx, crate);\n     tcx.sess.abort_if_errors();\n-    ccx.method_map\n+    (ccx.method_map, ccx.dict_map)\n }\n //\n // Local Variables:"}, {"sha": "2738f3e4b82c1960ede212b214ecf6fef91f8e6b", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -22,6 +22,7 @@ mod middle {\n     mod trans_uniq;\n     mod trans_closure;\n     mod trans_vec;\n+    mod trans_impl;\n     mod ty;\n     mod ast_map;\n     mod resolve;"}, {"sha": "b13f0cff92ac3f4b5f6bef273d0f4ccfe9d3ceaf", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -56,10 +56,10 @@ fn parse_companion_mod(cx: ctx, prefix: str, suffix: option::t<str>)\n     -> ([@ast::view_item], [@ast::item], [ast::attribute]) {\n \n     fn companion_file(prefix: str, suffix: option::t<str>) -> str {\n-        alt suffix {\n+        ret alt suffix {\n           option::some(s) { fs::connect(prefix, s) }\n           option::none. { prefix }\n-        } + \".rs\"\n+        } + \".rs\";\n     }\n \n     fn file_exists(path: str) -> bool {"}, {"sha": "a1e4ddbe50238bacbe65a6b895d127f96e782480", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 93, "deletions": 114, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -10,7 +10,12 @@ import util::interner;\n import ast::{node_id, spanned};\n import front::attr;\n \n-tag restriction { UNRESTRICTED; RESTRICT_NO_CALL_EXPRS; RESTRICT_NO_BAR_OP; }\n+tag restriction {\n+    UNRESTRICTED;\n+    RESTRICT_STMT_EXPR;\n+    RESTRICT_NO_CALL_EXPRS;\n+    RESTRICT_NO_BAR_OP;\n+}\n \n tag file_type { CRATE_FILE; SOURCE_FILE; }\n \n@@ -977,35 +982,54 @@ fn parse_syntax_ext_naked(p: parser, lo: uint) -> @ast::expr {\n \n fn parse_dot_or_call_expr(p: parser) -> @ast::expr {\n     let b = parse_bottom_expr(p);\n-    if expr_has_value(b) { parse_dot_or_call_expr_with(p, b) }\n-    else { b }\n+    parse_dot_or_call_expr_with(p, b)\n+}\n+\n+fn permits_call(p: parser) -> bool {\n+    ret p.get_restriction() != RESTRICT_NO_CALL_EXPRS;\n }\n \n fn parse_dot_or_call_expr_with(p: parser, e: @ast::expr) -> @ast::expr {\n     let lo = e.span.lo;\n     let hi = e.span.hi;\n     let e = e;\n-    while true {\n+    while !expr_is_complete(p, e) {\n         alt p.peek() {\n-          token::LPAREN. {\n-            if p.get_restriction() == RESTRICT_NO_CALL_EXPRS {\n-                ret e;\n-            } else {\n-                // Call expr.\n-                let es = parse_seq(token::LPAREN, token::RPAREN,\n-                                   seq_sep(token::COMMA), parse_expr, p);\n-                hi = es.span.hi;\n-                let nd = ast::expr_call(e, es.node, false);\n-                e = mk_expr(p, lo, hi, nd);\n+          // expr(...)\n+          token::LPAREN. when permits_call(p) {\n+            let es = parse_seq(token::LPAREN, token::RPAREN,\n+                               seq_sep(token::COMMA), parse_expr, p);\n+            hi = es.span.hi;\n+            let nd = ast::expr_call(e, es.node, false);\n+            e = mk_expr(p, lo, hi, nd);\n+          }\n+\n+          // expr { || ... }\n+          token::LBRACE. when is_bar(p.look_ahead(1u)) && permits_call(p) {\n+            p.bump();\n+            let blk = parse_fn_block_expr(p);\n+            alt e.node {\n+              ast::expr_call(f, args, false) {\n+                e = @{node: ast::expr_call(f, args + [blk], true)\n+                      with *e};\n+              }\n+              _ {\n+                e = mk_expr(p, lo, p.get_last_hi_pos(),\n+                            ast::expr_call(e, [blk], true));\n+              }\n             }\n           }\n+\n+          // expr[...]\n           token::LBRACKET. {\n             p.bump();\n             let ix = parse_expr(p);\n             hi = ix.span.hi;\n             expect(p, token::RBRACKET);\n             e = mk_expr(p, lo, hi, ast::expr_index(e, ix));\n           }\n+\n+          // expr.f\n           token::DOT. {\n             p.bump();\n             alt p.peek() {\n@@ -1022,6 +1046,7 @@ fn parse_dot_or_call_expr_with(p: parser, e: @ast::expr) -> @ast::expr {\n               t { unexpected(p, t); }\n             }\n           }\n+\n           _ { ret e; }\n         }\n     }\n@@ -1126,7 +1151,7 @@ const ternary_prec: int = 0;\n \n fn parse_more_binops(p: parser, lhs: @ast::expr, min_prec: int) ->\n    @ast::expr {\n-    if !expr_has_value(lhs) { ret lhs; }\n+    if expr_is_complete(p, lhs) { ret lhs; }\n     let peeked = p.peek();\n     if peeked == token::BINOP(token::OR) &&\n        p.get_restriction() == RESTRICT_NO_BAR_OP { ret lhs; }\n@@ -1207,11 +1232,6 @@ fn parse_if_expr_1(p: parser) ->\n         let elexpr = parse_else_expr(p);\n         els = some(elexpr);\n         hi = elexpr.span.hi;\n-    } else if !option::is_none(thn.node.expr) {\n-        let sp = option::get(thn.node.expr).span;\n-        p.span_fatal(sp, \"`if` without `else` can not produce a result\");\n-        //TODO: If a suggestion mechanism appears, suggest that the\n-        //user may have forgotten a ';'\n     }\n     ret {cond: cond, then: thn, els: els, lo: lo, hi: hi};\n }\n@@ -1550,84 +1570,52 @@ fn parse_stmt(p: parser) -> @ast::stmt {\n           }\n         }\n \n-        let maybe_item = parse_item(p, item_attrs);\n-\n-        // If we have attributes then we should have an item\n-        if vec::len(item_attrs) > 0u {\n-            alt maybe_item {\n-              some(_) {/* fallthrough */ }\n-              _ { ret p.fatal(\"expected item\"); }\n-            }\n-        }\n-\n-        alt maybe_item {\n+        alt parse_item(p, item_attrs) {\n           some(i) {\n             let hi = i.span.hi;\n             let decl = @spanned(lo, hi, ast::decl_item(i));\n             ret @spanned(lo, hi, ast::stmt_decl(decl, p.get_id()));\n           }\n-          none. {\n-            // Remainder are line-expr stmts.\n-            let e = parse_expr(p);\n-            // See if it is a block call\n-            if expr_has_value(e) && p.peek() == token::LBRACE &&\n-               is_bar(p.look_ahead(1u)) {\n-                p.bump();\n-                let blk = parse_fn_block_expr(p);\n-                alt e.node {\n-                  ast::expr_call(f, args, false) {\n-                    e = @{node: ast::expr_call(f, args + [blk], true)\n-                        with *e};\n-                  }\n-                  _ {\n-                    e = mk_expr(p, lo, p.get_last_hi_pos(),\n-                                ast::expr_call(e, [blk], true));\n-                  }\n-                }\n-            }\n-            ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_id()));\n-          }\n-          _ { p.fatal(\"expected statement\"); }\n+          none() { /* fallthrough */ }\n         }\n+\n+        // If we have attributes then we should have an item\n+        if vec::len(item_attrs) > 0u {\n+            ret p.fatal(\"expected item\");\n+        }\n+\n+        // Remainder are line-expr stmts.\n+        let e = parse_expr_res(p, RESTRICT_STMT_EXPR);\n+        ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_id()));\n     }\n }\n \n-fn expr_has_value(e: @ast::expr) -> bool {\n+fn expr_is_complete(p: parser, e: @ast::expr) -> bool {\n+    log(debug, (\"expr_is_complete\", p.get_restriction(),\n+                print::pprust::expr_to_str(e),\n+                expr_requires_semi_to_be_stmt(e)));\n+    ret p.get_restriction() == RESTRICT_STMT_EXPR &&\n+        !expr_requires_semi_to_be_stmt(e);\n+}\n+\n+fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n     alt e.node {\n-      ast::expr_if(_, th, els) | ast::expr_if_check(_, th, els) {\n-        if option::is_none(els) { false }\n-        else { !option::is_none(th.node.expr) ||\n-            expr_has_value(option::get(els)) }\n+      ast::expr_if(_, _, _) | ast::expr_if_check(_, _, _)\n+      | ast::expr_alt(_, _) | ast::expr_block(_)\n+      | ast::expr_do_while(_, _) | ast::expr_while(_, _)\n+      | ast::expr_for(_, _, _)\n+      | ast::expr_call(_, _, true) {\n+        false\n       }\n-      ast::expr_alt(_, arms) {\n-        let found_expr = false;\n-        for arm in arms {\n-            if !option::is_none(arm.body.node.expr) { found_expr = true; }\n-        }\n-        found_expr\n-      }\n-      ast::expr_block(blk) | ast::expr_while(_, blk) |\n-      ast::expr_for(_, _, blk) | ast::expr_do_while(blk, _) {\n-        !option::is_none(blk.node.expr)\n-      }\n-      ast::expr_call(_, _, true) { false }\n       _ { true }\n     }\n }\n \n-fn stmt_is_expr(stmt: @ast::stmt) -> bool {\n-    ret alt stmt.node {\n-      ast::stmt_expr(e, _) { expr_has_value(e) }\n-      _ { false }\n-    };\n-}\n-\n fn stmt_to_expr(stmt: @ast::stmt) -> option::t<@ast::expr> {\n-    ret if stmt_is_expr(stmt) {\n-        alt stmt.node {\n-          ast::stmt_expr(e, _) { some(e) }\n-        }\n-    } else { none };\n+    alt stmt.node {\n+      ast::stmt_expr(e, _) { some(e) }\n+      _ { none }\n+    }\n }\n \n fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n@@ -1639,7 +1627,7 @@ fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n             }\n       }\n       ast::stmt_expr(e, _) {\n-        ret expr_has_value(e);\n+        ret expr_requires_semi_to_be_stmt(e);\n       }\n     }\n }\n@@ -1659,14 +1647,10 @@ fn parse_block(p: parser) -> ast::blk {\n }\n \n fn parse_block_no_value(p: parser) -> ast::blk {\n-    let blk = parse_block(p);\n-    if !option::is_none(blk.node.expr) {\n-        let sp = option::get(blk.node.expr).span;\n-        p.span_fatal(sp, \"this block must not have a result\");\n-        //TODO: If a suggestion mechanism appears, suggest that the\n-        //user may have forgotten a ';'\n-    }\n-    ret blk;\n+    // We parse blocks that cannot have a value the same as any other block;\n+    // the type checker will make sure that the tail expression (if any) has\n+    // unit type.\n+    ret parse_block(p);\n }\n \n // Precondition: already parsed the '{' or '#{'\n@@ -1850,34 +1834,29 @@ fn parse_item_iface(p: parser, attrs: [ast::attribute]) -> @ast::item {\n                 ast::item_iface(tps, meths), attrs);\n }\n \n+// Parses three variants (with the initial params always optional):\n+//    impl <T: copy> of to_str for [T] { ... }\n+//    impl name<T> of to_str for [T] { ... }\n+//    impl name<T> for [T] { ... }\n fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n-    let lo = p.get_last_lo_pos(), ident, tps, ifce;\n+    let lo = p.get_last_lo_pos();\n     fn wrap_path(p: parser, pt: @ast::path) -> @ast::ty {\n         @{node: ast::ty_path(pt, p.get_id()), span: pt.span}\n     }\n-    if eat_word(p, \"of\") {\n+    let (ident, tps) = if !is_word(p, \"of\") {\n+        if p.peek() == token::LT { (none, parse_ty_params(p)) }\n+        else { (some(parse_ident(p)), parse_ty_params(p)) }\n+    } else { (none, []) };\n+    let ifce = if eat_word(p, \"of\") {\n         let path = parse_path_and_ty_param_substs(p, false);\n-        tps = vec::map(path.node.types, {|tp|\n-            alt tp.node {\n-              ast::ty_path(pt, _) {\n-                if vec::len(pt.node.idents) == 1u &&\n-                   vec::len(pt.node.types) == 0u {\n-                     ret {ident: pt.node.idents[0], id: p.get_id(),\n-                          bounds: @[]};\n-                }\n-              }\n-              _ {}\n-            }\n-            p.fatal(\"only single-word, parameter-less types allowed here\");\n-        });\n-        ident = path.node.idents[vec::len(path.node.idents)-1u];\n-        ifce = some(wrap_path(p, path));\n-    } else {\n-        ident = parse_ident(p);\n-        tps = parse_ty_params(p);\n-        ifce = if eat_word(p, \"of\") {\n-            some(wrap_path(p, parse_path_and_ty_param_substs(p, false)))\n-        } else { none };\n+        if option::is_none(ident) {\n+            ident = some(path.node.idents[vec::len(path.node.idents) - 1u]);\n+        }\n+        some(wrap_path(p, path))\n+    } else { none };\n+    let ident = alt ident {\n+        some(name) { name }\n+        none. { expect_word(p, \"of\"); fail; }\n     };\n     expect_word(p, \"for\");\n     let ty = parse_ty(p, false), meths = [];"}, {"sha": "da592b6d3c10d014f80a66ba4a32133015c763e6", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -558,11 +558,39 @@ fn print_attribute(s: ps, attr: ast::attribute) {\n     word(s.s, \"]\");\n }\n \n+// An expression that begins with a dual-form statement/expression like `{\n+// ... }-10` would be parsed as `{ ... };-10` unless parentheses are used (ie,\n+// `({...}-10)`).  These parentheses are not, however, preserved by the\n+// parser. This function specifies whether parentheses must be inserted.\n+fn stmt_expr_requires_parens(ex: @ast::expr) -> bool {\n+    fn helper(ex: @ast::expr, inner: bool) -> bool {\n+        alt ex.node {\n+          ast::expr_call(subex, _, _) | ast::expr_binary(_, subex, _) {\n+            be helper(subex, true);\n+          }\n+          _ when !inner { ret false; }\n+          _ { ret !parse::parser::expr_requires_semi_to_be_stmt(ex); }\n+        }\n+    }\n+    ret helper(ex, false);\n+}\n+\n fn print_stmt(s: ps, st: ast::stmt) {\n     maybe_print_comment(s, st.span.lo);\n     alt st.node {\n-      ast::stmt_decl(decl, _) { print_decl(s, decl); }\n-      ast::stmt_expr(expr, _) { space_if_not_bol(s); print_expr(s, expr); }\n+      ast::stmt_decl(decl, _) {\n+        print_decl(s, decl);\n+      }\n+      ast::stmt_expr(expr, _) {\n+        space_if_not_bol(s);\n+        if stmt_expr_requires_parens(expr) {\n+            popen(s);\n+            print_expr(s, expr);\n+            pclose(s);\n+        } else {\n+            print_expr(s, expr);\n+        }\n+      }\n     }\n     if parse::parser::stmt_ends_with_semi(st) { word(s.s, \";\"); }\n     maybe_print_trailing_comment(s, st.span, none::<uint>);"}, {"sha": "1e5b88e1aa65118294e7fd6694f9715a0a9e7bda", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -52,6 +52,7 @@ type visitor<E> =\n       visit_decl: fn@(@decl, E, vt<E>),\n       visit_expr: fn@(@expr, E, vt<E>),\n       visit_ty: fn@(@ty, E, vt<E>),\n+      visit_ty_params: fn@([ty_param], E, vt<E>),\n       visit_constr: fn@(@path, span, node_id, E, vt<E>),\n       visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id, E, vt<E>)};\n \n@@ -68,6 +69,7 @@ fn default_visitor<E>() -> visitor<E> {\n           visit_decl: bind visit_decl::<E>(_, _, _),\n           visit_expr: bind visit_expr::<E>(_, _, _),\n           visit_ty: bind skip_ty::<E>(_, _, _),\n+          visit_ty_params: bind visit_ty_params::<E>(_, _, _),\n           visit_constr: bind visit_constr::<E>(_, _, _, _, _),\n           visit_fn: bind visit_fn::<E>(_, _, _, _, _, _, _)};\n }\n@@ -113,27 +115,27 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         for vi: @view_item in nm.view_items { v.visit_view_item(vi, e, v); }\n         for ni: @native_item in nm.items { v.visit_native_item(ni, e, v); }\n       }\n-      item_ty(t, tps) { v.visit_ty(t, e, v); visit_ty_params(tps, e, v); }\n+      item_ty(t, tps) { v.visit_ty(t, e, v); v.visit_ty_params(tps, e, v); }\n       item_res(decl, tps, body, dtor_id, _) {\n         v.visit_fn(fk_res(i.ident, tps), decl, body, i.span,\n                    dtor_id, e, v);\n       }\n       item_tag(variants, tps) {\n-        visit_ty_params(tps, e, v);\n+        v.visit_ty_params(tps, e, v);\n         for vr: variant in variants {\n             for va: variant_arg in vr.node.args { v.visit_ty(va.ty, e, v); }\n         }\n       }\n       item_obj(ob, tps, _) {\n-        visit_ty_params(tps, e, v);\n+        v.visit_ty_params(tps, e, v);\n         for f: obj_field in ob.fields { v.visit_ty(f.ty, e, v); }\n         for m: @method in ob.methods {\n             v.visit_fn(fk_method(m.ident, m.tps), m.decl, m.body, m.span,\n                        m.id, e, v);\n         }\n       }\n       item_impl(tps, ifce, ty, methods) {\n-        visit_ty_params(tps, e, v);\n+        v.visit_ty_params(tps, e, v);\n         alt ifce { some(ty) { v.visit_ty(ty, e, v); } _ {} }\n         v.visit_ty(ty, e, v);\n         for m in methods {\n@@ -142,7 +144,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         }\n       }\n       item_iface(tps, methods) {\n-        visit_ty_params(tps, e, v);\n+        v.visit_ty_params(tps, e, v);\n         for m in methods {\n             for a in m.decl.inputs { v.visit_ty(a.ty, e, v); }\n             v.visit_ty(m.decl.output, e, v);\n@@ -217,7 +219,7 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n fn visit_native_item<E>(ni: @native_item, e: E, v: vt<E>) {\n     alt ni.node {\n       native_item_fn(fd, tps) {\n-        visit_ty_params(tps, e, v);\n+        v.visit_ty_params(tps, e, v);\n         visit_fn_decl(fd, e, v);\n       }\n       native_item_ty. { }\n@@ -246,7 +248,7 @@ fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n fn visit_fn<E>(fk: fn_kind, decl: fn_decl, body: blk, _sp: span,\n                _id: node_id, e: E, v: vt<E>) {\n     visit_fn_decl(decl, e, v);\n-    visit_ty_params(tps_of_fn(fk), e, v);\n+    v.visit_ty_params(tps_of_fn(fk), e, v);\n     v.visit_block(body, e, v);\n }\n \n@@ -414,6 +416,7 @@ type simple_visitor =\n       visit_decl: fn@(@decl),\n       visit_expr: fn@(@expr),\n       visit_ty: fn@(@ty),\n+      visit_ty_params: fn@([ty_param]),\n       visit_constr: fn@(@path, span, node_id),\n       visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id)};\n \n@@ -432,6 +435,7 @@ fn default_simple_visitor() -> simple_visitor {\n           visit_decl: fn(_d: @decl) { },\n           visit_expr: fn(_e: @expr) { },\n           visit_ty: simple_ignore_ty,\n+          visit_ty_params: fn(_ps: [ty_param]) {},\n           visit_constr: fn(_p: @path, _sp: span, _id: node_id) { },\n           visit_fn: fn(_fk: fn_kind, _d: fn_decl, _b: blk, _sp: span,\n                        _id: node_id) { }\n@@ -488,6 +492,10 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(ty);\n         visit_ty(ty, e, v);\n     }\n+    fn v_ty_params(f: fn@([ty_param]), ps: [ty_param], &&e: (), v: vt<()>) {\n+        f(ps);\n+        visit_ty_params(ps, e, v);\n+    }\n     fn v_constr(f: fn@(@path, span, node_id), pt: @path, sp: span,\n                 id: node_id, &&e: (), v: vt<()>) {\n         f(pt, sp, id);\n@@ -517,6 +525,7 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n                 visit_decl: bind v_decl(v.visit_decl, _, _, _),\n                 visit_expr: bind v_expr(v.visit_expr, _, _, _),\n                 visit_ty: visit_ty,\n+                visit_ty_params: bind v_ty_params(v.visit_ty_params, _, _, _),\n                 visit_constr: bind v_constr(v.visit_constr, _, _, _, _, _),\n                 visit_fn: bind v_fn(v.visit_fn, _, _, _, _, _, _, _)\n                });"}, {"sha": "d4c01edbb15a4c3b22ff5b94014bb604d990d75d", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -19,10 +19,6 @@ fn mode_str(m: ty::mode) -> str {\n     }\n }\n \n-fn mode_str_1(m: ty::mode) -> str {\n-    alt m { ast::by_ref. { \"ref\" } _ { mode_str(m) } }\n-}\n-\n fn ty_to_str(cx: ctxt, typ: t) -> str {\n     fn fn_input_to_str(cx: ctxt, input: {mode: middle::ty::mode, ty: t}) ->\n        str {\n@@ -95,6 +91,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n       ty_str. { \"str\" }\n       ty_box(tm) { \"@\" + mt_to_str(cx, tm) }\n       ty_uniq(tm) { \"~\" + mt_to_str(cx, tm) }\n+      ty_ptr(tm) { \"*\" + mt_to_str(cx, tm) }\n       ty_vec(tm) { \"[\" + mt_to_str(cx, tm) + \"]\" }\n       ty_type. { \"type\" }\n       ty_rec(elems) {"}, {"sha": "39ecb909a8585ca369a81f02c334153691343e0a", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -163,6 +163,7 @@ fn maybe_with_lib_path<T>(path: str, f: fn@() -> T) -> T {\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n fn maybe_with_lib_path<T>(_path: str, f: fn@() -> T) -> T {\n     f()\n }"}, {"sha": "fefa9d7e6172032e45fcf7d87cd618c6f0d32286", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -309,6 +309,7 @@ fn program_output(cx: cx, testfile: str, lib_path: str, prog: str,\n // Linux and mac don't require adjusting the library search path\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n fn make_cmdline(_libpath: str, prog: str, args: [str]) -> str {\n     #fmt[\"%s %s\", prog, str::connect(args, \" \")]\n }"}, {"sha": "eb8460374829b8d9bf011e744cfc9633adb8aaa0", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -17,6 +17,7 @@ fn make_new_path(path: str) -> str {\n }\n \n #[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"freebsd\")]\n fn lib_path_env_var() -> str { \"LD_LIBRARY_PATH\" }\n \n #[cfg(target_os = \"macos\")]\n@@ -27,6 +28,7 @@ fn lib_path_env_var() -> str { \"PATH\" }\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n fn path_div() -> str { \":\" }\n \n #[cfg(target_os = \"win32\")]"}, {"sha": "673facfe70a7f104f15d93e73ab4c6180aab0724", "filename": "src/etc/snapshot.py", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fetc%2Fsnapshot.py", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Fetc%2Fsnapshot.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsnapshot.py?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -33,7 +33,13 @@ def scrub(b):\n               \"lib/std-*.dll\",\n               \"lib/rustc-*.dll\",\n               \"lib/rustrt.dll\",\n-              \"lib/rustllvm.dll\"]\n+              \"lib/rustllvm.dll\"],\n+    \"freebsd\": [\"bin/rustc\",\n+                \"lib/libcore-*.so\",\n+                \"lib/libstd-*.so\",\n+                \"lib/librustc-*.so\",\n+                \"lib/librustrt.so\",\n+                \"lib/librustllvm.so\"]\n     }\n \n def parse_line(n, line):\n@@ -73,6 +79,8 @@ def get_kernel(triple):\n         return \"winnt\"\n     if os_name == \"darwin\":\n         return \"macos\"\n+    if os_name == \"freebsd\":\n+        return \"freebsd\"\n     return \"linux\"\n \n def get_cpu(triple):"}, {"sha": "5475e695a79906df42916f13c5845de9945ef6b8", "filename": "src/libcore/char.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -41,7 +41,7 @@ export is_alphabetic,\n        is_XID_start, is_XID_continue,\n        is_lowercase, is_uppercase,\n        is_whitespace, is_alphanumeric,\n-       to_digit, maybe_digit, cmp;\n+       to_digit, to_lower, to_upper, maybe_digit, cmp;\n \n import is_alphabetic = unicode::derived_property::Alphabetic;\n import is_XID_start = unicode::derived_property::XID_Start;\n@@ -122,7 +122,7 @@ pure fn to_digit(c: char) -> u8 unsafe {\n }\n \n /*\n- Function: to_digit\n+ Function: maybe_digit\n \n  Convert a char to the corresponding digit. Returns none when the\n  character is not a valid hexadecimal digit.\n@@ -136,6 +136,34 @@ pure fn maybe_digit(c: char) -> option::t<u8> {\n     }\n }\n \n+/*\n+ Function: to_lower\n+\n+ Convert a char to the corresponding lower case.\n+\n+ FIXME: works only on ASCII\n+*/\n+pure fn to_lower(c: char) -> char {\n+    alt c {\n+      'A' to 'Z' { ((c as u8) + 32u8) as char }\n+      _ { c }\n+    }\n+}\n+\n+/*\n+ Function: to_upper\n+\n+ Convert a char to the corresponding upper case.\n+\n+ FIXME: works only on ASCII\n+*/\n+pure fn to_upper(c: char) -> char {\n+    alt c {\n+      'a' to 'z' { ((c as u8) - 32u8) as char }\n+      _ { c }\n+    }\n+}\n+\n /*\n  Function: cmp\n "}, {"sha": "4f3c5a8d68b881ee0eb477bcb09cc01a89c4ef6a", "filename": "src/libcore/cmath.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmath.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -5,6 +5,9 @@ import ctypes::c_int;\n import ctypes::c_float;\n import ctypes::c_double;\n \n+// function names are almost identical to C's libmath, a few have been\n+// renamed, grep for \"rename:\"\n+\n #[link_name = \"m\"]\n #[abi = \"cdecl\"]\n native mod c_double {\n@@ -26,8 +29,10 @@ native mod c_double {\n     pure fn expm1(n: c_double) -> c_double;\n     pure fn exp2(n: c_double) -> c_double;\n     #[link_name=\"fabs\"] pure fn abs(n: c_double) -> c_double;\n-    #[link_name=\"fdim\"] pure fn sub_pos(a: c_double, b: c_double) -> c_double;\n+    // rename: for clarity and consistency with add/sub/mul/div\n+    #[link_name=\"fdim\"] pure fn abs_sub(a: c_double, b: c_double) -> c_double;\n     pure fn floor(n: c_double) -> c_double;\n+    // rename: for clarity and consistency with add/sub/mul/div\n     #[link_name=\"fma\"] pure fn mul_add(a: c_double, b: c_double,\n                                        c: c_double) -> c_double;\n     #[link_name=\"fmax\"] pure fn fmax(a: c_double, b: c_double) -> c_double;\n@@ -38,17 +43,26 @@ native mod c_double {\n     pure fn ldexp(x: c_double, n: c_int) -> c_double;\n     #[link_name=\"lgamma_r\"] pure fn lgamma(n: c_double,\n                                            &sign: c_int) -> c_double;\n+    // renamed: log is a reserved keyword; ln seems more natural, too\n     #[link_name=\"log\"] pure fn ln(n: c_double) -> c_double;\n-    pure fn logb(n: c_double) -> c_double;\n+    // renamed: \"logb\" /often/ is confused for log2 by beginners\n+    #[link_name=\"logb\"] pure fn log_radix(n: c_double) -> c_double;\n+    // renamed: to be consitent with log as ln\n     #[link_name=\"log1p\"] pure fn ln1p(n: c_double) -> c_double;\n     pure fn log10(n: c_double) -> c_double;\n+    #[cfg(target_os=\"linux\")]\n+    #[cfg(target_os=\"macos\")]\n+    #[cfg(target_os=\"win32\")]\n     pure fn log2(n: c_double) -> c_double;\n-    pure fn ilogb(n: c_double) -> c_int;\n+    #[link_name=\"ilogb\"] pure fn ilogradix(n: c_double) -> c_int;\n     pure fn modf(n: c_double, &iptr: c_double) -> c_double;\n     pure fn pow(n: c_double, e: c_double) -> c_double;\n-    pure fn rint(n: c_double) -> c_double;\n+// FIXME enable when rounding modes become available\n+//    pure fn rint(n: c_double) -> c_double;\n     pure fn round(n: c_double) -> c_double;\n-    pure fn scalbn(n: c_double, i: c_int) -> c_double;\n+    // rename: for consistency with logradix\n+    #[link_name=\"scalbn\"] pure fn ldexp_radix(n: c_double, i: c_int) ->\n+        c_double;\n     pure fn sin(n: c_double) -> c_double;\n     pure fn sinh(n: c_double) -> c_double;\n     pure fn sqrt(n: c_double) -> c_double;\n@@ -90,7 +104,7 @@ native mod c_float {\n     #[link_name=\"expm1f\"]pure fn expm1(n: c_float) -> c_float;\n     #[link_name=\"exp2f\"] pure fn exp2(n: c_float) -> c_float;\n     #[link_name=\"fabsf\"] pure fn abs(n: c_float) -> c_float;\n-    #[link_name=\"fdimf\"] pure fn sub_pos(a: c_float, b: c_float) -> c_float;\n+    #[link_name=\"fdimf\"] pure fn abs_sub(a: c_float, b: c_float) -> c_float;\n     #[link_name=\"floorf\"] pure fn floor(n: c_float) -> c_float;\n     #[link_name=\"frexpf\"] pure fn frexp(n: c_float,\n                                         &value: c_int) -> c_float;\n@@ -105,17 +119,21 @@ native mod c_float {\n     #[link_name=\"lgammaf_r\"] pure fn lgamma(n: c_float,\n                                             &sign: c_int) -> c_float;\n     #[link_name=\"logf\"] pure fn ln(n: c_float) -> c_float;\n-    #[link_name=\"logbf\"] pure fn logb(n: c_float) -> c_float;\n+    #[link_name=\"logbf\"] pure fn log_radix(n: c_float) -> c_float;\n     #[link_name=\"log1pf\"] pure fn ln1p(n: c_float) -> c_float;\n+    #[cfg(target_os=\"linux\")]\n+    #[cfg(target_os=\"macos\")]\n+    #[cfg(target_os=\"win32\")]\n     #[link_name=\"log2f\"] pure fn log2(n: c_float) -> c_float;\n     #[link_name=\"log10f\"] pure fn log10(n: c_float) -> c_float;\n-    #[link_name=\"ilogbf\"] pure fn ilogb(n: c_float) -> c_int;\n+    #[link_name=\"ilogbf\"] pure fn ilog_radix(n: c_float) -> c_int;\n     #[link_name=\"modff\"] pure fn modf(n: c_float,\n                                       &iptr: c_float) -> c_float;\n     #[link_name=\"powf\"] pure fn pow(n: c_float, e: c_float) -> c_float;\n-    #[link_name=\"rintf\"] pure fn rint(n: c_float) -> c_float;\n+// FIXME enable when rounding modes become available\n+//    #[link_name=\"rintf\"] pure fn rint(n: c_float) -> c_float;\n     #[link_name=\"roundf\"] pure fn round(n: c_float) -> c_float;\n-    #[link_name=\"scalbnf\"] pure fn scalbn(n: c_float, i: c_int) -> c_float;\n+    #[link_name=\"scalbnf\"] pure fn ldexp_radix(n: c_float, i: c_int) -> c_float;\n     #[link_name=\"sinf\"] pure fn sin(n: c_float) -> c_float;\n     #[link_name=\"sinhf\"] pure fn sinh(n: c_float) -> c_float;\n     #[link_name=\"sqrtf\"] pure fn sqrt(n: c_float) -> c_float;"}, {"sha": "f3571ea5bcf7d51d635799b4bb79506be13c3169", "filename": "src/libcore/either.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -103,6 +103,24 @@ pure fn to_result<copy T, copy U>(eith: t<T, U>) -> result::t<U, T> {\n     }\n }\n \n+/*\n+Function: is_left\n+\n+Checks whether the given value is a left\n+*/\n+pure fn is_left<T, U>(eith: t<T, U>) -> bool {\n+    alt eith { left(_) { true } _ { false } }\n+}\n+\n+/*\n+Function: is_left\n+\n+Checks whether the given value is a right\n+*/\n+pure fn is_right<T, U>(eith: t<T, U>) -> bool {\n+    alt eith { right(_) { true } _ { false } }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "7c7d45694e50bdc48c1f56cca4ff2057613c63ea", "filename": "src/libcore/f32.rs", "status": "modified", "additions": 51, "deletions": 8, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff32.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -16,6 +16,8 @@ type t = f32;\n \n // PORT check per architecture\n \n+// FIXME obtain these in a different way\n+\n const radix: uint = 2u;\n \n const mantissa_digits: uint = 24u;\n@@ -42,7 +44,7 @@ const infinity: f32 = 1.0_f32/0.0_f32;\n const neg_infinity: f32 = -1.0_f32/0.0_f32;\n \n /* Predicate: isNaN */\n-pure fn isNaN(f: f32) -> bool { f != f }\n+pure fn is_NaN(f: f32) -> bool { f != f }\n \n /* Function: add */\n pure fn add(x: f32, y: f32) -> f32 { ret x + y; }\n@@ -77,29 +79,32 @@ pure fn ge(x: f32, y: f32) -> bool { ret x >= y; }\n /* Predicate: gt */\n pure fn gt(x: f32, y: f32) -> bool { ret x > y; }\n \n+// FIXME replace the predicates below with llvm intrinsics or calls\n+// to the libmath macros in the rust runtime for performance\n+\n /*\n-Predicate: positive\n+Predicate: is_positive\n \n Returns true if `x` is a positive number, including +0.0f320 and +Infinity.\n  */\n-pure fn positive(x: f32) -> bool\n+pure fn is_positive(x: f32) -> bool\n     { ret x > 0.0f32 || (1.0f32/x) == infinity; }\n \n /*\n-Predicate: negative\n+Predicate: is_negative\n \n Returns true if `x` is a negative number, including -0.0f320 and -Infinity.\n  */\n-pure fn negative(x: f32) -> bool\n+pure fn is_negative(x: f32) -> bool\n     { ret x < 0.0f32 || (1.0f32/x) == neg_infinity; }\n \n /*\n-Predicate: nonpositive\n+Predicate: is_nonpositive\n \n Returns true if `x` is a negative number, including -0.0f320 and -Infinity.\n (This is the same as `f32::negative`.)\n */\n-pure fn nonpositive(x: f32) -> bool {\n+pure fn is_nonpositive(x: f32) -> bool {\n   ret x < 0.0f32 || (1.0f32/x) == neg_infinity;\n }\n \n@@ -109,10 +114,39 @@ Predicate: nonnegative\n Returns true if `x` is a positive number, including +0.0f320 and +Infinity.\n (This is the same as `f32::positive`.)\n */\n-pure fn nonnegative(x: f32) -> bool {\n+pure fn is_nonnegative(x: f32) -> bool {\n   ret x > 0.0f32 || (1.0f32/x) == infinity;\n }\n \n+/*\n+Predicate: is_zero\n+\n+Returns true if `x` is a zero number (positive or negative zero)\n+*/\n+pure fn is_zero(x: f32) -> bool {\n+    ret x == 0.0f32 || x == -0.0f32;\n+}\n+\n+/*\n+Predicate: is_infinite\n+\n+Returns true if `x`is an infinite numer\n+*/\n+pure fn is_infinite(x: f32) -> bool {\n+    ret x == infinity || x == neg_infinity;\n+}\n+\n+/*\n+Predicate: is_finite\n+\n+Returns true if `x`is a finite numer\n+*/\n+pure fn is_finite(x: f32) -> bool {\n+    ret !(is_nan(x) || is_infinite(x));\n+}\n+\n+// FIXME add is_normal, is_subnormal, and fpclassify\n+\n /* Module: consts */\n mod consts {\n \n@@ -208,6 +242,15 @@ mod consts {\n     const ln_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n+pure fn logarithm(n: f32, b: f32) -> f32 {\n+    ret ln(n) / ln(b);\n+}\n+\n+#[cfg(target_os=\"freebsd\")]\n+pure fn log2(n: f32) -> f32 {\n+    ret ln(n) / consts::ln_2;\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "058d662010604452b5a8e803853a3fd48c6b5276", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 49, "deletions": 9, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -16,6 +16,8 @@ type t = f64;\n \n // PORT check per architecture\n \n+// FIXME obtain these in a different way\n+\n const radix: uint = 2u;\n \n const mantissa_digits: uint = 53u;\n@@ -42,7 +44,7 @@ const infinity: f64 = 1.0_f64/0.0_f64;\n const neg_infinity: f64 = -1.0_f64/0.0_f64;\n \n /* Predicate: isNaN */\n-pure fn isNaN(f: f64) -> bool { f != f }\n+pure fn is_NaN(f: f64) -> bool { f != f }\n \n /* Function: add */\n pure fn add(x: f64, y: f64) -> f64 { ret x + y; }\n@@ -78,41 +80,70 @@ pure fn ge(x: f64, y: f64) -> bool { ret x >= y; }\n pure fn gt(x: f64, y: f64) -> bool { ret x > y; }\n \n /*\n-Predicate: positive\n+Predicate: is_positive\n \n Returns true if `x` is a positive number, including +0.0f640 and +Infinity.\n  */\n-pure fn positive(x: f64) -> bool\n+pure fn is_positive(x: f64) -> bool\n     { ret x > 0.0f64 || (1.0f64/x) == infinity; }\n \n /*\n-Predicate: negative\n+Predicate: is_negative\n \n Returns true if `x` is a negative number, including -0.0f640 and -Infinity.\n  */\n-pure fn negative(x: f64) -> bool\n+pure fn is_negative(x: f64) -> bool\n     { ret x < 0.0f64 || (1.0f64/x) == neg_infinity; }\n \n /*\n-Predicate: nonpositive\n+Predicate: is_nonpositive\n \n Returns true if `x` is a negative number, including -0.0f640 and -Infinity.\n (This is the same as `f64::negative`.)\n */\n-pure fn nonpositive(x: f64) -> bool {\n+pure fn is_nonpositive(x: f64) -> bool {\n   ret x < 0.0f64 || (1.0f64/x) == neg_infinity;\n }\n \n /*\n-Predicate: nonnegative\n+Predicate: is_nonnegative\n \n Returns true if `x` is a positive number, including +0.0f640 and +Infinity.\n (This is the same as `f64::positive`.)\n */\n-pure fn nonnegative(x: f64) -> bool {\n+pure fn is_nonnegative(x: f64) -> bool {\n   ret x > 0.0f64 || (1.0f64/x) == infinity;\n }\n \n+/*\n+Predicate: is_zero\n+\n+Returns true if `x` is a zero number (positive or negative zero)\n+*/\n+pure fn is_zero(x: f64) -> bool {\n+    ret x == 0.0f64 || x == -0.0f64;\n+}\n+\n+/*\n+Predicate: is_infinite\n+\n+Returns true if `x`is an infinite numer\n+*/\n+pure fn is_infinite(x: f64) -> bool {\n+    ret x == infinity || x == neg_infinity;\n+}\n+\n+/*\n+Predicate: is_finite\n+\n+Returns true if `x`is a finite numer\n+*/\n+pure fn is_finite(x: f64) -> bool {\n+    ret !(is_nan(x) || is_infinite(x));\n+}\n+\n+// FIXME add is_normal, is_subnormal, and fpclassify\n+\n /* Module: consts */\n mod consts {\n \n@@ -208,6 +239,15 @@ mod consts {\n     const ln_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n+pure fn logarithm(n: f64, b: f64) -> f64 {\n+    ret ln(n) / ln(b);\n+}\n+\n+#[cfg(target_os=\"freebsd\")]\n+pure fn log2(n: f64) -> f64 {\n+    ret ln(n) / consts::ln_2;\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "e0a137ca9e8483593d6024a521b2ccfe5c21cd39", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -36,7 +36,7 @@ pure fn get<copy T>(opt: t<T>) -> T {\n \n /*\n */\n-fn map<T, U>(opt: t<T>, f: block(T) -> U) -> t<U> {\n+fn map<T, copy U>(opt: t<T>, f: block(T) -> U) -> t<U> {\n     alt opt { some(x) { some(f(x)) } none. { none } }\n }\n \n@@ -61,7 +61,7 @@ Function: from_maybe\n \n Returns the contained value or a default\n */\n-pure fn from_maybe<T>(def: T, opt: t<T>) -> T {\n+pure fn from_maybe<copy T>(def: T, opt: t<T>) -> T {\n     alt opt { some(x) { x } none. { def } }\n }\n \n@@ -70,7 +70,7 @@ Function: maybe\n \n Applies a function to the contained value or returns a default\n */\n-fn maybe<T, U>(def: U, opt: t<T>, f: block(T) -> U) -> U {\n+fn maybe<T, copy U>(def: U, opt: t<T>, f: block(T) -> U) -> U {\n     alt opt { none. { def } some(t) { f(t) } }\n }\n "}, {"sha": "91038474eadd4c4703ae12a8f22630607b664550", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -37,7 +37,7 @@ Failure:\n \n If the result is an error\n */\n-fn get<T, U>(res: t<T, U>) -> T {\n+fn get<copy T, U>(res: t<T, U>) -> T {\n     alt res {\n       ok(t) { t }\n       err(_) {\n@@ -57,7 +57,7 @@ Failure:\n \n If the result is not an error\n */\n-fn get_err<T, U>(res: t<T, U>) -> U {\n+fn get_err<T, copy U>(res: t<T, U>) -> U {\n     alt res {\n       err(u) { u }\n       ok(_) {"}, {"sha": "cba9b11cb3d3888308f68cc6ee434502d2f9dc39", "filename": "src/libcore/str.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -7,12 +7,12 @@ String manipulation.\n export eq, lteq, hash, is_empty, is_not_empty, is_whitespace, byte_len,\n        byte_len_range, index,\n        rindex, find, starts_with, ends_with, substr, slice, split, splitn,\n-       split_str, concat, connect, to_upper, replace, char_slice, trim_left,\n-       trim_right, trim, unshift_char, shift_char, pop_char, push_char,\n-       is_utf8, from_chars, to_chars, char_len, char_len_range, char_at,\n-       bytes, is_ascii, shift_byte, pop_byte,\n+       split_str, concat, connect, to_lower, to_upper, replace, char_slice,\n+       trim_left, trim_right, trim, unshift_char, shift_char, pop_char,\n+       push_char, is_utf8, from_chars, to_chars, char_len, char_len_range,\n+       char_at, bytes, is_ascii, shift_byte, pop_byte,\n        unsafe_from_byte, unsafe_from_bytes, from_char, char_range_at,\n-       str_from_cstr, sbuf, as_buf, push_byte, utf8_char_width, safe_slice,\n+       from_cstr, sbuf, as_buf, push_byte, utf8_char_width, safe_slice,\n        contains, iter_chars, loop_chars, loop_chars_sub,\n        escape;\n \n@@ -116,14 +116,7 @@ Function: is_whitespace\n Returns true if the string contains only whitespace\n */\n fn is_whitespace(s: str) -> bool {\n-    let i = 0u;\n-    let len = char_len(s);\n-    while i < len {\n-        // FIXME: This is not how char_at works\n-        if !char::is_whitespace(char_at(s, i)) { ret false; }\n-        i += 1u;\n-    }\n-    ret true;\n+    ret loop_chars(s, char::is_whitespace);\n }\n \n /*\n@@ -832,23 +825,27 @@ fn connect(v: [str], sep: str) -> str {\n     ret s;\n }\n \n-// FIXME: This only handles ASCII\n+/*\n+Function: to_lower\n+\n+Convert a string to lowercase\n+*/\n+fn to_lower(s: str) -> str {\n+    let outstr = \"\";\n+    iter_chars(s) { |c|\n+        push_char(outstr, char::to_lower(c));\n+    }\n+    ret outstr;\n+}\n /*\n Function: to_upper\n \n Convert a string to uppercase\n */\n fn to_upper(s: str) -> str {\n     let outstr = \"\";\n-    let ascii_a = 'a' as u8;\n-    let ascii_z = 'z' as u8;\n-    let diff = 32u8;\n-    for byte: u8 in s {\n-        let next;\n-        if ascii_a <= byte && byte <= ascii_z {\n-            next = byte - diff;\n-        } else { next = byte; }\n-        push_byte(outstr, next);\n+    iter_chars(s) { |c|\n+        push_char(outstr, char::to_upper(c));\n     }\n     ret outstr;\n }\n@@ -976,11 +973,11 @@ fn as_buf<T>(s: str, f: block(sbuf) -> T) -> T unsafe {\n }\n \n /*\n-Function: str_from_cstr\n+Function: from_cstr\n \n Create a Rust string from a null-terminated C string\n */\n-unsafe fn str_from_cstr(cstr: sbuf) -> str {\n+unsafe fn from_cstr(cstr: sbuf) -> str {\n     let res = \"\";\n     let start = cstr;\n     let curr = start;"}, {"sha": "0c1db7119af8e1e607bf800930cfde4cdd5728e0", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -742,6 +742,17 @@ fn iter<T>(v: [const T], f: block(T)) {\n     iteri(v) { |_i, v| f(v) }\n }\n \n+/*\n+Function: iter2\n+\n+Iterates over two vectors in parallel\n+\n+*/\n+fn iter2<U, T>(v: [U], v2: [T], f: block(U, T)) {\n+    let i = 0;\n+    for elt in v { f(elt, v2[i]); i += 1; }\n+}\n+\n /*\n Function: iteri\n "}, {"sha": "8da26c55b105547a97b1371b34d5f0eb72c2e603", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -57,7 +57,7 @@ fn create<copy T>() -> t<T> {\n \n         ret rv;\n     }\n-    fn get<T>(elts: [mutable cell<T>], i: uint) -> T {\n+    fn get<copy T>(elts: [mutable cell<T>], i: uint) -> T {\n         ret alt elts[i] { option::some(t) { t } _ { fail } };\n     }\n     obj deque<copy T>(mutable nelts: uint,"}, {"sha": "4fecf418213e3990f833083132ffe6554b897f85", "filename": "src/libstd/freebsd_os.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Ffreebsd_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Ffreebsd_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffreebsd_os.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,155 @@\n+/*\n+Module: os\n+\n+TODO: Restructure and document\n+*/\n+\n+import core::option;\n+import core::ctypes::*;\n+\n+export libc;\n+export libc_constants;\n+export pipe;\n+export fd_FILE;\n+export close;\n+export fclose;\n+export waitpid;\n+export getcwd;\n+export exec_suffix;\n+export target_os;\n+export dylib_filename;\n+export get_exe_path;\n+export fsync_fd;\n+\n+// FIXME Somehow merge stuff duplicated here and macosx_os.rs. Made difficult\n+// by https://github.com/graydon/rust/issues#issue/268\n+\n+#[link_name = \"\"]               // FIXME remove after #[nolink] is snapshotted\n+#[nolink]\n+#[abi = \"cdecl\"]\n+native mod libc {\n+    fn read(fd: fd_t, buf: *u8, count: size_t) -> ssize_t;\n+    fn write(fd: fd_t, buf: *u8, count: size_t) -> ssize_t;\n+    fn fread(buf: *u8, size: size_t, n: size_t, f: libc::FILE) -> size_t;\n+    fn fwrite(buf: *u8, size: size_t, n: size_t, f: libc::FILE) -> size_t;\n+    fn open(s: str::sbuf, flags: c_int, mode: unsigned) -> fd_t;\n+    fn close(fd: fd_t) -> c_int;\n+    type FILE;\n+    fn fopen(path: str::sbuf, mode: str::sbuf) -> FILE;\n+    fn fdopen(fd: fd_t, mode: str::sbuf) -> FILE;\n+    fn fclose(f: FILE);\n+    fn fflush(f: FILE) -> c_int;\n+    fn fsync(fd: fd_t) -> c_int;\n+    fn fileno(f: FILE) -> fd_t;\n+    fn fgetc(f: FILE) -> c_int;\n+    fn ungetc(c: c_int, f: FILE);\n+    fn feof(f: FILE) -> c_int;\n+    fn fseek(f: FILE, offset: long, whence: c_int) -> c_int;\n+    fn ftell(f: FILE) -> long;\n+    type dir;\n+    fn opendir(d: str::sbuf) -> dir;\n+    fn closedir(d: dir) -> c_int;\n+    type dirent;\n+    fn readdir(d: dir) -> dirent;\n+    fn getenv(n: str::sbuf) -> str::sbuf;\n+    fn setenv(n: str::sbuf, v: str::sbuf, overwrite: c_int) -> c_int;\n+    fn unsetenv(n: str::sbuf) -> c_int;\n+    fn pipe(buf: *mutable fd_t) -> c_int;\n+    fn waitpid(pid: pid_t, &status: c_int, options: c_int) -> pid_t;\n+    fn readlink(path: str::sbuf, buf: str::sbuf, bufsize: size_t) -> ssize_t;\n+    fn mkdir(path: str::sbuf, mode: c_int) -> c_int;\n+    fn rmdir(path: str::sbuf) -> c_int;\n+    fn chdir(path: str::sbuf) -> c_int;\n+\n+    fn sysctl(name: *c_int, namelen: c_uint,\n+              oldp: *u8, &oldlenp: size_t,\n+              newp: *u8, newlen: size_t) -> c_int;\n+}\n+\n+mod libc_constants {\n+    const O_RDONLY: c_int = 0i32;\n+    const O_WRONLY: c_int = 1i32;\n+    const O_RDWR: c_int   = 2i32;\n+    const O_APPEND: c_int = 8i32;\n+    const O_CREAT: c_int  = 512i32;\n+    const O_EXCL: c_int   = 2048i32;\n+    const O_TRUNC: c_int  = 1024i32;\n+    const O_TEXT: c_int   = 0i32;     // nonexistent in FreeBSD libc\n+    const O_BINARY: c_int = 0i32;     // nonexistent in FreeBSD libc\n+\n+    const S_IRUSR: unsigned = 256u32;\n+    const S_IWUSR: unsigned = 128u32;\n+\n+    const CTL_KERN: c_int = 1i32;\n+    const KERN_PROC: c_int = 14i32;\n+    const KERN_PROC_PATHNAME: c_int = 12i32;\n+}\n+\n+fn pipe() -> {in: fd_t, out: fd_t} {\n+    let fds = {mutable in: 0i32, mutable out: 0i32};\n+    assert (os::libc::pipe(ptr::mut_addr_of(fds.in)) == 0i32);\n+    ret {in: fds.in, out: fds.out};\n+}\n+\n+fn fd_FILE(fd: fd_t) -> libc::FILE {\n+    ret str::as_buf(\"r\", {|modebuf| libc::fdopen(fd, modebuf) });\n+}\n+\n+fn close(fd: fd_t) -> c_int {\n+    libc::close(fd)\n+}\n+\n+fn fclose(file: libc::FILE) {\n+    libc::fclose(file)\n+}\n+\n+fn fsync_fd(fd: fd_t, _l: io::fsync::level) -> c_int {\n+    ret libc::fsync(fd);\n+}\n+\n+fn waitpid(pid: pid_t) -> i32 {\n+    let status = 0i32;\n+    assert (os::libc::waitpid(pid, status, 0i32) != -1i32);\n+    ret status;\n+}\n+\n+#[abi = \"cdecl\"]\n+native mod rustrt {\n+    fn rust_getcwd() -> str;\n+}\n+\n+fn getcwd() -> str { ret rustrt::rust_getcwd(); }\n+\n+fn exec_suffix() -> str { ret \"\"; }\n+\n+fn target_os() -> str { ret \"freebsd\"; }\n+\n+fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".so\"; }\n+\n+/// Returns the directory containing the running program\n+/// followed by a path separator\n+fn get_exe_path() -> option::t<fs::path> unsafe {\n+    let bufsize = 1023u;\n+    let path = str::unsafe_from_bytes(vec::init_elt(0u8, bufsize));\n+    let mib = [libc_constants::CTL_KERN,\n+               libc_constants::KERN_PROC,\n+               libc_constants::KERN_PROC_PATHNAME, -1i32];\n+    ret str::as_buf(path, { |path_buf|\n+        if libc::sysctl(vec::unsafe::to_ptr(mib),\n+                        vec::len(mib) as c_uint,\n+                        path_buf, bufsize,\n+                        ptr::null(), 0u) == 0i32 {\n+            option::some(fs::dirname(path) + fs::path_sep())\n+        } else {\n+            option::none\n+        }\n+    });\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:"}, {"sha": "330305651436549b6bc19883742875525154f283", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -148,6 +148,7 @@ fn make_dir(p: path, mode: ctypes::c_int) -> bool {\n \n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n     fn mkdir(_p: path, _mode: ctypes::c_int) -> bool {\n         ret str::as_buf(_p, {|buf| os::libc::mkdir(buf, _mode) == 0i32 });\n     }\n@@ -186,6 +187,7 @@ fn remove_dir(p: path) -> bool {\n \n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n     fn rmdir(_p: path) -> bool {\n         ret str::as_buf(_p, {|buf| os::libc::rmdir(buf) == 0i32 });\n     }\n@@ -201,6 +203,7 @@ fn change_dir(p: path) -> bool {\n \n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n     fn chdir(_p: path) -> bool {\n         ret str::as_buf(_p, {|buf| os::libc::chdir(buf) == 0i32 });\n     }\n@@ -367,6 +370,7 @@ fn normalize(p: path) -> path {\n \n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n     fn reabsolute(orig: path, new: path) -> path {\n         if path_is_absolute(orig) {\n             path_sep() + new"}, {"sha": "c1312ad460803710911aa7d0d9452f27e9cb5225", "filename": "src/libstd/generic_os.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgeneric_os.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -28,18 +28,20 @@ fn setenv(n: str, v: str) { }\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n fn getenv(n: str) -> option::t<str> unsafe {\n     let s = str::as_buf(n, {|buf| os::libc::getenv(buf) });\n     ret if unsafe::reinterpret_cast(s) == 0 {\n             option::none::<str>\n         } else {\n             let s = unsafe::reinterpret_cast(s);\n-            option::some::<str>(str::str_from_cstr(s))\n+            option::some::<str>(str::from_cstr(s))\n         };\n }\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n fn setenv(n: str, v: str) {\n     // FIXME (868)\n     str::as_buf("}, {"sha": "f6b46ed7d2e86f4538e947445570da5cffa14912", "filename": "src/libstd/list.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -97,6 +97,27 @@ fn has<copy T>(ls: list<T>, elt: T) -> bool {\n     ret false;\n }\n \n+/*\n+Function: is_empty\n+\n+Returns true if the list is empty.\n+*/\n+pure fn is_empty<copy T>(ls: list<T>) -> bool {\n+    alt ls {\n+        nil. { true }\n+        _ { false }\n+    }\n+}\n+\n+/*\n+Function: is_not_empty\n+\n+Returns true if the list is not empty.\n+*/\n+pure fn is_not_empty<copy T>(ls: list<T>) -> bool {\n+    ret !is_empty(ls);\n+}\n+\n /*\n Function: len\n \n@@ -112,17 +133,23 @@ Function: tail\n \n Returns all but the first element of a list\n */\n-pure fn tail<copy T>(ls: list<T>) -> list<T> {\n-    alt ls { cons(_, tl) { ret *tl; } nil. { fail \"list empty\" } }\n+pure fn tail<copy T>(ls: list<T>) : is_not_empty(ls) -> list<T> {\n+    alt ls {\n+        cons(_, tl) { ret *tl; }\n+        nil. { fail \"list empty\" }\n+    }\n }\n \n /*\n Function: head\n \n Returns the first element of a list\n */\n-pure fn head<copy T>(ls: list<T>) -> T {\n-    alt ls { cons(hd, _) { ret hd; } nil. { fail \"list empty\" } }\n+pure fn head<copy T>(ls: list<T>) : is_not_empty(ls) -> T {\n+    alt ls {\n+        cons(hd, _) { ret hd; }\n+        nil. { fail \"list empty\" }\n+    }\n }\n \n /*"}, {"sha": "6b821dc6223182ca1ceba616052162ce79743a86", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -443,7 +443,7 @@ fn iter_chars(rope: rope, it: block(char)) {\n     loop_chars(rope) {|x|\n         it(x);\n         ret true\n-    }\n+    };\n }\n \n /*"}, {"sha": "11bc15d578f853d8c1ce0ad6fc494e66d7e7ca4e", "filename": "src/libstd/run_program.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun_program.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -266,13 +266,15 @@ fn waitpid(pid: pid_t) -> int {\n \n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n     fn waitpid_os(pid: pid_t) -> int {\n         #[cfg(target_os = \"linux\")]\n         fn WIFEXITED(status: i32) -> bool {\n             (status & 0xffi32) == 0i32\n         }\n \n         #[cfg(target_os = \"macos\")]\n+        #[cfg(target_os = \"freebsd\")]\n         fn WIFEXITED(status: i32) -> bool {\n             (status & 0x7fi32) == 0i32\n         }\n@@ -283,6 +285,7 @@ fn waitpid(pid: pid_t) -> int {\n         }\n \n         #[cfg(target_os = \"macos\")]\n+        #[cfg(target_os = \"freebsd\")]\n         fn WEXITSTATUS(status: i32) -> i32 {\n             status >> 8i32\n         }"}, {"sha": "8acb1ac9ef92ec677e92d7b20cf919db37fbf0e4", "filename": "src/libstd/std.rc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -98,6 +98,13 @@ mod os;\n #[path = \"posix_fs.rs\"]\n mod os_fs;\n \n+#[cfg(target_os = \"freebsd\")]\n+#[path = \"freebsd_os.rs\"]\n+mod os;\n+#[cfg(target_os = \"freebsd\")]\n+#[path = \"posix_fs.rs\"]\n+mod os_fs;\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "f4d984a8937c239882fd70d6de4a2b7ac2380f0a", "filename": "src/libstd/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -7,7 +7,7 @@ Function: id\n \n The identity function\n */\n-pure fn id<T>(x: T) -> T { x }\n+pure fn id<copy T>(x: T) -> T { x }\n \n /*\n Function: unreachable"}, {"sha": "b24008448bb72c20cb30a136cd2c0fb0b278a632", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -5,6 +5,7 @@ the C libuv API. Does very little right now pending scheduler improvements.\n \n #[cfg(target_os = \"linux\")];\n #[cfg(target_os = \"macos\")];\n+#[cfg(target_os = \"freebsd\")];\n \n export sanity_check;\n export loop_t, idle_t;\n@@ -39,6 +40,7 @@ type idle_cb = opaque_cb;\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n type handle_private_fields = {\n     a00: ctypes::c_int,\n     a01: ctypes::c_int,\n@@ -121,6 +123,7 @@ fn sanity_check() {\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n fn handle_fields_new() -> handle_fields {\n     {\n         loop: ptr::null(),\n@@ -149,4 +152,4 @@ fn idle_new() -> idle_t {\n     {\n         fields: handle_fields_new()\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "4fb132c803512f06f7cbc38baa6e86280912f800", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -1 +1 @@\n-Subproject commit a320b2aa41fbe3f944bad33780626d65d1b11e6f\n+Subproject commit 4fb132c803512f06f7cbc38baa6e86280912f800"}, {"sha": "c04c3e01c7ea413a675f4407f742bb61b0ea12b2", "filename": "src/rt/arch/i386/ccall.S", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Farch%2Fi386%2Fccall.S", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Farch%2Fi386%2Fccall.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fccall.S?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -16,20 +16,20 @@ ___morestack:\n __morestack:\n #endif\n \n-#if defined(__linux__) || defined(__APPLE__)\n+#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n \t.cfi_startproc\n #endif\n \n \tpushl %ebp\n \n-#if defined(__linux__) || defined(__APPLE__)\n+#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n \t.cfi_def_cfa_offset 8\n \t.cfi_offset %ebp, -8\n #endif\n \n \tmovl %esp,%ebp          // save esp\n \n-#if defined(__linux__) || defined(__APPLE__)\n+#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n \t.cfi_def_cfa_register %ebp\n #endif\n \n@@ -42,6 +42,6 @@ __morestack:\n \n \tret\n \n-#if defined(__linux__) || defined(__APPLE__)\n+#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n \t.cfi_endproc\n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "d1433213b2d018912ac55d7ce7a1000fbda02b9e", "filename": "src/rt/arch/i386/morestack.S", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Farch%2Fi386%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Farch%2Fi386%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fmorestack.S?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -72,7 +72,7 @@\n #define UPCALL_DEL_STACK        L_upcall_del_stack$stub\n #define MORESTACK               ___morestack\n #else\n-#if defined(__linux__)\n+#if defined(__linux__) || defined(__FreeBSD__)\n #define UPCALL_NEW_STACK        upcall_new_stack\n #define UPCALL_DEL_STACK        upcall_del_stack\n #define RUST_GET_TASK           rust_get_task\n@@ -93,7 +93,7 @@\n .globl MORESTACK\n \n // FIXME: What about _WIN32?\t\n-#if defined(__linux__)\n+#if defined(__linux__) || defined(__FreeBSD__)\n \t.hidden MORESTACK\n #else\n #if defined(__APPLE__)\n@@ -106,7 +106,7 @@\n #endif\n \n MORESTACK:\n-#if defined(__linux__) || defined(__APPLE__)\n+#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n \t.cfi_startproc\n #endif\n \n@@ -125,15 +125,15 @@ MORESTACK:\n \t// __morestack, and an extra return address.\n \n \tpushl %ebp\n-#if defined(__linux__) || defined(__APPLE__)\n+#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n \t// The CFA is 20 bytes above the register that it is\n \t// associated with for this frame (which will be %ebp)\n \t.cfi_def_cfa_offset 20\n \t// %ebp is -20 bytes from the CFA\n \t.cfi_offset %ebp, -20\n #endif\n \tmovl %esp, %ebp\n-#if defined(__linux__) || defined(__APPLE__)\n+#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n \t// Calculate the CFA as an offset from %ebp\n \t.cfi_def_cfa_register %ebp\n #endif\n@@ -216,7 +216,7 @@ MORESTACK:\n \t// FIXME: I don't think these rules are necessary\n \t// since the unwinder should never encounter an instruction\n \t// pointer pointing here.\n-#if defined(__linux__) || defined(__APPLE__)\n+#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n \t// Restore the rule for how to find %ebp\n \t.cfi_restore %ebp\n \t// Tell the unwinder how to find the CFA in terms of %esp\n@@ -234,7 +234,7 @@ MORESTACK:\n \t\n \tjmpl *%eax\n \n-#if defined(__linux__) || defined(__APPLE__)\n+#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n \t.cfi_endproc\n #endif\n "}, {"sha": "1b698ed74bf50428f05249af684bfb4699517ef4", "filename": "src/rt/arch/i386/record_sp.S", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Farch%2Fi386%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Farch%2Fi386%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Frecord_sp.S?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -14,7 +14,7 @@\n .globl GET_SP\n .globl CHECK_STACK\n \n-#if defined(__linux__)\n+#if defined(__linux__) || defined(__FreeBSD__)\n RECORD_SP:\n \tmovl 4(%esp), %eax\n \tmovl %eax, %gs:48"}, {"sha": "42415e84a52f0cd1a6ad3437ee1b5a743bb5d540", "filename": "src/rt/arch/x86_64/ccall.S", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Farch%2Fx86_64%2Fccall.S", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Farch%2Fx86_64%2Fccall.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fccall.S?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -23,19 +23,19 @@ ___morestack:\n __morestack:\n #endif\n \n-#if defined(__linux__) || defined(__APPLE__)\n+#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n \t.cfi_startproc\n #endif\n \n \tpush %rbp\n-#if defined(__linux__) || defined(__APPLE__)\n+#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n \t.cfi_def_cfa_offset 16\n \t.cfi_offset %rbp, -16\n #endif\n \n \tmov %rsp,%rbp          // save rsp\n \n-#if defined(__linux__) || defined(__APPLE__)\n+#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n \t.cfi_def_cfa_register %rbp\n #endif\n \n@@ -46,6 +46,6 @@ __morestack:\n \n \tret\n \n-#if defined(__linux__) || defined(__APPLE__)\n+#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n \t.cfi_endproc\n #endif"}, {"sha": "5784a4b85fdacc937cb6728b11cc8abea67dbb0a", "filename": "src/rt/arch/x86_64/context.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Farch%2Fx86_64%2Fcontext.h", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Farch%2Fx86_64%2Fcontext.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fcontext.h?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -31,7 +31,11 @@ extern \"C\" void __morestack(void *args, void *fn_ptr, uintptr_t stack_ptr);\n \n class context {\n public:\n+#ifdef __FreeBSD__\n+    registers_t regs __attribute__((aligned(16)));\n+#else\n     registers_t regs;\n+#endif\n     \n     context();\n     "}, {"sha": "89ca9d21452c002ff3dc63d67e5b6d9683687782", "filename": "src/rt/arch/x86_64/morestack.S", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Fmorestack.S?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -20,7 +20,7 @@\n .globl UPCALL_DEL_STACK\n .globl MORESTACK\n \n-#if defined(__linux__)\n+#if defined(__linux__) || defined(__FreeBSD__)\n \t.hidden MORESTACK\n #else\n #if defined(__APPLE__)\n@@ -33,7 +33,7 @@\n #endif\n \n \n-#if defined(__linux__) || defined(__APPLE__)\n+#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n MORESTACK:\n \t.cfi_startproc\n \n@@ -92,6 +92,9 @@ MORESTACK:\n #ifdef __linux__\n \tcall UPCALL_NEW_STACK@PLT\n #endif\n+#ifdef __FreeBSD__\n+\tcall UPCALL_NEW_STACK@PLT\n+#endif\n \n \t// Pop the saved arguments\n \tmovdqa    (%rsp), %xmm0\n@@ -135,6 +138,9 @@ MORESTACK:\n #ifdef __linux__\n \tcall UPCALL_DEL_STACK@PLT\n #endif\n+#ifdef __FreeBSD__\n+\tcall UPCALL_DEL_STACK@PLT\n+#endif\n \n \tpopq %rax // Restore the return value\n \tpopq %rbp"}, {"sha": "3b238d33c77870b8d6ad40f7c0e1bf2572985b2f", "filename": "src/rt/arch/x86_64/record_sp.S", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Farch%2Fx86_64%2Frecord_sp.S", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Farch%2Fx86_64%2Frecord_sp.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fx86_64%2Frecord_sp.S?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -18,17 +18,19 @@\n RECORD_SP:\n \tmovq %rdi, %fs:112\n \tret\n-#else\n-#if defined(__APPLE__)\n+#elif defined(__APPLE__)\n RECORD_SP:\n \tmovq $0x60+90*8, %rsi\n \tmovq %rdi, %gs:(%rsi)\n \tret\n+#elif defined(__FreeBSD__)\n+RECORD_SP:\n+\tmovq %rdi, %fs:24\n+\tret\n #else\n RECORD_SP:\n \tret\n #endif\n-#endif\n \n GET_SP:\n \tmovq %rsp, %rax"}, {"sha": "b533ab1f673a481154ea5769329031ced142df2e", "filename": "src/rt/rust_abi.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Frust_abi.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Frust_abi.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_abi.cpp?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -7,7 +7,7 @@\n #include <stdint.h>\n #include \"rust_abi.h\"\n \n-#if defined(__APPLE__) || defined(__linux__)\n+#if defined(__APPLE__) || defined(__linux__) || defined(__FreeBSD__)\n #define HAVE_DLFCN_H\n #include <dlfcn.h>\n #elif defined(_WIN32)"}, {"sha": "92f24c8c7fa6bcb68d7136bb769062ff7d5d6a1c", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -23,6 +23,8 @@\n #define RZ_MAC_32   (1024*20)\n #define RZ_MAC_64   (1024*20)\n #define RZ_WIN_32   (1024*20)\n+#define RZ_BSD_32   (1024*20)\n+#define RZ_BSD_64   (1024*20)\n \n #ifdef __linux__\n #ifdef __i386__\n@@ -48,6 +50,14 @@\n #define RED_ZONE_SIZE RZ_WIN_64\n #endif\n #endif\n+#ifdef __FreeBSD__\n+#ifdef __i386__\n+#define RED_ZONE_SIZE RZ_BSD_32\n+#endif\n+#ifdef __x86_64__\n+#define RED_ZONE_SIZE RZ_BSD_64\n+#endif\n+#endif\n \n // A value that goes at the end of the stack and must not be touched\n const uint8_t stack_canary[] = {0xAB, 0xCD, 0xAB, 0xCD,"}, {"sha": "7d64842994e8c93d64e51c0b74fc6b423a8a889a", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -20,7 +20,7 @@\n // the rust stack and happen frequently enough to catch most stack changes,\n // including at the beginning of all landing pads.\n // FIXME: Enable this for windows\n-#if defined __linux__ || defined __APPLE__\n+#if defined __linux__ || defined __APPLE__ || defined __FreeBSD__\n extern \"C\" void\n check_stack_alignment() __attribute__ ((aligned (16)));\n #else"}, {"sha": "83d73da94d60db399095078f4b22c0c6e4775e6e", "filename": "src/test/compile-fail/binop-add-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fbinop-add-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fbinop-add-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-add-ptr.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:binary operation + cannot be applied to type `*i`\n+// error-pattern:binary operation + cannot be applied to type `*int`\n \n fn die() -> *int { (0 as *int) + (0 as *int) }\n fn main() { }\n\\ No newline at end of file"}, {"sha": "f842b0f02b496f19d5822d1ea66c88c85cb643dc", "filename": "src/test/compile-fail/block-must-not-have-result-do.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-do.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-do.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-do.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:this block must not have a result\n+// error-pattern:mismatched types: expected `()` but found `bool`\n \n fn main() {\n     do {"}, {"sha": "d2e7edbfc0f19fb98e991f3819cd823475f85aa3", "filename": "src/test/compile-fail/block-must-not-have-result-for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-for.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:this block must not have a result\n+// error-pattern:mismatched types: expected `()` but found `bool`\n \n fn main() {\n     for i in [0] {"}, {"sha": "d617aba2fdec230bb4fd3f9f594243141a795809", "filename": "src/test/compile-fail/block-must-not-have-result-res.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-res.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:this block must not have a result\n+// error-pattern:mismatched types: expected `()` but found `bool`\n \n resource r(i: int) {\n     true"}, {"sha": "7f172998c2859391f39ef55c2dad022d72e163ad", "filename": "src/test/compile-fail/block-must-not-have-result-while.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-must-not-have-result-while.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:this block must not have a result\n+// error-pattern:mismatched types: expected `()` but found `bool`\n \n fn main() {\n     while true {"}, {"sha": "4e422c970c6853c08c2eaa4071d6f554318cd303", "filename": "src/test/compile-fail/forgot-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fforgot-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fforgot-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fforgot-ret.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -3,6 +3,6 @@\n \n fn god_exists(a: int) -> bool { be god_exists(a); }\n \n-fn f(a: int) -> int { if god_exists(a) { ret 5; } }\n+fn f(a: int) -> int { if god_exists(a) { ret 5; }; }\n \n fn main() { f(12); }"}, {"sha": "2454f4f37bf69515cfd870869a77974fdde801ee", "filename": "src/test/compile-fail/if-without-else-result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fif-without-else-result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fif-without-else-result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-without-else-result.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:`if` without `else` can not produce a result\n+// error-pattern:mismatched types: expected `()` but found `bool`\n \n fn main() {\n     let a = if true { true };"}, {"sha": "26a9febd3c780c1a2df207f64ed55b150d918f70", "filename": "src/test/compile-fail/missing-return2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fmissing-return2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fmissing-return2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-return2.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -3,7 +3,7 @@\n fn f() -> int {\n     // Make sure typestate doesn't interpret this alt expression\n     // as the function result\n-    alt true { true { } }\n+    alt true { true { } };\n }\n \n fn main() { }"}, {"sha": "d4b8e44cad0c5e8b1e5b028b72f06f2098af60b3", "filename": "src/test/compile-fail/native-type-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fnative-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fcompile-fail%2Fnative-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnative-type-mismatch.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:expected `*Mb` but found `native`\n+// error-pattern:expected `*u8` but found `native`\n use std;\n \n fn main() unsafe {"}, {"sha": "5f9d57f94a732b693bd50a04b9d82ab8d814fa95", "filename": "src/test/pretty/disamb-stmt-expr.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdisamb-stmt-expr.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,8 @@\n+// pp-exact\n+\n+// Here we check that the parentheses around the body of `wsucc()` are\n+// preserved.  They are needed to disambiguate `{ret n+1}; - 0` from\n+// `({ret n+1}-0)`.\n+\n+fn wsucc(n: int) -> int { ({ ret n + 1 } - 0); }\n+fn main() { }"}, {"sha": "53187408af112291ad0b39dd3aec3275200b17c9", "filename": "src/test/run-pass/block-arg-as-stmt.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fblock-arg-as-stmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fblock-arg-as-stmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-as-stmt.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,25 @@\n+\n+fn compute1() -> float {\n+    let v = [0f, 1f, 2f, 3f];\n+\n+    // Here the \"-10f\" parses as a second\n+    // statement in tail position:\n+    vec::foldl(0f, v) { |x, y| x + y } - 10f\n+}\n+\n+fn compute2() -> float {\n+    let v = [0f, 1f, 2f, 3f];\n+\n+    // Here the ret makes this explicit:\n+    ret vec::foldl(0f, v) { |x, y| x + y } - 10f;\n+}\n+\n+fn main() {\n+    let x = compute1();\n+    log(debug, x);\n+    assert(x == -10f);\n+\n+    let y = compute2();\n+    log(debug, y);\n+    assert(y == -4f);\n+}"}, {"sha": "a8e763e96a68c9239f5bdeaf17d9bad4e12ee7f5", "filename": "src/test/run-pass/block-arg-can-be-followed-by-binop.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let v = [-1f, 0f, 1f, 2f, 3f];\n+\n+    // Trailing expressions require parentheses:\n+    let y = vec::foldl(0f, v) { |x, y| x + y } + 10f;\n+\n+    assert y == 15f;\n+}"}, {"sha": "8fd7974051254be084488dde778eaaee5cc516e9", "filename": "src/test/run-pass/block-arg-can-be-followed-by-block-arg.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    fn f(i: block() -> uint) -> uint { i() }\n+    let v = [-1f, 0f, 1f, 2f, 3f];\n+    let z = vec::foldl(f, v) { |x, _y| x } { || 22u };\n+    assert z == 22u;\n+}"}, {"sha": "b570a8bdd82b02b181d5b269b0581449d4b0903d", "filename": "src/test/run-pass/block-arg-can-be-followed-by-call.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    fn f(i: uint) -> uint { i }\n+    let v = [-1f, 0f, 1f, 2f, 3f];\n+    let z = vec::foldl(f, v) { |x, _y| x } (22u);\n+    assert z == 22u;\n+}"}, {"sha": "205c9144833a620b17ac912e2253cba601dbb531", "filename": "src/test/run-pass/block-arg-in-parentheses.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,23 @@\n+// xfail-test\n+\n+// FIXME: Parser doesn't distinguish expression in parentheses (as in\n+// this example) from one that is not!  It is somewhat of a pain to\n+// fix this though there are no theoretical difficulties.  We could\n+// either add paren to the AST (better for pretty-print, I suppose) or\n+// modify the parser to track whether the expression in question is\n+// parenthesized.  I did the latter once and it was a bit of pain but\n+// not terribly difficult.  We could also the decision as to whether\n+// something is an \"expression with a value\" down into the\n+// parse_expr() codepath, where we *know* if there are parentheses or\n+// not, but we'd probably have to be a bit more careful then with\n+// clearing the top-level restrction flag (which we ought to do\n+// anyhow!)\n+\n+fn main() {\n+    let v = [1f, 2f, 3f];\n+    let w =\n+        if true { (vec::any(v) { |e| float::nonnegative(e) }) }\n+        else { false };\n+    assert w;\n+}\n+"}, {"sha": "d48331b3c71cc8bbb5a47a9bcbe0e107c7629ec5", "filename": "src/test/run-pass/block-arg-in-ternary.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fblock-arg-in-ternary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fblock-arg-in-ternary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-in-ternary.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,6 @@\n+// Allow block arguments with ternary... why not, no chance of ambig.\n+fn main() {\n+    let v = [-1f, 1f];\n+    let foo = vec::any(v) { |e| float::negative(e) } ? true : false;\n+    assert foo;\n+}"}, {"sha": "6fa2ed5b0f3c46869e0ecf330131d73fd70918cf", "filename": "src/test/run-pass/block-arg.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,52 @@\n+// Check usage and precedence of block arguments in expressions:\n+fn main() {\n+    let v = [-1f, 0f, 1f, 2f, 3f];\n+\n+    // Statement form does not require parentheses:\n+    vec::iter(v) { |i|\n+        log(info, i);\n+    }\n+\n+    // Usable at all:\n+    let any_negative = vec::any(v) { |e| float::negative(e) };\n+    assert any_negative;\n+\n+    // Higher precedence than assignments:\n+    any_negative = vec::any(v) { |e| float::negative(e) };\n+    assert any_negative;\n+\n+    // Higher precedence than unary operations:\n+    let abs_v = vec::map(v) { |e| float::abs(e) };\n+    assert vec::all(abs_v) { |e| float::nonnegative(e) };\n+    assert !vec::any(abs_v) { |e| float::negative(e) };\n+\n+    // Usable in funny statement-like forms:\n+    if !vec::any(v) { |e| float::positive(e) } {\n+        assert false;\n+    }\n+    alt vec::all(v) { |e| float::negative(e) } {\n+        true { fail \"incorrect answer.\"; }\n+        false { }\n+    }\n+    alt 3 {\n+      _ when vec::any(v) { |e| float::negative(e) } {\n+      }\n+      _ {\n+        fail \"wrong answer.\";\n+      }\n+    }\n+\n+\n+    // Lower precedence than binary operations:\n+    let w = vec::foldl(0f, v, { |x, y| x + y }) + 10f;\n+    let y = vec::foldl(0f, v) { |x, y| x + y } + 10f;\n+    let z = 10f + vec::foldl(0f, v) { |x, y| x + y };\n+    assert w == y;\n+    assert y == z;\n+\n+    // They are not allowed as the tail of a block without parentheses:\n+    let w =\n+      if true { vec::any(abs_v, { |e| float::nonnegative(e) }) }\n+      else { false };\n+    assert w;\n+}"}, {"sha": "663bc50fd0259376d9820cf27fbf9f73981bdc9c", "filename": "src/test/run-pass/dupe-first-attr.rc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fdupe-first-attr.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fdupe-first-attr.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdupe-first-attr.rc?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -8,4 +8,7 @@ mod hello;\n mod hello;\n \n #[cfg(target_os = \"win32\")]\n-mod hello;\n\\ No newline at end of file\n+mod hello;\n+\n+#[cfg(target_os = \"freebsd\")]\n+mod hello;"}, {"sha": "21eca8fefacf284ced5ebf4e8898934baa191375", "filename": "src/test/run-pass/early-ret-binop-add.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fearly-ret-binop-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fearly-ret-binop-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fearly-ret-binop-add.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -1,2 +1,2 @@\n-fn wsucc(n: int) -> int { { ret n + 1 } + 0; }\n+fn wsucc(n: int) -> int { ({ ret n + 1 } + 0); }\n fn main() { }"}, {"sha": "118bec708b88bc649ec7be552f56c1db9137dc8f", "filename": "src/test/run-pass/early-ret-binop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fearly-ret-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fearly-ret-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fearly-ret-binop.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -1,2 +1,2 @@\n-fn wsucc(n: int) -> int { { ret n + 1 } == 0; }\n+fn wsucc(n: int) -> int { ({ ret n + 1 } == 0); }\n fn main() { }"}, {"sha": "bc19200e32374f4789363db61b3b31c14a9f5a3f", "filename": "src/test/run-pass/expr-alt-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T>(expected: T, eq: compare<T>) {\n+fn test_generic<copy T>(expected: T, eq: compare<T>) {\n     let actual: T = alt true { true { expected } };\n     assert (eq(expected, actual));\n }"}, {"sha": "301d56389b12e67fe17d9751db8aa195d8b9bef0", "filename": "src/test/run-pass/expr-alt-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -3,7 +3,7 @@\n // -*- rust -*-\n type compare<T> = fn@(~T, ~T) -> bool;\n \n-fn test_generic<T>(expected: ~T, eq: compare<T>) {\n+fn test_generic<copy T>(expected: ~T, eq: compare<T>) {\n     let actual: ~T = alt true { true { expected } };\n     assert (eq(expected, actual));\n }"}, {"sha": "5640dca0b4eb00859d0225d4f8d04219a35ebf55", "filename": "src/test/run-pass/expr-alt-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T>(expected: T, eq: compare<T>) {\n+fn test_generic<copy T>(expected: T, eq: compare<T>) {\n     let actual: T = alt true { true { expected } };\n     assert (eq(expected, actual));\n }"}, {"sha": "5a2f7d8b71cd8a4c21776a20495f7a61863530a0", "filename": "src/test/run-pass/expr-alt-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<T>(expected: T, eq: compare<T>) {\n+fn test_generic<copy T>(expected: T, eq: compare<T>) {\n     let actual: T = alt true { true { expected } };\n     assert (eq(expected, actual));\n }"}, {"sha": "5cd3f2a178b21e3342b73a2cd8f07ff3bc52129e", "filename": "src/test/run-pass/expr-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-fn.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -9,7 +9,7 @@ fn test_vec() {\n }\n \n fn test_generic() {\n-    fn f<T>(t: T) -> T { t }\n+    fn f<copy T>(t: T) -> T { t }\n     assert (f(10) == 10);\n }\n "}, {"sha": "07727035a28a158cbf27ede27675ac5066ae0308", "filename": "src/test/run-pass/iface-generic.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fiface-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fiface-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiface-generic.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,35 @@\n+// xfail-pretty\n+\n+iface to_str {\n+    fn to_str() -> str;\n+}\n+impl of to_str for int {\n+    fn to_str() -> str { int::str(self) }\n+}\n+impl of to_str for str {\n+    fn to_str() -> str { self }\n+}\n+\n+iface map<T> {\n+    fn map<U>(f: block(T) -> U) -> [U];\n+}\n+impl <T> of map<T> for [T] {\n+    fn map<U>(f: block(T) -> U) -> [U] {\n+        let r = [];\n+        for x in self { r += [f(x)]; }\n+        r\n+    }\n+}\n+\n+fn foo<U, T: map<U>>(x: T) -> [str] {\n+    x.map({|_e| \"hi\" })\n+}\n+fn bar<U: to_str, T: map<U>>(x: T) -> [str] {\n+    x.map({|_e| _e.to_str() })\n+}\n+\n+fn main() {\n+    assert foo([1]) == [\"hi\"];\n+    assert bar::<int, [int]>([4, 5]) == [\"4\", \"5\"];\n+    assert bar::<str, [str]>([\"x\", \"y\"]) == [\"x\", \"y\"];\n+}"}, {"sha": "cf30cefbd33cc9b958e64e9b9269a06454ed27d8", "filename": "src/test/run-pass/iface-to-str.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fiface-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fiface-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiface-to-str.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,28 @@\n+iface to_str {\n+    fn to_str() -> str;\n+}\n+\n+impl of to_str for int {\n+    fn to_str() -> str { int::str(self) }\n+}\n+\n+impl <T: to_str> of to_str for [T] {\n+    fn to_str() -> str {\n+        \"[\" + str::connect(vec::map(self, {|e| e.to_str()}), \", \") + \"]\"\n+    }\n+}\n+\n+fn main() {\n+    assert 1.to_str() == \"1\";\n+    assert [2, 3, 4].to_str() == \"[2, 3, 4]\";\n+\n+    fn indirect<T: to_str>(x: T) -> str {\n+        x.to_str() + \"!\"\n+    }\n+    assert indirect([10, 20]) == \"[10, 20]!\";\n+\n+    fn indirect2<T: to_str>(x: T) -> str {\n+        indirect(x)\n+    }\n+    assert indirect2([1]) == \"[1]!\";\n+}"}, {"sha": "a19b6ccbc7ba0cb5df9c6b252e27e31607accea4", "filename": "src/test/run-pass/issue-970.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fissue-970.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fissue-970.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-970.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,6 @@\n+tag maybe_ordered_pair {\n+    yes({low: int, high: int} : less_than(*.low, *.high));\n+    no;\n+}\n+pure fn less_than(x: int, y: int) -> bool { ret x < y; }\n+fn main() { }"}, {"sha": "1399839a1ed04806789748c36600af257ce2ee9c", "filename": "src/test/run-pass/last-use-is-capture.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Flast-use-is-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Flast-use-is-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-is-capture.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -0,0 +1,8 @@\n+// Make sure #1399 stays fixed\n+\n+fn main() {\n+    fn invoke(f: lambda()) { f(); }\n+    let k = ~22;\n+    let _u = {a: k};\n+    invoke {||log(error, k);}\n+}"}, {"sha": "27f3b530154dbcd29d6e7881827f334bf798a60d", "filename": "src/test/run-pass/non-boolean-pure-fns.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -14,7 +14,10 @@ pure fn nonempty_list<copy T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n // knowledge that ls is a cons node. Future work.\n // Also, this is pretty contrived since nonempty_list\n // could be a \"tag refinement\", if we implement those.\n-fn safe_head<copy T>(ls: list<T>) : nonempty_list(ls) -> T { head(ls) }\n+fn safe_head<copy T>(ls: list<T>) : nonempty_list(ls) -> T {\n+    check is_not_empty(ls);\n+    ret head(ls);\n+}\n \n fn main() {\n     let mylist = cons(@1u, @nil);"}, {"sha": "035b18f805125e060a218c85cbfa1f57fe417c73", "filename": "src/test/run-pass/unchecked-predicates.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -1,12 +1,17 @@\n // Uses foldl to exhibit the unchecked block syntax.\n+// TODO: since list's head/tail require the predicate \"is_not_empty\" now and\n+// we have unit tests for list, this test might me not necessary anymore?\n use std;\n \n import std::list::*;\n \n // Can't easily be written as a \"pure fn\" because there's\n // no syntax for specifying that f is pure.\n fn pure_foldl<copy T, copy U>(ls: list<T>, u: U, f: block(T, U) -> U) -> U {\n-    alt ls { nil. { u } cons(hd, tl) { f(hd, pure_foldl(*tl, f(hd, u), f)) } }\n+    alt ls {\n+        nil. { u }\n+        cons(hd, tl) { f(hd, pure_foldl(*tl, f(hd, u), f)) }\n+    }\n }\n \n // Shows how to use an \"unchecked\" block to call a general\n@@ -22,7 +27,10 @@ pure fn nonempty_list<copy T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n // knowledge that ls is a cons node. Future work.\n // Also, this is pretty contrived since nonempty_list\n // could be a \"tag refinement\", if we implement those.\n-fn safe_head<copy T>(ls: list<T>) : nonempty_list(ls) -> T { head(ls) }\n+fn safe_head<copy T>(ls: list<T>) : nonempty_list(ls) -> T {\n+    check is_not_empty(ls);\n+    ret head(ls)\n+}\n \n fn main() {\n     let mylist = cons(@1u, @nil);"}, {"sha": "b9d9b84a526c75473718e940b786df8da55271ee", "filename": "src/test/run-pass/x86stdcall.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fx86stdcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fx86stdcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fx86stdcall.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -19,4 +19,5 @@ fn main() {\n \n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"freebsd\")]\n fn main() { }"}, {"sha": "e58656a73a44f39fcc66f5a68e23ac2dea7a888a", "filename": "src/test/run-pass/x86stdcall2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -24,4 +24,5 @@ fn main() {\n \n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"freebsd\")]\n fn main() { }"}, {"sha": "7da2443d6c2c1c425de057afc8e26247f68c3cd8", "filename": "src/test/stdtest/char.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fstdtest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fstdtest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fchar.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -60,3 +60,19 @@ fn test_to_digit_fail_1() {\n fn test_to_digit_fail_2() {\n     char::to_digit('$');\n }\n+\n+#[test]\n+fn test_to_lower() {\n+    assert (char::to_lower('H') == 'h');\n+    assert (char::to_lower('e') == 'e');\n+    //assert (char::to_lower('\u00d6') == '\u00f6');\n+    assert (char::to_lower('\u00df') == '\u00df');\n+}\n+\n+#[test]\n+fn test_to_upper() {\n+    assert (char::to_upper('l') == 'L');\n+    assert (char::to_upper('Q') == 'Q');\n+    //assert (char::to_upper('\u00fc') == '\u00dc');\n+    assert (char::to_upper('\u00df') == '\u00df');\n+}"}, {"sha": "b96bc9cd16a56b9ae856a00995d3fc1c17d66b18", "filename": "src/test/stdtest/list.rs", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fstdtest%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fstdtest%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Flist.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -2,17 +2,38 @@ import core::*;\n \n use std;\n import std::list;\n-import std::list::head;\n-import std::list::tail;\n-import std::list::from_vec;\n+import std::list::{from_vec, head, is_empty, is_not_empty, tail};\n import option;\n \n+#[test]\n+fn test_is_empty() {\n+    let empty : list::list<int> = from_vec([]);\n+    let full1 = from_vec([1]);\n+    let full2 = from_vec(['r', 'u']);\n+\n+    assert is_empty(empty);\n+    assert !is_empty(full1);\n+    assert !is_empty(full2);\n+\n+    assert !is_not_empty(empty);\n+    assert is_not_empty(full1);\n+    assert is_not_empty(full2);\n+}\n+\n #[test]\n fn test_from_vec() {\n     let l = from_vec([0, 1, 2]);\n+\n+    check is_not_empty(l);\n     assert (head(l) == 0);\n-    assert (head(tail(l)) == 1);\n-    assert (head(tail(tail(l))) == 2);\n+\n+    let tail_l = tail(l);\n+    check is_not_empty(tail_l);\n+    assert (head(tail_l) == 1);\n+\n+    let tail_tail_l = tail(tail_l);\n+    check is_not_empty(tail_tail_l);\n+    assert (head(tail_tail_l) == 2);\n }\n \n #[test]\n@@ -24,9 +45,17 @@ fn test_from_vec_empty() {\n #[test]\n fn test_from_vec_mut() {\n     let l = from_vec([mutable 0, 1, 2]);\n+\n+    check is_not_empty(l);\n     assert (head(l) == 0);\n-    assert (head(tail(l)) == 1);\n-    assert (head(tail(tail(l))) == 2);\n+\n+    let tail_l = tail(l);\n+    check is_not_empty(tail_l);\n+    assert (head(tail_l) == 1);\n+\n+    let tail_tail_l = tail(tail_l);\n+    check is_not_empty(tail_tail_l);\n+    assert (head(tail_tail_l) == 2);\n }\n \n #[test]"}, {"sha": "fd773063e8d003d410a38e920d8112b0b57f3656", "filename": "src/test/stdtest/os.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fstdtest%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fstdtest%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fos.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -14,6 +14,7 @@ fn test_setenv() {\n }\n \n #[test]\n+#[ignore(reason = \"fails periodically on mac\")]\n fn test_setenv_overwrite() {\n     setenv(\"NAME2\", \"1\");\n     setenv(\"NAME2\", \"2\");\n@@ -23,12 +24,14 @@ fn test_setenv_overwrite() {\n // Windows GetEnvironmentVariable requires some extra work to make sure\n // the buffer the variable is copied into is the right size\n #[test]\n+#[ignore(reason = \"fails periodically on mac\")]\n fn test_getenv_big() {\n     let s = \"\";\n     let i = 0;\n     while i < 100 { s += \"aaaaaaaaaa\"; i += 1; }\n-    setenv(\"NAME3\", s);\n-    assert (getenv(\"NAME3\") == option::some(s));\n+    setenv(\"test_getenv_big\", s);\n+    log(debug, s);\n+    assert (getenv(\"test_getenv_big\") == option::some(s));\n }\n \n #[test]"}, {"sha": "39217fb8a8b5345733a572ae21444fcf28f51951", "filename": "src/test/stdtest/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fstdtest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fstdtest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstr.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -287,10 +287,10 @@ fn unsafe_from_bytes() {\n }\n \n #[test]\n-fn str_from_cstr() unsafe {\n+fn from_cstr() unsafe {\n     let a = [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n     let b = vec::to_ptr(a);\n-    let c = str::str_from_cstr(b);\n+    let c = str::from_cstr(b);\n     assert (c == \"AAAAAAA\");\n }\n \n@@ -312,7 +312,7 @@ fn as_buf_small() unsafe {\n fn as_buf2() unsafe {\n     let s = \"hello\";\n     let sb = str::as_buf(s, {|b| b });\n-    let s_cstr = str::str_from_cstr(sb);\n+    let s_cstr = str::from_cstr(sb);\n     assert (str::eq(s_cstr, s));\n }\n "}, {"sha": "a7f6e0a8f15730fc3ee97b9fe83497e4b7bdbff2", "filename": "src/test/stdtest/uv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fstdtest%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6284190ef9918e05cb9147a2a81100ddcb06fea8/src%2Ftest%2Fstdtest%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fuv.rs?ref=6284190ef9918e05cb9147a2a81100ddcb06fea8", "patch": "@@ -1,6 +1,7 @@\n \n #[cfg(target_os = \"linux\")];\n #[cfg(target_os = \"macos\")];\n+#[cfg(target_os = \"freebsd\")];\n \n import core::*;\n \n@@ -44,4 +45,4 @@ mod test_ref {\n         uv::loop_delete(loop);\n         */\n     }\n-}\n\\ No newline at end of file\n+}"}]}