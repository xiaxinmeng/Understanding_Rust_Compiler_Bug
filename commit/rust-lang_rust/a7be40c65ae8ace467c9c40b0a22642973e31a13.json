{"sha": "a7be40c65ae8ace467c9c40b0a22642973e31a13", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3YmU0MGM2NWFlOGFjZTQ2N2M5YzQwYjBhMjI2NDI5NzNlMzFhMTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-26T19:39:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-26T19:39:19Z"}, "message": "Auto merge of #56534 - xfix:copied, r=@SimonSapin\n\nAdd unstable Iterator::copied()\n\nInitially suggested at https://github.com/bluss/rust-itertools/pull/289, however the maintainers of itertools suggested this may be better of in a standard library.\n\nThe intent of `copied` is to avoid accidentally cloning iterator elements after doing a code refactoring which causes a structure to be no longer `Copy`. This is a relatively common pattern, as it can be seen by calling `rg --pcre2 '[.]map[(][|](?:(\\w+)[|] [*]\\1|&(\\w+)[|] \\2)[)]'` on Rust main repository. Additionally, many uses of `cloned` actually want to simply `Copy`, and changing something to be no longer copyable may introduce unnoticeable performance penalty.\n\nAlso, this makes sense because the standard library includes `[T].copy_from_slice` to pair with `[T].clone_from_slice`.\n\nThis also adds `Option::copied`, because it makes sense to pair it with `Iterator::copied`. I don't think this feature is particularly important, but it makes sense to update `Option` along with `Iterator` for consistency.", "tree": {"sha": "997497091f9aaca0489ac21046023138342a7432", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/997497091f9aaca0489ac21046023138342a7432"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7be40c65ae8ace467c9c40b0a22642973e31a13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7be40c65ae8ace467c9c40b0a22642973e31a13", "html_url": "https://github.com/rust-lang/rust/commit/a7be40c65ae8ace467c9c40b0a22642973e31a13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7be40c65ae8ace467c9c40b0a22642973e31a13/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79d8a0fcefa5134db2a94739b1d18daa01fc6e9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/79d8a0fcefa5134db2a94739b1d18daa01fc6e9f", "html_url": "https://github.com/rust-lang/rust/commit/79d8a0fcefa5134db2a94739b1d18daa01fc6e9f"}, {"sha": "315401ddf8857c9431a889ac1307dca856e4fe65", "url": "https://api.github.com/repos/rust-lang/rust/commits/315401ddf8857c9431a889ac1307dca856e4fe65", "html_url": "https://github.com/rust-lang/rust/commit/315401ddf8857c9431a889ac1307dca856e4fe65"}], "stats": {"total": 213, "additions": 212, "deletions": 1}, "files": [{"sha": "1ea500858ed1626b324fbac9f2199b9e5be5e485", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a7be40c65ae8ace467c9c40b0a22642973e31a13/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7be40c65ae8ace467c9c40b0a22642973e31a13/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=a7be40c65ae8ace467c9c40b0a22642973e31a13", "patch": "@@ -2,7 +2,7 @@ use cmp::Ordering;\n use ops::Try;\n \n use super::LoopState;\n-use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, Fuse};\n+use super::{Chain, Cycle, Copied, Cloned, Enumerate, Filter, FilterMap, Fuse};\n use super::{Flatten, FlatMap, flatten_compat};\n use super::{Inspect, Map, Peekable, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile, Rev};\n use super::{Zip, Sum, Product};\n@@ -2225,6 +2225,35 @@ pub trait Iterator {\n         (ts, us)\n     }\n \n+    /// Creates an iterator which copies all of its elements.\n+    ///\n+    /// This is useful when you have an iterator over `&T`, but you need an\n+    /// iterator over `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_copied)]\n+    ///\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let v_cloned: Vec<_> = a.iter().copied().collect();\n+    ///\n+    /// // copied is the same as .map(|&x| x)\n+    /// let v_map: Vec<_> = a.iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(v_cloned, vec![1, 2, 3]);\n+    /// assert_eq!(v_map, vec![1, 2, 3]);\n+    /// ```\n+    #[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+    fn copied<'a, T: 'a>(self) -> Copied<Self>\n+        where Self: Sized + Iterator<Item=&'a T>, T: Copy\n+    {\n+        Copied { it: self }\n+    }\n+\n     /// Creates an iterator which [`clone`]s all of its elements.\n     ///\n     /// This is useful when you have an iterator over `&T`, but you need an"}, {"sha": "03369d6c8f3fd60959ca670a185e8d250a16203b", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a7be40c65ae8ace467c9c40b0a22642973e31a13/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7be40c65ae8ace467c9c40b0a22642973e31a13/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=a7be40c65ae8ace467c9c40b0a22642973e31a13", "patch": "@@ -497,6 +497,106 @@ impl<I> FusedIterator for Rev<I>\n unsafe impl<I> TrustedLen for Rev<I>\n     where I: TrustedLen + DoubleEndedIterator {}\n \n+/// An iterator that copies the elements of an underlying iterator.\n+///\n+/// This `struct` is created by the [`copied`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`copied`]: trait.Iterator.html#method.copied\n+/// [`Iterator`]: trait.Iterator.html\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[derive(Clone, Debug)]\n+pub struct Copied<I> {\n+    it: I,\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+impl<'a, I, T: 'a> Iterator for Copied<I>\n+    where I: Iterator<Item=&'a T>, T: Copy\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.it.next().copied()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.it.size_hint()\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.it.try_fold(init, move |acc, &elt| f(acc, elt))\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.fold(init, move |acc, &elt| f(acc, elt))\n+    }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+impl<'a, I, T: 'a> DoubleEndedIterator for Copied<I>\n+    where I: DoubleEndedIterator<Item=&'a T>, T: Copy\n+{\n+    fn next_back(&mut self) -> Option<T> {\n+        self.it.next_back().copied()\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        self.it.try_rfold(init, move |acc, &elt| f(acc, elt))\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.rfold(init, move |acc, &elt| f(acc, elt))\n+    }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+impl<'a, I, T: 'a> ExactSizeIterator for Copied<I>\n+    where I: ExactSizeIterator<Item=&'a T>, T: Copy\n+{\n+    fn len(&self) -> usize {\n+        self.it.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.it.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+impl<'a, I, T: 'a> FusedIterator for Copied<I>\n+    where I: FusedIterator<Item=&'a T>, T: Copy\n+{}\n+\n+#[doc(hidden)]\n+unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Copied<I>\n+    where I: TrustedRandomAccess<Item=&'a T>, T: Copy\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        *self.it.get_unchecked(i)\n+    }\n+\n+    #[inline]\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+#[unstable(feature = \"iter_copied\", issue = \"57127\")]\n+unsafe impl<'a, I, T: 'a> TrustedLen for Copied<I>\n+    where I: TrustedLen<Item=&'a T>,\n+          T: Copy\n+{}\n+\n /// An iterator that clones the elements of an underlying iterator.\n ///\n /// This `struct` is created by the [`cloned`] method on [`Iterator`]. See its"}, {"sha": "6d4f4be1a17824ead0498e328b5af34ecd500dba", "filename": "src/libcore/option.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a7be40c65ae8ace467c9c40b0a22642973e31a13/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7be40c65ae8ace467c9c40b0a22642973e31a13/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=a7be40c65ae8ace467c9c40b0a22642973e31a13", "patch": "@@ -874,6 +874,48 @@ impl<T> Option<T> {\n     }\n }\n \n+impl<'a, T: Copy> Option<&'a T> {\n+    /// Maps an `Option<&T>` to an `Option<T>` by copying the contents of the\n+    /// option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(copied)]\n+    ///\n+    /// let x = 12;\n+    /// let opt_x = Some(&x);\n+    /// assert_eq!(opt_x, Some(&12));\n+    /// let copied = opt_x.copied();\n+    /// assert_eq!(copied, Some(12));\n+    /// ```\n+    #[unstable(feature = \"copied\", issue = \"57126\")]\n+    pub fn copied(self) -> Option<T> {\n+        self.map(|&t| t)\n+    }\n+}\n+\n+impl<'a, T: Copy> Option<&'a mut T> {\n+    /// Maps an `Option<&mut T>` to an `Option<T>` by copying the contents of the\n+    /// option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(copied)]\n+    ///\n+    /// let mut x = 12;\n+    /// let opt_x = Some(&mut x);\n+    /// assert_eq!(opt_x, Some(&mut 12));\n+    /// let copied = opt_x.copied();\n+    /// assert_eq!(copied, Some(12));\n+    /// ```\n+    #[unstable(feature = \"copied\", issue = \"57126\")]\n+    pub fn copied(self) -> Option<T> {\n+        self.map(|&mut t| t)\n+    }\n+}\n+\n impl<'a, T: Clone> Option<&'a T> {\n     /// Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the\n     /// option."}, {"sha": "cf19851c17b35ccc579a574d745aeb1582bff29f", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a7be40c65ae8ace467c9c40b0a22642973e31a13/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7be40c65ae8ace467c9c40b0a22642973e31a13/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=a7be40c65ae8ace467c9c40b0a22642973e31a13", "patch": "@@ -1253,6 +1253,23 @@ fn test_rev() {\n             vec![16, 14, 12, 10, 8, 6]);\n }\n \n+#[test]\n+fn test_copied() {\n+    let xs = [2, 4, 6, 8];\n+\n+    let mut it = xs.iter().copied();\n+    assert_eq!(it.len(), 4);\n+    assert_eq!(it.next(), Some(2));\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.next(), Some(4));\n+    assert_eq!(it.len(), 2);\n+    assert_eq!(it.next_back(), Some(8));\n+    assert_eq!(it.len(), 1);\n+    assert_eq!(it.next_back(), Some(6));\n+    assert_eq!(it.len(), 0);\n+    assert_eq!(it.next_back(), None);\n+}\n+\n #[test]\n fn test_cloned() {\n     let xs = [2, 4, 6, 8];"}, {"sha": "72846daf16a6b92beebb5c593542884be986ca40", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7be40c65ae8ace467c9c40b0a22642973e31a13/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7be40c65ae8ace467c9c40b0a22642973e31a13/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=a7be40c65ae8ace467c9c40b0a22642973e31a13", "patch": "@@ -1,5 +1,6 @@\n #![feature(box_syntax)]\n #![feature(cell_update)]\n+#![feature(copied)]\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]\n #![feature(dec2flt)]\n@@ -9,6 +10,7 @@\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n #![feature(hashmap_internals)]\n+#![feature(iter_copied)]\n #![feature(iter_nth_back)]\n #![feature(iter_unfold)]\n #![feature(pattern)]"}, {"sha": "b059b134868d999fae75fe4e75eba3c2ea03a3a7", "filename": "src/libcore/tests/option.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a7be40c65ae8ace467c9c40b0a22642973e31a13/src%2Flibcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7be40c65ae8ace467c9c40b0a22642973e31a13/src%2Flibcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Foption.rs?ref=a7be40c65ae8ace467c9c40b0a22642973e31a13", "patch": "@@ -238,6 +238,27 @@ fn test_collect() {\n     assert!(v == None);\n }\n \n+#[test]\n+fn test_copied() {\n+    let val = 1;\n+    let val_ref = &val;\n+    let opt_none: Option<&'static u32> = None;\n+    let opt_ref = Some(&val);\n+    let opt_ref_ref = Some(&val_ref);\n+\n+    // None works\n+    assert_eq!(opt_none.clone(), None);\n+    assert_eq!(opt_none.copied(), None);\n+\n+    // Immutable ref works\n+    assert_eq!(opt_ref.clone(), Some(&val));\n+    assert_eq!(opt_ref.copied(), Some(1));\n+\n+    // Double Immutable ref works\n+    assert_eq!(opt_ref_ref.clone(), Some(&val_ref));\n+    assert_eq!(opt_ref_ref.clone().copied(), Some(&val));\n+    assert_eq!(opt_ref_ref.copied().copied(), Some(1));\n+}\n \n #[test]\n fn test_cloned() {"}]}