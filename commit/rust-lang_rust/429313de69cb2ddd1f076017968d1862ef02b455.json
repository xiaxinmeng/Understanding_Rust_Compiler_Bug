{"sha": "429313de69cb2ddd1f076017968d1862ef02b455", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyOTMxM2RlNjljYjJkZGQxZjA3NjAxNzk2OGQxODYyZWYwMmI0NTU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-13T01:47:48Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-24T22:42:00Z"}, "message": "rustuv: Reimplement without using std::rt::sched\n\nThis reimplements librustuv without using the interfaces provided by the\nscheduler in libstd. This solely uses the new Runtime trait in order to\ninterface with the local task and perform the necessary scheduling operations.\n\nThe largest snag in this refactoring is reimplementing homing. The new runtime\ntrait exposes no concept of \"homing\" a task or forcibly sending a task to a\nremote scheduler (there is no concept of a scheduler). In order to reimplement\nhoming, the transferrence of tasks is now done at the librustuv level instead of\nthe scheduler level. This means that all I/O loops now have a concurrent queue\nwhich receives homing messages and requests.\n\nThis allows the entire implementation of librustuv to be only dependent on the\nruntime trait, severing all dependence of librustuv on the scheduler and related\ngreen-thread functions.\n\nThis is all in preparation of the introduction of libgreen and libnative.\n\nAt the same time, I also took the liberty of removing all glob imports from\nlibrustuv.", "tree": {"sha": "6bdf9da3c58a3a38e22fcc958c6b9e91509a0695", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bdf9da3c58a3a38e22fcc958c6b9e91509a0695"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/429313de69cb2ddd1f076017968d1862ef02b455", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/429313de69cb2ddd1f076017968d1862ef02b455", "html_url": "https://github.com/rust-lang/rust/commit/429313de69cb2ddd1f076017968d1862ef02b455", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/429313de69cb2ddd1f076017968d1862ef02b455/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ca77268d97b62e2fcaa1642aaf9313e164963b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ca77268d97b62e2fcaa1642aaf9313e164963b3", "html_url": "https://github.com/rust-lang/rust/commit/1ca77268d97b62e2fcaa1642aaf9313e164963b3"}], "stats": {"total": 1044, "additions": 644, "deletions": 400}, "files": [{"sha": "f4c12c6f2a398e08807ebbee49011af31c73d4c9", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -11,12 +11,10 @@\n use ai = std::io::net::addrinfo;\n use std::libc::c_int;\n use std::ptr::null;\n-use std::rt::BlockedTask;\n-use std::rt::local::Local;\n-use std::rt::sched::Scheduler;\n+use std::rt::task::BlockedTask;\n \n use net;\n-use super::{Loop, UvError, Request, wait_until_woken_after};\n+use super::{Loop, UvError, Request, wait_until_woken_after, wakeup};\n use uvll;\n \n struct Addrinfo {\n@@ -108,8 +106,7 @@ impl GetAddrInfoRequest {\n             cx.status = status;\n             cx.addrinfo = Some(Addrinfo { handle: res });\n \n-            let sched: ~Scheduler = Local::take();\n-            sched.resume_blocked_task_immediately(cx.slot.take_unwrap());\n+            wakeup(&mut cx.slot);\n         }\n     }\n }\n@@ -188,7 +185,6 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n #[cfg(test, not(target_os=\"android\"))]\n mod test {\n     use std::io::net::ip::{SocketAddr, Ipv4Addr};\n-    use super::*;\n     use super::super::local_loop;\n \n     #[test]"}, {"sha": "2d770ff6be1fe5e974a1ecabad8e2b7fd2f59def", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -129,7 +129,6 @@ mod test_remote {\n     use std::rt::thread::Thread;\n     use std::rt::tube::Tube;\n \n-    use super::*;\n     use super::super::local_loop;\n \n     // Make sure that we can fire watchers in remote threads and that they"}, {"sha": "cebf4f199e49c45192d4b3fb8fc09a595612680f", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -14,15 +14,15 @@ use std::cast::transmute;\n use std::cast;\n use std::libc::{c_int, c_char, c_void, size_t};\n use std::libc;\n-use std::rt::BlockedTask;\n+use std::rt::task::BlockedTask;\n use std::io::{FileStat, IoError};\n use std::io;\n-use std::rt::local::Local;\n use std::rt::rtio;\n-use std::rt::sched::{Scheduler, SchedHandle};\n+use std::vec;\n \n-use super::{Loop, UvError, uv_error_to_io_error, wait_until_woken_after};\n-use uvio::HomingIO;\n+use homing::{HomingIO, HomeHandle};\n+use super::{Loop, UvError, uv_error_to_io_error, wait_until_woken_after, wakeup};\n+use uvio::UvIoFactory;\n use uvll;\n \n pub struct FsRequest {\n@@ -34,19 +34,19 @@ pub struct FileWatcher {\n     priv loop_: Loop,\n     priv fd: c_int,\n     priv close: rtio::CloseBehavior,\n-    priv home: SchedHandle,\n+    priv home: HomeHandle,\n }\n \n impl FsRequest {\n-    pub fn open(loop_: &Loop, path: &CString, flags: int, mode: int)\n+    pub fn open(io: &mut UvIoFactory, path: &CString, flags: int, mode: int)\n         -> Result<FileWatcher, UvError>\n     {\n         execute(|req, cb| unsafe {\n-            uvll::uv_fs_open(loop_.handle,\n+            uvll::uv_fs_open(io.uv_loop(),\n                              req, path.with_ref(|p| p), flags as c_int,\n                              mode as c_int, cb)\n         }).map(|req|\n-            FileWatcher::new(*loop_, req.get_result() as c_int,\n+            FileWatcher::new(io, req.get_result() as c_int,\n                              rtio::CloseSynchronously)\n         )\n     }\n@@ -320,8 +320,7 @@ fn execute(f: |*uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n         let slot: &mut Option<BlockedTask> = unsafe {\n             cast::transmute(uvll::get_data_for_req(req))\n         };\n-        let sched: ~Scheduler = Local::take();\n-        sched.resume_blocked_task_immediately(slot.take_unwrap());\n+        wakeup(slot);\n     }\n }\n \n@@ -331,16 +330,17 @@ fn execute_nop(f: |*uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n }\n \n impl HomingIO for FileWatcher {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl FileWatcher {\n-    pub fn new(loop_: Loop, fd: c_int, close: rtio::CloseBehavior) -> FileWatcher {\n+    pub fn new(io: &mut UvIoFactory, fd: c_int,\n+               close: rtio::CloseBehavior) -> FileWatcher {\n         FileWatcher {\n-            loop_: loop_,\n+            loop_: Loop::wrap(io.uv_loop()),\n             fd: fd,\n             close: close,\n-            home: get_handle_to_current_scheduler!()\n+            home: io.make_handle(),\n         }\n     }\n \n@@ -448,7 +448,6 @@ mod test {\n     use std::io;\n     use std::str;\n     use std::vec;\n-    use super::*;\n     use l = super::super::local_loop;\n \n     #[test]"}, {"sha": "7a12c4ad06d6c27d19bc7625345f845b8ad7bd02", "filename": "src/librustuv/homing.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -0,0 +1,144 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Homing I/O implementation\n+//!\n+//! In libuv, whenever a handle is created on an I/O loop it is illegal to use\n+//! that handle outside of that I/O loop. We use libuv I/O with our green\n+//! scheduler, and each green scheduler corresponds to a different I/O loop on a\n+//! different OS thread. Green tasks are also free to roam among schedulers,\n+//! which implies that it is possible to create an I/O handle on one event loop\n+//! and then attempt to use it on another.\n+//!\n+//! In order to solve this problem, this module implements the notion of a\n+//! \"homing operation\" which will transplant a task from its currently running\n+//! scheduler back onto the original I/O loop. This is accomplished entirely at\n+//! the librustuv layer with very little cooperation from the scheduler (which\n+//! we don't even know exists technically).\n+//!\n+//! These homing operations are completed by first realizing that we're on the\n+//! wrong I/O loop, then descheduling ourselves, sending ourselves to the\n+//! correct I/O loop, and then waking up the I/O loop in order to process its\n+//! local queue of tasks which need to run.\n+//!\n+//! This enqueueing is done with a concurrent queue from libstd, and the\n+//! signalling is achieved with an async handle.\n+\n+use std::rt::local::Local;\n+use std::rt::rtio::LocalIo;\n+use std::rt::task::{Task, BlockedTask};\n+\n+use ForbidUnwind;\n+use queue::{Queue, QueuePool};\n+\n+/// A handle to a remote libuv event loop. This handle will keep the event loop\n+/// alive while active in order to ensure that a homing operation can always be\n+/// completed.\n+///\n+/// Handles are clone-able in order to derive new handles from existing handles\n+/// (very useful for when accepting a socket from a server).\n+pub struct HomeHandle {\n+    priv queue: Queue,\n+    priv id: uint,\n+}\n+\n+impl HomeHandle {\n+    pub fn new(id: uint, pool: &mut QueuePool) -> HomeHandle {\n+        HomeHandle { queue: pool.queue(), id: id }\n+    }\n+\n+    fn send(&mut self, task: BlockedTask) {\n+        self.queue.push(task);\n+    }\n+}\n+\n+impl Clone for HomeHandle {\n+    fn clone(&self) -> HomeHandle {\n+        HomeHandle {\n+            queue: self.queue.clone(),\n+            id: self.id,\n+        }\n+    }\n+}\n+\n+pub trait HomingIO {\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle;\n+\n+    /// This function will move tasks to run on their home I/O scheduler. Note\n+    /// that this function does *not* pin the task to the I/O scheduler, but\n+    /// rather it simply moves it to running on the I/O scheduler.\n+    fn go_to_IO_home(&mut self) -> uint {\n+        let _f = ForbidUnwind::new(\"going home\");\n+\n+        let mut cur_task: ~Task = Local::take();\n+        let cur_loop_id = {\n+            let mut io = cur_task.local_io().expect(\"libuv must have I/O\");\n+            io.get().id()\n+        };\n+\n+        // Try at all costs to avoid the homing operation because it is quite\n+        // expensive. Hence, we only deschedule/send if we're not on the correct\n+        // event loop. If we're already on the home event loop, then we're good\n+        // to go (remember we have no preemption, so we're guaranteed to stay on\n+        // this event loop as long as we avoid the scheduler).\n+        if cur_loop_id != self.home().id {\n+            cur_task.deschedule(1, |task| {\n+                self.home().send(task);\n+                Ok(())\n+            });\n+\n+            // Once we wake up, assert that we're in the right location\n+            let cur_loop_id = {\n+                let mut io = LocalIo::borrow().expect(\"libuv must have I/O\");\n+                io.get().id()\n+            };\n+            assert_eq!(cur_loop_id, self.home().id);\n+\n+            cur_loop_id\n+        } else {\n+            Local::put(cur_task);\n+            cur_loop_id\n+        }\n+    }\n+\n+    /// Fires a single homing missile, returning another missile targeted back\n+    /// at the original home of this task. In other words, this function will\n+    /// move the local task to its I/O scheduler and then return an RAII wrapper\n+    /// which will return the task home.\n+    fn fire_homing_missile(&mut self) -> HomingMissile {\n+        HomingMissile { io_home: self.go_to_IO_home() }\n+    }\n+}\n+\n+/// After a homing operation has been completed, this will return the current\n+/// task back to its appropriate home (if applicable). The field is used to\n+/// assert that we are where we think we are.\n+struct HomingMissile {\n+    priv io_home: uint,\n+}\n+\n+impl HomingMissile {\n+    /// Check at runtime that the task has *not* transplanted itself to a\n+    /// different I/O loop while executing.\n+    pub fn check(&self, msg: &'static str) {\n+        let mut io = LocalIo::borrow().expect(\"libuv must have I/O\");\n+        assert!(io.get().id() == self.io_home, \"{}\", msg);\n+    }\n+}\n+\n+impl Drop for HomingMissile {\n+    fn drop(&mut self) {\n+        let _f = ForbidUnwind::new(\"leaving home\");\n+\n+        // It would truly be a sad day if we had moved off the home I/O\n+        // scheduler while we were doing I/O.\n+        self.check(\"task moved away from the home scheduler\");\n+    }\n+}"}, {"sha": "2445932c026b8b5f4a69616aab48db1fbeb84991", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -97,7 +97,6 @@ impl Drop for IdleWatcher {\n \n #[cfg(test)]\n mod test {\n-    use super::*;\n     use std::rt::tube::Tube;\n     use std::rt::rtio::{Callback, PausableIdleCallback};\n     use super::super::local_loop;"}, {"sha": "2715f0bd02a1647267d154911fb4d707043c792a", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -41,23 +41,22 @@ via `close` and `delete` methods.\n #[crate_type = \"rlib\"];\n #[crate_type = \"dylib\"];\n \n-#[feature(macro_rules, globs)];\n+#[feature(macro_rules)];\n \n-use std::cast::transmute;\n use std::cast;\n+use std::io;\n+use std::io::IoError;\n use std::libc::{c_int, malloc};\n use std::ptr::null;\n use std::ptr;\n-use std::rt::BlockedTask;\n use std::rt::local::Local;\n-use std::rt::sched::Scheduler;\n+use std::rt::task::{BlockedTask, Task};\n+use std::rt::rtio::LocalIo;\n use std::str::raw::from_c_str;\n use std::str;\n use std::task;\n use std::unstable::finally::Finally;\n \n-use std::io::IoError;\n-\n pub use self::async::AsyncWatcher;\n pub use self::file::{FsRequest, FileWatcher};\n pub use self::idle::IdleWatcher;\n@@ -70,6 +69,9 @@ pub use self::tty::TtyWatcher;\n \n mod macros;\n \n+mod queue;\n+mod homing;\n+\n /// The implementation of `rtio` for libuv\n pub mod uvio;\n \n@@ -144,32 +146,31 @@ pub trait UvHandle<T> {\n                 uvll::free_handle(handle);\n                 if data == ptr::null() { return }\n                 let slot: &mut Option<BlockedTask> = cast::transmute(data);\n-                let sched: ~Scheduler = Local::take();\n-                sched.resume_blocked_task_immediately(slot.take_unwrap());\n+                wakeup(slot);\n             }\n         }\n     }\n }\n \n pub struct ForbidSwitch {\n-    msg: &'static str,\n-    sched: uint,\n+    priv msg: &'static str,\n+    priv io: uint,\n }\n \n impl ForbidSwitch {\n     fn new(s: &'static str) -> ForbidSwitch {\n-        let mut sched = Local::borrow(None::<Scheduler>);\n+        let mut io = LocalIo::borrow().expect(\"libuv must have local I/O\");\n         ForbidSwitch {\n             msg: s,\n-            sched: sched.get().sched_id(),\n+            io: io.get().id(),\n         }\n     }\n }\n \n impl Drop for ForbidSwitch {\n     fn drop(&mut self) {\n-        let mut sched = Local::borrow(None::<Scheduler>);\n-        assert!(self.sched == sched.get().sched_id(),\n+        let mut io = LocalIo::borrow().expect(\"libuv must have local I/O\");\n+        assert!(self.io == io.get().id(),\n                 \"didnt want a scheduler switch: {}\",\n                 self.msg);\n     }\n@@ -199,14 +200,20 @@ fn wait_until_woken_after(slot: *mut Option<BlockedTask>, f: ||) {\n     let _f = ForbidUnwind::new(\"wait_until_woken_after\");\n     unsafe {\n         assert!((*slot).is_none());\n-        let sched: ~Scheduler = Local::take();\n-        sched.deschedule_running_task_and_then(|_, task| {\n-            f();\n+        let task: ~Task = Local::take();\n+        task.deschedule(1, |task| {\n             *slot = Some(task);\n-        })\n+            f();\n+            Ok(())\n+        });\n     }\n }\n \n+fn wakeup(slot: &mut Option<BlockedTask>) {\n+    assert!(slot.is_some());\n+    slot.take_unwrap().wake().map(|t| t.reawaken(true));\n+}\n+\n pub struct Request {\n     handle: *uvll::uv_req_t,\n     priv defused: bool,\n@@ -325,28 +332,26 @@ fn error_smoke_test() {\n pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n     unsafe {\n         // Importing error constants\n-        use uvll::*;\n-        use std::io::*;\n \n         // uv error descriptions are static\n         let c_desc = uvll::uv_strerror(*uverr);\n         let desc = str::raw::c_str_to_static_slice(c_desc);\n \n         let kind = match *uverr {\n-            UNKNOWN => OtherIoError,\n-            OK => OtherIoError,\n-            EOF => EndOfFile,\n-            EACCES => PermissionDenied,\n-            ECONNREFUSED => ConnectionRefused,\n-            ECONNRESET => ConnectionReset,\n-            ENOENT => FileNotFound,\n-            ENOTCONN => NotConnected,\n-            EPIPE => BrokenPipe,\n-            ECONNABORTED => ConnectionAborted,\n+            uvll::UNKNOWN => io::OtherIoError,\n+            uvll::OK => io::OtherIoError,\n+            uvll::EOF => io::EndOfFile,\n+            uvll::EACCES => io::PermissionDenied,\n+            uvll::ECONNREFUSED => io::ConnectionRefused,\n+            uvll::ECONNRESET => io::ConnectionReset,\n+            uvll::ENOTCONN => io::NotConnected,\n+            uvll::ENOENT => io::FileNotFound,\n+            uvll::EPIPE => io::BrokenPipe,\n+            uvll::ECONNABORTED => io::ConnectionAborted,\n             err => {\n                 uvdebug!(\"uverr.code {}\", err as int);\n                 // XXX: Need to map remaining uv error types\n-                OtherIoError\n+                io::OtherIoError\n             }\n         };\n "}, {"sha": "61b4de5765592419385aa3f25130381a4546225d", "filename": "src/librustuv/macros.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fmacros.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -27,18 +27,21 @@ macro_rules! uvdebug (\n     })\n )\n \n-// get a handle for the current scheduler\n-macro_rules! get_handle_to_current_scheduler(\n-    () => ({\n-        let mut sched = Local::borrow(None::<Scheduler>);\n-        sched.get().make_handle()\n-    })\n-)\n-\n pub fn dumb_println(args: &fmt::Arguments) {\n-    use std::io::native::file::FileDesc;\n     use std::io;\n     use std::libc;\n-    let mut out = FileDesc::new(libc::STDERR_FILENO, false);\n-    fmt::writeln(&mut out as &mut io::Writer, args);\n+    use std::vec;\n+\n+    struct Stderr;\n+    impl io::Writer for Stderr {\n+        fn write(&mut self, data: &[u8]) {\n+            unsafe {\n+                libc::write(libc::STDERR_FILENO,\n+                            vec::raw::to_ptr(data) as *libc::c_void,\n+                            data.len() as libc::size_t);\n+            }\n+        }\n+    }\n+    let mut w = Stderr;\n+    fmt::writeln(&mut w as &mut io::Writer, args);\n }"}, {"sha": "caf9ee0aac636fdb686fa44b9745f91e11ed21e6", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 41, "deletions": 50, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -9,24 +9,22 @@\n // except according to those terms.\n \n use std::cast;\n-use std::libc;\n-use std::libc::{size_t, ssize_t, c_int, c_void, c_uint, c_char};\n-use std::ptr;\n-use std::rt::BlockedTask;\n use std::io::IoError;\n use std::io::net::ip::{Ipv4Addr, Ipv6Addr, SocketAddr, IpAddr};\n-use std::rt::local::Local;\n+use std::libc::{size_t, ssize_t, c_int, c_void, c_uint, c_char};\n+use std::libc;\n+use std::ptr;\n use std::rt::rtio;\n-use std::rt::sched::{Scheduler, SchedHandle};\n-use std::rt::tube::Tube;\n+use std::rt::task::BlockedTask;\n use std::str;\n use std::vec;\n \n+use homing::{HomingIO, HomeHandle};\n use stream::StreamWatcher;\n use super::{Loop, Request, UvError, Buf, status_to_io_result,\n             uv_error_to_io_error, UvHandle, slice_to_uv_buf,\n-            wait_until_woken_after};\n-use uvio::HomingIO;\n+            wait_until_woken_after, wakeup};\n+use uvio::UvIoFactory;\n use uvll;\n use uvll::sockaddr;\n \n@@ -145,42 +143,47 @@ fn socket_name(sk: SocketNameKind, handle: *c_void) -> Result<SocketAddr, IoErro\n pub struct TcpWatcher {\n     handle: *uvll::uv_tcp_t,\n     stream: StreamWatcher,\n-    home: SchedHandle,\n+    home: HomeHandle,\n }\n \n pub struct TcpListener {\n-    home: SchedHandle,\n+    home: HomeHandle,\n     handle: *uvll::uv_pipe_t,\n     priv closing_task: Option<BlockedTask>,\n-    priv outgoing: Tube<Result<~rtio::RtioTcpStream, IoError>>,\n+    priv outgoing: Chan<Result<~rtio::RtioTcpStream, IoError>>,\n+    priv incoming: Port<Result<~rtio::RtioTcpStream, IoError>>,\n }\n \n pub struct TcpAcceptor {\n     listener: ~TcpListener,\n-    priv incoming: Tube<Result<~rtio::RtioTcpStream, IoError>>,\n }\n \n // TCP watchers (clients/streams)\n \n impl TcpWatcher {\n-    pub fn new(loop_: &Loop) -> TcpWatcher {\n+    pub fn new(io: &mut UvIoFactory) -> TcpWatcher {\n+        let handle = io.make_handle();\n+        TcpWatcher::new_home(&io.loop_, handle)\n+    }\n+\n+    fn new_home(loop_: &Loop, home: HomeHandle) -> TcpWatcher {\n         let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n         assert_eq!(unsafe {\n             uvll::uv_tcp_init(loop_.handle, handle)\n         }, 0);\n         TcpWatcher {\n-            home: get_handle_to_current_scheduler!(),\n+            home: home,\n             handle: handle,\n             stream: StreamWatcher::new(handle),\n         }\n     }\n \n-    pub fn connect(loop_: &mut Loop, address: SocketAddr)\n+    pub fn connect(io: &mut UvIoFactory, address: SocketAddr)\n         -> Result<TcpWatcher, UvError>\n     {\n         struct Ctx { status: c_int, task: Option<BlockedTask> }\n \n-        let tcp = TcpWatcher::new(loop_);\n+        let tcp = TcpWatcher::new(io);\n         let ret = socket_addr_as_sockaddr(address, |addr| {\n             let mut req = Request::new(uvll::UV_CONNECT);\n             let result = unsafe {\n@@ -213,14 +216,13 @@ impl TcpWatcher {\n             assert!(status != uvll::ECANCELED);\n             let cx: &mut Ctx = unsafe { req.get_data() };\n             cx.status = status;\n-            let scheduler: ~Scheduler = Local::take();\n-            scheduler.resume_blocked_task_immediately(cx.task.take_unwrap());\n+            wakeup(&mut cx.task);\n         }\n     }\n }\n \n impl HomingIO for TcpWatcher {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl rtio::RtioSocket for TcpWatcher {\n@@ -290,17 +292,19 @@ impl Drop for TcpWatcher {\n // TCP listeners (unbound servers)\n \n impl TcpListener {\n-    pub fn bind(loop_: &mut Loop, address: SocketAddr)\n+    pub fn bind(io: &mut UvIoFactory, address: SocketAddr)\n                 -> Result<~TcpListener, UvError> {\n         let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n         assert_eq!(unsafe {\n-            uvll::uv_tcp_init(loop_.handle, handle)\n+            uvll::uv_tcp_init(io.uv_loop(), handle)\n         }, 0);\n+        let (port, chan) = Chan::new();\n         let l = ~TcpListener {\n-            home: get_handle_to_current_scheduler!(),\n+            home: io.make_handle(),\n             handle: handle,\n             closing_task: None,\n-            outgoing: Tube::new(),\n+            outgoing: chan,\n+            incoming: port,\n         };\n         let res = socket_addr_as_sockaddr(address, |addr| unsafe {\n             uvll::uv_tcp_bind(l.handle, addr)\n@@ -313,7 +317,7 @@ impl TcpListener {\n }\n \n impl HomingIO for TcpListener {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl UvHandle<uvll::uv_tcp_t> for TcpListener {\n@@ -330,11 +334,7 @@ impl rtio::RtioSocket for TcpListener {\n impl rtio::RtioTcpListener for TcpListener {\n     fn listen(mut ~self) -> Result<~rtio::RtioTcpAcceptor, IoError> {\n         // create the acceptor object from ourselves\n-        let incoming = self.outgoing.clone();\n-        let mut acceptor = ~TcpAcceptor {\n-            listener: self,\n-            incoming: incoming,\n-        };\n+        let mut acceptor = ~TcpAcceptor { listener: self };\n \n         let _m = acceptor.fire_homing_missile();\n         // XXX: the 128 backlog should be configurable\n@@ -347,19 +347,18 @@ impl rtio::RtioTcpListener for TcpListener {\n \n extern fn listen_cb(server: *uvll::uv_stream_t, status: c_int) {\n     assert!(status != uvll::ECANCELED);\n+    let tcp: &mut TcpListener = unsafe { UvHandle::from_uv_handle(&server) };\n     let msg = match status {\n         0 => {\n             let loop_ = Loop::wrap(unsafe {\n                 uvll::get_loop_for_uv_handle(server)\n             });\n-            let client = TcpWatcher::new(&loop_);\n+            let client = TcpWatcher::new_home(&loop_, tcp.home().clone());\n             assert_eq!(unsafe { uvll::uv_accept(server, client.handle) }, 0);\n             Ok(~client as ~rtio::RtioTcpStream)\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n-\n-    let tcp: &mut TcpListener = unsafe { UvHandle::from_uv_handle(&server) };\n     tcp.outgoing.send(msg);\n }\n \n@@ -373,7 +372,7 @@ impl Drop for TcpListener {\n // TCP acceptors (bound servers)\n \n impl HomingIO for TcpAcceptor {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.listener.home() }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { self.listener.home() }\n }\n \n impl rtio::RtioSocket for TcpAcceptor {\n@@ -385,8 +384,7 @@ impl rtio::RtioSocket for TcpAcceptor {\n \n impl rtio::RtioTcpAcceptor for TcpAcceptor {\n     fn accept(&mut self) -> Result<~rtio::RtioTcpStream, IoError> {\n-        let _m = self.fire_homing_missile();\n-        self.incoming.recv()\n+        self.listener.incoming.recv()\n     }\n \n     fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n@@ -410,18 +408,18 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n \n pub struct UdpWatcher {\n     handle: *uvll::uv_udp_t,\n-    home: SchedHandle,\n+    home: HomeHandle,\n }\n \n impl UdpWatcher {\n-    pub fn bind(loop_: &Loop, address: SocketAddr)\n+    pub fn bind(io: &mut UvIoFactory, address: SocketAddr)\n                 -> Result<UdpWatcher, UvError> {\n         let udp = UdpWatcher {\n             handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n-            home: get_handle_to_current_scheduler!(),\n+            home: io.make_handle(),\n         };\n         assert_eq!(unsafe {\n-            uvll::uv_udp_init(loop_.handle, udp.handle)\n+            uvll::uv_udp_init(io.uv_loop(), udp.handle)\n         }, 0);\n         let result = socket_addr_as_sockaddr(address, |addr| unsafe {\n             uvll::uv_udp_bind(udp.handle, addr, 0u32)\n@@ -438,7 +436,7 @@ impl UvHandle<uvll::uv_udp_t> for UdpWatcher {\n }\n \n impl HomingIO for UdpWatcher {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl rtio::RtioSocket for UdpWatcher {\n@@ -519,9 +517,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                 Some(sockaddr_to_socket_addr(addr))\n             };\n             cx.result = Some((nread, addr));\n-\n-            let sched: ~Scheduler = Local::take();\n-            sched.resume_blocked_task_immediately(cx.task.take_unwrap());\n+            wakeup(&mut cx.task);\n         }\n     }\n \n@@ -556,9 +552,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             assert!(status != uvll::ECANCELED);\n             let cx: &mut Ctx = unsafe { req.get_data() };\n             cx.result = status;\n-\n-            let sched: ~Scheduler = Local::take();\n-            sched.resume_blocked_task_immediately(cx.task.take_unwrap());\n+            wakeup(&mut cx.task);\n         }\n     }\n \n@@ -646,12 +640,10 @@ impl Drop for UdpWatcher {\n \n #[cfg(test)]\n mod test {\n-    use std::rt::test::*;\n     use std::rt::rtio::{RtioTcpStream, RtioTcpListener, RtioTcpAcceptor,\n                         RtioUdpSocket};\n     use std::task;\n \n-    use super::*;\n     use super::super::local_loop;\n \n     #[test]\n@@ -824,7 +816,6 @@ mod test {\n \n     #[test]\n     fn test_read_read_read() {\n-        use std::rt::rtio::*;\n         let addr = next_test_ip4();\n         static MAX: uint = 5000;\n         let (port, chan) = Chan::new();"}, {"sha": "6975ef26bd764b2dde4723fd6b1325482a922a65", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -9,35 +9,33 @@\n // except according to those terms.\n \n use std::c_str::CString;\n-use std::libc;\n-use std::rt::BlockedTask;\n use std::io::IoError;\n-use std::rt::local::Local;\n+use std::libc;\n use std::rt::rtio::{RtioPipe, RtioUnixListener, RtioUnixAcceptor};\n-use std::rt::sched::{Scheduler, SchedHandle};\n-use std::rt::tube::Tube;\n+use std::rt::task::BlockedTask;\n \n+use homing::{HomingIO, HomeHandle};\n use stream::StreamWatcher;\n use super::{Loop, UvError, UvHandle, Request, uv_error_to_io_error,\n-            wait_until_woken_after};\n-use uvio::HomingIO;\n+            wait_until_woken_after, wakeup};\n+use uvio::UvIoFactory;\n use uvll;\n \n pub struct PipeWatcher {\n     stream: StreamWatcher,\n-    home: SchedHandle,\n+    home: HomeHandle,\n     priv defused: bool,\n }\n \n pub struct PipeListener {\n-    home: SchedHandle,\n+    home: HomeHandle,\n     pipe: *uvll::uv_pipe_t,\n-    priv outgoing: Tube<Result<~RtioPipe, IoError>>,\n+    priv outgoing: Chan<Result<~RtioPipe, IoError>>,\n+    priv incoming: Port<Result<~RtioPipe, IoError>>,\n }\n \n pub struct PipeAcceptor {\n     listener: ~PipeListener,\n-    priv incoming: Tube<Result<~RtioPipe, IoError>>,\n }\n \n // PipeWatcher implementation and traits\n@@ -46,7 +44,12 @@ impl PipeWatcher {\n     // Creates an uninitialized pipe watcher. The underlying uv pipe is ready to\n     // get bound to some other source (this is normally a helper method paired\n     // with another call).\n-    pub fn new(loop_: &Loop, ipc: bool) -> PipeWatcher {\n+    pub fn new(io: &mut UvIoFactory, ipc: bool) -> PipeWatcher {\n+        let home = io.make_handle();\n+        PipeWatcher::new_home(&io.loop_, home, ipc)\n+    }\n+\n+    pub fn new_home(loop_: &Loop, home: HomeHandle, ipc: bool) -> PipeWatcher {\n         let handle = unsafe {\n             let handle = uvll::malloc_handle(uvll::UV_NAMED_PIPE);\n             assert!(!handle.is_null());\n@@ -56,26 +59,28 @@ impl PipeWatcher {\n         };\n         PipeWatcher {\n             stream: StreamWatcher::new(handle),\n-            home: get_handle_to_current_scheduler!(),\n+            home: home,\n             defused: false,\n         }\n     }\n \n-    pub fn open(loop_: &Loop, file: libc::c_int) -> Result<PipeWatcher, UvError>\n+    pub fn open(io: &mut UvIoFactory, file: libc::c_int)\n+        -> Result<PipeWatcher, UvError>\n     {\n-        let pipe = PipeWatcher::new(loop_, false);\n+        let pipe = PipeWatcher::new(io, false);\n         match unsafe { uvll::uv_pipe_open(pipe.handle(), file) } {\n             0 => Ok(pipe),\n             n => Err(UvError(n))\n         }\n     }\n \n-    pub fn connect(loop_: &Loop, name: &CString) -> Result<PipeWatcher, UvError>\n+    pub fn connect(io: &mut UvIoFactory, name: &CString)\n+        -> Result<PipeWatcher, UvError>\n     {\n         struct Ctx { task: Option<BlockedTask>, result: libc::c_int, }\n         let mut cx = Ctx { task: None, result: 0 };\n         let mut req = Request::new(uvll::UV_CONNECT);\n-        let pipe = PipeWatcher::new(loop_, false);\n+        let pipe = PipeWatcher::new(io, false);\n \n         wait_until_woken_after(&mut cx.task, || {\n             unsafe {\n@@ -97,8 +102,7 @@ impl PipeWatcher {\n             assert!(status != uvll::ECANCELED);\n             let cx: &mut Ctx = unsafe { req.get_data() };\n             cx.result = status;\n-            let sched: ~Scheduler = Local::take();\n-            sched.resume_blocked_task_immediately(cx.task.take_unwrap());\n+            wakeup(&mut cx.task);\n         }\n     }\n \n@@ -125,7 +129,7 @@ impl RtioPipe for PipeWatcher {\n }\n \n impl HomingIO for PipeWatcher {\n-    fn home<'a>(&'a mut self) -> &'a mut SchedHandle { &mut self.home }\n+    fn home<'a>(&'a mut self) -> &'a mut HomeHandle { &mut self.home }\n }\n \n impl UvHandle<uvll::uv_pipe_t> for PipeWatcher {\n@@ -144,19 +148,23 @@ impl Drop for PipeWatcher {\n // PipeListener implementation and traits\n \n impl PipeListener {\n-    pub fn bind(loop_: &Loop, name: &CString) -> Result<~PipeListener, UvError> {\n-        let pipe = PipeWatcher::new(loop_, false);\n+    pub fn bind(io: &mut UvIoFactory, name: &CString)\n+        -> Result<~PipeListener, UvError>\n+    {\n+        let pipe = PipeWatcher::new(io, false);\n         match unsafe {\n             uvll::uv_pipe_bind(pipe.handle(), name.with_ref(|p| p))\n         } {\n             0 => {\n                 // If successful, unwrap the PipeWatcher because we control how\n                 // we close the pipe differently. We can't rely on\n                 // StreamWatcher's default close method.\n+                let (port, chan) = Chan::new();\n                 let p = ~PipeListener {\n-                    home: get_handle_to_current_scheduler!(),\n+                    home: io.make_handle(),\n                     pipe: pipe.unwrap(),\n-                    outgoing: Tube::new(),\n+                    incoming: port,\n+                    outgoing: chan,\n                 };\n                 Ok(p.install())\n             }\n@@ -168,11 +176,7 @@ impl PipeListener {\n impl RtioUnixListener for PipeListener {\n     fn listen(mut ~self) -> Result<~RtioUnixAcceptor, IoError> {\n         // create the acceptor object from ourselves\n-        let incoming = self.outgoing.clone();\n-        let mut acceptor = ~PipeAcceptor {\n-            listener: self,\n-            incoming: incoming,\n-        };\n+        let mut acceptor = ~PipeAcceptor { listener: self };\n \n         let _m = acceptor.fire_homing_missile();\n         // XXX: the 128 backlog should be configurable\n@@ -184,7 +188,7 @@ impl RtioUnixListener for PipeListener {\n }\n \n impl HomingIO for PipeListener {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl UvHandle<uvll::uv_pipe_t> for PipeListener {\n@@ -193,20 +197,20 @@ impl UvHandle<uvll::uv_pipe_t> for PipeListener {\n \n extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) {\n     assert!(status != uvll::ECANCELED);\n+\n+    let pipe: &mut PipeListener = unsafe { UvHandle::from_uv_handle(&server) };\n     let msg = match status {\n         0 => {\n             let loop_ = Loop::wrap(unsafe {\n                 uvll::get_loop_for_uv_handle(server)\n             });\n-            let client = PipeWatcher::new(&loop_, false);\n+            let client = PipeWatcher::new_home(&loop_, pipe.home().clone(), false);\n             assert_eq!(unsafe { uvll::uv_accept(server, client.handle()) }, 0);\n             Ok(~client as ~RtioPipe)\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n-\n-    let pipe: &mut PipeListener = unsafe { UvHandle::from_uv_handle(&server) };\n-    pipe.outgoing.send(msg);\n+    pipe.outgoing.send_deferred(msg);\n }\n \n impl Drop for PipeListener {\n@@ -220,21 +224,19 @@ impl Drop for PipeListener {\n \n impl RtioUnixAcceptor for PipeAcceptor {\n     fn accept(&mut self) -> Result<~RtioPipe, IoError> {\n-        let _m = self.fire_homing_missile();\n-        self.incoming.recv()\n+        self.listener.incoming.recv()\n     }\n }\n \n impl HomingIO for PipeAcceptor {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.listener.home() }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.listener.home }\n }\n \n #[cfg(test)]\n mod tests {\n     use std::rt::rtio::{RtioUnixListener, RtioUnixAcceptor, RtioPipe};\n     use std::rt::test::next_test_unix;\n \n-    use super::*;\n     use super::super::local_loop;\n \n     #[test]"}, {"sha": "7b7a16d7084e5aa8da28c5e64d246e369719f410", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -8,40 +8,39 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::io::IoError;\n+use std::io::process;\n use std::libc::c_int;\n use std::libc;\n use std::ptr;\n-use std::rt::BlockedTask;\n-use std::io::IoError;\n-use std::io::process::*;\n-use std::rt::local::Local;\n use std::rt::rtio::RtioProcess;\n-use std::rt::sched::{Scheduler, SchedHandle};\n+use std::rt::task::BlockedTask;\n use std::vec;\n \n-use super::{Loop, UvHandle, UvError, uv_error_to_io_error,\n-            wait_until_woken_after};\n-use uvio::HomingIO;\n-use uvll;\n+use homing::{HomingIO, HomeHandle};\n use pipe::PipeWatcher;\n+use super::{UvHandle, UvError, uv_error_to_io_error,\n+            wait_until_woken_after, wakeup};\n+use uvio::UvIoFactory;\n+use uvll;\n \n pub struct Process {\n     handle: *uvll::uv_process_t,\n-    home: SchedHandle,\n+    home: HomeHandle,\n \n     /// Task to wake up (may be null) for when the process exits\n     to_wake: Option<BlockedTask>,\n \n     /// Collected from the exit_cb\n-    exit_status: Option<ProcessExit>,\n+    exit_status: Option<process::ProcessExit>,\n }\n \n impl Process {\n     /// Spawn a new process inside the specified event loop.\n     ///\n     /// Returns either the corresponding process object or an error which\n     /// occurred.\n-    pub fn spawn(loop_: &Loop, config: ProcessConfig)\n+    pub fn spawn(io_loop: &mut UvIoFactory, config: process::ProcessConfig)\n                 -> Result<(~Process, ~[Option<PipeWatcher>]), UvError>\n     {\n         let cwd = config.cwd.map(|s| s.to_c_str());\n@@ -52,7 +51,7 @@ impl Process {\n             stdio.set_len(io.len());\n             for (slot, other) in stdio.iter().zip(io.iter()) {\n                 let io = set_stdio(slot as *uvll::uv_stdio_container_t, other,\n-                                   loop_);\n+                                   io_loop);\n                 ret_io.push(io);\n             }\n         }\n@@ -78,12 +77,12 @@ impl Process {\n                 let handle = UvHandle::alloc(None::<Process>, uvll::UV_PROCESS);\n                 let process = ~Process {\n                     handle: handle,\n-                    home: get_handle_to_current_scheduler!(),\n+                    home: io_loop.make_handle(),\n                     to_wake: None,\n                     exit_status: None,\n                 };\n                 match unsafe {\n-                    uvll::uv_spawn(loop_.handle, handle, &options)\n+                    uvll::uv_spawn(io_loop.uv_loop(), handle, &options)\n                 } {\n                     0 => Ok(process.install()),\n                     err => Err(UvError(err)),\n@@ -105,41 +104,36 @@ extern fn on_exit(handle: *uvll::uv_process_t,\n \n     assert!(p.exit_status.is_none());\n     p.exit_status = Some(match term_signal {\n-        0 => ExitStatus(exit_status as int),\n-        n => ExitSignal(n as int),\n+        0 => process::ExitStatus(exit_status as int),\n+        n => process::ExitSignal(n as int),\n     });\n \n-    match p.to_wake.take() {\n-        Some(task) => {\n-            let scheduler: ~Scheduler = Local::take();\n-            scheduler.resume_blocked_task_immediately(task);\n-        }\n-        None => {}\n-    }\n+    if p.to_wake.is_none() { return }\n+    wakeup(&mut p.to_wake);\n }\n \n unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n-                    io: &StdioContainer,\n-                    loop_: &Loop) -> Option<PipeWatcher> {\n+                    io: &process::StdioContainer,\n+                    io_loop: &mut UvIoFactory) -> Option<PipeWatcher> {\n     match *io {\n-        Ignored => {\n+        process::Ignored => {\n             uvll::set_stdio_container_flags(dst, uvll::STDIO_IGNORE);\n             None\n         }\n-        InheritFd(fd) => {\n+        process::InheritFd(fd) => {\n             uvll::set_stdio_container_flags(dst, uvll::STDIO_INHERIT_FD);\n             uvll::set_stdio_container_fd(dst, fd);\n             None\n         }\n-        CreatePipe(readable, writable) => {\n+        process::CreatePipe(readable, writable) => {\n             let mut flags = uvll::STDIO_CREATE_PIPE as libc::c_int;\n             if readable {\n                 flags |= uvll::STDIO_READABLE_PIPE as libc::c_int;\n             }\n             if writable {\n                 flags |= uvll::STDIO_WRITABLE_PIPE as libc::c_int;\n             }\n-            let pipe = PipeWatcher::new(loop_, false);\n+            let pipe = PipeWatcher::new(io_loop, false);\n             uvll::set_stdio_container_flags(dst, flags);\n             uvll::set_stdio_container_stream(dst, pipe.handle());\n             Some(pipe)\n@@ -186,7 +180,7 @@ fn with_env<T>(env: Option<&[(~str, ~str)]>, f: |**libc::c_char| -> T) -> T {\n }\n \n impl HomingIO for Process {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl UvHandle<uvll::uv_process_t> for Process {\n@@ -208,7 +202,7 @@ impl RtioProcess for Process {\n         }\n     }\n \n-    fn wait(&mut self) -> ProcessExit {\n+    fn wait(&mut self) -> process::ProcessExit {\n         // Make sure (on the home scheduler) that we have an exit status listed\n         let _m = self.fire_homing_missile();\n         match self.exit_status {"}, {"sha": "22e7925b21108390cd0372df70e1d45093769b0c", "filename": "src/librustuv/queue.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fqueue.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -0,0 +1,184 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A concurrent queue used to signal remote event loops\n+//!\n+//! This queue implementation is used to send tasks among event loops. This is\n+//! backed by a multi-producer/single-consumer queue from libstd and uv_async_t\n+//! handles (to wake up a remote event loop).\n+//!\n+//! The uv_async_t is stored next to the event loop, so in order to not keep the\n+//! event loop alive we use uv_ref and uv_unref in order to control when the\n+//! async handle is active or not.\n+\n+use std::cast;\n+use std::libc::{c_void, c_int};\n+use std::rt::task::BlockedTask;\n+use std::unstable::sync::LittleLock;\n+use mpsc = std::sync::mpsc_queue;\n+\n+use async::AsyncWatcher;\n+use super::{Loop, UvHandle};\n+use uvll;\n+\n+enum Message {\n+    Task(BlockedTask),\n+    Increment,\n+    Decrement,\n+}\n+\n+struct State {\n+    handle: *uvll::uv_async_t,\n+    lock: LittleLock, // see comments in async_cb for why this is needed\n+}\n+\n+/// This structure is intended to be stored next to the event loop, and it is\n+/// used to create new `Queue` structures.\n+pub struct QueuePool {\n+    priv producer: mpsc::Producer<Message, State>,\n+    priv consumer: mpsc::Consumer<Message, State>,\n+    priv refcnt: uint,\n+}\n+\n+/// This type is used to send messages back to the original event loop.\n+pub struct Queue {\n+    priv queue: mpsc::Producer<Message, State>,\n+}\n+\n+extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n+    assert_eq!(status, 0);\n+    let state: &mut QueuePool = unsafe {\n+        cast::transmute(uvll::get_data_for_uv_handle(handle))\n+    };\n+    let packet = unsafe { state.consumer.packet() };\n+\n+    // Remember that there is no guarantee about how many times an async\n+    // callback is called with relation to the number of sends, so process the\n+    // entire queue in a loop.\n+    loop {\n+        match state.consumer.pop() {\n+            mpsc::Data(Task(task)) => {\n+                task.wake().map(|t| t.reawaken(true));\n+            }\n+            mpsc::Data(Increment) => unsafe {\n+                if state.refcnt == 0 {\n+                    uvll::uv_ref((*packet).handle);\n+                }\n+                state.refcnt += 1;\n+            },\n+            mpsc::Data(Decrement) => unsafe {\n+                state.refcnt -= 1;\n+                if state.refcnt == 0 {\n+                    uvll::uv_unref((*packet).handle);\n+                }\n+            },\n+            mpsc::Empty | mpsc::Inconsistent => break\n+        };\n+    }\n+\n+    // If the refcount is now zero after processing the queue, then there is no\n+    // longer a reference on the async handle and it is possible that this event\n+    // loop can exit. What we're not guaranteed, however, is that a producer in\n+    // the middle of dropping itself is yet done with the handle. It could be\n+    // possible that we saw their Decrement message but they have yet to signal\n+    // on the async handle. If we were to return immediately, the entire uv loop\n+    // could be destroyed meaning the call to uv_async_send would abort()\n+    //\n+    // In order to fix this, an OS mutex is used to wait for the other end to\n+    // finish before we continue. The drop block on a handle will acquire a\n+    // mutex and then drop it after both the push and send have been completed.\n+    // If we acquire the mutex here, then we are guaranteed that there are no\n+    // longer any senders which are holding on to their handles, so we can\n+    // safely allow the event loop to exit.\n+    if state.refcnt == 0 {\n+        unsafe {\n+            let _l = (*packet).lock.lock();\n+        }\n+    }\n+}\n+\n+impl QueuePool {\n+    pub fn new(loop_: &mut Loop) -> ~QueuePool {\n+        let handle = UvHandle::alloc(None::<AsyncWatcher>, uvll::UV_ASYNC);\n+        let (c, p) = mpsc::queue(State {\n+            handle: handle,\n+            lock: LittleLock::new(),\n+        });\n+        let q = ~QueuePool {\n+            producer: p,\n+            consumer: c,\n+            refcnt: 0,\n+        };\n+\n+        unsafe {\n+            assert_eq!(uvll::uv_async_init(loop_.handle, handle, async_cb), 0);\n+            uvll::uv_unref(handle);\n+            let data: *c_void = *cast::transmute::<&~QueuePool, &*c_void>(&q);\n+            uvll::set_data_for_uv_handle(handle, data);\n+        }\n+\n+        return q;\n+    }\n+\n+    pub fn queue(&mut self) -> Queue {\n+        unsafe {\n+            if self.refcnt == 0 {\n+                uvll::uv_ref((*self.producer.packet()).handle);\n+            }\n+            self.refcnt += 1;\n+        }\n+        Queue { queue: self.producer.clone() }\n+    }\n+}\n+\n+impl Queue {\n+    pub fn push(&mut self, task: BlockedTask) {\n+        self.queue.push(Task(task));\n+        unsafe {\n+            uvll::uv_async_send((*self.queue.packet()).handle);\n+        }\n+    }\n+}\n+\n+impl Clone for Queue {\n+    fn clone(&self) -> Queue {\n+        // Push a request to increment on the queue, but there's no need to\n+        // signal the event loop to process it at this time. We're guaranteed\n+        // that the count is at least one (because we have a queue right here),\n+        // and if the queue is dropped later on it'll see the increment for the\n+        // decrement anyway.\n+        unsafe {\n+            cast::transmute_mut(self).queue.push(Increment);\n+        }\n+        Queue { queue: self.queue.clone() }\n+    }\n+}\n+\n+impl Drop for Queue {\n+    fn drop(&mut self) {\n+        // See the comments in the async_cb function for why there is a lock\n+        // that is acquired only on a drop.\n+        unsafe {\n+            let state = self.queue.packet();\n+            let _l = (*state).lock.lock();\n+            self.queue.push(Decrement);\n+            uvll::uv_async_send((*state).handle);\n+        }\n+    }\n+}\n+\n+impl Drop for State {\n+    fn drop(&mut self) {\n+        unsafe {\n+            uvll::uv_close(self.handle, cast::transmute(0));\n+            uvll::free_handle(self.handle);\n+        }\n+    }\n+}"}, {"sha": "27dbc0fe3bb08769091515b0883e094a3795c549", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -10,34 +10,33 @@\n \n use std::libc::c_int;\n use std::io::signal::Signum;\n-use std::rt::sched::{SchedHandle, Scheduler};\n use std::comm::SharedChan;\n-use std::rt::local::Local;\n use std::rt::rtio::RtioSignal;\n \n-use super::{Loop, UvError, UvHandle};\n+use homing::{HomingIO, HomeHandle};\n+use super::{UvError, UvHandle};\n use uvll;\n-use uvio::HomingIO;\n+use uvio::UvIoFactory;\n \n pub struct SignalWatcher {\n     handle: *uvll::uv_signal_t,\n-    home: SchedHandle,\n+    home: HomeHandle,\n \n     channel: SharedChan<Signum>,\n     signal: Signum,\n }\n \n impl SignalWatcher {\n-    pub fn new(loop_: &mut Loop, signum: Signum,\n+    pub fn new(io: &mut UvIoFactory, signum: Signum,\n                channel: SharedChan<Signum>) -> Result<~SignalWatcher, UvError> {\n         let s = ~SignalWatcher {\n             handle: UvHandle::alloc(None::<SignalWatcher>, uvll::UV_SIGNAL),\n-            home: get_handle_to_current_scheduler!(),\n+            home: io.make_handle(),\n             channel: channel,\n             signal: signum,\n         };\n         assert_eq!(unsafe {\n-            uvll::uv_signal_init(loop_.handle, s.handle)\n+            uvll::uv_signal_init(io.uv_loop(), s.handle)\n         }, 0);\n \n         match unsafe {\n@@ -57,7 +56,7 @@ extern fn signal_cb(handle: *uvll::uv_signal_t, signum: c_int) {\n }\n \n impl HomingIO for SignalWatcher {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl UvHandle<uvll::uv_signal_t> for SignalWatcher {\n@@ -75,7 +74,6 @@ impl Drop for SignalWatcher {\n \n #[cfg(test)]\n mod test {\n-    use super::*;\n     use super::super::local_loop;\n     use std::io::signal;\n "}, {"sha": "73173fc677e8f786c782afc3388e0fd7b6132d76", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -11,12 +11,10 @@\n use std::cast;\n use std::libc::{c_int, size_t, ssize_t};\n use std::ptr;\n-use std::rt::BlockedTask;\n-use std::rt::local::Local;\n-use std::rt::sched::Scheduler;\n+use std::rt::task::BlockedTask;\n \n use super::{UvError, Buf, slice_to_uv_buf, Request, wait_until_woken_after,\n-            ForbidUnwind};\n+            ForbidUnwind, wakeup};\n use uvll;\n \n // This is a helper structure which is intended to get embedded into other\n@@ -164,8 +162,7 @@ extern fn read_cb(handle: *uvll::uv_stream_t, nread: ssize_t, _buf: *Buf) {\n     unsafe { assert_eq!(uvll::uv_read_stop(handle), 0); }\n     rcx.result = nread;\n \n-    let scheduler: ~Scheduler = Local::take();\n-    scheduler.resume_blocked_task_immediately(rcx.task.take_unwrap());\n+    wakeup(&mut rcx.task);\n }\n \n // Unlike reading, the WriteContext is stored in the uv_write_t request. Like\n@@ -180,6 +177,5 @@ extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n     wcx.result = status;\n     req.defuse();\n \n-    let sched: ~Scheduler = Local::take();\n-    sched.resume_blocked_task_immediately(wcx.task.take_unwrap());\n+    wakeup(&mut wcx.task);\n }"}, {"sha": "1e70c5c55e06c5b01c29c97078e1737d7ec4e0f1", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -9,19 +9,19 @@\n // except according to those terms.\n \n use std::libc::c_int;\n-use std::rt::BlockedTask;\n use std::rt::local::Local;\n use std::rt::rtio::RtioTimer;\n-use std::rt::sched::{Scheduler, SchedHandle};\n+use std::rt::task::{BlockedTask, Task};\n use std::util;\n \n+use homing::{HomeHandle, HomingIO};\n+use super::{UvHandle, ForbidUnwind, ForbidSwitch};\n+use uvio::UvIoFactory;\n use uvll;\n-use super::{Loop, UvHandle, ForbidUnwind, ForbidSwitch};\n-use uvio::HomingIO;\n \n pub struct TimerWatcher {\n     handle: *uvll::uv_timer_t,\n-    home: SchedHandle,\n+    home: HomeHandle,\n     action: Option<NextAction>,\n     id: uint, // see comments in timer_cb\n }\n@@ -33,15 +33,15 @@ pub enum NextAction {\n }\n \n impl TimerWatcher {\n-    pub fn new(loop_: &mut Loop) -> ~TimerWatcher {\n+    pub fn new(io: &mut UvIoFactory) -> ~TimerWatcher {\n         let handle = UvHandle::alloc(None::<TimerWatcher>, uvll::UV_TIMER);\n         assert_eq!(unsafe {\n-            uvll::uv_timer_init(loop_.handle, handle)\n+            uvll::uv_timer_init(io.uv_loop(), handle)\n         }, 0);\n         let me = ~TimerWatcher {\n             handle: handle,\n             action: None,\n-            home: get_handle_to_current_scheduler!(),\n+            home: io.make_handle(),\n             id: 0,\n         };\n         return me.install();\n@@ -59,7 +59,7 @@ impl TimerWatcher {\n }\n \n impl HomingIO for TimerWatcher {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl UvHandle<uvll::uv_timer_t> for TimerWatcher {\n@@ -89,10 +89,11 @@ impl RtioTimer for TimerWatcher {\n         // started, then we need to call stop on the timer.\n         let _f = ForbidUnwind::new(\"timer\");\n \n-        let sched: ~Scheduler = Local::take();\n-        sched.deschedule_running_task_and_then(|_sched, task| {\n+        let task: ~Task = Local::take();\n+        task.deschedule(1, |task| {\n             self.action = Some(WakeTask(task));\n             self.start(msecs, 0);\n+            Ok(())\n         });\n         self.stop();\n     }\n@@ -137,8 +138,7 @@ extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n \n     match timer.action.take_unwrap() {\n         WakeTask(task) => {\n-            let sched: ~Scheduler = Local::take();\n-            sched.resume_blocked_task_immediately(task);\n+            task.wake().map(|t| t.reawaken(true));\n         }\n         SendOnce(chan) => { chan.try_send_deferred(()); }\n         SendMany(chan, id) => {\n@@ -177,7 +177,6 @@ impl Drop for TimerWatcher {\n \n #[cfg(test)]\n mod test {\n-    use super::*;\n     use std::rt::rtio::RtioTimer;\n     use super::super::local_loop;\n "}, {"sha": "0e76ed9feb93dfe78985e3cda7372a6063ae5e66", "filename": "src/librustuv/tty.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -10,24 +10,23 @@\n \n use std::libc;\n use std::io::IoError;\n-use std::rt::local::Local;\n use std::rt::rtio::RtioTTY;\n-use std::rt::sched::{Scheduler, SchedHandle};\n \n+use homing::{HomingIO, HomeHandle};\n use stream::StreamWatcher;\n-use super::{Loop, UvError, UvHandle, uv_error_to_io_error};\n-use uvio::HomingIO;\n+use super::{UvError, UvHandle, uv_error_to_io_error};\n+use uvio::UvIoFactory;\n use uvll;\n \n pub struct TtyWatcher{\n     tty: *uvll::uv_tty_t,\n     stream: StreamWatcher,\n-    home: SchedHandle,\n+    home: HomeHandle,\n     fd: libc::c_int,\n }\n \n impl TtyWatcher {\n-    pub fn new(loop_: &Loop, fd: libc::c_int, readable: bool)\n+    pub fn new(io: &mut UvIoFactory, fd: libc::c_int, readable: bool)\n         -> Result<TtyWatcher, UvError>\n     {\n         // libuv may succeed in giving us a handle (via uv_tty_init), but if the\n@@ -56,14 +55,14 @@ impl TtyWatcher {\n         // with attempting to open it as a tty.\n         let handle = UvHandle::alloc(None::<TtyWatcher>, uvll::UV_TTY);\n         match unsafe {\n-            uvll::uv_tty_init(loop_.handle, handle, fd as libc::c_int,\n+            uvll::uv_tty_init(io.uv_loop(), handle, fd as libc::c_int,\n                               readable as libc::c_int)\n         } {\n             0 => {\n                 Ok(TtyWatcher {\n                     tty: handle,\n                     stream: StreamWatcher::new(handle),\n-                    home: get_handle_to_current_scheduler!(),\n+                    home: io.make_handle(),\n                     fd: fd,\n                 })\n             }\n@@ -120,7 +119,7 @@ impl UvHandle<uvll::uv_tty_t> for TtyWatcher {\n }\n \n impl HomingIO for TtyWatcher {\n-    fn home<'a>(&'a mut self) -> &'a mut SchedHandle { &mut self.home }\n+    fn home<'a>(&'a mut self) -> &'a mut HomeHandle { &mut self.home }\n }\n \n impl Drop for TtyWatcher {"}, {"sha": "52e0b5ed77b261760f18e9d6c00e29a7ece2190f", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 104, "deletions": 171, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -9,121 +9,41 @@\n // except according to those terms.\n \n use std::c_str::CString;\n+use std::cast;\n use std::comm::SharedChan;\n-use std::libc::c_int;\n-use std::libc;\n-use std::path::Path;\n use std::io::IoError;\n use std::io::net::ip::SocketAddr;\n use std::io::process::ProcessConfig;\n-use std::io;\n-use std::rt::local::Local;\n-use std::rt::rtio::*;\n-use std::rt::sched::{Scheduler, SchedHandle};\n-use std::rt::task::Task;\n-use std::libc::{O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n-                S_IRUSR, S_IWUSR};\n-use std::io::{FileMode, FileAccess, Open, Append, Truncate, Read, Write,\n-                  ReadWrite, FileStat};\n use std::io::signal::Signum;\n+use std::io::{FileMode, FileAccess, Open, Append, Truncate, Read, Write,\n+              ReadWrite, FileStat};\n+use std::io;\n+use std::libc::c_int;\n+use std::libc::{O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY, S_IRUSR,\n+                S_IWUSR};\n+use std::libc;\n+use std::path::Path;\n+use std::rt::rtio;\n+use std::rt::rtio::IoFactory;\n use ai = std::io::net::addrinfo;\n \n #[cfg(test)] use std::unstable::run_in_bare_thread;\n \n-use super::*;\n-use addrinfo::GetAddrInfoRequest;\n-\n-pub trait HomingIO {\n-\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle;\n-\n-    /// This function will move tasks to run on their home I/O scheduler. Note\n-    /// that this function does *not* pin the task to the I/O scheduler, but\n-    /// rather it simply moves it to running on the I/O scheduler.\n-    fn go_to_IO_home(&mut self) -> uint {\n-        use std::rt::sched::RunOnce;\n-\n-        let _f = ForbidUnwind::new(\"going home\");\n-\n-        let current_sched_id = {\n-            let mut sched = Local::borrow(None::<Scheduler>);\n-            sched.get().sched_id()\n-        };\n-\n-        // Only need to invoke a context switch if we're not on the right\n-        // scheduler.\n-        if current_sched_id != self.home().sched_id {\n-            let scheduler: ~Scheduler = Local::take();\n-            scheduler.deschedule_running_task_and_then(|_, task| {\n-                task.wake().map(|task| {\n-                    self.home().send(RunOnce(task));\n-                });\n-            })\n-        }\n-        let current_sched_id = {\n-            let mut sched = Local::borrow(None::<Scheduler>);\n-            sched.get().sched_id()\n-        };\n-        assert!(current_sched_id == self.home().sched_id);\n-\n-        self.home().sched_id\n-    }\n+use super::{uv_error_to_io_error, Loop};\n \n-    /// Fires a single homing missile, returning another missile targeted back\n-    /// at the original home of this task. In other words, this function will\n-    /// move the local task to its I/O scheduler and then return an RAII wrapper\n-    /// which will return the task home.\n-    fn fire_homing_missile(&mut self) -> HomingMissile {\n-        HomingMissile { io_home: self.go_to_IO_home() }\n-    }\n-\n-    /// Same as `fire_homing_missile`, but returns the local I/O scheduler as\n-    /// well (the one that was homed to).\n-    fn fire_homing_missile_sched(&mut self) -> (HomingMissile, ~Scheduler) {\n-        // First, transplant ourselves to the home I/O scheduler\n-        let missile = self.fire_homing_missile();\n-        // Next (must happen next), grab the local I/O scheduler\n-        let io_sched: ~Scheduler = Local::take();\n-\n-        (missile, io_sched)\n-    }\n-}\n-\n-/// After a homing operation has been completed, this will return the current\n-/// task back to its appropriate home (if applicable). The field is used to\n-/// assert that we are where we think we are.\n-struct HomingMissile {\n-    priv io_home: uint,\n-}\n-\n-impl HomingMissile {\n-    pub fn check(&self, msg: &'static str) {\n-        let mut sched = Local::borrow(None::<Scheduler>);\n-        let local_id = sched.get().sched_id();\n-        assert!(local_id == self.io_home, \"{}\", msg);\n-    }\n-}\n-\n-impl Drop for HomingMissile {\n-    fn drop(&mut self) {\n-        let _f = ForbidUnwind::new(\"leaving home\");\n-\n-        // It would truly be a sad day if we had moved off the home I/O\n-        // scheduler while we were doing I/O.\n-        self.check(\"task moved away from the home scheduler\");\n-\n-        // If we were a homed task, then we must send ourselves back to the\n-        // original scheduler. Otherwise, we can just return and keep running\n-        if !Task::on_appropriate_sched() {\n-            let scheduler: ~Scheduler = Local::take();\n-            scheduler.deschedule_running_task_and_then(|_, task| {\n-                task.wake().map(|task| {\n-                    Scheduler::run_task(task);\n-                });\n-            })\n-        }\n-    }\n-}\n+use addrinfo::GetAddrInfoRequest;\n+use async::AsyncWatcher;\n+use file::{FsRequest, FileWatcher};\n+use queue::QueuePool;\n+use homing::HomeHandle;\n+use idle::IdleWatcher;\n+use net::{TcpWatcher, TcpListener, UdpWatcher};\n+use pipe::{PipeWatcher, PipeListener};\n+use process::Process;\n+use signal::SignalWatcher;\n+use timer::TimerWatcher;\n+use tty::TtyWatcher;\n+use uvll;\n \n // Obviously an Event Loop is always home.\n pub struct UvEventLoop {\n@@ -132,45 +52,52 @@ pub struct UvEventLoop {\n \n impl UvEventLoop {\n     pub fn new() -> UvEventLoop {\n+        let mut loop_ = Loop::new();\n+        let handle_pool = QueuePool::new(&mut loop_);\n         UvEventLoop {\n-            uvio: UvIoFactory(Loop::new())\n+            uvio: UvIoFactory {\n+                loop_: loop_,\n+                handle_pool: handle_pool,\n+            }\n         }\n     }\n }\n \n impl Drop for UvEventLoop {\n     fn drop(&mut self) {\n-        self.uvio.uv_loop().close();\n+        self.uvio.loop_.close();\n     }\n }\n \n-impl EventLoop for UvEventLoop {\n+impl rtio::EventLoop for UvEventLoop {\n     fn run(&mut self) {\n-        self.uvio.uv_loop().run();\n+        self.uvio.loop_.run();\n     }\n \n     fn callback(&mut self, f: proc()) {\n-        IdleWatcher::onetime(self.uvio.uv_loop(), f);\n+        IdleWatcher::onetime(&mut self.uvio.loop_, f);\n     }\n \n-    fn pausable_idle_callback(&mut self, cb: ~Callback) -> ~PausableIdleCallback {\n-        IdleWatcher::new(self.uvio.uv_loop(), cb) as ~PausableIdleCallback\n+    fn pausible_idle_callback(&mut self, cb: ~rtio::Callback)\n+        -> ~rtio::PausibleIdleCallback\n+    {\n+        IdleWatcher::new(&mut self.uvio.loop_, cb) as ~rtio::PausibleIdleCallback\n     }\n \n-    fn remote_callback(&mut self, f: ~Callback) -> ~RemoteCallback {\n-        ~AsyncWatcher::new(self.uvio.uv_loop(), f) as ~RemoteCallback\n+    fn remote_callback(&mut self, f: ~rtio::Callback) -> ~rtio::RemoteCallback {\n+        ~AsyncWatcher::new(&mut self.uvio.loop_, f) as ~rtio::RemoteCallback\n     }\n \n-    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory> {\n-        let factory = &mut self.uvio as &mut IoFactory;\n+    fn io<'a>(&'a mut self) -> Option<&'a mut rtio::IoFactory> {\n+        let factory = &mut self.uvio as &mut rtio::IoFactory;\n         Some(factory)\n     }\n }\n \n #[cfg(not(test))]\n #[lang = \"event_loop_factory\"]\n-pub extern \"C\" fn new_loop() -> ~EventLoop {\n-    ~UvEventLoop::new() as ~EventLoop\n+pub extern \"C\" fn new_loop() -> ~rtio::EventLoop {\n+    ~UvEventLoop::new() as ~rtio::EventLoop\n }\n \n #[test]\n@@ -187,59 +114,65 @@ fn test_callback_run_once() {\n     }\n }\n \n-pub struct UvIoFactory(Loop);\n+pub struct UvIoFactory {\n+    loop_: Loop,\n+    priv handle_pool: ~QueuePool,\n+}\n \n impl UvIoFactory {\n-    pub fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n-        match self { &UvIoFactory(ref mut ptr) => ptr }\n+    pub fn uv_loop<'a>(&mut self) -> *uvll::uv_loop_t { self.loop_.handle }\n+\n+    pub fn make_handle(&mut self) -> HomeHandle {\n+        HomeHandle::new(self.id(), &mut *self.handle_pool)\n     }\n }\n \n impl IoFactory for UvIoFactory {\n+    fn id(&self) -> uint { unsafe { cast::transmute(self) } }\n+\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n     // It would probably be better to return a future\n     fn tcp_connect(&mut self, addr: SocketAddr)\n-        -> Result<~RtioTcpStream, IoError>\n+        -> Result<~rtio::RtioTcpStream, IoError>\n     {\n-        match TcpWatcher::connect(self.uv_loop(), addr) {\n-            Ok(t) => Ok(~t as ~RtioTcpStream),\n+        match TcpWatcher::connect(self, addr) {\n+            Ok(t) => Ok(~t as ~rtio::RtioTcpStream),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListener, IoError> {\n-        match TcpListener::bind(self.uv_loop(), addr) {\n-            Ok(t) => Ok(t as ~RtioTcpListener),\n+    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~rtio::RtioTcpListener, IoError> {\n+        match TcpListener::bind(self, addr) {\n+            Ok(t) => Ok(t as ~rtio::RtioTcpListener),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocket, IoError> {\n-        match UdpWatcher::bind(self.uv_loop(), addr) {\n-            Ok(u) => Ok(~u as ~RtioUdpSocket),\n+    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~rtio::RtioUdpSocket, IoError> {\n+        match UdpWatcher::bind(self, addr) {\n+            Ok(u) => Ok(~u as ~rtio::RtioUdpSocket),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn timer_init(&mut self) -> Result<~RtioTimer, IoError> {\n-        Ok(TimerWatcher::new(self.uv_loop()) as ~RtioTimer)\n+    fn timer_init(&mut self) -> Result<~rtio::RtioTimer, IoError> {\n+        Ok(TimerWatcher::new(self) as ~rtio::RtioTimer)\n     }\n \n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n                           hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError> {\n-        let r = GetAddrInfoRequest::run(self.uv_loop(), host, servname, hint);\n+        let r = GetAddrInfoRequest::run(&self.loop_, host, servname, hint);\n         r.map_err(uv_error_to_io_error)\n     }\n \n     fn fs_from_raw_fd(&mut self, fd: c_int,\n-                      close: CloseBehavior) -> ~RtioFileStream {\n-        let loop_ = Loop::wrap(self.uv_loop().handle);\n-        ~FileWatcher::new(loop_, fd, close) as ~RtioFileStream\n+                      close: rtio::CloseBehavior) -> ~rtio::RtioFileStream {\n+        ~FileWatcher::new(self, fd, close) as ~rtio::RtioFileStream\n     }\n \n     fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n-        -> Result<~RtioFileStream, IoError> {\n+        -> Result<~rtio::RtioFileStream, IoError> {\n         let flags = match fm {\n             io::Open => 0,\n             io::Append => libc::O_APPEND,\n@@ -254,117 +187,117 @@ impl IoFactory for UvIoFactory {\n                               libc::S_IRUSR | libc::S_IWUSR),\n         };\n \n-        match FsRequest::open(self.uv_loop(), path, flags as int, mode as int) {\n-            Ok(fs) => Ok(~fs as ~RtioFileStream),\n+        match FsRequest::open(self, path, flags as int, mode as int) {\n+            Ok(fs) => Ok(~fs as ~rtio::RtioFileStream),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n     fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError> {\n-        let r = FsRequest::unlink(self.uv_loop(), path);\n+        let r = FsRequest::unlink(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_lstat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n-        let r = FsRequest::lstat(self.uv_loop(), path);\n+        let r = FsRequest::lstat(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n-        let r = FsRequest::stat(self.uv_loop(), path);\n+        let r = FsRequest::stat(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_mkdir(&mut self, path: &CString,\n                 perm: io::FilePermission) -> Result<(), IoError> {\n-        let r = FsRequest::mkdir(self.uv_loop(), path, perm as c_int);\n+        let r = FsRequest::mkdir(&self.loop_, path, perm as c_int);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError> {\n-        let r = FsRequest::rmdir(self.uv_loop(), path);\n+        let r = FsRequest::rmdir(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_rename(&mut self, path: &CString, to: &CString) -> Result<(), IoError> {\n-        let r = FsRequest::rename(self.uv_loop(), path, to);\n+        let r = FsRequest::rename(&self.loop_, path, to);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_chmod(&mut self, path: &CString,\n                 perm: io::FilePermission) -> Result<(), IoError> {\n-        let r = FsRequest::chmod(self.uv_loop(), path, perm as c_int);\n+        let r = FsRequest::chmod(&self.loop_, path, perm as c_int);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_readdir(&mut self, path: &CString, flags: c_int)\n         -> Result<~[Path], IoError>\n     {\n-        let r = FsRequest::readdir(self.uv_loop(), path, flags);\n+        let r = FsRequest::readdir(&self.loop_, path, flags);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_link(&mut self, src: &CString, dst: &CString) -> Result<(), IoError> {\n-        let r = FsRequest::link(self.uv_loop(), src, dst);\n+        let r = FsRequest::link(&self.loop_, src, dst);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_symlink(&mut self, src: &CString, dst: &CString) -> Result<(), IoError> {\n-        let r = FsRequest::symlink(self.uv_loop(), src, dst);\n+        let r = FsRequest::symlink(&self.loop_, src, dst);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> Result<(), IoError> {\n-        let r = FsRequest::chown(self.uv_loop(), path, uid, gid);\n+        let r = FsRequest::chown(&self.loop_, path, uid, gid);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_readlink(&mut self, path: &CString) -> Result<Path, IoError> {\n-        let r = FsRequest::readlink(self.uv_loop(), path);\n+        let r = FsRequest::readlink(&self.loop_, path);\n         r.map_err(uv_error_to_io_error)\n     }\n     fn fs_utime(&mut self, path: &CString, atime: u64, mtime: u64)\n         -> Result<(), IoError>\n     {\n-        let r = FsRequest::utime(self.uv_loop(), path, atime, mtime);\n+        let r = FsRequest::utime(&self.loop_, path, atime, mtime);\n         r.map_err(uv_error_to_io_error)\n     }\n \n     fn spawn(&mut self, config: ProcessConfig)\n-            -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>\n+            -> Result<(~rtio::RtioProcess, ~[Option<~rtio::RtioPipe>]), IoError>\n     {\n-        match Process::spawn(self.uv_loop(), config) {\n+        match Process::spawn(self, config) {\n             Ok((p, io)) => {\n-                Ok((p as ~RtioProcess,\n-                    io.move_iter().map(|i| i.map(|p| ~p as ~RtioPipe)).collect()))\n+                Ok((p as ~rtio::RtioProcess,\n+                    io.move_iter().map(|i| i.map(|p| ~p as ~rtio::RtioPipe)).collect()))\n             }\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn unix_bind(&mut self, path: &CString) -> Result<~RtioUnixListener, IoError>\n+    fn unix_bind(&mut self, path: &CString) -> Result<~rtio::RtioUnixListener, IoError>\n     {\n-        match PipeListener::bind(self.uv_loop(), path) {\n-            Ok(p) => Ok(p as ~RtioUnixListener),\n+        match PipeListener::bind(self, path) {\n+            Ok(p) => Ok(p as ~rtio::RtioUnixListener),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError> {\n-        match PipeWatcher::connect(self.uv_loop(), path) {\n-            Ok(p) => Ok(~p as ~RtioPipe),\n+    fn unix_connect(&mut self, path: &CString) -> Result<~rtio::RtioPipe, IoError> {\n+        match PipeWatcher::connect(self, path) {\n+            Ok(p) => Ok(~p as ~rtio::RtioPipe),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n     fn tty_open(&mut self, fd: c_int, readable: bool)\n-            -> Result<~RtioTTY, IoError> {\n-        match TtyWatcher::new(self.uv_loop(), fd, readable) {\n-            Ok(tty) => Ok(~tty as ~RtioTTY),\n+            -> Result<~rtio::RtioTTY, IoError> {\n+        match TtyWatcher::new(self, fd, readable) {\n+            Ok(tty) => Ok(~tty as ~rtio::RtioTTY),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n-    fn pipe_open(&mut self, fd: c_int) -> Result<~RtioPipe, IoError> {\n-        match PipeWatcher::open(self.uv_loop(), fd) {\n-            Ok(s) => Ok(~s as ~RtioPipe),\n+    fn pipe_open(&mut self, fd: c_int) -> Result<~rtio::RtioPipe, IoError> {\n+        match PipeWatcher::open(self, fd) {\n+            Ok(s) => Ok(~s as ~rtio::RtioPipe),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n     fn signal(&mut self, signum: Signum, channel: SharedChan<Signum>)\n-        -> Result<~RtioSignal, IoError> {\n-        match SignalWatcher::new(self.uv_loop(), signum, channel) {\n-            Ok(s) => Ok(s as ~RtioSignal),\n+        -> Result<~rtio::RtioSignal, IoError> {\n+        match SignalWatcher::new(self, signum, channel) {\n+            Ok(s) => Ok(s as ~rtio::RtioSignal),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }"}, {"sha": "fa0bb85faed1bb7b36d27ec2be3774efdc6304a6", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429313de69cb2ddd1f076017968d1862ef02b455/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=429313de69cb2ddd1f076017968d1862ef02b455", "patch": "@@ -37,7 +37,8 @@ use std::libc;\n #[cfg(test)]\n use std::libc::uintptr_t;\n \n-pub use self::errors::*;\n+pub use self::errors::{EACCES, ECONNREFUSED, ECONNRESET, EPIPE, ECONNABORTED,\n+                       ECANCELED, EBADF, ENOTCONN};\n \n pub static OK: c_int = 0;\n pub static EOF: c_int = -4095;\n@@ -576,6 +577,8 @@ extern {\n \n     // generic uv functions\n     pub fn uv_loop_delete(l: *uv_loop_t);\n+    pub fn uv_ref(t: *uv_handle_t);\n+    pub fn uv_unref(t: *uv_handle_t);\n     pub fn uv_handle_size(ty: uv_handle_type) -> size_t;\n     pub fn uv_req_size(ty: uv_req_type) -> size_t;\n     pub fn uv_run(l: *uv_loop_t, mode: uv_run_mode) -> c_int;"}]}