{"sha": "0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "node_id": "C_kwDOAAsO6NoAKDBlYzAwYzBiYTNmMmZkZWRlNjcwMGFmN2I4ZjQ0MzhiNWQ3YWZlYmU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-12T21:16:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-12T21:16:55Z"}, "message": "Rollup merge of #95316 - fmease:rustdoc-discr-req-prov-assoc-consts-tys, r=notriddle,GuillaumeGomez\n\nRustdoc: Discriminate required and provided associated constants and types\n\nCurrently, rustdoc merely separates required and provided associated _functions_ (i.e. methods). This PR extends this to constants (fixes #94652) and types. This makes the documentation of all three kinds of associated items more alike and consistent.\n\nAs an aside, associated types may actually be provided / have a default when users enable the unstable feature `associated_type_defaults`.\n\n| Before | After |\n|---|---|\n| ![image](https://user-images.githubusercontent.com/14913065/160631832-d5862d13-b395-4d86-b45c-3873ffd4cd4e.png) | ![image](https://user-images.githubusercontent.com/14913065/160631903-33909a03-b6ee-4d75-9cbc-d188f7f8602e.png) |\n| ![image](https://user-images.githubusercontent.com/14913065/160632173-040d4139-76f4-4410-851b-d8c1cef014d2.png) | ![image](https://user-images.githubusercontent.com/14913065/160632233-6fd3fe73-cadc-4291-b104-59d2e45366a6.png) |\n\n### `clean::types::ItemKind` modification\n\n* `ItemKind::TypedefItem(.., true)` \u2192 `ItemKind::AssocTypeItem(..)`\n* `ItemKind::TypedefItem(.., false)` \u2192 `ItemKind::TypedefItem(..)`\n\nFurther, I added `ItemKind::TyAssoc{Const,Type}Item`, the \u201crequired\u201d variant of `ItemKind::Assoc{Const,Type}Item`, analogous to `ItemKind::TyMethodItem` with `ItemKind::MethodItem`. These new variants don't contain new information really, they are just the result of me getting rid of the `Option<_>` field in `AssocConstItem` and `AssocTypeItem`.\n\n**Goal**: Make associated items more consistent.\nOriginally I thought modifying `ItemKind` was necessary to achieve the new functionality of this PR but in retrospect, it does not. If you don't like the changes to `ItemKind`, I think I _can_ get rid of them.\n\nThis change is the root cause of those tiny changes in a lot of different files.\n\n ### Concerns and Open Questions\n\n* **breaking changes** to hyperlinks: Some heading IDs change:\n  * `associated-const` (sic!) -> `{provided,required}-associated-consts`\n  * `associated-types` -> `{provided,required}-associated-types`\n* **verbosity** of the headings _{Required,Provided} Associated {Constants,Types}_\n* For some files, I am not sure if the changes I made are correct. So please take extra care when reviewing `conversions.rs` (conversion to JSON), `cache.rs`/`fold_item`, `stripper.rs`/`fold_item`, `check_doc_test_visibility.rs`/`should_have_doc_example`, `collect_intra_doc_links.rs`/`from_assoc_item`\n* JSON output: I still map `AssocTypeItem`s to `Typedef` etc. (FIXME)", "tree": {"sha": "6dc8f5eb77ef06300cdbe0a18214844f5a4e7a22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dc8f5eb77ef06300cdbe0a18214844f5a4e7a22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiVexICRBK7hj4Ov3rIwAAOY8IAJ3lToIO/uBDn50ONgLN0+EQ\nCm1iwg5pN9XLiZCw9obSaRB5IIHgX87MVmxs4QhC4xDmpTKUsUxuTVZHJlH7BoOQ\n3ReZbgFIREalzcnVq11jrgbK9DSxI577U5ABvUBQs+2bl2zjaS2mZ0EwdVFaSNDb\nVvouipZIMxom3ZSrf9PKpNbdywscJifOch0bx7/T6cd9H8a3B65z8v8xk58/Mxr0\niGhvKxWLcf4mnK4CNbf3Z9MD1J2lQGW6Kl4YVHwV1sL6Qud62YiU2b1cuqRuIERw\n/vq0CYClc7FVsiN9cYGKXnXUSTpGVYHUMM0tA0LXVx6OCW068jV6OdeuQXfw9VI=\n=8WJs\n-----END PGP SIGNATURE-----\n", "payload": "tree 6dc8f5eb77ef06300cdbe0a18214844f5a4e7a22\nparent 52ca603da73ae9eaddf96f77953b33ad8c47cc8e\nparent 8de453a8c6a26e43876def2d757bec40ed9b2767\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1649798215 +0200\ncommitter GitHub <noreply@github.com> 1649798215 +0200\n\nRollup merge of #95316 - fmease:rustdoc-discr-req-prov-assoc-consts-tys, r=notriddle,GuillaumeGomez\n\nRustdoc: Discriminate required and provided associated constants and types\n\nCurrently, rustdoc merely separates required and provided associated _functions_ (i.e. methods). This PR extends this to constants (fixes #94652) and types. This makes the documentation of all three kinds of associated items more alike and consistent.\n\nAs an aside, associated types may actually be provided / have a default when users enable the unstable feature `associated_type_defaults`.\n\n| Before | After |\n|---|---|\n| ![image](https://user-images.githubusercontent.com/14913065/160631832-d5862d13-b395-4d86-b45c-3873ffd4cd4e.png) | ![image](https://user-images.githubusercontent.com/14913065/160631903-33909a03-b6ee-4d75-9cbc-d188f7f8602e.png) |\n| ![image](https://user-images.githubusercontent.com/14913065/160632173-040d4139-76f4-4410-851b-d8c1cef014d2.png) | ![image](https://user-images.githubusercontent.com/14913065/160632233-6fd3fe73-cadc-4291-b104-59d2e45366a6.png) |\n\n### `clean::types::ItemKind` modification\n\n* `ItemKind::TypedefItem(.., true)` \u2192 `ItemKind::AssocTypeItem(..)`\n* `ItemKind::TypedefItem(.., false)` \u2192 `ItemKind::TypedefItem(..)`\n\nFurther, I added `ItemKind::TyAssoc{Const,Type}Item`, the \u201crequired\u201d variant of `ItemKind::Assoc{Const,Type}Item`, analogous to `ItemKind::TyMethodItem` with `ItemKind::MethodItem`. These new variants don't contain new information really, they are just the result of me getting rid of the `Option<_>` field in `AssocConstItem` and `AssocTypeItem`.\n\n**Goal**: Make associated items more consistent.\nOriginally I thought modifying `ItemKind` was necessary to achieve the new functionality of this PR but in retrospect, it does not. If you don't like the changes to `ItemKind`, I think I _can_ get rid of them.\n\nThis change is the root cause of those tiny changes in a lot of different files.\n\n ### Concerns and Open Questions\n\n* **breaking changes** to hyperlinks: Some heading IDs change:\n  * `associated-const` (sic!) -> `{provided,required}-associated-consts`\n  * `associated-types` -> `{provided,required}-associated-types`\n* **verbosity** of the headings _{Required,Provided} Associated {Constants,Types}_\n* For some files, I am not sure if the changes I made are correct. So please take extra care when reviewing `conversions.rs` (conversion to JSON), `cache.rs`/`fold_item`, `stripper.rs`/`fold_item`, `check_doc_test_visibility.rs`/`should_have_doc_example`, `collect_intra_doc_links.rs`/`from_assoc_item`\n* JSON output: I still map `AssocTypeItem`s to `Typedef` etc. (FIXME)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "html_url": "https://github.com/rust-lang/rust/commit/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52ca603da73ae9eaddf96f77953b33ad8c47cc8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/52ca603da73ae9eaddf96f77953b33ad8c47cc8e", "html_url": "https://github.com/rust-lang/rust/commit/52ca603da73ae9eaddf96f77953b33ad8c47cc8e"}, {"sha": "8de453a8c6a26e43876def2d757bec40ed9b2767", "url": "https://api.github.com/repos/rust-lang/rust/commits/8de453a8c6a26e43876def2d757bec40ed9b2767", "html_url": "https://github.com/rust-lang/rust/commit/8de453a8c6a26e43876def2d757bec40ed9b2767"}], "stats": {"total": 644, "additions": 401, "deletions": 243}, "files": [{"sha": "33db6583125efbc9d03ecf9fea4a9244042d72a3", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -79,7 +79,7 @@ crate fn try_inline(\n         Res::Def(DefKind::TyAlias, did) => {\n             record_extern_fqn(cx, did, ItemType::Typedef);\n             build_impls(cx, Some(parent_module), did, attrs, &mut ret);\n-            clean::TypedefItem(build_type_alias(cx, did), false)\n+            clean::TypedefItem(build_type_alias(cx, did))\n         }\n         Res::Def(DefKind::Enum, did) => {\n             record_extern_fqn(cx, did, ItemType::Enum);"}, {"sha": "a6763d2827cec0fc486919126d422ac006d8a83c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 51, "deletions": 34, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -964,11 +964,11 @@ impl Clean<Item> for hir::TraitItem<'_> {\n         let local_did = self.def_id.to_def_id();\n         cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n-                hir::TraitItemKind::Const(ref ty, default) => {\n-                    let default =\n-                        default.map(|e| ConstantKind::Local { def_id: local_did, body: e });\n-                    AssocConstItem(ty.clean(cx), default)\n-                }\n+                hir::TraitItemKind::Const(ref ty, Some(default)) => AssocConstItem(\n+                    ty.clean(cx),\n+                    ConstantKind::Local { def_id: local_did, body: default },\n+                ),\n+                hir::TraitItemKind::Const(ref ty, None) => TyAssocConstItem(ty.clean(cx)),\n                 hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n                     let m = clean_function(cx, sig, &self.generics, body);\n                     MethodItem(m, None)\n@@ -983,11 +983,19 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     });\n                     TyMethodItem(Function { decl, generics })\n                 }\n-                hir::TraitItemKind::Type(bounds, ref default) => {\n+                hir::TraitItemKind::Type(bounds, Some(default)) => {\n+                    let generics = enter_impl_trait(cx, |cx| self.generics.clean(cx));\n+                    let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n+                    let item_type = hir_ty_to_ty(cx.tcx, default).clean(cx);\n+                    AssocTypeItem(\n+                        Typedef { type_: default.clean(cx), generics, item_type: Some(item_type) },\n+                        bounds,\n+                    )\n+                }\n+                hir::TraitItemKind::Type(bounds, None) => {\n                     let generics = enter_impl_trait(cx, |cx| self.generics.clean(cx));\n                     let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n-                    let default = default.map(|t| t.clean(cx));\n-                    AssocTypeItem(Box::new(generics), bounds, default)\n+                    TyAssocTypeItem(Box::new(generics), bounds)\n                 }\n             };\n             let what_rustc_thinks =\n@@ -1004,7 +1012,7 @@ impl Clean<Item> for hir::ImplItem<'_> {\n         cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n                 hir::ImplItemKind::Const(ref ty, expr) => {\n-                    let default = Some(ConstantKind::Local { def_id: local_did, body: expr });\n+                    let default = ConstantKind::Local { def_id: local_did, body: expr };\n                     AssocConstItem(ty.clean(cx), default)\n                 }\n                 hir::ImplItemKind::Fn(ref sig, body) => {\n@@ -1016,7 +1024,10 @@ impl Clean<Item> for hir::ImplItem<'_> {\n                     let type_ = hir_ty.clean(cx);\n                     let generics = self.generics.clean(cx);\n                     let item_type = hir_ty_to_ty(cx.tcx, hir_ty).clean(cx);\n-                    TypedefItem(Typedef { type_, generics, item_type: Some(item_type) }, true)\n+                    AssocTypeItem(\n+                        Typedef { type_, generics, item_type: Some(item_type) },\n+                        Vec::new(),\n+                    )\n                 }\n             };\n \n@@ -1041,13 +1052,17 @@ impl Clean<Item> for ty::AssocItem {\n         let tcx = cx.tcx;\n         let kind = match self.kind {\n             ty::AssocKind::Const => {\n-                let ty = tcx.type_of(self.def_id);\n-                let default = if self.defaultness.has_value() {\n-                    Some(ConstantKind::Extern { def_id: self.def_id })\n-                } else {\n-                    None\n+                let ty = tcx.type_of(self.def_id).clean(cx);\n+\n+                let provided = match self.container {\n+                    ty::ImplContainer(_) => true,\n+                    ty::TraitContainer(_) => self.defaultness.has_value(),\n                 };\n-                AssocConstItem(ty.clean(cx), default)\n+                if provided {\n+                    AssocConstItem(ty, ConstantKind::Extern { def_id: self.def_id })\n+                } else {\n+                    TyAssocConstItem(ty)\n+                }\n             }\n             ty::AssocKind::Fn => {\n                 let generics = clean_ty_generics(\n@@ -1181,23 +1196,28 @@ impl Clean<Item> for ty::AssocItem {\n                         None => bounds.push(GenericBound::maybe_sized(cx)),\n                     }\n \n-                    let ty = if self.defaultness.has_value() {\n-                        Some(tcx.type_of(self.def_id))\n+                    if self.defaultness.has_value() {\n+                        AssocTypeItem(\n+                            Typedef {\n+                                type_: tcx.type_of(self.def_id).clean(cx),\n+                                generics,\n+                                // FIXME: should we obtain the Type from HIR and pass it on here?\n+                                item_type: None,\n+                            },\n+                            bounds,\n+                        )\n                     } else {\n-                        None\n-                    };\n-\n-                    AssocTypeItem(Box::new(generics), bounds, ty.map(|t| t.clean(cx)))\n+                        TyAssocTypeItem(Box::new(generics), bounds)\n+                    }\n                 } else {\n                     // FIXME: when could this happen? Associated items in inherent impls?\n-                    let type_ = tcx.type_of(self.def_id).clean(cx);\n-                    TypedefItem(\n+                    AssocTypeItem(\n                         Typedef {\n-                            type_,\n+                            type_: tcx.type_of(self.def_id).clean(cx),\n                             generics: Generics { params: Vec::new(), where_predicates: Vec::new() },\n                             item_type: None,\n                         },\n-                        true,\n+                        Vec::new(),\n                     )\n                 }\n             }\n@@ -1837,14 +1857,11 @@ fn clean_maybe_renamed_item(\n             ItemKind::TyAlias(hir_ty, ref generics) => {\n                 let rustdoc_ty = hir_ty.clean(cx);\n                 let ty = hir_ty_to_ty(cx.tcx, hir_ty).clean(cx);\n-                TypedefItem(\n-                    Typedef {\n-                        type_: rustdoc_ty,\n-                        generics: generics.clean(cx),\n-                        item_type: Some(ty),\n-                    },\n-                    false,\n-                )\n+                TypedefItem(Typedef {\n+                    type_: rustdoc_ty,\n+                    generics: generics.clean(cx),\n+                    item_type: Some(ty),\n+                })\n             }\n             ItemKind::Enum(ref def, ref generics) => EnumItem(Enum {\n                 variants: def.variants.iter().map(|v| v.clean(cx)).collect(),"}, {"sha": "d2abfc35b932cfa1f3e6be1ef946ec737b985cb4", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -577,10 +577,16 @@ impl Item {\n         self.type_() == ItemType::Variant\n     }\n     crate fn is_associated_type(&self) -> bool {\n-        self.type_() == ItemType::AssocType\n+        matches!(&*self.kind, AssocTypeItem(..) | StrippedItem(box AssocTypeItem(..)))\n+    }\n+    crate fn is_ty_associated_type(&self) -> bool {\n+        matches!(&*self.kind, TyAssocTypeItem(..) | StrippedItem(box TyAssocTypeItem(..)))\n     }\n     crate fn is_associated_const(&self) -> bool {\n-        self.type_() == ItemType::AssocConst\n+        matches!(&*self.kind, AssocConstItem(..) | StrippedItem(box AssocConstItem(..)))\n+    }\n+    crate fn is_ty_associated_const(&self) -> bool {\n+        matches!(&*self.kind, TyAssocConstItem(..) | StrippedItem(box TyAssocConstItem(..)))\n     }\n     crate fn is_method(&self) -> bool {\n         self.type_() == ItemType::Method\n@@ -726,17 +732,18 @@ crate enum ItemKind {\n     EnumItem(Enum),\n     FunctionItem(Function),\n     ModuleItem(Module),\n-    TypedefItem(Typedef, bool /* is associated type */),\n+    TypedefItem(Typedef),\n     OpaqueTyItem(OpaqueTy),\n     StaticItem(Static),\n     ConstantItem(Constant),\n     TraitItem(Trait),\n     TraitAliasItem(TraitAlias),\n     ImplItem(Impl),\n-    /// A method signature only. Used for required methods in traits (ie,\n-    /// non-default-methods).\n+    /// A required method in a trait declaration meaning it's only a function signature.\n     TyMethodItem(Function),\n-    /// A method with a body.\n+    /// A method in a trait impl or a provided method in a trait declaration.\n+    ///\n+    /// Compared to [TyMethodItem], it also contains a method body.\n     MethodItem(Function, Option<hir::Defaultness>),\n     StructFieldItem(Type),\n     VariantItem(Variant),\n@@ -749,12 +756,16 @@ crate enum ItemKind {\n     MacroItem(Macro),\n     ProcMacroItem(ProcMacro),\n     PrimitiveItem(PrimitiveType),\n-    AssocConstItem(Type, Option<ConstantKind>),\n-    /// An associated item in a trait or trait impl.\n+    /// A required associated constant in a trait declaration.\n+    TyAssocConstItem(Type),\n+    /// An associated associated constant in a trait impl or a provided one in a trait declaration.\n+    AssocConstItem(Type, ConstantKind),\n+    /// A required associated type in a trait declaration.\n     ///\n     /// The bounds may be non-empty if there is a `where` clause.\n-    /// The `Option<Type>` is the default concrete type (e.g. `trait Trait { type Target = usize; }`)\n-    AssocTypeItem(Box<Generics>, Vec<GenericBound>, Option<Type>),\n+    TyAssocTypeItem(Box<Generics>, Vec<GenericBound>),\n+    /// An associated type in a trait impl or a provided one in a trait declaration.\n+    AssocTypeItem(Typedef, Vec<GenericBound>),\n     /// An item that has been stripped by a rustdoc pass\n     StrippedItem(Box<ItemKind>),\n     KeywordItem(Symbol),\n@@ -776,7 +787,7 @@ impl ItemKind {\n             ExternCrateItem { .. }\n             | ImportItem(_)\n             | FunctionItem(_)\n-            | TypedefItem(_, _)\n+            | TypedefItem(_)\n             | OpaqueTyItem(_)\n             | StaticItem(_)\n             | ConstantItem(_)\n@@ -791,7 +802,9 @@ impl ItemKind {\n             | MacroItem(_)\n             | ProcMacroItem(_)\n             | PrimitiveItem(_)\n+            | TyAssocConstItem(_)\n             | AssocConstItem(_, _)\n+            | TyAssocTypeItem(..)\n             | AssocTypeItem(..)\n             | StrippedItem(_)\n             | KeywordItem(_) => [].iter(),"}, {"sha": "fe6d680991f80f3e6652cf532a7fb4f065907ae6", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -178,7 +178,7 @@ crate fn build_deref_target_impls(cx: &mut DocContext<'_>, items: &[Item], ret:\n \n     for item in items {\n         let target = match *item.kind {\n-            ItemKind::TypedefItem(ref t, true) => &t.type_,\n+            ItemKind::AssocTypeItem(ref t, _) => &t.type_,\n             _ => continue,\n         };\n "}, {"sha": "95adc4426b585a1edb791d1bcecf6223aff768bd", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -71,7 +71,7 @@ crate trait DocFolder: Sized {\n             ExternCrateItem { src: _ }\n             | ImportItem(_)\n             | FunctionItem(_)\n-            | TypedefItem(_, _)\n+            | TypedefItem(_)\n             | OpaqueTyItem(_)\n             | StaticItem(_)\n             | ConstantItem(_)\n@@ -85,7 +85,9 @@ crate trait DocFolder: Sized {\n             | MacroItem(_)\n             | ProcMacroItem(_)\n             | PrimitiveItem(_)\n-            | AssocConstItem(_, _)\n+            | TyAssocConstItem(..)\n+            | AssocConstItem(..)\n+            | TyAssocTypeItem(..)\n             | AssocTypeItem(..)\n             | KeywordItem(_) => kind,\n         }"}, {"sha": "663e18fe9129fd594ebae6885b74ee88b7f25e0d", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -242,14 +242,15 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         if let Some(ref s) = item.name {\n             let (parent, is_inherent_impl_item) = match *item.kind {\n                 clean::StrippedItem(..) => ((None, None), false),\n-                clean::AssocConstItem(..) | clean::TypedefItem(_, true)\n+                clean::AssocConstItem(..) | clean::AssocTypeItem(..)\n                     if self.cache.parent_is_trait_impl =>\n                 {\n                     // skip associated items in trait impls\n                     ((None, None), false)\n                 }\n-                clean::AssocTypeItem(..)\n-                | clean::TyMethodItem(..)\n+                clean::TyMethodItem(..)\n+                | clean::TyAssocConstItem(..)\n+                | clean::TyAssocTypeItem(..)\n                 | clean::StructFieldItem(..)\n                 | clean::VariantItem(..) => (\n                     (\n@@ -258,7 +259,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                     ),\n                     false,\n                 ),\n-                clean::MethodItem(..) | clean::AssocConstItem(..) => {\n+                clean::MethodItem(..) | clean::AssocConstItem(..) | clean::AssocTypeItem(..) => {\n                     if self.cache.parent_stack.is_empty() {\n                         ((None, None), false)\n                     } else {\n@@ -373,7 +374,9 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             | clean::TyMethodItem(..)\n             | clean::MethodItem(..)\n             | clean::StructFieldItem(..)\n+            | clean::TyAssocConstItem(..)\n             | clean::AssocConstItem(..)\n+            | clean::TyAssocTypeItem(..)\n             | clean::AssocTypeItem(..)\n             | clean::StrippedItem(..)\n             | clean::KeywordItem(..) => {"}, {"sha": "fb4afb769ad15697ced9f1513db320bc65d13a39", "filename": "src/librustdoc/formats/item_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -14,7 +14,7 @@ use crate::clean;\n /// The search index uses item types encoded as smaller numbers which equal to\n /// discriminants. JavaScript then is used to decode them into the original value.\n /// Consequently, every change to this type should be synchronized to\n-/// the `itemTypes` mapping table in `html/static/main.js`.\n+/// the `itemTypes` mapping table in `html/static/js/search.js`.\n ///\n /// In addition, code in `html::render` uses this enum to generate CSS classes, page prefixes, and\n /// module headings. If you are adding to this enum and want to ensure that the sidebar also prints\n@@ -89,8 +89,8 @@ impl<'a> From<&'a clean::Item> for ItemType {\n             clean::ForeignStaticItem(..) => ItemType::Static,     // no ForeignStatic\n             clean::MacroItem(..) => ItemType::Macro,\n             clean::PrimitiveItem(..) => ItemType::Primitive,\n-            clean::AssocConstItem(..) => ItemType::AssocConst,\n-            clean::AssocTypeItem(..) => ItemType::AssocType,\n+            clean::TyAssocConstItem(..) | clean::AssocConstItem(..) => ItemType::AssocConst,\n+            clean::TyAssocTypeItem(..) | clean::AssocTypeItem(..) => ItemType::AssocType,\n             clean::ForeignTypeItem => ItemType::ForeignType,\n             clean::KeywordItem(..) => ItemType::Keyword,\n             clean::TraitAliasItem(..) => ItemType::TraitAlias,"}, {"sha": "55b0028180f66fece8164bb2f1c903a36154e7c4", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -527,6 +527,21 @@ crate enum HrefError {\n     /// This item is known to rustdoc, but from a crate that does not have documentation generated.\n     ///\n     /// This can only happen for non-local items.\n+    ///\n+    /// # Example\n+    ///\n+    /// Crate `a` defines a public trait and crate `b` \u2013 the target crate that depends on `a` \u2013\n+    /// implements it for a local type.\n+    /// We document `b` but **not** `a` (we only _build_ the latter \u2013 with `rustc`):\n+    ///\n+    /// ```sh\n+    /// rustc a.rs --crate-type=lib\n+    /// rustdoc b.rs --crate-type=lib --extern=a=liba.rlib\n+    /// ```\n+    ///\n+    /// Now, the associated items in the trait impl want to link to the corresponding item in the\n+    /// trait declaration (see `html::render::assoc_href_attr`) but it's not available since their\n+    /// *documentation (was) not built*.\n     DocumentationNotBuilt,\n     /// This can only happen for non-local items when `--document-private-items` is not passed.\n     Private,"}, {"sha": "1ebb41b5933d0b0350165494ce61bbe4198cd7d9", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -1452,8 +1452,10 @@ fn init_id_map() -> FxHashMap<String, usize> {\n     map.insert(\"trait-implementations\".to_owned(), 1);\n     map.insert(\"synthetic-implementations\".to_owned(), 1);\n     map.insert(\"blanket-implementations\".to_owned(), 1);\n-    map.insert(\"associated-types\".to_owned(), 1);\n-    map.insert(\"associated-const\".to_owned(), 1);\n+    map.insert(\"required-associated-types\".to_owned(), 1);\n+    map.insert(\"provided-associated-types\".to_owned(), 1);\n+    map.insert(\"provided-associated-consts\".to_owned(), 1);\n+    map.insert(\"required-associated-consts\".to_owned(), 1);\n     map.insert(\"required-methods\".to_owned(), 1);\n     map.insert(\"provided-methods\".to_owned(), 1);\n     map.insert(\"implementors\".to_owned(), 1);"}, {"sha": "9891c4b676fb4d2e32bea23619bed94b2ad05261", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 157, "deletions": 90, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -521,7 +521,7 @@ fn document_short(\n         let mut summary_html = MarkdownSummaryLine(&s, &item.links(cx)).into_string();\n \n         if s.contains('\\n') {\n-            let link = format!(r#\" <a href=\"{}\">Read more</a>\"#, naive_assoc_href(item, link, cx));\n+            let link = format!(r#\" <a{}>Read more</a>\"#, assoc_href_attr(item, link, cx));\n \n             if let Some(idx) = summary_html.rfind(\"</p>\") {\n                 summary_html.insert_str(idx, &link);\n@@ -737,42 +737,82 @@ fn render_impls(\n     w.write_str(&rendered_impls.join(\"\"));\n }\n \n-fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>, cx: &Context<'_>) -> String {\n-    use crate::formats::item_type::ItemType::*;\n+/// Build a (possibly empty) `href` attribute (a key-value pair) for the given associated item.\n+fn assoc_href_attr(it: &clean::Item, link: AssocItemLink<'_>, cx: &Context<'_>) -> String {\n+    let name = it.name.unwrap();\n+    let item_type = it.type_();\n \n-    let name = it.name.as_ref().unwrap();\n-    let ty = match it.type_() {\n-        Typedef | AssocType => AssocType,\n-        s => s,\n-    };\n+    let href = match link {\n+        AssocItemLink::Anchor(Some(ref id)) => Some(format!(\"#{}\", id)),\n+        AssocItemLink::Anchor(None) => Some(format!(\"#{}.{}\", item_type, name)),\n+        AssocItemLink::GotoSource(did, provided_methods) => {\n+            // We're creating a link from the implementation of an associated item to its\n+            // declaration in the trait declaration.\n+            let item_type = match item_type {\n+                // For historical but not technical reasons, the item type of methods in\n+                // trait declarations depends on whether the method is required (`TyMethod`) or\n+                // provided (`Method`).\n+                ItemType::Method | ItemType::TyMethod => {\n+                    if provided_methods.contains(&name) {\n+                        ItemType::Method\n+                    } else {\n+                        ItemType::TyMethod\n+                    }\n+                }\n+                // For associated types and constants, no such distinction exists.\n+                item_type => item_type,\n+            };\n \n-    let anchor = format!(\"#{}.{}\", ty, name);\n-    match link {\n-        AssocItemLink::Anchor(Some(ref id)) => format!(\"#{}\", id),\n-        AssocItemLink::Anchor(None) => anchor,\n-        AssocItemLink::GotoSource(did, _) => {\n-            href(did.expect_def_id(), cx).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n+            match href(did.expect_def_id(), cx) {\n+                Ok((url, ..)) => Some(format!(\"{}#{}.{}\", url, item_type, name)),\n+                // The link is broken since it points to an external crate that wasn't documented.\n+                // Do not create any link in such case. This is better than falling back to a\n+                // dummy anchor like `#{item_type}.{name}` representing the `id` of *this* impl item\n+                // (that used to happen in older versions). Indeed, in most cases this dummy would\n+                // coincide with the `id`. However, it would not always do so.\n+                // In general, this dummy would be incorrect:\n+                // If the type with the trait impl also had an inherent impl with an assoc. item of\n+                // the *same* name as this impl item, the dummy would link to that one even though\n+                // those two items are distinct!\n+                // In this scenario, the actual `id` of this impl item would be\n+                // `#{item_type}.{name}-{n}` for some number `n` (a disambiguator).\n+                Err(HrefError::DocumentationNotBuilt) => None,\n+                Err(_) => Some(format!(\"#{}.{}\", item_type, name)),\n+            }\n         }\n-    }\n+    };\n+\n+    // If there is no `href` for the reason explained above, simply do not render it which is valid:\n+    // https://html.spec.whatwg.org/multipage/links.html#links-created-by-a-and-area-elements\n+    href.map(|href| format!(\" href=\\\"{}\\\"\", href)).unwrap_or_default()\n }\n \n fn assoc_const(\n     w: &mut Buffer,\n     it: &clean::Item,\n     ty: &clean::Type,\n+    default: Option<&clean::ConstantKind>,\n     link: AssocItemLink<'_>,\n     extra: &str,\n     cx: &Context<'_>,\n ) {\n     write!(\n         w,\n-        \"{}{}const <a href=\\\"{}\\\" class=\\\"constant\\\">{}</a>: {}\",\n-        extra,\n-        it.visibility.print_with_space(it.def_id, cx),\n-        naive_assoc_href(it, link, cx),\n-        it.name.as_ref().unwrap(),\n-        ty.print(cx)\n+        \"{extra}{vis}const <a{href} class=\\\"constant\\\">{name}</a>: {ty}\",\n+        extra = extra,\n+        vis = it.visibility.print_with_space(it.def_id, cx),\n+        href = assoc_href_attr(it, link, cx),\n+        name = it.name.as_ref().unwrap(),\n+        ty = ty.print(cx),\n     );\n+    if let Some(default) = default {\n+        // FIXME: `.value()` uses `clean::utils::format_integer_with_underscore_sep` under the\n+        //        hood which adds noisy underscores and a type suffix to number literals.\n+        //        This hurts readability in this context especially when more complex expressions\n+        //        are involved and it doesn't add much of value.\n+        //        Find a way to print constants here without all that jazz.\n+        write!(w, \" = {}\", default.value(cx.tcx()).unwrap_or_else(|| default.expr(cx.tcx())));\n+    }\n }\n \n fn assoc_type(\n@@ -787,9 +827,9 @@ fn assoc_type(\n ) {\n     write!(\n         w,\n-        \"{indent}type <a href=\\\"{href}\\\" class=\\\"associatedtype\\\">{name}</a>{generics}\",\n+        \"{indent}type <a{href} class=\\\"associatedtype\\\">{name}</a>{generics}\",\n         indent = \" \".repeat(indent),\n-        href = naive_assoc_href(it, link, cx),\n+        href = assoc_href_attr(it, link, cx),\n         name = it.name.as_ref().unwrap(),\n         generics = generics.print(cx),\n     );\n@@ -814,22 +854,6 @@ fn assoc_method(\n ) {\n     let header = meth.fn_header(cx.tcx()).expect(\"Trying to get header from a non-function item\");\n     let name = meth.name.as_ref().unwrap();\n-    let href = match link {\n-        AssocItemLink::Anchor(Some(ref id)) => Some(format!(\"#{}\", id)),\n-        AssocItemLink::Anchor(None) => Some(format!(\"#{}.{}\", meth.type_(), name)),\n-        AssocItemLink::GotoSource(did, provided_methods) => {\n-            // We're creating a link from an impl-item to the corresponding\n-            // trait-item and need to map the anchored type accordingly.\n-            let ty =\n-                if provided_methods.contains(name) { ItemType::Method } else { ItemType::TyMethod };\n-\n-            match (href(did.expect_def_id(), cx), ty) {\n-                (Ok(p), ty) => Some(format!(\"{}#{}.{}\", p.0, ty, name)),\n-                (Err(HrefError::DocumentationNotBuilt), ItemType::TyMethod) => None,\n-                (Err(_), ty) => Some(format!(\"#{}.{}\", ty, name)),\n-            }\n-        }\n-    };\n     let vis = meth.visibility.print_with_space(meth.def_id, cx).to_string();\n     // FIXME: Once https://github.com/rust-lang/rust/issues/67792 is implemented, we can remove\n     // this condition.\n@@ -843,6 +867,7 @@ fn assoc_method(\n     let unsafety = header.unsafety.print_with_space();\n     let defaultness = print_default_space(meth.is_default());\n     let abi = print_abi_with_space(header.abi).to_string();\n+    let href = assoc_href_attr(meth, link, cx);\n \n     // NOTE: `{:#}` does not print HTML formatting, `{}` does. So `g.print` can't be reused between the length calculation and `write!`.\n     let generics_len = format!(\"{:#}\", g.print(cx)).len();\n@@ -868,7 +893,7 @@ fn assoc_method(\n     w.reserve(header_len + \"<a href=\\\"\\\" class=\\\"fnname\\\">{\".len() + \"</a>\".len());\n     write!(\n         w,\n-        \"{indent}{vis}{constness}{asyncness}{unsafety}{defaultness}{abi}fn <a {href} class=\\\"fnname\\\">{name}</a>\\\n+        \"{indent}{vis}{constness}{asyncness}{unsafety}{defaultness}{abi}fn <a{href} class=\\\"fnname\\\">{name}</a>\\\n          {generics}{decl}{notable_traits}{where_clause}\",\n         indent = indent_str,\n         vis = vis,\n@@ -877,8 +902,7 @@ fn assoc_method(\n         unsafety = unsafety,\n         defaultness = defaultness,\n         abi = abi,\n-        // links without a href are valid - https://www.w3schools.com/tags/att_a_href.asp\n-        href = href.map(|href| format!(\"href=\\\"{}\\\"\", href)).unwrap_or_else(|| \"\".to_string()),\n+        href = href,\n         name = name,\n         generics = g.print(cx),\n         decl = d.full_print(header_len, indent, header.asyncness, cx),\n@@ -968,23 +992,43 @@ fn render_assoc_item(\n     cx: &Context<'_>,\n     render_mode: RenderMode,\n ) {\n-    match *item.kind {\n+    match &*item.kind {\n         clean::StrippedItem(..) => {}\n-        clean::TyMethodItem(ref m) => {\n+        clean::TyMethodItem(m) => {\n             assoc_method(w, item, &m.generics, &m.decl, link, parent, cx, render_mode)\n         }\n-        clean::MethodItem(ref m, _) => {\n+        clean::MethodItem(m, _) => {\n             assoc_method(w, item, &m.generics, &m.decl, link, parent, cx, render_mode)\n         }\n-        clean::AssocConstItem(ref ty, _) => {\n-            assoc_const(w, item, ty, link, if parent == ItemType::Trait { \"    \" } else { \"\" }, cx)\n-        }\n-        clean::AssocTypeItem(ref generics, ref bounds, ref default) => assoc_type(\n+        kind @ (clean::TyAssocConstItem(ty) | clean::AssocConstItem(ty, _)) => assoc_const(\n+            w,\n+            item,\n+            ty,\n+            match kind {\n+                clean::TyAssocConstItem(_) => None,\n+                clean::AssocConstItem(_, default) => Some(default),\n+                _ => unreachable!(),\n+            },\n+            link,\n+            if parent == ItemType::Trait { \"    \" } else { \"\" },\n+            cx,\n+        ),\n+        clean::TyAssocTypeItem(ref generics, ref bounds) => assoc_type(\n             w,\n             item,\n             generics,\n             bounds,\n-            default.as_ref(),\n+            None,\n+            link,\n+            if parent == ItemType::Trait { 4 } else { 0 },\n+            cx,\n+        ),\n+        clean::AssocTypeItem(ref ty, ref bounds) => assoc_type(\n+            w,\n+            item,\n+            &ty.generics,\n+            bounds,\n+            Some(ty.item_type.as_ref().unwrap_or(&ty.type_)),\n             link,\n             if parent == ItemType::Trait { 4 } else { 0 },\n             cx,\n@@ -1205,7 +1249,7 @@ fn render_deref_methods(\n         .items\n         .iter()\n         .find_map(|item| match *item.kind {\n-            clean::TypedefItem(ref t, true) => Some(match *t {\n+            clean::AssocTypeItem(ref t, _) => Some(match *t {\n                 clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n                 _ => (&t.type_, &t.type_),\n             }),\n@@ -1291,7 +1335,7 @@ fn notable_traits_decl(decl: &clean::FnDecl, cx: &Context<'_>) -> String {\n                             impl_.print(false, cx)\n                         );\n                         for it in &impl_.items {\n-                            if let clean::TypedefItem(ref tydef, _) = *it.kind {\n+                            if let clean::AssocTypeItem(ref tydef, ref _bounds) = *it.kind {\n                                 out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n                                 let empty_set = FxHashSet::default();\n                                 let src_link =\n@@ -1300,7 +1344,7 @@ fn notable_traits_decl(decl: &clean::FnDecl, cx: &Context<'_>) -> String {\n                                     &mut out,\n                                     it,\n                                     &tydef.generics,\n-                                    &[],\n+                                    &[], // intentionally leaving out bounds\n                                     Some(&tydef.type_),\n                                     src_link,\n                                     0,\n@@ -1439,7 +1483,7 @@ fn render_impl(\n                 if item_type == ItemType::Method { \" method-toggle\" } else { \"\" };\n             write!(w, \"<details class=\\\"rustdoc-toggle{}\\\" open><summary>\", method_toggle_class);\n         }\n-        match *item.kind {\n+        match &*item.kind {\n             clean::MethodItem(..) | clean::TyMethodItem(_) => {\n                 // Only render when the method is not static or we allow static methods\n                 if render_method_item {\n@@ -1471,63 +1515,68 @@ fn render_impl(\n                     w.write_str(\"</section>\");\n                 }\n             }\n-            clean::TypedefItem(ref tydef, _) => {\n-                let source_id = format!(\"{}.{}\", ItemType::AssocType, name);\n+            kind @ (clean::TyAssocConstItem(ty) | clean::AssocConstItem(ty, _)) => {\n+                let source_id = format!(\"{}.{}\", item_type, name);\n                 let id = cx.derive_id(source_id.clone());\n                 write!(\n                     w,\n                     \"<section id=\\\"{}\\\" class=\\\"{}{} has-srclink\\\">\",\n                     id, item_type, in_trait_class\n                 );\n+                render_rightside(w, cx, item, containing_item, render_mode);\n                 write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n                 w.write_str(\"<h4 class=\\\"code-header\\\">\");\n-                assoc_type(\n+                assoc_const(\n                     w,\n                     item,\n-                    &tydef.generics,\n-                    &[],\n-                    Some(&tydef.type_),\n+                    ty,\n+                    match kind {\n+                        clean::TyAssocConstItem(_) => None,\n+                        clean::AssocConstItem(_, default) => Some(default),\n+                        _ => unreachable!(),\n+                    },\n                     link.anchor(if trait_.is_some() { &source_id } else { &id }),\n-                    0,\n+                    \"\",\n                     cx,\n                 );\n                 w.write_str(\"</h4>\");\n                 w.write_str(\"</section>\");\n             }\n-            clean::AssocConstItem(ref ty, _) => {\n+            clean::TyAssocTypeItem(generics, bounds) => {\n                 let source_id = format!(\"{}.{}\", item_type, name);\n                 let id = cx.derive_id(source_id.clone());\n-                write!(\n-                    w,\n-                    \"<section id=\\\"{}\\\" class=\\\"{}{} has-srclink\\\">\",\n-                    id, item_type, in_trait_class\n-                );\n-                render_rightside(w, cx, item, containing_item, render_mode);\n+                write!(w, \"<section id=\\\"{}\\\" class=\\\"{}{}\\\">\", id, item_type, in_trait_class);\n                 write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n                 w.write_str(\"<h4 class=\\\"code-header\\\">\");\n-                assoc_const(\n+                assoc_type(\n                     w,\n                     item,\n-                    ty,\n+                    generics,\n+                    bounds,\n+                    None,\n                     link.anchor(if trait_.is_some() { &source_id } else { &id }),\n-                    \"\",\n+                    0,\n                     cx,\n                 );\n                 w.write_str(\"</h4>\");\n                 w.write_str(\"</section>\");\n             }\n-            clean::AssocTypeItem(ref generics, ref bounds, ref default) => {\n+            clean::AssocTypeItem(tydef, _bounds) => {\n                 let source_id = format!(\"{}.{}\", item_type, name);\n                 let id = cx.derive_id(source_id.clone());\n-                write!(w, \"<section id=\\\"{}\\\" class=\\\"{}{}\\\">\", id, item_type, in_trait_class,);\n+                write!(\n+                    w,\n+                    \"<section id=\\\"{}\\\" class=\\\"{}{} has-srclink\\\">\",\n+                    id, item_type, in_trait_class\n+                );\n                 write!(w, \"<a href=\\\"#{}\\\" class=\\\"anchor\\\"></a>\", id);\n                 w.write_str(\"<h4 class=\\\"code-header\\\">\");\n                 assoc_type(\n                     w,\n                     item,\n-                    generics,\n-                    bounds,\n-                    default.as_ref(),\n+                    &tydef.generics,\n+                    &[], // intentionally leaving out bounds\n+                    Some(tydef.item_type.as_ref().unwrap_or(&tydef.type_)),\n                     link.anchor(if trait_.is_some() { &source_id } else { &id }),\n                     0,\n                     cx,\n@@ -1748,13 +1797,13 @@ pub(crate) fn render_impl_summary(\n         write!(w, \"{}\", i.inner_impl().print(use_absolute, cx));\n         if show_def_docs {\n             for it in &i.inner_impl().items {\n-                if let clean::TypedefItem(ref tydef, _) = *it.kind {\n+                if let clean::AssocTypeItem(ref tydef, ref _bounds) = *it.kind {\n                     w.write_str(\"<span class=\\\"where fmt-newline\\\">  \");\n                     assoc_type(\n                         w,\n                         it,\n                         &tydef.generics,\n-                        &[],\n+                        &[], // intentionally leaving out bounds\n                         Some(&tydef.type_),\n                         AssocItemLink::Anchor(None),\n                         0,\n@@ -1822,7 +1871,7 @@ fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer) {\n         clean::PrimitiveItem(_) => sidebar_primitive(cx, buffer, it),\n         clean::UnionItem(ref u) => sidebar_union(cx, buffer, it, u),\n         clean::EnumItem(ref e) => sidebar_enum(cx, buffer, it, e),\n-        clean::TypedefItem(_, _) => sidebar_typedef(cx, buffer, it),\n+        clean::TypedefItem(_) => sidebar_typedef(cx, buffer, it),\n         clean::ModuleItem(ref m) => sidebar_module(buffer, &m.items),\n         clean::ForeignTypeItem => sidebar_foreign_type(cx, buffer, it),\n         _ => {}\n@@ -1917,7 +1966,7 @@ fn get_methods(\n                 if !for_deref || should_render_item(item, deref_mut, tcx) {\n                     Some(SidebarLink {\n                         name,\n-                        url: get_next_url(used_links, format!(\"method.{}\", name)),\n+                        url: get_next_url(used_links, format!(\"{}.{}\", ItemType::Method, name)),\n                     })\n                 } else {\n                     None\n@@ -1937,7 +1986,7 @@ fn get_associated_constants(\n         .filter_map(|item| match item.name {\n             Some(name) if !name.is_empty() && item.is_associated_const() => Some(SidebarLink {\n                 name,\n-                url: get_next_url(used_links, format!(\"associatedconstant.{}\", name)),\n+                url: get_next_url(used_links, format!(\"{}.{}\", ItemType::AssocConst, name)),\n             }),\n             _ => None,\n         })\n@@ -2106,7 +2155,7 @@ fn sidebar_deref_methods(\n     debug!(\"found Deref: {:?}\", impl_);\n     if let Some((target, real_target)) =\n         impl_.inner_impl().items.iter().find_map(|item| match *item.kind {\n-            clean::TypedefItem(ref t, true) => Some(match *t {\n+            clean::AssocTypeItem(ref t, _) => Some(match *t {\n                 clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n                 _ => (&t.type_, &t.type_),\n             }),\n@@ -2281,19 +2330,37 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n     print_sidebar_section(\n         buf,\n         &t.items,\n-        \"associated-types\",\n-        \"Associated Types\",\n+        \"required-associated-types\",\n+        \"Required Associated Types\",\n+        |m| m.is_ty_associated_type(),\n+        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::AssocType),\n+    );\n+\n+    print_sidebar_section(\n+        buf,\n+        &t.items,\n+        \"provided-associated-types\",\n+        \"Provided Associated Types\",\n         |m| m.is_associated_type(),\n-        |sym| format!(\"<a href=\\\"#associatedtype.{0}\\\">{0}</a>\", sym),\n+        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::AssocType),\n+    );\n+\n+    print_sidebar_section(\n+        buf,\n+        &t.items,\n+        \"required-associated-consts\",\n+        \"Required Associated Constants\",\n+        |m| m.is_ty_associated_const(),\n+        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::AssocConst),\n     );\n \n     print_sidebar_section(\n         buf,\n         &t.items,\n-        \"associated-const\",\n-        \"Associated Constants\",\n+        \"provided-associated-consts\",\n+        \"Provided Associated Constants\",\n         |m| m.is_associated_const(),\n-        |sym| format!(\"<a href=\\\"#associatedconstant.{0}\\\">{0}</a>\", sym),\n+        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::AssocConst),\n     );\n \n     print_sidebar_section(\n@@ -2302,7 +2369,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n         \"required-methods\",\n         \"Required Methods\",\n         |m| m.is_ty_method(),\n-        |sym| format!(\"<a href=\\\"#tymethod.{0}\\\">{0}</a>\", sym),\n+        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::TyMethod),\n     );\n \n     print_sidebar_section(\n@@ -2311,7 +2378,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n         \"provided-methods\",\n         \"Provided Methods\",\n         |m| m.is_method(),\n-        |sym| format!(\"<a href=\\\"#method.{0}\\\">{0}</a>\", sym),\n+        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::Method),\n     );\n \n     let cache = cx.cache();"}, {"sha": "1ed5c662c41cc162280b91829ff0b813b06d92ac", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 85, "deletions": 75, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -141,7 +141,7 @@ pub(super) fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer,\n \n     item_vars.render_into(buf).unwrap();\n \n-    match *item.kind {\n+    match &*item.kind {\n         clean::ModuleItem(ref m) => item_module(buf, cx, item, &m.items),\n         clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) => {\n             item_function(buf, cx, item, f)\n@@ -150,7 +150,7 @@ pub(super) fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer,\n         clean::StructItem(ref s) => item_struct(buf, cx, item, s),\n         clean::UnionItem(ref s) => item_union(buf, cx, item, s),\n         clean::EnumItem(ref e) => item_enum(buf, cx, item, e),\n-        clean::TypedefItem(ref t, is_associated) => item_typedef(buf, cx, item, t, is_associated),\n+        clean::TypedefItem(ref t) => item_typedef(buf, cx, item, t),\n         clean::MacroItem(ref m) => item_macro(buf, cx, item, m),\n         clean::ProcMacroItem(ref m) => item_proc_macro(buf, cx, item, m),\n         clean::PrimitiveItem(_) => item_primitive(buf, cx, item),\n@@ -507,13 +507,15 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n \n fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Trait) {\n     let bounds = bounds(&t.bounds, false, cx);\n-    let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n-    let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n-    let required = t.items.iter().filter(|m| m.is_ty_method()).collect::<Vec<_>>();\n-    let provided = t.items.iter().filter(|m| m.is_method()).collect::<Vec<_>>();\n-    let count_types = types.len();\n-    let count_consts = consts.len();\n-    let count_methods = required.len() + provided.len();\n+    let required_types = t.items.iter().filter(|m| m.is_ty_associated_type()).collect::<Vec<_>>();\n+    let provided_types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n+    let required_consts = t.items.iter().filter(|m| m.is_ty_associated_const()).collect::<Vec<_>>();\n+    let provided_consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n+    let required_methods = t.items.iter().filter(|m| m.is_ty_method()).collect::<Vec<_>>();\n+    let provided_methods = t.items.iter().filter(|m| m.is_method()).collect::<Vec<_>>();\n+    let count_types = required_types.len() + provided_types.len();\n+    let count_consts = required_consts.len() + provided_consts.len();\n+    let count_methods = required_methods.len() + provided_methods.len();\n \n     // Output the trait definition\n     wrap_into_docblock(w, |w| {\n@@ -554,16 +556,18 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                         ),\n                     );\n                 }\n-                for t in &types {\n-                    render_assoc_item(\n-                        w,\n-                        t,\n-                        AssocItemLink::Anchor(None),\n-                        ItemType::Trait,\n-                        cx,\n-                        RenderMode::Normal,\n-                    );\n-                    w.write_str(\";\\n\");\n+                for types in [&required_types, &provided_types] {\n+                    for t in types {\n+                        render_assoc_item(\n+                            w,\n+                            t,\n+                            AssocItemLink::Anchor(None),\n+                            ItemType::Trait,\n+                            cx,\n+                            RenderMode::Normal,\n+                        );\n+                        w.write_str(\";\\n\");\n+                    }\n                 }\n                 // If there are too many associated constants, hide everything after them\n                 // We also do this if the types + consts is large because otherwise we could\n@@ -582,28 +586,30 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                         ),\n                     );\n                 }\n-                if !types.is_empty() && !consts.is_empty() {\n+                if count_types != 0 && (count_consts != 0 || count_methods != 0) {\n                     w.write_str(\"\\n\");\n                 }\n-                for t in &consts {\n-                    render_assoc_item(\n-                        w,\n-                        t,\n-                        AssocItemLink::Anchor(None),\n-                        ItemType::Trait,\n-                        cx,\n-                        RenderMode::Normal,\n-                    );\n-                    w.write_str(\";\\n\");\n+                for consts in [&required_consts, &provided_consts] {\n+                    for c in consts {\n+                        render_assoc_item(\n+                            w,\n+                            c,\n+                            AssocItemLink::Anchor(None),\n+                            ItemType::Trait,\n+                            cx,\n+                            RenderMode::Normal,\n+                        );\n+                        w.write_str(\";\\n\");\n+                    }\n                 }\n                 if !toggle && should_hide_fields(count_methods) {\n                     toggle = true;\n                     toggle_open(w, format_args!(\"{} methods\", count_methods));\n                 }\n-                if !consts.is_empty() && !required.is_empty() {\n+                if count_consts != 0 && count_methods != 0 {\n                     w.write_str(\"\\n\");\n                 }\n-                for (pos, m) in required.iter().enumerate() {\n+                for (pos, m) in required_methods.iter().enumerate() {\n                     render_assoc_item(\n                         w,\n                         m,\n@@ -614,14 +620,14 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                     );\n                     w.write_str(\";\\n\");\n \n-                    if pos < required.len() - 1 {\n+                    if pos < required_methods.len() - 1 {\n                         w.write_str(\"<span class=\\\"item-spacer\\\"></span>\");\n                     }\n                 }\n-                if !required.is_empty() && !provided.is_empty() {\n+                if !required_methods.is_empty() && !provided_methods.is_empty() {\n                     w.write_str(\"\\n\");\n                 }\n-                for (pos, m) in provided.iter().enumerate() {\n+                for (pos, m) in provided_methods.iter().enumerate() {\n                     render_assoc_item(\n                         w,\n                         m,\n@@ -640,7 +646,8 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                             w.write_str(\" { ... }\\n\");\n                         }\n                     }\n-                    if pos < provided.len() - 1 {\n+\n+                    if pos < provided_methods.len() - 1 {\n                         w.write_str(\"<span class=\\\"item-spacer\\\"></span>\");\n                     }\n                 }\n@@ -703,53 +710,77 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         }\n     }\n \n-    if !types.is_empty() {\n+    if !required_types.is_empty() {\n         write_small_section_header(\n             w,\n-            \"associated-types\",\n-            \"Associated Types\",\n+            \"required-associated-types\",\n+            \"Required Associated Types\",\n             \"<div class=\\\"methods\\\">\",\n         );\n-        for t in types {\n+        for t in required_types {\n+            trait_item(w, cx, t, it);\n+        }\n+        w.write_str(\"</div>\");\n+    }\n+    if !provided_types.is_empty() {\n+        write_small_section_header(\n+            w,\n+            \"provided-associated-types\",\n+            \"Provided Associated Types\",\n+            \"<div class=\\\"methods\\\">\",\n+        );\n+        for t in provided_types {\n             trait_item(w, cx, t, it);\n         }\n         w.write_str(\"</div>\");\n     }\n \n-    if !consts.is_empty() {\n+    if !required_consts.is_empty() {\n+        write_small_section_header(\n+            w,\n+            \"required-associated-consts\",\n+            \"Required Associated Constants\",\n+            \"<div class=\\\"methods\\\">\",\n+        );\n+        for t in required_consts {\n+            trait_item(w, cx, t, it);\n+        }\n+        w.write_str(\"</div>\");\n+    }\n+    if !provided_consts.is_empty() {\n         write_small_section_header(\n             w,\n-            \"associated-const\",\n-            \"Associated Constants\",\n+            \"provided-associated-consts\",\n+            \"Provided Associated Constants\",\n             \"<div class=\\\"methods\\\">\",\n         );\n-        for t in consts {\n+        for t in provided_consts {\n             trait_item(w, cx, t, it);\n         }\n         w.write_str(\"</div>\");\n     }\n \n     // Output the documentation for each function individually\n-    if !required.is_empty() {\n+    if !required_methods.is_empty() {\n         write_small_section_header(\n             w,\n             \"required-methods\",\n-            \"Required methods\",\n+            \"Required Methods\",\n             \"<div class=\\\"methods\\\">\",\n         );\n-        for m in required {\n+        for m in required_methods {\n             trait_item(w, cx, m, it);\n         }\n         w.write_str(\"</div>\");\n     }\n-    if !provided.is_empty() {\n+    if !provided_methods.is_empty() {\n         write_small_section_header(\n             w,\n             \"provided-methods\",\n-            \"Provided methods\",\n+            \"Provided Methods\",\n             \"<div class=\\\"methods\\\">\",\n         );\n-        for m in provided {\n+        for m in provided_methods {\n             trait_item(w, cx, m, it);\n         }\n         w.write_str(\"</div>\");\n@@ -933,25 +964,11 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean:\n     render_assoc_items(w, cx, it, it.def_id.expect_def_id(), AssocItemRender::All)\n }\n \n-fn item_typedef(\n-    w: &mut Buffer,\n-    cx: &Context<'_>,\n-    it: &clean::Item,\n-    t: &clean::Typedef,\n-    is_associated: bool,\n-) {\n-    fn write_content(\n-        w: &mut Buffer,\n-        cx: &Context<'_>,\n-        it: &clean::Item,\n-        t: &clean::Typedef,\n-        is_associated: bool,\n-    ) {\n+fn item_typedef(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n+    fn write_content(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n         wrap_item(w, \"typedef\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n-            if !is_associated {\n-                write!(w, \"{}\", it.visibility.print_with_space(it.def_id, cx));\n-            }\n+            write!(w, \"{}\", it.visibility.print_with_space(it.def_id, cx));\n             write!(\n                 w,\n                 \"type {}{}{where_clause} = {type_};\",\n@@ -963,14 +980,7 @@ fn item_typedef(\n         });\n     }\n \n-    // If this is an associated typedef, we don't want to wrap it into a docblock.\n-    if is_associated {\n-        write_content(w, cx, it, t, is_associated);\n-    } else {\n-        wrap_into_docblock(w, |w| {\n-            write_content(w, cx, it, t, is_associated);\n-        });\n-    }\n+    wrap_into_docblock(w, |w| write_content(w, cx, it, t));\n \n     document(w, cx, it, None, HeadingOffset::H2);\n "}, {"sha": "ab52304491a2bc17841d3515f9227f9c916a57a2", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -3,7 +3,7 @@\n \n (function() {\n // This mapping table should match the discriminants of\n-// `rustdoc::html::item_type::ItemType` type in Rust.\n+// `rustdoc::formats::item_type::ItemType` type in Rust.\n var itemTypes = [\n     \"mod\",\n     \"externcrate\","}, {"sha": "a9a6a31fccd0d7c8b3457feda0250b6fab56bc83", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -219,20 +219,23 @@ fn from_clean_item(item: clean::Item, tcx: TyCtxt<'_>) -> ItemEnum {\n         StaticItem(s) => ItemEnum::Static(s.into_tcx(tcx)),\n         ForeignStaticItem(s) => ItemEnum::Static(s.into_tcx(tcx)),\n         ForeignTypeItem => ItemEnum::ForeignType,\n-        TypedefItem(t, _) => ItemEnum::Typedef(t.into_tcx(tcx)),\n+        TypedefItem(t) => ItemEnum::Typedef(t.into_tcx(tcx)),\n         OpaqueTyItem(t) => ItemEnum::OpaqueTy(t.into_tcx(tcx)),\n         ConstantItem(c) => ItemEnum::Constant(c.into_tcx(tcx)),\n         MacroItem(m) => ItemEnum::Macro(m.source),\n         ProcMacroItem(m) => ItemEnum::ProcMacro(m.into_tcx(tcx)),\n         PrimitiveItem(p) => ItemEnum::PrimitiveType(p.as_sym().to_string()),\n+        TyAssocConstItem(ty) => ItemEnum::AssocConst { type_: ty.into_tcx(tcx), default: None },\n         AssocConstItem(ty, default) => {\n-            ItemEnum::AssocConst { type_: ty.into_tcx(tcx), default: default.map(|c| c.expr(tcx)) }\n+            ItemEnum::AssocConst { type_: ty.into_tcx(tcx), default: Some(default.expr(tcx)) }\n         }\n-        AssocTypeItem(g, b, t) => ItemEnum::AssocType {\n+        TyAssocTypeItem(g, b) => ItemEnum::AssocType {\n             generics: (*g).into_tcx(tcx),\n             bounds: b.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n-            default: t.map(|x| x.into_tcx(tcx)),\n+            default: None,\n         },\n+        // FIXME: do not map to Typedef but to a custom variant\n+        AssocTypeItem(t, _) => ItemEnum::Typedef(t.into_tcx(tcx)),\n         // `convert_item` early returns `None` for striped items\n         StrippedItem(_) => unreachable!(),\n         KeywordItem(_) => {"}, {"sha": "b541fb63bd413422e694053c68a2bb86cb28a63f", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -61,9 +61,9 @@ crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> boo\n             *item.kind,\n             clean::StructFieldItem(_)\n                 | clean::VariantItem(_)\n-                | clean::AssocConstItem(_, _)\n+                | clean::AssocConstItem(..)\n                 | clean::AssocTypeItem(..)\n-                | clean::TypedefItem(_, _)\n+                | clean::TypedefItem(_)\n                 | clean::StaticItem(_)\n                 | clean::ConstantItem(_)\n                 | clean::ExternCrateItem { .. }"}, {"sha": "4ab942c8f1bdc977ab9d482c714edd34261f06f9", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -93,7 +93,7 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n                 let target = items\n                     .iter()\n                     .find_map(|item| match *item.kind {\n-                        TypedefItem(ref t, true) => Some(&t.type_),\n+                        AssocTypeItem(ref t, _) => Some(&t.type_),\n                         _ => None,\n                     })\n                     .expect(\"Deref impl without Target type\");"}, {"sha": "82627aaf7a4cb339ff5deff0dea4f6f703345d8b", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -41,6 +41,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             | clean::ConstantItem(..)\n             | clean::UnionItem(..)\n             | clean::AssocConstItem(..)\n+            | clean::AssocTypeItem(..)\n             | clean::TraitAliasItem(..)\n             | clean::MacroItem(..)\n             | clean::ForeignTypeItem => {\n@@ -72,18 +73,15 @@ impl<'a> DocFolder for Stripper<'a> {\n \n             clean::ImplItem(..) => {}\n \n-            // tymethods have no control over privacy\n-            clean::TyMethodItem(..) => {}\n+            // tymethods etc. have no control over privacy\n+            clean::TyMethodItem(..) | clean::TyAssocConstItem(..) | clean::TyAssocTypeItem(..) => {}\n \n             // Proc-macros are always public\n             clean::ProcMacroItem(..) => {}\n \n             // Primitives are never stripped\n             clean::PrimitiveItem(..) => {}\n \n-            // Associated types are never stripped\n-            clean::AssocTypeItem(..) => {}\n-\n             // Keywords are never stripped\n             clean::KeywordItem(..) => {}\n         }"}, {"sha": "ef50292674276c17d6a656f134604f00dc04ca44", "filename": "src/librustdoc/visit.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Flibrustdoc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -26,7 +26,7 @@ crate trait DocVisitor: Sized {\n             ExternCrateItem { src: _ }\n             | ImportItem(_)\n             | FunctionItem(_)\n-            | TypedefItem(_, _)\n+            | TypedefItem(_)\n             | OpaqueTyItem(_)\n             | StaticItem(_)\n             | ConstantItem(_)\n@@ -40,7 +40,9 @@ crate trait DocVisitor: Sized {\n             | MacroItem(_)\n             | ProcMacroItem(_)\n             | PrimitiveItem(_)\n-            | AssocConstItem(_, _)\n+            | TyAssocConstItem(..)\n+            | AssocConstItem(..)\n+            | TyAssocTypeItem(..)\n             | AssocTypeItem(..)\n             | KeywordItem(_) => {}\n         }"}, {"sha": "0ac6dc763df88bd0e3641fe2f9d3b958915a8ab5", "filename": "src/test/rustdoc/assoc-consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-consts.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -1,8 +1,8 @@\n pub trait Foo {\n     // @has assoc_consts/trait.Foo.html '//*[@class=\"rust trait\"]' \\\n-    //      'const FOO: usize;'\n+    //      'const FOO: usize = 13usize;'\n     // @has - '//*[@id=\"associatedconstant.FOO\"]' 'const FOO: usize'\n-    const FOO: usize = 12;\n+    const FOO: usize = 12 + 1;\n     // @has - '//*[@id=\"associatedconstant.FOO_NO_DEFAULT\"]' 'const FOO_NO_DEFAULT: bool'\n     const FOO_NO_DEFAULT: bool;\n     // @!has - FOO_HIDDEN"}, {"sha": "dab0a64952955b6352e264c12c662a9dbb5557a0", "filename": "src/test/rustdoc/extern-default-method.no_href_on_anchor.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Ftest%2Frustdoc%2Fextern-default-method.no_href_on_anchor.html", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Ftest%2Frustdoc%2Fextern-default-method.no_href_on_anchor.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fextern-default-method.no_href_on_anchor.html?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -0,0 +1 @@\n+<a class=\"fnname\">provided</a>(&amp;self)\n\\ No newline at end of file"}, {"sha": "8139f5b2619b3143a0927cee582b8e4dd3f9c5c7", "filename": "src/test/rustdoc/extern-default-method.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Ftest%2Frustdoc%2Fextern-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Ftest%2Frustdoc%2Fextern-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fextern-default-method.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -1,9 +1,23 @@\n // aux-build:rustdoc-extern-default-method.rs\n // ignore-cross-compile\n+// ignore-tidy-linelength\n \n extern crate rustdoc_extern_default_method as ext;\n \n+// For this test, the dependency is compiled but not documented.\n+//\n+// Still, the struct from the external crate and its impl should be documented since\n+// the struct is re-exported from this crate.\n+// However, the method in the trait impl should *not* have a link (an `href` attribute) to\n+// its corresponding item in the trait declaration since it would otherwise be broken.\n+//\n+// In older versions of rustdoc, the impl item (`a[@class=\"fnname\"]`) used to link to\n+// `#method.provided` \u2013 i.e. \"to itself\". Put in quotes since that was actually incorrect in\n+// general: If the type `Struct` also had an inherent method called `provided`, the impl item\n+// would link to that one even though those two methods are distinct items!\n+\n // @count extern_default_method/struct.Struct.html '//*[@id=\"method.provided\"]' 1\n-// @has extern_default_method/struct.Struct.html '//*[@id=\"method.provided\"]//a[@class=\"fnname\"]/@href' #method.provided\n+// @count extern_default_method/struct.Struct.html '//*[@id=\"method.provided\"]//a[@class=\"fnname\"]' 1\n+// @snapshot no_href_on_anchor - '//*[@id=\"method.provided\"]//a[@class=\"fnname\"]'\n // @has extern_default_method/struct.Struct.html '//*[@id=\"method.provided\"]//a[@class=\"anchor\"]/@href' #method.provided\n pub use ext::Struct;"}, {"sha": "c7ce71b15f30c572c8f6b7110c17e69519fee6b5", "filename": "src/test/rustdoc/intra-doc/prim-self.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-self.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -5,6 +5,7 @@\n #![feature(no_core)]\n #![feature(rustdoc_internals)]\n #![feature(inherent_associated_types)]\n+#![feature(lang_items)]\n #![no_core]\n \n /// [Self::f]\n@@ -35,3 +36,6 @@ pub struct S;\n impl S {\n     pub fn f() {}\n }\n+\n+#[lang = \"sized\"]\n+pub trait Sized {}"}, {"sha": "b5b681ab085bf7d0b1fe4411e18b9ce7184a2e6c", "filename": "src/test/rustdoc/sidebar-items.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Ftest%2Frustdoc%2Fsidebar-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe/src%2Ftest%2Frustdoc%2Fsidebar-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsidebar-items.rs?ref=0ec00c0ba3f2fdede6700af7b8f4438b5d7afebe", "patch": "@@ -1,16 +1,23 @@\n+#![feature(associated_type_defaults)]\n #![crate_name = \"foo\"]\n \n // @has foo/trait.Foo.html\n // @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#required-methods\"]' 'Required Methods'\n // @has - '//*[@class=\"sidebar-elems\"]//section//a' 'bar'\n // @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#provided-methods\"]' 'Provided Methods'\n // @has - '//*[@class=\"sidebar-elems\"]//section//a' 'foo'\n-// @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#associated-const\"]' 'Associated Constants'\n+// @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#required-associated-consts\"]' 'Required Associated Constants'\n+// @has - '//*[@class=\"sidebar-elems\"]//section//a' 'FOO'\n+// @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#provided-associated-consts\"]' 'Provided Associated Constants'\n // @has - '//*[@class=\"sidebar-elems\"]//section//a' 'BAR'\n-// @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#associated-types\"]' 'Associated Types'\n+// @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#required-associated-types\"]' 'Required Associated Types'\n // @has - '//*[@class=\"sidebar-elems\"]//section//a' 'Output'\n+// @has - '//*[@class=\"sidebar-title\"]/a[@href=\"#provided-associated-types\"]' 'Provided Associated Types'\n+// @has - '//*[@class=\"sidebar-elems\"]//section//a' 'Extra'\n pub trait Foo {\n+    const FOO: usize;\n     const BAR: u32 = 0;\n+    type Extra: Copy = ();\n     type Output: ?Sized;\n \n     fn foo() {}"}]}