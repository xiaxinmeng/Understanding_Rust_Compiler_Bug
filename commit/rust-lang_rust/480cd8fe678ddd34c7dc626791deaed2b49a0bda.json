{"sha": "480cd8fe678ddd34c7dc626791deaed2b49a0bda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4MGNkOGZlNjc4ZGRkMzRjN2RjNjI2NzkxZGVhZWQyYjQ5YTBiZGE=", "commit": {"author": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-06-25T20:08:10Z"}, "committer": {"name": "Jared Roesch", "email": "roeschinc@gmail.com", "date": "2015-06-27T21:15:49Z"}, "message": "Ground work for replacing the ClosureTyper trait", "tree": {"sha": "fe2090ad997478f8ec0214c8404f5eb6e903c27d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe2090ad997478f8ec0214c8404f5eb6e903c27d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/480cd8fe678ddd34c7dc626791deaed2b49a0bda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/480cd8fe678ddd34c7dc626791deaed2b49a0bda", "html_url": "https://github.com/rust-lang/rust/commit/480cd8fe678ddd34c7dc626791deaed2b49a0bda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/480cd8fe678ddd34c7dc626791deaed2b49a0bda/comments", "author": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jroesch", "id": 696509, "node_id": "MDQ6VXNlcjY5NjUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/696509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jroesch", "html_url": "https://github.com/jroesch", "followers_url": "https://api.github.com/users/jroesch/followers", "following_url": "https://api.github.com/users/jroesch/following{/other_user}", "gists_url": "https://api.github.com/users/jroesch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jroesch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jroesch/subscriptions", "organizations_url": "https://api.github.com/users/jroesch/orgs", "repos_url": "https://api.github.com/users/jroesch/repos", "events_url": "https://api.github.com/users/jroesch/events{/privacy}", "received_events_url": "https://api.github.com/users/jroesch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79d02895fffa865c6a4ccfaad1fa35d8f732d497", "url": "https://api.github.com/repos/rust-lang/rust/commits/79d02895fffa865c6a4ccfaad1fa35d8f732d497", "html_url": "https://github.com/rust-lang/rust/commit/79d02895fffa865c6a4ccfaad1fa35d8f732d497"}], "stats": {"total": 191, "additions": 170, "deletions": 21}, "files": [{"sha": "8bbb6ae757fc1e1f0c63cd31dc9e7e791b79809d", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=480cd8fe678ddd34c7dc626791deaed2b49a0bda", "patch": "@@ -283,7 +283,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n     fn check_static_type(&self, e: &ast::Expr) {\n         let ty = self.tcx.node_id_to_type(e.id);\n-        let infcx = infer::new_infer_ctxt(self.tcx, None);\n+        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n         let mut fulfill_cx = traits::FulfillmentContext::new(false);\n         let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n         fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);"}, {"sha": "a6b7d7f832a3cce31680729552231baafebbf60c", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=480cd8fe678ddd34c7dc626791deaed2b49a0bda", "patch": "@@ -1031,7 +1031,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                               substs: trait_substs });\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx, None);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n \n     let mut selcx = traits::SelectionContext::new(&infcx, &infcx.parameter_environment);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),"}, {"sha": "7727f6a6470078f0dd3300a803a558844bf913db", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 150, "deletions": 4, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=480cd8fe678ddd34c7dc626791deaed2b49a0bda", "patch": "@@ -23,19 +23,24 @@ pub use self::freshen::TypeFreshener;\n pub use self::region_inference::GenericKind;\n \n use middle::free_region::FreeRegionMap;\n+use middle::mem_categorization as mc;\n+use middle::mem_categorization::McResult;\n+use middle::region::{self, CodeExtent};\n use middle::subst;\n use middle::subst::Substs;\n+use middle::subst::Subst;\n+use middle::traits;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, UnconstrainedNumeric};\n use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use rustc_data_structures::unify::{self, UnificationTable};\n-use std::cell::{RefCell};\n+use std::cell::{RefCell, Ref};\n use std::fmt;\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use self::combine::CombineFields;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n@@ -64,6 +69,8 @@ pub type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n pub struct InferCtxt<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n \n+    pub tables: &'a RefCell<ty::Tables<'tcx>>,\n+\n     // We instantiate UnificationTable with bounds<Ty> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n@@ -80,7 +87,9 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n \n     pub parameter_environment: ty::ParameterEnvironment<'a, 'tcx>,\n \n-    // pub tables: &'a RefCell<ty::Tables<'tcx>>\n+    normalize: bool,\n+\n+    err_count_on_creation: usize,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n@@ -314,15 +323,19 @@ pub fn fixup_err_to_string(f: fixup_err) -> String {\n }\n \n pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n+                                tables: &'a RefCell<ty::Tables<'tcx>>,\n                                 param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>)\n                                 -> InferCtxt<'a, 'tcx> {\n     InferCtxt {\n         tcx: tcx,\n+        tables: tables,\n         type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n         int_unification_table: RefCell::new(UnificationTable::new()),\n         float_unification_table: RefCell::new(UnificationTable::new()),\n         region_vars: RegionVarBindings::new(tcx),\n-        parameter_environment: param_env.unwrap_or(tcx.empty_parameter_environment())\n+        parameter_environment: param_env.unwrap_or(tcx.empty_parameter_environment()),\n+        normalize: true,\n+        err_count_on_creation: tcx.sess.err_count()\n     }\n }\n \n@@ -437,6 +450,92 @@ pub struct CombinedSnapshot {\n     region_vars_snapshot: RegionSnapshot,\n }\n \n+impl<'a, 'tcx> mc::Typer<'tcx> for InferCtxt<'a, 'tcx> {\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n+        let ty = self.node_ty(id);\n+        self.resolve_type_vars_or_error(&ty)\n+    }\n+\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n+        let ty = self.adjust_expr_ty(expr, self.tables.borrow().adjustments.get(&expr.id));\n+        self.resolve_type_vars_or_error(&ty)\n+    }\n+\n+    fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n+        let ty = self.resolve_type_vars_if_possible(&ty);\n+        !traits::type_known_to_meet_builtin_bound(self, self, ty, ty::BoundCopy, span)\n+    }\n+\n+    fn node_method_ty(&self, method_call: ty::MethodCall)\n+                      -> Option<Ty<'tcx>> {\n+        self.tables\n+            .borrow()\n+            .method_map\n+            .get(&method_call)\n+            .map(|method| method.ty)\n+            .map(|ty| self.resolve_type_vars_if_possible(&ty))\n+    }\n+\n+    fn node_method_origin(&self, method_call: ty::MethodCall)\n+                          -> Option<ty::MethodOrigin<'tcx>>\n+    {\n+        self.tables\n+            .borrow()\n+            .method_map\n+            .get(&method_call)\n+            .map(|method| method.origin.clone())\n+    }\n+\n+    fn adjustments(&self) -> Ref<NodeMap<ty::AutoAdjustment<'tcx>>> {\n+        fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>) -> &'a NodeMap<ty::AutoAdjustment<'tcx>> {\n+            &tables.adjustments\n+        }\n+\n+        Ref::map(self.tables.borrow(), project_adjustments)\n+    }\n+\n+    fn is_method_call(&self, id: ast::NodeId) -> bool {\n+        self.tables.borrow().method_map.contains_key(&ty::MethodCall::expr(id))\n+    }\n+\n+    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<CodeExtent> {\n+        self.parameter_environment.temporary_scope(rvalue_id)\n+    }\n+\n+    fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+        self.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n+    }\n+}\n+\n+impl<'a, 'tcx> ty::ClosureTyper<'tcx> for InferCtxt<'a, 'tcx> {\n+    fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n+        &self.parameter_environment\n+    }\n+\n+    fn closure_kind(&self,\n+                    def_id: ast::DefId)\n+                    -> Option<ty::ClosureKind>\n+    {\n+        self.tables.borrow().closure_kinds.get(&def_id).cloned()\n+    }\n+\n+    fn closure_type(&self,\n+                    def_id: ast::DefId,\n+                    substs: &subst::Substs<'tcx>)\n+                    -> ty::ClosureTy<'tcx>\n+    {\n+        self.tables.borrow().closure_tys.get(&def_id).unwrap().subst(self.tcx, substs)\n+    }\n+\n+    fn closure_upvars(&self,\n+                      def_id: ast::DefId,\n+                      substs: &Substs<'tcx>)\n+                      -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n+    {\n+        ty::ctxt::closure_upvars(self, def_id, substs)\n+    }\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn freshen<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.freshener())\n@@ -858,6 +957,48 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.region_vars.new_bound(debruijn)\n     }\n \n+    /// Apply `adjustment` to the type of `expr`\n+    pub fn adjust_expr_ty(&self,\n+                          expr: &ast::Expr,\n+                          adjustment: Option<&ty::AutoAdjustment<'tcx>>)\n+                          -> Ty<'tcx>\n+    {\n+        let raw_ty = self.expr_ty(expr);\n+        let raw_ty = self.shallow_resolve(raw_ty);\n+        let resolve_ty = |ty: Ty<'tcx>| self.resolve_type_vars_if_possible(&ty);\n+        raw_ty.adjust(self.tcx,\n+                      expr.span,\n+                      expr.id,\n+                      adjustment,\n+                      |method_call| self.tables\n+                                        .borrow()\n+                                        .method_map\n+                                        .get(&method_call)\n+                                        .map(|method| resolve_ty(method.ty)))\n+    }\n+\n+    pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n+        match self.tables.borrow().node_types.get(&id) {\n+            Some(&t) => t,\n+            // FIXME\n+            None if self.tcx.sess.err_count() - self.err_count_on_creation != 0 => self.tcx.types.err,\n+            None => {\n+                self.tcx.sess.bug(\n+                    &format!(\"no type for node {}: {} in fcx\",\n+                            id, self.tcx.map.node_to_string(id)));\n+            }\n+        }\n+    }\n+\n+    pub fn expr_ty(&self, ex: &ast::Expr) -> Ty<'tcx> {\n+        match self.tables.borrow().node_types.get(&ex.id) {\n+            Some(&t) => t,\n+            None => {\n+                self.tcx.sess.bug(&format!(\"no type for expr in fcx\"));\n+            }\n+        }\n+    }\n+\n     pub fn resolve_regions_and_report_errors(&self,\n                                              free_regions: &FreeRegionMap,\n                                              subject_node_id: ast::NodeId) {\n@@ -932,6 +1073,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         value.fold_with(&mut r)\n     }\n \n+    fn resolve_type_vars_or_error(&self, t: &Ty<'tcx>) -> mc::McResult<Ty<'tcx>> {\n+        let ty = self.resolve_type_vars_if_possible(t);\n+        if ty.has_infer_types() || ty.references_error() { Err(()) } else { Ok(ty) }\n+    }\n+\n     pub fn fully_resolve<T:TypeFoldable<'tcx>>(&self, value: &T) -> fres<T> {\n         /*!\n          * Attempts to resolve all type/region variables in"}, {"sha": "69b9762b7b9825e0bdca4656da20b906de014948", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=480cd8fe678ddd34c7dc626791deaed2b49a0bda", "patch": "@@ -397,7 +397,7 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    let infcx = infer::new_infer_ctxt(tcx, Some(elaborated_env));\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(elaborated_env));\n     let predicates = match fully_normalize(&infcx, &infcx.parameter_environment, cause,\n                                            &infcx.parameter_environment.caller_bounds) {\n         Ok(predicates) => predicates,"}, {"sha": "ae15c8aa8e028379eda46f5a0d62f57fdd6d86e1", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=480cd8fe678ddd34c7dc626791deaed2b49a0bda", "patch": "@@ -54,6 +54,7 @@ use util::nodemap::FnvHashMap;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n+\n     closure_typer: &'cx (ty::ClosureTyper<'tcx>+'cx),\n \n     /// Freshener used specifically for skolemizing entries on the\n@@ -77,6 +78,7 @@ pub struct SelectionContext<'cx, 'tcx:'cx> {\n     /// other words, we consider `$0 : Bar` to be unimplemented if\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n+\n     intercrate: bool,\n }\n "}, {"sha": "7616879d1025788825f56174acc68d12f54b7541", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=480cd8fe678ddd34c7dc626791deaed2b49a0bda", "patch": "@@ -4468,7 +4468,8 @@ impl<'tcx> TyS<'tcx> {\n                        span: Span)\n                        -> bool\n     {\n-        let infcx = infer::new_infer_ctxt(param_env.tcx(), Some(param_env.clone()));\n+        let tcx = param_env.tcx();\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env.clone()));\n \n         let is_impld = traits::type_known_to_meet_builtin_bound(&infcx, param_env,\n                                                                 self, bound, span);"}, {"sha": "c549d8cd22d64b66e9819db59699dfe4f31608d8", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=480cd8fe678ddd34c7dc626791deaed2b49a0bda", "patch": "@@ -997,7 +997,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            trait_ref, trait_ref.def_id());\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx, None);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n@@ -1059,7 +1059,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            predicates);\n \n     let tcx = ccx.tcx();\n-    let infcx = infer::new_infer_ctxt(tcx, None);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n     let typer = NormalizingClosureTyper::new(tcx);\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let mut fulfill_cx = traits::FulfillmentContext::new(false);"}, {"sha": "67ccf64621a854cf0e17037738e2ee0993657462", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=480cd8fe678ddd34c7dc626791deaed2b49a0bda", "patch": "@@ -324,7 +324,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     // FIXME(#20304) -- cache\n     // NOTE: @jroesch\n     // Here is of an example where we do not use a param_env but use a typer instead.\n-    let infcx = infer::new_infer_ctxt(tcx, None);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n     let typer = NormalizingClosureTyper::new(tcx);\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let cause = traits::ObligationCause::dummy();"}, {"sha": "85f4fdc8932012525cdd40163a5df176a36f7327", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=480cd8fe678ddd34c7dc626791deaed2b49a0bda", "patch": "@@ -43,7 +43,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_impl_method: impl_trait_ref (liberated) = {:?}\",\n            impl_trait_ref);\n \n-    let mut infcx = infer::new_infer_ctxt(tcx, None);\n+    let mut infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n     let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n \n     let trait_to_impl_substs = &impl_trait_ref.substs;\n@@ -418,7 +418,7 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n-    let infcx = infer::new_infer_ctxt(tcx, None);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n     let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n \n     // The below is for the most part highly similar to the procedure"}, {"sha": "6f0fbfebf46cc8fd37192d5b5a6833c7a1452b5b", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=480cd8fe678ddd34c7dc626791deaed2b49a0bda", "patch": "@@ -93,8 +93,8 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n                          ty: named_type } =\n         tcx.lookup_item_type(self_type_did);\n \n-    let infcx = infer::new_infer_ctxt(tcx, None);\n-    \n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+\n     infcx.commit_if_ok(|snapshot| {\n         let (named_type_to_skolem, skol_map) =\n             infcx.construct_skolemized_subst(named_type_generics, snapshot);"}, {"sha": "e91be5fa9df51d3a980f2b2ca5906f0fba116d1b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=480cd8fe678ddd34c7dc626791deaed2b49a0bda", "patch": "@@ -382,7 +382,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n            -> Inherited<'a, 'tcx> {\n \n         Inherited {\n-            infcx: infer::new_infer_ctxt(tcx, Some(param_env)),\n+            infcx: infer::new_infer_ctxt(tcx, tables, Some(param_env)),\n             locals: RefCell::new(NodeMap()),\n             tables: tables,\n             fn_sig_map: RefCell::new(NodeMap()),"}, {"sha": "af2c3a32150d83795181f72f7a724754a6f135e2", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=480cd8fe678ddd34c7dc626791deaed2b49a0bda", "patch": "@@ -448,7 +448,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n                    source, target);\n \n-            let infcx = new_infer_ctxt(tcx, Some(param_env));\n+            let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n \n             let check_mutbl = |mt_a: ty::mt<'tcx>, mt_b: ty::mt<'tcx>,\n                                mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n@@ -630,7 +630,7 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n pub fn check_coherence(crate_context: &CrateCtxt) {\n     CoherenceChecker {\n         crate_context: crate_context,\n-        inference_context: new_infer_ctxt(crate_context.tcx, None),\n+        inference_context: new_infer_ctxt(crate_context.tcx, &crate_context.tcx.tables, None),\n         inherent_impls: RefCell::new(FnvHashMap()),\n     }.check(crate_context.tcx.map.krate());\n     unsafety::check(crate_context.tcx);"}, {"sha": "3495714fcc7367d08ecd42a5094a7e39977bdfd3", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=480cd8fe678ddd34c7dc626791deaed2b49a0bda", "patch": "@@ -133,7 +133,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                    impl1_def_id,\n                    impl2_def_id);\n \n-            let infcx = infer::new_infer_ctxt(self.tcx, None);\n+            let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n             if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n                 self.report_overlap_error(trait_def_id, impl1_def_id, impl2_def_id);\n             }"}, {"sha": "ef9dcd56a578bdc1d8f04777a9f482e0965576dd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=480cd8fe678ddd34c7dc626791deaed2b49a0bda", "patch": "@@ -2204,7 +2204,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n                base_type,\n                base_type_free);\n \n-        let infcx = infer::new_infer_ctxt(tcx, None);\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n         drop(::require_same_types(tcx,\n                                   Some(&infcx),\n                                   false,"}, {"sha": "48a64675c708a3c38046e687f5ad490a16db221b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/480cd8fe678ddd34c7dc626791deaed2b49a0bda/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=480cd8fe678ddd34c7dc626791deaed2b49a0bda", "patch": "@@ -188,7 +188,7 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n {\n     let result = match maybe_infcx {\n         None => {\n-            let infcx = infer::new_infer_ctxt(tcx, None);\n+            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n             infer::mk_eqty(&infcx, t1_is_expected, infer::Misc(span), t1, t2)\n         }\n         Some(infcx) => {"}]}