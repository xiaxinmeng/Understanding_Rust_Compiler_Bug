{"sha": "4f6e8f82593874e5a16498c84b69e5c9ee5deb14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNmU4ZjgyNTkzODc0ZTVhMTY0OThjODRiNjllNWM5ZWU1ZGViMTQ=", "commit": {"author": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2016-06-10T12:16:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-10T12:16:44Z"}, "message": "Rollup merge of #34088 - srinivasreddy:rustfmt_map.rs, r=nrc\n\nrun rustfmt on map.rs in libcollections/btree folder", "tree": {"sha": "5d56a8ced31f50ec0b8f70c5f933e32dc56aace2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d56a8ced31f50ec0b8f70c5f933e32dc56aace2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f6e8f82593874e5a16498c84b69e5c9ee5deb14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f6e8f82593874e5a16498c84b69e5c9ee5deb14", "html_url": "https://github.com/rust-lang/rust/commit/4f6e8f82593874e5a16498c84b69e5c9ee5deb14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f6e8f82593874e5a16498c84b69e5c9ee5deb14/comments", "author": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9234c11e00d976e69bcab95342b8af469c82d5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9234c11e00d976e69bcab95342b8af469c82d5b", "html_url": "https://github.com/rust-lang/rust/commit/a9234c11e00d976e69bcab95342b8af469c82d5b"}, {"sha": "d6560ddd20f6cc3da04ae07b06a3fabffafe7562", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6560ddd20f6cc3da04ae07b06a3fabffafe7562", "html_url": "https://github.com/rust-lang/rust/commit/d6560ddd20f6cc3da04ae07b06a3fabffafe7562"}], "stats": {"total": 494, "additions": 274, "deletions": 220}, "files": [{"sha": "248240a7de884268af453efc3a37699b8c970ea8", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 274, "deletions": 220, "changes": 494, "blob_url": "https://github.com/rust-lang/rust/blob/4f6e8f82593874e5a16498c84b69e5c9ee5deb14/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f6e8f82593874e5a16498c84b69e5c9ee5deb14/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=4f6e8f82593874e5a16498c84b69e5c9ee5deb14", "patch": "@@ -17,9 +17,9 @@ use core::ops::Index;\n use core::{fmt, intrinsics, mem, ptr};\n \n use borrow::Borrow;\n-use Bound::{self, Included, Excluded, Unbounded};\n+use Bound::{self, Excluded, Included, Unbounded};\n \n-use super::node::{self, NodeRef, Handle, marker};\n+use super::node::{self, Handle, NodeRef, marker};\n use super::search;\n \n use super::node::InsertResult::*;\n@@ -129,35 +129,38 @@ use self::Entry::*;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BTreeMap<K, V> {\n     root: node::Root<K, V>,\n-    length: usize\n+    length: usize,\n }\n \n impl<K, V> Drop for BTreeMap<K, V> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         unsafe {\n-            for _ in ptr::read(self).into_iter() { }\n+            for _ in ptr::read(self).into_iter() {\n+            }\n         }\n     }\n }\n \n impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n     fn clone(&self) -> BTreeMap<K, V> {\n-        fn clone_subtree<K: Clone, V: Clone>(\n-                node: node::NodeRef<marker::Immut, K, V, marker::LeafOrInternal>)\n-                -> BTreeMap<K, V> {\n+        fn clone_subtree<K: Clone, V: Clone>(node: node::NodeRef<marker::Immut,\n+                                                                 K,\n+                                                                 V,\n+                                                                 marker::LeafOrInternal>)\n+                                             -> BTreeMap<K, V> {\n \n             match node.force() {\n                 Leaf(leaf) => {\n                     let mut out_tree = BTreeMap {\n                         root: node::Root::new_leaf(),\n-                        length: 0\n+                        length: 0,\n                     };\n \n                     {\n                         let mut out_node = match out_tree.root.as_mut().force() {\n                             Leaf(leaf) => leaf,\n-                            Internal(_) => unreachable!()\n+                            Internal(_) => unreachable!(),\n                         };\n \n                         let mut in_edge = leaf.first_edge();\n@@ -171,7 +174,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                     }\n \n                     out_tree\n-                },\n+                }\n                 Internal(internal) => {\n                     let mut out_tree = clone_subtree(internal.first_edge().descend());\n \n@@ -218,20 +221,22 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n     fn get(&self, key: &Q) -> Option<&K> {\n         match search::search_tree(self.root.as_ref(), key) {\n             Found(handle) => Some(handle.into_kv().0),\n-            GoDown(_) => None\n+            GoDown(_) => None,\n         }\n     }\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n         match search::search_tree(self.root.as_mut(), key) {\n             Found(handle) => {\n                 Some(OccupiedEntry {\n-                    handle: handle,\n-                    length: &mut self.length,\n-                    _marker: PhantomData,\n-                }.remove_kv().0)\n-            },\n-            GoDown(_) => None\n+                         handle: handle,\n+                         length: &mut self.length,\n+                         _marker: PhantomData,\n+                     }\n+                     .remove_kv()\n+                     .0)\n+            }\n+            GoDown(_) => None,\n         }\n     }\n \n@@ -244,7 +249,8 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n                     handle: handle,\n                     length: &mut self.length,\n                     _marker: PhantomData,\n-                }.insert(());\n+                }\n+                .insert(());\n                 None\n             }\n         }\n@@ -255,22 +261,22 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     range: Range<'a, K, V>,\n-    length: usize\n+    length: usize,\n }\n \n /// A mutable iterator over a BTreeMap's entries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     range: RangeMut<'a, K, V>,\n-    length: usize\n+    length: usize,\n }\n \n /// An owning iterator over a BTreeMap's entries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n     front: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n     back: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n-    length: usize\n+    length: usize,\n }\n \n /// An iterator over a BTreeMap's keys.\n@@ -294,7 +300,7 @@ pub struct ValuesMut<'a, K: 'a, V: 'a> {\n /// An iterator over a sub-range of BTreeMap's entries.\n pub struct Range<'a, K: 'a, V: 'a> {\n     front: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    back: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>\n+    back: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n }\n \n /// A mutable iterator over a sub-range of BTreeMap's entries.\n@@ -311,15 +317,13 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// A vacant Entry\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Vacant(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>\n-    ),\n+    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+           VacantEntry<'a, K, V>),\n \n     /// An occupied Entry\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Occupied(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>\n-    ),\n+    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+             OccupiedEntry<'a, K, V>),\n }\n \n /// A vacant Entry.\n@@ -336,11 +340,7 @@ pub struct VacantEntry<'a, K: 'a, V: 'a> {\n /// An occupied Entry.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n-    handle: Handle<NodeRef<\n-        marker::Mut<'a>,\n-        K, V,\n-        marker::LeafOrInternal\n-    >, marker::KV>,\n+    handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>,\n \n     length: &'a mut usize,\n \n@@ -349,7 +349,7 @@ pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n }\n \n // An iterator for merging two sorted sequences into one\n-struct MergeIter<K, V, I: Iterator<Item=(K, V)>> {\n+struct MergeIter<K, V, I: Iterator<Item = (K, V)>> {\n     left: Peekable<I>,\n     right: Peekable<I>,\n }\n@@ -373,7 +373,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn new() -> BTreeMap<K, V> {\n         BTreeMap {\n             root: node::Root::new_leaf(),\n-            length: 0\n+            length: 0,\n         }\n     }\n \n@@ -415,10 +415,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where K: Borrow<Q>, Q: Ord {\n+    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V>\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         match search::search_tree(self.root.as_ref(), key) {\n             Found(handle) => Some(handle.into_kv().1),\n-            GoDown(_) => None\n+            GoDown(_) => None,\n         }\n     }\n \n@@ -440,7 +443,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where K: Borrow<Q>, Q: Ord {\n+    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         self.get(key).is_some()\n     }\n \n@@ -465,10 +471,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where K: Borrow<Q>, Q: Ord {\n+    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V>\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         match search::search_tree(self.root.as_mut(), key) {\n             Found(handle) => Some(handle.into_kv_mut().1),\n-            GoDown(_) => None\n+            GoDown(_) => None,\n         }\n     }\n \n@@ -528,16 +537,20 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where K: Borrow<Q>, Q: Ord {\n+    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V>\n+        where K: Borrow<Q>,\n+              Q: Ord\n+    {\n         match search::search_tree(self.root.as_mut(), key) {\n             Found(handle) => {\n                 Some(OccupiedEntry {\n-                    handle: handle,\n-                    length: &mut self.length,\n-                    _marker: PhantomData,\n-                }.remove())\n-            },\n-            GoDown(_) => None\n+                         handle: handle,\n+                         length: &mut self.length,\n+                         _marker: PhantomData,\n+                     }\n+                     .remove())\n+            }\n+            GoDown(_) => None,\n         }\n     }\n \n@@ -628,47 +641,63 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                                                        min: Bound<&Min>,\n                                                        max: Bound<&Max>)\n                                                        -> Range<K, V>\n-        where K: Borrow<Min> + Borrow<Max>,\n+        where K: Borrow<Min> + Borrow<Max>\n     {\n         let front = match min {\n-            Included(key) => match search::search_tree(self.root.as_ref(), key) {\n-                Found(kv_handle) => match kv_handle.left_edge().force() {\n-                    Leaf(bottom) => bottom,\n-                    Internal(internal) => last_leaf_edge(internal.descend())\n-                },\n-                GoDown(bottom) => bottom\n-            },\n-            Excluded(key) => match search::search_tree(self.root.as_ref(), key) {\n-                Found(kv_handle) => match kv_handle.right_edge().force() {\n-                    Leaf(bottom) => bottom,\n-                    Internal(internal) => first_leaf_edge(internal.descend())\n-                },\n-                GoDown(bottom) => bottom\n-            },\n-            Unbounded => first_leaf_edge(self.root.as_ref())\n+            Included(key) => {\n+                match search::search_tree(self.root.as_ref(), key) {\n+                    Found(kv_handle) => {\n+                        match kv_handle.left_edge().force() {\n+                            Leaf(bottom) => bottom,\n+                            Internal(internal) => last_leaf_edge(internal.descend()),\n+                        }\n+                    }\n+                    GoDown(bottom) => bottom,\n+                }\n+            }\n+            Excluded(key) => {\n+                match search::search_tree(self.root.as_ref(), key) {\n+                    Found(kv_handle) => {\n+                        match kv_handle.right_edge().force() {\n+                            Leaf(bottom) => bottom,\n+                            Internal(internal) => first_leaf_edge(internal.descend()),\n+                        }\n+                    }\n+                    GoDown(bottom) => bottom,\n+                }\n+            }\n+            Unbounded => first_leaf_edge(self.root.as_ref()),\n         };\n \n         let back = match max {\n-            Included(key) => match search::search_tree(self.root.as_ref(), key) {\n-                Found(kv_handle) => match kv_handle.right_edge().force() {\n-                    Leaf(bottom) => bottom,\n-                    Internal(internal) => first_leaf_edge(internal.descend())\n-                },\n-                GoDown(bottom) => bottom\n-            },\n-            Excluded(key) => match search::search_tree(self.root.as_ref(), key) {\n-                Found(kv_handle) => match kv_handle.left_edge().force() {\n-                    Leaf(bottom) => bottom,\n-                    Internal(internal) => last_leaf_edge(internal.descend())\n-                },\n-                GoDown(bottom) => bottom\n-            },\n-            Unbounded => last_leaf_edge(self.root.as_ref())\n+            Included(key) => {\n+                match search::search_tree(self.root.as_ref(), key) {\n+                    Found(kv_handle) => {\n+                        match kv_handle.right_edge().force() {\n+                            Leaf(bottom) => bottom,\n+                            Internal(internal) => first_leaf_edge(internal.descend()),\n+                        }\n+                    }\n+                    GoDown(bottom) => bottom,\n+                }\n+            }\n+            Excluded(key) => {\n+                match search::search_tree(self.root.as_ref(), key) {\n+                    Found(kv_handle) => {\n+                        match kv_handle.left_edge().force() {\n+                            Leaf(bottom) => bottom,\n+                            Internal(internal) => last_leaf_edge(internal.descend()),\n+                        }\n+                    }\n+                    GoDown(bottom) => bottom,\n+                }\n+            }\n+            Unbounded => last_leaf_edge(self.root.as_ref()),\n         };\n \n         Range {\n             front: front,\n-            back: back\n+            back: back,\n         }\n     }\n \n@@ -704,51 +733,67 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                                                            min: Bound<&Min>,\n                                                            max: Bound<&Max>)\n                                                            -> RangeMut<K, V>\n-        where K: Borrow<Min> + Borrow<Max>,\n+        where K: Borrow<Min> + Borrow<Max>\n     {\n         let root1 = self.root.as_mut();\n         let root2 = unsafe { ptr::read(&root1) };\n \n         let front = match min {\n-            Included(key) => match search::search_tree(root1, key) {\n-                Found(kv_handle) => match kv_handle.left_edge().force() {\n-                    Leaf(bottom) => bottom,\n-                    Internal(internal) => last_leaf_edge(internal.descend())\n-                },\n-                GoDown(bottom) => bottom\n-            },\n-            Excluded(key) => match search::search_tree(root1, key) {\n-                Found(kv_handle) => match kv_handle.right_edge().force() {\n-                    Leaf(bottom) => bottom,\n-                    Internal(internal) => first_leaf_edge(internal.descend())\n-                },\n-                GoDown(bottom) => bottom\n-            },\n-            Unbounded => first_leaf_edge(root1)\n+            Included(key) => {\n+                match search::search_tree(root1, key) {\n+                    Found(kv_handle) => {\n+                        match kv_handle.left_edge().force() {\n+                            Leaf(bottom) => bottom,\n+                            Internal(internal) => last_leaf_edge(internal.descend()),\n+                        }\n+                    }\n+                    GoDown(bottom) => bottom,\n+                }\n+            }\n+            Excluded(key) => {\n+                match search::search_tree(root1, key) {\n+                    Found(kv_handle) => {\n+                        match kv_handle.right_edge().force() {\n+                            Leaf(bottom) => bottom,\n+                            Internal(internal) => first_leaf_edge(internal.descend()),\n+                        }\n+                    }\n+                    GoDown(bottom) => bottom,\n+                }\n+            }\n+            Unbounded => first_leaf_edge(root1),\n         };\n \n         let back = match max {\n-            Included(key) => match search::search_tree(root2, key) {\n-                Found(kv_handle) => match kv_handle.right_edge().force() {\n-                    Leaf(bottom) => bottom,\n-                    Internal(internal) => first_leaf_edge(internal.descend())\n-                },\n-                GoDown(bottom) => bottom\n-            },\n-            Excluded(key) => match search::search_tree(root2, key) {\n-                Found(kv_handle) => match kv_handle.left_edge().force() {\n-                    Leaf(bottom) => bottom,\n-                    Internal(internal) => last_leaf_edge(internal.descend())\n-                },\n-                GoDown(bottom) => bottom\n-            },\n-            Unbounded => last_leaf_edge(root2)\n+            Included(key) => {\n+                match search::search_tree(root2, key) {\n+                    Found(kv_handle) => {\n+                        match kv_handle.right_edge().force() {\n+                            Leaf(bottom) => bottom,\n+                            Internal(internal) => first_leaf_edge(internal.descend()),\n+                        }\n+                    }\n+                    GoDown(bottom) => bottom,\n+                }\n+            }\n+            Excluded(key) => {\n+                match search::search_tree(root2, key) {\n+                    Found(kv_handle) => {\n+                        match kv_handle.left_edge().force() {\n+                            Leaf(bottom) => bottom,\n+                            Internal(internal) => last_leaf_edge(internal.descend()),\n+                        }\n+                    }\n+                    GoDown(bottom) => bottom,\n+                }\n+            }\n+            Unbounded => last_leaf_edge(root2),\n         };\n \n         RangeMut {\n             front: front,\n             back: back,\n-            _marker: PhantomData\n+            _marker: PhantomData,\n         }\n     }\n \n@@ -773,21 +818,25 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn entry(&mut self, key: K) -> Entry<K, V> {\n         match search::search_tree(self.root.as_mut(), &key) {\n-            Found(handle) => Occupied(OccupiedEntry {\n-                handle: handle,\n-                length: &mut self.length,\n-                _marker: PhantomData,\n-            }),\n-            GoDown(handle) => Vacant(VacantEntry {\n-                key: key,\n-                handle: handle,\n-                length: &mut self.length,\n-                _marker: PhantomData,\n-            })\n+            Found(handle) => {\n+                Occupied(OccupiedEntry {\n+                    handle: handle,\n+                    length: &mut self.length,\n+                    _marker: PhantomData,\n+                })\n+            }\n+            GoDown(handle) => {\n+                Vacant(VacantEntry {\n+                    key: key,\n+                    handle: handle,\n+                    length: &mut self.length,\n+                    _marker: PhantomData,\n+                })\n+            }\n         }\n     }\n \n-    fn from_sorted_iter<I: Iterator<Item=(K, V)>>(&mut self, iter: I) {\n+    fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n         let mut cur_node = last_leaf_edge(self.root.as_mut()).into_node();\n         // Iterate through all key-value pairs, pushing them into nodes at the right level.\n         for (key, value) in iter {\n@@ -810,12 +859,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                                 // Go up again.\n                                 test_node = parent.forget_type();\n                             }\n-                        },\n+                        }\n                         Err(node) => {\n                             // We are at the top, create a new root node and push there.\n                             open_node = node.into_root_mut().push_level();\n                             break;\n-                        },\n+                        }\n                     }\n                 }\n \n@@ -890,7 +939,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[unstable(feature = \"btree_split_off\",\n                reason = \"recently added as part of collections reform 2\",\n                issue = \"19986\")]\n-    pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self where K: Borrow<Q> {\n+    pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n+        where K: Borrow<Q>\n+    {\n         if self.is_empty() {\n             return Self::new();\n         }\n@@ -910,7 +961,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 let mut split_edge = match search::search_node(left_node, key) {\n                     // key is going to the right tree\n                     Found(handle) => handle.left_edge(),\n-                    GoDown(handle) => handle\n+                    GoDown(handle) => handle,\n                 };\n \n                 split_edge.move_suffix(&mut right_node);\n@@ -920,8 +971,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                         left_node = edge.descend();\n                         right_node = node.first_edge().descend();\n                     }\n-                    (Leaf(_), Leaf(_)) => { break; },\n-                    _ => { unreachable!(); }\n+                    (Leaf(_), Leaf(_)) => {\n+                        break;\n+                    }\n+                    _ => {\n+                        unreachable!();\n+                    }\n                 }\n             }\n         }\n@@ -950,8 +1005,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 loop {\n                     res += dfs(edge.reborrow().descend());\n                     match edge.right_kv() {\n-                        Ok(right_kv) => { edge = right_kv.right_edge(); },\n-                        Err(_) => { break; }\n+                        Ok(right_kv) => {\n+                            edge = right_kv.right_edge();\n+                        }\n+                        Err(_) => {\n+                            break;\n+                        }\n                     }\n                 }\n             }\n@@ -1064,14 +1123,16 @@ impl<'a, K: 'a, V: 'a> DoubleEndedIterator for Iter<'a, K, V> {\n }\n \n impl<'a, K: 'a, V: 'a> ExactSizeIterator for Iter<'a, K, V> {\n-    fn len(&self) -> usize { self.length }\n+    fn len(&self) -> usize {\n+        self.length\n+    }\n }\n \n impl<'a, K, V> Clone for Iter<'a, K, V> {\n     fn clone(&self) -> Iter<'a, K, V> {\n         Iter {\n             range: self.range.clone(),\n-            length: self.length\n+            length: self.length,\n         }\n     }\n }\n@@ -1114,7 +1175,9 @@ impl<'a, K: 'a, V: 'a> DoubleEndedIterator for IterMut<'a, K, V> {\n }\n \n impl<'a, K: 'a, V: 'a> ExactSizeIterator for IterMut<'a, K, V> {\n-    fn len(&self) -> usize { self.length }\n+    fn len(&self) -> usize {\n+        self.length\n+    }\n }\n \n impl<K, V> IntoIterator for BTreeMap<K, V> {\n@@ -1130,14 +1193,15 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n         IntoIter {\n             front: first_leaf_edge(root1),\n             back: last_leaf_edge(root2),\n-            length: len\n+            length: len,\n         }\n     }\n }\n \n impl<K, V> Drop for IntoIter<K, V> {\n     fn drop(&mut self) {\n-        for _ in &mut *self { }\n+        for _ in &mut *self {\n+        }\n         unsafe {\n             let leaf_node = ptr::read(&self.front).into_node();\n             if let Some(first_parent) = leaf_node.deallocate_and_ascend() {\n@@ -1168,10 +1232,10 @@ impl<K, V> Iterator for IntoIter<K, V> {\n                 let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n                 self.front = kv.right_edge();\n                 return Some((k, v));\n-            },\n+            }\n             Err(last_edge) => unsafe {\n                 unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n-            }\n+            },\n         };\n \n         loop {\n@@ -1181,10 +1245,10 @@ impl<K, V> Iterator for IntoIter<K, V> {\n                     let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n                     self.front = first_leaf_edge(kv.right_edge().descend());\n                     return Some((k, v));\n-                },\n+                }\n                 Err(last_edge) => unsafe {\n                     cur_handle = unwrap_unchecked(last_edge.into_node().deallocate_and_ascend());\n-                }\n+                },\n             }\n         }\n     }\n@@ -1210,10 +1274,10 @@ impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n                 let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n                 self.back = kv.left_edge();\n                 return Some((k, v));\n-            },\n+            }\n             Err(last_edge) => unsafe {\n                 unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n-            }\n+            },\n         };\n \n         loop {\n@@ -1223,17 +1287,19 @@ impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n                     let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n                     self.back = last_leaf_edge(kv.left_edge().descend());\n                     return Some((k, v));\n-                },\n+                }\n                 Err(last_edge) => unsafe {\n                     cur_handle = unwrap_unchecked(last_edge.into_node().deallocate_and_ascend());\n-                }\n+                },\n             }\n         }\n     }\n }\n \n impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n-    fn len(&self) -> usize { self.length }\n+    fn len(&self) -> usize {\n+        self.length\n+    }\n }\n \n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n@@ -1262,9 +1328,7 @@ impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n \n impl<'a, K, V> Clone for Keys<'a, K, V> {\n     fn clone(&self) -> Keys<'a, K, V> {\n-        Keys {\n-            inner: self.inner.clone()\n-        }\n+        Keys { inner: self.inner.clone() }\n     }\n }\n \n@@ -1294,9 +1358,7 @@ impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n \n impl<'a, K, V> Clone for Values<'a, K, V> {\n     fn clone(&self) -> Values<'a, K, V> {\n-        Values {\n-            inner: self.inner.clone()\n-        }\n+        Values { inner: self.inner.clone() }\n     }\n }\n \n@@ -1348,7 +1410,7 @@ impl<'a, K, V> Range<'a, K, V> {\n                 let ret = kv.into_kv();\n                 self.front = kv.right_edge();\n                 return ret;\n-            },\n+            }\n             Err(last_edge) => {\n                 let next_level = last_edge.into_node().ascend().ok();\n                 unwrap_unchecked(next_level)\n@@ -1361,7 +1423,7 @@ impl<'a, K, V> Range<'a, K, V> {\n                     let ret = kv.into_kv();\n                     self.front = first_leaf_edge(kv.right_edge().descend());\n                     return ret;\n-                },\n+                }\n                 Err(last_edge) => {\n                     let next_level = last_edge.into_node().ascend().ok();\n                     cur_handle = unwrap_unchecked(next_level);\n@@ -1390,7 +1452,7 @@ impl<'a, K, V> Range<'a, K, V> {\n                 let ret = kv.into_kv();\n                 self.back = kv.left_edge();\n                 return ret;\n-            },\n+            }\n             Err(last_edge) => {\n                 let next_level = last_edge.into_node().ascend().ok();\n                 unwrap_unchecked(next_level)\n@@ -1403,7 +1465,7 @@ impl<'a, K, V> Range<'a, K, V> {\n                     let ret = kv.into_kv();\n                     self.back = last_leaf_edge(kv.left_edge().descend());\n                     return ret;\n-                },\n+                }\n                 Err(last_edge) => {\n                     let next_level = last_edge.into_node().ascend().ok();\n                     cur_handle = unwrap_unchecked(next_level);\n@@ -1417,7 +1479,7 @@ impl<'a, K, V> Clone for Range<'a, K, V> {\n     fn clone(&self) -> Range<'a, K, V> {\n         Range {\n             front: self.front,\n-            back: self.back\n+            back: self.back,\n         }\n     }\n }\n@@ -1429,7 +1491,7 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n         if self.front == self.back {\n             None\n         } else {\n-            unsafe { Some (self.next_unchecked()) }\n+            unsafe { Some(self.next_unchecked()) }\n         }\n     }\n }\n@@ -1443,7 +1505,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n                 let (k, v) = ptr::read(&kv).into_kv_mut();\n                 self.front = kv.right_edge();\n                 return (k, v);\n-            },\n+            }\n             Err(last_edge) => {\n                 let next_level = last_edge.into_node().ascend().ok();\n                 unwrap_unchecked(next_level)\n@@ -1456,7 +1518,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n                     let (k, v) = ptr::read(&kv).into_kv_mut();\n                     self.front = first_leaf_edge(kv.right_edge().descend());\n                     return (k, v);\n-                },\n+                }\n                 Err(last_edge) => {\n                     let next_level = last_edge.into_node().ascend().ok();\n                     cur_handle = unwrap_unchecked(next_level);\n@@ -1485,7 +1547,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n                 let (k, v) = ptr::read(&kv).into_kv_mut();\n                 self.back = kv.left_edge();\n                 return (k, v);\n-            },\n+            }\n             Err(last_edge) => {\n                 let next_level = last_edge.into_node().ascend().ok();\n                 unwrap_unchecked(next_level)\n@@ -1498,7 +1560,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n                     let (k, v) = ptr::read(&kv).into_kv_mut();\n                     self.back = last_leaf_edge(kv.left_edge().descend());\n                     return (k, v);\n-                },\n+                }\n                 Err(last_edge) => {\n                     let next_level = last_edge.into_node().ascend().ok();\n                     cur_handle = unwrap_unchecked(next_level);\n@@ -1509,7 +1571,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n }\n \n impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n-    fn from_iter<T: IntoIterator<Item=(K, V)>>(iter: T) -> BTreeMap<K, V> {\n+    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> BTreeMap<K, V> {\n         let mut map = BTreeMap::new();\n         map.extend(iter);\n         map\n@@ -1518,15 +1580,15 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n \n impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     #[inline]\n-    fn extend<T: IntoIterator<Item=(K, V)>>(&mut self, iter: T) {\n+    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n     }\n }\n \n impl<'a, K: Ord + Copy, V: Copy> Extend<(&'a K, &'a V)> for BTreeMap<K, V> {\n-    fn extend<I: IntoIterator<Item=(&'a K, &'a V)>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n     }\n }\n@@ -1547,8 +1609,7 @@ impl<K: Ord, V> Default for BTreeMap<K, V> {\n \n impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n     fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n-        self.len() == other.len() &&\n-            self.iter().zip(other).all(|(a, b)| a == b)\n+        self.len() == other.len() && self.iter().zip(other).all(|(a, b)| a == b)\n     }\n }\n \n@@ -1575,7 +1636,8 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n }\n \n impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n-    where K: Borrow<Q>, Q: Ord\n+    where K: Borrow<Q>,\n+          Q: Ord\n {\n     type Output = V;\n \n@@ -1585,11 +1647,9 @@ impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n     }\n }\n \n-fn first_leaf_edge<BorrowType, K, V>(\n-        mut node: NodeRef<BorrowType,\n-                          K, V,\n-                          marker::LeafOrInternal>\n-        ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+fn first_leaf_edge<BorrowType, K, V>\n+    (mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>)\n+     -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n     loop {\n         match node.force() {\n             Leaf(leaf) => return leaf.first_edge(),\n@@ -1600,11 +1660,9 @@ fn first_leaf_edge<BorrowType, K, V>(\n     }\n }\n \n-fn last_leaf_edge<BorrowType, K, V>(\n-        mut node: NodeRef<BorrowType,\n-                          K, V,\n-                          marker::LeafOrInternal>\n-        ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+fn last_leaf_edge<BorrowType, K, V>\n+    (mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>)\n+     -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n     loop {\n         match node.force() {\n             Leaf(leaf) => return leaf.last_edge(),\n@@ -1653,9 +1711,9 @@ impl<K, V> BTreeMap<K, V> {\n         Iter {\n             range: Range {\n                 front: first_leaf_edge(self.root.as_ref()),\n-                back: last_leaf_edge(self.root.as_ref())\n+                back: last_leaf_edge(self.root.as_ref()),\n             },\n-            length: self.length\n+            length: self.length,\n         }\n     }\n \n@@ -1690,7 +1748,7 @@ impl<K, V> BTreeMap<K, V> {\n                 back: last_leaf_edge(root2),\n                 _marker: PhantomData,\n             },\n-            length: self.length\n+            length: self.length,\n         }\n     }\n \n@@ -1865,15 +1923,17 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n \n         loop {\n             match cur_parent {\n-                Ok(parent) => match parent.insert(ins_k, ins_v, ins_edge) {\n-                    Fit(_) => return unsafe { &mut *out_ptr },\n-                    Split(left, k, v, right) => {\n-                        ins_k = k;\n-                        ins_v = v;\n-                        ins_edge = right;\n-                        cur_parent = left.ascend().map_err(|n| n.into_root_mut());\n+                Ok(parent) => {\n+                    match parent.insert(ins_k, ins_v, ins_edge) {\n+                        Fit(_) => return unsafe { &mut *out_ptr },\n+                        Split(left, k, v, right) => {\n+                            ins_k = k;\n+                            ins_v = v;\n+                            ins_edge = right;\n+                            cur_parent = left.ascend().map_err(|n| n.into_root_mut());\n+                        }\n                     }\n-                },\n+                }\n                 Err(root) => {\n                     root.push_level().push(ins_k, ins_v, ins_edge);\n                     return unsafe { &mut *out_ptr };\n@@ -1928,7 +1988,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n             Leaf(leaf) => {\n                 let (hole, old_key, old_val) = leaf.remove();\n                 (hole.into_node(), old_key, old_val)\n-            },\n+            }\n             Internal(mut internal) => {\n                 let key_loc = internal.kv_mut().0 as *mut K;\n                 let val_loc = internal.kv_mut().1 as *mut V;\n@@ -1938,12 +1998,8 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n                 let (hole, key, val) = to_remove.remove();\n \n-                let old_key = unsafe {\n-                    mem::replace(&mut *key_loc, key)\n-                };\n-                let old_val = unsafe {\n-                    mem::replace(&mut *val_loc, val)\n-                };\n+                let old_key = unsafe { mem::replace(&mut *key_loc, key) };\n+                let old_val = unsafe { mem::replace(&mut *val_loc, val) };\n \n                 (hole.into_node(), old_key, old_val)\n             }\n@@ -1955,14 +2011,16 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n             match handle_underfull_node(cur_node) {\n                 AtRoot => break,\n                 EmptyParent(_) => unreachable!(),\n-                Merged(parent) => if parent.len() == 0 {\n-                    // We must be at the root\n-                    parent.into_root_mut().pop_level();\n-                    break;\n-                } else {\n-                    cur_node = parent.forget_type();\n-                },\n-                Stole(_) => break\n+                Merged(parent) => {\n+                    if parent.len() == 0 {\n+                        // We must be at the root\n+                        parent.into_root_mut().pop_level();\n+                        break;\n+                    } else {\n+                        cur_node = parent.forget_type();\n+                    }\n+                }\n+                Stole(_) => break,\n             }\n         }\n \n@@ -1974,13 +2032,11 @@ enum UnderflowResult<'a, K, V> {\n     AtRoot,\n     EmptyParent(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n     Merged(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n-    Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>)\n+    Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n }\n \n-fn handle_underfull_node<'a, K, V>(node: NodeRef<marker::Mut<'a>,\n-                                                 K, V,\n-                                                 marker::LeafOrInternal>)\n-                                                 -> UnderflowResult<'a, K, V> {\n+fn handle_underfull_node<'a, K, V>(node: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>)\n+                                   -> UnderflowResult<'a, K, V> {\n     let parent = if let Ok(parent) = node.ascend() {\n         parent\n     } else {\n@@ -1989,10 +2045,12 @@ fn handle_underfull_node<'a, K, V>(node: NodeRef<marker::Mut<'a>,\n \n     let (is_left, mut handle) = match parent.left_kv() {\n         Ok(left) => (true, left),\n-        Err(parent) => match parent.right_kv() {\n-            Ok(right) => (false, right),\n-            Err(parent) => {\n-                return EmptyParent(parent.into_node());\n+        Err(parent) => {\n+            match parent.right_kv() {\n+                Ok(right) => (false, right),\n+                Err(parent) => {\n+                    return EmptyParent(parent.into_node());\n+                }\n             }\n         }\n     };\n@@ -2009,7 +2067,7 @@ fn handle_underfull_node<'a, K, V>(node: NodeRef<marker::Mut<'a>,\n     }\n }\n \n-impl<K: Ord, V, I: Iterator<Item=(K, V)>> Iterator for MergeIter<K, V, I> {\n+impl<K: Ord, V, I: Iterator<Item = (K, V)>> Iterator for MergeIter<K, V, I> {\n     type Item = (K, V);\n \n     fn next(&mut self) -> Option<(K, V)> {\n@@ -2023,16 +2081,12 @@ impl<K: Ord, V, I: Iterator<Item=(K, V)>> Iterator for MergeIter<K, V, I> {\n         // Check which elements comes first and only advance the corresponding iterator.\n         // If two keys are equal, take the value from `right`.\n         match res {\n-            Ordering::Less => {\n-                self.left.next()\n-            },\n-            Ordering::Greater => {\n-                self.right.next()\n-            },\n+            Ordering::Less => self.left.next(),\n+            Ordering::Greater => self.right.next(),\n             Ordering::Equal => {\n                 self.left.next();\n                 self.right.next()\n-            },\n+            }\n         }\n     }\n }"}]}