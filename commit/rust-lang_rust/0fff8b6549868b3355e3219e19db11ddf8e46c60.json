{"sha": "0fff8b6549868b3355e3219e19db11ddf8e46c60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmZmY4YjY1NDk4NjhiMzM1NWUzMjE5ZTE5ZGIxMWRkZjhlNDZjNjA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-08-18T02:55:22Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-08-24T22:46:03Z"}, "message": "std::rt: Reduce MessageQueue contention\n\nIt's not a huge win but it does reduce the amount of time spent\ncontesting the message queue when the schedulers are under load", "tree": {"sha": "e1fcae112bb4c03f681aee766f5683a642b86c6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1fcae112bb4c03f681aee766f5683a642b86c6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fff8b6549868b3355e3219e19db11ddf8e46c60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fff8b6549868b3355e3219e19db11ddf8e46c60", "html_url": "https://github.com/rust-lang/rust/commit/0fff8b6549868b3355e3219e19db11ddf8e46c60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fff8b6549868b3355e3219e19db11ddf8e46c60/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d04234868428fe819fb17d78b8f7468161586b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d04234868428fe819fb17d78b8f7468161586b9", "html_url": "https://github.com/rust-lang/rust/commit/5d04234868428fe819fb17d78b8f7468161586b9"}], "stats": {"total": 81, "additions": 69, "deletions": 12}, "files": [{"sha": "2bbcaff6d28d606ceb768d42aa72e5d837f0d6e4", "filename": "src/libstd/rt/message_queue.rs", "status": "modified", "additions": 42, "deletions": 8, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0fff8b6549868b3355e3219e19db11ddf8e46c60/src%2Flibstd%2Frt%2Fmessage_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fff8b6549868b3355e3219e19db11ddf8e46c60/src%2Flibstd%2Frt%2Fmessage_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmessage_queue.rs?ref=0fff8b6549868b3355e3219e19db11ddf8e46c60", "patch": "@@ -16,32 +16,66 @@ use kinds::Send;\n use vec::OwnedVector;\n use cell::Cell;\n use option::*;\n-use unstable::sync::Exclusive;\n+use unstable::sync::{UnsafeAtomicRcBox, LittleLock};\n use clone::Clone;\n \n pub struct MessageQueue<T> {\n-    priv queue: Exclusive<~[T]>\n+    priv state: UnsafeAtomicRcBox<State<T>>\n+}\n+\n+struct State<T> {\n+    count: uint,\n+    queue: ~[T],\n+    lock: LittleLock\n }\n \n impl<T: Send> MessageQueue<T> {\n     pub fn new() -> MessageQueue<T> {\n         MessageQueue {\n-            queue: Exclusive::new(~[])\n+            state: UnsafeAtomicRcBox::new(State {\n+                count: 0,\n+                queue: ~[],\n+                lock: LittleLock::new()\n+            })\n         }\n     }\n \n     pub fn push(&mut self, value: T) {\n         unsafe {\n             let value = Cell::new(value);\n-            self.queue.with(|q| q.push(value.take()) );\n+            let state = self.state.get();\n+            do (*state).lock.lock {\n+                (*state).count += 1;\n+                (*state).queue.push(value.take());\n+            }\n         }\n     }\n \n     pub fn pop(&mut self) -> Option<T> {\n         unsafe {\n-            do self.queue.with |q| {\n-                if !q.is_empty() {\n-                    Some(q.shift())\n+            let state = self.state.get();\n+            do (*state).lock.lock {\n+                if !(*state).queue.is_empty() {\n+                    (*state).count += 1;\n+                    Some((*state).queue.shift())\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    }\n+\n+    /// A pop that may sometimes miss enqueued elements, but is much faster\n+    /// to give up without doing any synchronization\n+    pub fn casual_pop(&mut self) -> Option<T> {\n+        unsafe {\n+            let state = self.state.get();\n+            // NB: Unsynchronized check\n+            if (*state).count == 0 { return None; }\n+            do (*state).lock.lock {\n+                if !(*state).queue.is_empty() {\n+                    (*state).count += 1;\n+                    Some((*state).queue.shift())\n                 } else {\n                     None\n                 }\n@@ -53,7 +87,7 @@ impl<T: Send> MessageQueue<T> {\n impl<T: Send> Clone for MessageQueue<T> {\n     fn clone(&self) -> MessageQueue<T> {\n         MessageQueue {\n-            queue: self.queue.clone()\n+            state: self.state.clone()\n         }\n     }\n }"}, {"sha": "158a5e3cfe3f52b7bacd6632957c3c3bd3e084d7", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0fff8b6549868b3355e3219e19db11ddf8e46c60/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fff8b6549868b3355e3219e19db11ddf8e46c60/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=0fff8b6549868b3355e3219e19db11ddf8e46c60", "patch": "@@ -83,6 +83,14 @@ pub struct Scheduler {\n     idle_callback: Option<~PausibleIdleCallback>\n }\n \n+/// An indication of how hard to work on a given operation, the difference\n+/// mainly being whether memory is synchronized or not\n+#[deriving(Eq)]\n+enum EffortLevel {\n+    DontTryTooHard,\n+    GiveItYourBest\n+}\n+\n impl Scheduler {\n \n     // * Initialization Functions\n@@ -237,14 +245,21 @@ impl Scheduler {\n \n         // First we check for scheduler messages, these are higher\n         // priority than regular tasks.\n-        let sched = match sched.interpret_message_queue() {\n+        let sched = match sched.interpret_message_queue(DontTryTooHard) {\n             Some(sched) => sched,\n             None => return\n         };\n \n         // This helper will use a randomized work-stealing algorithm\n         // to find work.\n-        let mut sched = match sched.do_work() {\n+        let sched = match sched.do_work() {\n+            Some(sched) => sched,\n+            None => return\n+        };\n+\n+        // Now, before sleeping we need to find out if there really\n+        // were any messages. Give it your best!\n+        let mut sched = match sched.interpret_message_queue(GiveItYourBest) {\n             Some(sched) => sched,\n             None => return\n         };\n@@ -277,10 +292,18 @@ impl Scheduler {\n     // returns the still-available scheduler. At this point all\n     // message-handling will count as a turn of work, and as a result\n     // return None.\n-    fn interpret_message_queue(~self) -> Option<~Scheduler> {\n+    fn interpret_message_queue(~self, effort: EffortLevel) -> Option<~Scheduler> {\n \n         let mut this = self;\n-        match this.message_queue.pop() {\n+\n+        let msg = if effort == DontTryTooHard {\n+            // Do a cheap check that may miss messages\n+            this.message_queue.casual_pop()\n+        } else {\n+            this.message_queue.pop()\n+        };\n+\n+        match msg {\n             Some(PinnedTask(task)) => {\n                 let mut task = task;\n                 task.give_home(Sched(this.make_handle()));"}]}