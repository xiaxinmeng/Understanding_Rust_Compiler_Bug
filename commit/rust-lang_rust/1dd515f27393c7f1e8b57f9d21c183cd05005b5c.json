{"sha": "1dd515f27393c7f1e8b57f9d21c183cd05005b5c", "node_id": "C_kwDOAAsO6NoAKDFkZDUxNWYyNzM5M2M3ZjFlOGI1N2Y5ZDIxYzE4M2NkMDUwMDViNWM", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2022-11-22T06:26:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-22T06:26:05Z"}, "message": "Rollup merge of #83608 - Kimundi:index_many, r=Mark-Simulacrum\n\nAdd slice methods for indexing via an array of indices.\n\nDisclaimer: It's been a while since I contributed to the main Rust repo, apologies in advance if this is large enough already that it should've been an RFC.\n\n---\n\n# Update:\n\n- Based on feedback, removed the `&[T]` variant of this API, and removed the requirements for the indices to be sorted.\n\n# Description\n\nThis adds the following slice methods to `core`:\n\n```rust\nimpl<T> [T] {\n    pub unsafe fn get_many_unchecked_mut<const N: usize>(&mut self, indices: [usize; N]) -> [&mut T; N];\n    pub fn get_many_mut<const N: usize>(&mut self, indices: [usize; N]) -> Option<[&mut T; N]>;\n}\n```\n\nThis allows creating multiple mutable references to disjunct positions in a slice, which previously required writing some awkward code with `split_at_mut()` or `iter_mut()`. For the bound-checked variant, the indices are checked against each other and against the bounds of the slice, which requires `N * (N + 1) / 2` comparison operations.\n\nThis has a proof-of-concept standalone implementation here: https://crates.io/crates/index_many\n\nCare has been taken that the implementation passes miri borrow checks, and generates straight-forward assembly (though this was only checked on x86_64).\n\n# Example\n\n```rust\nlet v = &mut [1, 2, 3, 4];\nlet [a, b] = v.get_many_mut([0, 2]).unwrap();\nstd::mem::swap(a, b);\n*v += 100;\nassert_eq!(v, &[3, 2, 101, 4]);\n```\n\n# Codegen Examples\n\n<details>\n  <summary>Click to expand!</summary>\n\nDisclaimer: Taken from local tests with the standalone implementation.\n\n## Unchecked Indexing:\n\n```rust\npub unsafe fn example_unchecked(slice: &mut [usize], indices: [usize; 3]) -> [&mut usize; 3] {\n    slice.get_many_unchecked_mut(indices)\n}\n```\n\n```nasm\nexample_unchecked:\n mov     rcx, qword, ptr, [r9]\n mov     r8, qword, ptr, [r9, +, 8]\n mov     r9, qword, ptr, [r9, +, 16]\n lea     rcx, [rdx, +, 8*rcx]\n lea     r8, [rdx, +, 8*r8]\n lea     rdx, [rdx, +, 8*r9]\n mov     qword, ptr, [rax], rcx\n mov     qword, ptr, [rax, +, 8], r8\n mov     qword, ptr, [rax, +, 16], rdx\n ret\n```\n\n## Checked Indexing (Option):\n\n```rust\npub unsafe fn example_option(slice: &mut [usize], indices: [usize; 3]) -> Option<[&mut usize; 3]> {\n    slice.get_many_mut(indices)\n}\n```\n\n```nasm\n mov     r10, qword, ptr, [r9, +, 8]\n mov     rcx, qword, ptr, [r9, +, 16]\n cmp     rcx, r10\n je      .LBB0_7\n mov     r9, qword, ptr, [r9]\n cmp     rcx, r9\n je      .LBB0_7\n cmp     rcx, r8\n jae     .LBB0_7\n cmp     r10, r9\n je      .LBB0_7\n cmp     r9, r8\n jae     .LBB0_7\n cmp     r10, r8\n jae     .LBB0_7\n lea     r8, [rdx, +, 8*r9]\n lea     r9, [rdx, +, 8*r10]\n lea     rcx, [rdx, +, 8*rcx]\n mov     qword, ptr, [rax], r8\n mov     qword, ptr, [rax, +, 8], r9\n mov     qword, ptr, [rax, +, 16], rcx\n ret\n.LBB0_7:\n mov     qword, ptr, [rax], 0\n ret\n```\n\n## Checked Indexing (Panic):\n\n```rust\npub fn example_panic(slice: &mut [usize], indices: [usize; 3]) -> [&mut usize; 3] {\n    let len = slice.len();\n    match slice.get_many_mut(indices) {\n        Some(s) => s,\n        None => {\n            let tmp = indices;\n            index_many::sorted_bound_check_failed(&tmp, len)\n        }\n    }\n}\n```\n\n```nasm\nexample_panic:\n sub     rsp, 56\n mov     rax, qword, ptr, [r9]\n mov     r10, qword, ptr, [r9, +, 8]\n mov     r9, qword, ptr, [r9, +, 16]\n cmp     r9, r10\n je      .LBB0_6\n cmp     r9, rax\n je      .LBB0_6\n cmp     r9, r8\n jae     .LBB0_6\n cmp     r10, rax\n je      .LBB0_6\n cmp     rax, r8\n jae     .LBB0_6\n cmp     r10, r8\n jae     .LBB0_6\n lea     rax, [rdx, +, 8*rax]\n lea     r8, [rdx, +, 8*r10]\n lea     rdx, [rdx, +, 8*r9]\n mov     qword, ptr, [rcx], rax\n mov     qword, ptr, [rcx, +, 8], r8\n mov     qword, ptr, [rcx, +, 16], rdx\n mov     rax, rcx\n add     rsp, 56\n ret\n.LBB0_6:\n mov     qword, ptr, [rsp, +, 32], rax\n mov     qword, ptr, [rsp, +, 40], r10\n mov     qword, ptr, [rsp, +, 48], r9\n lea     rcx, [rsp, +, 32]\n mov     edx, 3\n call    index_many::bound_check_failed\n ud2\n```\n</details>\n\n# Extensions\n\nThere are multiple optional extensions to this.\n\n## Indexing With Ranges\n\nThis could easily be expanded to allow indexing with `[I; N]` where `I: SliceIndex<Self>`.  I wanted to keep the initial implementation simple, so I didn't include it yet.\n\n## Panicking Variant\n\nWe could also add this method:\n\n```rust\nimpl<T> [T] {\n    fn index_many_mut<const N: usize>(&mut self, indices: [usize; N]) -> [&mut T; N];\n}\n```\n\nThis would work similar to the regular index operator and panic with out-of-bound indices. The advantage would be that we could more easily ensure good codegen with a useful panic message, which is non-trivial with the `Option` variant.\n\nThis is implemented in the standalone implementation, and used as basis for the codegen examples here and there.", "tree": {"sha": "6596908f444b487d8583d83b77194654741cbba1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6596908f444b487d8583d83b77194654741cbba1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dd515f27393c7f1e8b57f9d21c183cd05005b5c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjfGt9CRBK7hj4Ov3rIwAAqYYIACJxPKVe6glgTM4Se73aOri7\nIoVkDwjE0PQ2rhpSi11UxuuHqIG2n3dWZ/XtcsTjj5qi/5ofQ62siNNDSEJft108\nUfgARU1vbuerWH7L0t2qTTny3zIxt2ouh+vaiSjxNSDNeNp0Vl5NIlgZ0bGo77m1\n6t1MtOKiCeVyEA/EoXEzCnUuzvGQHSCspfwMsbQdFoe6GWeWSuTPzZVGPejrUM/y\nYF2tKPO+D7AWoLahH8O7Ni/BMNWL1VEEf6tqp5gF6bdEI9/10PxC5qwNItDcRSfH\n4HPmTFzWPKAFGd1JNDN32jP+FSZOd1iEmloiA9ufU1lKvMh9tfy8nRVFW/ULAs8=\n=vuIc\n-----END PGP SIGNATURE-----\n", "payload": "tree 6596908f444b487d8583d83b77194654741cbba1\nparent 0f7d81754db66d46ee9aa033735a1ee5c1daa44d\nparent 3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d\nauthor Manish Goregaokar <manishsmail@gmail.com> 1669098365 -0500\ncommitter GitHub <noreply@github.com> 1669098365 -0500\n\nRollup merge of #83608 - Kimundi:index_many, r=Mark-Simulacrum\n\nAdd slice methods for indexing via an array of indices.\n\nDisclaimer: It's been a while since I contributed to the main Rust repo, apologies in advance if this is large enough already that it should've been an RFC.\n\n---\n\n# Update:\n\n- Based on feedback, removed the `&[T]` variant of this API, and removed the requirements for the indices to be sorted.\n\n# Description\n\nThis adds the following slice methods to `core`:\n\n```rust\nimpl<T> [T] {\n    pub unsafe fn get_many_unchecked_mut<const N: usize>(&mut self, indices: [usize; N]) -> [&mut T; N];\n    pub fn get_many_mut<const N: usize>(&mut self, indices: [usize; N]) -> Option<[&mut T; N]>;\n}\n```\n\nThis allows creating multiple mutable references to disjunct positions in a slice, which previously required writing some awkward code with `split_at_mut()` or `iter_mut()`. For the bound-checked variant, the indices are checked against each other and against the bounds of the slice, which requires `N * (N + 1) / 2` comparison operations.\n\nThis has a proof-of-concept standalone implementation here: https://crates.io/crates/index_many\n\nCare has been taken that the implementation passes miri borrow checks, and generates straight-forward assembly (though this was only checked on x86_64).\n\n# Example\n\n```rust\nlet v = &mut [1, 2, 3, 4];\nlet [a, b] = v.get_many_mut([0, 2]).unwrap();\nstd::mem::swap(a, b);\n*v += 100;\nassert_eq!(v, &[3, 2, 101, 4]);\n```\n\n# Codegen Examples\n\n<details>\n  <summary>Click to expand!</summary>\n\nDisclaimer: Taken from local tests with the standalone implementation.\n\n## Unchecked Indexing:\n\n```rust\npub unsafe fn example_unchecked(slice: &mut [usize], indices: [usize; 3]) -> [&mut usize; 3] {\n    slice.get_many_unchecked_mut(indices)\n}\n```\n\n```nasm\nexample_unchecked:\n mov     rcx, qword, ptr, [r9]\n mov     r8, qword, ptr, [r9, +, 8]\n mov     r9, qword, ptr, [r9, +, 16]\n lea     rcx, [rdx, +, 8*rcx]\n lea     r8, [rdx, +, 8*r8]\n lea     rdx, [rdx, +, 8*r9]\n mov     qword, ptr, [rax], rcx\n mov     qword, ptr, [rax, +, 8], r8\n mov     qword, ptr, [rax, +, 16], rdx\n ret\n```\n\n## Checked Indexing (Option):\n\n```rust\npub unsafe fn example_option(slice: &mut [usize], indices: [usize; 3]) -> Option<[&mut usize; 3]> {\n    slice.get_many_mut(indices)\n}\n```\n\n```nasm\n mov     r10, qword, ptr, [r9, +, 8]\n mov     rcx, qword, ptr, [r9, +, 16]\n cmp     rcx, r10\n je      .LBB0_7\n mov     r9, qword, ptr, [r9]\n cmp     rcx, r9\n je      .LBB0_7\n cmp     rcx, r8\n jae     .LBB0_7\n cmp     r10, r9\n je      .LBB0_7\n cmp     r9, r8\n jae     .LBB0_7\n cmp     r10, r8\n jae     .LBB0_7\n lea     r8, [rdx, +, 8*r9]\n lea     r9, [rdx, +, 8*r10]\n lea     rcx, [rdx, +, 8*rcx]\n mov     qword, ptr, [rax], r8\n mov     qword, ptr, [rax, +, 8], r9\n mov     qword, ptr, [rax, +, 16], rcx\n ret\n.LBB0_7:\n mov     qword, ptr, [rax], 0\n ret\n```\n\n## Checked Indexing (Panic):\n\n```rust\npub fn example_panic(slice: &mut [usize], indices: [usize; 3]) -> [&mut usize; 3] {\n    let len = slice.len();\n    match slice.get_many_mut(indices) {\n        Some(s) => s,\n        None => {\n            let tmp = indices;\n            index_many::sorted_bound_check_failed(&tmp, len)\n        }\n    }\n}\n```\n\n```nasm\nexample_panic:\n sub     rsp, 56\n mov     rax, qword, ptr, [r9]\n mov     r10, qword, ptr, [r9, +, 8]\n mov     r9, qword, ptr, [r9, +, 16]\n cmp     r9, r10\n je      .LBB0_6\n cmp     r9, rax\n je      .LBB0_6\n cmp     r9, r8\n jae     .LBB0_6\n cmp     r10, rax\n je      .LBB0_6\n cmp     rax, r8\n jae     .LBB0_6\n cmp     r10, r8\n jae     .LBB0_6\n lea     rax, [rdx, +, 8*rax]\n lea     r8, [rdx, +, 8*r10]\n lea     rdx, [rdx, +, 8*r9]\n mov     qword, ptr, [rcx], rax\n mov     qword, ptr, [rcx, +, 8], r8\n mov     qword, ptr, [rcx, +, 16], rdx\n mov     rax, rcx\n add     rsp, 56\n ret\n.LBB0_6:\n mov     qword, ptr, [rsp, +, 32], rax\n mov     qword, ptr, [rsp, +, 40], r10\n mov     qword, ptr, [rsp, +, 48], r9\n lea     rcx, [rsp, +, 32]\n mov     edx, 3\n call    index_many::bound_check_failed\n ud2\n```\n</details>\n\n# Extensions\n\nThere are multiple optional extensions to this.\n\n## Indexing With Ranges\n\nThis could easily be expanded to allow indexing with `[I; N]` where `I: SliceIndex<Self>`.  I wanted to keep the initial implementation simple, so I didn't include it yet.\n\n## Panicking Variant\n\nWe could also add this method:\n\n```rust\nimpl<T> [T] {\n    fn index_many_mut<const N: usize>(&mut self, indices: [usize; N]) -> [&mut T; N];\n}\n```\n\nThis would work similar to the regular index operator and panic with out-of-bound indices. The advantage would be that we could more easily ensure good codegen with a useful panic message, which is non-trivial with the `Option` variant.\n\nThis is implemented in the standalone implementation, and used as basis for the codegen examples here and there.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dd515f27393c7f1e8b57f9d21c183cd05005b5c", "html_url": "https://github.com/rust-lang/rust/commit/1dd515f27393c7f1e8b57f9d21c183cd05005b5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dd515f27393c7f1e8b57f9d21c183cd05005b5c/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "html_url": "https://github.com/rust-lang/rust/commit/0f7d81754db66d46ee9aa033735a1ee5c1daa44d"}, {"sha": "3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d", "html_url": "https://github.com/rust-lang/rust/commit/3fe37b8c6e02daa6a7c33a71bb7f44682e43d08d"}], "stats": {"total": 201, "additions": 201, "deletions": 0}, "files": [{"sha": "7152300abcbf3a446cca031d797040d23abb2353", "filename": "library/core/src/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1dd515f27393c7f1e8b57f9d21c183cd05005b5c/library%2Fcore%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dd515f27393c7f1e8b57f9d21c183cd05005b5c/library%2Fcore%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ferror.rs?ref=1dd515f27393c7f1e8b57f9d21c183cd05005b5c", "patch": "@@ -506,3 +506,6 @@ impl Error for crate::ffi::FromBytesWithNulError {\n \n #[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n impl Error for crate::ffi::FromBytesUntilNulError {}\n+\n+#[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+impl<const N: usize> Error for crate::slice::GetManyMutError<N> {}"}, {"sha": "04486ed2d14e31a3c9c977ec9978e692b98b2a52", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/1dd515f27393c7f1e8b57f9d21c183cd05005b5c/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dd515f27393c7f1e8b57f9d21c183cd05005b5c/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=1dd515f27393c7f1e8b57f9d21c183cd05005b5c", "patch": "@@ -7,6 +7,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cmp::Ordering::{self, Greater, Less};\n+use crate::fmt;\n use crate::intrinsics::{assert_unsafe_precondition, exact_div};\n use crate::marker::Copy;\n use crate::mem::{self, SizedTypeProperties};\n@@ -4082,6 +4083,88 @@ impl<T> [T] {\n         *self = rem;\n         Some(last)\n     }\n+\n+    /// Returns mutable references to many indices at once, without doing any checks.\n+    ///\n+    /// For a safe alternative see [`get_many_mut`].\n+    ///\n+    /// # Safety\n+    ///\n+    /// Calling this method with overlapping or out-of-bounds indices is *[undefined behavior]*\n+    /// even if the resulting references are not used.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_many_mut)]\n+    ///\n+    /// let x = &mut [1, 2, 4];\n+    ///\n+    /// unsafe {\n+    ///     let [a, b] = x.get_many_unchecked_mut([0, 2]);\n+    ///     *a *= 10;\n+    ///     *b *= 100;\n+    /// }\n+    /// assert_eq!(x, &[10, 2, 400]);\n+    /// ```\n+    ///\n+    /// [`get_many_mut`]: slice::get_many_mut\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    #[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+    #[inline]\n+    pub unsafe fn get_many_unchecked_mut<const N: usize>(\n+        &mut self,\n+        indices: [usize; N],\n+    ) -> [&mut T; N] {\n+        // NB: This implementation is written as it is because any variation of\n+        // `indices.map(|i| self.get_unchecked_mut(i))` would make miri unhappy,\n+        // or generate worse code otherwise. This is also why we need to go\n+        // through a raw pointer here.\n+        let slice: *mut [T] = self;\n+        let mut arr: mem::MaybeUninit<[&mut T; N]> = mem::MaybeUninit::uninit();\n+        let arr_ptr = arr.as_mut_ptr();\n+\n+        // SAFETY: We expect `indices` to contain disjunct values that are\n+        // in bounds of `self`.\n+        unsafe {\n+            for i in 0..N {\n+                let idx = *indices.get_unchecked(i);\n+                *(*arr_ptr).get_unchecked_mut(i) = &mut *slice.get_unchecked_mut(idx);\n+            }\n+            arr.assume_init()\n+        }\n+    }\n+\n+    /// Returns mutable references to many indices at once.\n+    ///\n+    /// Returns an error if any index is out-of-bounds, or if the same index was\n+    /// passed more than once.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_many_mut)]\n+    ///\n+    /// let v = &mut [1, 2, 3];\n+    /// if let Ok([a, b]) = v.get_many_mut([0, 2]) {\n+    ///     *a = 413;\n+    ///     *b = 612;\n+    /// }\n+    /// assert_eq!(v, &[413, 2, 612]);\n+    /// ```\n+    #[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+    #[inline]\n+    pub fn get_many_mut<const N: usize>(\n+        &mut self,\n+        indices: [usize; N],\n+    ) -> Result<[&mut T; N], GetManyMutError<N>> {\n+        if !get_many_check_valid(&indices, self.len()) {\n+            return Err(GetManyMutError { _private: () });\n+        }\n+        // SAFETY: The `get_many_check_valid()` call checked that all indices\n+        // are disjunct and in bounds.\n+        unsafe { Ok(self.get_many_unchecked_mut(indices)) }\n+    }\n }\n \n impl<T, const N: usize> [[T; N]] {\n@@ -4304,3 +4387,56 @@ impl<T, const N: usize> SlicePattern for [T; N] {\n         self\n     }\n }\n+\n+/// This checks every index against each other, and against `len`.\n+///\n+/// This will do `binomial(N + 1, 2) = N * (N + 1) / 2 = 0, 1, 3, 6, 10, ..`\n+/// comparison operations.\n+fn get_many_check_valid<const N: usize>(indices: &[usize; N], len: usize) -> bool {\n+    // NB: The optimzer should inline the loops into a sequence\n+    // of instructions without additional branching.\n+    let mut valid = true;\n+    for (i, &idx) in indices.iter().enumerate() {\n+        valid &= idx < len;\n+        for &idx2 in &indices[..i] {\n+            valid &= idx != idx2;\n+        }\n+    }\n+    valid\n+}\n+\n+/// The error type returned by [`get_many_mut<N>`][`slice::get_many_mut`].\n+///\n+/// It indicates one of two possible errors:\n+/// - An index is out-of-bounds.\n+/// - The same index appeared multiple times in the array.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(get_many_mut)]\n+///\n+/// let v = &mut [1, 2, 3];\n+/// assert!(v.get_many_mut([0, 999]).is_err());\n+/// assert!(v.get_many_mut([1, 1]).is_err());\n+/// ```\n+#[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+// NB: The N here is there to be forward-compatible with adding more details\n+// to the error type at a later point\n+pub struct GetManyMutError<const N: usize> {\n+    _private: (),\n+}\n+\n+#[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+impl<const N: usize> fmt::Debug for GetManyMutError<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"GetManyMutError\").finish_non_exhaustive()\n+    }\n+}\n+\n+#[unstable(feature = \"get_many_mut\", issue = \"104642\")]\n+impl<const N: usize> fmt::Display for GetManyMutError<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(\"an index is out of bounds or appeared multiple times in the array\", f)\n+    }\n+}"}, {"sha": "99d4a40c4c962816f5637333c421579f518c6082", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1dd515f27393c7f1e8b57f9d21c183cd05005b5c/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dd515f27393c7f1e8b57f9d21c183cd05005b5c/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=1dd515f27393c7f1e8b57f9d21c183cd05005b5c", "patch": "@@ -108,6 +108,7 @@\n #![feature(provide_any)]\n #![feature(utf8_chunks)]\n #![feature(is_ascii_octdigit)]\n+#![feature(get_many_mut)]\n #![deny(unsafe_op_in_unsafe_fn)]\n #![deny(fuzzy_provenance_casts)]\n "}, {"sha": "4e06e0f43988687dc514a36cfe157ffc8b5b5957", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1dd515f27393c7f1e8b57f9d21c183cd05005b5c/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dd515f27393c7f1e8b57f9d21c183cd05005b5c/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=1dd515f27393c7f1e8b57f9d21c183cd05005b5c", "patch": "@@ -2595,3 +2595,63 @@ fn test_flatten_mut_size_overflow() {\n     let x = &mut [[(); usize::MAX]; 2][..];\n     let _ = x.flatten_mut();\n }\n+\n+#[test]\n+fn test_get_many_mut_normal_2() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let [a, b] = v.get_many_mut([3, 0]).unwrap();\n+    *a += 10;\n+    *b += 100;\n+    assert_eq!(v, vec![101, 2, 3, 14, 5]);\n+}\n+\n+#[test]\n+fn test_get_many_mut_normal_3() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let [a, b, c] = v.get_many_mut([0, 4, 2]).unwrap();\n+    *a += 10;\n+    *b += 100;\n+    *c += 1000;\n+    assert_eq!(v, vec![11, 2, 1003, 4, 105]);\n+}\n+\n+#[test]\n+fn test_get_many_mut_empty() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let [] = v.get_many_mut([]).unwrap();\n+    assert_eq!(v, vec![1, 2, 3, 4, 5]);\n+}\n+\n+#[test]\n+fn test_get_many_mut_single_first() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let [a] = v.get_many_mut([0]).unwrap();\n+    *a += 10;\n+    assert_eq!(v, vec![11, 2, 3, 4, 5]);\n+}\n+\n+#[test]\n+fn test_get_many_mut_single_last() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    let [a] = v.get_many_mut([4]).unwrap();\n+    *a += 10;\n+    assert_eq!(v, vec![1, 2, 3, 4, 15]);\n+}\n+\n+#[test]\n+fn test_get_many_mut_oob_nonempty() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    assert!(v.get_many_mut([5]).is_err());\n+}\n+\n+#[test]\n+fn test_get_many_mut_oob_empty() {\n+    let mut v: Vec<i32> = vec![];\n+    assert!(v.get_many_mut([0]).is_err());\n+}\n+\n+#[test]\n+fn test_get_many_mut_duplicate() {\n+    let mut v = vec![1, 2, 3, 4, 5];\n+    assert!(v.get_many_mut([1, 3, 3, 4]).is_err());\n+}"}, {"sha": "63ee6c521d793babfc515a583f9c22086b79eab9", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1dd515f27393c7f1e8b57f9d21c183cd05005b5c/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dd515f27393c7f1e8b57f9d21c183cd05005b5c/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=1dd515f27393c7f1e8b57f9d21c183cd05005b5c", "patch": "@@ -347,6 +347,7 @@\n #![feature(stdsimd)]\n #![feature(test)]\n #![feature(trace_macros)]\n+#![feature(get_many_mut)]\n //\n // Only used in tests/benchmarks:\n //"}]}