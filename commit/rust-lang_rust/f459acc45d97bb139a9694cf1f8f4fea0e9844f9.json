{"sha": "f459acc45d97bb139a9694cf1f8f4fea0e9844f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NTlhY2M0NWQ5N2JiMTM5YTk2OTRjZjFmOGY0ZmVhMGU5ODQ0Zjk=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-11-29T20:08:40Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-11-29T22:12:51Z"}, "message": "Disallow importing private items\n\nresolve wasn't checking that a `use` referred to a public item.\n\nr=brson", "tree": {"sha": "429ba42118756ee26902ecce32c65a3513d8c269", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/429ba42118756ee26902ecce32c65a3513d8c269"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f459acc45d97bb139a9694cf1f8f4fea0e9844f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f459acc45d97bb139a9694cf1f8f4fea0e9844f9", "html_url": "https://github.com/rust-lang/rust/commit/f459acc45d97bb139a9694cf1f8f4fea0e9844f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f459acc45d97bb139a9694cf1f8f4fea0e9844f9/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce24d3775980b992e59b382686ba50ca7b1d04dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce24d3775980b992e59b382686ba50ca7b1d04dc", "html_url": "https://github.com/rust-lang/rust/commit/ce24d3775980b992e59b382686ba50ca7b1d04dc"}], "stats": {"total": 232, "additions": 150, "deletions": 82}, "files": [{"sha": "d54e07f808c748d14b9e7f38ce92d2aa4e9d7ed8", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 117, "deletions": 82, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/f459acc45d97bb139a9694cf1f8f4fea0e9844f9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f459acc45d97bb139a9694cf1f8f4fea0e9844f9/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f459acc45d97bb139a9694cf1f8f4fea0e9844f9", "patch": "@@ -54,7 +54,7 @@ use syntax::visit::{visit_mod, visit_ty, vt};\n \n use box::ptr_eq;\n use dvec::DVec;\n-use option::{get, is_some};\n+use option::{Some, get, is_some, is_none};\n use str::{connect, split_str};\n use vec::pop;\n use syntax::parse::token::ident_interner;\n@@ -141,9 +141,19 @@ enum Namespace {\n     ValueNS\n }\n \n+/// A NamespaceResult represents the result of resolving an import in a\n+/// particular namespace. The result is either definitely-resolved, definitely-\n+/// unresolved, or unknown.\n enum NamespaceResult {\n+    /// Means that resolve hasn't gathered enough information yet to determine\n+    /// whether the name is bound in this namespace. (That is, it hasn't\n+    /// resolved all `use` directives yet.)\n     UnknownResult,\n+    /// Means that resolve has determined that the name is definitely not bound in\n+    /// the namespace.\n     UnboundResult,\n+    /// Means that resolve has determined that the name is bound in the Module\n+    /// argument, and specified by the NameBindings argument.\n     BoundResult(@Module, @NameBindings)\n }\n \n@@ -398,7 +408,10 @@ fn Target(target_module: @Module, bindings: @NameBindings) -> Target {\n     }\n }\n \n+/// An ImportResolution represents a particular `use` directive.\n struct ImportResolution {\n+    /// The privacy of this `use` directive (whether it's `use` or\n+    /// `pub use`.\n     privacy: Privacy,\n     span: span,\n \n@@ -408,7 +421,9 @@ struct ImportResolution {\n \n     mut outstanding_references: uint,\n \n+    /// The value that this `use` directive names, if there is one.\n     mut value_target: Option<Target>,\n+    /// The type that this `use` directive names, if there is one.\n     mut type_target: Option<Target>,\n \n     mut used: bool,\n@@ -418,7 +433,7 @@ fn ImportResolution(privacy: Privacy, span: span) -> ImportResolution {\n     ImportResolution {\n         privacy: privacy,\n         span: span,\n-        outstanding_references: 0u,\n+        outstanding_references: 0,\n         value_target: None,\n         type_target: None,\n         used: false\n@@ -503,8 +518,8 @@ fn Module(parent_link: ParentLink,\n         exported_names: HashMap(),\n         legacy_exports: legacy_exports,\n         import_resolutions: HashMap(),\n-        glob_count: 0u,\n-        resolved_import_count: 0u\n+        glob_count: 0,\n+        resolved_import_count: 0\n     }\n }\n \n@@ -514,16 +529,6 @@ impl Module {\n     }\n }\n \n-// XXX: This is a workaround due to is_none in the standard library mistakenly\n-// requiring a T:copy.\n-\n-pure fn is_none<T>(x: Option<T>) -> bool {\n-    match x {\n-        None => return true,\n-        Some(_) => return false\n-    }\n-}\n-\n fn unused_import_lint_level(session: Session) -> level {\n     for session.opts.lint_opts.each |lint_option_pair| {\n         let (lint_type, lint_level) = *lint_option_pair;\n@@ -814,7 +819,7 @@ fn Resolver(session: Session, lang_items: LanguageItems,\n         trait_info: HashMap(),\n         structs: HashMap(),\n \n-        unresolved_imports: 0u,\n+        unresolved_imports: 0,\n \n         current_module: current_module,\n         value_ribs: @DVec(),\n@@ -1069,7 +1074,7 @@ impl Resolver {\n \n     fn block_needs_anonymous_module(block: blk) -> bool {\n         // If the block has view items, we need an anonymous module.\n-        if block.node.view_items.len() > 0u {\n+        if block.node.view_items.len() > 0 {\n             return true;\n         }\n \n@@ -1198,10 +1203,10 @@ impl Resolver {\n \n                 for enum_definition.variants.each |variant| {\n                     self.build_reduced_graph_for_variant(*variant,\n-                                                         local_def(item.id),\n-                                                         privacy,\n-                                                         new_parent,\n-                                                         visitor);\n+                        local_def(item.id),\n+                        // inherited => privacy of the enum item\n+                        self.visibility_to_privacy(variant.node.vis, privacy == Public),\n+                        new_parent, visitor);\n                 }\n             }\n \n@@ -1461,10 +1466,10 @@ impl Resolver {\n                     match view_path.node {\n                         view_path_simple(_, full_path, _, _) => {\n                             let path_len = full_path.idents.len();\n-                            assert path_len != 0u;\n+                            assert path_len != 0;\n \n                             for full_path.idents.eachi |i, ident| {\n-                                if i != path_len - 1u {\n+                                if i != path_len - 1 {\n                                     (*module_path).push(*ident);\n                                 }\n                             }\n@@ -1551,7 +1556,7 @@ impl Resolver {\n \n                         view_path_list(path, path_list_idents, _) => {\n                             if path.idents.len() == 1u &&\n-                                    path_list_idents.len() == 0u {\n+                                    path_list_idents.len() == 0 {\n \n                                 self.session.span_warn(view_item.span,\n                                                        ~\"this syntax for \\\n@@ -1561,7 +1566,7 @@ impl Resolver {\n                                                         variants \\\n                                                         individually\");\n                             } else {\n-                                if path.idents.len() != 0u {\n+                                if path.idents.len() != 0 {\n                                     self.session.span_err(view_item.span,\n                                                           ~\"cannot export an \\\n                                                            item that is not \\\n@@ -1624,7 +1629,7 @@ impl Resolver {\n \n                 do self.with_type_parameter_rib\n                         (HasTypeParameters(&type_parameters, foreign_item.id,\n-                                           0u, NormalRibKind)) {\n+                                           0, NormalRibKind)) {\n                     visit_foreign_item(foreign_item, new_parent, visitor);\n                 }\n             }\n@@ -1971,12 +1976,12 @@ impl Resolver {\n                     Some(resolution) => {\n                         debug!(\"(building import directive) bumping \\\n                                 reference\");\n-                        resolution.outstanding_references += 1u;\n+                        resolution.outstanding_references += 1;\n                     }\n                     None => {\n                         debug!(\"(building import directive) creating new\");\n                         let resolution = @ImportResolution(privacy, span);\n-                        resolution.outstanding_references = 1u;\n+                        resolution.outstanding_references = 1;\n                         module_.import_resolutions.insert(target, resolution);\n                     }\n                 }\n@@ -1985,11 +1990,11 @@ impl Resolver {\n                 // Set the glob flag. This tells us that we don't know the\n                 // module's exports ahead of time.\n \n-                module_.glob_count += 1u;\n+                module_.glob_count += 1;\n             }\n         }\n \n-        self.unresolved_imports += 1u;\n+        self.unresolved_imports += 1;\n     }\n \n     // Import resolution\n@@ -2005,16 +2010,16 @@ impl Resolver {\n      * point iteration.\n      */\n     fn resolve_imports() {\n-        let mut i = 0u;\n-        let mut prev_unresolved_imports = 0u;\n+        let mut i = 0;\n+        let mut prev_unresolved_imports = 0;\n         loop {\n             debug!(\"(resolving imports) iteration %u, %u imports left\",\n                    i, self.unresolved_imports);\n \n             let module_root = (*self.graph_root).get_module();\n             self.resolve_imports_for_module_subtree(module_root);\n \n-            if self.unresolved_imports == 0u {\n+            if self.unresolved_imports == 0 {\n                 debug!(\"(resolving imports) success\");\n                 break;\n             }\n@@ -2025,7 +2030,7 @@ impl Resolver {\n                 break;\n             }\n \n-            i += 1u;\n+            i += 1;\n             prev_unresolved_imports = self.unresolved_imports;\n         }\n     }\n@@ -2083,7 +2088,7 @@ impl Resolver {\n                 }\n             }\n \n-            module_.resolved_import_count += 1u;\n+            module_.resolved_import_count += 1;\n         }\n     }\n \n@@ -2124,7 +2129,7 @@ impl Resolver {\n         // One-level renaming imports of the form `import foo = bar;` are\n         // handled specially.\n \n-        if (*module_path).len() == 0u {\n+        if (*module_path).len() == 0 {\n             resolution_result =\n                 self.resolve_one_level_renaming_import(module_,\n                                                        import_directive);\n@@ -2176,8 +2181,8 @@ impl Resolver {\n         // Decrement the count of unresolved imports.\n         match resolution_result {\n             Success(()) => {\n-                assert self.unresolved_imports >= 1u;\n-                self.unresolved_imports -= 1u;\n+                assert self.unresolved_imports >= 1;\n+                self.unresolved_imports -= 1;\n             }\n             _ => {\n                 // Nothing to do here; just return the error.\n@@ -2192,8 +2197,8 @@ impl Resolver {\n         if !resolution_result.indeterminate() {\n             match *import_directive.subclass {\n                 GlobImport => {\n-                    assert module_.glob_count >= 1u;\n-                    module_.glob_count -= 1u;\n+                    assert module_.glob_count >= 1;\n+                    module_.glob_count -= 1;\n                 }\n                 SingleImport(*) => {\n                     // Ignore.\n@@ -2259,7 +2264,7 @@ impl Resolver {\n                 // containing module, bail out. We don't know enough to be\n                 // able to resolve this import.\n \n-                if containing_module.glob_count > 0u {\n+                if containing_module.glob_count > 0 {\n                     debug!(\"(resolving single import) unresolved glob; \\\n                             bailing out\");\n                     return Indeterminate;\n@@ -2284,11 +2289,12 @@ impl Resolver {\n                     }\n                     Some(import_resolution)\n                             if import_resolution.outstanding_references\n-                                == 0u => {\n+                                == 0 => {\n \n                         fn get_binding(import_resolution: @ImportResolution,\n                                        namespace: Namespace)\n                                     -> NamespaceResult {\n+\n                             // Import resolutions must be declared with \"pub\"\n                             // in order to be exported.\n                             if import_resolution.privacy == Private {\n@@ -2356,14 +2362,44 @@ impl Resolver {\n \n         let i = import_resolution;\n         match (i.value_target, i.type_target) {\n-          // If this name wasn't found in either namespace, it's definitely\n-          // unresolved.\n-          (None, None) => { return Failed; }\n-          _ => {}\n+            // If this name wasn't found in either namespace, it's definitely\n+            // unresolved.\n+            (None, None) => { return Failed; }\n+            // If it's private, it's also unresolved.\n+            (Some(t), None) | (None, Some(t)) => {\n+                match t.bindings.type_def {\n+                    Some(ref type_def) => {\n+                        if type_def.privacy == Private {\n+                            return Failed;\n+                        }\n+                    }\n+                    _ => ()\n+                }\n+                match t.bindings.value_def {\n+                    Some(ref value_def) => {\n+                        if value_def.privacy == Private {\n+                            return Failed;\n+                        }\n+                    }\n+                    _ => ()\n+                }\n+            }\n+            // It's also an error if there's both a type and a value with this\n+            // name, but both are private\n+            (Some(val), Some(ty)) => {\n+                match (val.bindings.value_def, ty.bindings.value_def) {\n+                    (Some(ref value_def), Some(ref type_def)) =>\n+                        if value_def.privacy == Private\n+                            && type_def.privacy == Private {\n+                            return Failed;\n+                        },\n+                    _ => ()\n+                }\n+            }\n         }\n \n-        assert import_resolution.outstanding_references >= 1u;\n-        import_resolution.outstanding_references -= 1u;\n+        assert import_resolution.outstanding_references >= 1;\n+        import_resolution.outstanding_references -= 1;\n \n         debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());\n@@ -2414,15 +2450,14 @@ impl Resolver {\n                 // containing module, bail out. We don't know enough to be\n                 // able to resolve this import.\n \n-                if containing_module.glob_count > 0u {\n+                if containing_module.glob_count > 0 {\n                     debug!(\"(resolving single module import) unresolved \\\n                             glob; bailing out\");\n                     return Indeterminate;\n                 }\n \n                 // Now search the exported imports within the containing\n                 // module.\n-\n                 match containing_module.import_resolutions.find(source) {\n                     None => {\n                         // The containing module definitely doesn't have an\n@@ -2436,7 +2471,7 @@ impl Resolver {\n                     }\n                     Some(import_resolution)\n                             if import_resolution.outstanding_references\n-                                == 0u => {\n+                                == 0 => {\n                         // The name is an import which has been fully\n                         // resolved. We can, therefore, just follow it.\n \n@@ -2491,8 +2526,8 @@ impl Resolver {\n           return Failed;\n         }\n \n-        assert import_resolution.outstanding_references >= 1u;\n-        import_resolution.outstanding_references -= 1u;\n+        assert import_resolution.outstanding_references >= 1;\n+        import_resolution.outstanding_references -= 1;\n \n         debug!(\"(resolving single module import) successfully resolved \\\n                import\");\n@@ -2523,7 +2558,7 @@ impl Resolver {\n             return Indeterminate;\n         }\n \n-        assert containing_module.glob_count == 0u;\n+        assert containing_module.glob_count == 0;\n \n         // Add all resolved imports from the containing module.\n         for containing_module.import_resolutions.each\n@@ -2537,7 +2572,7 @@ impl Resolver {\n \n             debug!(\"(resolving glob import) writing module resolution \\\n                     %? into `%s`\",\n-                   is_none(target_import_resolution.type_target),\n+                   is_none(&target_import_resolution.type_target),\n                    self.module_to_str(module_));\n \n             // Here we merge two import resolutions.\n@@ -2688,7 +2723,7 @@ impl Resolver {\n                 }\n             }\n \n-            index += 1u;\n+            index += 1;\n         }\n \n         return Success(search_module);\n@@ -2705,7 +2740,7 @@ impl Resolver {\n                                    -> ResolveResult<@Module> {\n \n         let module_path_len = (*module_path).len();\n-        assert module_path_len > 0u;\n+        assert module_path_len > 0;\n \n         debug!(\"(resolving module path for import) processing `%s` rooted at \\\n                `%s`\",\n@@ -2715,7 +2750,7 @@ impl Resolver {\n         // The first element of the module path must be in the current scope\n         // chain.\n \n-        let first_element = (*module_path).get_elt(0u);\n+        let first_element = (*module_path).get_elt(0);\n         let mut search_module;\n         match self.resolve_module_in_lexical_scope(module_, first_element) {\n             Failed => {\n@@ -2734,7 +2769,7 @@ impl Resolver {\n \n         return self.resolve_module_path_from_root(search_module,\n                                                module_path,\n-                                               1u,\n+                                               1,\n                                                xray,\n                                                span);\n     }\n@@ -2865,7 +2900,7 @@ impl Resolver {\n \n     fn name_is_exported(module_: @Module, name: ident) -> bool {\n         return !module_.legacy_exports ||\n-            module_.exported_names.size() == 0u ||\n+            module_.exported_names.size() == 0 ||\n             module_.exported_names.contains_key(name);\n     }\n \n@@ -2906,15 +2941,15 @@ impl Resolver {\n         // Next, check the module's imports. If the module has a glob, then\n         // we bail out; we don't know its imports yet.\n \n-        if module_.glob_count > 0u {\n+        if module_.glob_count > 0 {\n             debug!(\"(resolving name in module) module has glob; bailing out\");\n             return Indeterminate;\n         }\n \n         // Otherwise, we check the list of resolved imports.\n         match module_.import_resolutions.find(name) {\n             Some(import_resolution) => {\n-                if import_resolution.outstanding_references != 0u {\n+                if import_resolution.outstanding_references != 0 {\n                     debug!(\"(resolving name in module) import unresolved; \\\n                             bailing out\");\n                     return Indeterminate;\n@@ -3069,9 +3104,9 @@ impl Resolver {\n         //\n \n         // If nothing at all was found, that's an error.\n-        if is_none(module_result) &&\n-                is_none(value_result) &&\n-                is_none(type_result) {\n+        if is_none(&module_result) &&\n+                is_none(&value_result) &&\n+                is_none(&type_result) {\n \n             self.session.span_err(import_directive.span,\n                                   ~\"unresolved import\");\n@@ -3088,15 +3123,15 @@ impl Resolver {\n             Some(import_resolution) => {\n                 debug!(\"(resolving one-level renaming import) writing module \\\n                         result %? for `%s` into `%s`\",\n-                       is_none(module_result),\n+                       is_none(&module_result),\n                        self.session.str_of(target_name),\n                        self.module_to_str(module_));\n \n                 import_resolution.value_target = value_result;\n                 import_resolution.type_target = type_result;\n \n-                assert import_resolution.outstanding_references >= 1u;\n-                import_resolution.outstanding_references -= 1u;\n+                assert import_resolution.outstanding_references >= 1;\n+                import_resolution.outstanding_references -= 1;\n             }\n         }\n \n@@ -3393,7 +3428,7 @@ impl Resolver {\n             }\n         }\n \n-        let mut rib_index = rib_index + 1u;\n+        let mut rib_index = rib_index + 1;\n         while rib_index < (*ribs).len() {\n             let rib = (*ribs).get_elt(rib_index);\n             match rib.kind {\n@@ -3559,7 +3594,7 @@ impl Resolver {\n \n             item_ty(_, type_parameters) => {\n                 do self.with_type_parameter_rib\n-                        (HasTypeParameters(&type_parameters, item.id, 0u,\n+                        (HasTypeParameters(&type_parameters, item.id, 0,\n                                            NormalRibKind))\n                         || {\n \n@@ -3589,7 +3624,7 @@ impl Resolver {\n \n                 // Create a new rib for the trait-wide type parameters.\n                 do self.with_type_parameter_rib\n-                        (HasTypeParameters(&type_parameters, item.id, 0u,\n+                        (HasTypeParameters(&type_parameters, item.id, 0,\n                                            NormalRibKind)) {\n \n                     self.resolve_type_parameters(type_parameters, visitor);\n@@ -3680,7 +3715,7 @@ impl Resolver {\n                                 do self.with_type_parameter_rib\n                                     (HasTypeParameters(&type_parameters,\n                                                        foreign_item.id,\n-                                                       0u,\n+                                                       0,\n                                                        OpaqueFunctionRibKind))\n                                         || {\n \n@@ -3705,7 +3740,7 @@ impl Resolver {\n                 // of conditionals.\n \n                 if !self.session.building_library &&\n-                    is_none(self.session.main_fn) &&\n+                    is_none(&self.session.main_fn) &&\n                     item.ident == syntax::parse::token::special_idents::main {\n \n                     self.session.main_fn = Some((item.id, item.span));\n@@ -3716,7 +3751,7 @@ impl Resolver {\n                                       HasTypeParameters\n                                         (&ty_params,\n                                          item.id,\n-                                         0u,\n+                                         0,\n                                          OpaqueFunctionRibKind),\n                                       block,\n                                       NoSelfBinding,\n@@ -4010,7 +4045,7 @@ impl Resolver {\n         let outer_type_parameter_count = type_parameters.len();\n         let borrowed_type_parameters: &~[ty_param] = &type_parameters;\n         do self.with_type_parameter_rib(HasTypeParameters\n-                                        (borrowed_type_parameters, id, 0u,\n+                                        (borrowed_type_parameters, id, 0,\n                                          NormalRibKind)) {\n             // Resolve the type parameters.\n             self.resolve_type_parameters(type_parameters, visitor);\n@@ -4291,7 +4326,7 @@ impl Resolver {\n         do walk_pat(pattern) |pattern| {\n             match pattern.node {\n                 pat_ident(binding_mode, path, _)\n-                        if !path.global && path.idents.len() == 1u => {\n+                        if !path.global && path.idents.len() == 1 => {\n \n                     // The meaning of pat_ident with no type parameters\n                     // depends on whether an enum variant or unit-like struct\n@@ -4633,7 +4668,7 @@ impl Resolver {\n     fn intern_module_part_of_path(path: @path) -> @DVec<ident> {\n         let module_path_idents = @DVec();\n         for path.idents.eachi |index, ident| {\n-            if index == path.idents.len() - 1u {\n+            if index == path.idents.len() - 1 {\n                 break;\n             }\n \n@@ -4700,7 +4735,7 @@ impl Resolver {\n         let mut containing_module;\n         match self.resolve_module_path_from_root(root_module,\n                                                module_path_idents,\n-                                               0u,\n+                                               0,\n                                                xray,\n                                                path.span) {\n \n@@ -5262,22 +5297,22 @@ impl Resolver {\n             }\n         }\n \n-        if idents.len() == 0u {\n+        if idents.len() == 0 {\n             return ~\"???\";\n         }\n \n         let mut string = ~\"\";\n-        let mut i = idents.len() - 1u;\n+        let mut i = idents.len() - 1;\n         loop {\n-            if i < idents.len() - 1u {\n+            if i < idents.len() - 1 {\n                 string += ~\"::\";\n             }\n             string += self.session.str_of(idents.get_elt(i));\n \n-            if i == 0u {\n+            if i == 0 {\n                 break;\n             }\n-            i -= 1u;\n+            i -= 1;\n         }\n \n         return string;"}, {"sha": "2094fc75233be80db5976d264ba36be8c16c957b", "filename": "src/test/compile-fail/issue-3993-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f459acc45d97bb139a9694cf1f8f4fea0e9844f9/src%2Ftest%2Fcompile-fail%2Fissue-3993-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f459acc45d97bb139a9694cf1f8f4fea0e9844f9/src%2Ftest%2Fcompile-fail%2Fissue-3993-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3993-2.rs?ref=f459acc45d97bb139a9694cf1f8f4fea0e9844f9", "patch": "@@ -0,0 +1,13 @@\n+use zoo::{duck, goose}; //~ ERROR failed to resolve import\n+\n+mod zoo {\n+    pub enum bird {\n+        pub duck,\n+        priv goose\n+    }\n+}\n+\n+\n+fn main() {\n+    let y = goose;\n+}"}, {"sha": "2dbdf95eadea3ab77a2364b1f2cc0f32dd8dc878", "filename": "src/test/compile-fail/issue-3993-3.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f459acc45d97bb139a9694cf1f8f4fea0e9844f9/src%2Ftest%2Fcompile-fail%2Fissue-3993-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f459acc45d97bb139a9694cf1f8f4fea0e9844f9/src%2Ftest%2Fcompile-fail%2Fissue-3993-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3993-3.rs?ref=f459acc45d97bb139a9694cf1f8f4fea0e9844f9", "patch": "@@ -0,0 +1,9 @@\n+use zoo::fly; //~ ERROR failed to resolve import\n+\n+mod zoo {\n+    priv type fly = ();\n+    priv fn fly() {}\n+}\n+\n+\n+fn main() {}"}, {"sha": "e4a192bcb285741c75042cdbedc31ef9b336a56f", "filename": "src/test/compile-fail/issue-3993.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f459acc45d97bb139a9694cf1f8f4fea0e9844f9/src%2Ftest%2Fcompile-fail%2Fissue-3993.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f459acc45d97bb139a9694cf1f8f4fea0e9844f9/src%2Ftest%2Fcompile-fail%2Fissue-3993.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3993.rs?ref=f459acc45d97bb139a9694cf1f8f4fea0e9844f9", "patch": "@@ -0,0 +1,8 @@\n+use zoo::fly; //~ ERROR failed to resolve import\n+\n+mod zoo {\n+    priv fn fly() {}\n+}\n+\n+\n+fn main() {}"}, {"sha": "8393e86f5155c0f1ebaf09d2b0a4d85eb8e52252", "filename": "src/test/run-pass/module-polymorphism3-files/float-template/inst_f32.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f459acc45d97bb139a9694cf1f8f4fea0e9844f9/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f459acc45d97bb139a9694cf1f8f4fea0e9844f9/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f32.rs?ref=f459acc45d97bb139a9694cf1f8f4fea0e9844f9", "patch": "@@ -0,0 +1 @@\n+pub type T = f32;\n\\ No newline at end of file"}, {"sha": "55dfb56f3e5093db94a9c324c1fd478dc65205dc", "filename": "src/test/run-pass/module-polymorphism3-files/float-template/inst_f64.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f459acc45d97bb139a9694cf1f8f4fea0e9844f9/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f459acc45d97bb139a9694cf1f8f4fea0e9844f9/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_f64.rs?ref=f459acc45d97bb139a9694cf1f8f4fea0e9844f9", "patch": "@@ -0,0 +1 @@\n+pub type T = f64;\n\\ No newline at end of file"}, {"sha": "2380a552f10afb96f91ee779bc4938a49bc89fa0", "filename": "src/test/run-pass/module-polymorphism3-files/float-template/inst_float.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f459acc45d97bb139a9694cf1f8f4fea0e9844f9/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f459acc45d97bb139a9694cf1f8f4fea0e9844f9/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmodule-polymorphism3-files%2Ffloat-template%2Finst_float.rs?ref=f459acc45d97bb139a9694cf1f8f4fea0e9844f9", "patch": "@@ -0,0 +1 @@\n+pub type T = float;\n\\ No newline at end of file"}]}