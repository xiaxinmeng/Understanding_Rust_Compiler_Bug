{"sha": "673e2b1d8f01e2059c5204b42b12c04b198e30b5", "node_id": "C_kwDOAAsO6NoAKDY3M2UyYjFkOGYwMWUyMDU5YzUyMDRiNDJiMTJjMDRiMTk4ZTMwYjU", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-18T17:11:16Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-03-18T17:11:16Z"}, "message": "feat: Implement lifetime elision hints", "tree": {"sha": "f136564eb32230ec2a1f5d55fd4e270c8f484cf7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f136564eb32230ec2a1f5d55fd4e270c8f484cf7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/673e2b1d8f01e2059c5204b42b12c04b198e30b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/673e2b1d8f01e2059c5204b42b12c04b198e30b5", "html_url": "https://github.com/rust-lang/rust/commit/673e2b1d8f01e2059c5204b42b12c04b198e30b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/673e2b1d8f01e2059c5204b42b12c04b198e30b5/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "890f98f21f50f158d0efda9dd1a2a6f86af95d51", "url": "https://api.github.com/repos/rust-lang/rust/commits/890f98f21f50f158d0efda9dd1a2a6f86af95d51", "html_url": "https://github.com/rust-lang/rust/commit/890f98f21f50f158d0efda9dd1a2a6f86af95d51"}], "stats": {"total": 259, "additions": 242, "deletions": 17}, "files": [{"sha": "43675e52ed836e1bc6b6b9c8f6b7ae1e9a2d4102", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 220, "deletions": 6, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/673e2b1d8f01e2059c5204b42b12c04b198e30b5/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673e2b1d8f01e2059c5204b42b12c04b198e30b5/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=673e2b1d8f01e2059c5204b42b12c04b198e30b5", "patch": "@@ -4,7 +4,7 @@ use ide_db::{base_db::FileRange, famous_defs::FamousDefs, RootDatabase};\n use itertools::Itertools;\n use stdx::to_lower_snake_case;\n use syntax::{\n-    ast::{self, AstNode, HasArgList, HasName, UnaryOp},\n+    ast::{self, AstNode, HasArgList, HasGenericParams, HasName, UnaryOp},\n     match_ast, Direction, NodeOrToken, SmolStr, SyntaxKind, SyntaxNode, TextRange, T,\n };\n \n@@ -17,6 +17,7 @@ pub struct InlayHintsConfig {\n     pub parameter_hints: bool,\n     pub chaining_hints: bool,\n     pub closure_return_type_hints: bool,\n+    pub lifetime_elision_hints: bool,\n     pub hide_named_constructor_hints: bool,\n     pub max_length: Option<usize>,\n }\n@@ -27,6 +28,8 @@ pub enum InlayKind {\n     ParameterHint,\n     ClosureReturnTypeHint,\n     ChainingHint,\n+    GenericParamListHint,\n+    LifetimeHint,\n }\n \n #[derive(Debug)]\n@@ -41,12 +44,16 @@ pub struct InlayHint {\n // rust-analyzer shows additional information inline with the source code.\n // Editors usually render this using read-only virtual text snippets interspersed with code.\n //\n-// rust-analyzer shows hints for\n+// rust-analyzer by default shows hints for\n //\n // * types of local variables\n // * names of function arguments\n // * types of chained expressions\n //\n+// Optionally, one can enable additional hints for\n+//\n+// * return types of closure expressions with blocks\n+//\n // **Note:** VS Code does not have native support for inlay hints https://github.com/microsoft/vscode/issues/16221[yet] and the hints are implemented using decorations.\n // This approach has limitations, the caret movement and bracket highlighting near the edges of the hint may be weird:\n // https://github.com/rust-analyzer/rust-analyzer/issues/1623[1], https://github.com/rust-analyzer/rust-analyzer/issues/3453[2].\n@@ -108,11 +115,172 @@ fn hints(\n             }\n             _ => (),\n         }\n-    } else if let Some(it) = ast::IdentPat::cast(node) {\n+    } else if let Some(it) = ast::IdentPat::cast(node.clone()) {\n         bind_pat_hints(hints, sema, config, &it);\n+    } else if let Some(it) = ast::Fn::cast(node) {\n+        lifetime_hints(hints, config, it);\n     }\n }\n \n+fn lifetime_hints(\n+    acc: &mut Vec<InlayHint>,\n+    config: &InlayHintsConfig,\n+    func: ast::Fn,\n+) -> Option<()> {\n+    if !config.lifetime_elision_hints {\n+        return None;\n+    }\n+    let param_list = func.param_list()?;\n+    let generic_param_list = func.generic_param_list();\n+    let ret_type = func.ret_type();\n+    let self_param = param_list.self_param();\n+\n+    let mut allocated_lifetimes = vec![];\n+    let mut gen_name = {\n+        let mut iter = 'a'..;\n+        let allocated_lifetimes = &mut allocated_lifetimes;\n+        move || {\n+            if let Some(it) = iter.next() {\n+                allocated_lifetimes.push(SmolStr::from_iter(['\\'', it]))\n+            }\n+        }\n+    };\n+\n+    let potential_lt_refs: Vec<_> = param_list\n+        .params()\n+        .filter_map(|it| {\n+            let ty = it.ty()?;\n+            // FIXME: look into the nested types here and check path types\n+            match ty {\n+                ast::Type::RefType(r) => Some(r),\n+                _ => None,\n+            }\n+        })\n+        .collect();\n+\n+    enum LifetimeKind {\n+        Elided,\n+        Named(SmolStr),\n+        Static,\n+    }\n+\n+    let fetch_lt_text = |lt: Option<ast::Lifetime>| match lt {\n+        Some(lt) => match lt.text().as_str() {\n+            \"'_\" => LifetimeKind::Elided,\n+            \"'static\" => LifetimeKind::Static,\n+            name => LifetimeKind::Named(name.into()),\n+        },\n+        None => LifetimeKind::Elided,\n+    };\n+    let is_elided = |lt: Option<ast::Lifetime>| match lt {\n+        Some(lt) => matches!(lt.text().as_str(), \"'_\"),\n+        None => true,\n+    };\n+\n+    // allocate names\n+    if let Some(self_param) = &self_param {\n+        if is_elided(self_param.lifetime()) {\n+            gen_name();\n+        }\n+    }\n+    potential_lt_refs.iter().for_each(|it| {\n+        // FIXME: look into the nested types here and check path types\n+        if is_elided(it.lifetime()) {\n+            gen_name();\n+        }\n+    });\n+\n+    // fetch output lifetime if elision rule applies\n+\n+    let output = if let Some(self_param) = &self_param {\n+        match fetch_lt_text(self_param.lifetime()) {\n+            LifetimeKind::Elided => allocated_lifetimes.get(0).cloned(),\n+            LifetimeKind::Named(name) => Some(name),\n+            LifetimeKind::Static => None,\n+        }\n+    } else {\n+        match potential_lt_refs.as_slice() {\n+            [r] => match fetch_lt_text(r.lifetime()) {\n+                LifetimeKind::Elided => allocated_lifetimes.get(0).cloned(),\n+                LifetimeKind::Named(name) => Some(name),\n+                LifetimeKind::Static => None,\n+            },\n+            [..] => None,\n+        }\n+    };\n+\n+    // apply hints\n+\n+    // apply output if required\n+    match (&output, ret_type) {\n+        (Some(output_lt), Some(r)) => {\n+            if let Some(ast::Type::RefType(t)) = r.ty() {\n+                if t.lifetime().is_none() {\n+                    let amp = t.amp_token()?;\n+                    acc.push(InlayHint {\n+                        range: amp.text_range(),\n+                        kind: InlayKind::LifetimeHint,\n+                        label: output_lt.clone(),\n+                    });\n+                }\n+            }\n+        }\n+        _ => (),\n+    }\n+\n+    let mut idx = if let Some(self_param) = &self_param {\n+        if is_elided(self_param.lifetime()) {\n+            if let Some(amp) = self_param.amp_token() {\n+                let lt = allocated_lifetimes[0].clone();\n+                acc.push(InlayHint {\n+                    range: amp.text_range(),\n+                    kind: InlayKind::LifetimeHint,\n+                    label: lt,\n+                });\n+            }\n+            1\n+        } else {\n+            0\n+        }\n+    } else {\n+        0\n+    };\n+\n+    for p in potential_lt_refs.iter() {\n+        if is_elided(p.lifetime()) {\n+            let t = p.amp_token()?;\n+            let lt = allocated_lifetimes[idx].clone();\n+            acc.push(InlayHint { range: t.text_range(), kind: InlayKind::LifetimeHint, label: lt });\n+            idx += 1;\n+        }\n+    }\n+\n+    // generate generic param list things\n+    match (generic_param_list, allocated_lifetimes.as_slice()) {\n+        (_, []) => (),\n+        (Some(gpl), allocated_lifetimes) => {\n+            let angle_tok = gpl.l_angle_token()?;\n+            let is_empty = gpl.generic_params().next().is_none();\n+            acc.push(InlayHint {\n+                range: angle_tok.text_range(),\n+                kind: InlayKind::GenericParamListHint,\n+                label: format!(\n+                    \"{}{}\",\n+                    allocated_lifetimes.iter().format(\", \"),\n+                    if is_empty { \"\" } else { \", \" }\n+                )\n+                .into(),\n+            });\n+        }\n+        (None, allocated_lifetimes) => acc.push(InlayHint {\n+            range: func.name()?.syntax().text_range(),\n+            kind: InlayKind::GenericParamListHint,\n+            label: format!(\"<{}>\", allocated_lifetimes.iter().format(\", \"),).into(),\n+        }),\n+    }\n+    Some(())\n+}\n+\n fn closure_ret_hints(\n     acc: &mut Vec<InlayHint>,\n     sema: &Semantics<RootDatabase>,\n@@ -600,6 +768,7 @@ fn get_callable(\n mod tests {\n     use expect_test::{expect, Expect};\n     use ide_db::base_db::FileRange;\n+    use itertools::Itertools;\n     use syntax::{TextRange, TextSize};\n     use test_utils::extract_annotations;\n \n@@ -610,6 +779,7 @@ mod tests {\n         type_hints: false,\n         parameter_hints: false,\n         chaining_hints: false,\n+        lifetime_elision_hints: false,\n         hide_named_constructor_hints: false,\n         closure_return_type_hints: false,\n         max_length: None,\n@@ -619,6 +789,7 @@ mod tests {\n         parameter_hints: true,\n         chaining_hints: true,\n         closure_return_type_hints: true,\n+        lifetime_elision_hints: true,\n         ..DISABLED_CONFIG\n     };\n \n@@ -648,10 +819,15 @@ mod tests {\n     #[track_caller]\n     fn check_with_config(config: InlayHintsConfig, ra_fixture: &str) {\n         let (analysis, file_id) = fixture::file(ra_fixture);\n-        let expected = extract_annotations(&*analysis.file_text(file_id).unwrap());\n+        let mut expected = extract_annotations(&*analysis.file_text(file_id).unwrap());\n         let inlay_hints = analysis.inlay_hints(&config, file_id, None).unwrap();\n-        let actual =\n-            inlay_hints.into_iter().map(|it| (it.range, it.label.to_string())).collect::<Vec<_>>();\n+        let actual = inlay_hints\n+            .into_iter()\n+            .map(|it| (it.range, it.label.to_string()))\n+            .sorted_by_key(|(range, _)| range.start())\n+            .collect::<Vec<_>>();\n+        expected.sort_by_key(|(range, _)| range.start());\n+\n         assert_eq!(expected, actual, \"\\nExpected:\\n{:#?}\\n\\nActual:\\n{:#?}\", expected, actual);\n     }\n \n@@ -1825,4 +2001,42 @@ fn main() {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn hints_sssin_attr_call() {\n+        check(\n+            r#\"\n+fn empty() {}\n+\n+fn no_gpl(a: &()) {}\n+ //^^^^^^<'a>\n+          // ^'a\n+fn empty_gpl<>(a: &()) {}\n+      //    ^'a   ^'a\n+fn partial<'b>(a: &(), b: &'b ()) {}\n+//        ^'a, $  ^'a\n+fn partial<'b>(a: &'b (), b: &()) {}\n+//        ^'a, $             ^'a\n+\n+fn single_ret(a: &()) -> &() {}\n+// ^^^^^^^^^^<'a>\n+              // ^'a     ^'a\n+fn full_mul(a: &(), b: &()) {}\n+// ^^^^^^^^<'a, 'b>\n+            // ^'a     ^'b\n+\n+fn foo<'c>(a: &'c ()) -> &() {}\n+                      // ^'c\n+\n+impl () {\n+    fn foo(&self) -> &() {}\n+    // ^^^<'a>\n+        // ^'a       ^'a\n+    fn foo(&self, a: &()) -> &() {}\n+    // ^^^<'a, 'b>\n+        // ^'a       ^'b     ^'a$\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "7b3fa016a26bd05c8b0c6f34668247ff88442f0d", "filename": "crates/ide/src/static_index.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/673e2b1d8f01e2059c5204b42b12c04b198e30b5/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673e2b1d8f01e2059c5204b42b12c04b198e30b5/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=673e2b1d8f01e2059c5204b42b12c04b198e30b5", "patch": "@@ -110,6 +110,7 @@ impl StaticIndex<'_> {\n                     parameter_hints: true,\n                     chaining_hints: true,\n                     closure_return_type_hints: true,\n+                    lifetime_elision_hints: false,\n                     hide_named_constructor_hints: false,\n                     max_length: Some(25),\n                 },"}, {"sha": "d2b089bb1b4661d74729faa0521b7fcf70201dc5", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/673e2b1d8f01e2059c5204b42b12c04b198e30b5/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673e2b1d8f01e2059c5204b42b12c04b198e30b5/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=673e2b1d8f01e2059c5204b42b12c04b198e30b5", "patch": "@@ -255,6 +255,8 @@ config_data! {\n         inlayHints_chainingHints: bool              = \"true\",\n         /// Whether to show inlay type hints for return types of closures with blocks.\n         inlayHints_closureReturnTypeHints: bool     = \"false\",\n+        /// Whether to show inlay type hints for elided lifetimes in function signatures.\n+        inlayHints_lifetimeElisionHints: bool       = \"false\",\n         /// Whether to hide inlay hints for constructors.\n         inlayHints_hideNamedConstructorHints: bool  = \"false\",\n \n@@ -855,6 +857,7 @@ impl Config {\n             parameter_hints: self.data.inlayHints_parameterHints,\n             chaining_hints: self.data.inlayHints_chainingHints,\n             closure_return_type_hints: self.data.inlayHints_closureReturnTypeHints,\n+            lifetime_elision_hints: self.data.inlayHints_lifetimeElisionHints,\n             hide_named_constructor_hints: self.data.inlayHints_hideNamedConstructorHints,\n             max_length: self.data.inlayHints_maxLength,\n         }"}, {"sha": "976542a4918ae183aa55b1916afeeabc01c47ddc", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/673e2b1d8f01e2059c5204b42b12c04b198e30b5/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673e2b1d8f01e2059c5204b42b12c04b198e30b5/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=673e2b1d8f01e2059c5204b42b12c04b198e30b5", "patch": "@@ -427,27 +427,34 @@ pub(crate) fn inlay_hint(\n         }),\n         position: match inlay_hint.kind {\n             InlayKind::ParameterHint => position(line_index, inlay_hint.range.start()),\n-            InlayKind::ClosureReturnTypeHint | InlayKind::TypeHint | InlayKind::ChainingHint => {\n-                position(line_index, inlay_hint.range.end())\n-            }\n+            InlayKind::ClosureReturnTypeHint\n+            | InlayKind::TypeHint\n+            | InlayKind::ChainingHint\n+            | InlayKind::GenericParamListHint\n+            | InlayKind::LifetimeHint => position(line_index, inlay_hint.range.end()),\n         },\n         kind: match inlay_hint.kind {\n             InlayKind::ParameterHint => Some(lsp_ext::InlayHintKind::PARAMETER),\n             InlayKind::ClosureReturnTypeHint | InlayKind::TypeHint | InlayKind::ChainingHint => {\n                 Some(lsp_ext::InlayHintKind::TYPE)\n             }\n+            InlayKind::GenericParamListHint | InlayKind::LifetimeHint => None,\n         },\n         tooltip: None,\n         padding_left: Some(match inlay_hint.kind {\n             InlayKind::TypeHint => !render_colons,\n             InlayKind::ParameterHint | InlayKind::ClosureReturnTypeHint => false,\n             InlayKind::ChainingHint => true,\n+            InlayKind::GenericParamListHint => false,\n+            InlayKind::LifetimeHint => false,\n         }),\n         padding_right: Some(match inlay_hint.kind {\n             InlayKind::TypeHint | InlayKind::ChainingHint | InlayKind::ClosureReturnTypeHint => {\n                 false\n             }\n             InlayKind::ParameterHint => true,\n+            InlayKind::LifetimeHint => true,\n+            InlayKind::GenericParamListHint => false,\n         }),\n     }\n }"}, {"sha": "4438a12093a63040d9dda06d975b18a5718bd827", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/673e2b1d8f01e2059c5204b42b12c04b198e30b5/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/673e2b1d8f01e2059c5204b42b12c04b198e30b5/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=673e2b1d8f01e2059c5204b42b12c04b198e30b5", "patch": "@@ -306,15 +306,15 @@ fn extract_line_annotations(mut line: &str) -> Vec<LineAnnotation> {\n         let end_marker = line_no_caret.find(|c| c == '$');\n         let next = line_no_caret.find(marker).map_or(line.len(), |it| it + len);\n \n-        let mut content = match end_marker {\n-            Some(end_marker)\n-                if end_marker < next\n-                    && line_no_caret[end_marker..]\n+        let cond = |end_marker| {\n+            end_marker < next\n+                && (line_no_caret[end_marker + 1..].is_empty()\n+                    || line_no_caret[end_marker + 1..]\n                         .strip_prefix(|c: char| c.is_whitespace() || c == '^')\n-                        .is_some() =>\n-            {\n-                &line_no_caret[..end_marker]\n-            }\n+                        .is_some())\n+        };\n+        let mut content = match end_marker {\n+            Some(end_marker) if cond(end_marker) => &line_no_caret[..end_marker],\n             _ => line_no_caret[..next - len].trim_end(),\n         };\n "}]}