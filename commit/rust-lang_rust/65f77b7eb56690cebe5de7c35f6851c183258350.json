{"sha": "65f77b7eb56690cebe5de7c35f6851c183258350", "node_id": "C_kwDOAAsO6NoAKDY1Zjc3YjdlYjU2NjkwY2ViZTVkZTdjMzVmNjg1MWMxODMyNTgzNTA", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-30T09:17:16Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-31T11:21:46Z"}, "message": "Use adt_def for ADT collection.", "tree": {"sha": "7db7917d56fc08bafeae8f88d06229313ea2d678", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7db7917d56fc08bafeae8f88d06229313ea2d678"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65f77b7eb56690cebe5de7c35f6851c183258350", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65f77b7eb56690cebe5de7c35f6851c183258350", "html_url": "https://github.com/rust-lang/rust/commit/65f77b7eb56690cebe5de7c35f6851c183258350", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65f77b7eb56690cebe5de7c35f6851c183258350/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6802e1da380ed6f5cdad0b6b312ad4cfd7f94a3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6802e1da380ed6f5cdad0b6b312ad4cfd7f94a3e", "html_url": "https://github.com/rust-lang/rust/commit/6802e1da380ed6f5cdad0b6b312ad4cfd7f94a3e"}], "stats": {"total": 43, "additions": 20, "deletions": 23}, "files": [{"sha": "81528863c53189b3a6e4e598d4c7f25755fa2d42", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/65f77b7eb56690cebe5de7c35f6851c183258350/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65f77b7eb56690cebe5de7c35f6851c183258350/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=65f77b7eb56690cebe5de7c35f6851c183258350", "patch": "@@ -604,11 +604,11 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n                 }\n             }\n         }\n-        hir::ItemKind::Enum(ref enum_definition, _) => {\n+        hir::ItemKind::Enum(..) => {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().type_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n-            convert_enum_variant_types(tcx, def_id.to_def_id(), enum_definition.variants);\n+            convert_enum_variant_types(tcx, def_id.to_def_id());\n         }\n         hir::ItemKind::Impl { .. } => {\n             tcx.ensure().generics_of(def_id);\n@@ -640,7 +640,8 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n             }\n \n             if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n-                convert_variant_ctor(tcx, ctor_hir_id);\n+                let ctor_def_id = tcx.hir().local_def_id(ctor_hir_id);\n+                convert_variant_ctor(tcx, ctor_def_id);\n             }\n         }\n \n@@ -750,55 +751,51 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::ImplItemId) {\n     }\n }\n \n-fn convert_variant_ctor(tcx: TyCtxt<'_>, ctor_id: hir::HirId) {\n-    let def_id = tcx.hir().local_def_id(ctor_id);\n+fn convert_variant_ctor(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     tcx.ensure().generics_of(def_id);\n     tcx.ensure().type_of(def_id);\n     tcx.ensure().predicates_of(def_id);\n }\n \n-fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId, variants: &[hir::Variant<'_>]) {\n+fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId) {\n     let def = tcx.adt_def(def_id);\n     let repr_type = def.repr().discr_type();\n     let initial = repr_type.initial_discriminant(tcx);\n     let mut prev_discr = None::<Discr<'_>>;\n \n     // fill the discriminant values and field types\n-    for variant in variants {\n+    for variant in def.variants() {\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n         prev_discr = Some(\n-            if let Some(ref e) = variant.disr_expr {\n-                let expr_did = tcx.hir().local_def_id(e.hir_id);\n-                def.eval_explicit_discr(tcx, expr_did.to_def_id())\n+            if let ty::VariantDiscr::Explicit(const_def_id) = variant.discr {\n+                def.eval_explicit_discr(tcx, const_def_id)\n             } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n                 Some(discr)\n             } else {\n-                struct_span_err!(tcx.sess, variant.span, E0370, \"enum discriminant overflowed\")\n-                    .span_label(\n-                        variant.span,\n-                        format!(\"overflowed on value after {}\", prev_discr.unwrap()),\n-                    )\n+                let span = tcx.def_span(variant.def_id);\n+                struct_span_err!(tcx.sess, span, E0370, \"enum discriminant overflowed\")\n+                    .span_label(span, format!(\"overflowed on value after {}\", prev_discr.unwrap()))\n                     .note(&format!(\n                         \"explicitly set `{} = {}` if that is desired outcome\",\n-                        variant.ident, wrapped_discr\n+                        tcx.item_name(variant.def_id),\n+                        wrapped_discr\n                     ))\n                     .emit();\n                 None\n             }\n             .unwrap_or(wrapped_discr),\n         );\n \n-        for f in variant.data.fields() {\n-            let def_id = tcx.hir().local_def_id(f.hir_id);\n-            tcx.ensure().generics_of(def_id);\n-            tcx.ensure().type_of(def_id);\n-            tcx.ensure().predicates_of(def_id);\n+        for f in &variant.fields {\n+            tcx.ensure().generics_of(f.did);\n+            tcx.ensure().type_of(f.did);\n+            tcx.ensure().predicates_of(f.did);\n         }\n \n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n-        if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n-            convert_variant_ctor(tcx, ctor_hir_id);\n+        if let Some(ctor_def_id) = variant.ctor_def_id {\n+            convert_variant_ctor(tcx, ctor_def_id.expect_local());\n         }\n     }\n }"}]}