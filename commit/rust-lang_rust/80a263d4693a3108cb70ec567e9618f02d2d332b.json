{"sha": "80a263d4693a3108cb70ec567e9618f02d2d332b", "node_id": "C_kwDOAAsO6NoAKDgwYTI2M2Q0NjkzYTMxMDhjYjcwZWM1NjdlOTYxOGYwMmQyZDMzMmI", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-11-13T00:12:17Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-11-13T00:12:17Z"}, "message": "Fix `manual_map` suggestion when used with unsafe functions and unsafe blocks.", "tree": {"sha": "fcb6a205b34a43f179436638810ad23e38f141c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcb6a205b34a43f179436638810ad23e38f141c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80a263d4693a3108cb70ec567e9618f02d2d332b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80a263d4693a3108cb70ec567e9618f02d2d332b", "html_url": "https://github.com/rust-lang/rust/commit/80a263d4693a3108cb70ec567e9618f02d2d332b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80a263d4693a3108cb70ec567e9618f02d2d332b/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc9d7fff8fa11665e16823e28140e681c495fc39", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc9d7fff8fa11665e16823e28140e681c495fc39", "html_url": "https://github.com/rust-lang/rust/commit/cc9d7fff8fa11665e16823e28140e681c495fc39"}], "stats": {"total": 139, "additions": 111, "deletions": 28}, "files": [{"sha": "6234932363ffaabddfca9e1a80b7668de12c2d11", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 68, "deletions": 27, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/80a263d4693a3108cb70ec567e9618f02d2d332b/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a263d4693a3108cb70ec567e9618f02d2d332b/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=80a263d4693a3108cb70ec567e9618f02d2d332b", "patch": "@@ -2,7 +2,7 @@ use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n-use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n+use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n use clippy_utils::{\n     can_move_expr_to_closure, in_constant, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id,\n     peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n@@ -11,7 +11,8 @@ use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{\n-    def::Res, Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path, QPath,\n+    def::Res, Arm, BindingAnnotation, Block, BlockCheckMode, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path,\n+    QPath, UnsafeSource,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -93,20 +94,20 @@ impl LateLintPass<'_> for ManualMap {\n             return;\n         }\n \n-        let some_expr = match get_some_expr(cx, some_expr, expr_ctxt) {\n+        let some_expr = match get_some_expr(cx, some_expr, false, expr_ctxt) {\n             Some(expr) => expr,\n             None => return,\n         };\n \n         // These two lints will go back and forth with each other.\n-        if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit\n+        if cx.typeck_results().expr_ty(some_expr.expr) == cx.tcx.types.unit\n             && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n         {\n             return;\n         }\n \n         // `map` won't perform any adjustments.\n-        if !cx.typeck_results().expr_adjustments(some_expr).is_empty() {\n+        if !cx.typeck_results().expr_adjustments(some_expr.expr).is_empty() {\n             return;\n         }\n \n@@ -120,7 +121,7 @@ impl LateLintPass<'_> for ManualMap {\n             None => \"\",\n         };\n \n-        match can_move_expr_to_closure(cx, some_expr) {\n+        match can_move_expr_to_closure(cx, some_expr.expr) {\n             Some(captures) => {\n                 // Check if captures the closure will need conflict with borrows made in the scrutinee.\n                 // TODO: check all the references made in the scrutinee expression. This will require interacting\n@@ -158,12 +159,14 @@ impl LateLintPass<'_> for ManualMap {\n             };\n \n         let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n-            match can_pass_as_func(cx, id, some_expr) {\n-                Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n+            if_chain! {\n+                if !some_expr.needs_unsafe_block;\n+                if let Some(func) = can_pass_as_func(cx, id, some_expr.expr);\n+                if func.span.ctxt() == some_expr.expr.span.ctxt();\n+                then {\n                     snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n-                },\n-                _ => {\n-                    if path_to_local_id(some_expr, id)\n+                } else {\n+                    if path_to_local_id(some_expr.expr, id)\n                         && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n                         && binding_ref.is_some()\n                     {\n@@ -176,21 +179,38 @@ impl LateLintPass<'_> for ManualMap {\n                     } else {\n                         \"\"\n                     };\n-                    format!(\n-                        \"|{}{}| {}\",\n-                        annotation,\n-                        some_binding,\n-                        snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n-                    )\n-                },\n+                    if some_expr.needs_unsafe_block {\n+                        format!(\n+                            \"|{}{}| unsafe {{ {} }}\",\n+                            annotation,\n+                            some_binding,\n+                            snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0\n+                        )\n+                    } else {\n+                        format!(\n+                            \"|{}{}| {}\",\n+                            annotation,\n+                            some_binding,\n+                            snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0\n+                        )\n+                    }\n+                }\n             }\n         } else if !is_wild_none && explicit_ref.is_none() {\n             // TODO: handle explicit reference annotations.\n-            format!(\n-                \"|{}| {}\",\n-                snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n-                snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n-            )\n+            if some_expr.needs_unsafe_block {\n+                format!(\n+                    \"|{}| unsafe {{ {} }}\",\n+                    snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n+                    snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0\n+                )\n+            } else {\n+                format!(\n+                    \"|{}| {}\",\n+                    snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n+                    snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0\n+                )\n+            }\n         } else {\n             // Refutable bindings and mixed reference annotations can't be handled by `map`.\n             return;\n@@ -217,7 +237,9 @@ impl LateLintPass<'_> for ManualMap {\n fn can_pass_as_func(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     match expr.kind {\n         ExprKind::Call(func, [arg])\n-            if path_to_local_id(arg, binding) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n+            if path_to_local_id(arg, binding)\n+                && cx.typeck_results().expr_adjustments(arg).is_empty()\n+                && !type_is_unsafe_function(cx, cx.typeck_results().expr_ty(func).peel_refs()) =>\n         {\n             Some(func)\n         },\n@@ -237,6 +259,11 @@ enum OptionPat<'a> {\n     },\n }\n \n+struct SomeExpr<'tcx> {\n+    expr: &'tcx Expr<'tcx>,\n+    needs_unsafe_block: bool,\n+}\n+\n // Try to parse into a recognized `Option` pattern.\n // i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n@@ -257,7 +284,12 @@ fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxCon\n }\n \n // Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n-fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, ctxt: SyntaxContext) -> Option<&'tcx Expr<'tcx>> {\n+fn get_some_expr(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    needs_unsafe_block: bool,\n+    ctxt: SyntaxContext,\n+) -> Option<SomeExpr<'tcx>> {\n     // TODO: Allow more complex expressions.\n     match expr.kind {\n         ExprKind::Call(\n@@ -266,15 +298,24 @@ fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, ctxt: SyntaxConte\n                 ..\n             },\n             [arg],\n-        ) if ctxt == expr.span.ctxt() && is_lang_ctor(cx, qpath, OptionSome) => Some(arg),\n+        ) if ctxt == expr.span.ctxt() && is_lang_ctor(cx, qpath, OptionSome) => Some(SomeExpr {\n+            expr: arg,\n+            needs_unsafe_block,\n+        }),\n         ExprKind::Block(\n             Block {\n                 stmts: [],\n                 expr: Some(expr),\n+                rules,\n                 ..\n             },\n             _,\n-        ) => get_some_expr(cx, expr, ctxt),\n+        ) => get_some_expr(\n+            cx,\n+            expr,\n+            needs_unsafe_block || *rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n+            ctxt,\n+        ),\n         _ => None,\n     }\n }"}, {"sha": "a004ea79d3b6da4cfde0643bf3f6d73e8acfa88d", "filename": "tests/ui/manual_map_option_2.fixed", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80a263d4693a3108cb70ec567e9618f02d2d332b/tests%2Fui%2Fmanual_map_option_2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/80a263d4693a3108cb70ec567e9618f02d2d332b/tests%2Fui%2Fmanual_map_option_2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.fixed?ref=80a263d4693a3108cb70ec567e9618f02d2d332b", "patch": "@@ -47,4 +47,12 @@ fn main() {\n     let _ = s.as_ref().map(|x| {\n             if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n         });\n+\n+    unsafe fn f(x: u32) -> u32 {\n+        x\n+    }\n+    unsafe {\n+        let _ = Some(0).map(|x| f(x));\n+    }\n+    let _ = Some(0).map(|x| unsafe { f(x) });\n }"}, {"sha": "0119e2bd9981c24b6aa55318b327d15c9019a866", "filename": "tests/ui/manual_map_option_2.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80a263d4693a3108cb70ec567e9618f02d2d332b/tests%2Fui%2Fmanual_map_option_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a263d4693a3108cb70ec567e9618f02d2d332b/tests%2Fui%2Fmanual_map_option_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.rs?ref=80a263d4693a3108cb70ec567e9618f02d2d332b", "patch": "@@ -53,4 +53,18 @@ fn main() {\n         }),\n         None => None,\n     };\n+\n+    unsafe fn f(x: u32) -> u32 {\n+        x\n+    }\n+    unsafe {\n+        let _ = match Some(0) {\n+            Some(x) => Some(f(x)),\n+            None => None,\n+        };\n+    }\n+    let _ = match Some(0) {\n+        Some(x) => unsafe { Some(f(x)) },\n+        None => None,\n+    };\n }"}, {"sha": "a3143638cfc28d3ee50951801ea9679be99ae5f4", "filename": "tests/ui/manual_map_option_2.stderr", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/80a263d4693a3108cb70ec567e9618f02d2d332b/tests%2Fui%2Fmanual_map_option_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/80a263d4693a3108cb70ec567e9618f02d2d332b/tests%2Fui%2Fmanual_map_option_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option_2.stderr?ref=80a263d4693a3108cb70ec567e9618f02d2d332b", "patch": "@@ -39,5 +39,25 @@ LL +             if let Some(ref s) = s { (x.clone(), s) } else { panic!() }\n LL ~         });\n    |\n \n-error: aborting due to 2 previous errors\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option_2.rs:61:17\n+   |\n+LL |           let _ = match Some(0) {\n+   |  _________________^\n+LL | |             Some(x) => Some(f(x)),\n+LL | |             None => None,\n+LL | |         };\n+   | |_________^ help: try this: `Some(0).map(|x| f(x))`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option_2.rs:66:13\n+   |\n+LL |       let _ = match Some(0) {\n+   |  _____________^\n+LL | |         Some(x) => unsafe { Some(f(x)) },\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(|x| unsafe { f(x) })`\n+\n+error: aborting due to 4 previous errors\n "}]}