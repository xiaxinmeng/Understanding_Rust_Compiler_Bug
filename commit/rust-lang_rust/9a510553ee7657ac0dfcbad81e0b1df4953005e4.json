{"sha": "9a510553ee7657ac0dfcbad81e0b1df4953005e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNTEwNTUzZWU3NjU3YWMwZGZjYmFkODFlMGIxZGY0OTUzMDA1ZTQ=", "commit": {"author": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-07-20T20:00:16Z"}, "committer": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-07-20T22:58:16Z"}, "message": "Clarify that sort_unstable is deterministic", "tree": {"sha": "af2d5d9bf1509a3731a312b650a7713825a1f95d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af2d5d9bf1509a3731a312b650a7713825a1f95d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a510553ee7657ac0dfcbad81e0b1df4953005e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a510553ee7657ac0dfcbad81e0b1df4953005e4", "html_url": "https://github.com/rust-lang/rust/commit/9a510553ee7657ac0dfcbad81e0b1df4953005e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a510553ee7657ac0dfcbad81e0b1df4953005e4/comments", "author": null, "committer": null, "parents": [{"sha": "ae98ebfcb9ad5a5384fd229a6ee91315b02ca969", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae98ebfcb9ad5a5384fd229a6ee91315b02ca969", "html_url": "https://github.com/rust-lang/rust/commit/ae98ebfcb9ad5a5384fd229a6ee91315b02ca969"}], "stats": {"total": 33, "additions": 18, "deletions": 15}, "files": [{"sha": "ec7a2b6d0e8d92595fe8154b03e0e7b72887e3d8", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9a510553ee7657ac0dfcbad81e0b1df4953005e4/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a510553ee7657ac0dfcbad81e0b1df4953005e4/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=9a510553ee7657ac0dfcbad81e0b1df4953005e4", "patch": "@@ -1252,12 +1252,13 @@ impl<T> [T] {\n     ///\n     /// # Current implementation\n     ///\n-    /// The current algorithm is based on Orson Peters' [pattern-defeating quicksort][pdqsort],\n-    /// which is a quicksort variant designed to be very fast on certain kinds of patterns,\n-    /// sometimes achieving linear time. It is randomized but deterministic, and falls back to\n-    /// heapsort on degenerate inputs.\n+    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n+    /// which combines the fast average case of randomized quicksort with the fast worst case of\n+    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n+    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n+    /// deterministic behavior.\n     ///\n-    /// It is generally faster than stable sorting, except in a few special cases, e.g. when the\n+    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n     /// slice consists of several concatenated sorted sequences.\n     ///\n     /// # Examples\n@@ -1286,12 +1287,13 @@ impl<T> [T] {\n     ///\n     /// # Current implementation\n     ///\n-    /// The current algorithm is based on Orson Peters' [pattern-defeating quicksort][pdqsort],\n-    /// which is a quicksort variant designed to be very fast on certain kinds of patterns,\n-    /// sometimes achieving linear time. It is randomized but deterministic, and falls back to\n-    /// heapsort on degenerate inputs.\n+    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n+    /// which combines the fast average case of randomized quicksort with the fast worst case of\n+    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n+    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n+    /// deterministic behavior.\n     ///\n-    /// It is generally faster than stable sorting, except in a few special cases, e.g. when the\n+    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n     /// slice consists of several concatenated sorted sequences.\n     ///\n     /// # Examples\n@@ -1323,12 +1325,13 @@ impl<T> [T] {\n     ///\n     /// # Current implementation\n     ///\n-    /// The current algorithm is based on Orson Peters' [pattern-defeating quicksort][pdqsort],\n-    /// which is a quicksort variant designed to be very fast on certain kinds of patterns,\n-    /// sometimes achieving linear time. It is randomized but deterministic, and falls back to\n-    /// heapsort on degenerate inputs.\n+    /// The current algorithm is based on [pattern-defeating quicksort][pdqsort] by Orson Peters,\n+    /// which combines the fast average case of randomized quicksort with the fast worst case of\n+    /// heapsort, while achieving linear time on slices with certain patterns. It uses some\n+    /// randomization to avoid degenerate cases, but with a fixed seed to always provide\n+    /// deterministic behavior.\n     ///\n-    /// It is generally faster than stable sorting, except in a few special cases, e.g. when the\n+    /// It is typically faster than stable sorting, except in a few special cases, e.g. when the\n     /// slice consists of several concatenated sorted sequences.\n     ///\n     /// # Examples"}]}