{"sha": "5b64aab2b60b391cc7c1d7bc4b777d5a2ced8a11", "node_id": "C_kwDOAAsO6NoAKDViNjRhYWIyYjYwYjM5MWNjN2MxZDdiYzRiNzc3ZDVhMmNlZDhhMTE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-06-02T21:39:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-02T21:39:07Z"}, "message": "Rollup merge of #97655 - steffahn:better-pin-box-construction-docs, r=thomcc\n\nImprove documentation for constructors of pinned `Box`es\n\nAdds a cross-references between `Box::pin` and `Box::into_pin` (and other related methods, i.e. the equivalent `From` implementation, and the unstable `pin_in` method), in particular now that `into_pin` [was stabilized](https://github.com/rust-lang/rust/pull/97397). The main goal is to further improve visibility of the fact that `Box<T> -> Pin<Box<T>>` conversion exits in the first place, and that `Box::pin(x)` is \u2013 essentially \u2013 just a convenience function for `Box::into_pin(Box::new(x))`\n\nThe motivating context why I think this is important is even experienced Rust users overlooking the existence this kind of conversion, [e.g. in this thread on IRLO](https://internals.rust-lang.org/t/pre-rfc-function-variants/16732/7?u=steffahn); and also the fact that that discussion brought up that there would be a bunch of Box-construction methods \"missing\" such as e.g. methods with fallible allocation a la \"`Box::try_pin`\", and similar; while those are in fact *not* necessary, because you can use `Box::into_pin(Box::try_new(x)?)` instead.\n\nI have *not* included explicit mention of methods (e.g. `try_new`) in the docs of stable methods (e.g. `into_pin`). (Referring to unstable API in stable API docs would be bad style IMO.) Stable examples I have in mind with the statement \"constructing a (pinned) Box in a different way than with `Box::new`\" are things like cloning a `Box`, or `Box::from_raw`. If/when `try_new` would get stabilized, it would become a very good concrete example use-case of `Box::into_pin` IMO.", "tree": {"sha": "f895e61058cbf6ae02b51b11cbad6aa1219f64b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f895e61058cbf6ae02b51b11cbad6aa1219f64b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b64aab2b60b391cc7c1d7bc4b777d5a2ced8a11", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJimS37CRBK7hj4Ov3rIwAAhg8IAKmW8F5EDd7MxtYSVvv2nZbD\nbJRh3YzyfZNaKJJRpKJw3i4GapbLKmocHmqVkZ5UXNXC21eJ8liRDmrXuv5Zd1jI\nAPEotB5UP9b8amkouTn4wcLpv0EVIY/+k5aLVMRm3RYPH4RMQooWnWb53UCPqqCA\nbCpzonpFZVHlq+2o91s5OR6UIrhs7pr/NeIbsY2jNg+3V4AJU1/W4ZQF8h0uUTiw\nSCbveNC2LGY+Y9Ybl1KS/+9d9eIvWNE9qE9DF1Su2P/xziGdNLozNjChTik/U1Q1\nbbddhWqpmP4CgcJBytNNZdbFp3JsPS/uUfG8YlpiFjVRAqVVNRd52Gxfr8nx9P8=\n=3A2Y\n-----END PGP SIGNATURE-----\n", "payload": "tree f895e61058cbf6ae02b51b11cbad6aa1219f64b3\nparent d1ae3a4c3b331f8734690aac3115689f310a7a29\nparent 6e2ac5df311412a2bae415c3dbef3187e67c2c58\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1654205947 +0200\ncommitter GitHub <noreply@github.com> 1654205947 +0200\n\nRollup merge of #97655 - steffahn:better-pin-box-construction-docs, r=thomcc\n\nImprove documentation for constructors of pinned `Box`es\n\nAdds a cross-references between `Box::pin` and `Box::into_pin` (and other related methods, i.e. the equivalent `From` implementation, and the unstable `pin_in` method), in particular now that `into_pin` [was stabilized](https://github.com/rust-lang/rust/pull/97397). The main goal is to further improve visibility of the fact that `Box<T> -> Pin<Box<T>>` conversion exits in the first place, and that `Box::pin(x)` is \u2013 essentially \u2013 just a convenience function for `Box::into_pin(Box::new(x))`\n\nThe motivating context why I think this is important is even experienced Rust users overlooking the existence this kind of conversion, [e.g. in this thread on IRLO](https://internals.rust-lang.org/t/pre-rfc-function-variants/16732/7?u=steffahn); and also the fact that that discussion brought up that there would be a bunch of Box-construction methods \"missing\" such as e.g. methods with fallible allocation a la \"`Box::try_pin`\", and similar; while those are in fact *not* necessary, because you can use `Box::into_pin(Box::try_new(x)?)` instead.\n\nI have *not* included explicit mention of methods (e.g. `try_new`) in the docs of stable methods (e.g. `into_pin`). (Referring to unstable API in stable API docs would be bad style IMO.) Stable examples I have in mind with the statement \"constructing a (pinned) Box in a different way than with `Box::new`\" are things like cloning a `Box`, or `Box::from_raw`. If/when `try_new` would get stabilized, it would become a very good concrete example use-case of `Box::into_pin` IMO.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b64aab2b60b391cc7c1d7bc4b777d5a2ced8a11", "html_url": "https://github.com/rust-lang/rust/commit/5b64aab2b60b391cc7c1d7bc4b777d5a2ced8a11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b64aab2b60b391cc7c1d7bc4b777d5a2ced8a11/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1ae3a4c3b331f8734690aac3115689f310a7a29", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1ae3a4c3b331f8734690aac3115689f310a7a29", "html_url": "https://github.com/rust-lang/rust/commit/d1ae3a4c3b331f8734690aac3115689f310a7a29"}, {"sha": "6e2ac5df311412a2bae415c3dbef3187e67c2c58", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e2ac5df311412a2bae415c3dbef3187e67c2c58", "html_url": "https://github.com/rust-lang/rust/commit/6e2ac5df311412a2bae415c3dbef3187e67c2c58"}], "stats": {"total": 32, "additions": 28, "deletions": 4}, "files": [{"sha": "cc395759b207859abb78254bb611a3f7d49a3bb8", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5b64aab2b60b391cc7c1d7bc4b777d5a2ced8a11/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b64aab2b60b391cc7c1d7bc4b777d5a2ced8a11/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=5b64aab2b60b391cc7c1d7bc4b777d5a2ced8a11", "patch": "@@ -284,8 +284,13 @@ impl<T> Box<T> {\n         Self::new_zeroed_in(Global)\n     }\n \n-    /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n+    /// Constructs a new `Pin<Box<T>>`. If `T` does not implement [`Unpin`], then\n     /// `x` will be pinned in memory and unable to be moved.\n+    ///\n+    /// Constructing and pinning of the `Box` can also be done in two steps: `Box::pin(x)`\n+    /// does the same as <code>[Box::into_pin]\\([Box::new]\\(x))</code>. Consider using\n+    /// [`into_pin`](Box::into_pin) if you already have a `Box<T>`, or if you want to\n+    /// construct a (pinned) `Box` in a different way than with [`Box::new`].\n     #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[must_use]\n@@ -573,8 +578,13 @@ impl<T, A: Allocator> Box<T, A> {\n         unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }\n     }\n \n-    /// Constructs a new `Pin<Box<T, A>>`. If `T` does not implement `Unpin`, then\n+    /// Constructs a new `Pin<Box<T, A>>`. If `T` does not implement [`Unpin`], then\n     /// `x` will be pinned in memory and unable to be moved.\n+    ///\n+    /// Constructing and pinning of the `Box` can also be done in two steps: `Box::pin_in(x, alloc)`\n+    /// does the same as <code>[Box::into_pin]\\([Box::new_in]\\(x, alloc))</code>. Consider using\n+    /// [`into_pin`](Box::into_pin) if you already have a `Box<T, A>`, or if you want to\n+    /// construct a (pinned) `Box` in a different way than with [`Box::new_in`].\n     #[cfg(not(no_global_oom_handling))]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n@@ -1190,12 +1200,18 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n         unsafe { &mut *mem::ManuallyDrop::new(b).0.as_ptr() }\n     }\n \n-    /// Converts a `Box<T>` into a `Pin<Box<T>>`\n+    /// Converts a `Box<T>` into a `Pin<Box<T>>`. If `T` does not implement [`Unpin`], then\n+    /// `*boxed` will be pinned in memory and unable to be moved.\n     ///\n     /// This conversion does not allocate on the heap and happens in place.\n     ///\n     /// This is also available via [`From`].\n     ///\n+    /// Constructing and pinning a `Box` with <code>Box::into_pin([Box::new]\\(x))</code>\n+    /// can also be written more concisely using <code>[Box::pin]\\(x)</code>.\n+    /// This `into_pin` method is useful if you already have a `Box<T>`, or you are\n+    /// constructing a (pinned) `Box` in a different way than with [`Box::new`].\n+    ///\n     /// # Notes\n     ///\n     /// It's not recommended that crates add an impl like `From<Box<T>> for Pin<T>`,\n@@ -1458,9 +1474,17 @@ impl<T: ?Sized, A: Allocator> const From<Box<T, A>> for Pin<Box<T, A>>\n where\n     A: 'static,\n {\n-    /// Converts a `Box<T>` into a `Pin<Box<T>>`\n+    /// Converts a `Box<T>` into a `Pin<Box<T>>`. If `T` does not implement [`Unpin`], then\n+    /// `*boxed` will be pinned in memory and unable to be moved.\n     ///\n     /// This conversion does not allocate on the heap and happens in place.\n+    ///\n+    /// This is also available via [`Box::into_pin`].\n+    ///\n+    /// Constructing and pinning a `Box` with <code><Pin<Box\\<T>>>::from([Box::new]\\(x))</code>\n+    /// can also be written more concisely using <code>[Box::pin]\\(x)</code>.\n+    /// This `From` implementation is useful if you already have a `Box<T>`, or you are\n+    /// constructing a (pinned) `Box` in a different way than with [`Box::new`].\n     fn from(boxed: Box<T, A>) -> Self {\n         Box::into_pin(boxed)\n     }"}]}