{"sha": "786875824ca6281b87bafb0edff099a3a05f73ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4Njg3NTgyNGNhNjI4MWI4N2JhZmIwZWRmZjA5OWEzYTA1ZjczYWU=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-05-08T02:47:18Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-10T21:43:59Z"}, "message": "Overlap locals that never have storage live at the same time\n\n...and are only included in a single variant.", "tree": {"sha": "9de1a0cd1c82765627a418124d68789c9225409d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9de1a0cd1c82765627a418124d68789c9225409d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/786875824ca6281b87bafb0edff099a3a05f73ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/786875824ca6281b87bafb0edff099a3a05f73ae", "html_url": "https://github.com/rust-lang/rust/commit/786875824ca6281b87bafb0edff099a3a05f73ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/786875824ca6281b87bafb0edff099a3a05f73ae/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9f8bfabf00c477d3430b276bf74b8335c92b82a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f8bfabf00c477d3430b276bf74b8335c92b82a", "html_url": "https://github.com/rust-lang/rust/commit/f9f8bfabf00c477d3430b276bf74b8335c92b82a"}], "stats": {"total": 214, "additions": 201, "deletions": 13}, "files": [{"sha": "208ea224242b18e7c2b42b99bb255770f3152c30", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 201, "deletions": 13, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/786875824ca6281b87bafb0edff099a3a05f73ae/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786875824ca6281b87bafb0edff099a3a05f73ae/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=786875824ca6281b87bafb0edff099a3a05f73ae", "patch": "@@ -14,6 +14,9 @@ use std::ops::Bound;\n \n use crate::hir;\n use crate::ich::StableHashingContext;\n+use crate::mir::GeneratorSavedLocal;\n+use crate::ty::subst::Subst;\n+use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n@@ -612,34 +615,219 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n \n             ty::Generator(def_id, ref substs, _) => {\n-                // FIXME(tmandry): For fields that are repeated in multiple\n-                // variants in the GeneratorLayout, we need code to ensure that\n-                // the offset of these fields never change. Right now this is\n-                // not an issue since every variant has every field, but once we\n-                // optimize this we have to be more careful.\n+                // When laying out generators, we divide our saved local fields\n+                // into two categories: overlap-eligible and overlap-ineligible.\n+                //\n+                // Those fields which are ineligible for overlap go in a\n+                // \"prefix\" at the beginning of the layout, and always have\n+                // space reserved for them.\n+                //\n+                // Overlap-eligible fields are only assigned to one variant, so\n+                // we lay those fields out for each variant and put them right\n+                // after the prefix.\n+                //\n+                // Finally, in the layout details, we point to the fields\n+                // from the variants they are assigned to. It is possible for\n+                // some fields to be included in multiple variants. No field\n+                // ever \"moves around\" in the layout; its offset is always the\n+                // same.\n+                //\n+                // Also included in the layout are the upvars and the\n+                // discriminant. These are included as fields on the \"outer\"\n+                // layout; they are not part of any variant.\n+\n+                let info = tcx.generator_layout(def_id);\n+                let subst_field = |ty: Ty<'tcx>| { ty.subst(tcx, substs.substs) };\n+\n+                #[derive(Clone, Debug, PartialEq)]\n+                enum SavedLocalEligibility {\n+                    Unassigned,\n+                    Assigned(VariantIdx),\n+                    // FIXME: Use newtype_index so we aren't wasting bytes\n+                    Ineligible(Option<u32>),\n+                }\n+                use SavedLocalEligibility::*;\n+\n+                let mut assignments: IndexVec<GeneratorSavedLocal, SavedLocalEligibility> =\n+                    iter::repeat(Unassigned)\n+                    .take(info.field_tys.len())\n+                    .collect();\n+\n+                // The saved locals not eligible for overlap. These will get\n+                // \"promoted\" to the prefix of our generator.\n+                let mut eligible_locals = BitSet::new_filled(info.field_tys.len());\n+\n+                // Figure out which of our saved locals are fields in only\n+                // one variant. The rest are deemed ineligible for overlap.\n+                for (variant_index, fields) in info.variant_fields.iter_enumerated() {\n+                    for local in fields {\n+                        match assignments[*local] {\n+                            Unassigned => {\n+                                assignments[*local] = Assigned(variant_index);\n+                            }\n+                            Assigned(idx) => {\n+                                // We've already seen this local at another suspension\n+                                // point, so it is no longer a candidate.\n+                                trace!(\"removing local {:?} in >1 variant ({:?}, {:?})\",\n+                                       local, variant_index, idx);\n+                                eligible_locals.remove(*local);\n+                                assignments[*local] = Ineligible(None);\n+                            }\n+                            Ineligible(_) => {},\n+                        }\n+                    }\n+                }\n+\n+                // Next, check every pair of eligible locals to see if they\n+                // conflict.\n+                for (local_a, conflicts_a) in info.storage_conflicts.iter_enumerated() {\n+                    if !eligible_locals.contains(local_a) {\n+                        continue;\n+                    }\n+\n+                    for local_b in conflicts_a.iter() {\n+                        // local_a and local_b have overlapping storage, therefore they\n+                        // cannot overlap in the generator layout. The only way to guarantee\n+                        // this is if they are in the same variant, or one is ineligible\n+                        // (which means it is stored in every variant).\n+                        if !eligible_locals.contains(local_b) ||\n+                            assignments[local_a] == assignments[local_b]\n+                        {\n+                            continue;\n+                        }\n+\n+                        // If they conflict, we will choose one to make ineligible.\n+                        let conflicts_b = &info.storage_conflicts[local_b];\n+                        let (remove, other) = if conflicts_a.count() > conflicts_b.count() {\n+                            (local_a, local_b)\n+                        } else {\n+                            (local_b, local_a)\n+                        };\n+                        eligible_locals.remove(remove);\n+                        assignments[remove] = Ineligible(None);\n+                        trace!(\"removing local {:?} due to conflict with {:?}\", remove, other);\n+                    }\n+                }\n+\n+                let mut ineligible_locals = BitSet::new_filled(info.field_tys.len());\n+                ineligible_locals.subtract(&eligible_locals);\n \n+                // Write down the order of our locals that will be promoted to\n+                // the prefix.\n+                for (idx, local) in ineligible_locals.iter().enumerate() {\n+                    assignments[local] = Ineligible(Some(idx as u32));\n+                }\n+                debug!(\"generator saved local assignments: {:?}\", assignments);\n+\n+                // Build a prefix layout, including \"promoting\" all ineligible\n+                // locals as part of the prefix.\n                 let discr_index = substs.prefix_tys(def_id, tcx).count();\n+                let promoted_tys =\n+                    ineligible_locals.iter().map(|local| subst_field(info.field_tys[local]));\n                 let prefix_tys = substs.prefix_tys(def_id, tcx)\n-                    .chain(iter::once(substs.discr_ty(tcx)));\n+                    .chain(iter::once(substs.discr_ty(tcx)))\n+                    .chain(promoted_tys);\n                 let prefix = univariant_uninterned(\n                     &prefix_tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n                     StructKind::AlwaysSized)?;\n+                let (prefix_size, prefix_align) = (prefix.size, prefix.align);\n+\n+                // Split the prefix layout into the \"outer\" fields (upvars and\n+                // discriminant) and the \"promoted\" fields. Promoted fields will\n+                // get included in each variant that requested them in\n+                // GeneratorLayout.\n+                let renumber_indices = |mut index: Vec<u32>| -> Vec<u32> {\n+                    debug!(\"renumber_indices({:?})\", index);\n+                    let mut inverse_index = (0..index.len() as u32).collect::<Vec<_>>();\n+                    inverse_index.sort_unstable_by_key(|i| index[*i as usize]);\n+                    for i in 0..index.len() {\n+                        index[inverse_index[i] as usize] = i as u32;\n+                    }\n+                    debug!(\"renumber_indices() => {:?}\", index);\n+                    index\n+                };\n+                debug!(\"prefix = {:#?}\", prefix);\n+                let (outer_fields, promoted_offsets, promoted_memory_index) = match prefix.fields {\n+                    FieldPlacement::Arbitrary { offsets, memory_index } => {\n+                        let (offsets_a, offsets_b) =\n+                            offsets.split_at(discr_index + 1);\n+                        let (memory_index_a, memory_index_b) =\n+                            memory_index.split_at(discr_index + 1);\n+                        let outer_fields = FieldPlacement::Arbitrary {\n+                            offsets: offsets_a.to_vec(),\n+                            memory_index: renumber_indices(memory_index_a.to_vec())\n+                        };\n+                        (outer_fields,\n+                         offsets_b.to_vec(),\n+                         renumber_indices(memory_index_b.to_vec()))\n+                    }\n+                    _ => bug!(),\n+                };\n \n                 let mut size = prefix.size;\n                 let mut align = prefix.align;\n-                let variants_tys = substs.state_tys(def_id, tcx);\n-                let variants = variants_tys.enumerate().map(|(i, variant_tys)| {\n+                let variants = info.variant_fields.iter_enumerated().map(|(index, variant_fields)| {\n+                    // Only include overlap-eligible fields when we compute our variant layout.\n+                    let variant_only_tys = variant_fields.iter().flat_map(|local| {\n+                        let ty = info.field_tys[*local];\n+                        match assignments[*local] {\n+                            Unassigned => bug!(),\n+                            Assigned(v) if v == index => Some(subst_field(ty)),\n+                            Assigned(_) => bug!(\"assignment does not match variant\"),\n+                            Ineligible(_) => None,\n+                        }\n+                    });\n+\n                     let mut variant = univariant_uninterned(\n-                        &variant_tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+                        &variant_only_tys\n+                            .map(|ty| self.layout_of(ty))\n+                            .collect::<Result<Vec<_>, _>>()?,\n                         &ReprOptions::default(),\n-                        StructKind::Prefixed(prefix.size, prefix.align.abi))?;\n+                        StructKind::Prefixed(prefix_size, prefix_align.abi))?;\n+                    variant.variants = Variants::Single { index };\n \n-                    variant.variants = Variants::Single { index: VariantIdx::new(i) };\n+                    let (offsets, memory_index) = match variant.fields {\n+                        FieldPlacement::Arbitrary { offsets, memory_index } =>\n+                            (offsets, memory_index),\n+                        _ => bug!(),\n+                    };\n+\n+                    // Now, stitch the promoted and variant-only fields back\n+                    // together in the order they are mentioned by our\n+                    // GeneratorLayout.\n+                    let mut next_variant_field = 0;\n+                    let mut combined_offsets = Vec::new();\n+                    let mut combined_memory_index = Vec::new();\n+                    for local in variant_fields.iter() {\n+                        match assignments[*local] {\n+                            Unassigned => bug!(),\n+                            Assigned(_) => {\n+                                combined_offsets.push(offsets[next_variant_field]);\n+                                // Shift memory indices by the number of\n+                                // promoted fields, which all come first. We\n+                                // may not use all promoted fields in our\n+                                // variant but that's okay; we'll renumber them\n+                                // below.\n+                                combined_memory_index.push(\n+                                    promoted_memory_index.len() as u32 +\n+                                    memory_index[next_variant_field]);\n+                                next_variant_field += 1;\n+                            }\n+                            Ineligible(field_idx) => {\n+                                let field_idx = field_idx.unwrap() as usize;\n+                                combined_offsets.push(promoted_offsets[field_idx]);\n+                                combined_memory_index.push(promoted_memory_index[field_idx]);\n+                            }\n+                        }\n+                    }\n+                    variant.fields = FieldPlacement::Arbitrary {\n+                        offsets: combined_offsets,\n+                        memory_index: renumber_indices(combined_memory_index),\n+                    };\n \n                     size = size.max(variant.size);\n                     align = align.max(variant.align);\n-\n                     Ok(variant)\n                 }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n@@ -661,7 +849,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         discr_index,\n                         variants,\n                     },\n-                    fields: prefix.fields,\n+                    fields: outer_fields,\n                     abi,\n                     size,\n                     align,"}]}