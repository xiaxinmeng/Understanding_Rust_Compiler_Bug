{"sha": "6e78d6c9d697217998322ab626cbeee24cdfe228", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNzhkNmM5ZDY5NzIxNzk5ODMyMmFiNjI2Y2JlZWUyNGNkZmUyMjg=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-10T21:34:41Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-17T17:35:33Z"}, "message": "Make the CrateNum part of the ExpnId.", "tree": {"sha": "0f6242e82240bc69adb48880344da2fcd555c5ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f6242e82240bc69adb48880344da2fcd555c5ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e78d6c9d697217998322ab626cbeee24cdfe228", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e78d6c9d697217998322ab626cbeee24cdfe228", "html_url": "https://github.com/rust-lang/rust/commit/6e78d6c9d697217998322ab626cbeee24cdfe228", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e78d6c9d697217998322ab626cbeee24cdfe228/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2d43e132975126dda1364346db8498fbc3917b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2d43e132975126dda1364346db8498fbc3917b0", "html_url": "https://github.com/rust-lang/rust/commit/c2d43e132975126dda1364346db8498fbc3917b0"}], "stats": {"total": 419, "additions": 307, "deletions": 112}, "files": [{"sha": "e1e7d757d7e627e226bbc0aac5f6dd8629848708", "filename": "compiler/rustc_ast/src/node_id.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs?ref=6e78d6c9d697217998322ab626cbeee24cdfe228", "patch": "@@ -1,4 +1,4 @@\n-use rustc_span::ExpnId;\n+use rustc_span::{ExpnId, LocalExpnId};\n use std::fmt;\n \n rustc_index::newtype_index! {\n@@ -25,11 +25,11 @@ pub const DUMMY_NODE_ID: NodeId = NodeId::MAX;\n \n impl NodeId {\n     pub fn placeholder_from_expn_id(expn_id: ExpnId) -> Self {\n-        NodeId::from_u32(expn_id.as_u32())\n+        NodeId::from_u32(expn_id.expect_local().as_u32())\n     }\n \n     pub fn placeholder_to_expn_id(self) -> ExpnId {\n-        ExpnId::from_u32(self.as_u32())\n+        LocalExpnId::from_u32(self.as_u32()).to_expn_id()\n     }\n }\n "}, {"sha": "4b72ac8695794eb3279a32e1f9b7dd51dc47208b", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=6e78d6c9d697217998322ab626cbeee24cdfe228", "patch": "@@ -30,9 +30,10 @@ use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::{self, Ty, TyCtxt, Visibility};\n use rustc_serialize::{opaque, Decodable, Decoder};\n use rustc_session::Session;\n+use rustc_span::hygiene::{ExpnIndex, MacroKind};\n use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n-use rustc_span::{self, hygiene::MacroKind, BytePos, ExpnId, Pos, Span, SyntaxContext, DUMMY_SP};\n+use rustc_span::{self, BytePos, ExpnId, Pos, Span, SyntaxContext, DUMMY_SP};\n \n use proc_macro::bridge::client::ProcMacro;\n use std::io;\n@@ -348,6 +349,12 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for DefIndex {\n     }\n }\n \n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnIndex {\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<ExpnIndex, String> {\n+        Ok(ExpnIndex::from_u32(d.read_u32()?))\n+    }\n+}\n+\n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for SyntaxContext {\n     fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<SyntaxContext, String> {\n         let cdata = decoder.cdata();"}, {"sha": "67023e9e84e22866914bd11d9f92e67ca6ad14c3", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=6e78d6c9d697217998322ab626cbeee24cdfe228", "patch": "@@ -18,11 +18,11 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, Visibility};\n use rustc_session::utils::NativeLibKind;\n use rustc_session::{Session, StableCrateId};\n+use rustc_span::hygiene::{ExpnData, ExpnHash, ExpnId};\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::Symbol;\n \n use rustc_data_structures::sync::Lrc;\n-use rustc_span::ExpnId;\n use smallvec::SmallVec;\n use std::any::Any;\n \n@@ -494,6 +494,23 @@ impl CrateStore for CStore {\n     fn as_any(&self) -> &dyn Any {\n         self\n     }\n+    fn decode_expn_data(&self, sess: &Session, expn_id: ExpnId) -> (ExpnData, ExpnHash) {\n+        let crate_data = self.get_crate_data(expn_id.krate);\n+        (\n+            crate_data\n+                .root\n+                .expn_data\n+                .get(&crate_data, expn_id.local_id)\n+                .unwrap()\n+                .decode((&crate_data, sess)),\n+            crate_data\n+                .root\n+                .expn_hashes\n+                .get(&crate_data, expn_id.local_id)\n+                .unwrap()\n+                .decode((&crate_data, sess)),\n+        )\n+    }\n \n     fn crate_name(&self, cnum: CrateNum) -> Symbol {\n         self.get_crate_data(cnum).root.name"}, {"sha": "4684daef4a18c7801edcfde795174fc8f7ec050d", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=6e78d6c9d697217998322ab626cbeee24cdfe228", "patch": "@@ -31,7 +31,7 @@ use rustc_session::config::CrateType;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span, SyntaxContext};\n use rustc_span::{\n-    hygiene::{HygieneEncodeContext, MacroKind},\n+    hygiene::{ExpnIndex, HygieneEncodeContext, MacroKind},\n     RealFileName,\n };\n use rustc_target::abi::VariantIdx;\n@@ -168,6 +168,12 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for DefIndex {\n     }\n }\n \n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for ExpnIndex {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        s.emit_u32(self.as_u32())\n+    }\n+}\n+\n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for SyntaxContext {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n         rustc_span::hygiene::raw_encode_syntax_context(*self, &s.hygiene_ctxt, s)\n@@ -1588,8 +1594,10 @@ impl EncodeContext<'a, 'tcx> {\n                 Ok(())\n             },\n             |(this, _, expn_data_table, expn_hash_table), index, expn_data, hash| {\n-                expn_data_table.set(index, this.lazy(expn_data));\n-                expn_hash_table.set(index, this.lazy(hash));\n+                if let Some(index) = index.as_local() {\n+                    expn_data_table.set(index.as_raw(), this.lazy(expn_data));\n+                    expn_hash_table.set(index.as_raw(), this.lazy(hash));\n+                }\n                 Ok(())\n             },\n         );"}, {"sha": "a487753f4628a4548275019870d0eaf0c9336982", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=6e78d6c9d697217998322ab626cbeee24cdfe228", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::ty::{self, ReprOptions, Ty};\n use rustc_serialize::opaque::Encoder;\n use rustc_session::config::SymbolManglingVersion;\n use rustc_span::edition::Edition;\n-use rustc_span::hygiene::MacroKind;\n+use rustc_span::hygiene::{ExpnIndex, MacroKind};\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{self, ExpnData, ExpnHash, ExpnId, Span};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n@@ -170,8 +170,8 @@ macro_rules! Lazy {\n }\n \n type SyntaxContextTable = Lazy<Table<u32, Lazy<SyntaxContextData>>>;\n-type ExpnDataTable = Lazy<Table<u32, Lazy<ExpnData>>>;\n-type ExpnHashTable = Lazy<Table<u32, Lazy<ExpnHash>>>;\n+type ExpnDataTable = Lazy<Table<ExpnIndex, Lazy<ExpnData>>>;\n+type ExpnHashTable = Lazy<Table<ExpnIndex, Lazy<ExpnHash>>>;\n \n #[derive(MetadataEncodable, MetadataDecodable)]\n crate struct ProcMacroData {"}, {"sha": "c10fcc2e90c7ea479117389add390e69adf2ad0d", "filename": "compiler/rustc_middle/src/middle/cstore.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs?ref=6e78d6c9d697217998322ab626cbeee24cdfe228", "patch": "@@ -6,12 +6,13 @@ use crate::ty::TyCtxt;\n \n use rustc_ast as ast;\n use rustc_data_structures::sync::{self, MetadataRef};\n-use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_macros::HashStable;\n use rustc_session::search_paths::PathKind;\n use rustc_session::utils::NativeLibKind;\n-use rustc_session::StableCrateId;\n+use rustc_session::Session;\n+use rustc_span::hygiene::{ExpnData, ExpnHash, ExpnId};\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n use rustc_target::spec::Target;\n@@ -187,6 +188,7 @@ pub type MetadataLoaderDyn = dyn MetadataLoader + Sync;\n /// during resolve)\n pub trait CrateStore: std::fmt::Debug {\n     fn as_any(&self) -> &dyn Any;\n+    fn decode_expn_data(&self, sess: &Session, expn_id: ExpnId) -> (ExpnData, ExpnHash);\n \n     // Foreign definitions.\n     // This information is safe to access, since it's hashed as part of the DefPathHash, which incr."}, {"sha": "358d016368ee067c6469f08ebe7a749b92399346", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=6e78d6c9d697217998322ab626cbeee24cdfe228", "patch": "@@ -364,9 +364,12 @@ impl<'sess> OnDiskCache<'sess> {\n                     Ok(())\n                 },\n                 |encoder, index, expn_data, hash| -> FileEncodeResult {\n-                    let pos = AbsoluteBytePos::new(encoder.position());\n-                    encoder.encode_tagged(TAG_EXPN_DATA, &(expn_data, hash))?;\n-                    expn_ids.insert(index, pos);\n+                    if index.krate == LOCAL_CRATE {\n+                        let pos = AbsoluteBytePos::new(encoder.position());\n+                        encoder.encode_tagged(TAG_EXPN_DATA, &(expn_data, hash))?;\n+                        expn_ids.insert(index.local_id.as_u32(), pos);\n+                    }\n+                    // TODO Handle foreign expansions.\n                     Ok(())\n                 },\n             )?;\n@@ -807,6 +810,9 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for ExpnId {\n                     Ok(data)\n                 })\n             },\n+            |this, expn_id| {\n+                Ok(this.tcx.untracked_resolutions.cstore.decode_expn_data(this.tcx.sess, expn_id))\n+            },\n         )\n     }\n }"}, {"sha": "14b6811298261b86f034cc0ae074a8f915f7810b", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 250, "deletions": 95, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=6e78d6c9d697217998322ab626cbeee24cdfe228", "patch": "@@ -29,12 +29,13 @@ use crate::symbol::{kw, sym, Symbol};\n use crate::with_session_globals;\n use crate::{HashStableContext, Span, DUMMY_SP};\n \n-use crate::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use crate::def_id::{CrateNum, DefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_data_structures::unhash::UnhashMap;\n+use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable_Generic;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::fmt;\n@@ -58,9 +59,34 @@ pub struct SyntaxContextData {\n     dollar_crate_name: Symbol,\n }\n \n+rustc_index::newtype_index! {\n+    /// A unique ID associated with a macro invocation and expansion.\n+    pub struct ExpnIndex {\n+        ENCODABLE = custom\n+    }\n+}\n+\n /// A unique ID associated with a macro invocation and expansion.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub struct ExpnId(u32);\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ExpnId {\n+    pub krate: CrateNum,\n+    pub local_id: ExpnIndex,\n+}\n+\n+impl fmt::Debug for ExpnId {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Generate crate_::{{expn_}}.\n+        write!(f, \"{:?}::{{{{expn{}}}}}\", self.krate, self.local_id.private)\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    /// A unique ID associated with a macro invocation and expansion.\n+    pub struct LocalExpnId {\n+        ENCODABLE = custom\n+        DEBUG_FORMAT = \"expn{}\"\n+    }\n+}\n \n /// A unique hash value associated to an expansion.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, Encodable, Decodable, HashStable_Generic)]\n@@ -86,31 +112,103 @@ pub enum Transparency {\n     Opaque,\n }\n \n-impl ExpnId {\n-    pub fn fresh_empty() -> Self {\n+impl LocalExpnId {\n+    /// The ID of the theoretical expansion that generates freshly parsed, unexpanded AST.\n+    pub const ROOT: LocalExpnId = LocalExpnId::from_u32(0);\n+\n+    pub fn from_raw(idx: ExpnIndex) -> LocalExpnId {\n+        LocalExpnId::from_u32(idx.as_u32())\n+    }\n+\n+    pub fn as_raw(self) -> ExpnIndex {\n+        ExpnIndex::from_u32(self.as_u32())\n+    }\n+\n+    pub fn fresh_empty() -> LocalExpnId {\n         HygieneData::with(|data| data.fresh_expn(None))\n     }\n \n-    pub fn fresh(expn_data: ExpnData, ctx: impl HashStableContext) -> Self {\n+    pub fn fresh(expn_data: ExpnData, ctx: impl HashStableContext) -> LocalExpnId {\n+        debug_assert_eq!(expn_data.parent.krate, LOCAL_CRATE);\n         let expn_id = HygieneData::with(|data| data.fresh_expn(Some(expn_data)));\n         update_disambiguator(expn_id, ctx);\n         expn_id\n     }\n \n-    /// The ID of the theoretical expansion that generates freshly parsed, unexpanded AST.\n     #[inline]\n-    pub fn root() -> Self {\n-        ExpnId(0)\n+    pub fn expn_hash(self) -> ExpnHash {\n+        HygieneData::with(|data| data.local_expn_hash(self))\n     }\n \n     #[inline]\n-    pub fn as_u32(self) -> u32 {\n-        self.0\n+    pub fn expn_data(self) -> ExpnData {\n+        HygieneData::with(|data| data.local_expn_data(self).clone())\n+    }\n+\n+    #[inline]\n+    pub fn to_expn_id(self) -> ExpnId {\n+        ExpnId { krate: LOCAL_CRATE, local_id: self.as_raw() }\n+    }\n+\n+    #[inline]\n+    pub fn set_expn_data(self, mut expn_data: ExpnData, ctx: impl HashStableContext) {\n+        debug_assert_eq!(expn_data.parent.krate, LOCAL_CRATE);\n+        HygieneData::with(|data| {\n+            let old_expn_data = &mut data.local_expn_data[self];\n+            assert!(old_expn_data.is_none(), \"expansion data is reset for an expansion ID\");\n+            assert_eq!(expn_data.orig_id, None);\n+            debug_assert_eq!(expn_data.krate, LOCAL_CRATE);\n+            expn_data.orig_id = Some(self.as_u32());\n+            *old_expn_data = Some(expn_data);\n+        });\n+        update_disambiguator(self, ctx)\n+    }\n+\n+    #[inline]\n+    pub fn is_descendant_of(self, ancestor: LocalExpnId) -> bool {\n+        self.to_expn_id().is_descendant_of(ancestor.to_expn_id())\n     }\n \n+    /// `expn_id.outer_expn_is_descendant_of(ctxt)` is equivalent to but faster than\n+    /// `expn_id.is_descendant_of(ctxt.outer_expn())`.\n     #[inline]\n-    pub fn from_u32(raw: u32) -> ExpnId {\n-        ExpnId(raw)\n+    pub fn outer_expn_is_descendant_of(self, ctxt: SyntaxContext) -> bool {\n+        self.to_expn_id().outer_expn_is_descendant_of(ctxt)\n+    }\n+\n+    /// Returns span for the macro which originally caused this expansion to happen.\n+    ///\n+    /// Stops backtracing at include! boundary.\n+    #[inline]\n+    pub fn expansion_cause(self) -> Option<Span> {\n+        self.to_expn_id().expansion_cause()\n+    }\n+\n+    #[inline]\n+    #[track_caller]\n+    pub fn parent(self) -> LocalExpnId {\n+        self.expn_data().parent.as_local().unwrap()\n+    }\n+}\n+\n+impl ExpnId {\n+    /// The ID of the theoretical expansion that generates freshly parsed, unexpanded AST.\n+    /// Invariant: we do not create any ExpnId with local_id == 0 and krate != 0.\n+    pub const fn root() -> ExpnId {\n+        ExpnId { krate: LOCAL_CRATE, local_id: ExpnIndex::from_u32(0) }\n+    }\n+\n+    pub fn fresh_empty() -> ExpnId {\n+        LocalExpnId::fresh_empty().to_expn_id()\n+    }\n+\n+    pub fn fresh(expn_data: ExpnData, ctx: impl HashStableContext) -> ExpnId {\n+        LocalExpnId::fresh(expn_data, ctx).to_expn_id()\n+    }\n+\n+    #[inline]\n+    pub fn set_expn_data(self, expn_data: ExpnData, ctx: impl HashStableContext) {\n+        self.expect_local().set_expn_data(expn_data, ctx)\n     }\n \n     #[inline]\n@@ -124,20 +222,19 @@ impl ExpnId {\n     }\n \n     #[inline]\n-    pub fn expn_data(self) -> ExpnData {\n-        HygieneData::with(|data| data.expn_data(self).clone())\n+    pub fn as_local(self) -> Option<LocalExpnId> {\n+        if self.krate == LOCAL_CRATE { Some(LocalExpnId::from_raw(self.local_id)) } else { None }\n     }\n \n     #[inline]\n-    pub fn set_expn_data(self, mut expn_data: ExpnData, ctx: impl HashStableContext) {\n-        HygieneData::with(|data| {\n-            let old_expn_data = &mut data.expn_data[self.0 as usize];\n-            assert!(old_expn_data.is_none(), \"expansion data is reset for an expansion ID\");\n-            assert_eq!(expn_data.orig_id, None);\n-            expn_data.orig_id = Some(self.as_u32());\n-            *old_expn_data = Some(expn_data);\n-        });\n-        update_disambiguator(self, ctx)\n+    #[track_caller]\n+    pub fn expect_local(self) -> LocalExpnId {\n+        self.as_local().unwrap()\n+    }\n+\n+    #[inline]\n+    pub fn expn_data(self) -> ExpnData {\n+        HygieneData::with(|data| data.expn_data(self).clone())\n     }\n \n     pub fn is_descendant_of(self, ancestor: ExpnId) -> bool {\n@@ -175,8 +272,10 @@ pub struct HygieneData {\n     /// Each expansion should have an associated expansion data, but sometimes there's a delay\n     /// between creation of an expansion ID and obtaining its data (e.g. macros are collected\n     /// first and then resolved later), so we use an `Option` here.\n-    expn_data: Vec<Option<ExpnData>>,\n-    expn_hashes: Vec<ExpnHash>,\n+    local_expn_data: IndexVec<LocalExpnId, Option<ExpnData>>,\n+    local_expn_hashes: IndexVec<LocalExpnId, ExpnHash>,\n+    foreign_expn_data: FxHashMap<ExpnId, ExpnData>,\n+    foreign_expn_hashes: FxHashMap<ExpnId, ExpnHash>,\n     expn_hash_to_expn_id: UnhashMap<ExpnHash, ExpnId>,\n     syntax_context_data: Vec<SyntaxContextData>,\n     syntax_context_map: FxHashMap<(SyntaxContext, ExpnId, Transparency), SyntaxContext>,\n@@ -194,15 +293,17 @@ impl HygieneData {\n             ExpnKind::Root,\n             DUMMY_SP,\n             edition,\n-            Some(DefId::local(CRATE_DEF_INDEX)),\n+            Some(CRATE_DEF_ID.to_def_id()),\n             None,\n         );\n         root_data.orig_id = Some(0);\n \n         HygieneData {\n-            expn_data: vec![Some(root_data)],\n-            expn_hashes: vec![ExpnHash(Fingerprint::ZERO)],\n-            expn_hash_to_expn_id: std::iter::once((ExpnHash(Fingerprint::ZERO), ExpnId(0)))\n+            local_expn_data: IndexVec::from_elem_n(Some(root_data), 1),\n+            local_expn_hashes: IndexVec::from_elem_n(ExpnHash(Fingerprint::ZERO), 1),\n+            foreign_expn_data: FxHashMap::default(),\n+            foreign_expn_hashes: FxHashMap::default(),\n+            expn_hash_to_expn_id: std::iter::once((ExpnHash(Fingerprint::ZERO), ExpnId::root()))\n                 .collect(),\n             syntax_context_data: vec![SyntaxContextData {\n                 outer_expn: ExpnId::root(),\n@@ -221,24 +322,42 @@ impl HygieneData {\n         with_session_globals(|session_globals| f(&mut *session_globals.hygiene_data.borrow_mut()))\n     }\n \n-    fn fresh_expn(&mut self, mut expn_data: Option<ExpnData>) -> ExpnId {\n-        let raw_id = self.expn_data.len() as u32;\n+    fn fresh_expn(&mut self, mut expn_data: Option<ExpnData>) -> LocalExpnId {\n+        let expn_id = self.local_expn_data.next_index();\n         if let Some(data) = expn_data.as_mut() {\n+            debug_assert_eq!(data.krate, LOCAL_CRATE);\n             assert_eq!(data.orig_id, None);\n-            data.orig_id = Some(raw_id);\n+            data.orig_id = Some(expn_id.as_u32());\n         }\n-        self.expn_data.push(expn_data);\n-        self.expn_hashes.push(ExpnHash(Fingerprint::ZERO));\n-        ExpnId(raw_id)\n+        self.local_expn_data.push(expn_data);\n+        let _eid = self.local_expn_hashes.push(ExpnHash(Fingerprint::ZERO));\n+        debug_assert_eq!(expn_id, _eid);\n+        expn_id\n+    }\n+\n+    #[inline]\n+    fn local_expn_hash(&self, expn_id: LocalExpnId) -> ExpnHash {\n+        self.local_expn_hashes[expn_id]\n     }\n \n     #[inline]\n     fn expn_hash(&self, expn_id: ExpnId) -> ExpnHash {\n-        self.expn_hashes[expn_id.0 as usize]\n+        match expn_id.as_local() {\n+            Some(expn_id) => self.local_expn_hashes[expn_id],\n+            None => self.foreign_expn_hashes[&expn_id],\n+        }\n+    }\n+\n+    fn local_expn_data(&self, expn_id: LocalExpnId) -> &ExpnData {\n+        self.local_expn_data[expn_id].as_ref().expect(\"no expansion data for an expansion ID\")\n     }\n \n     fn expn_data(&self, expn_id: ExpnId) -> &ExpnData {\n-        self.expn_data[expn_id.0 as usize].as_ref().expect(\"no expansion data for an expansion ID\")\n+        if let Some(expn_id) = expn_id.as_local() {\n+            self.local_expn_data[expn_id].as_ref().expect(\"no expansion data for an expansion ID\")\n+        } else {\n+            &self.foreign_expn_data[&expn_id]\n+        }\n     }\n \n     fn is_descendant_of(&self, mut expn_id: ExpnId, ancestor: ExpnId) -> bool {\n@@ -453,17 +572,21 @@ pub fn debug_hygiene_data(verbose: bool) -> String {\n         } else {\n             let mut s = String::from(\"\");\n             s.push_str(\"Expansions:\");\n-            data.expn_data.iter().enumerate().for_each(|(id, expn_info)| {\n-                let expn_info = expn_info.as_ref().expect(\"no expansion data for an expansion ID\");\n+            let mut debug_expn_data = |(id, expn_info): (&ExpnId, &ExpnData)| {\n                 s.push_str(&format!(\n-                    \"\\n{}: parent: {:?}, call_site_ctxt: {:?}, def_site_ctxt: {:?}, kind: {:?}\",\n+                    \"\\n{:?}: parent: {:?}, call_site_ctxt: {:?}, def_site_ctxt: {:?}, kind: {:?}\",\n                     id,\n                     expn_info.parent,\n                     expn_info.call_site.ctxt(),\n                     expn_info.def_site.ctxt(),\n                     expn_info.kind,\n-                ));\n+                ))\n+            };\n+            data.local_expn_data.iter_enumerated().for_each(|(id, expn_info)| {\n+                let expn_info = expn_info.as_ref().expect(\"no expansion data for an expansion ID\");\n+                debug_expn_data((&id.to_expn_id(), expn_info))\n             });\n+            data.foreign_expn_data.iter().for_each(debug_expn_data);\n             s.push_str(\"\\n\\nSyntaxContexts:\");\n             data.syntax_context_data.iter().enumerate().for_each(|(id, ctxt)| {\n                 s.push_str(&format!(\n@@ -1024,7 +1147,7 @@ impl HygieneEncodeContext {\n         &self,\n         encoder: &mut T,\n         mut encode_ctxt: impl FnMut(&mut T, u32, &SyntaxContextData) -> Result<(), R>,\n-        mut encode_expn: impl FnMut(&mut T, u32, ExpnData, ExpnHash) -> Result<(), R>,\n+        mut encode_expn: impl FnMut(&mut T, ExpnId, ExpnData, ExpnHash) -> Result<(), R>,\n     ) -> Result<(), R> {\n         // When we serialize a `SyntaxContextData`, we may end up serializing\n         // a `SyntaxContext` that we haven't seen before\n@@ -1051,9 +1174,9 @@ impl HygieneEncodeContext {\n \n             let latest_expns = { std::mem::take(&mut *self.latest_expns.lock()) };\n \n-            for_all_expns_in(latest_expns.into_iter(), |index, expn, data, hash| {\n+            for_all_expns_in(latest_expns.into_iter(), |expn, data, hash| {\n                 if self.serialized_expns.lock().insert(expn) {\n-                    encode_expn(encoder, index, data, hash)?;\n+                    encode_expn(encoder, expn, data, hash)?;\n                 }\n                 Ok(())\n             })?;\n@@ -1073,56 +1196,75 @@ pub struct HygieneDecodeContext {\n     // `SyntaxContext`\n     remapped_ctxts: Lock<Vec<Option<SyntaxContext>>>,\n     // The same as `remapepd_ctxts`, but for `ExpnId`s\n-    remapped_expns: Lock<Vec<Option<ExpnId>>>,\n+    remapped_expns: Lock<Vec<Option<LocalExpnId>>>,\n }\n \n pub fn decode_expn_id_incrcomp<D: Decoder>(\n     d: &mut D,\n     context: &HygieneDecodeContext,\n     decode_data: impl FnOnce(&mut D, u32) -> Result<(ExpnData, ExpnHash), D::Error>,\n+    decode_foreign: impl FnOnce(&mut D, ExpnId) -> Result<(ExpnData, ExpnHash), D::Error>,\n ) -> Result<ExpnId, D::Error> {\n+    let krate = CrateNum::decode(d)?;\n     let index = u32::decode(d)?;\n \n     // Do this after decoding, so that we decode a `CrateNum`\n     // if necessary\n-    if index == ExpnId::root().as_u32() {\n+    if index == 0 {\n         debug!(\"decode_expn_id: deserialized root\");\n         return Ok(ExpnId::root());\n     }\n \n+    if krate != LOCAL_CRATE {\n+        let expn_id = ExpnId { krate, local_id: ExpnIndex::from_u32(index) };\n+        if HygieneData::with(|hygiene_data| hygiene_data.foreign_expn_data.contains_key(&expn_id)) {\n+            return Ok(expn_id);\n+        }\n+        let (expn_data, hash) = decode_foreign(d, expn_id)?;\n+        debug_assert_eq!(krate, expn_data.krate);\n+        debug_assert_eq!(expn_data.orig_id, Some(index));\n+        let expn_id = HygieneData::with(|hygiene_data| {\n+            debug_assert_eq!(expn_data.orig_id, Some(index));\n+            let _old_data = hygiene_data.foreign_expn_data.insert(expn_id, expn_data);\n+            debug_assert!(_old_data.is_none());\n+            let _old_hash = hygiene_data.foreign_expn_hashes.insert(expn_id, hash);\n+            debug_assert!(_old_hash.is_none());\n+            let _old_id = hygiene_data.expn_hash_to_expn_id.insert(hash, expn_id);\n+            debug_assert!(_old_id.is_none());\n+            expn_id\n+        });\n+        return Ok(expn_id);\n+    }\n+\n     let outer_expns = &context.remapped_expns;\n \n     // Ensure that the lock() temporary is dropped early\n     {\n         if let Some(expn_id) = outer_expns.lock().get(index as usize).copied().flatten() {\n-            return Ok(expn_id);\n+            return Ok(expn_id.to_expn_id());\n         }\n     }\n \n     // Don't decode the data inside `HygieneData::with`, since we need to recursively decode\n     // other ExpnIds\n     let (mut expn_data, hash) = decode_data(d, index)?;\n+    debug_assert_eq!(krate, expn_data.krate);\n \n     let expn_id = HygieneData::with(|hygiene_data| {\n-        if let Some(&expn_id) = hygiene_data.expn_hash_to_expn_id.get(&hash) {\n-            return expn_id;\n+        if let Some(expn_id) = hygiene_data.expn_hash_to_expn_id.get(&hash) {\n+            return *expn_id;\n         }\n \n-        let expn_id = ExpnId(hygiene_data.expn_data.len() as u32);\n-\n         // If we just deserialized an `ExpnData` owned by\n         // the local crate, its `orig_id` will be stale,\n         // so we need to update it to its own value.\n         // This only happens when we deserialize the incremental cache,\n         // since a crate will never decode its own metadata.\n-        if expn_data.krate == LOCAL_CRATE {\n-            expn_data.orig_id = Some(expn_id.0);\n-        }\n-\n-        hygiene_data.expn_data.push(Some(expn_data));\n-        hygiene_data.expn_hashes.push(hash);\n-        let _old_id = hygiene_data.expn_hash_to_expn_id.insert(hash, expn_id);\n-        debug_assert!(_old_id.is_none());\n+        let expn_id = hygiene_data.local_expn_data.next_index();\n+        expn_data.orig_id = Some(expn_id.as_u32());\n+        hygiene_data.local_expn_data.push(Some(expn_data));\n+        let _eid = hygiene_data.local_expn_hashes.push(hash);\n+        debug_assert_eq!(expn_id, _eid);\n \n         let mut expns = outer_expns.lock();\n         let new_len = index as usize + 1;\n@@ -1131,46 +1273,53 @@ pub fn decode_expn_id_incrcomp<D: Decoder>(\n         }\n         expns[index as usize] = Some(expn_id);\n         drop(expns);\n+        let expn_id = expn_id.to_expn_id();\n+\n+        let _old_id = hygiene_data.expn_hash_to_expn_id.insert(hash, expn_id);\n+        debug_assert!(_old_id.is_none());\n         expn_id\n     });\n     Ok(expn_id)\n }\n \n pub fn decode_expn_id<D: Decoder>(\n     d: &mut D,\n-    decode_data: impl FnOnce(CrateNum, u32) -> (ExpnData, ExpnHash),\n+    decode_data: impl FnOnce(CrateNum, ExpnIndex) -> (ExpnData, ExpnHash),\n ) -> Result<ExpnId, D::Error> {\n-    let index = u32::decode(d)?;\n     let krate = CrateNum::decode(d)?;\n+    let index = u32::decode(d)?;\n \n     // Do this after decoding, so that we decode a `CrateNum`\n     // if necessary\n-    if index == ExpnId::root().as_u32() {\n+    if index == 0 {\n         debug!(\"decode_expn_id: deserialized root\");\n         return Ok(ExpnId::root());\n     }\n \n+    let index = ExpnIndex::from_u32(index);\n+\n     // This function is used to decode metadata, so it cannot decode information about LOCAL_CRATE.\n     debug_assert_ne!(krate, LOCAL_CRATE);\n+    let expn_id = ExpnId { krate, local_id: index };\n+\n+    // Fast path if the expansion has already been decoded.\n+    if HygieneData::with(|hygiene_data| hygiene_data.foreign_expn_data.contains_key(&expn_id)) {\n+        return Ok(expn_id);\n+    }\n \n     // Don't decode the data inside `HygieneData::with`, since we need to recursively decode\n     // other ExpnIds\n     let (expn_data, hash) = decode_data(krate, index);\n     debug_assert_eq!(krate, expn_data.krate);\n-    debug_assert_eq!(expn_data.orig_id, Some(index));\n-\n-    let expn_id = HygieneData::with(|hygiene_data| {\n-        if let Some(&expn_id) = hygiene_data.expn_hash_to_expn_id.get(&hash) {\n-            return expn_id;\n-        }\n+    debug_assert_eq!(Some(index.as_u32()), expn_data.orig_id);\n \n-        let expn_id = ExpnId(hygiene_data.expn_data.len() as u32);\n-        hygiene_data.expn_data.push(Some(expn_data));\n-        hygiene_data.expn_hashes.push(hash);\n+    HygieneData::with(|hygiene_data| {\n+        let _old_data = hygiene_data.foreign_expn_data.insert(expn_id, expn_data);\n+        debug_assert!(_old_data.is_none());\n+        let _old_hash = hygiene_data.foreign_expn_hashes.insert(expn_id, hash);\n+        debug_assert!(_old_hash.is_none());\n         let _old_id = hygiene_data.expn_hash_to_expn_id.insert(hash, expn_id);\n         debug_assert!(_old_id.is_none());\n-\n-        expn_id\n     });\n \n     Ok(expn_id)\n@@ -1264,29 +1413,37 @@ fn for_all_ctxts_in<E, F: FnMut(u32, SyntaxContext, &SyntaxContextData) -> Resul\n \n fn for_all_expns_in<E>(\n     expns: impl Iterator<Item = ExpnId>,\n-    mut f: impl FnMut(u32, ExpnId, ExpnData, ExpnHash) -> Result<(), E>,\n+    mut f: impl FnMut(ExpnId, ExpnData, ExpnHash) -> Result<(), E>,\n ) -> Result<(), E> {\n     let all_data: Vec<_> = HygieneData::with(|data| {\n         expns\n-            .map(|expn| {\n-                let idx = expn.0 as usize;\n-                (expn, data.expn_data[idx].clone(), data.expn_hashes[idx].clone())\n-            })\n+            .map(|expn| (expn, data.expn_data(expn).clone(), data.expn_hash(expn).clone()))\n             .collect()\n     });\n     for (expn, data, hash) in all_data.into_iter() {\n-        let data = data.unwrap_or_else(|| panic!(\"Missing data for {:?}\", expn));\n-        f(expn.0, expn, data, hash)?;\n+        f(expn, data, hash)?;\n     }\n     Ok(())\n }\n \n+impl<E: Encoder> Encodable<E> for LocalExpnId {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        self.to_expn_id().encode(e)\n+    }\n+}\n+\n impl<E: Encoder> Encodable<E> for ExpnId {\n     default fn encode(&self, _: &mut E) -> Result<(), E::Error> {\n         panic!(\"cannot encode `ExpnId` with `{}`\", std::any::type_name::<E>());\n     }\n }\n \n+impl<D: Decoder> Decodable<D> for LocalExpnId {\n+    fn decode(d: &mut D) -> Result<Self, D::Error> {\n+        ExpnId::decode(d).map(ExpnId::expect_local)\n+    }\n+}\n+\n impl<D: Decoder> Decodable<D> for ExpnId {\n     default fn decode(_: &mut D) -> Result<Self, D::Error> {\n         panic!(\"cannot decode `ExpnId` with `{}`\", std::any::type_name::<D>());\n@@ -1309,34 +1466,32 @@ pub fn raw_encode_expn_id_incrcomp<E: Encoder>(\n     context: &HygieneEncodeContext,\n     e: &mut E,\n ) -> Result<(), E::Error> {\n-    // Record the fact that we need to serialize the corresponding\n-    // `ExpnData`\n+    // Record the fact that we need to serialize the corresponding `ExpnData`\n     if !context.serialized_expns.lock().contains(&expn) {\n         context.latest_expns.lock().insert(expn);\n     }\n-    expn.0.encode(e)\n+    expn.krate.encode(e)?;\n+    expn.local_id.as_u32().encode(e)\n }\n \n pub fn raw_encode_expn_id<E: Encoder>(\n     expn: ExpnId,\n     context: &HygieneEncodeContext,\n     e: &mut E,\n ) -> Result<(), E::Error> {\n-    let data = expn.expn_data();\n     // We only need to serialize the ExpnData\n     // if it comes from this crate.\n     // We currently don't serialize any hygiene information data for\n     // proc-macro crates: see the `SpecializedEncoder<Span>` impl\n     // for crate metadata.\n-    if data.krate == LOCAL_CRATE {\n-        // Record the fact that we need to serialize the corresponding\n-        // `ExpnData`\n+    // Record the fact that we need to serialize the corresponding `ExpnData`\n+    if expn.krate == LOCAL_CRATE {\n         if !context.serialized_expns.lock().contains(&expn) {\n             context.latest_expns.lock().insert(expn);\n         }\n     }\n-    data.orig_id.expect(\"Missing orig_id\").encode(e)?;\n-    data.krate.encode(e)\n+    expn.krate.encode(e)?;\n+    expn.local_id.as_u32().encode(e)\n }\n \n impl<E: Encoder> Encodable<E> for SyntaxContext {\n@@ -1360,7 +1515,7 @@ impl<D: Decoder> Decodable<D> for SyntaxContext {\n /// `set_expn_data`). It is *not* called for foreign `ExpnId`s deserialized\n /// from another crate's metadata - since `ExpnData` includes a `krate` field,\n /// collisions are only possible between `ExpnId`s within the same crate.\n-fn update_disambiguator(expn_id: ExpnId, mut ctx: impl HashStableContext) {\n+fn update_disambiguator(expn_id: LocalExpnId, mut ctx: impl HashStableContext) {\n     let mut expn_data = expn_id.expn_data();\n     // This disambiguator should not have been set yet.\n     assert_eq!(\n@@ -1399,10 +1554,10 @@ fn update_disambiguator(expn_id: ExpnId, mut ctx: impl HashStableContext) {\n \n     let expn_hash = ExpnHash(expn_hash);\n     HygieneData::with(|data| {\n-        data.expn_data[expn_id.0 as usize].as_mut().unwrap().disambiguator = disambiguator;\n-        debug_assert_eq!(data.expn_hashes[expn_id.0 as usize].0, Fingerprint::ZERO);\n-        data.expn_hashes[expn_id.0 as usize] = expn_hash;\n-        let _old_id = data.expn_hash_to_expn_id.insert(expn_hash, expn_id);\n+        data.local_expn_data[expn_id].as_mut().unwrap().disambiguator = disambiguator;\n+        debug_assert_eq!(data.local_expn_hashes[expn_id].0, Fingerprint::ZERO);\n+        data.local_expn_hashes[expn_id] = expn_hash;\n+        let _old_id = data.expn_hash_to_expn_id.insert(expn_hash, expn_id.to_expn_id());\n         debug_assert!(_old_id.is_none());\n     });\n }"}, {"sha": "1c95cc91208d36f2cd0a3c98e42a8e3db9027e03", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e78d6c9d697217998322ab626cbeee24cdfe228/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=6e78d6c9d697217998322ab626cbeee24cdfe228", "patch": "@@ -38,7 +38,7 @@ use edition::Edition;\n pub mod hygiene;\n use hygiene::Transparency;\n pub use hygiene::{DesugaringKind, ExpnKind, ForLoopLoc, MacroKind};\n-pub use hygiene::{ExpnData, ExpnHash, ExpnId, SyntaxContext};\n+pub use hygiene::{ExpnData, ExpnHash, ExpnId, LocalExpnId, SyntaxContext};\n pub mod def_id;\n use def_id::{CrateNum, DefId, DefPathHash, LOCAL_CRATE};\n pub mod lev_distance;"}]}