{"sha": "adb1965c12587bcc24edd62e9ecf1c240f8196cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYjE5NjVjMTI1ODdiY2MyNGVkZDYyZTllY2YxYzI0MGY4MTk2Y2Q=", "commit": {"author": {"name": "Bruno Dutra", "email": "brunocodutra@gmail.com", "date": "2018-08-18T10:14:18Z"}, "committer": {"name": "Bruno Dutra", "email": "brunocodutra@gmail.com", "date": "2018-09-03T18:02:35Z"}, "message": "Introduce Snapshot and SnapshotContext traits", "tree": {"sha": "7decf0d63feec18af0e629a4910e8c6088707621", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7decf0d63feec18af0e629a4910e8c6088707621"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adb1965c12587bcc24edd62e9ecf1c240f8196cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adb1965c12587bcc24edd62e9ecf1c240f8196cd", "html_url": "https://github.com/rust-lang/rust/commit/adb1965c12587bcc24edd62e9ecf1c240f8196cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adb1965c12587bcc24edd62e9ecf1c240f8196cd/comments", "author": {"login": "brunocodutra", "id": 4043663, "node_id": "MDQ6VXNlcjQwNDM2NjM=", "avatar_url": "https://avatars.githubusercontent.com/u/4043663?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brunocodutra", "html_url": "https://github.com/brunocodutra", "followers_url": "https://api.github.com/users/brunocodutra/followers", "following_url": "https://api.github.com/users/brunocodutra/following{/other_user}", "gists_url": "https://api.github.com/users/brunocodutra/gists{/gist_id}", "starred_url": "https://api.github.com/users/brunocodutra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brunocodutra/subscriptions", "organizations_url": "https://api.github.com/users/brunocodutra/orgs", "repos_url": "https://api.github.com/users/brunocodutra/repos", "events_url": "https://api.github.com/users/brunocodutra/events{/privacy}", "received_events_url": "https://api.github.com/users/brunocodutra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brunocodutra", "id": 4043663, "node_id": "MDQ6VXNlcjQwNDM2NjM=", "avatar_url": "https://avatars.githubusercontent.com/u/4043663?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brunocodutra", "html_url": "https://github.com/brunocodutra", "followers_url": "https://api.github.com/users/brunocodutra/followers", "following_url": "https://api.github.com/users/brunocodutra/following{/other_user}", "gists_url": "https://api.github.com/users/brunocodutra/gists{/gist_id}", "starred_url": "https://api.github.com/users/brunocodutra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brunocodutra/subscriptions", "organizations_url": "https://api.github.com/users/brunocodutra/orgs", "repos_url": "https://api.github.com/users/brunocodutra/repos", "events_url": "https://api.github.com/users/brunocodutra/events{/privacy}", "received_events_url": "https://api.github.com/users/brunocodutra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f5c3fde7c5443b8afceaa65aec2b1f62f33e12e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f5c3fde7c5443b8afceaa65aec2b1f62f33e12e", "html_url": "https://github.com/rust-lang/rust/commit/2f5c3fde7c5443b8afceaa65aec2b1f62f33e12e"}], "stats": {"total": 266, "additions": 265, "deletions": 1}, "files": [{"sha": "2bb184cd9bc55c86c7cadac231c859676a87aae0", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 265, "deletions": 1, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/adb1965c12587bcc24edd62e9ecf1c240f8196cd/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb1965c12587bcc24edd62e9ecf1c240f8196cd/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=adb1965c12587bcc24edd62e9ecf1c240f8196cd", "patch": "@@ -1,9 +1,273 @@\n use std::hash::{Hash, Hasher};\n \n use rustc::ich::{StableHashingContext, StableHashingContextProvider};\n+use rustc::mir;\n+use rustc::mir::interpret::{AllocId, Pointer, Scalar, ScalarMaybeUndef, Relocations, Allocation, UndefMask};\n+use rustc::ty;\n+use rustc::ty::layout::Align;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+use syntax::ast::Mutability;\n+use syntax::source_map::Span;\n \n-use super::{Frame, Memory, Machine};\n+use super::eval_context::{LocalValue, StackPopCleanup};\n+use super::{Frame, Memory, Machine, Operand, MemPlace, Place, PlaceExtra, Value};\n+\n+trait SnapshotContext<'a> {\n+    type To;\n+    type From;\n+    fn resolve(&'a self, id: &Self::From) -> Option<&'a Self::To>;\n+}\n+\n+trait Snapshot<'a, Ctx: SnapshotContext<'a>> {\n+    type Item;\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item;\n+}\n+\n+#[derive(Eq, PartialEq)]\n+struct AllocIdSnapshot<'a>(Option<AllocationSnapshot<'a>>);\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for AllocId\n+    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+{\n+    type Item = AllocIdSnapshot<'a>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        AllocIdSnapshot(ctx.resolve(self).map(|alloc| alloc.snapshot(ctx)))\n+    }\n+}\n+\n+type PointerSnapshot<'a> = Pointer<AllocIdSnapshot<'a>>;\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for Pointer\n+    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+{\n+    type Item = PointerSnapshot<'a>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        let Pointer{ alloc_id, offset } = self;\n+\n+        Pointer {\n+            alloc_id: alloc_id.snapshot(ctx),\n+            offset: *offset,\n+        }\n+    }\n+}\n+\n+type ScalarSnapshot<'a> = Scalar<AllocIdSnapshot<'a>>;\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for Scalar\n+    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+{\n+    type Item = ScalarSnapshot<'a>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        match self {\n+            Scalar::Ptr(p) => Scalar::Ptr(p.snapshot(ctx)),\n+            Scalar::Bits{ size, bits } => Scalar::Bits{\n+                size: *size,\n+                bits: *bits,\n+            },\n+        }\n+    }\n+}\n+\n+type ScalarMaybeUndefSnapshot<'a> = ScalarMaybeUndef<AllocIdSnapshot<'a>>;\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for ScalarMaybeUndef\n+    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+{\n+    type Item = ScalarMaybeUndefSnapshot<'a>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        match self {\n+            ScalarMaybeUndef::Scalar(s) => ScalarMaybeUndef::Scalar(s.snapshot(ctx)),\n+            ScalarMaybeUndef::Undef => ScalarMaybeUndef::Undef,\n+        }\n+    }\n+}\n+\n+type MemPlaceSnapshot<'a> = MemPlace<AllocIdSnapshot<'a>>;\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for MemPlace\n+    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+{\n+    type Item = MemPlaceSnapshot<'a>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        let MemPlace{ ptr, extra, align } = self;\n+\n+        MemPlaceSnapshot{\n+            ptr: ptr.snapshot(ctx),\n+            extra: extra.snapshot(ctx),\n+            align: *align,\n+        }\n+    }\n+}\n+\n+type PlaceSnapshot<'a> = Place<AllocIdSnapshot<'a>>;\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n+    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+{\n+    type Item = PlaceSnapshot<'a>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        match self {\n+            Place::Ptr(p) => Place::Ptr(p.snapshot(ctx)),\n+\n+            Place::Local{ frame, local } => Place::Local{\n+                frame: *frame,\n+                local: *local,\n+            },\n+        }\n+    }\n+}\n+\n+type PlaceExtraSnapshot<'a> = PlaceExtra<AllocIdSnapshot<'a>>;\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for PlaceExtra\n+    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+{\n+    type Item = PlaceExtraSnapshot<'a>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        match self {\n+            PlaceExtra::Vtable(p) => PlaceExtra::Vtable(p.snapshot(ctx)),\n+            PlaceExtra::Length(l) => PlaceExtra::Length(*l),\n+            PlaceExtra::None => PlaceExtra::None,\n+        }\n+    }\n+}\n+\n+type ValueSnapshot<'a> = Value<AllocIdSnapshot<'a>>;\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for Value\n+    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+{\n+    type Item = ValueSnapshot<'a>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        match self {\n+            Value::Scalar(s) => Value::Scalar(s.snapshot(ctx)),\n+            Value::ScalarPair(a, b) => Value::ScalarPair(a.snapshot(ctx), b.snapshot(ctx)),\n+        }\n+    }\n+}\n+\n+type OperandSnapshot<'a> = Operand<AllocIdSnapshot<'a>>;\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for Operand\n+    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+{\n+    type Item = OperandSnapshot<'a>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        match self {\n+            Operand::Immediate(v) => Operand::Immediate(v.snapshot(ctx)),\n+            Operand::Indirect(m) => Operand::Indirect(m.snapshot(ctx)),\n+        }\n+    }\n+}\n+\n+type LocalValueSnapshot<'a> = LocalValue<AllocIdSnapshot<'a>>;\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for LocalValue\n+    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+{\n+    type Item = LocalValueSnapshot<'a>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        match self {\n+            LocalValue::Live(v) => LocalValue::Live(v.snapshot(ctx)),\n+            LocalValue::Dead => LocalValue::Dead,\n+        }\n+    }\n+}\n+\n+type RelocationsSnapshot<'a> = Relocations<AllocIdSnapshot<'a>>;\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for Relocations\n+    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+{\n+    type Item = RelocationsSnapshot<'a>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        Relocations::from_presorted(self.iter().map(|(size, id)| (*size, id.snapshot(ctx))).collect())\n+    }\n+}\n+\n+#[derive(Eq, PartialEq)]\n+struct AllocationSnapshot<'a> {\n+    bytes: &'a [u8],\n+    relocations: RelocationsSnapshot<'a>,\n+    undef_mask: &'a UndefMask,\n+    align: &'a Align,\n+    runtime_mutability: &'a Mutability,\n+}\n+\n+impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n+    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+{\n+    type Item = AllocationSnapshot<'a>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        let Allocation { bytes, relocations, undef_mask, align, runtime_mutability } = self;\n+\n+        AllocationSnapshot {\n+            bytes,\n+            undef_mask,\n+            align,\n+            runtime_mutability,\n+            relocations: relocations.snapshot(ctx),\n+        }\n+    }\n+}\n+\n+#[derive(Eq, PartialEq)]\n+struct FrameSnapshot<'a, 'tcx> {\n+    instance: &'a ty::Instance<'tcx>,\n+    span: &'a Span,\n+    return_to_block: &'a StackPopCleanup,\n+    return_place: PlaceSnapshot<'a>,\n+    locals: IndexVec<mir::Local, LocalValueSnapshot<'a>>,\n+    block: &'a mir::BasicBlock,\n+    stmt: usize,\n+}\n+\n+impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n+    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+{\n+    type Item = FrameSnapshot<'a, 'tcx>;\n+\n+    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n+        let Frame {\n+            mir: _,\n+            instance,\n+            span,\n+            return_to_block,\n+            return_place,\n+            locals,\n+            block,\n+            stmt,\n+        } = self;\n+\n+        FrameSnapshot {\n+            instance,\n+            span,\n+            return_to_block,\n+            block,\n+            stmt: *stmt,\n+            return_place: return_place.snapshot(ctx),\n+            locals: locals.iter().map(|local| local.snapshot(ctx)).collect(),\n+        }\n+    }\n+}\n+\n+#[derive(Eq, PartialEq)]\n+struct MemorySnapshot<'a, 'mir: 'a, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx> + 'a> {\n+    data: &'a M::MemoryData,\n+}\n \n /// The virtual machine state during const-evaluation at a given point in time.\n #[derive(Eq, PartialEq)]"}]}