{"sha": "e61a8a94f7762abcd2e77a3108f766d2f5bb1185", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MWE4YTk0Zjc3NjJhYmNkMmU3N2EzMTA4Zjc2NmQyZjViYjExODU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-21T14:28:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-21T14:28:46Z"}, "message": "Apply suggestions from code review\n\nCo-Authored-By: RalfJung <post@ralfj.de>", "tree": {"sha": "d10469c6c8f18537ff17218b893adc5d2131c237", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d10469c6c8f18537ff17218b893adc5d2131c237"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e61a8a94f7762abcd2e77a3108f766d2f5bb1185", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcbrWfCRBK7hj4Ov3rIwAAdHIIALIoPOrSWXI9gS1WlzpZEcVr\nVLcElrzm7SixPCjPRhEYPXhAXSXHirb+NUrprbkZmbXf6sLHEsuEQTxWZmUf3uEK\nGNNSIUx749+5Dk3IU/8OAjVGqbrC3i53m9NfaQTGLQWH1dstlydwG5FbVvDoJzF0\nFyoYLwysmOyjhT8en+Y/DqwX37LI9yMTpKlVOb4n7VvChWO2kQQ0a6BrsGaA19rw\n6gYCyrNEsOiK3wlTQ7STGDKpToewaPfgHlc9G+MgiAcVM9cvziscWFVXZTcLJFtW\nnvuxFarbVDudJlgxEGJGAZd2MX0ruLYwzPhApnhNLEzyhm8wIX81hk66sBF/Z90=\n=89Ls\n-----END PGP SIGNATURE-----\n", "payload": "tree d10469c6c8f18537ff17218b893adc5d2131c237\nparent 59bdb31c890adf726aec2036c3c8170c2e3a1767\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1550759326 +0100\ncommitter GitHub <noreply@github.com> 1550759326 +0100\n\nApply suggestions from code review\n\nCo-Authored-By: RalfJung <post@ralfj.de>"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e61a8a94f7762abcd2e77a3108f766d2f5bb1185", "html_url": "https://github.com/rust-lang/rust/commit/e61a8a94f7762abcd2e77a3108f766d2f5bb1185", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e61a8a94f7762abcd2e77a3108f766d2f5bb1185/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59bdb31c890adf726aec2036c3c8170c2e3a1767", "url": "https://api.github.com/repos/rust-lang/rust/commits/59bdb31c890adf726aec2036c3c8170c2e3a1767", "html_url": "https://github.com/rust-lang/rust/commit/59bdb31c890adf726aec2036c3c8170c2e3a1767"}], "stats": {"total": 81, "additions": 42, "deletions": 39}, "files": [{"sha": "91fd41e97b3f39d0cbcbba42508702be47e59542", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e61a8a94f7762abcd2e77a3108f766d2f5bb1185/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e61a8a94f7762abcd2e77a3108f766d2f5bb1185/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=e61a8a94f7762abcd2e77a3108f766d2f5bb1185", "patch": "@@ -612,7 +612,7 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n /// `Unpin` has no consequence at all for non-pinned data. In particular,\n /// [`mem::replace`] happily moves `!Unpin` data (it works for any `&mut T`, not\n /// just when `T: Unpin`). However, you cannot use\n-/// [`mem::replace`] on data wrapped inside a [`Pin`] because you cannot get the\n+/// [`mem::replace`] on data wrapped inside a [`Pin<P>`] because you cannot get the\n /// `&mut T` you need for that, and *that* is what makes this system work.\n ///\n /// So this, for example, can only be done on types implementing `Unpin`:\n@@ -633,7 +633,7 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n /// This trait is automatically implemented for almost every type.\n ///\n /// [`mem::replace`]: ../../std/mem/fn.replace.html\n-/// [`Pin`]: ../pin/struct.Pin.html\n+ /// [`Pin<P>`]: ../pin/struct.Pin.html\n /// [`pin module`]: ../../std/pin/index.html\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n #[cfg_attr(not(stage0), lang = \"unpin\")]"}, {"sha": "9ce85309565461aeee9b35bde5c691355588eb30", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e61a8a94f7762abcd2e77a3108f766d2f5bb1185/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e61a8a94f7762abcd2e77a3108f766d2f5bb1185/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=e61a8a94f7762abcd2e77a3108f766d2f5bb1185", "patch": "@@ -6,16 +6,16 @@\n //! since moving an object with pointers to itself will invalidate them,\n //! which could cause undefined behavior.\n //!\n-//! [`Pin`] ensures that the pointee of any pointer type has a stable location in memory,\n+//! A [`Pin<P>`] ensures that the pointee of any pointer type `P` has a stable location in memory,\n //! meaning it cannot be moved elsewhere and its memory cannot be deallocated\n //! until it gets dropped. We say that the pointee is \"pinned\".\n //!\n //! By default, all types in Rust are movable. Rust allows passing all types by-value,\n-//! and common smart-pointer types such as `Box` and `&mut` allow replacing and\n-//! moving the values they contain: you can move out of a `Box`, or you can use [`mem::swap`].\n-//! [`Pin`] wraps a pointer type, so `Pin<Box<T>>` functions much like a regular `Box<T>`\n-//! (when a `Pin<Box<T>>` gets dropped, so do its contents, and the memory gets deallocated).\n-//! Similarily, `Pin<&mut T>` is a lot like `&mut T`. However, [`Pin`] does not let clients actually\n+//! and common smart-pointer types such as `Box<T>` and `&mut T` allow replacing and\n+//! moving the values they contain: you can move out of a `Box<T>`, or you can use [`mem::swap`].\n+//! [`Pin<P>`] wraps a pointer type `P`, so `Pin<Box<T>>` functions much like a regular `Box<T>`:\n+//! when a `Pin<Box<T>>` gets dropped, so do its contents, and the memory gets deallocated.\n+//! Similarily, `Pin<&mut T>` is a lot like `&mut T`. However, [`Pin<P>`] does not let clients actually\n //! obtain a `Box<T>` or `&mut T` to pinned data, which implies that you cannot use\n //! operations such as [`mem::swap`]:\n //! ```\n@@ -28,18 +28,18 @@\n //! }\n //! ```\n //!\n-//! It is worth reiterating that [`Pin`] does *not* change the fact that a Rust compiler\n-//! considers all types movable. [`mem::swap`] remains callable for any `T`. Instead, `Pin`\n-//! prevents certain *values* (pointed to by pointers wrapped in `Pin`) from being\n+//! It is worth reiterating that [`Pin<P>`] does *not* change the fact that a Rust compiler\n+//! considers all types movable. [`mem::swap`] remains callable for any `T`. Instead, `Pin<P>`\n+//! prevents certain *values* (pointed to by pointers wrapped in `Pin<P>`) from being\n //! moved by making it impossible to call methods that require `&mut T` on them\n //! (like [`mem::swap`]).\n //!\n-//! [`Pin`] can be used to wrap any pointer type, and as such it interacts with\n+//! [`Pin<P>`] can be used to wrap any pointer type `P`, and as such it interacts with\n //! [`Deref`] and [`DerefMut`]. A `Pin<P>` where `P: Deref` should be considered\n //! as a \"`P`-style pointer\" to a pinned `P::Target` -- so, a `Pin<Box<T>>` is\n //! an owned pointer to a pinned `T`, and a `Pin<Rc<T>>` is a reference-counted\n //! pointer to a pinned `T`.\n-//! For correctness, [`Pin`] relies on the [`Deref`] and [`DerefMut`] implementations\n+//! For correctness, [`Pin<P>`] relies on the [`Deref`] and [`DerefMut`] implementations\n //! to not move out of their `self` parameter, and to only ever return a pointer\n //! to pinned data when they are called on a pinned pointer.\n //!\n@@ -50,11 +50,11 @@\n //! This includes all the basic types (`bool`, `i32` and friends, references)\n //! as well as types consisting solely of these types.\n //! Types that do not care about pinning implement the [`Unpin`] auto-trait, which\n-//! nullifies the effect of [`Pin`]. For `T: Unpin`, `Pin<Box<T>>` and `Box<T>` function\n+//! cancels the effect of [`Pin<P>`]. For `T: Unpin`, `Pin<Box<T>>` and `Box<T>` function\n //! identically, as do `Pin<&mut T>` and `&mut T`.\n //!\n //! Note that pinning and `Unpin` only affect the pointed-to type, not the pointer\n-//! type itself that got wrapped in `Pin`. For example, whether or not `Box<T>` is\n+//! type `P` itself that got wrapped in `Pin<P>`. For example, whether or not `Box<T>` is\n //! `Unpin` has no effect on the behavior of `Pin<Box<T>>` (here, `T` is the\n //! pointed-to type).\n //!\n@@ -120,7 +120,7 @@\n //! and elements can live on a stack frame that lives shorter than the collection does.\n //!\n //! To make this work, every element has pointers to its predecessor and successor in\n-//! the list. Element can only be added when they are pinned, because moving the elements\n+//! the list. Elements can only be added when they are pinned, because moving the elements\n //! around would invalidate the pointers. Moreover, the `Drop` implementation of a linked\n //! list element will patch the pointers of its predecessor and successor to remove itself\n //! from the list.\n@@ -129,17 +129,17 @@\n //! could be deallocated or otherwise invalidated without calling `drop`, the pointers into it\n //! from its neighbouring elements would become invalid, which would break the data structure.\n //!\n-//! This is why pinning also comes with a `drop`-related guarantee.\n+//! Therefore, pinning also comes with a `drop`-related guarantee.\n //!\n //! # `Drop` guarantee\n //!\n //! The purpose of pinning is to be able to rely on the placement of some data in memory.\n-//! To make this work, not just moving the data is restricted; deallocating, repurposing or\n+//! To make this work, not just moving the data is restricted; deallocating, repurposing, or\n //! otherwise invalidating the memory used to store the data is restricted, too.\n //! Concretely, for pinned data you have to maintain the invariant\n //! that *its memory will not get invalidated from the moment it gets pinned until\n //! when `drop` is called*. Memory can be invalidated by deallocation, but also by\n-//! replacing a `Some(v)` by `None`, or calling `Vec::set_len` to \"kill\" some elements\n+//! replacing a [`Some(v)`] by [`None`], or calling [`Vec::set_len`] to \"kill\" some elements\n //! off of a vector.\n //!\n //! This is exactly the kind of guarantee that the intrusive linked list from the previous\n@@ -174,7 +174,7 @@\n //! One interesting question arises when considering the interaction of pinning and\n //! the fields of a struct. When can a struct have a \"pinning projection\", i.e.,\n //! an operation with type `fn(Pin<&[mut] Struct>) -> Pin<&[mut] Field>`?\n-//! In a similar vein, when can a generic wrapper type (such as `Vec`, `Box`, or `RefCell`)\n+//! In a similar vein, when can a generic wrapper type (such as `Vec<T>`, `Box<T>`, or `RefCell<T>`)\n //! have an operation with type `fn(Pin<&[mut] Wrapper<T>>) -> Pin<&[mut] T>`?\n //!\n //! Having a pinning projection for some field means that pinning is \"structural\":\n@@ -199,7 +199,7 @@\n //! 3.  You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n //!     once your wrapper is pinned, the memory that contains the\n //!     content is not overwritten or deallocated without calling the content's destructors.\n-//!     This can be tricky, as witnessed by `VecDeque`: the destructor of `VecDeque` can fail\n+//!     This can be tricky, as witnessed by `VecDeque<T>`: the destructor of `VecDeque<T>` can fail\n //!     to call `drop` on all elements if one of the destructors panics. This violates the\n //!     `Drop` guarantee, because it can lead to elements being deallocated without\n //!     their destructor being called. (`VecDeque` has no pinning projections, so this\n@@ -208,31 +208,31 @@\n //!     the fields when your type is pinned. For example, if the wrapper contains an\n //!     `Option<T>` and there is a `take`-like operation with type\n //!     `fn(Pin<&mut Wrapper<T>>) -> Option<T>`,\n-//!     that operation can be used to move a `T` out of a pinned `Wrapper` -- which means\n+//!     that operation can be used to move a `T` out of a pinned `Wrapper<T>` -- which means\n //!     pinning cannot be structural.\n //!\n-//!     For a more complex example of moving data out of a pinnd type, imagine if `RefCell`\n+//!     For a more complex example of moving data out of a pinned type, imagine if `RefCell<T>`\n //!     had a method `fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>`.\n //!     Then we could do the following:\n //!     ```compile_fail\n //!     fn exploit_ref_cell<T>(rc: Pin<&mut RefCell<T>) {\n-//!         { let p = rc.as_mut().get_pin_mut(); } // here we get pinned access to the `T`\n+//!         { let p = rc.as_mut().get_pin_mut(); } // Here we get pinned access to the `T`.\n //!         let rc_shr: &RefCell<T> = rc.into_ref().get_ref();\n //!         let b = rc_shr.borrow_mut();\n-//!         let content = &mut *b; // and here we have `&mut T` to the same data\n+//!         let content = &mut *b; // And here we have `&mut T` to the same data.\n //!     }\n //!     ```\n-//!     This is catastrophic, it means we can first pin the content of the `RefCell`\n+//!     This is catastrophic, it means we can first pin the content of the `RefCell<T>`\n //!     (using `RefCell::get_pin_mut`) and then move that content using the mutable\n //!     reference we got later.\n //!\n-//! For a type like `Vec`, both possibilites (structural pinning or not) make sense,\n-//! and the choice is up to the author. A `Vec` with structural pinning could\n+//! For a type like `Vec<T>`, both possibilites (structural pinning or not) make sense,\n+//! and the choice is up to the author. A `Vec<T>` with structural pinning could\n //! have `get_pin`/`get_pin_mut` projections. However, it could *not* allow calling\n-//! `pop` on a pinned `Vec` because that would move the (structurally pinned) contents!\n+//! `pop` on a pinned `Vec<T>` because that would move the (structurally pinned) contents!\n //! Nor could it allow `push`, which might reallocate and thus also move the contents.\n-//! A `Vec` without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents\n-//! are never pinned and the `Vec` itself is fine with being moved as well.\n+//! A `Vec<T>` without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents\n+//! are never pinned and the `Vec<T>` itself is fine with being moved as well.\n //!\n //! In the standard library, pointer types generally do not have structural pinning,\n //! and thus they do not offer pinning projections. This is why `Box<T>: Unpin` holds for all `T`.\n@@ -244,13 +244,16 @@\n //! whether the content is pinned is entirely independent of whether the pointer is\n //! pinned, meaning pinning is *not* structural.\n //!\n-//! [`Pin`]: struct.Pin.html\n+//! [`Pin<P>`]: struct.Pin.html\n //! [`Unpin`]: ../../std/marker/trait.Unpin.html\n //! [`Deref`]: ../../std/ops/trait.Deref.html\n //! [`DerefMut`]: ../../std/ops/trait.DerefMut.html\n //! [`mem::swap`]: ../../std/mem/fn.swap.html\n //! [`mem::forget`]: ../../std/mem/fn.forget.html\n-//! [`Box`]: ../../std/boxed/struct.Box.html\n+//! [`Box<T>`]: ../../std/boxed/struct.Box.html\n+//! [`Vec::set_len`]: ../../std/vec/struct.Vec.html#method.set_len\n+//! [`None`]: ../../std/option/enum.Option.html#variant.None\n+//! [`Some(v)`]: ../../std/option/enum.Option.html#variant.Some\n //! [drop-impl]: #drop-implementation\n //! [drop-guarantee]: #drop-guarantee\n \n@@ -328,11 +331,11 @@ impl<P: Deref> Pin<P>\n where\n     P::Target: Unpin,\n {\n-    /// Construct a new `Pin` around a pointer to some data of a type that\n+    /// Construct a new `Pin<P>` around a pointer to some data of a type that\n     /// implements [`Unpin`].\n     ///\n     /// Unlike `Pin::new_unchecked`, this method is safe because the pointer\n-    /// `P` dereferences to an [`Unpin`] type, which nullifies the pinning guarantees.\n+    /// `P` dereferences to an [`Unpin`] type, which cancels the pinning guarantees.\n     ///\n     /// [`Unpin`]: ../../std/marker/trait.Unpin.html\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -345,7 +348,7 @@ where\n }\n \n impl<P: Deref> Pin<P> {\n-    /// Construct a new `Pin` around a reference to some data of a type that\n+    /// Construct a new `Pin<P>` around a reference to some data of a type that\n     /// may or may not implement `Unpin`.\n     ///\n     /// If `pointer` dereferences to an `Unpin` type, `Pin::new` should be used\n@@ -379,13 +382,13 @@ impl<P: Deref> Pin<P> {\n     /// fn move_pinned_ref<T>(mut a: T, mut b: T) {\n     ///     unsafe { let p = Pin::new_unchecked(&mut a); } // should mean `a` can never move again\n     ///     mem::swap(&mut a, &mut b);\n-    ///     // the address of `a` changed to `b`'s stack slot, so `a` got moved even\n+    ///     // The address of `a` changed to `b`'s stack slot, so `a` got moved even\n     ///     // though we have previously pinned it!\n     /// }\n     /// ```\n     /// A value, once pinned, must remain pinned forever (unless its type implements `Unpin`).\n     ///\n-    /// Similarily, calling `Pin::new_unchecked` on a `Rc<T>` is unsafe because there could be\n+    /// Similarily, calling `Pin::new_unchecked` on an `Rc<T>` is unsafe because there could be\n     /// aliases to the same data that are not subject to the pinning restrictions:\n     /// ```\n     /// use std::rc::Rc;\n@@ -482,7 +485,7 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     /// It may seem like there is an issue here with interior mutability: in fact,\n     /// it *is* possible to move a `T` out of a `&RefCell<T>`. However, this is\n     /// not a problem as long as there does not also exist a `Pin<&T>` pointing\n-    /// to the same data, and `RefCell` does not let you create a pinned reference\n+    /// to the same data, and `RefCell<T>` does not let you create a pinned reference\n     /// to its contents. See the discussion on [\"pinning projections\"] for further\n     /// details.\n     ///"}]}