{"sha": "cdf178f776371bb0320769f95810c3c4fa668404", "node_id": "C_kwDOAAsO6NoAKGNkZjE3OGY3NzYzNzFiYjAzMjA3NjlmOTU4MTBjM2M0ZmE2Njg0MDQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-04-01T04:59:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-01T04:59:44Z"}, "message": "Rollup merge of #95388 - RalfJung:rust-val-limit, r=oli-obk\n\ninterpret: make isize::MAX the limit for dynamic value sizes\n\nWe are currently enforcing `data_layout.obj_size_bound()` as the maximal dynamic size of a Rust value (including for `size_of_val_raw`), but that does not match the docs.\n\nIn particular, Miri currently falsely says that this code has UB:\n```rust\n#![feature(layout_for_ptr)]\nfn main() {\n    let size = isize::MAX as usize;\n    // Creating a raw slice of size isize::MAX and asking for its size is okay.\n    let s = std::ptr::slice_from_raw_parts(1usize as *const u8, size);\n    assert_eq!(size, unsafe { std::mem::size_of_val_raw(s) });\n}\n```", "tree": {"sha": "36a08f5a44ac652bec46989148e3d43528b79d1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36a08f5a44ac652bec46989148e3d43528b79d1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdf178f776371bb0320769f95810c3c4fa668404", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiRobACRBK7hj4Ov3rIwAALKcIAE1IDM4WMaOOXUnmOPgwEyI6\nbluvirpZC7dO9l/2mNmHTh0OEPhiyFmLQQHlJZX/MDkAKW0KMjbKGgH+rtS1s0Lw\nL7HHX4fU0wh/BCswqdtERpqgDeeNzR/uTp+j84R2bG32pGnTtetQHYTO4vtmdEqb\njPbdT8wqZ0dtsSrsCy65FzRkY7YjQLukj5uDRT0qXPUV8xfB3qVjJX9r1Jq+3fVm\n+0LXIBP1WN3czUi/M4KONfbD/DMs/ptKDFYKwQoK3U9HINQvqWQbSIIPuIptfzoT\nSBoE/HLida40KAAZCkDjOzJci+xiQiYcskTkTKvW17Aa0ydgjjrZxNDr2f51IkY=\n=J8sQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 36a08f5a44ac652bec46989148e3d43528b79d1c\nparent 40be7d3d487ca89460f5298baa4e678a016d39cf\nparent cb0d15b0904aacc8f6106a68e17d234d466a027e\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1648789184 +0200\ncommitter GitHub <noreply@github.com> 1648789184 +0200\n\nRollup merge of #95388 - RalfJung:rust-val-limit, r=oli-obk\n\ninterpret: make isize::MAX the limit for dynamic value sizes\n\nWe are currently enforcing `data_layout.obj_size_bound()` as the maximal dynamic size of a Rust value (including for `size_of_val_raw`), but that does not match the docs.\n\nIn particular, Miri currently falsely says that this code has UB:\n```rust\n#![feature(layout_for_ptr)]\nfn main() {\n    let size = isize::MAX as usize;\n    // Creating a raw slice of size isize::MAX and asking for its size is okay.\n    let s = std::ptr::slice_from_raw_parts(1usize as *const u8, size);\n    assert_eq!(size, unsafe { std::mem::size_of_val_raw(s) });\n}\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdf178f776371bb0320769f95810c3c4fa668404", "html_url": "https://github.com/rust-lang/rust/commit/cdf178f776371bb0320769f95810c3c4fa668404", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdf178f776371bb0320769f95810c3c4fa668404/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40be7d3d487ca89460f5298baa4e678a016d39cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/40be7d3d487ca89460f5298baa4e678a016d39cf", "html_url": "https://github.com/rust-lang/rust/commit/40be7d3d487ca89460f5298baa4e678a016d39cf"}, {"sha": "cb0d15b0904aacc8f6106a68e17d234d466a027e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb0d15b0904aacc8f6106a68e17d234d466a027e", "html_url": "https://github.com/rust-lang/rust/commit/cb0d15b0904aacc8f6106a68e17d234d466a027e"}], "stats": {"total": 147, "additions": 95, "deletions": 52}, "files": [{"sha": "1b8186b5aadbace598262cae23a4f7141c40f1fd", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cdf178f776371bb0320769f95810c3c4fa668404/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf178f776371bb0320769f95810c3c4fa668404/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=cdf178f776371bb0320769f95810c3c4fa668404", "patch": "@@ -23,8 +23,8 @@ use rustc_target::abi::{call::FnAbi, Align, HasDataLayout, Size, TargetDataLayou\n \n use super::{\n     AllocCheck, AllocId, GlobalId, Immediate, InterpErrorInfo, InterpResult, MPlaceTy, Machine,\n-    MemPlace, MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, Pointer, Provenance,\n-    Scalar, ScalarMaybeUninit, StackPopJump,\n+    MemPlace, MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, Pointer,\n+    PointerArithmetic, Provenance, Scalar, ScalarMaybeUninit, StackPopJump,\n };\n use crate::transform::validate::equal_up_to_regions;\n \n@@ -678,7 +678,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let size = size.align_to(align);\n \n                 // Check if this brought us over the size limit.\n-                if size.bytes() >= self.tcx.data_layout.obj_size_bound() {\n+                if size > self.max_size_of_val() {\n                     throw_ub!(InvalidMeta(\"total size is bigger than largest supported object\"));\n                 }\n                 Ok(Some((size, align)))\n@@ -694,9 +694,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let elem = layout.field(self, 0);\n \n                 // Make sure the slice is not too big.\n-                let size = elem.size.checked_mul(len, self).ok_or_else(|| {\n-                    err_ub!(InvalidMeta(\"slice is bigger than largest supported object\"))\n-                })?;\n+                let size = elem.size.bytes().saturating_mul(len); // we rely on `max_size_of_val` being smaller than `u64::MAX`.\n+                let size = Size::from_bytes(size);\n+                if size > self.max_size_of_val() {\n+                    throw_ub!(InvalidMeta(\"slice is bigger than largest supported object\"));\n+                }\n                 Ok(Some((size, elem.align.abi)))\n             }\n "}, {"sha": "c80d7d71787422ced418d9ea410c8c012ecd81cb", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdf178f776371bb0320769f95810c3c4fa668404/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf178f776371bb0320769f95810c3c4fa668404/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=cdf178f776371bb0320769f95810c3c4fa668404", "patch": "@@ -531,7 +531,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, Pointer<Option<M::PointerTag>>> {\n         // We cannot overflow i64 as a type's size must be <= isize::MAX.\n         let pointee_size = i64::try_from(self.layout_of(pointee_ty)?.size.bytes()).unwrap();\n-        // The computed offset, in bytes, cannot overflow an isize.\n+        // The computed offset, in bytes, must not overflow an isize.\n+        // `checked_mul` enforces a too small bound, but no actual allocation can be big enough for\n+        // the difference to be noticeable.\n         let offset_bytes =\n             offset_count.checked_mul(pointee_size).ok_or(err_ub!(PointerArithOverflow))?;\n         // The offset being in bounds cannot rely on \"wrapping around\" the address space.\n@@ -563,6 +565,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let count = self.read_scalar(&count)?.to_machine_usize(self)?;\n         let layout = self.layout_of(src.layout.ty.builtin_deref(true).unwrap().ty)?;\n         let (size, align) = (layout.size, layout.align.abi);\n+        // `checked_mul` enforces a too small bound (the correct one would probably be machine_isize_max),\n+        // but no actual allocation can be big enough for the difference to be noticeable.\n         let size = size.checked_mul(count, self).ok_or_else(|| {\n             err_ub_format!(\n                 \"overflow computing total size of `{}`\",\n@@ -588,6 +592,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let byte = self.read_scalar(&byte)?.to_u8()?;\n         let count = self.read_scalar(&count)?.to_machine_usize(self)?;\n \n+        // `checked_mul` enforces a too small bound (the correct one would probably be machine_isize_max),\n+        // but no actual allocation can be big enough for the difference to be noticeable.\n         let len = layout\n             .size\n             .checked_mul(count, self)"}, {"sha": "fc60a40e2ada6253881d91284c8fea91b833ae95", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cdf178f776371bb0320769f95810c3c4fa668404/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf178f776371bb0320769f95810c3c4fa668404/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=cdf178f776371bb0320769f95810c3c4fa668404", "patch": "@@ -110,16 +110,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .read_ptr_sized(pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_SIZE).unwrap())?\n             .check_init()?;\n         let size = size.to_machine_usize(self)?;\n+        let size = Size::from_bytes(size);\n         let align = vtable\n             .read_ptr_sized(pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_ALIGN).unwrap())?\n             .check_init()?;\n         let align = align.to_machine_usize(self)?;\n         let align = Align::from_bytes(align).map_err(|e| err_ub!(InvalidVtableAlignment(e)))?;\n \n-        if size >= self.tcx.data_layout.obj_size_bound() {\n+        if size > self.max_size_of_val() {\n             throw_ub!(InvalidVtableSize);\n         }\n-        Ok((Size::from_bytes(size), align))\n+        Ok((size, align))\n     }\n \n     pub fn read_new_vtable_after_trait_upcasting_from_vtable("}, {"sha": "813c0912f539679db80f57d1ec455580c0ccb1de", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cdf178f776371bb0320769f95810c3c4fa668404/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf178f776371bb0320769f95810c3c4fa668404/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=cdf178f776371bb0320769f95810c3c4fa668404", "patch": "@@ -18,6 +18,11 @@ pub trait PointerArithmetic: HasDataLayout {\n         self.data_layout().pointer_size\n     }\n \n+    #[inline(always)]\n+    fn max_size_of_val(&self) -> Size {\n+        Size::from_bytes(self.machine_isize_max())\n+    }\n+\n     #[inline]\n     fn machine_usize_max(&self) -> u64 {\n         self.pointer_size().unsigned_int_max().try_into().unwrap()"}, {"sha": "46901bd3b9b349b378b0e0c164d8d87e0d534d9b", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.32bit.stderr", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cdf178f776371bb0320769f95810c3c4fa668404/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cdf178f776371bb0320769f95810c3c4fa668404/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr?ref=cdf178f776371bb0320769f95810c3c4fa668404", "patch": "@@ -104,6 +104,17 @@ LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:71:1\n    |\n+LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257e\u2500allocN\u2500\u257c ff ff ff 7f                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:74:1\n+   |\n LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n@@ -113,7 +124,7 @@ LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:74:1\n+  --> $DIR/ub-wide-ptr.rs:77:1\n    |\n LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling box (going beyond the bounds of its allocation)\n@@ -124,7 +135,7 @@ LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999us\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:77:1\n+  --> $DIR/ub-wide-ptr.rs:80:1\n    |\n LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n@@ -135,7 +146,7 @@ LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:81:1\n+  --> $DIR/ub-wide-ptr.rs:84:1\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>[0]: encountered 0x03, but expected a boolean\n@@ -146,29 +157,29 @@ LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:87:1\n+  --> $DIR/ub-wide-ptr.rs:90:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.0: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500allocN\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257eallocN\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:90:1\n+  --> $DIR/ub-wide-ptr.rs:93:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.1[0]: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n-               \u257e\u2500allocN\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+               \u257eallocN\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:97:1\n+  --> $DIR/ub-wide-ptr.rs:100:1\n    |\n LL | / const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n LL | |\n@@ -183,7 +194,7 @@ LL | | };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:105:1\n+  --> $DIR/ub-wide-ptr.rs:108:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered too small vtable\n@@ -194,7 +205,7 @@ LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:108:1\n+  --> $DIR/ub-wide-ptr.rs:111:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered too small vtable\n@@ -205,7 +216,7 @@ LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:111:1\n+  --> $DIR/ub-wide-ptr.rs:114:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered dangling vtable pointer in wide pointer\n@@ -216,7 +227,7 @@ LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:113:1\n+  --> $DIR/ub-wide-ptr.rs:116:1\n    |\n LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered unaligned vtable pointer in wide pointer\n@@ -227,7 +238,7 @@ LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:115:1\n+  --> $DIR/ub-wide-ptr.rs:118:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -238,7 +249,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:117:1\n+  --> $DIR/ub-wide-ptr.rs:120:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -249,7 +260,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:119:1\n+  --> $DIR/ub-wide-ptr.rs:122:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -260,7 +271,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::trans\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:123:1\n+  --> $DIR/ub-wide-ptr.rs:126:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n@@ -271,7 +282,7 @@ LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_,\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:127:1\n+  --> $DIR/ub-wide-ptr.rs:130:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling vtable pointer in wide pointer\n@@ -282,7 +293,7 @@ LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:129:1\n+  --> $DIR/ub-wide-ptr.rs:132:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered too small vtable\n@@ -293,17 +304,17 @@ LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transm\n            }\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:135:5\n+  --> $DIR/ub-wide-ptr.rs:138:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: null pointer is not a valid pointer\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:139:5\n+  --> $DIR/ub-wide-ptr.rs:142:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: allocN has size N, so pointer to 12 bytes starting at offset N is out-of-bounds\n \n-error: aborting due to 28 previous errors\n+error: aborting due to 29 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "b76f88928678ae8ffffdd1ffd40e8479c6314e9a", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.64bit.stderr", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cdf178f776371bb0320769f95810c3c4fa668404/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cdf178f776371bb0320769f95810c3c4fa668404/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr?ref=cdf178f776371bb0320769f95810c3c4fa668404", "patch": "@@ -104,6 +104,17 @@ LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:71:1\n    |\n+LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid reference metadata: slice is bigger than largest supported object\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c ff ff ff ff ff ff ff 7f \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:74:1\n+   |\n LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n@@ -113,7 +124,7 @@ LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:74:1\n+  --> $DIR/ub-wide-ptr.rs:77:1\n    |\n LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling box (going beyond the bounds of its allocation)\n@@ -124,7 +135,7 @@ LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999us\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:77:1\n+  --> $DIR/ub-wide-ptr.rs:80:1\n    |\n LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n@@ -135,7 +146,7 @@ LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:81:1\n+  --> $DIR/ub-wide-ptr.rs:84:1\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>[0]: encountered 0x03, but expected a boolean\n@@ -146,29 +157,29 @@ LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:87:1\n+  --> $DIR/ub-wide-ptr.rs:90:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.0: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:90:1\n+  --> $DIR/ub-wide-ptr.rs:93:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.1[0]: encountered 0x03, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n-               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:97:1\n+  --> $DIR/ub-wide-ptr.rs:100:1\n    |\n LL | / const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n LL | |\n@@ -183,7 +194,7 @@ LL | | };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:105:1\n+  --> $DIR/ub-wide-ptr.rs:108:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered too small vtable\n@@ -194,7 +205,7 @@ LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:108:1\n+  --> $DIR/ub-wide-ptr.rs:111:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered too small vtable\n@@ -205,7 +216,7 @@ LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:111:1\n+  --> $DIR/ub-wide-ptr.rs:114:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered dangling vtable pointer in wide pointer\n@@ -216,7 +227,7 @@ LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:113:1\n+  --> $DIR/ub-wide-ptr.rs:116:1\n    |\n LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered unaligned vtable pointer in wide pointer\n@@ -227,7 +238,7 @@ LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:115:1\n+  --> $DIR/ub-wide-ptr.rs:118:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -238,7 +249,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:117:1\n+  --> $DIR/ub-wide-ptr.rs:120:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -249,7 +260,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:119:1\n+  --> $DIR/ub-wide-ptr.rs:122:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .0: encountered invalid drop function pointer in vtable (not pointing to a function)\n@@ -260,7 +271,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::trans\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:123:1\n+  --> $DIR/ub-wide-ptr.rs:126:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n@@ -271,7 +282,7 @@ LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_,\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:127:1\n+  --> $DIR/ub-wide-ptr.rs:130:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling vtable pointer in wide pointer\n@@ -282,7 +293,7 @@ LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:129:1\n+  --> $DIR/ub-wide-ptr.rs:132:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered too small vtable\n@@ -293,17 +304,17 @@ LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transm\n            }\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:135:5\n+  --> $DIR/ub-wide-ptr.rs:138:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: null pointer is not a valid pointer\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:139:5\n+  --> $DIR/ub-wide-ptr.rs:142:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: allocN has size N, so pointer to 24 bytes starting at offset N is out-of-bounds\n \n-error: aborting due to 28 previous errors\n+error: aborting due to 29 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "ea48a095df95c53ab7f61a134147c80c63aa7ee9", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cdf178f776371bb0320769f95810c3c4fa668404/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf178f776371bb0320769f95810c3c4fa668404/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=cdf178f776371bb0320769f95810c3c4fa668404", "patch": "@@ -67,6 +67,9 @@ const SLICE_LENGTH_UNINIT: &[u8] = unsafe {\n // bad slice: length too big\n const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n //~^ ERROR it is undefined behavior to use this value\n+// bad slice: length computation overflows\n+const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n+//~^ ERROR it is undefined behavior to use this value\n // bad slice: length not an int\n const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n //~^ ERROR it is undefined behavior to use this value"}, {"sha": "5a78313c483504849499f4a03719aab3a4b14011", "filename": "src/test/ui/consts/const-size_of_val-align_of_val.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cdf178f776371bb0320769f95810c3c4fa668404/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of_val-align_of_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf178f776371bb0320769f95810c3c4fa668404/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of_val-align_of_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of_val-align_of_val.rs?ref=cdf178f776371bb0320769f95810c3c4fa668404", "patch": "@@ -2,8 +2,9 @@\n \n #![feature(const_size_of_val, const_align_of_val)]\n #![feature(const_size_of_val_raw, const_align_of_val_raw, layout_for_ptr)]\n+#![feature(const_slice_from_raw_parts)]\n \n-use std::mem;\n+use std::{mem, ptr};\n \n struct Foo(u32);\n \n@@ -34,6 +35,8 @@ const ALIGN_OF_UGH: usize = mem::align_of_val(&UGH);\n const SIZE_OF_SLICE: usize = mem::size_of_val(\"foobar\".as_bytes());\n \n const SIZE_OF_DANGLING: usize = unsafe { mem::size_of_val_raw(0x100 as *const i32) };\n+const SIZE_OF_BIG: usize =\n+    unsafe { mem::size_of_val_raw(ptr::slice_from_raw_parts(0 as *const u8, isize::MAX as usize)) };\n const ALIGN_OF_DANGLING: usize = unsafe { mem::align_of_val_raw(0x100 as *const i16) };\n \n fn main() {\n@@ -46,6 +49,7 @@ fn main() {\n     assert_eq!(ALIGN_OF_UGH, mem::align_of::<Ugh>());\n \n     assert_eq!(SIZE_OF_DANGLING, mem::size_of::<i32>());\n+    assert_eq!(SIZE_OF_BIG, isize::MAX as usize);\n     assert_eq!(ALIGN_OF_DANGLING, mem::align_of::<i16>());\n \n     assert_eq!(SIZE_OF_SLICE, \"foobar\".len());"}]}