{"sha": "654e3345e535913653a2bad4204c31f9ccedb3c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1NGUzMzQ1ZTUzNTkxMzY1M2EyYmFkNDIwNGMzMWY5Y2NlZGIzYzQ=", "commit": {"author": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-06-20T04:34:26Z"}, "committer": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-06-27T11:34:34Z"}, "message": "Change miri to use tcx allocated allocations.", "tree": {"sha": "9c6fd74b4ebb57a294f90c202771484be0c5d8a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c6fd74b4ebb57a294f90c202771484be0c5d8a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/654e3345e535913653a2bad4204c31f9ccedb3c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/654e3345e535913653a2bad4204c31f9ccedb3c4", "html_url": "https://github.com/rust-lang/rust/commit/654e3345e535913653a2bad4204c31f9ccedb3c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/654e3345e535913653a2bad4204c31f9ccedb3c4/comments", "author": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "committer": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5b7511a6ccf241ba2ce6ad0b04e79f1e3d85686", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5b7511a6ccf241ba2ce6ad0b04e79f1e3d85686", "html_url": "https://github.com/rust-lang/rust/commit/a5b7511a6ccf241ba2ce6ad0b04e79f1e3d85686"}], "stats": {"total": 65, "additions": 36, "deletions": 29}, "files": [{"sha": "801e4b1e47850c5f99e9f0c09645eb8c8daba9f3", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/654e3345e535913653a2bad4204c31f9ccedb3c4/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/654e3345e535913653a2bad4204c31f9ccedb3c4/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=654e3345e535913653a2bad4204c31f9ccedb3c4", "patch": "@@ -2,7 +2,6 @@ use std::cell::Cell;\n use std::fmt;\n use std::mem;\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::{self as hir, def_id::DefId, definitions::DefPathData};\n use rustc_index::vec::IndexVec;\n@@ -40,10 +39,6 @@ pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n \n     /// The virtual memory system.\n     pub memory: Memory<'mir, 'tcx, M>,\n-\n-    /// A cache for deduplicating vtables\n-    pub(super) vtables:\n-        FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), Pointer<M::PointerTag>>,\n }\n \n // The Phantomdata exists to prevent this type from being `Send`. If it were sent across a thread\n@@ -393,7 +388,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             tcx: tcx.at(root_span),\n             param_env,\n             memory: Memory::new(tcx, memory_extra),\n-            vtables: FxHashMap::default(),\n         }\n     }\n "}, {"sha": "d5fec457fa19eb3d067f6247c4236d06991dcd7d", "filename": "compiler/rustc_mir/src/interpret/intern.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/654e3345e535913653a2bad4204c31f9ccedb3c4/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/654e3345e535913653a2bad4204c31f9ccedb3c4/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs?ref=654e3345e535913653a2bad4204c31f9ccedb3c4", "patch": "@@ -107,7 +107,6 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval:\n     match kind {\n         MemoryKind::Stack\n         | MemoryKind::Machine(const_eval::MemoryKind::Heap)\n-        | MemoryKind::Vtable\n         | MemoryKind::CallerLocation => {}\n     }\n     // Set allocation mutability as appropriate. This is used by LLVM to put things into"}, {"sha": "94506808a68c3fffd64c2222028a32160947b36b", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/654e3345e535913653a2bad4204c31f9ccedb3c4/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/654e3345e535913653a2bad4204c31f9ccedb3c4/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=654e3345e535913653a2bad4204c31f9ccedb3c4", "patch": "@@ -27,8 +27,6 @@ use crate::util::pretty;\n pub enum MemoryKind<T> {\n     /// Stack memory. Error if deallocated except during a stack pop.\n     Stack,\n-    /// Memory backing vtables. Error if ever deallocated.\n-    Vtable,\n     /// Memory allocated by `caller_location` intrinsic. Error if ever deallocated.\n     CallerLocation,\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones.\n@@ -40,7 +38,6 @@ impl<T: MayLeak> MayLeak for MemoryKind<T> {\n     fn may_leak(self) -> bool {\n         match self {\n             MemoryKind::Stack => false,\n-            MemoryKind::Vtable => true,\n             MemoryKind::CallerLocation => true,\n             MemoryKind::Machine(k) => k.may_leak(),\n         }\n@@ -51,7 +48,6 @@ impl<T: fmt::Display> fmt::Display for MemoryKind<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             MemoryKind::Stack => write!(f, \"stack variable\"),\n-            MemoryKind::Vtable => write!(f, \"vtable\"),\n             MemoryKind::CallerLocation => write!(f, \"caller location\"),\n             MemoryKind::Machine(m) => write!(f, \"{}\", m),\n         }"}, {"sha": "aea9933b337c995398f15f243a0ebd1673a19919", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/654e3345e535913653a2bad4204c31f9ccedb3c4/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/654e3345e535913653a2bad4204c31f9ccedb3c4/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=654e3345e535913653a2bad4204c31f9ccedb3c4", "patch": "@@ -459,7 +459,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 // Find and consult vtable\n                 let vtable = receiver_place.vtable();\n-                let drop_fn = self.get_vtable_slot(vtable, u64::try_from(idx).unwrap())?;\n+                let fn_val = self.get_vtable_slot(vtable, u64::try_from(idx).unwrap())?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we\n                 // want for args[0]: We have to project to field 0 because we want\n@@ -472,7 +472,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     OpTy::from(ImmTy::from_immediate(receiver_place.ptr.into(), this_receiver_ptr));\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(drop_fn, caller_abi, &args, ret, unwind)\n+                self.eval_fn_call(fn_val, caller_abi, &args, ret, unwind)\n             }\n         }\n     }"}, {"sha": "539d767d62ad502df8801dd2fc0f5c9f4b60931b", "filename": "compiler/rustc_mir/src/interpret/traits.rs", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/654e3345e535913653a2bad4204c31f9ccedb3c4/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/654e3345e535913653a2bad4204c31f9ccedb3c4/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs?ref=654e3345e535913653a2bad4204c31f9ccedb3c4", "patch": "@@ -1,14 +1,29 @@\n use std::convert::TryFrom;\n \n-use rustc_middle::mir::interpret::{InterpResult, Pointer, PointerArithmetic, Scalar};\n+use rustc_middle::mir::interpret::{\n+    AllocError, InterpError, InterpResult, Pointer, PointerArithmetic, Scalar,\n+    UndefinedBehaviorInfo, UnsupportedOpInfo,\n+};\n use rustc_middle::ty::{\n     self, Instance, Ty, VtblEntry, COMMON_VTABLE_ENTRIES, COMMON_VTABLE_ENTRIES_ALIGN,\n     COMMON_VTABLE_ENTRIES_DROPINPLACE, COMMON_VTABLE_ENTRIES_SIZE,\n };\n use rustc_target::abi::{Align, LayoutOf, Size};\n \n+use super::alloc_range;\n use super::util::ensure_monomorphic_enough;\n-use super::{FnVal, InterpCx, Machine, MemoryKind};\n+use super::{Allocation, FnVal, InterpCx, Machine};\n+\n+fn vtable_alloc_error_to_interp_error<'tcx>(error: AllocError) -> InterpError<'tcx> {\n+    match error {\n+        AllocError::ReadPointerAsBytes => {\n+            InterpError::Unsupported(UnsupportedOpInfo::ReadPointerAsBytes)\n+        }\n+        AllocError::InvalidUninitBytes(_info) => {\n+            InterpError::UndefinedBehavior(UndefinedBehaviorInfo::InvalidUninitBytes(None))\n+        }\n+    }\n+}\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n@@ -60,10 +75,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // `get_vtable` in `rust_codegen_llvm/meth.rs`.\n         // /////////////////////////////////////////////////////////////////////////////////////////\n         let vtable_size = ptr_size * u64::try_from(vtable_entries.len()).unwrap();\n-        let vtable = self.memory.allocate(vtable_size, ptr_align, MemoryKind::Vtable);\n-\n-        let drop = Instance::resolve_drop_in_place(tcx, ty);\n-        let drop = self.memory.create_fn_alloc(FnVal::Instance(drop));\n+        let mut vtable = Allocation::uninit(vtable_size, ptr_align);\n \n         // No need to do any alignment checks on the memory accesses below, because we know the\n         // allocation is correctly aligned as we created it above. Also we're only offsetting by\n@@ -72,36 +84,42 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .iter()\n             .map(|entry| -> InterpResult<'tcx, _> {\n                 match entry {\n-                    VtblEntry::MetadataDropInPlace => Ok(Some(drop.into())),\n+                    VtblEntry::MetadataDropInPlace => {\n+                        let instance = Instance::resolve_drop_in_place(tcx, ty);\n+                        let fn_alloc_id = tcx.create_fn_alloc(instance);\n+                        let fn_ptr = Pointer::from(fn_alloc_id);\n+                        Ok(Some(fn_ptr.into()))\n+                    }\n                     VtblEntry::MetadataSize => Ok(Some(Scalar::from_uint(size, ptr_size).into())),\n                     VtblEntry::MetadataAlign => Ok(Some(Scalar::from_uint(align, ptr_size).into())),\n                     VtblEntry::Vacant => Ok(None),\n                     VtblEntry::Method(def_id, substs) => {\n                         // Prepare the fn ptr we write into the vtable.\n                         let instance =\n-                            ty::Instance::resolve_for_vtable(tcx, self.param_env, *def_id, substs)\n+                            Instance::resolve_for_vtable(tcx, self.param_env, *def_id, substs)\n                                 .ok_or_else(|| err_inval!(TooGeneric))?;\n-                        let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n+                        let fn_alloc_id = tcx.create_fn_alloc(instance);\n+                        let fn_ptr = Pointer::from(fn_alloc_id);\n                         Ok(Some(fn_ptr.into()))\n                     }\n                 }\n             })\n             .collect::<Result<Vec<_>, _>>()?;\n-        let mut vtable_alloc =\n-            self.memory.get_mut(vtable.into(), vtable_size, ptr_align)?.expect(\"not a ZST\");\n         for (idx, scalar) in scalars.into_iter().enumerate() {\n             if let Some(scalar) = scalar {\n                 let idx: u64 = u64::try_from(idx).unwrap();\n-                vtable_alloc.write_ptr_sized(ptr_size * idx, scalar)?;\n+                vtable\n+                    .write_scalar(self, alloc_range(ptr_size * idx, ptr_size), scalar)\n+                    .map_err(vtable_alloc_error_to_interp_error)?;\n             }\n         }\n \n-        M::after_static_mem_initialized(self, vtable, vtable_size)?;\n+        let vtable_id = tcx.create_memory_alloc(tcx.intern_const_alloc(vtable));\n+        let vtable_ptr = self.memory.global_base_pointer(Pointer::from(vtable_id))?;\n \n-        self.memory.mark_immutable(vtable.alloc_id)?;\n-        assert!(self.vtables.insert((ty, poly_trait_ref), vtable).is_none());\n+        assert!(self.vtables.insert((ty, poly_trait_ref), vtable_ptr).is_none());\n \n-        Ok(vtable)\n+        Ok(vtable_ptr)\n     }\n \n     /// Resolves the function at the specified slot in the provided"}]}