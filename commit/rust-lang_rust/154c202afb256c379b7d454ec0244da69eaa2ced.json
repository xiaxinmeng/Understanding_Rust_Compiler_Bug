{"sha": "154c202afb256c379b7d454ec0244da69eaa2ced", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NGMyMDJhZmIyNTZjMzc5YjdkNDU0ZWMwMjQ0ZGE2OWVhYTJjZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-27T22:13:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-27T22:13:41Z"}, "message": "Auto merge of #37057 - brson:nosuggest, r=nikomatsakis\n\nrustc: Remove all \"consider using an explicit lifetime parameter\" suggestions\n\nThese give so many incorrect suggestions that having them is\ndetrimental to the user experience. The compiler should not be\nsuggesting changes to the code that are wrong - it is infuriating: not\nonly is the compiler telling you that _you don't understand_ borrowing,\n_the compiler itself_ appears to not understand borrowing. It does not\ninspire confidence.\n\nr? @nikomatsakis", "tree": {"sha": "f31d24ce9e30da7a0c7261132a3cec0e43ec0a38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f31d24ce9e30da7a0c7261132a3cec0e43ec0a38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/154c202afb256c379b7d454ec0244da69eaa2ced", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/154c202afb256c379b7d454ec0244da69eaa2ced", "html_url": "https://github.com/rust-lang/rust/commit/154c202afb256c379b7d454ec0244da69eaa2ced", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/154c202afb256c379b7d454ec0244da69eaa2ced/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62a72586775fc0bfe38f4e43bf3aca52a31c6921", "url": "https://api.github.com/repos/rust-lang/rust/commits/62a72586775fc0bfe38f4e43bf3aca52a31c6921", "html_url": "https://github.com/rust-lang/rust/commit/62a72586775fc0bfe38f4e43bf3aca52a31c6921"}, {"sha": "a2735c02493d816835a19249dd258e0c678530d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2735c02493d816835a19249dd258e0c678530d0", "html_url": "https://github.com/rust-lang/rust/commit/a2735c02493d816835a19249dd258e0c678530d0"}], "stats": {"total": 897, "additions": 4, "deletions": 893}, "files": [{"sha": "2489a6a6c7a6304e46d552a86112f2ce68d15a22", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 714, "changes": 718, "blob_url": "https://github.com/rust-lang/rust/blob/154c202afb256c379b7d454ec0244da69eaa2ced/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c202afb256c379b7d454ec0244da69eaa2ced/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=154c202afb256c379b7d454ec0244da69eaa2ced", "patch": "@@ -55,8 +55,6 @@\n //! ported to this system, and which relies on string concatenation at the\n //! time of error detection.\n \n-use self::FreshOrKept::*;\n-\n use super::InferCtxt;\n use super::TypeTrace;\n use super::SubregionOrigin;\n@@ -71,13 +69,10 @@ use super::region_inference::ProcessedErrors;\n use super::region_inference::ProcessedErrorOrigin;\n use super::region_inference::SameRegions;\n \n-use std::collections::HashSet;\n-\n use hir::map as hir_map;\n use hir;\n \n use lint;\n-use hir::def::Def;\n use hir::def_id::DefId;\n use infer;\n use middle::region;\n@@ -86,13 +81,9 @@ use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, ReFree};\n use ty::error::TypeError;\n \n-use std::cell::{Cell, RefCell};\n-use std::char::from_u32;\n use std::fmt;\n use syntax::ast;\n-use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n-use syntax_pos::{self, Pos, Span};\n+use syntax_pos::{Pos, Span};\n use errors::DiagnosticBuilder;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -292,7 +283,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ProcessedErrors(ref origins,\n                                 ref same_regions) => {\n                     if !same_regions.is_empty() {\n-                        self.report_processed_errors(origins, same_regions);\n+                        self.report_processed_errors(origins);\n                     }\n                 }\n             }\n@@ -1050,88 +1041,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn report_processed_errors(&self,\n-                               origins: &[ProcessedErrorOrigin<'tcx>],\n-                               same_regions: &[SameRegions]) {\n-        for (i, origin) in origins.iter().enumerate() {\n+                               origins: &[ProcessedErrorOrigin<'tcx>]) {\n+        for origin in origins.iter() {\n             let mut err = match *origin {\n                 ProcessedErrorOrigin::VariableFailure(ref var_origin) =>\n                     self.report_inference_failure(var_origin.clone()),\n                 ProcessedErrorOrigin::ConcreteFailure(ref sr_origin, sub, sup) =>\n                     self.report_concrete_failure(sr_origin.clone(), sub, sup),\n             };\n \n-            // attach the suggestion to the last such error\n-            if i == origins.len() - 1 {\n-                self.give_suggestion(&mut err, same_regions);\n-            }\n-\n             err.emit();\n         }\n     }\n \n-    fn give_suggestion(&self, err: &mut DiagnosticBuilder, same_regions: &[SameRegions]) {\n-        let scope_id = same_regions[0].scope_id;\n-        let parent = self.tcx.hir.get_parent(scope_id);\n-        let parent_node = self.tcx.hir.find(parent);\n-        let taken = lifetimes_in_scope(self.tcx, scope_id);\n-        let life_giver = LifeGiver::with_taken(&taken[..]);\n-        let node_inner = match parent_node {\n-            Some(ref node) => match *node {\n-                hir_map::NodeItem(ref item) => {\n-                    match item.node {\n-                        hir::ItemFn(ref fn_decl, unsafety, constness, _, ref gen, body) => {\n-                            Some((fn_decl, gen, unsafety, constness, item.name, item.span, body))\n-                        }\n-                        _ => None,\n-                    }\n-                }\n-                hir_map::NodeImplItem(item) => {\n-                    let id = self.tcx.hir.get_parent(item.id);\n-                    if let Some(hir_map::NodeItem(parent_scope)) = self.tcx.hir.find(id) {\n-                        if let hir::ItemImpl(_, _, _, None, _, _) = parent_scope.node {\n-                            // this impl scope implements a trait, do not recomend\n-                            // using explicit lifetimes (#37363)\n-                            return;\n-                        }\n-                    }\n-                    if let hir::ImplItemKind::Method(ref sig, body) = item.node {\n-                        Some((&sig.decl,\n-                              &sig.generics,\n-                              sig.unsafety,\n-                              sig.constness,\n-                              item.name,\n-                              item.span,\n-                              body))\n-                    } else {\n-                        None\n-                    }\n-                },\n-                hir_map::NodeTraitItem(item) => {\n-                    match item.node {\n-                        hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n-                            Some((&sig.decl,\n-                                  &sig.generics,\n-                                  sig.unsafety,\n-                                  sig.constness,\n-                                  item.name,\n-                                  item.span,\n-                                  body))\n-                        }\n-                        _ => None,\n-                    }\n-                }\n-                _ => None,\n-            },\n-            None => None,\n-        };\n-        let (fn_decl, generics, unsafety, constness, name, span, body)\n-                                    = node_inner.expect(\"expect item fn\");\n-        let rebuilder = Rebuilder::new(self.tcx, fn_decl, generics, same_regions, &life_giver);\n-        let (fn_decl, generics) = rebuilder.rebuild();\n-        self.give_expl_lifetime_param(\n-            err, &fn_decl, unsafety, constness, name, &generics, span, body);\n-    }\n-\n     pub fn issue_32330_warnings(&self, span: Span, issue32330s: &[ty::Issue32330]) {\n         for issue32330 in issue32330s {\n             match *issue32330 {\n@@ -1154,530 +1076,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-struct RebuildPathInfo<'a> {\n-    path: &'a hir::Path,\n-    // indexes to insert lifetime on path.lifetimes\n-    indexes: Vec<u32>,\n-    // number of lifetimes we expect to see on the type referred by `path`\n-    // (e.g., expected=1 for struct Foo<'a>)\n-    expected: u32,\n-    anon_nums: &'a HashSet<u32>,\n-    region_names: &'a HashSet<ast::Name>\n-}\n-\n-struct Rebuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    fn_decl: &'a hir::FnDecl,\n-    generics: &'a hir::Generics,\n-    same_regions: &'a [SameRegions],\n-    life_giver: &'a LifeGiver,\n-    cur_anon: Cell<u32>,\n-    inserted_anons: RefCell<HashSet<u32>>,\n-}\n-\n-enum FreshOrKept {\n-    Fresh,\n-    Kept\n-}\n-\n-impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-           fn_decl: &'a hir::FnDecl,\n-           generics: &'a hir::Generics,\n-           same_regions: &'a [SameRegions],\n-           life_giver: &'a LifeGiver)\n-           -> Rebuilder<'a, 'gcx, 'tcx> {\n-        Rebuilder {\n-            tcx: tcx,\n-            fn_decl: fn_decl,\n-            generics: generics,\n-            same_regions: same_regions,\n-            life_giver: life_giver,\n-            cur_anon: Cell::new(0),\n-            inserted_anons: RefCell::new(HashSet::new()),\n-        }\n-    }\n-\n-    fn rebuild(&self) -> (hir::FnDecl, hir::Generics) {\n-        let mut inputs = self.fn_decl.inputs.clone();\n-        let mut output = self.fn_decl.output.clone();\n-        let mut ty_params = self.generics.ty_params.clone();\n-        let where_clause = self.generics.where_clause.clone();\n-        let mut kept_lifetimes = HashSet::new();\n-        for sr in self.same_regions {\n-            self.cur_anon.set(0);\n-            self.offset_cur_anon();\n-            let (anon_nums, region_names) =\n-                                self.extract_anon_nums_and_names(sr);\n-            let (lifetime, fresh_or_kept) = self.pick_lifetime(&region_names);\n-            match fresh_or_kept {\n-                Kept => { kept_lifetimes.insert(lifetime.name); }\n-                _ => ()\n-            }\n-            inputs = self.rebuild_args_ty(&inputs[..], lifetime,\n-                                          &anon_nums, &region_names);\n-            output = self.rebuild_output(&output, lifetime, &anon_nums, &region_names);\n-            ty_params = self.rebuild_ty_params(ty_params, lifetime,\n-                                               &region_names);\n-        }\n-        let fresh_lifetimes = self.life_giver.get_generated_lifetimes();\n-        let all_region_names = self.extract_all_region_names();\n-        let generics = self.rebuild_generics(self.generics,\n-                                             &fresh_lifetimes,\n-                                             &kept_lifetimes,\n-                                             &all_region_names,\n-                                             ty_params,\n-                                             where_clause);\n-        let new_fn_decl = hir::FnDecl {\n-            inputs: inputs,\n-            output: output,\n-            variadic: self.fn_decl.variadic\n-        };\n-        (new_fn_decl, generics)\n-    }\n-\n-    fn pick_lifetime(&self,\n-                     region_names: &HashSet<ast::Name>)\n-                     -> (hir::Lifetime, FreshOrKept) {\n-        if !region_names.is_empty() {\n-            // It's not necessary to convert the set of region names to a\n-            // vector of string and then sort them. However, it makes the\n-            // choice of lifetime name deterministic and thus easier to test.\n-            let mut names = Vec::new();\n-            for rn in region_names {\n-                let lt_name = rn.to_string();\n-                names.push(lt_name);\n-            }\n-            names.sort();\n-            let name = Symbol::intern(&names[0]);\n-            return (name_to_dummy_lifetime(name), Kept);\n-        }\n-        return (self.life_giver.give_lifetime(), Fresh);\n-    }\n-\n-    fn extract_anon_nums_and_names(&self, same_regions: &SameRegions)\n-                                   -> (HashSet<u32>, HashSet<ast::Name>) {\n-        let mut anon_nums = HashSet::new();\n-        let mut region_names = HashSet::new();\n-        for br in &same_regions.regions {\n-            match *br {\n-                ty::BrAnon(i) => {\n-                    anon_nums.insert(i);\n-                }\n-                ty::BrNamed(_, name, _) => {\n-                    region_names.insert(name);\n-                }\n-                _ => ()\n-            }\n-        }\n-        (anon_nums, region_names)\n-    }\n-\n-    fn extract_all_region_names(&self) -> HashSet<ast::Name> {\n-        let mut all_region_names = HashSet::new();\n-        for sr in self.same_regions {\n-            for br in &sr.regions {\n-                match *br {\n-                    ty::BrNamed(_, name, _) => {\n-                        all_region_names.insert(name);\n-                    }\n-                    _ => ()\n-                }\n-            }\n-        }\n-        all_region_names\n-    }\n-\n-    fn inc_cur_anon(&self, n: u32) {\n-        let anon = self.cur_anon.get();\n-        self.cur_anon.set(anon+n);\n-    }\n-\n-    fn offset_cur_anon(&self) {\n-        let mut anon = self.cur_anon.get();\n-        while self.inserted_anons.borrow().contains(&anon) {\n-            anon += 1;\n-        }\n-        self.cur_anon.set(anon);\n-    }\n-\n-    fn inc_and_offset_cur_anon(&self, n: u32) {\n-        self.inc_cur_anon(n);\n-        self.offset_cur_anon();\n-    }\n-\n-    fn track_anon(&self, anon: u32) {\n-        self.inserted_anons.borrow_mut().insert(anon);\n-    }\n-\n-    fn rebuild_ty_params(&self,\n-                         ty_params: hir::HirVec<hir::TyParam>,\n-                         lifetime: hir::Lifetime,\n-                         region_names: &HashSet<ast::Name>)\n-                         -> hir::HirVec<hir::TyParam> {\n-        ty_params.into_iter().map(|ty_param| {\n-            let bounds = self.rebuild_ty_param_bounds(ty_param.bounds,\n-                                                      lifetime,\n-                                                      region_names);\n-            hir::TyParam {\n-                name: ty_param.name,\n-                id: ty_param.id,\n-                bounds: bounds,\n-                default: ty_param.default,\n-                span: ty_param.span,\n-                pure_wrt_drop: ty_param.pure_wrt_drop,\n-            }\n-        }).collect()\n-    }\n-\n-    fn rebuild_ty_param_bounds(&self,\n-                               ty_param_bounds: hir::TyParamBounds,\n-                               lifetime: hir::Lifetime,\n-                               region_names: &HashSet<ast::Name>)\n-                               -> hir::TyParamBounds {\n-        ty_param_bounds.iter().map(|tpb| {\n-            match tpb {\n-                &hir::RegionTyParamBound(lt) => {\n-                    // FIXME -- it's unclear whether I'm supposed to\n-                    // substitute lifetime here. I suspect we need to\n-                    // be passing down a map.\n-                    hir::RegionTyParamBound(lt)\n-                }\n-                &hir::TraitTyParamBound(ref poly_tr, modifier) => {\n-                    let tr = &poly_tr.trait_ref;\n-                    let last_seg = tr.path.segments.last().unwrap();\n-                    let mut insert = Vec::new();\n-                    let lifetimes = last_seg.parameters.lifetimes();\n-                    for (i, lt) in lifetimes.iter().enumerate() {\n-                        if region_names.contains(&lt.name) {\n-                            insert.push(i as u32);\n-                        }\n-                    }\n-                    let rebuild_info = RebuildPathInfo {\n-                        path: &tr.path,\n-                        indexes: insert,\n-                        expected: lifetimes.len() as u32,\n-                        anon_nums: &HashSet::new(),\n-                        region_names: region_names\n-                    };\n-                    let new_path = self.rebuild_path(rebuild_info, lifetime);\n-                    hir::TraitTyParamBound(hir::PolyTraitRef {\n-                        bound_lifetimes: poly_tr.bound_lifetimes.clone(),\n-                        trait_ref: hir::TraitRef {\n-                            path: new_path,\n-                            ref_id: tr.ref_id,\n-                        },\n-                        span: poly_tr.span,\n-                    }, modifier)\n-                }\n-            }\n-        }).collect()\n-    }\n-\n-    fn rebuild_generics(&self,\n-                        generics: &hir::Generics,\n-                        add: &Vec<hir::Lifetime>,\n-                        keep: &HashSet<ast::Name>,\n-                        remove: &HashSet<ast::Name>,\n-                        ty_params: hir::HirVec<hir::TyParam>,\n-                        where_clause: hir::WhereClause)\n-                        -> hir::Generics {\n-        let mut lifetimes = Vec::new();\n-        for lt in add {\n-            lifetimes.push(hir::LifetimeDef {\n-                lifetime: *lt,\n-                bounds: hir::HirVec::new(),\n-                pure_wrt_drop: false,\n-            });\n-        }\n-        for lt in &generics.lifetimes {\n-            if keep.contains(&lt.lifetime.name) ||\n-                !remove.contains(&lt.lifetime.name) {\n-                lifetimes.push((*lt).clone());\n-            }\n-        }\n-        hir::Generics {\n-            lifetimes: lifetimes.into(),\n-            ty_params: ty_params,\n-            where_clause: where_clause,\n-            span: generics.span,\n-        }\n-    }\n-\n-    fn rebuild_args_ty(&self,\n-                       inputs: &[P<hir::Ty>],\n-                       lifetime: hir::Lifetime,\n-                       anon_nums: &HashSet<u32>,\n-                       region_names: &HashSet<ast::Name>)\n-                       -> hir::HirVec<P<hir::Ty>> {\n-        inputs.iter().map(|arg_ty| {\n-            self.rebuild_arg_ty_or_output(arg_ty, lifetime, anon_nums, region_names)\n-        }).collect()\n-    }\n-\n-    fn rebuild_output(&self, ty: &hir::FunctionRetTy,\n-                      lifetime: hir::Lifetime,\n-                      anon_nums: &HashSet<u32>,\n-                      region_names: &HashSet<ast::Name>) -> hir::FunctionRetTy {\n-        match *ty {\n-            hir::Return(ref ret_ty) => hir::Return(\n-                self.rebuild_arg_ty_or_output(&ret_ty, lifetime, anon_nums, region_names)\n-            ),\n-            hir::DefaultReturn(span) => hir::DefaultReturn(span),\n-        }\n-    }\n-\n-    fn rebuild_arg_ty_or_output(&self,\n-                                ty: &hir::Ty,\n-                                lifetime: hir::Lifetime,\n-                                anon_nums: &HashSet<u32>,\n-                                region_names: &HashSet<ast::Name>)\n-                                -> P<hir::Ty> {\n-        let mut new_ty = P(ty.clone());\n-        let mut ty_queue = vec![ty];\n-        while !ty_queue.is_empty() {\n-            let cur_ty = ty_queue.remove(0);\n-            match cur_ty.node {\n-                hir::TyRptr(lt_opt, ref mut_ty) => {\n-                    let rebuild = match lt_opt {\n-                        Some(lt) => region_names.contains(&lt.name),\n-                        None => {\n-                            let anon = self.cur_anon.get();\n-                            let rebuild = anon_nums.contains(&anon);\n-                            if rebuild {\n-                                self.track_anon(anon);\n-                            }\n-                            self.inc_and_offset_cur_anon(1);\n-                            rebuild\n-                        }\n-                    };\n-                    if rebuild {\n-                        let to = hir::Ty {\n-                            id: cur_ty.id,\n-                            node: hir::TyRptr(Some(lifetime), mut_ty.clone()),\n-                            span: cur_ty.span\n-                        };\n-                        new_ty = self.rebuild_ty(new_ty, P(to));\n-                    }\n-                    ty_queue.push(&mut_ty.ty);\n-                }\n-                hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n-                    match path.def {\n-                        Def::Enum(did) | Def::TyAlias(did) |\n-                        Def::Struct(did) | Def::Union(did) => {\n-                            let generics = self.tcx.item_generics(did);\n-\n-                            let expected =\n-                                generics.regions.len() as u32;\n-                            let lifetimes =\n-                                path.segments.last().unwrap().parameters.lifetimes();\n-                            let mut insert = Vec::new();\n-                            if lifetimes.is_empty() {\n-                                let anon = self.cur_anon.get();\n-                                for (i, a) in (anon..anon+expected).enumerate() {\n-                                    if anon_nums.contains(&a) {\n-                                        insert.push(i as u32);\n-                                    }\n-                                    self.track_anon(a);\n-                                }\n-                                self.inc_and_offset_cur_anon(expected);\n-                            } else {\n-                                for (i, lt) in lifetimes.iter().enumerate() {\n-                                    if region_names.contains(&lt.name) {\n-                                        insert.push(i as u32);\n-                                    }\n-                                }\n-                            }\n-                            let rebuild_info = RebuildPathInfo {\n-                                path: path,\n-                                indexes: insert,\n-                                expected: expected,\n-                                anon_nums: anon_nums,\n-                                region_names: region_names\n-                            };\n-                            let new_path = self.rebuild_path(rebuild_info, lifetime);\n-                            let qself = maybe_qself.as_ref().map(|qself| {\n-                                self.rebuild_arg_ty_or_output(qself, lifetime,\n-                                                              anon_nums, region_names)\n-                            });\n-                            let to = hir::Ty {\n-                                id: cur_ty.id,\n-                                node: hir::TyPath(hir::QPath::Resolved(qself, P(new_path))),\n-                                span: cur_ty.span\n-                            };\n-                            new_ty = self.rebuild_ty(new_ty, P(to));\n-                        }\n-                        _ => ()\n-                    }\n-                }\n-\n-                hir::TyPtr(ref mut_ty) => {\n-                    ty_queue.push(&mut_ty.ty);\n-                }\n-                hir::TySlice(ref ty) |\n-                hir::TyArray(ref ty, _) => {\n-                    ty_queue.push(&ty);\n-                }\n-                hir::TyTup(ref tys) => ty_queue.extend(tys.iter().map(|ty| &**ty)),\n-                _ => {}\n-            }\n-        }\n-        new_ty\n-    }\n-\n-    fn rebuild_ty(&self,\n-                  from: P<hir::Ty>,\n-                  to: P<hir::Ty>)\n-                  -> P<hir::Ty> {\n-\n-        fn build_to(from: P<hir::Ty>,\n-                    to: &mut Option<P<hir::Ty>>)\n-                    -> P<hir::Ty> {\n-            if Some(from.id) == to.as_ref().map(|ty| ty.id) {\n-                return to.take().expect(\"`to` type found more than once during rebuild\");\n-            }\n-            from.map(|hir::Ty {id, node, span}| {\n-                let new_node = match node {\n-                    hir::TyRptr(lifetime, mut_ty) => {\n-                        hir::TyRptr(lifetime, hir::MutTy {\n-                            mutbl: mut_ty.mutbl,\n-                            ty: build_to(mut_ty.ty, to),\n-                        })\n-                    }\n-                    hir::TyPtr(mut_ty) => {\n-                        hir::TyPtr(hir::MutTy {\n-                            mutbl: mut_ty.mutbl,\n-                            ty: build_to(mut_ty.ty, to),\n-                        })\n-                    }\n-                    hir::TySlice(ty) => hir::TySlice(build_to(ty, to)),\n-                    hir::TyArray(ty, e) => {\n-                        hir::TyArray(build_to(ty, to), e)\n-                    }\n-                    hir::TyTup(tys) => {\n-                        hir::TyTup(tys.into_iter().map(|ty| build_to(ty, to)).collect())\n-                    }\n-                    other => other\n-                };\n-                hir::Ty { id: id, node: new_node, span: span }\n-            })\n-        }\n-\n-        build_to(from, &mut Some(to))\n-    }\n-\n-    fn rebuild_path(&self,\n-                    rebuild_info: RebuildPathInfo,\n-                    lifetime: hir::Lifetime)\n-                    -> hir::Path\n-    {\n-        let RebuildPathInfo {\n-            path,\n-            indexes,\n-            expected,\n-            anon_nums,\n-            region_names,\n-        } = rebuild_info;\n-\n-        let last_seg = path.segments.last().unwrap();\n-        let new_parameters = match last_seg.parameters {\n-            hir::ParenthesizedParameters(..) => {\n-                last_seg.parameters.clone()\n-            }\n-\n-            hir::AngleBracketedParameters(ref data) => {\n-                let mut new_lts = Vec::new();\n-                if data.lifetimes.is_empty() {\n-                    // traverse once to see if there's a need to insert lifetime\n-                    let need_insert = (0..expected).any(|i| {\n-                        indexes.contains(&i)\n-                    });\n-                    if need_insert {\n-                        for i in 0..expected {\n-                            if indexes.contains(&i) {\n-                                new_lts.push(lifetime);\n-                            } else {\n-                                new_lts.push(self.life_giver.give_lifetime());\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    for (i, lt) in data.lifetimes.iter().enumerate() {\n-                        if indexes.contains(&(i as u32)) {\n-                            new_lts.push(lifetime);\n-                        } else {\n-                            new_lts.push(*lt);\n-                        }\n-                    }\n-                }\n-                let new_types = data.types.iter().map(|t| {\n-                    self.rebuild_arg_ty_or_output(&t, lifetime, anon_nums, region_names)\n-                }).collect();\n-                let new_bindings = data.bindings.iter().map(|b| {\n-                    hir::TypeBinding {\n-                        id: b.id,\n-                        name: b.name,\n-                        ty: self.rebuild_arg_ty_or_output(&b.ty,\n-                                                          lifetime,\n-                                                          anon_nums,\n-                                                          region_names),\n-                        span: b.span\n-                    }\n-                }).collect();\n-                hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n-                    lifetimes: new_lts.into(),\n-                    types: new_types,\n-                    infer_types: data.infer_types,\n-                    bindings: new_bindings,\n-               })\n-            }\n-        };\n-        let new_seg = hir::PathSegment {\n-            name: last_seg.name,\n-            parameters: new_parameters\n-        };\n-        let mut new_segs = Vec::new();\n-        new_segs.extend_from_slice(path.segments.split_last().unwrap().1);\n-        new_segs.push(new_seg);\n-        hir::Path {\n-            span: path.span,\n-            def: path.def,\n-            segments: new_segs.into()\n-        }\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    fn give_expl_lifetime_param(&self,\n-                                err: &mut DiagnosticBuilder,\n-                                decl: &hir::FnDecl,\n-                                unsafety: hir::Unsafety,\n-                                constness: hir::Constness,\n-                                name: ast::Name,\n-                                generics: &hir::Generics,\n-                                span: Span,\n-                                body: hir::BodyId) {\n-        let s = hir::print::to_string(&self.tcx.hir, |s| {\n-            use syntax::abi::Abi;\n-            use syntax::print::pprust::PrintState;\n-\n-            s.head(\"\")?;\n-            s.print_fn(decl,\n-                       unsafety,\n-                       constness,\n-                       Abi::Rust,\n-                       Some(name),\n-                       generics,\n-                       &hir::Inherited,\n-                       &[],\n-                       Some(body))?;\n-            s.end()?; // Close the head box\n-            s.end()   // Close the outer box\n-        });\n-        let msg = format!(\"consider using an explicit lifetime parameter as shown: {}\", s);\n-        err.span_help(span, &msg[..]);\n-    }\n-\n     fn report_inference_failure(&self,\n                                 var_origin: RegionVariableOrigin)\n                                 -> DiagnosticBuilder<'tcx> {\n@@ -1890,114 +1289,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn lifetimes_in_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                      scope_id: ast::NodeId)\n-                                      -> Vec<hir::LifetimeDef> {\n-    let mut taken = Vec::new();\n-    let parent = tcx.hir.get_parent(scope_id);\n-    let method_id_opt = match tcx.hir.find(parent) {\n-        Some(node) => match node {\n-            hir_map::NodeItem(item) => match item.node {\n-                hir::ItemFn(.., ref gen, _) => {\n-                    taken.extend_from_slice(&gen.lifetimes);\n-                    None\n-                },\n-                _ => None\n-            },\n-            hir_map::NodeImplItem(ii) => {\n-                match ii.node {\n-                    hir::ImplItemKind::Method(ref sig, _) => {\n-                        taken.extend_from_slice(&sig.generics.lifetimes);\n-                        Some(ii.id)\n-                    }\n-                    _ => None,\n-                }\n-            }\n-            _ => None\n-        },\n-        None => None\n-    };\n-    if let Some(method_id) = method_id_opt {\n-        let parent = tcx.hir.get_parent(method_id);\n-        if let Some(node) = tcx.hir.find(parent) {\n-            match node {\n-                hir_map::NodeItem(item) => match item.node {\n-                    hir::ItemImpl(_, _, ref gen, ..) => {\n-                        taken.extend_from_slice(&gen.lifetimes);\n-                    }\n-                    _ => ()\n-                },\n-                _ => ()\n-            }\n-        }\n-    }\n-    return taken;\n-}\n-\n-// LifeGiver is responsible for generating fresh lifetime names\n-struct LifeGiver {\n-    taken: HashSet<String>,\n-    counter: Cell<usize>,\n-    generated: RefCell<Vec<hir::Lifetime>>,\n-}\n-\n-impl LifeGiver {\n-    fn with_taken(taken: &[hir::LifetimeDef]) -> LifeGiver {\n-        let mut taken_ = HashSet::new();\n-        for lt in taken {\n-            let lt_name = lt.lifetime.name.to_string();\n-            taken_.insert(lt_name);\n-        }\n-        LifeGiver {\n-            taken: taken_,\n-            counter: Cell::new(0),\n-            generated: RefCell::new(Vec::new()),\n-        }\n-    }\n-\n-    fn inc_counter(&self) {\n-        let c = self.counter.get();\n-        self.counter.set(c+1);\n-    }\n-\n-    fn give_lifetime(&self) -> hir::Lifetime {\n-        let lifetime;\n-        loop {\n-            let mut s = String::from(\"'\");\n-            s.push_str(&num_to_string(self.counter.get()));\n-            if !self.taken.contains(&s) {\n-                lifetime = name_to_dummy_lifetime(Symbol::intern(&s));\n-                self.generated.borrow_mut().push(lifetime);\n-                break;\n-            }\n-            self.inc_counter();\n-        }\n-        self.inc_counter();\n-        return lifetime;\n-\n-        // 0 .. 25 generates a .. z, 26 .. 51 generates aa .. zz, and so on\n-        fn num_to_string(counter: usize) -> String {\n-            let mut s = String::new();\n-            let (n, r) = (counter/26 + 1, counter % 26);\n-            let letter: char = from_u32((r+97) as u32).unwrap();\n-            for _ in 0..n {\n-                s.push(letter);\n-            }\n-            s\n-        }\n-    }\n-\n-    fn get_generated_lifetimes(&self) -> Vec<hir::Lifetime> {\n-        self.generated.borrow().clone()\n-    }\n-}\n-\n-fn name_to_dummy_lifetime(name: ast::Name) -> hir::Lifetime {\n-    hir::Lifetime { id: ast::DUMMY_NODE_ID,\n-                    span: syntax_pos::DUMMY_SP,\n-                    name: name }\n-}\n-\n impl<'tcx> ObligationCause<'tcx> {\n     fn as_failure_str(&self) -> &'static str {\n         use traits::ObligationCauseCode::*;\n@@ -2038,4 +1329,3 @@ impl<'tcx> ObligationCause<'tcx> {\n         }\n     }\n }\n-"}, {"sha": "408c6d411de9030efb4b80371f4ee13cd1e5a2de", "filename": "src/test/compile-fail/issue-13058.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/154c202afb256c379b7d454ec0244da69eaa2ced/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c202afb256c379b7d454ec0244da69eaa2ced/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs?ref=154c202afb256c379b7d454ec0244da69eaa2ced", "patch": "@@ -20,7 +20,6 @@ impl<'r> Itble<'r, usize, Range<usize>> for (usize, usize) {\n }\n \n fn check<'r, I: Iterator<Item=usize>, T: Itble<'r, usize, I>>(cont: &T) -> bool\n-//~^ HELP as shown: fn check<'r, I: Iterator<Item = usize>, T: Itble<'r, usize, I>>(cont: &'r T)\n {\n     let cont_iter = cont.iter();\n //~^ ERROR cannot infer an appropriate lifetime for autoref due to conflicting requirements"}, {"sha": "d2d0dbf3e981fe3fa32a24d7eb7d9bd32b8cbac4", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param-2.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/62a72586775fc0bfe38f4e43bf3aca52a31c6921/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a72586775fc0bfe38f4e43bf3aca52a31c6921/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs?ref=62a72586775fc0bfe38f4e43bf3aca52a31c6921", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-\n-use std::ops::Range;\n-\n-trait Itble<'r, T, I: Iterator<Item=T>> { fn iter(&'r self) -> I; }\n-\n-impl<'r> Itble<'r, usize, Range<usize>> for (usize, usize) {\n-    fn iter(&'r self) -> Range<usize> {\n-        let &(min, max) = self;\n-        min..max\n-    }\n-}\n-\n-fn check<'r, I: Iterator<Item=usize>, T: Itble<'r, usize, I>>(cont: &T) -> bool {\n-//~^ HELP: consider using an explicit lifetime parameter as shown: fn check<'r, I: Iterator<Item = usize>, T: Itble<'r, usize, I>>(cont: &'r T)\n-    let cont_iter = cont.iter(); //~ ERROR: cannot infer\n-    let result = cont_iter.fold(Some(0), |state, val| {\n-        state.map_or(None, |mask| {\n-            let bit = 1 << val;\n-            if mask & bit == 0 {Some(mask|bit)} else {None}\n-        })\n-    });\n-    result.is_some()\n-}\n-\n-fn main() {}"}, {"sha": "6b22d434804ffecafc2b56e71c8140e1ae6e5428", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param-3.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/62a72586775fc0bfe38f4e43bf3aca52a31c6921/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a72586775fc0bfe38f4e43bf3aca52a31c6921/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs?ref=62a72586775fc0bfe38f4e43bf3aca52a31c6921", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-\n-use std::marker::PhantomData;\n-\n-struct Bar<'x, 'y, 'z> { bar: &'y i32, baz: i32, marker: PhantomData<(&'x(),&'y(),&'z())> }\n-fn bar1<'a>(x: &Bar) -> (&'a i32, &'a i32, &'a i32) {\n-    //~^ HELP consider using an explicit lifetime parameter as shown: fn bar1<'b, 'c, 'a>(x: &'a Bar<'b, 'a, 'c>) -> (&'a i32, &'a i32, &'a i32)\n-    (x.bar, &x.baz, &x.baz)\n-    //~^ ERROR E0312\n-    //~| ERROR cannot infer\n-    //~| ERROR cannot infer\n-}\n-\n-fn bar2<'a, 'b, 'c>(x: &Bar<'a, 'b, 'c>) -> (&'a i32, &'a i32, &'a i32) {\n-    //~^ HELP: consider using an explicit lifetime parameter as shown: fn bar2<'a, 'c>(x: &'a Bar<'a, 'a, 'c>) -> (&'a i32, &'a i32, &'a i32)\n-    (x.bar, &x.baz, &x.baz)\n-    //~^ ERROR E0312\n-    //~| ERROR cannot infer\n-    //~| ERROR cannot infer\n-}\n-\n-fn main() { }"}, {"sha": "4323929e2e37a7cc07827fa3cccbde3cb06d72dd", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param.rs", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/62a72586775fc0bfe38f4e43bf3aca52a31c6921/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a72586775fc0bfe38f4e43bf3aca52a31c6921/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs?ref=62a72586775fc0bfe38f4e43bf3aca52a31c6921", "patch": "@@ -1,57 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-\n-use std::marker::PhantomData;\n-\n-struct Foo<'x> { bar: isize, marker: PhantomData<&'x ()> }\n-fn foo1<'a>(x: &Foo) -> &'a isize {\n-//~^ HELP: consider using an explicit lifetime parameter as shown: fn foo1<'a>(x: &'a Foo) -> &'a isize\n-    &x.bar //~ ERROR: cannot infer\n-}\n-\n-fn foo2<'a, 'b>(x: &'a Foo) -> &'b isize {\n-//~^ HELP: consider using an explicit lifetime parameter as shown: fn foo2<'a>(x: &'a Foo) -> &'a isize\n-    &x.bar //~ ERROR: cannot infer\n-}\n-\n-fn foo3<'a>(x: &Foo) -> (&'a isize, &'a isize) {\n-//~^ HELP: consider using an explicit lifetime parameter as shown: fn foo3<'a>(x: &'a Foo) -> (&'a isize, &'a isize)\n-    (&x.bar, &x.bar) //~ ERROR: cannot infer\n-    //~^ ERROR: cannot infer\n-}\n-\n-fn foo4<'a, 'b>(x: &'a Foo) -> (&'b isize, &'a isize, &'b isize) {\n-//~^ HELP: consider using an explicit lifetime parameter as shown: fn foo4<'a>(x: &'a Foo) -> (&'a isize, &'a isize, &'a isize)\n-    (&x.bar, &x.bar, &x.bar) //~ ERROR: cannot infer\n-    //~^ ERROR: cannot infer\n-}\n-\n-struct Cat<'x, T> { cat: &'x isize, t: T }\n-struct Dog<'y> { dog: &'y isize }\n-\n-fn cat2<'x, 'y>(x: Cat<'x, Dog<'y>>) -> &'x isize {\n-    //~^ HELP consider using an explicit lifetime parameter as shown: fn cat2<'x>(x: Cat<'x, Dog<'x>>) -> &'x isize\n-    x.t.dog //~ ERROR E0312\n-}\n-\n-struct Baz<'x> {\n-    bar: &'x isize\n-}\n-\n-impl<'a> Baz<'a> {\n-    fn baz2<'b>(&self, x: &isize) -> (&'b isize, &'b isize) {\n-        (self.bar, x) //~ ERROR E0312\n-        //~^ ERROR E0312\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "603f55af465f47f8c6b23f6592659a79b02a2c15", "filename": "src/test/ui/lifetimes/consider-using-explicit-lifetime.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/62a72586775fc0bfe38f4e43bf3aca52a31c6921/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62a72586775fc0bfe38f4e43bf3aca52a31c6921/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.rs?ref=62a72586775fc0bfe38f4e43bf3aca52a31c6921", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::str::FromStr;\n-\n-pub struct Foo<'a> {\n-    field: &'a str,\n-}\n-\n-impl<'a> Foo<'a> {\n-    fn bar(path: &str) -> Result<Self, ()> {\n-        Ok(Foo { field: path })\n-    }\n-}\n-\n-impl<'a> FromStr for Foo<'a> {\n-    type Err = ();\n-    fn from_str(path: &str) -> Result<Self, ()> {\n-        Ok(Foo { field: path })\n-    }\n-}"}, {"sha": "153aaa07833a8a08ee73586deec3859420bff3d3", "filename": "src/test/ui/lifetimes/consider-using-explicit-lifetime.stderr", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/62a72586775fc0bfe38f4e43bf3aca52a31c6921/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/62a72586775fc0bfe38f4e43bf3aca52a31c6921/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fconsider-using-explicit-lifetime.stderr?ref=62a72586775fc0bfe38f4e43bf3aca52a31c6921", "patch": "@@ -1,25 +0,0 @@\n-error: main function not found\n-\n-error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n-  --> $DIR/consider-using-explicit-lifetime.rs:19:12\n-   |\n-19 |         Ok(Foo { field: path })\n-   |            ^^^\n-\n-error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n-  --> $DIR/consider-using-explicit-lifetime.rs:26:12\n-   |\n-26 |         Ok(Foo { field: path })\n-   |            ^^^\n-   |\n-help: consider using an explicit lifetime parameter as shown: fn from_str(path: &'a str) -> Result<Self, ()>\n-  --> $DIR/consider-using-explicit-lifetime.rs:25:5\n-   |\n-25 |       fn from_str(path: &str) -> Result<Self, ()> {\n-   |  _____^ starting here...\n-26 | |         Ok(Foo { field: path })\n-27 | |     }\n-   | |_____^ ...ending here\n-\n-error: aborting due to 2 previous errors\n-"}]}