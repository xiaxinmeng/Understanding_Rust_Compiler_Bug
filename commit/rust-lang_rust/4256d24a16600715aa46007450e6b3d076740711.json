{"sha": "4256d24a16600715aa46007450e6b3d076740711", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNTZkMjRhMTY2MDA3MTVhYTQ2MDA3NDUwZTZiM2QwNzY3NDA3MTE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-11T06:14:42Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-12T17:46:31Z"}, "message": "Percolate the (Scheduler, GreenTask) pair upwards\n\nThis is in preparation for running do_work in a loop while there are no active\nI/O handles. This changes the do_work and interpret_message_queue methods to\nreturn a triple where the last element is a boolean flag as to whether work was\ndone or not.\n\nThis commit preserves the same behavior as before, it simply re-structures the\ncode in preparation for future work.", "tree": {"sha": "7b5b08465c5bb0938cd6e6c44f2dd68c642e1bd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b5b08465c5bb0938cd6e6c44f2dd68c642e1bd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4256d24a16600715aa46007450e6b3d076740711", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4256d24a16600715aa46007450e6b3d076740711", "html_url": "https://github.com/rust-lang/rust/commit/4256d24a16600715aa46007450e6b3d076740711", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4256d24a16600715aa46007450e6b3d076740711/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc34dbb84090f74c84037afb269003f13aa46b78", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc34dbb84090f74c84037afb269003f13aa46b78", "html_url": "https://github.com/rust-lang/rust/commit/cc34dbb84090f74c84037afb269003f13aa46b78"}], "stats": {"total": 106, "additions": 56, "deletions": 50}, "files": [{"sha": "b1c8386597544065221d5af4941327716d49826c", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 56, "deletions": 50, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/4256d24a16600715aa46007450e6b3d076740711/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4256d24a16600715aa46007450e6b3d076740711/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=4256d24a16600715aa46007450e6b3d076740711", "patch": "@@ -269,26 +269,26 @@ impl Scheduler {\n \n         // First we check for scheduler messages, these are higher\n         // priority than regular tasks.\n-        let (sched, stask) =\n-            match self.interpret_message_queue(stask, DontTryTooHard) {\n-                Some(pair) => pair,\n-                None => return\n-            };\n+        let (sched, stask, did_work) =\n+            self.interpret_message_queue(stask, DontTryTooHard);\n+        if did_work {\n+            return stask.put_with_sched(sched);\n+        }\n \n         // This helper will use a randomized work-stealing algorithm\n         // to find work.\n-        let (sched, stask) = match sched.do_work(stask) {\n-            Some(pair) => pair,\n-            None => return\n-        };\n+        let (sched, stask, did_work) = sched.do_work(stask);\n+        if did_work {\n+            return stask.put_with_sched(sched);\n+        }\n \n         // Now, before sleeping we need to find out if there really\n         // were any messages. Give it your best!\n-        let (mut sched, stask) =\n-            match sched.interpret_message_queue(stask, GiveItYourBest) {\n-                Some(pair) => pair,\n-                None => return\n-            };\n+        let (mut sched, stask, did_work) =\n+            sched.interpret_message_queue(stask, GiveItYourBest);\n+        if did_work {\n+            return stask.put_with_sched(sched);\n+        }\n \n         // If we got here then there was no work to do.\n         // Generate a SchedHandle and push it to the sleeper list so\n@@ -318,7 +318,7 @@ impl Scheduler {\n     // return None.\n     fn interpret_message_queue(mut ~self, stask: ~GreenTask,\n                                effort: EffortLevel)\n-        -> Option<(~Scheduler, ~GreenTask)>\n+            -> (~Scheduler, ~GreenTask, bool)\n     {\n \n         let msg = if effort == DontTryTooHard {\n@@ -349,25 +349,25 @@ impl Scheduler {\n             Some(PinnedTask(task)) => {\n                 let mut task = task;\n                 task.give_home(HomeSched(self.make_handle()));\n-                self.resume_task_immediately(stask, task).put();\n-                return None;\n+                let (sched, task) = self.resume_task_immediately(stask, task);\n+                (sched, task, true)\n             }\n             Some(TaskFromFriend(task)) => {\n                 rtdebug!(\"got a task from a friend. lovely!\");\n-                self.process_task(stask, task,\n-                                  Scheduler::resume_task_immediately_cl);\n-                return None;\n+                let (sched, task) =\n+                    self.process_task(stask, task,\n+                                      Scheduler::resume_task_immediately_cl);\n+                (sched, task, true)\n             }\n             Some(RunOnce(task)) => {\n                 // bypass the process_task logic to force running this task once\n                 // on this home scheduler. This is often used for I/O (homing).\n-                self.resume_task_immediately(stask, task).put();\n-                return None;\n+                let (sched, task) = self.resume_task_immediately(stask, task);\n+                (sched, task, true)\n             }\n             Some(Wake) => {\n                 self.sleepy = false;\n-                stask.put_with_sched(self);\n-                return None;\n+                (self, stask, true)\n             }\n             Some(Shutdown) => {\n                 rtdebug!(\"shutting down\");\n@@ -389,31 +389,30 @@ impl Scheduler {\n                 // event loop references we will shut down.\n                 self.no_sleep = true;\n                 self.sleepy = false;\n-                stask.put_with_sched(self);\n-                return None;\n+                (self, stask, true)\n             }\n             Some(NewNeighbor(neighbor)) => {\n                 self.work_queues.push(neighbor);\n-                return Some((self, stask));\n-            }\n-            None => {\n-                return Some((self, stask));\n+                (self, stask, false)\n             }\n+            None => (self, stask, false)\n         }\n     }\n \n-    fn do_work(mut ~self, stask: ~GreenTask) -> Option<(~Scheduler, ~GreenTask)> {\n+    fn do_work(mut ~self,\n+               stask: ~GreenTask) -> (~Scheduler, ~GreenTask, bool) {\n         rtdebug!(\"scheduler calling do work\");\n         match self.find_work() {\n             Some(task) => {\n                 rtdebug!(\"found some work! running the task\");\n-                self.process_task(stask, task,\n-                                  Scheduler::resume_task_immediately_cl);\n-                return None;\n+                let (sched, task) =\n+                    self.process_task(stask, task,\n+                                      Scheduler::resume_task_immediately_cl);\n+                (sched, task, true)\n             }\n             None => {\n                 rtdebug!(\"no work was found, returning the scheduler struct\");\n-                return Some((self, stask));\n+                (self, stask, false)\n             }\n         }\n     }\n@@ -486,7 +485,8 @@ impl Scheduler {\n     // place.\n \n     fn process_task(mut ~self, cur: ~GreenTask,\n-                    mut next: ~GreenTask, schedule_fn: SchedulingFn) {\n+                    mut next: ~GreenTask,\n+                    schedule_fn: SchedulingFn) -> (~Scheduler, ~GreenTask) {\n         rtdebug!(\"processing a task\");\n \n         match next.take_unwrap_home() {\n@@ -495,23 +495,23 @@ impl Scheduler {\n                     rtdebug!(\"sending task home\");\n                     next.give_home(HomeSched(home_handle));\n                     Scheduler::send_task_home(next);\n-                    cur.put_with_sched(self);\n+                    (self, cur)\n                 } else {\n                     rtdebug!(\"running task here\");\n                     next.give_home(HomeSched(home_handle));\n-                    schedule_fn(self, cur, next);\n+                    schedule_fn(self, cur, next)\n                 }\n             }\n             AnySched if self.run_anything => {\n                 rtdebug!(\"running anysched task here\");\n                 next.give_home(AnySched);\n-                schedule_fn(self, cur, next);\n+                schedule_fn(self, cur, next)\n             }\n             AnySched => {\n                 rtdebug!(\"sending task to friend\");\n                 next.give_home(AnySched);\n                 self.send_to_friend(next);\n-                cur.put_with_sched(self);\n+                (self, cur)\n             }\n         }\n     }\n@@ -664,18 +664,19 @@ impl Scheduler {\n     // * Context Swapping Helpers - Here be ugliness!\n \n     pub fn resume_task_immediately(~self, cur: ~GreenTask,\n-                                   next: ~GreenTask) -> ~GreenTask {\n+                                   next: ~GreenTask) -> (~Scheduler, ~GreenTask) {\n         assert!(cur.is_sched());\n-        self.change_task_context(cur, next, |sched, stask| {\n+        let mut cur = self.change_task_context(cur, next, |sched, stask| {\n             assert!(sched.sched_task.is_none());\n             sched.sched_task = Some(stask);\n-        })\n+        });\n+        (cur.sched.take_unwrap(), cur)\n     }\n \n     fn resume_task_immediately_cl(sched: ~Scheduler,\n                                   cur: ~GreenTask,\n-                                  next: ~GreenTask) {\n-        sched.resume_task_immediately(cur, next).put()\n+                                  next: ~GreenTask) -> (~Scheduler, ~GreenTask) {\n+        sched.resume_task_immediately(cur, next)\n     }\n \n     /// Block a running task, context switch to the scheduler, then pass the\n@@ -741,15 +742,17 @@ impl Scheduler {\n         cur.put();\n     }\n \n-    fn switch_task(sched: ~Scheduler, cur: ~GreenTask, next: ~GreenTask) {\n-        sched.change_task_context(cur, next, |sched, last_task| {\n+    fn switch_task(sched: ~Scheduler, cur: ~GreenTask,\n+                   next: ~GreenTask) -> (~Scheduler, ~GreenTask) {\n+        let mut cur = sched.change_task_context(cur, next, |sched, last_task| {\n             if last_task.is_sched() {\n                 assert!(sched.sched_task.is_none());\n                 sched.sched_task = Some(last_task);\n             } else {\n                 sched.enqueue_task(last_task);\n             }\n-        }).put()\n+        });\n+        (cur.sched.take_unwrap(), cur)\n     }\n \n     // * Task Context Helpers\n@@ -769,7 +772,9 @@ impl Scheduler {\n     }\n \n     pub fn run_task(~self, cur: ~GreenTask, next: ~GreenTask) {\n-        self.process_task(cur, next, Scheduler::switch_task);\n+        let (sched, task) =\n+            self.process_task(cur, next, Scheduler::switch_task);\n+        task.put_with_sched(sched);\n     }\n \n     pub fn run_task_later(mut cur: ~GreenTask, next: ~GreenTask) {\n@@ -836,7 +841,8 @@ impl Scheduler {\n \n // Supporting types\n \n-type SchedulingFn = extern \"Rust\" fn (~Scheduler, ~GreenTask, ~GreenTask);\n+type SchedulingFn = fn (~Scheduler, ~GreenTask, ~GreenTask)\n+                            -> (~Scheduler, ~GreenTask);\n \n pub enum SchedMessage {\n     Wake,"}]}