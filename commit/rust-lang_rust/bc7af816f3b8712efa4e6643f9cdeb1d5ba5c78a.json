{"sha": "bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjN2FmODE2ZjNiODcxMmVmYTRlNjY0M2Y5Y2RlYjFkNWJhNWM3OGE=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-04-05T11:00:17Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-04-12T09:42:15Z"}, "message": "ICH: Hash everything that gets encoded into crate metadata.", "tree": {"sha": "0bbca767d33bb89337e1d5c58c58c788bebe0b32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bbca767d33bb89337e1d5c58c58c788bebe0b32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a", "html_url": "https://github.com/rust-lang/rust/commit/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c008cd70f5cb20cf22eb2cc9ae12f978296e8a45", "url": "https://api.github.com/repos/rust-lang/rust/commits/c008cd70f5cb20cf22eb2cc9ae12f978296e8a45", "html_url": "https://github.com/rust-lang/rust/commit/c008cd70f5cb20cf22eb2cc9ae12f978296e8a45"}], "stats": {"total": 642, "additions": 576, "deletions": 66}, "files": [{"sha": "3a6367c353c1eec7cdcc32a756281ef81c8f528e", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a", "patch": "@@ -13,8 +13,10 @@ use hir::def_id::DefId;\n use ich::{self, CachingCodemapView};\n use session::config::DebugInfoLevel::NoDebugInfo;\n use ty;\n+use util::nodemap::NodeMap;\n \n use std::hash as std_hash;\n+use std::collections::{HashMap, HashSet};\n \n use syntax::ast;\n use syntax::attr;\n@@ -296,3 +298,53 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Span {\n         }\n     }\n }\n+\n+pub fn hash_stable_hashmap<'a, 'tcx, K, V, R, SK, F, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                                        hasher: &mut StableHasher<W>,\n+                                                        map: &HashMap<K, V, R>,\n+                                                        extract_stable_key: F)\n+    where K: Eq + std_hash::Hash,\n+          V: HashStable<StableHashingContext<'a, 'tcx>>,\n+          R: std_hash::BuildHasher,\n+          SK: HashStable<StableHashingContext<'a, 'tcx>> + Ord + Clone,\n+          F: Fn(&mut StableHashingContext<'a, 'tcx>, &K) -> SK,\n+          W: StableHasherResult,\n+{\n+    let mut keys: Vec<_> = map.keys()\n+                              .map(|k| (extract_stable_key(hcx, k), k))\n+                              .collect();\n+    keys.sort_unstable_by_key(|&(ref stable_key, _)| stable_key.clone());\n+    keys.len().hash_stable(hcx, hasher);\n+    for (stable_key, key) in keys {\n+        stable_key.hash_stable(hcx, hasher);\n+        map[key].hash_stable(hcx, hasher);\n+    }\n+}\n+\n+pub fn hash_stable_hashset<'a, 'tcx, K, R, SK, F, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                                     hasher: &mut StableHasher<W>,\n+                                                     set: &HashSet<K, R>,\n+                                                     extract_stable_key: F)\n+    where K: Eq + std_hash::Hash,\n+          R: std_hash::BuildHasher,\n+          SK: HashStable<StableHashingContext<'a, 'tcx>> + Ord + Clone,\n+          F: Fn(&mut StableHashingContext<'a, 'tcx>, &K) -> SK,\n+          W: StableHasherResult,\n+{\n+    let mut keys: Vec<_> = set.iter()\n+                              .map(|k| extract_stable_key(hcx, k))\n+                              .collect();\n+    keys.sort_unstable();\n+    keys.hash_stable(hcx, hasher);\n+}\n+\n+pub fn hash_stable_nodemap<'a, 'tcx, V, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                           hasher: &mut StableHasher<W>,\n+                                           map: &NodeMap<V>)\n+    where V: HashStable<StableHashingContext<'a, 'tcx>>,\n+          W: StableHasherResult,\n+{\n+    hash_stable_hashmap(hcx, hasher, map, |hcx, node_id| {\n+        hcx.tcx.hir.definitions().node_to_hir_id(*node_id).local_id\n+    });\n+}"}, {"sha": "c682f6b8668c3f2b28e7af58dfacd5f6ec1cdeab", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 279, "deletions": 12, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a", "patch": "@@ -11,31 +11,37 @@\n //! This module contains `HashStable` implementations for various data types\n //! from rustc::ty in no particular order.\n \n-use ich::StableHashingContext;\n+use ich::{self, StableHashingContext, NodeIdHashingMode};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use std::hash as std_hash;\n use std::mem;\n use ty;\n \n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Ty<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TyS<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        let type_hash = hcx.tcx().type_id_hash(*self);\n-        type_hash.hash_stable(hcx, hasher);\n+        let ty::TyS {\n+            ref sty,\n+\n+            // The other fields just provide fast access to information that is\n+            // also contained in `sty`, so no need to hash them.\n+            ..\n+        } = *self;\n+\n+        sty.hash_stable(hcx, hasher);\n     }\n }\n \n impl_stable_hash_for!(struct ty::ItemSubsts<'tcx> { substs });\n \n-impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for ty::Slice<T>\n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for &'tcx ty::Slice<T>\n     where T: HashStable<StableHashingContext<'a, 'tcx>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        (&**self).hash_stable(hcx, hasher);\n+        (&self[..]).hash_stable(hcx, hasher);\n     }\n }\n \n@@ -67,9 +73,13 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Region {\n                 index.hash_stable(hcx, hasher);\n                 name.hash_stable(hcx, hasher);\n             }\n+            ty::ReScope(code_extent) => {\n+                code_extent.hash_stable(hcx, hasher);\n+            }\n+            ty::ReFree(ref free_region) => {\n+                free_region.hash_stable(hcx, hasher);\n+            }\n             ty::ReLateBound(..) |\n-            ty::ReFree(..) |\n-            ty::ReScope(..) |\n             ty::ReVar(..) |\n             ty::ReSkolemized(..) => {\n                 bug!(\"TypeIdHasher: unexpected region {:?}\", *self)\n@@ -127,7 +137,6 @@ impl_stable_hash_for!(enum ty::BorrowKind {\n     MutBorrow\n });\n \n-\n impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::UpvarCapture<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'tcx>,\n@@ -223,7 +232,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Predicate<'tcx\n     }\n }\n \n-\n impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::AdtFlags {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _: &mut StableHashingContext<'a, 'tcx>,\n@@ -303,7 +311,6 @@ for ::middle::const_val::ConstVal<'tcx> {\n \n impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n \n-\n impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n     parent,\n     predicates\n@@ -413,3 +420,263 @@ impl_stable_hash_for!(struct ::middle::region::CallSiteScopeData {\n impl_stable_hash_for!(struct ty::DebruijnIndex {\n     depth\n });\n+\n+impl_stable_hash_for!(enum ty::cast::CastKind {\n+    CoercionCast,\n+    PtrPtrCast,\n+    PtrAddrCast,\n+    AddrPtrCast,\n+    NumericCast,\n+    EnumCast,\n+    PrimIntCast,\n+    U8CharCast,\n+    ArrayPtrCast,\n+    FnPtrPtrCast,\n+    FnPtrAddrCast\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::region::CodeExtent\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            hcx.tcx().region_maps.code_extent_data(*self).hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::region::CodeExtentData\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use middle::region::CodeExtentData;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            CodeExtentData::Misc(node_id) |\n+            CodeExtentData::DestructionScope(node_id) => {\n+                node_id.hash_stable(hcx, hasher);\n+            }\n+            CodeExtentData::CallSiteScope { fn_id, body_id } |\n+            CodeExtentData::ParameterScope { fn_id, body_id } => {\n+                fn_id.hash_stable(hcx, hasher);\n+                body_id.hash_stable(hcx, hasher);\n+            }\n+            CodeExtentData::Remainder(block_remainder) => {\n+                block_remainder.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ::middle::region::BlockRemainder {\n+    block,\n+    first_statement_index\n+});\n+\n+impl_stable_hash_for!(struct ty::adjustment::CoerceUnsizedInfo {\n+    custom_kind\n+});\n+\n+impl_stable_hash_for!(struct ty::FreeRegion {\n+    scope,\n+    bound_region\n+});\n+\n+impl_stable_hash_for!(enum ty::BoundRegion {\n+    BrAnon(index),\n+    BrNamed(def_id, name),\n+    BrFresh(index),\n+    BrEnv\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeVariants<'tcx>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use ty::TypeVariants::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            TyBool  |\n+            TyChar  |\n+            TyStr   |\n+            TyNever => {\n+                // Nothing more to hash.\n+            }\n+            TyInt(int_ty) => {\n+                int_ty.hash_stable(hcx, hasher);\n+            }\n+            TyUint(uint_ty) => {\n+                uint_ty.hash_stable(hcx, hasher);\n+            }\n+            TyFloat(float_ty)  => {\n+                float_ty.hash_stable(hcx, hasher);\n+            }\n+            TyAdt(adt_def, substs) => {\n+                adt_def.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+            TyArray(inner_ty, len) => {\n+                inner_ty.hash_stable(hcx, hasher);\n+                len.hash_stable(hcx, hasher);\n+            }\n+            TySlice(inner_ty) => {\n+                inner_ty.hash_stable(hcx, hasher);\n+            }\n+            TyRawPtr(pointee_ty) => {\n+                pointee_ty.hash_stable(hcx, hasher);\n+            }\n+            TyRef(region, pointee_ty) => {\n+                region.hash_stable(hcx, hasher);\n+                pointee_ty.hash_stable(hcx, hasher);\n+            }\n+            TyFnDef(def_id, substs, ref sig) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+                sig.hash_stable(hcx, hasher);\n+            }\n+            TyFnPtr(ref sig) => {\n+                sig.hash_stable(hcx, hasher);\n+            }\n+            TyDynamic(ref existential_predicates, region) => {\n+                existential_predicates.hash_stable(hcx, hasher);\n+                region.hash_stable(hcx, hasher);\n+            }\n+            TyClosure(def_id, closure_substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                closure_substs.hash_stable(hcx, hasher);\n+            }\n+            TyTuple(inner_tys, from_diverging_type_var) => {\n+                inner_tys.hash_stable(hcx, hasher);\n+                from_diverging_type_var.hash_stable(hcx, hasher);\n+            }\n+            TyProjection(ref projection_ty) => {\n+                projection_ty.hash_stable(hcx, hasher);\n+            }\n+            TyAnon(def_id, substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+            TyParam(param_ty) => {\n+                param_ty.hash_stable(hcx, hasher);\n+            }\n+\n+            TyError     |\n+            TyInfer(..) => {\n+                bug!(\"ty::TypeVariants::hash_stable() - Unexpected variant.\")\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::ParamTy {\n+    idx,\n+    name\n+});\n+\n+impl_stable_hash_for!(struct ty::TypeAndMut<'tcx> {\n+    ty,\n+    mutbl\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::ExistentialPredicate<'tcx>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::ExistentialPredicate::Trait(ref trait_ref) => {\n+                trait_ref.hash_stable(hcx, hasher);\n+            }\n+            ty::ExistentialPredicate::Projection(ref projection) => {\n+                projection.hash_stable(hcx, hasher);\n+            }\n+            ty::ExistentialPredicate::AutoTrait(def_id) => {\n+                def_id.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::ExistentialTraitRef<'tcx> {\n+    def_id,\n+    substs\n+});\n+\n+impl_stable_hash_for!(struct ty::ExistentialProjection<'tcx> {\n+    trait_ref,\n+    item_name,\n+    ty\n+});\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeckTables<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::TypeckTables {\n+            ref type_relative_path_defs,\n+            ref node_types,\n+            ref item_substs,\n+            ref adjustments,\n+            ref method_map,\n+            ref upvar_capture_map,\n+            ref closure_tys,\n+            ref closure_kinds,\n+            ref liberated_fn_sigs,\n+            ref fru_field_types,\n+\n+            ref cast_kinds,\n+            lints: _,\n+            ref used_trait_imports,\n+            tainted_by_errors,\n+            ref free_region_map,\n+        } = *self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            ich::hash_stable_nodemap(hcx, hasher, type_relative_path_defs);\n+            ich::hash_stable_nodemap(hcx, hasher, node_types);\n+            ich::hash_stable_nodemap(hcx, hasher, item_substs);\n+            ich::hash_stable_nodemap(hcx, hasher, adjustments);\n+\n+            ich::hash_stable_hashmap(hcx, hasher, method_map, |hcx, method_call| {\n+                let ty::MethodCall {\n+                    expr_id,\n+                    autoderef\n+                } = *method_call;\n+\n+                let def_id = hcx.tcx().hir.local_def_id(expr_id);\n+                (hcx.def_path_hash(def_id), autoderef)\n+            });\n+\n+            ich::hash_stable_hashmap(hcx, hasher, upvar_capture_map, |hcx, up_var_id| {\n+                let ty::UpvarId {\n+                    var_id,\n+                    closure_expr_id\n+                } = *up_var_id;\n+\n+                let var_def_id = hcx.tcx().hir.local_def_id(var_id);\n+                let closure_def_id = hcx.tcx().hir.local_def_id(closure_expr_id);\n+                (hcx.def_path_hash(var_def_id), hcx.def_path_hash(closure_def_id))\n+            });\n+\n+            ich::hash_stable_nodemap(hcx, hasher, closure_tys);\n+            ich::hash_stable_nodemap(hcx, hasher, closure_kinds);\n+            ich::hash_stable_nodemap(hcx, hasher, liberated_fn_sigs);\n+            ich::hash_stable_nodemap(hcx, hasher, fru_field_types);\n+            ich::hash_stable_nodemap(hcx, hasher, cast_kinds);\n+\n+            ich::hash_stable_hashset(hcx, hasher, used_trait_imports, |hcx, def_id| {\n+                hcx.tcx().def_path_hash(*def_id)\n+            });\n+\n+            tainted_by_errors.hash_stable(hcx, hasher);\n+            free_region_map.hash_stable(hcx, hasher);\n+        })\n+    }\n+}"}, {"sha": "d70ed051ac4107ad2d3b31ca3d8fc2c1ed6183ac", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a", "patch": "@@ -12,8 +12,8 @@\n \n pub use self::fingerprint::Fingerprint;\n pub use self::caching_codemap_view::CachingCodemapView;\n-pub use self::hcx::{StableHashingContext, NodeIdHashingMode};\n-\n+pub use self::hcx::{StableHashingContext, NodeIdHashingMode, hash_stable_hashmap,\n+                    hash_stable_hashset, hash_stable_nodemap};\n mod fingerprint;\n mod caching_codemap_view;\n mod hcx;"}, {"sha": "1f96330d51da556241475daac6875ba2f84b9324", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a", "patch": "@@ -42,6 +42,7 @@\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(discriminant_value)]\n+#![feature(sort_unstable)]\n \n extern crate arena;\n extern crate core;"}, {"sha": "a8eb6a1074383a5ece01e6fcdd7995c9629e89ef", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a", "patch": "@@ -180,3 +180,7 @@ fn lub() {\n     map.relate_free_regions(frs[1], frs[2]);\n     assert_eq!(map.lub_free_regions(frs[0], frs[1]), ty::ReFree(frs[2]));\n }\n+\n+impl_stable_hash_for!(struct FreeRegionMap {\n+    relation\n+});"}, {"sha": "848e5a076bb9a3fee2b12dad3dbd8b61d8418962", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a", "patch": "@@ -40,6 +40,12 @@ unsafe impl<T> Array for [T; 8] {\n     const LEN: usize = 8;\n }\n \n+unsafe impl<T> Array for [T; 32] {\n+    type Element = T;\n+    type PartialStorage = [ManuallyDrop<T>; 32];\n+    const LEN: usize = 32;\n+}\n+\n pub struct ArrayVec<A: Array> {\n     count: usize,\n     values: A::PartialStorage"}, {"sha": "2631108aeb5fa3563c6f004d791927b8a2d080c5", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a", "patch": "@@ -9,11 +9,14 @@\n // except according to those terms.\n \n use bitvec::BitMatrix;\n+use stable_hasher::{HashStable, StableHasher, StableHasherResult};\n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n use std::cell::RefCell;\n use std::fmt::Debug;\n use std::mem;\n \n+\n+\n #[derive(Clone)]\n pub struct TransitiveRelation<T: Debug + PartialEq> {\n     // List of elements. This is used to map from a T to a usize.  We\n@@ -334,6 +337,49 @@ impl<T> Decodable for TransitiveRelation<T>\n     }\n }\n \n+impl<CTX, T> HashStable<CTX> for TransitiveRelation<T>\n+    where T: HashStable<CTX> + PartialEq + Debug\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        // We are assuming here that the relation graph has been built in a\n+        // deterministic way and we can just hash it the way it is.\n+        let TransitiveRelation {\n+            ref elements,\n+            ref edges,\n+            // \"closure\" is just a copy of the data above\n+            closure: _\n+        } = *self;\n+\n+        elements.hash_stable(hcx, hasher);\n+        edges.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for Edge {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let Edge {\n+            ref source,\n+            ref target,\n+        } = *self;\n+\n+        source.hash_stable(hcx, hasher);\n+        target.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for Index {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let Index(idx) = *self;\n+        idx.hash_stable(hcx, hasher);\n+    }\n+}\n+\n #[test]\n fn test_one_step() {\n     let mut relation = TransitiveRelation::new();"}, {"sha": "d9008ce555cc17afa48a0e4924f3dba299450dc9", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a", "patch": "@@ -10,14 +10,12 @@\n \n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n \n-use encoder::EncodeContext;\n+use index_builder::EntryBuilder;\n use schema::*;\n \n use rustc::hir;\n use rustc::ty;\n \n-use rustc_serialize::Encodable;\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Ast<'tcx> {\n     pub body: Lazy<hir::Body>,\n@@ -26,51 +24,53 @@ pub struct Ast<'tcx> {\n     pub rvalue_promotable_to_static: bool,\n }\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+impl_stable_hash_for!(struct Ast<'tcx> {\n+    body,\n+    tables,\n+    nested_bodies,\n+    rvalue_promotable_to_static\n+});\n+\n+impl<'a, 'b, 'tcx> EntryBuilder<'a, 'b, 'tcx> {\n     pub fn encode_body(&mut self, body_id: hir::BodyId) -> Lazy<Ast<'tcx>> {\n         let body = self.tcx.hir.body(body_id);\n         let lazy_body = self.lazy(body);\n \n         let tables = self.tcx.body_tables(body_id);\n         let lazy_tables = self.lazy(tables);\n \n-        let nested_pos = self.position();\n-        let nested_count = {\n-            let mut visitor = NestedBodyEncodingVisitor {\n-                ecx: self,\n-                count: 0,\n-            };\n-            visitor.visit_body(body);\n-            visitor.count\n+        let mut visitor = NestedBodyCollector {\n+            tcx: self.tcx,\n+            bodies_found: Vec::new(),\n         };\n+        visitor.visit_body(body);\n+        let lazy_nested_bodies = self.lazy_seq_ref_from_slice(&visitor.bodies_found);\n \n         let rvalue_promotable_to_static =\n             self.tcx.rvalue_promotable_to_static.borrow()[&body.value.id];\n \n         self.lazy(&Ast {\n             body: lazy_body,\n             tables: lazy_tables,\n-            nested_bodies: LazySeq::with_position_and_length(nested_pos, nested_count),\n+            nested_bodies: lazy_nested_bodies,\n             rvalue_promotable_to_static: rvalue_promotable_to_static\n         })\n     }\n }\n \n-struct NestedBodyEncodingVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    ecx: &'a mut EncodeContext<'b, 'tcx>,\n-    count: usize,\n+struct NestedBodyCollector<'a, 'tcx: 'a> {\n+    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+    bodies_found: Vec<&'tcx hir::Body>,\n }\n \n-impl<'a, 'b, 'tcx> Visitor<'tcx> for NestedBodyEncodingVisitor<'a, 'b, 'tcx> {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for NestedBodyCollector<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let body = self.ecx.tcx.hir.body(body);\n-        body.encode(self.ecx).unwrap();\n-        self.count += 1;\n-\n+        let body = self.tcx.hir.body(body);\n+        self.bodies_found.push(body);\n         self.visit_body(body);\n     }\n }"}, {"sha": "a74ce3f650226450cbd4f8f1e2ee66514c881418", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a", "patch": "@@ -15,6 +15,7 @@ use schema::*;\n use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary};\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId};\n use rustc::hir::map::definitions::DefPathTable;\n+use rustc::ich;\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::lang_items;\n use rustc::mir;\n@@ -42,7 +43,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::hir::intravisit;\n \n-use super::index_builder::{FromId, IndexBuilder, Untracked};\n+use super::index_builder::{FromId, IndexBuilder, Untracked, EntryBuilder};\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Encoder<'a>,\n@@ -54,6 +55,8 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n+\n+    pub metadata_hashes: Vec<(DefIndex, ich::Fingerprint)>,\n }\n \n macro_rules! encoder_methods {\n@@ -172,7 +175,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         })\n     }\n \n-    fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n+    pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n         where I: IntoIterator<Item = T>,\n               T: Encodable\n     {\n@@ -184,7 +187,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         })\n     }\n \n-    fn lazy_seq_ref<'b, I, T>(&mut self, iter: I) -> LazySeq<T>\n+    pub fn lazy_seq_ref<'b, I, T>(&mut self, iter: I) -> LazySeq<T>\n         where I: IntoIterator<Item = &'b T>,\n               T: 'b + Encodable\n     {\n@@ -233,10 +236,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Ok(())\n     }\n+}\n \n+impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     fn encode_item_variances(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n         let tcx = self.tcx;\n-        self.lazy_seq(tcx.item_variances(def_id).iter().cloned())\n+        self.lazy_seq_from_slice(&tcx.item_variances(def_id))\n     }\n \n     fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n@@ -305,7 +310,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = ModData {\n             reexports: match tcx.export_map.get(&id) {\n-                Some(exports) if *vis == hir::Public => self.lazy_seq_ref(exports),\n+                Some(exports) if *vis == hir::Public => {\n+                    self.lazy_seq_from_slice(exports.as_slice())\n+                }\n                 _ => LazySeq::empty(),\n             },\n         };\n@@ -339,14 +346,14 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         for (variant_index, variant) in def.variants.iter().enumerate() {\n             for (field_index, field) in variant.fields.iter().enumerate() {\n                 self.record(field.did,\n-                            EncodeContext::encode_field,\n+                            EntryBuilder::encode_field,\n                             (adt_def_id, Untracked((variant_index, field_index))));\n             }\n         }\n     }\n }\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     /// Encode data for the given field of the given variant of the\n     /// given ADT. The indices of the variant/field are untracked:\n     /// this is ok because we will have to lookup the adt-def by its\n@@ -907,7 +914,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 let def = self.tcx.lookup_adt_def(def_id);\n                 for (i, variant) in def.variants.iter().enumerate() {\n                     self.record(variant.did,\n-                                EncodeContext::encode_enum_variant_info,\n+                                EntryBuilder::encode_enum_variant_info,\n                                 (def_id, Untracked(i)));\n                 }\n             }\n@@ -918,7 +925,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 if !struct_def.is_struct() {\n                     let ctor_def_id = self.tcx.hir.local_def_id(struct_def.id());\n                     self.record(ctor_def_id,\n-                                EncodeContext::encode_struct_ctor,\n+                                EntryBuilder::encode_struct_ctor,\n                                 (def_id, ctor_def_id));\n                 }\n             }\n@@ -928,22 +935,22 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n             hir::ItemImpl(..) => {\n                 for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n                     self.record(trait_item_def_id,\n-                                EncodeContext::encode_info_for_impl_item,\n+                                EntryBuilder::encode_info_for_impl_item,\n                                 trait_item_def_id);\n                 }\n             }\n             hir::ItemTrait(..) => {\n                 for &item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n                     self.record(item_def_id,\n-                                EncodeContext::encode_info_for_trait_item,\n+                                EntryBuilder::encode_info_for_trait_item,\n                                 item_def_id);\n                 }\n             }\n         }\n     }\n }\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_foreign_item(&mut self,\n                                     (def_id, nitem): (DefId, &hir::ForeignItem))\n                                     -> Entry<'tcx> {\n@@ -1002,15 +1009,15 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         match item.node {\n             hir::ItemExternCrate(_) |\n             hir::ItemUse(..) => (), // ignore these\n-            _ => self.index.record(def_id, EncodeContext::encode_info_for_item, (def_id, item)),\n+            _ => self.index.record(def_id, EntryBuilder::encode_info_for_item, (def_id, item)),\n         }\n         self.index.encode_addl_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n         let def_id = self.index.tcx.hir.local_def_id(ni.id);\n         self.index.record(def_id,\n-                          EncodeContext::encode_info_for_foreign_item,\n+                          EntryBuilder::encode_info_for_foreign_item,\n                           (def_id, ni));\n     }\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n@@ -1023,7 +1030,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n     }\n     fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n         let def_id = self.index.tcx.hir.local_def_id(macro_def.id);\n-        self.index.record(def_id, EncodeContext::encode_info_for_macro_def, macro_def);\n+        self.index.record(def_id, EntryBuilder::encode_info_for_macro_def, macro_def);\n     }\n }\n \n@@ -1032,29 +1039,29 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         for ty_param in &generics.ty_params {\n             let def_id = self.tcx.hir.local_def_id(ty_param.id);\n             let has_default = Untracked(ty_param.default.is_some());\n-            self.record(def_id, EncodeContext::encode_info_for_ty_param, (def_id, has_default));\n+            self.record(def_id, EntryBuilder::encode_info_for_ty_param, (def_id, has_default));\n         }\n     }\n \n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n         if let hir::TyImplTrait(_) = ty.node {\n             let def_id = self.tcx.hir.local_def_id(ty.id);\n-            self.record(def_id, EncodeContext::encode_info_for_anon_ty, def_id);\n+            self.record(def_id, EntryBuilder::encode_info_for_anon_ty, def_id);\n         }\n     }\n \n     fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprClosure(..) => {\n                 let def_id = self.tcx.hir.local_def_id(expr.id);\n-                self.record(def_id, EncodeContext::encode_info_for_closure, def_id);\n+                self.record(def_id, EntryBuilder::encode_info_for_closure, def_id);\n             }\n             _ => {}\n         }\n     }\n }\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_ty_param(&mut self,\n                                 (def_id, Untracked(has_default)): (DefId, Untracked<bool>))\n                                 -> Entry<'tcx> {\n@@ -1133,11 +1140,17 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n+    fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> LazySeq<ast::Attribute> {\n+        self.lazy_seq_from_slice(attrs)\n+    }\n+}\n+\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_items(&mut self) -> Index {\n         let krate = self.tcx.hir.krate();\n         let mut index = IndexBuilder::new(self);\n         index.record(DefId::local(CRATE_DEF_INDEX),\n-                     EncodeContext::encode_info_for_mod,\n+                     EntryBuilder::encode_info_for_mod,\n                      FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n         let mut visitor = EncodeVisitor { index: index };\n         krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n@@ -1147,10 +1160,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         visitor.index.into_items()\n     }\n \n-    fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> LazySeq<ast::Attribute> {\n-        self.lazy_seq_ref(attrs)\n-    }\n-\n     fn encode_crate_deps(&mut self) -> LazySeq<CrateDep> {\n         fn get_ordered_deps(cstore: &cstore::CStore) -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {\n             // Pull the cnums and name,vers,hash out of cstore\n@@ -1298,7 +1307,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             None => LazySeq::empty(),\n         }\n     }\n+}\n \n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot> {\n         let mut i = self.position();\n         let crate_deps = self.encode_crate_deps();\n@@ -1448,6 +1459,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),\n+            metadata_hashes: Vec::new(),\n         };\n \n         // Encode the rustc version string in a predictable location."}, {"sha": "389ada12da81e815344cc8b697cbd4bc515b83fa", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 70, "deletions": 7, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a", "patch": "@@ -59,14 +59,19 @@ use encoder::EncodeContext;\n use index::Index;\n use schema::*;\n \n-use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n+use rustc::ich::{StableHashingContext, Fingerprint};\n use rustc::ty::TyCtxt;\n use syntax::ast;\n \n use std::ops::{Deref, DerefMut};\n \n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n+use rustc_serialize::Encodable;\n+\n+use rustc::dep_graph::DepNode;\n+\n /// Builder that can encode new items, adding them into the index.\n /// Item encoding cannot be nested.\n pub struct IndexBuilder<'a, 'b: 'a, 'tcx: 'b> {\n@@ -112,16 +117,29 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     /// holds, and that it is therefore not gaining \"secret\" access to\n     /// bits of HIR or other state that would not be trackd by the\n     /// content system.\n-    pub fn record<DATA>(&mut self,\n-                        id: DefId,\n-                        op: fn(&mut EncodeContext<'b, 'tcx>, DATA) -> Entry<'tcx>,\n-                        data: DATA)\n+    pub fn record<'x, DATA>(&'x mut self,\n+                            id: DefId,\n+                            op: fn(&mut EntryBuilder<'x, 'b, 'tcx>, DATA) -> Entry<'tcx>,\n+                            data: DATA)\n         where DATA: DepGraphRead\n     {\n         let _task = self.tcx.dep_graph.in_task(DepNode::MetaData(id));\n         data.read(self.tcx);\n-        let entry = op(&mut self.ecx, data);\n-        self.items.record(id, self.ecx.lazy(&entry));\n+\n+        assert!(id.is_local());\n+        let tcx: TyCtxt<'b, 'tcx, 'tcx> = self.ecx.tcx;\n+        let ecx: &'x mut EncodeContext<'b, 'tcx> = &mut *self.ecx;\n+        let mut entry_builder = EntryBuilder {\n+            tcx: tcx,\n+            ecx: ecx,\n+            hasher: StableHasher::new(),\n+            hcx: StableHashingContext::new(tcx),\n+        };\n+\n+        let entry = op(&mut entry_builder, data);\n+        let entry = entry_builder.ecx.lazy(&entry);\n+        entry_builder.finish(id);\n+        self.items.record(id, entry);\n     }\n \n     pub fn into_items(self) -> Index {\n@@ -223,3 +241,48 @@ impl<T> DepGraphRead for FromId<T> {\n         tcx.hir.read(self.0);\n     }\n }\n+\n+pub struct EntryBuilder<'a, 'b: 'a, 'tcx: 'b> {\n+    pub tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+    ecx: &'a mut EncodeContext<'b, 'tcx>,\n+    hasher: StableHasher<Fingerprint>,\n+    hcx: StableHashingContext<'b, 'tcx>,\n+}\n+\n+impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n+\n+    pub fn finish(self, def_id: DefId) {\n+        let hash = self.hasher.finish();\n+        self.ecx.metadata_hashes.push((def_id.index, hash));\n+    }\n+\n+    pub fn lazy<T>(&mut self, value: &T) -> Lazy<T>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        value.hash_stable(&mut self.hcx, &mut self.hasher);\n+        self.ecx.lazy(value)\n+    }\n+\n+    pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n+        where I: IntoIterator<Item = T>,\n+              T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        let items: Vec<T> = iter.into_iter().collect();\n+        items.hash_stable(&mut self.hcx, &mut self.hasher);\n+        self.ecx.lazy_seq(items)\n+    }\n+\n+    pub fn lazy_seq_from_slice<T>(&mut self, slice: &[T]) -> LazySeq<T>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        slice.hash_stable(&mut self.hcx, &mut self.hasher);\n+        self.ecx.lazy_seq_ref(slice.iter())\n+    }\n+\n+    pub fn lazy_seq_ref_from_slice<T>(&mut self, slice: &[&T]) -> LazySeq<T>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        slice.hash_stable(&mut self.hcx, &mut self.hasher);\n+        self.ecx.lazy_seq_ref(slice.iter().map(|x| *x))\n+    }\n+}"}, {"sha": "b9e142ac65072e18dd2c256a4a418067700d0553", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a", "patch": "@@ -27,6 +27,7 @@\n #![feature(rustc_private)]\n #![feature(specialization)]\n #![feature(staged_api)]\n+#![feature(discriminant_value)]\n \n #[macro_use]\n extern crate log;"}, {"sha": "6ffa31c0727093e5c3d803eead57878ad77761d7", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=bc7af816f3b8712efa4e6643f9cdeb1d5ba5c78a", "patch": "@@ -28,6 +28,9 @@ use syntax_pos::{self, Span};\n \n use std::marker::PhantomData;\n \n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable,\n+                                           StableHasherResult};\n+\n pub fn rustc_version() -> String {\n     format!(\"rustc {}\",\n             option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n@@ -100,6 +103,15 @@ impl<T> Clone for Lazy<T> {\n impl<T> serialize::UseSpecializedEncodable for Lazy<T> {}\n impl<T> serialize::UseSpecializedDecodable for Lazy<T> {}\n \n+impl<CTX, T> HashStable<CTX> for Lazy<T> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut CTX,\n+                                          _: &mut StableHasher<W>) {\n+            // There's nothing to do. Whatever got encoded within this Lazy<>\n+            // wrapper has already been hashed.\n+    }\n+}\n+\n /// A sequence of type T referred to by its absolute position\n /// in the metadata and length, and which can be decoded lazily.\n /// The sequence is a single node for the purposes of `Lazy`.\n@@ -148,6 +160,15 @@ impl<T> Clone for LazySeq<T> {\n impl<T> serialize::UseSpecializedEncodable for LazySeq<T> {}\n impl<T> serialize::UseSpecializedDecodable for LazySeq<T> {}\n \n+impl<CTX, T> HashStable<CTX> for LazySeq<T> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut CTX,\n+                                          _: &mut StableHasher<W>) {\n+            // There's nothing to do. Whatever got encoded within this Lazy<>\n+            // wrapper has already been hashed.\n+    }\n+}\n+\n /// Encoding / decoding state for `Lazy` and `LazySeq`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum LazyState {\n@@ -251,17 +272,23 @@ pub struct ModData {\n     pub reexports: LazySeq<def::Export>,\n }\n \n+impl_stable_hash_for!(struct ModData { reexports });\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct MacroDef {\n     pub body: String,\n }\n \n+impl_stable_hash_for!(struct MacroDef { body });\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData {\n     pub constness: hir::Constness,\n     pub arg_names: LazySeq<ast::Name>,\n }\n \n+impl_stable_hash_for!(struct FnData { constness, arg_names });\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct VariantData<'tcx> {\n     pub ctor_kind: CtorKind,\n@@ -273,6 +300,13 @@ pub struct VariantData<'tcx> {\n     pub struct_ctor: Option<DefIndex>,\n }\n \n+impl_stable_hash_for!(struct VariantData<'tcx> {\n+    ctor_kind,\n+    discr,\n+    evaluated_discr,\n+    struct_ctor\n+});\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TraitData<'tcx> {\n     pub unsafety: hir::Unsafety,\n@@ -281,6 +315,13 @@ pub struct TraitData<'tcx> {\n     pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n }\n \n+impl_stable_hash_for!(struct TraitData<'tcx> {\n+    unsafety,\n+    paren_sugar,\n+    has_default_impl,\n+    super_predicates\n+});\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ImplData<'tcx> {\n     pub polarity: hir::ImplPolarity,\n@@ -291,6 +332,14 @@ pub struct ImplData<'tcx> {\n     pub trait_ref: Option<Lazy<ty::TraitRef<'tcx>>>,\n }\n \n+impl_stable_hash_for!(struct ImplData<'tcx> {\n+    polarity,\n+    parent_impl,\n+    coerce_unsized_info,\n+    trait_ref\n+});\n+\n+\n /// Describes whether the container of an associated item\n /// is a trait or an impl and whether, in a trait, it has\n /// a default, or an in impl, whether it's marked \"default\".\n@@ -302,6 +351,13 @@ pub enum AssociatedContainer {\n     ImplFinal,\n }\n \n+impl_stable_hash_for!(enum ::schema::AssociatedContainer {\n+    TraitRequired,\n+    TraitWithDefault,\n+    ImplDefault,\n+    ImplFinal\n+});\n+\n impl AssociatedContainer {\n     pub fn with_def_id(&self, def_id: DefId) -> ty::AssociatedItemContainer {\n         match *self {\n@@ -335,9 +391,11 @@ pub struct MethodData {\n     pub container: AssociatedContainer,\n     pub has_self: bool,\n }\n+impl_stable_hash_for!(struct MethodData { fn_data, container, has_self });\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ClosureData<'tcx> {\n     pub kind: ty::ClosureKind,\n     pub ty: Lazy<ty::PolyFnSig<'tcx>>,\n }\n+impl_stable_hash_for!(struct ClosureData<'tcx> { kind, ty });"}]}