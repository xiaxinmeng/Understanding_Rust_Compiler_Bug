{"sha": "4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZDcxNmFjOGViNjBkYmFjZWQ5ZTNkMmJhZmVlODliNzEzYTc4NDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-17T04:31:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-17T04:31:48Z"}, "message": "auto merge of #7831 : ozten/rust/issues-7764-swap_unwarp-take-unwrap, r=pcwalton\n\nFixes Issue #7764\r\n\r\nRunning `make check` I do get a failure:\r\n\r\n    test rt::io::extensions::test::push_bytes ... ok\r\n    rustest rt::comm::test::oneshot_single_thread_send_port_close ... t: task failed at 'Unhandled condition:\r\n     read_error: {kind: OtherIoError, desc: \"Placeholder error. You shouldn\\'t be seeing this\", detail: None}',\r\n     /Users/shout/Projects/rust/src/libstd/condition.rs:50\r\n    /bin/sh: line 1: 35056 Abort trap: 6           x86_64-apple-darwin/stage2/test/stdtest-x86_64-apple-darwin --logfile\r\n     tmp/check-stage2-T-x86_64-apple-darwin-H-x86_64-apple-darwin-std.log\r\n    make: *** [tmp/check-stage2-T-x86_64-apple-darwin-H-x86_64-apple-darwin-std.ok] Error 134", "tree": {"sha": "0e4b5bfa54cd0ada0c34029e3ab59eb7c50f5fc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e4b5bfa54cd0ada0c34029e3ab59eb7c50f5fc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "html_url": "https://github.com/rust-lang/rust/commit/4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a1002fbd93989bbf5c8989ed8002827920b375b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a1002fbd93989bbf5c8989ed8002827920b375b", "html_url": "https://github.com/rust-lang/rust/commit/8a1002fbd93989bbf5c8989ed8002827920b375b"}, {"sha": "712ac836c63c3ae98daf9fb98b7b96ed73347848", "url": "https://api.github.com/repos/rust-lang/rust/commits/712ac836c63c3ae98daf9fb98b7b96ed73347848", "html_url": "https://github.com/rust-lang/rust/commit/712ac836c63c3ae98daf9fb98b7b96ed73347848"}], "stats": {"total": 86, "additions": 43, "deletions": 43}, "files": [{"sha": "35600df4f9dd050d36aa7f647f1a331894ff04a2", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "patch": "@@ -173,11 +173,11 @@ impl<T> Deque<T> for DList<T> {\n                 let tail_own = match tail.prev.resolve() {\n                     None => {\n                         self.list_tail = Rawlink::none();\n-                        self.list_head.swap_unwrap()\n+                        self.list_head.take_unwrap()\n                     },\n                     Some(tail_prev) => {\n                         self.list_tail = tail.prev;\n-                        tail_prev.next.swap_unwrap()\n+                        tail_prev.next.take_unwrap()\n                     }\n                 };\n                 Some(tail_own.value)\n@@ -465,7 +465,7 @@ impl<'self, A> ListInsertion<A> for MutDListIterator<'self, A> {\n                     Some(prev) => prev,\n                 };\n                 let mut ins_node = ~Node{value: elt, next: None, prev: Rawlink::none()};\n-                let node_own = prev_node.next.swap_unwrap();\n+                let node_own = prev_node.next.take_unwrap();\n                 ins_node.next = link_with_prev(node_own, Rawlink::some(ins_node));\n                 prev_node.next = link_with_prev(ins_node, Rawlink::some(prev_node));\n                 self.list.length += 1;"}, {"sha": "11e3106e4b5a9213f04523366a18ed87289b7d74", "filename": "src/libextra/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibextra%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibextra%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet%2Fip.rs?ref=4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "patch": "@@ -116,7 +116,7 @@ pub fn get_addr(node: &str, iotask: &iotask)\n     let (output_po, output_ch) = stream();\n     let mut output_ch = Some(SharedChan::new(output_ch));\n     do str::as_buf(node) |node_ptr, len| {\n-        let output_ch = output_ch.swap_unwrap();\n+        let output_ch = output_ch.take_unwrap();\n         debug!(\"slice len %?\", len);\n         let handle = create_uv_getaddrinfo_t();\n         let handle_ptr: *uv_getaddrinfo_t = &handle;"}, {"sha": "632f5d7827d4cfb38de9704709f3c7815fc1c40f", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "patch": "@@ -260,7 +260,7 @@ impl<'self> Condvar<'self> {\n                             signal_waitqueue(&state.waiters);\n                         }\n                         // Enqueue ourself to be woken up by a signaller.\n-                        let SignalEnd = SignalEnd.swap_unwrap();\n+                        let SignalEnd = SignalEnd.take_unwrap();\n                         state.blocked[condvar_id].tail.send(SignalEnd);\n                     } else {\n                         out_of_bounds = Some(state.blocked.len());\n@@ -281,7 +281,7 @@ impl<'self> Condvar<'self> {\n             // Unconditionally \"block\". (Might not actually block if a\n             // signaller already sent -- I mean 'unconditionally' in contrast\n             // with acquire().)\n-            let _ = comm::recv_one(WaitEnd.swap_unwrap());\n+            let _ = comm::recv_one(WaitEnd.take_unwrap());\n         }\n \n         // This is needed for a failing condition variable to reacquire the\n@@ -353,7 +353,7 @@ impl<'self> Condvar<'self> {\n                 }\n             }\n             do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n-                let queue = queue.swap_unwrap();\n+                let queue = queue.take_unwrap();\n                 broadcast_waitqueue(&queue)\n             }\n         }\n@@ -1436,7 +1436,7 @@ mod tests {\n         do x.write_downgrade |xwrite| {\n             let mut xopt = Some(xwrite);\n             do y.write_downgrade |_ywrite| {\n-                y.downgrade(xopt.swap_unwrap());\n+                y.downgrade(xopt.take_unwrap());\n                 error!(\"oops, y.downgrade(x) should have failed!\");\n             }\n         }"}, {"sha": "bd13c8619be1d071b192cde278f357ce856ee7b8", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "patch": "@@ -552,7 +552,7 @@ fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n // Remove left horizontal link by rotating right\n fn skew<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n     if node.left.map_default(false, |x| x.level == node.level) {\n-        let mut save = node.left.swap_unwrap();\n+        let mut save = node.left.take_unwrap();\n         swap(&mut node.left, &mut save.right); // save.right now None\n         swap(node, &mut save);\n         node.right = Some(save);\n@@ -564,7 +564,7 @@ fn skew<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n fn split<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n     if node.right.map_default(false,\n       |x| x.right.map_default(false, |y| y.level == node.level)) {\n-        let mut save = node.right.swap_unwrap();\n+        let mut save = node.right.take_unwrap();\n         swap(&mut node.right, &mut save.left); // save.left now None\n         save.level += 1;\n         swap(node, &mut save);\n@@ -643,7 +643,7 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n           Equal => {\n             if save.left.is_some() {\n                 if save.right.is_some() {\n-                    let mut left = save.left.swap_unwrap();\n+                    let mut left = save.left.take_unwrap();\n                     if left.right.is_some() {\n                         heir_swap(save, &mut left.right);\n                     } else {\n@@ -653,13 +653,13 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n                     save.left = Some(left);\n                     (remove(&mut save.left, key), true)\n                 } else {\n-                    let new = save.left.swap_unwrap();\n+                    let new = save.left.take_unwrap();\n                     let ~TreeNode{value, _} = replace(save, new);\n-                    *save = save.left.swap_unwrap();\n+                    *save = save.left.take_unwrap();\n                     (Some(value), true)\n                 }\n             } else if save.right.is_some() {\n-                let new = save.right.swap_unwrap();\n+                let new = save.right.take_unwrap();\n                 let ~TreeNode{value, _} = replace(save, new);\n                 (Some(value), true)\n             } else {"}, {"sha": "b0811674a7bfa573d97f6e548974971107e6a0e6", "filename": "src/libstd/option.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "patch": "@@ -203,14 +203,14 @@ impl<T> Option<T> {\n     /// Apply a function to the contained value or do nothing\n     pub fn mutate(&mut self, f: &fn(T) -> T) {\n         if self.is_some() {\n-            *self = Some(f(self.swap_unwrap()));\n+            *self = Some(f(self.take_unwrap()));\n         }\n     }\n \n     /// Apply a function to the contained value or set it to a default\n     pub fn mutate_default(&mut self, def: T, f: &fn(T) -> T) {\n         if self.is_some() {\n-            *self = Some(f(self.swap_unwrap()));\n+            *self = Some(f(self.take_unwrap()));\n         } else {\n             *self = Some(def);\n         }\n@@ -293,8 +293,8 @@ impl<T> Option<T> {\n      * Fails if the value equals `None`.\n      */\n     #[inline]\n-    pub fn swap_unwrap(&mut self) -> T {\n-        if self.is_none() { fail!(\"option::swap_unwrap none\") }\n+    pub fn take_unwrap(&mut self) -> T {\n+        if self.is_none() { fail!(\"option::take_unwrap none\") }\n         util::replace(self, None).unwrap()\n     }\n \n@@ -460,16 +460,16 @@ fn test_option_dance() {\n     let mut y = Some(5);\n     let mut y2 = 0;\n     for x.iter().advance |_x| {\n-        y2 = y.swap_unwrap();\n+        y2 = y.take_unwrap();\n     }\n     assert_eq!(y2, 5);\n     assert!(y.is_none());\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_option_too_much_dance() {\n     let mut y = Some(util::NonCopyable);\n-    let _y2 = y.swap_unwrap();\n-    let _y3 = y.swap_unwrap();\n+    let _y2 = y.take_unwrap();\n+    let _y3 = y.take_unwrap();\n }\n \n #[test]"}, {"sha": "4e4145ddc161ff9e5301272073d3cee0a29442a3", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "patch": "@@ -328,7 +328,7 @@ impl Scheduler {\n     /// Given an input Coroutine sends it back to its home scheduler.\n     fn send_task_home(task: ~Task) {\n         let mut task = task;\n-        let mut home = task.home.swap_unwrap();\n+        let mut home = task.home.take_unwrap();\n         match home {\n             Sched(ref mut home_handle) => {\n                 home_handle.send(PinnedTask(task));\n@@ -418,7 +418,7 @@ impl Scheduler {\n \n         do self.deschedule_running_task_and_then |sched, dead_task| {\n             let mut dead_task = dead_task;\n-            let coroutine = dead_task.coroutine.swap_unwrap();\n+            let coroutine = dead_task.coroutine.take_unwrap();\n             coroutine.recycle(&mut sched.stack_pool);\n         }\n \n@@ -506,7 +506,7 @@ impl Scheduler {\n         this.metrics.context_switches_task_to_sched += 1;\n \n         unsafe {\n-            let blocked_task = this.current_task.swap_unwrap();\n+            let blocked_task = this.current_task.take_unwrap();\n             let f_fake_region = transmute::<&fn(&mut Scheduler, ~Task),\n                                             &fn(&mut Scheduler, ~Task)>(f);\n             let f_opaque = ClosureConverter::from_fn(f_fake_region);\n@@ -538,7 +538,7 @@ impl Scheduler {\n         rtdebug!(\"switching tasks\");\n         this.metrics.context_switches_task_to_task += 1;\n \n-        let old_running_task = this.current_task.swap_unwrap();\n+        let old_running_task = this.current_task.take_unwrap();\n         let f_fake_region = unsafe {\n             transmute::<&fn(&mut Scheduler, ~Task),\n                         &fn(&mut Scheduler, ~Task)>(f)\n@@ -576,7 +576,7 @@ impl Scheduler {\n \n         assert!(self.cleanup_job.is_some());\n \n-        let cleanup_job = self.cleanup_job.swap_unwrap();\n+        let cleanup_job = self.cleanup_job.take_unwrap();\n         match cleanup_job {\n             DoNothing => { }\n             GiveTask(task, f) => (f.to_fn())(self, task)"}, {"sha": "449438b92055178901e27f2237b1fb4ccf5931ce", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "patch": "@@ -127,7 +127,7 @@ impl Task {\n \n         // Wait for children. Possibly report the exit status.\n         let local_success = !self.unwinder.unwinding;\n-        let join_latch = self.join_latch.swap_unwrap();\n+        let join_latch = self.join_latch.take_unwrap();\n         match self.on_exit {\n             Some(ref on_exit) => {\n                 let success = join_latch.wait(local_success);"}, {"sha": "f61eee8859b1a28f2de2dd3115a8fd917cd50a2e", "filename": "src/libstd/rt/tube.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftube.rs?ref=4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "patch": "@@ -53,7 +53,7 @@ impl<T> Tube<T> {\n             if (*state).blocked_task.is_some() {\n                 // There's a waiting task. Wake it up\n                 rtdebug!(\"waking blocked tube\");\n-                let task = (*state).blocked_task.swap_unwrap();\n+                let task = (*state).blocked_task.take_unwrap();\n                 let sched = Local::take::<Scheduler>();\n                 sched.resume_task_immediately(task);\n             }"}, {"sha": "81428509e33e53d44afef52055180f81ed9ab863", "filename": "src/libstd/rt/uv/async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Frt%2Fuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fasync.rs?ref=4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "patch": "@@ -62,7 +62,7 @@ impl AsyncWatcher {\n             let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n             {\n                 let data = watcher.get_watcher_data();\n-                data.close_cb.swap_unwrap()();\n+                data.close_cb.take_unwrap()();\n             }\n             watcher.drop_watcher_data();\n             unsafe { uvll::free_handle(handle as *c_void); }"}, {"sha": "28b101f686d4cb4d70029c4195c9858d592353cc", "filename": "src/libstd/rt/uv/idle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fidle.rs?ref=4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "patch": "@@ -73,7 +73,7 @@ impl IdleWatcher {\n                 let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n                 {\n                     let data = idle_watcher.get_watcher_data();\n-                    data.close_cb.swap_unwrap()();\n+                    data.close_cb.take_unwrap()();\n                 }\n                 idle_watcher.drop_watcher_data();\n                 uvll::idle_delete(handle);"}, {"sha": "09c748ec04782e9bd5e5926d2c7661f2398f9118", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "patch": "@@ -209,7 +209,7 @@ impl StreamWatcher {\n             let write_request: WriteRequest = NativeHandle::from_native_handle(req);\n             let mut stream_watcher = write_request.stream();\n             write_request.delete();\n-            let cb = stream_watcher.get_watcher_data().write_cb.swap_unwrap();\n+            let cb = stream_watcher.get_watcher_data().write_cb.take_unwrap();\n             let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n             cb(stream_watcher, status);\n         }\n@@ -233,7 +233,7 @@ impl StreamWatcher {\n \n         extern fn close_cb(handle: *uvll::uv_stream_t) {\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n-            stream_watcher.get_watcher_data().close_cb.swap_unwrap()();\n+            stream_watcher.get_watcher_data().close_cb.take_unwrap()();\n             stream_watcher.drop_watcher_data();\n             unsafe { free_handle(handle as *c_void) }\n         }\n@@ -301,7 +301,7 @@ impl TcpWatcher {\n                 let connect_request: ConnectRequest = NativeHandle::from_native_handle(req);\n                 let mut stream_watcher = connect_request.stream();\n                 connect_request.delete();\n-                let cb = stream_watcher.get_watcher_data().connect_cb.swap_unwrap();\n+                let cb = stream_watcher.get_watcher_data().connect_cb.take_unwrap();\n                 let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n                 cb(stream_watcher, status);\n             }\n@@ -438,7 +438,7 @@ impl UdpWatcher {\n             let send_request: UdpSendRequest = NativeHandle::from_native_handle(req);\n             let mut udp_watcher = send_request.handle();\n             send_request.delete();\n-            let cb = udp_watcher.get_watcher_data().udp_send_cb.swap_unwrap();\n+            let cb = udp_watcher.get_watcher_data().udp_send_cb.take_unwrap();\n             let status = status_to_maybe_uv_error(udp_watcher.native_handle(), status);\n             cb(udp_watcher, status);\n         }\n@@ -456,7 +456,7 @@ impl UdpWatcher {\n \n         extern fn close_cb(handle: *uvll::uv_udp_t) {\n             let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n-            udp_watcher.get_watcher_data().close_cb.swap_unwrap()();\n+            udp_watcher.get_watcher_data().close_cb.take_unwrap()();\n             udp_watcher.drop_watcher_data();\n             unsafe { free_handle(handle as *c_void) }\n         }"}, {"sha": "bc5399327a03216952ca306e333241eb8ed92df6", "filename": "src/libstd/rt/uv/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ftimer.rs?ref=4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "patch": "@@ -70,7 +70,7 @@ impl TimerWatcher {\n             let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n             {\n                 let data = watcher.get_watcher_data();\n-                data.close_cb.swap_unwrap()();\n+                data.close_cb.take_unwrap()();\n             }\n             watcher.drop_watcher_data();\n             unsafe {"}, {"sha": "bf09a533ebe12666600f86d585fba993235085db", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "patch": "@@ -302,7 +302,7 @@ fn each_ancestor(list:        &mut AncestorList,\n         fn with_parent_tg<U>(parent_group: &mut Option<TaskGroupArc>,\n                              blk: &fn(TaskGroupInner) -> U) -> U {\n             // If this trips, more likely the problem is 'blk' failed inside.\n-            let tmp_arc = parent_group.swap_unwrap();\n+            let tmp_arc = parent_group.take_unwrap();\n             let result = do access_group(&tmp_arc) |tg_opt| { blk(tg_opt) };\n             *parent_group = Some(tmp_arc);\n             result\n@@ -609,7 +609,7 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n     };\n \n     if opts.notify_chan.is_some() {\n-        let notify_chan = opts.notify_chan.swap_unwrap();\n+        let notify_chan = opts.notify_chan.take_unwrap();\n         let notify_chan = Cell::new(notify_chan);\n         let on_exit: ~fn(bool) = |success| {\n             notify_chan.take().send(\n@@ -647,7 +647,7 @@ fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n             let notify_chan = if opts.notify_chan.is_none() {\n                 None\n             } else {\n-                Some(opts.notify_chan.swap_unwrap())\n+                Some(opts.notify_chan.take_unwrap())\n             };\n \n             let child_wrapper = make_child_wrapper(new_task, child_tg,"}, {"sha": "0bf492ae55f0ca87ba2f3ab2891e534afe577f2d", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "patch": "@@ -60,8 +60,8 @@ fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n     // Send/Receive lots of messages.\n     for uint::range(0u, count) |j| {\n         //error!(\"task %?, iter %?\", i, j);\n-        let mut num_chan2 = num_chan.swap_unwrap();\n-        let mut num_port2 = num_port.swap_unwrap();\n+        let mut num_chan2 = num_chan.take_unwrap();\n+        let mut num_port2 = num_port.take_unwrap();\n         send(&num_chan2, i * j);\n         num_chan = Some(num_chan2);\n         let _n = recv(&num_port2);"}, {"sha": "a5f96b35999e2290f45a0aef63abc426cd6b56bd", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bd716ac8eb60dbaced9e3d2bafee89b713a7849/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=4bd716ac8eb60dbaced9e3d2bafee89b713a7849", "patch": "@@ -56,8 +56,8 @@ fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n     // Send/Receive lots of messages.\n     for uint::range(0u, count) |j| {\n         //error!(\"task %?, iter %?\", i, j);\n-        let mut num_chan2 = num_chan.swap_unwrap();\n-        let mut num_port2 = num_port.swap_unwrap();\n+        let mut num_chan2 = num_chan.take_unwrap();\n+        let mut num_port2 = num_port.take_unwrap();\n         send(&num_chan2, i * j);\n         num_chan = Some(num_chan2);\n         let _n = recv(&num_port2);"}]}