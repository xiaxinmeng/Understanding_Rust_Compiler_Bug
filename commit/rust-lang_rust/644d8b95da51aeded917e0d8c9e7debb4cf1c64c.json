{"sha": "644d8b95da51aeded917e0d8c9e7debb4cf1c64c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0NGQ4Yjk1ZGE1MWFlZGVkOTE3ZTBkOGM5ZTdkZWJiNGNmMWM2NGM=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-03-13T01:44:09Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-14T23:41:46Z"}, "message": "Factor out expression checking for forms that look like assignment", "tree": {"sha": "a5799d5be57ea07a7601a756bd3ec20e9e251c21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5799d5be57ea07a7601a756bd3ec20e9e251c21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/644d8b95da51aeded917e0d8c9e7debb4cf1c64c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/644d8b95da51aeded917e0d8c9e7debb4cf1c64c", "html_url": "https://github.com/rust-lang/rust/commit/644d8b95da51aeded917e0d8c9e7debb4cf1c64c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/644d8b95da51aeded917e0d8c9e7debb4cf1c64c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7464237256990c4a346cbaaa7ce3d2d9e8fe8d5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7464237256990c4a346cbaaa7ce3d2d9e8fe8d5c", "html_url": "https://github.com/rust-lang/rust/commit/7464237256990c4a346cbaaa7ce3d2d9e8fe8d5c"}], "stats": {"total": 50, "additions": 27, "deletions": 23}, "files": [{"sha": "f44292d581be18f9e22f9e7a8679fbfabdab32ae", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/644d8b95da51aeded917e0d8c9e7debb4cf1c64c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/644d8b95da51aeded917e0d8c9e7debb4cf1c64c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=644d8b95da51aeded917e0d8c9e7debb4cf1c64c", "patch": "@@ -1644,6 +1644,22 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         ret tup(f_1, args_1);\n     }\n \n+    // A generic function for checking expressions that have a form\n+    // similar to assignment.\n+    fn check_assignment_like(&@fn_ctxt fcx, @ast.expr lhs, @ast.expr rhs)\n+        -> tup(@ast.expr, @ast.expr, ast.ann) {\n+        auto lhs_0 = check_expr(fcx, lhs);\n+        auto rhs_0 = check_expr(fcx, rhs);\n+        auto lhs_t0 = expr_ty(lhs_0);\n+        auto rhs_t0 = expr_ty(rhs_0);\n+\n+        auto lhs_1 = demand_expr(fcx, rhs_t0, lhs_0);\n+        auto rhs_1 = demand_expr(fcx, expr_ty(lhs_1), rhs_0);\n+\n+        auto ann = ast.ann_type(rhs_t0, none[vec[@ty.t]]);\n+        ret tup(lhs_1, rhs_1, ann);\n+    }\n+\n     alt (expr.node) {\n         case (ast.expr_lit(?lit, _)) {\n             auto typ = check_lit(lit);\n@@ -1798,32 +1814,20 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_assign(?lhs, ?rhs, _)) {\n-            auto lhs_0 = check_expr(fcx, lhs);\n-            auto rhs_0 = check_expr(fcx, rhs);\n-            auto lhs_t0 = expr_ty(lhs_0);\n-            auto rhs_t0 = expr_ty(rhs_0);\n-\n-            auto lhs_1 = demand_expr(fcx, rhs_t0, lhs_0);\n-            auto rhs_1 = demand_expr(fcx, expr_ty(lhs_1), rhs_0);\n-\n-            auto ann = ast.ann_type(rhs_t0, none[vec[@ty.t]]);\n-            ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_assign(lhs_1, rhs_1, ann));\n+            auto checked = check_assignment_like(fcx, lhs, rhs);\n+            auto newexpr = ast.expr_assign(checked._0,\n+                                           checked._1,\n+                                           checked._2);\n+            ret @fold.respan[ast.expr_](expr.span, newexpr);\n         }\n \n         case (ast.expr_assign_op(?op, ?lhs, ?rhs, _)) {\n-            auto lhs_0 = check_expr(fcx, lhs);\n-            auto rhs_0 = check_expr(fcx, rhs);\n-            auto lhs_t0 = expr_ty(lhs_0);\n-            auto rhs_t0 = expr_ty(rhs_0);\n-\n-            auto lhs_1 = demand_expr(fcx, rhs_t0, lhs_0);\n-            auto rhs_1 = demand_expr(fcx, expr_ty(lhs_1), rhs_0);\n-\n-            auto ann = ast.ann_type(rhs_t0, none[vec[@ty.t]]);\n-            ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_assign_op(op, lhs_1, rhs_1,\n-                                                           ann));\n+            auto checked = check_assignment_like(fcx, lhs, rhs);\n+            auto newexpr = ast.expr_assign_op(op,\n+                                              checked._0,\n+                                              checked._1,\n+                                              checked._2);\n+            ret @fold.respan[ast.expr_](expr.span, newexpr);\n         }\n \n         case (ast.expr_if(?cond, ?thn, ?elifs, ?elsopt, _)) {"}]}