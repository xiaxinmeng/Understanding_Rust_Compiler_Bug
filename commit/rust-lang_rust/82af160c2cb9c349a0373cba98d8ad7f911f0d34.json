{"sha": "82af160c2cb9c349a0373cba98d8ad7f911f0d34", "node_id": "C_kwDOAAsO6NoAKDgyYWYxNjBjMmNiOWMzNDlhMDM3M2NiYTk4ZDhhZDdmOTExZjBkMzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-10T20:12:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-10T20:12:14Z"}, "message": "Auto merge of #90769 - matthiaskrgr:rollup-266apqm, r=matthiaskrgr\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #88447 (Use computed visibility in rustdoc)\n - #88868 (Allow simd_bitmask to return byte arrays)\n - #90727 (Remove potential useless data for search index)\n - #90742 (Use AddAssign impl)\n - #90758 (Fix collections entry API documentation.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ef011d09272715b6898e45b6a0c211f363dcfb76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef011d09272715b6898e45b6a0c211f363dcfb76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82af160c2cb9c349a0373cba98d8ad7f911f0d34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82af160c2cb9c349a0373cba98d8ad7f911f0d34", "html_url": "https://github.com/rust-lang/rust/commit/82af160c2cb9c349a0373cba98d8ad7f911f0d34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82af160c2cb9c349a0373cba98d8ad7f911f0d34/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68ca579406f2fa9ec62710e4a4d5d3e07a168d3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/68ca579406f2fa9ec62710e4a4d5d3e07a168d3c", "html_url": "https://github.com/rust-lang/rust/commit/68ca579406f2fa9ec62710e4a4d5d3e07a168d3c"}, {"sha": "5f2497541fb39699ac3c208c6b0944ac39cec565", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f2497541fb39699ac3c208c6b0944ac39cec565", "html_url": "https://github.com/rust-lang/rust/commit/5f2497541fb39699ac3c208c6b0944ac39cec565"}], "stats": {"total": 373, "additions": 234, "deletions": 139}, "files": [{"sha": "80a06fa594366de0492471300308e7ab4048e02d", "filename": "compiler/rustc_ast/src/util/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -169,7 +169,7 @@ pub fn gather_comments(sm: &SourceMap, path: FileName, src: String) -> Vec<Comme\n                 if let Some(mut idx) = token_text.find('\\n') {\n                     code_to_the_left = false;\n                     while let Some(next_newline) = &token_text[idx + 1..].find('\\n') {\n-                        idx = idx + 1 + next_newline;\n+                        idx += 1 + next_newline;\n                         comments.push(Comment {\n                             style: CommentStyle::BlankLine,\n                             lines: vec![],"}, {"sha": "924bb803b368fb850a4c7b1c208cc5f473f6b225", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 69, "deletions": 32, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt, LayoutOf};\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_span::{sym, symbol::kw, Span, Symbol};\n-use rustc_target::abi::{self, HasDataLayout, Primitive};\n+use rustc_target::abi::{self, Align, HasDataLayout, Primitive};\n use rustc_target::spec::{HasTargetSpec, PanicStrategy};\n \n use std::cmp::Ordering;\n@@ -857,28 +857,39 @@ fn generic_simd_intrinsic(\n     let arg_tys = sig.inputs();\n \n     if name == sym::simd_select_bitmask {\n-        let in_ty = arg_tys[0];\n-        let m_len = match in_ty.kind() {\n-            // Note that this `.unwrap()` crashes for isize/usize, that's sort\n-            // of intentional as there's not currently a use case for that.\n-            ty::Int(i) => i.bit_width().unwrap(),\n-            ty::Uint(i) => i.bit_width().unwrap(),\n-            _ => return_error!(\"`{}` is not an integral type\", in_ty),\n-        };\n         require_simd!(arg_tys[1], \"argument\");\n-        let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n-        require!(\n-            // Allow masks for vectors with fewer than 8 elements to be\n-            // represented with a u8 or i8.\n-            m_len == v_len || (m_len == 8 && v_len < 8),\n-            \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n-            m_len,\n-            v_len\n-        );\n+        let (len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+\n+        let expected_int_bits = (len.max(8) - 1).next_power_of_two();\n+        let expected_bytes = len / 8 + ((len % 8 > 0) as u64);\n+\n+        let mask_ty = arg_tys[0];\n+        let mask = match mask_ty.kind() {\n+            ty::Int(i) if i.bit_width() == Some(expected_int_bits) => args[0].immediate(),\n+            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => args[0].immediate(),\n+            ty::Array(elem, len)\n+                if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                    && len.try_eval_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                        == Some(expected_bytes) =>\n+            {\n+                let place = PlaceRef::alloca(bx, args[0].layout);\n+                args[0].val.store(bx, place);\n+                let int_ty = bx.type_ix(expected_bytes * 8);\n+                let ptr = bx.pointercast(place.llval, bx.cx.type_ptr_to(int_ty));\n+                bx.load(int_ty, ptr, Align::ONE)\n+            }\n+            _ => return_error!(\n+                \"invalid bitmask `{}`, expected `u{}` or `[u8; {}]`\",\n+                mask_ty,\n+                expected_int_bits,\n+                expected_bytes\n+            ),\n+        };\n+\n         let i1 = bx.type_i1();\n-        let im = bx.type_ix(v_len);\n-        let i1xn = bx.type_vector(i1, v_len);\n-        let m_im = bx.trunc(args[0].immediate(), im);\n+        let im = bx.type_ix(len);\n+        let i1xn = bx.type_vector(i1, len);\n+        let m_im = bx.trunc(mask, im);\n         let m_i1s = bx.bitcast(m_im, i1xn);\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n     }\n@@ -1056,16 +1067,16 @@ fn generic_simd_intrinsic(\n \n     if name == sym::simd_bitmask {\n         // The `fn simd_bitmask(vector) -> unsigned integer` intrinsic takes a\n-        // vector mask and returns an unsigned integer containing the most\n-        // significant bit (MSB) of each lane.\n-\n-        // If the vector has less than 8 lanes, a u8 is returned with zeroed\n-        // trailing bits.\n+        // vector mask and returns the most significant bit (MSB) of each lane in the form\n+        // of either:\n+        // * an unsigned integer\n+        // * an array of `u8`\n+        // If the vector has less than 8 lanes, a u8 is returned with zeroed trailing bits.\n+        //\n+        // The bit order of the result depends on the byte endianness, LSB-first for little\n+        // endian and MSB-first for big endian.\n         let expected_int_bits = in_len.max(8);\n-        match ret_ty.kind() {\n-            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => (),\n-            _ => return_error!(\"bitmask `{}`, expected `u{}`\", ret_ty, expected_int_bits),\n-        }\n+        let expected_bytes = expected_int_bits / 8 + ((expected_int_bits % 8 > 0) as u64);\n \n         // Integer vector <i{in_bitwidth} x in_len>:\n         let (i_xn, in_elem_bitwidth) = match in_elem.kind() {\n@@ -1095,8 +1106,34 @@ fn generic_simd_intrinsic(\n         let i1xn = bx.trunc(i_xn_msb, bx.type_vector(bx.type_i1(), in_len));\n         // Bitcast <i1 x N> to iN:\n         let i_ = bx.bitcast(i1xn, bx.type_ix(in_len));\n-        // Zero-extend iN to the bitmask type:\n-        return Ok(bx.zext(i_, bx.type_ix(expected_int_bits)));\n+\n+        match ret_ty.kind() {\n+            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => {\n+                // Zero-extend iN to the bitmask type:\n+                return Ok(bx.zext(i_, bx.type_ix(expected_int_bits)));\n+            }\n+            ty::Array(elem, len)\n+                if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                    && len.try_eval_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                        == Some(expected_bytes) =>\n+            {\n+                // Zero-extend iN to the array lengh:\n+                let ze = bx.zext(i_, bx.type_ix(expected_bytes * 8));\n+\n+                // Convert the integer to a byte array\n+                let ptr = bx.alloca(bx.type_ix(expected_bytes * 8), Align::ONE);\n+                bx.store(ze, ptr, Align::ONE);\n+                let array_ty = bx.type_array(bx.type_i8(), expected_bytes);\n+                let ptr = bx.pointercast(ptr, bx.cx.type_ptr_to(array_ty));\n+                return Ok(bx.load(array_ty, ptr, Align::ONE));\n+            }\n+            _ => return_error!(\n+                \"cannot return `{}`, expected `u{}` or `[u8; {}]`\",\n+                ret_ty,\n+                expected_int_bits,\n+                expected_bytes\n+            ),\n+        }\n     }\n \n     fn simd_simple_float_intrinsic("}, {"sha": "b2c7818a542189e79382e475f39f44d4b67e4c72", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -1179,7 +1179,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                             let ctor_res =\n                                 Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n                             let mut vis = self.get_visibility(ctor_def_id.index);\n-                            if ctor_def_id == def_id && vis == ty::Visibility::Public {\n+                            if ctor_def_id == def_id && vis.is_public() {\n                                 // For non-exhaustive variants lower the constructor visibility to\n                                 // within the crate. We only need this for fictive constructors,\n                                 // for other constructors correct visibilities"}, {"sha": "eeb0a77adc0ad73b06de2d381df0f1e0f2e01ac8", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -318,7 +318,7 @@ pub fn provide(providers: &mut Providers) {\n             }\n \n             let mut add_child = |bfs_queue: &mut VecDeque<_>, child: &Export, parent: DefId| {\n-                if child.vis != ty::Visibility::Public {\n+                if !child.vis.is_public() {\n                     return;\n                 }\n "}, {"sha": "673733faa766ff5846c02075833be4fba79c0cf7", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -333,6 +333,10 @@ impl Visibility {\n             Visibility::Invisible => false,\n         }\n     }\n+\n+    pub fn is_public(self) -> bool {\n+        matches!(self, Visibility::Public)\n+    }\n }\n \n /// The crate variances map is computed during typeck and contains the"}, {"sha": "5d9e7aaf72f8eece66bbee1f08eaab6b1f74aa70", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -2404,7 +2404,7 @@ fn for_each_def(tcx: TyCtxt<'_>, mut collect_fn: impl for<'b> FnMut(&'b Ident, N\n     // Iterate external crate defs but be mindful about visibility\n     while let Some(def) = queue.pop() {\n         for child in tcx.item_children(def).iter() {\n-            if child.vis != ty::Visibility::Public {\n+            if !child.vis.is_public() {\n                 continue;\n             }\n "}, {"sha": "08977049db02d772e5ab0e1e5b0ec90782af9a14", "filename": "compiler/rustc_middle/src/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_middle%2Fsrc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_middle%2Fsrc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Futil%2Fcommon.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -34,7 +34,7 @@ where\n     let rv = f();\n     let duration = start.elapsed();\n     let mut accu = accu.lock();\n-    *accu = *accu + duration;\n+    *accu += duration;\n     rv\n }\n "}, {"sha": "11668146f7b105560054110ed66e1c3d2cdd79f7", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -543,7 +543,7 @@ impl EmbargoVisitor<'tcx> {\n         module: LocalDefId,\n     ) {\n         let level = Some(AccessLevel::Reachable);\n-        if let ty::Visibility::Public = vis {\n+        if vis.is_public() {\n             self.update(def_id, level);\n         }\n         match def_kind {\n@@ -580,7 +580,7 @@ impl EmbargoVisitor<'tcx> {\n \n             DefKind::Struct | DefKind::Union => {\n                 // While structs and unions have type privacy, their fields do not.\n-                if let ty::Visibility::Public = vis {\n+                if vis.is_public() {\n                     let item =\n                         self.tcx.hir().expect_item(self.tcx.hir().local_def_id_to_hir_id(def_id));\n                     if let hir::ItemKind::Struct(ref struct_def, _)\n@@ -933,7 +933,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             let def_id = self.tcx.hir().local_def_id(id);\n             if let Some(exports) = self.tcx.module_exports(def_id) {\n                 for export in exports.iter() {\n-                    if export.vis == ty::Visibility::Public {\n+                    if export.vis.is_public() {\n                         if let Some(def_id) = export.res.opt_def_id() {\n                             if let Some(def_id) = def_id.as_local() {\n                                 self.update(def_id, Some(AccessLevel::Exported));\n@@ -1918,8 +1918,7 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n     /// 1. It's contained within a public type\n     /// 2. It comes from a private crate\n     fn leaks_private_dep(&self, item_id: DefId) -> bool {\n-        let ret = self.required_visibility == ty::Visibility::Public\n-            && self.tcx.is_private_dep(item_id.krate);\n+        let ret = self.required_visibility.is_public() && self.tcx.is_private_dep(item_id.krate);\n \n         tracing::debug!(\"leaks_private_dep(item_id={:?})={}\", item_id, ret);\n         ret"}, {"sha": "63699128e9e1627ebbe2e36f83435db6a1489e9b", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -32,7 +32,6 @@ use rustc_ast::visit::{self, Visitor};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::pluralize;\n-use rustc_middle::ty;\n use rustc_session::lint::builtin::{MACRO_USE_EXTERN_CRATE, UNUSED_IMPORTS};\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n@@ -228,7 +227,7 @@ impl Resolver<'_> {\n         for import in self.potentially_unused_imports.iter() {\n             match import.kind {\n                 _ if import.used.get()\n-                    || import.vis.get() == ty::Visibility::Public\n+                    || import.vis.get().is_public()\n                     || import.span.is_dummy() =>\n                 {\n                     if let ImportKind::MacroUse = import.kind {"}, {"sha": "094a5ed7bfbfeb0ee4a986efd728ce9752028d0f", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -11,7 +11,7 @@ use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_middle::bug;\n-use rustc_middle::ty::{self, DefIdTree};\n+use rustc_middle::ty::DefIdTree;\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n@@ -1308,7 +1308,7 @@ impl<'a> Resolver<'a> {\n             );\n             let def_span = self.session.source_map().guess_head_span(binding.span);\n             let mut note_span = MultiSpan::from_span(def_span);\n-            if !first && binding.vis == ty::Visibility::Public {\n+            if !first && binding.vis.is_public() {\n                 note_span.push_span_label(def_span, \"consider importing it directly\".into());\n             }\n             err.span_note(note_span, &msg);"}, {"sha": "4262c1e9051ee57a1694c34aab3281198c4edf81", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -164,7 +164,7 @@ fn pub_use_of_private_extern_crate_hack(import: &Import<'_>, binding: &NameBindi\n                 import: Import { kind: ImportKind::ExternCrate { .. }, .. },\n                 ..\n             },\n-        ) => import.vis.get() == ty::Visibility::Public,\n+        ) => import.vis.get().is_public(),\n         _ => false,\n     }\n }"}, {"sha": "5c79a067e9f047e74a66005f0365ed5620136d8a", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -35,14 +35,11 @@ use rustc_hir::{ExprKind, QPath};\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::InferOk;\n-use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n use rustc_middle::ty::error::TypeError::{FieldMisMatch, Sorts};\n use rustc_middle::ty::relate::expected_found_bool;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::Ty;\n-use rustc_middle::ty::TypeFoldable;\n-use rustc_middle::ty::{AdtKind, Visibility};\n+use rustc_middle::ty::{self, AdtKind, Ty, TypeFoldable};\n use rustc_session::parse::feature_err;\n use rustc_span::edition::LATEST_STABLE_EDITION;\n use rustc_span::hygiene::DesugaringKind;\n@@ -1732,7 +1729,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .filter_map(|field| {\n                 // ignore already set fields and private fields from non-local crates\n                 if skip.iter().any(|&x| x == field.ident.name)\n-                    || (!variant.def_id.is_local() && field.vis != Visibility::Public)\n+                    || (!variant.def_id.is_local() && !field.vis.is_public())\n                 {\n                     None\n                 } else {"}, {"sha": "71cd8a43329c5df8a8f25bdab7c2d310fb3a1158", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -1410,7 +1410,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 }\n                             }\n                             // We only want to suggest public or local traits (#45781).\n-                            item.vis == ty::Visibility::Public || info.def_id.is_local()\n+                            item.vis.is_public() || info.def_id.is_local()\n                         })\n                         .is_some()\n             })"}, {"sha": "8b004525b469796203b3e6b6fb8a5e39eb7eaf89", "filename": "library/std/src/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fmod.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -268,7 +268,7 @@\n //! not. Normally, this would require a `find` followed by an `insert`,\n //! effectively duplicating the search effort on each insertion.\n //!\n-//! When a user calls `map.entry(&key)`, the map will search for the key and\n+//! When a user calls `map.entry(key)`, the map will search for the key and\n //! then yield a variant of the `Entry` enum.\n //!\n //! If a `Vacant(entry)` is yielded, then the key *was not* found. In this case"}, {"sha": "4a8a316037961fcd056d0aa7b91e876bb24471b0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -435,7 +435,7 @@ crate fn build_impl(\n             tcx.associated_items(did)\n                 .in_definition_order()\n                 .filter_map(|item| {\n-                    if associated_trait.is_some() || item.vis == ty::Visibility::Public {\n+                    if associated_trait.is_some() || item.vis.is_public() {\n                         Some(item.clean(cx))\n                     } else {\n                         None\n@@ -515,7 +515,7 @@ fn build_module(\n     // two namespaces, so the target may be listed twice. Make sure we only\n     // visit each node at most once.\n     for &item in cx.tcx.item_children(did).iter() {\n-        if item.vis == ty::Visibility::Public {\n+        if item.vis.is_public() {\n             let res = item.res.expect_non_local();\n             if let Some(def_id) = res.mod_def_id() {\n                 if did == def_id || !visited.insert(def_id) {"}, {"sha": "a44641f4488e8aae4234608bdf8f740a2f159eac", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -1881,7 +1881,7 @@ fn clean_extern_crate(\n     // this is the ID of the crate itself\n     let crate_def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n     let attrs = cx.tcx.hir().attrs(krate.hir_id());\n-    let please_inline = krate.vis.node.is_pub()\n+    let please_inline = cx.tcx.visibility(krate.def_id).is_public()\n         && attrs.iter().any(|a| {\n             a.has_name(sym::doc)\n                 && match a.meta_item_list() {\n@@ -1933,9 +1933,12 @@ fn clean_use_statement(\n         return Vec::new();\n     }\n \n+    let visibility = cx.tcx.visibility(import.def_id);\n     let attrs = cx.tcx.hir().attrs(import.hir_id());\n     let inline_attr = attrs.lists(sym::doc).get_word_attr(sym::inline);\n-    let pub_underscore = import.vis.node.is_pub() && name == kw::Underscore;\n+    let pub_underscore = visibility.is_public() && name == kw::Underscore;\n+    let current_mod = cx.tcx.parent_module_from_def_id(import.def_id);\n+    let parent_mod = cx.tcx.parent_module_from_def_id(current_mod);\n \n     if pub_underscore {\n         if let Some(ref inline) = inline_attr {\n@@ -1954,8 +1957,9 @@ fn clean_use_statement(\n     // forcefully don't inline if this is not public or if the\n     // #[doc(no_inline)] attribute is present.\n     // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n-    let mut denied = !(import.vis.node.is_pub()\n-        || (cx.render_options.document_private && import.vis.node.is_pub_restricted()))\n+    let mut denied = !(visibility.is_public()\n+        || (cx.render_options.document_private\n+            && visibility.is_accessible_from(parent_mod.to_def_id(), cx.tcx)))\n         || pub_underscore\n         || attrs.iter().any(|a| {\n             a.has_name(sym::doc)"}, {"sha": "2dba52afcd9cd847203c001024e4cb157dc7aafa", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -254,7 +254,7 @@ impl ExternalCrate {\n                             as_keyword(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n                         }\n                         hir::ItemKind::Use(path, hir::UseKind::Single)\n-                            if item.vis.node.is_pub() =>\n+                            if tcx.visibility(id.def_id).is_public() =>\n                         {\n                             as_keyword(path.res.expect_non_local())\n                                 .map(|(_, prim)| (id.def_id.to_def_id(), prim))\n@@ -320,7 +320,7 @@ impl ExternalCrate {\n                             as_primitive(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n                         }\n                         hir::ItemKind::Use(path, hir::UseKind::Single)\n-                            if item.vis.node.is_pub() =>\n+                            if tcx.visibility(id.def_id).is_public() =>\n                         {\n                             as_primitive(path.res.expect_non_local()).map(|(_, prim)| {\n                                 // Pretend the primitive is local."}, {"sha": "79421c128bcf8eea5056cfc4f4dce4c09201a988", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 46, "deletions": 39, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -258,45 +258,52 @@ crate fn get_real_types<'tcx>(\n     ) {\n         let is_full_generic = ty.is_full_generic();\n \n-        if is_full_generic && generics.len() == 1 {\n-            // In this case, no need to go through an intermediate state if the generics\n-            // contains only one element.\n-            //\n-            // For example:\n-            //\n-            // fn foo<T: Display>(r: Option<T>) {}\n-            //\n-            // In this case, it would contain:\n-            //\n-            // ```\n-            // [{\n-            //     name: \"option\",\n-            //     generics: [{\n-            //         name: \"\",\n-            //         generics: [\n-            //             name: \"Display\",\n-            //             generics: []\n-            //         }]\n-            //     }]\n-            // }]\n-            // ```\n-            //\n-            // After removing the intermediate (unnecessary) full generic, it'll become:\n-            //\n-            // ```\n-            // [{\n-            //     name: \"option\",\n-            //     generics: [{\n-            //         name: \"Display\",\n-            //         generics: []\n-            //     }]\n-            // }]\n-            // ```\n-            //\n-            // To be noted that it can work if there is ONLY ONE generic, otherwise we still\n-            // need to keep it as is!\n-            res.push(generics.pop().unwrap());\n-            return;\n+        if is_full_generic {\n+            if generics.is_empty() {\n+                // This is a type parameter with no trait bounds (for example: `T` in\n+                // `fn f<T>(p: T)`, so not useful for the rustdoc search because we would end up\n+                // with an empty type with an empty name. Let's just discard it.\n+                return;\n+            } else if generics.len() == 1 {\n+                // In this case, no need to go through an intermediate state if the type parameter\n+                // contains only one trait bound.\n+                //\n+                // For example:\n+                //\n+                // `fn foo<T: Display>(r: Option<T>) {}`\n+                //\n+                // In this case, it would contain:\n+                //\n+                // ```\n+                // [{\n+                //     name: \"option\",\n+                //     generics: [{\n+                //         name: \"\",\n+                //         generics: [\n+                //             name: \"Display\",\n+                //             generics: []\n+                //         }]\n+                //     }]\n+                // }]\n+                // ```\n+                //\n+                // After removing the intermediate (unnecessary) type parameter, it'll become:\n+                //\n+                // ```\n+                // [{\n+                //     name: \"option\",\n+                //     generics: [{\n+                //         name: \"Display\",\n+                //         generics: []\n+                //     }]\n+                // }]\n+                // ```\n+                //\n+                // To be noted that it can work if there is ONLY ONE trait bound, otherwise we still\n+                // need to keep it as is!\n+                res.push(generics.pop().unwrap());\n+                return;\n+            }\n         }\n         let mut index_ty = get_index_type(&ty, generics);\n         if index_ty.name.as_ref().map(|s| s.is_empty()).unwrap_or(true) {"}, {"sha": "1191a94a7039bee6bf544d7d182dc31e706867c9", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -10,7 +10,6 @@ use rustc_hir::CRATE_HIR_ID;\n use rustc_middle::middle::privacy::AccessLevel;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n-use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n use std::mem;\n@@ -72,9 +71,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     crate fn visit(mut self) -> Module<'tcx> {\n-        let span = self.cx.tcx.def_span(CRATE_DEF_ID);\n         let mut top_level_module = self.visit_mod_contents(\n-            &Spanned { span, node: hir::VisibilityKind::Public },\n             hir::CRATE_HIR_ID,\n             self.cx.tcx.hir().root_module(),\n             self.cx.tcx.crate_name(LOCAL_CRATE),\n@@ -134,15 +131,15 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n     fn visit_mod_contents(\n         &mut self,\n-        vis: &hir::Visibility<'_>,\n         id: hir::HirId,\n         m: &'tcx hir::Mod<'tcx>,\n         name: Symbol,\n     ) -> Module<'tcx> {\n         let mut om = Module::new(name, id, m.inner);\n+        let def_id = self.cx.tcx.hir().local_def_id(id).to_def_id();\n         // Keep track of if there were any private modules in the path.\n         let orig_inside_public_path = self.inside_public_path;\n-        self.inside_public_path &= vis.node.is_pub();\n+        self.inside_public_path &= self.cx.tcx.visibility(def_id).is_public();\n         for &i in m.item_ids {\n             let item = self.cx.tcx.hir().item(i);\n             self.visit_item(item, None, &mut om);\n@@ -259,7 +256,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let name = renamed.unwrap_or(item.ident.name);\n \n         let def_id = item.def_id.to_def_id();\n-        let is_pub = item.vis.node.is_pub() || self.cx.tcx.has_attr(def_id, sym::macro_export);\n+        let is_pub = self.cx.tcx.visibility(def_id).is_public();\n \n         if is_pub {\n             self.store_path(item.def_id.to_def_id());\n@@ -332,7 +329,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                om.mods.push(self.visit_mod_contents(&item.vis, item.hir_id(), m, name));\n+                om.mods.push(self.visit_mod_contents(item.hir_id(), m, name));\n             }\n             hir::ItemKind::Fn(..)\n             | hir::ItemKind::ExternCrate(..)\n@@ -368,7 +365,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om: &mut Module<'tcx>,\n     ) {\n         // If inlining we only want to include public functions.\n-        if !self.inlining || item.vis.node.is_pub() {\n+        if !self.inlining || self.cx.tcx.visibility(item.def_id).is_public() {\n             om.foreigns.push((item, renamed));\n         }\n     }"}, {"sha": "791f7ff437c8bf4e86229cbb7831cdc0abd5407b", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -2,7 +2,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n-use rustc_middle::ty::{TyCtxt, Visibility};\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n \n use crate::clean::{AttributesExt, NestedAttributesExt};\n@@ -59,7 +59,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n         for item in self.tcx.item_children(def_id).iter() {\n             if let Some(def_id) = item.res.opt_def_id() {\n                 if self.tcx.def_key(def_id).parent.map_or(false, |d| d == def_id.index)\n-                    || item.vis == Visibility::Public\n+                    || item.vis.is_public()\n                 {\n                     self.visit_item(item.res);\n                 }\n@@ -70,7 +70,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, res: Res<!>) {\n         let def_id = res.def_id();\n         let vis = self.tcx.visibility(def_id);\n-        let inherited_item_level = if vis == Visibility::Public { self.prev_level } else { None };\n+        let inherited_item_level = if vis.is_public() { self.prev_level } else { None };\n \n         let item_level = self.update(def_id, inherited_item_level);\n "}, {"sha": "9a23dae77b96e572084b590f04cb27b943dbc9f7", "filename": "src/test/ui/simd/intrinsic/generic-bitmask.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-bitmask.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -51,19 +51,19 @@ fn main() {\n         let _: u64 = simd_bitmask(m64);\n \n         let _: u16 = simd_bitmask(m2);\n-        //~^ ERROR bitmask `u16`, expected `u8`\n+        //~^ ERROR invalid monomorphization of `simd_bitmask` intrinsic\n \n         let _: u16 = simd_bitmask(m8);\n-        //~^ ERROR bitmask `u16`, expected `u8`\n+        //~^ ERROR invalid monomorphization of `simd_bitmask` intrinsic\n \n         let _: u32 = simd_bitmask(m16);\n-        //~^ ERROR bitmask `u32`, expected `u16`\n+        //~^ ERROR invalid monomorphization of `simd_bitmask` intrinsic\n \n         let _: u64 = simd_bitmask(m32);\n-        //~^ ERROR bitmask `u64`, expected `u32`\n+        //~^ ERROR invalid monomorphization of `simd_bitmask` intrinsic\n \n         let _: u128 = simd_bitmask(m64);\n-        //~^ ERROR bitmask `u128`, expected `u64`\n+        //~^ ERROR invalid monomorphization of `simd_bitmask` intrinsic\n \n    }\n }"}, {"sha": "0de3f8eead86d12bf3fdb18e3e8e1d9ad1a70d4b", "filename": "src/test/ui/simd/intrinsic/generic-bitmask.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-bitmask.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-bitmask.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-bitmask.stderr?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -1,28 +1,28 @@\n-error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: bitmask `u16`, expected `u8`\n+error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: cannot return `u16`, expected `u8` or `[u8; 1]`\n   --> $DIR/generic-bitmask.rs:53:22\n    |\n LL |         let _: u16 = simd_bitmask(m2);\n    |                      ^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: bitmask `u16`, expected `u8`\n+error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: cannot return `u16`, expected `u8` or `[u8; 1]`\n   --> $DIR/generic-bitmask.rs:56:22\n    |\n LL |         let _: u16 = simd_bitmask(m8);\n    |                      ^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: bitmask `u32`, expected `u16`\n+error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: cannot return `u32`, expected `u16` or `[u8; 2]`\n   --> $DIR/generic-bitmask.rs:59:22\n    |\n LL |         let _: u32 = simd_bitmask(m16);\n    |                      ^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: bitmask `u64`, expected `u32`\n+error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: cannot return `u64`, expected `u32` or `[u8; 4]`\n   --> $DIR/generic-bitmask.rs:62:22\n    |\n LL |         let _: u64 = simd_bitmask(m32);\n    |                      ^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: bitmask `u128`, expected `u64`\n+error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: cannot return `u128`, expected `u64` or `[u8; 8]`\n   --> $DIR/generic-bitmask.rs:65:23\n    |\n LL |         let _: u128 = simd_bitmask(m64);"}, {"sha": "248e82ea21cfce6ec8aefcbb44b0ca8c093cfc46", "filename": "src/test/ui/simd/intrinsic/generic-select.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-select.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -20,8 +20,7 @@ struct b8x4(pub i8, pub i8, pub i8, pub i8);\n \n #[repr(simd)]\n #[derive(Copy, Clone, PartialEq)]\n-struct b8x8(pub i8, pub i8, pub i8, pub i8,\n-            pub i8, pub i8, pub i8, pub i8);\n+struct b8x8(pub i8, pub i8, pub i8, pub i8, pub i8, pub i8, pub i8, pub i8);\n \n extern \"platform-intrinsic\" {\n     fn simd_select<T, U>(x: T, a: U, b: U) -> U;\n@@ -50,15 +49,15 @@ fn main() {\n         //~^ ERROR found non-SIMD `u32`\n \n         simd_select_bitmask(0u16, x, x);\n-        //~^ ERROR mask length `16` != other vector length `4`\n-        //\n+        //~^ ERROR invalid bitmask `u16`, expected `u8` or `[u8; 1]`\n+\n         simd_select_bitmask(0u8, 1u32, 2u32);\n         //~^ ERROR found non-SIMD `u32`\n \n         simd_select_bitmask(0.0f32, x, x);\n-        //~^ ERROR `f32` is not an integral type\n+        //~^ ERROR invalid bitmask `f32`, expected `u8` or `[u8; 1]`\n \n         simd_select_bitmask(\"x\", x, x);\n-        //~^ ERROR `&str` is not an integral type\n+        //~^ ERROR invalid bitmask `&str`, expected `u8` or `[u8; 1]`\n     }\n }"}, {"sha": "d576f1bc77473fc2216b3cfe28ffe3a84d75fc15", "filename": "src/test/ui/simd/intrinsic/generic-select.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-select.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-select.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-select.stderr?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -1,47 +1,47 @@\n error[E0511]: invalid monomorphization of `simd_select` intrinsic: mismatched lengths: mask length `8` != other vector length `4`\n-  --> $DIR/generic-select.rs:40:9\n+  --> $DIR/generic-select.rs:39:9\n    |\n LL |         simd_select(m8, x, x);\n    |         ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_select` intrinsic: mask element type is `u32`, expected `i_`\n-  --> $DIR/generic-select.rs:43:9\n+  --> $DIR/generic-select.rs:42:9\n    |\n LL |         simd_select(x, x, x);\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_select` intrinsic: mask element type is `f32`, expected `i_`\n-  --> $DIR/generic-select.rs:46:9\n+  --> $DIR/generic-select.rs:45:9\n    |\n LL |         simd_select(z, z, z);\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_select` intrinsic: expected SIMD argument type, found non-SIMD `u32`\n-  --> $DIR/generic-select.rs:49:9\n+  --> $DIR/generic-select.rs:48:9\n    |\n LL |         simd_select(m4, 0u32, 1u32);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: mismatched lengths: mask length `16` != other vector length `4`\n-  --> $DIR/generic-select.rs:52:9\n+error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: invalid bitmask `u16`, expected `u8` or `[u8; 1]`\n+  --> $DIR/generic-select.rs:51:9\n    |\n LL |         simd_select_bitmask(0u16, x, x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: expected SIMD argument type, found non-SIMD `u32`\n-  --> $DIR/generic-select.rs:55:9\n+  --> $DIR/generic-select.rs:54:9\n    |\n LL |         simd_select_bitmask(0u8, 1u32, 2u32);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: `f32` is not an integral type\n-  --> $DIR/generic-select.rs:58:9\n+error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: invalid bitmask `f32`, expected `u8` or `[u8; 1]`\n+  --> $DIR/generic-select.rs:57:9\n    |\n LL |         simd_select_bitmask(0.0f32, x, x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: `&str` is not an integral type\n-  --> $DIR/generic-select.rs:61:9\n+error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: invalid bitmask `&str`, expected `u8` or `[u8; 1]`\n+  --> $DIR/generic-select.rs:60:9\n    |\n LL |         simd_select_bitmask(\"x\", x, x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "14ee2e741bdfdda5e519bda7d740bfac2af64d27", "filename": "src/test/ui/simd/simd-bitmask.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Ftest%2Fui%2Fsimd%2Fsimd-bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82af160c2cb9c349a0373cba98d8ad7f911f0d34/src%2Ftest%2Fui%2Fsimd%2Fsimd-bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-bitmask.rs?ref=82af160c2cb9c349a0373cba98d8ad7f911f0d34", "patch": "@@ -0,0 +1,52 @@\n+//run-pass\n+//ignore-endian-big behavior of simd_select_bitmask is endian-specific\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_bitmask<T, U>(v: T) -> U;\n+    fn simd_select_bitmask<T, U>(m: T, a: U, b: U) -> U;\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(simd)]\n+struct Simd<T, const N: usize>([T; N]);\n+\n+fn main() {\n+    unsafe {\n+        let v = Simd::<i8, 4>([-1, 0, -1, 0]);\n+        let i: u8 = simd_bitmask(v);\n+        let a: [u8; 1] = simd_bitmask(v);\n+\n+        assert_eq!(i, 0b0101);\n+        assert_eq!(a, [0b0101]);\n+\n+        let v = Simd::<i8, 16>([0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, -1, 0]);\n+        let i: u16 = simd_bitmask(v);\n+        let a: [u8; 2] = simd_bitmask(v);\n+\n+        assert_eq!(i, 0b0101000000001100);\n+        assert_eq!(a, [0b1100, 0b01010000]);\n+    }\n+\n+    unsafe {\n+        let a = Simd::<i32, 8>([0, 1, 2, 3, 4, 5, 6, 7]);\n+        let b = Simd::<i32, 8>([8, 9, 10, 11, 12, 13, 14, 15]);\n+        let e = [0, 9, 2, 11, 12, 13, 14, 15];\n+\n+        let r = simd_select_bitmask(0b0101u8, a, b);\n+        assert_eq!(r.0, e);\n+\n+        let r = simd_select_bitmask([0b0101u8], a, b);\n+        assert_eq!(r.0, e);\n+\n+        let a = Simd::<i32, 16>([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n+        let b = Simd::<i32, 16>([16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]);\n+        let e = [16, 17, 2, 3, 20, 21, 22, 23, 24, 25, 26, 27, 12, 29, 14, 31];\n+\n+        let r = simd_select_bitmask(0b0101000000001100u16, a, b);\n+        assert_eq!(r.0, e);\n+\n+        let r = simd_select_bitmask([0b1100u8, 0b01010000u8], a, b);\n+        assert_eq!(r.0, e);\n+    }\n+}"}]}