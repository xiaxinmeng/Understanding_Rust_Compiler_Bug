{"sha": "b2e298853113e9b9d68c956749d92ad540fb286d", "node_id": "C_kwDOAAsO6NoAKGIyZTI5ODg1MzExM2U5YjlkNjhjOTU2NzQ5ZDkyYWQ1NDBmYjI4NmQ", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-01-27T11:46:20Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-01-27T11:46:20Z"}, "message": "Revert \"Avoid a temporary file when processing macOS fat archives\"\n\nThis reverts commit bd8e476d8bd85b6d60a0de7694d154b4a74f5133.", "tree": {"sha": "42285d6dc31d8a12239175b081bad84fbf6a09a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42285d6dc31d8a12239175b081bad84fbf6a09a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2e298853113e9b9d68c956749d92ad540fb286d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2e298853113e9b9d68c956749d92ad540fb286d", "html_url": "https://github.com/rust-lang/rust/commit/b2e298853113e9b9d68c956749d92ad540fb286d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2e298853113e9b9d68c956749d92ad540fb286d/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "url": "https://api.github.com/repos/rust-lang/rust/commits/18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "html_url": "https://github.com/rust-lang/rust/commit/18890f05f6cea40fd25bb4bb9aa6f7372b69f641"}], "stats": {"total": 70, "additions": 36, "deletions": 34}, "files": [{"sha": "d3cd085cfb66854f374041ab5d5a2aeba32925bc", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b2e298853113e9b9d68c956749d92ad540fb286d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2e298853113e9b9d68c956749d92ad540fb286d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=b2e298853113e9b9d68c956749d92ad540fb286d", "patch": "@@ -14,7 +14,7 @@ use tempfile::Builder as TempFileBuilder;\n \n use std::error::Error;\n use std::fs::File;\n-use std::io;\n+use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n \n // Re-exporting for rustc_codegen_llvm::back::archive\n@@ -116,42 +116,51 @@ impl<'a> ArArchiveBuilder<'a> {\n     }\n }\n \n-fn try_filter_fat_archs<'a>(\n+fn try_filter_fat_archs(\n     archs: object::read::Result<&[impl FatArch]>,\n     target_arch: object::Architecture,\n-    archive_map_data: &'a [u8],\n-) -> io::Result<Option<(&'a [u8], u64)>> {\n+    archive_path: &Path,\n+    archive_map_data: &[u8],\n+) -> io::Result<Option<PathBuf>> {\n     let archs = archs.map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n \n     let desired = match archs.iter().find(|a| a.architecture() == target_arch) {\n         Some(a) => a,\n         None => return Ok(None),\n     };\n \n-    Ok(Some((\n+    let (mut new_f, extracted_path) = tempfile::Builder::new()\n+        .suffix(archive_path.file_name().unwrap())\n+        .tempfile()?\n+        .keep()\n+        .unwrap();\n+\n+    new_f.write_all(\n         desired.data(archive_map_data).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?,\n-        desired.offset().into(),\n-    )))\n+    )?;\n+\n+    Ok(Some(extracted_path))\n }\n \n-pub fn try_extract_macho_fat_archive<'a>(\n+pub fn try_extract_macho_fat_archive(\n     sess: &Session,\n-    archive_bytes: &'a [u8],\n-) -> io::Result<Option<(&'a [u8], u64)>> {\n+    archive_path: &Path,\n+) -> io::Result<Option<PathBuf>> {\n+    let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n     let target_arch = match sess.target.arch.as_ref() {\n         \"aarch64\" => object::Architecture::Aarch64,\n         \"x86_64\" => object::Architecture::X86_64,\n         _ => return Ok(None),\n     };\n \n-    match object::macho::FatHeader::parse(archive_bytes) {\n+    match object::macho::FatHeader::parse(&*archive_map) {\n         Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC => {\n-            let archs = object::macho::FatHeader::parse_arch32(archive_bytes);\n-            try_filter_fat_archs(archs, target_arch, archive_bytes)\n+            let archs = object::macho::FatHeader::parse_arch32(&*archive_map);\n+            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n         }\n         Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC_64 => {\n-            let archs = object::macho::FatHeader::parse_arch64(archive_bytes);\n-            try_filter_fat_archs(archs, target_arch, archive_bytes)\n+            let archs = object::macho::FatHeader::parse_arch64(&*archive_map);\n+            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n         }\n         // Not a FatHeader at all, just return None.\n         _ => Ok(None),\n@@ -164,24 +173,21 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         archive_path: &Path,\n         mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n     ) -> io::Result<()> {\n-        let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n+        let mut archive_path = archive_path.to_path_buf();\n+        if self.sess.target.llvm_target.contains(\"-apple-macosx\") {\n+            if let Some(new_archive_path) =\n+                try_extract_macho_fat_archive(&self.sess, &archive_path)?\n+            {\n+                archive_path = new_archive_path\n+            }\n+        }\n+\n         if self.src_archives.iter().any(|archive| archive.0 == archive_path) {\n             return Ok(());\n         }\n \n-        let (archive_bytes, offset) = if self.sess.target.llvm_target.contains(\"-apple-macosx\") {\n-            if let Some((sub_archive, archive_offset)) =\n-                try_extract_macho_fat_archive(&self.sess, &*archive_map)?\n-            {\n-                (sub_archive, Some(archive_offset))\n-            } else {\n-                (&*archive_map, None)\n-            }\n-        } else {\n-            (&*archive_map, None)\n-        };\n-\n-        let archive = ArchiveFile::parse(&*archive_bytes)\n+        let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n+        let archive = ArchiveFile::parse(&*archive_map)\n             .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n         let archive_index = self.src_archives.len();\n \n@@ -190,13 +196,9 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             let file_name = String::from_utf8(entry.name().to_vec())\n                 .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n             if !skip(&file_name) {\n-                let mut range = entry.file_range();\n-                if let Some(offset) = offset {\n-                    range.0 += offset;\n-                }\n                 self.entries.push((\n                     file_name.into_bytes(),\n-                    ArchiveEntry::FromArchive { archive_index, file_range: range },\n+                    ArchiveEntry::FromArchive { archive_index, file_range: entry.file_range() },\n                 ));\n             }\n         }"}]}