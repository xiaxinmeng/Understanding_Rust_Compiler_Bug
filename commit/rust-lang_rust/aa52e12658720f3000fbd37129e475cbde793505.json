{"sha": "aa52e12658720f3000fbd37129e475cbde793505", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNTJlMTI2NTg3MjBmMzAwMGZiZDM3MTI5ZTQ3NWNiZGU3OTM1MDU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-31T20:22:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-09T18:31:05Z"}, "message": "add generalization", "tree": {"sha": "b00704ecf8406741330ab658ffce1614dab61ee9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b00704ecf8406741330ab658ffce1614dab61ee9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa52e12658720f3000fbd37129e475cbde793505", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa52e12658720f3000fbd37129e475cbde793505", "html_url": "https://github.com/rust-lang/rust/commit/aa52e12658720f3000fbd37129e475cbde793505", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa52e12658720f3000fbd37129e475cbde793505/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f43b099cd3e198d8f804399feca6680fd840f39", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f43b099cd3e198d8f804399feca6680fd840f39", "html_url": "https://github.com/rust-lang/rust/commit/5f43b099cd3e198d8f804399feca6680fd840f39"}], "stats": {"total": 254, "additions": 155, "deletions": 99}, "files": [{"sha": "9ed4ec8eec180337bb67c112992f09eb5e4c7d9a", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 155, "deletions": 99, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/aa52e12658720f3000fbd37129e475cbde793505/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa52e12658720f3000fbd37129e475cbde793505/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=aa52e12658720f3000fbd37129e475cbde793505", "patch": "@@ -15,13 +15,12 @@ use borrow_check::nll::ToRegionVid;\n use rustc::infer::canonical::{Canonical, CanonicalVarInfos};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::traits::query::Fallible;\n-use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc::ty::subst::Kind;\n use rustc::ty::{self, CanonicalTy, CanonicalVar, RegionVid, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use std::mem;\n \n pub(super) fn sub_types<'tcx>(\n     infcx: &InferCtxt<'_, '_, 'tcx>,\n@@ -262,76 +261,52 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n     /// When we encounter a canonical variable `var` in the output,\n     /// equate it with `kind`. If the variable has been previously\n     /// equated, then equate it again.\n-    fn equate_var(\n+    fn relate_var(\n         &mut self,\n-        universal_regions: &UniversalRegions<'tcx>,\n         var: CanonicalVar,\n         b_kind: Kind<'tcx>,\n     ) -> RelateResult<'tcx, Kind<'tcx>> {\n         debug!(\"equate_var(var={:?}, b_kind={:?})\", var, b_kind);\n \n-        // We only encounter canonical variables when equating.\n-        assert_eq!(self.ambient_variance, ty::Variance::Invariant);\n-\n-        // The canonical variable already had a value. Equate that\n-        // value with `b`.\n-        if let Some(a_kind) = self.canonical_var_values[var] {\n-            debug!(\"equate_var: a_kind={:?}\", a_kind);\n+        let generalized_kind = match self.canonical_var_values[var] {\n+            Some(v) => v,\n+            None => {\n+                let generalized_kind = self.generalize_value(b_kind);\n+                self.canonical_var_values[var] = Some(generalized_kind);\n+                generalized_kind\n+            }\n+        };\n \n-            // The values we extract from `canonical_var_values` have\n-            // been \"instantiated\" and hence the set of scopes we have\n-            // doesn't matter -- just to be sure, put an empty vector\n-            // in there.\n-            let old_a_scopes = mem::replace(&mut self.a_scopes, vec![]);\n-            let result = self.relate(&a_kind, &b_kind);\n-            self.a_scopes = old_a_scopes;\n+        // The generalized values we extract from `canonical_var_values` have\n+        // been fully instantiated and hence the set of scopes we have\n+        // doesn't matter -- just to be sure, put an empty vector\n+        // in there.\n+        let old_a_scopes = ::std::mem::replace(&mut self.a_scopes, vec![]);\n \n-            debug!(\"equate_var: complete, result = {:?}\", result);\n-            return result;\n-        }\n+        // Relate the generalized kind to the original one.\n+        let result = self.relate(&generalized_kind, &b_kind);\n \n-        // Not yet. Capture the value from the RHS and carry on.\n-        let closed_kind =\n-            self.instantiate_traversed_binders(universal_regions, &self.b_scopes, b_kind);\n-        self.canonical_var_values[var] = Some(closed_kind);\n-        debug!(\n-            \"equate_var: capturing value {:?}\",\n-            self.canonical_var_values[var]\n-        );\n+        // Restore the old scopes now.\n+        self.a_scopes = old_a_scopes;\n \n-        // FIXME -- technically, we should add some sort of\n-        // assertion that this value can be named in the universe\n-        // of the canonical variable. But in practice these\n-        // canonical variables only arise presently in cases where\n-        // they are in the root universe and the main typeck has\n-        // ensured there are no universe errors. So we just kind\n-        // of over look this right now.\n-        Ok(b_kind)\n+        debug!(\"equate_var: complete, result = {:?}\", result);\n+        return result;\n     }\n \n-    /// As we traverse types and pass through binders, we push the\n-    /// values for each of the regions bound by those binders onto\n-    /// `scopes`. This function goes through `kind` and replaces any\n-    /// references into those scopes with the corresponding free\n-    /// region. Thus the resulting value should have no escaping\n-    /// references to bound things and can be transported into other\n-    /// scopes.\n-    fn instantiate_traversed_binders(\n+    fn generalize_value(\n         &self,\n-        universal_regions: &UniversalRegions<'tcx>,\n-        scopes: &[BoundRegionScope],\n         kind: Kind<'tcx>,\n     ) -> Kind<'tcx> {\n-        let k = kind.fold_with(&mut BoundReplacer {\n+        TypeGeneralizer {\n             type_rel: self,\n             first_free_index: ty::INNERMOST,\n-            universal_regions,\n-            scopes: scopes,\n-        });\n+            ambient_variance: self.ambient_variance,\n \n-        assert!(!k.has_escaping_regions());\n-\n-        k\n+            // These always correspond to an `_` or `'_` written by\n+            // user, and those are always in the root universe.\n+            universe: ty::UniverseIndex::ROOT,\n+        }.relate(&kind, &kind)\n+            .unwrap()\n     }\n }\n \n@@ -382,21 +357,8 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n         // Watch out for the case that we are matching a `?T` against the\n         // right-hand side.\n         if let ty::Infer(ty::CanonicalTy(var)) = a.sty {\n-            if let Some(&mut BorrowCheckContext {\n-                universal_regions, ..\n-            }) = self.borrowck_context\n-            {\n-                self.equate_var(universal_regions, var, b.into())?;\n-                Ok(a)\n-            } else {\n-                // if NLL is not enabled just ignore these variables\n-                // for now; in that case we're just doing a \"sanity\n-                // check\" anyway, and this only affects user-given\n-                // annotations like `let x: Vec<_> = ...` -- and then\n-                // only if the user uses type aliases to make a type\n-                // variable repeat more than once.\n-                Ok(a)\n-            }\n+            self.relate_var(var, b.into())?;\n+            Ok(a)\n         } else {\n             debug!(\n                 \"tys(a={:?}, b={:?}, variance={:?})\",\n@@ -417,7 +379,7 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n         }) = self.borrowck_context\n         {\n             if let ty::ReCanonical(var) = a {\n-                self.equate_var(universal_regions, *var, b.into())?;\n+                self.relate_var(*var, b.into())?;\n                 return Ok(a);\n             }\n \n@@ -589,48 +551,142 @@ impl<'cx, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'cx, 'gcx, 'tcx> {\n     }\n }\n \n-/// When we encounter a binder like `for<..> fn(..)`, we actually have\n-/// to walk the `fn` value to find all the values bound by the `for`\n-/// (these are not explicitly present in the ty representation right\n-/// now). This visitor handles that: it descends the type, tracking\n-/// binder depth, and finds late-bound regions targeting the\n-/// `for<..`>.  For each of those, it creates an entry in\n-/// `bound_region_scope`.\n-struct BoundReplacer<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n+/// The \"type generalize\" is used when handling inference variables.\n+///\n+/// The basic strategy for handling a constraint like `?A <: B` is to\n+/// apply a \"generalization strategy\" to the type `B` -- this replaces\n+/// all the lifetimes in the type `B` with fresh inference\n+/// variables. (You can read more about the strategy in this [blog\n+/// post].)\n+///\n+/// As an example, if we had `?A <: &'x u32`, we would generalize `&'x\n+/// u32` to `&'0 u32` where `'0` is a fresh variable. This becomes the\n+/// value of `A`. Finally, we relate `&'0 u32 <: &'x u32`, which\n+/// establishes `'0: 'x` as a constraint.\n+///\n+/// As a side-effect of this generalization procedure, we also replace\n+/// all the bound regions that we have traversed with concrete values,\n+/// so that the resulting generalized type is independent from the\n+/// scopes.\n+///\n+/// [blog post]: http://smallcultfollowing.com/babysteps/blog/2014/07/09/an-experimental-new-type-inference-scheme-for-rust/\n+struct TypeGeneralizer<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n     type_rel: &'me TypeRelating<'me, 'bccx, 'gcx, 'tcx>,\n+\n+    /// After we generalize this type, we are going to relative it to\n+    /// some other type. What will be the variance at this point?\n+    ambient_variance: ty::Variance,\n+\n     first_free_index: ty::DebruijnIndex,\n-    universal_regions: &'me UniversalRegions<'tcx>,\n-    scopes: &'me [BoundRegionScope],\n+\n+    universe: ty::UniverseIndex,\n }\n \n-impl TypeFolder<'gcx, 'tcx> for BoundReplacer<'me, 'bccx, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n-        self.type_rel.tcx()\n+impl TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'bbcx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+        self.type_rel.infcx.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n-        self.first_free_index.shift_in(1);\n-        let result = t.super_fold_with(self);\n-        self.first_free_index.shift_out(1);\n-        result\n+    fn tag(&self) -> &'static str {\n+        \"nll::generalizer\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        let tcx = self.tcx();\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        variance: ty::Variance,\n+        a: &T,\n+        b: &T,\n+    ) -> RelateResult<'tcx, T> {\n+        debug!(\n+            \"TypeGeneralizer::relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n+            variance, a, b\n+        );\n+\n+        let old_ambient_variance = self.ambient_variance;\n+        self.ambient_variance = self.ambient_variance.xform(variance);\n \n-        if let ty::ReLateBound(debruijn, _) = r {\n+        debug!(\n+            \"TypeGeneralizer::relate_with_variance: ambient_variance = {:?}\",\n+            self.ambient_variance\n+        );\n+\n+        let r = self.relate(a, b)?;\n+\n+        self.ambient_variance = old_ambient_variance;\n+\n+        debug!(\"TypeGeneralizer::relate_with_variance: r={:?}\", r);\n+\n+        Ok(r)\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, _: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"TypeGeneralizer::tys(a={:?})\", a,);\n+\n+        match a.sty {\n+            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) => {\n+                bug!(\n+                    \"unexpected inference variable encountered in NLL generalization: {:?}\",\n+                    a\n+                );\n+            }\n+\n+            _ => relate::super_relate_tys(self, a, a),\n+        }\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        _: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        debug!(\"TypeGeneralizer::regions(a={:?})\", a,);\n+\n+        if let ty::ReLateBound(debruijn, _) = a {\n             if *debruijn < self.first_free_index {\n-                return r;\n+                return Ok(a);\n             }\n         }\n \n-        let region_vid = self.type_rel.replace_bound_region(\n-            self.universal_regions,\n-            r,\n-            self.first_free_index,\n-            self.scopes,\n-        );\n+        // For now, we just always create a fresh region variable to\n+        // replace all the regions in the source type. In the main\n+        // type checker, we special case the case where the ambient\n+        // variance is `Invariant` and try to avoid creating a fresh\n+        // region variable, but since this comes up so much less in\n+        // NLL (only when users use `_` etc) it is much less\n+        // important.\n+        //\n+        // As an aside, since these new variables are created in\n+        // `self.universe` universe, this also serves to enforce the\n+        // universe scoping rules.\n+        //\n+        // FIXME -- if the ambient variance is bivariant, though, we\n+        // may however need to check well-formedness or risk a problem\n+        // like #41677 again.\n+\n+        let replacement_region_vid = self.type_rel\n+            .infcx\n+            .next_nll_region_var_in_universe(NLLRegionVariableOrigin::Existential, self.universe);\n+\n+        Ok(replacement_region_vid)\n+    }\n \n-        tcx.mk_region(ty::ReVar(region_vid))\n+    fn binders<T>(\n+        &mut self,\n+        a: &ty::Binder<T>,\n+        _: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        debug!(\"TypeGeneralizer::binders(a={:?})\", a,);\n+\n+        self.first_free_index.shift_in(1);\n+        let result = self.relate(a.skip_binder(), a.skip_binder())?;\n+        self.first_free_index.shift_out(1);\n+        Ok(ty::Binder::bind(result))\n     }\n }"}]}