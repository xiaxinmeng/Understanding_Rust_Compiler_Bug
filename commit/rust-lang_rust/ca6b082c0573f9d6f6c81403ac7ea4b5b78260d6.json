{"sha": "ca6b082c0573f9d6f6c81403ac7ea4b5b78260d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNmIwODJjMDU3M2Y5ZDZmNmM4MTQwM2FjN2VhNGI1Yjc4MjYwZDY=", "commit": {"author": {"name": "Dan Burkert", "email": "dan@danburkert.com", "date": "2014-09-27T21:19:19Z"}, "committer": {"name": "Dan Burkert", "email": "dan@danburkert.com", "date": "2014-11-01T17:54:34Z"}, "message": "libserialize: tuple-arity should be provided to `Decoder::read_tuple`\n\nCurrently `Decoder` implementations are not provided the tuple arity as\na parameter to `read_tuple`. This forces all encoder/decoder combos to\nserialize the arity along with the elements. Tuple-arity is always known\nstatically at the decode site, because it is part of the type of the\ntuple, so it could instead be provided as an argument to `read_tuple`,\nas it is to `read_struct`.\n\nThe upside to this is that serialized tuples could become smaller in\nencoder/decoder implementations which choose not to serialize type\n(arity) information. For example, @TyOverby's\n[binary-encode](https://github.com/TyOverby/binary-encode) format is\ncurrently forced to serialize the tuple-arity along with every tuple,\ndespite the information being statically known at the decode site.\n\nA downside to this change is that the tuple-arity of serialized tuples\ncan no longer be automatically checked during deserialization. However,\nfor formats which do serialize the tuple-arity, either explicitly (rbml)\nor implicitly (json), this check can be added to the `read_tuple` method.\n\nThe signature of `Deserialize::read_tuple` and\n`Deserialize::read_tuple_struct` are changed, and thus binary\nbackwards-compatibility is broken. This change does *not* force\nserialization formats to change, and thus does not break decoding values\nserialized prior to this change.\n\n[breaking-change]", "tree": {"sha": "89fc51a5a629a766949f6445f56e04b020f05d27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89fc51a5a629a766949f6445f56e04b020f05d27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca6b082c0573f9d6f6c81403ac7ea4b5b78260d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca6b082c0573f9d6f6c81403ac7ea4b5b78260d6", "html_url": "https://github.com/rust-lang/rust/commit/ca6b082c0573f9d6f6c81403ac7ea4b5b78260d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca6b082c0573f9d6f6c81403ac7ea4b5b78260d6/comments", "author": {"login": "danburkert", "id": 160242, "node_id": "MDQ6VXNlcjE2MDI0Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160242?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danburkert", "html_url": "https://github.com/danburkert", "followers_url": "https://api.github.com/users/danburkert/followers", "following_url": "https://api.github.com/users/danburkert/following{/other_user}", "gists_url": "https://api.github.com/users/danburkert/gists{/gist_id}", "starred_url": "https://api.github.com/users/danburkert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danburkert/subscriptions", "organizations_url": "https://api.github.com/users/danburkert/orgs", "repos_url": "https://api.github.com/users/danburkert/repos", "events_url": "https://api.github.com/users/danburkert/events{/privacy}", "received_events_url": "https://api.github.com/users/danburkert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "danburkert", "id": 160242, "node_id": "MDQ6VXNlcjE2MDI0Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160242?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danburkert", "html_url": "https://github.com/danburkert", "followers_url": "https://api.github.com/users/danburkert/followers", "following_url": "https://api.github.com/users/danburkert/following{/other_user}", "gists_url": "https://api.github.com/users/danburkert/gists{/gist_id}", "starred_url": "https://api.github.com/users/danburkert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danburkert/subscriptions", "organizations_url": "https://api.github.com/users/danburkert/orgs", "repos_url": "https://api.github.com/users/danburkert/repos", "events_url": "https://api.github.com/users/danburkert/events{/privacy}", "received_events_url": "https://api.github.com/users/danburkert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0547a407aa03b9f1c03843aead617a2e8c5d1147", "url": "https://api.github.com/repos/rust-lang/rust/commits/0547a407aa03b9f1c03843aead617a2e8c5d1147", "html_url": "https://github.com/rust-lang/rust/commit/0547a407aa03b9f1c03843aead617a2e8c5d1147"}], "stats": {"total": 66, "additions": 52, "deletions": 14}, "files": [{"sha": "9bb5777ec9a5e343fcbd16fc43a5afab04a313e3", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ca6b082c0573f9d6f6c81403ac7ea4b5b78260d6/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6b082c0573f9d6f6c81403ac7ea4b5b78260d6/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=ca6b082c0573f9d6f6c81403ac7ea4b5b78260d6", "patch": "@@ -558,9 +558,15 @@ pub mod reader {\n         }\n \n         fn read_tuple<T>(&mut self,\n-                         f: |&mut Decoder<'doc>, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n+                         tuple_len: uint,\n+                         f: |&mut Decoder<'doc>| -> DecodeResult<T>) -> DecodeResult<T> {\n             debug!(\"read_tuple()\");\n-            self.read_seq(f)\n+            self.read_seq(|d, len| {\n+                assert!(len == tuple_len,\n+                        \"expected tuple of length `{}`, found tuple \\\n+                         of length `{}`\", tuple_len, len);\n+                f(d)\n+            })\n         }\n \n         fn read_tuple_arg<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n@@ -571,10 +577,11 @@ pub mod reader {\n \n         fn read_tuple_struct<T>(&mut self,\n                                 name: &str,\n-                                f: |&mut Decoder<'doc>, uint| -> DecodeResult<T>)\n+                                len: uint,\n+                                f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n                                 -> DecodeResult<T> {\n             debug!(\"read_tuple_struct(name={})\", name);\n-            self.read_tuple(f)\n+            self.read_tuple(len, f)\n         }\n \n         fn read_tuple_struct_arg<T>(&mut self,"}, {"sha": "e5847ce58db1287c333bd41b5b9465aac5a9797e", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ca6b082c0573f9d6f6c81403ac7ea4b5b78260d6/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6b082c0573f9d6f6c81403ac7ea4b5b78260d6/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=ca6b082c0573f9d6f6c81403ac7ea4b5b78260d6", "patch": "@@ -2153,9 +2153,14 @@ impl ::Decoder<DecoderError> for Decoder {\n         Ok(value)\n     }\n \n-    fn read_tuple<T>(&mut self, f: |&mut Decoder, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n+    fn read_tuple<T>(&mut self, tuple_len: uint, f: |&mut Decoder| -> DecodeResult<T>) -> DecodeResult<T> {\n         debug!(\"read_tuple()\");\n-        self.read_seq(f)\n+        self.read_seq(|d, len| {\n+            assert!(len == tuple_len,\n+                    \"expected tuple of length `{}`, found tuple \\\n+                         of length `{}`\", tuple_len, len);\n+            f(d)\n+        })\n     }\n \n     fn read_tuple_arg<T>(&mut self,\n@@ -2167,10 +2172,11 @@ impl ::Decoder<DecoderError> for Decoder {\n \n     fn read_tuple_struct<T>(&mut self,\n                             name: &str,\n-                            f: |&mut Decoder, uint| -> DecodeResult<T>)\n+                            len: uint,\n+                            f: |&mut Decoder| -> DecodeResult<T>)\n                             -> DecodeResult<T> {\n         debug!(\"read_tuple_struct(name={})\", name);\n-        self.read_tuple(f)\n+        self.read_tuple(len, f)\n     }\n \n     fn read_tuple_struct_arg<T>(&mut self,\n@@ -2872,6 +2878,26 @@ mod tests {\n         assert_eq!(v, vec![vec![3], vec![1, 2]]);\n     }\n \n+    #[test]\n+    fn test_decode_tuple() {\n+        let t: (uint, uint, uint) = super::decode(\"[1, 2, 3]\").unwrap();\n+        assert_eq!(t, (1u, 2, 3))\n+\n+        let t: (uint, string::String) = super::decode(\"[1, \\\"two\\\"]\").unwrap();\n+        assert_eq!(t, (1u, \"two\".to_string()));\n+    }\n+\n+    #[test]\n+    fn test_decode_tuple_malformed_types() {\n+        assert!(super::decode::<(uint, string::String)>(\"[1, 2]\").is_err());\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_decode_tuple_malformed_length() {\n+        let _ = super::decode::<(uint, uint)>(\"[1, 2, 3]\");\n+    }\n+\n     #[test]\n     fn test_read_object() {\n         assert_eq!(from_str(\"{\"),       Err(SyntaxError(EOFWhileParsingObject, 1, 2)));"}, {"sha": "b7c37defbfa4e72702b6add27ff2e6fb6993dfb6", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ca6b082c0573f9d6f6c81403ac7ea4b5b78260d6/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6b082c0573f9d6f6c81403ac7ea4b5b78260d6/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=ca6b082c0573f9d6f6c81403ac7ea4b5b78260d6", "patch": "@@ -142,12 +142,13 @@ pub trait Decoder<E> {\n                             f: |&mut Self| -> Result<T, E>)\n                             -> Result<T, E>;\n \n-    fn read_tuple<T>(&mut self, f: |&mut Self, uint| -> Result<T, E>) -> Result<T, E>;\n+    fn read_tuple<T>(&mut self, len: uint, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n     fn read_tuple_arg<T>(&mut self, a_idx: uint, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n \n     fn read_tuple_struct<T>(&mut self,\n                             s_name: &str,\n-                            f: |&mut Self, uint| -> Result<T, E>)\n+                            len: uint,\n+                            f: |&mut Self| -> Result<T, E>)\n                             -> Result<T, E>;\n     fn read_tuple_struct_arg<T>(&mut self,\n                                 a_idx: uint,\n@@ -465,20 +466,24 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Option<T> {\n \n macro_rules! peel(($name:ident, $($other:ident,)*) => (tuple!($($other,)*)))\n \n+/// Evaluates to the number of identifiers passed to it, for example: `count_idents!(a, b, c) == 3\n+macro_rules! count_idents {\n+    () => { 0u };\n+    ($_i:ident $(, $rest:ident)*) => { 1 + count_idents!($($rest),*) }\n+}\n+\n macro_rules! tuple (\n     () => ();\n     ( $($name:ident,)+ ) => (\n         impl<E, D:Decoder<E>,$($name:Decodable<D, E>),*> Decodable<D,E> for ($($name,)*) {\n             #[allow(non_snake_case)]\n             fn decode(d: &mut D) -> Result<($($name,)*), E> {\n-                d.read_tuple(|d, amt| {\n+                let len: uint = count_idents!($($name),*);\n+                d.read_tuple(len, |d| {\n                     let mut i = 0;\n                     let ret = ($(try!(d.read_tuple_arg({ i+=1; i-1 }, |d| -> Result<$name,E> {\n                         Decodable::decode(d)\n                     })),)*);\n-                    assert!(amt == i,\n-                            \"expected tuple of length `{}`, found tuple \\\n-                             of length `{}`\", i, amt);\n                     return Ok(ret);\n                 })\n             }"}]}