{"sha": "39d8d3ab6a880179ef12b5d11414d940711ed422", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZDhkM2FiNmE4ODAxNzllZjEyYjVkMTE0MTRkOTQwNzExZWQ0MjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-20T16:03:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-20T16:03:47Z"}, "message": "Auto merge of #87247 - crlf0710:merge-libterm-into-libtest, r=nagisa\n\nMerge libterm into libtest\n\nI think it's quite clear at this point that rust won't stablize the current libterm APIs to the outside world. And its only user is libtest. The compiler doesn't use this api at all. So I'm merging the crate into libtest as a module.\n\nThis also allows me to remove 15% of the libterm code, since these APIs are dead-code now.", "tree": {"sha": "d0c959fb55f0683f20d4cc4014497dd6c1022327", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0c959fb55f0683f20d4cc4014497dd6c1022327"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39d8d3ab6a880179ef12b5d11414d940711ed422", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39d8d3ab6a880179ef12b5d11414d940711ed422", "html_url": "https://github.com/rust-lang/rust/commit/39d8d3ab6a880179ef12b5d11414d940711ed422", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39d8d3ab6a880179ef12b5d11414d940711ed422/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c0ca08c662399c1c864310d1a20867d3ab68027", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c0ca08c662399c1c864310d1a20867d3ab68027", "html_url": "https://github.com/rust-lang/rust/commit/5c0ca08c662399c1c864310d1a20867d3ab68027"}, {"sha": "4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac", "html_url": "https://github.com/rust-lang/rust/commit/4486795d02bff3bd4ef4327a3dfe3c5c5f87f8ac"}], "stats": {"total": 543, "additions": 133, "deletions": 410}, "files": [{"sha": "5441542d84e0327e289c0d30aafab75fe8541e22", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/39d8d3ab6a880179ef12b5d11414d940711ed422/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/39d8d3ab6a880179ef12b5d11414d940711ed422/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=39d8d3ab6a880179ef12b5d11414d940711ed422", "patch": "@@ -5095,14 +5095,6 @@ dependencies = [\n  \"serde_json\",\n ]\n \n-[[package]]\n-name = \"term\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"core\",\n- \"std\",\n-]\n-\n [[package]]\n name = \"term\"\n version = \"0.6.1\"\n@@ -5155,7 +5147,6 @@ dependencies = [\n  \"panic_unwind\",\n  \"proc_macro\",\n  \"std\",\n- \"term 0.0.0\",\n ]\n \n [[package]]"}, {"sha": "ddf85b5c5bcdbddf584b6ddc988988a1269f30b8", "filename": "library/term/Cargo.toml", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c0ca08c662399c1c864310d1a20867d3ab68027/library%2Fterm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5c0ca08c662399c1c864310d1a20867d3ab68027/library%2Fterm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fterm%2FCargo.toml?ref=5c0ca08c662399c1c864310d1a20867d3ab68027", "patch": "@@ -1,9 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"term\"\n-version = \"0.0.0\"\n-edition = \"2018\"\n-\n-[dependencies]\n-core = { path = \"../core\" }\n-std = { path = \"../std\" }"}, {"sha": "943b276a220c88fc7e330804f0c2edcc6601bfc9", "filename": "library/term/src/lib.rs", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/5c0ca08c662399c1c864310d1a20867d3ab68027/library%2Fterm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c0ca08c662399c1c864310d1a20867d3ab68027/library%2Fterm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fterm%2Fsrc%2Flib.rs?ref=5c0ca08c662399c1c864310d1a20867d3ab68027", "patch": "@@ -1,194 +0,0 @@\n-//! Terminal formatting library.\n-//!\n-//! This crate provides the `Terminal` trait, which abstracts over an [ANSI\n-//! Terminal][ansi] to provide color printing, among other things. There are two\n-//! implementations, the `TerminfoTerminal`, which uses control characters from\n-//! a [terminfo][ti] database, and `WinConsole`, which uses the [Win32 Console\n-//! API][win].\n-//!\n-//! # Examples\n-//!\n-//! ```no_run\n-//! # #![feature(rustc_private)]\n-//! extern crate term;\n-//! use std::io::prelude::*;\n-//!\n-//! fn main() {\n-//!     let mut t = term::stdout().unwrap();\n-//!\n-//!     t.fg(term::color::GREEN).unwrap();\n-//!     write!(t, \"hello, \").unwrap();\n-//!\n-//!     t.fg(term::color::RED).unwrap();\n-//!     writeln!(t, \"world!\").unwrap();\n-//!\n-//!     assert!(t.reset().unwrap());\n-//! }\n-//! ```\n-//!\n-//! [ansi]: https://en.wikipedia.org/wiki/ANSI_escape_code\n-//! [win]: https://docs.microsoft.com/en-us/windows/console/character-mode-applications\n-//! [ti]: https://en.wikipedia.org/wiki/Terminfo\n-\n-#![doc(html_playground_url = \"https://play.rust-lang.org/\", test(attr(deny(warnings))))]\n-#![deny(missing_docs)]\n-#![cfg_attr(windows, feature(libc))]\n-\n-use std::io::prelude::*;\n-use std::io::{self, Stderr, Stdout};\n-\n-pub use terminfo::TerminfoTerminal;\n-#[cfg(windows)]\n-pub use win::WinConsole;\n-\n-pub mod terminfo;\n-\n-#[cfg(windows)]\n-mod win;\n-\n-/// Alias for stdout terminals.\n-pub type StdoutTerminal = dyn Terminal<Output = Stdout> + Send;\n-/// Alias for stderr terminals.\n-pub type StderrTerminal = dyn Terminal<Output = Stderr> + Send;\n-\n-#[cfg(not(windows))]\n-/// Returns a Terminal wrapping stdout, or None if a terminal couldn't be\n-/// opened.\n-pub fn stdout() -> Option<Box<StdoutTerminal>> {\n-    TerminfoTerminal::new(io::stdout()).map(|t| Box::new(t) as Box<StdoutTerminal>)\n-}\n-\n-#[cfg(windows)]\n-/// Returns a Terminal wrapping stdout, or None if a terminal couldn't be\n-/// opened.\n-pub fn stdout() -> Option<Box<StdoutTerminal>> {\n-    TerminfoTerminal::new(io::stdout())\n-        .map(|t| Box::new(t) as Box<StdoutTerminal>)\n-        .or_else(|| WinConsole::new(io::stdout()).ok().map(|t| Box::new(t) as Box<StdoutTerminal>))\n-}\n-\n-#[cfg(not(windows))]\n-/// Returns a Terminal wrapping stderr, or None if a terminal couldn't be\n-/// opened.\n-pub fn stderr() -> Option<Box<StderrTerminal>> {\n-    TerminfoTerminal::new(io::stderr()).map(|t| Box::new(t) as Box<StderrTerminal>)\n-}\n-\n-#[cfg(windows)]\n-/// Returns a Terminal wrapping stderr, or None if a terminal couldn't be\n-/// opened.\n-pub fn stderr() -> Option<Box<StderrTerminal>> {\n-    TerminfoTerminal::new(io::stderr())\n-        .map(|t| Box::new(t) as Box<StderrTerminal>)\n-        .or_else(|| WinConsole::new(io::stderr()).ok().map(|t| Box::new(t) as Box<StderrTerminal>))\n-}\n-\n-/// Terminal color definitions\n-#[allow(missing_docs)]\n-pub mod color {\n-    /// Number for a terminal color\n-    pub type Color = u32;\n-\n-    pub const BLACK: Color = 0;\n-    pub const RED: Color = 1;\n-    pub const GREEN: Color = 2;\n-    pub const YELLOW: Color = 3;\n-    pub const BLUE: Color = 4;\n-    pub const MAGENTA: Color = 5;\n-    pub const CYAN: Color = 6;\n-    pub const WHITE: Color = 7;\n-\n-    pub const BRIGHT_BLACK: Color = 8;\n-    pub const BRIGHT_RED: Color = 9;\n-    pub const BRIGHT_GREEN: Color = 10;\n-    pub const BRIGHT_YELLOW: Color = 11;\n-    pub const BRIGHT_BLUE: Color = 12;\n-    pub const BRIGHT_MAGENTA: Color = 13;\n-    pub const BRIGHT_CYAN: Color = 14;\n-    pub const BRIGHT_WHITE: Color = 15;\n-}\n-\n-/// Terminal attributes for use with term.attr().\n-///\n-/// Most attributes can only be turned on and must be turned off with term.reset().\n-/// The ones that can be turned off explicitly take a boolean value.\n-/// Color is also represented as an attribute for convenience.\n-#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n-pub enum Attr {\n-    /// Bold (or possibly bright) mode\n-    Bold,\n-    /// Dim mode, also called faint or half-bright. Often not supported\n-    Dim,\n-    /// Italics mode. Often not supported\n-    Italic(bool),\n-    /// Underline mode\n-    Underline(bool),\n-    /// Blink mode\n-    Blink,\n-    /// Standout mode. Often implemented as Reverse, sometimes coupled with Bold\n-    Standout(bool),\n-    /// Reverse mode, inverts the foreground and background colors\n-    Reverse,\n-    /// Secure mode, also called invis mode. Hides the printed text\n-    Secure,\n-    /// Convenience attribute to set the foreground color\n-    ForegroundColor(color::Color),\n-    /// Convenience attribute to set the background color\n-    BackgroundColor(color::Color),\n-}\n-\n-/// A terminal with similar capabilities to an ANSI Terminal\n-/// (foreground/background colors etc).\n-pub trait Terminal: Write {\n-    /// The terminal's output writer type.\n-    type Output: Write;\n-\n-    /// Sets the foreground color to the given color.\n-    ///\n-    /// If the color is a bright color, but the terminal only supports 8 colors,\n-    /// the corresponding normal color will be used instead.\n-    ///\n-    /// Returns `Ok(true)` if the color was set, `Ok(false)` otherwise, and `Err(e)`\n-    /// if there was an I/O error.\n-    fn fg(&mut self, color: color::Color) -> io::Result<bool>;\n-\n-    /// Sets the background color to the given color.\n-    ///\n-    /// If the color is a bright color, but the terminal only supports 8 colors,\n-    /// the corresponding normal color will be used instead.\n-    ///\n-    /// Returns `Ok(true)` if the color was set, `Ok(false)` otherwise, and `Err(e)`\n-    /// if there was an I/O error.\n-    fn bg(&mut self, color: color::Color) -> io::Result<bool>;\n-\n-    /// Sets the given terminal attribute, if supported. Returns `Ok(true)`\n-    /// if the attribute was supported, `Ok(false)` otherwise, and `Err(e)` if\n-    /// there was an I/O error.\n-    fn attr(&mut self, attr: Attr) -> io::Result<bool>;\n-\n-    /// Returns `true` if the given terminal attribute is supported.\n-    fn supports_attr(&self, attr: Attr) -> bool;\n-\n-    /// Resets all terminal attributes and colors to their defaults.\n-    ///\n-    /// Returns `Ok(true)` if the terminal was reset, `Ok(false)` otherwise, and `Err(e)` if there\n-    /// was an I/O error.\n-    ///\n-    /// *Note: This does not flush.*\n-    ///\n-    /// That means the reset command may get buffered so, if you aren't planning on doing anything\n-    /// else that might flush stdout's buffer (e.g., writing a line of text), you should flush after\n-    /// calling reset.\n-    fn reset(&mut self) -> io::Result<bool>;\n-\n-    /// Gets an immutable reference to the stream inside\n-    fn get_ref(&self) -> &Self::Output;\n-\n-    /// Gets a mutable reference to the stream inside\n-    fn get_mut(&mut self) -> &mut Self::Output;\n-\n-    /// Returns the contained stream, destroying the `Terminal`\n-    fn into_inner(self) -> Self::Output\n-    where\n-        Self: Sized;\n-}"}, {"sha": "479d86354c04cd24f84bcb938183e6630c31bd7a", "filename": "library/test/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2FCargo.toml?ref=39d8d3ab6a880179ef12b5d11414d940711ed422", "patch": "@@ -10,7 +10,6 @@ crate-type = [\"dylib\", \"rlib\"]\n [dependencies]\n cfg-if = { version = \"0.1.8\", features = ['rustc-dep-of-std'] }\n getopts = { version = \"0.2.21\", features = ['rustc-dep-of-std'] }\n-term = { path = \"../term\" }\n std = { path = \"../std\" }\n core = { path = \"../core\" }\n libc = { version = \"0.2\", default-features = false }"}, {"sha": "54e30a1fcd070424475b0dcdc661f29053bab207", "filename": "library/test/src/console.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fconsole.rs?ref=39d8d3ab6a880179ef12b5d11414d940711ed422", "patch": "@@ -13,7 +13,7 @@ use super::{\n     formatters::{JsonFormatter, JunitFormatter, OutputFormatter, PrettyFormatter, TerseFormatter},\n     helpers::{concurrency::get_concurrency, metrics::MetricMap},\n     options::{Options, OutputFormat},\n-    run_tests,\n+    run_tests, term,\n     test_result::TestResult,\n     time::{TestExecTime, TestSuiteExecTime},\n     types::{NamePadding, TestDesc, TestDescAndFn},"}, {"sha": "9cad71e30bddb85e8d78b798c70b8d32543339ca", "filename": "library/test/src/formatters/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fpretty.rs?ref=39d8d3ab6a880179ef12b5d11414d940711ed422", "patch": "@@ -4,6 +4,7 @@ use super::OutputFormatter;\n use crate::{\n     bench::fmt_bench_samples,\n     console::{ConsoleTestState, OutputLocation},\n+    term,\n     test_result::TestResult,\n     time,\n     types::TestDesc,"}, {"sha": "0c8215c5daca165b71975d777ab1393a2aeeb700", "filename": "library/test/src/formatters/terse.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fformatters%2Fterse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fformatters%2Fterse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fterse.rs?ref=39d8d3ab6a880179ef12b5d11414d940711ed422", "patch": "@@ -4,6 +4,7 @@ use super::OutputFormatter;\n use crate::{\n     bench::fmt_bench_samples,\n     console::{ConsoleTestState, OutputLocation},\n+    term,\n     test_result::TestResult,\n     time,\n     types::NamePadding,"}, {"sha": "251f099f28af47e399640842f01c05fa4038837a", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=39d8d3ab6a880179ef12b5d11414d940711ed422", "patch": "@@ -20,7 +20,7 @@\n #![crate_name = \"test\"]\n #![unstable(feature = \"test\", issue = \"50297\")]\n #![doc(test(attr(deny(warnings))))]\n-#![cfg_attr(unix, feature(libc))]\n+#![feature(libc)]\n #![feature(rustc_private)]\n #![feature(nll)]\n #![feature(available_concurrency)]\n@@ -80,6 +80,7 @@ mod formatters;\n mod helpers;\n mod options;\n pub mod stats;\n+mod term;\n mod test_result;\n mod time;\n mod types;"}, {"sha": "b256ab7b8f82872942e11bb81d7894eb3a8323a6", "filename": "library/test/src/term.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm.rs?ref=39d8d3ab6a880179ef12b5d11414d940711ed422", "patch": "@@ -0,0 +1,85 @@\n+//! Terminal formatting module.\n+//!\n+//! This module provides the `Terminal` trait, which abstracts over an [ANSI\n+//! Terminal][ansi] to provide color printing, among other things. There are two\n+//! implementations, the `TerminfoTerminal`, which uses control characters from\n+//! a [terminfo][ti] database, and `WinConsole`, which uses the [Win32 Console\n+//! API][win].\n+//!\n+//! [ansi]: https://en.wikipedia.org/wiki/ANSI_escape_code\n+//! [win]: https://docs.microsoft.com/en-us/windows/console/character-mode-applications\n+//! [ti]: https://en.wikipedia.org/wiki/Terminfo\n+\n+#![deny(missing_docs)]\n+\n+use std::io::{self, prelude::*};\n+\n+pub(crate) use terminfo::TerminfoTerminal;\n+#[cfg(windows)]\n+pub(crate) use win::WinConsole;\n+\n+pub(crate) mod terminfo;\n+\n+#[cfg(windows)]\n+mod win;\n+\n+/// Alias for stdout terminals.\n+pub(crate) type StdoutTerminal = dyn Terminal + Send;\n+\n+#[cfg(not(windows))]\n+/// Returns a Terminal wrapping stdout, or None if a terminal couldn't be\n+/// opened.\n+pub(crate) fn stdout() -> Option<Box<StdoutTerminal>> {\n+    TerminfoTerminal::new(io::stdout()).map(|t| Box::new(t) as Box<StdoutTerminal>)\n+}\n+\n+#[cfg(windows)]\n+/// Returns a Terminal wrapping stdout, or None if a terminal couldn't be\n+/// opened.\n+pub(crate) fn stdout() -> Option<Box<StdoutTerminal>> {\n+    TerminfoTerminal::new(io::stdout())\n+        .map(|t| Box::new(t) as Box<StdoutTerminal>)\n+        .or_else(|| WinConsole::new(io::stdout()).ok().map(|t| Box::new(t) as Box<StdoutTerminal>))\n+}\n+\n+/// Terminal color definitions\n+#[allow(missing_docs)]\n+#[cfg_attr(not(windows), allow(dead_code))]\n+pub(crate) mod color {\n+    /// Number for a terminal color\n+    pub(crate) type Color = u32;\n+\n+    pub(crate) const BLACK: Color = 0;\n+    pub(crate) const RED: Color = 1;\n+    pub(crate) const GREEN: Color = 2;\n+    pub(crate) const YELLOW: Color = 3;\n+    pub(crate) const BLUE: Color = 4;\n+    pub(crate) const MAGENTA: Color = 5;\n+    pub(crate) const CYAN: Color = 6;\n+    pub(crate) const WHITE: Color = 7;\n+}\n+\n+/// A terminal with similar capabilities to an ANSI Terminal\n+/// (foreground/background colors etc).\n+pub trait Terminal: Write {\n+    /// Sets the foreground color to the given color.\n+    ///\n+    /// If the color is a bright color, but the terminal only supports 8 colors,\n+    /// the corresponding normal color will be used instead.\n+    ///\n+    /// Returns `Ok(true)` if the color was set, `Ok(false)` otherwise, and `Err(e)`\n+    /// if there was an I/O error.\n+    fn fg(&mut self, color: color::Color) -> io::Result<bool>;\n+\n+    /// Resets all terminal attributes and colors to their defaults.\n+    ///\n+    /// Returns `Ok(true)` if the terminal was reset, `Ok(false)` otherwise, and `Err(e)` if there\n+    /// was an I/O error.\n+    ///\n+    /// *Note: This does not flush.*\n+    ///\n+    /// That means the reset command may get buffered so, if you aren't planning on doing anything\n+    /// else that might flush stdout's buffer (e.g., writing a line of text), you should flush after\n+    /// calling reset.\n+    fn reset(&mut self) -> io::Result<bool>;\n+}"}, {"sha": "f4c5a05d1e2cebbd97f717274c5d40c434887b78", "filename": "library/test/src/term/terminfo/mod.rs", "status": "renamed", "additions": 18, "deletions": 79, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fmod.rs?ref=39d8d3ab6a880179ef12b5d11414d940711ed422", "patch": "@@ -8,30 +8,29 @@ use std::fs::File;\n use std::io::{self, prelude::*, BufReader};\n use std::path::Path;\n \n-use crate::color;\n-use crate::Attr;\n-use crate::Terminal;\n+use super::color;\n+use super::Terminal;\n \n use parm::{expand, Param, Variables};\n use parser::compiled::{msys_terminfo, parse};\n use searcher::get_dbpath_for_term;\n \n /// A parsed terminfo database entry.\n #[derive(Debug)]\n-pub struct TermInfo {\n+pub(crate) struct TermInfo {\n     /// Names for the terminal\n-    pub names: Vec<String>,\n+    pub(crate) names: Vec<String>,\n     /// Map of capability name to boolean value\n-    pub bools: HashMap<String, bool>,\n+    pub(crate) bools: HashMap<String, bool>,\n     /// Map of capability name to numeric value\n-    pub numbers: HashMap<String, u32>,\n+    pub(crate) numbers: HashMap<String, u32>,\n     /// Map of capability name to raw (unexpanded) string\n-    pub strings: HashMap<String, Vec<u8>>,\n+    pub(crate) strings: HashMap<String, Vec<u8>>,\n }\n \n /// A terminfo creation error.\n #[derive(Debug)]\n-pub enum Error {\n+pub(crate) enum Error {\n     /// TermUnset Indicates that the environment doesn't include enough information to find\n     /// the terminfo entry.\n     TermUnset,\n@@ -64,7 +63,7 @@ impl fmt::Display for Error {\n \n impl TermInfo {\n     /// Creates a TermInfo based on current environment.\n-    pub fn from_env() -> Result<TermInfo, Error> {\n+    pub(crate) fn from_env() -> Result<TermInfo, Error> {\n         let term = match env::var(\"TERM\") {\n             Ok(name) => TermInfo::from_name(&name),\n             Err(..) => return Err(Error::TermUnset),\n@@ -79,7 +78,7 @@ impl TermInfo {\n     }\n \n     /// Creates a TermInfo for the named terminal.\n-    pub fn from_name(name: &str) -> Result<TermInfo, Error> {\n+    pub(crate) fn from_name(name: &str) -> Result<TermInfo, Error> {\n         get_dbpath_for_term(name)\n             .ok_or_else(|| {\n                 Error::IoError(io::Error::new(io::ErrorKind::NotFound, \"terminfo file not found\"))\n@@ -88,7 +87,7 @@ impl TermInfo {\n     }\n \n     /// Parse the given TermInfo.\n-    pub fn from_path<P: AsRef<Path>>(path: P) -> Result<TermInfo, Error> {\n+    pub(crate) fn from_path<P: AsRef<Path>>(path: P) -> Result<TermInfo, Error> {\n         Self::_from_path(path.as_ref())\n     }\n     // Keep the metadata small\n@@ -99,43 +98,24 @@ impl TermInfo {\n     }\n }\n \n-pub mod searcher;\n+pub(crate) mod searcher;\n \n /// TermInfo format parsing.\n-pub mod parser {\n+pub(crate) mod parser {\n     //! ncurses-compatible compiled terminfo format parsing (term(5))\n-    pub mod compiled;\n-}\n-pub mod parm;\n-\n-fn cap_for_attr(attr: Attr) -> &'static str {\n-    match attr {\n-        Attr::Bold => \"bold\",\n-        Attr::Dim => \"dim\",\n-        Attr::Italic(true) => \"sitm\",\n-        Attr::Italic(false) => \"ritm\",\n-        Attr::Underline(true) => \"smul\",\n-        Attr::Underline(false) => \"rmul\",\n-        Attr::Blink => \"blink\",\n-        Attr::Standout(true) => \"smso\",\n-        Attr::Standout(false) => \"rmso\",\n-        Attr::Reverse => \"rev\",\n-        Attr::Secure => \"invis\",\n-        Attr::ForegroundColor(_) => \"setaf\",\n-        Attr::BackgroundColor(_) => \"setab\",\n-    }\n+    pub(crate) mod compiled;\n }\n+pub(crate) mod parm;\n \n /// A Terminal that knows how many colors it supports, with a reference to its\n /// parsed Terminfo database record.\n-pub struct TerminfoTerminal<T> {\n+pub(crate) struct TerminfoTerminal<T> {\n     num_colors: u32,\n     out: T,\n     ti: TermInfo,\n }\n \n impl<T: Write + Send> Terminal for TerminfoTerminal<T> {\n-    type Output = T;\n     fn fg(&mut self, color: color::Color) -> io::Result<bool> {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n@@ -144,32 +124,6 @@ impl<T: Write + Send> Terminal for TerminfoTerminal<T> {\n         Ok(false)\n     }\n \n-    fn bg(&mut self, color: color::Color) -> io::Result<bool> {\n-        let color = self.dim_if_necessary(color);\n-        if self.num_colors > color {\n-            return self.apply_cap(\"setab\", &[Param::Number(color as i32)]);\n-        }\n-        Ok(false)\n-    }\n-\n-    fn attr(&mut self, attr: Attr) -> io::Result<bool> {\n-        match attr {\n-            Attr::ForegroundColor(c) => self.fg(c),\n-            Attr::BackgroundColor(c) => self.bg(c),\n-            _ => self.apply_cap(cap_for_attr(attr), &[]),\n-        }\n-    }\n-\n-    fn supports_attr(&self, attr: Attr) -> bool {\n-        match attr {\n-            Attr::ForegroundColor(_) | Attr::BackgroundColor(_) => self.num_colors > 0,\n-            _ => {\n-                let cap = cap_for_attr(attr);\n-                self.ti.strings.get(cap).is_some()\n-            }\n-        }\n-    }\n-\n     fn reset(&mut self) -> io::Result<bool> {\n         // are there any terminals that have color/attrs and not sgr0?\n         // Try falling back to sgr, then op\n@@ -182,26 +136,11 @@ impl<T: Write + Send> Terminal for TerminfoTerminal<T> {\n         };\n         self.out.write_all(&cmd).and(Ok(true))\n     }\n-\n-    fn get_ref(&self) -> &T {\n-        &self.out\n-    }\n-\n-    fn get_mut(&mut self) -> &mut T {\n-        &mut self.out\n-    }\n-\n-    fn into_inner(self) -> T\n-    where\n-        Self: Sized,\n-    {\n-        self.out\n-    }\n }\n \n impl<T: Write + Send> TerminfoTerminal<T> {\n     /// Creates a new TerminfoTerminal with the given TermInfo and Write.\n-    pub fn new_with_terminfo(out: T, terminfo: TermInfo) -> TerminfoTerminal<T> {\n+    pub(crate) fn new_with_terminfo(out: T, terminfo: TermInfo) -> TerminfoTerminal<T> {\n         let nc = if terminfo.strings.contains_key(\"setaf\") && terminfo.strings.contains_key(\"setab\")\n         {\n             terminfo.numbers.get(\"colors\").map_or(0, |&n| n)\n@@ -215,7 +154,7 @@ impl<T: Write + Send> TerminfoTerminal<T> {\n     /// Creates a new TerminfoTerminal for the current environment with the given Write.\n     ///\n     /// Returns `None` when the terminfo cannot be found or parsed.\n-    pub fn new(out: T) -> Option<TerminfoTerminal<T>> {\n+    pub(crate) fn new(out: T) -> Option<TerminfoTerminal<T>> {\n         TermInfo::from_env().map(move |ti| TerminfoTerminal::new_with_terminfo(out, ti)).ok()\n     }\n ", "previous_filename": "library/term/src/terminfo/mod.rs"}, {"sha": "0d37eb7359d85cd50963a5e4e2dee17b700db786", "filename": "library/test/src/term/terminfo/parm.rs", "status": "renamed", "additions": 8, "deletions": 35, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparm.rs?ref=39d8d3ab6a880179ef12b5d11414d940711ed422", "patch": "@@ -35,13 +35,12 @@ enum FormatState {\n /// Types of parameters a capability can use\n #[allow(missing_docs)]\n #[derive(Clone)]\n-pub enum Param {\n-    Words(String),\n+pub(crate) enum Param {\n     Number(i32),\n }\n \n /// Container for static and dynamic variable arrays\n-pub struct Variables {\n+pub(crate) struct Variables {\n     /// Static variables A-Z\n     sta_va: [Param; 26],\n     /// Dynamic variables a-z\n@@ -50,7 +49,7 @@ pub struct Variables {\n \n impl Variables {\n     /// Returns a new zero-initialized Variables\n-    pub fn new() -> Variables {\n+    pub(crate) fn new() -> Variables {\n         Variables {\n             sta_va: [\n                 Number(0),\n@@ -121,7 +120,11 @@ impl Variables {\n ///\n /// To be compatible with ncurses, `vars` should be the same between calls to `expand` for\n /// multiple capabilities for the same terminal.\n-pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<u8>, String> {\n+pub(crate) fn expand(\n+    cap: &[u8],\n+    params: &[Param],\n+    vars: &mut Variables,\n+) -> Result<Vec<u8>, String> {\n     let mut state = Nothing;\n \n     // expanded cap will only rarely be larger than the cap itself\n@@ -168,7 +171,6 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                             Some(Number(0)) => output.push(128u8),\n                             // Don't check bounds. ncurses just casts and truncates.\n                             Some(Number(c)) => output.push(c as u8),\n-                            Some(_) => return Err(\"a non-char was used with %c\".to_string()),\n                             None => return Err(\"stack is empty\".to_string()),\n                         }\n                     }\n@@ -178,7 +180,6 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                     '\\'' => state = CharConstant,\n                     '{' => state = IntConstant(0),\n                     'l' => match stack.pop() {\n-                        Some(Words(s)) => stack.push(Number(s.len() as i32)),\n                         Some(_) => return Err(\"a non-str was used with %l\".to_string()),\n                         None => return Err(\"stack is empty\".to_string()),\n                     },\n@@ -195,9 +196,6 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                                 'm' => x % y,\n                                 _ => unreachable!(\"All cases handled\"),\n                             })),\n-                            (Some(_), Some(_)) => {\n-                                return Err(format!(\"non-numbers on stack with {}\", cur));\n-                            }\n                             _ => return Err(\"stack is empty\".to_string()),\n                         }\n                     }\n@@ -216,9 +214,6 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                                 0\n                             },\n                         )),\n-                        (Some(_), Some(_)) => {\n-                            return Err(format!(\"non-numbers on stack with {}\", cur));\n-                        }\n                         _ => return Err(\"stack is empty\".to_string()),\n                     },\n                     '!' | '~' => match stack.pop() {\n@@ -228,15 +223,13 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                             '~' => !x,\n                             _ => unreachable!(),\n                         })),\n-                        Some(_) => return Err(format!(\"non-numbers on stack with {}\", cur)),\n                         None => return Err(\"stack is empty\".to_string()),\n                     },\n                     'i' => match (&mparams[0], &mparams[1]) {\n                         (&Number(x), &Number(y)) => {\n                             mparams[0] = Number(x + 1);\n                             mparams[1] = Number(y + 1);\n                         }\n-                        _ => return Err(\"first two params not numbers with %i\".to_string()),\n                     },\n \n                     // printf-style support for %doxXs\n@@ -271,7 +264,6 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                     't' => match stack.pop() {\n                         Some(Number(0)) => state = SeekIfElse(0),\n                         Some(Number(_)) => (),\n-                        Some(_) => return Err(\"non-number on stack with conditional\".to_string()),\n                         None => return Err(\"stack is empty\".to_string()),\n                     },\n                     'e' => state = SeekIfEnd(0),\n@@ -480,15 +472,6 @@ impl FormatOp {\n             _ => panic!(\"bad FormatOp char\"),\n         }\n     }\n-    fn to_char(self) -> char {\n-        match self {\n-            FormatOp::Digit => 'd',\n-            FormatOp::Octal => 'o',\n-            FormatOp::LowerHex => 'x',\n-            FormatOp::UpperHex => 'X',\n-            FormatOp::String => 's',\n-        }\n-    }\n }\n \n fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8>, String> {\n@@ -533,16 +516,6 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8>, String> {\n             }\n             .into_bytes()\n         }\n-        Words(s) => match op {\n-            FormatOp::String => {\n-                let mut s = s.into_bytes();\n-                if flags.precision > 0 && flags.precision < s.len() {\n-                    s.truncate(flags.precision);\n-                }\n-                s\n-            }\n-            _ => return Err(format!(\"non-string on stack with %{}\", op.to_char())),\n-        },\n     };\n     if flags.width > s.len() {\n         let n = flags.width - s.len();", "previous_filename": "library/term/src/terminfo/parm.rs"}, {"sha": "256d1aaf446d96f962e0d29f0285d75ef2b5f9c5", "filename": "library/test/src/term/terminfo/parm/tests.rs", "status": "renamed", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparm%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparm%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparm%2Ftests.rs?ref=39d8d3ab6a880179ef12b5d11414d940711ed422", "patch": "@@ -51,7 +51,10 @@ fn test_param_stack_failure_conditions() {\n     for &cap in caps.iter() {\n         let res = get_res(\"\", cap, &[], vars);\n         assert!(res.is_err(), \"Op {} succeeded incorrectly with 0 stack entries\", cap);\n-        let p = if cap == \"%s\" || cap == \"%l\" { Words(\"foo\".to_string()) } else { Number(97) };\n+        if cap == \"%s\" || cap == \"%l\" {\n+            continue;\n+        }\n+        let p = Number(97);\n         let res = get_res(\"%p1\", cap, &[p], vars);\n         assert!(res.is_ok(), \"Op {} failed with 1 stack entry: {}\", cap, res.unwrap_err());\n     }\n@@ -109,23 +112,6 @@ fn test_conditionals() {\n fn test_format() {\n     let mut varstruct = Variables::new();\n     let vars = &mut varstruct;\n-    assert_eq!(\n-        expand(\n-            b\"%p1%s%p2%2s%p3%2s%p4%.2s\",\n-            &[\n-                Words(\"foo\".to_string()),\n-                Words(\"foo\".to_string()),\n-                Words(\"f\".to_string()),\n-                Words(\"foo\".to_string())\n-            ],\n-            vars\n-        ),\n-        Ok(\"foofoo ffo\".bytes().collect::<Vec<_>>())\n-    );\n-    assert_eq!(\n-        expand(b\"%p1%:-4.2s\", &[Words(\"foo\".to_string())], vars),\n-        Ok(\"fo  \".bytes().collect::<Vec<_>>())\n-    );\n \n     assert_eq!(\n         expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", &[Number(1)], vars),", "previous_filename": "library/term/src/terminfo/parm/tests.rs"}, {"sha": "b24f3f8b05e708cd9bb606d8f1de07f3a485c3ca", "filename": "library/test/src/term/terminfo/parser/compiled.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=39d8d3ab6a880179ef12b5d11414d940711ed422", "patch": "@@ -13,7 +13,7 @@ mod tests;\n // These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n \n #[rustfmt::skip]\n-pub static boolfnames: &[&str] = &[\"auto_left_margin\", \"auto_right_margin\",\n+pub(crate) static boolfnames: &[&str] = &[\"auto_left_margin\", \"auto_right_margin\",\n     \"no_esc_ctlc\", \"ceol_standout_glitch\", \"eat_newline_glitch\", \"erase_overstrike\", \"generic_type\",\n     \"hard_copy\", \"has_meta_key\", \"has_status_line\", \"insert_null_glitch\", \"memory_above\",\n     \"memory_below\", \"move_insert_mode\", \"move_standout_mode\", \"over_strike\", \"status_line_esc_ok\",\n@@ -26,13 +26,13 @@ pub static boolfnames: &[&str] = &[\"auto_left_margin\", \"auto_right_margin\",\n     \"return_does_clr_eol\"];\n \n #[rustfmt::skip]\n-pub static boolnames: &[&str] = &[\"bw\", \"am\", \"xsb\", \"xhp\", \"xenl\", \"eo\",\n+pub(crate) static boolnames: &[&str] = &[\"bw\", \"am\", \"xsb\", \"xhp\", \"xenl\", \"eo\",\n     \"gn\", \"hc\", \"km\", \"hs\", \"in\", \"db\", \"da\", \"mir\", \"msgr\", \"os\", \"eslok\", \"xt\", \"hz\", \"ul\", \"xon\",\n     \"nxon\", \"mc5i\", \"chts\", \"nrrmc\", \"npc\", \"ndscr\", \"ccc\", \"bce\", \"hls\", \"xhpa\", \"crxm\", \"daisy\",\n     \"xvpa\", \"sam\", \"cpix\", \"lpix\", \"OTbs\", \"OTns\", \"OTnc\", \"OTMT\", \"OTNL\", \"OTpt\", \"OTxr\"];\n \n #[rustfmt::skip]\n-pub static numfnames: &[&str] = &[ \"columns\", \"init_tabs\", \"lines\",\n+pub(crate) static numfnames: &[&str] = &[ \"columns\", \"init_tabs\", \"lines\",\n     \"lines_of_memory\", \"magic_cookie_glitch\", \"padding_baud_rate\", \"virtual_terminal\",\n     \"width_status_line\", \"num_labels\", \"label_height\", \"label_width\", \"max_attributes\",\n     \"maximum_windows\", \"max_colors\", \"max_pairs\", \"no_color_video\", \"buffer_capacity\",\n@@ -43,13 +43,13 @@ pub static numfnames: &[&str] = &[ \"columns\", \"init_tabs\", \"lines\",\n     \"new_line_delay\", \"backspace_delay\", \"horizontal_tab_delay\", \"number_of_function_keys\"];\n \n #[rustfmt::skip]\n-pub static numnames: &[&str] = &[ \"cols\", \"it\", \"lines\", \"lm\", \"xmc\", \"pb\",\n+pub(crate) static numnames: &[&str] = &[ \"cols\", \"it\", \"lines\", \"lm\", \"xmc\", \"pb\",\n     \"vt\", \"wsl\", \"nlab\", \"lh\", \"lw\", \"ma\", \"wnum\", \"colors\", \"pairs\", \"ncv\", \"bufsz\", \"spinv\",\n     \"spinh\", \"maddr\", \"mjump\", \"mcs\", \"mls\", \"npins\", \"orc\", \"orl\", \"orhi\", \"orvi\", \"cps\", \"widcs\",\n     \"btns\", \"bitwin\", \"bitype\", \"UTug\", \"OTdC\", \"OTdN\", \"OTdB\", \"OTdT\", \"OTkn\"];\n \n #[rustfmt::skip]\n-pub static stringfnames: &[&str] = &[ \"back_tab\", \"bell\", \"carriage_return\",\n+pub(crate) static stringfnames: &[&str] = &[ \"back_tab\", \"bell\", \"carriage_return\",\n     \"change_scroll_region\", \"clear_all_tabs\", \"clear_screen\", \"clr_eol\", \"clr_eos\",\n     \"column_address\", \"command_character\", \"cursor_address\", \"cursor_down\", \"cursor_home\",\n     \"cursor_invisible\", \"cursor_left\", \"cursor_mem_address\", \"cursor_normal\", \"cursor_right\",\n@@ -123,7 +123,7 @@ pub static stringfnames: &[&str] = &[ \"back_tab\", \"bell\", \"carriage_return\",\n     \"acs_plus\", \"memory_lock\", \"memory_unlock\", \"box_chars_1\"];\n \n #[rustfmt::skip]\n-pub static stringnames: &[&str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tbc\", \"clear\",\n+pub(crate) static stringnames: &[&str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tbc\", \"clear\",\n     \"_\", \"_\", \"hpa\", \"cmdch\", \"cup\", \"cud1\", \"home\", \"civis\", \"cub1\", \"mrcup\", \"cnorm\", \"cuf1\",\n     \"ll\", \"cuu1\", \"cvvis\", \"dch1\", \"dl1\", \"dsl\", \"hd\", \"smacs\", \"blink\", \"bold\", \"smcup\", \"smdc\",\n     \"dim\", \"smir\", \"invis\", \"prot\", \"rev\", \"smso\", \"smul\", \"ech\", \"rmacs\", \"sgr0\", \"rmcup\", \"rmdc\",\n@@ -178,7 +178,7 @@ fn read_byte(r: &mut dyn io::Read) -> io::Result<u8> {\n \n /// Parse a compiled terminfo entry, using long capability names if `longnames`\n /// is true\n-pub fn parse(file: &mut dyn io::Read, longnames: bool) -> Result<TermInfo, String> {\n+pub(crate) fn parse(file: &mut dyn io::Read, longnames: bool) -> Result<TermInfo, String> {\n     macro_rules! t( ($e:expr) => (\n         match $e {\n             Ok(e) => e,\n@@ -317,7 +317,7 @@ pub fn parse(file: &mut dyn io::Read, longnames: bool) -> Result<TermInfo, Strin\n }\n \n /// Creates a dummy TermInfo struct for msys terminals\n-pub fn msys_terminfo() -> TermInfo {\n+pub(crate) fn msys_terminfo() -> TermInfo {\n     let mut strings = HashMap::new();\n     strings.insert(\"sgr0\".to_string(), b\"\\x1B[0m\".to_vec());\n     strings.insert(\"bold\".to_string(), b\"\\x1B[1m\".to_vec());", "previous_filename": "library/term/src/terminfo/parser/compiled.rs"}, {"sha": "8a9187b0495cc9a6e314cc01fd3b3cee21b9aed6", "filename": "library/test/src/term/terminfo/parser/compiled/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparser%2Fcompiled%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparser%2Fcompiled%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fparser%2Fcompiled%2Ftests.rs?ref=39d8d3ab6a880179ef12b5d11414d940711ed422", "previous_filename": "library/term/src/terminfo/parser/compiled/tests.rs"}, {"sha": "68e181a6895799ef1bcbb5fe224f1354a4e74dea", "filename": "library/test/src/term/terminfo/searcher.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs?ref=39d8d3ab6a880179ef12b5d11414d940711ed422", "patch": "@@ -11,7 +11,7 @@ mod tests;\n \n /// Return path to database entry for `term`\n #[allow(deprecated)]\n-pub fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n+pub(crate) fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n     let mut dirs_to_search = Vec::new();\n     let first_char = term.chars().next()?;\n ", "previous_filename": "library/term/src/terminfo/searcher.rs"}, {"sha": "4227a585e2f59e22e7f1dd129110f3115539f90d", "filename": "library/test/src/term/terminfo/searcher/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher%2Ftests.rs?ref=39d8d3ab6a880179ef12b5d11414d940711ed422", "previous_filename": "library/term/src/terminfo/searcher/tests.rs"}, {"sha": "4bdbd6ee75f527139d1f8d90e46a6a369463871e", "filename": "library/test/src/term/win.rs", "status": "renamed", "additions": 4, "deletions": 54, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39d8d3ab6a880179ef12b5d11414d940711ed422/library%2Ftest%2Fsrc%2Fterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fwin.rs?ref=39d8d3ab6a880179ef12b5d11414d940711ed422", "patch": "@@ -5,12 +5,11 @@\n use std::io;\n use std::io::prelude::*;\n \n-use crate::color;\n-use crate::Attr;\n-use crate::Terminal;\n+use super::color;\n+use super::Terminal;\n \n /// A Terminal implementation that uses the Win32 Console API.\n-pub struct WinConsole<T> {\n+pub(crate) struct WinConsole<T> {\n     buf: T,\n     def_foreground: color::Color,\n     def_background: color::Color,\n@@ -115,7 +114,7 @@ impl<T: Write + Send + 'static> WinConsole<T> {\n     }\n \n     /// Returns `None` whenever the terminal cannot be created for some reason.\n-    pub fn new(out: T) -> io::Result<WinConsole<T>> {\n+    pub(crate) fn new(out: T) -> io::Result<WinConsole<T>> {\n         use std::mem::MaybeUninit;\n \n         let fg;\n@@ -154,67 +153,18 @@ impl<T: Write> Write for WinConsole<T> {\n }\n \n impl<T: Write + Send + 'static> Terminal for WinConsole<T> {\n-    type Output = T;\n-\n     fn fg(&mut self, color: color::Color) -> io::Result<bool> {\n         self.foreground = color;\n         self.apply();\n \n         Ok(true)\n     }\n \n-    fn bg(&mut self, color: color::Color) -> io::Result<bool> {\n-        self.background = color;\n-        self.apply();\n-\n-        Ok(true)\n-    }\n-\n-    fn attr(&mut self, attr: Attr) -> io::Result<bool> {\n-        match attr {\n-            Attr::ForegroundColor(f) => {\n-                self.foreground = f;\n-                self.apply();\n-                Ok(true)\n-            }\n-            Attr::BackgroundColor(b) => {\n-                self.background = b;\n-                self.apply();\n-                Ok(true)\n-            }\n-            _ => Ok(false),\n-        }\n-    }\n-\n-    fn supports_attr(&self, attr: Attr) -> bool {\n-        // it claims support for underscore and reverse video, but I can't get\n-        // it to do anything -cmr\n-        match attr {\n-            Attr::ForegroundColor(_) | Attr::BackgroundColor(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n     fn reset(&mut self) -> io::Result<bool> {\n         self.foreground = self.def_foreground;\n         self.background = self.def_background;\n         self.apply();\n \n         Ok(true)\n     }\n-\n-    fn get_ref(&self) -> &T {\n-        &self.buf\n-    }\n-\n-    fn get_mut(&mut self) -> &mut T {\n-        &mut self.buf\n-    }\n-\n-    fn into_inner(self) -> T\n-    where\n-        Self: Sized,\n-    {\n-        self.buf\n-    }\n }", "previous_filename": "library/term/src/win.rs"}]}