{"sha": "3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiMTNiOWMyYjRlNzJkMDhjYjFjNjgwMjRjY2M0ZjUwMDAxZjQ4Nzg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-24T22:27:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-24T22:27:14Z"}, "message": "rollup merge of #23638: pnkfelix/fsk-reject-specialized-drops\n\nReject specialized Drop impls.\n\nSee Issue #8142 for discussion.\n\nThis makes it illegal for a Drop impl to be more specialized than the original item.\n\nSo for example, all of the following are now rejected (when they would have been blindly accepted before):\n\n```rust\nstruct S<A> { ... };\nimpl Drop for S<i8> { ... } // error: specialized to concrete type\n\nstruct T<'a> { ... };\nimpl Drop for T<'static> { ... } // error: specialized to concrete region\n\nstruct U<A> { ... };\nimpl<A:Clone> Drop for U<A> { ... } // error: added extra type requirement\n\nstruct V<'a,'b>;\nimpl<'a,'b:a> Drop for V<'a,'b> { ... } // error: added extra region requirement\n```\n\nDue to examples like the above, this is a [breaking-change].\n\n(The fix is to either remove the specialization from the `Drop` impl, or to transcribe the requirements into the struct/enum definition; examples of both are shown in the PR's fixed to `libstd`.)\n\n----\n\nThis is likely to be the last thing blocking the removal of the `#[unsafe_destructor]` attribute.\n\nFix #8142\nFix #23584", "tree": {"sha": "d4efd6426beeeee1f0c543cfe345b9625285f46e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4efd6426beeeee1f0c543cfe345b9625285f46e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "html_url": "https://github.com/rust-lang/rust/commit/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91b633aa038008fdbee658a10182afdd794d2aa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/91b633aa038008fdbee658a10182afdd794d2aa6", "html_url": "https://github.com/rust-lang/rust/commit/91b633aa038008fdbee658a10182afdd794d2aa6"}, {"sha": "1955e052675d4457432da85a00db0ae55be64e83", "url": "https://api.github.com/repos/rust-lang/rust/commits/1955e052675d4457432da85a00db0ae55be64e83", "html_url": "https://github.com/rust-lang/rust/commit/1955e052675d4457432da85a00db0ae55be64e83"}], "stats": {"total": 528, "additions": 465, "deletions": 63}, "files": [{"sha": "dbf0cae6f4ba84b852e771e978b94ae84bbb99c5", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -197,15 +197,16 @@ use std::ptr;\n \n // Define a wrapper around the handle returned by the foreign code.\n // Unique<T> has the same semantics as Box<T>\n-pub struct Unique<T> {\n+//\n+// NB: For simplicity and correctness, we require that T has kind Send\n+// (owned boxes relax this restriction).\n+pub struct Unique<T: Send> {\n     // It contains a single raw, mutable pointer to the object in question.\n     ptr: *mut T\n }\n \n // Implement methods for creating and using the values in the box.\n \n-// NB: For simplicity and correctness, we require that T has kind Send\n-// (owned boxes relax this restriction).\n impl<T: Send> Unique<T> {\n     pub fn new(value: T) -> Unique<T> {\n         unsafe {\n@@ -239,11 +240,11 @@ impl<T: Send> Unique<T> {\n // Unique<T>, making the struct manage the raw pointer: when the\n // struct goes out of scope, it will automatically free the raw pointer.\n //\n-// NB: This is an unsafe destructor, because rustc will not normally\n-// allow destructors to be associated with parameterized types, due to\n-// bad interaction with managed boxes. (With the Send restriction,\n-// we don't have this problem.) Note that the `#[unsafe_destructor]`\n-// feature gate is required to use unsafe destructors.\n+// NB: This is an unsafe destructor; rustc will not normally allow\n+// destructors to be associated with parameterized types (due to\n+// historically failing to check them soundly).  Note that the\n+// `#[unsafe_destructor]` feature gate is currently required to use\n+// unsafe destructors.\n #[unsafe_destructor]\n impl<T: Send> Drop for Unique<T> {\n     fn drop(&mut self) {"}, {"sha": "b5d16d29272850843e9204749c68e6be9165d56d", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -321,7 +321,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Sync + Send> Drop for Arc<T> {\n+impl<T> Drop for Arc<T> {\n     /// Drops the `Arc<T>`.\n     ///\n     /// This will decrement the strong reference count. If the strong reference\n@@ -388,7 +388,7 @@ impl<T: Sync + Send> Drop for Arc<T> {\n \n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n-impl<T: Sync + Send> Weak<T> {\n+impl<T> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n     ///\n     /// Upgrades the `Weak<T>` reference to an `Arc<T>`, if possible.\n@@ -454,7 +454,7 @@ impl<T: Sync + Send> Clone for Weak<T> {\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Sync + Send> Drop for Weak<T> {\n+impl<T> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n     ///\n     /// This will decrement the weak reference count."}, {"sha": "16b387330b9efea402867d39e78c64e76cbeefeb", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -14,6 +14,7 @@\n use super::{CombinedSnapshot, cres, InferCtxt, HigherRankedType, SkolemizationMap};\n use super::combine::{Combine, Combineable};\n \n+use middle::subst;\n use middle::ty::{self, Binder};\n use middle::ty_fold::{self, TypeFoldable};\n use syntax::codemap::Span;\n@@ -455,6 +456,63 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n     }\n }\n \n+/// Constructs and returns a substitution that, for a given type\n+/// scheme parameterized by `generics`, will replace every generic\n+/// parmeter in the type with a skolemized type/region (which one can\n+/// think of as a \"fresh constant\", except at the type/region level of\n+/// reasoning).\n+///\n+/// Since we currently represent bound/free type parameters in the\n+/// same way, this only has an effect on regions.\n+///\n+/// (Note that unlike a substitution from `ty::construct_free_substs`,\n+/// this inserts skolemized regions rather than free regions; this\n+/// allows one to use `fn leak_check` to catch attmepts to unify the\n+/// skolemized regions with e.g. the `'static` lifetime)\n+pub fn construct_skolemized_substs<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                            generics: &ty::Generics<'tcx>,\n+                                            snapshot: &CombinedSnapshot)\n+                                            -> (subst::Substs<'tcx>, SkolemizationMap)\n+{\n+    let mut map = FnvHashMap();\n+\n+    // map T => T\n+    let mut types = subst::VecPerParamSpace::empty();\n+    push_types_from_defs(infcx.tcx, &mut types, generics.types.as_slice());\n+\n+    // map early- or late-bound 'a => fresh 'a\n+    let mut regions = subst::VecPerParamSpace::empty();\n+    push_region_params(infcx, &mut map, &mut regions, generics.regions.as_slice(), snapshot);\n+\n+    let substs = subst::Substs { types: types,\n+                                 regions: subst::NonerasedRegions(regions) };\n+    return (substs, map);\n+\n+    fn push_region_params<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                   map: &mut SkolemizationMap,\n+                                   regions: &mut subst::VecPerParamSpace<ty::Region>,\n+                                   region_params: &[ty::RegionParameterDef],\n+                                   snapshot: &CombinedSnapshot)\n+    {\n+        for r in region_params {\n+            let br = r.to_bound_region();\n+            let skol_var = infcx.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot);\n+            let sanity_check = map.insert(br, skol_var);\n+            assert!(sanity_check.is_none());\n+            regions.push(r.space, skol_var);\n+        }\n+    }\n+\n+    fn push_types_from_defs<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                  types: &mut subst::VecPerParamSpace<ty::Ty<'tcx>>,\n+                                  defs: &[ty::TypeParameterDef<'tcx>]) {\n+        for def in defs {\n+            let ty = ty::mk_param_from_def(tcx, def);\n+            types.push(def.space, ty);\n+        }\n+    }\n+}\n+\n pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                binder: &ty::Binder<T>,\n                                                snapshot: &CombinedSnapshot)"}, {"sha": "a38adabee915b318b0abe2fcc50fb341743ef0d8", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -726,6 +726,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n+    pub fn construct_skolemized_subst(&self,\n+                                      generics: &ty::Generics<'tcx>,\n+                                      snapshot: &CombinedSnapshot)\n+                                      -> (subst::Substs<'tcx>, SkolemizationMap) {\n+        /*! See `higher_ranked::construct_skolemized_subst` */\n+\n+        higher_ranked::construct_skolemized_substs(self, generics, snapshot)\n+    }\n+\n     pub fn skolemize_late_bound_regions<T>(&self,\n                                            value: &ty::Binder<T>,\n                                            snapshot: &CombinedSnapshot)"}, {"sha": "92b444e85d8c3f5fa713bfc632c1272b50acf01f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -1793,6 +1793,9 @@ impl RegionParameterDef {\n     pub fn to_early_bound_region(&self) -> ty::Region {\n         ty::ReEarlyBound(self.def_id.node, self.space, self.index, self.name)\n     }\n+    pub fn to_bound_region(&self) -> ty::BoundRegion {\n+        ty::BoundRegion::BrNamed(self.def_id, self.name)\n+    }\n }\n \n /// Information about the formal type/lifetime parameters associated"}, {"sha": "c48033cab897f612c1a371d365340655c634dcda", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 238, "deletions": 2, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -12,13 +12,249 @@ use check::regionck::{self, Rcx};\n \n use middle::infer;\n use middle::region;\n-use middle::subst;\n+use middle::subst::{self, Subst};\n use middle::ty::{self, Ty};\n use util::ppaux::{Repr, UserString};\n \n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax::codemap::{self, Span};\n+\n+/// check_drop_impl confirms that the Drop implementation identfied by\n+/// `drop_impl_did` is not any more specialized than the type it is\n+/// attached to (Issue #8142).\n+///\n+/// This means:\n+///\n+/// 1. The self type must be nominal (this is already checked during\n+///    coherence),\n+///\n+/// 2. The generic region/type parameters of the impl's self-type must\n+///    all be parameters of the Drop impl itself (i.e. no\n+///    specialization like `impl Drop for Foo<i32>`), and,\n+///\n+/// 3. Any bounds on the generic parameters must be reflected in the\n+///    struct/enum definition for the nominal type itself (i.e.\n+///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n+///\n+pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(), ()> {\n+    let ty::TypeScheme { generics: ref dtor_generics,\n+                         ty: ref dtor_self_type } = ty::lookup_item_type(tcx, drop_impl_did);\n+    let dtor_predicates = ty::lookup_predicates(tcx, drop_impl_did);\n+    match dtor_self_type.sty {\n+        ty::ty_enum(self_type_did, self_to_impl_substs) |\n+        ty::ty_struct(self_type_did, self_to_impl_substs) |\n+        ty::ty_closure(self_type_did, self_to_impl_substs) => {\n+            try!(ensure_drop_params_and_item_params_correspond(tcx,\n+                                                               drop_impl_did,\n+                                                               dtor_generics,\n+                                                               dtor_self_type,\n+                                                               self_type_did));\n+\n+            ensure_drop_predicates_are_implied_by_item_defn(tcx,\n+                                                            drop_impl_did,\n+                                                            &dtor_predicates,\n+                                                            self_type_did,\n+                                                            self_to_impl_substs)\n+        }\n+        _ => {\n+            // Destructors only work on nominal types.  This was\n+            // already checked by coherence, so we can panic here.\n+            let span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n+            tcx.sess.span_bug(\n+                span, &format!(\"should have been rejected by coherence check: {}\",\n+                               dtor_self_type.repr(tcx)));\n+        }\n+    }\n+}\n+\n+fn ensure_drop_params_and_item_params_correspond<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    drop_impl_did: ast::DefId,\n+    drop_impl_generics: &ty::Generics<'tcx>,\n+    drop_impl_ty: &ty::Ty<'tcx>,\n+    self_type_did: ast::DefId) -> Result<(), ()>\n+{\n+    // New strategy based on review suggestion from nikomatsakis.\n+    //\n+    // (In the text and code below, \"named\" denotes \"struct/enum\", and\n+    // \"generic params\" denotes \"type and region params\")\n+    //\n+    // 1. Create fresh skolemized type/region \"constants\" for each of\n+    //    the named type's generic params.  Instantiate the named type\n+    //    with the fresh constants, yielding `named_skolem`.\n+    //\n+    // 2. Create unification variables for each of the Drop impl's\n+    //    generic params.  Instantiate the impl's Self's type with the\n+    //    unification-vars, yielding `drop_unifier`.\n+    //\n+    // 3. Attempt to unify Self_unif with Type_skolem.  If unification\n+    //    succeeds, continue (i.e. with the predicate checks).\n+\n+    let ty::TypeScheme { generics: ref named_type_generics,\n+                         ty: named_type } =\n+        ty::lookup_item_type(tcx, self_type_did);\n+\n+    let infcx = infer::new_infer_ctxt(tcx);\n+    infcx.try(|snapshot| {\n+        let (named_type_to_skolem, skol_map) =\n+            infcx.construct_skolemized_subst(named_type_generics, snapshot);\n+        let named_type_skolem = named_type.subst(tcx, &named_type_to_skolem);\n+\n+        let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n+        let drop_to_unifier =\n+            infcx.fresh_substs_for_generics(drop_impl_span, drop_impl_generics);\n+        let drop_unifier = drop_impl_ty.subst(tcx, &drop_to_unifier);\n+\n+        if let Ok(()) = infer::mk_eqty(&infcx, true, infer::TypeOrigin::Misc(drop_impl_span),\n+                                       named_type_skolem, drop_unifier) {\n+            // Even if we did manage to equate the types, the process\n+            // may have just gathered unsolvable region constraints\n+            // like `R == 'static` (represented as a pair of subregion\n+            // constraints) for some skolemization constant R.\n+            //\n+            // However, the leak_check method allows us to confirm\n+            // that no skolemized regions escaped (i.e. were related\n+            // to other regions in the constraint graph).\n+            if let Ok(()) = infcx.leak_check(&skol_map, snapshot) {\n+                return Ok(())\n+            }\n+        }\n+\n+        span_err!(tcx.sess, drop_impl_span, E0366,\n+                  \"Implementations of Drop cannot be specialized\");\n+        let item_span = tcx.map.span(self_type_did.node);\n+        tcx.sess.span_note(item_span,\n+                           \"Use same sequence of generic type and region \\\n+                            parameters that is on the struct/enum definition\");\n+        return Err(());\n+    })\n+}\n+\n+/// Confirms that every predicate imposed by dtor_predicates is\n+/// implied by assuming the predicates attached to self_type_did.\n+fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    drop_impl_did: ast::DefId,\n+    dtor_predicates: &ty::GenericPredicates<'tcx>,\n+    self_type_did: ast::DefId,\n+    self_to_impl_substs: &subst::Substs<'tcx>) -> Result<(), ()> {\n+\n+    // Here is an example, analogous to that from\n+    // `compare_impl_method`.\n+    //\n+    // Consider a struct type:\n+    //\n+    //     struct Type<'c, 'b:'c, 'a> {\n+    //         x: &'a Contents            // (contents are irrelevant;\n+    //         y: &'c Cell<&'b Contents>, //  only the bounds matter for our purposes.)\n+    //     }\n+    //\n+    // and a Drop impl:\n+    //\n+    //     impl<'z, 'y:'z, 'x:'y> Drop for P<'z, 'y, 'x> {\n+    //         fn drop(&mut self) { self.y.set(self.x); } // (only legal if 'x: 'y)\n+    //     }\n+    //\n+    // We start out with self_to_impl_substs, that maps the generic\n+    // parameters of Type to that of the Drop impl.\n+    //\n+    //     self_to_impl_substs = {'c => 'z, 'b => 'y, 'a => 'x}\n+    //\n+    // Applying this to the predicates (i.e. assumptions) provided by the item\n+    // definition yields the instantiated assumptions:\n+    //\n+    //     ['y : 'z]\n+    //\n+    // We then check all of the predicates of the Drop impl:\n+    //\n+    //     ['y:'z, 'x:'y]\n+    //\n+    // and ensure each is in the list of instantiated\n+    // assumptions. Here, `'y:'z` is present, but `'x:'y` is\n+    // absent. So we report an error that the Drop impl injected a\n+    // predicate that is not present on the struct definition.\n+\n+    assert_eq!(self_type_did.krate, ast::LOCAL_CRATE);\n+\n+    let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n+\n+    // We can assume the predicates attached to struct/enum definition\n+    // hold.\n+    let generic_assumptions = ty::lookup_predicates(tcx, self_type_did);\n+\n+    let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n+    assert!(assumptions_in_impl_context.predicates.is_empty_in(subst::SelfSpace));\n+    assert!(assumptions_in_impl_context.predicates.is_empty_in(subst::FnSpace));\n+    let assumptions_in_impl_context =\n+        assumptions_in_impl_context.predicates.get_slice(subst::TypeSpace);\n+\n+    // An earlier version of this code attempted to do this checking\n+    // via the traits::fulfill machinery. However, it ran into trouble\n+    // since the fulfill machinery merely turns outlives-predicates\n+    // 'a:'b and T:'b into region inference constraints. It is simpler\n+    // just to look for all the predicates directly.\n+\n+    assert!(dtor_predicates.predicates.is_empty_in(subst::SelfSpace));\n+    assert!(dtor_predicates.predicates.is_empty_in(subst::FnSpace));\n+    let predicates = dtor_predicates.predicates.get_slice(subst::TypeSpace);\n+    for predicate in predicates {\n+        // (We do not need to worry about deep analysis of type\n+        // expressions etc because the Drop impls are already forced\n+        // to take on a structure that is roughly a alpha-renaming of\n+        // the generic parameters of the item definition.)\n+\n+        // This path now just checks *all* predicates via the direct\n+        // lookup, rather than using fulfill machinery.\n+        //\n+        // However, it may be more efficient in the future to batch\n+        // the analysis together via the fulfill , rather than the\n+        // repeated `contains` calls.\n+\n+        if !assumptions_in_impl_context.contains(&predicate) {\n+            let item_span = tcx.map.span(self_type_did.node);\n+            let req = predicate.user_string(tcx);\n+            span_err!(tcx.sess, drop_impl_span, E0367,\n+                      \"The requirement `{}` is added only by the Drop impl.\", req);\n+            tcx.sess.span_note(item_span,\n+                               \"The same requirement must be part of \\\n+                                the struct/enum definition\");\n+        }\n+    }\n+\n+    if tcx.sess.has_errors() {\n+        return Err(());\n+    }\n+    Ok(())\n+}\n \n+/// check_safety_of_destructor_if_necessary confirms that the type\n+/// expression `typ` conforms to the \"Drop Check Rule\" from the Sound\n+/// Generic Drop (RFC 769).\n+///\n+/// ----\n+///\n+/// The Drop Check Rule is the following:\n+///\n+/// Let `v` be some value (either temporary or named) and 'a be some\n+/// lifetime (scope). If the type of `v` owns data of type `D`, where\n+///\n+///   (1.) `D` has a lifetime- or type-parametric Drop implementation, and\n+///   (2.) the structure of `D` can reach a reference of type `&'a _`, and\n+///   (3.) either:\n+///\n+///     (A.) the Drop impl for `D` instantiates `D` at 'a directly,\n+///          i.e. `D<'a>`, or,\n+///\n+///     (B.) the Drop impl for `D` has some type parameter with a\n+///          trait bound `T` where `T` is a trait that has at least\n+///          one method,\n+///\n+/// then 'a must strictly outlive the scope of v.\n+///\n+/// ----\n+///\n+/// This function is meant to by applied to the type for every\n+/// expression in the program.\n pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                                      typ: ty::Ty<'tcx>,\n                                                      span: Span,"}, {"sha": "1e38a7d2d9f944222403095c82f24ddf733b20d1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -490,6 +490,20 @@ pub fn check_item_types(ccx: &CrateCtxt) {\n     visit::walk_crate(&mut visit, krate);\n \n     ccx.tcx.sess.abort_if_errors();\n+\n+    for drop_method_did in ccx.tcx.destructors.borrow().iter() {\n+        if drop_method_did.krate == ast::LOCAL_CRATE {\n+            let drop_impl_did = ccx.tcx.map.get_parent_did(drop_method_did.node);\n+            match dropck::check_drop_impl(ccx.tcx, drop_impl_did) {\n+                Ok(()) => {}\n+                Err(()) => {\n+                    assert!(ccx.tcx.sess.has_errors());\n+                }\n+            }\n+        }\n+    }\n+\n+    ccx.tcx.sess.abort_if_errors();\n }\n \n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,"}, {"sha": "95e06879fb2235a066c2aa83104fe7ec9ca643b0", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -177,7 +177,9 @@ register_diagnostics! {\n     E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck\n     E0321, // extended coherence rules for defaulted traits violated\n-    E0322  // cannot implement Sized explicitly\n+    E0322, // cannot implement Sized explicitly\n+    E0366, // dropck forbid specialization to concrete type or region\n+    E0367  // dropck forbid specialization to predicate not in struct/enum\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "2a1294f23b20e9a33384abf6d83f14b5ab548a12", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -120,7 +120,7 @@ impl<R> fmt::Debug for BufReader<R> where R: fmt::Debug {\n ///\n /// The buffer will be written out when the writer is dropped.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct BufWriter<W> {\n+pub struct BufWriter<W: Write> {\n     inner: Option<W>,\n     buf: Vec<u8>,\n }\n@@ -220,7 +220,7 @@ impl<W: Write> Write for BufWriter<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W> fmt::Debug for BufWriter<W> where W: fmt::Debug {\n+impl<W: Write> fmt::Debug for BufWriter<W> where W: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"BufWriter {{ writer: {:?}, buffer: {}/{} }}\",\n                self.inner.as_ref().unwrap(), self.buf.len(), self.buf.capacity())\n@@ -276,7 +276,7 @@ impl<W> fmt::Display for IntoInnerError<W> {\n ///\n /// The buffer will be written out when the writer is dropped.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct LineWriter<W> {\n+pub struct LineWriter<W: Write> {\n     inner: BufWriter<W>,\n }\n \n@@ -335,24 +335,24 @@ impl<W: Write> Write for LineWriter<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W> fmt::Debug for LineWriter<W> where W: fmt::Debug {\n+impl<W: Write> fmt::Debug for LineWriter<W> where W: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"LineWriter {{ writer: {:?}, buffer: {}/{} }}\",\n                self.inner.inner, self.inner.buf.len(),\n                self.inner.buf.capacity())\n     }\n }\n \n-struct InternalBufWriter<W>(BufWriter<W>);\n+struct InternalBufWriter<W: Write>(BufWriter<W>);\n \n-impl<W> InternalBufWriter<W> {\n+impl<W: Read + Write> InternalBufWriter<W> {\n     fn get_mut(&mut self) -> &mut BufWriter<W> {\n         let InternalBufWriter(ref mut w) = *self;\n         return w;\n     }\n }\n \n-impl<W: Read> Read for InternalBufWriter<W> {\n+impl<W: Read + Write> Read for InternalBufWriter<W> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.get_mut().inner.as_mut().unwrap().read(buf)\n     }\n@@ -367,7 +367,7 @@ impl<W: Read> Read for InternalBufWriter<W> {\n ///\n /// The output buffer will be written out when this stream is dropped.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct BufStream<S> {\n+pub struct BufStream<S: Write> {\n     inner: BufReader<InternalBufWriter<S>>\n }\n \n@@ -448,7 +448,7 @@ impl<S: Read + Write> Write for BufStream<S> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<S> fmt::Debug for BufStream<S> where S: fmt::Debug {\n+impl<S: Write> fmt::Debug for BufStream<S> where S: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let reader = &self.inner;\n         let writer = &self.inner.inner.0;"}, {"sha": "9a9d421dfe1f02700d12a855837c7d1370e19699", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -148,14 +148,14 @@ impl<R: Reader> Reader for BufferedReader<R> {\n /// writer.write_str(\"hello, world\").unwrap();\n /// writer.flush().unwrap();\n /// ```\n-pub struct BufferedWriter<W> {\n+pub struct BufferedWriter<W: Writer> {\n     inner: Option<W>,\n     buf: Vec<u8>,\n     pos: uint\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W> fmt::Debug for BufferedWriter<W> where W: fmt::Debug {\n+impl<W: Writer> fmt::Debug for BufferedWriter<W> where W: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"BufferedWriter {{ writer: {:?}, buffer: {}/{} }}\",\n                self.inner.as_ref().unwrap(), self.pos, self.buf.len())\n@@ -250,12 +250,12 @@ impl<W: Writer> Drop for BufferedWriter<W> {\n /// `'\\n'`) is detected.\n ///\n /// This writer will be flushed when it is dropped.\n-pub struct LineBufferedWriter<W> {\n+pub struct LineBufferedWriter<W: Writer> {\n     inner: BufferedWriter<W>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W> fmt::Debug for LineBufferedWriter<W> where W: fmt::Debug {\n+impl<W: Writer> fmt::Debug for LineBufferedWriter<W> where W: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"LineBufferedWriter {{ writer: {:?}, buffer: {}/{} }}\",\n                self.inner.inner, self.inner.pos, self.inner.buf.len())\n@@ -299,16 +299,16 @@ impl<W: Writer> Writer for LineBufferedWriter<W> {\n     fn flush(&mut self) -> IoResult<()> { self.inner.flush() }\n }\n \n-struct InternalBufferedWriter<W>(BufferedWriter<W>);\n+struct InternalBufferedWriter<W: Writer>(BufferedWriter<W>);\n \n-impl<W> InternalBufferedWriter<W> {\n+impl<W: Writer> InternalBufferedWriter<W> {\n     fn get_mut<'a>(&'a mut self) -> &'a mut BufferedWriter<W> {\n         let InternalBufferedWriter(ref mut w) = *self;\n         return w;\n     }\n }\n \n-impl<W: Reader> Reader for InternalBufferedWriter<W> {\n+impl<W: Reader + Writer> Reader for InternalBufferedWriter<W> {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         self.get_mut().inner.as_mut().unwrap().read(buf)\n     }\n@@ -343,12 +343,12 @@ impl<W: Reader> Reader for InternalBufferedWriter<W> {\n ///     Err(e) => println!(\"error reading: {}\", e)\n /// }\n /// ```\n-pub struct BufferedStream<S> {\n+pub struct BufferedStream<S: Writer> {\n     inner: BufferedReader<InternalBufferedWriter<S>>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<S> fmt::Debug for BufferedStream<S> where S: fmt::Debug {\n+impl<S: Writer> fmt::Debug for BufferedStream<S> where S: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let reader = &self.inner;\n         let writer = &self.inner.inner.0;"}, {"sha": "eb421fe55a4d093ad80337808a5b61333232bd11", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -342,7 +342,7 @@ mod spsc_queue;\n /// The receiving-half of Rust's channel type. This half can only be owned by\n /// one task\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Receiver<T> {\n+pub struct Receiver<T:Send> {\n     inner: UnsafeCell<Flavor<T>>,\n }\n \n@@ -354,14 +354,14 @@ unsafe impl<T: Send> Send for Receiver<T> { }\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Iter<'a, T:'a> {\n+pub struct Iter<'a, T:Send+'a> {\n     rx: &'a Receiver<T>\n }\n \n /// The sending-half of Rust's asynchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Sender<T> {\n+pub struct Sender<T:Send> {\n     inner: UnsafeCell<Flavor<T>>,\n }\n \n@@ -372,7 +372,7 @@ unsafe impl<T: Send> Send for Sender<T> { }\n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SyncSender<T> {\n+pub struct SyncSender<T: Send> {\n     inner: Arc<UnsafeCell<sync::Packet<T>>>,\n }\n \n@@ -433,15 +433,15 @@ pub enum TrySendError<T> {\n     Disconnected(T),\n }\n \n-enum Flavor<T> {\n+enum Flavor<T:Send> {\n     Oneshot(Arc<UnsafeCell<oneshot::Packet<T>>>),\n     Stream(Arc<UnsafeCell<stream::Packet<T>>>),\n     Shared(Arc<UnsafeCell<shared::Packet<T>>>),\n     Sync(Arc<UnsafeCell<sync::Packet<T>>>),\n }\n \n #[doc(hidden)]\n-trait UnsafeFlavor<T> {\n+trait UnsafeFlavor<T:Send> {\n     fn inner_unsafe<'a>(&'a self) -> &'a UnsafeCell<Flavor<T>>;\n     unsafe fn inner_mut<'a>(&'a self) -> &'a mut Flavor<T> {\n         &mut *self.inner_unsafe().get()\n@@ -450,12 +450,12 @@ trait UnsafeFlavor<T> {\n         &*self.inner_unsafe().get()\n     }\n }\n-impl<T> UnsafeFlavor<T> for Sender<T> {\n+impl<T:Send> UnsafeFlavor<T> for Sender<T> {\n     fn inner_unsafe<'a>(&'a self) -> &'a UnsafeCell<Flavor<T>> {\n         &self.inner\n     }\n }\n-impl<T> UnsafeFlavor<T> for Receiver<T> {\n+impl<T:Send> UnsafeFlavor<T> for Receiver<T> {\n     fn inner_unsafe<'a>(&'a self) -> &'a UnsafeCell<Flavor<T>> {\n         &self.inner\n     }"}, {"sha": "1be8b0dd8628a217e57fdcaaaeb48c0c65cdc9e9", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -72,7 +72,7 @@ struct Node<T> {\n /// The multi-producer single-consumer structure. This is not cloneable, but it\n /// may be safely shared so long as it is guaranteed that there is only one\n /// popper at a time (many pushers are allowed).\n-pub struct Queue<T> {\n+pub struct Queue<T: Send> {\n     head: AtomicPtr<Node<T>>,\n     tail: UnsafeCell<*mut Node<T>>,\n }"}, {"sha": "13578ce0517911393e106c941ea30e73ce6845a8", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -54,7 +54,7 @@ const DISCONNECTED: usize = 2;   // channel is disconnected OR upgraded\n // moves *from* a pointer, ownership of the token is transferred to\n // whoever changed the state.\n \n-pub struct Packet<T> {\n+pub struct Packet<T:Send> {\n     // Internal state of the chan/port pair (stores the blocked task as well)\n     state: AtomicUsize,\n     // One-shot data slot location\n@@ -64,7 +64,7 @@ pub struct Packet<T> {\n     upgrade: MyUpgrade<T>,\n }\n \n-pub enum Failure<T> {\n+pub enum Failure<T:Send> {\n     Empty,\n     Disconnected,\n     Upgraded(Receiver<T>),\n@@ -76,13 +76,13 @@ pub enum UpgradeResult {\n     UpWoke(SignalToken),\n }\n \n-pub enum SelectionResult<T> {\n+pub enum SelectionResult<T:Send> {\n     SelCanceled,\n     SelUpgraded(SignalToken, Receiver<T>),\n     SelSuccess,\n }\n \n-enum MyUpgrade<T> {\n+enum MyUpgrade<T:Send> {\n     NothingSent,\n     SendUsed,\n     GoUp(Receiver<T>),"}, {"sha": "b509b3472ee413276ecf52c78c64da05e97f4e2b", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -80,7 +80,7 @@ impl !marker::Send for Select {}\n /// A handle to a receiver which is currently a member of a `Select` set of\n /// receivers.  This handle is used to keep the receiver in the set as well as\n /// interact with the underlying receiver.\n-pub struct Handle<'rx, T:'rx> {\n+pub struct Handle<'rx, T:Send+'rx> {\n     /// The ID of this handle, used to compare against the return value of\n     /// `Select::wait()`\n     id: usize,"}, {"sha": "f3930a8a5d632756f52f93d61a1e7b91a47a1939", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -40,7 +40,7 @@ const MAX_STEALS: isize = 5;\n #[cfg(not(test))]\n const MAX_STEALS: isize = 1 << 20;\n \n-pub struct Packet<T> {\n+pub struct Packet<T: Send> {\n     queue: mpsc::Queue<T>,\n     cnt: AtomicIsize, // How many items are on this channel\n     steals: isize, // How many times has a port received without blocking?"}, {"sha": "cd6d1ee05c788bb453b6ceba4f5112c03f9aef42", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -57,7 +57,7 @@ struct Node<T> {\n /// but it can be safely shared in an Arc if it is guaranteed that there\n /// is only one popper and one pusher touching the queue at any one point in\n /// time.\n-pub struct Queue<T> {\n+pub struct Queue<T: Send> {\n     // consumer fields\n     tail: UnsafeCell<*mut Node<T>>, // where to pop from\n     tail_prev: AtomicPtr<Node<T>>, // where to pop from"}, {"sha": "a5a73314a6db3d36e29cd08540744954ee986c1e", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -39,7 +39,7 @@ const MAX_STEALS: isize = 5;\n #[cfg(not(test))]\n const MAX_STEALS: isize = 1 << 20;\n \n-pub struct Packet<T> {\n+pub struct Packet<T:Send> {\n     queue: spsc::Queue<Message<T>>, // internal queue for all message\n \n     cnt: AtomicIsize, // How many items are on this channel\n@@ -49,7 +49,7 @@ pub struct Packet<T> {\n     port_dropped: AtomicBool, // flag if the channel has been destroyed.\n }\n \n-pub enum Failure<T> {\n+pub enum Failure<T:Send> {\n     Empty,\n     Disconnected,\n     Upgraded(Receiver<T>),\n@@ -61,15 +61,15 @@ pub enum UpgradeResult {\n     UpWoke(SignalToken),\n }\n \n-pub enum SelectionResult<T> {\n+pub enum SelectionResult<T:Send> {\n     SelSuccess,\n     SelCanceled,\n     SelUpgraded(SignalToken, Receiver<T>),\n }\n \n // Any message could contain an \"upgrade request\" to a new shared port, so the\n // internal queue it's a queue of T, but rather Message<T>\n-enum Message<T> {\n+enum Message<T:Send> {\n     Data(T),\n     GoUp(Receiver<T>),\n }"}, {"sha": "71236269487ef8c803ce2fc1af7d01572cb025a9", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -47,7 +47,7 @@ use sync::mpsc::blocking::{self, WaitToken, SignalToken};\n use sync::mpsc::select::StartResult::{self, Installed, Abort};\n use sync::{Mutex, MutexGuard};\n \n-pub struct Packet<T> {\n+pub struct Packet<T: Send> {\n     /// Only field outside of the mutex. Just done for kicks, but mainly because\n     /// the other shared channel already had the code implemented\n     channels: AtomicUsize,"}, {"sha": "b24cfbb6899a9c655d794958259477a7f8217e11", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -112,7 +112,7 @@ use fmt;\n /// *guard += 1;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Mutex<T> {\n+pub struct Mutex<T: Send> {\n     // Note that this static mutex is in a *box*, not inlined into the struct\n     // itself. Once a native mutex has been used once, its address can never\n     // change (it can't be moved). This mutex type can be safely moved at any\n@@ -366,7 +366,7 @@ mod test {\n     use sync::{Arc, Mutex, StaticMutex, MUTEX_INIT, Condvar};\n     use thread;\n \n-    struct Packet<T>(Arc<(Mutex<T>, Condvar)>);\n+    struct Packet<T: Send>(Arc<(Mutex<T>, Condvar)>);\n \n     unsafe impl<T: Send> Send for Packet<T> {}\n     unsafe impl<T> Sync for Packet<T> {}"}, {"sha": "10077dfd1b86517f5bcf64ddb37c5bf6eef73178", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -38,7 +38,7 @@ use thread;\n ///\n /// The fields of this helper are all public, but they should not be used, this\n /// is for static initialization.\n-pub struct Helper<M> {\n+pub struct Helper<M:Send> {\n     /// Internal lock which protects the remaining fields\n     pub lock: StaticMutex,\n     pub cond: StaticCondvar,"}, {"sha": "27b50fc9aaa60ca0312245161eb46c48b8a8f61e", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -698,7 +698,7 @@ impl Drop for JoinHandle {\n /// permission.\n #[must_use = \"thread will be immediately joined if `JoinGuard` is not used\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct JoinGuard<'a, T: 'a> {\n+pub struct JoinGuard<'a, T: Send + 'a> {\n     inner: JoinInner<T>,\n     _marker: PhantomData<&'a T>,\n }"}, {"sha": "832665abdc2d762ab48ac265c3a54e3a674eea43", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -15,7 +15,7 @@\n \n use std::marker;\n \n-struct arc_destruct<T> {\n+struct arc_destruct<T: Sync> {\n     _data: int,\n     _marker: marker::PhantomData<T>\n }"}, {"sha": "30264c9f218a18aed7e7665e46da61df077ab37c", "filename": "src/test/compile-fail/reject-specialized-drops-8142.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Ftest%2Fcompile-fail%2Freject-specialized-drops-8142.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Ftest%2Fcompile-fail%2Freject-specialized-drops-8142.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freject-specialized-drops-8142.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 8142: Test that Drop impls cannot be specialized beyond the\n+// predicates attached to the struct/enum definition itself.\n+\n+#![feature(unsafe_destructor)]\n+\n+trait Bound { fn foo(&self) { } }\n+struct K<'l1,'l2> { x: &'l1 i8, y: &'l2 u8 }\n+struct L<'l1,'l2> { x: &'l1 i8, y: &'l2 u8 }\n+struct M<'m> { x: &'m i8 }\n+struct N<'n> { x: &'n i8 }\n+struct O<To> { x: *const To }\n+struct P<Tp> { x: *const Tp }\n+struct Q<Tq> { x: *const Tq }\n+struct R<Tr> { x: *const Tr }\n+struct S<Ts:Bound> { x: *const Ts }\n+struct T<'t,Ts:'t> { x: &'t Ts }\n+struct U;\n+struct V<Tva, Tvb> { x: *const Tva, y: *const Tvb }\n+struct W<'l1, 'l2> { x: &'l1 i8, y: &'l2 u8 }\n+\n+#[unsafe_destructor]\n+impl<'al,'adds_bnd:'al> Drop for K<'al,'adds_bnd> {                        // REJECT\n+    //~^ ERROR The requirement `'adds_bnd : 'al` is added only by the Drop impl.\n+    fn drop(&mut self) { } }\n+\n+#[unsafe_destructor]\n+impl<'al,'adds_bnd>     Drop for L<'al,'adds_bnd> where 'adds_bnd:'al {    // REJECT\n+    //~^ ERROR The requirement `'adds_bnd : 'al` is added only by the Drop impl.\n+    fn drop(&mut self) { } }\n+\n+#[unsafe_destructor]\n+impl<'ml>               Drop for M<'ml>         { fn drop(&mut self) { } } // ACCEPT\n+\n+#[unsafe_destructor]\n+impl                    Drop for N<'static>     { fn drop(&mut self) { } } // REJECT\n+//~^ ERROR Implementations of Drop cannot be specialized\n+\n+#[unsafe_destructor]\n+impl<Cok_nobound> Drop for O<Cok_nobound> { fn drop(&mut self) { } } // ACCEPT\n+\n+#[unsafe_destructor]\n+impl              Drop for P<i8>          { fn drop(&mut self) { } } // REJECT\n+//~^ ERROR Implementations of Drop cannot be specialized\n+\n+#[unsafe_destructor]\n+impl<Adds_bnd:Bound> Drop for Q<Adds_bnd> { fn drop(&mut self) { } } // REJECT\n+//~^ ERROR The requirement `Adds_bnd : Bound` is added only by the Drop impl.\n+\n+#[unsafe_destructor]\n+impl<'rbnd,Adds_rbnd:'rbnd> Drop for R<Adds_rbnd> { fn drop(&mut self) { } } // REJECT\n+//~^ ERROR The requirement `Adds_rbnd : 'rbnd` is added only by the Drop impl.\n+\n+#[unsafe_destructor]\n+impl<Bs:Bound>    Drop for S<Bs>          { fn drop(&mut self) { } } // ACCEPT\n+\n+#[unsafe_destructor]\n+impl<'t,Bt:'t>    Drop for T<'t,Bt>       { fn drop(&mut self) { } } // ACCEPT\n+\n+impl              Drop for U              { fn drop(&mut self) { } } // ACCEPT\n+\n+#[unsafe_destructor]\n+impl<One>         Drop for V<One,One>     { fn drop(&mut self) { } } // REJECT\n+//~^ERROR Implementations of Drop cannot be specialized\n+\n+#[unsafe_destructor]\n+impl<'lw>         Drop for W<'lw,'lw>     { fn drop(&mut self) { } } // REJECT\n+//~^ERROR Implementations of Drop cannot be specialized\n+\n+pub fn main() { }"}, {"sha": "265db3fe1336a6520a4d92dfd0e63e3c96c3f014", "filename": "src/test/run-pass/issue-15858.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Ftest%2Frun-pass%2Fissue-15858.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Ftest%2Frun-pass%2Fissue-15858.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15858.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -25,7 +25,7 @@ impl Bar for BarImpl {\n }\n \n \n-struct Foo<B>(B);\n+struct Foo<B: Bar>(B);\n \n #[unsafe_destructor]\n impl<B: Bar> Drop for Foo<B> {"}, {"sha": "e544585745de3dfc21839f252614879bc2e19d44", "filename": "src/test/run-pass/issue-15924.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Ftest%2Frun-pass%2Fissue-15924.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Ftest%2Frun-pass%2Fissue-15924.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15924.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -18,7 +18,7 @@ use std::fmt;\n use serialize::{Encoder, Encodable};\n use serialize::json;\n \n-struct Foo<T> {\n+struct Foo<T: Encodable> {\n     v: T,\n }\n "}, {"sha": "7ca0ee01015b89f2c0db75779ff2ee1bd6afe691", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -162,7 +162,7 @@ pub mod pipes {\n         }\n     }\n \n-    pub struct send_packet<T> {\n+    pub struct send_packet<T:Send> {\n         p: Option<*const packet<T>>,\n     }\n \n@@ -192,7 +192,7 @@ pub mod pipes {\n         }\n     }\n \n-    pub struct recv_packet<T> {\n+    pub struct recv_packet<T:Send> {\n         p: Option<*const packet<T>>,\n     }\n "}, {"sha": "08ee955cabbacd65e29a8300f9901f6f29f60b6b", "filename": "src/test/run-pass/issue-4252.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Ftest%2Frun-pass%2Fissue-4252.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b13b9c2b4e72d08cb1c68024ccc4f50001f4878/src%2Ftest%2Frun-pass%2Fissue-4252.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4252.rs?ref=3b13b9c2b4e72d08cb1c68024ccc4f50001f4878", "patch": "@@ -21,7 +21,7 @@ trait X {\n struct Y(int);\n \n #[derive(Debug)]\n-struct Z<T> {\n+struct Z<T: X+std::fmt::Debug> {\n     x: T\n }\n "}]}