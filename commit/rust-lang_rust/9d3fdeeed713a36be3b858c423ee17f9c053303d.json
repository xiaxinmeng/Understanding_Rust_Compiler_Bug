{"sha": "9d3fdeeed713a36be3b858c423ee17f9c053303d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkM2ZkZWVlZDcxM2EzNmJlM2I4NThjNDIzZWUxN2Y5YzA1MzMwM2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-03T13:15:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-03T13:15:51Z"}, "message": "Auto merge of #856 - RalfJung:type_dispatch_first, r=RalfJung\n\nAdjust for ptr_op changes\n\nThis is the Miri side of https://github.com/rust-lang/rust/pull/62946.", "tree": {"sha": "420dd3fca10fa19a7c2568e59b97ed72fef42a56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/420dd3fca10fa19a7c2568e59b97ed72fef42a56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d3fdeeed713a36be3b858c423ee17f9c053303d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d3fdeeed713a36be3b858c423ee17f9c053303d", "html_url": "https://github.com/rust-lang/rust/commit/9d3fdeeed713a36be3b858c423ee17f9c053303d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d3fdeeed713a36be3b858c423ee17f9c053303d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "247786dba612b7103c4eb694f80f28b75d2e242b", "url": "https://api.github.com/repos/rust-lang/rust/commits/247786dba612b7103c4eb694f80f28b75d2e242b", "html_url": "https://github.com/rust-lang/rust/commit/247786dba612b7103c4eb694f80f28b75d2e242b"}, {"sha": "5efacf636baba76bec2255e3d3312f5d5c81018f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5efacf636baba76bec2255e3d3312f5d5c81018f", "html_url": "https://github.com/rust-lang/rust/commit/5efacf636baba76bec2255e3d3312f5d5c81018f"}], "stats": {"total": 253, "additions": 29, "deletions": 224}, "files": [{"sha": "f54537d33b937a70cc2910bd663636c96cda9bed", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d3fdeeed713a36be3b858c423ee17f9c053303d/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/9d3fdeeed713a36be3b858c423ee17f9c053303d/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=9d3fdeeed713a36be3b858c423ee17f9c053303d", "patch": "@@ -1 +1 @@\n-d7270712cb446aad0817040bbca73a8d024f67b0\n+8e917f48382c6afaf50568263b89d35fba5d98e4"}, {"sha": "7fa79d822c35b6763758e46127c56475ac0aa4b0", "filename": "src/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d3fdeeed713a36be3b858c423ee17f9c053303d/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3fdeeed713a36be3b858c423ee17f9c053303d/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=9d3fdeeed713a36be3b858c423ee17f9c053303d", "patch": "@@ -179,13 +179,13 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     #[inline(always)]\n-    fn ptr_op(\n+    fn binary_ptr_op(\n         ecx: &rustc_mir::interpret::InterpCx<'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Tag>,\n         right: ImmTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, (Scalar<Tag>, bool)> {\n-        ecx.ptr_op(bin_op, left, right)\n+        ecx.binary_ptr_op(bin_op, left, right)\n     }\n \n     fn box_alloc("}, {"sha": "f047f4f4fad01d64ff5fcff5766b16dd911f7ab1", "filename": "src/operator.rs", "status": "modified", "additions": 25, "deletions": 206, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/9d3fdeeed713a36be3b858c423ee17f9c053303d/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3fdeeed713a36be3b858c423ee17f9c053303d/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=9d3fdeeed713a36be3b858c423ee17f9c053303d", "patch": "@@ -1,4 +1,4 @@\n-use rustc::ty::{Ty, layout::{Size, LayoutOf}};\n+use rustc::ty::{Ty, layout::LayoutOf};\n use rustc::mir;\n \n use crate::*;\n@@ -9,21 +9,13 @@ pub trait EvalContextExt<'tcx> {\n         ptr: Pointer<Tag>\n     ) -> InterpResult<'tcx>;\n \n-    fn ptr_op(\n+    fn binary_ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Tag>,\n         right: ImmTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, (Scalar<Tag>, bool)>;\n \n-    fn ptr_int_arithmetic(\n-        &self,\n-        bin_op: mir::BinOp,\n-        left: Pointer<Tag>,\n-        right: u128,\n-        signed: bool,\n-    ) -> InterpResult<'tcx, (Scalar<Tag>, bool)>;\n-\n     fn ptr_eq(\n         &self,\n         left: Scalar<Tag>,\n@@ -46,7 +38,7 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n         ptr.check_in_alloc(size, CheckInAllocMsg::InboundsTest)\n     }\n \n-    fn ptr_op(\n+    fn binary_ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Tag>,\n@@ -56,24 +48,9 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n \n         trace!(\"ptr_op: {:?} {:?} {:?}\", *left, bin_op, *right);\n \n-        // Treat everything of integer *type* at integer *value*.\n-        if left.layout.ty.is_integral() {\n-            // This is actually an integer operation, so dispatch back to the core engine.\n-            // TODO: Once intptrcast is the default, librustc_mir should never even call us\n-            // for integer types.\n-            assert!(right.layout.ty.is_integral());\n-            let l_bits = self.force_bits(left.imm.to_scalar()?, left.layout.size)?;\n-            let r_bits = self.force_bits(right.imm.to_scalar()?, right.layout.size)?;\n-\n-            let left = ImmTy::from_scalar(Scalar::from_uint(l_bits, left.layout.size), left.layout);\n-            let right = ImmTy::from_scalar(Scalar::from_uint(r_bits, left.layout.size), right.layout);\n-\n-            return self.binary_op(bin_op, left, right);\n-        }\n-\n-        // Operations that support fat pointers\n-        match bin_op {\n+        Ok(match bin_op {\n             Eq | Ne => {\n+                // This supports fat pointers.\n                 let eq = match (*left, *right) {\n                     (Immediate::Scalar(left), Immediate::Scalar(right)) =>\n                         self.ptr_eq(left.not_undef()?, right.not_undef()?)?,\n@@ -82,103 +59,38 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                         self.ptr_eq(left2.not_undef()?, right2.not_undef()?)?,\n                     _ => bug!(\"Type system should not allow comparing Scalar with ScalarPair\"),\n                 };\n-                return Ok((Scalar::from_bool(if bin_op == Eq { eq } else { !eq }), false));\n+                (Scalar::from_bool(if bin_op == Eq { eq } else { !eq }), false)\n             }\n-            _ => {},\n-        }\n \n-        // Now we expect no more fat pointers.\n-        let left_layout = left.layout;\n-        let left = left.to_scalar()?;\n-        let right_layout = right.layout;\n-        let right = right.to_scalar()?;\n-        debug_assert!(left.is_ptr() || right.is_ptr() || bin_op == Offset);\n+            Lt | Le | Gt | Ge => {\n+                // Just compare the integers.\n+                // TODO: Do we really want to *always* do that, even when comparing two live in-bounds pointers?\n+                let left = self.force_bits(left.to_scalar()?, left.layout.size)?;\n+                let right = self.force_bits(right.to_scalar()?, right.layout.size)?;\n+                let res = match bin_op {\n+                    Lt => left < right,\n+                    Le => left <= right,\n+                    Gt => left > right,\n+                    Ge => left >= right,\n+                    _ => bug!(\"We already established it has to be one of these operators.\"),\n+                };\n+                (Scalar::from_bool(res), false)\n+            }\n \n-        Ok(match bin_op {\n             Offset => {\n-                let pointee_ty = left_layout.ty\n+                let pointee_ty = left.layout.ty\n                     .builtin_deref(true)\n                     .expect(\"Offset called on non-ptr type\")\n                     .ty;\n                 let ptr = self.pointer_offset_inbounds(\n-                    left,\n+                    left.to_scalar()?,\n                     pointee_ty,\n-                    right.to_isize(self)?,\n+                    right.to_scalar()?.to_isize(self)?,\n                 )?;\n                 (ptr, false)\n             }\n-            // These need both to be pointer, and fail if they are not in the same location\n-            Lt | Le | Gt | Ge | Sub if left.is_ptr() && right.is_ptr() => {\n-                let left = left.to_ptr().expect(\"we checked is_ptr\");\n-                let right = right.to_ptr().expect(\"we checked is_ptr\");\n-                if left.alloc_id == right.alloc_id {\n-                    let res = match bin_op {\n-                        Lt => left.offset < right.offset,\n-                        Le => left.offset <= right.offset,\n-                        Gt => left.offset > right.offset,\n-                        Ge => left.offset >= right.offset,\n-                        Sub => {\n-                            // subtract the offsets\n-                            let left_offset = Scalar::from_uint(left.offset.bytes(), self.memory().pointer_size());\n-                            let right_offset = Scalar::from_uint(right.offset.bytes(), self.memory().pointer_size());\n-                            let layout = self.layout_of(self.tcx.types.usize)?;\n-                            return self.binary_op(\n-                                Sub,\n-                                ImmTy::from_scalar(left_offset, layout),\n-                                ImmTy::from_scalar(right_offset, layout),\n-                            )\n-                        }\n-                        _ => bug!(\"We already established it has to be one of these operators.\"),\n-                    };\n-                    (Scalar::from_bool(res), false)\n-                } else {\n-                    // Both are pointers, but from different allocations.\n-                    throw_unsup!(InvalidPointerMath)\n-                }\n-            }\n-            Gt | Ge if left.is_ptr() && right.is_bits() => {\n-                // \"ptr >[=] integer\" can be tested if the integer is small enough.\n-                let left = left.to_ptr().expect(\"we checked is_ptr\");\n-                let right = right.to_bits(self.memory().pointer_size()).expect(\"we checked is_bits\");\n-                let (_alloc_size, alloc_align) = self.memory()\n-                    .get_size_and_align(left.alloc_id, AllocCheck::MaybeDead)\n-                    .expect(\"alloc info with MaybeDead cannot fail\");\n-                let min_ptr_val = u128::from(alloc_align.bytes()) + u128::from(left.offset.bytes());\n-                let result = match bin_op {\n-                    Gt => min_ptr_val > right,\n-                    Ge => min_ptr_val >= right,\n-                    _ => bug!(),\n-                };\n-                if result {\n-                    // Definitely true!\n-                    (Scalar::from_bool(true), false)\n-                } else {\n-                    // Sorry, can't tell.\n-                    throw_unsup!(InvalidPointerMath)\n-                }\n-            }\n-            // These work if the left operand is a pointer, and the right an integer\n-            Add | BitAnd | Sub | Rem if left.is_ptr() && right.is_bits() => {\n-                // Cast to i128 is fine as we checked the kind to be ptr-sized\n-                self.ptr_int_arithmetic(\n-                    bin_op,\n-                    left.to_ptr().expect(\"we checked is_ptr\"),\n-                    right.to_bits(self.memory().pointer_size()).expect(\"we checked is_bits\"),\n-                    right_layout.abi.is_signed(),\n-                )?\n-            }\n-            // Commutative operators also work if the integer is on the left\n-            Add | BitAnd if left.is_bits() && right.is_ptr() => {\n-                // This is a commutative operation, just swap the operands\n-                self.ptr_int_arithmetic(\n-                    bin_op,\n-                    right.to_ptr().expect(\"we checked is_ptr\"),\n-                    left.to_bits(self.memory().pointer_size()).expect(\"we checked is_bits\"),\n-                    left_layout.abi.is_signed(),\n-                )?\n-            }\n-            // Nothing else works\n-            _ => throw_unsup!(InvalidPointerMath),\n+\n+            _ => bug!(\"Invalid operator on pointers: {:?}\", bin_op)\n         })\n     }\n \n@@ -195,99 +107,6 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n         Ok(left == right)\n     }\n \n-    fn ptr_int_arithmetic(\n-        &self,\n-        bin_op: mir::BinOp,\n-        left: Pointer<Tag>,\n-        right: u128,\n-        signed: bool,\n-    ) -> InterpResult<'tcx, (Scalar<Tag>, bool)> {\n-        use rustc::mir::BinOp::*;\n-\n-        fn map_to_primval((res, over): (Pointer<Tag>, bool)) -> (Scalar<Tag>, bool) {\n-            (Scalar::Ptr(res), over)\n-        }\n-\n-        Ok(match bin_op {\n-            Sub =>\n-                // The only way this can overflow is by underflowing, so signdeness of the right\n-                // operands does not matter.\n-                map_to_primval(left.overflowing_signed_offset(-(right as i128), self)),\n-            Add if signed =>\n-                map_to_primval(left.overflowing_signed_offset(right as i128, self)),\n-            Add if !signed =>\n-                map_to_primval(left.overflowing_offset(Size::from_bytes(right as u64), self)),\n-\n-            BitAnd if !signed => {\n-                let ptr_base_align = self.memory().get_size_and_align(left.alloc_id, AllocCheck::MaybeDead)\n-                    .expect(\"alloc info with MaybeDead cannot fail\")\n-                    .1.bytes();\n-                let base_mask = {\n-                    // FIXME: use `interpret::truncate`, once that takes a `Size` instead of a `Layout`.\n-                    let shift = 128 - self.memory().pointer_size().bits();\n-                    let value = !(ptr_base_align as u128 - 1);\n-                    // Truncate (shift left to drop out leftover values, shift right to fill with zeroes).\n-                    (value << shift) >> shift\n-                };\n-                let ptr_size = self.memory().pointer_size();\n-                trace!(\"ptr BitAnd, align {}, operand {:#010x}, base_mask {:#010x}\",\n-                    ptr_base_align, right, base_mask);\n-                if right & base_mask == base_mask {\n-                    // Case 1: the base address bits are all preserved, i.e., right is all-1 there.\n-                    let offset = (left.offset.bytes() as u128 & right) as u64;\n-                    (\n-                        Scalar::Ptr(Pointer::new_with_tag(\n-                            left.alloc_id,\n-                            Size::from_bytes(offset),\n-                            left.tag,\n-                        )),\n-                        false,\n-                    )\n-                } else if right & base_mask == 0 {\n-                    // Case 2: the base address bits are all taken away, i.e., right is all-0 there.\n-                    let v = Scalar::from_uint((left.offset.bytes() as u128) & right, ptr_size);\n-                    (v, false)\n-                } else {\n-                    throw_unsup!(ReadPointerAsBytes);\n-                }\n-            }\n-\n-            Rem if !signed => {\n-                // Doing modulo a divisor of the alignment is allowed.\n-                // (Intuition: modulo a divisor leaks less information.)\n-                let ptr_base_align = self.memory().get_size_and_align(left.alloc_id, AllocCheck::MaybeDead)\n-                    .expect(\"alloc info with MaybeDead cannot fail\")\n-                    .1.bytes();\n-                let right = right as u64;\n-                let ptr_size = self.memory().pointer_size();\n-                if right == 1 {\n-                    // Modulo 1 is always 0.\n-                    (Scalar::from_uint(0u32, ptr_size), false)\n-                } else if ptr_base_align % right == 0 {\n-                    // The base address would be cancelled out by the modulo operation, so we can\n-                    // just take the modulo of the offset.\n-                    (\n-                        Scalar::from_uint((left.offset.bytes() % right) as u128, ptr_size),\n-                        false,\n-                    )\n-                } else {\n-                    throw_unsup!(ReadPointerAsBytes);\n-                }\n-            }\n-\n-            _ => {\n-                let msg = format!(\n-                    \"unimplemented binary op on pointer {:?}: {:?}, {:?} ({})\",\n-                    bin_op,\n-                    left,\n-                    right,\n-                    if signed { \"signed\" } else { \"unsigned\" }\n-                );\n-                throw_unsup!(Unimplemented(msg));\n-            }\n-        })\n-    }\n-\n     /// Raises an error if the offset moves the pointer outside of its allocation.\n     /// We consider ZSTs their own huge allocation that doesn't overlap with anything (and nothing\n     /// moves in there because the size is 0). We also consider the NULL pointer its own separate"}, {"sha": "7a213a8059967a46d3a9aae137df6ac0efba70b8", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d3fdeeed713a36be3b858c423ee17f9c053303d/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d3fdeeed713a36be3b858c423ee17f9c053303d/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=9d3fdeeed713a36be3b858c423ee17f9c053303d", "patch": "@@ -306,7 +306,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(ref s) => {\n                             let x = Scalar::from_int(0, s.value.size(this));\n-                            this.write_immediate(Immediate::Scalar(x.into()), dest)?;\n+                            this.write_scalar(x, dest)?;\n                         }\n                         layout::Abi::ScalarPair(ref s1, ref s2) => {\n                             let x = Scalar::from_int(0, s1.value.size(this));"}, {"sha": "124f84de5bf45b6186719f3e39f204bde9051e64", "filename": "tests/compile-fail/pointers_to_different_allocations_are_unorderable.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/247786dba612b7103c4eb694f80f28b75d2e242b/tests%2Fcompile-fail%2Fpointers_to_different_allocations_are_unorderable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247786dba612b7103c4eb694f80f28b75d2e242b/tests%2Fcompile-fail%2Fpointers_to_different_allocations_are_unorderable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpointers_to_different_allocations_are_unorderable.rs?ref=247786dba612b7103c4eb694f80f28b75d2e242b", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    let x: *const u8 = &1;\n-    let y: *const u8 = &2;\n-    if x < y { //~ ERROR attempted to do invalid arithmetic on pointers\n-        unreachable!()\n-    }\n-}"}, {"sha": "43160249c36354d00eaacc2468b58365c0868ea8", "filename": "tests/compile-fail/ptr_ge_integer.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/247786dba612b7103c4eb694f80f28b75d2e242b/tests%2Fcompile-fail%2Fptr_ge_integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/247786dba612b7103c4eb694f80f28b75d2e242b/tests%2Fcompile-fail%2Fptr_ge_integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_ge_integer.rs?ref=247786dba612b7103c4eb694f80f28b75d2e242b", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    let b = Box::new(0);\n-    let x = &*b as *const i32;\n-    // We cannot test if this is >= 64.  After all, depending on the base address, that\n-    // might or might not be the case.\n-    assert!(x >= 64 as *const i32); //~ ERROR invalid arithmetic on pointers\n-}"}]}