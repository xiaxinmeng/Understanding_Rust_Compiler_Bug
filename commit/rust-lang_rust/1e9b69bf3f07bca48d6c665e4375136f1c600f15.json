{"sha": "1e9b69bf3f07bca48d6c665e4375136f1c600f15", "node_id": "C_kwDOAAsO6NoAKDFlOWI2OWJmM2YwN2JjYTQ4ZDZjNjY1ZTQzNzUxMzZmMWM2MDBmMTU", "commit": {"author": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-05-31T01:13:47Z"}, "committer": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-05-31T01:14:15Z"}, "message": "move hack to `normalize_param_env_or_error`", "tree": {"sha": "a1f3cb405a3b6a28d4da70ab3116a848fe36be38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1f3cb405a3b6a28d4da70ab3116a848fe36be38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e9b69bf3f07bca48d6c665e4375136f1c600f15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e9b69bf3f07bca48d6c665e4375136f1c600f15", "html_url": "https://github.com/rust-lang/rust/commit/1e9b69bf3f07bca48d6c665e4375136f1c600f15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e9b69bf3f07bca48d6c665e4375136f1c600f15/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "url": "https://api.github.com/repos/rust-lang/rust/commits/9610dfe5a9a731ced1ea4923ecbd0c57fe367898", "html_url": "https://github.com/rust-lang/rust/commit/9610dfe5a9a731ced1ea4923ecbd0c57fe367898"}], "stats": {"total": 71, "additions": 57, "deletions": 14}, "files": [{"sha": "8bcae3d9ab7cc7450c2a5d5bed364ed49d671731", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1e9b69bf3f07bca48d6c665e4375136f1c600f15/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9b69bf3f07bca48d6c665e4375136f1c600f15/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=1e9b69bf3f07bca48d6c665e4375136f1c600f15", "patch": "@@ -589,17 +589,6 @@ pub fn structurally_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n     debug!(\"{}.structurally_relate_consts(a = {:?}, b = {:?})\", relation.tag(), a, b);\n     let tcx = relation.tcx();\n \n-    // HACK(const_generics): We still need to eagerly evaluate consts when\n-    // relating them because during `normalize_param_env_or_error`,\n-    // we may relate an evaluated constant in a obligation against\n-    // an unnormalized (i.e. unevaluated) const in the param-env.\n-    // FIXME(generic_const_exprs): Once we always lazily unify unevaluated constants\n-    // these `eval` calls can be removed.\n-    if !tcx.features().generic_const_exprs {\n-        a = a.eval(tcx, relation.param_env());\n-        b = b.eval(tcx, relation.param_env());\n-    }\n-\n     if tcx.features().generic_const_exprs {\n         a = tcx.expand_abstract_consts(a);\n         b = tcx.expand_abstract_consts(b);"}, {"sha": "f7389bda159e5272ffc431e3414c78b481d28577", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1e9b69bf3f07bca48d6c665e4375136f1c600f15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e9b69bf3f07bca48d6c665e4375136f1c600f15/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=1e9b69bf3f07bca48d6c665e4375136f1c600f15", "patch": "@@ -32,7 +32,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_middle::query::Providers;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::{TypeVisitable, TypeVisitableExt};\n-use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeSuperVisitable};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFolder, TypeSuperVisitable};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_span::def_id::DefId;\n use rustc_span::Span;\n@@ -272,8 +272,62 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // parameter environments once for every fn as it goes,\n     // and errors will get reported then; so outside of type inference we\n     // can be sure that no errors should occur.\n-    let mut predicates: Vec<_> =\n-        util::elaborate(tcx, unnormalized_env.caller_bounds().into_iter()).collect();\n+    let mut predicates: Vec<_> = util::elaborate(\n+        tcx,\n+        unnormalized_env.caller_bounds().into_iter().map(|predicate| {\n+            if tcx.features().generic_const_exprs {\n+                return predicate;\n+            }\n+\n+            struct ConstNormalizer<'tcx>(TyCtxt<'tcx>);\n+\n+            impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ConstNormalizer<'tcx> {\n+                fn interner(&self) -> TyCtxt<'tcx> {\n+                    self.0\n+                }\n+\n+                fn fold_const(&mut self, c: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+                    // While it is pretty sus to be evaluating things with an empty param env, it\n+                    // should actually be okay since without `feature(generic_const_exprs)` the only\n+                    // const arguments that have a non-empty param env are array repeat counts. These\n+                    // do not appear in the type system though.\n+                    c.eval(self.0, ty::ParamEnv::empty())\n+                }\n+            }\n+\n+            // This whole normalization step is a hack to work around the fact that\n+            // `normalize_param_env_or_error` is fundamentally broken from using an\n+            // unnormalized param env with a trait solver that expects the param env\n+            // to be normalized.\n+            //\n+            // When normalizing the param env we can end up evaluating obligations\n+            // that have been normalized but can only be proven via a where clause\n+            // which is still in its unnormalized form. example:\n+            //\n+            // Attempting to prove `T: Trait<<u8 as Identity>::Assoc>` in a param env\n+            // with a `T: Trait<<u8 as Identity>::Assoc>` where clause will fail because\n+            // we first normalize obligations before proving them so we end up proving\n+            // `T: Trait<u8>`. Since lazy normalization is not implemented equating `u8`\n+            // with `<u8 as Identity>::Assoc` fails outright so we incorrectly believe that\n+            // we cannot prove `T: Trait<u8>`.\n+            //\n+            // The same thing is true for const generics- attempting to prove\n+            // `T: Trait<ConstKind::Unevaluated(...)>` with the same thing as a where clauses\n+            // will fail. After normalization we may be attempting to prove `T: Trait<4>` with\n+            // the unnormalized where clause `T: Trait<ConstKind::Unevaluated(...)>`. In order\n+            // for the obligation to hold `4` must be equal to `ConstKind::Unevaluated(...)`\n+            // but as we do not have lazy norm implemented, equating the two consts fails outright.\n+            //\n+            // Ideally we would not normalize consts here at all but it is required for backwards\n+            // compatibility. Eventually when lazy norm is implemented this can just be removed.\n+            // We do not normalize types here as there is no backwards compatibility requirement\n+            // for us to do so.\n+            //\n+            // FIXME(-Ztrait-solver=next): remove this hack since we have deferred projection equality\n+            predicate.fold_with(&mut ConstNormalizer(tcx))\n+        }),\n+    )\n+    .collect();\n \n     debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\", predicates);\n "}]}