{"sha": "3da868dcb67e85ccbd6d64cdcc29829b1399de15", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkYTg2OGRjYjY3ZTg1Y2NiZDZkNjRjZGNjMjk4MjliMTM5OWRlMTU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-07-31T20:04:34Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-08-29T22:38:54Z"}, "message": "Make fields of `Span` private", "tree": {"sha": "379d1e6e3d7a0b3bca1a5d6f73fd4443b841b0a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/379d1e6e3d7a0b3bca1a5d6f73fd4443b841b0a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3da868dcb67e85ccbd6d64cdcc29829b1399de15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3da868dcb67e85ccbd6d64cdcc29829b1399de15", "html_url": "https://github.com/rust-lang/rust/commit/3da868dcb67e85ccbd6d64cdcc29829b1399de15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3da868dcb67e85ccbd6d64cdcc29829b1399de15/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "630e02f25be1e65b316857c5bd8022da0b96db40", "url": "https://api.github.com/repos/rust-lang/rust/commits/630e02f25be1e65b316857c5bd8022da0b96db40", "html_url": "https://github.com/rust-lang/rust/commit/630e02f25be1e65b316857c5bd8022da0b96db40"}], "stats": {"total": 665, "additions": 316, "deletions": 349}, "files": [{"sha": "a86854cdbc7dff237c782ca602f0bef956ff39bd", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -89,10 +89,7 @@ impl FromStr for TokenStream {\n             // notify the expansion info that it is unhygienic\n             let mark = Mark::fresh(mark);\n             mark.set_expn_info(expn_info);\n-            let span = syntax_pos::Span {\n-                ctxt: SyntaxContext::empty().apply_mark(mark),\n-                ..call_site\n-            };\n+            let span = call_site.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n             let stream = parse::parse_stream_from_source_str(name, src, sess, Some(span));\n             Ok(__internal::token_stream_wrap(stream))\n         })\n@@ -177,10 +174,10 @@ pub struct Span(syntax_pos::Span);\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl Default for Span {\n     fn default() -> Span {\n-        ::__internal::with_sess(|(_, mark)| Span(syntax_pos::Span {\n-            ctxt: SyntaxContext::empty().apply_mark(mark),\n-            ..mark.expn_info().unwrap().call_site\n-        }))\n+        ::__internal::with_sess(|(_, mark)| {\n+            let call_site = mark.expn_info().unwrap().call_site;\n+            Span(call_site.with_ctxt(SyntaxContext::empty().apply_mark(mark)))\n+        })\n     }\n }\n \n@@ -570,7 +567,7 @@ impl TokenTree {\n                 }).into();\n             },\n             TokenNode::Term(symbol) => {\n-                let ident = ast::Ident { name: symbol.0, ctxt: self.span.0.ctxt };\n+                let ident = ast::Ident { name: symbol.0, ctxt: self.span.0.ctxt() };\n                 let token =\n                     if symbol.0.as_str().starts_with(\"'\") { Lifetime(ident) } else { Ident(ident) };\n                 return TokenTree::Token(self.span.0, token).into();"}, {"sha": "0f69c06c417a1e5b7fcfd5d6ecfc44827009fb09", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -425,8 +425,7 @@ impl<'a> LoweringContext<'a> {\n         Symbol::gensym(s)\n     }\n \n-    fn allow_internal_unstable(&self, reason: CompilerDesugaringKind, mut span: Span)\n-        -> Span\n+    fn allow_internal_unstable(&self, reason: CompilerDesugaringKind, span: Span) -> Span\n     {\n         let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(codemap::ExpnInfo {\n@@ -438,8 +437,7 @@ impl<'a> LoweringContext<'a> {\n                 allow_internal_unsafe: false,\n             },\n         });\n-        span.ctxt = SyntaxContext::empty().apply_mark(mark);\n-        span\n+        span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n     }\n \n     fn with_catch_scope<T, F>(&mut self, catch_id: NodeId, f: F) -> T\n@@ -613,7 +611,7 @@ impl<'a> LoweringContext<'a> {\n             TyKind::Slice(ref ty) => hir::TySlice(self.lower_ty(ty)),\n             TyKind::Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt)),\n             TyKind::Rptr(ref region, ref mt) => {\n-                let span = Span { hi: t.span.lo, ..t.span };\n+                let span = t.span.with_hi(t.span.lo());\n                 let lifetime = match *region {\n                     Some(ref lt) => self.lower_lifetime(lt),\n                     None => self.elided_lifetime(span)\n@@ -1237,7 +1235,7 @@ impl<'a> LoweringContext<'a> {\n             name: self.lower_ident(match f.ident {\n                 Some(ident) => ident,\n                 // FIXME(jseyfried) positional field hygiene\n-                None => Ident { name: Symbol::intern(&index.to_string()), ctxt: f.span.ctxt },\n+                None => Ident { name: Symbol::intern(&index.to_string()), ctxt: f.span.ctxt() },\n             }),\n             vis: self.lower_visibility(&f.vis, None),\n             ty: self.lower_ty(&f.ty),"}, {"sha": "dce824bd513a7d9d00392914346a40ffac879ccf", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -262,7 +262,7 @@ impl<'a> State<'a> {\n                              indented: usize,\n                              close_box: bool)\n                              -> io::Result<()> {\n-        self.maybe_print_comment(span.hi)?;\n+        self.maybe_print_comment(span.hi())?;\n         self.break_offset_if_not_bol(1, -(indented as isize))?;\n         self.s.word(\"}\")?;\n         if close_box {\n@@ -324,12 +324,12 @@ impl<'a> State<'a> {\n         let len = elts.len();\n         let mut i = 0;\n         for elt in elts {\n-            self.maybe_print_comment(get_span(elt).hi)?;\n+            self.maybe_print_comment(get_span(elt).hi())?;\n             op(self, elt)?;\n             i += 1;\n             if i < len {\n                 self.s.word(\",\")?;\n-                self.maybe_print_trailing_comment(get_span(elt), Some(get_span(&elts[i]).hi))?;\n+                self.maybe_print_trailing_comment(get_span(elt), Some(get_span(&elts[i]).hi()))?;\n                 self.space_if_not_bol()?;\n             }\n         }\n@@ -368,7 +368,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_type(&mut self, ty: &hir::Ty) -> io::Result<()> {\n-        self.maybe_print_comment(ty.span.lo)?;\n+        self.maybe_print_comment(ty.span.lo())?;\n         self.ibox(0)?;\n         match ty.node {\n             hir::TySlice(ref ty) => {\n@@ -458,7 +458,7 @@ impl<'a> State<'a> {\n \n     pub fn print_foreign_item(&mut self, item: &hir::ForeignItem) -> io::Result<()> {\n         self.hardbreak_if_not_bol()?;\n-        self.maybe_print_comment(item.span.lo)?;\n+        self.maybe_print_comment(item.span.lo())?;\n         self.print_outer_attributes(&item.attrs)?;\n         match item.node {\n             hir::ForeignItemFn(ref decl, ref arg_names, ref generics) => {\n@@ -531,7 +531,7 @@ impl<'a> State<'a> {\n     /// Pretty-print an item\n     pub fn print_item(&mut self, item: &hir::Item) -> io::Result<()> {\n         self.hardbreak_if_not_bol()?;\n-        self.maybe_print_comment(item.span.lo)?;\n+        self.maybe_print_comment(item.span.lo())?;\n         self.print_outer_attributes(&item.attrs)?;\n         self.ann.pre(self, NodeItem(item))?;\n         match item.node {\n@@ -797,7 +797,7 @@ impl<'a> State<'a> {\n         self.bopen()?;\n         for v in variants {\n             self.space_if_not_bol()?;\n-            self.maybe_print_comment(v.span.lo)?;\n+            self.maybe_print_comment(v.span.lo())?;\n             self.print_outer_attributes(&v.node.attrs)?;\n             self.ibox(indent_unit)?;\n             self.print_variant(v)?;\n@@ -842,7 +842,7 @@ impl<'a> State<'a> {\n             if struct_def.is_tuple() {\n                 self.popen()?;\n                 self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n-                    s.maybe_print_comment(field.span.lo)?;\n+                    s.maybe_print_comment(field.span.lo())?;\n                     s.print_outer_attributes(&field.attrs)?;\n                     s.print_visibility(&field.vis)?;\n                     s.print_type(&field.ty)\n@@ -863,7 +863,7 @@ impl<'a> State<'a> {\n \n             for field in struct_def.fields() {\n                 self.hardbreak_if_not_bol()?;\n-                self.maybe_print_comment(field.span.lo)?;\n+                self.maybe_print_comment(field.span.lo())?;\n                 self.print_outer_attributes(&field.attrs)?;\n                 self.print_visibility(&field.vis)?;\n                 self.print_name(field.name)?;\n@@ -908,7 +908,7 @@ impl<'a> State<'a> {\n     pub fn print_trait_item(&mut self, ti: &hir::TraitItem) -> io::Result<()> {\n         self.ann.pre(self, NodeSubItem(ti.id))?;\n         self.hardbreak_if_not_bol()?;\n-        self.maybe_print_comment(ti.span.lo)?;\n+        self.maybe_print_comment(ti.span.lo())?;\n         self.print_outer_attributes(&ti.attrs)?;\n         match ti.node {\n             hir::TraitItemKind::Const(ref ty, default) => {\n@@ -938,7 +938,7 @@ impl<'a> State<'a> {\n     pub fn print_impl_item(&mut self, ii: &hir::ImplItem) -> io::Result<()> {\n         self.ann.pre(self, NodeSubItem(ii.id))?;\n         self.hardbreak_if_not_bol()?;\n-        self.maybe_print_comment(ii.span.lo)?;\n+        self.maybe_print_comment(ii.span.lo())?;\n         self.print_outer_attributes(&ii.attrs)?;\n         self.print_defaultness(ii.defaultness)?;\n \n@@ -962,7 +962,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_stmt(&mut self, st: &hir::Stmt) -> io::Result<()> {\n-        self.maybe_print_comment(st.span.lo)?;\n+        self.maybe_print_comment(st.span.lo())?;\n         match st.node {\n             hir::StmtDecl(ref decl, _) => {\n                 self.print_decl(&decl)?;\n@@ -1017,7 +1017,7 @@ impl<'a> State<'a> {\n             hir::PopUnsafeBlock(..) => self.word_space(\"pop_unsafe\")?,\n             hir::DefaultBlock => (),\n         }\n-        self.maybe_print_comment(blk.span.lo)?;\n+        self.maybe_print_comment(blk.span.lo())?;\n         self.ann.pre(self, NodeBlock(blk))?;\n         self.bopen()?;\n \n@@ -1030,7 +1030,7 @@ impl<'a> State<'a> {\n             Some(ref expr) => {\n                 self.space_if_not_bol()?;\n                 self.print_expr(&expr)?;\n-                self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi))?;\n+                self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi()))?;\n             }\n             _ => (),\n         }\n@@ -1228,7 +1228,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_expr(&mut self, expr: &hir::Expr) -> io::Result<()> {\n-        self.maybe_print_comment(expr.span.lo)?;\n+        self.maybe_print_comment(expr.span.lo())?;\n         self.print_outer_attributes(&expr.attrs)?;\n         self.ibox(indent_unit)?;\n         self.ann.pre(self, NodeExpr(expr))?;\n@@ -1480,7 +1480,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_decl(&mut self, decl: &hir::Decl) -> io::Result<()> {\n-        self.maybe_print_comment(decl.span.lo)?;\n+        self.maybe_print_comment(decl.span.lo())?;\n         match decl.node {\n             hir::DeclLocal(ref loc) => {\n                 self.space_if_not_bol()?;\n@@ -1523,7 +1523,7 @@ impl<'a> State<'a> {\n                       path: &hir::Path,\n                       colons_before_params: bool)\n                       -> io::Result<()> {\n-        self.maybe_print_comment(path.span.lo)?;\n+        self.maybe_print_comment(path.span.lo())?;\n \n         for (i, segment) in path.segments.iter().enumerate() {\n             if i > 0 {\n@@ -1641,7 +1641,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_pat(&mut self, pat: &hir::Pat) -> io::Result<()> {\n-        self.maybe_print_comment(pat.span.lo)?;\n+        self.maybe_print_comment(pat.span.lo())?;\n         self.ann.pre(self, NodePat(pat))?;\n         // Pat isn't normalized, but the beauty of it\n         // is that it doesn't matter\n@@ -1897,7 +1897,7 @@ impl<'a> State<'a> {\n         match decl.output {\n             hir::Return(ref ty) => {\n                 self.print_type(&ty)?;\n-                self.maybe_print_comment(ty.span.lo)\n+                self.maybe_print_comment(ty.span.lo())\n             }\n             hir::DefaultReturn(..) => unreachable!(),\n         }\n@@ -2074,7 +2074,7 @@ impl<'a> State<'a> {\n         self.end()?;\n \n         match decl.output {\n-            hir::Return(ref output) => self.maybe_print_comment(output.span.lo),\n+            hir::Return(ref output) => self.maybe_print_comment(output.span.lo()),\n             _ => Ok(()),\n         }\n     }\n@@ -2124,13 +2124,13 @@ impl<'a> State<'a> {\n             if (*cmnt).style != comments::Trailing {\n                 return Ok(());\n             }\n-            let span_line = cm.lookup_char_pos(span.hi);\n+            let span_line = cm.lookup_char_pos(span.hi());\n             let comment_line = cm.lookup_char_pos((*cmnt).pos);\n             let mut next = (*cmnt).pos + BytePos(1);\n             if let Some(p) = next_pos {\n                 next = p;\n             }\n-            if span.hi < (*cmnt).pos && (*cmnt).pos < next &&\n+            if span.hi() < (*cmnt).pos && (*cmnt).pos < next &&\n                span_line.line == comment_line.line {\n                 self.print_comment(cmnt)?;\n             }"}, {"sha": "544c824f83ce2f9e4c048da32ac0efce704d6577", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -253,17 +253,17 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Span {\n         // If this is not an empty or invalid span, we want to hash the last\n         // position that belongs to it, as opposed to hashing the first\n         // position past it.\n-        let span_hi = if self.hi > self.lo {\n+        let span_hi = if self.hi() > self.lo() {\n             // We might end up in the middle of a multibyte character here,\n             // but that's OK, since we are not trying to decode anything at\n             // this position.\n-            self.hi - ::syntax_pos::BytePos(1)\n+            self.hi() - ::syntax_pos::BytePos(1)\n         } else {\n-            self.hi\n+            self.hi()\n         };\n \n         {\n-            let loc1 = hcx.codemap().byte_pos_to_line_and_col(self.lo);\n+            let loc1 = hcx.codemap().byte_pos_to_line_and_col(self.lo());\n             let loc1 = loc1.as_ref()\n                            .map(|&(ref fm, line, col)| (&fm.name[..], line, col.to_usize()))\n                            .unwrap_or((\"???\", 0, 0));\n@@ -296,7 +296,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Span {\n             }\n         }\n \n-        if self.ctxt == SyntaxContext::empty() {\n+        if self.ctxt() == SyntaxContext::empty() {\n             0u8.hash_stable(hcx, hasher);\n         } else {\n             1u8.hash_stable(hcx, hasher);"}, {"sha": "4c55c1474a326c11759e6ce1aa87c81dbcba47d4", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         fn explain_span<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                         heading: &str, span: Span)\n                                         -> (String, Option<Span>) {\n-            let lo = tcx.sess.codemap().lookup_char_pos_adj(span.lo);\n+            let lo = tcx.sess.codemap().lookup_char_pos_adj(span.lo());\n             (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1),\n              Some(span))\n         }"}, {"sha": "a611b3b937beef5bbaf37a70ef15825ec14d5b9d", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -180,7 +180,7 @@ impl CodeExtent {\n                         // (This is the special case aluded to in the\n                         // doc-comment for this method)\n                         let stmt_span = blk.stmts[r.first_statement_index as usize].span;\n-                        Some(Span { lo: stmt_span.hi, hi: blk.span.hi, ctxt: stmt_span.ctxt })\n+                        Some(Span::new(stmt_span.hi(), blk.span.hi(), stmt_span.ctxt()))\n                     }\n                 }\n             }"}, {"sha": "eafb4c5c80078c6cc8a91bf73786369f0e2384c2", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -82,10 +82,7 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n                 allow_internal_unsafe: false,\n             }\n         });\n-        let span = Span {\n-            ctxt: SyntaxContext::empty().apply_mark(mark),\n-            ..item.span\n-        };\n+        let span = item.span.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n         let ecfg = ExpansionConfig::default(name.to_string());\n         let mut f = AllocFnFactory {\n             span,"}, {"sha": "daa132dbf6213b35202b2fd375f44e043ed7b51d", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -183,8 +183,8 @@ impl EmitterWriter {\n                     continue;\n                 }\n \n-                let lo = cm.lookup_char_pos(span_label.span.lo);\n-                let mut hi = cm.lookup_char_pos(span_label.span.hi);\n+                let lo = cm.lookup_char_pos(span_label.span.lo());\n+                let mut hi = cm.lookup_char_pos(span_label.span.hi());\n \n                 // Watch out for \"empty spans\". If we get a span like 6..6, we\n                 // want to just display a `^` at 6, so convert that to\n@@ -683,15 +683,15 @@ impl EmitterWriter {\n         if let Some(ref cm) = self.cm {\n             for primary_span in msp.primary_spans() {\n                 if primary_span != &DUMMY_SP {\n-                    let hi = cm.lookup_char_pos(primary_span.hi);\n+                    let hi = cm.lookup_char_pos(primary_span.hi());\n                     if hi.line > max {\n                         max = hi.line;\n                     }\n                 }\n             }\n             for span_label in msp.span_labels() {\n                 if span_label.span != DUMMY_SP {\n-                    let hi = cm.lookup_char_pos(span_label.span.hi);\n+                    let hi = cm.lookup_char_pos(span_label.span.hi());\n                     if hi.line > max {\n                         max = hi.line;\n                     }\n@@ -914,7 +914,7 @@ impl EmitterWriter {\n         let (primary_lo, cm) = if let (Some(cm), Some(ref primary_span)) =\n             (self.cm.as_ref(), msp.primary_span().as_ref()) {\n             if primary_span != &&DUMMY_SP {\n-                (cm.lookup_char_pos(primary_span.lo), cm)\n+                (cm.lookup_char_pos(primary_span.lo()), cm)\n             } else {\n                 emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n                 return Ok(());\n@@ -1091,7 +1091,7 @@ impl EmitterWriter {\n                                Some(Style::HeaderMsg));\n \n             let suggestions = suggestion.splice_lines(cm.borrow());\n-            let span_start_pos = cm.lookup_char_pos(primary_sub.span.lo);\n+            let span_start_pos = cm.lookup_char_pos(primary_sub.span.lo());\n             let line_start = span_start_pos.line;\n             draw_col_separator_no_space(&mut buffer, 1, max_line_num_len + 1);\n             let mut row_num = 2;"}, {"sha": "7aaf4e598d6bf273b0f06ece3b10347986a58ae9", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -148,16 +148,12 @@ impl CodeSuggestion {\n \n         // Assumption: all spans are in the same file, and all spans\n         // are disjoint. Sort in ascending order.\n-        primary_spans.sort_by_key(|sp| sp.0.lo);\n+        primary_spans.sort_by_key(|sp| sp.0.lo());\n \n         // Find the bounding span.\n-        let lo = primary_spans.iter().map(|sp| sp.0.lo).min().unwrap();\n-        let hi = primary_spans.iter().map(|sp| sp.0.hi).min().unwrap();\n-        let bounding_span = Span {\n-            lo,\n-            hi,\n-            ctxt: NO_EXPANSION,\n-        };\n+        let lo = primary_spans.iter().map(|sp| sp.0.lo()).min().unwrap();\n+        let hi = primary_spans.iter().map(|sp| sp.0.hi()).min().unwrap();\n+        let bounding_span = Span::new(lo, hi, NO_EXPANSION);\n         let lines = cm.span_to_lines(bounding_span).unwrap();\n         assert!(!lines.lines.is_empty());\n \n@@ -171,14 +167,14 @@ impl CodeSuggestion {\n         //\n         // Finally push the trailing line segment of the last span\n         let fm = &lines.file;\n-        let mut prev_hi = cm.lookup_char_pos(bounding_span.lo);\n+        let mut prev_hi = cm.lookup_char_pos(bounding_span.lo());\n         prev_hi.col = CharPos::from_usize(0);\n \n         let mut prev_line = fm.get_line(lines.lines[0].line_index);\n         let mut bufs = vec![(String::new(), false); self.substitutions()];\n \n         for (sp, substitutes) in primary_spans {\n-            let cur_lo = cm.lookup_char_pos(sp.lo);\n+            let cur_lo = cm.lookup_char_pos(sp.lo());\n             for (&mut (ref mut buf, ref mut underline), substitute) in bufs.iter_mut()\n                                                                            .zip(substitutes) {\n                 if prev_hi.line == cur_lo.line {\n@@ -208,7 +204,7 @@ impl CodeSuggestion {\n                 }\n                 buf.push_str(substitute);\n             }\n-            prev_hi = cm.lookup_char_pos(sp.hi);\n+            prev_hi = cm.lookup_char_pos(sp.hi());\n             prev_line = fm.get_line(prev_hi.line - 1);\n         }\n         for &mut (ref mut buf, _) in &mut bufs {"}, {"sha": "268071ed434827792308817b44b8b80735b00e9a", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -369,7 +369,7 @@ impl CrateStore for cstore::CStore {\n         let source_name = format!(\"<{} macros>\", name);\n \n         let filemap = sess.parse_sess.codemap().new_filemap(source_name, def.body);\n-        let local_span = Span { lo: filemap.start_pos, hi: filemap.end_pos, ctxt: NO_EXPANSION };\n+        let local_span = Span::new(filemap.start_pos, filemap.end_pos, NO_EXPANSION);\n         let body = filemap_to_stream(&sess.parse_sess, filemap, None);\n \n         // Mark the attrs as used"}, {"sha": "1e2f167f199621e466c99b5959d992beb354d0c6", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -242,7 +242,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let sess = if let Some(sess) = self.sess {\n             sess\n         } else {\n-            return Ok(Span { lo: lo, hi: hi, ctxt: NO_EXPANSION });\n+            return Ok(Span::new(lo, hi, NO_EXPANSION));\n         };\n \n         let (lo, hi) = if lo > hi {\n@@ -289,7 +289,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let lo = (lo - filemap.original_start_pos) + filemap.translated_filemap.start_pos;\n         let hi = (hi - filemap.original_start_pos) + filemap.translated_filemap.start_pos;\n \n-        Ok(Span { lo: lo, hi: hi, ctxt: NO_EXPANSION })\n+        Ok(Span::new(lo, hi, NO_EXPANSION))\n     }\n }\n "}, {"sha": "904e30a01eba68791894f69df05735a08a35e59a", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -364,7 +364,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n             builder.args_and_body(block, &arguments, arg_extent, &body.value)\n         }));\n         // Attribute epilogue to function's closing brace\n-        let fn_end = Span { lo: span.hi, ..span };\n+        let fn_end = span.with_lo(span.hi());\n         let source_info = builder.source_info(fn_end);\n         let return_block = builder.return_block();\n         builder.cfg.terminate(block, source_info,"}, {"sha": "90f9c1c0d5f56cbb69ed203118da821e559a21d6", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -636,7 +636,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let tcx = self.hir.tcx();\n                 let extent_span = extent.span(&tcx.hir).unwrap();\n                 // Attribute scope exit drops to scope's closing brace\n-                let scope_end = Span { lo: extent_span.hi, .. extent_span};\n+                let scope_end = extent_span.with_lo(extent_span.hi());\n                 scope.drops.push(DropData {\n                     span: scope_end,\n                     location: lvalue.clone(),"}, {"sha": "e34b0927f67a9010f4e070065924ff4fbc6d6cee", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -477,7 +477,7 @@ struct NamePrivacyVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n     // Checks that a field is accessible.\n     fn check_field(&mut self, span: Span, def: &'tcx ty::AdtDef, field: &'tcx ty::FieldDef) {\n-        let ident = Ident { ctxt: span.ctxt.modern(), ..keywords::Invalid.ident() };\n+        let ident = Ident { ctxt: span.ctxt().modern(), ..keywords::Invalid.ident() };\n         let def_id = self.tcx.adjust_ident(ident, def.did, self.current_item).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\","}, {"sha": "2183c9124e7f4367d9390f7651d63dda95b48332", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -606,9 +606,7 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                     // don't suggest placing a use before the prelude\n                     // import or other generated ones\n                     if item.span == DUMMY_SP {\n-                        let mut span = item.span;\n-                        span.hi = span.lo;\n-                        self.span = Some(span);\n+                        self.span = Some(item.span.with_hi(item.span.lo()));\n                         self.found_use = true;\n                         return;\n                     }\n@@ -617,9 +615,7 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                 ItemKind::ExternCrate(_) => {}\n                 // but place them before the first other item\n                 _ => if self.span.map_or(true, |span| item.span < span ) {\n-                    let mut span = item.span;\n-                    span.hi = span.lo;\n-                    self.span = Some(span);\n+                    self.span = Some(item.span.with_hi(item.span.lo()));\n                 },\n             }\n         }\n@@ -1732,7 +1728,7 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_self(&mut self, ctxt: &mut SyntaxContext, module: Module<'a>) -> Module<'a> {\n         let mut module = self.get_module(module.normal_ancestor_id);\n-        while module.span.ctxt.modern() != *ctxt {\n+        while module.span.ctxt().modern() != *ctxt {\n             let parent = module.parent.unwrap_or_else(|| self.macro_def_scope(ctxt.remove_mark()));\n             module = self.get_module(parent.normal_ancestor_id);\n         }\n@@ -2659,8 +2655,8 @@ impl<'a> Resolver<'a> {\n                 sp = sp.next_point();\n                 if let Ok(snippet) = cm.span_to_snippet(sp.to(sp.next_point())) {\n                     debug!(\"snippet {:?}\", snippet);\n-                    let line_sp = cm.lookup_char_pos(sp.hi).line;\n-                    let line_base_sp = cm.lookup_char_pos(base_span.lo).line;\n+                    let line_sp = cm.lookup_char_pos(sp.hi()).line;\n+                    let line_base_sp = cm.lookup_char_pos(base_span.lo()).line;\n                     debug!(\"{:?} {:?}\", line_sp, line_base_sp);\n                     if snippet == \":\" {\n                         err.span_label(base_span,\n@@ -3360,7 +3356,7 @@ impl<'a> Resolver<'a> {\n         for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n             let module = binding.module().unwrap();\n             let mut ident = ident;\n-            if ident.ctxt.glob_adjust(module.expansion, binding.span.ctxt.modern()).is_none() {\n+            if ident.ctxt.glob_adjust(module.expansion, binding.span.ctxt().modern()).is_none() {\n                 continue\n             }\n             if self.resolve_ident_in_module_unadjusted(module, ident, ns, false, false, module.span)\n@@ -3586,7 +3582,7 @@ impl<'a> Resolver<'a> {\n                        new_binding: &NameBinding,\n                        old_binding: &NameBinding) {\n         // Error on the second of two conflicting names\n-        if old_binding.span.lo > new_binding.span.lo {\n+        if old_binding.span.lo() > new_binding.span.lo() {\n             return self.report_conflict(parent, ident, ns, old_binding, new_binding);\n         }\n "}, {"sha": "71bcee56ecc515f2d46ae2cabd9d2213178f79f1", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -237,7 +237,7 @@ impl<'a> Resolver<'a> {\n             }\n             let module = unwrap_or!(directive.imported_module.get(), return Err(Undetermined));\n             let (orig_current_module, mut ident) = (self.current_module, ident.modern());\n-            match ident.ctxt.glob_adjust(module.expansion, directive.span.ctxt.modern()) {\n+            match ident.ctxt.glob_adjust(module.expansion, directive.span.ctxt().modern()) {\n                 Some(Some(def)) => self.current_module = self.macro_def_scope(def),\n                 Some(None) => {}\n                 None => continue,\n@@ -398,7 +398,7 @@ impl<'a> Resolver<'a> {\n         for directive in module.glob_importers.borrow_mut().iter() {\n             let mut ident = ident.modern();\n             let scope = match ident.ctxt.reverse_glob_adjust(module.expansion,\n-                                                             directive.span.ctxt.modern()) {\n+                                                             directive.span.ctxt().modern()) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n                 Some(None) => directive.parent,\n                 None => continue,\n@@ -800,7 +800,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }).collect::<Vec<_>>();\n         for ((mut ident, ns), binding) in bindings {\n             let scope = match ident.ctxt.reverse_glob_adjust(module.expansion,\n-                                                             directive.span.ctxt.modern()) {\n+                                                             directive.span.ctxt().modern()) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n                 Some(None) => self.current_module,\n                 None => continue,"}, {"sha": "9ee38dd86c1b556859e2a7e8e6a1f1d60bb5b0e8", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -91,13 +91,13 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         use rls_span::{Row, Column};\n \n         let cm = self.tcx.sess.codemap();\n-        let start = cm.lookup_char_pos(span.lo);\n-        let end = cm.lookup_char_pos(span.hi);\n+        let start = cm.lookup_char_pos(span.lo());\n+        let end = cm.lookup_char_pos(span.hi());\n \n         SpanData {\n             file_name: start.file.name.clone().into(),\n-            byte_start: span.lo.0,\n-            byte_end: span.hi.0,\n+            byte_start: span.lo().0,\n+            byte_end: span.hi().0,\n             line_start: Row::new_one_indexed(start.line as u32),\n             line_end: Row::new_one_indexed(end.line as u32),\n             column_start: Column::new_one_indexed(start.col.0 as u32 + 1),\n@@ -117,7 +117,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     continue;\n                 }\n             };\n-            let lo_loc = self.span_utils.sess.codemap().lookup_char_pos(span.lo);\n+            let lo_loc = self.span_utils.sess.codemap().lookup_char_pos(span.lo());\n             result.push(ExternalCrateData {\n                 name: self.tcx.sess.cstore.crate_name(n).to_string(),\n                 num: n.as_u32(),\n@@ -999,7 +999,7 @@ fn escape(s: String) -> String {\n // Helper function to determine if a span came from a\n // macro expansion or syntax extension.\n fn generated_code(span: Span) -> bool {\n-    span.ctxt != NO_EXPANSION || span == DUMMY_SP\n+    span.ctxt() != NO_EXPANSION || span == DUMMY_SP\n }\n \n // DefId::index is a newtype and so the JSON serialisation is ugly. Therefore"}, {"sha": "b9d82b8e2512a1c21bb64a871c7b879c6274222f", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -192,7 +192,7 @@ impl<'a> SpanUtils<'a> {\n             prev = next;\n         }\n         if angle_count != 0 || bracket_count != 0 {\n-            let loc = self.sess.codemap().lookup_char_pos(span.lo);\n+            let loc = self.sess.codemap().lookup_char_pos(span.lo());\n             span_bug!(span,\n                       \"Mis-counted brackets when breaking path? Parsing '{}' \\\n                        in {}, line {}\",\n@@ -319,7 +319,7 @@ impl<'a> SpanUtils<'a> {\n         };\n \n         //If the span comes from a fake filemap, filter it.\n-        if !self.sess.codemap().lookup_char_pos(parent.lo).file.is_real_file() {\n+        if !self.sess.codemap().lookup_char_pos(parent.lo()).file.is_real_file() {\n             return true;\n         }\n "}, {"sha": "a6c6b0efcfa8cb7f9d760a92b22c06e07b49811d", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -1371,7 +1371,7 @@ fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trans_i\n             // Deterministically select one of the spans for error reporting\n             let span = match (span1, span2) {\n                 (Some(span1), Some(span2)) => {\n-                    Some(if span1.lo.0 > span2.lo.0 {\n+                    Some(if span1.lo().0 > span2.lo().0 {\n                         span1\n                     } else {\n                         span2"}, {"sha": "7529139c05aacfb78eef8621b669ae2e165cf8a0", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -49,7 +49,7 @@ pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n \n /// Return syntax_pos::Loc corresponding to the beginning of the span\n pub fn span_start(cx: &CrateContext, span: Span) -> syntax_pos::Loc {\n-    cx.sess().codemap().lookup_char_pos(span.lo)\n+    cx.sess().codemap().lookup_char_pos(span.lo())\n }\n \n pub fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (u64, u32) {"}, {"sha": "bba3b1fa5baee102f3873310c99c19f09a53e76e", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -330,7 +330,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 self.set_debug_loc(&bcx, terminator.source_info);\n \n                 // Get the location information.\n-                let loc = bcx.sess().codemap().lookup_char_pos(span.lo);\n+                let loc = bcx.sess().codemap().lookup_char_pos(span.lo());\n                 let filename = Symbol::intern(&loc.file.name).as_str();\n                 let filename = C_str_slice(bcx.ccx, filename);\n                 let line = C_u32(bcx.ccx, loc.line as u32);"}, {"sha": "5206ad74e20544825e42db2f69d61643ee47c342", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -129,23 +129,23 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // In order to have a good line stepping behavior in debugger, we overwrite debug\n         // locations of macro expansions with that of the outermost expansion site\n         // (unless the crate is being compiled with `-Z debug-macros`).\n-        if source_info.span.ctxt == NO_EXPANSION ||\n+        if source_info.span.ctxt() == NO_EXPANSION ||\n            self.ccx.sess().opts.debugging_opts.debug_macros {\n-            let scope = self.scope_metadata_for_loc(source_info.scope, source_info.span.lo);\n+            let scope = self.scope_metadata_for_loc(source_info.scope, source_info.span.lo());\n             (scope, source_info.span)\n         } else {\n             // Walk up the macro expansion chain until we reach a non-expanded span.\n             // We also stop at the function body level because no line stepping can occur\n             // at the level above that.\n             let mut span = source_info.span;\n-            while span.ctxt != NO_EXPANSION && span.ctxt != self.mir.span.ctxt {\n-                if let Some(info) = span.ctxt.outer().expn_info() {\n+            while span.ctxt() != NO_EXPANSION && span.ctxt() != self.mir.span.ctxt() {\n+                if let Some(info) = span.ctxt().outer().expn_info() {\n                     span = info.call_site;\n                 } else {\n                     break;\n                 }\n             }\n-            let scope = self.scope_metadata_for_loc(source_info.scope, span.lo);\n+            let scope = self.scope_metadata_for_loc(source_info.scope, span.lo());\n             // Use span of the outermost expansion site, while keeping the original lexical scope.\n             (scope, span)\n         }"}, {"sha": "dc362b4d953d2ad6676cd041e8cf38fad0feb3bf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -2486,9 +2486,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 err.span_label(def_s, \"defined here\");\n             }\n             if sugg_unit {\n-                let mut sugg_span = sp.end_point();\n+                let sugg_span = sp.end_point();\n                 // remove closing `)` from the span\n-                sugg_span.hi = sugg_span.lo;\n+                let sugg_span = sugg_span.with_hi(sugg_span.lo());\n                 err.span_suggestion(\n                     sugg_span,\n                     \"expected the unit value `()`. You can create one with a pair of parenthesis\",\n@@ -3137,7 +3137,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     debug!(\"tuple struct named {:?}\",  base_t);\n                     let ident = ast::Ident {\n                         name: Symbol::intern(&idx.node.to_string()),\n-                        ctxt: idx.span.ctxt.modern(),\n+                        ctxt: idx.span.ctxt().modern(),\n                     };\n                     let (ident, def_scope) =\n                         self.tcx.adjust_ident(ident, base_def.did, self.body_id);\n@@ -4524,11 +4524,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return;\n         }\n         let original_span = original_sp(last_stmt.span, blk.span);\n-        let span_semi = Span {\n-            lo: original_span.hi - BytePos(1),\n-            hi: original_span.hi,\n-            ctxt: original_span.ctxt,\n-        };\n+        let span_semi = original_span.with_lo(original_span.hi() - BytePos(1));\n         err.span_suggestion(span_semi, \"consider removing this semicolon\", \"\".to_string());\n     }\n "}, {"sha": "aab44ddce0e6af711a15d6c6e5c68f0b0df8cead", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -457,8 +457,8 @@ impl Clean<Item> for doctree::Module {\n         // the outer `mod` item for the source code.\n         let whence = {\n             let cm = cx.sess().codemap();\n-            let outer = cm.lookup_char_pos(self.where_outer.lo);\n-            let inner = cm.lookup_char_pos(self.where_inner.lo);\n+            let outer = cm.lookup_char_pos(self.where_outer.lo());\n+            let inner = cm.lookup_char_pos(self.where_inner.lo());\n             if outer.file.start_pos == inner.file.start_pos {\n                 // mod foo { ... }\n                 self.where_outer\n@@ -2251,8 +2251,8 @@ impl Clean<Span> for syntax_pos::Span {\n \n         let cm = cx.sess().codemap();\n         let filename = cm.span_to_filename(*self);\n-        let lo = cm.lookup_char_pos(self.lo);\n-        let hi = cm.lookup_char_pos(self.hi);\n+        let lo = cm.lookup_char_pos(self.lo());\n+        let hi = cm.lookup_char_pos(self.hi());\n         Span {\n             filename: filename.to_string(),\n             loline: lo.line,"}, {"sha": "5d74cbdf56a196d2c1bf2d7762eeaec83a30ae90", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -532,7 +532,7 @@ impl Collector {\n \n     pub fn get_line(&self) -> usize {\n         if let Some(ref codemap) = self.codemap {\n-            let line = self.position.lo.to_usize();\n+            let line = self.position.lo().to_usize();\n             let line = codemap.lookup_char_pos(BytePos(line as u32)).line;\n             if line > 0 { line - 1 } else { line }\n         } else {"}, {"sha": "925178f86398fbe2fa524cd54b69d7735584cec2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -134,7 +134,7 @@ impl PathSegment {\n     }\n     pub fn crate_root(span: Span) -> Self {\n         PathSegment {\n-            identifier: Ident { ctxt: span.ctxt, ..keywords::CrateRoot.ident() },\n+            identifier: Ident { ctxt: span.ctxt(), ..keywords::CrateRoot.ident() },\n             span,\n             parameters: None,\n         }"}, {"sha": "bf8e0c0996ae4ebe6ca02be944cd8c52bb080c18", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -1059,7 +1059,7 @@ impl MetaItem {\n     fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItem>\n         where I: Iterator<Item = TokenTree>,\n     {\n-        let (mut span, name) = match tokens.next() {\n+        let (span, name) = match tokens.next() {\n             Some(TokenTree::Token(span, Token::Ident(ident))) => (span, ident.name),\n             Some(TokenTree::Token(_, Token::Interpolated(ref nt))) => match nt.0 {\n                 token::Nonterminal::NtIdent(ident) => (ident.span, ident.node.name),\n@@ -1068,17 +1068,17 @@ impl MetaItem {\n             },\n             _ => return None,\n         };\n-        let list_closing_paren_pos = tokens.peek().map(|tt| tt.span().hi);\n+        let list_closing_paren_pos = tokens.peek().map(|tt| tt.span().hi());\n         let node = match MetaItemKind::from_tokens(tokens) {\n             Some(node) => node,\n             _ => return None,\n         };\n-        span.hi = match node {\n-            MetaItemKind::NameValue(ref lit) => lit.span.hi,\n-            MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(span.hi),\n-            _ => span.hi,\n+        let hi = match node {\n+            MetaItemKind::NameValue(ref lit) => lit.span.hi(),\n+            MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(span.hi()),\n+            _ => span.hi(),\n         };\n-        Some(MetaItem { name: name, span: span, node: node })\n+        Some(MetaItem { name, node, span: span.with_hi(hi) })\n     }\n }\n "}, {"sha": "cd4a6f921fe6f1a74ce7ae0ad85f3abc98f3e476", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -34,8 +34,8 @@ use errors::CodeMapper;\n /// otherwise return the call site span up to the `enclosing_sp` by\n /// following the `expn_info` chain.\n pub fn original_sp(sp: Span, enclosing_sp: Span) -> Span {\n-    let call_site1 = sp.ctxt.outer().expn_info().map(|ei| ei.call_site);\n-    let call_site2 = enclosing_sp.ctxt.outer().expn_info().map(|ei| ei.call_site);\n+    let call_site1 = sp.ctxt().outer().expn_info().map(|ei| ei.call_site);\n+    let call_site2 = enclosing_sp.ctxt().outer().expn_info().map(|ei| ei.call_site);\n     match (call_site1, call_site2) {\n         (None, _) => sp,\n         (Some(call_site1), Some(call_site2)) if call_site1 == call_site2 => sp,\n@@ -232,7 +232,7 @@ impl CodeMap {\n     }\n \n     pub fn mk_substr_filename(&self, sp: Span) -> String {\n-        let pos = self.lookup_char_pos(sp.lo);\n+        let pos = self.lookup_char_pos(sp.lo());\n         (format!(\"<{}:{}:{}>\",\n                  pos.file.name,\n                  pos.line,\n@@ -299,18 +299,16 @@ impl CodeMap {\n     ///    * the lhs span needs to end on the same line the rhs span begins\n     ///    * the lhs span must start at or before the rhs span\n     pub fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span> {\n-        use std::cmp;\n-\n         // make sure we're at the same expansion id\n-        if sp_lhs.ctxt != sp_rhs.ctxt {\n+        if sp_lhs.ctxt() != sp_rhs.ctxt() {\n             return None;\n         }\n \n-        let lhs_end = match self.lookup_line(sp_lhs.hi) {\n+        let lhs_end = match self.lookup_line(sp_lhs.hi()) {\n             Ok(x) => x,\n             Err(_) => return None\n         };\n-        let rhs_begin = match self.lookup_line(sp_rhs.lo) {\n+        let rhs_begin = match self.lookup_line(sp_rhs.lo()) {\n             Ok(x) => x,\n             Err(_) => return None\n         };\n@@ -321,12 +319,8 @@ impl CodeMap {\n         }\n \n         // ensure these follow the expected order and we don't overlap\n-        if (sp_lhs.lo <= sp_rhs.lo) && (sp_lhs.hi <= sp_rhs.lo) {\n-            Some(Span {\n-                lo: cmp::min(sp_lhs.lo, sp_rhs.lo),\n-                hi: cmp::max(sp_lhs.hi, sp_rhs.hi),\n-                ctxt: sp_lhs.ctxt,\n-            })\n+        if (sp_lhs.lo() <= sp_rhs.lo()) && (sp_lhs.hi() <= sp_rhs.lo()) {\n+            Some(sp_lhs.to(sp_rhs))\n         } else {\n             None\n         }\n@@ -337,8 +331,8 @@ impl CodeMap {\n             return \"no-location\".to_string();\n         }\n \n-        let lo = self.lookup_char_pos_adj(sp.lo);\n-        let hi = self.lookup_char_pos_adj(sp.hi);\n+        let lo = self.lookup_char_pos_adj(sp.lo());\n+        let hi = self.lookup_char_pos_adj(sp.hi());\n         return (format!(\"{}:{}:{}: {}:{}\",\n                         lo.filename,\n                         lo.line,\n@@ -348,19 +342,19 @@ impl CodeMap {\n     }\n \n     pub fn span_to_filename(&self, sp: Span) -> FileName {\n-        self.lookup_char_pos(sp.lo).file.name.to_string()\n+        self.lookup_char_pos(sp.lo()).file.name.to_string()\n     }\n \n     pub fn span_to_lines(&self, sp: Span) -> FileLinesResult {\n         debug!(\"span_to_lines(sp={:?})\", sp);\n \n-        if sp.lo > sp.hi {\n+        if sp.lo() > sp.hi() {\n             return Err(SpanLinesError::IllFormedSpan(sp));\n         }\n \n-        let lo = self.lookup_char_pos(sp.lo);\n+        let lo = self.lookup_char_pos(sp.lo());\n         debug!(\"span_to_lines: lo={:?}\", lo);\n-        let hi = self.lookup_char_pos(sp.hi);\n+        let hi = self.lookup_char_pos(sp.hi());\n         debug!(\"span_to_lines: hi={:?}\", hi);\n \n         if lo.file.start_pos != hi.file.start_pos {\n@@ -400,12 +394,12 @@ impl CodeMap {\n     }\n \n     pub fn span_to_snippet(&self, sp: Span) -> Result<String, SpanSnippetError> {\n-        if sp.lo > sp.hi {\n+        if sp.lo() > sp.hi() {\n             return Err(SpanSnippetError::IllFormedSpan(sp));\n         }\n \n-        let local_begin = self.lookup_byte_offset(sp.lo);\n-        let local_end = self.lookup_byte_offset(sp.hi);\n+        let local_begin = self.lookup_byte_offset(sp.lo());\n+        let local_end = self.lookup_byte_offset(sp.hi());\n \n         if local_begin.fm.start_pos != local_end.fm.start_pos {\n             return Err(SpanSnippetError::DistinctSources(DistinctSources {\n@@ -450,7 +444,7 @@ impl CodeMap {\n             Ok(snippet) => {\n                 let snippet = snippet.split(c).nth(0).unwrap_or(\"\").trim_right();\n                 if !snippet.is_empty() && !snippet.contains('\\n') {\n-                    Span { hi: BytePos(sp.lo.0 + snippet.len() as u32), ..sp }\n+                    sp.with_hi(BytePos(sp.lo().0 + snippet.len() as u32))\n                 } else {\n                     sp\n                 }\n@@ -752,7 +746,7 @@ mod tests {\n     fn t7() {\n         // Test span_to_lines for a span ending at the end of filemap\n         let cm = init_code_map();\n-        let span = Span {lo: BytePos(12), hi: BytePos(23), ctxt: NO_EXPANSION};\n+        let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n         let file_lines = cm.span_to_lines(span).unwrap();\n \n         assert_eq!(file_lines.file.name, \"blork.rs\");\n@@ -768,7 +762,7 @@ mod tests {\n         assert_eq!(input.len(), selection.len());\n         let left_index = selection.find('~').unwrap() as u32;\n         let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n-        Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), ctxt: NO_EXPANSION }\n+        Span::new(BytePos(left_index), BytePos(right_index + 1), NO_EXPANSION)\n     }\n \n     /// Test span_to_snippet and span_to_lines for a span converting 3\n@@ -798,7 +792,7 @@ mod tests {\n     fn t8() {\n         // Test span_to_snippet for a span ending at the end of filemap\n         let cm = init_code_map();\n-        let span = Span {lo: BytePos(12), hi: BytePos(23), ctxt: NO_EXPANSION};\n+        let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n         let snippet = cm.span_to_snippet(span);\n \n         assert_eq!(snippet, Ok(\"second line\".to_string()));\n@@ -808,7 +802,7 @@ mod tests {\n     fn t9() {\n         // Test span_to_str for a span ending at the end of filemap\n         let cm = init_code_map();\n-        let span = Span {lo: BytePos(12), hi: BytePos(23), ctxt: NO_EXPANSION};\n+        let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n         let sstr =  cm.span_to_string(span);\n \n         assert_eq!(sstr, \"blork.rs:2:1: 2:12\");\n@@ -859,11 +853,11 @@ mod tests {\n                 let lo = hi + offset;\n                 hi = lo + substring.len();\n                 if i == n {\n-                    let span = Span {\n-                        lo: BytePos(lo as u32 + file.start_pos.0),\n-                        hi: BytePos(hi as u32 + file.start_pos.0),\n-                        ctxt: NO_EXPANSION,\n-                    };\n+                    let span = Span::new(\n+                        BytePos(lo as u32 + file.start_pos.0),\n+                        BytePos(hi as u32 + file.start_pos.0),\n+                        NO_EXPANSION,\n+                    );\n                     assert_eq!(&self.span_to_snippet(span).unwrap()[..],\n                             substring);\n                     return span;"}, {"sha": "0909eec62691b39f582327f477b6f5914f5c11e9", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -14,7 +14,6 @@ use {fold, attr};\n use ast;\n use codemap::Spanned;\n use parse::{token, ParseSess};\n-use syntax_pos::Span;\n \n use ptr::P;\n use util::small_vector::SmallVector;\n@@ -89,10 +88,10 @@ impl<'a> StripUnconfigured<'a> {\n             parser.expect(&token::OpenDelim(token::Paren))?;\n             let cfg = parser.parse_meta_item()?;\n             parser.expect(&token::Comma)?;\n-            let lo = parser.span.lo;\n+            let lo = parser.span.lo();\n             let (path, tokens) = parser.parse_path_and_tokens()?;\n             parser.expect(&token::CloseDelim(token::Paren))?;\n-            Ok((cfg, path, tokens, Span { lo: lo, ..parser.prev_span }))\n+            Ok((cfg, path, tokens, parser.prev_span.with_lo(lo)))\n         }) {\n             Ok(result) => result,\n             Err(mut e) => {"}, {"sha": "daa7112235f4769cb5d96ccfc3b6d3ef07a57a63", "filename": "src/libsyntax/diagnostics/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -47,7 +47,7 @@ pub struct ErrorLocation {\n impl ErrorLocation {\n     /// Create an error location from a span.\n     pub fn from_span(ecx: &ExtCtxt, sp: Span) -> ErrorLocation {\n-        let loc = ecx.codemap().lookup_char_pos_adj(sp.lo);\n+        let loc = ecx.codemap().lookup_char_pos_adj(sp.lo());\n         ErrorLocation {\n             filename: loc.filename,\n             line: loc.line"}, {"sha": "cac2ff975d64b2f00c67ca115d2b55a36699c569", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -731,7 +731,7 @@ impl<'a> ExtCtxt<'a> {\n                     // Stop going up the backtrace once include! is encountered\n                     return None;\n                 }\n-                ctxt = info.call_site.ctxt;\n+                ctxt = info.call_site.ctxt();\n                 last_macro = Some(info.call_site);\n                 Some(())\n             }).is_none() {\n@@ -837,7 +837,7 @@ pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &st\n                               -> Option<Spanned<(Symbol, ast::StrStyle)>> {\n     // Update `expr.span`'s ctxt now in case expr is an `include!` macro invocation.\n     let expr = expr.map(|mut expr| {\n-        expr.span.ctxt = expr.span.ctxt.apply_mark(cx.current_expansion.mark);\n+        expr.span = expr.span.with_ctxt(expr.span.ctxt().apply_mark(cx.current_expansion.mark));\n         expr\n     });\n "}, {"sha": "66df734b328c0cf2b6db635e4eaaba5d6a8bc5c5", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -755,7 +755,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr> {\n-        let loc = self.codemap().lookup_char_pos(span.lo);\n+        let loc = self.codemap().lookup_char_pos(span.lo());\n         let expr_file = self.expr_str(span, Symbol::intern(&loc.file.name));\n         let expr_line = self.expr_u32(span, loc.line as u32);\n         let expr_col = self.expr_u32(span, loc.col.to_usize() as u32 + 1);"}, {"sha": "2e70962cad6f86201d75a7c16ee87e31066dc0fd", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -68,7 +68,7 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt, span: Span, traits: &[ast::Path]\n         },\n     });\n \n-    let span = Span { ctxt: cx.backtrace(), ..span };\n+    let span = span.with_ctxt(cx.backtrace());\n     item.map_attrs(|mut attrs| {\n         if names.contains(&Symbol::intern(\"Eq\")) && names.contains(&Symbol::intern(\"PartialEq\")) {\n             let meta = cx.meta_word(span, Symbol::intern(\"structural_match\"));"}, {"sha": "2f7d5685b6efecb42c669116745c93d8da219162", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -598,7 +598,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         match *ext {\n             ProcMacroDerive(ref ext, _) => {\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n-                let span = Span { ctxt: self.cx.backtrace(), ..span };\n+                let span = span.with_ctxt(self.cx.backtrace());\n                 let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this\n                     name: keywords::Invalid.name(),\n                     span: DUMMY_SP,\n@@ -609,7 +609,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             BuiltinDerive(func) => {\n                 expn_info.callee.allow_internal_unstable = true;\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n-                let span = Span { ctxt: self.cx.backtrace(), ..span };\n+                let span = span.with_ctxt(self.cx.backtrace());\n                 let mut items = Vec::new();\n                 func(self.cx, span, &attr.meta().unwrap(), &item, &mut |a| items.push(a));\n                 kind.expect_from_annotatables(items)\n@@ -684,8 +684,8 @@ impl<'a> Parser<'a> {\n         if self.token != token::Eof {\n             let msg = format!(\"macro expansion ignores token `{}` and any following\",\n                               self.this_token_to_string());\n-            let mut def_site_span = self.span;\n-            def_site_span.ctxt = SyntaxContext::empty(); // Avoid emitting backtrace info twice.\n+            // Avoid emitting backtrace info twice.\n+            let def_site_span = self.span.with_ctxt(SyntaxContext::empty());\n             let mut err = self.diagnostic().struct_span_err(def_site_span, &msg);\n             let msg = format!(\"caused by the macro expansion here; the usage \\\n                                of `{}!` is likely invalid in {} context\",\n@@ -1069,9 +1069,8 @@ impl Folder for Marker {\n         ident\n     }\n \n-    fn new_span(&mut self, mut span: Span) -> Span {\n-        span.ctxt = span.ctxt.apply_mark(self.0);\n-        span\n+    fn new_span(&mut self, span: Span) -> Span {\n+        span.with_ctxt(span.ctxt().apply_mark(self.0))\n     }\n \n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {"}, {"sha": "18a262d139a27571c54ee5870644f393256b8a9c", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -36,7 +36,7 @@ pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n-    let loc = cx.codemap().lookup_char_pos(topmost.lo);\n+    let loc = cx.codemap().lookup_char_pos(topmost.lo());\n \n     base::MacEager::expr(cx.expr_u32(topmost, loc.line as u32))\n }\n@@ -47,7 +47,7 @@ pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n     base::check_zero_tts(cx, sp, tts, \"column!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n-    let loc = cx.codemap().lookup_char_pos(topmost.lo);\n+    let loc = cx.codemap().lookup_char_pos(topmost.lo());\n \n     base::MacEager::expr(cx.expr_u32(topmost, loc.col.to_usize() as u32))\n }\n@@ -70,7 +70,7 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n-    let loc = cx.codemap().lookup_char_pos(topmost.lo);\n+    let loc = cx.codemap().lookup_char_pos(topmost.lo());\n     base::MacEager::expr(cx.expr_str(topmost, Symbol::intern(&loc.file.name)))\n }\n "}, {"sha": "2167b64e6103d8bac3d7c2289b4576dc9116bfb1", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -329,7 +329,8 @@ fn inner_parse_loop(sess: &ParseSess,\n                     // Only touch the binders we have actually bound\n                     for idx in item.match_lo..item.match_hi {\n                         let sub = item.matches[idx].clone();\n-                        new_pos.push_match(idx, MatchedSeq(sub, Span { lo: item.sp_lo, ..span }));\n+                        let span = span.with_lo(item.sp_lo);\n+                        new_pos.push_match(idx, MatchedSeq(sub, span));\n                     }\n \n                     new_pos.match_cur = item.match_hi;\n@@ -379,7 +380,7 @@ fn inner_parse_loop(sess: &ParseSess,\n                         match_cur: item.match_cur,\n                         match_hi: item.match_cur + seq.num_captures,\n                         up: Some(item),\n-                        sp_lo: sp.lo,\n+                        sp_lo: sp.lo(),\n                         top_elts: Tt(TokenTree::Sequence(sp, seq)),\n                     }));\n                 }\n@@ -424,7 +425,7 @@ pub fn parse(sess: &ParseSess,\n              recurse_into_modules: bool)\n              -> NamedParseResult {\n     let mut parser = Parser::new(sess, tts, directory, recurse_into_modules, true);\n-    let mut cur_items = SmallVector::one(initial_matcher_pos(ms.to_owned(), parser.span.lo));\n+    let mut cur_items = SmallVector::one(initial_matcher_pos(ms.to_owned(), parser.span.lo()));\n     let mut next_items = Vec::new(); // or proceed normally\n \n     loop {"}, {"sha": "6d58af497f091256ec603e4b0bf926dd2059e13f", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -130,7 +130,7 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,\n                     tts = tts.map_enumerated(|i, tt| {\n                         let mut tt = tt.clone();\n                         let mut sp = rhs_spans[i];\n-                        sp.ctxt = tt.span().ctxt;\n+                        sp = sp.with_ctxt(tt.span().ctxt());\n                         tt.set_span(sp);\n                         tt\n                     });\n@@ -161,7 +161,7 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,\n                     macro_ident: name\n                 })\n             }\n-            Failure(sp, tok) => if sp.lo >= best_fail_spot.lo {\n+            Failure(sp, tok) => if sp.lo() >= best_fail_spot.lo() {\n                 best_fail_spot = sp;\n                 best_fail_tok = Some(tok);\n             },"}, {"sha": "0e21e3f6b00109e48863721368f91167262446a1", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -37,7 +37,7 @@ impl Delimited {\n         let open_span = if span == DUMMY_SP {\n             DUMMY_SP\n         } else {\n-            Span { hi: span.lo + BytePos(self.delim.len() as u32), ..span }\n+            span.with_lo(span.lo() + BytePos(self.delim.len() as u32))\n         };\n         TokenTree::Token(open_span, self.open_token())\n     }\n@@ -46,7 +46,7 @@ impl Delimited {\n         let close_span = if span == DUMMY_SP {\n             DUMMY_SP\n         } else {\n-            Span { lo: span.hi - BytePos(self.delim.len() as u32), ..span }\n+            span.with_lo(span.hi() - BytePos(self.delim.len() as u32))\n         };\n         TokenTree::Token(close_span, self.close_token())\n     }\n@@ -152,7 +152,7 @@ pub fn parse(input: tokenstream::TokenStream, expect_matchers: bool, sess: &Pars\n                     Some(tokenstream::TokenTree::Token(span, token::Colon)) => match trees.next() {\n                         Some(tokenstream::TokenTree::Token(end_sp, ref tok)) => match tok.ident() {\n                             Some(kind) => {\n-                                let span = Span { lo: start_sp.lo, ..end_sp };\n+                                let span = end_sp.with_lo(start_sp.lo());\n                                 result.push(TokenTree::MetaVarDecl(span, ident, kind));\n                                 continue\n                             }\n@@ -198,7 +198,7 @@ fn parse_tree<I>(tree: tokenstream::TokenTree,\n             }\n             Some(tokenstream::TokenTree::Token(ident_span, ref token)) if token.is_ident() => {\n                 let ident = token.ident().unwrap();\n-                let span = Span { lo: span.lo, ..ident_span };\n+                let span = ident_span.with_lo(span.lo());\n                 if ident.name == keywords::Crate.name() {\n                     let ident = ast::Ident { name: keywords::DollarCrate.name(), ..ident };\n                     TokenTree::Token(span, token::Ident(ident))"}, {"sha": "d51b0d0ae3e939091c18a3c5a0476afc6b41518d", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -155,7 +155,7 @@ pub fn transcribe(cx: &ExtCtxt,\n                         if let NtTT(ref tt) = **nt {\n                             result.push(tt.clone().into());\n                         } else {\n-                            sp.ctxt = sp.ctxt.apply_mark(cx.current_expansion.mark);\n+                            sp = sp.with_ctxt(sp.ctxt().apply_mark(cx.current_expansion.mark));\n                             let token = TokenTree::Token(sp, Token::interpolated((**nt).clone()));\n                             result.push(token.into());\n                         }\n@@ -166,13 +166,13 @@ pub fn transcribe(cx: &ExtCtxt,\n                 } else {\n                     let ident =\n                         Ident { ctxt: ident.ctxt.apply_mark(cx.current_expansion.mark), ..ident };\n-                    sp.ctxt = sp.ctxt.apply_mark(cx.current_expansion.mark);\n+                    sp = sp.with_ctxt(sp.ctxt().apply_mark(cx.current_expansion.mark));\n                     result.push(TokenTree::Token(sp, token::Dollar).into());\n                     result.push(TokenTree::Token(sp, token::Ident(ident)).into());\n                 }\n             }\n             quoted::TokenTree::Delimited(mut span, delimited) => {\n-                span.ctxt = span.ctxt.apply_mark(cx.current_expansion.mark);\n+                span = span.with_ctxt(span.ctxt().apply_mark(cx.current_expansion.mark));\n                 stack.push(Frame::Delimited { forest: delimited, idx: 0, span: span });\n                 result_stack.push(mem::replace(&mut result, Vec::new()));\n             }"}, {"sha": "db49ab1034358787325725168ad91a0524fdc12f", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -230,8 +230,8 @@ impl DiagnosticSpan {\n                       mut backtrace: vec::IntoIter<MacroBacktrace>,\n                       je: &JsonEmitter)\n                       -> DiagnosticSpan {\n-        let start = je.cm.lookup_char_pos(span.lo);\n-        let end = je.cm.lookup_char_pos(span.hi);\n+        let start = je.cm.lookup_char_pos(span.lo());\n+        let end = je.cm.lookup_char_pos(span.hi());\n         let backtrace_step = backtrace.next().map(|bt| {\n             let call_site =\n                 Self::from_span_full(bt.call_site,\n@@ -256,8 +256,8 @@ impl DiagnosticSpan {\n         });\n         DiagnosticSpan {\n             file_name: start.file.name.clone(),\n-            byte_start: span.lo.0 - start.file.start_pos.0,\n-            byte_end: span.hi.0 - start.file.start_pos.0,\n+            byte_start: span.lo().0 - start.file.start_pos.0,\n+            byte_end: span.hi().0 - start.file.start_pos.0,\n             line_start: start.line,\n             line_end: end.line,\n             column_start: start.col.0 + 1,"}, {"sha": "fb558d1a58f85140060ed1ecd95f26d8a93280a3", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -386,7 +386,7 @@ pub fn gather_comments_and_literals(sess: &ParseSess, path: String, srdr: &mut R\n                 debug!(\"tok lit: {}\", s);\n                 literals.push(Literal {\n                     lit: s.to_string(),\n-                    pos: sp.lo,\n+                    pos: sp.lo(),\n                 });\n             })\n         } else {"}, {"sha": "f26a04609054527669f034d689eae36dd0cc2d01", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -71,7 +71,7 @@ pub struct StringReader<'a> {\n \n impl<'a> StringReader<'a> {\n     fn mk_sp(&self, lo: BytePos, hi: BytePos) -> Span {\n-        unwrap_or!(self.override_span, Span { lo: lo, hi: hi, ctxt: NO_EXPANSION})\n+        unwrap_or!(self.override_span, Span::new(lo, hi, NO_EXPANSION))\n     }\n \n     fn next_token(&mut self) -> TokenAndSpan where Self: Sized {\n@@ -190,20 +190,20 @@ impl<'a> StringReader<'a> {\n     }\n \n     pub fn retokenize(sess: &'a ParseSess, mut span: Span) -> Self {\n-        let begin = sess.codemap().lookup_byte_offset(span.lo);\n-        let end = sess.codemap().lookup_byte_offset(span.hi);\n+        let begin = sess.codemap().lookup_byte_offset(span.lo());\n+        let end = sess.codemap().lookup_byte_offset(span.hi());\n \n         // Make the range zero-length if the span is invalid.\n-        if span.lo > span.hi || begin.fm.start_pos != end.fm.start_pos {\n-            span.hi = span.lo;\n+        if span.lo() > span.hi() || begin.fm.start_pos != end.fm.start_pos {\n+            span = span.with_hi(span.lo());\n         }\n \n         let mut sr = StringReader::new_raw_internal(sess, begin.fm);\n \n         // Seek the lexer to the right byte range.\n         sr.save_new_lines_and_multibyte = false;\n-        sr.next_pos = span.lo;\n-        sr.terminator = Some(span.hi);\n+        sr.next_pos = span.lo();\n+        sr.terminator = Some(span.hi());\n \n         sr.bump();\n \n@@ -1745,11 +1745,7 @@ mod tests {\n         let tok1 = string_reader.next_token();\n         let tok2 = TokenAndSpan {\n             tok: token::Ident(id),\n-            sp: Span {\n-                lo: BytePos(21),\n-                hi: BytePos(23),\n-                ctxt: NO_EXPANSION,\n-            },\n+            sp: Span::new(BytePos(21), BytePos(23), NO_EXPANSION),\n         };\n         assert_eq!(tok1, tok2);\n         assert_eq!(string_reader.next_token().tok, token::Whitespace);\n@@ -1759,11 +1755,7 @@ mod tests {\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan {\n             tok: token::Ident(Ident::from_str(\"main\")),\n-            sp: Span {\n-                lo: BytePos(24),\n-                hi: BytePos(28),\n-                ctxt: NO_EXPANSION,\n-            },\n+            sp: Span::new(BytePos(24), BytePos(28), NO_EXPANSION),\n         };\n         assert_eq!(tok3, tok4);\n         // the lparen is already read:\n@@ -1921,7 +1913,7 @@ mod tests {\n         let mut lexer = setup(&cm, &sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n         let comment = lexer.next_token();\n         assert_eq!(comment.tok, token::Comment);\n-        assert_eq!((comment.sp.lo, comment.sp.hi), (BytePos(0), BytePos(7)));\n+        assert_eq!((comment.sp.lo(), comment.sp.hi()), (BytePos(0), BytePos(7)));\n         assert_eq!(lexer.next_token().tok, token::Whitespace);\n         assert_eq!(lexer.next_token().tok,\n                    token::DocComment(Symbol::intern(\"/// test\")));"}, {"sha": "a2c81e2475428e073e04ad837dd1c2483a038896", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -11,7 +11,6 @@\n use print::pprust::token_to_string;\n use parse::lexer::StringReader;\n use parse::{token, PResult};\n-use syntax_pos::Span;\n use tokenstream::{Delimited, TokenStream, TokenTree};\n \n impl<'a> StringReader<'a> {\n@@ -20,7 +19,7 @@ impl<'a> StringReader<'a> {\n         let mut tts = Vec::new();\n         while self.token != token::Eof {\n             let tree = self.parse_token_tree()?;\n-            let is_joint = tree.span().hi == self.span.lo && token::is_op(&self.token);\n+            let is_joint = tree.span().hi() == self.span.lo() && token::is_op(&self.token);\n             tts.push(if is_joint { tree.joint() } else { tree.into() });\n         }\n         Ok(TokenStream::concat(tts))\n@@ -40,7 +39,7 @@ impl<'a> StringReader<'a> {\n                     return TokenStream::concat(tts);\n                 }\n             };\n-            let is_joint = tree.span().hi == self.span.lo && token::is_op(&self.token);\n+            let is_joint = tree.span().hi() == self.span.lo() && token::is_op(&self.token);\n             tts.push(if is_joint { tree.joint() } else { tree.into() });\n         }\n     }\n@@ -69,7 +68,7 @@ impl<'a> StringReader<'a> {\n                 let tts = self.parse_token_trees_until_close_delim();\n \n                 // Expand to cover the entire delimited token tree\n-                let span = Span { hi: self.span.hi, ..pre_span };\n+                let span = pre_span.with_hi(self.span.hi());\n \n                 match self.token {\n                     // Correct delimiter."}, {"sha": "39b5482a066d4fca6d0dbaa83c51ea58545d2edf", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -340,7 +340,7 @@ pub fn check_for_substitution<'a>(reader: &StringReader<'a>,\n     .iter()\n     .find(|&&(c, _, _)| c == ch)\n     .map(|&(_, u_name, ascii_char)| {\n-        let span = Span { lo: reader.pos, hi: reader.next_pos, ctxt: NO_EXPANSION };\n+        let span = Span::new(reader.pos, reader.next_pos, NO_EXPANSION);\n         match ASCII_ARRAY.iter().find(|&&(c, _)| c == ascii_char) {\n             Some(&(ascii_char, ascii_name)) => {\n                 let msg ="}, {"sha": "76a7e2923fc3939c71f5e3add7342330966e399b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -181,7 +181,7 @@ pub fn filemap_to_parser(sess: & ParseSess, filemap: Rc<FileMap>, ) -> Parser {\n     let mut parser = stream_to_parser(sess, filemap_to_stream(sess, filemap, None));\n \n     if parser.token == token::Eof && parser.span == syntax_pos::DUMMY_SP {\n-        parser.span = Span { lo: end_pos, hi: end_pos, ctxt: NO_EXPANSION };\n+        parser.span = Span::new(end_pos, end_pos, NO_EXPANSION);\n     }\n \n     parser\n@@ -661,7 +661,7 @@ mod tests {\n \n     // produce a syntax_pos::span\n     fn sp(a: u32, b: u32) -> Span {\n-        Span {lo: BytePos(a), hi: BytePos(b), ctxt: NO_EXPANSION}\n+        Span::new(BytePos(a), BytePos(b), NO_EXPANSION)\n     }\n \n     fn str2seg(s: &str, lo: u32, hi: u32) -> ast::PathSegment {\n@@ -976,7 +976,7 @@ mod tests {\n \n         for &src in &srcs {\n             let spans = get_spans_of_pat_idents(src);\n-            let Span{ lo, hi, .. } = spans[0];\n+            let (lo, hi) = (spans[0].lo(), spans[0].hi());\n             assert!(\"self\" == &src[lo.to_usize()..hi.to_usize()],\n                     \"\\\"{}\\\" != \\\"self\\\". src=\\\"{}\\\"\",\n                     &src[lo.to_usize()..hi.to_usize()], src)"}, {"sha": "5e05f36345f68c3119ce3c1f5d5018897175066c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -790,9 +790,8 @@ impl<'a> Parser<'a> {\n                 Ok(())\n             }\n             token::AndAnd => {\n-                let span = self.span;\n-                let lo = span.lo + BytePos(1);\n-                Ok(self.bump_with(token::BinOp(token::And), Span { lo: lo, ..span }))\n+                let span = self.span.with_lo(self.span.lo() + BytePos(1));\n+                Ok(self.bump_with(token::BinOp(token::And), span))\n             }\n             _ => self.unexpected()\n         }\n@@ -824,9 +823,8 @@ impl<'a> Parser<'a> {\n                 true\n             }\n             token::BinOp(token::Shl) => {\n-                let span = self.span;\n-                let lo = span.lo + BytePos(1);\n-                self.bump_with(token::Lt, Span { lo: lo, ..span });\n+                let span = self.span.with_lo(self.span.lo() + BytePos(1));\n+                self.bump_with(token::Lt, span);\n                 true\n             }\n             _ => false,\n@@ -852,19 +850,16 @@ impl<'a> Parser<'a> {\n                 Ok(())\n             }\n             token::BinOp(token::Shr) => {\n-                let span = self.span;\n-                let lo = span.lo + BytePos(1);\n-                Ok(self.bump_with(token::Gt, Span { lo: lo, ..span }))\n+                let span = self.span.with_lo(self.span.lo() + BytePos(1));\n+                Ok(self.bump_with(token::Gt, span))\n             }\n             token::BinOpEq(token::Shr) => {\n-                let span = self.span;\n-                let lo = span.lo + BytePos(1);\n-                Ok(self.bump_with(token::Ge, Span { lo: lo, ..span }))\n+                let span = self.span.with_lo(self.span.lo() + BytePos(1));\n+                Ok(self.bump_with(token::Ge, span))\n             }\n             token::Ge => {\n-                let span = self.span;\n-                let lo = span.lo + BytePos(1);\n-                Ok(self.bump_with(token::Eq, Span { lo: lo, ..span }))\n+                let span = self.span.with_lo(self.span.lo() + BytePos(1));\n+                Ok(self.bump_with(token::Eq, span))\n             }\n             _ => self.unexpected()\n         }\n@@ -1094,7 +1089,7 @@ impl<'a> Parser<'a> {\n     /// Advance the parser using provided token as a next one. Use this when\n     /// consuming a part of a token. For example a single `<` from `<<`.\n     pub fn bump_with(&mut self, next: token::Token, span: Span) {\n-        self.prev_span = Span { hi: span.lo, ..self.span };\n+        self.prev_span = self.span.with_hi(span.lo());\n         // It would be incorrect to record the kind of the current token, but\n         // fortunately for tokens currently using `bump_with`, the\n         // prev_token_kind will be of no use anyway.\n@@ -1356,7 +1351,7 @@ impl<'a> Parser<'a> {\n         if self.eat(&token::RArrow) {\n             Ok(FunctionRetTy::Ty(self.parse_ty_no_plus()?))\n         } else {\n-            Ok(FunctionRetTy::Default(Span { hi: self.span.lo, ..self.span }))\n+            Ok(FunctionRetTy::Default(self.span.with_hi(self.span.lo())))\n         }\n     }\n \n@@ -2532,7 +2527,7 @@ impl<'a> Parser<'a> {\n \n     pub fn process_potential_macro_variable(&mut self) {\n         let ident = match self.token {\n-            token::Dollar if self.span.ctxt != syntax_pos::hygiene::SyntaxContext::empty() &&\n+            token::Dollar if self.span.ctxt() != syntax_pos::hygiene::SyntaxContext::empty() &&\n                              self.look_ahead(1, |t| t.is_ident()) => {\n                 self.bump();\n                 let name = match self.token { token::Ident(ident) => ident, _ => unreachable!() };\n@@ -2734,8 +2729,8 @@ impl<'a> Parser<'a> {\n                         err.span_label(self.span,\n                                        \"expecting a type here because of type ascription\");\n                         let cm = self.sess.codemap();\n-                        let cur_pos = cm.lookup_char_pos(self.span.lo);\n-                        let op_pos = cm.lookup_char_pos(cur_op_span.hi);\n+                        let cur_pos = cm.lookup_char_pos(self.span.lo());\n+                        let op_pos = cm.lookup_char_pos(cur_op_span.hi());\n                         if cur_pos.line != op_pos.line {\n                             err.span_suggestion_short(cur_op_span,\n                                                       \"did you mean to use `;` here?\",\n@@ -4056,7 +4051,7 @@ impl<'a> Parser<'a> {\n                     let mut stmt_span = stmt.span;\n                     // expand the span to include the semicolon, if it exists\n                     if self.eat(&token::Semi) {\n-                        stmt_span.hi = self.prev_span.hi;\n+                        stmt_span = stmt_span.with_hi(self.prev_span.hi());\n                     }\n                     let sugg = pprust::to_string(|s| {\n                         use print::pprust::{PrintState, INDENT_UNIT};\n@@ -4148,7 +4143,7 @@ impl<'a> Parser<'a> {\n             stmt = stmt.add_trailing_semicolon();\n         }\n \n-        stmt.span.hi = self.prev_span.hi;\n+        stmt.span = stmt.span.with_hi(self.prev_span.hi());\n         Ok(Some(stmt))\n     }\n "}, {"sha": "3b5ec1caf0de93616bd6c74794a0a9a85518b712", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -603,8 +603,8 @@ pub trait PrintState<'a> {\n     }\n \n     fn print_literal(&mut self, lit: &ast::Lit) -> io::Result<()> {\n-        self.maybe_print_comment(lit.span.lo)?;\n-        if let Some(ltrl) = self.next_lit(lit.span.lo) {\n+        self.maybe_print_comment(lit.span.lo())?;\n+        if let Some(ltrl) = self.next_lit(lit.span.lo()) {\n             return self.writer().word(&ltrl.lit);\n         }\n         match lit.node {\n@@ -723,7 +723,7 @@ pub trait PrintState<'a> {\n         if !is_inline {\n             self.hardbreak_if_not_bol()?;\n         }\n-        self.maybe_print_comment(attr.span.lo)?;\n+        self.maybe_print_comment(attr.span.lo())?;\n         if attr.is_sugared_doc {\n             self.writer().word(&attr.value_str().unwrap().as_str())?;\n             self.writer().hardbreak()\n@@ -892,7 +892,7 @@ impl<'a> State<'a> {\n     }\n     pub fn bclose_maybe_open(&mut self, span: syntax_pos::Span,\n                              indented: usize, close_box: bool) -> io::Result<()> {\n-        self.maybe_print_comment(span.hi)?;\n+        self.maybe_print_comment(span.hi())?;\n         self.break_offset_if_not_bol(1, -(indented as isize))?;\n         self.s.word(\"}\")?;\n         if close_box {\n@@ -950,13 +950,13 @@ impl<'a> State<'a> {\n         let len = elts.len();\n         let mut i = 0;\n         for elt in elts {\n-            self.maybe_print_comment(get_span(elt).hi)?;\n+            self.maybe_print_comment(get_span(elt).hi())?;\n             op(self, elt)?;\n             i += 1;\n             if i < len {\n                 self.s.word(\",\")?;\n                 self.maybe_print_trailing_comment(get_span(elt),\n-                                                  Some(get_span(&elts[i]).hi))?;\n+                                                  Some(get_span(&elts[i]).hi()))?;\n                 self.space_if_not_bol()?;\n             }\n         }\n@@ -996,7 +996,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_type(&mut self, ty: &ast::Ty) -> io::Result<()> {\n-        self.maybe_print_comment(ty.span.lo)?;\n+        self.maybe_print_comment(ty.span.lo())?;\n         self.ibox(0)?;\n         match ty.node {\n             ast::TyKind::Slice(ref ty) => {\n@@ -1094,7 +1094,7 @@ impl<'a> State<'a> {\n     pub fn print_foreign_item(&mut self,\n                               item: &ast::ForeignItem) -> io::Result<()> {\n         self.hardbreak_if_not_bol()?;\n-        self.maybe_print_comment(item.span.lo)?;\n+        self.maybe_print_comment(item.span.lo())?;\n         self.print_outer_attributes(&item.attrs)?;\n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n@@ -1163,7 +1163,7 @@ impl<'a> State<'a> {\n     /// Pretty-print an item\n     pub fn print_item(&mut self, item: &ast::Item) -> io::Result<()> {\n         self.hardbreak_if_not_bol()?;\n-        self.maybe_print_comment(item.span.lo)?;\n+        self.maybe_print_comment(item.span.lo())?;\n         self.print_outer_attributes(&item.attrs)?;\n         self.ann.pre(self, NodeItem(item))?;\n         match item.node {\n@@ -1433,7 +1433,7 @@ impl<'a> State<'a> {\n         self.bopen()?;\n         for v in variants {\n             self.space_if_not_bol()?;\n-            self.maybe_print_comment(v.span.lo)?;\n+            self.maybe_print_comment(v.span.lo())?;\n             self.print_outer_attributes(&v.node.attrs)?;\n             self.ibox(INDENT_UNIT)?;\n             self.print_variant(v)?;\n@@ -1481,7 +1481,7 @@ impl<'a> State<'a> {\n                 self.commasep(\n                     Inconsistent, struct_def.fields(),\n                     |s, field| {\n-                        s.maybe_print_comment(field.span.lo)?;\n+                        s.maybe_print_comment(field.span.lo())?;\n                         s.print_outer_attributes(&field.attrs)?;\n                         s.print_visibility(&field.vis)?;\n                         s.print_type(&field.ty)\n@@ -1503,7 +1503,7 @@ impl<'a> State<'a> {\n \n             for field in struct_def.fields() {\n                 self.hardbreak_if_not_bol()?;\n-                self.maybe_print_comment(field.span.lo)?;\n+                self.maybe_print_comment(field.span.lo())?;\n                 self.print_outer_attributes(&field.attrs)?;\n                 self.print_visibility(&field.vis)?;\n                 self.print_ident(field.ident.unwrap())?;\n@@ -1548,7 +1548,7 @@ impl<'a> State<'a> {\n                             -> io::Result<()> {\n         self.ann.pre(self, NodeSubItem(ti.id))?;\n         self.hardbreak_if_not_bol()?;\n-        self.maybe_print_comment(ti.span.lo)?;\n+        self.maybe_print_comment(ti.span.lo())?;\n         self.print_outer_attributes(&ti.attrs)?;\n         match ti.node {\n             ast::TraitItemKind::Const(ref ty, ref default) => {\n@@ -1590,7 +1590,7 @@ impl<'a> State<'a> {\n     pub fn print_impl_item(&mut self, ii: &ast::ImplItem) -> io::Result<()> {\n         self.ann.pre(self, NodeSubItem(ii.id))?;\n         self.hardbreak_if_not_bol()?;\n-        self.maybe_print_comment(ii.span.lo)?;\n+        self.maybe_print_comment(ii.span.lo())?;\n         self.print_outer_attributes(&ii.attrs)?;\n         self.print_defaultness(ii.defaultness)?;\n         match ii.node {\n@@ -1622,7 +1622,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_stmt(&mut self, st: &ast::Stmt) -> io::Result<()> {\n-        self.maybe_print_comment(st.span.lo)?;\n+        self.maybe_print_comment(st.span.lo())?;\n         match st.node {\n             ast::StmtKind::Local(ref loc) => {\n                 self.print_outer_attributes(&loc.attrs)?;\n@@ -1705,7 +1705,7 @@ impl<'a> State<'a> {\n             BlockCheckMode::Unsafe(..) => self.word_space(\"unsafe\")?,\n             BlockCheckMode::Default => ()\n         }\n-        self.maybe_print_comment(blk.span.lo)?;\n+        self.maybe_print_comment(blk.span.lo())?;\n         self.ann.pre(self, NodeBlock(blk))?;\n         self.bopen()?;\n \n@@ -1714,10 +1714,10 @@ impl<'a> State<'a> {\n         for (i, st) in blk.stmts.iter().enumerate() {\n             match st.node {\n                 ast::StmtKind::Expr(ref expr) if i == blk.stmts.len() - 1 => {\n-                    self.maybe_print_comment(st.span.lo)?;\n+                    self.maybe_print_comment(st.span.lo())?;\n                     self.space_if_not_bol()?;\n                     self.print_expr_outer_attr_style(expr, false)?;\n-                    self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi))?;\n+                    self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi()))?;\n                 }\n                 _ => self.print_stmt(st)?,\n             }\n@@ -1988,7 +1988,7 @@ impl<'a> State<'a> {\n     fn print_expr_outer_attr_style(&mut self,\n                                   expr: &ast::Expr,\n                                   is_inline: bool) -> io::Result<()> {\n-        self.maybe_print_comment(expr.span.lo)?;\n+        self.maybe_print_comment(expr.span.lo())?;\n \n         let attrs = &expr.attrs;\n         if is_inline {\n@@ -2343,7 +2343,7 @@ impl<'a> State<'a> {\n                   defaults_to_global: bool)\n                   -> io::Result<()>\n     {\n-        self.maybe_print_comment(path.span.lo)?;\n+        self.maybe_print_comment(path.span.lo())?;\n \n         let mut segments = path.segments[..path.segments.len()-depth].iter();\n         if defaults_to_global && path.is_global() {\n@@ -2465,7 +2465,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_pat(&mut self, pat: &ast::Pat) -> io::Result<()> {\n-        self.maybe_print_comment(pat.span.lo)?;\n+        self.maybe_print_comment(pat.span.lo())?;\n         self.ann.pre(self, NodePat(pat))?;\n         /* Pat isn't normalized, but the beauty of it\n          is that it doesn't matter */\n@@ -2607,7 +2607,7 @@ impl<'a> State<'a> {\n         }\n         self.cbox(INDENT_UNIT)?;\n         self.ibox(0)?;\n-        self.maybe_print_comment(arm.pats[0].span.lo)?;\n+        self.maybe_print_comment(arm.pats[0].span.lo())?;\n         self.print_outer_attributes(&arm.attrs)?;\n         let mut first = true;\n         for p in &arm.pats {\n@@ -2715,7 +2715,7 @@ impl<'a> State<'a> {\n         match decl.output {\n             ast::FunctionRetTy::Ty(ref ty) => {\n                 self.print_type(ty)?;\n-                self.maybe_print_comment(ty.span.lo)\n+                self.maybe_print_comment(ty.span.lo())\n             }\n             ast::FunctionRetTy::Default(..) => unreachable!(),\n         }\n@@ -2971,7 +2971,7 @@ impl<'a> State<'a> {\n         self.end()?;\n \n         match decl.output {\n-            ast::FunctionRetTy::Ty(ref output) => self.maybe_print_comment(output.span.lo),\n+            ast::FunctionRetTy::Ty(ref output) => self.maybe_print_comment(output.span.lo()),\n             _ => Ok(())\n         }\n     }\n@@ -3017,10 +3017,10 @@ impl<'a> State<'a> {\n         };\n         if let Some(ref cmnt) = self.next_comment() {\n             if cmnt.style != comments::Trailing { return Ok(()) }\n-            let span_line = cm.lookup_char_pos(span.hi);\n+            let span_line = cm.lookup_char_pos(span.hi());\n             let comment_line = cm.lookup_char_pos(cmnt.pos);\n             let next = next_pos.unwrap_or(cmnt.pos + BytePos(1));\n-            if span.hi < cmnt.pos && cmnt.pos < next && span_line.line == comment_line.line {\n+            if span.hi() < cmnt.pos && cmnt.pos < next && span_line.line == comment_line.line {\n                 self.print_comment(cmnt)?;\n             }\n         }"}, {"sha": "7aa94de9d3d5bde02b724c5a9fcfa4469c71d10b", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -31,7 +31,7 @@ fn ignored_span(sp: Span) -> Span {\n             allow_internal_unsafe: false,\n         }\n     });\n-    Span { ctxt: SyntaxContext::empty().apply_mark(mark), ..sp }\n+    sp.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n }\n \n pub fn injected_crate_name(krate: &ast::Crate) -> Option<&'static str> {"}, {"sha": "5a5a1ce3777e69741910b13f348d23e19d4d2256", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -306,7 +306,7 @@ fn generate_test_harness(sess: &ParseSess,\n /// call to codemap's `is_internal` check.\n /// The expanded code calls some unstable functions in the test crate.\n fn ignored_span(cx: &TestCtxt, sp: Span) -> Span {\n-    Span { ctxt: cx.ctxt, ..sp }\n+    sp.with_ctxt(cx.ctxt)\n }\n \n #[derive(PartialEq)]"}, {"sha": "e9b1976ea472b734ce83bd516e3bb2a1ded3f4cd", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -80,11 +80,7 @@ fn make_span(file_text: &str, start: &Position, end: &Position) -> Span {\n     let start = make_pos(file_text, start);\n     let end = make_pos(file_text, end) + end.string.len(); // just after matching thing ends\n     assert!(start <= end);\n-    Span {\n-        lo: BytePos(start as u32),\n-        hi: BytePos(end as u32),\n-        ctxt: NO_EXPANSION,\n-    }\n+    Span::new(BytePos(start as u32), BytePos(end as u32), NO_EXPANSION)\n }\n \n fn make_pos(file_text: &str, pos: &Position) -> usize {"}, {"sha": "870f54e4396aff5d4224ded8629360d79e086f4b", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -59,7 +59,7 @@ impl Delimited {\n         let open_span = if span == DUMMY_SP {\n             DUMMY_SP\n         } else {\n-            Span { hi: span.lo + BytePos(self.delim.len() as u32), ..span }\n+            span.with_hi(span.lo() + BytePos(self.delim.len() as u32))\n         };\n         TokenTree::Token(open_span, self.open_token())\n     }\n@@ -69,7 +69,7 @@ impl Delimited {\n         let close_span = if span == DUMMY_SP {\n             DUMMY_SP\n         } else {\n-            Span { lo: span.hi - BytePos(self.delim.len() as u32), ..span }\n+            span.with_lo(span.hi() - BytePos(self.delim.len() as u32))\n         };\n         TokenTree::Token(close_span, self.close_token())\n     }\n@@ -602,11 +602,7 @@ mod tests {\n     }\n \n     fn sp(a: u32, b: u32) -> Span {\n-        Span {\n-            lo: BytePos(a),\n-            hi: BytePos(b),\n-            ctxt: NO_EXPANSION,\n-        }\n+        Span::new(BytePos(a), BytePos(b), NO_EXPANSION)\n     }\n \n     #[test]"}, {"sha": "5d93c2a5f72a196898ccc4a9cb5cda969e29d665", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -111,7 +111,7 @@ fn cs_clone_shallow(name: &str,\n                         ty: P<ast::Ty>, span: Span, helper_name: &str) {\n         // Generate statement `let _: helper_name<ty>;`,\n         // set the expn ID so we can use the unstable struct.\n-        let span = Span { ctxt: cx.backtrace(), ..span};\n+        let span = span.with_ctxt(cx.backtrace());\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[\"clone\", helper_name]),\n                                         vec![], vec![ty], vec![]);"}, {"sha": "a282ff5bd045fff5ad3f1efd26916e7fba4ac802", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -58,7 +58,7 @@ fn cs_total_eq_assert(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                         ty: P<ast::Ty>, span: Span, helper_name: &str) {\n         // Generate statement `let _: helper_name<ty>;`,\n         // set the expn ID so we can use the unstable struct.\n-        let span = Span { ctxt: cx.backtrace(), ..span };\n+        let span = span.with_ctxt(cx.backtrace());\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[\"cmp\", helper_name]),\n                                         vec![], vec![ty], vec![]);"}, {"sha": "ab6dd04520c1b2f570d0acc6f0c82f445ff5dfe9", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -67,7 +67,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n     };\n \n     // We want to make sure we have the ctxt set so that we can use unstable methods\n-    let span = Span { ctxt: cx.backtrace(), ..span };\n+    let span = span.with_ctxt(cx.backtrace());\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n     let builder = Ident::from_str(\"builder\");\n     let builder_expr = cx.expr_ident(span, builder.clone());"}, {"sha": "d701810e2e9f2fd9b025ae7db0c4326038beb8d4", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -375,7 +375,7 @@ fn find_type_parameters(ty: &ast::Ty,\n         }\n \n         fn visit_mac(&mut self, mac: &ast::Mac) {\n-            let span = Span { ctxt: self.span.ctxt, ..mac.span };\n+            let span = mac.span.with_ctxt(self.span.ctxt());\n             self.cx.span_err(span, \"`derive` cannot be used on items with type macros\");\n         }\n     }\n@@ -1464,7 +1464,7 @@ impl<'a> MethodDef<'a> {\n             .iter()\n             .map(|v| {\n                 let ident = v.node.name;\n-                let sp = Span { ctxt: trait_.span.ctxt, ..v.span };\n+                let sp = v.span.with_ctxt(trait_.span.ctxt());\n                 let summary = trait_.summarise_struct(cx, &v.node.data);\n                 (ident, sp, summary)\n             })\n@@ -1484,7 +1484,7 @@ impl<'a> TraitDef<'a> {\n         let mut named_idents = Vec::new();\n         let mut just_spans = Vec::new();\n         for field in struct_def.fields() {\n-            let sp = Span { ctxt: self.span.ctxt, ..field.span };\n+            let sp = field.span.with_ctxt(self.span.ctxt());\n             match field.ident {\n                 Some(ident) => named_idents.push((ident, sp)),\n                 _ => just_spans.push(sp),\n@@ -1529,7 +1529,7 @@ impl<'a> TraitDef<'a> {\n         let mut paths = Vec::new();\n         let mut ident_exprs = Vec::new();\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n-            let sp = Span { ctxt: self.span.ctxt, ..struct_field.span };\n+            let sp = struct_field.span.with_ctxt(self.span.ctxt());\n             let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i));\n             paths.push(codemap::Spanned {\n                 span: sp,\n@@ -1550,7 +1550,7 @@ impl<'a> TraitDef<'a> {\n                             cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n                         }\n                         codemap::Spanned {\n-                            span: Span { ctxt: self.span.ctxt, ..pat.span },\n+                            span: pat.span.with_ctxt(self.span.ctxt()),\n                             node: ast::FieldPat {\n                                 ident: ident.unwrap(),\n                                 pat,\n@@ -1582,7 +1582,7 @@ impl<'a> TraitDef<'a> {\n          mutbl: ast::Mutability)\n          -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n         let variant_ident = variant.node.name;\n-        let sp = Span { ctxt: self.span.ctxt, ..variant.span };\n+        let sp = variant.span.with_ctxt(self.span.ctxt());\n         let variant_path = cx.path(sp, vec![enum_ident, variant_ident]);\n         self.create_struct_pattern(cx, variant_path, &variant.node.data, prefix, mutbl)\n     }"}, {"sha": "ccf3d5502341f1af99a62061decd9f8d5016acd0", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -158,13 +158,13 @@ fn call_intrinsic(cx: &ExtCtxt,\n                   args: Vec<P<ast::Expr>>)\n                   -> P<ast::Expr> {\n     if cx.current_expansion.mark.expn_info().unwrap().callee.allow_internal_unstable {\n-        span.ctxt = cx.backtrace();\n+        span = span.with_ctxt(cx.backtrace());\n     } else { // Avoid instability errors with user defined curstom derives, cc #36316\n         let mut info = cx.current_expansion.mark.expn_info().unwrap();\n         info.callee.allow_internal_unstable = true;\n         let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(info);\n-        span.ctxt = SyntaxContext::empty().apply_mark(mark);\n+        span = span.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n     }\n     let path = cx.std_path(&[\"intrinsics\", intrinsic]);\n     let call = cx.expr_call_global(span, path, args);"}, {"sha": "3e20bc481bde8a5083fadaffd0adfb48fd35ed7f", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -558,10 +558,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         // passed to this function.\n         for (i, e) in self.args.into_iter().enumerate() {\n             let name = self.ecx.ident_of(&format!(\"__arg{}\", i));\n-            let span = Span {\n-                ctxt: e.span.ctxt.apply_mark(self.ecx.current_expansion.mark),\n-                ..DUMMY_SP\n-            };\n+            let span =\n+                DUMMY_SP.with_ctxt(e.span.ctxt().apply_mark(self.ecx.current_expansion.mark));\n             pats.push(self.ecx.pat_ident(span, name));\n             for ref arg_ty in self.arg_unique_types[i].iter() {\n                 locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty, name));\n@@ -642,7 +640,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                   ty: &ArgumentType,\n                   arg: ast::Ident)\n                   -> P<ast::Expr> {\n-        sp.ctxt = sp.ctxt.apply_mark(ecx.current_expansion.mark);\n+        sp = sp.with_ctxt(sp.ctxt().apply_mark(ecx.current_expansion.mark));\n         let arg = ecx.expr_ident(sp, arg);\n         let trait_ = match *ty {\n             Placeholder(ref tyname) => {\n@@ -679,7 +677,7 @@ pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt,\n                                mut sp: Span,\n                                tts: &[tokenstream::TokenTree])\n                                -> Box<base::MacResult + 'cx> {\n-    sp.ctxt = sp.ctxt.apply_mark(ecx.current_expansion.mark);\n+    sp = sp.with_ctxt(sp.ctxt().apply_mark(ecx.current_expansion.mark));\n     match parse_args(ecx, sp, tts) {\n         Some((efmt, args, names)) => {\n             MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt, args, names))\n@@ -701,7 +699,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     let arg_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let mut macsp = ecx.call_site();\n-    macsp.ctxt = macsp.ctxt.apply_mark(ecx.current_expansion.mark);\n+    macsp = macsp.with_ctxt(macsp.ctxt().apply_mark(ecx.current_expansion.mark));\n     let msg = \"format argument must be a string literal.\";\n     let fmt = match expr_to_spanned_string(ecx, efmt, msg) {\n         Some(fmt) => fmt,"}, {"sha": "a58d2c96388ca2f3f6c7ae4b1f3e072533f6b21a", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -371,7 +371,7 @@ fn mk_registrar(cx: &mut ExtCtxt,\n             allow_internal_unsafe: false,\n         }\n     });\n-    let span = Span { ctxt: SyntaxContext::empty().apply_mark(mark), ..DUMMY_SP };\n+    let span = DUMMY_SP.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n \n     let proc_macro = Ident::from_str(\"proc_macro\");\n     let krate = cx.item(span,"}, {"sha": "231f3062f08d4007916a8879007a00895e4e1bd7", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 69, "deletions": 51, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -60,13 +60,15 @@ pub type FileName = String;\n /// range between files.\n #[derive(Clone, Copy, Hash, PartialEq, Eq, Ord, PartialOrd)]\n pub struct Span {\n-    pub lo: BytePos,\n-    pub hi: BytePos,\n+    lo: BytePos,\n+    hi: BytePos,\n     /// Information about where the macro came from, if this piece of\n     /// code was created by a macro expansion.\n-    pub ctxt: SyntaxContext,\n+    ctxt: SyntaxContext,\n }\n \n+pub const DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), ctxt: NO_EXPANSION };\n+\n /// A collection of spans. Spans have two orthogonal attributes:\n ///\n /// - they can be *primary spans*. In this case they are the locus of\n@@ -80,16 +82,46 @@ pub struct MultiSpan {\n }\n \n impl Span {\n+    #[inline]\n+    pub fn new(lo: BytePos, hi: BytePos, ctxt: SyntaxContext) -> Self {\n+        Span { lo, hi, ctxt }\n+    }\n+\n+    #[inline]\n+    pub fn lo(self) -> BytePos {\n+        self.lo\n+    }\n+    #[inline]\n+    pub fn with_lo(self, lo: BytePos) -> Span {\n+        Span::new(lo, self.hi(), self.ctxt())\n+    }\n+    #[inline]\n+    pub fn hi(self) -> BytePos {\n+        self.hi\n+    }\n+    #[inline]\n+    pub fn with_hi(self, hi: BytePos) -> Span {\n+        Span::new(self.lo(), hi, self.ctxt())\n+    }\n+    #[inline]\n+    pub fn ctxt(self) -> SyntaxContext {\n+        self.ctxt\n+    }\n+    #[inline]\n+    pub fn with_ctxt(self, ctxt: SyntaxContext) -> Span {\n+        Span::new(self.lo(), self.hi(), ctxt)\n+    }\n+\n     /// Returns a new span representing just the end-point of this span\n     pub fn end_point(self) -> Span {\n-        let lo = cmp::max(self.hi.0 - 1, self.lo.0);\n-        Span { lo: BytePos(lo), ..self }\n+        let lo = cmp::max(self.hi().0 - 1, self.lo().0);\n+        self.with_lo(BytePos(lo))\n     }\n \n     /// Returns a new span representing the next character after the end-point of this span\n     pub fn next_point(self) -> Span {\n-        let lo = cmp::max(self.hi.0, self.lo.0 + 1);\n-        Span { lo: BytePos(lo), hi: BytePos(lo), ..self }\n+        let lo = cmp::max(self.hi().0, self.lo().0 + 1);\n+        Span::new(BytePos(lo), BytePos(lo), self.ctxt())\n     }\n \n     /// Returns `self` if `self` is not the dummy span, and `other` otherwise.\n@@ -99,21 +131,21 @@ impl Span {\n \n     /// Return true if `self` fully encloses `other`.\n     pub fn contains(self, other: Span) -> bool {\n-        self.lo <= other.lo && other.hi <= self.hi\n+        self.lo() <= other.lo() && other.hi() <= self.hi()\n     }\n \n     /// Return true if the spans are equal with regards to the source text.\n     ///\n     /// Use this instead of `==` when either span could be generated code,\n     /// and you only care that they point to the same bytes of source text.\n     pub fn source_equal(&self, other: &Span) -> bool {\n-        self.lo == other.lo && self.hi == other.hi\n+        self.lo() == other.lo() && self.hi() == other.hi()\n     }\n \n     /// Returns `Some(span)`, where the start is trimmed by the end of `other`\n     pub fn trim_start(self, other: Span) -> Option<Span> {\n-        if self.hi > other.hi {\n-            Some(Span { lo: cmp::max(self.lo, other.hi), .. self })\n+        if self.hi() > other.hi() {\n+            Some(self.with_lo(cmp::max(self.lo(), other.hi())))\n         } else {\n             None\n         }\n@@ -122,7 +154,7 @@ impl Span {\n     /// Return the source span - this is either the supplied span, or the span for\n     /// the macro callsite that expanded to it.\n     pub fn source_callsite(self) -> Span {\n-        self.ctxt.outer().expn_info().map(|info| info.call_site.source_callsite()).unwrap_or(self)\n+        self.ctxt().outer().expn_info().map(|info| info.call_site.source_callsite()).unwrap_or(self)\n     }\n \n     /// Return the source callee.\n@@ -132,27 +164,27 @@ impl Span {\n     /// corresponding to the source callsite.\n     pub fn source_callee(self) -> Option<NameAndSpan> {\n         fn source_callee(info: ExpnInfo) -> NameAndSpan {\n-            match info.call_site.ctxt.outer().expn_info() {\n+            match info.call_site.ctxt().outer().expn_info() {\n                 Some(info) => source_callee(info),\n                 None => info.callee,\n             }\n         }\n-        self.ctxt.outer().expn_info().map(source_callee)\n+        self.ctxt().outer().expn_info().map(source_callee)\n     }\n \n     /// Check if a span is \"internal\" to a macro in which #[unstable]\n     /// items can be used (that is, a macro marked with\n     /// `#[allow_internal_unstable]`).\n     pub fn allows_unstable(&self) -> bool {\n-        match self.ctxt.outer().expn_info() {\n+        match self.ctxt().outer().expn_info() {\n             Some(info) => info.callee.allow_internal_unstable,\n             None => false,\n         }\n     }\n \n     /// Check if this span arises from a compiler desugaring of kind `kind`.\n     pub fn is_compiler_desugaring(&self, kind: CompilerDesugaringKind) -> bool {\n-        match self.ctxt.outer().expn_info() {\n+        match self.ctxt().outer().expn_info() {\n             Some(info) => match info.callee.format {\n                 ExpnFormat::CompilerDesugaring(k) => k == kind,\n                 _ => false,\n@@ -165,7 +197,7 @@ impl Span {\n     /// can be used without triggering the `unsafe_code` lint\n     //  (that is, a macro marked with `#[allow_internal_unsafe]`).\n     pub fn allows_unsafe(&self) -> bool {\n-        match self.ctxt.outer().expn_info() {\n+        match self.ctxt().outer().expn_info() {\n             Some(info) => info.callee.allow_internal_unsafe,\n             None => false,\n         }\n@@ -175,7 +207,7 @@ impl Span {\n         let mut prev_span = DUMMY_SP;\n         let mut result = vec![];\n         loop {\n-            let info = match self.ctxt.outer().expn_info() {\n+            let info = match self.ctxt().outer().expn_info() {\n                 Some(info) => info,\n                 None => break,\n             };\n@@ -205,42 +237,30 @@ impl Span {\n \n     /// Return a `Span` that would enclose both `self` and `end`.\n     pub fn to(self, end: Span) -> Span {\n-        Span {\n-            lo: cmp::min(self.lo, end.lo),\n-            hi: cmp::max(self.hi, end.hi),\n+        Span::new(\n+            cmp::min(self.lo(), end.lo()),\n+            cmp::max(self.hi(), end.hi()),\n             // FIXME(jseyfried): self.ctxt should always equal end.ctxt here (c.f. issue #23480)\n-            ctxt: if self.ctxt == SyntaxContext::empty() {\n-                end.ctxt\n-            } else {\n-                self.ctxt\n-            },\n-        }\n+            if self.ctxt() == SyntaxContext::empty() { end.ctxt() } else { self.ctxt() },\n+        )\n     }\n \n     /// Return a `Span` between the end of `self` to the beginning of `end`.\n     pub fn between(self, end: Span) -> Span {\n-        Span {\n-            lo: self.hi,\n-            hi: end.lo,\n-            ctxt: if end.ctxt == SyntaxContext::empty() {\n-                end.ctxt\n-            } else {\n-                self.ctxt\n-            }\n-        }\n+        Span::new(\n+            self.hi(),\n+            end.lo(),\n+            if end.ctxt() == SyntaxContext::empty() { end.ctxt() } else { self.ctxt() },\n+        )\n     }\n \n     /// Return a `Span` between the beginning of `self` to the beginning of `end`.\n     pub fn until(self, end: Span) -> Span {\n-        Span {\n-            lo: self.lo,\n-            hi: end.lo,\n-            ctxt: if end.ctxt == SyntaxContext::empty() {\n-                end.ctxt\n-            } else {\n-                self.ctxt\n-            }\n-        }\n+        Span::new(\n+            self.lo(),\n+            end.lo(),\n+            if end.ctxt() == SyntaxContext::empty() { end.ctxt() } else { self.ctxt() },\n+        )\n     }\n }\n \n@@ -267,11 +287,11 @@ impl serialize::UseSpecializedEncodable for Span {\n     fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_struct(\"Span\", 2, |s| {\n             s.emit_struct_field(\"lo\", 0, |s| {\n-                self.lo.encode(s)\n+                self.lo().encode(s)\n             })?;\n \n             s.emit_struct_field(\"hi\", 1, |s| {\n-                self.hi.encode(s)\n+                self.hi().encode(s)\n             })\n         })\n     }\n@@ -282,14 +302,14 @@ impl serialize::UseSpecializedDecodable for Span {\n         d.read_struct(\"Span\", 2, |d| {\n             let lo = d.read_struct_field(\"lo\", 0, Decodable::decode)?;\n             let hi = d.read_struct_field(\"hi\", 1, Decodable::decode)?;\n-            Ok(Span { lo: lo, hi: hi, ctxt: NO_EXPANSION })\n+            Ok(Span::new(lo, hi, NO_EXPANSION))\n         })\n     }\n }\n \n fn default_span_debug(span: Span, f: &mut fmt::Formatter) -> fmt::Result {\n     write!(f, \"Span {{ lo: {:?}, hi: {:?}, ctxt: {:?} }}\",\n-           span.lo, span.hi, span.ctxt)\n+           span.lo(), span.hi(), span.ctxt())\n }\n \n impl fmt::Debug for Span {\n@@ -298,8 +318,6 @@ impl fmt::Debug for Span {\n     }\n }\n \n-pub const DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), ctxt: NO_EXPANSION };\n-\n impl MultiSpan {\n     pub fn new() -> MultiSpan {\n         MultiSpan {"}, {"sha": "2f80a0954dc0a2c3f67782eeeb38985cb498cdc5", "filename": "src/test/run-pass/import-crate-with-invalid-spans/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Ftest%2Frun-pass%2Fimport-crate-with-invalid-spans%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3da868dcb67e85ccbd6d64cdcc29829b1399de15/src%2Ftest%2Frun-pass%2Fimport-crate-with-invalid-spans%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-crate-with-invalid-spans%2Fmain.rs?ref=3da868dcb67e85ccbd6d64cdcc29829b1399de15", "patch": "@@ -16,7 +16,7 @@ extern crate crate_with_invalid_spans;\n \n fn main() {\n     // The AST of `exported_generic` stored in crate_with_invalid_spans's\n-    // metadata should contain an invalid span where span.lo > span.hi.\n+    // metadata should contain an invalid span where span.lo() > span.hi().\n     // Let's make sure the compiler doesn't crash when encountering this.\n     let _ = crate_with_invalid_spans::exported_generic(32u32, 7u32);\n }"}]}