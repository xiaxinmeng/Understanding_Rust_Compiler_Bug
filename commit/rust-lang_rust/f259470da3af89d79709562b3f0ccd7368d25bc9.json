{"sha": "f259470da3af89d79709562b3f0ccd7368d25bc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyNTk0NzBkYTNhZjg5ZDc5NzA5NTYyYjNmMGNjZDczNjhkMjViYzk=", "commit": {"author": {"name": "Ana-Maria Mihalache", "email": "mihalacheana.maria@yahoo.com", "date": "2020-03-31T13:44:52Z"}, "committer": {"name": "Ana-Maria Mihalache", "email": "mihalacheana.maria@yahoo.com", "date": "2020-03-31T13:44:52Z"}, "message": "rustc_target::abi: rename FieldPlacement to FieldsShape.", "tree": {"sha": "315e1e01bb119760e7f119c4a9fa8798c2ed059c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/315e1e01bb119760e7f119c4a9fa8798c2ed059c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f259470da3af89d79709562b3f0ccd7368d25bc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f259470da3af89d79709562b3f0ccd7368d25bc9", "html_url": "https://github.com/rust-lang/rust/commit/f259470da3af89d79709562b3f0ccd7368d25bc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f259470da3af89d79709562b3f0ccd7368d25bc9/comments", "author": {"login": "anyska", "id": 13694484, "node_id": "MDQ6VXNlcjEzNjk0NDg0", "avatar_url": "https://avatars.githubusercontent.com/u/13694484?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anyska", "html_url": "https://github.com/anyska", "followers_url": "https://api.github.com/users/anyska/followers", "following_url": "https://api.github.com/users/anyska/following{/other_user}", "gists_url": "https://api.github.com/users/anyska/gists{/gist_id}", "starred_url": "https://api.github.com/users/anyska/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anyska/subscriptions", "organizations_url": "https://api.github.com/users/anyska/orgs", "repos_url": "https://api.github.com/users/anyska/repos", "events_url": "https://api.github.com/users/anyska/events{/privacy}", "received_events_url": "https://api.github.com/users/anyska/received_events", "type": "User", "site_admin": false}, "committer": {"login": "anyska", "id": 13694484, "node_id": "MDQ6VXNlcjEzNjk0NDg0", "avatar_url": "https://avatars.githubusercontent.com/u/13694484?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anyska", "html_url": "https://github.com/anyska", "followers_url": "https://api.github.com/users/anyska/followers", "following_url": "https://api.github.com/users/anyska/following{/other_user}", "gists_url": "https://api.github.com/users/anyska/gists{/gist_id}", "starred_url": "https://api.github.com/users/anyska/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anyska/subscriptions", "organizations_url": "https://api.github.com/users/anyska/orgs", "repos_url": "https://api.github.com/users/anyska/repos", "events_url": "https://api.github.com/users/anyska/events{/privacy}", "received_events_url": "https://api.github.com/users/anyska/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2113659479a82ea69633b23ef710b58ab127755e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2113659479a82ea69633b23ef710b58ab127755e", "html_url": "https://github.com/rust-lang/rust/commit/2113659479a82ea69633b23ef710b58ab127755e"}], "stats": {"total": 128, "additions": 64, "deletions": 64}, "files": [{"sha": "6501ba031e44507a97f096a8172ecbe6655570fa", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=f259470da3af89d79709562b3f0ccd7368d25bc9", "patch": "@@ -79,7 +79,7 @@ fn uncached_llvm_type<'a, 'tcx>(\n     };\n \n     match layout.fields {\n-        layout::FieldPlacement::Union(_) => {\n+        layout::FieldsShape::Union(_) => {\n             let fill = cx.type_padding_filler(layout.size, layout.align.abi);\n             let packed = false;\n             match name {\n@@ -91,10 +91,10 @@ fn uncached_llvm_type<'a, 'tcx>(\n                 }\n             }\n         }\n-        layout::FieldPlacement::Array { count, .. } => {\n+        layout::FieldsShape::Array { count, .. } => {\n             cx.type_array(layout.field(cx, 0).llvm_type(cx), count)\n         }\n-        layout::FieldPlacement::Arbitrary { .. } => match name {\n+        layout::FieldsShape::Arbitrary { .. } => match name {\n             None => {\n                 let (llfields, packed) = struct_llfields(cx, layout);\n                 cx.type_struct(&llfields, packed)\n@@ -371,13 +371,13 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n             _ => {}\n         }\n         match self.fields {\n-            layout::FieldPlacement::Union(_) => {\n+            layout::FieldsShape::Union(_) => {\n                 bug!(\"TyAndLayout::llvm_field_index({:?}): not applicable\", self)\n             }\n \n-            layout::FieldPlacement::Array { .. } => index as u64,\n+            layout::FieldsShape::Array { .. } => index as u64,\n \n-            layout::FieldPlacement::Arbitrary { .. } => {\n+            layout::FieldsShape::Arbitrary { .. } => {\n                 1 + (self.fields.memory_index(index) as u64) * 2\n             }\n         }"}, {"sha": "eca66a5704db90548d764f6317f8ce3df67148b0", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=f259470da3af89d79709562b3f0ccd7368d25bc9", "patch": "@@ -66,7 +66,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     }\n \n     pub fn len<Cx: ConstMethods<'tcx, Value = V>>(&self, cx: &Cx) -> V {\n-        if let layout::FieldPlacement::Array { count, .. } = self.layout.fields {\n+        if let layout::FieldsShape::Array { count, .. } = self.layout.fields {\n             if self.layout.is_unsized() {\n                 assert_eq!(count, 0);\n                 self.llextra.unwrap()"}, {"sha": "f0d0e190dfb41fd48fdd6bdc545befb71ab980a4", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=f259470da3af89d79709562b3f0ccd7368d25bc9", "patch": "@@ -229,7 +229,7 @@ enum StructKind {\n // Invert a bijective mapping, i.e. `invert(map)[y] = x` if `map[x] = y`.\n // This is used to go between `memory_index` (source field order to memory order)\n // and `inverse_memory_index` (memory order to source field order).\n-// See also `FieldPlacement::Arbitrary::memory_index` for more details.\n+// See also `FieldsShape::Arbitrary::memory_index` for more details.\n // FIXME(eddyb) build a better abstraction for permutations, if possible.\n fn invert_mapping(map: &[u32]) -> Vec<u32> {\n     let mut inverse = vec![0; map.len()];\n@@ -256,7 +256,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n         Layout {\n             variants: Variants::Single { index: VariantIdx::new(0) },\n-            fields: FieldPlacement::Arbitrary {\n+            fields: FieldsShape::Arbitrary {\n                 offsets: vec![Size::ZERO, b_offset],\n                 memory_index: vec![0, 1],\n             },\n@@ -442,7 +442,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         };\n                         let pair = self.scalar_pair(a.clone(), b.clone());\n                         let pair_offsets = match pair.fields {\n-                            FieldPlacement::Arbitrary { ref offsets, ref memory_index } => {\n+                            FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n                                 assert_eq!(memory_index, &[0, 1]);\n                                 offsets\n                             }\n@@ -470,7 +470,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n         Ok(Layout {\n             variants: Variants::Single { index: VariantIdx::new(0) },\n-            fields: FieldPlacement::Arbitrary { offsets, memory_index },\n+            fields: FieldsShape::Arbitrary { offsets, memory_index },\n             abi,\n             largest_niche,\n             align,\n@@ -519,7 +519,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             // The never type.\n             ty::Never => tcx.intern_layout(Layout {\n                 variants: Variants::Single { index: VariantIdx::new(0) },\n-                fields: FieldPlacement::Union(0),\n+                fields: FieldsShape::Union(0),\n                 abi: Abi::Uninhabited,\n                 largest_niche: None,\n                 align: dl.i8_align,\n@@ -580,7 +580,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 tcx.intern_layout(Layout {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n-                    fields: FieldPlacement::Array { stride: element.size, count },\n+                    fields: FieldsShape::Array { stride: element.size, count },\n                     abi,\n                     largest_niche,\n                     align: element.align,\n@@ -591,7 +591,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 let element = self.layout_of(element)?;\n                 tcx.intern_layout(Layout {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n-                    fields: FieldPlacement::Array { stride: element.size, count: 0 },\n+                    fields: FieldsShape::Array { stride: element.size, count: 0 },\n                     abi: Abi::Aggregate { sized: false },\n                     largest_niche: None,\n                     align: element.align,\n@@ -600,7 +600,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }\n             ty::Str => tcx.intern_layout(Layout {\n                 variants: Variants::Single { index: VariantIdx::new(0) },\n-                fields: FieldPlacement::Array { stride: Size::from_bytes(1), count: 0 },\n+                fields: FieldsShape::Array { stride: Size::from_bytes(1), count: 0 },\n                 abi: Abi::Aggregate { sized: false },\n                 largest_niche: None,\n                 align: dl.i8_align,\n@@ -669,7 +669,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 tcx.intern_layout(Layout {\n                     variants: Variants::Single { index: VariantIdx::new(0) },\n-                    fields: FieldPlacement::Array { stride: element.size, count },\n+                    fields: FieldsShape::Array { stride: element.size, count },\n                     abi: Abi::Vector { element: scalar, count },\n                     largest_niche: element.largest_niche.clone(),\n                     size,\n@@ -745,7 +745,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                     return Ok(tcx.intern_layout(Layout {\n                         variants: Variants::Single { index },\n-                        fields: FieldPlacement::Union(variants[index].len()),\n+                        fields: FieldsShape::Union(variants[index].len()),\n                         abi,\n                         largest_niche: None,\n                         align,\n@@ -979,7 +979,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                     discr_index: 0,\n                                     variants: st,\n                                 },\n-                                fields: FieldPlacement::Arbitrary {\n+                                fields: FieldsShape::Arbitrary {\n                                     offsets: vec![offset],\n                                     memory_index: vec![0],\n                                 },\n@@ -1120,7 +1120,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     let new_ity_size = ity.size();\n                     for variant in &mut layout_variants {\n                         match variant.fields {\n-                            FieldPlacement::Arbitrary { ref mut offsets, .. } => {\n+                            FieldsShape::Arbitrary { ref mut offsets, .. } => {\n                                 for i in offsets {\n                                     if *i <= old_ity_size {\n                                         assert_eq!(*i, old_ity_size);\n@@ -1150,7 +1150,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     let mut common_prim = None;\n                     for (field_layouts, layout_variant) in variants.iter().zip(&layout_variants) {\n                         let offsets = match layout_variant.fields {\n-                            FieldPlacement::Arbitrary { ref offsets, .. } => offsets,\n+                            FieldsShape::Arbitrary { ref offsets, .. } => offsets,\n                             _ => bug!(),\n                         };\n                         let mut fields =\n@@ -1186,7 +1186,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     if let Some((prim, offset)) = common_prim {\n                         let pair = self.scalar_pair(tag.clone(), scalar_unit(prim));\n                         let pair_offsets = match pair.fields {\n-                            FieldPlacement::Arbitrary { ref offsets, ref memory_index } => {\n+                            FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n                                 assert_eq!(memory_index, &[0, 1]);\n                                 offsets\n                             }\n@@ -1217,7 +1217,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         discr_index: 0,\n                         variants: layout_variants,\n                     },\n-                    fields: FieldPlacement::Arbitrary {\n+                    fields: FieldsShape::Arbitrary {\n                         offsets: vec![Size::ZERO],\n                         memory_index: vec![0],\n                     },\n@@ -1434,7 +1434,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // GeneratorLayout.\n         debug!(\"prefix = {:#?}\", prefix);\n         let (outer_fields, promoted_offsets, promoted_memory_index) = match prefix.fields {\n-            FieldPlacement::Arbitrary { mut offsets, memory_index } => {\n+            FieldsShape::Arbitrary { mut offsets, memory_index } => {\n                 let mut inverse_memory_index = invert_mapping(&memory_index);\n \n                 // \"a\" (`0..b_start`) and \"b\" (`b_start..`) correspond to\n@@ -1457,7 +1457,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 let memory_index_b = invert_mapping(&inverse_memory_index_b);\n \n                 let outer_fields =\n-                    FieldPlacement::Arbitrary { offsets: offsets_a, memory_index: memory_index_a };\n+                    FieldsShape::Arbitrary { offsets: offsets_a, memory_index: memory_index_a };\n                 (outer_fields, offsets_b, memory_index_b)\n             }\n             _ => bug!(),\n@@ -1491,7 +1491,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 variant.variants = Variants::Single { index };\n \n                 let (offsets, memory_index) = match variant.fields {\n-                    FieldPlacement::Arbitrary { offsets, memory_index } => (offsets, memory_index),\n+                    FieldsShape::Arbitrary { offsets, memory_index } => (offsets, memory_index),\n                     _ => bug!(),\n                 };\n \n@@ -1534,7 +1534,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 combined_inverse_memory_index.retain(|&i| i != INVALID_FIELD_IDX);\n                 let combined_memory_index = invert_mapping(&combined_inverse_memory_index);\n \n-                variant.fields = FieldPlacement::Arbitrary {\n+                variant.fields = FieldsShape::Arbitrary {\n                     offsets: combined_offsets,\n                     memory_index: combined_memory_index,\n                 };\n@@ -1989,7 +1989,7 @@ where\n                 if index == variant_index &&\n                 // Don't confuse variants of uninhabited enums with the enum itself.\n                 // For more details see https://github.com/rust-lang/rust/issues/69763.\n-                this.fields != FieldPlacement::Union(0) =>\n+                this.fields != FieldsShape::Union(0) =>\n             {\n                 this.layout\n             }\n@@ -2007,7 +2007,7 @@ where\n                 let tcx = cx.tcx();\n                 tcx.intern_layout(Layout {\n                     variants: Variants::Single { index: variant_index },\n-                    fields: FieldPlacement::Union(fields),\n+                    fields: FieldsShape::Union(fields),\n                     abi: Abi::Uninhabited,\n                     largest_niche: None,\n                     align: tcx.data_layout.i8_align,\n@@ -2053,7 +2053,7 @@ where\n                 // Reuse the fat `*T` type as its own thin pointer data field.\n                 // This provides information about, e.g., DST struct pointees\n                 // (which may have no non-DST form), and will work as long\n-                // as the `Abi` or `FieldPlacement` is checked by users.\n+                // as the `Abi` or `FieldsShape` is checked by users.\n                 if i == 0 {\n                     let nil = tcx.mk_unit();\n                     let ptr_ty = if this.ty.is_unsafe_ptr() {\n@@ -2218,7 +2218,7 @@ where\n \n                 if let Some(variant) = data_variant {\n                     // We're not interested in any unions.\n-                    if let FieldPlacement::Union(_) = variant.fields {\n+                    if let FieldsShape::Union(_) = variant.fields {\n                         data_variant = None;\n                     }\n                 }"}, {"sha": "9dfeb955ef97b7719ef8053d616291fad9b7d018", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=f259470da3af89d79709562b3f0ccd7368d25bc9", "patch": "@@ -219,7 +219,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n             // Go through the layout.  There are lots of types that support a length,\n             // e.g., SIMD types.\n             match self.layout.fields {\n-                layout::FieldPlacement::Array { count, .. } => Ok(count),\n+                layout::FieldsShape::Array { count, .. } => Ok(count),\n                 _ => bug!(\"len not supported on sized type {:?}\", self.layout.ty),\n             }\n         }\n@@ -437,7 +437,7 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         // Not using the layout method because we want to compute on u64\n         match base.layout.fields {\n-            layout::FieldPlacement::Array { stride, .. } => {\n+            layout::FieldsShape::Array { stride, .. } => {\n                 let len = base.len(self)?;\n                 if index >= len {\n                     // This can only be reached in ConstProp and non-rustc-MIR.\n@@ -463,7 +463,7 @@ where\n     {\n         let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let stride = match base.layout.fields {\n-            layout::FieldPlacement::Array { stride, .. } => stride,\n+            layout::FieldsShape::Array { stride, .. } => stride,\n             _ => bug!(\"mplace_array_fields: expected an array layout\"),\n         };\n         let layout = base.layout.field(self, 0)?;\n@@ -493,7 +493,7 @@ where\n         // Not using layout method because that works with usize, and does not work with slices\n         // (that have count 0 in their layout).\n         let from_offset = match base.layout.fields {\n-            layout::FieldPlacement::Array { stride, .. } => stride * from, // `Size` multiplication is checked\n+            layout::FieldsShape::Array { stride, .. } => stride * from, // `Size` multiplication is checked\n             _ => bug!(\"Unexpected layout of index access: {:#?}\", base.layout),\n         };\n "}, {"sha": "66a46c12c062fd64336fa715fe3fcf14d98026bc", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=f259470da3af89d79709562b3f0ccd7368d25bc9", "patch": "@@ -207,10 +207,10 @@ macro_rules! make_value_visitor {\n \n                 // Visit the fields of this value.\n                 match v.layout().fields {\n-                    layout::FieldPlacement::Union(fields) => {\n+                    layout::FieldsShape::Union(fields) => {\n                         self.visit_union(v, fields)?;\n                     },\n-                    layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n+                    layout::FieldsShape::Arbitrary { ref offsets, .. } => {\n                         // FIXME: We collect in a vec because otherwise there are lifetime\n                         // errors: Projecting to a field needs access to `ecx`.\n                         let fields: Vec<InterpResult<'tcx, Self::V>> =\n@@ -220,7 +220,7 @@ macro_rules! make_value_visitor {\n                             .collect();\n                         self.visit_aggregate(v, fields.into_iter())?;\n                     },\n-                    layout::FieldPlacement::Array { .. } => {\n+                    layout::FieldsShape::Array { .. } => {\n                         // Let's get an mplace first.\n                         let mplace = v.to_op(self.ecx())?.assert_mem_place(self.ecx());\n                         // Now we can go over all the fields."}, {"sha": "81de6306788908bfd1eabf5dd0a136265496e8f0", "filename": "src/librustc_target/abi/call/mips64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmips64.rs?ref=f259470da3af89d79709562b3f0ccd7368d25bc9", "patch": "@@ -49,7 +49,7 @@ where\n         // use of float registers to structures (not unions) containing exactly one or two\n         // float fields.\n \n-        if let abi::FieldPlacement::Arbitrary { .. } = ret.layout.fields {\n+        if let abi::FieldsShape::Arbitrary { .. } = ret.layout.fields {\n             if ret.layout.fields.count() == 1 {\n                 if let Some(reg) = float_reg(cx, ret, 0) {\n                     ret.cast_to(reg);\n@@ -88,15 +88,15 @@ where\n     let mut prefix_index = 0;\n \n     match arg.layout.fields {\n-        abi::FieldPlacement::Array { .. } => {\n+        abi::FieldsShape::Array { .. } => {\n             // Arrays are passed indirectly\n             arg.make_indirect();\n             return;\n         }\n-        abi::FieldPlacement::Union(_) => {\n+        abi::FieldsShape::Union(_) => {\n             // Unions and are always treated as a series of 64-bit integer chunks\n         }\n-        abi::FieldPlacement::Arbitrary { .. } => {\n+        abi::FieldsShape::Arbitrary { .. } => {\n             // Structures are split up into a series of 64-bit integer chunks, but any aligned\n             // doubles not part of another aggregate are passed as floats.\n             let mut last_offset = Size::ZERO;"}, {"sha": "d9824087fa927c46df6f076bab7d917fd0e24bc2", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=f259470da3af89d79709562b3f0ccd7368d25bc9", "patch": "@@ -1,4 +1,4 @@\n-use crate::abi::{self, Abi, Align, FieldPlacement, Size};\n+use crate::abi::{self, Abi, Align, FieldsShape, Size};\n use crate::abi::{HasDataLayout, LayoutOf, TyAndLayout, TyAndLayoutMethods};\n use crate::spec::{self, HasTargetSpec};\n \n@@ -315,7 +315,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n                      start: Size|\n                      -> Result<(HomogeneousAggregate, Size), Heterogeneous> {\n                         let is_union = match layout.fields {\n-                            FieldPlacement::Array { count, .. } => {\n+                            FieldsShape::Array { count, .. } => {\n                                 assert_eq!(start, Size::ZERO);\n \n                                 let result = if count > 0 {\n@@ -325,8 +325,8 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n                                 };\n                                 return Ok((result, layout.size));\n                             }\n-                            FieldPlacement::Union(_) => true,\n-                            FieldPlacement::Arbitrary { .. } => false,\n+                            FieldsShape::Union(_) => true,\n+                            FieldsShape::Arbitrary { .. } => false,\n                         };\n \n                         let mut result = HomogeneousAggregate::NoData;"}, {"sha": "0eb8816e4346195672a30f42f6956bd48189c6e0", "filename": "src/librustc_target/abi/call/riscv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Friscv.rs?ref=f259470da3af89d79709562b3f0ccd7368d25bc9", "patch": "@@ -6,7 +6,7 @@\n \n use crate::abi::call::{ArgAbi, ArgAttribute, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n use crate::abi::{\n-    self, Abi, FieldPlacement, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods,\n+    self, Abi, FieldsShape, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods,\n };\n use crate::spec::HasTargetSpec;\n \n@@ -87,12 +87,12 @@ where\n         },\n         Abi::Vector { .. } | Abi::Uninhabited => return Err(CannotUseFpConv),\n         Abi::ScalarPair(..) | Abi::Aggregate { .. } => match arg_layout.fields {\n-            FieldPlacement::Union(_) => {\n+            FieldsShape::Union(_) => {\n                 if !arg_layout.is_zst() {\n                     return Err(CannotUseFpConv);\n                 }\n             }\n-            FieldPlacement::Array { count, .. } => {\n+            FieldsShape::Array { count, .. } => {\n                 for _ in 0..count {\n                     let elem_layout = arg_layout.field(cx, 0);\n                     should_use_fp_conv_helper(\n@@ -105,7 +105,7 @@ where\n                     )?;\n                 }\n             }\n-            FieldPlacement::Arbitrary { .. } => {\n+            FieldsShape::Arbitrary { .. } => {\n                 match arg_layout.variants {\n                     abi::Variants::Multiple { .. } => return Err(CannotUseFpConv),\n                     abi::Variants::Single { .. } => (),"}, {"sha": "f382ef984be24a3b3ceba77b89b6f3f0950395c3", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f259470da3af89d79709562b3f0ccd7368d25bc9/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=f259470da3af89d79709562b3f0ccd7368d25bc9", "patch": "@@ -618,7 +618,7 @@ impl Scalar {\n \n /// Describes how the fields of a type are located in memory.\n #[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n-pub enum FieldPlacement {\n+pub enum FieldsShape {\n     /// All fields start at no offset. The `usize` is the field count.\n     ///\n     /// In the case of primitives the number of fields is `0`.\n@@ -657,38 +657,38 @@ pub enum FieldPlacement {\n     },\n }\n \n-impl FieldPlacement {\n+impl FieldsShape {\n     pub fn count(&self) -> usize {\n         match *self {\n-            FieldPlacement::Union(count) => count,\n-            FieldPlacement::Array { count, .. } => {\n+            FieldsShape::Union(count) => count,\n+            FieldsShape::Array { count, .. } => {\n                 let usize_count = count as usize;\n                 assert_eq!(usize_count as u64, count);\n                 usize_count\n             }\n-            FieldPlacement::Arbitrary { ref offsets, .. } => offsets.len(),\n+            FieldsShape::Arbitrary { ref offsets, .. } => offsets.len(),\n         }\n     }\n \n     pub fn offset(&self, i: usize) -> Size {\n         match *self {\n-            FieldPlacement::Union(count) => {\n+            FieldsShape::Union(count) => {\n                 assert!(i < count, \"tried to access field {} of union with {} fields\", i, count);\n                 Size::ZERO\n             }\n-            FieldPlacement::Array { stride, count } => {\n+            FieldsShape::Array { stride, count } => {\n                 let i = u64::try_from(i).unwrap();\n                 assert!(i < count);\n                 stride * i\n             }\n-            FieldPlacement::Arbitrary { ref offsets, .. } => offsets[i],\n+            FieldsShape::Arbitrary { ref offsets, .. } => offsets[i],\n         }\n     }\n \n     pub fn memory_index(&self, i: usize) -> usize {\n         match *self {\n-            FieldPlacement::Union(_) | FieldPlacement::Array { .. } => i,\n-            FieldPlacement::Arbitrary { ref memory_index, .. } => {\n+            FieldsShape::Union(_) | FieldsShape::Array { .. } => i,\n+            FieldsShape::Arbitrary { ref memory_index, .. } => {\n                 let r = memory_index[i];\n                 assert_eq!(r as usize as u32, r);\n                 r as usize\n@@ -704,7 +704,7 @@ impl FieldPlacement {\n         let use_small = self.count() <= inverse_small.len();\n \n         // We have to write this logic twice in order to keep the array small.\n-        if let FieldPlacement::Arbitrary { ref memory_index, .. } = *self {\n+        if let FieldsShape::Arbitrary { ref memory_index, .. } = *self {\n             if use_small {\n                 for i in 0..self.count() {\n                     inverse_small[memory_index[i] as usize] = i as u8;\n@@ -718,8 +718,8 @@ impl FieldPlacement {\n         }\n \n         (0..self.count()).map(move |i| match *self {\n-            FieldPlacement::Union(_) | FieldPlacement::Array { .. } => i,\n-            FieldPlacement::Arbitrary { .. } => {\n+            FieldsShape::Union(_) | FieldsShape::Array { .. } => i,\n+            FieldsShape::Arbitrary { .. } => {\n                 if use_small {\n                     inverse_small[i] as usize\n                 } else {\n@@ -888,7 +888,7 @@ impl Niche {\n pub struct Layout {\n     /// Says where the fields are located within the layout.\n     /// Primitives and uninhabited enums appear as unions without fields.\n-    pub fields: FieldPlacement,\n+    pub fields: FieldsShape,\n \n     /// Encodes information about multi-variant layouts.\n     /// Even with `Multiple` variants, a layout still has its own fields! Those are then\n@@ -923,7 +923,7 @@ impl Layout {\n         let align = scalar.value.align(cx);\n         Layout {\n             variants: Variants::Single { index: VariantIdx::new(0) },\n-            fields: FieldPlacement::Union(0),\n+            fields: FieldsShape::Union(0),\n             abi: Abi::Scalar(scalar),\n             largest_niche,\n             size,"}]}