{"sha": "d4add198be2c7cc8285673ca724b330067fa2f57", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0YWRkMTk4YmUyYzdjYzgyODU2NzNjYTcyNGIzMzAwNjdmYTJmNTc=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-09-30T18:56:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-30T18:56:12Z"}, "message": "Rollup merge of #77296 - tmiasko:liveness-option, r=ecstatic-morse\n\nliveness: Use Option::None to represent absent live nodes\n\nNo functional changes intended.", "tree": {"sha": "098ab888e6b06d7dc997e4a25d690d20a4446d1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/098ab888e6b06d7dc997e4a25d690d20a4446d1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4add198be2c7cc8285673ca724b330067fa2f57", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfdNTMCRBK7hj4Ov3rIwAAdHIIAJPgFqv6/Nmw65hmMW03dljq\nxNieanMWeM1Z1Mcg770Qr1WVqMtsj1OGWwjeI6AMRkqk/OlMWRKghchkGts6a7O/\nBinJMM+7ijsCtCzaQkhB7HIpx9nSS9rEyHyfrwJQPF3jyjXkzVIefczQHx3BuYYj\nTJpYd7mropcxzKwlidBRm7S83cRXlCfSZ4CU3LG4ltgcDoAI0EhzE/UvcamMFuhw\nXWUQnH9jeu6VgALvXrNt+kf0GrS7zbKM43ve6BJ2asaFQl1a1oipLKUyIs7Atk7W\nrzL7poAZh8eq8aM6Gb23jQ0k7AqNOWhaGNUArf4fv5IIyEAtFhexI6uXCDDAIM4=\n=fP+K\n-----END PGP SIGNATURE-----\n", "payload": "tree 098ab888e6b06d7dc997e4a25d690d20a4446d1c\nparent 87387fd23ead4ca4d2dcc3ea6e4e6dbc925d6914\nparent 93e3db30e9c3b8fb217743e9d06f37b12dcb8745\nauthor Jonas Schievink <jonasschievink@gmail.com> 1601492172 +0200\ncommitter GitHub <noreply@github.com> 1601492172 +0200\n\nRollup merge of #77296 - tmiasko:liveness-option, r=ecstatic-morse\n\nliveness: Use Option::None to represent absent live nodes\n\nNo functional changes intended.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4add198be2c7cc8285673ca724b330067fa2f57", "html_url": "https://github.com/rust-lang/rust/commit/d4add198be2c7cc8285673ca724b330067fa2f57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4add198be2c7cc8285673ca724b330067fa2f57/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87387fd23ead4ca4d2dcc3ea6e4e6dbc925d6914", "url": "https://api.github.com/repos/rust-lang/rust/commits/87387fd23ead4ca4d2dcc3ea6e4e6dbc925d6914", "html_url": "https://github.com/rust-lang/rust/commit/87387fd23ead4ca4d2dcc3ea6e4e6dbc925d6914"}, {"sha": "93e3db30e9c3b8fb217743e9d06f37b12dcb8745", "url": "https://api.github.com/repos/rust-lang/rust/commits/93e3db30e9c3b8fb217743e9d06f37b12dcb8745", "html_url": "https://github.com/rust-lang/rust/commit/93e3db30e9c3b8fb217743e9d06f37b12dcb8745"}], "stats": {"total": 76, "additions": 36, "deletions": 40}, "files": [{"sha": "e8b97d7dc7d50e9a3ebb9d24f638766074937b6a", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d4add198be2c7cc8285673ca724b330067fa2f57/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4add198be2c7cc8285673ca724b330067fa2f57/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=d4add198be2c7cc8285673ca724b330067fa2f57", "patch": "@@ -62,13 +62,13 @@\n //! - `reader`: the `LiveNode` ID of some node which will read the value\n //!    that `V` holds on entry to `N`. Formally: a node `M` such\n //!    that there exists a path `P` from `N` to `M` where `P` does not\n-//!    write `V`. If the `reader` is `INVALID_NODE`, then the current\n+//!    write `V`. If the `reader` is `None`, then the current\n //!    value will never be read (the variable is dead, essentially).\n //!\n //! - `writer`: the `LiveNode` ID of some node which will write the\n //!    variable `V` and which is reachable from `N`. Formally: a node `M`\n //!    such that there exists a path `P` from `N` to `M` and `M` writes\n-//!    `V`. If the `writer` is `INVALID_NODE`, then there is no writer\n+//!    `V`. If the `writer` is `None`, then there is no writer\n //!    of `V` that follows `N`.\n //!\n //! - `used`: a boolean value indicating whether `V` is *used*. We\n@@ -114,7 +114,6 @@ rustc_index::newtype_index! {\n rustc_index::newtype_index! {\n     pub struct LiveNode {\n         DEBUG_FORMAT = \"ln({})\",\n-        const INVALID_NODE = LiveNode::MAX_AS_U32,\n     }\n }\n \n@@ -168,12 +167,6 @@ pub fn provide(providers: &mut Providers) {\n // variable must not be assigned if there is some successor\n // assignment.  And so forth.\n \n-impl LiveNode {\n-    fn is_valid(self) -> bool {\n-        self != INVALID_NODE\n-    }\n-}\n-\n struct CaptureInfo {\n     ln: LiveNode,\n     var_hid: HirId,\n@@ -467,8 +460,8 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n \n #[derive(Clone, Copy)]\n struct RWU {\n-    reader: LiveNode,\n-    writer: LiveNode,\n+    reader: Option<LiveNode>,\n+    writer: Option<LiveNode>,\n     used: bool,\n }\n \n@@ -490,10 +483,10 @@ struct RWUTable {\n     unpacked_rwus: Vec<RWU>,\n }\n \n-// A constant representing `RWU { reader: INVALID_NODE; writer: INVALID_NODE; used: false }`.\n+// A constant representing `RWU { reader: None; writer: None; used: false }`.\n const INV_INV_FALSE: u32 = u32::MAX;\n \n-// A constant representing `RWU { reader: INVALID_NODE; writer: INVALID_NODE; used: true }`.\n+// A constant representing `RWU { reader: None; writer: None; used: true }`.\n const INV_INV_TRUE: u32 = u32::MAX - 1;\n \n impl RWUTable {\n@@ -504,24 +497,24 @@ impl RWUTable {\n     fn get(&self, idx: usize) -> RWU {\n         let packed_rwu = self.packed_rwus[idx];\n         match packed_rwu {\n-            INV_INV_FALSE => RWU { reader: INVALID_NODE, writer: INVALID_NODE, used: false },\n-            INV_INV_TRUE => RWU { reader: INVALID_NODE, writer: INVALID_NODE, used: true },\n+            INV_INV_FALSE => RWU { reader: None, writer: None, used: false },\n+            INV_INV_TRUE => RWU { reader: None, writer: None, used: true },\n             _ => self.unpacked_rwus[packed_rwu as usize],\n         }\n     }\n \n-    fn get_reader(&self, idx: usize) -> LiveNode {\n+    fn get_reader(&self, idx: usize) -> Option<LiveNode> {\n         let packed_rwu = self.packed_rwus[idx];\n         match packed_rwu {\n-            INV_INV_FALSE | INV_INV_TRUE => INVALID_NODE,\n+            INV_INV_FALSE | INV_INV_TRUE => None,\n             _ => self.unpacked_rwus[packed_rwu as usize].reader,\n         }\n     }\n \n-    fn get_writer(&self, idx: usize) -> LiveNode {\n+    fn get_writer(&self, idx: usize) -> Option<LiveNode> {\n         let packed_rwu = self.packed_rwus[idx];\n         match packed_rwu {\n-            INV_INV_FALSE | INV_INV_TRUE => INVALID_NODE,\n+            INV_INV_FALSE | INV_INV_TRUE => None,\n             _ => self.unpacked_rwus[packed_rwu as usize].writer,\n         }\n     }\n@@ -541,7 +534,7 @@ impl RWUTable {\n     }\n \n     fn assign_unpacked(&mut self, idx: usize, rwu: RWU) {\n-        if rwu.reader == INVALID_NODE && rwu.writer == INVALID_NODE {\n+        if rwu.reader == None && rwu.writer == None {\n             // When we overwrite an indexing entry in `self.packed_rwus` with\n             // `INV_INV_{TRUE,FALSE}` we don't remove the corresponding entry\n             // from `self.unpacked_rwus`; it's not worth the effort, and we\n@@ -570,7 +563,7 @@ struct Liveness<'a, 'tcx> {\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n-    successors: IndexVec<LiveNode, LiveNode>,\n+    successors: IndexVec<LiveNode, Option<LiveNode>>,\n     rwu_table: RWUTable,\n \n     /// A live node representing a point of execution before closure entry &\n@@ -606,7 +599,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             typeck_results,\n             param_env,\n             upvars,\n-            successors: IndexVec::from_elem_n(INVALID_NODE, num_live_nodes),\n+            successors: IndexVec::from_elem_n(None, num_live_nodes),\n             rwu_table: RWUTable::new(num_live_nodes * num_vars),\n             closure_ln,\n             exit_ln,\n@@ -651,30 +644,33 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn live_on_entry(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        assert!(ln.is_valid());\n-        let reader = self.rwu_table.get_reader(self.idx(ln, var));\n-        if reader.is_valid() { Some(self.ir.lnks[reader]) } else { None }\n+        if let Some(reader) = self.rwu_table.get_reader(self.idx(ln, var)) {\n+            Some(self.ir.lnks[reader])\n+        } else {\n+            None\n+        }\n     }\n \n     // Is this variable live on entry to any of its successor nodes?\n     fn live_on_exit(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        let successor = self.successors[ln];\n+        let successor = self.successors[ln].unwrap();\n         self.live_on_entry(successor, var)\n     }\n \n     fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n-        assert!(ln.is_valid());\n         self.rwu_table.get_used(self.idx(ln, var))\n     }\n \n     fn assigned_on_entry(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        assert!(ln.is_valid());\n-        let writer = self.rwu_table.get_writer(self.idx(ln, var));\n-        if writer.is_valid() { Some(self.ir.lnks[writer]) } else { None }\n+        if let Some(writer) = self.rwu_table.get_writer(self.idx(ln, var)) {\n+            Some(self.ir.lnks[writer])\n+        } else {\n+            None\n+        }\n     }\n \n     fn assigned_on_exit(&self, ln: LiveNode, var: Variable) -> Option<LiveNodeKind> {\n-        let successor = self.successors[ln];\n+        let successor = self.successors[ln].unwrap();\n         self.assigned_on_entry(successor, var)\n     }\n \n@@ -709,9 +705,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         {\n             let wr = &mut wr as &mut dyn Write;\n             write!(wr, \"[{:?} of kind {:?} reads\", ln, self.ir.lnks[ln]);\n-            self.write_vars(wr, ln, |idx| self.rwu_table.get_reader(idx).is_valid());\n+            self.write_vars(wr, ln, |idx| self.rwu_table.get_reader(idx).is_some());\n             write!(wr, \"  writes\");\n-            self.write_vars(wr, ln, |idx| self.rwu_table.get_writer(idx).is_valid());\n+            self.write_vars(wr, ln, |idx| self.rwu_table.get_writer(idx).is_some());\n             write!(wr, \"  uses\");\n             self.write_vars(wr, ln, |idx| self.rwu_table.get_used(idx));\n \n@@ -735,7 +731,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n-        self.successors[ln] = succ_ln;\n+        self.successors[ln] = Some(succ_ln);\n \n         // It is not necessary to initialize the RWUs here because they are all\n         // set to INV_INV_FALSE when they are created, and the sets only grow\n@@ -744,7 +740,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn init_from_succ(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         // more efficient version of init_empty() / merge_from_succ()\n-        self.successors[ln] = succ_ln;\n+        self.successors[ln] = Some(succ_ln);\n \n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n             this.rwu_table.copy_packed(idx, succ_idx);\n@@ -768,12 +764,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             let mut changed = false;\n             let mut rwu = this.rwu_table.get(idx);\n             let succ_rwu = this.rwu_table.get(succ_idx);\n-            if succ_rwu.reader.is_valid() && !rwu.reader.is_valid() {\n+            if succ_rwu.reader.is_some() && rwu.reader.is_none() {\n                 rwu.reader = succ_rwu.reader;\n                 changed = true\n             }\n \n-            if succ_rwu.writer.is_valid() && !rwu.writer.is_valid() {\n+            if succ_rwu.writer.is_some() && rwu.writer.is_none() {\n                 rwu.writer = succ_rwu.writer;\n                 changed = true\n             }\n@@ -817,14 +813,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut rwu = self.rwu_table.get(idx);\n \n         if (acc & ACC_WRITE) != 0 {\n-            rwu.reader = INVALID_NODE;\n-            rwu.writer = ln;\n+            rwu.reader = None;\n+            rwu.writer = Some(ln);\n         }\n \n         // Important: if we both read/write, must do read second\n         // or else the write will override.\n         if (acc & ACC_READ) != 0 {\n-            rwu.reader = ln;\n+            rwu.reader = Some(ln);\n         }\n \n         if (acc & ACC_USE) != 0 {"}]}