{"sha": "8490862cc37d7518c79d09d7911d86bfca2cea89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0OTA4NjJjYzM3ZDc1MThjNzlkMDlkNzkxMWQ4NmJmY2EyY2VhODk=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-01-06T21:14:01Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-01-08T17:56:52Z"}, "message": "Fix path_to_res for enum inherent items", "tree": {"sha": "e13a16914433b2bdbb49121ae5e350a23882c175", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e13a16914433b2bdbb49121ae5e350a23882c175"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8490862cc37d7518c79d09d7911d86bfca2cea89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8490862cc37d7518c79d09d7911d86bfca2cea89", "html_url": "https://github.com/rust-lang/rust/commit/8490862cc37d7518c79d09d7911d86bfca2cea89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8490862cc37d7518c79d09d7911d86bfca2cea89/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2950c8e1cb32e864b599c4b4dae896d29d86e5e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2950c8e1cb32e864b599c4b4dae896d29d86e5e7", "html_url": "https://github.com/rust-lang/rust/commit/2950c8e1cb32e864b599c4b4dae896d29d86e5e7"}], "stats": {"total": 99, "additions": 40, "deletions": 59}, "files": [{"sha": "b2c9d4f8739b13fce568c535e330a1989a0699eb", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 37, "deletions": 59, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8490862cc37d7518c79d09d7911d86bfca2cea89/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8490862cc37d7518c79d09d7911d86bfca2cea89/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=8490862cc37d7518c79d09d7911d86bfca2cea89", "patch": "@@ -31,7 +31,6 @@ pub use self::hir_utils::{both, eq_expr_value, over, SpanlessEq, SpanlessHash};\n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::hash::BuildHasherDefault;\n-use std::mem;\n \n use if_chain::if_chain;\n use rustc_ast::ast::{self, Attribute, LitKind};\n@@ -40,7 +39,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::Node;\n use rustc_hir::{\n@@ -49,6 +48,7 @@ use rustc_hir::{\n };\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n+use rustc_middle::hir::exports::Export;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n use rustc_middle::ty::{self, layout::IntegerExt, Ty, TyCtxt, TypeFoldable};\n@@ -309,65 +309,43 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n }\n \n /// Gets the definition associated to a path.\n-pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Option<def::Res> {\n-    let crates = cx.tcx.crates();\n-    let krate = crates\n-        .iter()\n-        .find(|&&krate| cx.tcx.crate_name(krate).as_str() == path[0]);\n-    if let Some(krate) = krate {\n-        let krate = DefId {\n-            krate: *krate,\n-            index: CRATE_DEF_INDEX,\n-        };\n-        let mut current_item = None;\n-        let mut items = cx.tcx.item_children(krate);\n-        let mut path_it = path.iter().skip(1).peekable();\n-\n-        loop {\n-            let segment = match path_it.next() {\n-                Some(segment) => segment,\n-                None => return None,\n-            };\n-\n-            // `get_def_path` seems to generate these empty segments for extern blocks.\n-            // We can just ignore them.\n-            if segment.is_empty() {\n-                continue;\n-            }\n-\n-            let result = SmallVec::<[_; 8]>::new();\n-            for item in mem::replace(&mut items, cx.tcx.arena.alloc_slice(&result)).iter() {\n-                if item.ident.name.as_str() == *segment {\n-                    if path_it.peek().is_none() {\n-                        return Some(item.res);\n-                    }\n-\n-                    current_item = Some(item);\n-                    items = cx.tcx.item_children(item.res.def_id());\n-                    break;\n-                }\n-            }\n+#[allow(clippy::shadow_unrelated)] // false positive #6563\n+pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Option<Res> {\n+    fn item_child_by_name<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, name: &str) -> Option<&'tcx Export<HirId>> {\n+        tcx.item_children(def_id)\n+            .iter()\n+            .find(|item| item.ident.name.as_str() == name)\n+    }\n \n-            // The segment isn't a child_item.\n-            // Try to find it under an inherent impl.\n-            if_chain! {\n-                if path_it.peek().is_none();\n-                if let Some(current_item) = current_item;\n-                let item_def_id = current_item.res.def_id();\n-                if cx.tcx.def_kind(item_def_id) == DefKind::Struct;\n-                then {\n-                    // Bad `find_map` suggestion. See #4193.\n-                    #[allow(clippy::find_map)]\n-                    return cx.tcx.inherent_impls(item_def_id).iter()\n-                        .flat_map(|&impl_def_id| cx.tcx.item_children(impl_def_id))\n-                        .find(|item| item.ident.name.as_str() == *segment)\n-                        .map(|item| item.res);\n-                }\n+    let (krate, first, path) = match *path {\n+        [krate, first, ref path @ ..] => (krate, first, path),\n+        _ => return None,\n+    };\n+    let tcx = cx.tcx;\n+    let crates = tcx.crates();\n+    let krate = crates.iter().find(|&&num| tcx.crate_name(num).as_str() == krate)?;\n+    let first = item_child_by_name(tcx, krate.as_def_id(), first)?;\n+    let last = path\n+        .iter()\n+        .copied()\n+        // `get_def_path` seems to generate these empty segments for extern blocks.\n+        // We can just ignore them.\n+        .filter(|segment| !segment.is_empty())\n+        // for each segment, find the child item\n+        .try_fold(first, |item, segment| {\n+            let def_id = item.res.def_id();\n+            if let Some(item) = item_child_by_name(tcx, def_id, segment) {\n+                Some(item)\n+            } else if matches!(item.res, Res::Def(DefKind::Enum | DefKind::Struct, _)) {\n+                // it is not a child item so check inherent impl items\n+                tcx.inherent_impls(def_id)\n+                    .iter()\n+                    .find_map(|&impl_def_id| item_child_by_name(tcx, impl_def_id, segment))\n+            } else {\n+                None\n             }\n-        }\n-    } else {\n-        None\n-    }\n+        })?;\n+    Some(last.res)\n }\n \n pub fn qpath_res(cx: &LateContext<'_>, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {"}, {"sha": "a3b19c2e3949f112a9381eac6e71c8bf2c8b594c", "filename": "tests/ui-internal/invalid_paths.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8490862cc37d7518c79d09d7911d86bfca2cea89/tests%2Fui-internal%2Finvalid_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8490862cc37d7518c79d09d7911d86bfca2cea89/tests%2Fui-internal%2Finvalid_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Finvalid_paths.rs?ref=8490862cc37d7518c79d09d7911d86bfca2cea89", "patch": "@@ -18,6 +18,9 @@ mod paths {\n \n     // Path with bad module\n     pub const BAD_MOD_PATH: [&str; 2] = [\"std\", \"xxx\"];\n+\n+    // Path to method on an enum inherent impl\n+    pub const OPTION_IS_SOME: [&str; 4] = [\"core\", \"option\", \"Option\", \"is_some\"];\n }\n \n fn main() {}"}]}