{"sha": "25cf8001b1352fdaccdd1d71071c941f99acc2a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1Y2Y4MDAxYjEzNTJmZGFjY2RkMWQ3MTA3MWM5NDFmOTlhY2MyYTE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-17T19:50:55Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-24T10:23:38Z"}, "message": "Remove AST from metadata except for consts and const fns.", "tree": {"sha": "fed739e6043411bed16a5c5882e79f37ce938de5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fed739e6043411bed16a5c5882e79f37ce938de5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25cf8001b1352fdaccdd1d71071c941f99acc2a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25cf8001b1352fdaccdd1d71071c941f99acc2a1", "html_url": "https://github.com/rust-lang/rust/commit/25cf8001b1352fdaccdd1d71071c941f99acc2a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25cf8001b1352fdaccdd1d71071c941f99acc2a1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "119508cdb4051280a6b89d4ba1a8157f1113d379", "url": "https://api.github.com/repos/rust-lang/rust/commits/119508cdb4051280a6b89d4ba1a8157f1113d379", "html_url": "https://github.com/rust-lang/rust/commit/119508cdb4051280a6b89d4ba1a8157f1113d379"}], "stats": {"total": 697, "additions": 126, "deletions": 571}, "files": [{"sha": "5e14bb51ce8672fe5dffd5ec332d8bf7cc543dd1", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -315,8 +315,7 @@ impl<'ast> Map<'ast> {\n                     RootInlinedParent(parent) => match *parent {\n                         InlinedItem::Item(def_id, _) |\n                         InlinedItem::TraitItem(def_id, _) |\n-                        InlinedItem::ImplItem(def_id, _) |\n-                        InlinedItem::Foreign(def_id, _) =>\n+                        InlinedItem::ImplItem(def_id, _) =>\n                             return DepNode::MetaData(def_id)\n                     },\n \n@@ -940,8 +939,6 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n             II::ImplItem(fld.fold_ops.new_def_id(d),\n                          ii.map(|ii| fld.fold_impl_item(ii)))\n         }\n-        II::Foreign(d, i) => II::Foreign(fld.fold_ops.new_def_id(d),\n-                                         i.map(|i| fld.fold_foreign_item(i)))\n     };\n \n     let ii = map.forest.inlined_items.alloc(ii);"}, {"sha": "92e1b0681cc7e24eef7edfa61322e777e7481f83", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -96,17 +96,15 @@ pub enum DefLike {\n pub enum InlinedItem {\n     Item(DefId /* def-id in source crate */, P<hir::Item>),\n     TraitItem(DefId /* impl id */, P<hir::TraitItem>),\n-    ImplItem(DefId /* impl id */, P<hir::ImplItem>),\n-    Foreign(DefId /* extern item */, P<hir::ForeignItem>),\n+    ImplItem(DefId /* impl id */, P<hir::ImplItem>)\n }\n \n /// A borrowed version of `hir::InlinedItem`.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InlinedItemRef<'a> {\n     Item(DefId, &'a hir::Item),\n     TraitItem(DefId, &'a hir::TraitItem),\n-    ImplItem(DefId, &'a hir::ImplItem),\n-    Foreign(DefId, &'a hir::ForeignItem)\n+    ImplItem(DefId, &'a hir::ImplItem)\n }\n \n /// Item definitions in the currently-compiled crate would have the CrateNum\n@@ -286,7 +284,6 @@ impl InlinedItem {\n     {\n         match *self {\n             InlinedItem::Item(_, ref i) => visitor.visit_item(&i),\n-            InlinedItem::Foreign(_, ref i) => visitor.visit_foreign_item(&i),\n             InlinedItem::TraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n             InlinedItem::ImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n         }"}, {"sha": "ad52d346857ffb0ab25d7d85e779bacfb62d5775", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -79,7 +79,6 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            ii: InlinedItemRef) {\n     let id = match ii {\n         InlinedItemRef::Item(_, i) => i.id,\n-        InlinedItemRef::Foreign(_, i) => i.id,\n         InlinedItemRef::TraitItem(_, ti) => ti.id,\n         InlinedItemRef::ImplItem(_, ii) => ii.id,\n     };\n@@ -147,7 +146,6 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::CrateMetadata,\n                                        dcx);\n     let name = match *ii {\n         InlinedItem::Item(_, ref i) => i.name,\n-        InlinedItem::Foreign(_, ref i) => i.name,\n         InlinedItem::TraitItem(_, ref ti) => ti.name,\n         InlinedItem::ImplItem(_, ref ii) => ii.name\n     };\n@@ -357,9 +355,6 @@ fn simplify_ast(ii: InlinedItemRef) -> (InlinedItem, IdRange) {\n         InlinedItemRef::ImplItem(d, ii) => {\n             InlinedItem::ImplItem(d, P(fold::noop_fold_impl_item(ii.clone(), &mut fld)))\n         }\n-        InlinedItemRef::Foreign(d, i) => {\n-            InlinedItem::Foreign(d, P(fold::noop_fold_foreign_item(i.clone(), &mut fld)))\n-        }\n     };\n \n     (ii, fld.id_range)\n@@ -1208,8 +1203,7 @@ fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem, orig_did: DefId) {\n     let item_node_id = match ii {\n         &InlinedItem::Item(_, ref i) => i.id,\n         &InlinedItem::TraitItem(_, ref ti) => ti.id,\n-        &InlinedItem::ImplItem(_, ref ii) => ii.id,\n-        &InlinedItem::Foreign(_, ref fi) => fi.id\n+        &InlinedItem::ImplItem(_, ref ii) => ii.id\n     };\n     copy_item_type(dcx, item_node_id, orig_did);\n "}, {"sha": "94426dcbf1d8d0efdd424588d623b7dabd3b9c2a", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -562,11 +562,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                 let inlined_root_node_id = find_inlined_item_root(item.id);\n                 cache_inlined_item(def_id, item.id, inlined_root_node_id);\n             }\n-            decoder::FoundAst::Found(&InlinedItem::Foreign(d, ref item)) => {\n-                assert_eq!(d, def_id);\n-                let inlined_root_node_id = find_inlined_item_root(item.id);\n-                cache_inlined_item(def_id, item.id, inlined_root_node_id);\n-            }\n             decoder::FoundAst::FoundParent(parent_did, item) => {\n                 let inlined_root_node_id = find_inlined_item_root(item.id);\n                 cache_inlined_item(parent_did, item.id, inlined_root_node_id);"}, {"sha": "9a668b69b2eeb45480a5b8d456f7f65f28ae8ac0", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -40,7 +40,6 @@ use std::io::prelude::*;\n use std::io::{Cursor, SeekFrom};\n use std::rc::Rc;\n use std::u32;\n-use syntax::abi::Abi;\n use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID, CrateNum};\n use syntax::attr::{self,AttrMetaMethods,AttributeMethods};\n use errors::Handler;\n@@ -626,11 +625,6 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n \n                 if body.is_some() {\n                     encode_item_sort(self.rbml_w, 'p');\n-                    encode_inlined_item(ecx,\n-                                        self.rbml_w,\n-                                        InlinedItemRef::TraitItem(\n-                                            trait_def_id,\n-                                            trait_item));\n                     self.encode_mir(trait_item.id);\n                 } else {\n                     encode_item_sort(self.rbml_w, 'r');\n@@ -728,12 +722,14 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                 let types = generics.parent_types as usize + generics.types.len();\n                 let needs_inline = types > 0 || is_default_impl ||\n                     attr::requests_inline(&impl_item.attrs);\n-                if needs_inline || sig.constness == hir::Constness::Const {\n+                if sig.constness == hir::Constness::Const {\n                     encode_inlined_item(\n                         ecx,\n                         self.rbml_w,\n                         InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n                                                  impl_item));\n+                }\n+                if needs_inline || sig.constness == hir::Constness::Const {\n                     self.encode_mir(impl_item.id);\n                 }\n                 encode_constness(self.rbml_w, sig.constness);\n@@ -934,8 +930,10 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                 encode_name(self.rbml_w, item.name);\n                 encode_attributes(self.rbml_w, &item.attrs);\n                 let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n-                if needs_inline || constness == hir::Constness::Const {\n+                if constness == hir::Constness::Const {\n                     encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n+                }\n+                if needs_inline || constness == hir::Constness::Const {\n                     self.encode_mir(item.id);\n                 }\n                 encode_constness(self.rbml_w, constness);\n@@ -982,8 +980,6 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                 for v in &enum_definition.variants {\n                     encode_variant_id(self.rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n                 }\n-                encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n-                self.encode_mir(item.id);\n \n                 // Encode inherent implementations for self enumeration.\n                 encode_inherent_implementations(ecx, self.rbml_w, def_id);\n@@ -1019,9 +1015,6 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                 needs to know*/\n                 self.encode_struct_fields(variant);\n \n-                encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n-                self.encode_mir(item.id);\n-\n                 // Encode inherent implementations for self structure.\n                 encode_inherent_implementations(ecx, self.rbml_w, def_id);\n \n@@ -1265,7 +1258,6 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n         let ecx = self.ecx();\n \n         debug!(\"writing foreign item {}\", ecx.tcx.node_path_str(nitem.id));\n-        let abi = ecx.tcx.map.get_foreign_abi(nitem.id);\n \n         encode_def_id_and_key(ecx, self.rbml_w, def_id);\n         let parent_id = ecx.tcx.map.get_parent(nitem.id);\n@@ -1276,12 +1268,6 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                 encode_family(self.rbml_w, FN_FAMILY);\n                 self.encode_bounds_and_type_for_item(nitem.id);\n                 encode_name(self.rbml_w, nitem.name);\n-                if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-                    encode_inlined_item(ecx,\n-                                        self.rbml_w,\n-                                        InlinedItemRef::Foreign(def_id, nitem));\n-                    self.encode_mir(nitem.id);\n-                }\n                 encode_attributes(self.rbml_w, &nitem.attrs);\n                 let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n                 let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));"}, {"sha": "165884c8f55a2a9eb4605c9dd2356e7c4444700b", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -66,7 +66,6 @@ use consts;\n use context::{SharedCrateContext, CrateContextList};\n use debuginfo::{self, DebugLoc};\n use declare;\n-use inline;\n use machine;\n use machine::{llalign_of_min, llsize_of};\n use meth;\n@@ -949,14 +948,17 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             false\n         };\n \n-        let debug_context = if let (false, Some((instance, sig, abi))) = (no_debug, definition) {\n-            debuginfo::create_function_debug_context(ccx, instance, sig, abi, llfndecl)\n+        let mir = def_id.and_then(|id| ccx.get_mir(id));\n+\n+        let debug_context = if let (false, Some((instance, sig, abi)), &Some(ref mir)) =\n+                (no_debug, definition, &mir) {\n+            debuginfo::create_function_debug_context(ccx, instance, sig, abi, llfndecl, mir)\n         } else {\n             debuginfo::empty_function_debug_context(ccx)\n         };\n \n         FunctionContext {\n-            mir: def_id.and_then(|id| ccx.get_mir(id)),\n+            mir: mir,\n             llfn: llfndecl,\n             llretslotptr: Cell::new(None),\n             param_env: ccx.tcx().empty_parameter_environment(),\n@@ -1134,8 +1136,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     let sig = ccx.tcx().normalize_associated_type(&sig);\n     let abi = fn_ty.fn_abi();\n \n-    let local_instance = inline::maybe_inline_instance(ccx, instance);\n-    let lldecl = match ccx.instances().borrow().get(&local_instance) {\n+    let lldecl = match ccx.instances().borrow().get(&instance) {\n         Some(&val) => val,\n         None => bug!(\"Instance `{:?}` not already declared\", instance)\n     };\n@@ -1144,12 +1145,15 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n }\n \n pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                 ctor_id: ast::NodeId,\n+                                 def_id: DefId,\n+                                 substs: &'tcx Substs<'tcx>,\n                                  disr: Disr,\n-                                 param_substs: &'tcx Substs<'tcx>,\n                                  llfndecl: ValueRef) {\n-    let ctor_ty = ccx.tcx().node_id_to_type(ctor_id);\n-    let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &ctor_ty);\n+    attributes::inline(llfndecl, attributes::InlineAttr::Hint);\n+    attributes::set_frame_pointer_elimination(ccx, llfndecl);\n+\n+    let ctor_ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), substs, &ctor_ty);\n \n     let sig = ccx.tcx().erase_late_bound_regions(&ctor_ty.fn_sig());\n     let sig = ccx.tcx().normalize_associated_type(&sig);\n@@ -1742,10 +1746,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         println!(\"n_null_glues: {}\", stats.n_null_glues.get());\n         println!(\"n_real_glues: {}\", stats.n_real_glues.get());\n \n-        println!(\"n_fallback_instantiations: {}\", stats.n_fallback_instantiations.get());\n-\n         println!(\"n_fns: {}\", stats.n_fns.get());\n-        println!(\"n_monos: {}\", stats.n_monos.get());\n         println!(\"n_inlines: {}\", stats.n_inlines.get());\n         println!(\"n_closures: {}\", stats.n_closures.get());\n         println!(\"fn stats:\");"}, {"sha": "9aa486dc62811604f7dbda71f3543994d12c21f7", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 62, "deletions": 135, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -18,12 +18,10 @@ pub use self::CalleeData::*;\n \n use arena::TypedArena;\n use back::symbol_names;\n-use llvm::{ValueRef, get_params};\n-use middle::cstore::LOCAL_CRATE;\n+use llvm::{self, ValueRef, get_params};\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n-use rustc::hir::map as hir_map;\n use abi::{Abi, FnType};\n use attributes;\n use base;\n@@ -34,18 +32,15 @@ use common::{self, Block, Result, CrateContext, FunctionContext};\n use consts;\n use debuginfo::DebugLoc;\n use declare;\n-use inline;\n use meth;\n use monomorphize::{self, Instance};\n use trans_item::TransItem;\n use type_of;\n-use value::Value;\n use Disr;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::hir;\n \n use syntax_pos::DUMMY_SP;\n-use errors;\n \n #[derive(Debug)]\n pub enum CalleeData {\n@@ -102,35 +97,28 @@ impl<'tcx> Callee<'tcx> {\n             return Callee::trait_method(ccx, trait_id, def_id, substs);\n         }\n \n-        let maybe_node_id = inline::get_local_instance(ccx, def_id)\n-            .and_then(|def_id| tcx.map.as_local_node_id(def_id));\n-        let maybe_ast_node = maybe_node_id.and_then(|node_id| {\n-            tcx.map.find(node_id)\n-        });\n-\n-        let data = match maybe_ast_node {\n-            Some(hir_map::NodeStructCtor(_)) => {\n-                NamedTupleConstructor(Disr(0))\n-            }\n-            Some(hir_map::NodeVariant(_)) => {\n-                let vinfo = common::inlined_variant_def(ccx, maybe_node_id.unwrap());\n-                NamedTupleConstructor(Disr::from(vinfo.disr_val))\n-            }\n-            Some(hir_map::NodeForeignItem(fi)) if {\n-                let abi = tcx.map.get_foreign_abi(fi.id);\n-                abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic\n-            } => Intrinsic,\n-\n-            _ => {\n-                let (llfn, ty) = get_fn(ccx, def_id, substs);\n-                return Callee::ptr(llfn, ty);\n+        let fn_ty = def_ty(tcx, def_id, substs);\n+        if let ty::TyFnDef(_, _, f) = fn_ty.sty {\n+            if f.abi == Abi::RustIntrinsic || f.abi == Abi::PlatformIntrinsic {\n+                return Callee {\n+                    data: Intrinsic,\n+                    ty: fn_ty\n+                };\n             }\n-        };\n+        }\n \n-        Callee {\n-            data: data,\n-            ty: def_ty(tcx, def_id, substs)\n+        // FIXME(eddyb) Detect ADT constructors more efficiently.\n+        if let Some(adt_def) = fn_ty.fn_ret().skip_binder().ty_adt_def() {\n+            if let Some(v) = adt_def.variants.iter().find(|v| def_id == v.did) {\n+                return Callee {\n+                    data: NamedTupleConstructor(Disr::from(v.disr_val)),\n+                    ty: fn_ty\n+                };\n+            }\n         }\n+\n+        let (llfn, ty) = get_fn(ccx, def_id, substs);\n+        Callee::ptr(llfn, ty)\n     }\n \n     /// Trait method, which has to be resolved to an impl method.\n@@ -168,24 +156,14 @@ impl<'tcx> Callee<'tcx> {\n                                                          trait_closure_kind);\n \n                 let method_ty = def_ty(tcx, def_id, substs);\n-                let fn_ptr_ty = match method_ty.sty {\n-                    ty::TyFnDef(_, _, fty) => tcx.mk_fn_ptr(fty),\n-                    _ => bug!(\"expected fn item type, found {}\",\n-                              method_ty)\n-                };\n-                Callee::ptr(llfn, fn_ptr_ty)\n+                Callee::ptr(llfn, method_ty)\n             }\n             traits::VtableFnPointer(vtable_fn_pointer) => {\n                 let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n                 let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, vtable_fn_pointer.fn_ty);\n \n                 let method_ty = def_ty(tcx, def_id, substs);\n-                let fn_ptr_ty = match method_ty.sty {\n-                    ty::TyFnDef(_, _, fty) => tcx.mk_fn_ptr(fty),\n-                    _ => bug!(\"expected fn item type, found {}\",\n-                              method_ty)\n-                };\n-                Callee::ptr(llfn, fn_ptr_ty)\n+                Callee::ptr(llfn, method_ty)\n             }\n             traits::VtableObject(ref data) => {\n                 Callee {\n@@ -242,9 +220,21 @@ impl<'tcx> Callee<'tcx> {\n             Virtual(idx) => {\n                 meth::trans_object_shim(ccx, self.ty, idx)\n             }\n-            NamedTupleConstructor(_) => match self.ty.sty {\n+            NamedTupleConstructor(disr) => match self.ty.sty {\n                 ty::TyFnDef(def_id, substs, _) => {\n-                    return get_fn(ccx, def_id, substs).0;\n+                    let instance = Instance::new(def_id, substs);\n+                    if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n+                        return llfn;\n+                    }\n+\n+                    let sym = ccx.symbol_map().get_or_compute(ccx.shared(),\n+                                                              TransItem::Fn(instance));\n+                    assert!(!ccx.codegen_unit().contains_item(&TransItem::Fn(instance)));\n+                    let lldecl = declare::define_internal_fn(ccx, &sym, self.ty);\n+                    base::trans_ctor_shim(ccx, def_id, substs, disr, lldecl);\n+                    ccx.instances().borrow_mut().insert(instance, lldecl);\n+\n+                    lldecl\n                 }\n                 _ => bug!(\"expected fn item type, found {}\", self.ty)\n             },\n@@ -412,83 +402,20 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     assert!(!substs.types.needs_infer());\n     assert!(!substs.types.has_escaping_regions());\n+    assert!(!substs.types.has_param_types());\n \n-    // Check whether this fn has an inlined copy and, if so, redirect\n-    // def_id to the local id of the inlined copy.\n-    let def_id = inline::maybe_instantiate_inline(ccx, def_id);\n-\n-    fn is_named_tuple_constructor(tcx: TyCtxt, def_id: DefId) -> bool {\n-        let node_id = match tcx.map.as_local_node_id(def_id) {\n-            Some(n) => n,\n-            None => { return false; }\n-        };\n-        let map_node = errors::expect(\n-            &tcx.sess.diagnostic(),\n-            tcx.map.find(node_id),\n-            || \"local item should be in ast map\".to_string());\n-\n-        match map_node {\n-            hir_map::NodeVariant(v) => {\n-                v.node.data.is_tuple()\n-            }\n-            hir_map::NodeStructCtor(_) => true,\n-            _ => false\n-        }\n-    }\n-    let must_monomorphise =\n-        !substs.types.is_empty() || is_named_tuple_constructor(tcx, def_id);\n-\n-    debug!(\"get_fn({:?}) must_monomorphise: {}\",\n-           def_id, must_monomorphise);\n-\n-    // Create a monomorphic version of generic functions\n-    if must_monomorphise {\n-        // Should be either intra-crate or inlined.\n-        assert_eq!(def_id.krate, LOCAL_CRATE);\n-\n-        let substs = tcx.normalize_associated_type(&substs);\n-        let (val, fn_ty) = monomorphize::monomorphic_fn(ccx, def_id, substs);\n-        let fn_ptr_ty = match fn_ty.sty {\n-            ty::TyFnDef(_, _, fty) => {\n-                // Create a fn pointer with the substituted signature.\n-                tcx.mk_fn_ptr(fty)\n-            }\n-            _ => bug!(\"expected fn item type, found {}\", fn_ty)\n-        };\n-        assert_eq!(type_of::type_of(ccx, fn_ptr_ty), common::val_ty(val));\n-        return (val, fn_ptr_ty);\n-    }\n-\n-    // Find the actual function pointer.\n-    let ty = ccx.tcx().lookup_item_type(def_id).ty;\n-    let fn_ptr_ty = match ty.sty {\n-        ty::TyFnDef(_, _, ref fty) => {\n-            // Create a fn pointer with the normalized signature.\n-            tcx.mk_fn_ptr(tcx.normalize_associated_type(fty))\n-        }\n-        _ => bug!(\"expected fn item type, found {}\", ty)\n-    };\n+    let substs = tcx.normalize_associated_type(&substs);\n+    let instance = Instance::new(def_id, substs);\n+    let item_ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    let fn_ty = monomorphize::apply_param_substs(ccx.tcx(), substs, &item_ty);\n \n-    let instance = Instance::mono(ccx.shared(), def_id);\n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n-        return (llfn, fn_ptr_ty);\n+        return (llfn, fn_ty);\n     }\n \n-    let local_id = ccx.tcx().map.as_local_node_id(def_id);\n-    let local_item = match local_id.and_then(|id| tcx.map.find(id)) {\n-        Some(hir_map::NodeItem(&hir::Item {\n-            span, node: hir::ItemFn(..), ..\n-        })) |\n-        Some(hir_map::NodeTraitItem(&hir::TraitItem {\n-            span, node: hir::MethodTraitItem(_, Some(_)), ..\n-        })) |\n-        Some(hir_map::NodeImplItem(&hir::ImplItem {\n-            span, node: hir::ImplItemKind::Method(..), ..\n-        })) => {\n-            Some(span)\n-        }\n-        _ => None\n-    };\n+    let sym = ccx.symbol_map().get_or_compute(ccx.shared(),\n+                                              TransItem::Fn(instance));\n+    debug!(\"get_fn({:?}: {:?}) => {}\", instance, fn_ty, sym);\n \n     // This is subtle and surprising, but sometimes we have to bitcast\n     // the resulting fn pointer.  The reason has to do with external\n@@ -514,47 +441,47 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n \n-    let sym = ccx.symbol_map().get_or_compute(ccx.shared(),\n-                                              TransItem::Fn(instance));\n-\n-    let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n-    let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {\n-        if let Some(span) = local_item {\n-            if declare::get_defined_value(ccx, &sym).is_some() {\n-                ccx.sess().span_fatal(span,\n-                    &format!(\"symbol `{}` is already defined\", &sym));\n-            }\n+    let fn_ptr_ty = match fn_ty.sty {\n+        ty::TyFnDef(_, _, fty) => {\n+            // Create a fn pointer with the substituted signature.\n+            tcx.mk_fn_ptr(fty)\n         }\n+        _ => bug!(\"expected fn item type, found {}\", fn_ty)\n+    };\n+    let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n \n+    let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {\n         if common::val_ty(llfn) != llptrty {\n-            if local_item.is_some() {\n-                bug!(\"symbol `{}` previously declared as {:?}, now wanted as {:?}\",\n-                     sym, Value(llfn), llptrty);\n-            }\n             debug!(\"get_fn: casting {:?} to {:?}\", llfn, llptrty);\n             consts::ptrcast(llfn, llptrty)\n         } else {\n             debug!(\"get_fn: not casting pointer!\");\n             llfn\n         }\n     } else {\n-        let llfn = declare::declare_fn(ccx, &sym, ty);\n+        let llfn = declare::declare_fn(ccx, &sym, fn_ty);\n         assert_eq!(common::val_ty(llfn), llptrty);\n         debug!(\"get_fn: not casting pointer!\");\n \n         let attrs = ccx.tcx().get_attrs(def_id);\n         attributes::from_fn_attrs(ccx, &attrs, llfn);\n-        if local_item.is_some() {\n+\n+        let is_local_def = ccx.shared().translation_items().borrow()\n+                              .contains(&TransItem::Fn(instance));\n+        if is_local_def {\n             // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n             attributes::unwind(llfn, true);\n+            unsafe {\n+                llvm::LLVMSetLinkage(llfn, llvm::ExternalLinkage);\n+            }\n         }\n \n         llfn\n     };\n \n     ccx.instances().borrow_mut().insert(instance, llfn);\n \n-    (llfn, fn_ptr_ty)\n+    (llfn, fn_ty)\n }\n \n // ______________________________________________________________________"}, {"sha": "c5053e4feee6200bc7e98e511f93bdc6a07a1312", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -199,12 +199,6 @@ pub fn gensym_name(name: &str) -> ast::Name {\n \n use Disr;\n \n-#[derive(Copy, Clone)]\n-pub struct NodeIdAndSpan {\n-    pub id: ast::NodeId,\n-    pub span: Span,\n-}\n-\n /// The concrete version of ty::FieldDef. The name is the field index if\n /// the field is numeric.\n pub struct Field<'tcx>(pub ast::Name, pub Ty<'tcx>);\n@@ -1066,34 +1060,6 @@ pub fn langcall(tcx: TyCtxt,\n     }\n }\n \n-/// Return the VariantDef corresponding to an inlined variant node\n-pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                     inlined_vid: ast::NodeId)\n-                                     -> ty::VariantDef<'tcx>\n-{\n-    let ctor_ty = ccx.tcx().node_id_to_type(inlined_vid);\n-    debug!(\"inlined_variant_def: ctor_ty={:?} inlined_vid={:?}\", ctor_ty,\n-           inlined_vid);\n-    let adt_def = match ctor_ty.sty {\n-        ty::TyFnDef(_, _, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n-            output, ..\n-        }), ..}) => output,\n-        _ => ctor_ty\n-    }.ty_adt_def().unwrap();\n-    let variant_def_id = if ccx.tcx().map.is_inlined_node_id(inlined_vid) {\n-        ccx.defid_for_inlined_node(inlined_vid).unwrap()\n-    } else {\n-        ccx.tcx().map.local_def_id(inlined_vid)\n-    };\n-\n-    adt_def.variants\n-           .iter()\n-           .find(|v| variant_def_id == v.did)\n-           .unwrap_or_else(|| {\n-                bug!(\"no variant for {:?}::{}\", adt_def, inlined_vid)\n-            })\n-}\n-\n // To avoid UB from LLVM, these two functions mask RHS with an\n // appropriate mask unconditionally (i.e. the fallback behavior for\n // all shifts). For 32- and 64-bit types, this matches the semantics"}, {"sha": "fa1e008d496e45d08eb99d2df2ae5cdc1e859b6b", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -105,14 +105,10 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n                                                          .items()\n                                                          .contains_key(&TransItem::Static(id));\n-                if defined_in_current_codegen_unit {\n-                    if declare::get_declared_value(ccx, sym).is_none() {\n-                        span_bug!(span, \"trans: Static not properly pre-defined?\");\n-                    }\n-                } else {\n-                    if declare::get_declared_value(ccx, sym).is_some() {\n-                        span_bug!(span, \"trans: Conflicting symbol names for static?\");\n-                    }\n+                assert!(!defined_in_current_codegen_unit);\n+\n+                if declare::get_declared_value(ccx, sym).is_some() {\n+                    span_bug!(span, \"trans: Conflicting symbol names for static?\");\n                 }\n \n                 let g = declare::define_global(ccx, sym, llty).unwrap();"}, {"sha": "0a295b251b31e4ff85ddc4c028b43b1735562219", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -53,9 +53,7 @@ pub struct Stats {\n     pub n_glues_created: Cell<usize>,\n     pub n_null_glues: Cell<usize>,\n     pub n_real_glues: Cell<usize>,\n-    pub n_fallback_instantiations: Cell<usize>,\n     pub n_fns: Cell<usize>,\n-    pub n_monos: Cell<usize>,\n     pub n_inlines: Cell<usize>,\n     pub n_closures: Cell<usize>,\n     pub n_llvm_insns: Cell<usize>,\n@@ -103,7 +101,6 @@ pub struct LocalCrateContext<'tcx> {\n     drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, (ValueRef, FnType)>>,\n     /// Cache instances of monomorphic and polymorphic items\n     instances: RefCell<FnvHashMap<Instance<'tcx>, ValueRef>>,\n-    monomorphizing: RefCell<DefIdMap<usize>>,\n     /// Cache generated vtables\n     vtables: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>>,\n     /// Cache of constant strings,\n@@ -488,9 +485,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n                 n_glues_created: Cell::new(0),\n                 n_null_glues: Cell::new(0),\n                 n_real_glues: Cell::new(0),\n-                n_fallback_instantiations: Cell::new(0),\n                 n_fns: Cell::new(0),\n-                n_monos: Cell::new(0),\n                 n_inlines: Cell::new(0),\n                 n_closures: Cell::new(0),\n                 n_llvm_insns: Cell::new(0),\n@@ -626,7 +621,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 fn_pointer_shims: RefCell::new(FnvHashMap()),\n                 drop_glues: RefCell::new(FnvHashMap()),\n                 instances: RefCell::new(FnvHashMap()),\n-                monomorphizing: RefCell::new(DefIdMap()),\n                 vtables: RefCell::new(FnvHashMap()),\n                 const_cstr_cache: RefCell::new(FnvHashMap()),\n                 const_unsized: RefCell::new(FnvHashMap()),\n@@ -830,10 +824,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().instances\n     }\n \n-    pub fn monomorphizing<'a>(&'a self) -> &'a RefCell<DefIdMap<usize>> {\n-        &self.local().monomorphizing\n-    }\n-\n     pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>> {\n         &self.local().vtables\n     }"}, {"sha": "ba91b44343868decf494f3fde8396616c62bff71", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -28,7 +28,7 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::hir;\n use {type_of, adt, machine, monomorphize};\n-use common::{CrateContext, FunctionContext};\n+use common::CrateContext;\n use type_::Type;\n use rustc::ty::{self, Ty};\n use session::config;\n@@ -882,26 +882,6 @@ fn file_metadata_(cx: &CrateContext, key: &str, file_name: &str, work_dir: &str)\n     file_metadata\n }\n \n-/// Finds the scope metadata node for the given AST node.\n-pub fn scope_metadata(fcx: &FunctionContext,\n-                  node_id: ast::NodeId,\n-                  error_reporting_span: Span)\n-               -> DIScope {\n-    let scope_map = &fcx.debug_context\n-                        .get_ref(error_reporting_span)\n-                        .scope_map;\n-    match scope_map.borrow().get(&node_id).cloned() {\n-        Some(scope_metadata) => scope_metadata,\n-        None => {\n-            let node = fcx.ccx.tcx().map.get(node_id);\n-\n-            span_bug!(error_reporting_span,\n-                      \"debuginfo: Could not find scope info for node {:?}\",\n-                      node);\n-        }\n-    }\n-}\n-\n fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                  t: Ty<'tcx>) -> DIType {\n "}, {"sha": "cbf423b0739a399f3e61f0ced5ba0a5b44f50efd", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 13, "deletions": 48, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -27,15 +27,14 @@ use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArr\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::ty::subst::Substs;\n-use rustc::hir;\n \n use abi::Abi;\n-use common::{NodeIdAndSpan, CrateContext, FunctionContext, Block, BlockAndBuilder};\n-use inline;\n+use common::{CrateContext, FunctionContext, Block, BlockAndBuilder};\n use monomorphize::{self, Instance};\n use rustc::ty::{self, Ty};\n+use rustc::mir::repr as mir;\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n-use util::nodemap::{DefIdMap, NodeMap, FnvHashMap, FnvHashSet};\n+use util::nodemap::{DefIdMap, FnvHashMap, FnvHashSet};\n \n use libc::c_uint;\n use std::cell::{Cell, RefCell};\n@@ -134,7 +133,6 @@ impl FunctionDebugContext {\n }\n \n pub struct FunctionDebugContextData {\n-    scope_map: RefCell<NodeMap<DIScope>>,\n     fn_metadata: DISubprogram,\n     source_locations_enabled: Cell<bool>,\n     source_location_override: Cell<bool>,\n@@ -222,7 +220,8 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                instance: Instance<'tcx>,\n                                                sig: &ty::FnSig<'tcx>,\n                                                abi: Abi,\n-                                               llfn: ValueRef) -> FunctionDebugContext {\n+                                               llfn: ValueRef,\n+                                               mir: &mir::Mir) -> FunctionDebugContext {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n         return FunctionDebugContext::DebugInfoDisabled;\n     }\n@@ -231,8 +230,8 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // Do this here already, in case we do an early exit from this function.\n     source_loc::set_debug_location(cx, None, UnknownLocation);\n \n-    let instance = inline::maybe_inline_instance(cx, instance);\n-    let (containing_scope, span) = get_containing_scope_and_span(cx, instance);\n+    let containing_scope = get_containing_scope(cx, instance);\n+    let span = mir.span;\n \n     // This can be the case for functions inlined from another crate\n     if span == syntax_pos::DUMMY_SP {\n@@ -298,7 +297,6 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // Initialize fn debug context (including scope map and namespace map)\n     let fn_debug_context = box FunctionDebugContextData {\n-        scope_map: RefCell::new(NodeMap()),\n         fn_metadata: fn_metadata,\n         source_locations_enabled: Cell::new(false),\n         source_location_override: Cell::new(false),\n@@ -406,9 +404,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         names\n     }\n \n-    fn get_containing_scope_and_span<'ccx, 'tcx>(cx: &CrateContext<'ccx, 'tcx>,\n-                                                 instance: Instance<'tcx>)\n-                                                 -> (DIScope, Span) {\n+    fn get_containing_scope<'ccx, 'tcx>(cx: &CrateContext<'ccx, 'tcx>,\n+                                        instance: Instance<'tcx>)\n+                                        -> DIScope {\n         // First, let's see if this is a method within an inherent impl. Because\n         // if yes, we want to make the result subroutine DIE a child of the\n         // subroutine's self-type.\n@@ -428,22 +426,15 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n         });\n \n-        let containing_scope = self_type.unwrap_or_else(|| {\n+        self_type.unwrap_or_else(|| {\n             namespace::item_namespace(cx, DefId {\n                 krate: instance.def.krate,\n                 index: cx.tcx()\n                          .def_key(instance.def)\n                          .parent\n-                         .expect(\"get_containing_scope_and_span: missing parent?\")\n+                         .expect(\"get_containing_scope: missing parent?\")\n             })\n-        });\n-\n-        // Try to get some span information, if we have an inlined item.\n-        let definition_span = cx.tcx()\n-                                .map\n-                                .def_id_span(instance.def, syntax_pos::DUMMY_SP);\n-\n-        (containing_scope, definition_span)\n+        })\n     }\n }\n \n@@ -521,7 +512,6 @@ pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum DebugLoc {\n-    At(ast::NodeId, Span),\n     ScopeAt(DIScope, Span),\n     None\n }\n@@ -535,28 +525,3 @@ impl DebugLoc {\n         source_loc::set_source_location(bcx.fcx(), Some(bcx), self);\n     }\n }\n-\n-pub trait ToDebugLoc {\n-    fn debug_loc(&self) -> DebugLoc;\n-}\n-\n-impl ToDebugLoc for hir::Expr {\n-    fn debug_loc(&self) -> DebugLoc {\n-        DebugLoc::At(self.id, self.span)\n-    }\n-}\n-\n-impl ToDebugLoc for NodeIdAndSpan {\n-    fn debug_loc(&self) -> DebugLoc {\n-        DebugLoc::At(self.id, self.span)\n-    }\n-}\n-\n-impl ToDebugLoc for Option<NodeIdAndSpan> {\n-    fn debug_loc(&self) -> DebugLoc {\n-        match *self {\n-            Some(NodeIdAndSpan { id, span }) => DebugLoc::At(id, span),\n-            None => DebugLoc::None\n-        }\n-    }\n-}"}, {"sha": "1aee27c144a36f9c0a9c8ed1ccc4f1f8ee3cf7a5", "filename": "src/librustc_trans/debuginfo/source_loc.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -11,7 +11,7 @@\n use self::InternalDebugLocation::*;\n \n use super::utils::{debug_context, span_start};\n-use super::metadata::{scope_metadata,UNKNOWN_COLUMN_NUMBER};\n+use super::metadata::{UNKNOWN_COLUMN_NUMBER};\n use super::{FunctionDebugContext, DebugLoc};\n \n use llvm;\n@@ -47,9 +47,6 @@ pub fn set_source_location(fcx: &FunctionContext,\n \n     let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n         let (scope, span) = match debug_loc {\n-            DebugLoc::At(node_id, span) => {\n-                (scope_metadata(fcx, node_id, span), span)\n-            }\n             DebugLoc::ScopeAt(scope, span) => (scope, span),\n             DebugLoc::None => {\n                 set_debug_location(fcx.ccx, builder, UnknownLocation);"}, {"sha": "6a072c84dd9b39e39d6b3faa33e22c7950213f8d", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -221,10 +221,6 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     g,\n                     TransItem::DropGlue(g).to_raw_string(),\n                     ccx.codegen_unit().name());\n-\n-            ccx.stats().n_fallback_instantiations.set(ccx.stats()\n-                                                         .n_fallback_instantiations\n-                                                         .get() + 1);\n         }\n     }\n "}, {"sha": "8581fccf10ab53b0d2c783567a4e403ea894e60f", "filename": "src/librustc_trans/inline.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119508cdb4051280a6b89d4ba1a8157f1113d379/src%2Flibrustc_trans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Finline.rs?ref=119508cdb4051280a6b89d4ba1a8157f1113d379", "patch": "@@ -1,52 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::hir::def_id::DefId;\n-use base::push_ctxt;\n-use common::*;\n-use monomorphize::Instance;\n-\n-use rustc::dep_graph::DepNode;\n-\n-fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n-    debug!(\"instantiate_inline({:?})\", fn_id);\n-    let _icx = push_ctxt(\"instantiate_inline\");\n-    let tcx = ccx.tcx();\n-    let _task = tcx.dep_graph.in_task(DepNode::TransInlinedItem(fn_id));\n-\n-    tcx.sess\n-       .cstore\n-       .maybe_get_item_ast(tcx, fn_id)\n-       .map(|(_, inline_id)| {\n-            tcx.map.local_def_id(inline_id)\n-       })\n-}\n-\n-pub fn get_local_instance(ccx: &CrateContext, fn_id: DefId)\n-    -> Option<DefId> {\n-    if let Some(_) = ccx.tcx().map.as_local_node_id(fn_id) {\n-        Some(fn_id)\n-    } else {\n-        instantiate_inline(ccx, fn_id)\n-    }\n-}\n-\n-pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> DefId {\n-    get_local_instance(ccx, fn_id).unwrap_or(fn_id)\n-}\n-\n-pub fn maybe_inline_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                       instance: Instance<'tcx>) -> Instance<'tcx> {\n-    let def_id = maybe_instantiate_inline(ccx, instance.def);\n-    Instance {\n-        def: def_id,\n-        substs: instance.substs\n-    }\n-}"}, {"sha": "7faff98aea4425b490468d27b581cca86afdb58b", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -111,7 +111,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let name = tcx.item_name(def_id).as_str();\n \n     let span = match call_debug_location {\n-        DebugLoc::At(_, span) | DebugLoc::ScopeAt(_, span) => span,\n+        DebugLoc::ScopeAt(_, span) => span,\n         DebugLoc::None => {\n             span_bug!(fcx.span.unwrap_or(DUMMY_SP),\n                       \"intrinsic `{}` called with missing span\", name);"}, {"sha": "1286df7b97e6742582a7e6aae85a435efad5aee2", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -114,7 +114,6 @@ mod debuginfo;\n mod declare;\n mod disr;\n mod glue;\n-mod inline;\n mod intrinsic;\n mod machine;\n mod meth;"}, {"sha": "020ac8d643b86df29e82959ef6a4e4062158a36f", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 149, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -8,162 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::ValueRef;\n-use llvm;\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n-use attributes;\n-use base::{push_ctxt};\n-use base;\n+use rustc::ty::{self, Ty, TyCtxt};\n use common::*;\n-use declare;\n-use Disr;\n-use rustc::hir::map as hir_map;\n use rustc::util::ppaux;\n \n-use rustc::hir;\n-\n-use errors;\n-\n use std::fmt;\n-use trans_item::TransItem;\n-\n-pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                fn_id: DefId,\n-                                psubsts: &'tcx Substs<'tcx>)\n-                                -> (ValueRef, Ty<'tcx>) {\n-    debug!(\"monomorphic_fn(fn_id={:?}, real_substs={:?})\", fn_id, psubsts);\n-    assert!(!psubsts.types.needs_infer() && !psubsts.types.has_param_types());\n-\n-    let _icx = push_ctxt(\"monomorphic_fn\");\n-\n-    let instance = Instance::new(fn_id, psubsts);\n-\n-    let item_ty = ccx.tcx().lookup_item_type(fn_id).ty;\n-\n-    debug!(\"monomorphic_fn about to subst into {:?}\", item_ty);\n-    let mono_ty = apply_param_substs(ccx.tcx(), psubsts, &item_ty);\n-    debug!(\"mono_ty = {:?} (post-substitution)\", mono_ty);\n-\n-    if let Some(&val) = ccx.instances().borrow().get(&instance) {\n-        debug!(\"leaving monomorphic fn {:?}\", instance);\n-        return (val, mono_ty);\n-    } else {\n-        assert!(!ccx.codegen_unit().contains_item(&TransItem::Fn(instance)));\n-    }\n-\n-    debug!(\"monomorphic_fn({:?})\", instance);\n-\n-    ccx.stats().n_monos.set(ccx.stats().n_monos.get() + 1);\n-\n-    let depth;\n-    {\n-        let mut monomorphizing = ccx.monomorphizing().borrow_mut();\n-        depth = match monomorphizing.get(&fn_id) {\n-            Some(&d) => d, None => 0\n-        };\n-\n-        debug!(\"monomorphic_fn: depth for fn_id={:?} is {:?}\", fn_id, depth+1);\n-\n-        // Random cut-off -- code that needs to instantiate the same function\n-        // recursively more than thirty times can probably safely be assumed\n-        // to be causing an infinite expansion.\n-        if depth > ccx.sess().recursion_limit.get() {\n-            let error = format!(\"reached the recursion limit while instantiating `{}`\",\n-                                instance);\n-            if let Some(id) = ccx.tcx().map.as_local_node_id(fn_id) {\n-                ccx.sess().span_fatal(ccx.tcx().map.span(id), &error);\n-            } else {\n-                ccx.sess().fatal(&error);\n-            }\n-        }\n-\n-        monomorphizing.insert(fn_id, depth + 1);\n-    }\n-\n-    let symbol = ccx.symbol_map().get_or_compute(ccx.shared(),\n-                                                 TransItem::Fn(instance));\n-\n-    debug!(\"monomorphize_fn mangled to {}\", &symbol);\n-    assert!(declare::get_defined_value(ccx, &symbol).is_none());\n-\n-    // FIXME(nagisa): perhaps needs a more fine grained selection?\n-    let lldecl = declare::define_internal_fn(ccx, &symbol, mono_ty);\n-    // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n-    attributes::unwind(lldecl, true);\n-\n-    ccx.instances().borrow_mut().insert(instance, lldecl);\n-\n-    // we can only monomorphize things in this crate (or inlined into it)\n-    let fn_node_id = ccx.tcx().map.as_local_node_id(fn_id).unwrap();\n-    let map_node = errors::expect(\n-        ccx.sess().diagnostic(),\n-        ccx.tcx().map.find(fn_node_id),\n-        || {\n-            format!(\"while instantiating `{}`, couldn't find it in \\\n-                     the item map (may have attempted to monomorphize \\\n-                     an item defined in a different crate?)\",\n-                    instance)\n-        });\n-    match map_node {\n-        hir_map::NodeItem(&hir::Item {\n-            ref attrs,\n-            node: hir::ItemFn(..), ..\n-        }) |\n-        hir_map::NodeImplItem(&hir::ImplItem {\n-            ref attrs, node: hir::ImplItemKind::Method(\n-                hir::MethodSig { .. }, _), ..\n-        }) |\n-        hir_map::NodeTraitItem(&hir::TraitItem {\n-            ref attrs, node: hir::MethodTraitItem(\n-                hir::MethodSig { .. }, Some(_)), ..\n-        }) => {\n-            let trans_item = TransItem::Fn(instance);\n-\n-            if ccx.shared().translation_items().borrow().contains(&trans_item) {\n-                attributes::from_fn_attrs(ccx, attrs, lldecl);\n-                unsafe {\n-                    llvm::LLVMSetLinkage(lldecl, llvm::ExternalLinkage);\n-                }\n-            } else {\n-                // FIXME: #34151\n-                // Normally, getting here would indicate a bug in trans::collector,\n-                // since it seems to have missed a translation item. When we are\n-                // translating with non-MIR based trans, however, the results of\n-                // the collector are not entirely reliable since it bases its\n-                // analysis on MIR. Thus, we'll instantiate the missing function\n-                // privately in this codegen unit, so that things keep working.\n-                ccx.stats().n_fallback_instantiations.set(ccx.stats()\n-                                                             .n_fallback_instantiations\n-                                                             .get() + 1);\n-                trans_item.predefine(ccx, llvm::InternalLinkage);\n-                trans_item.define(ccx);\n-            }\n-        }\n-\n-        hir_map::NodeVariant(_) | hir_map::NodeStructCtor(_) => {\n-            let disr = match map_node {\n-                hir_map::NodeVariant(_) => {\n-                    Disr::from(inlined_variant_def(ccx, fn_node_id).disr_val)\n-                }\n-                hir_map::NodeStructCtor(_) => Disr(0),\n-                _ => bug!()\n-            };\n-            attributes::inline(lldecl, attributes::InlineAttr::Hint);\n-            attributes::set_frame_pointer_elimination(ccx, lldecl);\n-            base::trans_ctor_shim(ccx, fn_node_id, disr, psubsts, lldecl);\n-        }\n-\n-        _ => bug!(\"can't monomorphize a {:?}\", map_node)\n-    };\n-\n-    ccx.monomorphizing().borrow_mut().insert(fn_id, depth);\n-\n-    debug!(\"leaving monomorphic fn {}\", ccx.tcx().item_path_str(fn_id));\n-    (lldecl, mono_ty)\n-}\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Instance<'tcx> {"}, {"sha": "90dcc3a61fd7ebda35f10c6bff6c5d29032612a7", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 19, "deletions": 50, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25cf8001b1352fdaccdd1d71071c941f99acc2a1/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=25cf8001b1352fdaccdd1d71071c941f99acc2a1", "patch": "@@ -22,17 +22,15 @@ use declare;\n use glue::DropGlueKind;\n use llvm;\n use monomorphize::{self, Instance};\n-use inline;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n-use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst::Substs;\n use rustc_const_eval::fatal_const_eval_err;\n use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n-use syntax::{attr,errors};\n+use syntax::attr;\n use type_of;\n use glue;\n use abi::{Abi, FnType};\n@@ -157,20 +155,16 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         let ty = ccx.tcx().lookup_item_type(def_id).ty;\n         let llty = type_of::type_of(ccx, ty);\n \n-        match ccx.tcx().map.get(node_id) {\n-            hir::map::NodeItem(&hir::Item {\n-                span, node: hir::ItemStatic(..), ..\n-            }) => {\n-                let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n-                    ccx.sess().span_fatal(span,\n-                        &format!(\"symbol `{}` is already defined\", symbol_name))\n-                });\n+        let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n+            ccx.sess().span_fatal(ccx.tcx().map.span(node_id),\n+                &format!(\"symbol `{}` is already defined\", symbol_name))\n+        });\n \n-                unsafe { llvm::LLVMSetLinkage(g, linkage) };\n-            }\n+        unsafe { llvm::LLVMSetLinkage(g, linkage) };\n \n-            item => bug!(\"predefine_static: expected static, found {:?}\", item)\n-        }\n+        let instance = Instance::mono(ccx.shared(), def_id);\n+        ccx.instances().borrow_mut().insert(instance, g);\n+        ccx.statics().borrow_mut().insert(g, def_id);\n     }\n \n     fn predefine_fn(ccx: &CrateContext<'a, 'tcx>,\n@@ -180,47 +174,22 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         assert!(!instance.substs.types.needs_infer() &&\n                 !instance.substs.types.has_param_types());\n \n-        let instance = inline::maybe_inline_instance(ccx, instance);\n-\n         let item_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n         let item_ty = ccx.tcx().erase_regions(&item_ty);\n         let mono_ty = monomorphize::apply_param_substs(ccx.tcx(), instance.substs, &item_ty);\n \n-        let fn_node_id = ccx.tcx().map.as_local_node_id(instance.def).unwrap();\n-        let map_node = errors::expect(\n-            ccx.sess().diagnostic(),\n-            ccx.tcx().map.find(fn_node_id),\n-            || {\n-                format!(\"while instantiating `{}`, couldn't find it in \\\n-                     the item map (may have attempted to monomorphize \\\n-                     an item defined in a different crate?)\",\n-                    instance)\n-            });\n-\n-        match map_node {\n-            hir_map::NodeItem(&hir::Item {\n-                ref attrs, node: hir::ItemFn(..), ..\n-            }) |\n-            hir_map::NodeTraitItem(&hir::TraitItem {\n-                ref attrs, node: hir::MethodTraitItem(..), ..\n-            }) |\n-            hir_map::NodeImplItem(&hir::ImplItem {\n-                ref attrs, node: hir::ImplItemKind::Method(..), ..\n-            }) => {\n-                let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n-                unsafe { llvm::LLVMSetLinkage(lldecl, linkage) };\n-                base::set_link_section(ccx, lldecl, attrs);\n-                if linkage == llvm::LinkOnceODRLinkage ||\n-                   linkage == llvm::WeakODRLinkage {\n-                    llvm::SetUniqueComdat(ccx.llmod(), lldecl);\n-                }\n+        let attrs = ccx.tcx().get_attrs(instance.def);\n+        let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n+        unsafe { llvm::LLVMSetLinkage(lldecl, linkage) };\n+        base::set_link_section(ccx, lldecl, &attrs);\n+        if linkage == llvm::LinkOnceODRLinkage ||\n+            linkage == llvm::WeakODRLinkage {\n+            llvm::SetUniqueComdat(ccx.llmod(), lldecl);\n+        }\n \n-                attributes::from_fn_attrs(ccx, attrs, lldecl);\n-                ccx.instances().borrow_mut().insert(instance, lldecl);\n-            }\n-            _ => bug!(\"Invalid item for TransItem::Fn: `{:?}`\", map_node)\n-        };\n+        attributes::from_fn_attrs(ccx, &attrs, lldecl);\n \n+        ccx.instances().borrow_mut().insert(instance, lldecl);\n     }\n \n     fn predefine_drop_glue(ccx: &CrateContext<'a, 'tcx>,"}]}