{"sha": "b52414fedebe9774bf8a5339eb5042a2fa3dc9a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MjQxNGZlZGViZTk3NzRiZjhhNTMzOWViNTA0MmEyZmEzZGM5YTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-10-08T14:56:03Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-02-06T20:57:58Z"}, "message": "integrate the `sub_free_regions` code so we have only one copy of it", "tree": {"sha": "21ba545a67ef07bbb09af3c1254a72e9e9a62c31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21ba545a67ef07bbb09af3c1254a72e9e9a62c31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b52414fedebe9774bf8a5339eb5042a2fa3dc9a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b52414fedebe9774bf8a5339eb5042a2fa3dc9a3", "html_url": "https://github.com/rust-lang/rust/commit/b52414fedebe9774bf8a5339eb5042a2fa3dc9a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b52414fedebe9774bf8a5339eb5042a2fa3dc9a3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03b2fff40ed8c58357934789ab1158eafd942d39", "url": "https://api.github.com/repos/rust-lang/rust/commits/03b2fff40ed8c58357934789ab1158eafd942d39", "html_url": "https://github.com/rust-lang/rust/commit/03b2fff40ed8c58357934789ab1158eafd942d39"}], "stats": {"total": 200, "additions": 106, "deletions": 94}, "files": [{"sha": "cd4d2257de896c9bbb0277d30bc06afd0e9c0dd4", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b52414fedebe9774bf8a5339eb5042a2fa3dc9a3/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52414fedebe9774bf8a5339eb5042a2fa3dc9a3/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=b52414fedebe9774bf8a5339eb5042a2fa3dc9a3", "patch": "@@ -420,12 +420,34 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n     /// True if `a <= b`, but not defined over inference variables.\n     fn sub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> bool {\n+        let tcx = self.tcx();\n+        let sub_free_regions = |r1, r2| self.region_rels.free_regions.sub_free_regions(tcx, r1, r2);\n+\n+        // Check for the case where we know that `'b: 'static` -- in that case,\n+        // `a <= b` for all `a`.\n+        let b_free_or_static = self.region_rels.free_regions.is_free_or_static(b);\n+        if b_free_or_static && sub_free_regions(tcx.lifetimes.re_static, b) {\n+            return true;\n+        }\n+\n+        // If both a and b are free, consult the declared\n+        // relationships.  Note that this can be more precise than the\n+        // `lub` relationship defined below, since sometimes the \"lub\"\n+        // is actually the `postdom_upper_bound` (see\n+        // `TransitiveRelation` for more details).\n+        let a_free_or_static = self.region_rels.free_regions.is_free_or_static(a);\n+        if a_free_or_static && b_free_or_static {\n+            return sub_free_regions(a, b);\n+        }\n+\n+        // For other cases, leverage the LUB code to find the LUB and\n+        // check if it is equal to b.\n         self.lub_concrete_regions(a, b) == b\n     }\n \n     /// Returns the smallest region `c` such that `a <= c` and `b <= c`.\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n-        match (a, b) {\n+        let r = match (a, b) {\n             (&ty::ReClosureBound(..), _)\n             | (_, &ty::ReClosureBound(..))\n             | (&ReLateBound(..), _)\n@@ -509,7 +531,11 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     self.tcx().lifetimes.re_static\n                 }\n             }\n-        }\n+        };\n+\n+        debug!(\"lub_concrete_regions({:?}, {:?}) = {:?}\", a, b, r);\n+\n+        r\n     }\n \n     /// After expansion is complete, go and check upper bounds (i.e.,\n@@ -528,7 +554,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 }\n \n                 Constraint::RegSubReg(sub, sup) => {\n-                    if self.region_rels.is_subregion_of(sub, sup) {\n+                    if self.sub_concrete_regions(sub, sup) {\n                         continue;\n                     }\n \n@@ -557,7 +583,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     // Do not report these errors immediately:\n                     // instead, set the variable value to error and\n                     // collect them later.\n-                    if !self.region_rels.is_subregion_of(a_region, b_region) {\n+                    if !self.sub_concrete_regions(a_region, b_region) {\n                         debug!(\n                             \"collect_errors: region error at {:?}: \\\n                              cannot verify that {:?}={:?} <= {:?}\",\n@@ -754,7 +780,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             };\n \n             for upper_bound in &upper_bounds {\n-                if !self.region_rels.is_subregion_of(effective_lower_bound, upper_bound.region) {\n+                if !self.sub_concrete_regions(effective_lower_bound, upper_bound.region) {\n                     let origin = self.var_infos[node_idx].origin;\n                     debug!(\n                         \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n@@ -884,7 +910,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n \n             VerifyBound::OutlivedBy(r) => {\n-                self.region_rels.is_subregion_of(min, var_values.normalize(self.tcx(), r))\n+                self.sub_concrete_regions(min, var_values.normalize(self.tcx(), r))\n             }\n \n             VerifyBound::IsEmpty => {"}, {"sha": "c86f9f66ec83a4878be32fc6e017f16c6f62fa9f", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b52414fedebe9774bf8a5339eb5042a2fa3dc9a3/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52414fedebe9774bf8a5339eb5042a2fa3dc9a3/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=b52414fedebe9774bf8a5339eb5042a2fa3dc9a3", "patch": "@@ -384,9 +384,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             match least_region {\n                 None => least_region = Some(subst_arg),\n                 Some(lr) => {\n-                    if free_region_relations.sub_free_regions(lr, subst_arg) {\n+                    if free_region_relations.sub_free_regions(self.tcx, lr, subst_arg) {\n                         // keep the current least region\n-                    } else if free_region_relations.sub_free_regions(subst_arg, lr) {\n+                    } else if free_region_relations.sub_free_regions(self.tcx, subst_arg, lr) {\n                         // switch to `subst_arg`\n                         least_region = Some(subst_arg);\n                     } else {"}, {"sha": "62ccd94674488277ac66f6b3a405a8394e3fb50d", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 2, "deletions": 58, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b52414fedebe9774bf8a5339eb5042a2fa3dc9a3/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52414fedebe9774bf8a5339eb5042a2fa3dc9a3/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=b52414fedebe9774bf8a5339eb5042a2fa3dc9a3", "patch": "@@ -4,8 +4,8 @@\n //! and use that to decide when one free region outlives another, and so forth.\n \n use crate::middle::region;\n-use crate::ty::free_region_map::{FreeRegionMap, FreeRegionRelations};\n-use crate::ty::{self, Region, TyCtxt};\n+use crate::ty::free_region_map::FreeRegionMap;\n+use crate::ty::{Region, TyCtxt};\n use rustc_hir::def_id::DefId;\n \n /// Combines a `region::ScopeTree` (which governs relationships between\n@@ -38,62 +38,6 @@ impl<'a, 'tcx> RegionRelations<'a, 'tcx> {\n         Self { tcx, context, region_scope_tree, free_regions }\n     }\n \n-    /// Determines whether one region is a subregion of another. This is intended to run *after\n-    /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n-    pub fn is_subregion_of(\n-        &self,\n-        sub_region: ty::Region<'tcx>,\n-        super_region: ty::Region<'tcx>,\n-    ) -> bool {\n-        let result = sub_region == super_region || {\n-            match (sub_region, super_region) {\n-                (ty::ReEmpty, _) | (_, ty::ReStatic) => true,\n-\n-                (ty::ReScope(sub_scope), ty::ReScope(super_scope)) => {\n-                    self.region_scope_tree.is_subscope_of(*sub_scope, *super_scope)\n-                }\n-\n-                (ty::ReScope(sub_scope), ty::ReEarlyBound(ref br)) => {\n-                    let fr_scope = self.region_scope_tree.early_free_scope(self.tcx, br);\n-                    self.region_scope_tree.is_subscope_of(*sub_scope, fr_scope)\n-                }\n-\n-                (ty::ReScope(sub_scope), ty::ReFree(fr)) => {\n-                    let fr_scope = self.region_scope_tree.free_scope(self.tcx, fr);\n-                    self.region_scope_tree.is_subscope_of(*sub_scope, fr_scope)\n-                }\n-\n-                (ty::ReEarlyBound(_), ty::ReEarlyBound(_))\n-                | (ty::ReFree(_), ty::ReEarlyBound(_))\n-                | (ty::ReEarlyBound(_), ty::ReFree(_))\n-                | (ty::ReFree(_), ty::ReFree(_)) => {\n-                    self.free_regions.sub_free_regions(sub_region, super_region)\n-                }\n-\n-                _ => false,\n-            }\n-        };\n-        let result = result || self.is_static(super_region);\n-        debug!(\n-            \"is_subregion_of(sub_region={:?}, super_region={:?}) = {:?}\",\n-            sub_region, super_region, result\n-        );\n-        result\n-    }\n-\n-    /// Determines whether this free region is required to be `'static`.\n-    fn is_static(&self, super_region: ty::Region<'tcx>) -> bool {\n-        debug!(\"is_static(super_region={:?})\", super_region);\n-        match *super_region {\n-            ty::ReStatic => true,\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                let re_static = self.tcx.mk_region(ty::ReStatic);\n-                self.free_regions.sub_free_regions(&re_static, &super_region)\n-            }\n-            _ => false,\n-        }\n-    }\n-\n     pub fn lub_free_regions(&self, r_a: Region<'tcx>, r_b: Region<'tcx>) -> Region<'tcx> {\n         self.free_regions.lub_free_regions(self.tcx, r_a, r_b)\n     }"}, {"sha": "4cd6b4cfadb0c36dd7ca7a7e39c8a57b0dcca6bf", "filename": "src/librustc/ty/free_region_map.rs", "status": "modified", "additions": 63, "deletions": 26, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b52414fedebe9774bf8a5339eb5042a2fa3dc9a3/src%2Flibrustc%2Fty%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52414fedebe9774bf8a5339eb5042a2fa3dc9a3/src%2Flibrustc%2Fty%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffree_region_map.rs?ref=b52414fedebe9774bf8a5339eb5042a2fa3dc9a3", "patch": "@@ -23,11 +23,61 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     // (with the exception that `'static: 'x` is not notable)\n     pub fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n         debug!(\"relate_regions(sub={:?}, sup={:?})\", sub, sup);\n-        if is_free_or_static(sub) && is_free(sup) {\n+        if self.is_free_or_static(sub) && self.is_free(sup) {\n             self.relation.add(sub, sup)\n         }\n     }\n \n+    /// Tests whether `r_a <= r_b`.\n+    ///\n+    /// Both regions must meet `is_free_or_static`.\n+    ///\n+    /// Subtle: one tricky case that this code gets correct is as\n+    /// follows. If we know that `r_b: 'static`, then this function\n+    /// will return true, even though we don't know anything that\n+    /// directly relates `r_a` and `r_b`.\n+    ///\n+    /// Also available through the `FreeRegionRelations` trait below.\n+    pub fn sub_free_regions(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        r_a: Region<'tcx>,\n+        r_b: Region<'tcx>,\n+    ) -> bool {\n+        assert!(self.is_free_or_static(r_a) && self.is_free_or_static(r_b));\n+        let re_static = tcx.lifetimes.re_static;\n+        if self.check_relation(re_static, r_b) {\n+            // `'a <= 'static` is always true, and not stored in the\n+            // relation explicitly, so check if `'b` is `'static` (or\n+            // equivalent to it)\n+            true\n+        } else {\n+            self.check_relation(r_a, r_b)\n+        }\n+    }\n+\n+    /// Check whether `r_a <= r_b` is found in the relation\n+    fn check_relation(&self, r_a: Region<'tcx>, r_b: Region<'tcx>) -> bool {\n+        r_a == r_b || self.relation.contains(&r_a, &r_b)\n+    }\n+\n+    /// True for free regions other than `'static`.\n+    pub fn is_free(&self, r: Region<'_>) -> bool {\n+        match *r {\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// True if `r` is a free region or static of the sort that this\n+    /// free region map can be used with.\n+    pub fn is_free_or_static(&self, r: Region<'_>) -> bool {\n+        match *r {\n+            ty::ReStatic => true,\n+            _ => self.is_free(r),\n+        }\n+    }\n+\n     /// Computes the least-upper-bound of two free regions. In some\n     /// cases, this is more conservative than necessary, in order to\n     /// avoid making arbitrary choices. See\n@@ -39,13 +89,13 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         r_b: Region<'tcx>,\n     ) -> Region<'tcx> {\n         debug!(\"lub_free_regions(r_a={:?}, r_b={:?})\", r_a, r_b);\n-        assert!(is_free(r_a));\n-        assert!(is_free(r_b));\n+        assert!(self.is_free(r_a));\n+        assert!(self.is_free(r_b));\n         let result = if r_a == r_b {\n             r_a\n         } else {\n             match self.relation.postdom_upper_bound(&r_a, &r_b) {\n-                None => tcx.mk_region(ty::ReStatic),\n+                None => tcx.lifetimes.re_static,\n                 Some(r) => *r,\n             }\n         };\n@@ -60,31 +110,18 @@ impl<'tcx> FreeRegionMap<'tcx> {\n pub trait FreeRegionRelations<'tcx> {\n     /// Tests whether `r_a <= r_b`. Both must be free regions or\n     /// `'static`.\n-    fn sub_free_regions(&self, shorter: ty::Region<'tcx>, longer: ty::Region<'tcx>) -> bool;\n+    fn sub_free_regions(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        shorter: ty::Region<'tcx>,\n+        longer: ty::Region<'tcx>,\n+    ) -> bool;\n }\n \n impl<'tcx> FreeRegionRelations<'tcx> for FreeRegionMap<'tcx> {\n-    fn sub_free_regions(&self, r_a: Region<'tcx>, r_b: Region<'tcx>) -> bool {\n-        assert!(is_free_or_static(r_a) && is_free_or_static(r_b));\n-        if let ty::ReStatic = r_b {\n-            true // `'a <= 'static` is just always true, and not stored in the relation explicitly\n-        } else {\n-            r_a == r_b || self.relation.contains(&r_a, &r_b)\n-        }\n-    }\n-}\n-\n-fn is_free(r: Region<'_>) -> bool {\n-    match *r {\n-        ty::ReEarlyBound(_) | ty::ReFree(_) => true,\n-        _ => false,\n-    }\n-}\n-\n-fn is_free_or_static(r: Region<'_>) -> bool {\n-    match *r {\n-        ty::ReStatic => true,\n-        _ => is_free(r),\n+    fn sub_free_regions(&self, tcx: TyCtxt<'tcx>, r_a: Region<'tcx>, r_b: Region<'tcx>) -> bool {\n+        // invoke the \"inherent method\"\n+        self.sub_free_regions(tcx, r_a, r_b)\n     }\n }\n "}, {"sha": "4caab458025b19e41b28c9737db1727b277d8b78", "filename": "src/librustc_mir/borrow_check/type_check/free_region_relations.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b52414fedebe9774bf8a5339eb5042a2fa3dc9a3/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b52414fedebe9774bf8a5339eb5042a2fa3dc9a3/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs?ref=b52414fedebe9774bf8a5339eb5042a2fa3dc9a3", "patch": "@@ -5,7 +5,7 @@ use rustc::mir::ConstraintCategory;\n use rustc::traits::query::outlives_bounds::{self, OutlivesBound};\n use rustc::traits::query::type_op::{self, TypeOp};\n use rustc::ty::free_region_map::FreeRegionRelations;\n-use rustc::ty::{self, RegionVid, Ty};\n+use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n use rustc_span::DUMMY_SP;\n use std::rc::Rc;\n@@ -359,7 +359,12 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n /// over the `FreeRegionMap` from lexical regions and\n /// `UniversalRegions` (from NLL)`.\n impl<'tcx> FreeRegionRelations<'tcx> for UniversalRegionRelations<'tcx> {\n-    fn sub_free_regions(&self, shorter: ty::Region<'tcx>, longer: ty::Region<'tcx>) -> bool {\n+    fn sub_free_regions(\n+        &self,\n+        _tcx: TyCtxt<'tcx>,\n+        shorter: ty::Region<'tcx>,\n+        longer: ty::Region<'tcx>,\n+    ) -> bool {\n         let shorter = shorter.to_region_vid();\n         assert!(self.universal_regions.is_universal_region(shorter));\n         let longer = longer.to_region_vid();"}]}