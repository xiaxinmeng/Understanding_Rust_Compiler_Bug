{"sha": "4679eb3a0d09219b4bd815c636eb55e5b05c5a5e", "node_id": "C_kwDOAAsO6NoAKDQ2NzllYjNhMGQwOTIxOWI0YmQ4MTVjNjM2ZWI1NWU1YjA1YzVhNWU", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2021-10-20T04:13:42Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2021-10-20T04:13:42Z"}, "message": "Move const int value code to utils", "tree": {"sha": "9617bf8b07fed269332ca1034efa19ade4d1e61b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9617bf8b07fed269332ca1034efa19ade4d1e61b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4679eb3a0d09219b4bd815c636eb55e5b05c5a5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4679eb3a0d09219b4bd815c636eb55e5b05c5a5e", "html_url": "https://github.com/rust-lang/rust/commit/4679eb3a0d09219b4bd815c636eb55e5b05c5a5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4679eb3a0d09219b4bd815c636eb55e5b05c5a5e/comments", "author": null, "committer": null, "parents": [{"sha": "5bdd2cebe24455c7cffa056a4ce3497ab58ee8c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bdd2cebe24455c7cffa056a4ce3497ab58ee8c8", "html_url": "https://github.com/rust-lang/rust/commit/5bdd2cebe24455c7cffa056a4ce3497ab58ee8c8"}], "stats": {"total": 136, "additions": 71, "deletions": 65}, "files": [{"sha": "82438d85c7a3a353128134b0736e587c4dc9d5f1", "filename": "clippy_lints/src/invalid_upcast_comparisons.rs", "status": "modified", "additions": 3, "deletions": 65, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4679eb3a0d09219b4bd815c636eb55e5b05c5a5e/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4679eb3a0d09219b4bd815c636eb55e5b05c5a5e/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs?ref=4679eb3a0d09219b4bd815c636eb55e5b05c5a5e", "patch": "@@ -1,17 +1,15 @@\n-use std::cmp::Ordering;\n-\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, IntTy, UintTy};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n \n+use clippy_utils::comparisons;\n use clippy_utils::comparisons::Rel;\n-use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::consts::{constant_full_int, FullInt};\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::source::snippet;\n-use clippy_utils::{comparisons, sext};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -39,53 +37,6 @@ declare_clippy_lint! {\n \n declare_lint_pass!(InvalidUpcastComparisons => [INVALID_UPCAST_COMPARISONS]);\n \n-#[derive(Copy, Clone, Debug, Eq)]\n-enum FullInt {\n-    S(i128),\n-    U(u128),\n-}\n-\n-impl FullInt {\n-    #[allow(clippy::cast_sign_loss)]\n-    #[must_use]\n-    fn cmp_s_u(s: i128, u: u128) -> Ordering {\n-        if s < 0 {\n-            Ordering::Less\n-        } else if u > (i128::MAX as u128) {\n-            Ordering::Greater\n-        } else {\n-            (s as u128).cmp(&u)\n-        }\n-    }\n-}\n-\n-impl PartialEq for FullInt {\n-    #[must_use]\n-    fn eq(&self, other: &Self) -> bool {\n-        self.partial_cmp(other).expect(\"`partial_cmp` only returns `Some(_)`\") == Ordering::Equal\n-    }\n-}\n-\n-impl PartialOrd for FullInt {\n-    #[must_use]\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(match (self, other) {\n-            (&Self::S(s), &Self::S(o)) => s.cmp(&o),\n-            (&Self::U(s), &Self::U(o)) => s.cmp(&o),\n-            (&Self::S(s), &Self::U(o)) => Self::cmp_s_u(s, o),\n-            (&Self::U(s), &Self::S(o)) => Self::cmp_s_u(o, s).reverse(),\n-        })\n-    }\n-}\n-\n-impl Ord for FullInt {\n-    #[must_use]\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.partial_cmp(other)\n-            .expect(\"`partial_cmp` for FullInt can never return `None`\")\n-    }\n-}\n-\n fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) -> Option<(FullInt, FullInt)> {\n     if let ExprKind::Cast(cast_exp, _) = expr.kind {\n         let pre_cast_ty = cx.typeck_results().expr_ty(cast_exp);\n@@ -118,19 +69,6 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) ->\n     }\n }\n \n-fn node_as_const_fullint<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<FullInt> {\n-    let val = constant(cx, cx.typeck_results(), expr)?.0;\n-    if let Constant::Int(const_int) = val {\n-        match *cx.typeck_results().expr_ty(expr).kind() {\n-            ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n-            ty::Uint(_) => Some(FullInt::U(const_int)),\n-            _ => None,\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n fn err_upcast_comparison(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, always: bool) {\n     if let ExprKind::Cast(cast_val, _) = expr.kind {\n         span_lint(\n@@ -156,7 +94,7 @@ fn upcast_comparison_bounds_err<'tcx>(\n     invert: bool,\n ) {\n     if let Some((lb, ub)) = lhs_bounds {\n-        if let Some(norm_rhs_val) = node_as_const_fullint(cx, rhs) {\n+        if let Some(norm_rhs_val) = constant_full_int(cx, cx.typeck_results(), rhs) {\n             if rel == Rel::Eq || rel == Rel::Ne {\n                 if norm_rhs_val < lb || norm_rhs_val > ub {\n                     err_upcast_comparison(cx, span, lhs, rel == Rel::Ne);"}, {"sha": "3e5d74a66f4e8200fcbee161cc9bd3a1705fbe05", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4679eb3a0d09219b4bd815c636eb55e5b05c5a5e/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4679eb3a0d09219b4bd815c636eb55e5b05c5a5e/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=4679eb3a0d09219b4bd815c636eb55e5b05c5a5e", "patch": "@@ -155,6 +155,19 @@ impl Constant {\n             _ => None,\n         }\n     }\n+\n+    /// Returns the integer value or `None` if `self` or `val_type` is not integer type.\n+    pub fn int_value(&self, cx: &LateContext<'_>, val_type: Ty<'_>) -> Option<FullInt> {\n+        if let Constant::Int(const_int) = *self {\n+            match *val_type.kind() {\n+                ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n+                ty::Uint(_) => Some(FullInt::U(const_int)),\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        }\n+    }\n }\n \n /// Parses a `LitKind` to a `Constant`.\n@@ -202,6 +215,61 @@ pub fn constant_simple<'tcx>(\n     constant(lcx, typeck_results, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n }\n \n+pub fn constant_full_int(\n+    lcx: &LateContext<'tcx>,\n+    typeck_results: &ty::TypeckResults<'tcx>,\n+    e: &Expr<'_>,\n+) -> Option<FullInt> {\n+    constant_simple(lcx, typeck_results, e)?.int_value(lcx, typeck_results.expr_ty(e))\n+}\n+\n+#[derive(Copy, Clone, Debug, Eq)]\n+pub enum FullInt {\n+    S(i128),\n+    U(u128),\n+}\n+\n+impl FullInt {\n+    #[allow(clippy::cast_sign_loss)]\n+    #[must_use]\n+    fn cmp_s_u(s: i128, u: u128) -> Ordering {\n+        if s < 0 {\n+            Ordering::Less\n+        } else if u > (i128::MAX as u128) {\n+            Ordering::Greater\n+        } else {\n+            (s as u128).cmp(&u)\n+        }\n+    }\n+}\n+\n+impl PartialEq for FullInt {\n+    #[must_use]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.partial_cmp(other).expect(\"`partial_cmp` only returns `Some(_)`\") == Ordering::Equal\n+    }\n+}\n+\n+impl PartialOrd for FullInt {\n+    #[must_use]\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(match (self, other) {\n+            (&Self::S(s), &Self::S(o)) => s.cmp(&o),\n+            (&Self::U(s), &Self::U(o)) => s.cmp(&o),\n+            (&Self::S(s), &Self::U(o)) => Self::cmp_s_u(s, o),\n+            (&Self::U(s), &Self::S(o)) => Self::cmp_s_u(o, s).reverse(),\n+        })\n+    }\n+}\n+\n+impl Ord for FullInt {\n+    #[must_use]\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.partial_cmp(other)\n+            .expect(\"`partial_cmp` for FullInt can never return `None`\")\n+    }\n+}\n+\n /// Creates a `ConstEvalLateContext` from the given `LateContext` and `TypeckResults`.\n pub fn constant_context<'a, 'tcx>(\n     lcx: &'a LateContext<'tcx>,"}]}