{"sha": "e02fac4896fb30eb82d52dda07db8f3ef3bc456a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMmZhYzQ4OTZmYjMwZWI4MmQ1MmRkYTA3ZGI4ZjNlZjNiYzQ1NmE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2017-01-04T21:46:41Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2017-01-04T23:50:43Z"}, "message": "Rustup to rustc 1.16.0-nightly (468227129 2017-01-03): Recover patterns from arguments", "tree": {"sha": "599dbad6388deb5b9e261af0f8606e1d3e871110", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/599dbad6388deb5b9e261af0f8606e1d3e871110"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e02fac4896fb30eb82d52dda07db8f3ef3bc456a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e02fac4896fb30eb82d52dda07db8f3ef3bc456a", "html_url": "https://github.com/rust-lang/rust/commit/e02fac4896fb30eb82d52dda07db8f3ef3bc456a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a262e3bb0b74e8e9210ee36a43145d8d33d0425d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a262e3bb0b74e8e9210ee36a43145d8d33d0425d", "html_url": "https://github.com/rust-lang/rust/commit/a262e3bb0b74e8e9210ee36a43145d8d33d0425d"}], "stats": {"total": 82, "additions": 46, "deletions": 36}, "files": [{"sha": "0b34bb99bc7f4f2c0ea6fe9dff3f26a38386a177", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=e02fac4896fb30eb82d52dda07db8f3ef3bc456a", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use rustc::ty;\n use rustc::hir::*;\n-use utils::{snippet_opt, span_lint_and_then, is_adjusted};\n+use utils::{snippet_opt, span_lint_and_then, is_adjusted, iter_input_pats};\n \n #[allow(missing_copy_implementations)]\n pub struct EtaPass;\n@@ -49,7 +49,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n \n fn check_closure(cx: &LateContext, expr: &Expr) {\n     if let ExprClosure(_, ref decl, eid, _) = expr.node {\n-        let ex = cx.tcx.map.body(eid).value;\n+        let body = cx.tcx.map.body(eid);\n+        let ex = body.value;\n         if let ExprCall(ref caller, ref args) = ex.node {\n             if args.len() != decl.inputs.len() {\n                 // Not the same number of arguments, there\n@@ -71,8 +72,8 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                 },\n                 _ => (),\n             }\n-            for (a1, a2) in decl.inputs.iter().zip(args) {\n-                if let PatKind::Binding(_, _, ident, _) = a1.node {\n+            for (a1, a2) in iter_input_pats(decl, body).zip(args) {\n+                if let PatKind::Binding(_, _, ident, _) = a1.pat.node {\n                     // XXXManishearth Should I be checking the binding mode here?\n                     if let ExprPath(QPath::Resolved(None, ref p)) = a2.node {\n                         if p.segments.len() != 1 {"}, {"sha": "784bca40377295b3a0fa08d3132b64e6c6d2f273", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=e02fac4896fb30eb82d52dda07db8f3ef3bc456a", "patch": "@@ -6,7 +6,7 @@ use std::collections::HashSet;\n use syntax::ast;\n use syntax::abi::Abi;\n use syntax::codemap::Span;\n-use utils::{span_lint, type_is_unsafe_function};\n+use utils::{span_lint, type_is_unsafe_function, iter_input_pats};\n \n /// **What it does:** Checks for functions with too many parameters.\n ///\n@@ -102,7 +102,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n             }\n         }\n \n-        self.check_raw_ptr(cx, unsafety, decl, &body.value, nodeid);\n+        self.check_raw_ptr(cx, unsafety, decl, &body, nodeid);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n@@ -113,8 +113,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n             }\n \n             if let hir::TraitMethod::Provided(eid) = eid {\n-                let expr = cx.tcx.map.body(eid).value;\n-                self.check_raw_ptr(cx, sig.unsafety, &sig.decl, &expr, item.id);\n+                let body = cx.tcx.map.body(eid);\n+                self.check_raw_ptr(cx, sig.unsafety, &sig.decl, &body, item.id);\n             }\n         }\n     }\n@@ -136,11 +136,14 @@ impl<'a, 'tcx> Functions {\n         cx: &LateContext<'a, 'tcx>,\n         unsafety: hir::Unsafety,\n         decl: &'tcx hir::FnDecl,\n-        expr: &'tcx hir::Expr,\n+        body: &'tcx hir::Body,\n         nodeid: ast::NodeId\n     ) {\n+        let expr = &body.value;\n         if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(nodeid) {\n-            let raw_ptrs = decl.inputs.iter().filter_map(|arg| raw_ptr_arg(cx, arg)).collect::<HashSet<_>>();\n+            let raw_ptrs = iter_input_pats(&decl, body).zip(decl.inputs.iter())\n+                                                            .filter_map(|(arg, ty)| raw_ptr_arg(arg, ty))\n+                                                            .collect::<HashSet<_>>();\n \n             if !raw_ptrs.is_empty() {\n                 let mut v = DerefVisitor {\n@@ -154,8 +157,8 @@ impl<'a, 'tcx> Functions {\n     }\n }\n \n-fn raw_ptr_arg(cx: &LateContext, arg: &hir::Arg) -> Option<hir::def_id::DefId> {\n-    if let (&hir::PatKind::Binding(_, def_id, _, _), &hir::TyPtr(_)) = (&arg.pat.node, &cx.tcx.map.get(arg.id)) {\n+fn raw_ptr_arg(arg: &hir::Arg, ty: &hir::Ty) -> Option<hir::def_id::DefId> {\n+    if let (&hir::PatKind::Binding(_, def_id, _, _), hir::TyPtr(_)) = (&arg.pat.node, ty.node) {\n         Some(def_id)\n     } else {\n         None"}, {"sha": "fa4a5bf67573dcf03ab5553789fb23ef71758c9c", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=e02fac4896fb30eb82d52dda07db8f3ef3bc456a", "patch": "@@ -104,7 +104,7 @@ fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItemRef]\n \n     if !trait_items.iter().any(|i| is_named_self(cx, i, \"is_empty\")) {\n         if let Some(i) = trait_items.iter().find(|i| is_named_self(cx, i, \"len\")) {\n-            if cx.access_levels.is_exported(i.id) {\n+            if cx.access_levels.is_exported(i.id.node_id) {\n                 span_lint(cx,\n                           LEN_WITHOUT_IS_EMPTY,\n                           i.span,"}, {"sha": "cdcb271d8d7589b1b2881704e0300b13e3c704e8", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=e02fac4896fb30eb82d52dda07db8f3ef3bc456a", "patch": "@@ -8,6 +8,7 @@\n #![feature(slice_patterns)]\n #![feature(stmt_expr_attributes)]\n #![feature(repeat_str)]\n+#![feature(conservative_impl_trait)]\n \n #![allow(indexing_slicing, shadow_reuse, unknown_lints, missing_docs_in_private_items)]\n #![allow(needless_lifetimes)]"}, {"sha": "311eb16514b94863a4f8645c693d801ef9f2e04e", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=e02fac4896fb30eb82d52dda07db8f3ef3bc456a", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc::hir::*;\n use syntax::ast;\n use utils::{is_adjusted, match_path, match_trait_method, match_type, remove_blocks, paths, snippet,\n-            span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n+            span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, iter_input_pats};\n \n /// **What it does:** Checks for mapping `clone()` over an iterator.\n ///\n@@ -31,18 +31,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if &*name.node.as_str() == \"map\" && args.len() == 2 {\n                 match args[1].node {\n                     ExprClosure(_, ref decl, closure_eid, _) => {\n-                        let closure_expr = remove_blocks(&cx.tcx.map.body(closure_eid).value);\n+                        let body = cx.tcx.map.body(closure_eid);\n+                        let closure_expr = remove_blocks(&body.value);\n                         if_let_chain! {[\n                             // nothing special in the argument, besides reference bindings\n                             // (e.g. .map(|&x| x) )\n-                            let Some(arg_ident) = get_arg_name(&*decl.inputs[0]),\n+                            let Some(first_arg) = iter_input_pats(decl, body).next(),\n+                            let Some(arg_ident) = get_arg_name(&first_arg.pat),\n                             // the method is being called on a known type (option or iterator)\n                             let Some(type_name) = get_type_name(cx, expr, &args[0])\n                         ], {\n                             // look for derefs, for .map(|x| *x)\n                             if only_derefs(cx, &*closure_expr, arg_ident) &&\n                                 // .cloned() only removes one level of indirection, don't lint on more\n-                                walk_ptrs_ty_depth(cx.tcx.tables().pat_ty(&*decl.inputs[0])).1 == 1\n+                                walk_ptrs_ty_depth(cx.tcx.tables().pat_ty(&first_arg.pat)).1 == 1\n                             {\n                                 span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n                                     \"you seem to be using .map() to clone the contents of an {}, consider \\"}, {"sha": "ab84a7f927db9c6855b78e66e9262d2a4833d35f", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=e02fac4896fb30eb82d52dda07db8f3ef3bc456a", "patch": "@@ -11,7 +11,7 @@ use syntax::codemap::Span;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, match_path, match_trait_method,\n             match_type, method_chain_args, return_ty, same_tys, snippet, span_lint, span_lint_and_then,\n             span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, last_path_segment, single_segment_path,\n-            match_def_path, is_self};\n+            match_def_path, is_self, iter_input_pats};\n use utils::paths;\n use utils::sugg;\n \n@@ -636,16 +636,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         let parent = cx.tcx.map.get_parent(implitem.id);\n         let item = cx.tcx.map.expect_item(parent);\n         if_let_chain! {[\n-            let hir::ImplItemKind::Method(ref sig, _) = implitem.node,\n-            let Some(first_arg) = sig.decl.inputs.get(0),\n+            let hir::ImplItemKind::Method(ref sig, id) = implitem.node,\n+            let body = cx.tcx.map.body(id),\n+            let Some(first_arg) = iter_input_pats(&sig.decl, body).next(),\n             let hir::ItemImpl(_, _, _, None, _, _) = item.node,\n         ], {\n             // check missing trait implementations\n             for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n                 if &*name.as_str() == method_name &&\n                    sig.decl.inputs.len() == n_args &&\n                    out_type.matches(&sig.decl.output) &&\n-                   self_kind.matches(&**first_arg, false) {\n+                   self_kind.matches(&first_arg, false) {\n                     span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n                         \"defining a method called `{}` on this type; consider implementing \\\n                          the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n@@ -658,8 +659,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             for &(ref conv, self_kinds) in &CONVENTIONS {\n                 if_let_chain! {[\n                     conv.check(&name.as_str()),\n-                    let Some(explicit_self) = sig.decl.inputs.get(0),\n-                    !self_kinds.iter().any(|k| k.matches(&**explicit_self, is_copy)),\n+                    !self_kinds.iter().any(|k| k.matches(&first_arg, is_copy)),\n                 ], {\n                     let lint = if item.vis == hir::Visibility::Public {\n                         WRONG_PUB_SELF_CONVENTION\n@@ -668,7 +668,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     };\n                     span_lint(cx,\n                               lint,\n-                              explicit_self.span,\n+                              first_arg.pat.span,\n                               &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n                                         ambiguous name\",\n                                        conv,\n@@ -684,7 +684,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                !ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id)) {\n                 span_lint(cx,\n                           NEW_RET_NO_SELF,\n-                          first_arg.span,\n+                          implitem.span,\n                           \"methods called `new` usually return `Self`\");\n             }\n         }}"}, {"sha": "4af47d731726620fdf1d8e4726af6d69b181618e", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=e02fac4896fb30eb82d52dda07db8f3ef3bc456a", "patch": "@@ -9,7 +9,7 @@ use rustc_const_eval::eval_const_expr_partial;\n use rustc_const_math::ConstFloat;\n use syntax::codemap::{Span, Spanned, ExpnFormat};\n use utils::{get_item_name, get_parent_expr, implements_trait, in_macro, is_integer_literal, match_path, snippet,\n-            span_lint, span_lint_and_then, walk_ptrs_ty, last_path_segment};\n+            span_lint, span_lint_and_then, walk_ptrs_ty, last_path_segment, iter_input_pats};\n use utils::sugg::Sugg;\n \n /// **What it does:** Checks for function arguments and let bindings denoted as `ref`.\n@@ -175,19 +175,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         cx: &LateContext<'a, 'tcx>,\n         k: FnKind<'tcx>,\n         decl: &'tcx FnDecl,\n-        _: &'tcx Body,\n+        body: &'tcx Body,\n         _: Span,\n         _: NodeId\n     ) {\n         if let FnKind::Closure(_) = k {\n             // Does not apply to closures\n             return;\n         }\n-        for arg in &decl.inputs {\n-            if let PatKind::Binding(BindByRef(_), _, _, _) = arg.node {\n+        for arg in iter_input_pats(decl, body) {\n+            if let PatKind::Binding(BindByRef(_), _, _, _) = arg.pat.node {\n                 span_lint(cx,\n                           TOPLEVEL_REF_ARG,\n-                          arg.span,\n+                          arg.pat.span,\n                           \"`ref` directly on a function argument is ignored. Consider using a reference type instead.\");\n             }\n         }"}, {"sha": "6cf8a337be1a68558ecfad19f094cc4dbc5ba108", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=e02fac4896fb30eb82d52dda07db8f3ef3bc456a", "patch": "@@ -4,7 +4,7 @@ use rustc::hir::*;\n use rustc::hir::intravisit::{Visitor, FnKind, NestedVisitorMap};\n use rustc::ty;\n use syntax::codemap::Span;\n-use utils::{higher, in_external_macro, snippet, span_lint_and_then};\n+use utils::{higher, in_external_macro, snippet, span_lint_and_then, iter_input_pats};\n \n /// **What it does:** Checks for bindings that shadow other bindings already in\n /// scope, while just changing reference level or mutability.\n@@ -92,18 +92,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if in_external_macro(cx, body.value.span) {\n             return;\n         }\n-        check_fn(cx, decl, &body.value);\n+        check_fn(cx, decl, &body);\n     }\n }\n \n-fn check_fn<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, expr: &'tcx Expr) {\n+fn check_fn<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, body: &'tcx Body) {\n     let mut bindings = Vec::new();\n-    for arg in &decl.inputs {\n-        if let PatKind::Binding(_, _, ident, _) = arg.node {\n+    for arg in iter_input_pats(decl, body) {\n+        if let PatKind::Binding(_, _, ident, _) = arg.pat.node {\n             bindings.push((ident.node, ident.span))\n         }\n     }\n-    check_expr(cx, expr, &mut bindings);\n+    check_expr(cx, &body.value, &mut bindings);\n }\n \n fn check_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, block: &'tcx Block, bindings: &mut Vec<(Name, Span)>) {"}, {"sha": "9dc623dbe5f0d1d5b509d1411945ef8114b4f5af", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02fac4896fb30eb82d52dda07db8f3ef3bc456a/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=e02fac4896fb30eb82d52dda07db8f3ef3bc456a", "patch": "@@ -906,3 +906,6 @@ pub fn is_self(slf: &Arg) -> bool {\n     }\n }\n \n+pub fn iter_input_pats<'tcx>(decl: &FnDecl, body: &'tcx Body) -> impl Iterator<Item=&'tcx Arg> {\n+    (0..decl.inputs.len()).map(move |i| &body.arguments[i])\n+}\n\\ No newline at end of file"}]}