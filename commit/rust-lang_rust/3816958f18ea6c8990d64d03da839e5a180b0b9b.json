{"sha": "3816958f18ea6c8990d64d03da839e5a180b0b9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MTY5NThmMThlYTZjODk5MGQ2NGQwM2RhODM5ZTVhMTgwYjBiOWI=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-02-28T22:43:53Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-06-05T20:09:26Z"}, "message": "Implemented for function bounds, type bounds, and named existential types.", "tree": {"sha": "1bf9dca622038936fb05d803c5cd441b7e95885e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bf9dca622038936fb05d803c5cd441b7e95885e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3816958f18ea6c8990d64d03da839e5a180b0b9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3816958f18ea6c8990d64d03da839e5a180b0b9b", "html_url": "https://github.com/rust-lang/rust/commit/3816958f18ea6c8990d64d03da839e5a180b0b9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3816958f18ea6c8990d64d03da839e5a180b0b9b/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dce27cba78ebda2c5adfe149d33af5a88a28d08d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dce27cba78ebda2c5adfe149d33af5a88a28d08d", "html_url": "https://github.com/rust-lang/rust/commit/dce27cba78ebda2c5adfe149d33af5a88a28d08d"}], "stats": {"total": 563, "additions": 367, "deletions": 196}, "files": [{"sha": "5a0e9d53b0833f9117097b2a616d592b1277ca53", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 47, "deletions": 21, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -69,7 +69,7 @@ use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::Token;\n use syntax::visit::{self, Visitor};\n-use syntax_pos::{edition, Span};\n+use syntax_pos::{DUMMY_SP, edition, Span};\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n@@ -191,9 +191,9 @@ enum ImplTraitContext<'a> {\n     /// equivalent to a fresh existential parameter like `existential type T; fn foo() -> T`.\n     ///\n     /// We optionally store a `DefId` for the parent item here so we can look up necessary\n-    /// information later. It is `None` when no information about the context should be stored,\n-    /// e.g., for consts and statics.\n-    Existential(Option<DefId>),\n+    /// information later. It is `None` when no information about the context should be stored\n+    /// (e.g., for consts and statics).\n+    Existential(Option<DefId> /* fn def-ID */),\n \n     /// `impl Trait` is not accepted in this position.\n     Disallowed(ImplTraitPosition),\n@@ -216,7 +216,7 @@ impl<'a> ImplTraitContext<'a> {\n         use self::ImplTraitContext::*;\n         match self {\n             Universal(params) => Universal(params),\n-            Existential(did) => Existential(*did),\n+            Existential(fn_def_id) => Existential(*fn_def_id),\n             Disallowed(pos) => Disallowed(*pos),\n         }\n     }\n@@ -1342,13 +1342,36 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_ty_binding(&mut self, b: &TypeBinding,\n-                        itctx: ImplTraitContext<'_>) -> hir::TypeBinding {\n+    fn lower_assoc_ty_constraint(&mut self,\n+                                 c: &AssocTyConstraint,\n+                                 itctx: ImplTraitContext<'_>)\n+                                 -> hir::TypeBinding {\n+        let ty = match c.kind {\n+            AssocTyConstraintKind::Equality { ref ty } => self.lower_ty(ty, itctx),\n+            AssocTyConstraintKind::Bound { ref bounds } => {\n+                // Desugar `AssocTy: Bounds` into `AssocTy = impl Bounds`.\n+                let impl_ty_node_id = self.sess.next_node_id();\n+                let parent_def_index = self.current_hir_id_owner.last().unwrap().0;\n+                self.resolver.definitions().create_def_with_parent(\n+                    parent_def_index,\n+                    impl_ty_node_id,\n+                    DefPathData::Misc,\n+                    DefIndexAddressSpace::High,\n+                    Mark::root(),\n+                    DUMMY_SP);\n+                self.lower_ty(&Ty {\n+                    id: self.sess.next_node_id(),\n+                    node: TyKind::ImplTrait(impl_ty_node_id, bounds.clone()),\n+                    span: DUMMY_SP,\n+                }, itctx)\n+            }\n+        };\n+\n         hir::TypeBinding {\n-            hir_id: self.lower_node_id(b.id),\n-            ident: b.ident,\n-            ty: self.lower_ty(&b.ty, itctx),\n-            span: b.span,\n+            hir_id: self.lower_node_id(c.id),\n+            ident: c.ident,\n+            ty\n+            span: c.span,\n         }\n     }\n \n@@ -1604,7 +1627,7 @@ impl<'a> LoweringContext<'a> {\n                 origin: hir::ExistTyOrigin::ReturnImplTrait,\n             };\n \n-            trace!(\"exist ty from impl trait def index: {:#?}\", exist_ty_def_index);\n+            trace!(\"exist ty from impl trait def-index: {:#?}\", exist_ty_def_index);\n             let exist_ty_id = lctx.generate_existential_type(\n                 exist_ty_node_id,\n                 exist_ty_item,\n@@ -1617,7 +1640,7 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    /// Registers a new existential type with the proper NodeIds and\n+    /// Registers a new existential type with the proper `NodeId`ss and\n     /// returns the lowered node ID for the existential type.\n     fn generate_existential_type(\n         &mut self,\n@@ -2195,15 +2218,16 @@ impl<'a> LoweringContext<'a> {\n         param_mode: ParamMode,\n         mut itctx: ImplTraitContext<'_>,\n     ) -> (hir::GenericArgs, bool) {\n-        let &AngleBracketedArgs { ref args, ref bindings, .. } = data;\n+        let &AngleBracketedArgs { ref args, ref constraints, .. } = data;\n         let has_types = args.iter().any(|arg| match arg {\n             ast::GenericArg::Type(_) => true,\n             _ => false,\n         });\n         (\n             hir::GenericArgs {\n                 args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n-                bindings: bindings.iter().map(|b| self.lower_ty_binding(b, itctx.reborrow())).collect(),\n+                bindings: constraints.iter().map(\n+                    |b| self.lower_assoc_ty_constraint(b, itctx.reborrow())).collect(),\n                 parenthesized: false,\n             },\n             !has_types && param_mode == ParamMode::Optional\n@@ -3236,12 +3260,14 @@ impl<'a> LoweringContext<'a> {\n                 self.lower_ty(t, ImplTraitContext::disallowed()),\n                 self.lower_generics(generics, ImplTraitContext::disallowed()),\n             ),\n-            ItemKind::Existential(ref b, ref generics) => hir::ItemKind::Existential(hir::ExistTy {\n-                generics: self.lower_generics(generics, ImplTraitContext::disallowed()),\n-                bounds: self.lower_param_bounds(b, ImplTraitContext::disallowed()),\n-                impl_trait_fn: None,\n-                origin: hir::ExistTyOrigin::ExistentialType,\n-            }),\n+            ItemKind::Existential(ref b, ref generics) => hir::ItemKind::Existential(\n+                hir::ExistTy {\n+                    generics: self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                    bounds: self.lower_param_bounds(b, ImplTraitContext::Existential(None)),\n+                    impl_trait_fn: None,\n+                    origin: hir::ExistTyOrigin::ExistentialType,\n+                },\n+            ),\n             ItemKind::Enum(ref enum_definition, ref generics) => hir::ItemKind::Enum(\n                 hir::EnumDef {\n                     variants: enum_definition"}, {"sha": "b01eed8f6609dea0b6b0a1532f29698e5684e008", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -397,6 +397,11 @@ impl Definitions {\n         self.node_to_hir_id[node_id]\n     }\n \n+    #[inline]\n+    pub fn def_index_to_node_id(&self, def_index: DefIndex) -> ast::NodeId {\n+        self.as_local_node_id(DefId::local(def_index)).unwrap()\n+    }\n+\n     /// Retrieves the span of the given `DefId` if `DefId` is in the local crate, the span exists\n     /// and it's not `DUMMY_SP`.\n     #[inline]"}, {"sha": "cdbeb8a4a545dd6f0ec99cea4946de7d91934a66", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 64, "deletions": 19, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -288,7 +288,7 @@ impl<'hir> Map<'hir> {\n \n     #[inline]\n     pub fn def_index_to_node_id(&self, def_index: DefIndex) -> NodeId {\n-        self.definitions.as_local_node_id(DefId::local(def_index)).unwrap()\n+        self.definitions.def_index_to_node_id(def_index)\n     }\n \n     #[inline]\n@@ -649,16 +649,16 @@ impl<'hir> Map<'hir> {\n         result\n     }\n \n-    /// Similar to `get_parent`; returns the parent node-id, or own `id` if there is\n-    /// no parent. Note that the parent may be `CRATE_NODE_ID`, which is not itself\n-    /// present in the map -- so passing the return value of get_parent_node to\n-    /// get may actually panic.\n-    /// This function returns the immediate parent in the AST, whereas get_parent\n+    /// Similar to `get_parent`; returns the parent node-ID, or just `hir_id` if there\n+    /// is no parent. Note that the parent may be `CRATE_NODE_ID`, which is not itself\n+    /// present in the map, so passing the return value of `get_parent_node` to\n+    /// `get` may in fact panic.\n+    /// This function returns the immediate parent in the AST, whereas `get_parent`\n     /// returns the enclosing item. Note that this might not be the actual parent\n-    /// node in the AST - some kinds of nodes are not in the map and these will\n-    /// never appear as the parent_node. So you can always walk the `parent_nodes`\n-    /// from a node to the root of the ast (unless you get the same ID back here\n-    /// that can happen if the ID is not in the map itself or is just weird).\n+    /// node in the AST -- some kinds of nodes are not in the map and these will\n+    /// never appear as the parent node. Thus, you can always walk the parent nodes\n+    /// from a node to the root of the AST (unless you get back the same ID here,\n+    /// which can happen if the ID is not in the map itself or is just weird).\n     pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n         let hir_id = self.node_to_hir_id(id);\n         let parent_hir_id = self.get_parent_node_by_hir_id(hir_id);\n@@ -841,21 +841,66 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Returns the nearest enclosing scope. A scope is an item or block.\n-    /// FIXME: it is not clear to me that all items qualify as scopes -- statics\n-    /// and associated types probably shouldn't, for example. Behavior in this\n-    /// regard should be expected to be highly unstable.\n-    pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n+    /// Returns the nearest enclosing scope. A scope is roughly an item or block.\n+    pub fn get_enclosing_scope(&self, id: HirId) -> Option<HirId> {\n         self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(_) |\n-            Node::ForeignItem(_) |\n-            Node::TraitItem(_) |\n-            Node::ImplItem(_) |\n+            Node::Item(i) => {\n+                match i.node {\n+                    ItemKind::Fn(..)\n+                    | ItemKind::Mod(..)\n+                    | ItemKind::Enum(..)\n+                    | ItemKind::Struct(..)\n+                    | ItemKind::Union(..)\n+                    | ItemKind::Trait(..)\n+                    | ItemKind::Impl(..) => true,\n+                    _ => false,\n+                }\n+            },\n+            Node::ForeignItem(fi) => {\n+                match fi.node {\n+                    ForeignItemKind::Fn(..) => true,\n+                    _ => false,\n+                }\n+            },\n+            Node::TraitItem(ti) => {\n+                match ti.node {\n+                    TraitItemKind::Method(..) => true,\n+                    _ => false,\n+                }\n+            },\n+            Node::ImplItem(ii) => {\n+                match ii.node {\n+                    ImplItemKind::Method(..) => true,\n+                    _ => false,\n+                }\n+            },\n             Node::Block(_) => true,\n             _ => false,\n         }, |_| false).ok()\n     }\n \n+    /// Returns the defining scope for an existential type definition.\n+    pub fn get_defining_scope(&self, id: NodeId) -> Option<NodeId> {\n+        let mut scope = id;\n+        loop {\n+            scope = self.get_enclosing_scope(scope)?;\n+            if scope == CRATE_NODE_ID {\n+                return Some(CRATE_NODE_ID);\n+            }\n+            match self.get(scope) {\n+                Node::Item(i) => {\n+                    match i.node {\n+                        ItemKind::Existential(ExistTy { impl_trait_fn: None, .. }) => {}\n+                        _ => break,\n+                    }\n+                }\n+                Node::Block(_) => {}\n+                _ => break,\n+            }\n+        }\n+        Some(scope)\n+    }\n+\n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n         let hir_id = self.node_to_hir_id(id);\n         self.get_parent_did_by_hir_id(hir_id)"}, {"sha": "ef216110c9e626100f3e7a701eaeab2a539d1382", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -786,13 +786,13 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                             match tcx.hir().find_by_hir_id(opaque_hir_id)\n                         {\n                             Some(Node::Item(item)) => match item.node {\n-                                // impl trait\n+                                // Anonymous `impl Trait`\n                                 hir::ItemKind::Existential(hir::ExistTy {\n                                     impl_trait_fn: Some(parent),\n                                     origin,\n                                     ..\n                                 }) => (parent == self.parent_def_id, origin),\n-                                // named existential types\n+                                // Named `existential type`\n                                 hir::ItemKind::Existential(hir::ExistTy {\n                                     impl_trait_fn: None,\n                                     origin,\n@@ -868,7 +868,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n \n         let predicates_of = tcx.predicates_of(def_id);\n         debug!(\n-            \"instantiate_opaque_types: predicates: {:#?}\",\n+            \"instantiate_opaque_types: predicates={:#?}\",\n             predicates_of,\n         );\n         let bounds = predicates_of.instantiate(tcx, substs);\n@@ -884,11 +884,11 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n         // (e.g., `existential type Foo<T: Bound>: Bar;` needs to be\n         // defined by a function like `fn foo<T: Bound>() -> Foo<T>`).\n         debug!(\n-            \"instantiate_opaque_types: param_env: {:#?}\",\n+            \"instantiate_opaque_types: param_env={:#?}\",\n             self.param_env,\n         );\n         debug!(\n-            \"instantiate_opaque_types: generics: {:#?}\",\n+            \"instantiate_opaque_types: generics={:#?}\",\n             tcx.generics_of(def_id),\n         );\n \n@@ -922,8 +922,9 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// Returns `true` if `opaque_node_id` is a sibling or a child of a sibling of `def_id`.\n+/// Returns `true` if `opaque_hir_id` is a sibling or a child of a sibling of `def_id`.\n ///\n+/// Example:\n /// ```rust\n /// pub mod foo {\n ///     pub mod bar {\n@@ -936,24 +937,28 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n /// }\n /// ```\n ///\n-/// Here, `def_id` is the `DefId` of the existential type `Baz` and `opaque_node_id` is the\n-/// `NodeId` of the reference to `Baz` (i.e., the return type of both `f1` and `f2`).\n-/// We return `true` if the reference is within the same module as the existential type\n-/// (i.e., `true` for `f1`, `false` for `f2`).\n+/// Here, `def_id` is the `DefId` of the defining use of the existential type (e.g., `f1` or `f2`),\n+/// and `opaque_hir_id` is the `HirId` of the definition of the existential type `Baz`.\n+/// For the above example, this function returns `true` for `f1` and `false` for `f2`.\n pub fn may_define_existential_type(\n     tcx: TyCtxt<'_, '_, '_>,\n     def_id: DefId,\n     opaque_hir_id: hir::HirId,\n ) -> bool {\n     let mut hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    // Named existential types can be defined by any siblings or\n-    // children of siblings.\n-    let mod_id = tcx.hir().get_parent_item(opaque_hir_id);\n-    // We walk up the node tree until we hit the root or the parent\n-    // of the opaque type.\n-    while hir_id != mod_id && node_id != ast::CRATE_HIR_ID {\n+    trace!(\n+        \"may_define_existential_type(def={:?}, opaque_node={:?})\",\n+        tcx.hir().get(hir_id),\n+        tcx.hir().get(opaque_hir_id)\n+    );\n+\n+    // Named existential types can be defined by any siblings or children of siblings.\n+    let scope_id = tcx.hir().get_defining_scope(opaque_hir_id)\n+                            .expect(\"could not get defining scope\");\n+    // We walk up the node tree until we hit the root or the scope of the opaque type.\n+    while hir_id != scope_id && hir_id != ast::CRATE_hir_ID {\n         hir_id = tcx.hir().get_parent_item(hir_id);\n     }\n-    // Syntactically we are allowed to define the concrete type.\n-    hir_id == mod_id\n+    // Syntactically, we are allowed to define the concrete type if:\n+    hir_id == scope_id\n }"}, {"sha": "7810d65e88cc16315c3049ae0e1f0f798ad45e7c", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -1848,8 +1848,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .iter()\n             .filter_map(|o| o.to_opt_poly_trait_ref());\n \n-        // micro-optimization: filter out predicates relating to different\n-        // traits.\n+        // Micro-optimization: filter out predicates relating to different traits.\n         let matching_bounds =\n             all_bounds.filter(|p| p.def_id() == stack.obligation.predicate.def_id());\n "}, {"sha": "f49f2110f23659804a419515dbe1599840c02cfc", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -716,8 +716,22 @@ impl<'a> ReplaceBodyWithLoop<'a> {\n                                     ast::GenericArg::Type(ty) => Some(ty),\n                                     _ => None,\n                                 });\n+                                let any_assoc_ty_bounds = data.constraints.iter().any(|c| {\n+                                    if let ast::AssocTyConstraintKind::Bound { .. } = c.kind {\n+                                        true\n+                                    } else {\n+                                        false\n+                                    }\n+                                });\n+                                any_assoc_ty_bounds ||\n                                 any_involves_impl_trait(types.into_iter()) ||\n-                                any_involves_impl_trait(data.bindings.iter().map(|b| &b.ty))\n+                                any_involves_impl_trait(data.constraints.iter().filter_map(|c| {\n+                                    if let ast::AssocTyConstraintKind::Equality { ref ty } = c.kind {\n+                                        Some(ty)\n+                                    } else {\n+                                        None\n+                                    }\n+                                }))\n                             },\n                             Some(&ast::GenericArgs::Parenthesized(ref data)) => {\n                                 any_involves_impl_trait(data.inputs.iter()) ||"}, {"sha": "2d602a7f1b468d4d361d7814573ef7c951f6560f", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -93,14 +93,16 @@ impl<'a> AstValidator<'a> {\n         self.outer_impl_trait = old;\n     }\n \n-    fn visit_assoc_type_binding_from_generic_args(&mut self, type_binding: &'a TypeBinding) {\n-        // rust-lang/rust#57979: bug in old `visit_generic_args` called\n-        // `walk_ty` rather than `visit_ty`, skipping outer `impl Trait`\n-        // if it happened to occur at `type_binding.ty`.\n-        if let TyKind::ImplTrait(..) = type_binding.ty.node {\n-            self.warning_period_57979_didnt_record_next_impl_trait = true;\n+    fn visit_assoc_ty_constraint_from_generic_args(&mut self, constraint: &'a AssocTyConstraint) {\n+        if let AssocTyConstraintKind::Equality { ref ty } = constraint.kind {\n+            // rust-lang/rust#57979: bug in old `visit_generic_args` called\n+            // `walk_ty` rather than `visit_ty`, skipping outer `impl Trait`\n+            // if it happened to occur at `ty`.\n+            if let TyKind::ImplTrait(..) = ty.node {\n+                self.warning_period_57979_didnt_record_next_impl_trait = true;\n+            }\n         }\n-        self.visit_assoc_type_binding(type_binding);\n+        self.visit_assoc_ty_constraint(constraint);\n     }\n \n     fn visit_ty_from_generic_args(&mut self, ty: &'a Ty) {\n@@ -724,7 +726,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 // Type bindings such as `Item = impl Debug` in `Iterator<Item = Debug>`\n                 // are allowed to contain nested `impl Trait`.\n                 self.with_impl_trait(None, |this| {\n-                    walk_list!(this, visit_assoc_type_binding_from_generic_args, &data.bindings);\n+                    walk_list!(this, visit_assoc_ty_constraint_from_generic_args, &data.constraints);\n                 });\n             }\n             GenericArgs::Parenthesized(ref data) => {"}, {"sha": "6936aedb9de80d48f93482a3423dd8b60961bc28", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -353,9 +353,9 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n         ast_visit::walk_path_segment(self, path_span, path_segment)\n     }\n \n-    fn visit_assoc_type_binding(&mut self, type_binding: &'v ast::TypeBinding) {\n-        self.record(\"TypeBinding\", Id::None, type_binding);\n-        ast_visit::walk_assoc_type_binding(self, type_binding)\n+    fn visit_assoc_ty_constraint(&mut self, constraint: &'v ast::AssocTyConstraint) {\n+        self.record(\"AssocTyConstraint\", Id::None, constraint);\n+        ast_visit::walk_assoc_ty_constraint(self, constraint)\n     }\n \n     fn visit_attribute(&mut self, attr: &'v ast::Attribute) {"}, {"sha": "2b627a692508e65271ff502dedc5fa2a88cb238a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 64, "deletions": 54, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -20,8 +20,11 @@ use rustc::hir::itemlikevisit::ParItemLikeVisitor;\n use rustc::hir;\n \n /// Helper type of a temporary returned by `.for_item(...)`.\n-/// Necessary because we can't write the following bound:\n-/// `F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>)`.\n+/// This is necessary because we can't write the following bound:\n+///\n+/// ```rust\n+/// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>)\n+/// ```\n struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     inherited: super::InheritedBuilder<'a, 'gcx, 'tcx>,\n     id: hir::HirId,\n@@ -42,7 +45,7 @@ impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n             if !inh.tcx.features().trivial_bounds {\n                 // As predicates are cached rather than obligations, this\n                 // needsto be called first so that they are checked with an\n-                // empty param_env.\n+                // empty `param_env`.\n                 check_false_global_bounds(&fcx, span, id);\n             }\n             let wf_tys = f(&fcx, fcx.tcx.global_tcx());\n@@ -56,7 +59,9 @@ impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n /// well-formed, meaning that they do not require any constraints not declared in the struct\n /// definition itself. For example, this definition would be illegal:\n ///\n-///     struct Ref<'a, T> { x: &'a T }\n+/// ```rust\n+/// struct Ref<'a, T> { x: &'a T }\n+/// ```\n ///\n /// because the type did not declare that `T:'a`.\n ///\n@@ -75,7 +80,7 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n         // Right now we check that every default trait implementation\n         // has an implementation of itself. Basically, a case like:\n         //\n-        // `impl Trait for T {}`\n+        //     impl Trait for T {}\n         //\n         // has a requirement of `T: Trait` which was required for default\n         // method implementations. Although this could be improved now that\n@@ -85,7 +90,7 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n         // Since there's such a requirement, we need to check *just* positive\n         // implementations, otherwise things like:\n         //\n-        // impl !Send for T {}\n+        //     impl !Send for T {}\n         //\n         // won't be allowed unless there's an *explicit* implementation of `Send`\n         // for `T`\n@@ -98,7 +103,7 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n             if polarity == hir::ImplPolarity::Positive {\n                 check_impl(tcx, item, self_ty, trait_ref);\n             } else {\n-                // FIXME(#27579) what amount of WF checking do we need for neg impls?\n+                // FIXME(#27579): what amount of WF checking do we need for neg impls?\n                 if trait_ref.is_some() && !is_auto {\n                     span_err!(tcx.sess, item.span, E0192,\n                               \"negative impls are only allowed for \\\n@@ -302,7 +307,8 @@ fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         check_where_clauses(tcx, fcx, item.span, def_id, None);\n \n-        vec![] // no implied bounds in a struct def'n\n+        // No implied bounds in a struct definition.\n+        vec![]\n     });\n }\n \n@@ -369,7 +375,8 @@ fn check_item_type<'a, 'tcx>(\n             );\n         }\n \n-        vec![] // no implied bounds in a const etc\n+        // No implied bounds in a const, etc.\n+        vec![]\n     });\n }\n \n@@ -421,6 +428,8 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n     def_id: DefId,\n     return_ty: Option<Ty<'tcx>>,\n ) {\n+    debug!(\"check_where_clauses(def_id={:?}, return_ty={:?})\", def_id, return_ty);\n+\n     let predicates = fcx.tcx.predicates_of(def_id);\n     let generics = tcx.generics_of(def_id);\n \n@@ -434,15 +443,17 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n     };\n \n     // Check that concrete defaults are well-formed. See test `type-check-defaults.rs`.\n-    // For example this forbids the declaration:\n-    // struct Foo<T = Vec<[u32]>> { .. }\n-    // Here the default `Vec<[u32]>` is not WF because `[u32]: Sized` does not hold.\n+    // For example, this forbids the declaration:\n+    //\n+    //     struct Foo<T = Vec<[u32]>> { .. }\n+    //\n+    // Here, the default `Vec<[u32]>` is not WF because `[u32]: Sized` does not hold.\n     for param in &generics.params {\n         if let GenericParamDefKind::Type { .. } = param.kind {\n             if is_our_default(&param) {\n                 let ty = fcx.tcx.type_of(param.def_id);\n-                // ignore dependent defaults -- that is, where the default of one type\n-                // parameter includes another (e.g., <T, U = T>). In those cases, we can't\n+                // Ignore dependent defaults -- that is, where the default of one type\n+                // parameter includes another (e.g., `<T, U = T>`). In those cases, we can't\n                 // be sure if it will error or not as user might always specify the other.\n                 if !ty.needs_subst() {\n                     fcx.register_wf_obligation(ty, fcx.tcx.def_span(param.def_id),\n@@ -468,16 +479,16 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n             }\n \n             GenericParamDefKind::Type { .. } => {\n-                // If the param has a default,\n+                // If the param has a default, ...\n                 if is_our_default(param) {\n                     let default_ty = fcx.tcx.type_of(param.def_id);\n-                    // and it's not a dependent default\n+                    // ... and it's not a dependent default, ...\n                     if !default_ty.needs_subst() {\n-                        // then substitute with the default.\n+                        // ... then substitute it with the default.\n                         return default_ty.into();\n                     }\n                 }\n-                // Mark unwanted params as err.\n+                // Mark unwanted params as error.\n                 fcx.tcx.types.err.into()\n             }\n \n@@ -525,7 +536,7 @@ fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(\n             Some(substituted_pred)\n         }\n     }).map(|pred| {\n-        // convert each of those into an obligation. So if you have\n+        // Convert each of those into an obligation. So if you have\n         // something like `struct Foo<T: Copy = String>`, we would\n         // take that predicate `T: Copy`, substitute to `String: Copy`\n         // (actually that happens in the previous `flat_map` call),\n@@ -595,14 +606,13 @@ fn check_fn_or_method<'a, 'fcx, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n /// ```rust\n /// existential type Foo<A, B>;\n ///\n-/// // ok -- `Foo` is applied to two distinct, generic types.\n+/// // Okay -- `Foo` is applied to two distinct, generic types.\n /// fn a<T, U>() -> Foo<T, U> { .. }\n ///\n-/// // not ok -- `Foo` is applied to `T` twice.\n+/// // Not okay -- `Foo` is applied to `T` twice.\n /// fn b<T>() -> Foo<T, T> { .. }\n ///\n-///\n-/// // not ok -- `Foo` is applied to a non-generic type.\n+/// // Not okay -- `Foo` is applied to a non-generic type.\n /// fn b<T>() -> Foo<T, u32> { .. }\n /// ```\n ///\n@@ -613,25 +623,25 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n     span: Span,\n     ty: Ty<'tcx>,\n ) -> Vec<ty::Predicate<'tcx>> {\n-    trace!(\"check_existential_types: {:?}\", ty);\n+    trace!(\"check_existential_types(ty={:?})\", ty);\n     let mut substituted_predicates = Vec::new();\n     ty.fold_with(&mut ty::fold::BottomUpFolder {\n         tcx: fcx.tcx,\n         ty_op: |ty| {\n             if let ty::Opaque(def_id, substs) = ty.sty {\n                 trace!(\"check_existential_types: opaque_ty, {:?}, {:?}\", def_id, substs);\n                 let generics = tcx.generics_of(def_id);\n-                // only check named existential types defined in this crate\n+                // Only check named existential types defined in this crate.\n                 if generics.parent.is_none() && def_id.is_local() {\n                     let opaque_hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n                     if may_define_existential_type(tcx, fn_def_id, opaque_hir_id) {\n-                        trace!(\"check_existential_types may define. Generics: {:#?}\", generics);\n+                        trace!(\"check_existential_types: may define, generics={:#?}\", generics);\n                         let mut seen: FxHashMap<_, Vec<_>> = FxHashMap::default();\n                         for (subst, param) in substs.iter().zip(&generics.params) {\n                             match subst.unpack() {\n                                 ty::subst::UnpackedKind::Type(ty) => match ty.sty {\n                                     ty::Param(..) => {}\n-                                    // prevent `fn foo() -> Foo<u32>` from being defining\n+                                    // Prevent `fn foo() -> Foo<u32>` from being defining.\n                                     _ => {\n                                         tcx.sess\n                                             .struct_span_err(\n@@ -713,20 +723,19 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n                         }\n                     } // if may_define_existential_type\n \n-                    // now register the bounds on the parameters of the existential type\n-                    // so the parameters given by the function need to fulfill them\n-                    // ```rust\n-                    // existential type Foo<T: Bar>: 'static;\n-                    // fn foo<U>() -> Foo<U> { .. *}\n-                    // ```\n+                    // Now register the bounds on the parameters of the existential type\n+                    // so the parameters given by the function need to fulfill them.\n+                    //\n+                    //     existential type Foo<T: Bar>: 'static;\n+                    //     fn foo<U>() -> Foo<U> { .. *}\n+                    //\n                     // becomes\n-                    // ```rust\n-                    // existential type Foo<T: Bar>: 'static;\n-                    // fn foo<U: Bar>() -> Foo<U> { .. *}\n-                    // ```\n+                    //\n+                    //     existential type Foo<T: Bar>: 'static;\n+                    //     fn foo<U: Bar>() -> Foo<U> { .. *}\n                     let predicates = tcx.predicates_of(def_id);\n                     trace!(\n-                        \"check_existential_types may define. adding predicates: {:#?}\",\n+                        \"check_existential_types: may define, predicates={:#?}\",\n                         predicates,\n                     );\n                     for &(pred, _) in predicates.predicates.iter() {\n@@ -751,7 +760,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                                            method: &ty::AssocItem,\n                                            self_ty: Ty<'tcx>)\n {\n-    // check that the method has a valid receiver type, given the type `Self`\n+    // Check that the method has a valid receiver type, given the type `Self`.\n     debug!(\"check_method_receiver({:?}, self_ty={:?})\",\n            method, self_ty);\n \n@@ -783,7 +792,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n \n     if fcx.tcx.features().arbitrary_self_types {\n         if !receiver_is_valid(fcx, span, receiver_ty, self_ty, true) {\n-            // report error, arbitrary_self_types was enabled\n+            // Report error; `arbitrary_self_types` was enabled.\n             fcx.tcx.sess.diagnostic().mut_span_err(\n                 span, &format!(\"invalid method receiver type: {:?}\", receiver_ty)\n             ).note(\"type of `self` must be `Self` or a type that dereferences to it\")\n@@ -794,7 +803,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n     } else {\n         if !receiver_is_valid(fcx, span, receiver_ty, self_ty, false) {\n             if receiver_is_valid(fcx, span, receiver_ty, self_ty, true) {\n-                // report error, would have worked with arbitrary_self_types\n+                // Report error; would have worked with `arbitrary_self_types`.\n                 feature_gate::feature_err(\n                     &fcx.tcx.sess.parse_sess,\n                     sym::arbitrary_self_types,\n@@ -808,7 +817,7 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                 ).help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n                 .emit();\n             } else {\n-                // report error, would not have worked with arbitrary_self_types\n+                // Report error; would not have worked with `arbitrary_self_types`.\n                 fcx.tcx.sess.diagnostic().mut_span_err(\n                     span, &format!(\"invalid method receiver type: {:?}\", receiver_ty)\n                 ).note(\"type must be `Self` or a type that dereferences to it\")\n@@ -820,10 +829,11 @@ fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n     }\n }\n \n-/// returns true if `receiver_ty` would be considered a valid receiver type for `self_ty`. If\n+/// Returns whether `receiver_ty` would be considered a valid receiver type for `self_ty`. If\n /// `arbitrary_self_types` is enabled, `receiver_ty` must transitively deref to `self_ty`, possibly\n /// through a `*const/mut T` raw pointer. If the feature is not enabled, the requirements are more\n-/// strict: `receiver_ty` must implement `Receiver` and directly implement `Deref<Target=self_ty>`.\n+/// strict: `receiver_ty` must implement `Receiver` and directly implement\n+/// `Deref<Target = self_ty>`.\n ///\n /// N.B., there are cases this function returns `true` but causes an error to be emitted,\n /// particularly when `receiver_ty` derefs to a type that is the same as `self_ty` but has the\n@@ -839,7 +849,7 @@ fn receiver_is_valid<'fcx, 'tcx, 'gcx>(\n \n     let can_eq_self = |ty| fcx.infcx.can_eq(fcx.param_env, self_ty, ty).is_ok();\n \n-    // `self: Self` is always valid\n+    // `self: Self` is always valid.\n     if can_eq_self(receiver_ty) {\n         if let Some(mut err) = fcx.demand_eqtype_with_origin(&cause, self_ty, receiver_ty) {\n             err.emit();\n@@ -849,15 +859,15 @@ fn receiver_is_valid<'fcx, 'tcx, 'gcx>(\n \n     let mut autoderef = fcx.autoderef(span, receiver_ty);\n \n-    // the `arbitrary_self_types` feature allows raw pointer receivers like `self: *const Self`\n+    // The `arbitrary_self_types` feature allows raw pointer receivers like `self: *const Self`.\n     if arbitrary_self_types_enabled {\n         autoderef = autoderef.include_raw_pointers();\n     }\n \n-    // the first type is `receiver_ty`, which we know its not equal to `self_ty`. skip it.\n+    // The first type is `receiver_ty`, which we know its not equal to `self_ty`; skip it.\n     autoderef.next();\n \n-    // keep dereferencing `receiver_ty` until we get to `self_ty`\n+    // Keep dereferencing `receiver_ty` until we get to `self_ty`.\n     loop {\n         if let Some((potential_self_ty, _)) = autoderef.next() {\n             debug!(\"receiver_is_valid: potential self type `{:?}` to match `{:?}`\",\n@@ -882,14 +892,14 @@ fn receiver_is_valid<'fcx, 'tcx, 'gcx>(\n             return receiver_ty.references_error();\n         }\n \n-        // without the `arbitrary_self_types` feature, `receiver_ty` must directly deref to\n-        // `self_ty`. Enforce this by only doing one iteration of the loop\n+        // Without the `arbitrary_self_types` feature, `receiver_ty` must directly deref to\n+        // `self_ty`. Enforce this by only doing one iteration of the loop.\n         if !arbitrary_self_types_enabled {\n             return false\n         }\n     }\n \n-    // without `feature(arbitrary_self_types)`, we require that `receiver_ty` implements `Receiver`\n+    // Without `feature(arbitrary_self_types)`, we require that `receiver_ty` implements `Receiver`.\n     if !arbitrary_self_types_enabled {\n         let trait_def_id = match fcx.tcx.lang_items().receiver_trait() {\n             Some(did) => did,\n@@ -968,7 +978,7 @@ fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut err = error_392(tcx, span, param_name);\n \n     let suggested_marker_id = tcx.lang_items().phantom_data();\n-    // help is available only in presence of lang items\n+    // Help is available only in presence of lang items.\n     if let Some(def_id) = suggested_marker_id {\n         err.help(&format!(\"consider removing `{}` or using a marker such as `{}`\",\n                           param_name,\n@@ -988,12 +998,12 @@ fn reject_shadowing_parameters(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) {\n     }).collect();\n \n     for method_param in &generics.params {\n-        // Shadowing is checked in resolve_lifetime.\n+        // Shadowing is checked in `resolve_lifetime`.\n         if let GenericParamDefKind::Lifetime = method_param.kind {\n             continue\n         }\n         if impl_params.contains_key(&method_param.name) {\n-            // Tighten up the span to focus on only the shadowing type\n+            // Tighten up the span to focus on only the shadowing type.\n             let type_span = tcx.def_span(method_param.def_id);\n \n             // The expectation here is that the original trait declaration is"}, {"sha": "ee7961197d3b0e2b4cf9572e779d487f178b4c4d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -1488,10 +1488,13 @@ fn find_existential_constraints<'a, 'tcx>(\n \n     impl<'a, 'tcx> ConstraintLocator<'a, 'tcx> {\n         fn check(&mut self, def_id: DefId) {\n-            trace!(\"checking {:?}\", def_id);\n-            // don't try to check items that cannot possibly constrain the type\n+            // Don't try to check items that cannot possibly constrain the type.\n             if !self.tcx.has_typeck_tables(def_id) {\n-                trace!(\"no typeck tables for {:?}\", def_id);\n+                debug!(\n+                    \"find_existential_constraints: no constraint for `{:?}` at `{:?}`: no tables\",\n+                    self.def_id,\n+                    def_id,\n+                );\n                 return;\n             }\n             let ty = self\n@@ -1500,7 +1503,14 @@ fn find_existential_constraints<'a, 'tcx>(\n                 .concrete_existential_types\n                 .get(&self.def_id);\n             if let Some(ty::ResolvedOpaqueTy { concrete_type, substs }) = ty {\n-                // FIXME(oli-obk): trace the actual span from inference to improve errors\n+                debug!(\n+                    \"find_existential_constraints: found constraint for `{:?}` at `{:?}`: {:?}\",\n+                    self.def_id,\n+                    def_id,\n+                    ty,\n+                );\n+\n+                // FIXME(oli-obk): trace the actual span from inference to improve errors.\n                 let span = self.tcx.def_span(def_id);\n                 // used to quickly look up the position of a generic parameter\n                 let mut index_map: FxHashMap<ty::ParamTy, usize> = FxHashMap::default();\n@@ -1555,14 +1565,15 @@ fn find_existential_constraints<'a, 'tcx>(\n                     let mut ty = concrete_type.walk().fuse();\n                     let mut p_ty = prev_ty.walk().fuse();\n                     let iter_eq = (&mut ty).zip(&mut p_ty).all(|(t, p)| match (&t.sty, &p.sty) {\n-                        // type parameters are equal to any other type parameter for the purpose of\n+                        // Type parameters are equal to any other type parameter for the purpose of\n                         // concrete type equality, as it is possible to obtain the same type just\n                         // by passing matching parameters to a function.\n                         (ty::Param(_), ty::Param(_)) => true,\n                         _ => t == p,\n                     });\n                     if !iter_eq || ty.next().is_some() || p_ty.next().is_some() {\n-                        // found different concrete types for the existential type\n+                        debug!(\"find_existential_constraints: span={:?}\", span);\n+                        // Found different concrete types for the existential type.\n                         let mut err = self.tcx.sess.struct_span_err(\n                             span,\n                             \"concrete type differs from previous defining existential type use\",\n@@ -1574,7 +1585,7 @@ fn find_existential_constraints<'a, 'tcx>(\n                         err.span_note(prev_span, \"previous use here\");\n                         err.emit();\n                     } else if indices != *prev_indices {\n-                        // found \"same\" concrete types, but the generic parameter order differs\n+                        // Found \"same\" concrete types, but the generic parameter order differs.\n                         let mut err = self.tcx.sess.struct_span_err(\n                             span,\n                             \"concrete type's generic parameters differ from previous defining use\",\n@@ -1602,6 +1613,12 @@ fn find_existential_constraints<'a, 'tcx>(\n                 } else {\n                     self.found = Some((span, concrete_type, indices));\n                 }\n+            } else {\n+                debug!(\n+                    \"find_existential_constraints: no constraint for `{:?}` at `{:?}`\",\n+                    self.def_id,\n+                    def_id,\n+                );\n             }\n         }\n     }\n@@ -1633,26 +1650,27 @@ fn find_existential_constraints<'a, 'tcx>(\n         }\n     }\n \n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let scope_id = tcx.hir().get_defining_scope(hir_id)\n+                            .expect(\"could not get defining scope\");\n     let mut locator = ConstraintLocator {\n         def_id,\n         tcx,\n         found: None,\n     };\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let parent = tcx.hir().get_parent_item(hir_id);\n \n-    trace!(\"parent_id: {:?}\", parent);\n+    debug!(\"find_existential_constraints: scope_id={:?}\", scope_id);\n \n-    if parent == hir::CRATE_HIR_ID {\n+    if scope_id == ast::CRATE_HIR_ID {\n         intravisit::walk_crate(&mut locator, tcx.hir().krate());\n     } else {\n-        trace!(\"parent: {:?}\", tcx.hir().get_by_hir_id(parent));\n-        match tcx.hir().get_by_hir_id(parent) {\n+        debug!(\"find_existential_constraints: scope={:?}\", tcx.hir().get_by_hir_id(scope_id));\n+        match tcx.hir().get_by_hir_id(scope_id) {\n             Node::Item(ref it) => intravisit::walk_item(&mut locator, it),\n             Node::ImplItem(ref it) => intravisit::walk_impl_item(&mut locator, it),\n             Node::TraitItem(ref it) => intravisit::walk_trait_item(&mut locator, it),\n             other => bug!(\n-                \"{:?} is not a valid parent of an existential type item\",\n+                \"{:?} is not a valid scope for an existential type item\",\n                 other\n             ),\n         }"}, {"sha": "598232f9f8f22e4de8bbe1506b3f5791bd8fc685", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -190,9 +190,9 @@ pub struct AngleBracketedArgs {\n     pub span: Span,\n     /// The arguments for this path segment.\n     pub args: Vec<GenericArg>,\n-    /// Bindings (equality constraints) on associated types, if present.\n-    /// E.g., `Foo<A = Bar>`.\n-    pub bindings: Vec<TypeBinding>,\n+    /// Constraints on associated types, if any.\n+    /// E.g., `Foo<A = Bar, B: Baz>`.\n+    pub constraints: Vec<AssocTyConstraint>,\n }\n \n impl Into<Option<P<GenericArgs>>> for AngleBracketedArgs {\n@@ -225,7 +225,7 @@ impl ParenthesizedArgs {\n         AngleBracketedArgs {\n             span: self.span,\n             args: self.inputs.iter().cloned().map(|input| GenericArg::Type(input)).collect(),\n-            bindings: vec![],\n+            constraints: vec![],\n         }\n     }\n }\n@@ -1611,15 +1611,29 @@ impl fmt::Display for UintTy {\n     }\n }\n \n-// Bind a type to an associated type: `A = Foo`.\n+/// A constraint on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n+/// `A: TraitA + TraitB` in `Foo<A: TraitA + TraitB>`).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct TypeBinding {\n+pub struct AssocTyConstraint {\n     pub id: NodeId,\n     pub ident: Ident,\n-    pub ty: P<Ty>,\n+    pub kind: AssocTyConstraintKind,\n     pub span: Span,\n }\n \n+/// The kinds of an `AssocTyConstraint`.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub enum AssocTyConstraintKind {\n+    /// E.g., `A = Bar` in `Foo<A = Bar>`.\n+    Equality {\n+        ty: P<Ty>,\n+    },\n+    /// E.g. `A: TraitA + TraitB` in `Foo<A: TraitA + TraitB>`.\n+    Bound {\n+        bounds: GenericBounds,\n+    },\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Ty {\n     pub id: NodeId,"}, {"sha": "2a03e49996b6cac49adbcf413b2fb138b3e31176", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -18,7 +18,7 @@ pub trait AstBuilder {\n                 global: bool,\n                 idents: Vec<ast::Ident>,\n                 args: Vec<ast::GenericArg>,\n-                bindings: Vec<ast::TypeBinding>)\n+                constraints: Vec<ast::AssocTyConstraint>)\n         -> ast::Path;\n \n     fn qpath(&self, self_type: P<ast::Ty>,\n@@ -29,7 +29,7 @@ pub trait AstBuilder {\n                 trait_path: ast::Path,\n                 ident: ast::Ident,\n                 args: Vec<ast::GenericArg>,\n-                bindings: Vec<ast::TypeBinding>)\n+                constraints: Vec<ast::AssocTyConstraint>)\n                 -> (ast::QSelf, ast::Path);\n \n     // types and consts\n@@ -302,7 +302,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 global: bool,\n                 mut idents: Vec<ast::Ident> ,\n                 args: Vec<ast::GenericArg>,\n-                bindings: Vec<ast::TypeBinding> )\n+                constraints: Vec<ast::AssocTyConstraint> )\n                 -> ast::Path {\n         assert!(!idents.is_empty());\n         let add_root = global && !idents[0].is_path_segment_keyword();\n@@ -314,8 +314,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         segments.extend(idents.into_iter().map(|ident| {\n             ast::PathSegment::from_ident(ident.with_span_pos(span))\n         }));\n-        let args = if !args.is_empty() || !bindings.is_empty() {\n-            ast::AngleBracketedArgs { args, bindings, span }.into()\n+        let args = if !args.is_empty() || !constraints.is_empty() {\n+            ast::AngleBracketedArgs { args, constraints, span }.into()\n         } else {\n             None\n         };\n@@ -346,11 +346,11 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                  trait_path: ast::Path,\n                  ident: ast::Ident,\n                  args: Vec<ast::GenericArg>,\n-                 bindings: Vec<ast::TypeBinding>)\n+                 constraints: Vec<ast::AssocTyConstraint>)\n                  -> (ast::QSelf, ast::Path) {\n         let mut path = trait_path;\n-        let args = if !args.is_empty() || !bindings.is_empty() {\n-            ast::AngleBracketedArgs { args, bindings, span: ident.span }.into()\n+        let args = if !args.is_empty() || !constraints.is_empty() {\n+            ast::AngleBracketedArgs { args, constraints, span: ident.span }.into()\n         } else {\n             None\n         };"}, {"sha": "fb1a7a680baaf532552ccbcca6790bf2bb1e0488", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -163,8 +163,8 @@ pub trait MutVisitor: Sized {\n         noop_visit_lifetime(l, self);\n     }\n \n-    fn visit_ty_binding(&mut self, t: &mut TypeBinding) {\n-        noop_visit_ty_binding(t, self);\n+    fn visit_ty_constraint(&mut self, t: &mut AssocTyConstraint) {\n+        noop_visit_ty_constraint(t, self);\n     }\n \n     fn visit_mod(&mut self, m: &mut Mod) {\n@@ -400,11 +400,20 @@ pub fn noop_visit_guard<T: MutVisitor>(g: &mut Guard, vis: &mut T) {\n     }\n }\n \n-pub fn noop_visit_ty_binding<T: MutVisitor>(TypeBinding { id, ident, ty, span }: &mut TypeBinding,\n-                                            vis: &mut T) {\n+pub fn noop_visit_ty_constraint<T: MutVisitor>(\n+    AssocTyConstraint { id, ident, kind, span }: &mut AssocTyConstraint,\n+    vis: &mut T\n+) {\n     vis.visit_id(id);\n     vis.visit_ident(ident);\n-    vis.visit_ty(ty);\n+    match kind {\n+        AssocTyConstraintKind::Equality { ref mut ty } => {\n+            vis.visit_ty(ty);\n+        }\n+        AssocTyConstraintKind::Bound { ref mut bounds } => {\n+            visit_bounds(bounds, vis);\n+        }\n+    }\n     vis.visit_span(span);\n }\n \n@@ -499,9 +508,9 @@ pub fn noop_visit_generic_arg<T: MutVisitor>(arg: &mut GenericArg, vis: &mut T)\n \n pub fn noop_visit_angle_bracketed_parameter_data<T: MutVisitor>(data: &mut AngleBracketedArgs,\n                                                                 vis: &mut T) {\n-    let AngleBracketedArgs { args, bindings, span } = data;\n+    let AngleBracketedArgs { args, constraints, span } = data;\n     visit_vec(args, |arg| vis.visit_generic_arg(arg));\n-    visit_vec(bindings, |binding| vis.visit_ty_binding(binding));\n+    visit_vec(constraints, |constraint| vis.visit_ty_constraint(constraint));\n     vis.visit_span(span);\n }\n "}, {"sha": "790013f6eb1286f6d81b51bcdd23743e990d5b15", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -27,7 +27,7 @@ use crate::ast::{VariantData, StructField};\n use crate::ast::StrStyle;\n use crate::ast::SelfKind;\n use crate::ast::{TraitItem, TraitRef, TraitObjectSyntax};\n-use crate::ast::{Ty, TyKind, TypeBinding, GenericBounds};\n+use crate::ast::{Ty, TyKind, AssocTyConstraint, AssocTyConstraintKind, GenericBounds};\n use crate::ast::{Visibility, VisibilityKind, WhereClause, CrateSugar};\n use crate::ast::{UseTree, UseTreeKind};\n use crate::ast::{BinOpKind, UnOp};\n@@ -1791,11 +1791,11 @@ impl<'a> Parser<'a> {\n             let lo = self.span;\n             let args = if self.eat_lt() {\n                 // `<'a, T, A = U>`\n-                let (args, bindings) =\n+                let (args, constraints) =\n                     self.parse_generic_args_with_leaning_angle_bracket_recovery(style, lo)?;\n                 self.expect_gt()?;\n                 let span = lo.to(self.prev_span);\n-                AngleBracketedArgs { args, bindings, span }.into()\n+                AngleBracketedArgs { args, constraints, span }.into()\n             } else {\n                 // `(T, U) -> R`\n                 self.bump(); // `(`\n@@ -5076,7 +5076,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         style: PathStyle,\n         lo: Span,\n-    ) -> PResult<'a, (Vec<GenericArg>, Vec<TypeBinding>)> {\n+    ) -> PResult<'a, (Vec<GenericArg>, Vec<AssocTyConstraint>)> {\n         // We need to detect whether there are extra leading left angle brackets and produce an\n         // appropriate error and suggestion. This cannot be implemented by looking ahead at\n         // upcoming tokens for a matching `>` character - if there are unmatched `<` tokens\n@@ -5211,33 +5211,43 @@ impl<'a> Parser<'a> {\n \n     /// Parses (possibly empty) list of lifetime and type arguments and associated type bindings,\n     /// possibly including trailing comma.\n-    fn parse_generic_args(&mut self) -> PResult<'a, (Vec<GenericArg>, Vec<TypeBinding>)> {\n+    fn parse_generic_args(&mut self) -> PResult<'a, (Vec<GenericArg>, Vec<AssocTyConstraint>)> {\n         let mut args = Vec::new();\n-        let mut bindings = Vec::new();\n-        let mut misplaced_assoc_ty_bindings: Vec<Span> = Vec::new();\n-        let mut assoc_ty_bindings: Vec<Span> = Vec::new();\n+        let mut constraints = Vec::new();\n+        let mut misplaced_assoc_ty_constraints: Vec<Span> = Vec::new();\n+        let mut assoc_ty_constraints: Vec<Span> = Vec::new();\n \n         let args_lo = self.span;\n \n         loop {\n             if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n                 // Parse lifetime argument.\n                 args.push(GenericArg::Lifetime(self.expect_lifetime()));\n-                misplaced_assoc_ty_bindings.append(&mut assoc_ty_bindings);\n-            } else if self.check_ident() && self.look_ahead(1, |t| t == &token::Eq) {\n-                // Parse associated type binding.\n+                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n+            } else if self.check_ident() && self.look_ahead(1,\n+                    |t| t == &token::Eq || t == &token::Colon) {\n+                // Parse associated type constraint.\n                 let lo = self.span;\n                 let ident = self.parse_ident()?;\n-                self.bump();\n-                let ty = self.parse_ty()?;\n+                let kind = if self.eat(&token::Eq) {\n+                    AssocTyConstraintKind::Equality {\n+                        ty: self.parse_ty()?,\n+                    }\n+                } else if self.eat(&token::Colon) {\n+                    AssocTyConstraintKind::Bound {\n+                        bounds: self.parse_generic_bounds(Some(self.prev_span))?,\n+                    }\n+                } else {\n+                    unreachable!();\n+                };\n                 let span = lo.to(self.prev_span);\n-                bindings.push(TypeBinding {\n+                constraints.push(AssocTyConstraint {\n                     id: ast::DUMMY_NODE_ID,\n                     ident,\n-                    ty,\n+                    kind,\n                     span,\n                 });\n-                assoc_ty_bindings.push(span);\n+                assoc_ty_constraints.push(span);\n             } else if self.check_const_arg() {\n                 // Parse const argument.\n                 let expr = if let token::OpenDelim(token::Brace) = self.token {\n@@ -5261,11 +5271,11 @@ impl<'a> Parser<'a> {\n                     value: expr,\n                 };\n                 args.push(GenericArg::Const(value));\n-                misplaced_assoc_ty_bindings.append(&mut assoc_ty_bindings);\n+                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n             } else if self.check_type() {\n                 // Parse type argument.\n                 args.push(GenericArg::Type(self.parse_ty()?));\n-                misplaced_assoc_ty_bindings.append(&mut assoc_ty_bindings);\n+                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n             } else {\n                 break\n             }\n@@ -5278,12 +5288,12 @@ impl<'a> Parser<'a> {\n         // FIXME: we would like to report this in ast_validation instead, but we currently do not\n         // preserve ordering of generic parameters with respect to associated type binding, so we\n         // lose that information after parsing.\n-        if misplaced_assoc_ty_bindings.len() > 0 {\n+        if misplaced_assoc_ty_constraints.len() > 0 {\n             let mut err = self.struct_span_err(\n                 args_lo.to(self.prev_span),\n                 \"associated type bindings must be declared after generic parameters\",\n             );\n-            for span in misplaced_assoc_ty_bindings {\n+            for span in misplaced_assoc_ty_constraints {\n                 err.span_label(\n                     span,\n                     \"this associated type binding should be moved after the generic parameters\",\n@@ -5292,7 +5302,7 @@ impl<'a> Parser<'a> {\n             err.emit();\n         }\n \n-        Ok((args, bindings))\n+        Ok((args, constraints))\n     }\n \n     /// Parses an optional where-clause and places it in `generics`."}, {"sha": "57c01e9e3efea2aa8fe72497588151afce4c6214", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -2450,14 +2450,21 @@ impl<'a> State<'a> {\n \n                 let mut comma = data.args.len() != 0;\n \n-                for binding in data.bindings.iter() {\n+                for constraint in data.constraints.iter() {\n                     if comma {\n                         self.word_space(\",\")?\n                     }\n-                    self.print_ident(binding.ident)?;\n+                    self.print_ident(constraint.ident)?;\n                     self.s.space()?;\n-                    self.word_space(\"=\")?;\n-                    self.print_type(&binding.ty)?;\n+                    match constraint.kind {\n+                        ast::AssocTyConstraintKind::Equality { ref ty } => {\n+                            self.word_space(\"=\")?;\n+                            self.print_type(ty)?;\n+                        }\n+                        ast::AssocTyConstraintKind::Bound { ref bounds } => {\n+                            self.print_type_bounds(\":\", &*bounds)?;\n+                        }\n+                    }\n                     comma = true;\n                 }\n "}, {"sha": "f17eb3b39432efccb2d5e87eec22f4f70033558a", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -131,9 +131,9 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_generic_args(self, path_span, generic_args)\n     }\n-    fn visit_assoc_type_binding(&mut self, type_binding: &TypeBinding) {\n+    fn visit_assoc_ty_constraint(&mut self, constraint: &AssocTyConstraint) {\n         self.count += 1;\n-        walk_assoc_type_binding(self, type_binding)\n+        walk_assoc_ty_constraint(self, constraint)\n     }\n     fn visit_attribute(&mut self, _attr: &Attribute) {\n         self.count += 1;"}, {"sha": "334709b1521972d300eb69fa1cd6a8bfbdb78a82", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3816958f18ea6c8990d64d03da839e5a180b0b9b/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=3816958f18ea6c8990d64d03da839e5a180b0b9b", "patch": "@@ -139,8 +139,8 @@ pub trait Visitor<'ast>: Sized {\n             GenericArg::Const(ct) => self.visit_anon_const(ct),\n         }\n     }\n-    fn visit_assoc_type_binding(&mut self, type_binding: &'ast TypeBinding) {\n-        walk_assoc_type_binding(self, type_binding)\n+    fn visit_assoc_ty_constraint(&mut self, constraint: &'ast AssocTyConstraint) {\n+        walk_assoc_ty_constraint(self, constraint)\n     }\n     fn visit_attribute(&mut self, attr: &'ast Attribute) {\n         walk_attribute(self, attr)\n@@ -404,7 +404,7 @@ pub fn walk_generic_args<'a, V>(visitor: &mut V,\n     match *generic_args {\n         GenericArgs::AngleBracketed(ref data) => {\n             walk_list!(visitor, visit_generic_arg, &data.args);\n-            walk_list!(visitor, visit_assoc_type_binding, &data.bindings);\n+            walk_list!(visitor, visit_assoc_ty_constraint, &data.constraints);\n         }\n         GenericArgs::Parenthesized(ref data) => {\n             walk_list!(visitor, visit_ty, &data.inputs);\n@@ -413,10 +413,17 @@ pub fn walk_generic_args<'a, V>(visitor: &mut V,\n     }\n }\n \n-pub fn walk_assoc_type_binding<'a, V: Visitor<'a>>(visitor: &mut V,\n-                                                   type_binding: &'a TypeBinding) {\n-    visitor.visit_ident(type_binding.ident);\n-    visitor.visit_ty(&type_binding.ty);\n+pub fn walk_assoc_ty_constraint<'a, V: Visitor<'a>>(visitor: &mut V,\n+                                                    constraint: &'a AssocTyConstraint) {\n+    visitor.visit_ident(constraint.ident);\n+    match constraint.kind {\n+        AssocTyConstraintKind::Equality { ref ty } => {\n+            visitor.visit_ty(ty);\n+        }\n+        AssocTyConstraintKind::Bound { ref bounds } => {\n+            walk_list!(visitor, visit_param_bound, bounds);\n+        }\n+    }\n }\n \n pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {"}]}