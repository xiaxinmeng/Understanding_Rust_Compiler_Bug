{"sha": "744e69663e910ece9a7cf754049b09d6afb22e9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NGU2OTY2M2U5MTBlY2U5YTdjZjc1NDA0OWIwOWQ2YWZiMjJlOWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-12T02:50:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-12T02:50:17Z"}, "message": "Auto merge of #40446 - arielb1:rollup, r=alexcrichton\n\nRollup of 12 pull requests\n\n- Successful merges: #40146, #40299, #40315, #40319, #40344, #40345, #40372, #40373, #40400, #40404, #40419, #40431\n- Failed merges:", "tree": {"sha": "ac3cfeecfef8f7c537a96a88ebf1952ecdabd719", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac3cfeecfef8f7c537a96a88ebf1952ecdabd719"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/744e69663e910ece9a7cf754049b09d6afb22e9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/744e69663e910ece9a7cf754049b09d6afb22e9f", "html_url": "https://github.com/rust-lang/rust/commit/744e69663e910ece9a7cf754049b09d6afb22e9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/744e69663e910ece9a7cf754049b09d6afb22e9f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "html_url": "https://github.com/rust-lang/rust/commit/1b19284ad9d85f2848650be6dd466ad0e1e2d82c"}, {"sha": "6a5fd0f7ee00878ec46d277265a1ac3e12bb048b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a5fd0f7ee00878ec46d277265a1ac3e12bb048b", "html_url": "https://github.com/rust-lang/rust/commit/6a5fd0f7ee00878ec46d277265a1ac3e12bb048b"}], "stats": {"total": 759, "additions": 527, "deletions": 232}, "files": [{"sha": "a9867cbc11e0e3127e3eaa1f70bfb7ee47f5d2ac", "filename": ".travis.yml", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -46,6 +46,8 @@ matrix:\n         RUST_CONFIGURE_ARGS=--build=x86_64-apple-darwin\n         SRC=.\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n+        SCCACHE_ERROR_LOG=/tmp/sccache.log\n+        RUST_LOG=sccache\n       os: osx\n       osx_image: xcode8.2\n       install: &osx_install_sccache >\n@@ -56,6 +58,8 @@ matrix:\n         RUST_CONFIGURE_ARGS=--build=i686-apple-darwin\n         SRC=.\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n+        SCCACHE_ERROR_LOG=/tmp/sccache.log\n+        RUST_LOG=sccache\n       os: osx\n       osx_image: xcode8.2\n       install: *osx_install_sccache\n@@ -66,6 +70,8 @@ matrix:\n         SRC=.\n         DEPLOY=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n+        SCCACHE_ERROR_LOG=/tmp/sccache.log\n+        RUST_LOG=sccache\n       os: osx\n       osx_image: xcode8.2\n       install: >\n@@ -77,6 +83,8 @@ matrix:\n         SRC=.\n         DEPLOY=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n+        SCCACHE_ERROR_LOG=/tmp/sccache.log\n+        RUST_LOG=sccache\n       os: osx\n       osx_image: xcode8.2\n       install: *osx_install_sccache\n@@ -92,6 +100,8 @@ matrix:\n         SRC=.\n         DEPLOY_ALT=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n+        SCCACHE_ERROR_LOG=/tmp/sccache.log\n+        RUST_LOG=sccache\n       os: osx\n       osx_image: xcode8.2\n       install: *osx_install_sccache\n@@ -133,6 +143,7 @@ after_failure:\n       df -h;\n       du . | sort -nr | head -n100\n   - cat obj/tmp/sccache.log\n+  - cat /tmp/sccache.log\n \n # Save tagged docker images we created and load them if they're available\n before_cache:"}, {"sha": "46ff9a252a0f6af2c67acca0c4ac9c1f756ef7a5", "filename": "appveyor.yml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -130,12 +130,19 @@ install:\n   - set PATH=%PATH%;%CD%\\handle\n   - handle.exe -accepteula -help\n \n+  # Attempt to debug sccache failures\n+  - set RUST_LOG=sccache\n+  - set SCCACHE_ERROR_LOG=%CD%/sccache.log\n+\n test_script:\n   - appveyor-retry sh -c 'git submodule deinit -f . && git submodule update --init'\n   - set SRC=.\n   - set NO_CCACHE=1\n   - sh src/ci/run.sh\n \n+on_failure:\n+  - cat %CD%/sccache.log\n+\n cache:\n   - \"build/i686-pc-windows-msvc/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n   - \"build/x86_64-pc-windows-msvc/llvm -> src/rustllvm/llvm-auto-clean-trigger\""}, {"sha": "1657342ff6ac6f8aa567307edc13e9c727147309", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -529,6 +529,26 @@ pub trait Debug {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Display {\n     /// Formats the value using the given formatter.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Position {\n+    ///     longitude: f32,\n+    ///     latitude: f32,\n+    /// }\n+    ///\n+    /// impl fmt::Display for Position {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"({}, {})\", self.longitude, self.latitude)\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(\"(1.987, 2.983)\".to_owned(),\n+    ///            format!(\"{}\", Position { longitude: 1.987, latitude: 2.983, }));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fmt(&self, f: &mut Formatter) -> Result;\n }\n@@ -930,7 +950,6 @@ pub fn write(output: &mut Write, args: Arguments) -> Result {\n }\n \n impl<'a> Formatter<'a> {\n-\n     // First up is the collection of functions used to execute a format string\n     // at runtime. This consumes all of the compile-time statics generated by\n     // the format! syntax extension."}, {"sha": "68e64b8b7bfc827a03bfffd75abd246f7e2d4569", "filename": "src/librustc/infer/README.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc%2Finfer%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc%2Finfer%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2FREADME.md?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -152,7 +152,7 @@ course, it depends on the program.\n \n The main case which fails today that I would like to support is:\n \n-```text\n+```rust\n fn foo<T>(x: T, y: T) { ... }\n \n fn bar() {\n@@ -168,6 +168,8 @@ because the type variable `T` is merged with the type variable for\n `X`, and thus inherits its UB/LB of `@mut int`.  This leaves no\n flexibility for `T` to later adjust to accommodate `@int`.\n \n+Note: `@` and `@mut` are replaced with `Rc<T>` and `Rc<RefCell<T>>` in current Rust.\n+\n ### What to do when not all bounds are present\n \n In the prior discussion we assumed that A.ub was not top and B.lb was"}, {"sha": "b564faf3d0c24c9500c3a56950e3b9f89ca9f8c5", "filename": "src/librustc/infer/region_inference/README.md", "status": "modified", "additions": 59, "deletions": 49, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc%2Finfer%2Fregion_inference%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc%2Finfer%2Fregion_inference%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2FREADME.md?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -121,17 +121,19 @@ every expression, block, and pattern (patterns are considered to\n \"execute\" by testing the value they are applied to and creating any\n relevant bindings).  So, for example:\n \n-    fn foo(x: isize, y: isize) { // -+\n-    //  +------------+       //  |\n-    //  |      +-----+       //  |\n-    //  |  +-+ +-+ +-+       //  |\n-    //  |  | | | | | |       //  |\n-    //  v  v v v v v v       //  |\n-        let z = x + y;       //  |\n-        ...                  //  |\n-    }                        // -+\n-\n-    fn bar() { ... }\n+```rust\n+fn foo(x: isize, y: isize) { // -+\n+//  +------------+           //  |\n+//  |      +-----+           //  |\n+//  |  +-+ +-+ +-+           //  |\n+//  |  | | | | | |           //  |\n+//  v  v v v v v v           //  |\n+    let z = x + y;           //  |\n+    ...                      //  |\n+}                            // -+\n+\n+fn bar() { ... }\n+```\n \n In this example, there is a region for the fn body block as a whole,\n and then a subregion for the declaration of the local variable.\n@@ -160,28 +162,32 @@ this, we get a lot of spurious errors around nested calls, in\n particular when combined with `&mut` functions. For example, a call\n like this one\n \n-    self.foo(self.bar())\n+```rust\n+self.foo(self.bar())\n+```\n \n where both `foo` and `bar` are `&mut self` functions will always yield\n an error.\n \n Here is a more involved example (which is safe) so we can see what's\n going on:\n \n-    struct Foo { f: usize, g: usize }\n-    ...\n-    fn add(p: &mut usize, v: usize) {\n-        *p += v;\n-    }\n-    ...\n-    fn inc(p: &mut usize) -> usize {\n-        *p += 1; *p\n-    }\n-    fn weird() {\n-        let mut x: Box<Foo> = box Foo { ... };\n-        'a: add(&mut (*x).f,\n-                'b: inc(&mut (*x).f)) // (..)\n-    }\n+```rust\n+struct Foo { f: usize, g: usize }\n+// ...\n+fn add(p: &mut usize, v: usize) {\n+    *p += v;\n+}\n+// ...\n+fn inc(p: &mut usize) -> usize {\n+    *p += 1; *p\n+}\n+fn weird() {\n+    let mut x: Box<Foo> = box Foo { /* ... */ };\n+    'a: add(&mut (*x).f,\n+            'b: inc(&mut (*x).f)) // (..)\n+}\n+```\n \n The important part is the line marked `(..)` which contains a call to\n `add()`. The first argument is a mutable borrow of the field `f`.  The\n@@ -197,16 +203,18 @@ can see that this error is unnecessary. Let's examine the lifetimes\n involved with `'a` in detail. We'll break apart all the steps involved\n in a call expression:\n \n-    'a: {\n-        'a_arg1: let a_temp1: ... = add;\n-        'a_arg2: let a_temp2: &'a mut usize = &'a mut (*x).f;\n-        'a_arg3: let a_temp3: usize = {\n-            let b_temp1: ... = inc;\n-            let b_temp2: &'b = &'b mut (*x).f;\n-            'b_call: b_temp1(b_temp2)\n-        };\n-        'a_call: a_temp1(a_temp2, a_temp3) // (**)\n-    }\n+```rust\n+'a: {\n+    'a_arg1: let a_temp1: ... = add;\n+    'a_arg2: let a_temp2: &'a mut usize = &'a mut (*x).f;\n+    'a_arg3: let a_temp3: usize = {\n+        let b_temp1: ... = inc;\n+        let b_temp2: &'b = &'b mut (*x).f;\n+        'b_call: b_temp1(b_temp2)\n+    };\n+    'a_call: a_temp1(a_temp2, a_temp3) // (**)\n+}\n+```\n \n Here we see that the lifetime `'a` includes a number of substatements.\n In particular, there is this lifetime I've called `'a_call` that\n@@ -225,19 +233,21 @@ it will not be *dereferenced* during the evaluation of the second\n argument, it can still be *invalidated* by that evaluation. Consider\n this similar but unsound example:\n \n-    struct Foo { f: usize, g: usize }\n-    ...\n-    fn add(p: &mut usize, v: usize) {\n-        *p += v;\n-    }\n-    ...\n-    fn consume(x: Box<Foo>) -> usize {\n-        x.f + x.g\n-    }\n-    fn weird() {\n-        let mut x: Box<Foo> = box Foo { ... };\n-        'a: add(&mut (*x).f, consume(x)) // (..)\n-    }\n+```rust\n+struct Foo { f: usize, g: usize }\n+// ...\n+fn add(p: &mut usize, v: usize) {\n+    *p += v;\n+}\n+// ...\n+fn consume(x: Box<Foo>) -> usize {\n+    x.f + x.g\n+}\n+fn weird() {\n+    let mut x: Box<Foo> = box Foo { ... };\n+    'a: add(&mut (*x).f, consume(x)) // (..)\n+}\n+```\n \n In this case, the second argument to `add` actually consumes `x`, thus\n invalidating the first argument."}, {"sha": "a67049f72852bd99b81ee062c1fed836c875e842", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -91,7 +91,7 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n         };\n \n         if output_template.is_empty() {\n-            bug!(\"empty string provided as RUST_REGION_GRAPH\");\n+            panic!(\"empty string provided as RUST_REGION_GRAPH\");\n         }\n \n         if output_template.contains('%') {"}, {"sha": "9279f24a57ab32d3892a5bd1b0ac54171efd69f5", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -806,6 +806,12 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         self.tables = old_tables;\n     }\n \n+    fn visit_body(&mut self, body: &'tcx hir::Body) {\n+        run_lints!(self, check_body, late_passes, body);\n+        hir_visit::walk_body(self, body);\n+        run_lints!(self, check_body_post, late_passes, body);\n+    }\n+\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, late_passes, it);"}, {"sha": "e81d09773701cb7f3e5c90fe8f607bf0d89f844c", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -133,6 +133,8 @@ pub trait LintPass {\n // FIXME: eliminate the duplication with `Visitor`. But this also\n // contains a few lint-specific methods with no equivalent in `Visitor`.\n pub trait LateLintPass<'a, 'tcx>: LintPass {\n+    fn check_body(&mut self, _: &LateContext, _: &'tcx hir::Body) { }\n+    fn check_body_post(&mut self, _: &LateContext, _: &'tcx hir::Body) { }\n     fn check_name(&mut self, _: &LateContext, _: Span, _: ast::Name) { }\n     fn check_crate(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Crate) { }\n     fn check_crate_post(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Crate) { }"}, {"sha": "0e5c786cd8dcf424de39c6de5aa044f6ab53b3fc", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -23,24 +23,26 @@ use super::{\n     ObjectSafetyViolation,\n };\n \n+use errors::DiagnosticBuilder;\n use fmt_macros::{Parser, Piece, Position};\n+use hir::{intravisit, Local, Pat};\n+use hir::intravisit::{Visitor, NestedVisitorMap};\n+use hir::map::NodeExpr;\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n use infer::type_variable::TypeVariableOrigin;\n use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n+use std::fmt;\n+use syntax::ast;\n use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n use ty::subst::Subst;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n-use std::fmt;\n-use syntax::ast;\n-use hir::{intravisit, Local, Pat};\n-use hir::intravisit::{Visitor, NestedVisitorMap};\n use syntax_pos::{DUMMY_SP, Span};\n-use errors::DiagnosticBuilder;\n+\n \n #[derive(Debug, PartialEq, Eq, Hash)]\n pub struct TraitErrorKey<'tcx> {\n@@ -848,15 +850,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         err.span_label(cause.span, &format!(\"cannot infer type for `{}`\", name));\n \n-        let expr = self.tcx.hir.expect_expr(cause.body_id);\n-\n         let mut local_visitor = FindLocalByTypeVisitor {\n             infcx: &self,\n             target_ty: &ty,\n             found_pattern: None,\n         };\n \n-        local_visitor.visit_expr(expr);\n+        // #40294: cause.body_id can also be a fn declaration.\n+        // Currently, if it's anything other than NodeExpr, we just ignore it\n+        match self.tcx.hir.find(cause.body_id) {\n+            Some(NodeExpr(expr)) => local_visitor.visit_expr(expr),\n+            _ => ()\n+        }\n \n         if let Some(pattern) = local_visitor.found_pattern {\n             let pattern_span = pattern.span;"}, {"sha": "38ea1e4a19b91f536e989da9610cc1547384e700", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -2461,7 +2461,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let new_trait = tcx.mk_dynamic(\n                     ty::Binder(tcx.mk_existential_predicates(iter)), r_b);\n                 let InferOk { obligations, .. } =\n-                    self.infcx.sub_types(false, &obligation.cause, new_trait, target)\n+                    self.infcx.eq_types(false, &obligation.cause, new_trait, target)\n                     .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n \n@@ -2520,7 +2520,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // [T; n] -> [T].\n             (&ty::TyArray(a, _), &ty::TySlice(b)) => {\n                 let InferOk { obligations, .. } =\n-                    self.infcx.sub_types(false, &obligation.cause, a, b)\n+                    self.infcx.eq_types(false, &obligation.cause, a, b)\n                     .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n             }\n@@ -2583,7 +2583,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 });\n                 let new_struct = tcx.mk_adt(def, tcx.mk_substs(params));\n                 let InferOk { obligations, .. } =\n-                    self.infcx.sub_types(false, &obligation.cause, new_struct, target)\n+                    self.infcx.eq_types(false, &obligation.cause, new_struct, target)\n                     .map_err(|_| Unimplemented)?;\n                 self.inferred_obligations.extend(obligations);\n "}, {"sha": "4f3abbb362ff90ff1b3a5315cff8408708b093ff", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -25,7 +25,7 @@ const ARM_WHITELIST: &'static [&'static str] = &[\"neon\\0\", \"vfp2\\0\", \"vfp3\\0\", \"\n const X86_WHITELIST: &'static [&'static str] = &[\"avx\\0\", \"avx2\\0\", \"bmi\\0\", \"bmi2\\0\", \"sse\\0\",\n                                                  \"sse2\\0\", \"sse3\\0\", \"sse4.1\\0\", \"sse4.2\\0\",\n                                                  \"ssse3\\0\", \"tbm\\0\", \"lzcnt\\0\", \"popcnt\\0\",\n-                                                 \"sse4a\\0\", \"rdrnd\\0\", \"rdseed\\0\"];\n+                                                 \"sse4a\\0\", \"rdrnd\\0\", \"rdseed\\0\", \"fma\\0\"];\n \n /// Add `target_feature = \"...\"` cfgs for a variety of platform\n /// specific features (SSE, NEON etc.)."}, {"sha": "42d9ab4d2bf274dde9f1c82b789c70b325220f0c", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n (https://github.com/rust-lang/rust/issues/39283)\");\n         }\n \n-        if temp_lifetime.is_some() {\n+        if !expr_ty.is_never() && temp_lifetime.is_some() {\n             this.cfg.push(block, Statement {\n                 source_info: source_info,\n                 kind: StatementKind::StorageLive(temp.clone())"}, {"sha": "111c8370be2b1ca2582c113537cf006cd8cc6c59", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -395,7 +395,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     }\n                 }\n                 None => {\n-                    span_bug!(span, \"Could not find container for method {}\", id);\n+                    debug!(\"Could not find container for method {} at {:?}\", id, span);\n+                    // This is not necessarily a bug, if there was a compilation error, the tables\n+                    // we need might not exist.\n+                    return None;\n                 }\n             },\n         };"}, {"sha": "1aab4853a4f641f6efd096c191365258b75d46c9", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -12,6 +12,7 @@ use astconv::AstConv;\n \n use super::FnCtxt;\n \n+use rustc::infer::InferOk;\n use rustc::traits;\n use rustc::ty::{self, Ty, TraitRef};\n use rustc::ty::{ToPredicate, TypeFoldable};\n@@ -149,6 +150,14 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n \n     pub fn finalize<'b, I>(self, pref: LvaluePreference, exprs: I)\n         where I: IntoIterator<Item = &'b hir::Expr>\n+    {\n+        let fcx = self.fcx;\n+        fcx.register_infer_ok_obligations(self.finalize_as_infer_ok(pref, exprs));\n+    }\n+\n+    pub fn finalize_as_infer_ok<'b, I>(self, pref: LvaluePreference, exprs: I)\n+                                       -> InferOk<'tcx, ()>\n+        where I: IntoIterator<Item = &'b hir::Expr>\n     {\n         let methods: Vec<_> = self.steps\n             .iter()\n@@ -176,8 +185,9 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        for obligation in self.obligations {\n-            self.fcx.register_predicate(obligation);\n+        InferOk {\n+            value: (),\n+            obligations: self.obligations\n         }\n     }\n }"}, {"sha": "c43291557f7fa4034959ac0f2fb1eb06a89c03ac", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 102, "deletions": 112, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -64,7 +64,8 @@ use check::FnCtxt;\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::{Coercion, InferOk, TypeTrace};\n+use rustc::infer::{Coercion, InferResult, InferOk, TypeTrace};\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::{self, LvaluePreference, TypeAndMut,\n@@ -75,17 +76,14 @@ use rustc::ty::relate::RelateResult;\n use rustc::ty::subst::Subst;\n use syntax::abi;\n use syntax::feature_gate;\n-use util::common::indent;\n \n-use std::cell::RefCell;\n use std::collections::VecDeque;\n use std::ops::Deref;\n \n struct Coerce<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     cause: ObligationCause<'tcx>,\n     use_lub: bool,\n-    unsizing_obligations: RefCell<Vec<traits::PredicateObligation<'tcx>>>,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for Coerce<'a, 'gcx, 'tcx> {\n@@ -95,7 +93,7 @@ impl<'a, 'gcx, 'tcx> Deref for Coerce<'a, 'gcx, 'tcx> {\n     }\n }\n \n-type CoerceResult<'tcx> = RelateResult<'tcx, (Ty<'tcx>, Adjust<'tcx>)>;\n+type CoerceResult<'tcx> = InferResult<'tcx, Adjustment<'tcx>>;\n \n fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n                        to_mutbl: hir::Mutability)\n@@ -108,44 +106,53 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n     }\n }\n \n+fn identity<'tcx>() -> Adjust<'tcx> {\n+    Adjust::DerefRef {\n+        autoderefs: 0,\n+        autoref: None,\n+        unsize: false,\n+    }\n+}\n+\n+fn success<'tcx>(kind: Adjust<'tcx>,\n+                 target: Ty<'tcx>,\n+                 obligations: traits::PredicateObligations<'tcx>)\n+                 -> CoerceResult<'tcx> {\n+    Ok(InferOk {\n+        value: Adjustment {\n+            kind,\n+            target\n+        },\n+        obligations\n+    })\n+}\n+\n impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n     fn new(fcx: &'f FnCtxt<'f, 'gcx, 'tcx>, cause: ObligationCause<'tcx>) -> Self {\n         Coerce {\n             fcx: fcx,\n             cause: cause,\n             use_lub: false,\n-            unsizing_obligations: RefCell::new(vec![]),\n         }\n     }\n \n-    fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+    fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(&self.cause, false, a, b);\n             if self.use_lub {\n                 self.lub(false, trace, &a, &b)\n-                    .map(|ok| self.register_infer_ok_obligations(ok))\n             } else {\n                 self.sub(false, trace, &a, &b)\n-                    .map(|InferOk { value, obligations }| {\n-                        self.fcx.register_predicates(obligations);\n-                        value\n-                    })\n             }\n         })\n     }\n \n-    /// Unify two types (using sub or lub) and produce a noop coercion.\n-    fn unify_and_identity(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        self.unify(&a, &b).and_then(|ty| self.identity(ty))\n-    }\n-\n-    /// Synthesize an identity adjustment.\n-    fn identity(&self, ty: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        Ok((ty, Adjust::DerefRef {\n-            autoderefs: 0,\n-            autoref: None,\n-            unsize: false,\n-        }))\n+    /// Unify two types (using sub or lub) and produce a specific coercion.\n+    fn unify_and(&self, a: Ty<'tcx>, b: Ty<'tcx>, kind: Adjust<'tcx>)\n+                 -> CoerceResult<'tcx> {\n+        self.unify(&a, &b).and_then(|InferOk { value: ty, obligations }| {\n+            success(kind, ty, obligations)\n+        })\n     }\n \n     fn coerce<'a, E, I>(&self, exprs: &E, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx>\n@@ -158,11 +165,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         // Just ignore error types.\n         if a.references_error() || b.references_error() {\n-            return self.identity(b);\n+            return success(identity(), b, vec![]);\n         }\n \n         if a.is_never() {\n-            return Ok((b, Adjust::NeverToAny));\n+            return success(Adjust::NeverToAny, b, vec![]);\n         }\n \n         // Consider coercing the subtype to a DST\n@@ -208,7 +215,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n             _ => {\n                 // Otherwise, just use unification rules.\n-                self.unify_and_identity(a, b)\n+                self.unify_and(a, b, identity())\n             }\n         }\n     }\n@@ -240,15 +247,15 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n                 (r_a, mt_a)\n             }\n-            _ => return self.unify_and_identity(a, b),\n+            _ => return self.unify_and(a, b, identity()),\n         };\n \n         let span = self.cause.span;\n \n         let mut first_error = None;\n         let mut r_borrow_var = None;\n         let mut autoderef = self.autoderef(span, a);\n-        let mut success = None;\n+        let mut found = None;\n \n         for (referent_ty, autoderefs) in autoderef.by_ref() {\n             if autoderefs == 0 {\n@@ -346,8 +353,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                                   mutbl: mt_b.mutbl, // [1] above\n                                               });\n             match self.unify(derefd_ty_a, b) {\n-                Ok(ty) => {\n-                    success = Some((ty, autoderefs));\n+                Ok(ok) => {\n+                    found = Some((ok, autoderefs));\n                     break;\n                 }\n                 Err(err) => {\n@@ -363,7 +370,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // (e.g., in example above, the failure from relating `Vec<T>`\n         // to the target type), since that should be the least\n         // confusing.\n-        let (ty, autoderefs) = match success {\n+        let (InferOk { value: ty, mut obligations }, autoderefs) = match found {\n             Some(d) => d,\n             None => {\n                 let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n@@ -372,12 +379,6 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n         };\n \n-        // This commits the obligations to the fulfillcx. After this succeeds,\n-        // this snapshot can't be rolled back.\n-        autoderef.finalize(LvaluePreference::from_mutbl(mt_b.mutbl), exprs());\n-\n-        // Now apply the autoref. We have to extract the region out of\n-        // the final ref type we got.\n         if ty == a && mt_a.mutbl == hir::MutImmutable && autoderefs == 1 {\n             // As a special case, if we would produce `&'a *x`, that's\n             // a total no-op. We end up with the type `&'a T` just as\n@@ -391,8 +392,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             // `self.x`, but we auto-coerce it to `foo(&mut *self.x)`,\n             // which is a borrow.\n             assert_eq!(mt_b.mutbl, hir::MutImmutable); // can only coerce &T -> &U\n-            return self.identity(ty);\n+            return success(identity(), ty, obligations);\n         }\n+\n+        // Now apply the autoref. We have to extract the region out of\n+        // the final ref type we got.\n         let r_borrow = match ty.sty {\n             ty::TyRef(r_borrow, _) => r_borrow,\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n@@ -402,11 +406,15 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                ty,\n                autoderefs,\n                autoref);\n-        Ok((ty, Adjust::DerefRef {\n+\n+        let pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n+        obligations.extend(autoderef.finalize_as_infer_ok(pref, exprs()).obligations);\n+\n+        success(Adjust::DerefRef {\n             autoderefs: autoderefs,\n             autoref: autoref,\n             unsize: false,\n-        }))\n+        }, ty, obligations)\n     }\n \n \n@@ -445,18 +453,32 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n             _ => (source, None),\n         };\n-        let source = source.adjust_for_autoref(self.tcx, reborrow);\n+        let coerce_source = source.adjust_for_autoref(self.tcx, reborrow);\n+\n+        let adjust = Adjust::DerefRef {\n+            autoderefs: if reborrow.is_some() { 1 } else { 0 },\n+            autoref: reborrow,\n+            unsize: true,\n+        };\n+\n+        // Setup either a subtyping or a LUB relationship between\n+        // the `CoerceUnsized` target type and the expected type.\n+        // We only have the latter, so we use an inference variable\n+        // for the former and let type inference do the rest.\n+        let origin = TypeVariableOrigin::MiscVariable(self.cause.span);\n+        let coerce_target = self.next_ty_var(origin);\n+        let mut coercion = self.unify_and(coerce_target, target, adjust)?;\n \n         let mut selcx = traits::SelectionContext::new(self);\n \n         // Use a FIFO queue for this custom fulfillment procedure.\n         let mut queue = VecDeque::new();\n-        let mut leftover_predicates = vec![];\n \n         // Create an obligation for `Source: CoerceUnsized<Target>`.\n         let cause = ObligationCause::misc(self.cause.span, self.body_id);\n         queue.push_back(self.tcx\n-            .predicate_for_trait_def(cause, coerce_unsized_did, 0, source, &[target]));\n+            .predicate_for_trait_def(cause, coerce_unsized_did, 0,\n+                                     coerce_source, &[coerce_target]));\n \n         // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n         // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where\n@@ -467,7 +489,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             let trait_ref = match obligation.predicate {\n                 ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => tr.clone(),\n                 _ => {\n-                    leftover_predicates.push(obligation);\n+                    coercion.obligations.push(obligation);\n                     continue;\n                 }\n             };\n@@ -495,33 +517,26 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n         }\n \n-        *self.unsizing_obligations.borrow_mut() = leftover_predicates;\n-\n-        let adjustment = Adjust::DerefRef {\n-            autoderefs: if reborrow.is_some() { 1 } else { 0 },\n-            autoref: reborrow,\n-            unsize: true,\n-        };\n-        debug!(\"Success, coerced with {:?}\", adjustment);\n-        Ok((target, adjustment))\n+        Ok(coercion)\n     }\n \n     fn coerce_from_safe_fn(&self,\n                            a: Ty<'tcx>,\n                            fn_ty_a: ty::PolyFnSig<'tcx>,\n-                           b: Ty<'tcx>)\n+                           b: Ty<'tcx>,\n+                           to_unsafe: Adjust<'tcx>,\n+                           normal: Adjust<'tcx>)\n                            -> CoerceResult<'tcx> {\n         if let ty::TyFnPtr(fn_ty_b) = b.sty {\n             match (fn_ty_a.unsafety(), fn_ty_b.unsafety()) {\n                 (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n                     let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n-                    return self.unify_and_identity(unsafe_a, b)\n-                        .map(|(ty, _)| (ty, Adjust::UnsafeFnPointer));\n+                    return self.unify_and(unsafe_a, b, to_unsafe);\n                 }\n                 _ => {}\n             }\n         }\n-        self.unify_and_identity(a, b)\n+        self.unify_and(a, b, normal)\n     }\n \n     fn coerce_from_fn_pointer(&self,\n@@ -536,7 +551,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         let b = self.shallow_resolve(b);\n         debug!(\"coerce_from_fn_pointer(a={:?}, b={:?})\", a, b);\n \n-        self.coerce_from_safe_fn(a, fn_ty_a, b)\n+        self.coerce_from_safe_fn(a, fn_ty_a, b,\n+            Adjust::UnsafeFnPointer, identity())\n     }\n \n     fn coerce_from_fn_item(&self,\n@@ -554,10 +570,10 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         match b.sty {\n             ty::TyFnPtr(_) => {\n                 let a_fn_pointer = self.tcx.mk_fn_ptr(fn_ty_a);\n-                self.coerce_from_safe_fn(a_fn_pointer, fn_ty_a, b)\n-                    .map(|(ty, _)| (ty, Adjust::ReifyFnPointer))\n+                self.coerce_from_safe_fn(a_fn_pointer, fn_ty_a, b,\n+                    Adjust::ReifyFnPointer, Adjust::ReifyFnPointer)\n             }\n-            _ => self.unify_and_identity(a, b),\n+            _ => self.unify_and(a, b, identity()),\n         }\n     }\n \n@@ -582,7 +598,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                                    self.cause.span,\n                                                    feature_gate::GateIssue::Language,\n                                                    feature_gate::CLOSURE_TO_FN_COERCION);\n-                    return self.unify_and_identity(a, b);\n+                    return self.unify_and(a, b, identity());\n                 }\n                 // We coerce the closure, which has fn type\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n@@ -607,10 +623,9 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 let pointer_ty = self.tcx.mk_fn_ptr(converted_sig);\n                 debug!(\"coerce_closure_to_fn(a={:?}, b={:?}, pty={:?})\",\n                        a, b, pointer_ty);\n-                self.unify_and_identity(pointer_ty, b)\n-                    .map(|(ty, _)| (ty, Adjust::ClosureFnPointer))\n+                self.unify_and(pointer_ty, b, Adjust::ClosureFnPointer)\n             }\n-            _ => self.unify_and_identity(a, b),\n+            _ => self.unify_and(a, b, identity()),\n         }\n     }\n \n@@ -625,7 +640,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             ty::TyRef(_, mt) => (true, mt),\n             ty::TyRawPtr(mt) => (false, mt),\n             _ => {\n-                return self.unify_and_identity(a, b);\n+                return self.unify_and(a, b, identity());\n             }\n         };\n \n@@ -634,50 +649,22 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             mutbl: mutbl_b,\n             ty: mt_a.ty,\n         });\n-        let (ty, noop) = self.unify_and_identity(a_unsafe, b)?;\n         coerce_mutbls(mt_a.mutbl, mutbl_b)?;\n-\n         // Although references and unsafe ptrs have the same\n         // representation, we still register an Adjust::DerefRef so that\n         // regionck knows that the region for `a` must be valid here.\n-        Ok((ty,\n-            if is_ref {\n-                Adjust::DerefRef {\n-                    autoderefs: 1,\n-                    autoref: Some(AutoBorrow::RawPtr(mutbl_b)),\n-                    unsize: false,\n-                }\n-            } else if mt_a.mutbl != mutbl_b {\n-                Adjust::MutToConstPointer\n-            } else {\n-                noop\n-            }))\n-    }\n-}\n-\n-fn apply<'a, 'b, 'gcx, 'tcx, E, I>(coerce: &mut Coerce<'a, 'gcx, 'tcx>,\n-                                   exprs: &E,\n-                                   a: Ty<'tcx>,\n-                                   b: Ty<'tcx>)\n-                                   -> RelateResult<'tcx, Adjustment<'tcx>>\n-    where E: Fn() -> I,\n-          I: IntoIterator<Item = &'b hir::Expr>\n-{\n-\n-    let (ty, adjust) = indent(|| coerce.coerce(exprs, a, b))?;\n-\n-    let fcx = coerce.fcx;\n-    if let Adjust::DerefRef { unsize: true, .. } = adjust {\n-        let mut obligations = coerce.unsizing_obligations.borrow_mut();\n-        for obligation in obligations.drain(..) {\n-            fcx.register_predicate(obligation);\n-        }\n+        self.unify_and(a_unsafe, b, if is_ref {\n+            Adjust::DerefRef {\n+                autoderefs: 1,\n+                autoref: Some(AutoBorrow::RawPtr(mutbl_b)),\n+                unsize: false,\n+            }\n+        } else if mt_a.mutbl != mutbl_b {\n+            Adjust::MutToConstPointer\n+        } else {\n+            identity()\n+        })\n     }\n-\n-    Ok(Adjustment {\n-        kind: adjust,\n-        target: ty\n-    })\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -694,9 +681,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n \n         let cause = self.cause(expr.span, ObligationCauseCode::ExprAssignable);\n-        let mut coerce = Coerce::new(self, cause);\n+        let coerce = Coerce::new(self, cause);\n         self.commit_if_ok(|_| {\n-            let adjustment = apply(&mut coerce, &|| Some(expr), source, target)?;\n+            let ok = coerce.coerce(&|| Some(expr), source, target)?;\n+            let adjustment = self.register_infer_ok_obligations(ok);\n             if !adjustment.is_identity() {\n                 debug!(\"Success, coerced with {:?}\", adjustment);\n                 match self.tables.borrow().adjustments.get(&expr.id) {\n@@ -773,9 +761,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // but only if the new expression has no coercion already applied to it.\n         let mut first_error = None;\n         if !self.tables.borrow().adjustments.contains_key(&new.id) {\n-            let result = self.commit_if_ok(|_| apply(&mut coerce, &|| Some(new), new_ty, prev_ty));\n+            let result = self.commit_if_ok(|_| coerce.coerce(&|| Some(new), new_ty, prev_ty));\n             match result {\n-                Ok(adjustment) => {\n+                Ok(ok) => {\n+                    let adjustment = self.register_infer_ok_obligations(ok);\n                     if !adjustment.is_identity() {\n                         self.write_adjustment(new.id, adjustment);\n                     }\n@@ -816,7 +805,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        match self.commit_if_ok(|_| apply(&mut coerce, &exprs, prev_ty, new_ty)) {\n+        match self.commit_if_ok(|_| coerce.coerce(&exprs, prev_ty, new_ty)) {\n             Err(_) => {\n                 // Avoid giving strange errors on failed attempts.\n                 if let Some(e) = first_error {\n@@ -828,7 +817,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     })\n                 }\n             }\n-            Ok(adjustment) => {\n+            Ok(ok) => {\n+                let adjustment = self.register_infer_ok_obligations(ok);\n                 if !adjustment.is_identity() {\n                     let mut tables = self.tables.borrow_mut();\n                     for expr in exprs() {"}, {"sha": "fc5507d4d5559cde8ddc306560265c9bf8fe92d9", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 47, "deletions": 19, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -442,7 +442,7 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n-                 print_all: bool, use_absolute: bool) -> fmt::Result {\n+                 print_all: bool, use_absolute: bool, is_not_debug: bool) -> fmt::Result {\n     let last = path.segments.last().unwrap();\n     let rel_root = match &*path.segments[0].name {\n         \"self\" => Some(\"./\".to_string()),\n@@ -459,10 +459,14 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n                     } else {\n                         root.push_str(&seg.name);\n                         root.push_str(\"/\");\n-                        write!(w, \"<a class=\\\"mod\\\"\n-                                       href=\\\"{}index.html\\\">{}</a>::\",\n-                                 root,\n-                                 seg.name)?;\n+                        if is_not_debug {\n+                            write!(w, \"<a class=\\\"mod\\\"\n+                                           href=\\\"{}index.html\\\">{}</a>::\",\n+                                     root,\n+                                     seg.name)?;\n+                        } else {\n+                            write!(w, \"{}::\", seg.name)?;\n+                        }\n                     }\n                 }\n             }\n@@ -474,19 +478,37 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n         }\n     }\n     if w.alternate() {\n-        write!(w, \"{:#}{:#}\", HRef::new(did, &last.name), last.params)?;\n+        if is_not_debug {\n+            write!(w, \"{:#}{:#}\", HRef::new(did, &last.name), last.params)?;\n+        } else {\n+            write!(w, \"{:?}{:?}\", HRef::new(did, &last.name), last.params)?;\n+        }\n     } else {\n-        let path = if use_absolute {\n-            match href(did) {\n-                Some((_, _, fqp)) => format!(\"{}::{}\",\n-                                             fqp[..fqp.len()-1].join(\"::\"),\n-                                             HRef::new(did, fqp.last().unwrap())),\n-                None => format!(\"{}\", HRef::new(did, &last.name)),\n-            }\n+        if is_not_debug {\n+            let path = if use_absolute {\n+                match href(did) {\n+                    Some((_, _, fqp)) => format!(\"{}::{}\",\n+                                                 fqp[..fqp.len()-1].join(\"::\"),\n+                                                 HRef::new(did, fqp.last().unwrap())),\n+                    None => format!(\"{}\", HRef::new(did, &last.name)),\n+                }\n+            } else {\n+                format!(\"{}\", HRef::new(did, &last.name))\n+            };\n+            write!(w, \"{}{}\", path, last.params)?;\n         } else {\n-            format!(\"{}\", HRef::new(did, &last.name))\n-        };\n-        write!(w, \"{}{}\", path, last.params)?;\n+            let path = if use_absolute {\n+                match href(did) {\n+                    Some((_, _, fqp)) => format!(\"{:?}::{:?}\",\n+                                                 fqp[..fqp.len()-1].join(\"::\"),\n+                                                 HRef::new(did, fqp.last().unwrap())),\n+                    None => format!(\"{:?}\", HRef::new(did, &last.name)),\n+                }\n+            } else {\n+                format!(\"{:?}\", HRef::new(did, &last.name))\n+            };\n+            write!(w, \"{}{:?}\", path, last.params)?;\n+        }\n     }\n     Ok(())\n }\n@@ -570,6 +592,12 @@ impl<'a> fmt::Display for HRef<'a> {\n     }\n }\n \n+impl<'a> fmt::Debug for HRef<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.text)\n+    }\n+}\n+\n fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n             is_not_debug: bool) -> fmt::Result {\n     match *t {\n@@ -578,7 +606,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n         }\n         clean::ResolvedPath{ did, ref typarams, ref path, is_generic } => {\n             // Paths like T::Output and Self::Output should be rendered with all segments\n-            resolved_path(f, did, path, is_generic, use_absolute)?;\n+            resolved_path(f, did, path, is_generic, use_absolute, is_not_debug)?;\n             tybounds(f, typarams)\n         }\n         clean::Infer => write!(f, \"_\"),\n@@ -767,7 +795,7 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool,\n                 write!(f, \"{}::\", self_type)?;\n             }\n             let path = clean::Path::singleton(name.clone());\n-            resolved_path(f, did, &path, true, use_absolute)?;\n+            resolved_path(f, did, &path, true, use_absolute, is_not_debug)?;\n \n             // FIXME: `typarams` are not rendered, and this seems bad?\n             drop(typarams);\n@@ -1051,7 +1079,7 @@ impl fmt::Display for clean::Import {\n impl fmt::Display for clean::ImportSource {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.did {\n-            Some(did) => resolved_path(f, did, &self.path, true, false),\n+            Some(did) => resolved_path(f, did, &self.path, true, false, true),\n             _ => {\n                 for (i, seg) in self.path.segments.iter().enumerate() {\n                     if i > 0 {"}, {"sha": "c1e8cb8b6defb231e9594736b31ae80165decbf8", "filename": "src/test/compile-fail/issue-40288-2.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fissue-40288-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fissue-40288-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-40288-2.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn prove_static<T: 'static + ?Sized>(_: &'static T) {}\n+\n+fn lifetime_transmute_slice<'a, T: ?Sized>(x: &'a T, y: &T) -> &'a T {\n+    let mut out = [x];\n+    //~^ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n+    {\n+        let slice: &mut [_] = &mut out;\n+        slice[0] = y;\n+    }\n+    out[0]\n+}\n+\n+struct Struct<T, U: ?Sized> {\n+    head: T,\n+    _tail: U\n+}\n+\n+fn lifetime_transmute_struct<'a, T: ?Sized>(x: &'a T, y: &T) -> &'a T {\n+    let mut out = Struct { head: x, _tail: [()] };\n+    //~^ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n+    {\n+        let dst: &mut Struct<_, [()]> = &mut out;\n+        dst.head = y;\n+    }\n+    out.head\n+}\n+\n+fn main() {\n+    prove_static(lifetime_transmute_slice(\"\", &String::from(\"foo\")));\n+    prove_static(lifetime_transmute_struct(\"\", &String::from(\"bar\")));\n+}"}, {"sha": "b5418e85bec784b04afc64488c57009701132eb2", "filename": "src/test/compile-fail/issue-40288.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fissue-40288.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fissue-40288.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-40288.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn save_ref<'a>(refr: &'a i32, to: &mut [&'a i32]) {\n+    for val in &mut *to {\n+        *val = refr;\n+    }\n+}\n+\n+fn main() {\n+    let ref init = 0i32;\n+    let ref mut refr = 1i32;\n+\n+    let mut out = [init];\n+\n+    save_ref(&*refr, &mut out);\n+\n+    // This shouldn't be allowed as `refr` is borrowed\n+    *refr = 3; //~ ERROR cannot assign to `*refr` because it is borrowed\n+\n+    // Prints 3?!\n+    println!(\"{:?}\", out[0]);\n+}"}, {"sha": "e37b6a2bb9c99aa0993c5c3525edc5c322efc696", "filename": "src/test/compile-fail/object-lifetime-default-elision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -79,7 +79,7 @@ fn load3<'a,'b>(ss: &'a SomeTrait) -> &'b SomeTrait {\n     // which fails to type check.\n \n     ss\n-        //~^ ERROR lifetime bound not satisfied\n+        //~^ ERROR cannot infer\n         //~| ERROR cannot infer\n }\n "}, {"sha": "c0dd5200f6cb4e97be5e24eddf6f1d699f27052a", "filename": "src/test/compile-fail/object-lifetime-default-from-box-error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -25,7 +25,7 @@ fn load(ss: &mut SomeStruct) -> Box<SomeTrait> {\n     // `Box<SomeTrait>` defaults to a `'static` bound, so this return\n     // is illegal.\n \n-    ss.r //~ ERROR lifetime bound not satisfied\n+    ss.r //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn store(ss: &mut SomeStruct, b: Box<SomeTrait>) {\n@@ -38,7 +38,7 @@ fn store(ss: &mut SomeStruct, b: Box<SomeTrait>) {\n fn store1<'b>(ss: &mut SomeStruct, b: Box<SomeTrait+'b>) {\n     // Here we override the lifetimes explicitly, and so naturally we get an error.\n \n-    ss.r = b; //~ ERROR lifetime bound not satisfied\n+    ss.r = b; //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "ad6c5a31bbbd3fbc4076af08cde2723acd0992ad", "filename": "src/test/compile-fail/regions-close-over-type-parameter-multiple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -27,7 +27,7 @@ fn make_object_good2<'a,'b,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'b> {\n \n fn make_object_bad<'a,'b,'c,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'c> {\n     // A outlives 'a AND 'b...but not 'c.\n-    box v as Box<SomeTrait+'a> //~ ERROR lifetime bound not satisfied\n+    box v as Box<SomeTrait+'a> //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "17fd55b031b61463513dc077928a330bb5ffe6ac", "filename": "src/test/compile-fail/regions-proc-bound-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -16,7 +16,7 @@ fn borrowed_proc<'a>(x: &'a isize) -> Box<FnMut()->(isize) + 'a> {\n \n fn static_proc(x: &isize) -> Box<FnMut()->(isize) + 'static> {\n     // This is illegal, because the region bound on `proc` is 'static.\n-    Box::new(move|| { *x }) //~ ERROR does not fulfill the required lifetime\n+    Box::new(move|| { *x }) //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() { }"}, {"sha": "e8ada6a1755719205422e74f43591b9bf8ea138f", "filename": "src/test/compile-fail/regions-trait-object-subtyping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -22,8 +22,8 @@ fn foo2<'a:'b,'b>(x: &'b mut (Dummy+'a)) -> &'b mut (Dummy+'b) {\n \n fn foo3<'a,'b>(x: &'a mut Dummy) -> &'b mut Dummy {\n     // Without knowing 'a:'b, we can't coerce\n-    x //~ ERROR lifetime bound not satisfied\n-     //~^ ERROR cannot infer\n+    x //~ ERROR cannot infer an appropriate lifetime\n+     //~^ ERROR cannot infer an appropriate lifetime\n }\n \n struct Wrapper<T>(T);"}, {"sha": "d3bf92e85f411a5207e03786dc844487d7417dcf", "filename": "src/test/compile-fail/variance-contravariant-arg-object.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-contravariant-arg-object.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -21,15 +21,15 @@ fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n                                 -> Box<Get<&'min i32>>\n     where 'max : 'min\n {\n-    v //~ ERROR mismatched types\n+    v //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n                                    -> Box<Get<&'max i32>>\n     where 'max : 'min\n {\n     // Previously OK:\n-    v //~ ERROR mismatched types\n+    v //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() { }"}, {"sha": "0e94e35df2839895fdc389f970eeb6396db708e0", "filename": "src/test/compile-fail/variance-covariant-arg-object.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-covariant-arg-object.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -22,14 +22,14 @@ fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n     where 'max : 'min\n {\n     // Previously OK, now an error as traits are invariant.\n-    v //~ ERROR mismatched types\n+    v //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n                                    -> Box<Get<&'max i32>>\n     where 'max : 'min\n {\n-    v //~ ERROR mismatched types\n+    v //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() { }"}, {"sha": "aa3e06c015d503829e89c839c2beb07e52a40e4e", "filename": "src/test/compile-fail/variance-invariant-arg-object.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-invariant-arg-object.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -18,14 +18,14 @@ fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n                                 -> Box<Get<&'min i32>>\n     where 'max : 'min\n {\n-    v //~ ERROR mismatched types\n+    v //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n                                    -> Box<Get<&'max i32>>\n     where 'max : 'min\n {\n-    v //~ ERROR mismatched types\n+    v //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() { }"}, {"sha": "900b0829530f3c41923cb30a1feecac01b1251d2", "filename": "src/test/debuginfo/c-style-enum.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fdebuginfo%2Fc-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fdebuginfo%2Fc-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fc-style-enum.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -15,31 +15,38 @@\n \n // === GDB TESTS ===================================================================================\n \n-// gdb-command:print 'c_style_enum::SINGLE_VARIANT'\n+// gdbg-command:print 'c_style_enum::SINGLE_VARIANT'\n+// gdbr-command:print c_style_enum::SINGLE_VARIANT\n // gdbg-check:$1 = TheOnlyVariant\n // gdbr-check:$1 = c_style_enum::SingleVariant::TheOnlyVariant\n \n-// gdb-command:print 'c_style_enum::AUTO_ONE'\n+// gdbg-command:print 'c_style_enum::AUTO_ONE'\n+// gdbr-command:print c_style_enum::AUTO_ONE\n // gdbg-check:$2 = One\n // gdbr-check:$2 = c_style_enum::AutoDiscriminant::One\n \n-// gdb-command:print 'c_style_enum::AUTO_TWO'\n+// gdbg-command:print 'c_style_enum::AUTO_TWO'\n+// gdbr-command:print c_style_enum::AUTO_TWO\n // gdbg-check:$3 = One\n // gdbr-check:$3 = c_style_enum::AutoDiscriminant::One\n \n-// gdb-command:print 'c_style_enum::AUTO_THREE'\n+// gdbg-command:print 'c_style_enum::AUTO_THREE'\n+// gdbr-command:print c_style_enum::AUTO_THREE\n // gdbg-check:$4 = One\n // gdbr-check:$4 = c_style_enum::AutoDiscriminant::One\n \n-// gdb-command:print 'c_style_enum::MANUAL_ONE'\n+// gdbg-command:print 'c_style_enum::MANUAL_ONE'\n+// gdbr-command:print c_style_enum::MANUAL_ONE\n // gdbg-check:$5 = OneHundred\n // gdbr-check:$5 = c_style_enum::ManualDiscriminant::OneHundred\n \n-// gdb-command:print 'c_style_enum::MANUAL_TWO'\n+// gdbg-command:print 'c_style_enum::MANUAL_TWO'\n+// gdbr-command:print c_style_enum::MANUAL_TWO\n // gdbg-check:$6 = OneHundred\n // gdbr-check:$6 = c_style_enum::ManualDiscriminant::OneHundred\n \n-// gdb-command:print 'c_style_enum::MANUAL_THREE'\n+// gdbg-command:print 'c_style_enum::MANUAL_THREE'\n+// gdbr-command:print c_style_enum::MANUAL_THREE\n // gdbg-check:$7 = OneHundred\n // gdbr-check:$7 = c_style_enum::ManualDiscriminant::OneHundred\n "}, {"sha": "e8c3597b8c8dd68fdbd194f10c79831b82032f54", "filename": "src/test/debuginfo/limited-debuginfo.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -15,10 +15,14 @@\n \n // Make sure functions have proper names\n // gdb-command:info functions\n-// gdb-check:[...]void[...]main([...]);\n-// gdb-check:[...]void[...]some_function([...]);\n-// gdb-check:[...]void[...]some_other_function([...]);\n-// gdb-check:[...]void[...]zzz([...]);\n+// gdbg-check:[...]void[...]main([...]);\n+// gdbr-check:fn limited_debuginfo::main();\n+// gdbg-check:[...]void[...]some_function([...]);\n+// gdbr-check:fn limited_debuginfo::some_function();\n+// gdbg-check:[...]void[...]some_other_function([...]);\n+// gdbr-check:fn limited_debuginfo::some_other_function();\n+// gdbg-check:[...]void[...]zzz([...]);\n+// gdbr-check:fn limited_debuginfo::zzz();\n \n // gdb-command:run\n "}, {"sha": "ae05bafe5adaa70c07967a202d8f929bf1771f3e", "filename": "src/test/debuginfo/simple-struct.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fdebuginfo%2Fsimple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fdebuginfo%2Fsimple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fsimple-struct.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -14,9 +14,6 @@\n \n // === GDB TESTS ===================================================================================\n \n-// there's no frame yet for gdb to reliably detect the language, set it explicitly\n-// gdbr-command:set language rust\n-\n // gdbg-command:print 'simple_struct::NO_PADDING_16'\n // gdbr-command:print simple_struct::NO_PADDING_16\n // gdbg-check:$1 = {x = 1000, y = -1001}"}, {"sha": "b3c270411509592141fac499eb96864fb3d0c665", "filename": "src/test/debuginfo/simple-tuple.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fdebuginfo%2Fsimple-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fdebuginfo%2Fsimple-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fsimple-tuple.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -14,9 +14,6 @@\n \n // === GDB TESTS ===================================================================================\n \n-// there's no frame yet for gdb to reliably detect the language, set it explicitly\n-// gdbr-command:set language rust\n-\n // gdbg-command:print/d 'simple_tuple::NO_PADDING_8'\n // gdbr-command:print simple_tuple::NO_PADDING_8\n // gdbg-check:$1 = {__0 = -50, __1 = 50}"}, {"sha": "fbbffe8953b38959a550565ba3fcd80128315e47", "filename": "src/test/mir-opt/issue-38669.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-38669.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -35,7 +35,6 @@ fn main() {\n //     }\n //\n //     bb2: {\n-//         StorageLive(_6);\n //         _0 = ();\n //         StorageDead(_4);\n //         StorageDead(_1);"}, {"sha": "9e81636e36703c4372203d87202027456c7496db", "filename": "src/test/run-make/extern-fn-with-packed-struct/test.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -8,14 +8,36 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::fmt;\n+\n #[repr(packed)]\n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone)]\n struct Foo {\n     a: i8,\n     b: i16,\n     c: i8\n }\n \n+impl PartialEq for Foo {\n+    fn eq(&self, other: &Foo) -> bool {\n+        self.a == other.a && self.b == other.b && self.c == other.c\n+    }\n+}\n+\n+impl fmt::Debug for Foo {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let a = self.a;\n+        let b = self.b;\n+        let c = self.c;\n+\n+        f.debug_struct(\"Foo\")\n+            .field(\"a\", &a)\n+            .field(\"b\", &b)\n+            .field(\"c\", &c)\n+            .finish()\n+    }\n+}\n+\n #[link(name = \"test\", kind = \"static\")]\n extern {\n     fn foo(f: Foo) -> Foo;"}, {"sha": "b19708f5a89316f46bad187fdca87bf5235eb932", "filename": "src/test/run-pass/coerce-unsize-subtype.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Frun-pass%2Fcoerce-unsize-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Frun-pass%2Fcoerce-unsize-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-unsize-subtype.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// pretty-expanded FIXME #23616\n+\n+use std::rc::Rc;\n+\n+fn lub_short<'a, T>(_: &[&'a T], _: &[&'a T]) {}\n+\n+// The two arguments are a subtype of their LUB, after coercion.\n+fn long_and_short<'a, T>(xs: &[&'static T; 1], ys: &[&'a T; 1]) {\n+    lub_short(xs, ys);\n+}\n+\n+// The argument coerces to a subtype of the return type.\n+fn long_to_short<'a, 'b, T>(xs: &'b [&'static T; 1]) -> &'b [&'a T] {\n+    xs\n+}\n+\n+// Rc<T> is covariant over T just like &T.\n+fn long_to_short_rc<'a, T>(xs: Rc<[&'static T; 1]>) -> Rc<[&'a T]> {\n+    xs\n+}\n+\n+// LUB-coercion (if-else/match/array) coerces `xs: &'b [&'static T: N]`\n+// to a subtype of the LUB of `xs` and `ys` (i.e. `&'b [&'a T]`),\n+// regardless of the order they appear (in if-else/match/array).\n+fn long_and_short_lub1<'a, 'b, T>(xs: &'b [&'static T; 1], ys: &'b [&'a T]) {\n+    let _order1 = [xs, ys];\n+    let _order2 = [ys, xs];\n+}\n+\n+// LUB-coercion should also have the exact same effect when `&'b [&'a T; N]`\n+// needs to be coerced, i.e. the resulting type is not &'b [&'static T], but\n+// rather the `&'b [&'a T]` LUB.\n+fn long_and_short_lub2<'a, 'b, T>(xs: &'b [&'static T], ys: &'b [&'a T; 1]) {\n+    let _order1 = [xs, ys];\n+    let _order2 = [ys, xs];\n+}\n+\n+fn main() {}"}, {"sha": "57407b8422371be2152d5d30207e1c78a17f6c8d", "filename": "src/test/run-pass/packed-struct-vec.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-vec.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -8,15 +8,34 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::fmt;\n use std::mem;\n \n #[repr(packed)]\n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone)]\n struct Foo {\n     bar: u8,\n     baz: u64\n }\n \n+impl PartialEq for Foo {\n+    fn eq(&self, other: &Foo) -> bool {\n+        self.bar == other.bar && self.baz == other.baz\n+    }\n+}\n+\n+impl fmt::Debug for Foo {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let bar = self.bar;\n+        let baz = self.baz;\n+\n+        f.debug_struct(\"Foo\")\n+            .field(\"bar\", &bar)\n+            .field(\"baz\", &baz)\n+            .finish()\n+    }\n+}\n+\n pub fn main() {\n     let foos = [Foo { bar: 1, baz: 2 }; 10];\n "}, {"sha": "c476657d207966cdf2d9242e86bda46643a5fba2", "filename": "src/test/ui/type-check/issue-38812-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fui%2Ftype-check%2Fissue-38812-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fui%2Ftype-check%2Fissue-38812-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fissue-38812-2.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "previous_filename": "src/test/ui/codemap_tests/issue-38812-2.rs"}, {"sha": "156a6bdee99799a4b4af722c6f3bc95e0a5e7360", "filename": "src/test/ui/type-check/issue-38812-2.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fui%2Ftype-check%2Fissue-38812-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fui%2Ftype-check%2Fissue-38812-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fissue-38812-2.stderr?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "previous_filename": "src/test/ui/codemap_tests/issue-38812-2.stderr"}, {"sha": "a9943f753366da8d794a144eed344cb7b1597d06", "filename": "src/test/ui/type-check/issue-38812.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fui%2Ftype-check%2Fissue-38812.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fui%2Ftype-check%2Fissue-38812.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fissue-38812.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "previous_filename": "src/test/ui/codemap_tests/issue-38812.rs"}, {"sha": "6365e761453f90167fb088a5f7cb52c233b3459b", "filename": "src/test/ui/type-check/issue-38812.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fui%2Ftype-check%2Fissue-38812.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fui%2Ftype-check%2Fissue-38812.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fissue-38812.stderr?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "previous_filename": "src/test/ui/codemap_tests/issue-38812.stderr"}, {"sha": "d30a425d1099b01d88489dc80eae1e650e027f4e", "filename": "src/test/ui/type-check/issue-40294.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fui%2Ftype-check%2Fissue-40294.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fui%2Ftype-check%2Fissue-40294.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fissue-40294.rs?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo: Sized {\n+    fn foo(self);\n+}\n+\n+fn foo<'a,'b,T>(x: &'a T, y: &'b T)\n+    where &'a T : Foo,\n+          &'b T : Foo\n+{\n+    x.foo();\n+    y.foo();\n+}\n+\n+fn main() { }"}, {"sha": "5c388c9d602eab7e6f1c28927422a8dcff3b888f", "filename": "src/test/ui/type-check/issue-40294.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fui%2Ftype-check%2Fissue-40294.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/744e69663e910ece9a7cf754049b09d6afb22e9f/src%2Ftest%2Fui%2Ftype-check%2Fissue-40294.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fissue-40294.stderr?ref=744e69663e910ece9a7cf754049b09d6afb22e9f", "patch": "@@ -0,0 +1,15 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-40294.rs:15:1\n+   |\n+15 |   fn foo<'a,'b,T>(x: &'a T, y: &'b T)\n+   |  _^ starting here...\n+16 | |     where &'a T : Foo,\n+17 | |           &'b T : Foo\n+18 | | {\n+19 | |     x.foo();\n+20 | |     y.foo();\n+21 | | }\n+   | |_^ ...ending here: cannot infer type for `&'a T`\n+\n+error: aborting due to previous error\n+"}]}