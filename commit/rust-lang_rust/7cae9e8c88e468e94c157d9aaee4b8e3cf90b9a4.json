{"sha": "7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjYWU5ZThjODhlNDY4ZTk0YzE1N2Q5YWFlZTRiOGUzY2Y5MGI5YTQ=", "commit": {"author": {"name": "maekawatoshiki", "email": "konndennsa@gmail.com", "date": "2020-07-31T09:50:11Z"}, "committer": {"name": "maekawatoshiki", "email": "konndennsa@gmail.com", "date": "2020-07-31T12:08:08Z"}, "message": "`#![deny(unsafe_op_in_unsafe_fn)]` in sys/hermit", "tree": {"sha": "13e6344753d21e56a0f16f4b5a3b08170c879d1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13e6344753d21e56a0f16f4b5a3b08170c879d1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4", "html_url": "https://github.com/rust-lang/rust/commit/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/comments", "author": {"login": "maekawatoshiki", "id": 9913176, "node_id": "MDQ6VXNlcjk5MTMxNzY=", "avatar_url": "https://avatars.githubusercontent.com/u/9913176?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maekawatoshiki", "html_url": "https://github.com/maekawatoshiki", "followers_url": "https://api.github.com/users/maekawatoshiki/followers", "following_url": "https://api.github.com/users/maekawatoshiki/following{/other_user}", "gists_url": "https://api.github.com/users/maekawatoshiki/gists{/gist_id}", "starred_url": "https://api.github.com/users/maekawatoshiki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maekawatoshiki/subscriptions", "organizations_url": "https://api.github.com/users/maekawatoshiki/orgs", "repos_url": "https://api.github.com/users/maekawatoshiki/repos", "events_url": "https://api.github.com/users/maekawatoshiki/events{/privacy}", "received_events_url": "https://api.github.com/users/maekawatoshiki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "maekawatoshiki", "id": 9913176, "node_id": "MDQ6VXNlcjk5MTMxNzY=", "avatar_url": "https://avatars.githubusercontent.com/u/9913176?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maekawatoshiki", "html_url": "https://github.com/maekawatoshiki", "followers_url": "https://api.github.com/users/maekawatoshiki/followers", "following_url": "https://api.github.com/users/maekawatoshiki/following{/other_user}", "gists_url": "https://api.github.com/users/maekawatoshiki/gists{/gist_id}", "starred_url": "https://api.github.com/users/maekawatoshiki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maekawatoshiki/subscriptions", "organizations_url": "https://api.github.com/users/maekawatoshiki/orgs", "repos_url": "https://api.github.com/users/maekawatoshiki/repos", "events_url": "https://api.github.com/users/maekawatoshiki/events{/privacy}", "received_events_url": "https://api.github.com/users/maekawatoshiki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac91673d895a0c578ed773e1280bdde8adb87b8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac91673d895a0c578ed773e1280bdde8adb87b8c", "html_url": "https://github.com/rust-lang/rust/commit/ac91673d895a0c578ed773e1280bdde8adb87b8c"}], "stats": {"total": 222, "additions": 147, "deletions": 75}, "files": [{"sha": "04446172197f76bb76d833e2eeea389cfea573b4", "filename": "library/std/src/sys/hermit/alloc.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Falloc.rs?ref=7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4", "patch": "@@ -1,3 +1,5 @@\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use crate::alloc::{GlobalAlloc, Layout, System};\n use crate::ptr;\n use crate::sys::hermit::abi;\n@@ -6,26 +8,33 @@ use crate::sys::hermit::abi;\n unsafe impl GlobalAlloc for System {\n     #[inline]\n     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-        abi::malloc(layout.size(), layout.align())\n+        // SAFETY: The safety contract for `malloc` must be upheld by the caller.\n+        unsafe { abi::malloc(layout.size(), layout.align()) }\n     }\n \n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-        let addr = abi::malloc(layout.size(), layout.align());\n+        // SAFETY: The safety contract for `malloc` must be upheld by the caller.\n+        // Also, `addr` must be valid for writes of `layout.size() * size_of::<u8>()` bytes.\n+        unsafe {\n+            let addr = abi::malloc(layout.size(), layout.align());\n \n-        if !addr.is_null() {\n-            ptr::write_bytes(addr, 0x00, layout.size());\n-        }\n+            if !addr.is_null() {\n+                ptr::write_bytes(addr, 0x00, layout.size());\n+            }\n \n-        addr\n+            addr\n+        }\n     }\n \n     #[inline]\n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n-        abi::free(ptr, layout.size(), layout.align())\n+        // SAFETY: The safety contract for `free` must be upheld by the caller.\n+        unsafe { abi::free(ptr, layout.size(), layout.align()) }\n     }\n \n     #[inline]\n     unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-        abi::realloc(ptr, layout.size(), layout.align(), new_size)\n+        // SAFETY: The safety contract for `realloc` must be upheld by the caller.\n+        unsafe { abi::realloc(ptr, layout.size(), layout.align(), new_size) }\n     }\n }"}, {"sha": "dd8830599c37efbf7a669fc69aba0ffbdc5f7524", "filename": "library/std/src/sys/hermit/args.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs?ref=7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4", "patch": "@@ -1,15 +1,17 @@\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use crate::ffi::OsString;\n use crate::marker::PhantomData;\n use crate::vec;\n \n /// One-time global initialization.\n pub unsafe fn init(argc: isize, argv: *const *const u8) {\n-    imp::init(argc, argv)\n+    unsafe { imp::init(argc, argv) }\n }\n \n /// One-time global cleanup.\n pub unsafe fn cleanup() {\n-    imp::cleanup()\n+    unsafe { imp::cleanup() }\n }\n \n /// Returns the command line arguments\n@@ -65,14 +67,18 @@ mod imp {\n \n     pub unsafe fn init(argc: isize, argv: *const *const u8) {\n         let _guard = LOCK.lock();\n-        ARGC = argc;\n-        ARGV = argv;\n+        unsafe {\n+            ARGC = argc;\n+            ARGV = argv;\n+        }\n     }\n \n     pub unsafe fn cleanup() {\n         let _guard = LOCK.lock();\n         ARGC = 0;\n-        ARGV = ptr::null();\n+        unsafe {\n+            ARGV = ptr::null();\n+        }\n     }\n \n     pub fn args() -> Args {"}, {"sha": "662dc9394a36f228a24bee1313b3619a9ebe6afc", "filename": "library/std/src/sys/hermit/condvar.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fcondvar.rs?ref=7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4", "patch": "@@ -1,3 +1,5 @@\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use crate::ffi::c_void;\n use crate::ptr;\n use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n@@ -23,33 +25,43 @@ impl Condvar {\n     }\n \n     pub unsafe fn init(&mut self) {\n-        let _ = abi::sem_init(&mut self.sem1 as *mut *const c_void, 0);\n-        let _ = abi::sem_init(&mut self.sem2 as *mut *const c_void, 0);\n+        unsafe {\n+            let _ = abi::sem_init(&mut self.sem1 as *mut *const c_void, 0);\n+            let _ = abi::sem_init(&mut self.sem2 as *mut *const c_void, 0);\n+        }\n     }\n \n     pub unsafe fn notify_one(&self) {\n         if self.counter.load(SeqCst) > 0 {\n             self.counter.fetch_sub(1, SeqCst);\n-            abi::sem_post(self.sem1);\n-            abi::sem_timedwait(self.sem2, 0);\n+            unsafe {\n+                abi::sem_post(self.sem1);\n+                abi::sem_timedwait(self.sem2, 0);\n+            }\n         }\n     }\n \n     pub unsafe fn notify_all(&self) {\n         let counter = self.counter.swap(0, SeqCst);\n         for _ in 0..counter {\n-            abi::sem_post(self.sem1);\n+            unsafe {\n+                abi::sem_post(self.sem1);\n+            }\n         }\n         for _ in 0..counter {\n-            abi::sem_timedwait(self.sem2, 0);\n+            unsafe {\n+                abi::sem_timedwait(self.sem2, 0);\n+            }\n         }\n     }\n \n     pub unsafe fn wait(&self, mutex: &Mutex) {\n         self.counter.fetch_add(1, SeqCst);\n         mutex.unlock();\n-        abi::sem_timedwait(self.sem1, 0);\n-        abi::sem_post(self.sem2);\n+        unsafe {\n+            abi::sem_timedwait(self.sem1, 0);\n+            abi::sem_post(self.sem2);\n+        }\n         mutex.lock();\n     }\n \n@@ -58,7 +70,9 @@ impl Condvar {\n     }\n \n     pub unsafe fn destroy(&self) {\n-        let _ = abi::sem_destroy(self.sem1);\n-        let _ = abi::sem_destroy(self.sem2);\n+        unsafe {\n+            let _ = abi::sem_destroy(self.sem1);\n+            let _ = abi::sem_destroy(self.sem2);\n+        }\n     }\n }"}, {"sha": "2914e5ad3dbe2f3c78089ecbe9b3a832d0ab5ea4", "filename": "library/std/src/sys/hermit/fd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd.rs?ref=7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4", "patch": "@@ -1,3 +1,4 @@\n+#![deny(unsafe_op_in_unsafe_fn)]\n #![unstable(reason = \"not public\", issue = \"none\", feature = \"fd\")]\n \n use crate::io::{self, ErrorKind, Read};"}, {"sha": "0e4504020df4231778473ea91a715532a2901549", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4", "patch": "@@ -13,6 +13,8 @@\n //! compiling for wasm. That way it's a compile time error for something that's\n //! guaranteed to be a runtime error!\n \n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use crate::intrinsics;\n use crate::os::raw::c_char;\n \n@@ -62,8 +64,12 @@ pub enum Void {}\n pub unsafe fn strlen(start: *const c_char) -> usize {\n     let mut str = start;\n \n-    while *str != 0 {\n-        str = str.offset(1);\n+    // SAFETY: The safety contract for `*str != 0` must be upheld by the caller.\n+    // `start` must not be null.\n+    unsafe {\n+        while *str != 0 {\n+            str = str.offset(1);\n+        }\n     }\n \n     (str as usize) - (start as usize)\n@@ -111,13 +117,15 @@ pub unsafe extern \"C\" fn runtime_entry(\n         fn main(argc: isize, argv: *const *const c_char) -> i32;\n     }\n \n-    // initialize environment\n-    os::init_environment(env as *const *const i8);\n+    unsafe {\n+        // initialize environment\n+        os::init_environment(env as *const *const i8);\n \n-    let result = main(argc as isize, argv);\n+        let result = main(argc as isize, argv);\n \n-    run_dtors();\n-    abi::exit(result);\n+        run_dtors();\n+        abi::exit(result);\n+    }\n }\n \n pub fn decode_error_kind(errno: i32) -> ErrorKind {"}, {"sha": "bcb2554ab29278a44a2b5c821a458710b29c54bf", "filename": "library/std/src/sys/hermit/mutex.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs?ref=7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4", "patch": "@@ -1,3 +1,5 @@\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use crate::ffi::c_void;\n use crate::ptr;\n use crate::sys::hermit::abi;\n@@ -16,28 +18,34 @@ impl Mutex {\n \n     #[inline]\n     pub unsafe fn init(&mut self) {\n-        let _ = abi::sem_init(&mut self.inner as *mut *const c_void, 1);\n+        unsafe {\n+            let _ = abi::sem_init(&mut self.inner as *mut *const c_void, 1);\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn lock(&self) {\n-        let _ = abi::sem_timedwait(self.inner, 0);\n+        unsafe {\n+            let _ = abi::sem_timedwait(self.inner, 0);\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn unlock(&self) {\n-        let _ = abi::sem_post(self.inner);\n+        unsafe {\n+            let _ = abi::sem_post(self.inner);\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        let result = abi::sem_trywait(self.inner);\n+        let result = unsafe { abi::sem_trywait(self.inner) };\n         result == 0\n     }\n \n     #[inline]\n     pub unsafe fn destroy(&self) {\n-        let _ = abi::sem_destroy(self.inner);\n+        let _ = unsafe { abi::sem_destroy(self.inner) };\n     }\n }\n \n@@ -52,12 +60,12 @@ impl ReentrantMutex {\n \n     #[inline]\n     pub unsafe fn init(&self) {\n-        let _ = abi::recmutex_init(&self.inner as *const *const c_void as *mut _);\n+        let _ = unsafe { abi::recmutex_init(&self.inner as *const *const c_void as *mut _) };\n     }\n \n     #[inline]\n     pub unsafe fn lock(&self) {\n-        let _ = abi::recmutex_lock(self.inner);\n+        let _ = unsafe { abi::recmutex_lock(self.inner) };\n     }\n \n     #[inline]\n@@ -67,11 +75,11 @@ impl ReentrantMutex {\n \n     #[inline]\n     pub unsafe fn unlock(&self) {\n-        let _ = abi::recmutex_unlock(self.inner);\n+        let _ = unsafe { abi::recmutex_unlock(self.inner) };\n     }\n \n     #[inline]\n     pub unsafe fn destroy(&self) {\n-        let _ = abi::recmutex_destroy(self.inner);\n+        let _ = unsafe { abi::recmutex_destroy(self.inner) };\n     }\n }"}, {"sha": "d95940c9a76c8b16b1b7843a0196e766a5853fac", "filename": "library/std/src/sys/hermit/os.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fos.rs?ref=7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4", "patch": "@@ -1,3 +1,5 @@\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use crate::collections::HashMap;\n use crate::error::Error as StdError;\n use crate::ffi::{CStr, OsStr, OsString};"}, {"sha": "a6c7bcc7641fc6650239fd4bf74a1cd3d677d8d5", "filename": "library/std/src/sys/hermit/rwlock.rs", "status": "modified", "additions": 42, "deletions": 26, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Frwlock.rs?ref=7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4", "patch": "@@ -1,3 +1,5 @@\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use crate::cell::UnsafeCell;\n use crate::sys::condvar::Condvar;\n use crate::sys::mutex::Mutex;\n@@ -32,62 +34,76 @@ impl RWLock {\n \n     #[inline]\n     pub unsafe fn read(&self) {\n-        self.lock.lock();\n-        while !(*self.state.get()).inc_readers() {\n-            self.cond.wait(&self.lock);\n+        unsafe {\n+            self.lock.lock();\n+            while !(*self.state.get()).inc_readers() {\n+                self.cond.wait(&self.lock);\n+            }\n+            self.lock.unlock();\n         }\n-        self.lock.unlock();\n     }\n \n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n-        self.lock.lock();\n-        let ok = (*self.state.get()).inc_readers();\n-        self.lock.unlock();\n+        unsafe {\n+            self.lock.lock();\n+            let ok = (*self.state.get()).inc_readers();\n+            self.lock.unlock();\n+        }\n         return ok;\n     }\n \n     #[inline]\n     pub unsafe fn write(&self) {\n-        self.lock.lock();\n-        while !(*self.state.get()).inc_writers() {\n-            self.cond.wait(&self.lock);\n+        unsafe {\n+            self.lock.lock();\n+            while !(*self.state.get()).inc_writers() {\n+                self.cond.wait(&self.lock);\n+            }\n         }\n         self.lock.unlock();\n     }\n \n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n-        self.lock.lock();\n-        let ok = (*self.state.get()).inc_writers();\n-        self.lock.unlock();\n+        unsafe {\n+            self.lock.lock();\n+            let ok = (*self.state.get()).inc_writers();\n+            self.lock.unlock();\n+        }\n         return ok;\n     }\n \n     #[inline]\n     pub unsafe fn read_unlock(&self) {\n-        self.lock.lock();\n-        let notify = (*self.state.get()).dec_readers();\n-        self.lock.unlock();\n-        if notify {\n-            // FIXME: should only wake up one of these some of the time\n-            self.cond.notify_all();\n+        unsafe {\n+            self.lock.lock();\n+            let notify = (*self.state.get()).dec_readers();\n+            self.lock.unlock();\n+            if notify {\n+                // FIXME: should only wake up one of these some of the time\n+                self.cond.notify_all();\n+            }\n         }\n     }\n \n     #[inline]\n     pub unsafe fn write_unlock(&self) {\n-        self.lock.lock();\n-        (*self.state.get()).dec_writers();\n-        self.lock.unlock();\n-        // FIXME: should only wake up one of these some of the time\n-        self.cond.notify_all();\n+        unsafe {\n+            self.lock.lock();\n+            (*self.state.get()).dec_writers();\n+            self.lock.unlock();\n+            // FIXME: should only wake up one of these some of the time\n+            self.cond.notify_all();\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn destroy(&self) {\n-        self.lock.destroy();\n-        self.cond.destroy();\n+        unsafe {\n+            self.lock.destroy();\n+            self.cond.destroy();\n+        }\n     }\n }\n "}, {"sha": "7c52112a80c2d299eceb28955217fef13b29452d", "filename": "library/std/src/sys/hermit/thread.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs?ref=7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4", "patch": "@@ -1,4 +1,5 @@\n #![allow(dead_code)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::ffi::CStr;\n use crate::io;\n@@ -25,18 +26,22 @@ impl Thread {\n         core_id: isize,\n     ) -> io::Result<Thread> {\n         let p = Box::into_raw(box p);\n-        let tid = abi::spawn2(\n-            thread_start,\n-            p as usize,\n-            abi::Priority::into(abi::NORMAL_PRIO),\n-            stack,\n-            core_id,\n-        );\n+        let tid = unsafe {\n+            abi::spawn2(\n+                thread_start,\n+                p as usize,\n+                abi::Priority::into(abi::NORMAL_PRIO),\n+                stack,\n+                core_id,\n+            )\n+        };\n \n         return if tid == 0 {\n             // The thread failed to start and as a result p was not consumed. Therefore, it is\n             // safe to reconstruct the box so that it gets deallocated.\n-            drop(Box::from_raw(p));\n+            unsafe {\n+                drop(Box::from_raw(p));\n+            }\n             Err(io::Error::new(io::ErrorKind::Other, \"Unable to create thread!\"))\n         } else {\n             Ok(Thread { tid: tid })"}, {"sha": "7998dd3cb4347f55a827c9ac3418e3526fcbd70f", "filename": "library/std/src/sys/hermit/thread_local_dtor.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread_local_dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread_local_dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread_local_dtor.rs?ref=7cae9e8c88e468e94c157d9aaee4b8e3cf90b9a4", "patch": "@@ -1,5 +1,6 @@\n #![cfg(target_thread_local)]\n #![unstable(feature = \"thread_local_internals\", issue = \"none\")]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n // Simplify dtor registration by using a list of destructors.\n // The this solution works like the implementation of macOS and\n@@ -19,15 +20,17 @@ pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n         DTORS.set(Box::into_raw(v));\n     }\n \n-    let list: &mut List = &mut *DTORS.get();\n+    // SAFETY: `DTORS.get()` is not null.\n+    let list: &mut List = unsafe { &mut *DTORS.get() };\n     list.push((t, dtor));\n }\n \n // every thread call this function to run through all possible destructors\n pub unsafe fn run_dtors() {\n     let mut ptr = DTORS.replace(ptr::null_mut());\n     while !ptr.is_null() {\n-        let list = Box::from_raw(ptr);\n+        // SAFETY: `ptr` is not null.\n+        let list = unsafe { Box::from_raw(ptr) };\n         for (ptr, dtor) in list.into_iter() {\n             dtor(ptr);\n         }"}]}