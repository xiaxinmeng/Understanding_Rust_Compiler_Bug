{"sha": "d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyYjg1MzIzYWQzODc0ZjRhYWQwYjU2ZjY3NTViYzk4N2I1ZDhkYWQ=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-03-10T17:19:47Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-03-10T18:06:28Z"}, "message": "Addressed points raised in review.", "tree": {"sha": "c3dbbebfa8c37601d0f873df3c740b194a4f57c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3dbbebfa8c37601d0f873df3c740b194a4f57c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "html_url": "https://github.com/rust-lang/rust/commit/d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d43966a1760069180fad2ec05f9c2e33391d6c42", "url": "https://api.github.com/repos/rust-lang/rust/commits/d43966a1760069180fad2ec05f9c2e33391d6c42", "html_url": "https://github.com/rust-lang/rust/commit/d43966a1760069180fad2ec05f9c2e33391d6c42"}], "stats": {"total": 92, "additions": 44, "deletions": 48}, "files": [{"sha": "e2651206e8032ff29e8bc1ea3fb9697b63f35f78", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "patch": "@@ -26,8 +26,7 @@ declare_clippy_lint! {\n     /// ```\n     pub ASSERTIONS_ON_CONSTANTS,\n     style,\n-    \"`assert!(true)` / `assert!(false)` will be optimized out by the compiler, \\\n-     and should probably be replaced by a `panic!()` or `unreachable!()`\"\n+    \"`assert!(true)` / `assert!(false)` will be optimized out by the compiler, and should probably be replaced by a `panic!()` or `unreachable!()`\"\n }\n \n pub struct AssertionsOnConstants;"}, {"sha": "0e8d47384f1a4b6825793c29e2a6dde6365e125b", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "patch": "@@ -258,9 +258,8 @@ fn check_text(cx: &EarlyContext<'_>, valid_idents: &FxHashSet<String>, text: &st\n \n fn check_word(cx: &EarlyContext<'_>, word: &str, span: Span) {\n     /// Checks if a string is camel-case, i.e., contains at least two uppercase\n-    /// letters (`Clippy` is\n-    /// ok) and one lower-case letter (`NASA` is ok). Plural are also excluded\n-    /// (`IDs` is ok).\n+    /// letters (`Clippy` is ok) and one lower-case letter (`NASA` is ok).\n+    /// Plurals are also excluded (`IDs` is ok).\n     fn is_camel_case(s: &str) -> bool {\n         if s.starts_with(|c: char| c.is_digit(10)) {\n             return false;"}, {"sha": "4b2ba60090f9d3583db40eff0ce25b71eedc170c", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "patch": "@@ -20,7 +20,7 @@ declare_clippy_lint! {\n     /// them leads to more readable code.\n     ///\n     /// **Known problems:** Potential false negatives: we bail out if the function\n-    /// has a where-clause where lifetimes are mentioned.\n+    /// has a `where` clause where lifetimes are mentioned.\n     ///\n     /// **Example:**\n     /// ```rust\n@@ -385,7 +385,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n     }\n }\n \n-/// Are any lifetimes mentioned in the where-clause? If yes, we don't try to\n+/// Are any lifetimes mentioned in the `where` clause? If so, we don't try to\n /// reason about elision.\n fn has_where_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, where_clause: &'tcx WhereClause) -> bool {\n     for predicate in &where_clause.predicates {"}, {"sha": "0016625631c70b29007151aeff683ad983353be6", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "patch": "@@ -1413,7 +1413,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Ex\n     }\n }\n \n-/// Checks for `for` loops over `Option`s and `Results`\n+/// Checks for `for` loops over `Option`s and `Result`s.\n fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr) {\n     let ty = cx.tables.expr_ty(arg);\n     if match_type(cx, ty, &paths::OPTION) {\n@@ -1673,7 +1673,7 @@ fn check_for_mutation(\n     delegate.mutation_span()\n }\n \n-/// Returns `true` if the pattern is a `PatWild` or an ident prefixed with `'_'`.\n+/// Returns `true` if the pattern is a `PatWild` or an ident prefixed with `_`.\n fn pat_is_wild<'tcx>(pat: &'tcx PatKind, body: &'tcx Expr) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n@@ -2336,7 +2336,7 @@ fn path_name(e: &Expr) -> Option<Name> {\n \n fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, expr: &'tcx Expr) {\n     if constant(cx, cx.tables, cond).is_some() {\n-        // A pure constant condition (e.g., while false) is not linted.\n+        // A pure constant condition (e.g., `while false`) is not linted.\n         return;\n     }\n "}, {"sha": "e7e1df5cffff201855942b4892326f4a9a289401", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "patch": "@@ -322,7 +322,7 @@ fn check_single_match_opt_like(\n     ty: Ty<'_>,\n     els: Option<&Expr>,\n ) {\n-    // list of candidate Enums we know will never get any more members\n+    // list of candidate `Enum`s we know will never get any more members\n     let candidates = &[\n         (&paths::COW, \"Borrowed\"),\n         (&paths::COW, \"Cow::Borrowed\"),\n@@ -335,7 +335,7 @@ fn check_single_match_opt_like(\n \n     let path = match arms[1].pats[0].node {\n         PatKind::TupleStruct(ref path, ref inner, _) => {\n-            // contains any non wildcard patterns? e.g., Err(err)\n+            // Contains any non wildcard patterns (e.g., `Err(err)`)?\n             if !inner.iter().all(is_wild) {\n                 return;\n             }\n@@ -354,7 +354,7 @@ fn check_single_match_opt_like(\n }\n \n fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n-    // type of expression == bool\n+    // Type of expression is `bool`.\n     if cx.tables.expr_ty(ex).sty == ty::Bool {\n         span_lint_and_then(\n             cx,"}, {"sha": "46cb9ecc49be990054f3464b153d97975eec283a", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "patch": "@@ -592,8 +592,7 @@ fn is_used(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n }\n \n /// Tests whether an expression is in a macro expansion (e.g., something\n-/// generated by\n-/// `#[derive(...)`] or the like).\n+/// generated by `#[derive(...)]` or the like).\n fn in_attributes_expansion(expr: &Expr) -> bool {\n     expr.span\n         .ctxt()"}, {"sha": "de11e3ff45b5451b1b82426c7bbeefc3106ff878", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "patch": "@@ -52,7 +52,7 @@ impl Pass {\n     ///\n     /// ```ignore\n     /// if option.is_none() {\n-    ///    return `None`;\n+    ///    return None;\n     /// }\n     /// ```\n     ///"}, {"sha": "888405983fd5129a853ccd80f13d5bb1d9f5e520", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "patch": "@@ -197,7 +197,7 @@ struct VectorInitializationVisitor<'a, 'tcx: 'a> {\n     /// Contains the information.\n     vec_alloc: VecAllocation<'tcx>,\n \n-    /// Contains, the slow initialization expression, if one was found.\n+    /// Contains the slow initialization expression, if one was found.\n     slow_expression: Option<InitializationType<'tcx>>,\n \n     /// `true` if the initialization of the vector has been found on the visited block."}, {"sha": "5b124dd96bf2e46a742efe082a6481efd563a404", "filename": "clippy_lints/src/utils/camel_case.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fcamel_case.rs?ref=d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "patch": "@@ -1,5 +1,4 @@\n-/// Returns the index of the character after the first camel-case component of\n-/// `s`.\n+/// Returns the index of the character after the first camel-case component of `s`.\n pub fn until(s: &str) -> usize {\n     let mut iter = s.char_indices();\n     if let Some((_, first)) = iter.next() {"}, {"sha": "bf94c8a086811f184040be1199b3a19e27d1807a", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "patch": "@@ -147,15 +147,15 @@ pub fn get_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Vec<&'static str>\n         .collect()\n }\n \n-/// Checks if type is struct, enum or union type with given def path.\n+/// Checks if type is struct, enum or union type with the given def path.\n pub fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::Adt(adt, _) => match_def_path(cx.tcx, adt.did, path),\n         _ => false,\n     }\n }\n \n-/// Checks if the method call given in `expr` belongs to given trait.\n+/// Checks if the method call given in `expr` belongs to the given trait.\n pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = cx.tables.type_dependent_defs()[expr.hir_id];\n     let trt_id = cx.tcx.trait_of_item(method_call.def_id());\n@@ -434,7 +434,7 @@ pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Name> {\n     }\n }\n \n-/// Gets the name of a `Pat`, if any\n+/// Gets the name of a `Pat`, if any.\n pub fn get_pat_name(pat: &Pat) -> Option<Name> {\n     match pat.node {\n         PatKind::Binding(.., ref spname, _) => Some(spname.name),\n@@ -614,7 +614,7 @@ fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, ch: char) -> Cow<'_\n     }\n }\n \n-/// Gets a parent expressions if any \u2013 this is useful to constrain a lint.\n+/// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr) -> Option<&'c Expr> {\n     let map = &cx.tcx.hir();\n     let hir_id = e.hir_id;\n@@ -727,7 +727,7 @@ pub fn is_expn_of(mut span: Span, name: &str) -> Option<Span> {\n     }\n }\n \n-/// Returns the pre-expansion span if is this directly comes from an expansion\n+/// Returns the pre-expansion span if the span directly comes from an expansion\n /// of the macro `name`.\n /// The difference with `is_expn_of` is that in\n /// ```rust,ignore\n@@ -749,7 +749,7 @@ pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n     }\n }\n \n-/// Convenience function to get the return type of a function\n+/// Convenience function to get the return type of a function.\n pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: hir::HirId) -> Ty<'tcx> {\n     let fn_def_id = cx.tcx.hir().local_def_id_from_hir_id(fn_item);\n     let ret_ty = cx.tcx.fn_sig(fn_def_id).output();\n@@ -759,9 +759,9 @@ pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: hir::HirId) -> T\n /// Checks if two types are the same.\n ///\n /// This discards any lifetime annotations, too.\n-// FIXME: this works correctly for lifetimes bounds (`for <'a> Foo<'a>` == `for\n-// <'b> Foo<'b>` but\n-// not for type parameters.\n+//\n+// FIXME: this works correctly for lifetimes bounds (`for <'a> Foo<'a>` ==\n+// `for <'b> Foo<'b>`, but not for type parameters).\n pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n     let a = cx.tcx.erase_late_bound_regions(&Binder::bind(a));\n     let b = cx.tcx.erase_late_bound_regions(&Binder::bind(b));\n@@ -871,8 +871,8 @@ pub fn iter_input_pats<'tcx>(decl: &FnDecl, body: &'tcx Body) -> impl Iterator<I\n     (0..decl.inputs.len()).map(move |i| &body.arguments[i])\n }\n \n-/// Checks if a given expression is a match expression\n-/// expanded from `?` operator or `try` macro.\n+/// Checks if a given expression is a match expression expanded from the `?`\n+/// operator or the `try` macro.\n pub fn is_try<'a>(cx: &'_ LateContext<'_, '_>, expr: &'a Expr) -> Option<&'a Expr> {\n     fn is_ok(cx: &'_ LateContext<'_, '_>, arm: &Arm) -> bool {\n         if_chain! {"}, {"sha": "72740cee5006a1812c3407957dbaebf71be4ea3d", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "patch": "@@ -241,12 +241,12 @@ impl<'a> Sugg<'a> {\n     }\n \n     /// Adds parenthesis to any expression that might need them. Suitable to the\n-    /// `self` argument of\n-    /// a method call (e.g., to build `bar.foo()` or `(1 + 2).foo()`).\n+    /// `self` argument of a method call\n+    /// (e.g., to build `bar.foo()` or `(1 + 2).foo()`).\n     pub fn maybe_par(self) -> Self {\n         match self {\n             Sugg::NonParen(..) => self,\n-            // (x) and (x).y() both don't need additional parens\n+            // `(x)` and `(x).y()` both don't need additional parens.\n             Sugg::MaybeParen(sugg) => {\n                 if sugg.starts_with('(') && sugg.ends_with(')') {\n                     Sugg::MaybeParen(sugg)\n@@ -282,7 +282,7 @@ impl<'a> std::ops::Not for Sugg<'a> {\n \n /// Helper type to display either `foo` or `(foo)`.\n struct ParenHelper<T> {\n-    /// Whether parenthesis are needed.\n+    /// `true` if parentheses are needed.\n     paren: bool,\n     /// The main thing to display.\n     wrapped: T,\n@@ -320,22 +320,22 @@ pub fn make_unop(op: &str, expr: Sugg<'_>) -> Sugg<'static> {\n /// often confusing so\n /// parenthesis will always be added for a mix of these.\n pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static> {\n-    /// Whether the operator is a shift operator `<<` or `>>`.\n+    /// Returns `true` if the operator is a shift operator `<<` or `>>`.\n     fn is_shift(op: &AssocOp) -> bool {\n         matches!(*op, AssocOp::ShiftLeft | AssocOp::ShiftRight)\n     }\n \n-    /// Whether the operator is a arithmetic operator (`+`, `-`, `*`, `/`, `%`).\n+    /// Returns `true` if the operator is a arithmetic operator\n+    /// (i.e., `+`, `-`, `*`, `/`, `%`).\n     fn is_arith(op: &AssocOp) -> bool {\n         matches!(\n             *op,\n             AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide | AssocOp::Modulus\n         )\n     }\n \n-    /// Whether the operator `op` needs parenthesis with the operator `other`\n-    /// in the direction\n-    /// `dir`.\n+    /// Returns `true` if the operator `op` needs parenthesis with the operator\n+    /// `other` in the direction `dir`.\n     fn needs_paren(op: &AssocOp, other: &AssocOp, dir: Associativity) -> bool {\n         other.precedence() < op.precedence()\n             || (other.precedence() == op.precedence()\n@@ -414,9 +414,8 @@ enum Associativity {\n }\n \n /// Returns the associativity/fixity of an operator. The difference with\n-/// `AssocOp::fixity` is that\n-/// an operator can be both left and right associative (such as `+`:\n-/// `a + b + c == (a + b) + c == a + (b + c)`.\n+/// `AssocOp::fixity` is that an operator can be both left and right associative\n+/// (such as `+`: `a + b + c == (a + b) + c == a + (b + c)`.\n ///\n /// Chained `as` and explicit `:` type coercion never need inner parenthesis so\n /// they are considered"}, {"sha": "10342ed28b5757e94b2db10eb3a168fd878cd561", "filename": "tests/ui/block_in_if_condition.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/tests%2Fui%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/tests%2Fui%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblock_in_if_condition.rs?ref=d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "patch": "@@ -48,9 +48,10 @@ fn predicate<F: FnOnce(T) -> bool, T>(pfn: F, val: T) -> bool {\n fn pred_test() {\n     let v = 3;\n     let sky = \"blue\";\n-    // this is a sneaky case, where the block isn't directly in the condition, but is actually\n-    , andadd some extra\n-    // expressions to make sure linter isn't confused by them.\n+    // This is a sneaky case, where the block isn't directly in the condition,\n+    // but is actually nside a closure that the condition is using.\n+    // The same principle applies -- add some extra expressions to make sure\n+    // linter isn't confused by them.\n     if v == 3\n         && sky == \"blue\"\n         && predicate("}, {"sha": "2ef31f0b9484cf79ba57e7f3ae1ffd7bc22815ce", "filename": "tests/ui/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/tests%2Fui%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b85323ad3874f4aad0b56f6755bc987b5d8dad/tests%2Fui%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.rs?ref=d2b85323ad3874f4aad0b56f6755bc987b5d8dad", "patch": "@@ -6,7 +6,7 @@\n struct Foo(pub String);\n \n macro_rules! foo {\n-  ($($t:tt)*) => (Foo(format!($($t)*)))\n+    ($($t:tt)*) => (Foo(format!($($t)*)))\n }\n \n fn main() {\n@@ -49,8 +49,8 @@ fn main() {\n     foo!(\"should not warn\");\n \n     // Precision on string means slicing without panicking on size.\n-    format!(\"{:.1}\", \"foo\"); // could be `\"foo\"[..1]`\n-    format!(\"{:.10}\", \"foo\"); // could not be `\"foo\"[..10]`\n+    format!(\"{:.1}\", \"foo\"); // Could be `\"foo\"[..1]`\n+    format!(\"{:.10}\", \"foo\"); // Could not be `\"foo\"[..10]`\n     format!(\"{:.prec$}\", \"foo\", prec = 1);\n     format!(\"{:.prec$}\", \"foo\", prec = 10);\n "}]}