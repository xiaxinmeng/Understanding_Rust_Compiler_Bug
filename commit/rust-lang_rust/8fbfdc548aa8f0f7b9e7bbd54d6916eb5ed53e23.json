{"sha": "8fbfdc548aa8f0f7b9e7bbd54d6916eb5ed53e23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmYmZkYzU0OGFhOGYwZjdiOWU3YmJkNTRkNjkxNmViNWVkNTNlMjM=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-10-04T15:15:45Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-10-08T04:29:38Z"}, "message": "Introduce `Divider`\n\nThis distinguishes between documentation on the original from docs on\nthe re-export", "tree": {"sha": "b47f63c71f0513dfcb400b7de7e0458760cde6c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b47f63c71f0513dfcb400b7de7e0458760cde6c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fbfdc548aa8f0f7b9e7bbd54d6916eb5ed53e23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fbfdc548aa8f0f7b9e7bbd54d6916eb5ed53e23", "html_url": "https://github.com/rust-lang/rust/commit/8fbfdc548aa8f0f7b9e7bbd54d6916eb5ed53e23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fbfdc548aa8f0f7b9e7bbd54d6916eb5ed53e23/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa1b15f6279a95923b8a19046f45f27f243d49d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa1b15f6279a95923b8a19046f45f27f243d49d2", "html_url": "https://github.com/rust-lang/rust/commit/fa1b15f6279a95923b8a19046f45f27f243d49d2"}], "stats": {"total": 128, "additions": 75, "deletions": 53}, "files": [{"sha": "179cf248846a8018d82b3d508dea4c2cc71362a4", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 75, "deletions": 53, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/8fbfdc548aa8f0f7b9e7bbd54d6916eb5ed53e23/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fbfdc548aa8f0f7b9e7bbd54d6916eb5ed53e23/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=8fbfdc548aa8f0f7b9e7bbd54d6916eb5ed53e23", "patch": "@@ -391,6 +391,24 @@ pub enum DocFragmentKind {\n     /// A doc fragment created from a `#[doc(include=\"filename\")]` attribute. Contains both the\n     /// given filename and the file contents.\n     Include { filename: String },\n+    /// A doc fragment used to distinguish between documentation in different modules.\n+    ///\n+    /// In particular, this prevents `collapse_docs` from turning all documentation comments\n+    /// into a single giant attributes even when the item is re-exported with documentation on the re-export.\n+    Divider,\n+}\n+\n+impl DocFragment {\n+    /// Creates a dummy doc-fragment which divides earlier and later fragments.\n+    fn divider() -> Self {\n+        DocFragment {\n+            line: 0,\n+            span: DUMMY_SP,\n+            parent_module: None,\n+            doc: String::new(),\n+            kind: DocFragmentKind::Divider,\n+        }\n+    }\n }\n \n impl<'a> FromIterator<&'a DocFragment> for String {\n@@ -531,68 +549,72 @@ impl Attributes {\n         attrs: &[ast::Attribute],\n         additional_attrs: Option<(&[ast::Attribute], DefId)>,\n     ) -> Attributes {\n-        let mut doc_strings = vec![];\n+        let doc_strings = RefCell::new(vec![]);\n         let mut sp = None;\n         let mut cfg = Cfg::True;\n         let mut doc_line = 0;\n \n-        // Additional documentation should be shown before the original documentation\n-        let other_attrs = additional_attrs\n-            .into_iter()\n-            .map(|(attrs, id)| attrs.iter().map(move |attr| (attr, Some(id))))\n-            .flatten()\n-            .chain(attrs.iter().map(|attr| (attr, None)))\n-            .filter_map(|(attr, parent_module)| {\n-                if let Some(value) = attr.doc_str() {\n-                    trace!(\"got doc_str={:?}\", value);\n-                    let value = beautify_doc_string(value);\n-                    let kind = if attr.is_doc_comment() {\n-                        DocFragmentKind::SugaredDoc\n-                    } else {\n-                        DocFragmentKind::RawDoc\n-                    };\n-\n-                    let line = doc_line;\n-                    doc_line += value.lines().count();\n-                    doc_strings.push(DocFragment {\n-                        line,\n-                        span: attr.span,\n-                        doc: value,\n-                        kind,\n-                        parent_module,\n-                    });\n-\n-                    if sp.is_none() {\n-                        sp = Some(attr.span);\n-                    }\n-                    None\n+        let clean_attr = |(attr, parent_module): (&ast::Attribute, _)| {\n+            if let Some(value) = attr.doc_str() {\n+                trace!(\"got doc_str={:?}\", value);\n+                let value = beautify_doc_string(value);\n+                let kind = if attr.is_doc_comment() {\n+                    DocFragmentKind::SugaredDoc\n                 } else {\n-                    if attr.has_name(sym::doc) {\n-                        if let Some(mi) = attr.meta() {\n-                            if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n-                                // Extracted #[doc(cfg(...))]\n-                                match Cfg::parse(cfg_mi) {\n-                                    Ok(new_cfg) => cfg &= new_cfg,\n-                                    Err(e) => diagnostic.span_err(e.span, e.msg),\n-                                }\n-                            } else if let Some((filename, contents)) =\n-                                Attributes::extract_include(&mi)\n-                            {\n-                                let line = doc_line;\n-                                doc_line += contents.lines().count();\n-                                doc_strings.push(DocFragment {\n-                                    line,\n-                                    span: attr.span,\n-                                    doc: contents,\n-                                    kind: DocFragmentKind::Include { filename },\n-                                    parent_module: parent_module,\n-                                });\n+                    DocFragmentKind::RawDoc\n+                };\n+\n+                let line = doc_line;\n+                doc_line += value.lines().count();\n+                doc_strings.borrow_mut().push(DocFragment {\n+                    line,\n+                    span: attr.span,\n+                    doc: value,\n+                    kind,\n+                    parent_module,\n+                });\n+\n+                if sp.is_none() {\n+                    sp = Some(attr.span);\n+                }\n+                None\n+            } else {\n+                if attr.has_name(sym::doc) {\n+                    if let Some(mi) = attr.meta() {\n+                        if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n+                            // Extracted #[doc(cfg(...))]\n+                            match Cfg::parse(cfg_mi) {\n+                                Ok(new_cfg) => cfg &= new_cfg,\n+                                Err(e) => diagnostic.span_err(e.span, e.msg),\n                             }\n+                        } else if let Some((filename, contents)) = Attributes::extract_include(&mi)\n+                        {\n+                            let line = doc_line;\n+                            doc_line += contents.lines().count();\n+                            doc_strings.borrow_mut().push(DocFragment {\n+                                line,\n+                                span: attr.span,\n+                                doc: contents,\n+                                kind: DocFragmentKind::Include { filename },\n+                                parent_module: parent_module,\n+                            });\n                         }\n                     }\n-                    Some(attr.clone())\n                 }\n+                Some(attr.clone())\n+            }\n+        };\n+\n+        // Additional documentation should be shown before the original documentation\n+        let other_attrs = additional_attrs\n+            .into_iter()\n+            .map(|(attrs, id)| {\n+                doc_strings.borrow_mut().push(DocFragment::divider());\n+                attrs.iter().map(move |attr| (attr, Some(id)))\n             })\n+            .flatten()\n+            .chain(attrs.iter().map(|attr| (attr, None)))\n+            .filter_map(clean_attr)\n             .collect();\n \n         // treat #[target_feature(enable = \"feat\")] attributes as if they were\n@@ -618,7 +640,7 @@ impl Attributes {\n             .map_or(true, |a| a.style == AttrStyle::Inner);\n \n         Attributes {\n-            doc_strings,\n+            doc_strings: doc_strings.into_inner(),\n             other_attrs,\n             cfg: if cfg == Cfg::True { None } else { Some(Arc::new(cfg)) },\n             span: sp,"}]}