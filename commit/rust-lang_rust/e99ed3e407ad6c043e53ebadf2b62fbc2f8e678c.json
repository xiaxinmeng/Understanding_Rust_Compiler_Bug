{"sha": "e99ed3e407ad6c043e53ebadf2b62fbc2f8e678c", "node_id": "C_kwDOAAsO6NoAKGU5OWVkM2U0MDdhZDZjMDQzZTUzZWJhZGYyYjYyZmJjMmY4ZTY3OGM", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-12-21T14:01:52Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-12-21T14:01:52Z"}, "message": "Simplify enum variant rendering, remove constructor structs", "tree": {"sha": "de596bcc0b3677e345b53ab5a2e082266791168d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de596bcc0b3677e345b53ab5a2e082266791168d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e99ed3e407ad6c043e53ebadf2b62fbc2f8e678c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e99ed3e407ad6c043e53ebadf2b62fbc2f8e678c", "html_url": "https://github.com/rust-lang/rust/commit/e99ed3e407ad6c043e53ebadf2b62fbc2f8e678c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e99ed3e407ad6c043e53ebadf2b62fbc2f8e678c/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a720fc8e3a8ae3d8052d0c87767056408bc25ffa", "url": "https://api.github.com/repos/rust-lang/rust/commits/a720fc8e3a8ae3d8052d0c87767056408bc25ffa", "html_url": "https://github.com/rust-lang/rust/commit/a720fc8e3a8ae3d8052d0c87767056408bc25ffa"}], "stats": {"total": 172, "additions": 71, "deletions": 101}, "files": [{"sha": "f613f0dfde2d2e42ac44755e260170dbd48f0da1", "filename": "crates/ide_completion/src/render/enum_variant.rs", "status": "modified", "additions": 71, "deletions": 101, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/e99ed3e407ad6c043e53ebadf2b62fbc2f8e678c/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e99ed3e407ad6c043e53ebadf2b62fbc2f8e678c/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs?ref=e99ed3e407ad6c043e53ebadf2b62fbc2f8e678c", "patch": "@@ -1,10 +1,10 @@\n //! Renderer for `enum` variants.\n \n-use std::{iter, mem};\n+use std::iter;\n \n-use hir::{HasAttrs, HirDisplay};\n+use hir::{db::HirDatabase, HasAttrs, HirDisplay, StructKind};\n use ide_db::SymbolKind;\n-use stdx::format_to;\n+use itertools::Itertools;\n \n use crate::{\n     item::{CompletionItem, ImportEdit},\n@@ -20,116 +20,86 @@ pub(crate) fn render_variant(\n     path: Option<hir::ModPath>,\n ) -> CompletionItem {\n     let _p = profile::span(\"render_enum_variant\");\n-    EnumRender::new(ctx, local_name, variant, path).render(import_to_add)\n+    render(ctx, local_name, variant, path, import_to_add)\n }\n \n-#[derive(Debug)]\n-struct EnumRender<'a> {\n-    ctx: RenderContext<'a>,\n+fn render(\n+    ctx @ RenderContext { completion }: RenderContext<'_>,\n+    local_name: Option<hir::Name>,\n     variant: hir::Variant,\n     path: Option<hir::ModPath>,\n-    qualified_name: hir::ModPath,\n-    short_qualified_name: hir::ModPath,\n-    variant_kind: hir::StructKind,\n-}\n-\n-impl<'a> EnumRender<'a> {\n-    fn new(\n-        ctx: RenderContext<'a>,\n-        local_name: Option<hir::Name>,\n-        variant: hir::Variant,\n-        path: Option<hir::ModPath>,\n-    ) -> EnumRender<'a> {\n-        let name = local_name.unwrap_or_else(|| variant.name(ctx.db()));\n-        let variant_kind = variant.kind(ctx.db());\n-\n-        let (qualified_name, short_qualified_name) = match &path {\n-            Some(path) => {\n-                let short = hir::ModPath::from_segments(\n-                    hir::PathKind::Plain,\n-                    path.segments().iter().skip(path.segments().len().saturating_sub(2)).cloned(),\n-                );\n-                (path.clone(), short)\n-            }\n-            None => (\n-                hir::ModPath::from_segments(hir::PathKind::Plain, iter::once(name.clone())),\n-                hir::ModPath::from_segments(hir::PathKind::Plain, iter::once(name)),\n-            ),\n-        };\n-\n-        EnumRender { ctx, variant, path, qualified_name, short_qualified_name, variant_kind }\n-    }\n-    fn render(self, import_to_add: Option<ImportEdit>) -> CompletionItem {\n-        let mut item = CompletionItem::new(\n-            SymbolKind::Variant,\n-            self.ctx.source_range(),\n-            self.qualified_name.to_string(),\n-        );\n-        item.set_documentation(self.variant.docs(self.ctx.db()))\n-            .set_deprecated(self.ctx.is_deprecated(self.variant))\n-            .detail(self.detail());\n-\n-        if let Some(import_to_add) = import_to_add {\n-            item.add_import(import_to_add);\n-        }\n-\n-        if self.variant_kind == hir::StructKind::Tuple {\n-            cov_mark::hit!(inserts_parens_for_tuple_enums);\n-            let params = Params::Anonymous(self.variant.fields(self.ctx.db()).len());\n-            item.add_call_parens(\n-                self.ctx.completion,\n-                self.short_qualified_name.to_string(),\n-                params,\n+    import_to_add: Option<ImportEdit>,\n+) -> CompletionItem {\n+    let db = completion.db;\n+    let name = local_name.unwrap_or_else(|| variant.name(db));\n+    let variant_kind = variant.kind(db);\n+\n+    let (qualified_name, short_qualified_name, qualified) = match path {\n+        Some(path) => {\n+            let short = hir::ModPath::from_segments(\n+                hir::PathKind::Plain,\n+                path.segments().iter().skip(path.segments().len().saturating_sub(2)).cloned(),\n             );\n-        } else if self.path.is_some() {\n-            item.lookup_by(self.short_qualified_name.to_string());\n+            (path, short, true)\n         }\n+        None => (\n+            hir::ModPath::from_segments(hir::PathKind::Plain, iter::once(name.clone())),\n+            hir::ModPath::from_segments(hir::PathKind::Plain, iter::once(name)),\n+            false,\n+        ),\n+    };\n+\n+    // FIXME: ModPath::to_smol_str()?\n+    let mut item =\n+        CompletionItem::new(SymbolKind::Variant, ctx.source_range(), qualified_name.to_string());\n+    item.set_documentation(variant.docs(db))\n+        .set_deprecated(ctx.is_deprecated(variant))\n+        .detail(detail(db, variant, variant_kind));\n+\n+    if let Some(import_to_add) = import_to_add {\n+        item.add_import(import_to_add);\n+    }\n \n-        let ty = self.variant.parent_enum(self.ctx.completion.db).ty(self.ctx.completion.db);\n-        item.set_relevance(CompletionRelevance {\n-            type_match: compute_type_match(self.ctx.completion, &ty),\n-            ..CompletionRelevance::default()\n-        });\n+    // FIXME: ModPath::to_smol_str()?\n+    let short_qualified_name = short_qualified_name.to_string();\n+    if variant_kind == hir::StructKind::Tuple {\n+        cov_mark::hit!(inserts_parens_for_tuple_enums);\n+        let params = Params::Anonymous(variant.fields(db).len());\n+        item.add_call_parens(ctx.completion, short_qualified_name, params);\n+    } else if qualified {\n+        item.lookup_by(short_qualified_name);\n+    }\n \n-        if let Some(ref_match) = compute_ref_match(self.ctx.completion, &ty) {\n-            item.ref_match(ref_match);\n-        }\n+    let ty = variant.parent_enum(ctx.completion.db).ty(ctx.completion.db);\n+    item.set_relevance(CompletionRelevance {\n+        type_match: compute_type_match(ctx.completion, &ty),\n+        ..CompletionRelevance::default()\n+    });\n \n-        item.build()\n+    if let Some(ref_match) = compute_ref_match(ctx.completion, &ty) {\n+        item.ref_match(ref_match);\n     }\n \n-    fn detail(&self) -> String {\n-        let detail_types = self\n-            .variant\n-            .fields(self.ctx.db())\n-            .into_iter()\n-            .map(|field| (field.name(self.ctx.db()), field.ty(self.ctx.db())));\n-\n-        let mut b = String::new();\n-        let mut first_run = true;\n-        match self.variant_kind {\n-            hir::StructKind::Tuple | hir::StructKind::Unit => {\n-                format_to!(b, \"(\");\n-                for (_, t) in detail_types {\n-                    if !mem::take(&mut first_run) {\n-                        format_to!(b, \", \");\n-                    }\n-                    format_to!(b, \"{}\", t.display(self.ctx.db()));\n-                }\n-                format_to!(b, \")\");\n-            }\n-            hir::StructKind::Record => {\n-                format_to!(b, \"{{\");\n-                for (n, t) in detail_types {\n-                    if !mem::take(&mut first_run) {\n-                        format_to!(b, \", \");\n-                    }\n-                    format_to!(b, \"{}: {}\", n, t.display(self.ctx.db()));\n-                }\n-                format_to!(b, \"}}\");\n-            }\n+    item.build()\n+}\n+\n+fn detail(db: &dyn HirDatabase, variant: hir::Variant, variant_kind: StructKind) -> String {\n+    let detail_types = variant.fields(db).into_iter().map(|field| (field.name(db), field.ty(db)));\n+\n+    match variant_kind {\n+        hir::StructKind::Tuple | hir::StructKind::Unit => {\n+            format!(\"({})\", detail_types.format_with(\", \", |(_, t), f| f(&t.display(db))))\n+        }\n+        hir::StructKind::Record => {\n+            format!(\n+                \"{{{}}}\",\n+                detail_types.format_with(\", \", |(n, t), f| {\n+                    f(&n)?;\n+                    f(&\": \")?;\n+                    f(&t.display(db))\n+                }),\n+            )\n         }\n-        b\n     }\n }\n "}]}