{"sha": "1a78991df69630b581b4210083c9e94157bab0e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhNzg5OTFkZjY5NjMwYjU4MWI0MjEwMDgzYzllOTQxNTdiYWIwZTE=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-01-26T22:16:18Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-01-26T22:57:24Z"}, "message": "Adjust the tests", "tree": {"sha": "b139503ade9771b6135c5c578aabc1c77a1bb4a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b139503ade9771b6135c5c578aabc1c77a1bb4a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a78991df69630b581b4210083c9e94157bab0e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a78991df69630b581b4210083c9e94157bab0e1", "html_url": "https://github.com/rust-lang/rust/commit/1a78991df69630b581b4210083c9e94157bab0e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a78991df69630b581b4210083c9e94157bab0e1/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0a782ef1c53ef5c5d3b49b02c498f7a688c3a4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0a782ef1c53ef5c5d3b49b02c498f7a688c3a4d", "html_url": "https://github.com/rust-lang/rust/commit/d0a782ef1c53ef5c5d3b49b02c498f7a688c3a4d"}], "stats": {"total": 211, "additions": 150, "deletions": 61}, "files": [{"sha": "295fdf2e29b92bfccafd7c52529d285afffdddba", "filename": "crates/ra_assists/src/assists/auto_import.rs", "status": "modified", "additions": 89, "deletions": 55, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/1a78991df69630b581b4210083c9e94157bab0e1/crates%2Fra_assists%2Fsrc%2Fassists%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a78991df69630b581b4210083c9e94157bab0e1/crates%2Fra_assists%2Fsrc%2Fassists%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fauto_import.rs?ref=1a78991df69630b581b4210083c9e94157bab0e1", "patch": "@@ -100,88 +100,122 @@ mod tests {\n     use super::*;\n     use crate::helpers::{\n         check_assist_with_imports_locator, check_assist_with_imports_locator_not_applicable,\n+        TestImportsLocator,\n     };\n-    use hir::Name;\n \n-    #[derive(Clone)]\n-    struct TestImportsLocator<'a> {\n-        import_path: &'a [Name],\n-    }\n+    #[test]\n+    fn applicable_when_found_an_import() {\n+        check_assist_with_imports_locator(\n+            auto_import,\n+            TestImportsLocator::new,\n+            r\"\n+            PubStruct<|>\n \n-    impl<'a> TestImportsLocator<'a> {\n-        fn new(import_path: &'a [Name]) -> Self {\n-            TestImportsLocator { import_path }\n-        }\n-    }\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n+            r\"\n+            use PubMod::PubStruct;\n \n-    impl<'a> ImportsLocator for TestImportsLocator<'a> {\n-        fn find_imports(\n-            &mut self,\n-            _: hir::InFile<&ast::NameRef>,\n-            _: hir::Module,\n-        ) -> Option<Vec<hir::ModPath>> {\n-            if self.import_path.is_empty() {\n-                None\n-            } else {\n-                Some(vec![hir::ModPath {\n-                    kind: hir::PathKind::Plain,\n-                    segments: self.import_path.to_owned(),\n-                }])\n+            PubStruct<|>\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n             }\n-        }\n+            \",\n+        );\n     }\n \n     #[test]\n-    fn applicable_when_found_an_import() {\n-        let import_path = &[hir::name::known::std, hir::name::known::ops, hir::name::known::Debug];\n-        let mut imports_locator = TestImportsLocator::new(import_path);\n+    fn applicable_when_found_multiple_imports() {\n         check_assist_with_imports_locator(\n             auto_import,\n-            &mut imports_locator,\n-            \"\n-            fn main() {\n+            TestImportsLocator::new,\n+            r\"\n+            PubStruct<|>\n+\n+            pub mod PubMod1 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod2 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod3 {\n+                pub struct PubStruct;\n+            }\n+            \",\n+            r\"\n+            use PubMod1::PubStruct;\n+\n+            PubStruct<|>\n+\n+            pub mod PubMod1 {\n+                pub struct PubStruct;\n+            }\n+            pub mod PubMod2 {\n+                pub struct PubStruct;\n             }\n+            pub mod PubMod3 {\n+                pub struct PubStruct;\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_already_imported_types() {\n+        check_assist_with_imports_locator_not_applicable(\n+            auto_import,\n+            TestImportsLocator::new,\n+            r\"\n+            use PubMod::PubStruct;\n+\n+            PubStruct<|>\n \n-            Debug<|>\",\n-            &format!(\n-                \"\n-            use {};\n-\n-            fn main() {{\n-            }}\n-\n-            Debug<|>\",\n-                import_path\n-                    .into_iter()\n-                    .map(|name| name.to_string())\n-                    .collect::<Vec<String>>()\n-                    .join(\"::\")\n-            ),\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\n+            \",\n         );\n     }\n \n     #[test]\n-    fn not_applicable_when_no_imports_found() {\n-        let mut imports_locator = TestImportsLocator::new(&[]);\n+    fn not_applicable_for_types_with_private_paths() {\n         check_assist_with_imports_locator_not_applicable(\n             auto_import,\n-            &mut imports_locator,\n-            \"\n-            fn main() {\n+            TestImportsLocator::new,\n+            r\"\n+            PrivateStruct<|>\n+\n+            pub mod PubMod {\n+                struct PrivateStruct;\n             }\n+            \",\n+        );\n+    }\n \n-            Debug<|>\",\n+    #[test]\n+    fn not_applicable_when_no_imports_found() {\n+        check_assist_with_imports_locator_not_applicable(\n+            auto_import,\n+            TestImportsLocator::new,\n+            \"\n+            PubStruct<|>\",\n         );\n     }\n \n     #[test]\n     fn not_applicable_in_import_statements() {\n-        let import_path = &[hir::name::known::std, hir::name::known::ops, hir::name::known::Debug];\n-        let mut imports_locator = TestImportsLocator::new(import_path);\n         check_assist_with_imports_locator_not_applicable(\n             auto_import,\n-            &mut imports_locator,\n-            \"use Debug<|>;\",\n+            TestImportsLocator::new,\n+            r\"\n+            use PubStruct<|>;\n+\n+            pub mod PubMod {\n+                pub struct PubStruct;\n+            }\",\n         );\n     }\n }"}, {"sha": "724bce1916c78e16ed0136ea1cad152ab5aa7e54", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 60, "deletions": 6, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1a78991df69630b581b4210083c9e94157bab0e1/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a78991df69630b581b4210083c9e94157bab0e1/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=1a78991df69630b581b4210083c9e94157bab0e1", "patch": "@@ -226,11 +226,59 @@ mod assists {\n \n #[cfg(test)]\n mod helpers {\n-    use ra_db::{fixture::WithFixture, FileRange};\n+    use hir::db::DefDatabase;\n+    use ra_db::{fixture::WithFixture, FileId, FileRange};\n     use ra_syntax::TextRange;\n     use test_utils::{add_cursor, assert_eq_text, extract_offset, extract_range};\n \n     use crate::{test_db::TestDB, Assist, AssistCtx, ImportsLocator};\n+    use std::sync::Arc;\n+\n+    pub(crate) struct TestImportsLocator {\n+        db: Arc<TestDB>,\n+        test_file_id: FileId,\n+    }\n+\n+    impl TestImportsLocator {\n+        pub(crate) fn new(db: Arc<TestDB>, test_file_id: FileId) -> Self {\n+            TestImportsLocator { db, test_file_id }\n+        }\n+    }\n+\n+    impl ImportsLocator for TestImportsLocator {\n+        fn find_imports(&mut self, name_to_import: &str) -> Vec<hir::ModuleDef> {\n+            let crate_def_map = self.db.crate_def_map(self.db.test_crate());\n+            let mut findings = vec![];\n+\n+            let mut module_ids_to_process =\n+                crate_def_map.modules_for_file(self.test_file_id).collect::<Vec<_>>();\n+\n+            while !module_ids_to_process.is_empty() {\n+                let mut more_ids_to_process = vec![];\n+                for local_module_id in module_ids_to_process.drain(..) {\n+                    for (name, namespace_data) in\n+                        crate_def_map[local_module_id].scope.entries_without_primitives()\n+                    {\n+                        let found_a_match = &name.to_string() == name_to_import;\n+                        vec![namespace_data.types, namespace_data.values]\n+                            .into_iter()\n+                            .filter_map(std::convert::identity)\n+                            .for_each(|(module_def_id, _)| {\n+                                if found_a_match {\n+                                    findings.push(module_def_id.into());\n+                                }\n+                                if let hir::ModuleDefId::ModuleId(module_id) = module_def_id {\n+                                    more_ids_to_process.push(module_id.local_id);\n+                                }\n+                            });\n+                    }\n+                }\n+                module_ids_to_process = more_ids_to_process;\n+            }\n+\n+            findings\n+        }\n+    }\n \n     pub(crate) fn check_assist(\n         assist: fn(AssistCtx<TestDB>) -> Option<Assist>,\n@@ -262,16 +310,19 @@ mod helpers {\n \n     pub(crate) fn check_assist_with_imports_locator<F: ImportsLocator>(\n         assist: fn(AssistCtx<TestDB>, &mut F) -> Option<Assist>,\n-        imports_locator: &mut F,\n+        imports_locator_provider: fn(db: Arc<TestDB>, file_id: FileId) -> F,\n         before: &str,\n         after: &str,\n     ) {\n         let (before_cursor_pos, before) = extract_offset(before);\n         let (db, file_id) = TestDB::with_single_file(&before);\n+        let db = Arc::new(db);\n+        let mut imports_locator = imports_locator_provider(Arc::clone(&db), file_id);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n-        let assist = AssistCtx::with_ctx(&db, frange, true, |ctx| assist(ctx, imports_locator))\n-            .expect(\"code action is not applicable\");\n+        let assist =\n+            AssistCtx::with_ctx(db.as_ref(), frange, true, |ctx| assist(ctx, &mut imports_locator))\n+                .expect(\"code action is not applicable\");\n         let action = match assist {\n             Assist::Unresolved { .. } => unreachable!(),\n             Assist::Resolved { assist } => assist.get_first_action(),\n@@ -364,14 +415,17 @@ mod helpers {\n \n     pub(crate) fn check_assist_with_imports_locator_not_applicable<F: ImportsLocator>(\n         assist: fn(AssistCtx<TestDB>, &mut F) -> Option<Assist>,\n-        imports_locator: &mut F,\n+        imports_locator_provider: fn(db: Arc<TestDB>, file_id: FileId) -> F,\n         before: &str,\n     ) {\n         let (before_cursor_pos, before) = extract_offset(before);\n         let (db, file_id) = TestDB::with_single_file(&before);\n+        let db = Arc::new(db);\n+        let mut imports_locator = imports_locator_provider(Arc::clone(&db), file_id);\n         let frange =\n             FileRange { file_id, range: TextRange::offset_len(before_cursor_pos, 0.into()) };\n-        let assist = AssistCtx::with_ctx(&db, frange, true, |ctx| assist(ctx, imports_locator));\n+        let assist =\n+            AssistCtx::with_ctx(db.as_ref(), frange, true, |ctx| assist(ctx, &mut imports_locator));\n         assert!(assist.is_none());\n     }\n "}, {"sha": "2cfeaba72f85a67288ab33c5c1bf83cc5a83f640", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a78991df69630b581b4210083c9e94157bab0e1/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a78991df69630b581b4210083c9e94157bab0e1/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=1a78991df69630b581b4210083c9e94157bab0e1", "patch": "@@ -56,6 +56,7 @@ pub use hir_def::{\n     nameres::ModuleSource,\n     path::{ModPath, Path, PathKind},\n     type_ref::Mutability,\n+    ModuleDefId,\n };\n pub use hir_expand::{\n     name::{AsName, Name},"}]}