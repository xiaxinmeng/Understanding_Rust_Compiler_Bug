{"sha": "4b42e919d640f7c714a7e87c91b4f3a9089552d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNDJlOTE5ZDY0MGY3YzcxNGE3ZTg3YzkxYjRmM2E5MDg5NTUyZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-12T02:31:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-12T02:31:03Z"}, "message": "Auto merge of #65020 - pnkfelix:targetted-fix-for-always-marking-rust-abi-unwind-issue-64655, r=alexcrichton\n\nAlways mark rust and rust-call abi's as unwind\n\nPR #63909 identified a bug that had been injected by PR #55982. As discussed on https://github.com/rust-lang/rust/issues/64655#issuecomment-537517428 , we started marking extern items as nounwind, *even* extern items that said they were using \"Rust\" or \"rust-call\" ABI.\n\nThis is a more targeted variant of PR #63909 that fixes the above bug.\n\nFix #64655\n\n----\n\nI personally suspect we will want PR #63909 to land in the long-term\n\nBut:\n *  it is not certain that PR #63909 *will* land,\n * more importantly, PR #63909 almost certainly will not be backported to beta/stable.\n\nThe identified bug was more severe than I think anyone realized (apart from perhaps @gnzlbg, as noted [here](https://github.com/rust-lang/rust/pull/63909#issuecomment-524818838)).\n\nThus, I was motivated to write this PR, which fixes *just* the issue with extern rust/rust-call functions, and deliberately avoids injecting further deviation from current behavior (you can see further notes on this in the comments of the code added here).", "tree": {"sha": "a4e7dc818358e548ca505d9c67fff6e85bd6c5b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4e7dc818358e548ca505d9c67fff6e85bd6c5b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b42e919d640f7c714a7e87c91b4f3a9089552d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b42e919d640f7c714a7e87c91b4f3a9089552d0", "html_url": "https://github.com/rust-lang/rust/commit/4b42e919d640f7c714a7e87c91b4f3a9089552d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b42e919d640f7c714a7e87c91b4f3a9089552d0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6767d9b90b6b630ad8e2a9e5e02fd74c00c98759", "url": "https://api.github.com/repos/rust-lang/rust/commits/6767d9b90b6b630ad8e2a9e5e02fd74c00c98759", "html_url": "https://github.com/rust-lang/rust/commit/6767d9b90b6b630ad8e2a9e5e02fd74c00c98759"}, {"sha": "028f53e38e5830897693ea3644c672a096cfa0ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/028f53e38e5830897693ea3644c672a096cfa0ec", "html_url": "https://github.com/rust-lang/rust/commit/028f53e38e5830897693ea3644c672a096cfa0ec"}], "stats": {"total": 200, "additions": 187, "deletions": 13}, "files": [{"sha": "22607476021144f8bcf2848da2a72f872bdba5a2", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4b42e919d640f7c714a7e87c91b4f3a9089552d0/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b42e919d640f7c714a7e87c91b4f3a9089552d0/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=4b42e919d640f7c714a7e87c91b4f3a9089552d0", "patch": "@@ -275,25 +275,51 @@ pub fn from_fn_attrs(\n     } else if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND) {\n         // Special attribute for allocator functions, which can't unwind\n         false\n-    } else if let Some(id) = id {\n+    } else if let Some(_) = id {\n+        // rust-lang/rust#64655, rust-lang/rust#63909: to minimize\n+        // risk associated with changing cases where nounwind\n+        // attribute is attached, this code is deliberately mimicking\n+        // old control flow based on whether `id` is `Some` or `None`.\n+        //\n+        // However, in the long term we should either:\n+        // - fold this into final else (i.e. stop inspecting `id`)\n+        // - or, adopt Rust PR #63909.\n+        //\n+        // see also Rust RFC 2753.\n+\n         let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n-        if cx.tcx.is_foreign_item(id) {\n-            // Foreign items like `extern \"C\" { fn foo(); }` are assumed not to\n-            // unwind\n-            false\n-        } else if sig.abi != Abi::Rust && sig.abi != Abi::RustCall {\n-            // Any items defined in Rust that *don't* have the `extern` ABI are\n-            // defined to not unwind. We insert shims to abort if an unwind\n-            // happens to enforce this.\n-            false\n-        } else {\n-            // Anything else defined in Rust is assumed that it can possibly\n-            // unwind\n+        if sig.abi == Abi::Rust || sig.abi == Abi::RustCall {\n+            // Any Rust method (or `extern \"Rust\" fn` or `extern\n+            // \"rust-call\" fn`) is explicitly allowed to unwind\n+            // (unless it has no-unwind attribute, handled above).\n             true\n+        } else {\n+            // Anything else is either:\n+            //\n+            //  1. A foreign item using a non-Rust ABI (like `extern \"C\" { fn foo(); }`), or\n+            //\n+            //  2. A Rust item using a non-Rust ABI (like `extern \"C\" fn foo() { ... }`).\n+            //\n+            // Foreign items (case 1) are assumed to not unwind; it is\n+            // UB otherwise. (At least for now; see also\n+            // rust-lang/rust#63909 and Rust RFC 2753.)\n+            //\n+            // Items defined in Rust with non-Rust ABIs (case 2) are also\n+            // not supposed to unwind. Whether this should be enforced\n+            // (versus stating it is UB) and *how* it would be enforced\n+            // is currently under discussion; see rust-lang/rust#58794.\n+            //\n+            // In either case, we mark item as explicitly nounwind.\n+            false\n         }\n     } else {\n         // assume this can possibly unwind, avoiding the application of a\n         // `nounwind` attribute below.\n+        //\n+        // (But: See comments in previous branch. Specifically, it is\n+        // unclear whether there is real value in the assumption this\n+        // can unwind. The conservatism here may just be papering over\n+        // a real problem by making some UB a bit harder to hit.)\n         true\n     });\n "}, {"sha": "ff10d412a110ae04fc317223bab432832920d354", "filename": "src/test/ui/extern/issue-64655-allow-unwind-when-calling-panic-directly.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/4b42e919d640f7c714a7e87c91b4f3a9089552d0/src%2Ftest%2Fui%2Fextern%2Fissue-64655-allow-unwind-when-calling-panic-directly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b42e919d640f7c714a7e87c91b4f3a9089552d0/src%2Ftest%2Fui%2Fextern%2Fissue-64655-allow-unwind-when-calling-panic-directly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fissue-64655-allow-unwind-when-calling-panic-directly.rs?ref=4b42e919d640f7c714a7e87c91b4f3a9089552d0", "patch": "@@ -0,0 +1,65 @@\n+// run-pass\n+// ignore-wasm32-bare compiled with panic=abort by default\n+// ignore-emscripten no threads support\n+\n+// rust-lang/rust#64655: with panic=unwind, a panic from a subroutine\n+// should still run destructors as it unwinds the stack. However,\n+// bugs with how the nounwind LLVM attribute was applied led to this\n+// simple case being mishandled *if* you had fat LTO turned on.\n+\n+// Unlike issue-64655-extern-rust-must-allow-unwind.rs, the issue\n+// embodied in this test cropped up regardless of optimization level.\n+// Therefore it seemed worthy of being enshrined as a dedicated unit\n+// test.\n+\n+// LTO settings cannot be combined with -C prefer-dynamic\n+// no-prefer-dynamic\n+\n+// The revisions just enumerate lto settings (the opt-level appeared irrelevant in practice)\n+\n+// revisions: no thin fat\n+//[no]compile-flags: -C lto=no\n+//[thin]compile-flags: -C lto=thin\n+//[fat]compile-flags: -C lto=fat\n+\n+#![feature(core_panic)]\n+\n+// (For some reason, reproducing the LTO issue requires pulling in std\n+// explicitly this way.)\n+#![no_std]\n+extern crate std;\n+\n+fn main() {\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n+    use std::boxed::Box;\n+\n+    static SHARED: AtomicUsize = AtomicUsize::new(0);\n+\n+    assert_eq!(SHARED.fetch_add(0, Ordering::SeqCst), 0);\n+\n+    let old_hook = std::panic::take_hook();\n+\n+    std::panic::set_hook(Box::new(|_| { } )); // no-op on panic.\n+\n+    let handle = std::thread::spawn(|| {\n+        struct Droppable;\n+        impl Drop for Droppable {\n+            fn drop(&mut self) {\n+                SHARED.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+\n+        let _guard = Droppable;\n+        let s = \"issue-64655-allow-unwind-when-calling-panic-directly.rs\";\n+        core::panicking::panic(&(\"???\", s, 17, 4));\n+    });\n+\n+    let wait = handle.join();\n+\n+    // Reinstate handler to ease observation of assertion failures.\n+    std::panic::set_hook(old_hook);\n+\n+    assert!(wait.is_err());\n+\n+    assert_eq!(SHARED.fetch_add(0, Ordering::SeqCst), 1);\n+}"}, {"sha": "bc15fcb0e399618a2e926517549264ad9d991449", "filename": "src/test/ui/extern/issue-64655-extern-rust-must-allow-unwind.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4b42e919d640f7c714a7e87c91b4f3a9089552d0/src%2Ftest%2Fui%2Fextern%2Fissue-64655-extern-rust-must-allow-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b42e919d640f7c714a7e87c91b4f3a9089552d0/src%2Ftest%2Fui%2Fextern%2Fissue-64655-extern-rust-must-allow-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fissue-64655-extern-rust-must-allow-unwind.rs?ref=4b42e919d640f7c714a7e87c91b4f3a9089552d0", "patch": "@@ -0,0 +1,83 @@\n+// run-pass\n+// ignore-wasm32-bare compiled with panic=abort by default\n+// ignore-emscripten no threads support\n+\n+// rust-lang/rust#64655: with panic=unwind, a panic from a subroutine\n+// should still run destructors as it unwinds the stack. However,\n+// bugs with how the nounwind LLVM attribute was applied led to this\n+// simple case being mishandled *if* you had optimization *and* fat\n+// LTO turned on.\n+\n+// This test is the closest thing to a \"regression test\" we can do\n+// without actually spawning subprocesses and comparing stderr\n+// results.\n+//\n+// This test takes the code from the above issue and adapts it to\n+// better fit our test infrastructure:\n+//\n+// * Instead of relying on `println!` to observe whether the destructor\n+//   is run, we instead run the code in a spawned thread and\n+//   communicate the destructor's operation via a synchronous atomic\n+//   in static memory.\n+//\n+// * To keep the output from confusing a casual user, we override the\n+//   panic hook to be a no-op (rather than printing a message to\n+//   stderr).\n+//\n+// (pnkfelix has confirmed by hand that these additions do not mask\n+// the underlying bug.)\n+\n+// LTO settings cannot be combined with -C prefer-dynamic\n+// no-prefer-dynamic\n+\n+// The revisions combine each lto setting with each optimization\n+// setting; pnkfelix observed three differing behaviors at opt-levels\n+// 0/1/2+3 for this test, so it seems prudent to be thorough.\n+\n+// revisions: no0 no1 no2 no3 thin0 thin1 thin2 thin3 fat0 fat1 fat2  fat3\n+\n+//[no0]compile-flags: -C opt-level=0 -C lto=no\n+//[no1]compile-flags: -C opt-level=1 -C lto=no\n+//[no2]compile-flags: -C opt-level=2 -C lto=no\n+//[no3]compile-flags: -C opt-level=3 -C lto=no\n+//[thin0]compile-flags: -C opt-level=0 -C lto=thin\n+//[thin1]compile-flags: -C opt-level=1 -C lto=thin\n+//[thin2]compile-flags: -C opt-level=2 -C lto=thin\n+//[thin3]compile-flags: -C opt-level=3 -C lto=thin\n+//[fat0]compile-flags: -C opt-level=0 -C lto=fat\n+//[fat1]compile-flags: -C opt-level=1 -C lto=fat\n+//[fat2]compile-flags: -C opt-level=2 -C lto=fat\n+//[fat3]compile-flags: -C opt-level=3 -C lto=fat\n+\n+fn main() {\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+    static SHARED: AtomicUsize = AtomicUsize::new(0);\n+\n+    assert_eq!(SHARED.fetch_add(0, Ordering::SeqCst), 0);\n+\n+    let old_hook = std::panic::take_hook();\n+\n+    std::panic::set_hook(Box::new(|_| { } )); // no-op on panic.\n+\n+    let handle = std::thread::spawn(|| {\n+        struct Droppable;\n+        impl Drop for Droppable {\n+            fn drop(&mut self) {\n+                SHARED.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+\n+        let _guard = Droppable;\n+        None::<()>.expect(\"???\");\n+    });\n+\n+    let wait = handle.join();\n+\n+    // reinstate handler to ease observation of assertion failures.\n+    std::panic::set_hook(old_hook);\n+\n+    assert!(wait.is_err());\n+\n+    assert_eq!(SHARED.fetch_add(0, Ordering::SeqCst), 1);\n+}"}]}