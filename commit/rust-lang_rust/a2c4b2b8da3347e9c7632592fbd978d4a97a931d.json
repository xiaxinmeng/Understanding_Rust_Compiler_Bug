{"sha": "a2c4b2b8da3347e9c7632592fbd978d4a97a931d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyYzRiMmI4ZGEzMzQ3ZTljNzYzMjU5MmZiZDk3OGQ0YTk3YTkzMWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-04T11:35:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-04T11:35:13Z"}, "message": "Auto merge of #4490 - mikerite:fix-4364, r=flip1995\n\nFix `too_many_lines` false positive\n\nchangelog: Fix `too_many_lines` false positive", "tree": {"sha": "ffdcb23d069441a187527f3cb86a230a44b8996b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffdcb23d069441a187527f3cb86a230a44b8996b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2c4b2b8da3347e9c7632592fbd978d4a97a931d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2c4b2b8da3347e9c7632592fbd978d4a97a931d", "html_url": "https://github.com/rust-lang/rust/commit/a2c4b2b8da3347e9c7632592fbd978d4a97a931d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2c4b2b8da3347e9c7632592fbd978d4a97a931d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8239b7616f90b577f7ca3cbbe26209d100aac2b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8239b7616f90b577f7ca3cbbe26209d100aac2b1", "html_url": "https://github.com/rust-lang/rust/commit/8239b7616f90b577f7ca3cbbe26209d100aac2b1"}, {"sha": "232dd43fe932db6db21e41007cd05dd490590fa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/232dd43fe932db6db21e41007cd05dd490590fa0", "html_url": "https://github.com/rust-lang/rust/commit/232dd43fe932db6db21e41007cd05dd490590fa0"}], "stats": {"total": 309, "additions": 167, "deletions": 142}, "files": [{"sha": "dfcab83faee8b9bc99cfb419c4ce82c71e7acbfd", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2c4b2b8da3347e9c7632592fbd978d4a97a931d/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c4b2b8da3347e9c7632592fbd978d4a97a931d/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=a2c4b2b8da3347e9c7632592fbd978d4a97a931d", "patch": "@@ -200,7 +200,7 @@ impl<'a, 'tcx> Functions {\n             Some(i) => i + 1,\n             None => 0,\n         };\n-        let end_brace_idx = match code_snippet.find('}') {\n+        let end_brace_idx = match code_snippet.rfind('}') {\n             Some(i) => i,\n             None => code_snippet.len(),\n         };"}, {"sha": "7b6b6cbc8f835f6d112a18ebc03503638554b50a", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 73, "deletions": 66, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/a2c4b2b8da3347e9c7632592fbd978d4a97a931d/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c4b2b8da3347e9c7632592fbd978d4a97a931d/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=a2c4b2b8da3347e9c7632592fbd978d4a97a931d", "patch": "@@ -151,75 +151,82 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ranges {\n             }\n         }\n \n-        // exclusive range plus one: `x..(y+1)`\n-        if_chain! {\n-            if let Some(higher::Range {\n-                start,\n-                end: Some(end),\n-                limits: RangeLimits::HalfOpen\n-            }) = higher::range(cx, expr);\n-            if let Some(y) = y_plus_one(end);\n-            then {\n-                let span = if expr.span.from_expansion() {\n-                    expr.span\n-                        .ctxt()\n-                        .outer_expn_data()\n-                        .call_site\n-                } else {\n-                    expr.span\n-                };\n-                span_lint_and_then(\n-                    cx,\n-                    RANGE_PLUS_ONE,\n-                    span,\n-                    \"an inclusive range would be more readable\",\n-                    |db| {\n-                        let start = start.map_or(String::new(), |x| Sugg::hir(cx, x, \"x\").to_string());\n-                        let end = Sugg::hir(cx, y, \"y\");\n-                        if let Some(is_wrapped) = &snippet_opt(cx, span) {\n-                            if is_wrapped.starts_with('(') && is_wrapped.ends_with(')') {\n-                                db.span_suggestion(\n-                                    span,\n-                                    \"use\",\n-                                    format!(\"({}..={})\", start, end),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            } else {\n-                                db.span_suggestion(\n-                                    span,\n-                                    \"use\",\n-                                    format!(\"{}..={}\", start, end),\n-                                    Applicability::MachineApplicable, // snippet\n-                                );\n-                            }\n+        check_exclusive_range_plus_one(cx, expr);\n+        check_inclusive_range_minus_one(cx, expr);\n+    }\n+}\n+\n+// exclusive range plus one: `x..(y+1)`\n+fn check_exclusive_range_plus_one(cx: &LateContext<'_, '_>, expr: &Expr) {\n+    if_chain! {\n+        if let Some(higher::Range {\n+            start,\n+            end: Some(end),\n+            limits: RangeLimits::HalfOpen\n+        }) = higher::range(cx, expr);\n+        if let Some(y) = y_plus_one(end);\n+        then {\n+            let span = if expr.span.from_expansion() {\n+                expr.span\n+                    .ctxt()\n+                    .outer_expn_data()\n+                    .call_site\n+            } else {\n+                expr.span\n+            };\n+            span_lint_and_then(\n+                cx,\n+                RANGE_PLUS_ONE,\n+                span,\n+                \"an inclusive range would be more readable\",\n+                |db| {\n+                    let start = start.map_or(String::new(), |x| Sugg::hir(cx, x, \"x\").to_string());\n+                    let end = Sugg::hir(cx, y, \"y\");\n+                    if let Some(is_wrapped) = &snippet_opt(cx, span) {\n+                        if is_wrapped.starts_with('(') && is_wrapped.ends_with(')') {\n+                            db.span_suggestion(\n+                                span,\n+                                \"use\",\n+                                format!(\"({}..={})\", start, end),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        } else {\n+                            db.span_suggestion(\n+                                span,\n+                                \"use\",\n+                                format!(\"{}..={}\", start, end),\n+                                Applicability::MachineApplicable, // snippet\n+                            );\n                         }\n-                    },\n-                );\n-            }\n+                    }\n+                },\n+            );\n         }\n+    }\n+}\n \n-        // inclusive range minus one: `x..=(y-1)`\n-        if_chain! {\n-            if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::range(cx, expr);\n-            if let Some(y) = y_minus_one(end);\n-            then {\n-                span_lint_and_then(\n-                    cx,\n-                    RANGE_MINUS_ONE,\n-                    expr.span,\n-                    \"an exclusive range would be more readable\",\n-                    |db| {\n-                        let start = start.map_or(String::new(), |x| Sugg::hir(cx, x, \"x\").to_string());\n-                        let end = Sugg::hir(cx, y, \"y\");\n-                        db.span_suggestion(\n-                            expr.span,\n-                            \"use\",\n-                            format!(\"{}..{}\", start, end),\n-                            Applicability::MachineApplicable, // snippet\n-                        );\n-                    },\n-                );\n-            }\n+// inclusive range minus one: `x..=(y-1)`\n+fn check_inclusive_range_minus_one(cx: &LateContext<'_, '_>, expr: &Expr) {\n+    if_chain! {\n+        if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::range(cx, expr);\n+        if let Some(y) = y_minus_one(end);\n+        then {\n+            span_lint_and_then(\n+                cx,\n+                RANGE_MINUS_ONE,\n+                expr.span,\n+                \"an exclusive range would be more readable\",\n+                |db| {\n+                    let start = start.map_or(String::new(), |x| Sugg::hir(cx, x, \"x\").to_string());\n+                    let end = Sugg::hir(cx, y, \"y\");\n+                    db.span_suggestion(\n+                        expr.span,\n+                        \"use\",\n+                        format!(\"{}..{}\", start, end),\n+                        Applicability::MachineApplicable, // snippet\n+                    );\n+                },\n+            );\n         }\n     }\n }"}, {"sha": "3c2111c55fb56e9bc9c05be6a8722bac07f7c4fd", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 88, "deletions": 74, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/a2c4b2b8da3347e9c7632592fbd978d4a97a931d/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c4b2b8da3347e9c7632592fbd978d4a97a931d/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=a2c4b2b8da3347e9c7632592fbd978d4a97a931d", "patch": "@@ -1159,83 +1159,97 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Casts {\n                 }\n             }\n             if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx.sess(), expr.span) {\n-                match (cast_from.is_integral(), cast_to.is_integral()) {\n-                    (true, false) => {\n-                        let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n-                        let to_nbits = if let ty::Float(FloatTy::F32) = cast_to.sty {\n-                            32\n-                        } else {\n-                            64\n-                        };\n-                        if is_isize_or_usize(cast_from) || from_nbits >= to_nbits {\n-                            span_precision_loss_lint(cx, expr, cast_from, to_nbits == 64);\n-                        }\n-                        if from_nbits < to_nbits {\n-                            span_lossless_lint(cx, expr, ex, cast_from, cast_to);\n-                        }\n-                    },\n-                    (false, true) => {\n-                        span_lint(\n-                            cx,\n-                            CAST_POSSIBLE_TRUNCATION,\n-                            expr.span,\n-                            &format!(\"casting {} to {} may truncate the value\", cast_from, cast_to),\n-                        );\n-                        if !cast_to.is_signed() {\n-                            span_lint(\n-                                cx,\n-                                CAST_SIGN_LOSS,\n-                                expr.span,\n-                                &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to),\n-                            );\n-                        }\n-                    },\n-                    (true, true) => {\n-                        check_loss_of_sign(cx, expr, ex, cast_from, cast_to);\n-                        check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n-                        check_lossless(cx, expr, ex, cast_from, cast_to);\n-                    },\n-                    (false, false) => {\n-                        if let (&ty::Float(FloatTy::F64), &ty::Float(FloatTy::F32)) = (&cast_from.sty, &cast_to.sty) {\n-                            span_lint(\n-                                cx,\n-                                CAST_POSSIBLE_TRUNCATION,\n-                                expr.span,\n-                                \"casting f64 to f32 may truncate the value\",\n-                            );\n-                        }\n-                        if let (&ty::Float(FloatTy::F32), &ty::Float(FloatTy::F64)) = (&cast_from.sty, &cast_to.sty) {\n-                            span_lossless_lint(cx, expr, ex, cast_from, cast_to);\n-                        }\n-                    },\n-                }\n+                lint_numeric_casts(cx, expr, ex, cast_from, cast_to);\n             }\n \n-            if_chain! {\n-                if let ty::RawPtr(from_ptr_ty) = &cast_from.sty;\n-                if let ty::RawPtr(to_ptr_ty) = &cast_to.sty;\n-                if let Ok(from_layout) = cx.layout_of(from_ptr_ty.ty);\n-                if let Ok(to_layout) = cx.layout_of(to_ptr_ty.ty);\n-                if from_layout.align.abi < to_layout.align.abi;\n-                // with c_void, we inherently need to trust the user\n-                if !is_c_void(cx, from_ptr_ty.ty);\n-                // when casting from a ZST, we don't know enough to properly lint\n-                if !from_layout.is_zst();\n-                then {\n-                    span_lint(\n-                        cx,\n-                        CAST_PTR_ALIGNMENT,\n-                        expr.span,\n-                        &format!(\n-                            \"casting from `{}` to a more-strictly-aligned pointer (`{}`) ({} < {} bytes)\",\n-                            cast_from,\n-                            cast_to,\n-                            from_layout.align.abi.bytes(),\n-                            to_layout.align.abi.bytes(),\n-                        ),\n-                    );\n-                }\n+            lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n+        }\n+    }\n+}\n+\n+fn lint_numeric_casts<'tcx>(\n+    cx: &LateContext<'_, 'tcx>,\n+    expr: &Expr,\n+    cast_expr: &Expr,\n+    cast_from: Ty<'tcx>,\n+    cast_to: Ty<'tcx>,\n+) {\n+    match (cast_from.is_integral(), cast_to.is_integral()) {\n+        (true, false) => {\n+            let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n+            let to_nbits = if let ty::Float(FloatTy::F32) = cast_to.sty {\n+                32\n+            } else {\n+                64\n+            };\n+            if is_isize_or_usize(cast_from) || from_nbits >= to_nbits {\n+                span_precision_loss_lint(cx, expr, cast_from, to_nbits == 64);\n             }\n+            if from_nbits < to_nbits {\n+                span_lossless_lint(cx, expr, cast_expr, cast_from, cast_to);\n+            }\n+        },\n+        (false, true) => {\n+            span_lint(\n+                cx,\n+                CAST_POSSIBLE_TRUNCATION,\n+                expr.span,\n+                &format!(\"casting {} to {} may truncate the value\", cast_from, cast_to),\n+            );\n+            if !cast_to.is_signed() {\n+                span_lint(\n+                    cx,\n+                    CAST_SIGN_LOSS,\n+                    expr.span,\n+                    &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to),\n+                );\n+            }\n+        },\n+        (true, true) => {\n+            check_loss_of_sign(cx, expr, cast_expr, cast_from, cast_to);\n+            check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n+            check_lossless(cx, expr, cast_expr, cast_from, cast_to);\n+        },\n+        (false, false) => {\n+            if let (&ty::Float(FloatTy::F64), &ty::Float(FloatTy::F32)) = (&cast_from.sty, &cast_to.sty) {\n+                span_lint(\n+                    cx,\n+                    CAST_POSSIBLE_TRUNCATION,\n+                    expr.span,\n+                    \"casting f64 to f32 may truncate the value\",\n+                );\n+            }\n+            if let (&ty::Float(FloatTy::F32), &ty::Float(FloatTy::F64)) = (&cast_from.sty, &cast_to.sty) {\n+                span_lossless_lint(cx, expr, cast_expr, cast_from, cast_to);\n+            }\n+        },\n+    }\n+}\n+\n+fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {\n+    if_chain! {\n+        if let ty::RawPtr(from_ptr_ty) = &cast_from.sty;\n+        if let ty::RawPtr(to_ptr_ty) = &cast_to.sty;\n+        if let Ok(from_layout) = cx.layout_of(from_ptr_ty.ty);\n+        if let Ok(to_layout) = cx.layout_of(to_ptr_ty.ty);\n+        if from_layout.align.abi < to_layout.align.abi;\n+        // with c_void, we inherently need to trust the user\n+        if !is_c_void(cx, from_ptr_ty.ty);\n+        // when casting from a ZST, we don't know enough to properly lint\n+        if !from_layout.is_zst();\n+        then {\n+            span_lint(\n+                cx,\n+                CAST_PTR_ALIGNMENT,\n+                expr.span,\n+                &format!(\n+                    \"casting from `{}` to a more-strictly-aligned pointer (`{}`) ({} < {} bytes)\",\n+                    cast_from,\n+                    cast_to,\n+                    from_layout.align.abi.bytes(),\n+                    to_layout.align.abi.bytes(),\n+                ),\n+            );\n         }\n     }\n }"}, {"sha": "ba0e56c9987a5fa68dec47ac6b05ab63c9e87e65", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2c4b2b8da3347e9c7632592fbd978d4a97a931d/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c4b2b8da3347e9c7632592fbd978d4a97a931d/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=a2c4b2b8da3347e9c7632592fbd978d4a97a931d", "patch": "@@ -144,6 +144,7 @@ fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n }\n \n #[allow(clippy::similar_names)]\n+#[allow(clippy::too_many_lines)]\n fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n@@ -396,6 +397,7 @@ fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item) {\n }\n \n #[allow(clippy::similar_names)]\n+#[allow(clippy::too_many_lines)]\n fn print_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);"}, {"sha": "7d72a21ac0360cdb22f826d2b0aa2c71418b23a5", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2c4b2b8da3347e9c7632592fbd978d4a97a931d/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c4b2b8da3347e9c7632592fbd978d4a97a931d/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=a2c4b2b8da3347e9c7632592fbd978d4a97a931d", "patch": "@@ -320,6 +320,7 @@ impl FmtStr {\n /// ```rust,ignore\n /// (Some(\"string to write: {}\"), Some(buf))\n /// ```\n+#[allow(clippy::too_many_lines)]\n fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (Option<FmtStr>, Option<Expr>) {\n     use fmt_macros::*;\n     let tts = tts.clone();"}, {"sha": "5e1ee55e01040d2386906c5be85f53729483e808", "filename": "tests/ui/functions_maxlines.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2c4b2b8da3347e9c7632592fbd978d4a97a931d/tests%2Fui%2Ffunctions_maxlines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c4b2b8da3347e9c7632592fbd978d4a97a931d/tests%2Fui%2Ffunctions_maxlines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffunctions_maxlines.rs?ref=a2c4b2b8da3347e9c7632592fbd978d4a97a931d", "patch": "@@ -56,6 +56,7 @@ fn good_lines() {\n }\n \n fn bad_lines() {\n+    println!(\"Dont get confused by braces: {{}}\");\n     println!(\"This is bad.\");\n     println!(\"This is bad.\");\n     println!(\"This is bad.\");"}, {"sha": "9b0e7550cc314b774f400ffc095ef77921800430", "filename": "tests/ui/functions_maxlines.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2c4b2b8da3347e9c7632592fbd978d4a97a931d/tests%2Fui%2Ffunctions_maxlines.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2c4b2b8da3347e9c7632592fbd978d4a97a931d/tests%2Fui%2Ffunctions_maxlines.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffunctions_maxlines.stderr?ref=a2c4b2b8da3347e9c7632592fbd978d4a97a931d", "patch": "@@ -2,7 +2,7 @@ error: This function has a large number of lines.\n   --> $DIR/functions_maxlines.rs:58:1\n    |\n LL | / fn bad_lines() {\n-LL | |     println!(\"This is bad.\");\n+LL | |     println!(\"Dont get confused by braces: {{}}\");\n LL | |     println!(\"This is bad.\");\n LL | |     println!(\"This is bad.\");\n ...  |"}]}