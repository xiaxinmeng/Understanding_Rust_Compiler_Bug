{"sha": "adb895a34f6d0b925b8ef877289ca6e3c4d854d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYjg5NWEzNGY2ZDBiOTI1YjhlZjg3NzI4OWNhNmUzYzRkODU0ZDQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-22T06:15:04Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-15T19:21:56Z"}, "message": "Allow more \"error\" values in try_recv()\n\nThis should allow callers to know whether the channel was empty or disconnected\nwithout having to block.\n\nCloses #11087", "tree": {"sha": "fc5a2b0a6930d08c9b96e4ef24bdf5ff31adc3ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc5a2b0a6930d08c9b96e4ef24bdf5ff31adc3ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adb895a34f6d0b925b8ef877289ca6e3c4d854d4", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adb895a34f6d0b925b8ef877289ca6e3c4d854d4", "html_url": "https://github.com/rust-lang/rust/commit/adb895a34f6d0b925b8ef877289ca6e3c4d854d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adb895a34f6d0b925b8ef877289ca6e3c4d854d4/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "900893112570eea5a01c0573ae1fa1e3a72397e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/900893112570eea5a01c0573ae1fa1e3a72397e9", "html_url": "https://github.com/rust-lang/rust/commit/900893112570eea5a01c0573ae1fa1e3a72397e9"}], "stats": {"total": 149, "additions": 114, "deletions": 35}, "files": [{"sha": "bd1a46ae9bfd38dd40bf5f13e0938319e9ef4ec0", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/adb895a34f6d0b925b8ef877289ca6e3c4d854d4/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb895a34f6d0b925b8ef877289ca6e3c4d854d4/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=adb895a34f6d0b925b8ef877289ca6e3c4d854d4", "patch": "@@ -16,6 +16,8 @@ Higher level communication abstractions.\n \n #[allow(missing_doc)];\n \n+use std::comm;\n+\n /// An extension of `pipes::stream` that allows both sending and receiving.\n pub struct DuplexStream<T, U> {\n     priv chan: Chan<T>,\n@@ -40,7 +42,7 @@ impl<T:Send,U:Send> DuplexStream<T, U> {\n     pub fn recv(&self) -> U {\n         self.port.recv()\n     }\n-    pub fn try_recv(&self) -> Option<U> {\n+    pub fn try_recv(&self) -> comm::TryRecvResult<U> {\n         self.port.try_recv()\n     }\n     pub fn recv_opt(&self) -> Option<U> {\n@@ -77,11 +79,11 @@ impl<T: Send> SyncPort<T> {\n         })\n     }\n \n-    pub fn try_recv(&self) -> Option<T> {\n-        self.duplex_stream.try_recv().map(|val| {\n-            self.duplex_stream.try_send(());\n-            val\n-        })\n+    pub fn try_recv(&self) -> comm::TryRecvResult<T> {\n+        match self.duplex_stream.try_recv() {\n+            comm::Data(t) => { self.duplex_stream.try_send(()); comm::Data(t) }\n+            state => state,\n+        }\n     }\n }\n "}, {"sha": "044e5e9e5098937c203a317433e309d82e28c797", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/adb895a34f6d0b925b8ef877289ca6e3c4d854d4/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb895a34f6d0b925b8ef877289ca6e3c4d854d4/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=adb895a34f6d0b925b8ef877289ca6e3c4d854d4", "patch": "@@ -19,6 +19,7 @@\n \n \n use std::borrow;\n+use std::comm;\n use std::unstable::sync::Exclusive;\n use std::sync::arc::UnsafeArc;\n use std::sync::atomics;\n@@ -49,7 +50,7 @@ impl WaitQueue {\n     // Signals one live task from the queue.\n     fn signal(&self) -> bool {\n         match self.head.try_recv() {\n-            Some(ch) => {\n+            comm::Data(ch) => {\n                 // Send a wakeup signal. If the waiter was killed, its port will\n                 // have closed. Keep trying until we get a live task.\n                 if ch.try_send_deferred(()) {\n@@ -58,20 +59,20 @@ impl WaitQueue {\n                     self.signal()\n                 }\n             }\n-            None => false\n+            _ => false\n         }\n     }\n \n     fn broadcast(&self) -> uint {\n         let mut count = 0;\n         loop {\n             match self.head.try_recv() {\n-                None => break,\n-                Some(ch) => {\n+                comm::Data(ch) => {\n                     if ch.try_send_deferred(()) {\n                         count += 1;\n                     }\n                 }\n+                _ => break\n             }\n         }\n         count"}, {"sha": "1ae4d07af18ec9d5ba4782301834f8220906298c", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adb895a34f6d0b925b8ef877289ca6e3c4d854d4/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb895a34f6d0b925b8ef877289ca6e3c4d854d4/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=adb895a34f6d0b925b8ef877289ca6e3c4d854d4", "patch": "@@ -958,6 +958,7 @@ fn new_sched_rng() -> XorShiftRng {\n \n #[cfg(test)]\n mod test {\n+    use std::comm;\n     use std::task::TaskOpts;\n     use std::rt::Runtime;\n     use std::rt::task::Task;\n@@ -1376,7 +1377,7 @@ mod test {\n             // This task should not be able to starve the sender;\n             // The sender should get stolen to another thread.\n             do spawn {\n-                while port.try_recv().is_none() { }\n+                while port.try_recv() != comm::Data(()) { }\n             }\n \n             chan.send(());\n@@ -1393,7 +1394,7 @@ mod test {\n             // This task should not be able to starve the other task.\n             // The sends should eventually yield.\n             do spawn {\n-                while port.try_recv().is_none() {\n+                while port.try_recv() != comm::Data(()) {\n                     chan2.send(());\n                 }\n             }"}, {"sha": "bf9e28f3e97faba96e39397cfe752d7586c877d8", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 88, "deletions": 16, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/adb895a34f6d0b925b8ef877289ca6e3c4d854d4/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb895a34f6d0b925b8ef877289ca6e3c4d854d4/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=adb895a34f6d0b925b8ef877289ca6e3c4d854d4", "patch": "@@ -251,6 +251,7 @@ macro_rules! test (\n             #[allow(unused_imports)];\n \n             use native;\n+            use comm::*;\n             use prelude::*;\n             use super::*;\n             use super::super::*;\n@@ -323,6 +324,20 @@ pub struct SharedChan<T> {\n     priv queue: mpsc::Producer<T, Packet>,\n }\n \n+/// This enumeration is the list of the possible reasons that try_recv could not\n+/// return data when called.\n+#[deriving(Eq, Clone)]\n+pub enum TryRecvResult<T> {\n+    /// This channel is currently empty, but the sender(s) have not yet\n+    /// disconnected, so data may yet become available.\n+    Empty,\n+    /// This channel's sending half has become disconnected, and there will\n+    /// never be any more data received on this channel\n+    Disconnected,\n+    /// The channel had some data and we successfully popped it\n+    Data(T),\n+}\n+\n ///////////////////////////////////////////////////////////////////////////////\n // Internal struct definitions\n ///////////////////////////////////////////////////////////////////////////////\n@@ -739,11 +754,11 @@ impl<T: Send> Port<T> {\n     /// block on a port.\n     ///\n     /// This function cannot fail.\n-    pub fn try_recv(&self) -> Option<T> {\n+    pub fn try_recv(&self) -> TryRecvResult<T> {\n         self.try_recv_inc(true)\n     }\n \n-    fn try_recv_inc(&self, increment: bool) -> Option<T> {\n+    fn try_recv_inc(&self, increment: bool) -> TryRecvResult<T> {\n         // This is a \"best effort\" situation, so if a queue is inconsistent just\n         // don't worry about it.\n         let this = unsafe { cast::transmute_mut(self) };\n@@ -807,7 +822,35 @@ impl<T: Send> Port<T> {\n         if increment && ret.is_some() {\n             unsafe { (*this.queue.packet()).steals += 1; }\n         }\n-        return ret;\n+        match ret {\n+            Some(t) => Data(t),\n+            None => {\n+                // It's possible that between the time that we saw the queue was\n+                // empty and here the other side disconnected. It's also\n+                // possible for us to see the disconnection here while there is\n+                // data in the queue. It's pretty backwards-thinking to return\n+                // Disconnected when there's actually data on the queue, so if\n+                // we see a disconnected state be sure to check again to be 100%\n+                // sure that there's no data in the queue.\n+                let cnt = unsafe { (*this.queue.packet()).cnt.load(Relaxed) };\n+                if cnt != DISCONNECTED { return Empty }\n+\n+                let ret = match this.queue {\n+                    SPSC(ref mut queue) => queue.pop(),\n+                    MPSC(ref mut queue) => match queue.pop() {\n+                        mpsc::Data(t) => Some(t),\n+                        mpsc::Empty => None,\n+                        mpsc::Inconsistent => {\n+                            fail!(\"inconsistent with no senders?!\");\n+                        }\n+                    }\n+                };\n+                match ret {\n+                    Some(data) => Data(data),\n+                    None => Disconnected,\n+                }\n+            }\n+        }\n     }\n \n     /// Attempt to wait for a value on this port, but does not fail if the\n@@ -824,7 +867,11 @@ impl<T: Send> Port<T> {\n     /// the value found on the port is returned.\n     pub fn recv_opt(&self) -> Option<T> {\n         // optimistic preflight check (scheduling is expensive)\n-        match self.try_recv() { None => {}, data => return data }\n+        match self.try_recv() {\n+            Empty => {},\n+            Disconnected => return None,\n+            Data(t) => return Some(t),\n+        }\n \n         let packet;\n         let this;\n@@ -843,12 +890,11 @@ impl<T: Send> Port<T> {\n             });\n         }\n \n-        let data = self.try_recv_inc(false);\n-        if data.is_none() &&\n-           unsafe { (*packet).cnt.load(SeqCst) } != DISCONNECTED {\n-            fail!(\"bug: woke up too soon {}\", unsafe { (*packet).cnt.load(SeqCst) });\n+        match self.try_recv_inc(false) {\n+            Data(t) => Some(t),\n+            Empty => fail!(\"bug: woke up too soon\"),\n+            Disconnected => None,\n         }\n-        return data;\n     }\n \n     /// Returns an iterator which will block waiting for messages, but never\n@@ -1005,7 +1051,10 @@ mod test {\n             for _ in range(0, AMT * NTHREADS) {\n                 assert_eq!(p.recv(), 1);\n             }\n-            assert_eq!(p.try_recv(), None);\n+            match p.try_recv() {\n+                Data(..) => fail!(),\n+                _ => {}\n+            }\n             c1.send(());\n         }\n \n@@ -1129,7 +1178,7 @@ mod test {\n     test!(fn oneshot_single_thread_try_recv_open() {\n         let (port, chan) = Chan::<int>::new();\n         chan.send(10);\n-        assert!(port.try_recv() == Some(10));\n+        assert!(port.recv_opt() == Some(10));\n     })\n \n     test!(fn oneshot_single_thread_try_recv_closed() {\n@@ -1140,21 +1189,21 @@ mod test {\n \n     test!(fn oneshot_single_thread_peek_data() {\n         let (port, chan) = Chan::<int>::new();\n-        assert!(port.try_recv().is_none());\n+        assert_eq!(port.try_recv(), Empty)\n         chan.send(10);\n-        assert!(port.try_recv().is_some());\n+        assert_eq!(port.try_recv(), Data(10));\n     })\n \n     test!(fn oneshot_single_thread_peek_close() {\n         let (port, chan) = Chan::<int>::new();\n         { let _c = chan; }\n-        assert!(port.try_recv().is_none());\n-        assert!(port.try_recv().is_none());\n+        assert_eq!(port.try_recv(), Disconnected);\n+        assert_eq!(port.try_recv(), Disconnected);\n     })\n \n     test!(fn oneshot_single_thread_peek_open() {\n         let (port, _) = Chan::<int>::new();\n-        assert!(port.try_recv().is_none());\n+        assert_eq!(port.try_recv(), Empty);\n     })\n \n     test!(fn oneshot_multi_task_recv_then_send() {\n@@ -1321,4 +1370,27 @@ mod test {\n         drop(chan);\n         assert_eq!(count_port.recv(), 4);\n     })\n+\n+    test!(fn try_recv_states() {\n+        let (p, c) = Chan::<int>::new();\n+        let (p1, c1) = Chan::<()>::new();\n+        let (p2, c2) = Chan::<()>::new();\n+        do spawn {\n+            p1.recv();\n+            c.send(1);\n+            c2.send(());\n+            p1.recv();\n+            drop(c);\n+            c2.send(());\n+        }\n+\n+        assert_eq!(p.try_recv(), Empty);\n+        c1.send(());\n+        p2.recv();\n+        assert_eq!(p.try_recv(), Data(1));\n+        assert_eq!(p.try_recv(), Empty);\n+        c1.send(());\n+        p2.recv();\n+        assert_eq!(p.try_recv(), Disconnected);\n+    })\n }"}, {"sha": "fa5ec1d3e309fc328b1e5146e3e679d9fd60ebc2", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/adb895a34f6d0b925b8ef877289ca6e3c4d854d4/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb895a34f6d0b925b8ef877289ca6e3c4d854d4/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=adb895a34f6d0b925b8ef877289ca6e3c4d854d4", "patch": "@@ -45,6 +45,7 @@\n #[allow(dead_code)];\n \n use cast;\n+use comm;\n use iter::Iterator;\n use kinds::Send;\n use ops::Drop;\n@@ -279,7 +280,9 @@ impl<'port, T: Send> Handle<'port, T> {\n     pub fn recv_opt(&mut self) -> Option<T> { self.port.recv_opt() }\n     /// Immediately attempt to receive a value on a port, this function will\n     /// never block. Has the same semantics as `Port.try_recv`.\n-    pub fn try_recv(&mut self) -> Option<T> { self.port.try_recv() }\n+    pub fn try_recv(&mut self) -> comm::TryRecvResult<T> {\n+        self.port.try_recv()\n+    }\n }\n \n #[unsafe_destructor]\n@@ -409,8 +412,8 @@ mod test {\n             a = p1.recv() => { assert_eq!(a, 1); },\n             a = p2.recv() => { assert_eq!(a, 2); }\n         )\n-        assert_eq!(p1.try_recv(), None);\n-        assert_eq!(p2.try_recv(), None);\n+        assert_eq!(p1.try_recv(), Empty);\n+        assert_eq!(p2.try_recv(), Empty);\n         c3.send(());\n     })\n "}, {"sha": "0f05254b034896dc99a9efda17064e09ffa1b73a", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/adb895a34f6d0b925b8ef877289ca6e3c4d854d4/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb895a34f6d0b925b8ef877289ca6e3c4d854d4/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=adb895a34f6d0b925b8ef877289ca6e3c4d854d4", "patch": "@@ -144,6 +144,7 @@ impl Listener {\n #[cfg(test)]\n mod test {\n     use libc;\n+    use comm::Empty;\n     use io::timer;\n     use super::{Listener, Interrupt};\n \n@@ -194,7 +195,7 @@ mod test {\n         s2.unregister(Interrupt);\n         sigint();\n         timer::sleep(10);\n-        assert!(s2.port.try_recv().is_none());\n+        assert_eq!(s2.port.try_recv(), Empty);\n     }\n \n     #[cfg(windows)]"}, {"sha": "d156a7460e17c30fabff087211c9b92f7d8bd408", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adb895a34f6d0b925b8ef877289ca6e3c4d854d4/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb895a34f6d0b925b8ef877289ca6e3c4d854d4/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=adb895a34f6d0b925b8ef877289ca6e3c4d854d4", "patch": "@@ -123,16 +123,15 @@ mod test {\n         let port1 = timer.oneshot(10000);\n         let port = timer.oneshot(1);\n         port.recv();\n-        assert_eq!(port1.try_recv(), None);\n+        assert!(port1.recv_opt().is_none());\n     }\n \n     #[test]\n     fn test_io_timer_oneshot_then_sleep() {\n         let mut timer = Timer::new().unwrap();\n         let port = timer.oneshot(100000000000);\n         timer.sleep(1); // this should invalidate the port\n-\n-        assert_eq!(port.try_recv(), None);\n+        assert!(port.recv_opt().is_none());\n     }\n \n     #[test]"}]}