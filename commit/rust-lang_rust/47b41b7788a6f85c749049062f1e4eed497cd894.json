{"sha": "47b41b7788a6f85c749049062f1e4eed497cd894", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3YjQxYjc3ODhhNmY4NWM3NDkwNDkwNjJmMWU0ZWVkNDk3Y2Q4OTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-11T01:36:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-11T01:36:23Z"}, "message": "Auto merge of #87254 - rusticstuff:rustc_codegen_llvm_dont_emit_zero_sized_padding, r=eddyb\n\nLLVM codegen: Don't emit zero-sized padding for fields\n\nCurrently padding is emitted before fields of a struct and at the end of the struct regardless of the ABI. Even if no padding is required zero-sized padding fields are emitted. This is not useful and - more importantly - it make it impossible to generate the exact vector types that LLVM expects for certain ARM SIMD intrinsics. This change should unblock the implementation of many ARM intrinsics using the `unadjusted` ABI, see https://github.com/rust-lang/stdarch/issues/1143#issuecomment-827404092.\n\nThis is a proof of concept only because the field lookup now takes O(number of fields) time compared to O(1) before since it recalculates the mapping at every lookup. I would like to find out how big the performance impact actually is before implementing caching or restricting this behavior to the `unadjusted` ABI.\n\ncc `@SparrowLii` `@bjorn3`\n\n([Discussion on internals](https://internals.rust-lang.org/t/feature-request-add-a-way-in-rustc-for-generating-struct-type-llvm-ir-without-paddings/15007))", "tree": {"sha": "f68a519116440d8e4194981cdbacdaab12f9abf1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f68a519116440d8e4194981cdbacdaab12f9abf1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47b41b7788a6f85c749049062f1e4eed497cd894", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47b41b7788a6f85c749049062f1e4eed497cd894", "html_url": "https://github.com/rust-lang/rust/commit/47b41b7788a6f85c749049062f1e4eed497cd894", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47b41b7788a6f85c749049062f1e4eed497cd894/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8e1b32a7840c07f30c04b252c379a044a73902d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8e1b32a7840c07f30c04b252c379a044a73902d", "html_url": "https://github.com/rust-lang/rust/commit/e8e1b32a7840c07f30c04b252c379a044a73902d"}, {"sha": "02295f464aaf78ece81a80e5b99a034119e74748", "url": "https://api.github.com/repos/rust-lang/rust/commits/02295f464aaf78ece81a80e5b99a034119e74748", "html_url": "https://github.com/rust-lang/rust/commit/02295f464aaf78ece81a80e5b99a034119e74748"}], "stats": {"total": 148, "additions": 107, "deletions": 41}, "files": [{"sha": "5d56c93f835d60308cd4aa606577a18b8dd44fc2", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/47b41b7788a6f85c749049062f1e4eed497cd894/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b41b7788a6f85c749049062f1e4eed497cd894/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=47b41b7788a6f85c749049062f1e4eed497cd894", "patch": "@@ -24,6 +24,7 @@ use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_span::symbol::Symbol;\n use rustc_target::abi::{HasDataLayout, LayoutOf, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n use rustc_target::spec::{HasTargetSpec, RelocModel, Target, TlsModel};\n+use smallvec::SmallVec;\n \n use std::cell::{Cell, RefCell};\n use std::ffi::CStr;\n@@ -74,8 +75,12 @@ pub struct CodegenCx<'ll, 'tcx> {\n     /// See <https://llvm.org/docs/LangRef.html#the-llvm-used-global-variable> for details\n     pub used_statics: RefCell<Vec<&'ll Value>>,\n \n-    pub lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<VariantIdx>), &'ll Type>>,\n+    /// Mapping of non-scalar types to llvm types and field remapping if needed.\n+    pub type_lowering: RefCell<FxHashMap<(Ty<'tcx>, Option<VariantIdx>), TypeLowering<'ll>>>,\n+\n+    /// Mapping of scalar types to llvm types.\n     pub scalar_lltypes: RefCell<FxHashMap<Ty<'tcx>, &'ll Type>>,\n+\n     pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n     pub isize_ty: &'ll Type,\n \n@@ -92,6 +97,15 @@ pub struct CodegenCx<'ll, 'tcx> {\n     local_gen_sym_counter: Cell<usize>,\n }\n \n+pub struct TypeLowering<'ll> {\n+    /// Associated LLVM type\n+    pub lltype: &'ll Type,\n+\n+    /// If padding is used the slice maps fields from source order\n+    /// to llvm order.\n+    pub field_remapping: Option<SmallVec<[u32; 4]>>,\n+}\n+\n fn to_llvm_tls_model(tls_model: TlsModel) -> llvm::ThreadLocalMode {\n     match tls_model {\n         TlsModel::GeneralDynamic => llvm::ThreadLocalMode::GeneralDynamic,\n@@ -304,7 +318,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n             const_globals: Default::default(),\n             statics_to_rauw: RefCell::new(Vec::new()),\n             used_statics: RefCell::new(Vec::new()),\n-            lltypes: Default::default(),\n+            type_lowering: Default::default(),\n             scalar_lltypes: Default::default(),\n             pointee_infos: Default::default(),\n             isize_ty,"}, {"sha": "c7f4287e28e4ae29479c8045ce369d055c1a2ee7", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b41b7788a6f85c749049062f1e4eed497cd894/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b41b7788a6f85c749049062f1e4eed497cd894/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=47b41b7788a6f85c749049062f1e4eed497cd894", "patch": "@@ -266,7 +266,7 @@ impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         layout.is_llvm_scalar_pair()\n     }\n     fn backend_field_index(&self, layout: TyAndLayout<'tcx>, index: usize) -> u64 {\n-        layout.llvm_field_index(index)\n+        layout.llvm_field_index(self, index)\n     }\n     fn scalar_pair_element_backend_type(\n         &self,"}, {"sha": "85efe3e64836c76c5df392129d6095f1f8b45c7f", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 62, "deletions": 27, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/47b41b7788a6f85c749049062f1e4eed497cd894/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b41b7788a6f85c749049062f1e4eed497cd894/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=47b41b7788a6f85c749049062f1e4eed497cd894", "patch": "@@ -1,5 +1,6 @@\n use crate::abi::FnAbi;\n use crate::common::*;\n+use crate::context::TypeLowering;\n use crate::type_::Type;\n use rustc_codegen_ssa::traits::*;\n use rustc_middle::bug;\n@@ -9,6 +10,7 @@ use rustc_middle::ty::{self, Ty, TypeFoldable};\n use rustc_target::abi::{Abi, AddressSpace, Align, FieldsShape};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n use rustc_target::abi::{LayoutOf, PointeeInfo, Scalar, Size, TyAndLayoutMethods, Variants};\n+use smallvec::{smallvec, SmallVec};\n use tracing::debug;\n \n use std::fmt::Write;\n@@ -17,6 +19,7 @@ fn uncached_llvm_type<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     defer: &mut Option<(&'a Type, TyAndLayout<'tcx>)>,\n+    field_remapping: &mut Option<SmallVec<[u32; 4]>>,\n ) -> &'a Type {\n     match layout.abi {\n         Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n@@ -75,7 +78,8 @@ fn uncached_llvm_type<'a, 'tcx>(\n         FieldsShape::Array { count, .. } => cx.type_array(layout.field(cx, 0).llvm_type(cx), count),\n         FieldsShape::Arbitrary { .. } => match name {\n             None => {\n-                let (llfields, packed) = struct_llfields(cx, layout);\n+                let (llfields, packed, new_field_remapping) = struct_llfields(cx, layout);\n+                *field_remapping = new_field_remapping;\n                 cx.type_struct(&llfields, packed)\n             }\n             Some(ref name) => {\n@@ -90,14 +94,15 @@ fn uncached_llvm_type<'a, 'tcx>(\n fn struct_llfields<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n-) -> (Vec<&'a Type>, bool) {\n+) -> (Vec<&'a Type>, bool, Option<SmallVec<[u32; 4]>>) {\n     debug!(\"struct_llfields: {:#?}\", layout);\n     let field_count = layout.fields.count();\n \n     let mut packed = false;\n     let mut offset = Size::ZERO;\n     let mut prev_effective_align = layout.align.abi;\n     let mut result: Vec<_> = Vec::with_capacity(1 + field_count * 2);\n+    let mut field_remapping = smallvec![0; field_count];\n     for i in layout.fields.index_by_increasing_offset() {\n         let target_offset = layout.fields.offset(i as usize);\n         let field = layout.field(cx, i);\n@@ -116,33 +121,37 @@ fn struct_llfields<'a, 'tcx>(\n         );\n         assert!(target_offset >= offset);\n         let padding = target_offset - offset;\n-        let padding_align = prev_effective_align.min(effective_field_align);\n-        assert_eq!(offset.align_to(padding_align) + padding, target_offset);\n-        result.push(cx.type_padding_filler(padding, padding_align));\n-        debug!(\"    padding before: {:?}\", padding);\n-\n+        if padding != Size::ZERO {\n+            let padding_align = prev_effective_align.min(effective_field_align);\n+            assert_eq!(offset.align_to(padding_align) + padding, target_offset);\n+            result.push(cx.type_padding_filler(padding, padding_align));\n+            debug!(\"    padding before: {:?}\", padding);\n+        }\n+        field_remapping[i] = result.len() as u32;\n         result.push(field.llvm_type(cx));\n         offset = target_offset + field.size;\n         prev_effective_align = effective_field_align;\n     }\n+    let padding_used = result.len() > field_count;\n     if !layout.is_unsized() && field_count > 0 {\n         if offset > layout.size {\n             bug!(\"layout: {:#?} stride: {:?} offset: {:?}\", layout, layout.size, offset);\n         }\n         let padding = layout.size - offset;\n-        let padding_align = prev_effective_align;\n-        assert_eq!(offset.align_to(padding_align) + padding, layout.size);\n-        debug!(\n-            \"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n-            padding, offset, layout.size\n-        );\n-        result.push(cx.type_padding_filler(padding, padding_align));\n-        assert_eq!(result.len(), 1 + field_count * 2);\n+        if padding != Size::ZERO {\n+            let padding_align = prev_effective_align;\n+            assert_eq!(offset.align_to(padding_align) + padding, layout.size);\n+            debug!(\n+                \"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n+                padding, offset, layout.size\n+            );\n+            result.push(cx.type_padding_filler(padding, padding_align));\n+        }\n     } else {\n         debug!(\"struct_llfields: offset: {:?} stride: {:?}\", offset, layout.size);\n     }\n-\n-    (result, packed)\n+    let field_remapping = if padding_used { Some(field_remapping) } else { None };\n+    (result, packed, field_remapping)\n }\n \n impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n@@ -177,7 +186,7 @@ pub trait LayoutLlvmExt<'tcx> {\n         index: usize,\n         immediate: bool,\n     ) -> &'a Type;\n-    fn llvm_field_index(&self, index: usize) -> u64;\n+    fn llvm_field_index<'a>(&self, cx: &CodegenCx<'a, 'tcx>, index: usize) -> u64;\n     fn pointee_info_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>, offset: Size) -> Option<PointeeInfo>;\n }\n \n@@ -234,8 +243,8 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n             Variants::Single { index } => Some(index),\n             _ => None,\n         };\n-        if let Some(&llty) = cx.lltypes.borrow().get(&(self.ty, variant_index)) {\n-            return llty;\n+        if let Some(ref llty) = cx.type_lowering.borrow().get(&(self.ty, variant_index)) {\n+            return llty.lltype;\n         }\n \n         debug!(\"llvm_type({:#?})\", self);\n@@ -247,24 +256,32 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n         let normal_ty = cx.tcx.erase_regions(self.ty);\n \n         let mut defer = None;\n+        let mut field_remapping = None;\n         let llty = if self.ty != normal_ty {\n             let mut layout = cx.layout_of(normal_ty);\n             if let Some(v) = variant_index {\n                 layout = layout.for_variant(cx, v);\n             }\n             layout.llvm_type(cx)\n         } else {\n-            uncached_llvm_type(cx, *self, &mut defer)\n+            uncached_llvm_type(cx, *self, &mut defer, &mut field_remapping)\n         };\n         debug!(\"--> mapped {:#?} to llty={:?}\", self, llty);\n \n-        cx.lltypes.borrow_mut().insert((self.ty, variant_index), llty);\n+        cx.type_lowering.borrow_mut().insert(\n+            (self.ty, variant_index),\n+            TypeLowering { lltype: llty, field_remapping: field_remapping },\n+        );\n \n         if let Some((llty, layout)) = defer {\n-            let (llfields, packed) = struct_llfields(cx, layout);\n-            cx.set_struct_body(llty, &llfields, packed)\n+            let (llfields, packed, new_field_remapping) = struct_llfields(cx, layout);\n+            cx.set_struct_body(llty, &llfields, packed);\n+            cx.type_lowering\n+                .borrow_mut()\n+                .get_mut(&(self.ty, variant_index))\n+                .unwrap()\n+                .field_remapping = new_field_remapping;\n         }\n-\n         llty\n     }\n \n@@ -340,7 +357,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n         self.scalar_llvm_type_at(cx, scalar, offset)\n     }\n \n-    fn llvm_field_index(&self, index: usize) -> u64 {\n+    fn llvm_field_index<'a>(&self, cx: &CodegenCx<'a, 'tcx>, index: usize) -> u64 {\n         match self.abi {\n             Abi::Scalar(_) | Abi::ScalarPair(..) => {\n                 bug!(\"TyAndLayout::llvm_field_index({:?}): not applicable\", self)\n@@ -354,7 +371,25 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n \n             FieldsShape::Array { .. } => index as u64,\n \n-            FieldsShape::Arbitrary { .. } => 1 + (self.fields.memory_index(index) as u64) * 2,\n+            FieldsShape::Arbitrary { .. } => {\n+                let variant_index = match self.variants {\n+                    Variants::Single { index } => Some(index),\n+                    _ => None,\n+                };\n+\n+                // Look up llvm field if indexes do not match memory order due to padding. If\n+                // `field_remapping` is `None` no padding was used and the llvm field index\n+                // matches the memory index.\n+                match cx.type_lowering.borrow().get(&(self.ty, variant_index)) {\n+                    Some(TypeLowering { field_remapping: Some(ref remap), .. }) => {\n+                        remap[index] as u64\n+                    }\n+                    Some(_) => self.fields.memory_index(index) as u64,\n+                    None => {\n+                        bug!(\"TyAndLayout::llvm_field_index({:?}): type info not found\", self)\n+                    }\n+                }\n+            }\n         }\n     }\n "}, {"sha": "2208ec37a423551539391ea47ba4ab10e883e2d2", "filename": "compiler/rustc_codegen_llvm/src/va_arg.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/47b41b7788a6f85c749049062f1e4eed497cd894/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b41b7788a6f85c749049062f1e4eed497cd894/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs?ref=47b41b7788a6f85c749049062f1e4eed497cd894", "patch": "@@ -98,7 +98,8 @@ fn emit_aapcs_va_arg(\n     // Implementation of the AAPCS64 calling convention for va_args see\n     // https://github.com/ARM-software/abi-aa/blob/master/aapcs64/aapcs64.rst\n     let va_list_addr = list.immediate();\n-    let va_list_ty = list.deref(bx.cx).layout.llvm_type(bx);\n+    let va_list_layout = list.deref(bx.cx).layout;\n+    let va_list_ty = va_list_layout.llvm_type(bx);\n     let layout = bx.cx.layout_of(target_ty);\n \n     let mut maybe_reg = bx.build_sibling_block(\"va_arg.maybe_reg\");\n@@ -110,13 +111,15 @@ fn emit_aapcs_va_arg(\n \n     let gr_type = target_ty.is_any_ptr() || target_ty.is_integral();\n     let (reg_off, reg_top_index, slot_size) = if gr_type {\n-        let gr_offs = bx.struct_gep(va_list_ty, va_list_addr, 7);\n+        let gr_offs =\n+            bx.struct_gep(va_list_ty, va_list_addr, va_list_layout.llvm_field_index(bx.cx, 3));\n         let nreg = (layout.size.bytes() + 7) / 8;\n-        (gr_offs, 3, nreg * 8)\n+        (gr_offs, va_list_layout.llvm_field_index(bx.cx, 1), nreg * 8)\n     } else {\n-        let vr_off = bx.struct_gep(va_list_ty, va_list_addr, 9);\n+        let vr_off =\n+            bx.struct_gep(va_list_ty, va_list_addr, va_list_layout.llvm_field_index(bx.cx, 4));\n         let nreg = (layout.size.bytes() + 15) / 16;\n-        (vr_off, 5, nreg * 16)\n+        (vr_off, va_list_layout.llvm_field_index(bx.cx, 2), nreg * 16)\n     };\n \n     // if the offset >= 0 then the value will be on the stack"}, {"sha": "441cd04690e7011df1beed33398e7c115a7b927f", "filename": "src/test/codegen/align-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b41b7788a6f85c749049062f1e4eed497cd894/src%2Ftest%2Fcodegen%2Falign-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b41b7788a6f85c749049062f1e4eed497cd894/src%2Ftest%2Fcodegen%2Falign-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Falign-enum.rs?ref=47b41b7788a6f85c749049062f1e4eed497cd894", "patch": "@@ -8,7 +8,7 @@ pub enum Align64 {\n     A(u32),\n     B(u32),\n }\n-// CHECK: %Align64 = type { [0 x i32], i32, [15 x i32] }\n+// CHECK: %Align64 = type { i32, [15 x i32] }\n \n pub struct Nested64 {\n     a: u8,"}, {"sha": "acc5a2d5499ffb7158ce5691f43578cacf71e01c", "filename": "src/test/codegen/align-struct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47b41b7788a6f85c749049062f1e4eed497cd894/src%2Ftest%2Fcodegen%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b41b7788a6f85c749049062f1e4eed497cd894/src%2Ftest%2Fcodegen%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Falign-struct.rs?ref=47b41b7788a6f85c749049062f1e4eed497cd894", "patch": "@@ -5,28 +5,28 @@\n \n #[repr(align(64))]\n pub struct Align64(i32);\n-// CHECK: %Align64 = type { [0 x i32], i32, [15 x i32] }\n+// CHECK: %Align64 = type { i32, [15 x i32] }\n \n pub struct Nested64 {\n     a: Align64,\n     b: i32,\n     c: i32,\n     d: i8,\n }\n-// CHECK: %Nested64 = type { [0 x i64], %Align64, [0 x i32], i32, [0 x i32], i32, [0 x i8], i8, [55 x i8] }\n+// CHECK: %Nested64 = type { %Align64, i32, i32, i8, [55 x i8] }\n \n pub enum Enum4 {\n     A(i32),\n     B(i32),\n }\n-// CHECK: %\"Enum4::A\" = type { [1 x i32], i32, [0 x i32] }\n+// CHECK: %\"Enum4::A\" = type { [1 x i32], i32 }\n \n pub enum Enum64 {\n     A(Align64),\n     B(i32),\n }\n-// CHECK: %Enum64 = type { [0 x i32], i32, [31 x i32] }\n-// CHECK: %\"Enum64::A\" = type { [8 x i64], %Align64, [0 x i64] }\n+// CHECK: %Enum64 = type { i32, [31 x i32] }\n+// CHECK: %\"Enum64::A\" = type { [8 x i64], %Align64 }\n \n // CHECK-LABEL: @align64\n #[no_mangle]"}, {"sha": "eb44dbd931352bfa8a1c6ae10dbeed6de4e042a8", "filename": "src/test/codegen/unpadded-simd.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/47b41b7788a6f85c749049062f1e4eed497cd894/src%2Ftest%2Fcodegen%2Funpadded-simd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b41b7788a6f85c749049062f1e4eed497cd894/src%2Ftest%2Fcodegen%2Funpadded-simd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funpadded-simd.rs?ref=47b41b7788a6f85c749049062f1e4eed497cd894", "patch": "@@ -0,0 +1,14 @@\n+// Make sure that no 0-sized padding is inserted in structs and that\n+// structs are represented as expected by Neon intrinsics in LLVM.\n+// See #87254.\n+\n+#![crate_type = \"lib\"]\n+#![feature(repr_simd)]\n+\n+#[derive(Copy, Clone, Debug)]\n+#[repr(simd)]\n+pub struct int16x4_t(pub i16, pub i16, pub i16, pub i16);\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct int16x4x2_t(pub int16x4_t, pub int16x4_t);\n+// CHECK: %int16x4x2_t = type { <4 x i16>, <4 x i16> }"}]}