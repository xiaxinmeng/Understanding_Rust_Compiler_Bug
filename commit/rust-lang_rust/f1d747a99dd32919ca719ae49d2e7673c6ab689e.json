{"sha": "f1d747a99dd32919ca719ae49d2e7673c6ab689e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxZDc0N2E5OWRkMzI5MTljYTcxOWFlNDlkMmU3NjczYzZhYjY4OWU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-25T11:12:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-25T11:12:48Z"}, "message": "Rollup merge of #65685 - oxalica:statx-eperm, r=alexcrichton\n\nFix check of `statx` and handle EPERM\n\nShould fix #65662\n\nhttps://github.com/rust-lang/rust/issues/65662#issuecomment-544593939\n> I think a reasonable solution might be to do something like try to stat AT_CWD initially and if that fails with EPERM or ENOSYS we disable the syscall entirely, otherwise it's cached as always good to use.\n\nr? @alexcrichton", "tree": {"sha": "4be405bef3d3d0b5c0c012e8cb2901f08f48af3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4be405bef3d3d0b5c0c012e8cb2901f08f48af3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1d747a99dd32919ca719ae49d2e7673c6ab689e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdstiwCRBK7hj4Ov3rIwAAdHIIAHvop5VByIpFc3FoeHzgLJUF\nS65hyb2Ri0p86S5u49+AVo/hSvpgZHyg6mBIaZvI9sI8TY+aShBfXhhILGH4jyCM\n2YOG86aHxuibk+/SWnHxXL7MIg4H/TeSVzPyoL93d7+VfeGGha9ljsaZuKK5l8Dm\ncoJnQs/eWRaKv+aiojoOOO0mzKo2IoeJLE0Lb497bx5P7uJzk1xm7JplcdpnDBKv\n1/wroqS8ehYwW6ZL5xaP1bbZEhAMi/DCCYQ5ZBtRnBEdlPO9mCsmnM4whImRfBTL\nSiqTHG9wtEPYuYuTeQnm5lJXbLkkMO8NhAsu7jJMTjmICbdFT6XUhYrBHADFtk4=\n=4KJQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 4be405bef3d3d0b5c0c012e8cb2901f08f48af3c\nparent 8bb039fb83f7f18df5e1d71607981c8d4902b7b3\nparent 10f1bc77b3c404ebc1d386fc14453b6b32cf02bb\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1572001968 +0200\ncommitter GitHub <noreply@github.com> 1572001968 +0200\n\nRollup merge of #65685 - oxalica:statx-eperm, r=alexcrichton\n\nFix check of `statx` and handle EPERM\n\nShould fix #65662\n\nhttps://github.com/rust-lang/rust/issues/65662#issuecomment-544593939\n> I think a reasonable solution might be to do something like try to stat AT_CWD initially and if that fails with EPERM or ENOSYS we disable the syscall entirely, otherwise it's cached as always good to use.\n\nr? @alexcrichton\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1d747a99dd32919ca719ae49d2e7673c6ab689e", "html_url": "https://github.com/rust-lang/rust/commit/f1d747a99dd32919ca719ae49d2e7673c6ab689e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1d747a99dd32919ca719ae49d2e7673c6ab689e/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "html_url": "https://github.com/rust-lang/rust/commit/8bb039fb83f7f18df5e1d71607981c8d4902b7b3"}, {"sha": "10f1bc77b3c404ebc1d386fc14453b6b32cf02bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/10f1bc77b3c404ebc1d386fc14453b6b32cf02bb", "html_url": "https://github.com/rust-lang/rust/commit/10f1bc77b3c404ebc1d386fc14453b6b32cf02bb"}], "stats": {"total": 97, "additions": 55, "deletions": 42}, "files": [{"sha": "5e1f10c03ceda583b9145dee6101376d14f6cbfa", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 55, "deletions": 42, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f1d747a99dd32919ca719ae49d2e7673c6ab689e/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d747a99dd32919ca719ae49d2e7673c6ab689e/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=f1d747a99dd32919ca719ae49d2e7673c6ab689e", "patch": "@@ -105,11 +105,14 @@ cfg_has_statx! {{\n         flags: i32,\n         mask: u32,\n     ) -> Option<io::Result<FileAttr>> {\n-        use crate::sync::atomic::{AtomicBool, Ordering};\n+        use crate::sync::atomic::{AtomicU8, Ordering};\n \n         // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`\n-        // We store the availability in a global to avoid unnecessary syscalls\n-        static HAS_STATX: AtomicBool = AtomicBool::new(true);\n+        // We store the availability in global to avoid unnecessary syscalls.\n+        // 0: Unknown\n+        // 1: Not available\n+        // 2: Available\n+        static STATX_STATE: AtomicU8 = AtomicU8::new(0);\n         syscall! {\n             fn statx(\n                 fd: c_int,\n@@ -120,50 +123,60 @@ cfg_has_statx! {{\n             ) -> c_int\n         }\n \n-        if !HAS_STATX.load(Ordering::Relaxed) {\n-            return None;\n-        }\n-\n-        let mut buf: libc::statx = mem::zeroed();\n-        let ret = cvt(statx(fd, path, flags, mask, &mut buf));\n-        match ret {\n-            Err(err) => match err.raw_os_error() {\n-                Some(libc::ENOSYS) => {\n-                    HAS_STATX.store(false, Ordering::Relaxed);\n+        match STATX_STATE.load(Ordering::Relaxed) {\n+            0 => {\n+                // It is a trick to call `statx` with NULL pointers to check if the syscall\n+                // is available. According to the manual, it is expected to fail with EFAULT.\n+                // We do this mainly for performance, since it is nearly hundreds times\n+                // faster than a normal successfull call.\n+                let err = cvt(statx(0, ptr::null(), 0, libc::STATX_ALL, ptr::null_mut()))\n+                    .err()\n+                    .and_then(|e| e.raw_os_error());\n+                // We don't check `err == Some(libc::ENOSYS)` because the syscall may be limited\n+                // and returns `EPERM`. Listing all possible errors seems not a good idea.\n+                // See: https://github.com/rust-lang/rust/issues/65662\n+                if err != Some(libc::EFAULT) {\n+                    STATX_STATE.store(1, Ordering::Relaxed);\n                     return None;\n                 }\n-                _ => return Some(Err(err)),\n+                STATX_STATE.store(2, Ordering::Relaxed);\n             }\n-            Ok(_) => {\n-                // We cannot fill `stat64` exhaustively because of private padding fields.\n-                let mut stat: stat64 = mem::zeroed();\n-                // `c_ulong` on gnu-mips, `dev_t` otherwise\n-                stat.st_dev = libc::makedev(buf.stx_dev_major, buf.stx_dev_minor) as _;\n-                stat.st_ino = buf.stx_ino as libc::ino64_t;\n-                stat.st_nlink = buf.stx_nlink as libc::nlink_t;\n-                stat.st_mode = buf.stx_mode as libc::mode_t;\n-                stat.st_uid = buf.stx_uid as libc::uid_t;\n-                stat.st_gid = buf.stx_gid as libc::gid_t;\n-                stat.st_rdev = libc::makedev(buf.stx_rdev_major, buf.stx_rdev_minor) as _;\n-                stat.st_size = buf.stx_size as off64_t;\n-                stat.st_blksize = buf.stx_blksize as libc::blksize_t;\n-                stat.st_blocks = buf.stx_blocks as libc::blkcnt64_t;\n-                stat.st_atime = buf.stx_atime.tv_sec as libc::time_t;\n-                // `i64` on gnu-x86_64-x32, `c_ulong` otherwise.\n-                stat.st_atime_nsec = buf.stx_atime.tv_nsec as _;\n-                stat.st_mtime = buf.stx_mtime.tv_sec as libc::time_t;\n-                stat.st_mtime_nsec = buf.stx_mtime.tv_nsec as _;\n-                stat.st_ctime = buf.stx_ctime.tv_sec as libc::time_t;\n-                stat.st_ctime_nsec = buf.stx_ctime.tv_nsec as _;\n-\n-                let extra = StatxExtraFields {\n-                    stx_mask: buf.stx_mask,\n-                    stx_btime: buf.stx_btime,\n-                };\n+            1 => return None,\n+            _ => {}\n+        }\n \n-                Some(Ok(FileAttr { stat, statx_extra_fields: Some(extra) }))\n-            }\n+        let mut buf: libc::statx = mem::zeroed();\n+        if let Err(err) = cvt(statx(fd, path, flags, mask, &mut buf)) {\n+            return Some(Err(err));\n         }\n+\n+        // We cannot fill `stat64` exhaustively because of private padding fields.\n+        let mut stat: stat64 = mem::zeroed();\n+        // `c_ulong` on gnu-mips, `dev_t` otherwise\n+        stat.st_dev = libc::makedev(buf.stx_dev_major, buf.stx_dev_minor) as _;\n+        stat.st_ino = buf.stx_ino as libc::ino64_t;\n+        stat.st_nlink = buf.stx_nlink as libc::nlink_t;\n+        stat.st_mode = buf.stx_mode as libc::mode_t;\n+        stat.st_uid = buf.stx_uid as libc::uid_t;\n+        stat.st_gid = buf.stx_gid as libc::gid_t;\n+        stat.st_rdev = libc::makedev(buf.stx_rdev_major, buf.stx_rdev_minor) as _;\n+        stat.st_size = buf.stx_size as off64_t;\n+        stat.st_blksize = buf.stx_blksize as libc::blksize_t;\n+        stat.st_blocks = buf.stx_blocks as libc::blkcnt64_t;\n+        stat.st_atime = buf.stx_atime.tv_sec as libc::time_t;\n+        // `i64` on gnu-x86_64-x32, `c_ulong` otherwise.\n+        stat.st_atime_nsec = buf.stx_atime.tv_nsec as _;\n+        stat.st_mtime = buf.stx_mtime.tv_sec as libc::time_t;\n+        stat.st_mtime_nsec = buf.stx_mtime.tv_nsec as _;\n+        stat.st_ctime = buf.stx_ctime.tv_sec as libc::time_t;\n+        stat.st_ctime_nsec = buf.stx_ctime.tv_nsec as _;\n+\n+        let extra = StatxExtraFields {\n+            stx_mask: buf.stx_mask,\n+            stx_btime: buf.stx_btime,\n+        };\n+\n+        Some(Ok(FileAttr { stat, statx_extra_fields: Some(extra) }))\n     }\n \n } else {"}]}