{"sha": "0f3848471d83574e9b439a06def657ba35ff569f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMzg0ODQ3MWQ4MzU3NGU5YjQzOWEwNmRlZjY1N2JhMzVmZjU2OWY=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-07-25T21:03:56Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-07-25T21:03:56Z"}, "message": "Merge pull request #142 from cassiersg/rewrite-imports\n\nMove 'use' to Rewrite", "tree": {"sha": "d258a4871d88868cf3328281f0867772782c7bdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d258a4871d88868cf3328281f0867772782c7bdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f3848471d83574e9b439a06def657ba35ff569f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f3848471d83574e9b439a06def657ba35ff569f", "html_url": "https://github.com/rust-lang/rust/commit/0f3848471d83574e9b439a06def657ba35ff569f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f3848471d83574e9b439a06def657ba35ff569f/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8461e8a0a8b1dd825f30de9d5bc4f5c1d8d57dbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8461e8a0a8b1dd825f30de9d5bc4f5c1d8d57dbd", "html_url": "https://github.com/rust-lang/rust/commit/8461e8a0a8b1dd825f30de9d5bc4f5c1d8d57dbd"}, {"sha": "92b3f69934efb61433223fc10888746e0c705afe", "url": "https://api.github.com/repos/rust-lang/rust/commits/92b3f69934efb61433223fc10888746e0c705afe", "html_url": "https://github.com/rust-lang/rust/commit/92b3f69934efb61433223fc10888746e0c705afe"}], "stats": {"total": 295, "additions": 155, "deletions": 140}, "files": [{"sha": "81cc204908141f5c2f9727b8816cf1606b8390f5", "filename": "src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f3848471d83574e9b439a06def657ba35ff569f/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f3848471d83574e9b439a06def657ba35ff569f/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=0f3848471d83574e9b439a06def657ba35ff569f", "patch": "@@ -608,7 +608,7 @@ fn rewrite_binary_op(context: &RewriteContext,\n     result.push_str(&operator_str);\n \n     // 1 = space between operator and rhs\n-    let used_width = result.len() + operator_str.len() + 1;\n+    let used_width = result.len() + 1;\n     let remaining_width = match result.rfind('\\n') {\n         Some(idx) => (offset + width + idx).checked_sub(used_width).unwrap_or(0),\n         None => width.checked_sub(used_width).unwrap_or(0)"}, {"sha": "37b1d9e5d46e5078ee37b443679e39c7e2f24388", "filename": "src/imports.rs", "status": "modified", "additions": 112, "deletions": 93, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/0f3848471d83574e9b439a06def657ba35ff569f/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f3848471d83574e9b439a06def657ba35ff569f/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=0f3848471d83574e9b439a06def657ba35ff569f", "patch": "@@ -8,126 +8,145 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use visitor::FmtVisitor;\n use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n-use utils::{span_after, format_visibility};\n+use utils::span_after;\n+use rewrite::{Rewrite, RewriteContext};\n+use config::Config;\n \n use syntax::ast;\n use syntax::parse::token;\n use syntax::print::pprust;\n-use syntax::codemap::Span;\n+use syntax::codemap::{CodeMap, Span};\n \n // TODO (some day) remove unused imports, expand globs, compress many single imports into a list import\n \n-fn rewrite_single_use_list(path_str: String, vpi: ast::PathListItem, vis: &str) -> String {\n+impl Rewrite for ast::ViewPath {\n+    // Returns an empty string when the ViewPath is empty (like foo::bar::{})\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+        match self.node {\n+            ast::ViewPath_::ViewPathList(ref path, ref path_list) => {\n+                Some(rewrite_use_list(width,\n+                                      offset,\n+                                      path,\n+                                      path_list,\n+                                      self.span,\n+                                      context.codemap,\n+                                      context.config).unwrap_or(\"\".to_owned()))\n+            }\n+            ast::ViewPath_::ViewPathGlob(_) => {\n+                // FIXME convert to list?\n+                None\n+            }\n+            ast::ViewPath_::ViewPathSimple(_,_) => {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+fn rewrite_single_use_list(path_str: String, vpi: ast::PathListItem) -> String {\n     if let ast::PathListItem_::PathListIdent{ name, .. } = vpi.node {\n         let name_str = token::get_ident(name).to_string();\n         if path_str.len() == 0 {\n-            format!(\"{}use {};\", vis, name_str)\n+            name_str\n         } else {\n-            format!(\"{}use {}::{};\", vis, path_str, name_str)\n+            format!(\"{}::{}\", path_str, name_str)\n         }\n     } else {\n         if path_str.len() != 0 {\n-            format!(\"{}use {};\", vis, path_str)\n+            path_str\n         } else {\n             // This catches the import: use {self}, which is a compiler error, so we just\n             // leave it alone.\n-            format!(\"{}use {{self}};\", vis)\n+            \"{self}\".to_owned()\n         }\n     }\n }\n \n-impl<'a> FmtVisitor<'a> {\n-    // Basically just pretty prints a multi-item import.\n-    // Returns None when the import can be removed.\n-    pub fn rewrite_use_list(&self,\n-                            block_indent: usize,\n-                            one_line_budget: usize, // excluding indentation\n-                            multi_line_budget: usize,\n-                            path: &ast::Path,\n-                            path_list: &[ast::PathListItem],\n-                            visibility: ast::Visibility,\n-                            span: Span)\n-                            -> Option<String> {\n-        let path_str = pprust::path_to_string(path);\n-        let vis = format_visibility(visibility);\n-\n-        match path_list.len() {\n-            0 => return None,\n-            1 => return Some(rewrite_single_use_list(path_str, path_list[0], vis)),\n-            _ => ()\n-        }\n-\n-        // 2 = ::\n-        let path_separation_w = if path_str.len() > 0 {\n-            2\n-        } else {\n-            0\n-        };\n-        // 5 = \"use \" + {\n-        let indent = path_str.len() + 5 + path_separation_w + vis.len();\n-\n-        // 2 = } + ;\n-        let used_width = indent + 2;\n+// Basically just pretty prints a multi-item import.\n+// Returns None when the import can be removed.\n+pub fn rewrite_use_list(width: usize,\n+                        offset: usize,\n+                        path: &ast::Path,\n+                        path_list: &[ast::PathListItem],\n+                        span: Span,\n+                        codemap: &CodeMap,\n+                        config: &Config)\n+                        -> Option<String> {\n+    let path_str = pprust::path_to_string(path);\n+\n+    match path_list.len() {\n+        0 => return None,\n+        1 => return Some(rewrite_single_use_list(path_str, path_list[0])),\n+        _ => ()\n+    }\n \n-        // Break as early as possible when we've blown our budget.\n-        let remaining_line_budget = one_line_budget.checked_sub(used_width).unwrap_or(0);\n-        let remaining_multi_budget = multi_line_budget.checked_sub(used_width).unwrap_or(0);\n+    // 2 = ::\n+    let path_separation_w = if path_str.len() > 0 {\n+        2\n+    } else {\n+        0\n+    };\n+    // 1 = {\n+    let supp_indent = path_str.len() + path_separation_w + 1;\n+    // 1 = }\n+    let remaining_width = width.checked_sub(supp_indent + 1).unwrap_or(0);\n+\n+    let fmt = ListFormatting {\n+        tactic: ListTactic::Mixed,\n+        separator: \",\",\n+        trailing_separator: SeparatorTactic::Never,\n+        indent: offset + supp_indent,\n+        h_width: remaining_width,\n+        // FIXME This is too conservative, and will not use all width\n+        // available\n+        // (loose 1 column (\";\"))\n+        v_width: remaining_width,\n+        ends_with_newline: true,\n+    };\n+\n+    let mut items = itemize_list(codemap,\n+                                 vec![ListItem::from_str(\"\")], /* Dummy value, explanation\n+                                                                * below */\n+                                 path_list.iter(),\n+                                 \",\",\n+                                 \"}\",\n+                                 |vpi| vpi.span.lo,\n+                                 |vpi| vpi.span.hi,\n+                                 |vpi| match vpi.node {\n+                                     ast::PathListItem_::PathListIdent{ name, .. } => {\n+                                         token::get_ident(name).to_string()\n+                                     }\n+                                     ast::PathListItem_::PathListMod{ .. } => {\n+                                         \"self\".to_owned()\n+                                     }\n+                                 },\n+                                 span_after(span, \"{\", codemap),\n+                                 span.hi);\n+\n+    // We prefixed the item list with a dummy value so that we can\n+    // potentially move \"self\" to the front of the vector without touching\n+    // the rest of the items.\n+    // FIXME: Make more efficient by using a linked list? That would\n+    // require changes to the signatures of itemize_list and write_list.\n+    let has_self = move_self_to_front(&mut items);\n+    let first_index = if has_self {\n+        0\n+    } else {\n+        1\n+    };\n \n-        let fmt = ListFormatting {\n-            tactic: ListTactic::Mixed,\n-            separator: \",\",\n-            trailing_separator: SeparatorTactic::Never,\n-            indent: block_indent + indent,\n-            h_width: remaining_line_budget,\n-            v_width: remaining_multi_budget,\n-            ends_with_newline: true,\n-        };\n+    if config.reorder_imports {\n+        items[1..].sort_by(|a, b| a.item.cmp(&b.item));\n+    }\n \n-        let mut items = itemize_list(self.codemap,\n-                                     vec![ListItem::from_str(\"\")], /* Dummy value, explanation\n-                                                                    * below */\n-                                     path_list.iter(),\n-                                     \",\",\n-                                     \"}\",\n-                                     |vpi| vpi.span.lo,\n-                                     |vpi| vpi.span.hi,\n-                                     |vpi| match vpi.node {\n-                                         ast::PathListItem_::PathListIdent{ name, .. } => {\n-                                             token::get_ident(name).to_string()\n-                                         }\n-                                         ast::PathListItem_::PathListMod{ .. } => {\n-                                             \"self\".to_owned()\n-                                         }\n-                                     },\n-                                     span_after(span, \"{\", self.codemap),\n-                                     span.hi);\n+    let list = write_list(&items[first_index..], &fmt);\n \n-        // We prefixed the item list with a dummy value so that we can\n-        // potentially move \"self\" to the front of the vector without touching\n-        // the rest of the items.\n-        // FIXME: Make more efficient by using a linked list? That would\n-        // require changes to the signatures of itemize_list and write_list.\n-        let has_self = move_self_to_front(&mut items);\n-        let first_index = if has_self {\n-            0\n+    Some(if path_str.len() == 0 {\n+            format!(\"{{{}}}\", list)\n         } else {\n-            1\n-        };\n-\n-        if self.config.reorder_imports {\n-            items[1..].sort_by(|a, b| a.item.cmp(&b.item));\n-        }\n-\n-        let list = write_list(&items[first_index..], &fmt);\n-\n-        Some(if path_str.len() == 0 {\n-                format!(\"{}use {{{}}};\", vis, list)\n-            } else {\n-                format!(\"{}use {}::{{{}}};\", vis, path_str, list)\n-            })\n-    }\n+            format!(\"{}::{{{}}}\", path_str, list)\n+        })\n }\n \n // Returns true when self item was found."}, {"sha": "6e550c2f3301ef1733e5a373769dec0d8b3d1e7f", "filename": "src/visitor.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0f3848471d83574e9b439a06def657ba35ff569f/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f3848471d83574e9b439a06def657ba35ff569f/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=0f3848471d83574e9b439a06def657ba35ff569f", "patch": "@@ -164,43 +164,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n \n         match item.node {\n             ast::Item_::ItemUse(ref vp) => {\n-                match vp.node {\n-                    ast::ViewPath_::ViewPathList(ref path, ref path_list) => {\n-                        let block_indent = self.block_indent;\n-                        let one_line_budget = self.config.max_width - block_indent;\n-                        let multi_line_budget = self.config.ideal_width - block_indent;\n-                        let formatted = self.rewrite_use_list(block_indent,\n-                                                              one_line_budget,\n-                                                              multi_line_budget,\n-                                                              path,\n-                                                              path_list,\n-                                                              item.vis,\n-                                                              item.span);\n-\n-                        if let Some(new_str) = formatted {\n-                            self.format_missing_with_indent(item.span.lo);\n-                            self.changes.push_str_span(item.span, &new_str);\n-                        } else {\n-                            // Format up to last newline\n-                            let span = codemap::mk_sp(self.last_pos, item.span.lo);\n-                            let span_end = match self.snippet(span).rfind('\\n') {\n-                                Some(offset) => self.last_pos + BytePos(offset as u32),\n-                                None => item.span.lo\n-                            };\n-                            self.format_missing(span_end);\n-                        }\n-\n-                        self.last_pos = item.span.hi;\n-                    }\n-                    ast::ViewPath_::ViewPathGlob(_) => {\n-                        self.format_missing_with_indent(item.span.lo);\n-                        // FIXME convert to list?\n-                    }\n-                    ast::ViewPath_::ViewPathSimple(_,_) => {\n-                        self.format_missing_with_indent(item.span.lo);\n-                    }\n-                }\n-                visit::walk_item(self, item);\n+                self.format_import(item.vis, vp, item.span);\n             }\n             ast::Item_::ItemImpl(..) |\n             ast::Item_::ItemTrait(..) => {\n@@ -221,7 +185,6 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                                   def,\n                                   generics,\n                                   item.span);\n-                self.last_pos = item.span.hi;\n             }\n             ast::Item_::ItemEnum(ref def, ref generics) => {\n                 self.format_missing_with_indent(item.span.lo);\n@@ -418,4 +381,37 @@ impl<'a> FmtVisitor<'a> {\n         self.last_pos = last_pos;\n         self.block_indent = block_indent;\n     }\n+\n+    fn format_import(&mut self, vis: ast::Visibility, vp: &ast::ViewPath, span: Span) {\n+        let vis = utils::format_visibility(vis);\n+        let offset = self.block_indent + vis.len() + \"use \".len();\n+        let context = RewriteContext {\n+            codemap: self.codemap,\n+            config: self.config,\n+            block_indent: self.block_indent,\n+        };\n+        // 1 = \";\"\n+        match vp.rewrite(&context, self.config.max_width - offset - 1, offset) {\n+            Some(ref s) if s.len() == 0 => {\n+                // Format up to last newline\n+                let prev_span = codemap::mk_sp(self.last_pos, span.lo);\n+                let span_end = match self.snippet(prev_span).rfind('\\n') {\n+                    Some(offset) => self.last_pos + BytePos(offset as u32),\n+                    None => span.lo\n+                };\n+                self.format_missing(span_end);\n+                self.last_pos = span.hi;\n+            }\n+            Some(ref s) => {\n+                let s = format!(\"{}use {};\", vis, s);\n+                self.format_missing_with_indent(span.lo);\n+                self.changes.push_str_span(span, &s);\n+                self.last_pos = span.hi;\n+            }\n+            None => {\n+                self.format_missing_with_indent(span.lo);\n+                self.format_missing(span.hi);\n+            }\n+        }\n+    }\n }"}, {"sha": "9a69d68987f12eed2ccb359ab28a4c07c2d7581c", "filename": "tests/source/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f3848471d83574e9b439a06def657ba35ff569f/tests%2Fsource%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f3848471d83574e9b439a06def657ba35ff569f/tests%2Fsource%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fexpr.rs?ref=0f3848471d83574e9b439a06def657ba35ff569f", "patch": "@@ -7,6 +7,7 @@ fn foo() -> bool {\n     let very_long_variable_name = ( a +  first +   simple + test   );\n     let very_long_variable_name = (a + first + simple + test + AAAAAAAAAAAAA + BBBBBBBBBBBBBBBBB + b + c);\n \n+    //FIXME this exceeds width limit. Needs assignments reformatting\n     let is_internalxxxx = self.codemap.span_to_filename(s) == self.codemap.span_to_filename(m.inner);\n \n     let some_val = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa * bbbb / (bbbbbb -"}, {"sha": "1ec5e0168fa9bb0abcfeb617934acd7bc063b659", "filename": "tests/target/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f3848471d83574e9b439a06def657ba35ff569f/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f3848471d83574e9b439a06def657ba35ff569f/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=0f3848471d83574e9b439a06def657ba35ff569f", "patch": "@@ -8,8 +8,8 @@ fn foo() -> bool {\n     let very_long_variable_name = (a + first + simple + test + AAAAAAAAAAAAA + BBBBBBBBBBBBBBBBB +\n                                    b + c);\n \n-    let is_internalxxxx = self.codemap.span_to_filename(s) ==\n-                          self.codemap.span_to_filename(m.inner);\n+    //FIXME this exceeds width limit. Needs assignments reformatting\n+    let is_internalxxxx = self.codemap.span_to_filename(s) == self.codemap.span_to_filename(m.inner);\n \n     let some_val = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa * bbbb /\n                    (bbbbbb - function_call(x, *very_long_pointer, y)) + 1000;"}, {"sha": "a799c09621000907a45d86840bb6db45ef58731c", "filename": "tests/target/imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f3848471d83574e9b439a06def657ba35ff569f/tests%2Ftarget%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f3848471d83574e9b439a06def657ba35ff569f/tests%2Ftarget%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimports.rs?ref=0f3848471d83574e9b439a06def657ba35ff569f", "patch": "@@ -23,8 +23,8 @@ mod Foo {\n     pub use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n \n     mod Foo2 {\n-        pub use syntax::ast::{self, ItemForeignMod, ItemImpl, ItemMac, ItemMod,\n-                              ItemStatic, ItemDefaultImpl};\n+        pub use syntax::ast::{self, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic,\n+                              ItemDefaultImpl};\n     }\n }\n "}, {"sha": "5573ea7e96e74d7f5ed19196a9ef0de9ac52fe2e", "filename": "tests/target/multiple.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f3848471d83574e9b439a06def657ba35ff569f/tests%2Ftarget%2Fmultiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f3848471d83574e9b439a06def657ba35ff569f/tests%2Ftarget%2Fmultiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmultiple.rs?ref=0f3848471d83574e9b439a06def657ba35ff569f", "patch": "@@ -14,10 +14,9 @@ extern crate foo;\n extern crate foo;\n \n use std::cell::*;\n-use std::{self, any, ascii, borrow, boxed, char, borrow, boxed, char, borrow,\n-          borrow, boxed, char, borrow, boxed, char, borrow, boxed, char,\n-          borrow, boxed, char, borrow, boxed, char, borrow, boxed, char,\n-          borrow, boxed, char, borrow, boxed, char};\n+use std::{self, any, ascii, borrow, boxed, char, borrow, boxed, char, borrow, borrow, boxed, char,\n+          borrow, boxed, char, borrow, boxed, char, borrow, boxed, char, borrow, boxed, char,\n+          borrow, boxed, char, borrow, boxed, char, borrow, boxed, char};\n \n mod doc;\n mod other;"}]}