{"sha": "a5b6a9fa8ad2e13adbfcc5f3f624d9252379d745", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YjZhOWZhOGFkMmUxM2FkYmZjYzVmM2Y2MjRkOTI1MjM3OWQ3NDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-26T15:15:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-26T15:15:07Z"}, "message": "Auto merge of #37312 - arthurprs:sip-smaller, r=alexcrichton\n\nSmall improvement to SipHasher\n\nVery small but constant improvement, the objective is to lower latency for u16, u32 and small strings.\n\nCC #35735\n\n```\n\u279c  siphash-bench git:(master) \u2717 sudo nice -n -20 target/release/foo-648738a54f390643 --bench | tee benches.txt\n[sudo] password for arthurprs:\n\nrunning 62 tests\ntest _same                       ... bench:           0 ns/iter (+/- 0)\ntest _warmup                     ... bench:           0 ns/iter (+/- 0)\ntest rust_siphash13::int_u16     ... bench:          12 ns/iter (+/- 1)\ntest rust_siphash13::int_u32     ... bench:          14 ns/iter (+/- 0)\ntest rust_siphash13::int_u64     ... bench:          11 ns/iter (+/- 1)\ntest rust_siphash13::int_u8      ... bench:          11 ns/iter (+/- 1)\ntest rust_siphash13::slice::_10  ... bench:          18 ns/iter (+/- 1)\ntest rust_siphash13::slice::_100 ... bench:          42 ns/iter (+/- 2)\ntest rust_siphash13::slice::_11  ... bench:          19 ns/iter (+/- 1)\ntest rust_siphash13::slice::_12  ... bench:          21 ns/iter (+/- 3)\ntest rust_siphash13::slice::_2   ... bench:          16 ns/iter (+/- 2)\ntest rust_siphash13::slice::_200 ... bench:          68 ns/iter (+/- 3)\ntest rust_siphash13::slice::_3   ... bench:          17 ns/iter (+/- 3)\ntest rust_siphash13::slice::_4   ... bench:          18 ns/iter (+/- 1)\ntest rust_siphash13::slice::_5   ... bench:          19 ns/iter (+/- 4)\ntest rust_siphash13::slice::_6   ... bench:          19 ns/iter (+/- 1)\ntest rust_siphash13::slice::_7   ... bench:          20 ns/iter (+/- 1)\ntest rust_siphash13::slice::_8   ... bench:          16 ns/iter (+/- 1)\ntest rust_siphash13::slice::_9   ... bench:          18 ns/iter (+/- 2)\ntest rust_siphash13::str_::_10   ... bench:          18 ns/iter (+/- 1)\ntest rust_siphash13::str_::_100  ... bench:          41 ns/iter (+/- 2)\ntest rust_siphash13::str_::_11   ... bench:          19 ns/iter (+/- 1)\ntest rust_siphash13::str_::_12   ... bench:          20 ns/iter (+/- 2)\ntest rust_siphash13::str_::_2    ... bench:          16 ns/iter (+/- 1)\ntest rust_siphash13::str_::_200  ... bench:          68 ns/iter (+/- 3)\ntest rust_siphash13::str_::_3    ... bench:          17 ns/iter (+/- 1)\ntest rust_siphash13::str_::_4    ... bench:          18 ns/iter (+/- 2)\ntest rust_siphash13::str_::_5    ... bench:          19 ns/iter (+/- 6)\ntest rust_siphash13::str_::_6    ... bench:          20 ns/iter (+/- 5)\ntest rust_siphash13::str_::_7    ... bench:          23 ns/iter (+/- 1)\ntest rust_siphash13::str_::_8    ... bench:          15 ns/iter (+/- 1)\ntest rust_siphash13::str_::_9    ... bench:          17 ns/iter (+/- 1)\ntest sip1b::int_u16              ... bench:          10 ns/iter (+/- 1)\ntest sip1b::int_u32              ... bench:           9 ns/iter (+/- 1)\ntest sip1b::int_u64              ... bench:          12 ns/iter (+/- 1)\ntest sip1b::int_u8               ... bench:           7 ns/iter (+/- 0)\ntest sip1b::slice::_10           ... bench:          12 ns/iter (+/- 1)\ntest sip1b::slice::_100          ... bench:          33 ns/iter (+/- 2)\ntest sip1b::slice::_11           ... bench:          13 ns/iter (+/- 0)\ntest sip1b::slice::_12           ... bench:          12 ns/iter (+/- 1)\ntest sip1b::slice::_2            ... bench:          10 ns/iter (+/- 0)\ntest sip1b::slice::_200          ... bench:          62 ns/iter (+/- 2)\ntest sip1b::slice::_3            ... bench:          10 ns/iter (+/- 1)\ntest sip1b::slice::_4            ... bench:           9 ns/iter (+/- 0)\ntest sip1b::slice::_5            ... bench:          10 ns/iter (+/- 1)\ntest sip1b::slice::_6            ... bench:          10 ns/iter (+/- 0)\ntest sip1b::slice::_7            ... bench:          11 ns/iter (+/- 0)\ntest sip1b::slice::_8            ... bench:          11 ns/iter (+/- 1)\ntest sip1b::slice::_9            ... bench:          12 ns/iter (+/- 1)\ntest sip1b::str_::_10            ... bench:          15 ns/iter (+/- 1)\ntest sip1b::str_::_100           ... bench:          37 ns/iter (+/- 3)\ntest sip1b::str_::_11            ... bench:          16 ns/iter (+/- 1)\ntest sip1b::str_::_12            ... bench:          14 ns/iter (+/- 1)\ntest sip1b::str_::_2             ... bench:          13 ns/iter (+/- 1)\ntest sip1b::str_::_200           ... bench:          67 ns/iter (+/- 5)\ntest sip1b::str_::_3             ... bench:          14 ns/iter (+/- 2)\ntest sip1b::str_::_4             ... bench:          12 ns/iter (+/- 1)\ntest sip1b::str_::_5             ... bench:          13 ns/iter (+/- 1)\ntest sip1b::str_::_6             ... bench:          13 ns/iter (+/- 0)\ntest sip1b::str_::_7             ... bench:          16 ns/iter (+/- 1)\ntest sip1b::str_::_8             ... bench:          14 ns/iter (+/- 1)\ntest sip1b::str_::_9             ... bench:          15 ns/iter (+/- 1)\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 62 measured\n\n\u279c  siphash-bench git:(master) \u2717 cargo benchcmp rust_siphash13:: sip1b:: benches.txt\n name         rust_siphash13:: ns/iter  sip1b:: ns/iter  diff ns/iter   diff %\n int_u16      12                        10                         -2  -16.67%\n int_u32      14                        9                          -5  -35.71%\n int_u64      11                        12                          1    9.09%\n int_u8       11                        7                          -4  -36.36%\n slice::_10   18                        12                         -6  -33.33%\n slice::_100  42                        33                         -9  -21.43%\n slice::_11   19                        13                         -6  -31.58%\n slice::_12   21                        12                         -9  -42.86%\n slice::_2    16                        10                         -6  -37.50%\n slice::_200  68                        62                         -6   -8.82%\n slice::_3    17                        10                         -7  -41.18%\n slice::_4    18                        9                          -9  -50.00%\n slice::_5    19                        10                         -9  -47.37%\n slice::_6    19                        10                         -9  -47.37%\n slice::_7    20                        11                         -9  -45.00%\n slice::_8    16                        11                         -5  -31.25%\n slice::_9    18                        12                         -6  -33.33%\n str_::_10    18                        15                         -3  -16.67%\n str_::_100   41                        37                         -4   -9.76%\n str_::_11    19                        16                         -3  -15.79%\n str_::_12    20                        14                         -6  -30.00%\n str_::_2     16                        13                         -3  -18.75%\n str_::_200   68                        67                         -1   -1.47%\n str_::_3     17                        14                         -3  -17.65%\n str_::_4     18                        12                         -6  -33.33%\n str_::_5     19                        13                         -6  -31.58%\n str_::_6     20                        13                         -7  -35.00%\n str_::_7     23                        16                         -7  -30.43%\n str_::_8     15                        14                         -1   -6.67%\n str_::_9     17                        15                         -2  -11.76%\n\n```\n\nfrom a modified hash-rs suite (preallocating maps and adding having slice/str variants)\n\ngraph version: http://imgur.com/a/DuoI4\n\n```\n\u279c  hash-rs git:(rfc-extend-hasher) \u2717 cargo benchcmp sip13:: sip13opt:: benches.txt\n name                             sip13:: ns/iter      sip13opt:: ns/iter   diff ns/iter   diff %\n slice::mapcountdense_000000001   27,343 (36 MB/s)     26,401 (37 MB/s)             -942   -3.45%\n slice::mapcountdense_000000002   28,982 (69 MB/s)     26,807 (74 MB/s)           -2,175   -7.50%\n slice::mapcountdense_000000003   29,304 (102 MB/s)    27,360 (109 MB/s)          -1,944   -6.63%\n slice::mapcountdense_000000004   30,411 (131 MB/s)    25,888 (154 MB/s)          -4,523  -14.87%\n slice::mapcountdense_000000005   32,625 (153 MB/s)    27,486 (181 MB/s)          -5,139  -15.75%\n slice::mapcountdense_000000006   34,920 (171 MB/s)    27,204 (220 MB/s)          -7,716  -22.10%\n slice::mapcountdense_000000007   33,497 (208 MB/s)    28,330 (247 MB/s)          -5,167  -15.43%\n slice::mapcountdense_000000008   31,153 (256 MB/s)    28,617 (279 MB/s)          -2,536   -8.14%\n slice::mapcountdense_000000009   30,745 (292 MB/s)    29,666 (303 MB/s)          -1,079   -3.51%\n slice::mapcountdense_000000010   31,509 (317 MB/s)    29,804 (335 MB/s)          -1,705   -5.41%\n slice::mapcountdense_000000011   32,526 (338 MB/s)    30,520 (360 MB/s)          -2,006   -6.17%\n slice::mapcountdense_000000012   32,981 (363 MB/s)    28,739 (417 MB/s)          -4,242  -12.86%\n slice::mapcountdense_000000013   34,713 (374 MB/s)    30,348 (428 MB/s)          -4,365  -12.57%\n slice::mapcountdense_000000014   34,635 (404 MB/s)    29,974 (467 MB/s)          -4,661  -13.46%\n slice::mapcountdense_000000015   35,924 (417 MB/s)    30,584 (490 MB/s)          -5,340  -14.86%\n slice::mapcountdense_000000016   31,939 (500 MB/s)    30,564 (523 MB/s)          -1,375   -4.31%\n slice::mapcountdense_000000032   36,545 (875 MB/s)    34,833 (918 MB/s)          -1,712   -4.68%\n slice::mapcountdense_000000064   44,691 (1432 MB/s)   43,912 (1457 MB/s)           -779   -1.74%\n slice::mapcountdense_000000128   67,210 (1904 MB/s)   64,630 (1980 MB/s)         -2,580   -3.84%\n slice::mapcountdense_000000256   110,320 (2320 MB/s)  108,713 (2354 MB/s)        -1,607   -1.46%\n slice::mapcountsparse_000000001  29,686 (33 MB/s)     28,673 (34 MB/s)           -1,013   -3.41%\n slice::mapcountsparse_000000002  32,073 (62 MB/s)     30,519 (65 MB/s)           -1,554   -4.85%\n slice::mapcountsparse_000000003  33,184 (90 MB/s)     31,208 (96 MB/s)           -1,976   -5.95%\n slice::mapcountsparse_000000004  34,344 (116 MB/s)    30,242 (132 MB/s)          -4,102  -11.94%\n slice::mapcountsparse_000000005  34,536 (144 MB/s)    30,552 (163 MB/s)          -3,984  -11.54%\n slice::mapcountsparse_000000006  35,791 (167 MB/s)    30,813 (194 MB/s)          -4,978  -13.91%\n slice::mapcountsparse_000000007  36,773 (190 MB/s)    31,362 (223 MB/s)          -5,411  -14.71%\n slice::mapcountsparse_000000008  33,101 (241 MB/s)    32,399 (246 MB/s)            -702   -2.12%\n slice::mapcountsparse_000000009  34,025 (264 MB/s)    33,065 (272 MB/s)            -960   -2.82%\n slice::mapcountsparse_000000010  34,755 (287 MB/s)    33,152 (301 MB/s)          -1,603   -4.61%\n slice::mapcountsparse_000000011  35,682 (308 MB/s)    33,631 (327 MB/s)          -2,051   -5.75%\n slice::mapcountsparse_000000012  36,422 (329 MB/s)    32,604 (368 MB/s)          -3,818  -10.48%\n slice::mapcountsparse_000000013  37,561 (346 MB/s)    32,978 (394 MB/s)          -4,583  -12.20%\n slice::mapcountsparse_000000014  38,476 (363 MB/s)    33,376 (419 MB/s)          -5,100  -13.26%\n slice::mapcountsparse_000000015  39,202 (382 MB/s)    33,750 (444 MB/s)          -5,452  -13.91%\n slice::mapcountsparse_000000016  34,898 (458 MB/s)    33,621 (475 MB/s)          -1,277   -3.66%\n slice::mapcountsparse_000000032  39,767 (804 MB/s)    38,013 (841 MB/s)          -1,754   -4.41%\n slice::mapcountsparse_000000064  47,810 (1338 MB/s)   46,332 (1381 MB/s)         -1,478   -3.09%\n slice::mapcountsparse_000000128  64,519 (1983 MB/s)   63,322 (2021 MB/s)         -1,197   -1.86%\n slice::mapcountsparse_000000256  101,042 (2533 MB/s)  99,754 (2566 MB/s)         -1,288   -1.27%\n str_::mapcountdense_000000001    27,183 (36 MB/s)     24,007 (41 MB/s)           -3,176  -11.68%\n str_::mapcountdense_000000002    28,940 (69 MB/s)     24,574 (81 MB/s)           -4,366  -15.09%\n str_::mapcountdense_000000003    29,000 (103 MB/s)    24,687 (121 MB/s)          -4,313  -14.87%\n str_::mapcountdense_000000004    29,822 (134 MB/s)    24,377 (164 MB/s)          -5,445  -18.26%\n str_::mapcountdense_000000005    31,962 (156 MB/s)    25,184 (198 MB/s)          -6,778  -21.21%\n str_::mapcountdense_000000006    32,218 (186 MB/s)    25,020 (239 MB/s)          -7,198  -22.34%\n str_::mapcountdense_000000007    35,482 (197 MB/s)    27,705 (252 MB/s)          -7,777  -21.92%\n str_::mapcountdense_000000008    28,643 (279 MB/s)    25,563 (312 MB/s)          -3,080  -10.75%\n str_::mapcountdense_000000009    30,112 (298 MB/s)    26,773 (336 MB/s)          -3,339  -11.09%\n str_::mapcountdense_000000010    31,554 (316 MB/s)    27,607 (362 MB/s)          -3,947  -12.51%\n str_::mapcountdense_000000011    32,062 (343 MB/s)    27,770 (396 MB/s)          -4,292  -13.39%\n str_::mapcountdense_000000012    32,258 (372 MB/s)    25,612 (468 MB/s)          -6,646  -20.60%\n str_::mapcountdense_000000013    33,544 (387 MB/s)    26,908 (483 MB/s)          -6,636  -19.78%\n str_::mapcountdense_000000014    34,681 (403 MB/s)    27,267 (513 MB/s)          -7,414  -21.38%\n str_::mapcountdense_000000015    37,883 (395 MB/s)    30,226 (496 MB/s)          -7,657  -20.21%\n str_::mapcountdense_000000016    30,299 (528 MB/s)    27,960 (572 MB/s)          -2,339   -7.72%\n str_::mapcountdense_000000032    34,372 (930 MB/s)    32,736 (977 MB/s)          -1,636   -4.76%\n str_::mapcountdense_000000048    38,610 (1243 MB/s)   36,437 (1317 MB/s)         -2,173   -5.63%\n str_::mapcountdense_000000064    43,052 (1486 MB/s)   41,269 (1550 MB/s)         -1,783   -4.14%\n str_::mapcountdense_000000128    64,059 (1998 MB/s)   62,007 (2064 MB/s)         -2,052   -3.20%\n str_::mapcountdense_000000256    109,608 (2335 MB/s)  107,184 (2388 MB/s)        -2,424   -2.21%\n str_::mapcountsparse_000000001   29,155 (34 MB/s)     26,151 (38 MB/s)           -3,004  -10.30%\n str_::mapcountsparse_000000002   31,536 (63 MB/s)     27,787 (71 MB/s)           -3,749  -11.89%\n str_::mapcountsparse_000000003   32,524 (92 MB/s)     27,861 (107 MB/s)          -4,663  -14.34%\n str_::mapcountsparse_000000004   33,535 (119 MB/s)    27,585 (145 MB/s)          -5,950  -17.74%\n str_::mapcountsparse_000000005   34,239 (146 MB/s)    27,520 (181 MB/s)          -6,719  -19.62%\n str_::mapcountsparse_000000006   35,485 (169 MB/s)    27,437 (218 MB/s)          -8,048  -22.68%\n str_::mapcountsparse_000000007   39,098 (179 MB/s)    30,465 (229 MB/s)          -8,633  -22.08%\n str_::mapcountsparse_000000008   30,882 (259 MB/s)    29,215 (273 MB/s)          -1,667   -5.40%\n str_::mapcountsparse_000000009   33,375 (269 MB/s)    29,301 (307 MB/s)          -4,074  -12.21%\n str_::mapcountsparse_000000010   33,531 (298 MB/s)    29,008 (344 MB/s)          -4,523  -13.49%\n str_::mapcountsparse_000000011   34,607 (317 MB/s)    29,800 (369 MB/s)          -4,807  -13.89%\n str_::mapcountsparse_000000012   35,700 (336 MB/s)    28,380 (422 MB/s)          -7,320  -20.50%\n str_::mapcountsparse_000000013   36,692 (354 MB/s)    29,350 (442 MB/s)          -7,342  -20.01%\n str_::mapcountsparse_000000014   37,326 (375 MB/s)    29,285 (478 MB/s)          -8,041  -21.54%\n str_::mapcountsparse_000000015   41,098 (364 MB/s)    33,073 (453 MB/s)          -8,025  -19.53%\n str_::mapcountsparse_000000016   33,046 (484 MB/s)    30,717 (520 MB/s)          -2,329   -7.05%\n str_::mapcountsparse_000000032   37,471 (853 MB/s)    35,542 (900 MB/s)          -1,929   -5.15%\n str_::mapcountsparse_000000048   41,324 (1161 MB/s)   39,332 (1220 MB/s)         -1,992   -4.82%\n str_::mapcountsparse_000000064   45,858 (1395 MB/s)   43,802 (1461 MB/s)         -2,056   -4.48%\n str_::mapcountsparse_000000128   62,471 (2048 MB/s)   60,683 (2109 MB/s)         -1,788   -2.86%\n str_::mapcountsparse_000000256   101,283 (2527 MB/s)  97,655 (2621 MB/s)         -3,628   -3.58%\n```", "tree": {"sha": "932139e10bd9f4ad86ce3f9c3bd8b265372397b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/932139e10bd9f4ad86ce3f9c3bd8b265372397b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5b6a9fa8ad2e13adbfcc5f3f624d9252379d745", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5b6a9fa8ad2e13adbfcc5f3f624d9252379d745", "html_url": "https://github.com/rust-lang/rust/commit/a5b6a9fa8ad2e13adbfcc5f3f624d9252379d745", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5b6a9fa8ad2e13adbfcc5f3f624d9252379d745/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6b3b01b5f7f5a9d7d340dacf7dbf72be29e2c07", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6b3b01b5f7f5a9d7d340dacf7dbf72be29e2c07", "html_url": "https://github.com/rust-lang/rust/commit/a6b3b01b5f7f5a9d7d340dacf7dbf72be29e2c07"}, {"sha": "a319d13a9beba484a5c7e4e9c674ef905fd3d6f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a319d13a9beba484a5c7e4e9c674ef905fd3d6f4", "html_url": "https://github.com/rust-lang/rust/commit/a319d13a9beba484a5c7e4e9c674ef905fd3d6f4"}], "stats": {"total": 168, "additions": 118, "deletions": 50}, "files": [{"sha": "6b3ab64dfd88ccb4bc67e1e4fdf6945ef01d8c7c", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 97, "deletions": 50, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/a5b6a9fa8ad2e13adbfcc5f3f624d9252379d745/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b6a9fa8ad2e13adbfcc5f3f624d9252379d745/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=a5b6a9fa8ad2e13adbfcc5f3f624d9252379d745", "patch": "@@ -14,6 +14,8 @@\n \n use marker::PhantomData;\n use ptr;\n+use cmp;\n+use mem;\n \n /// An implementation of SipHash 1-3.\n ///\n@@ -78,45 +80,6 @@ struct State {\n     v3: u64,\n }\n \n-// sadly, these macro definitions can't appear later,\n-// because they're needed in the following defs;\n-// this design could be improved.\n-\n-macro_rules! u8to64_le {\n-    ($buf:expr, $i:expr) =>\n-    ($buf[0+$i] as u64 |\n-     ($buf[1+$i] as u64) << 8 |\n-     ($buf[2+$i] as u64) << 16 |\n-     ($buf[3+$i] as u64) << 24 |\n-     ($buf[4+$i] as u64) << 32 |\n-     ($buf[5+$i] as u64) << 40 |\n-     ($buf[6+$i] as u64) << 48 |\n-     ($buf[7+$i] as u64) << 56);\n-    ($buf:expr, $i:expr, $len:expr) =>\n-    ({\n-        let mut t = 0;\n-        let mut out = 0;\n-        while t < $len {\n-            out |= ($buf[t+$i] as u64) << t*8;\n-            t += 1;\n-        }\n-        out\n-    });\n-}\n-\n-/// Load a full u64 word from a byte stream, in LE order. Use\n-/// `copy_nonoverlapping` to let the compiler generate the most efficient way\n-/// to load u64 from a possibly unaligned address.\n-///\n-/// Unsafe because: unchecked indexing at i..i+8\n-#[inline]\n-unsafe fn load_u64_le(buf: &[u8], i: usize) -> u64 {\n-    debug_assert!(i + 8 <= buf.len());\n-    let mut data = 0u64;\n-    ptr::copy_nonoverlapping(buf.get_unchecked(i), &mut data as *mut _ as *mut u8, 8);\n-    data.to_le()\n-}\n-\n macro_rules! compress {\n     ($state:expr) => ({\n         compress!($state.v0, $state.v1, $state.v2, $state.v3)\n@@ -132,6 +95,47 @@ macro_rules! compress {\n     });\n }\n \n+/// Load an integer of the desired type from a byte stream, in LE order. Uses\n+/// `copy_nonoverlapping` to let the compiler generate the most efficient way\n+/// to load it from a possibly unaligned address.\n+///\n+/// Unsafe because: unchecked indexing at i..i+size_of(int_ty)\n+macro_rules! load_int_le {\n+    ($buf:expr, $i:expr, $int_ty:ident) =>\n+    ({\n+       debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n+       let mut data = 0 as $int_ty;\n+       ptr::copy_nonoverlapping($buf.get_unchecked($i),\n+                                &mut data as *mut _ as *mut u8,\n+                                mem::size_of::<$int_ty>());\n+       data.to_le()\n+    });\n+}\n+\n+/// Load an u64 using up to 7 bytes of a byte slice.\n+///\n+/// Unsafe because: unchecked indexing at start..start+len\n+#[inline]\n+unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n+    debug_assert!(len < 8);\n+    let mut i = 0; // current byte index (from LSB) in the output u64\n+    let mut out = 0;\n+    if i + 3 < len {\n+        out = load_int_le!(buf, start + i, u32) as u64;\n+        i += 4;\n+    }\n+    if i + 1 < len {\n+        out |= (load_int_le!(buf, start + i, u16) as u64) << (i * 8);\n+        i += 2\n+    }\n+    if i < len {\n+        out |= (*buf.get_unchecked(start + i) as u64) << (i * 8);\n+        i += 1;\n+    }\n+    debug_assert_eq!(i, len);\n+    out\n+}\n+\n impl SipHasher {\n     /// Creates a new `SipHasher` with the two initial keys set to 0.\n     #[inline]\n@@ -220,6 +224,37 @@ impl<S: Sip> Hasher<S> {\n         self.state.v3 = self.k1 ^ 0x7465646279746573;\n         self.ntail = 0;\n     }\n+\n+    // Specialized write function that is only valid for buffers with len <= 8.\n+    // It's used to force inlining of write_u8 and write_usize, those would normally be inlined\n+    // except for composite types (that includes slices and str hashing because of delimiter).\n+    // Without this extra push the compiler is very reluctant to inline delimiter writes,\n+    // degrading performance substantially for the most common use cases.\n+    #[inline(always)]\n+    fn short_write(&mut self, msg: &[u8]) {\n+        debug_assert!(msg.len() <= 8);\n+        let length = msg.len();\n+        self.length += length;\n+\n+        let needed = 8 - self.ntail;\n+        let fill = cmp::min(length, needed);\n+        if fill == 8 {\n+            self.tail = unsafe { load_int_le!(msg, 0, u64) };\n+        } else {\n+            self.tail |= unsafe { u8to64_le(msg, 0, fill) } << (8 * self.ntail);\n+            if length < needed {\n+                self.ntail += length;\n+                return;\n+            }\n+        }\n+        self.state.v3 ^= self.tail;\n+        S::c_rounds(&mut self.state);\n+        self.state.v0 ^= self.tail;\n+\n+        // Buffered tail is now flushed, process new input.\n+        self.ntail = length - needed;\n+        self.tail = unsafe { u8to64_le(msg, needed, self.ntail) };\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -262,6 +297,21 @@ impl super::Hasher for SipHasher24 {\n }\n \n impl<S: Sip> super::Hasher for Hasher<S> {\n+    // see short_write comment for explanation\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        let bytes = unsafe {\n+            ::slice::from_raw_parts(&i as *const usize as *const u8, mem::size_of::<usize>())\n+        };\n+        self.short_write(bytes);\n+    }\n+\n+    // see short_write comment for explanation\n+    #[inline]\n+    fn write_u8(&mut self, i: u8) {\n+        self.short_write(&[i]);\n+    }\n+\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         let length = msg.len();\n@@ -271,19 +321,16 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n \n         if self.ntail != 0 {\n             needed = 8 - self.ntail;\n+            self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << 8 * self.ntail;\n             if length < needed {\n-                self.tail |= u8to64_le!(msg, 0, length) << 8 * self.ntail;\n                 self.ntail += length;\n                 return\n+            } else {\n+                self.state.v3 ^= self.tail;\n+                S::c_rounds(&mut self.state);\n+                self.state.v0 ^= self.tail;\n+                self.ntail = 0;\n             }\n-\n-            let m = self.tail | u8to64_le!(msg, 0, needed) << 8 * self.ntail;\n-\n-            self.state.v3 ^= m;\n-            S::c_rounds(&mut self.state);\n-            self.state.v0 ^= m;\n-\n-            self.ntail = 0;\n         }\n \n         // Buffered tail is now flushed, process new input.\n@@ -292,7 +339,7 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n \n         let mut i = needed;\n         while i < len - left {\n-            let mi = unsafe { load_u64_le(msg, i) };\n+            let mi = unsafe { load_int_le!(msg, i, u64) };\n \n             self.state.v3 ^= mi;\n             S::c_rounds(&mut self.state);\n@@ -301,7 +348,7 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n             i += 8;\n         }\n \n-        self.tail = u8to64_le!(msg, i, left);\n+        self.tail = unsafe { u8to64_le(msg, i, left) };\n         self.ntail = left;\n     }\n "}, {"sha": "fa3bfdea42df8194734d8ccb3e80222f9b1d5636", "filename": "src/libcoretest/hash/sip.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a5b6a9fa8ad2e13adbfcc5f3f624d9252379d745/src%2Flibcoretest%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b6a9fa8ad2e13adbfcc5f3f624d9252379d745/src%2Flibcoretest%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fsip.rs?ref=a5b6a9fa8ad2e13adbfcc5f3f624d9252379d745", "patch": "@@ -14,6 +14,7 @@ use test::{Bencher, black_box};\n \n use core::hash::{Hash, Hasher};\n use core::hash::{SipHasher, SipHasher13, SipHasher24};\n+use core::{slice, mem};\n \n // Hash just the bytes of the slice, without length prefix\n struct Bytes<'a>(&'a [u8]);\n@@ -327,6 +328,26 @@ fn test_hash_no_concat_alias() {\n     assert!(hash(&v) != hash(&w));\n }\n \n+#[test]\n+fn test_write_short_works() {\n+    let test_usize = 0xd0c0b0a0usize;\n+    let mut h1 = SipHasher24::new();\n+    h1.write_usize(test_usize);\n+    h1.write(b\"bytes\");\n+    h1.write(b\"string\");\n+    h1.write_u8(0xFFu8);\n+    h1.write_u8(0x01u8);\n+    let mut h2 = SipHasher24::new();\n+    h2.write(unsafe {\n+        slice::from_raw_parts(&test_usize as *const _ as *const u8,\n+                              mem::size_of::<usize>())\n+    });\n+    h2.write(b\"bytes\");\n+    h2.write(b\"string\");\n+    h2.write(&[0xFFu8, 0x01u8]);\n+    assert_eq!(h1.finish(), h2.finish());\n+}\n+\n #[bench]\n fn bench_str_under_8_bytes(b: &mut Bencher) {\n     let s = \"foo\";"}]}