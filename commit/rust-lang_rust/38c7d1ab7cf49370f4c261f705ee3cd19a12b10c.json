{"sha": "38c7d1ab7cf49370f4c261f705ee3cd19a12b10c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4YzdkMWFiN2NmNDkzNzBmNGMyNjFmNzA1ZWUzY2QxOWExMmIxMGM=", "commit": {"author": {"name": "dylan_DPC", "email": "dylan.dpc@gmail.com", "date": "2018-07-06T15:27:01Z"}, "committer": {"name": "dylan_DPC", "email": "dylan.dpc@gmail.com", "date": "2018-07-19T17:44:10Z"}, "message": "add generic parameter", "tree": {"sha": "8fdb62c75c02d7c30ad9ddf0eed85dbf3b5617a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fdb62c75c02d7c30ad9ddf0eed85dbf3b5617a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38c7d1ab7cf49370f4c261f705ee3cd19a12b10c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38c7d1ab7cf49370f4c261f705ee3cd19a12b10c", "html_url": "https://github.com/rust-lang/rust/commit/38c7d1ab7cf49370f4c261f705ee3cd19a12b10c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38c7d1ab7cf49370f4c261f705ee3cd19a12b10c/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8247dd5c69ca57ede5073209bd30afb90dd4e3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8247dd5c69ca57ede5073209bd30afb90dd4e3b", "html_url": "https://github.com/rust-lang/rust/commit/a8247dd5c69ca57ede5073209bd30afb90dd4e3b"}], "stats": {"total": 134, "additions": 71, "deletions": 63}, "files": [{"sha": "ba96e7c3b30be2f4fdbe1b46fccc7f376cda9a74", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38c7d1ab7cf49370f4c261f705ee3cd19a12b10c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c7d1ab7cf49370f4c261f705ee3cd19a12b10c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=38c7d1ab7cf49370f4c261f705ee3cd19a12b10c", "patch": "@@ -22,6 +22,7 @@ use rustc::infer::InferCtxt;\n use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Mir};\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc::util::nodemap::FxHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n use std::collections::BTreeSet;\n use std::fmt::Debug;\n use std::env;\n@@ -207,9 +208,9 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     (regioncx, polonius_output, closure_region_requirements)\n }\n \n-fn dump_mir_results<'a, 'gcx, 'tcx>(\n+fn dump_mir_results<'a, 'gcx, 'tcx, V: Idx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    liveness: &LivenessResults,\n+    liveness: &LivenessResults<V>,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n     regioncx: &RegionInferenceContext,\n@@ -405,7 +406,7 @@ impl ToRegionVid for RegionVid {\n     }\n }\n \n-fn live_variable_set(regular: &LocalSet, drops: &LocalSet) -> String {\n+fn live_variable_set<V: Idx>(regular: &LocalSet<V>, drops: &LocalSet<V>) -> String {\n     // sort and deduplicate:\n     let all_locals: BTreeSet<_> = regular.iter().chain(drops.iter()).collect();\n "}, {"sha": "7c0e7941a44137728c2196c076bcc7e53f03408a", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/38c7d1ab7cf49370f4c261f705ee3cd19a12b10c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c7d1ab7cf49370f4c261f705ee3cd19a12b10c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=38c7d1ab7cf49370f4c261f705ee3cd19a12b10c", "patch": "@@ -20,6 +20,7 @@ use rustc::traits::query::type_op::outlives::DropckOutlives;\n use rustc::traits::query::type_op::TypeOp;\n use rustc::ty::{Ty, TypeFoldable};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::indexed_vec::Idx;\n use std::rc::Rc;\n use util::liveness::LivenessResults;\n \n@@ -33,10 +34,10 @@ use super::TypeChecker;\n ///\n /// NB. This computation requires normalization; therefore, it must be\n /// performed before\n-pub(super) fn generate<'gcx, 'tcx>(\n+pub(super) fn generate<'gcx, 'tcx, V: Idx>(\n     cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n-    liveness: &LivenessResults,\n+    liveness: &LivenessResults<V>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) {\n@@ -54,16 +55,17 @@ pub(super) fn generate<'gcx, 'tcx>(\n     }\n }\n \n-struct TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx>\n+struct TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx, V>\n where\n     'typeck: 'gen,\n     'flow: 'gen,\n     'tcx: 'typeck + 'flow,\n     'gcx: 'tcx,\n+    V: Idx + 'gen,\n {\n     cx: &'gen mut TypeChecker<'typeck, 'gcx, 'tcx>,\n     mir: &'gen Mir<'tcx>,\n-    liveness: &'gen LivenessResults,\n+    liveness: &'gen LivenessResults<V>,\n     flow_inits: &'gen mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n     move_data: &'gen MoveData<'tcx>,\n     drop_data: FxHashMap<Ty<'tcx>, DropData<'tcx>>,\n@@ -74,7 +76,7 @@ struct DropData<'tcx> {\n     region_constraint_data: Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>,\n }\n \n-impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx> {\n+impl<'gen, 'typeck, 'flow, 'gcx, 'tcx, V: Idx> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx, V> {\n     /// Liveness constraints:\n     ///\n     /// > If a variable V is live at point P, then all regions R in the type of V"}, {"sha": "0b8c7e512fbd8655c21d0239fdf02d30acc13e86", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/38c7d1ab7cf49370f4c261f705ee3cd19a12b10c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c7d1ab7cf49370f4c261f705ee3cd19a12b10c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=38c7d1ab7cf49370f4c261f705ee3cd19a12b10c", "patch": "@@ -126,14 +126,14 @@ fn self_arg() -> Local {\n     Local::new(1)\n }\n \n-struct SuspensionPoint {\n+struct SuspensionPoint<V: Idx> {\n     state: u32,\n     resume: BasicBlock,\n     drop: Option<BasicBlock>,\n-    storage_liveness: liveness::LocalSet,\n+    storage_liveness: liveness::LocalSet<V>,\n }\n \n-struct TransformVisitor<'a, 'tcx: 'a> {\n+struct TransformVisitor<'a, 'tcx: 'a, V: Idx> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     state_adt_ref: &'tcx AdtDef,\n     state_substs: &'tcx Substs<'tcx>,\n@@ -145,16 +145,16 @@ struct TransformVisitor<'a, 'tcx: 'a> {\n     remap: HashMap<Local, (Ty<'tcx>, usize)>,\n \n     // A map from a suspension point in a block to the locals which have live storage at that point\n-    storage_liveness: HashMap<BasicBlock, liveness::LocalSet>,\n+    storage_liveness: HashMap<BasicBlock, liveness::LocalSet<V>>,\n \n     // A list of suspension points, generated during the transform\n-    suspension_points: Vec<SuspensionPoint>,\n+    suspension_points: Vec<SuspensionPoint<V>>,\n \n     // The original RETURN_PLACE local\n     new_ret_local: Local,\n }\n \n-impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, V: Idx> TransformVisitor<'a, 'tcx, V> {\n     // Make a GeneratorState rvalue\n     fn make_state(&self, idx: usize, val: Operand<'tcx>) -> Rvalue<'tcx> {\n         let adt = AggregateKind::Adt(self.state_adt_ref, idx, self.state_substs, None);\n@@ -191,7 +191,7 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, V: Idx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx, V> {\n     fn visit_local(&mut self,\n                    local: &mut Local,\n                    _: PlaceContext<'tcx>,\n@@ -317,9 +317,9 @@ fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n     new_ret_local\n }\n \n-struct StorageIgnored(liveness::LocalSet);\n+struct StorageIgnored<V: Idx>(liveness::LocalSet<V>);\n \n-impl<'tcx> Visitor<'tcx> for StorageIgnored {\n+impl<'tcx, V: Idx> Visitor<'tcx> for StorageIgnored<V> {\n     fn visit_statement(&mut self,\n                        _block: BasicBlock,\n                        statement: &Statement<'tcx>,\n@@ -332,9 +332,9 @@ impl<'tcx> Visitor<'tcx> for StorageIgnored {\n     }\n }\n \n-struct BorrowedLocals(liveness::LocalSet);\n+struct BorrowedLocals<V: Idx>(liveness::LocalSet<V>);\n \n-fn mark_as_borrowed<'tcx>(place: &Place<'tcx>, locals: &mut BorrowedLocals) {\n+fn mark_as_borrowed<'tcx, V: Idx>(place: &Place<'tcx>, locals: &mut BorrowedLocals<V>) {\n     match *place {\n         Place::Local(l) => { locals.0.add(&l); },\n         Place::Static(..) => (),\n@@ -349,7 +349,7 @@ fn mark_as_borrowed<'tcx>(place: &Place<'tcx>, locals: &mut BorrowedLocals) {\n     }\n }\n \n-impl<'tcx> Visitor<'tcx> for BorrowedLocals {\n+impl<'tcx, V: Idx> Visitor<'tcx> for BorrowedLocals<V> {\n     fn visit_rvalue(&mut self,\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {\n@@ -361,12 +361,12 @@ impl<'tcx> Visitor<'tcx> for BorrowedLocals {\n     }\n }\n \n-fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn locals_live_across_suspend_points<'a, 'tcx, V: Idx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                mir: &Mir<'tcx>,\n                                                source: MirSource,\n                                                movable: bool) ->\n-                                               (liveness::LocalSet,\n-                                                HashMap<BasicBlock, liveness::LocalSet>) {\n+                                               (liveness::LocalSet<V>,\n+                                                HashMap<BasicBlock, liveness::LocalSet<V>>) {\n     let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n     let node_id = tcx.hir.as_local_node_id(source.def_id).unwrap();\n \n@@ -460,15 +460,15 @@ fn locals_live_across_suspend_points<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     (set, storage_liveness_map)\n }\n \n-fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn compute_layout<'a, 'tcx, V: Idx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             source: MirSource,\n                             upvars: Vec<Ty<'tcx>>,\n                             interior: Ty<'tcx>,\n                             movable: bool,\n                             mir: &mut Mir<'tcx>)\n     -> (HashMap<Local, (Ty<'tcx>, usize)>,\n         GeneratorLayout<'tcx>,\n-        HashMap<BasicBlock, liveness::LocalSet>)\n+        HashMap<BasicBlock, liveness::LocalSet<V>>)\n {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n     let (live_locals, storage_liveness) = locals_live_across_suspend_points(tcx,\n@@ -524,10 +524,10 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     (remap, layout, storage_liveness)\n }\n \n-fn insert_switch<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn insert_switch<'a, 'tcx, V: Idx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            mir: &mut Mir<'tcx>,\n                            cases: Vec<(u32, BasicBlock)>,\n-                           transform: &TransformVisitor<'a, 'tcx>,\n+                           transform: &TransformVisitor<'a, 'tcx, V>,\n                            default: TerminatorKind<'tcx>) {\n     let default_block = insert_term_block(mir, default);\n \n@@ -608,9 +608,9 @@ fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn create_generator_drop_shim<'a, 'tcx>(\n+fn create_generator_drop_shim<'a, 'tcx, V: Idx>(\n                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                transform: &TransformVisitor<'a, 'tcx>,\n+                transform: &TransformVisitor<'a, 'tcx, V>,\n                 def_id: DefId,\n                 source: MirSource,\n                 gen_ty: Ty<'tcx>,\n@@ -719,9 +719,9 @@ fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     assert_block\n }\n \n-fn create_generator_resume_function<'a, 'tcx>(\n+fn create_generator_resume_function<'a, 'tcx, V: Idx>(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        transform: TransformVisitor<'a, 'tcx>,\n+        transform: TransformVisitor<'a, 'tcx, V>,\n         def_id: DefId,\n         source: MirSource,\n         mir: &mut Mir<'tcx>) {\n@@ -790,10 +790,10 @@ fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n     drop_clean\n }\n \n-fn create_cases<'a, 'tcx, F>(mir: &mut Mir<'tcx>,\n-                          transform: &TransformVisitor<'a, 'tcx>,\n+fn create_cases<'a, 'tcx, F, V: Idx>(mir: &mut Mir<'tcx>,\n+                          transform: &TransformVisitor<'a, 'tcx, V>,\n                           target: F) -> Vec<(u32, BasicBlock)>\n-    where F: Fn(&SuspensionPoint) -> Option<BasicBlock> {\n+    where F: Fn(&SuspensionPoint<V>) -> Option<BasicBlock> {\n     let source_info = source_info(mir);\n \n     transform.suspension_points.iter().filter_map(|point| {"}, {"sha": "5c1b92b672f31a034a41b05ce59e6de8296e4cdd", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/38c7d1ab7cf49370f4c261f705ee3cd19a12b10c/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38c7d1ab7cf49370f4c261f705ee3cd19a12b10c/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=38c7d1ab7cf49370f4c261f705ee3cd19a12b10c", "patch": "@@ -47,18 +47,18 @@ use rustc::ty::TyCtxt;\n use std::io::{self, Write};\n use transform::MirSource;\n \n-pub type LocalSet = IdxSetBuf<Local>;\n+pub type LocalSet<V: Idx> = IdxSetBuf<V>;\n \n /// This gives the result of the liveness analysis at the boundary of\n /// basic blocks. You can use `simulate_block` to obtain the\n /// intra-block results.\n-pub struct LivenessResult {\n+pub struct LivenessResult<V: Idx> {\n     /// Liveness mode in use when these results were computed.\n     pub mode: LivenessMode,\n \n     /// Live variables on exit to each basic block. This is equal to\n     /// the union of the `ins` for each successor.\n-    pub outs: IndexVec<BasicBlock, LocalSet>,\n+    pub outs: IndexVec<BasicBlock, LocalSet<V>>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -80,18 +80,18 @@ pub struct LivenessMode {\n }\n \n /// A combination of liveness results, used in NLL.\n-pub struct LivenessResults {\n+pub struct LivenessResults<V: Idx> {\n     /// Liveness results where a regular use makes a variable X live,\n     /// but not a drop.\n-    pub regular: LivenessResult,\n+    pub regular: LivenessResult<V>,\n \n     /// Liveness results where a drop makes a variable X live,\n     /// but not a regular use.\n-    pub drop: LivenessResult,\n+    pub drop: LivenessResult<V>,\n }\n \n-impl LivenessResults {\n-    pub fn compute<'tcx>(mir: &Mir<'tcx>) -> LivenessResults {\n+impl<V: Idx> LivenessResults<V> {\n+    pub fn compute<'tcx>(mir: &Mir<'tcx>) -> LivenessResults<V> {\n         LivenessResults {\n             regular: liveness_of_locals(\n                 &mir,\n@@ -115,7 +115,7 @@ impl LivenessResults {\n /// Compute which local variables are live within the given function\n /// `mir`. The liveness mode `mode` determines what sorts of uses are\n /// considered to make a variable live (e.g., do drops count?).\n-pub fn liveness_of_locals<'tcx>(mir: &Mir<'tcx>, mode: LivenessMode) -> LivenessResult {\n+pub fn liveness_of_locals<'tcx, V: Idx>(mir: &Mir<'tcx>, mode: LivenessMode) -> LivenessResult<V> {\n     let locals = mir.local_decls.len();\n     let def_use: IndexVec<_, _> = mir.basic_blocks()\n         .iter()\n@@ -156,14 +156,16 @@ pub fn liveness_of_locals<'tcx>(mir: &Mir<'tcx>, mode: LivenessMode) -> Liveness\n     LivenessResult { mode, outs }\n }\n \n-impl LivenessResult {\n+impl<V> LivenessResult<V>\n+where V:Idx\n+{\n     /// Walks backwards through the statements/terminator in the given\n     /// basic block `block`.  At each point within `block`, invokes\n     /// the callback `op` with the current location and the set of\n     /// variables that are live on entry to that location.\n     pub fn simulate_block<'tcx, OP>(&self, mir: &Mir<'tcx>, block: BasicBlock, mut callback: OP)\n     where\n-        OP: FnMut(Location, &LocalSet),\n+        OP: FnMut(Location, &LocalSet<V>),\n     {\n         let data = &mir[block];\n \n@@ -281,24 +283,25 @@ pub fn categorize<'tcx>(context: PlaceContext<'tcx>, mode: LivenessMode) -> Opti\n     }\n }\n \n-struct DefsUsesVisitor {\n+struct DefsUsesVisitor<V: Idx> {\n     mode: LivenessMode,\n-    defs_uses: DefsUses,\n+    defs_uses: DefsUses<V>,\n }\n \n #[derive(Eq, PartialEq, Clone)]\n-struct DefsUses {\n-    defs: LocalSet,\n-    uses: LocalSet,\n+struct DefsUses<V: Idx>\n+{\n+    defs: LocalSet<V>,\n+    uses: LocalSet<V>,\n }\n \n-impl DefsUses {\n+impl<V: Idx> DefsUses<V> {\n     fn clear(&mut self) {\n         self.uses.clear();\n         self.defs.clear();\n     }\n \n-    fn apply(&self, bits: &mut LocalSet) -> bool {\n+    fn apply(&self, bits: &mut LocalSet<V>) -> bool {\n         bits.subtract(&self.defs) | bits.union(&self.uses)\n     }\n \n@@ -332,23 +335,25 @@ impl DefsUses {\n     }\n }\n \n-impl DefsUsesVisitor {\n+impl<V> DefsUsesVisitor<V>\n+where V: Idx\n+{\n     /// Update `bits` with the effects of `value` and call `callback`. We\n     /// should always visit in reverse order. This method assumes that we have\n     /// not visited anything before; if you have, clear `bits` first.\n     fn update_bits_and_do_callback<'tcx, OP>(&mut self, location: Location,\n-                                             value: &impl MirVisitable<'tcx>, bits: &mut LocalSet,\n+                                             value: &impl MirVisitable<'tcx>, bits: &mut LocalSet<V>,\n                                              callback: &mut OP)\n     where\n-        OP: FnMut(Location, &LocalSet),\n+        OP: FnMut(Location, &LocalSet<V>),\n     {\n         value.apply(location, self);\n         self.defs_uses.apply(bits);\n         callback(location, bits);\n     }\n }\n \n-impl<'tcx> Visitor<'tcx> for DefsUsesVisitor {\n+impl<'tcx, V: Idx> Visitor<'tcx> for DefsUsesVisitor<V> {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, _: Location) {\n         match categorize(context, self.mode) {\n             Some(DefUse::Def) => {\n@@ -364,7 +369,7 @@ impl<'tcx> Visitor<'tcx> for DefsUsesVisitor {\n     }\n }\n \n-fn block<'tcx>(mode: LivenessMode, b: &BasicBlockData<'tcx>, locals: usize) -> DefsUses {\n+fn block<'tcx, V: Idx>(mode: LivenessMode, b: &BasicBlockData<'tcx>, locals: usize) -> DefsUses<V> {\n     let mut visitor = DefsUsesVisitor {\n         mode,\n         defs_uses: DefsUses {\n@@ -388,12 +393,12 @@ fn block<'tcx>(mode: LivenessMode, b: &BasicBlockData<'tcx>, locals: usize) -> D\n     visitor.defs_uses\n }\n \n-pub fn dump_mir<'a, 'tcx>(\n+pub fn dump_mir<'a, 'tcx, V: Idx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pass_name: &str,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n-    result: &LivenessResult,\n+    result: &LivenessResult<V>,\n ) {\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n@@ -405,13 +410,13 @@ pub fn dump_mir<'a, 'tcx>(\n     dump_matched_mir_node(tcx, pass_name, &node_path, source, mir, result);\n }\n \n-fn dump_matched_mir_node<'a, 'tcx>(\n+fn dump_matched_mir_node<'a, 'tcx, V: Idx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pass_name: &str,\n     node_path: &str,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n-    result: &LivenessResult,\n+    result: &LivenessResult<V>,\n ) {\n     let mut file_path = PathBuf::new();\n     file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n@@ -428,12 +433,12 @@ fn dump_matched_mir_node<'a, 'tcx>(\n     });\n }\n \n-pub fn write_mir_fn<'a, 'tcx>(\n+pub fn write_mir_fn<'a, 'tcx, V :Idx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     src: MirSource,\n     mir: &Mir<'tcx>,\n     w: &mut dyn Write,\n-    result: &LivenessResult,\n+    result: &LivenessResult<V>,\n ) -> io::Result<()> {\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {"}]}