{"sha": "f41a510631ca8e41f16c8a0097a179d067ce4f7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0MWE1MTA2MzFjYThlNDFmMTZjOGEwMDk3YTE3OWQwNjdjZTRmN2Q=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-27T03:52:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-27T04:30:18Z"}, "message": "librustc: Remove obsolete syntax", "tree": {"sha": "90efcc825f9341632886b71034cacd82997fd3a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90efcc825f9341632886b71034cacd82997fd3a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f41a510631ca8e41f16c8a0097a179d067ce4f7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f41a510631ca8e41f16c8a0097a179d067ce4f7d", "html_url": "https://github.com/rust-lang/rust/commit/f41a510631ca8e41f16c8a0097a179d067ce4f7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f41a510631ca8e41f16c8a0097a179d067ce4f7d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8", "html_url": "https://github.com/rust-lang/rust/commit/0a4d0f37ca97bb0b69f5f9e768269dde4acedae8"}], "stats": {"total": 66, "additions": 46, "deletions": 20}, "files": [{"sha": "8ca65606fe285ce775df0ecd88aedcec46c7319d", "filename": "src/libcore/str.rs", "status": "modified", "additions": 42, "deletions": 16, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f41a510631ca8e41f16c8a0097a179d067ce4f7d/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f41a510631ca8e41f16c8a0097a179d067ce4f7d/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=f41a510631ca8e41f16c8a0097a179d067ce4f7d", "patch": "@@ -435,12 +435,14 @@ pub fn slice<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n }\n \n /// Splits a string into substrings at each occurrence of a given character\n-pub fn each_split_char(s: &'a str, sep: char, it: &fn(&'a str) -> bool) {\n+pub fn each_split_char<'a>(s: &'a str, sep: char, it: &fn(&'a str) -> bool) {\n     each_split_char_inner(s, sep, len(s), true, true, it)\n }\n \n /// Like `each_split_char`, but a trailing empty string is omitted\n-pub fn each_split_char_no_trailing(s: &'a str, sep: char, it: &fn(&'a str) -> bool) {\n+pub fn each_split_char_no_trailing<'a>(s: &'a str,\n+                                       sep: char,\n+                                       it: &fn(&'a str) -> bool) {\n     each_split_char_inner(s, sep, len(s), true, false, it)\n }\n \n@@ -450,17 +452,26 @@ pub fn each_split_char_no_trailing(s: &'a str, sep: char, it: &fn(&'a str) -> bo\n  *\n  * The character must be a valid UTF-8/ASCII character\n  */\n-pub fn each_splitn_char(s: &'a str, sep: char, count: uint, it: &fn(&'a str) -> bool) {\n+pub fn each_splitn_char<'a>(s: &'a str,\n+                            sep: char,\n+                            count: uint,\n+                            it: &fn(&'a str) -> bool) {\n     each_split_char_inner(s, sep, count, true, true, it)\n }\n \n /// Like `each_split_char`, but omits empty strings\n-pub fn each_split_char_nonempty(s: &'a str, sep: char, it: &fn(&'a str) -> bool) {\n+pub fn each_split_char_nonempty<'a>(s: &'a str,\n+                                    sep: char,\n+                                    it: &fn(&'a str) -> bool) {\n     each_split_char_inner(s, sep, len(s), false, false, it)\n }\n \n-fn each_split_char_inner(s: &'a str, sep: char, count: uint, allow_empty: bool,\n-                         allow_trailing_empty: bool, it: &fn(&'a str) -> bool) {\n+fn each_split_char_inner<'a>(s: &'a str,\n+                             sep: char,\n+                             count: uint,\n+                             allow_empty: bool,\n+                             allow_trailing_empty: bool,\n+                             it: &fn(&'a str) -> bool) {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n         let mut done = 0u;\n@@ -485,30 +496,43 @@ fn each_split_char_inner(s: &'a str, sep: char, count: uint, allow_empty: bool,\n }\n \n /// Splits a string into substrings using a character function\n-pub fn each_split(s: &'a str, sepfn: &fn(char) -> bool, it: &fn(&'a str) -> bool) {\n+pub fn each_split<'a>(s: &'a str,\n+                      sepfn: &fn(char) -> bool,\n+                      it: &fn(&'a str) -> bool) {\n     each_split_inner(s, sepfn, len(s), true, true, it)\n }\n \n /// Like `each_split`, but a trailing empty string is omitted\n-pub fn each_split_no_trailing(s: &'a str, sepfn: &fn(char) -> bool, it: &fn(&'a str) -> bool) {\n+pub fn each_split_no_trailing<'a>(s: &'a str,\n+                                  sepfn: &fn(char) -> bool,\n+                                  it: &fn(&'a str) -> bool) {\n     each_split_inner(s, sepfn, len(s), true, false, it)\n }\n \n /**\n  * Splits a string into substrings using a character function, cutting at\n  * most `count` times.\n  */\n-pub fn each_splitn(s: &'a str, sepfn: &fn(char) -> bool, count: uint, it: &fn(&'a str) -> bool) {\n+pub fn each_splitn<'a>(s: &'a str,\n+                       sepfn: &fn(char) -> bool,\n+                       count: uint,\n+                       it: &fn(&'a str) -> bool) {\n     each_split_inner(s, sepfn, count, true, true, it)\n }\n \n /// Like `each_split`, but omits empty strings\n-pub fn each_split_nonempty(s: &'a str, sepfn: &fn(char) -> bool, it: &fn(&'a str) -> bool) {\n+pub fn each_split_nonempty<'a>(s: &'a str,\n+                               sepfn: &fn(char) -> bool,\n+                               it: &fn(&'a str) -> bool) {\n     each_split_inner(s, sepfn, len(s), false, false, it)\n }\n \n-fn each_split_inner(s: &'a str, sepfn: &fn(cc: char) -> bool, count: uint,\n-                    allow_empty: bool, allow_trailing_empty: bool, it: &fn(&'a str) -> bool) {\n+fn each_split_inner<'a>(s: &'a str,\n+                        sepfn: &fn(cc: char) -> bool,\n+                        count: uint,\n+                        allow_empty: bool,\n+                        allow_trailing_empty: bool,\n+                        it: &fn(&'a str) -> bool) {\n     let l = len(s);\n     let mut i = 0u, start = 0u, done = 0u;\n     while i < l && done < count {\n@@ -632,15 +656,15 @@ pub fn levdistance(s: &str, t: &str) -> uint {\n /**\n  * Splits a string into substrings separated by LF ('\\n').\n  */\n-pub fn each_line(s: &'a str, it: &fn(&'a str) -> bool) {\n+pub fn each_line<'a>(s: &'a str, it: &fn(&'a str) -> bool) {\n     each_split_char_no_trailing(s, '\\n', it)\n }\n \n /**\n  * Splits a string into substrings separated by LF ('\\n')\n  * and/or CR LF (\"\\r\\n\")\n  */\n-pub fn each_line_any(s: &'a str, it: &fn(&'a str) -> bool) {\n+pub fn each_line_any<'a>(s: &'a str, it: &fn(&'a str) -> bool) {\n     for each_line(s) |s| {\n         let l = s.len();\n         if l > 0u && s[l - 1u] == '\\r' as u8 {\n@@ -652,7 +676,7 @@ pub fn each_line_any(s: &'a str, it: &fn(&'a str) -> bool) {\n }\n \n /// Splits a string into substrings separated by whitespace\n-pub fn each_word(s: &'a str, it: &fn(&'a str) -> bool) {\n+pub fn each_word<'a>(s: &'a str, it: &fn(&'a str) -> bool) {\n     each_split_nonempty(s, char::is_whitespace, it)\n }\n \n@@ -665,7 +689,9 @@ pub fn each_word(s: &'a str, it: &fn(&'a str) -> bool) {\n  *  Fails during iteration if the string contains a non-whitespace\n  *  sequence longer than the limit.\n  */\n-pub fn each_split_within(ss: &'a str, lim: uint, it: &fn(&'a str) -> bool) {\n+pub fn each_split_within<'a>(ss: &'a str,\n+                             lim: uint,\n+                             it: &fn(&'a str) -> bool) {\n     // Just for fun, let's write this as an state machine:\n \n     enum SplitWithinState {"}, {"sha": "e1e6f557c8376507e1f47358d6563a3f0b71cee1", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f41a510631ca8e41f16c8a0097a179d067ce4f7d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f41a510631ca8e41f16c8a0097a179d067ce4f7d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=f41a510631ca8e41f16c8a0097a179d067ce4f7d", "patch": "@@ -32,7 +32,7 @@ use syntax::{visit, ast_util, ast_map};\n \n pub type map = @LinearSet<node_id>;\n \n-struct ctx {\n+struct ctx<'self> {\n     exp_map2: resolve::ExportMap2,\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n@@ -152,7 +152,7 @@ fn mk_ty_visitor() -> visit::vt<ctx> {\n                                   ..*visit::default_visitor()})\n }\n \n-fn traverse_ty(ty: @Ty, cx: ctx<'a>, v: visit::vt<ctx<'a>>) {\n+fn traverse_ty<'a>(ty: @Ty, cx: ctx<'a>, v: visit::vt<ctx<'a>>) {\n     // XXX: it shouldn't be necessary to do this\n     let rmap: &mut LinearSet<node_id> = cx.rmap;\n     if rmap.contains(&ty.id) { return; }\n@@ -176,7 +176,7 @@ fn traverse_ty(ty: @Ty, cx: ctx<'a>, v: visit::vt<ctx<'a>>) {\n }\n \n fn traverse_inline_body(cx: ctx, body: &blk) {\n-    fn traverse_expr(e: @expr, cx: ctx<'a>, v: visit::vt<ctx<'a>>) {\n+    fn traverse_expr<'a>(e: @expr, cx: ctx<'a>, v: visit::vt<ctx<'a>>) {\n         match e.node {\n           expr_path(_) => {\n             match cx.tcx.def_map.find(&e.id) {"}, {"sha": "cdc15ae1d45dcec5bb4cd7b8528464486c29ef09", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f41a510631ca8e41f16c8a0097a179d067ce4f7d/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f41a510631ca8e41f16c8a0097a179d067ce4f7d/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=f41a510631ca8e41f16c8a0097a179d067ce4f7d", "patch": "@@ -16,7 +16,7 @@ pub trait ToBase64 {\n     fn to_base64(&self) -> ~str;\n }\n \n-static CHARS: [char * 64] = [\n+static CHARS: [char, ..64] = [\n     'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n     'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n     'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',"}]}