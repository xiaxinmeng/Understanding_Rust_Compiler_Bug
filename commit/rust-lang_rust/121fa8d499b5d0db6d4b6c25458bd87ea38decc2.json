{"sha": "121fa8d499b5d0db6d4b6c25458bd87ea38decc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMWZhOGQ0OTliNWQwZGI2ZDRiNmMyNTQ1OGJkODdlYTM4ZGVjYzI=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-20T00:54:22Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-16T19:09:04Z"}, "message": "Fix handling of signed integers", "tree": {"sha": "ac375018a474810efc8f2bb75b72ff193d3b3300", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac375018a474810efc8f2bb75b72ff193d3b3300"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/121fa8d499b5d0db6d4b6c25458bd87ea38decc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/121fa8d499b5d0db6d4b6c25458bd87ea38decc2", "html_url": "https://github.com/rust-lang/rust/commit/121fa8d499b5d0db6d4b6c25458bd87ea38decc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/121fa8d499b5d0db6d4b6c25458bd87ea38decc2/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8702a0b1dd66f422d2666de1d50c344c0f008c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8702a0b1dd66f422d2666de1d50c344c0f008c0", "html_url": "https://github.com/rust-lang/rust/commit/b8702a0b1dd66f422d2666de1d50c344c0f008c0"}], "stats": {"total": 56, "additions": 44, "deletions": 12}, "files": [{"sha": "03b1ea44c753dac6b7c9bd4fb5eadd4cdbc9e45c", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/121fa8d499b5d0db6d4b6c25458bd87ea38decc2/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/121fa8d499b5d0db6d4b6c25458bd87ea38decc2/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=121fa8d499b5d0db6d4b6c25458bd87ea38decc2", "patch": "@@ -469,20 +469,16 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         ty::TyInt(int_ty) if exhaustive_integer_patterns => {\n             use syntax::ast::IntTy::*;\n             let (min, max, ty) = match int_ty {\n-                Isize => (isize::MIN as i128, isize::MAX as i128, cx.tcx.types.isize),\n-                I8    => (   i8::MIN as i128,    i8::MAX as i128, cx.tcx.types.i8),\n-                I16   => (  i16::MIN as i128,   i16::MAX as i128, cx.tcx.types.i16),\n-                I32   => (  i32::MIN as i128,   i32::MAX as i128, cx.tcx.types.i32),\n-                I64   => (  i64::MIN as i128,   i64::MAX as i128, cx.tcx.types.i64),\n-                I128  => ( i128::MIN as i128,  i128::MAX as i128, cx.tcx.types.i128),\n+                Isize => (isize::MIN as usize as u128, isize::MAX as usize as u128, cx.tcx.types.isize),\n+                I8    => (   i8::MIN as u8 as u128,    i8::MAX as u8 as u128, cx.tcx.types.i8),\n+                I16   => (  i16::MIN as u16 as u128,   i16::MAX as u16 as u128, cx.tcx.types.i16),\n+                I32   => (  i32::MIN as u32 as u128,   i32::MAX as u32 as u128, cx.tcx.types.i32),\n+                I64   => (  i64::MIN as u64 as u128,   i64::MAX as u64 as u128, cx.tcx.types.i64),\n+                I128  => ( i128::MIN as u128 as u128,  i128::MAX as u128 as u128, cx.tcx.types.i128),\n             };\n             value_constructors = true;\n-            vec![ConstantRange(ty::Const::from_bits(cx.tcx, unsafe {\n-                                   transmute::<i128, u128>(min)\n-                               }, ty),\n-                               ty::Const::from_bits(cx.tcx, unsafe {\n-                                   transmute::<i128, u128>(max)\n-                               }, ty),\n+            vec![ConstantRange(ty::Const::from_bits(cx.tcx, min, ty),\n+                               ty::Const::from_bits(cx.tcx, max, ty),\n                                RangeEnd::Included)]\n         }\n         ty::TyUint(uint_ty) if exhaustive_integer_patterns => {\n@@ -628,6 +624,9 @@ impl<'tcx> Interval<'tcx> {\n                 let ty = lo.ty;\n                 if let Some(lo) = lo.assert_bits(ty) {\n                     if let Some(hi) = hi.assert_bits(ty) {\n+                        // Perform a shift if the underlying types are signed,\n+                        // which makes the interval arithmetic simpler.\n+                        let (lo, hi) = Interval::offset_sign(ty, (lo, hi), true);\n                         // Make sure the interval is well-formed.\n                         return if lo > hi || lo == hi && *end == RangeEnd::Excluded {\n                             None\n@@ -649,6 +648,38 @@ impl<'tcx> Interval<'tcx> {\n         }\n     }\n \n+    fn offset_sign(ty: Ty<'tcx>, (lo, hi): (u128, u128), forwards: bool) -> (u128, u128) {\n+        use syntax::ast::IntTy::*;\n+        match ty.sty {\n+            ty::TyInt(int_ty) => {\n+                macro_rules! offset_sign_for_ty {\n+                    ($ity:ty, $uty:ty, $min:expr) => {{\n+                        let min = Wrapping($min as $uty);\n+                        if forwards {\n+                            ((Wrapping(lo as $uty) + min).0 as u128,\n+                             (Wrapping(hi as $uty) + min).0 as u128)\n+                        } else {\n+                            ((Wrapping(lo as $uty) + min).0 as $ity as u128,\n+                             (Wrapping(hi as $uty) + min).0 as $ity as u128)\n+                        }\n+                    }}\n+                }\n+                match int_ty {\n+                    Isize => offset_sign_for_ty!(isize, usize, isize::MIN),\n+                    I8    => offset_sign_for_ty!(i8, u8, i8::MIN),\n+                    I16   => offset_sign_for_ty!(i16, u16, i16::MIN),\n+                    I32   => offset_sign_for_ty!(i32, u32, i32::MIN),\n+                    I64   => offset_sign_for_ty!(i64, u64, i64::MIN),\n+                    I128  => offset_sign_for_ty!(i128, u128, i128::MIN),\n+                }\n+            }\n+            ty::TyUint(_) | ty::TyChar => {\n+                (lo, hi)\n+            }\n+            _ => bug!(\"`Interval` should only contain integer types\")\n+        }\n+    }\n+\n     fn into_inner(self) -> (u128, u128) {\n         (self.lo, self.hi)\n     }\n@@ -692,6 +723,7 @@ fn ranges_subtract_pattern<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         // Convert the remaining ranges from pairs to inclusive `ConstantRange`s.\n         let ty = pat_interval.ty;\n         remaining_ranges.into_iter().map(|(lo, hi)| {\n+            let (lo, hi) = Interval::offset_sign(ty, (lo, hi), false);\n             ConstantRange(ty::Const::from_bits(cx.tcx, lo, ty),\n                           ty::Const::from_bits(cx.tcx, hi, ty),\n                           RangeEnd::Included)"}]}