{"sha": "ecae3d74e26b8f10322060954fbc2a6c4ba92402", "node_id": "C_kwDOAAsO6NoAKGVjYWUzZDc0ZTI2YjhmMTAzMjIwNjA5NTRmYmMyYTZjNGJhOTI0MDI", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-14T13:54:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-14T13:54:04Z"}, "message": "Rollup merge of #99000 - JulianKnodt:allow_resolve_no_substs, r=lcnr\n\nMove abstract const to middle\n\nMoves AbstractConst (and all associated methods) to rustc middle for use in `rustc_infer`.\nThis allows for const resolution in infer to use abstract consts to walk consts and check if\nthey are resolvable.\n\nThis attempts to resolve the issue where `Foo<{ concrete const }, generic T>` is incorrectly marked as conflicting, and is independent from the other issue where nested abstract consts must be resolved.\n\nr? `@lcnr`", "tree": {"sha": "22fce1b96af296f285880e54f300fa8c067cdadf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22fce1b96af296f285880e54f300fa8c067cdadf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecae3d74e26b8f10322060954fbc2a6c4ba92402", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi0B/8CRBK7hj4Ov3rIwAAPegIAFrtBAF5kFFsxUhfjJApkOv5\neNnCWDx/AUP9TYfDzWy9+EC+gT4mgd3UgHnvsDZhH81YXMC9dRpnR0wJa/V2F6tP\n7em3FBAae+cKccqfMRSXncbS+v2jWT431UM/f3/hh5ySSzZEHWQJj+0l91L9HAgt\nGOo/2i4Ql/c5LcKd4pUgfUHKo35L0oHwCroORpWJR2Gjvzy/IyoOIL+kJ918Tt6r\ndjr6ArRMO5dkx6z3dReC0A5qWVkdr+rmt6ZPVQ/pAUFeieKb4js3sC4dEB7mM+KS\npJRcChu2GPF6DRZqsAX3xLE7WJULNsiPqutnAdF/WUrLigB7SX7m+NQ8Vwmr4Ns=\n=q7VP\n-----END PGP SIGNATURE-----\n", "payload": "tree 22fce1b96af296f285880e54f300fa8c067cdadf\nparent 8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec\nparent 20fb8aba8f39e257e7003918f9a299633511511b\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1657806844 +0530\ncommitter GitHub <noreply@github.com> 1657806844 +0530\n\nRollup merge of #99000 - JulianKnodt:allow_resolve_no_substs, r=lcnr\n\nMove abstract const to middle\n\nMoves AbstractConst (and all associated methods) to rustc middle for use in `rustc_infer`.\nThis allows for const resolution in infer to use abstract consts to walk consts and check if\nthey are resolvable.\n\nThis attempts to resolve the issue where `Foo<{ concrete const }, generic T>` is incorrectly marked as conflicting, and is independent from the other issue where nested abstract consts must be resolved.\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecae3d74e26b8f10322060954fbc2a6c4ba92402", "html_url": "https://github.com/rust-lang/rust/commit/ecae3d74e26b8f10322060954fbc2a6c4ba92402", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecae3d74e26b8f10322060954fbc2a6c4ba92402/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "html_url": "https://github.com/rust-lang/rust/commit/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec"}, {"sha": "20fb8aba8f39e257e7003918f9a299633511511b", "url": "https://api.github.com/repos/rust-lang/rust/commits/20fb8aba8f39e257e7003918f9a299633511511b", "html_url": "https://github.com/rust-lang/rust/commit/20fb8aba8f39e257e7003918f9a299633511511b"}], "stats": {"total": 1549, "additions": 799, "deletions": 750}, "files": [{"sha": "147d47044078a9fa7e8896fac80fd788c315bb41", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -4514,6 +4514,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n+ \"rustc_index\",\n  \"rustc_infer\",\n  \"rustc_middle\",\n  \"rustc_session\","}, {"sha": "881682678dbed3c040ae3635923cb240f0f0f2fa", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -21,6 +21,7 @@ use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n use rustc_middle::mir::interpret::{ErrorHandled, EvalToValTreeResult};\n use rustc_middle::traits::select;\n+use rustc_middle::ty::abstract_const::AbstractConst;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::relate::RelateResult;\n@@ -1651,14 +1652,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         unevaluated: ty::Unevaluated<'tcx>,\n         span: Option<Span>,\n     ) -> EvalToValTreeResult<'tcx> {\n-        let substs = self.resolve_vars_if_possible(unevaluated.substs);\n+        let mut substs = self.resolve_vars_if_possible(unevaluated.substs);\n         debug!(?substs);\n \n         // Postpone the evaluation of constants whose substs depend on inference\n         // variables\n         if substs.has_infer_types_or_consts() {\n-            debug!(\"substs have infer types or consts: {:?}\", substs);\n-            return Err(ErrorHandled::TooGeneric);\n+            let ac = AbstractConst::new(self.tcx, unevaluated.shrink());\n+            if let Ok(None) = ac {\n+                substs = InternalSubsts::identity_for_item(self.tcx, unevaluated.def.did);\n+            } else {\n+                return Err(ErrorHandled::TooGeneric);\n+            }\n         }\n \n         let param_env_erased = self.tcx.erase_regions(param_env);"}, {"sha": "f0874f8f2da00374f8f7fb773fbfa308329b822d", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -21,7 +21,6 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n-use rustc_middle::thir;\n use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::GeneratorDiagnosticData;\n@@ -638,7 +637,7 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n     }\n }\n \n-impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [thir::abstract_const::Node<'tcx>] {\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [ty::abstract_const::Node<'tcx>] {\n     fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Self {\n         ty::codec::RefDecodable::decode(d)\n     }"}, {"sha": "a5a9dbb8da2e8dc8dca2aa965361728b30ea7a87", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -17,7 +17,6 @@ use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n use rustc_middle::mir;\n-use rustc_middle::thir;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, ReprOptions, Ty};\n@@ -361,7 +360,7 @@ define_tables! {\n     mir_for_ctfe: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n     promoted_mir: Table<DefIndex, LazyValue<IndexVec<mir::Promoted, mir::Body<'static>>>>,\n     // FIXME(compiler-errors): Why isn't this a LazyArray?\n-    thir_abstract_const: Table<DefIndex, LazyValue<&'static [thir::abstract_const::Node<'static>]>>,\n+    thir_abstract_const: Table<DefIndex, LazyValue<&'static [ty::abstract_const::Node<'static>]>>,\n     impl_parent: Table<DefIndex, RawDefId>,\n     impl_polarity: Table<DefIndex, ty::ImplPolarity>,\n     constness: Table<DefIndex, hir::Constness>,"}, {"sha": "bdae7e5fcd6b1b446204c6c5e64cc4387e53235d", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -351,7 +351,7 @@ rustc_queries! {\n     /// Try to build an abstract representation of the given constant.\n     query thir_abstract_const(\n         key: DefId\n-    ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n+    ) -> Result<Option<&'tcx [ty::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n         desc {\n             |tcx| \"building an abstract representation for {}\", tcx.def_path_str(key),\n         }\n@@ -360,7 +360,7 @@ rustc_queries! {\n     /// Try to build an abstract representation of the given constant.\n     query thir_abstract_const_of_const_arg(\n         key: (LocalDefId, DefId)\n-    ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n+    ) -> Result<Option<&'tcx [ty::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n         desc {\n             |tcx|\n             \"building an abstract representation for the const argument {}\","}, {"sha": "36db8d04918b02830088db7867b50f39a8cab027", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -30,7 +30,6 @@ use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::fmt;\n use std::ops::Index;\n \n-pub mod abstract_const;\n pub mod visit;\n \n newtype_index! {"}, {"sha": "527dbd1cd090aa71ebdf677c498a3a93133903a9", "filename": "compiler/rustc_middle/src/thir/abstract_const.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fabstract_const.rs?ref=8c5c983e5bb491682b57a9bbe33be4f2b94fa2ec", "patch": "@@ -1,61 +0,0 @@\n-//! A subset of a mir body used for const evaluatability checking.\n-use crate::mir;\n-use crate::ty::{self, Ty, TyCtxt};\n-use rustc_errors::ErrorGuaranteed;\n-\n-rustc_index::newtype_index! {\n-    /// An index into an `AbstractConst`.\n-    pub struct NodeId {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"n{}\",\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n-pub enum CastKind {\n-    /// thir::ExprKind::As\n-    As,\n-    /// thir::ExprKind::Use\n-    Use,\n-}\n-\n-/// A node of an `AbstractConst`.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n-pub enum Node<'tcx> {\n-    Leaf(ty::Const<'tcx>),\n-    Binop(mir::BinOp, NodeId, NodeId),\n-    UnaryOp(mir::UnOp, NodeId),\n-    FunctionCall(NodeId, &'tcx [NodeId]),\n-    Cast(CastKind, NodeId, Ty<'tcx>),\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n-pub enum NotConstEvaluatable {\n-    Error(ErrorGuaranteed),\n-    MentionsInfer,\n-    MentionsParam,\n-}\n-\n-impl From<ErrorGuaranteed> for NotConstEvaluatable {\n-    fn from(e: ErrorGuaranteed) -> NotConstEvaluatable {\n-        NotConstEvaluatable::Error(e)\n-    }\n-}\n-\n-TrivialTypeTraversalAndLiftImpls! {\n-    NotConstEvaluatable,\n-}\n-\n-impl<'tcx> TyCtxt<'tcx> {\n-    #[inline]\n-    pub fn thir_abstract_const_opt_const_arg(\n-        self,\n-        def: ty::WithOptConstParam<rustc_hir::def_id::DefId>,\n-    ) -> Result<Option<&'tcx [Node<'tcx>]>, ErrorGuaranteed> {\n-        if let Some((did, param_did)) = def.as_const_arg() {\n-            self.thir_abstract_const_of_const_arg((did, param_did))\n-        } else {\n-            self.thir_abstract_const(def.did)\n-        }\n-    }\n-}"}, {"sha": "955f2bdfa1d916561b931349defa7319fc19d071", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -10,7 +10,7 @@ mod structural_impls;\n pub mod util;\n \n use crate::infer::canonical::Canonical;\n-use crate::thir::abstract_const::NotConstEvaluatable;\n+use crate::ty::abstract_const::NotConstEvaluatable;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtKind, Ty, TyCtxt};\n "}, {"sha": "bed809930da615d61eff49b2ed099036fdfe90db", "filename": "compiler/rustc_middle/src/ty/abstract_const.rs", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -0,0 +1,194 @@\n+//! A subset of a mir body used for const evaluatability checking.\n+use crate::mir;\n+use crate::ty::visit::TypeVisitable;\n+use crate::ty::{self, subst::Subst, DelaySpanBugEmitted, EarlyBinder, SubstsRef, Ty, TyCtxt};\n+use rustc_errors::ErrorGuaranteed;\n+use rustc_hir::def_id::DefId;\n+use std::cmp;\n+use std::ops::ControlFlow;\n+\n+rustc_index::newtype_index! {\n+    /// An index into an `AbstractConst`.\n+    pub struct NodeId {\n+        derive [HashStable]\n+        DEBUG_FORMAT = \"n{}\",\n+    }\n+}\n+\n+/// A tree representing an anonymous constant.\n+///\n+/// This is only able to represent a subset of `MIR`,\n+/// and should not leak any information about desugarings.\n+#[derive(Debug, Clone, Copy)]\n+pub struct AbstractConst<'tcx> {\n+    // FIXME: Consider adding something like `IndexSlice`\n+    // and use this here.\n+    inner: &'tcx [Node<'tcx>],\n+    substs: SubstsRef<'tcx>,\n+}\n+\n+impl<'tcx> AbstractConst<'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        uv: ty::Unevaluated<'tcx, ()>,\n+    ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n+        let inner = tcx.thir_abstract_const_opt_const_arg(uv.def)?;\n+        debug!(\"AbstractConst::new({:?}) = {:?}\", uv, inner);\n+        Ok(inner.map(|inner| AbstractConst { inner, substs: tcx.erase_regions(uv.substs) }))\n+    }\n+\n+    pub fn from_const(\n+        tcx: TyCtxt<'tcx>,\n+        ct: ty::Const<'tcx>,\n+    ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n+        match ct.kind() {\n+            ty::ConstKind::Unevaluated(uv) => AbstractConst::new(tcx, uv.shrink()),\n+            ty::ConstKind::Error(DelaySpanBugEmitted { reported, .. }) => Err(reported),\n+            _ => Ok(None),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn subtree(self, node: NodeId) -> AbstractConst<'tcx> {\n+        AbstractConst { inner: &self.inner[..=node.index()], substs: self.substs }\n+    }\n+\n+    #[inline]\n+    pub fn root(self, tcx: TyCtxt<'tcx>) -> Node<'tcx> {\n+        let node = self.inner.last().copied().unwrap();\n+        match node {\n+            Node::Leaf(leaf) => Node::Leaf(EarlyBinder(leaf).subst(tcx, self.substs)),\n+            Node::Cast(kind, operand, ty) => {\n+                Node::Cast(kind, operand, EarlyBinder(ty).subst(tcx, self.substs))\n+            }\n+            // Don't perform substitution on the following as they can't directly contain generic params\n+            Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => node,\n+        }\n+    }\n+\n+    pub fn unify_failure_kind(self, tcx: TyCtxt<'tcx>) -> FailureKind {\n+        let mut failure_kind = FailureKind::Concrete;\n+        walk_abstract_const::<!, _>(tcx, self, |node| {\n+            match node.root(tcx) {\n+                Node::Leaf(leaf) => {\n+                    if leaf.has_infer_types_or_consts() {\n+                        failure_kind = FailureKind::MentionsInfer;\n+                    } else if leaf.has_param_types_or_consts() {\n+                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n+                    }\n+                }\n+                Node::Cast(_, _, ty) => {\n+                    if ty.has_infer_types_or_consts() {\n+                        failure_kind = FailureKind::MentionsInfer;\n+                    } else if ty.has_param_types_or_consts() {\n+                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n+                    }\n+                }\n+                Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => {}\n+            }\n+            ControlFlow::CONTINUE\n+        });\n+        failure_kind\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub enum CastKind {\n+    /// thir::ExprKind::As\n+    As,\n+    /// thir::ExprKind::Use\n+    Use,\n+}\n+\n+/// A node of an `AbstractConst`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub enum Node<'tcx> {\n+    Leaf(ty::Const<'tcx>),\n+    Binop(mir::BinOp, NodeId, NodeId),\n+    UnaryOp(mir::UnOp, NodeId),\n+    FunctionCall(NodeId, &'tcx [NodeId]),\n+    Cast(CastKind, NodeId, Ty<'tcx>),\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+pub enum NotConstEvaluatable {\n+    Error(ErrorGuaranteed),\n+    MentionsInfer,\n+    MentionsParam,\n+}\n+\n+impl From<ErrorGuaranteed> for NotConstEvaluatable {\n+    fn from(e: ErrorGuaranteed) -> NotConstEvaluatable {\n+        NotConstEvaluatable::Error(e)\n+    }\n+}\n+\n+TrivialTypeTraversalAndLiftImpls! {\n+    NotConstEvaluatable,\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    #[inline]\n+    pub fn thir_abstract_const_opt_const_arg(\n+        self,\n+        def: ty::WithOptConstParam<DefId>,\n+    ) -> Result<Option<&'tcx [Node<'tcx>]>, ErrorGuaranteed> {\n+        if let Some((did, param_did)) = def.as_const_arg() {\n+            self.thir_abstract_const_of_const_arg((did, param_did))\n+        } else {\n+            self.thir_abstract_const(def.did)\n+        }\n+    }\n+}\n+\n+#[instrument(skip(tcx, f), level = \"debug\")]\n+pub fn walk_abstract_const<'tcx, R, F>(\n+    tcx: TyCtxt<'tcx>,\n+    ct: AbstractConst<'tcx>,\n+    mut f: F,\n+) -> ControlFlow<R>\n+where\n+    F: FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n+{\n+    #[instrument(skip(tcx, f), level = \"debug\")]\n+    fn recurse<'tcx, R>(\n+        tcx: TyCtxt<'tcx>,\n+        ct: AbstractConst<'tcx>,\n+        f: &mut dyn FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n+    ) -> ControlFlow<R> {\n+        f(ct)?;\n+        let root = ct.root(tcx);\n+        debug!(?root);\n+        match root {\n+            Node::Leaf(_) => ControlFlow::CONTINUE,\n+            Node::Binop(_, l, r) => {\n+                recurse(tcx, ct.subtree(l), f)?;\n+                recurse(tcx, ct.subtree(r), f)\n+            }\n+            Node::UnaryOp(_, v) => recurse(tcx, ct.subtree(v), f),\n+            Node::FunctionCall(func, args) => {\n+                recurse(tcx, ct.subtree(func), f)?;\n+                args.iter().try_for_each(|&arg| recurse(tcx, ct.subtree(arg), f))\n+            }\n+            Node::Cast(_, operand, _) => recurse(tcx, ct.subtree(operand), f),\n+        }\n+    }\n+\n+    recurse(tcx, ct, &mut f)\n+}\n+\n+// We were unable to unify the abstract constant with\n+// a constant found in the caller bounds, there are\n+// now three possible cases here.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum FailureKind {\n+    /// The abstract const still references an inference\n+    /// variable, in this case we return `TooGeneric`.\n+    MentionsInfer,\n+    /// The abstract const references a generic parameter,\n+    /// this means that we emit an error here.\n+    MentionsParam,\n+    /// The substs are concrete enough that we can simply\n+    /// try and evaluate the given constant.\n+    Concrete,\n+}"}, {"sha": "e6ea3d88853763217b44ea5b0643ba435b64d4e1", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -12,7 +12,6 @@ use crate::mir::{\n     self,\n     interpret::{AllocId, ConstAllocation},\n };\n-use crate::thir;\n use crate::traits;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtDef, Ty};\n@@ -346,7 +345,7 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n }\n \n impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n-    for [thir::abstract_const::Node<'tcx>]\n+    for [ty::abstract_const::Node<'tcx>]\n {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         decoder.interner().arena.alloc_from_iter(\n@@ -356,7 +355,7 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n }\n \n impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n-    for [thir::abstract_const::NodeId]\n+    for [ty::abstract_const::NodeId]\n {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         decoder.interner().arena.alloc_from_iter("}, {"sha": "f0acb02933a68c895f5f3cad211af3a7db6e6d89", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -92,6 +92,7 @@ pub use self::sty::{\n pub use self::trait_def::TraitDef;\n \n pub mod _match;\n+pub mod abstract_const;\n pub mod adjustment;\n pub mod binding;\n pub mod cast;"}, {"sha": "e189ee2fc4db12023454c91fe5aa1669da6b487a", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -3,7 +3,7 @@ use rustc_index::vec::{Idx, IndexVec};\n \n use crate::middle::exported_symbols::ExportedSymbol;\n use crate::mir::Body;\n-use crate::thir::abstract_const::Node;\n+use crate::ty::abstract_const::Node;\n use crate::ty::{\n     self, Const, FnSig, GeneratorDiagnosticData, GenericPredicates, Predicate, TraitRef, Ty,\n };"}, {"sha": "4e73c26d35f2f250e36e1abc622e625b2b8b6f48", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -23,7 +23,7 @@ use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n use rustc_middle::span_bug;\n-use rustc_middle::thir::abstract_const::Node as ACNode;\n+use rustc_middle::ty::abstract_const::{walk_abstract_const, AbstractConst, Node as ACNode};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, Const, DefIdTree, GenericParamDefKind};\n@@ -32,7 +32,6 @@ use rustc_session::lint;\n use rustc_span::hygiene::Transparency;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n-use rustc_trait_selection::traits::const_evaluatable::{self, AbstractConst};\n \n use std::marker::PhantomData;\n use std::ops::ControlFlow;\n@@ -164,7 +163,7 @@ where\n         tcx: TyCtxt<'tcx>,\n         ct: AbstractConst<'tcx>,\n     ) -> ControlFlow<V::BreakTy> {\n-        const_evaluatable::walk_abstract_const(tcx, ct, |node| match node.root(tcx) {\n+        walk_abstract_const(tcx, ct, |node| match node.root(tcx) {\n             ACNode::Leaf(leaf) => self.visit_const(leaf),\n             ACNode::Cast(_, _, ty) => self.visit_ty(ty),\n             ACNode::Binop(..) | ACNode::UnaryOp(..) | ACNode::FunctionCall(_, _) => {"}, {"sha": "56fd90c9855e0a821d44321d9ebdead35f68e0d8", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -9,7 +9,6 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::mir::{self, interpret};\n-use rustc_middle::thir;\n use rustc_middle::ty::codec::{RefDecodable, TyDecoder, TyEncoder};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_query_system::dep_graph::DepContext;\n@@ -766,7 +765,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n     }\n }\n \n-impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [thir::abstract_const::Node<'tcx>] {\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [ty::abstract_const::Node<'tcx>] {\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)\n     }"}, {"sha": "e6284b1c4ace04a34776f9266752077c5a9f1067", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 141, "deletions": 641, "changes": 782, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -10,22 +10,153 @@\n //! generic constants mentioned in the `caller_bounds` of the current environment.\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n-use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n-use rustc_middle::mir;\n-use rustc_middle::mir::interpret::{ErrorHandled, LitToConstError, LitToConstInput};\n-use rustc_middle::thir;\n-use rustc_middle::thir::abstract_const::{self, Node, NodeId, NotConstEvaluatable};\n-use rustc_middle::ty::subst::{Subst, SubstsRef};\n-use rustc_middle::ty::{self, DelaySpanBugEmitted, EarlyBinder, TyCtxt, TypeVisitable};\n+use rustc_middle::mir::interpret::ErrorHandled;\n+use rustc_middle::ty::abstract_const::{\n+    walk_abstract_const, AbstractConst, FailureKind, Node, NotConstEvaluatable,\n+};\n+use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n use rustc_session::lint;\n-use rustc_span::def_id::LocalDefId;\n use rustc_span::Span;\n \n-use std::cmp;\n use std::iter;\n use std::ops::ControlFlow;\n \n+pub struct ConstUnifyCtxt<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'tcx> ConstUnifyCtxt<'tcx> {\n+    // Substitutes generics repeatedly to allow AbstractConsts to unify where a\n+    // ConstKind::Unevaluated could be turned into an AbstractConst that would unify e.g.\n+    // Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n+    #[inline]\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn try_replace_substs_in_root(\n+        &self,\n+        mut abstr_const: AbstractConst<'tcx>,\n+    ) -> Option<AbstractConst<'tcx>> {\n+        while let Node::Leaf(ct) = abstr_const.root(self.tcx) {\n+            match AbstractConst::from_const(self.tcx, ct) {\n+                Ok(Some(act)) => abstr_const = act,\n+                Ok(None) => break,\n+                Err(_) => return None,\n+            }\n+        }\n+\n+        Some(abstr_const)\n+    }\n+\n+    /// Tries to unify two abstract constants using structural equality.\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub fn try_unify(&self, a: AbstractConst<'tcx>, b: AbstractConst<'tcx>) -> bool {\n+        let a = if let Some(a) = self.try_replace_substs_in_root(a) {\n+            a\n+        } else {\n+            return true;\n+        };\n+\n+        let b = if let Some(b) = self.try_replace_substs_in_root(b) {\n+            b\n+        } else {\n+            return true;\n+        };\n+\n+        let a_root = a.root(self.tcx);\n+        let b_root = b.root(self.tcx);\n+        debug!(?a_root, ?b_root);\n+\n+        match (a_root, b_root) {\n+            (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n+                let a_ct = a_ct.eval(self.tcx, self.param_env);\n+                debug!(\"a_ct evaluated: {:?}\", a_ct);\n+                let b_ct = b_ct.eval(self.tcx, self.param_env);\n+                debug!(\"b_ct evaluated: {:?}\", b_ct);\n+\n+                if a_ct.ty() != b_ct.ty() {\n+                    return false;\n+                }\n+\n+                match (a_ct.kind(), b_ct.kind()) {\n+                    // We can just unify errors with everything to reduce the amount of\n+                    // emitted errors here.\n+                    (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,\n+                    (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n+                        a_param == b_param\n+                    }\n+                    (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n+                    // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n+                    // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n+                    // means that we only allow inference variables if they are equal.\n+                    (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n+                    // We expand generic anonymous constants at the start of this function, so this\n+                    // branch should only be taking when dealing with associated constants, at\n+                    // which point directly comparing them seems like the desired behavior.\n+                    //\n+                    // FIXME(generic_const_exprs): This isn't actually the case.\n+                    // We also take this branch for concrete anonymous constants and\n+                    // expand generic anonymous constants with concrete substs.\n+                    (ty::ConstKind::Unevaluated(a_uv), ty::ConstKind::Unevaluated(b_uv)) => {\n+                        a_uv == b_uv\n+                    }\n+                    // FIXME(generic_const_exprs): We may want to either actually try\n+                    // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n+                    // this, for now we just return false here.\n+                    _ => false,\n+                }\n+            }\n+            (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n+                self.try_unify(a.subtree(al), b.subtree(bl))\n+                    && self.try_unify(a.subtree(ar), b.subtree(br))\n+            }\n+            (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n+                self.try_unify(a.subtree(av), b.subtree(bv))\n+            }\n+            (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n+                if a_args.len() == b_args.len() =>\n+            {\n+                self.try_unify(a.subtree(a_f), b.subtree(b_f))\n+                    && iter::zip(a_args, b_args)\n+                        .all(|(&an, &bn)| self.try_unify(a.subtree(an), b.subtree(bn)))\n+            }\n+            (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n+                if (a_ty == b_ty) && (a_kind == b_kind) =>\n+            {\n+                self.try_unify(a.subtree(a_operand), b.subtree(b_operand))\n+            }\n+            // use this over `_ => false` to make adding variants to `Node` less error prone\n+            (Node::Cast(..), _)\n+            | (Node::FunctionCall(..), _)\n+            | (Node::UnaryOp(..), _)\n+            | (Node::Binop(..), _)\n+            | (Node::Leaf(..), _) => false,\n+        }\n+    }\n+}\n+\n+#[instrument(skip(tcx), level = \"debug\")]\n+pub fn try_unify_abstract_consts<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    (a, b): (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>),\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> bool {\n+    (|| {\n+        if let Some(a) = AbstractConst::new(tcx, a)? {\n+            if let Some(b) = AbstractConst::new(tcx, b)? {\n+                let const_unify_ctxt = ConstUnifyCtxt { tcx, param_env };\n+                return Ok(const_unify_ctxt.try_unify(a, b));\n+            }\n+        }\n+\n+        Ok(false)\n+    })()\n+    .unwrap_or_else(|_: ErrorGuaranteed| true)\n+    // FIXME(generic_const_exprs): We should instead have this\n+    // method return the resulting `ty::Const` and return `ConstKind::Error`\n+    // on `ErrorGuaranteed`.\n+}\n+\n /// Check if a given constant can be evaluated.\n #[instrument(skip(infcx), level = \"debug\")]\n pub fn is_const_evaluatable<'cx, 'tcx>(\n@@ -41,48 +172,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n             if satisfied_from_param_env(tcx, ct, param_env)? {\n                 return Ok(());\n             }\n-\n-            // We were unable to unify the abstract constant with\n-            // a constant found in the caller bounds, there are\n-            // now three possible cases here.\n-            #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n-            enum FailureKind {\n-                /// The abstract const still references an inference\n-                /// variable, in this case we return `TooGeneric`.\n-                MentionsInfer,\n-                /// The abstract const references a generic parameter,\n-                /// this means that we emit an error here.\n-                MentionsParam,\n-                /// The substs are concrete enough that we can simply\n-                /// try and evaluate the given constant.\n-                Concrete,\n-            }\n-            let mut failure_kind = FailureKind::Concrete;\n-            walk_abstract_const::<!, _>(tcx, ct, |node| match node.root(tcx) {\n-                Node::Leaf(leaf) => {\n-                    if leaf.has_infer_types_or_consts() {\n-                        failure_kind = FailureKind::MentionsInfer;\n-                    } else if leaf.has_param_types_or_consts() {\n-                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n-                    }\n-\n-                    ControlFlow::CONTINUE\n-                }\n-                Node::Cast(_, _, ty) => {\n-                    if ty.has_infer_types_or_consts() {\n-                        failure_kind = FailureKind::MentionsInfer;\n-                    } else if ty.has_param_types_or_consts() {\n-                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n-                    }\n-\n-                    ControlFlow::CONTINUE\n-                }\n-                Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => {\n-                    ControlFlow::CONTINUE\n-                }\n-            });\n-\n-            match failure_kind {\n+            match ct.unify_failure_kind(tcx) {\n                 FailureKind::MentionsInfer => {\n                     return Err(NotConstEvaluatable::MentionsInfer);\n                 }\n@@ -216,593 +306,3 @@ fn satisfied_from_param_env<'tcx>(\n \n     Ok(false)\n }\n-\n-/// A tree representing an anonymous constant.\n-///\n-/// This is only able to represent a subset of `MIR`,\n-/// and should not leak any information about desugarings.\n-#[derive(Debug, Clone, Copy)]\n-pub struct AbstractConst<'tcx> {\n-    // FIXME: Consider adding something like `IndexSlice`\n-    // and use this here.\n-    inner: &'tcx [Node<'tcx>],\n-    substs: SubstsRef<'tcx>,\n-}\n-\n-impl<'tcx> AbstractConst<'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        uv: ty::Unevaluated<'tcx, ()>,\n-    ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n-        let inner = tcx.thir_abstract_const_opt_const_arg(uv.def)?;\n-        debug!(\"AbstractConst::new({:?}) = {:?}\", uv, inner);\n-        Ok(inner.map(|inner| AbstractConst { inner, substs: tcx.erase_regions(uv.substs) }))\n-    }\n-\n-    pub fn from_const(\n-        tcx: TyCtxt<'tcx>,\n-        ct: ty::Const<'tcx>,\n-    ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n-        match ct.kind() {\n-            ty::ConstKind::Unevaluated(uv) => AbstractConst::new(tcx, uv.shrink()),\n-            ty::ConstKind::Error(DelaySpanBugEmitted { reported, .. }) => Err(reported),\n-            _ => Ok(None),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn subtree(self, node: NodeId) -> AbstractConst<'tcx> {\n-        AbstractConst { inner: &self.inner[..=node.index()], substs: self.substs }\n-    }\n-\n-    #[inline]\n-    pub fn root(self, tcx: TyCtxt<'tcx>) -> Node<'tcx> {\n-        let node = self.inner.last().copied().unwrap();\n-        match node {\n-            Node::Leaf(leaf) => Node::Leaf(EarlyBinder(leaf).subst(tcx, self.substs)),\n-            Node::Cast(kind, operand, ty) => {\n-                Node::Cast(kind, operand, EarlyBinder(ty).subst(tcx, self.substs))\n-            }\n-            // Don't perform substitution on the following as they can't directly contain generic params\n-            Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => node,\n-        }\n-    }\n-}\n-\n-struct AbstractConstBuilder<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    body_id: thir::ExprId,\n-    body: &'a thir::Thir<'tcx>,\n-    /// The current WIP node tree.\n-    nodes: IndexVec<NodeId, Node<'tcx>>,\n-}\n-\n-impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n-    fn root_span(&self) -> Span {\n-        self.body.exprs[self.body_id].span\n-    }\n-\n-    fn error(&mut self, span: Span, msg: &str) -> Result<!, ErrorGuaranteed> {\n-        let reported = self\n-            .tcx\n-            .sess\n-            .struct_span_err(self.root_span(), \"overly complex generic constant\")\n-            .span_label(span, msg)\n-            .help(\"consider moving this anonymous constant into a `const` function\")\n-            .emit();\n-\n-        Err(reported)\n-    }\n-    fn maybe_supported_error(&mut self, span: Span, msg: &str) -> Result<!, ErrorGuaranteed> {\n-        let reported = self\n-            .tcx\n-            .sess\n-            .struct_span_err(self.root_span(), \"overly complex generic constant\")\n-            .span_label(span, msg)\n-            .help(\"consider moving this anonymous constant into a `const` function\")\n-            .note(\"this operation may be supported in the future\")\n-            .emit();\n-\n-        Err(reported)\n-    }\n-\n-    #[instrument(skip(tcx, body, body_id), level = \"debug\")]\n-    fn new(\n-        tcx: TyCtxt<'tcx>,\n-        (body, body_id): (&'a thir::Thir<'tcx>, thir::ExprId),\n-    ) -> Result<Option<AbstractConstBuilder<'a, 'tcx>>, ErrorGuaranteed> {\n-        let builder = AbstractConstBuilder { tcx, body_id, body, nodes: IndexVec::new() };\n-\n-        struct IsThirPolymorphic<'a, 'tcx> {\n-            is_poly: bool,\n-            thir: &'a thir::Thir<'tcx>,\n-        }\n-\n-        use crate::rustc_middle::thir::visit::Visitor;\n-        use thir::visit;\n-\n-        impl<'a, 'tcx> IsThirPolymorphic<'a, 'tcx> {\n-            fn expr_is_poly(&mut self, expr: &thir::Expr<'tcx>) -> bool {\n-                if expr.ty.has_param_types_or_consts() {\n-                    return true;\n-                }\n-\n-                match expr.kind {\n-                    thir::ExprKind::NamedConst { substs, .. } => substs.has_param_types_or_consts(),\n-                    thir::ExprKind::ConstParam { .. } => true,\n-                    thir::ExprKind::Repeat { value, count } => {\n-                        self.visit_expr(&self.thir()[value]);\n-                        count.has_param_types_or_consts()\n-                    }\n-                    _ => false,\n-                }\n-            }\n-\n-            fn pat_is_poly(&mut self, pat: &thir::Pat<'tcx>) -> bool {\n-                if pat.ty.has_param_types_or_consts() {\n-                    return true;\n-                }\n-\n-                match pat.kind.as_ref() {\n-                    thir::PatKind::Constant { value } => value.has_param_types_or_consts(),\n-                    thir::PatKind::Range(thir::PatRange { lo, hi, .. }) => {\n-                        lo.has_param_types_or_consts() || hi.has_param_types_or_consts()\n-                    }\n-                    _ => false,\n-                }\n-            }\n-        }\n-\n-        impl<'a, 'tcx> visit::Visitor<'a, 'tcx> for IsThirPolymorphic<'a, 'tcx> {\n-            fn thir(&self) -> &'a thir::Thir<'tcx> {\n-                &self.thir\n-            }\n-\n-            #[instrument(skip(self), level = \"debug\")]\n-            fn visit_expr(&mut self, expr: &thir::Expr<'tcx>) {\n-                self.is_poly |= self.expr_is_poly(expr);\n-                if !self.is_poly {\n-                    visit::walk_expr(self, expr)\n-                }\n-            }\n-\n-            #[instrument(skip(self), level = \"debug\")]\n-            fn visit_pat(&mut self, pat: &thir::Pat<'tcx>) {\n-                self.is_poly |= self.pat_is_poly(pat);\n-                if !self.is_poly {\n-                    visit::walk_pat(self, pat);\n-                }\n-            }\n-        }\n-\n-        let mut is_poly_vis = IsThirPolymorphic { is_poly: false, thir: body };\n-        visit::walk_expr(&mut is_poly_vis, &body[body_id]);\n-        debug!(\"AbstractConstBuilder: is_poly={}\", is_poly_vis.is_poly);\n-        if !is_poly_vis.is_poly {\n-            return Ok(None);\n-        }\n-\n-        Ok(Some(builder))\n-    }\n-\n-    /// We do not allow all binary operations in abstract consts, so filter disallowed ones.\n-    fn check_binop(op: mir::BinOp) -> bool {\n-        use mir::BinOp::*;\n-        match op {\n-            Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr | Eq | Lt | Le\n-            | Ne | Ge | Gt => true,\n-            Offset => false,\n-        }\n-    }\n-\n-    /// While we currently allow all unary operations, we still want to explicitly guard against\n-    /// future changes here.\n-    fn check_unop(op: mir::UnOp) -> bool {\n-        use mir::UnOp::*;\n-        match op {\n-            Not | Neg => true,\n-        }\n-    }\n-\n-    /// Builds the abstract const by walking the thir and bailing out when\n-    /// encountering an unsupported operation.\n-    fn build(mut self) -> Result<&'tcx [Node<'tcx>], ErrorGuaranteed> {\n-        debug!(\"Abstractconstbuilder::build: body={:?}\", &*self.body);\n-        self.recurse_build(self.body_id)?;\n-\n-        for n in self.nodes.iter() {\n-            if let Node::Leaf(ct) = n {\n-                if let ty::ConstKind::Unevaluated(ct) = ct.kind() {\n-                    // `AbstractConst`s should not contain any promoteds as they require references which\n-                    // are not allowed.\n-                    assert_eq!(ct.promoted, None);\n-                    assert_eq!(ct, self.tcx.erase_regions(ct));\n-                }\n-            }\n-        }\n-\n-        Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter()))\n-    }\n-\n-    fn recurse_build(&mut self, node: thir::ExprId) -> Result<NodeId, ErrorGuaranteed> {\n-        use thir::ExprKind;\n-        let node = &self.body.exprs[node];\n-        Ok(match &node.kind {\n-            // I dont know if handling of these 3 is correct\n-            &ExprKind::Scope { value, .. } => self.recurse_build(value)?,\n-            &ExprKind::PlaceTypeAscription { source, .. }\n-            | &ExprKind::ValueTypeAscription { source, .. } => self.recurse_build(source)?,\n-            &ExprKind::Literal { lit, neg} => {\n-                let sp = node.span;\n-                let constant =\n-                    match self.tcx.at(sp).lit_to_const(LitToConstInput { lit: &lit.node, ty: node.ty, neg }) {\n-                        Ok(c) => c,\n-                        Err(LitToConstError::Reported) => {\n-                            self.tcx.const_error(node.ty)\n-                        }\n-                        Err(LitToConstError::TypeError) => {\n-                            bug!(\"encountered type error in lit_to_const\")\n-                        }\n-                    };\n-\n-                self.nodes.push(Node::Leaf(constant))\n-            }\n-            &ExprKind::NonHirLiteral { lit , user_ty: _} => {\n-                let val = ty::ValTree::from_scalar_int(lit);\n-                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, val, node.ty)))\n-            }\n-            &ExprKind::ZstLiteral { user_ty: _ } => {\n-                let val = ty::ValTree::zst();\n-                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, val, node.ty)))\n-            }\n-            &ExprKind::NamedConst { def_id, substs, user_ty: _ } => {\n-                let uneval = ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs);\n-\n-                let constant = self.tcx.mk_const(ty::ConstS {\n-                                kind: ty::ConstKind::Unevaluated(uneval),\n-                                ty: node.ty,\n-                            });\n-\n-                self.nodes.push(Node::Leaf(constant))\n-            }\n-\n-            ExprKind::ConstParam {param, ..} => {\n-                let const_param = self.tcx.mk_const(ty::ConstS {\n-                        kind: ty::ConstKind::Param(*param),\n-                        ty: node.ty,\n-                    });\n-                self.nodes.push(Node::Leaf(const_param))\n-            }\n-\n-            ExprKind::Call { fun, args, .. } => {\n-                let fun = self.recurse_build(*fun)?;\n-\n-                let mut new_args = Vec::<NodeId>::with_capacity(args.len());\n-                for &id in args.iter() {\n-                    new_args.push(self.recurse_build(id)?);\n-                }\n-                let new_args = self.tcx.arena.alloc_slice(&new_args);\n-                self.nodes.push(Node::FunctionCall(fun, new_args))\n-            }\n-            &ExprKind::Binary { op, lhs, rhs } if Self::check_binop(op) => {\n-                let lhs = self.recurse_build(lhs)?;\n-                let rhs = self.recurse_build(rhs)?;\n-                self.nodes.push(Node::Binop(op, lhs, rhs))\n-            }\n-            &ExprKind::Unary { op, arg } if Self::check_unop(op) => {\n-                let arg = self.recurse_build(arg)?;\n-                self.nodes.push(Node::UnaryOp(op, arg))\n-            }\n-            // This is necessary so that the following compiles:\n-            //\n-            // ```\n-            // fn foo<const N: usize>(a: [(); N + 1]) {\n-            //     bar::<{ N + 1 }>();\n-            // }\n-            // ```\n-            ExprKind::Block { body: thir::Block { stmts: box [], expr: Some(e), .. } } => {\n-                self.recurse_build(*e)?\n-            }\n-            // `ExprKind::Use` happens when a `hir::ExprKind::Cast` is a\n-            // \"coercion cast\" i.e. using a coercion or is a no-op.\n-            // This is important so that `N as usize as usize` doesnt unify with `N as usize`. (untested)\n-            &ExprKind::Use { source } => {\n-                let arg = self.recurse_build(source)?;\n-                self.nodes.push(Node::Cast(abstract_const::CastKind::Use, arg, node.ty))\n-            }\n-            &ExprKind::Cast { source } => {\n-                let arg = self.recurse_build(source)?;\n-                self.nodes.push(Node::Cast(abstract_const::CastKind::As, arg, node.ty))\n-            }\n-            ExprKind::Borrow{ arg, ..} => {\n-                let arg_node = &self.body.exprs[*arg];\n-\n-                // Skip reborrows for now until we allow Deref/Borrow/AddressOf\n-                // expressions.\n-                // FIXME(generic_const_exprs): Verify/explain why this is sound\n-                if let ExprKind::Deref {arg} = arg_node.kind {\n-                    self.recurse_build(arg)?\n-                } else {\n-                    self.maybe_supported_error(\n-                        node.span,\n-                        \"borrowing is not supported in generic constants\",\n-                    )?\n-                }\n-            }\n-            // FIXME(generic_const_exprs): We may want to support these.\n-            ExprKind::AddressOf { .. } | ExprKind::Deref {..}=> self.maybe_supported_error(\n-                node.span,\n-                \"dereferencing or taking the address is not supported in generic constants\",\n-            )?,\n-            ExprKind::Repeat { .. } | ExprKind::Array { .. } =>  self.maybe_supported_error(\n-                node.span,\n-                \"array construction is not supported in generic constants\",\n-            )?,\n-            ExprKind::Block { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"blocks are not supported in generic constant\",\n-            )?,\n-            ExprKind::NeverToAny { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"converting nevers to any is not supported in generic constant\",\n-            )?,\n-            ExprKind::Tuple { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"tuple construction is not supported in generic constants\",\n-            )?,\n-            ExprKind::Index { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"indexing is not supported in generic constant\",\n-            )?,\n-            ExprKind::Field { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"field access is not supported in generic constant\",\n-            )?,\n-            ExprKind::ConstBlock { .. } => self.maybe_supported_error(\n-                node.span,\n-                \"const blocks are not supported in generic constant\",\n-            )?,\n-            ExprKind::Adt(_) => self.maybe_supported_error(\n-                node.span,\n-                \"struct/enum construction is not supported in generic constants\",\n-            )?,\n-            // dont know if this is correct\n-            ExprKind::Pointer { .. } =>\n-                self.error(node.span, \"pointer casts are not allowed in generic constants\")?,\n-            ExprKind::Yield { .. } =>\n-                self.error(node.span, \"generator control flow is not allowed in generic constants\")?,\n-            ExprKind::Continue { .. } | ExprKind::Break { .. } | ExprKind::Loop { .. } => self\n-                .error(\n-                    node.span,\n-                    \"loops and loop control flow are not supported in generic constants\",\n-                )?,\n-            ExprKind::Box { .. } =>\n-                self.error(node.span, \"allocations are not allowed in generic constants\")?,\n-\n-            ExprKind::Unary { .. } => unreachable!(),\n-            // we handle valid unary/binary ops above\n-            ExprKind::Binary { .. } =>\n-                self.error(node.span, \"unsupported binary operation in generic constants\")?,\n-            ExprKind::LogicalOp { .. } =>\n-                self.error(node.span, \"unsupported operation in generic constants, short-circuiting operations would imply control flow\")?,\n-            ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {\n-                self.error(node.span, \"assignment is not supported in generic constants\")?\n-            }\n-            ExprKind::Closure { .. } | ExprKind::Return { .. } => self.error(\n-                node.span,\n-                \"closures and function keywords are not supported in generic constants\",\n-            )?,\n-            // let expressions imply control flow\n-            ExprKind::Match { .. } | ExprKind::If { .. } | ExprKind::Let { .. } =>\n-                self.error(node.span, \"control flow is not supported in generic constants\")?,\n-            ExprKind::InlineAsm { .. } => {\n-                self.error(node.span, \"assembly is not supported in generic constants\")?\n-            }\n-\n-            // we dont permit let stmts so `VarRef` and `UpvarRef` cant happen\n-            ExprKind::VarRef { .. }\n-            | ExprKind::UpvarRef { .. }\n-            | ExprKind::StaticRef { .. }\n-            | ExprKind::ThreadLocalRef(_) => {\n-                self.error(node.span, \"unsupported operation in generic constant\")?\n-            }\n-        })\n-    }\n-}\n-\n-/// Builds an abstract const, do not use this directly, but use `AbstractConst::new` instead.\n-pub(super) fn thir_abstract_const<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n-) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n-    if tcx.features().generic_const_exprs {\n-        match tcx.def_kind(def.did) {\n-            // FIXME(generic_const_exprs): We currently only do this for anonymous constants,\n-            // meaning that we do not look into associated constants. I(@lcnr) am not yet sure whether\n-            // we want to look into them or treat them as opaque projections.\n-            //\n-            // Right now we do neither of that and simply always fail to unify them.\n-            DefKind::AnonConst | DefKind::InlineConst => (),\n-            _ => return Ok(None),\n-        }\n-\n-        let body = tcx.thir_body(def)?;\n-\n-        AbstractConstBuilder::new(tcx, (&*body.0.borrow(), body.1))?\n-            .map(AbstractConstBuilder::build)\n-            .transpose()\n-    } else {\n-        Ok(None)\n-    }\n-}\n-\n-#[instrument(skip(tcx), level = \"debug\")]\n-pub(super) fn try_unify_abstract_consts<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    (a, b): (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>),\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> bool {\n-    (|| {\n-        if let Some(a) = AbstractConst::new(tcx, a)? {\n-            if let Some(b) = AbstractConst::new(tcx, b)? {\n-                let const_unify_ctxt = ConstUnifyCtxt { tcx, param_env };\n-                return Ok(const_unify_ctxt.try_unify(a, b));\n-            }\n-        }\n-\n-        Ok(false)\n-    })()\n-    .unwrap_or_else(|_: ErrorGuaranteed| true)\n-    // FIXME(generic_const_exprs): We should instead have this\n-    // method return the resulting `ty::Const` and return `ConstKind::Error`\n-    // on `ErrorGuaranteed`.\n-}\n-\n-#[instrument(skip(tcx, f), level = \"debug\")]\n-pub fn walk_abstract_const<'tcx, R, F>(\n-    tcx: TyCtxt<'tcx>,\n-    ct: AbstractConst<'tcx>,\n-    mut f: F,\n-) -> ControlFlow<R>\n-where\n-    F: FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n-{\n-    #[instrument(skip(tcx, f), level = \"debug\")]\n-    fn recurse<'tcx, R>(\n-        tcx: TyCtxt<'tcx>,\n-        ct: AbstractConst<'tcx>,\n-        f: &mut dyn FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n-    ) -> ControlFlow<R> {\n-        f(ct)?;\n-        let root = ct.root(tcx);\n-        debug!(?root);\n-        match root {\n-            Node::Leaf(_) => ControlFlow::CONTINUE,\n-            Node::Binop(_, l, r) => {\n-                recurse(tcx, ct.subtree(l), f)?;\n-                recurse(tcx, ct.subtree(r), f)\n-            }\n-            Node::UnaryOp(_, v) => recurse(tcx, ct.subtree(v), f),\n-            Node::FunctionCall(func, args) => {\n-                recurse(tcx, ct.subtree(func), f)?;\n-                args.iter().try_for_each(|&arg| recurse(tcx, ct.subtree(arg), f))\n-            }\n-            Node::Cast(_, operand, _) => recurse(tcx, ct.subtree(operand), f),\n-        }\n-    }\n-\n-    recurse(tcx, ct, &mut f)\n-}\n-\n-struct ConstUnifyCtxt<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-impl<'tcx> ConstUnifyCtxt<'tcx> {\n-    // Substitutes generics repeatedly to allow AbstractConsts to unify where a\n-    // ConstKind::Unevaluated could be turned into an AbstractConst that would unify e.g.\n-    // Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n-    #[inline]\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn try_replace_substs_in_root(\n-        &self,\n-        mut abstr_const: AbstractConst<'tcx>,\n-    ) -> Option<AbstractConst<'tcx>> {\n-        while let Node::Leaf(ct) = abstr_const.root(self.tcx) {\n-            match AbstractConst::from_const(self.tcx, ct) {\n-                Ok(Some(act)) => abstr_const = act,\n-                Ok(None) => break,\n-                Err(_) => return None,\n-            }\n-        }\n-\n-        Some(abstr_const)\n-    }\n-\n-    /// Tries to unify two abstract constants using structural equality.\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn try_unify(&self, a: AbstractConst<'tcx>, b: AbstractConst<'tcx>) -> bool {\n-        let a = if let Some(a) = self.try_replace_substs_in_root(a) {\n-            a\n-        } else {\n-            return true;\n-        };\n-\n-        let b = if let Some(b) = self.try_replace_substs_in_root(b) {\n-            b\n-        } else {\n-            return true;\n-        };\n-\n-        let a_root = a.root(self.tcx);\n-        let b_root = b.root(self.tcx);\n-        debug!(?a_root, ?b_root);\n-\n-        match (a_root, b_root) {\n-            (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n-                let a_ct = a_ct.eval(self.tcx, self.param_env);\n-                debug!(\"a_ct evaluated: {:?}\", a_ct);\n-                let b_ct = b_ct.eval(self.tcx, self.param_env);\n-                debug!(\"b_ct evaluated: {:?}\", b_ct);\n-\n-                if a_ct.ty() != b_ct.ty() {\n-                    return false;\n-                }\n-\n-                match (a_ct.kind(), b_ct.kind()) {\n-                    // We can just unify errors with everything to reduce the amount of\n-                    // emitted errors here.\n-                    (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,\n-                    (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n-                        a_param == b_param\n-                    }\n-                    (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n-                    // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n-                    // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n-                    // means that we only allow inference variables if they are equal.\n-                    (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n-                    // We expand generic anonymous constants at the start of this function, so this\n-                    // branch should only be taking when dealing with associated constants, at\n-                    // which point directly comparing them seems like the desired behavior.\n-                    //\n-                    // FIXME(generic_const_exprs): This isn't actually the case.\n-                    // We also take this branch for concrete anonymous constants and\n-                    // expand generic anonymous constants with concrete substs.\n-                    (ty::ConstKind::Unevaluated(a_uv), ty::ConstKind::Unevaluated(b_uv)) => {\n-                        a_uv == b_uv\n-                    }\n-                    // FIXME(generic_const_exprs): We may want to either actually try\n-                    // to evaluate `a_ct` and `b_ct` if they are are fully concrete or something like\n-                    // this, for now we just return false here.\n-                    _ => false,\n-                }\n-            }\n-            (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n-                self.try_unify(a.subtree(al), b.subtree(bl))\n-                    && self.try_unify(a.subtree(ar), b.subtree(br))\n-            }\n-            (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n-                self.try_unify(a.subtree(av), b.subtree(bv))\n-            }\n-            (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n-                if a_args.len() == b_args.len() =>\n-            {\n-                self.try_unify(a.subtree(a_f), b.subtree(b_f))\n-                    && iter::zip(a_args, b_args)\n-                        .all(|(&an, &bn)| self.try_unify(a.subtree(an), b.subtree(bn)))\n-            }\n-            (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n-                if (a_ty == b_ty) && (a_kind == b_kind) =>\n-            {\n-                self.try_unify(a.subtree(a_operand), b.subtree(b_operand))\n-            }\n-            // use this over `_ => false` to make adding variants to `Node` less error prone\n-            (Node::Cast(..), _)\n-            | (Node::FunctionCall(..), _)\n-            | (Node::UnaryOp(..), _)\n-            | (Node::Binop(..), _)\n-            | (Node::Leaf(..), _) => false,\n-        }\n-    }\n-}"}, {"sha": "d47860f95b8f2accbba0d1272c5615797e9a75c1", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -24,8 +24,8 @@ use rustc_hir::Item;\n use rustc_hir::Node;\n use rustc_infer::infer::error_reporting::same_type_modulo_infer;\n use rustc_infer::traits::{AmbiguousSelection, TraitEngine};\n-use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n use rustc_middle::traits::select::OverflowError;\n+use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::{"}, {"sha": "4aa62f8078d42dcd4a7d1a74772343cd6b3bc21d", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -6,7 +6,7 @@ use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProce\n use rustc_infer::traits::ProjectionCacheKey;\n use rustc_infer::traits::{SelectionError, TraitEngine, TraitEngineExt as _, TraitObligation};\n use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n+use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::ToPredicate;"}, {"sha": "0ad1b47a89079763509992f845d20b9d4a99859c", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -845,20 +845,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         vtable_entries,\n         vtable_trait_upcasting_coercion_new_vptr_slot,\n         subst_and_check_impossible_predicates,\n-        thir_abstract_const: |tcx, def_id| {\n-            let def_id = def_id.expect_local();\n-            if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n-                tcx.thir_abstract_const_of_const_arg(def)\n-            } else {\n-                const_evaluatable::thir_abstract_const(tcx, ty::WithOptConstParam::unknown(def_id))\n-            }\n-        },\n-        thir_abstract_const_of_const_arg: |tcx, (did, param_did)| {\n-            const_evaluatable::thir_abstract_const(\n-                tcx,\n-                ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n-            )\n-        },\n         try_unify_abstract_consts: |tcx, param_env_and| {\n             let (param_env, (a, b)) = param_env_and.into_parts();\n             const_evaluatable::try_unify_abstract_consts(tcx, (a, b), param_env)"}, {"sha": "2921ce0ffefe1f3bb8ed32e6217c65140184b5ff", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -11,12 +11,12 @@\n use super::elaborate_predicates;\n \n use crate::infer::TyCtxtInferExt;\n-use crate::traits::const_evaluatable::{self, AbstractConst};\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::{self, Obligation, ObligationCause};\n use rustc_errors::{FatalError, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::abstract_const::{walk_abstract_const, AbstractConst};\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts, Subst};\n use rustc_middle::ty::{\n     self, EarlyBinder, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n@@ -841,15 +841,13 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeVisitable<'tcx>>(\n             //\n             // This shouldn't really matter though as we can't really use any\n             // constants which are not considered const evaluatable.\n-            use rustc_middle::thir::abstract_const::Node;\n+            use rustc_middle::ty::abstract_const::Node;\n             if let Ok(Some(ct)) = AbstractConst::new(self.tcx, uv.shrink()) {\n-                const_evaluatable::walk_abstract_const(self.tcx, ct, |node| {\n-                    match node.root(self.tcx) {\n-                        Node::Leaf(leaf) => self.visit_const(leaf),\n-                        Node::Cast(_, _, ty) => self.visit_ty(ty),\n-                        Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n-                            ControlFlow::CONTINUE\n-                        }\n+                walk_abstract_const(self.tcx, ct, |node| match node.root(self.tcx) {\n+                    Node::Leaf(leaf) => self.visit_const(leaf),\n+                    Node::Cast(_, _, ty) => self.visit_ty(ty),\n+                    Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n+                        ControlFlow::CONTINUE\n                     }\n                 })\n             } else {"}, {"sha": "7c5673c8632109e5c5f41bc460427ce3672a3637", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -32,7 +32,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::thir::abstract_const::NotConstEvaluatable;\n+use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::print::with_no_trimmed_paths;"}, {"sha": "caad2ed4274f8d13017cc92d71a3a88c403fd952", "filename": "compiler/rustc_ty_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_ty_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_ty_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2FCargo.toml?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -15,3 +15,4 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }\n+rustc_index = { path = \"../rustc_index\" }"}, {"sha": "7c2f4db94ff7269e7c60fd9bf9bf7db7d62bda11", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 394, "deletions": 2, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -1,4 +1,12 @@\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_errors::ErrorGuaranteed;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n+use rustc_middle::ty::abstract_const::{CastKind, Node, NodeId};\n+use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n+use rustc_middle::{mir, thir};\n+use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n \n use std::iter;\n@@ -72,6 +80,390 @@ pub(crate) fn destructure_const<'tcx>(\n     ty::DestructuredConst { variant, fields }\n }\n \n+pub struct AbstractConstBuilder<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    body_id: thir::ExprId,\n+    body: &'a thir::Thir<'tcx>,\n+    /// The current WIP node tree.\n+    nodes: IndexVec<NodeId, Node<'tcx>>,\n+}\n+\n+impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n+    fn root_span(&self) -> Span {\n+        self.body.exprs[self.body_id].span\n+    }\n+\n+    fn error(&mut self, span: Span, msg: &str) -> Result<!, ErrorGuaranteed> {\n+        let reported = self\n+            .tcx\n+            .sess\n+            .struct_span_err(self.root_span(), \"overly complex generic constant\")\n+            .span_label(span, msg)\n+            .help(\"consider moving this anonymous constant into a `const` function\")\n+            .emit();\n+\n+        Err(reported)\n+    }\n+    fn maybe_supported_error(&mut self, span: Span, msg: &str) -> Result<!, ErrorGuaranteed> {\n+        let reported = self\n+            .tcx\n+            .sess\n+            .struct_span_err(self.root_span(), \"overly complex generic constant\")\n+            .span_label(span, msg)\n+            .help(\"consider moving this anonymous constant into a `const` function\")\n+            .note(\"this operation may be supported in the future\")\n+            .emit();\n+\n+        Err(reported)\n+    }\n+\n+    #[instrument(skip(tcx, body, body_id), level = \"debug\")]\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        (body, body_id): (&'a thir::Thir<'tcx>, thir::ExprId),\n+    ) -> Result<Option<AbstractConstBuilder<'a, 'tcx>>, ErrorGuaranteed> {\n+        let builder = AbstractConstBuilder { tcx, body_id, body, nodes: IndexVec::new() };\n+\n+        struct IsThirPolymorphic<'a, 'tcx> {\n+            is_poly: bool,\n+            thir: &'a thir::Thir<'tcx>,\n+        }\n+\n+        use crate::rustc_middle::thir::visit::Visitor;\n+        use thir::visit;\n+\n+        impl<'a, 'tcx> IsThirPolymorphic<'a, 'tcx> {\n+            fn expr_is_poly(&mut self, expr: &thir::Expr<'tcx>) -> bool {\n+                if expr.ty.has_param_types_or_consts() {\n+                    return true;\n+                }\n+\n+                match expr.kind {\n+                    thir::ExprKind::NamedConst { substs, .. } => substs.has_param_types_or_consts(),\n+                    thir::ExprKind::ConstParam { .. } => true,\n+                    thir::ExprKind::Repeat { value, count } => {\n+                        self.visit_expr(&self.thir()[value]);\n+                        count.has_param_types_or_consts()\n+                    }\n+                    _ => false,\n+                }\n+            }\n+\n+            fn pat_is_poly(&mut self, pat: &thir::Pat<'tcx>) -> bool {\n+                if pat.ty.has_param_types_or_consts() {\n+                    return true;\n+                }\n+\n+                match pat.kind.as_ref() {\n+                    thir::PatKind::Constant { value } => value.has_param_types_or_consts(),\n+                    thir::PatKind::Range(thir::PatRange { lo, hi, .. }) => {\n+                        lo.has_param_types_or_consts() || hi.has_param_types_or_consts()\n+                    }\n+                    _ => false,\n+                }\n+            }\n+        }\n+\n+        impl<'a, 'tcx> visit::Visitor<'a, 'tcx> for IsThirPolymorphic<'a, 'tcx> {\n+            fn thir(&self) -> &'a thir::Thir<'tcx> {\n+                &self.thir\n+            }\n+\n+            #[instrument(skip(self), level = \"debug\")]\n+            fn visit_expr(&mut self, expr: &thir::Expr<'tcx>) {\n+                self.is_poly |= self.expr_is_poly(expr);\n+                if !self.is_poly {\n+                    visit::walk_expr(self, expr)\n+                }\n+            }\n+\n+            #[instrument(skip(self), level = \"debug\")]\n+            fn visit_pat(&mut self, pat: &thir::Pat<'tcx>) {\n+                self.is_poly |= self.pat_is_poly(pat);\n+                if !self.is_poly {\n+                    visit::walk_pat(self, pat);\n+                }\n+            }\n+        }\n+\n+        let mut is_poly_vis = IsThirPolymorphic { is_poly: false, thir: body };\n+        visit::walk_expr(&mut is_poly_vis, &body[body_id]);\n+        debug!(\"AbstractConstBuilder: is_poly={}\", is_poly_vis.is_poly);\n+        if !is_poly_vis.is_poly {\n+            return Ok(None);\n+        }\n+\n+        Ok(Some(builder))\n+    }\n+\n+    /// We do not allow all binary operations in abstract consts, so filter disallowed ones.\n+    fn check_binop(op: mir::BinOp) -> bool {\n+        use mir::BinOp::*;\n+        match op {\n+            Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr | Eq | Lt | Le\n+            | Ne | Ge | Gt => true,\n+            Offset => false,\n+        }\n+    }\n+\n+    /// While we currently allow all unary operations, we still want to explicitly guard against\n+    /// future changes here.\n+    fn check_unop(op: mir::UnOp) -> bool {\n+        use mir::UnOp::*;\n+        match op {\n+            Not | Neg => true,\n+        }\n+    }\n+\n+    /// Builds the abstract const by walking the thir and bailing out when\n+    /// encountering an unsupported operation.\n+    pub fn build(mut self) -> Result<&'tcx [Node<'tcx>], ErrorGuaranteed> {\n+        debug!(\"AbstractConstBuilder::build: body={:?}\", &*self.body);\n+        self.recurse_build(self.body_id)?;\n+\n+        for n in self.nodes.iter() {\n+            if let Node::Leaf(ct) = n {\n+                if let ty::ConstKind::Unevaluated(ct) = ct.kind() {\n+                    // `AbstractConst`s should not contain any promoteds as they require references which\n+                    // are not allowed.\n+                    assert_eq!(ct.promoted, None);\n+                    assert_eq!(ct, self.tcx.erase_regions(ct));\n+                }\n+            }\n+        }\n+\n+        Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter()))\n+    }\n+\n+    fn recurse_build(&mut self, node: thir::ExprId) -> Result<NodeId, ErrorGuaranteed> {\n+        use thir::ExprKind;\n+        let node = &self.body.exprs[node];\n+        Ok(match &node.kind {\n+            // I dont know if handling of these 3 is correct\n+            &ExprKind::Scope { value, .. } => self.recurse_build(value)?,\n+            &ExprKind::PlaceTypeAscription { source, .. }\n+            | &ExprKind::ValueTypeAscription { source, .. } => self.recurse_build(source)?,\n+            &ExprKind::Literal { lit, neg} => {\n+                let sp = node.span;\n+                let constant =\n+                    match self.tcx.at(sp).lit_to_const(LitToConstInput { lit: &lit.node, ty: node.ty, neg }) {\n+                        Ok(c) => c,\n+                        Err(LitToConstError::Reported) => {\n+                            self.tcx.const_error(node.ty)\n+                        }\n+                        Err(LitToConstError::TypeError) => {\n+                            bug!(\"encountered type error in lit_to_const\")\n+                        }\n+                    };\n+\n+                self.nodes.push(Node::Leaf(constant))\n+            }\n+            &ExprKind::NonHirLiteral { lit , user_ty: _} => {\n+                let val = ty::ValTree::from_scalar_int(lit);\n+                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, val, node.ty)))\n+            }\n+            &ExprKind::ZstLiteral { user_ty: _ } => {\n+                let val = ty::ValTree::zst();\n+                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, val, node.ty)))\n+            }\n+            &ExprKind::NamedConst { def_id, substs, user_ty: _ } => {\n+                let uneval = ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs);\n+\n+                let constant = self.tcx.mk_const(ty::ConstS {\n+                                kind: ty::ConstKind::Unevaluated(uneval),\n+                                ty: node.ty,\n+                            });\n+\n+                self.nodes.push(Node::Leaf(constant))\n+            }\n+\n+            ExprKind::ConstParam {param, ..} => {\n+                let const_param = self.tcx.mk_const(ty::ConstS {\n+                        kind: ty::ConstKind::Param(*param),\n+                        ty: node.ty,\n+                    });\n+                self.nodes.push(Node::Leaf(const_param))\n+            }\n+\n+            ExprKind::Call { fun, args, .. } => {\n+                let fun = self.recurse_build(*fun)?;\n+\n+                let mut new_args = Vec::<NodeId>::with_capacity(args.len());\n+                for &id in args.iter() {\n+                    new_args.push(self.recurse_build(id)?);\n+                }\n+                let new_args = self.tcx.arena.alloc_slice(&new_args);\n+                self.nodes.push(Node::FunctionCall(fun, new_args))\n+            }\n+            &ExprKind::Binary { op, lhs, rhs } if Self::check_binop(op) => {\n+                let lhs = self.recurse_build(lhs)?;\n+                let rhs = self.recurse_build(rhs)?;\n+                self.nodes.push(Node::Binop(op, lhs, rhs))\n+            }\n+            &ExprKind::Unary { op, arg } if Self::check_unop(op) => {\n+                let arg = self.recurse_build(arg)?;\n+                self.nodes.push(Node::UnaryOp(op, arg))\n+            }\n+            // This is necessary so that the following compiles:\n+            //\n+            // ```\n+            // fn foo<const N: usize>(a: [(); N + 1]) {\n+            //     bar::<{ N + 1 }>();\n+            // }\n+            // ```\n+            ExprKind::Block { body: thir::Block { stmts: box [], expr: Some(e), .. } } => {\n+                self.recurse_build(*e)?\n+            }\n+            // `ExprKind::Use` happens when a `hir::ExprKind::Cast` is a\n+            // \"coercion cast\" i.e. using a coercion or is a no-op.\n+            // This is important so that `N as usize as usize` doesnt unify with `N as usize`. (untested)\n+            &ExprKind::Use { source } => {\n+                let arg = self.recurse_build(source)?;\n+                self.nodes.push(Node::Cast(CastKind::Use, arg, node.ty))\n+            }\n+            &ExprKind::Cast { source } => {\n+                let arg = self.recurse_build(source)?;\n+                self.nodes.push(Node::Cast(CastKind::As, arg, node.ty))\n+            }\n+            ExprKind::Borrow{ arg, ..} => {\n+                let arg_node = &self.body.exprs[*arg];\n+\n+                // Skip reborrows for now until we allow Deref/Borrow/AddressOf\n+                // expressions.\n+                // FIXME(generic_const_exprs): Verify/explain why this is sound\n+                if let ExprKind::Deref { arg } = arg_node.kind {\n+                    self.recurse_build(arg)?\n+                } else {\n+                    self.maybe_supported_error(\n+                        node.span,\n+                        \"borrowing is not supported in generic constants\",\n+                    )?\n+                }\n+            }\n+            // FIXME(generic_const_exprs): We may want to support these.\n+            ExprKind::AddressOf { .. } | ExprKind::Deref {..}=> self.maybe_supported_error(\n+                node.span,\n+                \"dereferencing or taking the address is not supported in generic constants\",\n+            )?,\n+            ExprKind::Repeat { .. } | ExprKind::Array { .. } =>  self.maybe_supported_error(\n+                node.span,\n+                \"array construction is not supported in generic constants\",\n+            )?,\n+            ExprKind::Block { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"blocks are not supported in generic constant\",\n+            )?,\n+            ExprKind::NeverToAny { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"converting nevers to any is not supported in generic constant\",\n+            )?,\n+            ExprKind::Tuple { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"tuple construction is not supported in generic constants\",\n+            )?,\n+            ExprKind::Index { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"indexing is not supported in generic constant\",\n+            )?,\n+            ExprKind::Field { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"field access is not supported in generic constant\",\n+            )?,\n+            ExprKind::ConstBlock { .. } => self.maybe_supported_error(\n+                node.span,\n+                \"const blocks are not supported in generic constant\",\n+            )?,\n+            ExprKind::Adt(_) => self.maybe_supported_error(\n+                node.span,\n+                \"struct/enum construction is not supported in generic constants\",\n+            )?,\n+            // dont know if this is correct\n+            ExprKind::Pointer { .. } =>\n+                self.error(node.span, \"pointer casts are not allowed in generic constants\")?,\n+            ExprKind::Yield { .. } =>\n+                self.error(node.span, \"generator control flow is not allowed in generic constants\")?,\n+            ExprKind::Continue { .. } | ExprKind::Break { .. } | ExprKind::Loop { .. } => self\n+                .error(\n+                    node.span,\n+                    \"loops and loop control flow are not supported in generic constants\",\n+                )?,\n+            ExprKind::Box { .. } =>\n+                self.error(node.span, \"allocations are not allowed in generic constants\")?,\n+\n+            ExprKind::Unary { .. } => unreachable!(),\n+            // we handle valid unary/binary ops above\n+            ExprKind::Binary { .. } =>\n+                self.error(node.span, \"unsupported binary operation in generic constants\")?,\n+            ExprKind::LogicalOp { .. } =>\n+                self.error(node.span, \"unsupported operation in generic constants, short-circuiting operations would imply control flow\")?,\n+            ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {\n+                self.error(node.span, \"assignment is not supported in generic constants\")?\n+            }\n+            ExprKind::Closure { .. } | ExprKind::Return { .. } => self.error(\n+                node.span,\n+                \"closures and function keywords are not supported in generic constants\",\n+            )?,\n+            // let expressions imply control flow\n+            ExprKind::Match { .. } | ExprKind::If { .. } | ExprKind::Let { .. } =>\n+                self.error(node.span, \"control flow is not supported in generic constants\")?,\n+            ExprKind::InlineAsm { .. } => {\n+                self.error(node.span, \"assembly is not supported in generic constants\")?\n+            }\n+\n+            // we dont permit let stmts so `VarRef` and `UpvarRef` cant happen\n+            ExprKind::VarRef { .. }\n+            | ExprKind::UpvarRef { .. }\n+            | ExprKind::StaticRef { .. }\n+            | ExprKind::ThreadLocalRef(_) => {\n+                self.error(node.span, \"unsupported operation in generic constant\")?\n+            }\n+        })\n+    }\n+}\n+\n+/// Builds an abstract const, do not use this directly, but use `AbstractConst::new` instead.\n+pub fn thir_abstract_const<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def: ty::WithOptConstParam<LocalDefId>,\n+) -> Result<Option<&'tcx [Node<'tcx>]>, ErrorGuaranteed> {\n+    if tcx.features().generic_const_exprs {\n+        match tcx.def_kind(def.did) {\n+            // FIXME(generic_const_exprs): We currently only do this for anonymous constants,\n+            // meaning that we do not look into associated constants. I(@lcnr) am not yet sure whether\n+            // we want to look into them or treat them as opaque projections.\n+            //\n+            // Right now we do neither of that and simply always fail to unify them.\n+            DefKind::AnonConst | DefKind::InlineConst => (),\n+            _ => return Ok(None),\n+        }\n+\n+        let body = tcx.thir_body(def)?;\n+\n+        AbstractConstBuilder::new(tcx, (&*body.0.borrow(), body.1))?\n+            .map(AbstractConstBuilder::build)\n+            .transpose()\n+    } else {\n+        Ok(None)\n+    }\n+}\n+\n pub fn provide(providers: &mut ty::query::Providers) {\n-    *providers = ty::query::Providers { destructure_const, ..*providers };\n+    *providers = ty::query::Providers {\n+        destructure_const,\n+        thir_abstract_const: |tcx, def_id| {\n+            let def_id = def_id.expect_local();\n+            if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n+                tcx.thir_abstract_const_of_const_arg(def)\n+            } else {\n+                thir_abstract_const(tcx, ty::WithOptConstParam::unknown(def_id))\n+            }\n+        },\n+        thir_abstract_const_of_const_arg: |tcx, (did, param_did)| {\n+            thir_abstract_const(\n+                tcx,\n+                ty::WithOptConstParam { did, const_param_did: Some(param_did) },\n+            )\n+        },\n+        ..*providers\n+    };\n }"}, {"sha": "09f5c2a11aaa808d835133a4ffdd6df86b4360c7", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -7,6 +7,8 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(control_flow_enum)]\n #![feature(let_else)]\n+#![feature(never_type)]\n+#![feature(box_patterns)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "e599eadd8cf4804815436c0bc859f53cfbe3ff72", "filename": "src/test/ui/const-generics/overlapping_impls.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ecae3d74e26b8f10322060954fbc2a6c4ba92402/src%2Ftest%2Fui%2Fconst-generics%2Foverlapping_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecae3d74e26b8f10322060954fbc2a6c4ba92402/src%2Ftest%2Fui%2Fconst-generics%2Foverlapping_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Foverlapping_impls.rs?ref=ecae3d74e26b8f10322060954fbc2a6c4ba92402", "patch": "@@ -0,0 +1,36 @@\n+// check-pass\n+#![allow(incomplete_features)]\n+#![feature(adt_const_params)]\n+#![feature(generic_const_exprs)]\n+use std::marker::PhantomData;\n+\n+struct Foo<const I: i32, const J: i32> {}\n+\n+const ONE: i32 = 1;\n+const TWO: i32 = 2;\n+\n+impl<const I: i32> Foo<I, ONE> {\n+    pub fn foo() {}\n+}\n+\n+impl<const I: i32> Foo<I, TWO> {\n+    pub fn foo() {}\n+}\n+\n+\n+pub struct Foo2<const P: Protocol, T> {\n+    _marker: PhantomData<T>,\n+}\n+\n+#[derive(PartialEq, Eq)]\n+pub enum Protocol {\n+    Variant1,\n+    Variant2,\n+}\n+\n+pub trait Bar {}\n+\n+impl<T> Bar for Foo2<{ Protocol::Variant1 }, T> {}\n+impl<T> Bar for Foo2<{ Protocol::Variant2 }, T> {}\n+\n+fn main() {}"}]}