{"sha": "fe998dbfe496d05dc1536820ab9611bd3281a7f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlOTk4ZGJmZTQ5NmQwNWRjMTUzNjgyMGFiOTYxMWJkMzI4MWE3ZjI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-06T06:17:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-06T06:17:31Z"}, "message": "Rollup merge of #61457 - timvermeulen:double_ended_iters, r=scottmcm\n\nImplement DoubleEndedIterator for iter::{StepBy, Peekable, Take}\n\nNow that `DoubleEndedIterator::nth_back` has landed, `StepBy` and `Take` can have an efficient `DoubleEndedIterator` implementation. I don't know if there was any particular reason for `Peekable` not having a `DoubleEndedIterator` implementation, but it's quite trivial and I don't see any drawbacks to having it.\n\nI'm not very happy about the implementation of `Peekable::try_rfold`, but I didn't see another way to only take the value out of `self.peeked` in case `self.iter.try_rfold` didn't exit early.\n\nI only added `Peekable::rfold` (in addition to `try_rfold`) because its `Iterator` implementation has both `fold` and `try_fold` (and for similar reasons I added `Take::try_rfold` but not `Take::rfold`). Do we have any guidelines on whether we want both? If we do want both, maybe we should investigate which iterator adaptors override `try_fold` but not `fold` and add the missing implementations. At the moment I think that it's better to always have iterator adaptors implement both, because some iterators have a simpler `fold` implementation than their `try_fold` implementation.\n\nThe tests that I added may not be sufficient because they're all just existing tests where `next`/`nth`/`fold`/`try_fold` are replaced by their DEI counterparts, but I do think all paths are covered. Is there anything in particular that I should probably also test?", "tree": {"sha": "283463b03e3ba369e849e40423e70db5a9b42cd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/283463b03e3ba369e849e40423e70db5a9b42cd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe998dbfe496d05dc1536820ab9611bd3281a7f2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdSRt7CRBK7hj4Ov3rIwAAdHIIAAYesbVbP1BPrL/RQYzCYBnJ\nfSt1yBFaeNZ4gZWKWGaWNsQjQ7duKKfLnFB2esDscCPmQQ0iRDvBGHKWHBcnmSF9\nswl3iWr3r2qAxnXSl+Fs0c0jYh5bl9UylvlHKtobZhw74XjVMqfeJUq4KustreNt\nZyVtA5+b4NdzpzVXD/7rOQqP7/DzfpD661Lm8QanINCGEZp3vMZRP6+SatnKwRFb\n4apPSEa8KyFbmQtUC+RVjy9HNDAPDdQoerpQeUwriTdGipJbUdfGIUChHRHLf9ja\nhJXo1WsbxSmDJ2I06ARHGqBxvd0/SfDVploxphX/rl5W2JANxO9pvib1s+F5wHU=\n=b7B5\n-----END PGP SIGNATURE-----\n", "payload": "tree 283463b03e3ba369e849e40423e70db5a9b42cd3\nparent c4715198b50d1cdaad44b6e250844362b77dcdd7\nparent 56ebfb185b2e144d5404eda1fc40b0070a3122f3\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1565072251 +0200\ncommitter GitHub <noreply@github.com> 1565072251 +0200\n\nRollup merge of #61457 - timvermeulen:double_ended_iters, r=scottmcm\n\nImplement DoubleEndedIterator for iter::{StepBy, Peekable, Take}\n\nNow that `DoubleEndedIterator::nth_back` has landed, `StepBy` and `Take` can have an efficient `DoubleEndedIterator` implementation. I don't know if there was any particular reason for `Peekable` not having a `DoubleEndedIterator` implementation, but it's quite trivial and I don't see any drawbacks to having it.\n\nI'm not very happy about the implementation of `Peekable::try_rfold`, but I didn't see another way to only take the value out of `self.peeked` in case `self.iter.try_rfold` didn't exit early.\n\nI only added `Peekable::rfold` (in addition to `try_rfold`) because its `Iterator` implementation has both `fold` and `try_fold` (and for similar reasons I added `Take::try_rfold` but not `Take::rfold`). Do we have any guidelines on whether we want both? If we do want both, maybe we should investigate which iterator adaptors override `try_fold` but not `fold` and add the missing implementations. At the moment I think that it's better to always have iterator adaptors implement both, because some iterators have a simpler `fold` implementation than their `try_fold` implementation.\n\nThe tests that I added may not be sufficient because they're all just existing tests where `next`/`nth`/`fold`/`try_fold` are replaced by their DEI counterparts, but I do think all paths are covered. Is there anything in particular that I should probably also test?\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe998dbfe496d05dc1536820ab9611bd3281a7f2", "html_url": "https://github.com/rust-lang/rust/commit/fe998dbfe496d05dc1536820ab9611bd3281a7f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe998dbfe496d05dc1536820ab9611bd3281a7f2/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4715198b50d1cdaad44b6e250844362b77dcdd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4715198b50d1cdaad44b6e250844362b77dcdd7", "html_url": "https://github.com/rust-lang/rust/commit/c4715198b50d1cdaad44b6e250844362b77dcdd7"}, {"sha": "56ebfb185b2e144d5404eda1fc40b0070a3122f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/56ebfb185b2e144d5404eda1fc40b0070a3122f3", "html_url": "https://github.com/rust-lang/rust/commit/56ebfb185b2e144d5404eda1fc40b0070a3122f3"}], "stats": {"total": 309, "additions": 296, "deletions": 13}, "files": [{"sha": "af46e6df2942b21711a2e570470540732573464b", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/fe998dbfe496d05dc1536820ab9611bd3281a7f2/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe998dbfe496d05dc1536820ab9611bd3281a7f2/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=fe998dbfe496d05dc1536820ab9611bd3281a7f2", "patch": "@@ -485,6 +485,39 @@ impl<I> Iterator for StepBy<I> where I: Iterator {\n     }\n }\n \n+impl<I> StepBy<I> where I: ExactSizeIterator {\n+    // The zero-based index starting from the end of the iterator of the\n+    // last element. Used in the `DoubleEndedIterator` implementation.\n+    fn next_back_index(&self) -> usize {\n+        let rem = self.iter.len() % (self.step + 1);\n+        if self.first_take {\n+            if rem == 0 { self.step } else { rem - 1 }\n+        } else {\n+            rem\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"double_ended_step_by_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for StepBy<I> where I: DoubleEndedIterator + ExactSizeIterator {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.iter.nth_back(self.next_back_index())\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        // `self.iter.nth_back(usize::MAX)` does the right thing here when `n`\n+        // is out of bounds because the length of `self.iter` does not exceed\n+        // `usize::MAX` (because `I: ExactSizeIterator`) and `nth_back` is\n+        // zero-indexed\n+        let n = n\n+            .saturating_mul(self.step + 1)\n+            .saturating_add(self.next_back_index());\n+        self.iter.nth_back(n)\n+    }\n+}\n+\n // StepBy can only make the iterator shorter, so the len will still fit.\n #[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n impl<I> ExactSizeIterator for StepBy<I> where I: ExactSizeIterator {}\n@@ -1158,6 +1191,45 @@ impl<I: Iterator> Iterator for Peekable<I> {\n     }\n }\n \n+#[stable(feature = \"double_ended_peek_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for Peekable<I> where I: DoubleEndedIterator {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.iter.next_back().or_else(|| self.peeked.take().and_then(|x| x))\n+    }\n+\n+    #[inline]\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        match self.peeked.take() {\n+            Some(None) => return Try::from_ok(init),\n+            Some(Some(v)) => match self.iter.try_rfold(init, &mut f).into_result() {\n+                Ok(acc) => f(acc, v),\n+                Err(e) => {\n+                    self.peeked = Some(Some(v));\n+                    Try::from_error(e)\n+                }\n+            },\n+            None => self.iter.try_rfold(init, f),\n+        }\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        match self.peeked {\n+            Some(None) => return init,\n+            Some(Some(v)) => {\n+                let acc = self.iter.rfold(init, &mut fold);\n+                fold(acc, v)\n+            }\n+            None => self.iter.rfold(init, fold),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n \n@@ -1627,6 +1699,51 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     }\n }\n \n+#[stable(feature = \"double_ended_take_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for Take<I> where I: DoubleEndedIterator + ExactSizeIterator {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.n == 0 {\n+            None\n+        } else {\n+            let n = self.n;\n+            self.n -= 1;\n+            self.iter.nth_back(self.iter.len().saturating_sub(n))\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.iter.len();\n+        if self.n > n {\n+            let m = len.saturating_sub(self.n) + n;\n+            self.n -= n + 1;\n+            self.iter.nth_back(m)\n+        } else {\n+            if len > 0 {\n+                self.iter.nth_back(len - 1);\n+            }\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok = Acc>\n+    {\n+        if self.n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            let len = self.iter.len();\n+            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n+                Try::from_ok(init)\n+            } else {\n+                self.iter.try_rfold(init, fold)\n+            }\n+        }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n "}, {"sha": "e27e1605607144f94b63a284015fab14e185bcac", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 179, "deletions": 13, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/fe998dbfe496d05dc1536820ab9611bd3281a7f2/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe998dbfe496d05dc1536820ab9611bd3281a7f2/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=fe998dbfe496d05dc1536820ab9611bd3281a7f2", "patch": "@@ -188,6 +188,19 @@ fn test_iterator_step_by() {\n     assert_eq!(it.next(), Some(6));\n     assert_eq!(it.next(), Some(9));\n     assert_eq!(it.next(), None);\n+\n+    let mut it = (0..3).step_by(1);\n+    assert_eq!(it.next_back(), Some(2));\n+    assert_eq!(it.next_back(), Some(1));\n+    assert_eq!(it.next_back(), Some(0));\n+    assert_eq!(it.next_back(), None);\n+\n+    let mut it = (0..11).step_by(3);\n+    assert_eq!(it.next_back(), Some(9));\n+    assert_eq!(it.next_back(), Some(6));\n+    assert_eq!(it.next_back(), Some(3));\n+    assert_eq!(it.next_back(), Some(0));\n+    assert_eq!(it.next_back(), None);\n }\n \n #[test]\n@@ -252,6 +265,31 @@ fn test_iterator_step_by_nth_overflow() {\n     assert_eq!(it.0, (usize::MAX as Bigger) * 1);\n }\n \n+#[test]\n+fn test_iterator_step_by_nth_back() {\n+    let mut it = (0..16).step_by(5);\n+    assert_eq!(it.nth_back(0), Some(15));\n+    assert_eq!(it.nth_back(0), Some(10));\n+    assert_eq!(it.nth_back(0), Some(5));\n+    assert_eq!(it.nth_back(0), Some(0));\n+    assert_eq!(it.nth_back(0), None);\n+\n+    let mut it = (0..16).step_by(5);\n+    assert_eq!(it.next(), Some(0)); // to set `first_take` to `false`\n+    assert_eq!(it.nth_back(0), Some(15));\n+    assert_eq!(it.nth_back(0), Some(10));\n+    assert_eq!(it.nth_back(0), Some(5));\n+    assert_eq!(it.nth_back(0), None);\n+\n+    let it = || (0..18).step_by(5);\n+    assert_eq!(it().nth_back(0), Some(15));\n+    assert_eq!(it().nth_back(1), Some(10));\n+    assert_eq!(it().nth_back(2), Some(5));\n+    assert_eq!(it().nth_back(3), Some(0));\n+    assert_eq!(it().nth_back(4), None);\n+    assert_eq!(it().nth_back(42), None);\n+}\n+\n #[test]\n #[should_panic]\n fn test_iterator_step_by_zero() {\n@@ -465,8 +503,8 @@ fn test_iterator_filter_fold() {\n #[test]\n fn test_iterator_peekable() {\n     let xs = vec![0, 1, 2, 3, 4, 5];\n-    let mut it = xs.iter().cloned().peekable();\n \n+    let mut it = xs.iter().cloned().peekable();\n     assert_eq!(it.len(), 6);\n     assert_eq!(it.peek().unwrap(), &0);\n     assert_eq!(it.len(), 6);\n@@ -492,6 +530,33 @@ fn test_iterator_peekable() {\n     assert_eq!(it.len(), 0);\n     assert!(it.next().is_none());\n     assert_eq!(it.len(), 0);\n+\n+    let mut it = xs.iter().cloned().peekable();\n+    assert_eq!(it.len(), 6);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 6);\n+    assert_eq!(it.next_back().unwrap(), 5);\n+    assert_eq!(it.len(), 5);\n+    assert_eq!(it.next_back().unwrap(), 4);\n+    assert_eq!(it.len(), 4);\n+    assert_eq!(it.next_back().unwrap(), 3);\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.next_back().unwrap(), 2);\n+    assert_eq!(it.len(), 2);\n+    assert_eq!(it.next_back().unwrap(), 1);\n+    assert_eq!(it.len(), 1);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 1);\n+    assert_eq!(it.next_back().unwrap(), 0);\n+    assert_eq!(it.len(), 0);\n+    assert!(it.peek().is_none());\n+    assert_eq!(it.len(), 0);\n+    assert!(it.next_back().is_none());\n+    assert_eq!(it.len(), 0);\n }\n \n #[test]\n@@ -564,6 +629,18 @@ fn test_iterator_peekable_fold() {\n     assert_eq!(i, xs.len());\n }\n \n+#[test]\n+fn test_iterator_peekable_rfold() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    let i = it.rfold(0, |i, &x| {\n+        assert_eq!(x, xs[xs.len() - 1 - i]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+}\n+\n /// This is an iterator that follows the Iterator contract,\n /// but it is not fused. After having returned None once, it will start\n /// producing elements if .next() is called again.\n@@ -812,13 +889,25 @@ fn test_iterator_skip_fold() {\n fn test_iterator_take() {\n     let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n     let ys = [0, 1, 2, 3, 5];\n-    let mut it = xs.iter().take(5);\n+\n+    let mut it = xs.iter().take(ys.len());\n     let mut i = 0;\n-    assert_eq!(it.len(), 5);\n+    assert_eq!(it.len(), ys.len());\n     while let Some(&x) = it.next() {\n         assert_eq!(x, ys[i]);\n         i += 1;\n-        assert_eq!(it.len(), 5-i);\n+        assert_eq!(it.len(), ys.len() - i);\n+    }\n+    assert_eq!(i, ys.len());\n+    assert_eq!(it.len(), 0);\n+\n+    let mut it = xs.iter().take(ys.len());\n+    let mut i = 0;\n+    assert_eq!(it.len(), ys.len());\n+    while let Some(&x) = it.next_back() {\n+        i += 1;\n+        assert_eq!(x, ys[ys.len() - i]);\n+        assert_eq!(it.len(), ys.len() - i);\n     }\n     assert_eq!(i, ys.len());\n     assert_eq!(it.len(), 0);\n@@ -848,19 +937,51 @@ fn test_iterator_take_nth() {\n     }\n }\n \n+#[test]\n+fn test_iterator_take_nth_back() {\n+    let xs = [0, 1, 2, 4, 5];\n+    let mut it = xs.iter();\n+    {\n+        let mut take = it.by_ref().take(3);\n+        let mut i = 0;\n+        while let Some(&x) = take.nth_back(0) {\n+            i += 1;\n+            assert_eq!(x, 3 - i);\n+        }\n+    }\n+    assert_eq!(it.nth_back(0), None);\n+\n+    let xs = [0, 1, 2, 3, 4];\n+    let mut it = xs.iter().take(7);\n+    assert_eq!(it.nth_back(1), Some(&3));\n+    assert_eq!(it.nth_back(1), Some(&1));\n+    assert_eq!(it.nth_back(1), None);\n+}\n+\n #[test]\n fn test_iterator_take_short() {\n     let xs = [0, 1, 2, 3];\n-    let ys = [0, 1, 2, 3];\n+\n     let mut it = xs.iter().take(5);\n     let mut i = 0;\n-    assert_eq!(it.len(), 4);\n+    assert_eq!(it.len(), xs.len());\n     while let Some(&x) = it.next() {\n-        assert_eq!(x, ys[i]);\n+        assert_eq!(x, xs[i]);\n         i += 1;\n-        assert_eq!(it.len(), 4-i);\n+        assert_eq!(it.len(), xs.len() - i);\n     }\n-    assert_eq!(i, ys.len());\n+    assert_eq!(i, xs.len());\n+    assert_eq!(it.len(), 0);\n+\n+    let mut it = xs.iter().take(5);\n+    let mut i = 0;\n+    assert_eq!(it.len(), xs.len());\n+    while let Some(&x) = it.next_back() {\n+        i += 1;\n+        assert_eq!(x, xs[xs.len() - i]);\n+        assert_eq!(it.len(), xs.len() - i);\n+    }\n+    assert_eq!(i, xs.len());\n     assert_eq!(it.len(), 0);\n }\n \n@@ -2278,17 +2399,50 @@ fn test_enumerate_try_folds() {\n }\n \n #[test]\n-fn test_peek_try_fold() {\n+fn test_peek_try_folds() {\n     let f = &|acc, x| i32::checked_add(2*acc, x);\n+\n     assert_eq!((1..20).peekable().try_fold(7, f), (1..20).try_fold(7, f));\n+    assert_eq!((1..20).peekable().try_rfold(7, f), (1..20).try_rfold(7, f));\n+\n     let mut iter = (1..20).peekable();\n     assert_eq!(iter.peek(), Some(&1));\n     assert_eq!(iter.try_fold(7, f), (1..20).try_fold(7, f));\n \n+    let mut iter = (1..20).peekable();\n+    assert_eq!(iter.peek(), Some(&1));\n+    assert_eq!(iter.try_rfold(7, f), (1..20).try_rfold(7, f));\n+\n     let mut iter = [100, 20, 30, 40, 50, 60, 70].iter().cloned().peekable();\n     assert_eq!(iter.peek(), Some(&100));\n     assert_eq!(iter.try_fold(0, i8::checked_add), None);\n     assert_eq!(iter.peek(), Some(&40));\n+\n+    let mut iter = [100, 20, 30, 40, 50, 60, 70].iter().cloned().peekable();\n+    assert_eq!(iter.peek(), Some(&100));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.peek(), Some(&100));\n+    assert_eq!(iter.next_back(), Some(50));\n+\n+    let mut iter = (2..5).peekable();\n+    assert_eq!(iter.peek(), Some(&2));\n+    assert_eq!(iter.try_for_each(Err), Err(2));\n+    assert_eq!(iter.peek(), Some(&3));\n+    assert_eq!(iter.try_for_each(Err), Err(3));\n+    assert_eq!(iter.peek(), Some(&4));\n+    assert_eq!(iter.try_for_each(Err), Err(4));\n+    assert_eq!(iter.peek(), None);\n+    assert_eq!(iter.try_for_each(Err), Ok(()));\n+\n+    let mut iter = (2..5).peekable();\n+    assert_eq!(iter.peek(), Some(&2));\n+    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Err(4));\n+    assert_eq!(iter.peek(), Some(&2));\n+    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Err(3));\n+    assert_eq!(iter.peek(), Some(&2));\n+    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Err(2));\n+    assert_eq!(iter.peek(), None);\n+    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Ok(()));\n }\n \n #[test]\n@@ -2371,13 +2525,25 @@ fn test_skip_nth_back() {\n fn test_take_try_folds() {\n     let f = &|acc, x| i32::checked_add(2*acc, x);\n     assert_eq!((10..30).take(10).try_fold(7, f), (10..20).try_fold(7, f));\n-    //assert_eq!((10..30).take(10).try_rfold(7, f), (10..20).try_rfold(7, f));\n+    assert_eq!((10..30).take(10).try_rfold(7, f), (10..20).try_rfold(7, f));\n \n     let mut iter = (10..30).take(20);\n     assert_eq!(iter.try_fold(0, i8::checked_add), None);\n     assert_eq!(iter.next(), Some(20));\n-    //assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n-    //assert_eq!(iter.next_back(), Some(24));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(24));\n+\n+    let mut iter = (2..20).take(3);\n+    assert_eq!(iter.try_for_each(Err), Err(2));\n+    assert_eq!(iter.try_for_each(Err), Err(3));\n+    assert_eq!(iter.try_for_each(Err), Err(4));\n+    assert_eq!(iter.try_for_each(Err), Ok(()));\n+\n+    let mut iter = (2..20).take(3).rev();\n+    assert_eq!(iter.try_for_each(Err), Err(4));\n+    assert_eq!(iter.try_for_each(Err), Err(3));\n+    assert_eq!(iter.try_for_each(Err), Err(2));\n+    assert_eq!(iter.try_for_each(Err), Ok(()));\n }\n \n #[test]"}]}