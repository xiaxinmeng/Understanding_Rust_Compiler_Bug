{"sha": "41e74a2282752499ebd9e2444f9b710d92fd0e64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxZTc0YTIyODI3NTI0OTllYmQ5ZTI0NDRmOWI3MTBkOTJmZDBlNjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-28T09:40:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-28T09:40:47Z"}, "message": "Auto merge of #42276 - Mark-Simulacrum:rollup, r=Mark-Simulacrum\n\nRollup of 6 pull requests\n\n- Successful merges: #42207, #42217, #42249, #42251, #42260, #42266\n- Failed merges:", "tree": {"sha": "328f3e9d6039adc2cbc73a8dea0f5db37b2153d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/328f3e9d6039adc2cbc73a8dea0f5db37b2153d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41e74a2282752499ebd9e2444f9b710d92fd0e64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41e74a2282752499ebd9e2444f9b710d92fd0e64", "html_url": "https://github.com/rust-lang/rust/commit/41e74a2282752499ebd9e2444f9b710d92fd0e64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41e74a2282752499ebd9e2444f9b710d92fd0e64/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d2512ec5b03a1155054df881e40e35fc87d6351", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d2512ec5b03a1155054df881e40e35fc87d6351", "html_url": "https://github.com/rust-lang/rust/commit/5d2512ec5b03a1155054df881e40e35fc87d6351"}, {"sha": "1128fabb333a35eac6ee56001c0f7e5eb910a85d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1128fabb333a35eac6ee56001c0f7e5eb910a85d", "html_url": "https://github.com/rust-lang/rust/commit/1128fabb333a35eac6ee56001c0f7e5eb910a85d"}], "stats": {"total": 1390, "additions": 155, "deletions": 1235}, "files": [{"sha": "988f88516255731e47a4f43cb9cdc9987b574afc", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -43,8 +43,11 @@\n //! // instead of a max-heap.\n //! impl Ord for State {\n //!     fn cmp(&self, other: &State) -> Ordering {\n-//!         // Notice that the we flip the ordering here\n+//!         // Notice that the we flip the ordering on costs.\n+//!         // In case of a tie we compare positions - this step is necessary\n+//!         // to make implementations of `PartialEq` and `Ord` consistent.\n //!         other.cost.cmp(&self.cost)\n+//!             .then_with(|| self.position.cmp(&other.position))\n //!     }\n //! }\n //!"}, {"sha": "661cf73c7f30e3f36daf2da8d55eea9399ca1ed1", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -67,6 +67,10 @@ use self::Ordering::*;\n /// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n /// only if `a != b`.\n ///\n+/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with\n+/// each other. It's easy to accidentally make them disagree by deriving some\n+/// of the traits and manually implementing others.\n+///\n /// An example implementation for a domain in which two books are considered\n /// the same book if their ISBN matches, even if the formats differ:\n ///\n@@ -386,6 +390,10 @@ impl<T: Ord> Ord for Reverse<T> {\n /// Then you must define an implementation for `cmp()`. You may find it useful to use\n /// `cmp()` on your type's fields.\n ///\n+/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with each other. It's\n+/// easy to accidentally make them disagree by deriving some of the traits and manually\n+/// implementing others.\n+///\n /// Here's an example where you want to sort people by height only, disregarding `id`\n /// and `name`:\n ///\n@@ -474,15 +482,19 @@ impl PartialOrd for Ordering {\n ///\n /// ## How can I implement `PartialOrd`?\n ///\n-/// PartialOrd only requires implementation of the `partial_cmp` method, with the others generated\n-/// from default implementations.\n+/// `PartialOrd` only requires implementation of the `partial_cmp` method, with the others\n+/// generated from default implementations.\n ///\n /// However it remains possible to implement the others separately for types which do not have a\n /// total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 ==\n /// false` (cf. IEEE 754-2008 section 5.11).\n ///\n /// `PartialOrd` requires your type to be `PartialEq`.\n ///\n+/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with each other. It's\n+/// easy to accidentally make them disagree by deriving some of the traits and manually\n+/// implementing others.\n+///\n /// If your type is `Ord`, you can implement `partial_cmp()` by using `cmp()`:\n ///\n /// ```"}, {"sha": "64e16c41d1132bde1629051f71002cc1c0fbeb67", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -40,7 +40,7 @@ use ty::layout::{Layout, TargetDataLayout};\n use ty::inhabitedness::DefIdForest;\n use ty::maps;\n use ty::steal::Steal;\n-use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n+use util::nodemap::{NodeMap, NodeSet, DefIdSet};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n@@ -499,33 +499,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Maps Expr NodeId's to `true` iff `&expr` can have 'static lifetime.\n     pub rvalue_promotable_to_static: RefCell<NodeMap<bool>>,\n \n-    /// Maps Fn items to a collection of fragment infos.\n-    ///\n-    /// The main goal is to identify data (each of which may be moved\n-    /// or assigned) whose subparts are not moved nor assigned\n-    /// (i.e. their state is *unfragmented*) and corresponding ast\n-    /// nodes where the path to that data is moved or assigned.\n-    ///\n-    /// In the long term, unfragmented values will have their\n-    /// destructor entirely driven by a single stack-local drop-flag,\n-    /// and their parents, the collections of the unfragmented values\n-    /// (or more simply, \"fragmented values\"), are mapped to the\n-    /// corresponding collections of stack-local drop-flags.\n-    ///\n-    /// (However, in the short term that is not the case; e.g. some\n-    /// unfragmented paths still need to be zeroed, namely when they\n-    /// reference parent data from an outer scope that was not\n-    /// entirely moved, and therefore that needs to be zeroed so that\n-    /// we do not get double-drop when we hit the end of the parent\n-    /// scope.)\n-    ///\n-    /// Also: currently the table solely holds keys for node-ids of\n-    /// unfragmented values (see `FragmentInfo` enum definition), but\n-    /// longer-term we will need to also store mappings from\n-    /// fragmented data to the set of unfragmented pieces that\n-    /// constitute it.\n-    pub fragment_infos: RefCell<DefIdMap<Vec<ty::FragmentInfo>>>,\n-\n     /// The definite name of the current crate after taking into account\n     /// attributes, commandline parameters, etc.\n     pub crate_name: Symbol,\n@@ -730,7 +703,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             rvalue_promotable_to_static: RefCell::new(NodeMap()),\n-            fragment_infos: RefCell::new(DefIdMap()),\n             crate_name: Symbol::intern(crate_name),\n             data_layout: data_layout,\n             layout_cache: RefCell::new(FxHashMap()),"}, {"sha": "aeffd71a0964980e430de3b550c30f9e4e5be233", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -444,17 +444,6 @@ pub struct CReaderCacheKey {\n     pub pos: usize,\n }\n \n-/// Describes the fragment-state associated with a NodeId.\n-///\n-/// Currently only unfragmented paths have entries in the table,\n-/// but longer-term this enum is expected to expand to also\n-/// include data for fragmented paths.\n-#[derive(Copy, Clone, Debug)]\n-pub enum FragmentInfo {\n-    Moved { var: NodeId, move_expr: NodeId },\n-    Assigned { var: NodeId, assign_expr: NodeId, assignee_id: NodeId },\n-}\n-\n // Flags that we track on types. These flags are propagated upwards\n // through the type during type construction, so that we can quickly\n // check whether the type has various kinds of types in it without"}, {"sha": "eb7744e1213e703245877c35fa1567d3cfcc4443", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -266,13 +266,29 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// if not a structure at all. Corresponds to the only possible unsized\n     /// field, and its type can be used to determine unsizing strategy.\n     pub fn struct_tail(self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-        while let TyAdt(def, substs) = ty.sty {\n-            if !def.is_struct() {\n-                break;\n-            }\n-            match def.struct_variant().fields.last() {\n-                Some(f) => ty = f.ty(self, substs),\n-                None => break,\n+        loop {\n+            match ty.sty {\n+                ty::TyAdt(def, substs) => {\n+                    if !def.is_struct() {\n+                        break;\n+                    }\n+                    match def.struct_variant().fields.last() {\n+                        Some(f) => ty = f.ty(self, substs),\n+                        None => break,\n+                    }\n+                }\n+\n+                ty::TyTuple(tys, _) => {\n+                    if let Some((&last_ty, _)) = tys.split_last() {\n+                        ty = last_ty;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+\n+                _ => {\n+                    break;\n+                }\n             }\n         }\n         ty"}, {"sha": "b728d4d534516672e436312a336f40f627017943", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "removed", "additions": 0, "deletions": 542, "changes": 542, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,542 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Helper routines used for fragmenting structural paths due to moves for\n-//! tracking drop obligations. Please see the extensive comments in the\n-//! section \"Structural fragments\" in `README.md`.\n-\n-use self::Fragment::*;\n-\n-use borrowck::InteriorKind::{InteriorField, InteriorElement};\n-use borrowck::{self, LoanPath};\n-use borrowck::LoanPathKind::{LpVar, LpUpvar, LpDowncast, LpExtend};\n-use borrowck::LoanPathElem::{LpDeref, LpInterior};\n-use borrowck::move_data::InvalidMovePathIndex;\n-use borrowck::move_data::{MoveData, MovePathIndex};\n-use rustc::hir::def_id::{DefId};\n-use rustc::ty::{self, AdtKind, TyCtxt};\n-use rustc::middle::mem_categorization as mc;\n-\n-use std::mem;\n-use std::rc::Rc;\n-use syntax::ast;\n-use syntax_pos::DUMMY_SP;\n-\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-enum Fragment {\n-    // This represents the path described by the move path index\n-    Just(MovePathIndex),\n-\n-    // This represents the collection of all but one of the elements\n-    // from an array at the path described by the move path index.\n-    // Note that attached MovePathIndex should have mem_categorization\n-    // of InteriorElement (i.e. array dereference `&foo[..]`).\n-    AllButOneFrom(MovePathIndex),\n-}\n-\n-impl Fragment {\n-    fn loan_path_repr(&self, move_data: &MoveData) -> String {\n-        let lp = |mpi| move_data.path_loan_path(mpi);\n-        match *self {\n-            Just(mpi) => format!(\"{:?}\", lp(mpi)),\n-            AllButOneFrom(mpi) => format!(\"$(allbutone {:?})\", lp(mpi)),\n-        }\n-    }\n-\n-    fn loan_path_user_string(&self, move_data: &MoveData) -> String {\n-        let lp = |mpi| move_data.path_loan_path(mpi);\n-        match *self {\n-            Just(mpi) => lp(mpi).to_string(),\n-            AllButOneFrom(mpi) => format!(\"$(allbutone {})\", lp(mpi)),\n-        }\n-    }\n-}\n-\n-pub fn build_unfragmented_map(this: &mut borrowck::BorrowckCtxt,\n-                              move_data: &MoveData,\n-                              id: ast::NodeId) {\n-    let fr = &move_data.fragments.borrow();\n-\n-    // For now, don't care about other kinds of fragments; the precise\n-    // classfication of all paths for non-zeroing *drop* needs them,\n-    // but the loose approximation used by non-zeroing moves does not.\n-    let moved_leaf_paths = fr.moved_leaf_paths();\n-    let assigned_leaf_paths = fr.assigned_leaf_paths();\n-\n-    let mut fragment_infos = Vec::with_capacity(moved_leaf_paths.len());\n-\n-    let find_var_id = |move_path_index: MovePathIndex| -> Option<ast::NodeId> {\n-        let lp = move_data.path_loan_path(move_path_index);\n-        match lp.kind {\n-            LpVar(var_id) => Some(var_id),\n-            LpUpvar(ty::UpvarId { var_id, closure_expr_id }) => {\n-                // The `var_id` is unique *relative to* the current function.\n-                // (Check that we are indeed talking about the same function.)\n-                assert_eq!(id, closure_expr_id);\n-                Some(var_id)\n-            }\n-            LpDowncast(..) | LpExtend(..) => {\n-                // This simple implementation of non-zeroing move does\n-                // not attempt to deal with tracking substructure\n-                // accurately in the general case.\n-                None\n-            }\n-        }\n-    };\n-\n-    let moves = move_data.moves.borrow();\n-    for &move_path_index in moved_leaf_paths {\n-        let var_id = match find_var_id(move_path_index) {\n-            None => continue,\n-            Some(var_id) => var_id,\n-        };\n-\n-        move_data.each_applicable_move(move_path_index, |move_index| {\n-            let info = ty::FragmentInfo::Moved {\n-                var: var_id,\n-                move_expr: moves[move_index.get()].id,\n-            };\n-            debug!(\"fragment_infos push({:?} \\\n-                    due to move_path_index: {} move_index: {}\",\n-                   info, move_path_index.get(), move_index.get());\n-            fragment_infos.push(info);\n-            true\n-        });\n-    }\n-\n-    for &move_path_index in assigned_leaf_paths {\n-        let var_id = match find_var_id(move_path_index) {\n-            None => continue,\n-            Some(var_id) => var_id,\n-        };\n-\n-        let var_assigns = move_data.var_assignments.borrow();\n-        for var_assign in var_assigns.iter()\n-            .filter(|&assign| assign.path == move_path_index)\n-        {\n-            let info = ty::FragmentInfo::Assigned {\n-                var: var_id,\n-                assign_expr: var_assign.id,\n-                assignee_id: var_assign.assignee_id,\n-            };\n-            debug!(\"fragment_infos push({:?} due to var_assignment\", info);\n-            fragment_infos.push(info);\n-        }\n-    }\n-\n-    let mut fraginfo_map = this.tcx.fragment_infos.borrow_mut();\n-    let fn_did = this.tcx.hir.local_def_id(id);\n-    let prev = fraginfo_map.insert(fn_did, fragment_infos);\n-    assert!(prev.is_none());\n-}\n-\n-pub struct FragmentSets {\n-    /// During move_data construction, `moved_leaf_paths` tracks paths\n-    /// that have been used directly by being moved out of.  When\n-    /// move_data construction has been completed, `moved_leaf_paths`\n-    /// tracks such paths that are *leaf fragments* (e.g. `a.j` if we\n-    /// never move out any child like `a.j.x`); any parent paths\n-    /// (e.g. `a` for the `a.j` example) are moved over to\n-    /// `parents_of_fragments`.\n-    moved_leaf_paths: Vec<MovePathIndex>,\n-\n-    /// `assigned_leaf_paths` tracks paths that have been used\n-    /// directly by being overwritten, but is otherwise much like\n-    /// `moved_leaf_paths`.\n-    assigned_leaf_paths: Vec<MovePathIndex>,\n-\n-    /// `parents_of_fragments` tracks paths that are definitely\n-    /// parents of paths that have been moved.\n-    ///\n-    /// FIXME(pnkfelix) probably do not want/need\n-    /// `parents_of_fragments` at all, if we can avoid it.\n-    ///\n-    /// Update: I do not see a way to avoid it.  Maybe just remove\n-    /// above fixme, or at least document why doing this may be hard.\n-    parents_of_fragments: Vec<MovePathIndex>,\n-\n-    /// During move_data construction (specifically the\n-    /// fixup_fragment_sets call), `unmoved_fragments` tracks paths\n-    /// that have been \"left behind\" after a sibling has been moved or\n-    /// assigned.  When move_data construction has been completed,\n-    /// `unmoved_fragments` tracks paths that were *only* results of\n-    /// being left-behind, and never directly moved themselves.\n-    unmoved_fragments: Vec<Fragment>,\n-}\n-\n-impl FragmentSets {\n-    pub fn new() -> FragmentSets {\n-        FragmentSets {\n-            unmoved_fragments: Vec::new(),\n-            moved_leaf_paths: Vec::new(),\n-            assigned_leaf_paths: Vec::new(),\n-            parents_of_fragments: Vec::new(),\n-        }\n-    }\n-\n-    pub fn moved_leaf_paths(&self) -> &[MovePathIndex] {\n-        &self.moved_leaf_paths\n-    }\n-\n-    pub fn assigned_leaf_paths(&self) -> &[MovePathIndex] {\n-        &self.assigned_leaf_paths\n-    }\n-\n-    pub fn add_move(&mut self, path_index: MovePathIndex) {\n-        self.moved_leaf_paths.push(path_index);\n-    }\n-\n-    pub fn add_assignment(&mut self, path_index: MovePathIndex) {\n-        self.assigned_leaf_paths.push(path_index);\n-    }\n-}\n-\n-pub fn instrument_move_fragments<'a, 'tcx>(this: &MoveData<'tcx>,\n-                                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           id: ast::NodeId) {\n-    let span_err = tcx.hir.attrs(id).iter()\n-                          .any(|a| a.check_name(\"rustc_move_fragments\"));\n-    let print = tcx.sess.opts.debugging_opts.print_move_fragments;\n-\n-    if !span_err && !print { return; }\n-\n-    let sp = tcx.hir.span(id);\n-\n-    let instrument_all_paths = |kind, vec_rc: &Vec<MovePathIndex>| {\n-        for (i, mpi) in vec_rc.iter().enumerate() {\n-            let lp = || this.path_loan_path(*mpi);\n-            if span_err {\n-                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, lp()));\n-            }\n-            if print {\n-                println!(\"id:{} {}[{}] `{}`\", id, kind, i, lp());\n-            }\n-        }\n-    };\n-\n-    let instrument_all_fragments = |kind, vec_rc: &Vec<Fragment>| {\n-        for (i, f) in vec_rc.iter().enumerate() {\n-            let render = || f.loan_path_user_string(this);\n-            if span_err {\n-                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render()));\n-            }\n-            if print {\n-                println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n-            }\n-        }\n-    };\n-\n-    let fragments = this.fragments.borrow();\n-    instrument_all_paths(\"moved_leaf_path\", &fragments.moved_leaf_paths);\n-    instrument_all_fragments(\"unmoved_fragment\", &fragments.unmoved_fragments);\n-    instrument_all_paths(\"parent_of_fragments\", &fragments.parents_of_fragments);\n-    instrument_all_paths(\"assigned_leaf_path\", &fragments.assigned_leaf_paths);\n-}\n-\n-/// Normalizes the fragment sets in `this`; i.e., removes duplicate entries, constructs the set of\n-/// parents, and constructs the left-over fragments.\n-///\n-/// Note: \"left-over fragments\" means paths that were not directly referenced in moves nor\n-/// assignments, but must nonetheless be tracked as potential drop obligations.\n-pub fn fixup_fragment_sets<'a, 'tcx>(this: &MoveData<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-\n-    let mut fragments = this.fragments.borrow_mut();\n-\n-    // Swap out contents of fragments so that we can modify the fields\n-    // without borrowing the common fragments.\n-    let mut unmoved = mem::replace(&mut fragments.unmoved_fragments, vec![]);\n-    let mut parents = mem::replace(&mut fragments.parents_of_fragments, vec![]);\n-    let mut moved = mem::replace(&mut fragments.moved_leaf_paths, vec![]);\n-    let mut assigned = mem::replace(&mut fragments.assigned_leaf_paths, vec![]);\n-\n-    let path_lps = |mpis: &[MovePathIndex]| -> Vec<String> {\n-        mpis.iter().map(|mpi| format!(\"{:?}\", this.path_loan_path(*mpi))).collect()\n-    };\n-\n-    let frag_lps = |fs: &[Fragment]| -> Vec<String> {\n-        fs.iter().map(|f| f.loan_path_repr(this)).collect()\n-    };\n-\n-    // First, filter out duplicates\n-    moved.sort();\n-    moved.dedup();\n-    debug!(\"fragments 1 moved: {:?}\", path_lps(&moved));\n-\n-    assigned.sort();\n-    assigned.dedup();\n-    debug!(\"fragments 1 assigned: {:?}\", path_lps(&assigned));\n-\n-    // Second, build parents from the moved and assigned.\n-    for m in &moved {\n-        let mut p = this.path_parent(*m);\n-        while p != InvalidMovePathIndex {\n-            parents.push(p);\n-            p = this.path_parent(p);\n-        }\n-    }\n-    for a in &assigned {\n-        let mut p = this.path_parent(*a);\n-        while p != InvalidMovePathIndex {\n-            parents.push(p);\n-            p = this.path_parent(p);\n-        }\n-    }\n-\n-    parents.sort();\n-    parents.dedup();\n-    debug!(\"fragments 2 parents: {:?}\", path_lps(&parents));\n-\n-    // Third, filter the moved and assigned fragments down to just the non-parents\n-    moved.retain(|f| non_member(*f, &parents));\n-    debug!(\"fragments 3 moved: {:?}\", path_lps(&moved));\n-\n-    assigned.retain(|f| non_member(*f, &parents));\n-    debug!(\"fragments 3 assigned: {:?}\", path_lps(&assigned));\n-\n-    // Fourth, build the leftover from the moved, assigned, and parents.\n-    for m in &moved {\n-        let lp = this.path_loan_path(*m);\n-        add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n-    }\n-    for a in &assigned {\n-        let lp = this.path_loan_path(*a);\n-        add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n-    }\n-    for p in &parents {\n-        let lp = this.path_loan_path(*p);\n-        add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n-    }\n-\n-    unmoved.sort();\n-    unmoved.dedup();\n-    debug!(\"fragments 4 unmoved: {:?}\", frag_lps(&unmoved));\n-\n-    // Fifth, filter the leftover fragments down to its core.\n-    unmoved.retain(|f| match *f {\n-        AllButOneFrom(_) => true,\n-        Just(mpi) => non_member(mpi, &parents) &&\n-            non_member(mpi, &moved) &&\n-            non_member(mpi, &assigned)\n-    });\n-    debug!(\"fragments 5 unmoved: {:?}\", frag_lps(&unmoved));\n-\n-    // Swap contents back in.\n-    fragments.unmoved_fragments = unmoved;\n-    fragments.parents_of_fragments = parents;\n-    fragments.moved_leaf_paths = moved;\n-    fragments.assigned_leaf_paths = assigned;\n-\n-    return;\n-\n-    fn non_member(elem: MovePathIndex, set: &[MovePathIndex]) -> bool {\n-        match set.binary_search(&elem) {\n-            Ok(_) => false,\n-            Err(_) => true,\n-        }\n-    }\n-}\n-\n-/// Adds all of the precisely-tracked siblings of `lp` as potential move paths of interest. For\n-/// example, if `lp` represents `s.x.j`, then adds moves paths for `s.x.i` and `s.x.k`, the\n-/// siblings of `s.x.j`.\n-fn add_fragment_siblings<'a, 'tcx>(this: &MoveData<'tcx>,\n-                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   gathered_fragments: &mut Vec<Fragment>,\n-                                   lp: Rc<LoanPath<'tcx>>,\n-                                   origin_id: Option<ast::NodeId>) {\n-    match lp.kind {\n-        LpVar(_) | LpUpvar(..) => {} // Local variables have no siblings.\n-\n-        // Consuming a downcast is like consuming the original value, so propage inward.\n-        LpDowncast(ref loan_parent, _) => {\n-            add_fragment_siblings(this, tcx, gathered_fragments, loan_parent.clone(), origin_id);\n-        }\n-\n-        // *LV for Unique consumes the contents of the box (at\n-        // least when it is non-copy...), so propagate inward.\n-        LpExtend(ref loan_parent, _, LpDeref(mc::Unique)) => {\n-            add_fragment_siblings(this, tcx, gathered_fragments, loan_parent.clone(), origin_id);\n-        }\n-\n-        // *LV for unsafe and borrowed pointers do not consume their loan path, so stop here.\n-        LpExtend(.., LpDeref(mc::UnsafePtr(..)))   |\n-        LpExtend(.., LpDeref(mc::Implicit(..)))    |\n-        LpExtend(.., LpDeref(mc::BorrowedPtr(..))) => {}\n-\n-        // FIXME (pnkfelix): LV[j] should be tracked, at least in the\n-        // sense of we will track the remaining drop obligation of the\n-        // rest of the array.\n-        //\n-        // Well, either that or LV[j] should be made illegal.\n-        // But even then, we will need to deal with destructuring\n-        // bind.\n-        //\n-        // Anyway, for now: LV[j] is not tracked precisely\n-        LpExtend(.., LpInterior(_, InteriorElement(..))) => {\n-            let mp = this.move_path(tcx, lp.clone());\n-            gathered_fragments.push(AllButOneFrom(mp));\n-        }\n-\n-        // field access LV.x and tuple access LV#k are the cases\n-        // we are interested in\n-        LpExtend(ref loan_parent, mc,\n-                 LpInterior(_, InteriorField(ref field_name))) => {\n-            let enum_variant_info = match loan_parent.kind {\n-                LpDowncast(ref loan_parent_2, variant_def_id) =>\n-                    Some((variant_def_id, loan_parent_2.clone())),\n-                LpExtend(..) | LpVar(..) | LpUpvar(..) =>\n-                    None,\n-            };\n-            add_fragment_siblings_for_extension(\n-                this,\n-                tcx,\n-                gathered_fragments,\n-                loan_parent, mc, field_name, &lp, origin_id, enum_variant_info);\n-        }\n-    }\n-}\n-\n-/// We have determined that `origin_lp` destructures to LpExtend(parent, original_field_name).\n-/// Based on this, add move paths for all of the siblings of `origin_lp`.\n-fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n-                                                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 gathered_fragments: &mut Vec<Fragment>,\n-                                                 parent_lp: &Rc<LoanPath<'tcx>>,\n-                                                 mc: mc::MutabilityCategory,\n-                                                 origin_field_name: &mc::FieldName,\n-                                                 origin_lp: &Rc<LoanPath<'tcx>>,\n-                                                 origin_id: Option<ast::NodeId>,\n-                                                 enum_variant_info: Option<(DefId,\n-                                                    Rc<LoanPath<'tcx>>)>) {\n-    let parent_ty = parent_lp.to_type();\n-\n-    let mut add_fragment_sibling_local = |field_name, variant_did| {\n-        add_fragment_sibling_core(\n-            this, tcx, gathered_fragments, parent_lp.clone(), mc, field_name, origin_lp,\n-            variant_did);\n-    };\n-\n-    match parent_ty.sty {\n-        ty::TyTuple(ref v, _) => {\n-            let tuple_idx = match *origin_field_name {\n-                mc::PositionalField(tuple_idx) => tuple_idx,\n-                mc::NamedField(_) =>\n-                    bug!(\"tuple type {:?} should not have named fields.\",\n-                         parent_ty),\n-            };\n-            let tuple_len = v.len();\n-            for i in 0..tuple_len {\n-                if i == tuple_idx { continue }\n-                let field_name = mc::PositionalField(i);\n-                add_fragment_sibling_local(field_name, None);\n-            }\n-        }\n-\n-        ty::TyAdt(def, ..) => match def.adt_kind() {\n-            AdtKind::Struct => {\n-                match *origin_field_name {\n-                    mc::NamedField(ast_name) => {\n-                        for f in &def.struct_variant().fields {\n-                            if f.name == ast_name {\n-                                continue;\n-                            }\n-                            let field_name = mc::NamedField(f.name);\n-                            add_fragment_sibling_local(field_name, None);\n-                        }\n-                    }\n-                    mc::PositionalField(tuple_idx) => {\n-                        for (i, _f) in def.struct_variant().fields.iter().enumerate() {\n-                            if i == tuple_idx {\n-                                continue\n-                            }\n-                            let field_name = mc::PositionalField(i);\n-                            add_fragment_sibling_local(field_name, None);\n-                        }\n-                    }\n-                }\n-            }\n-            AdtKind::Union => {\n-                // Do nothing, all union fields are moved/assigned together.\n-            }\n-            AdtKind::Enum => {\n-                let variant = match enum_variant_info {\n-                    Some((vid, ref _lp2)) => def.variant_with_id(vid),\n-                    None => {\n-                        assert!(def.is_univariant());\n-                        &def.variants[0]\n-                    }\n-                };\n-                match *origin_field_name {\n-                    mc::NamedField(ast_name) => {\n-                        for field in &variant.fields {\n-                            if field.name == ast_name {\n-                                continue;\n-                            }\n-                            let field_name = mc::NamedField(field.name);\n-                            add_fragment_sibling_local(field_name, Some(variant.did));\n-                        }\n-                    }\n-                    mc::PositionalField(tuple_idx) => {\n-                        for (i, _f) in variant.fields.iter().enumerate() {\n-                            if tuple_idx == i {\n-                                continue;\n-                            }\n-                            let field_name = mc::PositionalField(i);\n-                            add_fragment_sibling_local(field_name, None);\n-                        }\n-                    }\n-                }\n-            }\n-        },\n-\n-        ref ty => {\n-            let span = origin_id.map_or(DUMMY_SP, |id| tcx.hir.span(id));\n-            span_bug!(span,\n-                      \"type {:?} ({:?}) is not fragmentable\",\n-                      parent_ty, ty);\n-        }\n-    }\n-}\n-\n-/// Adds the single sibling `LpExtend(parent, new_field_name)` of `origin_lp` (the original\n-/// loan-path).\n-fn add_fragment_sibling_core<'a, 'tcx>(this: &MoveData<'tcx>,\n-                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       gathered_fragments: &mut Vec<Fragment>,\n-                                       parent: Rc<LoanPath<'tcx>>,\n-                                       mc: mc::MutabilityCategory,\n-                                       new_field_name: mc::FieldName,\n-                                       origin_lp: &Rc<LoanPath<'tcx>>,\n-                                       enum_variant_did: Option<DefId>)\n-                                       -> MovePathIndex {\n-    let opt_variant_did = match parent.kind {\n-        LpDowncast(_, variant_did) => Some(variant_did),\n-        LpVar(..) | LpUpvar(..) | LpExtend(..) => enum_variant_did,\n-    };\n-\n-    let loan_path_elem = LpInterior(opt_variant_did, InteriorField(new_field_name));\n-    let new_lp_type = match new_field_name {\n-        mc::NamedField(ast_name) =>\n-            tcx.named_element_ty(parent.to_type(), ast_name, opt_variant_did),\n-        mc::PositionalField(idx) =>\n-            tcx.positional_element_ty(parent.to_type(), idx, opt_variant_did),\n-    };\n-    let new_lp_variant = LpExtend(parent, mc, loan_path_elem);\n-    let new_lp = LoanPath::new(new_lp_variant, new_lp_type.unwrap());\n-    debug!(\"add_fragment_sibling_core(new_lp={:?}, origin_lp={:?})\",\n-           new_lp, origin_lp);\n-    let mp = this.move_path(tcx, Rc::new(new_lp));\n-\n-    // Do not worry about checking for duplicates here; we will sort\n-    // and dedup after all are added.\n-    gathered_fragments.push(Just(mp));\n-\n-    mp\n-}"}, {"sha": "ff5ebb9c1dc5d1aee2ce4fa94a03e37dfb24db22", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -129,13 +129,6 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n                        move_data: flowed_moves } =\n         build_borrowck_dataflow_data(bccx, &cfg, body_id);\n \n-    move_data::fragments::instrument_move_fragments(&flowed_moves.move_data,\n-                                                    bccx.tcx,\n-                                                    owner_id);\n-    move_data::fragments::build_unfragmented_map(bccx,\n-                                                 &flowed_moves.move_data,\n-                                                 owner_id);\n-\n     check_loans::check_loans(bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n }\n "}, {"sha": "1b364596a23f7fd518de0871ebb808afa4778592", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -33,9 +33,6 @@ use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n-#[path=\"fragments.rs\"]\n-pub mod fragments;\n-\n pub struct MoveData<'tcx> {\n     /// Move paths. See section \"Move paths\" in `README.md`.\n     pub paths: RefCell<Vec<MovePath<'tcx>>>,\n@@ -62,9 +59,6 @@ pub struct MoveData<'tcx> {\n \n     /// Assignments to a variable or path, like `x = foo`, but not `x += foo`.\n     pub assignee_ids: RefCell<NodeSet>,\n-\n-    /// Path-fragments from moves in to or out of parts of structured data.\n-    pub fragments: RefCell<fragments::FragmentSets>,\n }\n \n pub struct FlowedMoveData<'a, 'tcx: 'a> {\n@@ -223,7 +217,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n             var_assignments: RefCell::new(Vec::new()),\n             variant_matches: RefCell::new(Vec::new()),\n             assignee_ids: RefCell::new(NodeSet()),\n-            fragments: RefCell::new(fragments::FragmentSets::new()),\n         }\n     }\n \n@@ -401,8 +394,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         let path_index = self.move_path(tcx, lp.clone());\n         let move_index = MoveIndex(self.moves.borrow().len());\n \n-        self.fragments.borrow_mut().add_move(path_index);\n-\n         let next_move = self.path_first_move(path_index);\n         self.set_path_first_move(path_index, move_index);\n \n@@ -458,8 +449,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n         let path_index = self.move_path(tcx, lp.clone());\n \n-        self.fragments.borrow_mut().add_assignment(path_index);\n-\n         match mode {\n             MutateMode::Init | MutateMode::JustWrite => {\n                 self.assignee_ids.borrow_mut().insert(assignee_id);\n@@ -502,8 +491,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         let path_index = self.move_path(tcx, lp.clone());\n         let base_path_index = self.move_path(tcx, base_lp.clone());\n \n-        self.fragments.borrow_mut().add_assignment(path_index);\n-\n         let variant_match = VariantMatch {\n             path: path_index,\n             base_path: base_path_index,\n@@ -514,10 +501,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         self.variant_matches.borrow_mut().push(variant_match);\n     }\n \n-    fn fixup_fragment_sets(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-        fragments::fixup_fragment_sets(self, tcx)\n-    }\n-\n     /// Adds the gen/kills for the various moves and\n     /// assignments into the provided data flow contexts.\n     /// Moves are generated by moves and killed by assignments and\n@@ -677,8 +660,6 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                                  id_range,\n                                  move_data.var_assignments.borrow().len());\n \n-        move_data.fixup_fragment_sets(tcx);\n-\n         move_data.add_gen_kills(bccx,\n                                 &mut dfcx_moves,\n                                 &mut dfcx_assign);"}, {"sha": "b5ef4aac34c89586436a73ade3cff6f517807bb5", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -40,8 +40,8 @@ const CFG: &'static str = \"cfg\";\n #[derive(Debug, PartialEq)]\n enum Disposition { Reused, Translated }\n \n-pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       modules: &[ModuleTranslation]) {\n+pub(crate) fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                              modules: &[ModuleTranslation]) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n     if tcx.sess.opts.incremental.is_none() {"}, {"sha": "e40267238801cb791e63a600821b493aa769e84b", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -14,18 +14,16 @@ use super::rpath::RPathConfig;\n use super::rpath;\n use super::msvc;\n use metadata::METADATA_FILENAME;\n-use session::config;\n-use session::config::NoDebugInfo;\n-use session::config::{OutputFilenames, Input, OutputType};\n-use session::filesearch;\n-use session::search_paths::PathKind;\n-use session::Session;\n-use middle::cstore::{self, LinkMeta, NativeLibrary, LibSource};\n-use middle::cstore::{LinkagePreference, NativeLibraryKind};\n-use middle::dependency_format::Linkage;\n+use rustc::session::config::{self, NoDebugInfo, OutputFilenames, Input, OutputType};\n+use rustc::session::filesearch;\n+use rustc::session::search_paths::PathKind;\n+use rustc::session::Session;\n+use rustc::middle::cstore::{self, LinkMeta, NativeLibrary, LibSource, LinkagePreference,\n+                            NativeLibraryKind};\n+use rustc::middle::dependency_format::Linkage;\n use CrateTranslation;\n-use util::common::time;\n-use util::fs::fix_windows_verbatim_for_gcc;\n+use rustc::util::common::time;\n+use rustc::util::fs::fix_windows_verbatim_for_gcc;\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::CrateNum;\n use rustc::hir::svh::Svh;"}, {"sha": "0b15886083a4e4d099613a43d86c06c88f86f74e", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -20,11 +20,11 @@ use context::SharedCrateContext;\n \n use back::archive;\n use back::symbol_export::{self, ExportedSymbols};\n-use middle::dependency_format::Linkage;\n+use rustc::middle::dependency_format::Linkage;\n use rustc::hir::def_id::{LOCAL_CRATE, CrateNum};\n use rustc_back::LinkerFlavor;\n-use session::Session;\n-use session::config::{self, CrateType, OptLevel, DebugInfoLevel};\n+use rustc::session::Session;\n+use rustc::session::config::{self, CrateType, OptLevel, DebugInfoLevel};\n use serialize::{json, Encoder};\n \n /// For all the linkers we support, and information they might"}, {"sha": "97648888fa9b95bebc3362964c64c3598a2fac42", "filename": "src/librustc_trans/back/msvc/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fmod.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -52,7 +52,7 @@ mod platform {\n     use std::fs;\n     use std::path::{Path, PathBuf};\n     use std::process::Command;\n-    use session::Session;\n+    use rustc::session::Session;\n     use super::arch::{host_arch, Arch};\n     use super::registry::LOCAL_MACHINE;\n \n@@ -296,7 +296,7 @@ mod platform {\n mod platform {\n     use std::path::PathBuf;\n     use std::process::Command;\n-    use session::Session;\n+    use rustc::session::Session;\n     pub fn link_exe_cmd(_sess: &Session) -> (Command, Option<PathBuf>) {\n         (Command::new(\"link.exe\"), None)\n     }"}, {"sha": "ef75de04045e5d64b5307b535cbe5e17386fccf8", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -10,7 +10,7 @@\n \n use context::SharedCrateContext;\n use monomorphize::Instance;\n-use util::nodemap::FxHashMap;\n+use rustc::util::nodemap::FxHashMap;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::session::config;\n use rustc::ty::TyCtxt;"}, {"sha": "8e14335ceacb9950a2d8ffe9cddc52114db062bc", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -348,16 +348,6 @@ impl ItemPathBuffer for SymbolPathBuffer {\n     }\n }\n \n-pub fn exported_name_from_type_and_prefix<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                    t: Ty<'tcx>,\n-                                                    prefix: &str)\n-                                                    -> String {\n-    let hash = get_symbol_hash(tcx, None, t, None);\n-    let mut buffer = SymbolPathBuffer::new();\n-    buffer.push(prefix);\n-    buffer.finish(hash)\n-}\n-\n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n // gas doesn't!\n // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $"}, {"sha": "6ed0cb0092f52d0be31e3d5fa522ac49c807c534", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -12,16 +12,15 @@ use back::lto;\n use back::link::{get_linker, remove};\n use back::symbol_export::ExportedSymbols;\n use rustc_incremental::{save_trans_partition, in_incr_comp_dir};\n-use session::config::{OutputFilenames, OutputTypes, Passes, SomePasses, AllPasses, Sanitizer};\n-use session::Session;\n-use session::config::{self, OutputType};\n+use rustc::session::config::{self, OutputFilenames, OutputType, OutputTypes, Passes, SomePasses,\n+                             AllPasses, Sanitizer};\n+use rustc::session::Session;\n use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef, ContextRef};\n use llvm::SMDiagnosticRef;\n use {CrateTranslation, ModuleLlvm, ModuleSource, ModuleTranslation};\n-use util::common::{time, time_depth, set_time_depth};\n-use util::common::path2cstr;\n-use util::fs::link_or_copy;\n+use rustc::util::common::{time, time_depth, set_time_depth, path2cstr};\n+use rustc::util::fs::link_or_copy;\n use errors::{self, Handler, Level, DiagnosticBuilder};\n use errors::emitter::Emitter;\n use syntax_pos::MultiSpan;"}, {"sha": "1b3f0ba7ce5b6f61c7430d92a882cfb7cc7fa9f7", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -36,16 +36,16 @@ use llvm::{ContextRef, Linkage, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n use metadata;\n use rustc::hir::def_id::LOCAL_CRATE;\n-use middle::lang_items::StartFnLangItem;\n-use middle::cstore::EncodedMetadata;\n+use rustc::middle::lang_items::StartFnLangItem;\n+use rustc::middle::cstore::EncodedMetadata;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::dep_graph::AssertDepGraphSafe;\n use rustc::middle::cstore::LinkMeta;\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n-use session::config::{self, NoDebugInfo};\n+use rustc::session::config::{self, NoDebugInfo};\n+use rustc::session::{self, DataTypeKind, Session};\n use rustc_incremental::IncrementalHashesMap;\n-use session::{self, DataTypeKind, Session};\n use abi;\n use mir::lvalue::LvalueRef;\n use attributes;\n@@ -71,7 +71,7 @@ use trans_item::{TransItem, DefPathBasedNames};\n use type_::Type;\n use type_of;\n use value::Value;\n-use util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n+use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n \n use libc::c_uint;\n use std::ffi::{CStr, CString};"}, {"sha": "672a37a0bd5c2af0904fdb1f6dd235f814fdca54", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -204,7 +204,7 @@ use rustc::mir::visit::Visitor as MirVisitor;\n use context::SharedCrateContext;\n use common::{def_ty, instance_ty};\n use monomorphize::{self, Instance};\n-use util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n+use rustc::util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n use trans_item::{TransItem, DefPathBasedNames, InstantiationMode};\n "}, {"sha": "fc48ec6b5c5abd78666780f08b779a53524830f0", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -17,7 +17,7 @@ use llvm::{ValueRef, ContextRef, TypeKind};\n use llvm::{True, False, Bool, OperandBundleDef};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n-use middle::lang_items::LangItem;\n+use rustc::middle::lang_items::LangItem;\n use base;\n use builder::Builder;\n use consts;"}, {"sha": "c3b16c2d07d0733ddc43b0c403ab7dc426a38455", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -26,10 +26,9 @@ use rustc_data_structures::base_n;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{LayoutTyper, TyLayout};\n-use session::config::NoDebugInfo;\n-use session::Session;\n-use session::config;\n-use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n+use rustc::session::config::{self, NoDebugInfo};\n+use rustc::session::Session;\n+use rustc::util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};"}, {"sha": "14d3fa495530773173de9e870aa5eff813f9c2b9", "filename": "src/librustc_trans/debuginfo/gdb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fgdb.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -16,7 +16,7 @@ use common::{C_bytes, CrateContext, C_i32};\n use builder::Builder;\n use declare;\n use type_::Type;\n-use session::config::NoDebugInfo;\n+use rustc::session::config::NoDebugInfo;\n \n use std::ptr;\n use syntax::attr;"}, {"sha": "fea24e6da873e02420303f8c0089c8211073b378", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -19,7 +19,6 @@ use super::namespace::mangled_name_of_item;\n use super::type_names::compute_debuginfo_type_name;\n use super::{CrateDebugContext};\n use context::SharedCrateContext;\n-use session::Session;\n \n use llvm::{self, ValueRef};\n use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor,\n@@ -37,8 +36,8 @@ use common::{self, CrateContext};\n use type_::Type;\n use rustc::ty::{self, AdtKind, Ty};\n use rustc::ty::layout::{self, LayoutTyper};\n-use session::config;\n-use util::nodemap::FxHashMap;\n+use rustc::session::{Session, config};\n+use rustc::util::nodemap::FxHashMap;\n \n use libc::{c_uint, c_longlong};\n use std::ffi::CString;"}, {"sha": "4d781d6f77de919f15d71832f8dd7e709da38e39", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -32,8 +32,8 @@ use builder::Builder;\n use monomorphize::Instance;\n use rustc::ty::{self, Ty};\n use rustc::mir;\n-use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n-use util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n+use rustc::session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n+use rustc::util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n \n use libc::c_uint;\n use std::cell::{Cell, RefCell};"}, {"sha": "c111a3983e7ea272e0b7c0c9957e2d906776f775", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -63,32 +63,25 @@ extern crate syntax_pos;\n extern crate rustc_errors as errors;\n extern crate serialize;\n \n-pub use rustc::session;\n-pub use rustc::middle;\n-pub use rustc::lint;\n-pub use rustc::util;\n-\n pub use base::trans_crate;\n pub use back::symbol_names::provide;\n \n pub use metadata::LlvmMetadataLoader;\n pub use llvm_util::{init, target_features, print_version, print_passes, print, enable_llvm_debug};\n \n pub mod back {\n-    pub use rustc::hir::svh;\n-\n-    pub mod archive;\n-    pub mod linker;\n+    mod archive;\n+    pub(crate) mod linker;\n     pub mod link;\n-    pub mod lto;\n-    pub mod symbol_export;\n-    pub mod symbol_names;\n+    mod lto;\n+    pub(crate) mod symbol_export;\n+    pub(crate) mod symbol_names;\n     pub mod write;\n-    pub mod msvc;\n-    pub mod rpath;\n+    mod msvc;\n+    mod rpath;\n }\n \n-pub mod diagnostics;\n+mod diagnostics;\n \n mod abi;\n mod adt;\n@@ -171,8 +164,8 @@ pub struct CrateTranslation {\n     pub crate_name: Symbol,\n     pub modules: Vec<ModuleTranslation>,\n     pub metadata_module: ModuleTranslation,\n-    pub link: middle::cstore::LinkMeta,\n-    pub metadata: middle::cstore::EncodedMetadata,\n+    pub link: rustc::middle::cstore::LinkMeta,\n+    pub metadata: rustc::middle::cstore::EncodedMetadata,\n     pub exported_symbols: back::symbol_export::ExportedSymbols,\n     pub no_builtins: bool,\n     pub windows_subsystem: Option<String>,"}, {"sha": "aa20d70978c94978716e3f9243db26041435e87a", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -17,7 +17,7 @@ use rustc::mir::{self, Mir};\n use rustc::mir::tcx::LvalueTy;\n use rustc::ty::subst::Substs;\n use rustc::infer::TransNormalize;\n-use session::config::FullDebugInfo;\n+use rustc::session::config::FullDebugInfo;\n use base;\n use builder::Builder;\n use common::{self, CrateContext, Funclet};"}, {"sha": "fc4130942a192a70a3916ba105e7a5521ca1507c", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -14,7 +14,7 @@ use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::layout::{Layout, LayoutTyper};\n use rustc::mir::tcx::LvalueTy;\n use rustc::mir;\n-use middle::lang_items::ExchangeMallocFnLangItem;\n+use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n \n use base;\n use builder::Builder;"}, {"sha": "2fe463e92a8aad9540d4337b7da478622b40463a", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -118,7 +118,7 @@ use std::sync::Arc;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n use trans_item::{TransItem, InstantiationMode};\n-use util::nodemap::{FxHashMap, FxHashSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n pub enum PartitioningStrategy {\n     /// Generate one codegen unit per source-level module."}, {"sha": "18f33dc22e743591bff0ab8ded26c2500be04d5b", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -4078,7 +4078,7 @@ register_diagnostics! {\n //  E0217, // ambiguous associated type, defined in multiple supertraits\n //  E0218, // no associated type defined\n //  E0219, // associated type defined in higher-ranked supertrait\n-//  E0222, // Error code E0045 (variadic function must have C calling\n+//  E0222, // Error code E0045 (variadic function must have C or cdecl calling\n            // convention) duplicate\n     E0224, // at least one non-builtin train is required for an object type\n     E0227, // ambiguous lifetime bound, explicit lifetime bound required"}, {"sha": "699b5f330d4577ac5dcd10a94b075910608fb49a", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -141,11 +141,10 @@ fn require_c_abi_if_variadic(tcx: TyCtxt,\n                              decl: &hir::FnDecl,\n                              abi: Abi,\n                              span: Span) {\n-    if decl.variadic && abi != Abi::C {\n+    if decl.variadic && !(abi == Abi::C || abi == Abi::Cdecl) {\n         let mut err = struct_span_err!(tcx.sess, span, E0045,\n-                  \"variadic function must have C calling convention\");\n-        err.span_label(span, \"variadics require C calling conventions\")\n-            .emit();\n+                  \"variadic function must have C or cdecl calling convention\");\n+        err.span_label(span, \"variadics require C or cdecl calling convention\").emit();\n     }\n }\n "}, {"sha": "b2f52d11db2b111b82f6073ec5e17fd5527a4745", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -664,12 +664,6 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                            \"rustc_attrs\",\n                                            \"internal rustc attributes will never be stable\",\n                                            cfg_fn!(rustc_attrs))),\n-    (\"rustc_move_fragments\", Normal, Gated(Stability::Unstable,\n-                                           \"rustc_attrs\",\n-                                           \"the `#[rustc_move_fragments]` attribute \\\n-                                            is just used for rustc unit tests \\\n-                                            and will never be stable\",\n-                                           cfg_fn!(rustc_attrs))),\n     (\"rustc_mir\", Whitelisted, Gated(Stability::Unstable,\n                                      \"rustc_attrs\",\n                                      \"the `#[rustc_mir]` attribute \\"}, {"sha": "3f098861eb60c08587ccfc4af967f11a256ca4c9", "filename": "src/test/compile-fail/E0045.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Ftest%2Fcompile-fail%2FE0045.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Ftest%2Fcompile-fail%2FE0045.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0045.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n extern \"Rust\" { fn foo(x: u8, ...); }   //~ ERROR E0045\n-                                        //~| NOTE variadics require C calling conventions\n+                                        //~| NOTE variadics require C or cdecl calling convention\n \n fn main() {\n }"}, {"sha": "8cfd3e020c69a47da7d3eeb1cf1eb8be261a62fa", "filename": "src/test/compile-fail/feature-gate-rustc-attrs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rustc-attrs.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -14,7 +14,6 @@\n \n #[rustc_variance] //~ ERROR the `#[rustc_variance]` attribute is just used for rustc unit tests and will never be stable\n #[rustc_error] //~ ERROR the `#[rustc_error]` attribute is just used for rustc unit tests and will never be stable\n-#[rustc_move_fragments] //~ ERROR the `#[rustc_move_fragments]` attribute is just used for rustc unit tests and will never be stable\n #[rustc_foo]\n //~^ ERROR unless otherwise specified, attributes with the prefix `rustc_` are reserved for internal compiler diagnostics\n "}, {"sha": "6f6b775a2a3c69a8c5a48c1be5b54ce038d6fa86", "filename": "src/test/compile-fail/issue-39974.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Ftest%2Fcompile-fail%2Fissue-39974.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Ftest%2Fcompile-fail%2Fissue-39974.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39974.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const LENGTH: f64 = 2;\n+\n+struct Thing {\n+    f: [[f64; 2]; LENGTH],\n+    //~^ ERROR mismatched types\n+    //~| expected usize, found f64\n+}\n+\n+fn main() {\n+    let _t = Thing { f: [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]] };\n+}"}, {"sha": "0219f5b6becb3bae271892a3cc559bebacc8ae56", "filename": "src/test/compile-fail/move-fragments-1.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-1.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,58 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we correctly compute the move fragments for a fn.\n-//\n-// Note that the code below is not actually incorrect; the\n-// `rustc_move_fragments` attribute is a hack that uses the error\n-// reporting mechanisms as a channel for communicating from the\n-// internals of the compiler.\n-\n-// These are all fairly trivial cases: unused variables or direct\n-// drops of substructure.\n-\n-#![feature(rustc_attrs)]\n-\n-pub struct D { d: isize }\n-impl Drop for D { fn drop(&mut self) { } }\n-\n-#[rustc_move_fragments]\n-pub fn test_noop() {\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_take(_x: D) {\n-    //~^ ERROR                  assigned_leaf_path: `$(local _x)`\n-}\n-\n-pub struct Pair<X,Y> { x: X, y: Y }\n-\n-#[rustc_move_fragments]\n-pub fn test_take_struct(_p: Pair<D, D>) {\n-    //~^ ERROR                  assigned_leaf_path: `$(local _p)`\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_drop_struct_part(p: Pair<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                     moved_leaf_path: `$(local p).x`\n-    //~| ERROR                    unmoved_fragment: `$(local p).y`\n-    drop(p.x);\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_drop_tuple_part(p: (D, D)) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                     moved_leaf_path: `$(local p).#0`\n-    //~| ERROR                    unmoved_fragment: `$(local p).#1`\n-    drop(p.0);\n-}\n-\n-pub fn main() { }"}, {"sha": "15c28ec2713e967d160e67bd20c1f047407afd53", "filename": "src/test/compile-fail/move-fragments-2.rs", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-2.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,87 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we correctly compute the move fragments for a fn.\n-//\n-// Note that the code below is not actually incorrect; the\n-// `rustc_move_fragments` attribute is a hack that uses the error\n-// reporting mechanisms as a channel for communicating from the\n-// internals of the compiler.\n-\n-// These are checking that enums are tracked; note that their output\n-// paths include \"downcasts\" of the path to a particular enum.\n-\n-#![feature(rustc_attrs)]\n-\n-use self::Lonely::{Zero, One, Two};\n-\n-pub struct D { d: isize }\n-impl Drop for D { fn drop(&mut self) { } }\n-\n-pub enum Lonely<X,Y> { Zero, One(X), Two(X, Y) }\n-\n-#[rustc_move_fragments]\n-pub fn test_match_partial(p: Lonely<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::Zero)`\n-    match p {\n-        Zero => {}\n-        _ => {}\n-    }\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_match_full(p: Lonely<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::Zero)`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::One)`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::Two)`\n-    match p {\n-        Zero => {}\n-        One(..) => {}\n-        Two(..) => {}\n-    }\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_match_bind_one(p: Lonely<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::Zero)`\n-    //~| ERROR                 parent_of_fragments: `($(local p) as Lonely::One)`\n-    //~| ERROR                     moved_leaf_path: `($(local p) as Lonely::One).#0`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::Two)`\n-    //~| ERROR                  assigned_leaf_path: `$(local data)`\n-    match p {\n-        Zero => {}\n-        One(data) => {}\n-        Two(..) => {}\n-    }\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_match_bind_many(p: Lonely<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::Zero)`\n-    //~| ERROR                 parent_of_fragments: `($(local p) as Lonely::One)`\n-    //~| ERROR                     moved_leaf_path: `($(local p) as Lonely::One).#0`\n-    //~| ERROR                  assigned_leaf_path: `$(local data)`\n-    //~| ERROR                 parent_of_fragments: `($(local p) as Lonely::Two)`\n-    //~| ERROR                     moved_leaf_path: `($(local p) as Lonely::Two).#0`\n-    //~| ERROR                     moved_leaf_path: `($(local p) as Lonely::Two).#1`\n-    //~| ERROR                  assigned_leaf_path: `$(local left)`\n-    //~| ERROR                  assigned_leaf_path: `$(local right)`\n-    match p {\n-        Zero => {}\n-        One(data) => {}\n-        Two(left, right) => {}\n-    }\n-}\n-\n-pub fn main() { }"}, {"sha": "a1152333900a0f455b4d096acf7b3b4b6e5a69a1", "filename": "src/test/compile-fail/move-fragments-3.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-3.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we correctly compute the move fragments for a fn.\n-//\n-// Note that the code below is not actually incorrect; the\n-// `rustc_move_fragments` attribute is a hack that uses the error\n-// reporting mechanisms as a channel for communicating from the\n-// internals of the compiler.\n-\n-// This checks the handling of `_` within variants, especially when mixed\n-// with bindings.\n-\n-#![feature(rustc_attrs)]\n-\n-use self::Lonely::{Zero, One, Two};\n-\n-pub struct D { d: isize }\n-impl Drop for D { fn drop(&mut self) { } }\n-\n-pub enum Lonely<X,Y> { Zero, One(X), Two(X, Y) }\n-\n-#[rustc_move_fragments]\n-pub fn test_match_bind_and_underscore(p: Lonely<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::Zero)`\n-    //~| ERROR                  assigned_leaf_path: `($(local p) as Lonely::One)`\n-    //~| ERROR                 parent_of_fragments: `($(local p) as Lonely::Two)`\n-    //~| ERROR                     moved_leaf_path: `($(local p) as Lonely::Two).#0`\n-    //~| ERROR                    unmoved_fragment: `($(local p) as Lonely::Two).#1`\n-    //~| ERROR                  assigned_leaf_path: `$(local left)`\n-\n-    match p {\n-        Zero => {}\n-\n-        One(_) => {}       // <-- does not fragment `($(local p) as One)` ...\n-\n-        Two(left, _) => {} // <-- ... *does* fragment `($(local p) as Two)`.\n-    }\n-}\n-\n-pub fn main() { }"}, {"sha": "191e23a28638b59c8119386ae18525d6f172cc36", "filename": "src/test/compile-fail/move-fragments-4.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-4.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we correctly compute the move fragments for a fn.\n-//\n-// Note that the code below is not actually incorrect; the\n-// `rustc_move_fragments` attribute is a hack that uses the error\n-// reporting mechanisms as a channel for communicating from the\n-// internals of the compiler.\n-\n-// This checks that a move of deep structure is properly tracked. (An\n-// early draft of the code did not properly traverse up through all of\n-// the parents of the leaf fragment.)\n-\n-#![feature(rustc_attrs)]\n-\n-pub struct D { d: isize }\n-impl Drop for D { fn drop(&mut self) { } }\n-\n-pub struct Pair<X,Y> { x: X, y: Y }\n-\n-#[rustc_move_fragments]\n-pub fn test_move_substructure(pppp: Pair<Pair<Pair<Pair<D,D>, D>, D>, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local pppp)`\n-    //~| ERROR                 parent_of_fragments: `$(local pppp).x`\n-    //~| ERROR                 parent_of_fragments: `$(local pppp).x.x`\n-    //~| ERROR                    unmoved_fragment: `$(local pppp).x.x.x`\n-    //~| ERROR                     moved_leaf_path: `$(local pppp).x.x.y`\n-    //~| ERROR                    unmoved_fragment: `$(local pppp).x.y`\n-    //~| ERROR                    unmoved_fragment: `$(local pppp).y`\n-    drop(pppp.x.x.y);\n-}\n-\n-pub fn main() { }"}, {"sha": "38a385eacac5c07795c9a19e49c5d9288b3b7e63", "filename": "src/test/compile-fail/move-fragments-5.rs", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-5.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,94 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we correctly compute the move fragments for a fn.\n-//\n-// Note that the code below is not actually incorrect; the\n-// `rustc_move_fragments` attribute is a hack that uses the error\n-// reporting mechanisms as a channel for communicating from the\n-// internals of the compiler.\n-\n-// This is the first test that checks moving into local variables.\n-\n-#![feature(rustc_attrs)]\n-\n-pub struct D { d: isize }\n-impl Drop for D { fn drop(&mut self) { } }\n-\n-pub struct Pair<X,Y> { x: X, y: Y }\n-\n-#[rustc_move_fragments]\n-pub fn test_move_field_to_local(p: Pair<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                     moved_leaf_path: `$(local p).x`\n-    //~| ERROR                    unmoved_fragment: `$(local p).y`\n-    //~| ERROR                  assigned_leaf_path: `$(local _x)`\n-    let _x = p.x;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_move_field_to_local_to_local(p: Pair<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                     moved_leaf_path: `$(local p).x`\n-    //~| ERROR                    unmoved_fragment: `$(local p).y`\n-    //~| ERROR                  assigned_leaf_path: `$(local _x)`\n-    //~| ERROR                     moved_leaf_path: `$(local _x)`\n-    //~| ERROR                  assigned_leaf_path: `$(local _y)`\n-    let _x = p.x;\n-    let _y = _x;\n-}\n-\n-// In the following fn's `test_move_field_to_local_delayed` and\n-// `test_uninitialized_local` , the instrumentation reports that `_x`\n-// is moved. This is unlike `test_move_field_to_local`, where `_x` is\n-// just reported as an assigned_leaf_path. Presumably because this is\n-// how we represent that it did not have an initializing expression at\n-// the binding site.\n-\n-#[rustc_move_fragments]\n-pub fn test_uninitialized_local(_p: Pair<D, D>) {\n-    //~^ ERROR                  assigned_leaf_path: `$(local _p)`\n-    //~| ERROR                     moved_leaf_path: `$(local _x)`\n-    let _x: D;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_move_field_to_local_delayed(p: Pair<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                     moved_leaf_path: `$(local p).x`\n-    //~| ERROR                    unmoved_fragment: `$(local p).y`\n-    //~| ERROR                  assigned_leaf_path: `$(local _x)`\n-    //~| ERROR                     moved_leaf_path: `$(local _x)`\n-    let _x;\n-    _x = p.x;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_move_field_mut_to_local(mut p: Pair<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local mut p)`\n-    //~| ERROR                     moved_leaf_path: `$(local mut p).x`\n-    //~| ERROR                    unmoved_fragment: `$(local mut p).y`\n-    //~| ERROR                  assigned_leaf_path: `$(local _x)`\n-    let _x = p.x;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_move_field_to_local_to_local_mut(p: Pair<D, D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                     moved_leaf_path: `$(local p).x`\n-    //~| ERROR                    unmoved_fragment: `$(local p).y`\n-    //~| ERROR                  assigned_leaf_path: `$(local mut _x)`\n-    //~| ERROR                     moved_leaf_path: `$(local mut _x)`\n-    //~| ERROR                  assigned_leaf_path: `$(local _y)`\n-    let mut _x = p.x;\n-    let _y = _x;\n-}\n-\n-pub fn main() {}"}, {"sha": "122727c3f6b64a0c1cf75e4ca4a216cf51df98b3", "filename": "src/test/compile-fail/move-fragments-6.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-6.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we correctly compute the move fragments for a fn.\n-//\n-// Note that the code below is not actually incorrect; the\n-// `rustc_move_fragments` attribute is a hack that uses the error\n-// reporting mechanisms as a channel for communicating from the\n-// internals of the compiler.\n-\n-// Test that moving into a field (i.e. overwriting it) fragments the\n-// receiver.\n-\n-#![feature(rustc_attrs)]\n-\n-use std::mem::drop;\n-\n-pub struct Pair<X,Y> { x: X, y: Y }\n-\n-#[rustc_move_fragments]\n-pub fn test_overwrite_uninit_field<Z>(z: Z) {\n-    //~^ ERROR                 parent_of_fragments: `$(local mut p)`\n-    //~| ERROR                  assigned_leaf_path: `$(local z)`\n-    //~| ERROR                     moved_leaf_path: `$(local z)`\n-    //~| ERROR                  assigned_leaf_path: `$(local mut p).x`\n-    //~| ERROR                    unmoved_fragment: `$(local mut p).y`\n-\n-    let mut p: Pair<Z,Z>;\n-    p.x = z;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_overwrite_moved_field<Z>(mut p: Pair<Z,Z>, z: Z) {\n-    //~^ ERROR                 parent_of_fragments: `$(local mut p)`\n-    //~| ERROR                  assigned_leaf_path: `$(local z)`\n-    //~| ERROR                     moved_leaf_path: `$(local z)`\n-    //~| ERROR                  assigned_leaf_path: `$(local mut p).y`\n-    //~| ERROR                    unmoved_fragment: `$(local mut p).x`\n-\n-    drop(p);\n-    p.y = z;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_overwrite_same_field<Z>(mut p: Pair<Z,Z>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local mut p)`\n-    //~| ERROR                     moved_leaf_path: `$(local mut p).x`\n-    //~| ERROR                  assigned_leaf_path: `$(local mut p).x`\n-    //~| ERROR                    unmoved_fragment: `$(local mut p).y`\n-\n-    p.x = p.x;\n-}\n-\n-pub fn main() { }"}, {"sha": "a2a37208cd6168b61f4dcbdce75f59cf93e4b65d", "filename": "src/test/compile-fail/move-fragments-7.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-7.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,48 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we correctly compute the move fragments for a fn.\n-//\n-// Note that the code below is not actually incorrect; the\n-// `rustc_move_fragments` attribute is a hack that uses the error\n-// reporting mechanisms as a channel for communicating from the\n-// internals of the compiler.\n-\n-// Test that moving a Box<T> fragments its containing structure, for\n-// both moving out of the structure (i.e. reading `*p.x`) and writing\n-// into the container (i.e. writing `*p.x`).\n-\n-#![feature(rustc_attrs)]\n-\n-pub struct D { d: isize }\n-impl Drop for D { fn drop(&mut self) { } }\n-\n-pub struct Pair<X,Y> { x: X, y: Y }\n-\n-#[rustc_move_fragments]\n-pub fn test_deref_box_field(p: Pair<Box<D>, Box<D>>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                 parent_of_fragments: `$(local p).x`\n-    //~| ERROR                     moved_leaf_path: `$(local p).x.*`\n-    //~| ERROR                    unmoved_fragment: `$(local p).y`\n-    //~| ERROR                  assigned_leaf_path: `$(local i)`\n-    let i : D = *p.x;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_overwrite_deref_box_field(mut p: Pair<Box<D>, Box<D>>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local mut p)`\n-    //~| ERROR                 parent_of_fragments: `$(local mut p).x`\n-    //~| ERROR                  assigned_leaf_path: `$(local mut p).x.*`\n-    //~| ERROR                    unmoved_fragment: `$(local mut p).y`\n-    *p.x = D { d: 3 };\n-}\n-\n-pub fn main() { }"}, {"sha": "e57268dbfa32aa985afb154168824b5916186a22", "filename": "src/test/compile-fail/move-fragments-8.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-8.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,41 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we correctly compute the move fragments for a fn.\n-//\n-// Note that the code below is not actually incorrect; the\n-// `rustc_move_fragments` attribute is a hack that uses the error\n-// reporting mechanisms as a channel for communicating from the\n-// internals of the compiler.\n-\n-// Test that assigning into a `&T` within structured container does\n-// *not* fragment its containing structure.\n-//\n-// Compare against the `Box<T>` handling in move-fragments-7.rs. Note\n-// also that in this case we cannot do a move out of `&T`, so we only\n-// test writing `*p.x` here.\n-\n-#![feature(rustc_attrs)]\n-\n-pub struct D { d: isize }\n-impl Drop for D { fn drop(&mut self) { } }\n-\n-pub struct Pair<X,Y> { x: X, y: Y }\n-\n-#[rustc_move_fragments]\n-pub fn test_overwrite_deref_ampersand_field<'a>(p: Pair<&'a mut D, &'a D>) {\n-    //~^ ERROR                 parent_of_fragments: `$(local p)`\n-    //~| ERROR                 parent_of_fragments: `$(local p).x`\n-    //~| ERROR                  assigned_leaf_path: `$(local p).x.*`\n-    //~| ERROR                    unmoved_fragment: `$(local p).y`\n-    *p.x = D { d: 3 };\n-}\n-\n-pub fn main() { }"}, {"sha": "350f4169034004620cae6bf2cb6367532dfb27b2", "filename": "src/test/compile-fail/move-fragments-9.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2512ec5b03a1155054df881e40e35fc87d6351/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-fragments-9.rs?ref=5d2512ec5b03a1155054df881e40e35fc87d6351", "patch": "@@ -1,49 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test moving array structures, e.g. `[T; 3]` as well as moving\n-// elements in and out of such arrays.\n-//\n-// Note also that the `test_move_array_then_overwrite` tests represent\n-// cases that we probably should make illegal.\n-\n-#![feature(rustc_attrs)]\n-\n-pub struct D { d: isize }\n-impl Drop for D { fn drop(&mut self) { } }\n-\n-#[rustc_move_fragments]\n-pub fn test_move_array_via_return(a: [D; 3]) -> [D; 3] {\n-    //~^ ERROR                  assigned_leaf_path: `$(local a)`\n-    //~| ERROR                     moved_leaf_path: `$(local a)`\n-    return a;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_move_array_into_recv(a: [D; 3], recv: &mut [D; 3]) {\n-    //~^ ERROR                 parent_of_fragments: `$(local recv)`\n-    //~| ERROR                  assigned_leaf_path: `$(local a)`\n-    //~| ERROR                     moved_leaf_path: `$(local a)`\n-    //~| ERROR                  assigned_leaf_path: `$(local recv).*`\n-    *recv = a;\n-}\n-\n-#[rustc_move_fragments]\n-pub fn test_overwrite_array_elem(mut a: [D; 3], i: usize, d: D) {\n-    //~^ ERROR                 parent_of_fragments: `$(local mut a)`\n-    //~| ERROR                  assigned_leaf_path: `$(local i)`\n-    //~| ERROR                  assigned_leaf_path: `$(local d)`\n-    //~| ERROR                     moved_leaf_path: `$(local d)`\n-    //~| ERROR                  assigned_leaf_path: `$(local mut a).[]`\n-    //~| ERROR                    unmoved_fragment: `$(allbutone $(local mut a).[])`\n-    a[i] = d;\n-}\n-\n-pub fn main() { }"}, {"sha": "ec5669f639277f6db2623791bf8b4ac7c47df91b", "filename": "src/test/compile-fail/variadic-ffi-2.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi-2.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn baz(f: extern \"cdecl\" fn(usize, ...)) {\n-    //~^ ERROR: variadic function must have C calling convention\n+// ignore-arm stdcall isn't suppported\n+\n+fn baz(f: extern \"stdcall\" fn(usize, ...)) {\n+    //~^ ERROR: variadic function must have C or cdecl calling convention\n     f(22, 44);\n }\n "}, {"sha": "125177efc53c79d102e62c519462536f9354fd69", "filename": "src/test/compile-fail/variadic-ffi.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern \"cdecl\" {\n-    fn printf(_: *const u8, ...); //~ ERROR: variadic function must have C calling convention\n+// ignore-arm stdcall isn't suppported\n+\n+extern \"stdcall\" {\n+    fn printf(_: *const u8, ...); //~ ERROR: variadic function must have C or cdecl calling\n }\n \n extern {"}, {"sha": "ecdf78cd5bdf807a3fa419284a42bd4a3b1c198e", "filename": "src/test/run-pass/issue-42210.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Ftest%2Frun-pass%2Fissue-42210.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e74a2282752499ebd9e2444f9b710d92fd0e64/src%2Ftest%2Frun-pass%2Fissue-42210.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-42210.rs?ref=41e74a2282752499ebd9e2444f9b710d92fd0e64", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #42210.\n+\n+// compile-flags: -g\n+\n+trait Foo {\n+    fn foo() { }\n+}\n+\n+struct Bar;\n+\n+trait Baz {\n+}\n+\n+impl Foo for (Bar, Baz) { }\n+\n+\n+fn main() {\n+    <(Bar, Baz) as Foo>::foo()\n+}"}]}