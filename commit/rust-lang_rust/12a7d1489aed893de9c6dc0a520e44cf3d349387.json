{"sha": "12a7d1489aed893de9c6dc0a520e44cf3d349387", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyYTdkMTQ4OWFlZDg5M2RlOWM2ZGMwYTUyMGU0NGNmM2QzNDkzODc=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-10-06T07:10:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-10-06T07:10:33Z"}, "message": "Merge pull request #2111 from camsteffen/never_loop\n\nFix never_loop", "tree": {"sha": "4ed932b2eafd02c38247f62d2931da3ba70c37fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ed932b2eafd02c38247f62d2931da3ba70c37fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12a7d1489aed893de9c6dc0a520e44cf3d349387", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12a7d1489aed893de9c6dc0a520e44cf3d349387", "html_url": "https://github.com/rust-lang/rust/commit/12a7d1489aed893de9c6dc0a520e44cf3d349387", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12a7d1489aed893de9c6dc0a520e44cf3d349387/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "346936a7c183908eb2f4e73baa3ba070671e55cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/346936a7c183908eb2f4e73baa3ba070671e55cb", "html_url": "https://github.com/rust-lang/rust/commit/346936a7c183908eb2f4e73baa3ba070671e55cb"}, {"sha": "d92d5a88118c98477b33ed14b7ae3dc9ca4b394f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d92d5a88118c98477b33ed14b7ae3dc9ca4b394f", "html_url": "https://github.com/rust-lang/rust/commit/d92d5a88118c98477b33ed14b7ae3dc9ca4b394f"}], "stats": {"total": 79, "additions": 53, "deletions": 26}, "files": [{"sha": "8d2a2f8fac619401458b7010b9c2ed19c1d10090", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/12a7d1489aed893de9c6dc0a520e44cf3d349387/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12a7d1489aed893de9c6dc0a520e44cf3d349387/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=12a7d1489aed893de9c6dc0a520e44cf3d349387", "patch": "@@ -378,7 +378,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         match expr.node {\n             ExprWhile(_, ref block, _) |\n             ExprLoop(ref block, _, _) => {\n-                if never_loop(block, &expr.id) {\n+                if never_loop(block, expr.id) {\n                     span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\");\n                 }\n             },\n@@ -485,27 +485,27 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn never_loop(block: &Block, id: &NodeId) -> bool {\n-    !contains_continue_block(block, id) && loop_exit_block(block)\n+fn never_loop(block: &Block, id: NodeId) -> bool {\n+    !contains_continue_block(block, Some(id)) && loop_exit_block(block, &mut vec![id])\n }\n \n-fn contains_continue_block(block: &Block, dest: &NodeId) -> bool {\n+fn contains_continue_block(block: &Block, dest: Option<NodeId>) -> bool {\n     block.stmts.iter().any(|e| contains_continue_stmt(e, dest)) ||\n         block.expr.as_ref().map_or(\n             false,\n             |e| contains_continue_expr(e, dest),\n         )\n }\n \n-fn contains_continue_stmt(stmt: &Stmt, dest: &NodeId) -> bool {\n+fn contains_continue_stmt(stmt: &Stmt, dest: Option<NodeId>) -> bool {\n     match stmt.node {\n         StmtSemi(ref e, _) |\n         StmtExpr(ref e, _) => contains_continue_expr(e, dest),\n         StmtDecl(ref d, _) => contains_continue_decl(d, dest),\n     }\n }\n \n-fn contains_continue_decl(decl: &Decl, dest: &NodeId) -> bool {\n+fn contains_continue_decl(decl: &Decl, dest: Option<NodeId>) -> bool {\n     match decl.node {\n         DeclLocal(ref local) => {\n             local.init.as_ref().map_or(\n@@ -517,7 +517,7 @@ fn contains_continue_decl(decl: &Decl, dest: &NodeId) -> bool {\n     }\n }\n \n-fn contains_continue_expr(expr: &Expr, dest: &NodeId) -> bool {\n+fn contains_continue_expr(expr: &Expr, dest: Option<NodeId>) -> bool {\n     match expr.node {\n         ExprRet(Some(ref e)) |\n         ExprBox(ref e) |\n@@ -555,31 +555,32 @@ fn contains_continue_expr(expr: &Expr, dest: &NodeId) -> bool {\n                 |e| contains_continue_expr(e, dest),\n             )\n         },\n-        ExprAgain(d) => d.target_id.opt_id().map_or(false, |id| id == *dest),\n+        ExprAgain(d) => dest.map_or(true, |dest| d.target_id.opt_id().map_or(false, |id| id == dest)),\n         _ => false,\n     }\n }\n \n-fn loop_exit_block(block: &Block) -> bool {\n-    block.stmts.iter().any(|e| loop_exit_stmt(e)) || block.expr.as_ref().map_or(false, |e| loop_exit_expr(e))\n+fn loop_exit_block(block: &Block, loops: &mut Vec<NodeId>) -> bool {\n+    block.stmts.iter().take_while(|s| !contains_continue_stmt(s, None)).any(|s| loop_exit_stmt(s, loops))\n+        || block.expr.as_ref().map_or(false, |e| loop_exit_expr(e, loops))\n }\n \n-fn loop_exit_stmt(stmt: &Stmt) -> bool {\n+fn loop_exit_stmt(stmt: &Stmt, loops: &mut Vec<NodeId>) -> bool {\n     match stmt.node {\n         StmtSemi(ref e, _) |\n-        StmtExpr(ref e, _) => loop_exit_expr(e),\n-        StmtDecl(ref d, _) => loop_exit_decl(d),\n+        StmtExpr(ref e, _) => loop_exit_expr(e, loops),\n+        StmtDecl(ref d, _) => loop_exit_decl(d, loops),\n     }\n }\n \n-fn loop_exit_decl(decl: &Decl) -> bool {\n+fn loop_exit_decl(decl: &Decl, loops: &mut Vec<NodeId>) -> bool {\n     match decl.node {\n-        DeclLocal(ref local) => local.init.as_ref().map_or(false, |e| loop_exit_expr(e)),\n+        DeclLocal(ref local) => local.init.as_ref().map_or(false, |e| loop_exit_expr(e, loops)),\n         _ => false,\n     }\n }\n \n-fn loop_exit_expr(expr: &Expr) -> bool {\n+fn loop_exit_expr(expr: &Expr, loops: &mut Vec<NodeId>) -> bool {\n     match expr.node {\n         ExprBox(ref e) |\n         ExprUnary(_, ref e) |\n@@ -588,22 +589,34 @@ fn loop_exit_expr(expr: &Expr) -> bool {\n         ExprField(ref e, _) |\n         ExprTupField(ref e, _) |\n         ExprAddrOf(_, ref e) |\n-        ExprRepeat(ref e, _) => loop_exit_expr(e),\n+        ExprRepeat(ref e, _) => loop_exit_expr(e, loops),\n         ExprArray(ref es) |\n         ExprMethodCall(_, _, ref es) |\n-        ExprTup(ref es) => es.iter().any(|e| loop_exit_expr(e)),\n-        ExprCall(ref e, ref es) => loop_exit_expr(e) || es.iter().any(|e| loop_exit_expr(e)),\n+        ExprTup(ref es) => es.iter().any(|e| loop_exit_expr(e, loops)),\n+        ExprCall(ref e, ref es) => loop_exit_expr(e, loops) || es.iter().any(|e| loop_exit_expr(e, loops)),\n         ExprBinary(_, ref e1, ref e2) |\n         ExprAssign(ref e1, ref e2) |\n         ExprAssignOp(_, ref e1, ref e2) |\n-        ExprIndex(ref e1, ref e2) => [e1, e2].iter().any(|e| loop_exit_expr(e)),\n-        ExprIf(ref e, ref e2, ref e3) => {\n-            loop_exit_expr(e) || e3.as_ref().map_or(false, |e| loop_exit_expr(e)) && loop_exit_expr(e2)\n+        ExprIndex(ref e1, ref e2) => [e1, e2].iter().any(|e| loop_exit_expr(e, loops)),\n+        ExprIf(ref e, ref e2, ref e3) => loop_exit_expr(e, loops)\n+            || e3.as_ref().map_or(false, |e3| loop_exit_expr(e3, loops)) && loop_exit_expr(e2, loops),\n+        ExprLoop(ref b, _, _) => {\n+            loops.push(expr.id);\n+            let val = loop_exit_block(b, loops);\n+            loops.pop();\n+            val\n+        },\n+        ExprWhile(ref e, ref b, _) => {\n+            loops.push(expr.id);\n+            let val = loop_exit_expr(e, loops) || loop_exit_block(b, loops);\n+            loops.pop();\n+            val\n         },\n-        ExprWhile(ref e, ref b, _) => loop_exit_expr(e) || loop_exit_block(b),\n-        ExprMatch(ref e, ref arms, _) => loop_exit_expr(e) || arms.iter().all(|a| loop_exit_expr(&a.body)),\n-        ExprBlock(ref b) => loop_exit_block(b),\n-        ExprBreak(_, _) | ExprAgain(_) | ExprRet(_) => true,\n+        ExprMatch(ref e, ref arms, _) => loop_exit_expr(e, loops) || arms.iter().all(|a| loop_exit_expr(&a.body, loops)),\n+        ExprBlock(ref b) => loop_exit_block(b, loops),\n+        ExprAgain(d) => d.target_id.opt_id().map_or(false, |id| loops.iter().skip(1).all(|&id2| id != id2)),\n+        ExprBreak(d, _) => d.target_id.opt_id().map_or(false, |id| loops[0] == id),\n+        ExprRet(_) => true,\n         _ => false,\n     }\n }"}, {"sha": "715a83efd93da4c36fcf6373148463d9c66db0af", "filename": "tests/ui/never_loop.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/12a7d1489aed893de9c6dc0a520e44cf3d349387/tests%2Fui%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12a7d1489aed893de9c6dc0a520e44cf3d349387/tests%2Fui%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_loop.rs?ref=12a7d1489aed893de9c6dc0a520e44cf3d349387", "patch": "@@ -126,6 +126,19 @@ pub fn test12(a: bool, b: bool) {\n     }\n }\n \n+pub fn test13() {\n+    let mut a = true;\n+    loop { // infinite loop\n+        while a {\n+            if true {\n+                a = false;\n+                continue;\n+            }\n+            return;\n+        }\n+    }\n+}\n+\n fn main() {\n     test1();\n     test2();\n@@ -139,5 +152,6 @@ fn main() {\n     test10();\n     test11(|| 0);\n     test12(true, false);\n+    test13();\n }\n "}]}