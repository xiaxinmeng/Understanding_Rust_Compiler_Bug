{"sha": "48fa6f9631868b07309b02f479e2ec523bb58c2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZmE2Zjk2MzE4NjhiMDczMDliMDJmNDc5ZTJlYzUyM2JiNThjMmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-05T19:25:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-05T19:25:37Z"}, "message": "Auto merge of #49696 - alexcrichton:rollup, r=alexcrichton\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #49045 (Make queries thread safe)\n - #49350 (Expand macros in `extern {}` blocks)\n - #49497 (Chalkify - Tweak `Clause` definition and HRTBs)\n - #49597 (proc_macro: Reorganize public API)\n - #49686 (typos)\n- #49621\n- #49697\n- #49705\n\nFailed merges:", "tree": {"sha": "f42e4285226c191c4448946f440ba79642ba1080", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f42e4285226c191c4448946f440ba79642ba1080"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48fa6f9631868b07309b02f479e2ec523bb58c2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48fa6f9631868b07309b02f479e2ec523bb58c2b", "html_url": "https://github.com/rust-lang/rust/commit/48fa6f9631868b07309b02f479e2ec523bb58c2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48fa6f9631868b07309b02f479e2ec523bb58c2b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7222241e7c2d7caf9ad6ee6e34748e4addfb8dd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7222241e7c2d7caf9ad6ee6e34748e4addfb8dd3", "html_url": "https://github.com/rust-lang/rust/commit/7222241e7c2d7caf9ad6ee6e34748e4addfb8dd3"}, {"sha": "cd615e9863fa4593ff87243920875ad5bb73906a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd615e9863fa4593ff87243920875ad5bb73906a", "html_url": "https://github.com/rust-lang/rust/commit/cd615e9863fa4593ff87243920875ad5bb73906a"}], "stats": {"total": 1856, "additions": 1420, "deletions": 436}, "files": [{"sha": "f36ad67b111033ba47ae675212622fbc20ad6c31", "filename": ".travis.yml", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -21,7 +21,7 @@ matrix:\n     # \"alternate\" deployments, these are \"nightlies\" but have LLVM assertions\n     # turned on, they're deployed to a different location primarily for\n     # additional testing.\n-    - env: IMAGE=dist-x86_64-linux DEPLOY_ALT=1\n+    - env: IMAGE=dist-x86_64-linux DEPLOY_ALT=1 CI_JOB_NAME=dist-x86_64-linux-alt\n       if: branch = try OR branch = auto\n \n     - env: >\n@@ -33,6 +33,7 @@ matrix:\n         MACOSX_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n+        CI_JOB_NAME=dist-x86_64-apple-alt\n       os: osx\n       osx_image: xcode9.3-moar\n       if: branch = auto\n@@ -53,6 +54,7 @@ matrix:\n         MACOSX_STD_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n+        CI_JOB_NAME=x86_64-apple\n       os: osx\n       osx_image: xcode9.3-moar\n       if: branch = auto\n@@ -66,6 +68,7 @@ matrix:\n         MACOSX_STD_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n+        CI_JOB_NAME=i686-apple\n       os: osx\n       osx_image: xcode9.3-moar\n       if: branch = auto\n@@ -85,6 +88,7 @@ matrix:\n         MACOSX_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n+        CI_JOB_NAME=dist-i686-apple\n       os: osx\n       osx_image: xcode9.3-moar\n       if: branch = auto\n@@ -98,6 +102,7 @@ matrix:\n         MACOSX_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n+        CI_JOB_NAME=dist-x86_64-apple\n       os: osx\n       osx_image: xcode9.3-moar\n       if: branch = auto"}, {"sha": "a15f3dd8d5cac2b957daab5e0ee6fa91a14c9176", "filename": "appveyor.yml", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -18,25 +18,31 @@ environment:\n   - MSYS_BITS: 64\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n     SCRIPT: python x.py test\n+    CI_JOB_NAME: x86_64-msvc\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n     SCRIPT: make appveyor-subset-1\n+    CI_JOB_NAME: i686-msvc-1\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n     SCRIPT: make appveyor-subset-2\n+    CI_JOB_NAME: i686-msvc-2\n \n   # MSVC aux tests\n   - MSYS_BITS: 64\n     RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+    CI_JOB_NAME: x86_64-msvc-aux\n   - MSYS_BITS: 64\n     SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+    CI_JOB_NAME: x86_64-msvc-cargo\n \n   # MSVC tools tests\n   - MSYS_BITS: 64\n     SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstates.json windows\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstates.json --enable-test-miri\n+    CI_JOB_NAME: x86_64-msvc-tools\n \n   # 32/64-bit MinGW builds.\n   #\n@@ -57,18 +63,21 @@ environment:\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n     MINGW_DIR: mingw32\n+    CI_JOB_NAME: i686-mingw-1\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n     SCRIPT: make appveyor-subset-2\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n     MINGW_DIR: mingw32\n+    CI_JOB_NAME: i686-mingw-2\n   - MSYS_BITS: 64\n     SCRIPT: python x.py test\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n     MINGW_DIR: mingw64\n+    CI_JOB_NAME: x86_64-mingw\n \n   # 32/64 bit MSVC and GNU deployment\n   - RUST_CONFIGURE_ARGS: >\n@@ -77,33 +86,38 @@ environment:\n       --enable-profiler\n     SCRIPT: python x.py dist\n     DEPLOY: 1\n+    CI_JOB_NAME: dist-x86_64-msvc\n   - RUST_CONFIGURE_ARGS: >\n       --build=i686-pc-windows-msvc\n       --target=i586-pc-windows-msvc\n       --enable-full-tools\n       --enable-profiler\n     SCRIPT: python x.py dist\n     DEPLOY: 1\n+    CI_JOB_NAME: dist-i686-msvc\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools\n     SCRIPT: python x.py dist\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n     MINGW_DIR: mingw32\n     DEPLOY: 1\n+    CI_JOB_NAME: dist-i686-mingw\n   - MSYS_BITS: 64\n     SCRIPT: python x.py dist\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n     MINGW_DIR: mingw64\n     DEPLOY: 1\n+    CI_JOB_NAME: dist-x86_64-mingw\n \n   # \"alternate\" deployment, see .travis.yml for more info\n   - MSYS_BITS: 64\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n     SCRIPT: python x.py dist\n     DEPLOY_ALT: 1\n+    CI_JOB_NAME: dist-x86_64-msvc-alt\n \n matrix:\n   fast_finish: true"}, {"sha": "c470ae7eb30306cdaa081c06e3c5d79e4d3b90c3", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -130,6 +130,7 @@ exec docker \\\n   --env TRAVIS \\\n   --env TRAVIS_BRANCH \\\n   --env TOOLSTATE_REPO_ACCESS_TOKEN \\\n+  --env CI_JOB_NAME=\"${CI_JOB_NAME-$IMAGE}\" \\\n   --volume \"$HOME/.cargo:/cargo\" \\\n   --volume \"$HOME/rustsrc:$HOME/rustsrc\" \\\n   --init \\"}, {"sha": "119b239d6b290177ac4c41b9cb19ab0a9271ef18", "filename": "src/ci/run.sh", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -11,6 +11,10 @@\n \n set -e\n \n+if [ -n \"$CI_JOB_NAME\" ]; then\n+  echo \"[CI_JOB_NAME=$CI_JOB_NAME]\"\n+fi\n+\n if [ \"$NO_CHANGE_USER\" = \"\" ]; then\n   if [ \"$LOCAL_USER_ID\" != \"\" ]; then\n     useradd --shell /bin/bash -u $LOCAL_USER_ID -o -c \"\" -m user"}, {"sha": "71b53cc88e54dfef3ec2b22ce57a182e265c1067", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -845,3 +845,6 @@ impl<T: ?Sized> fmt::Pointer for PinBox<T> {\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<PinBox<U>> for PinBox<T> {}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+unsafe impl<T: ?Sized> Unpin for PinBox<T> {}"}, {"sha": "e3f08926610f69592ecb583a7165b05d5fc0ddad", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -1213,3 +1213,6 @@ impl<'a, T: ?Sized> fmt::Pointer for Pin<'a, T> {\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Pin<'a, U>> for Pin<'a, T> {}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+unsafe impl<'a, T: ?Sized> Unpin for Pin<'a, T> {}"}, {"sha": "ebd5c834fd0364cd0918048500d197d7e66b4573", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 568, "deletions": 185, "changes": 753, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -59,7 +59,7 @@ use syntax::errors::DiagnosticBuilder;\n use syntax::parse::{self, token};\n use syntax::symbol::Symbol;\n use syntax::tokenstream;\n-use syntax_pos::DUMMY_SP;\n+use syntax::parse::lexer::comments;\n use syntax_pos::{FileMap, Pos, SyntaxContext, FileName};\n use syntax_pos::hygiene::Mark;\n \n@@ -73,7 +73,7 @@ use syntax_pos::hygiene::Mark;\n /// The API of this type is intentionally bare-bones, but it'll be expanded over\n /// time!\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub struct TokenStream(tokenstream::TokenStream);\n \n /// Error returned from `TokenStream::from_str`.\n@@ -83,6 +83,20 @@ pub struct LexError {\n     _inner: (),\n }\n \n+impl TokenStream {\n+    /// Returns an empty `TokenStream`.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn empty() -> TokenStream {\n+        TokenStream(tokenstream::TokenStream::empty())\n+    }\n+\n+    /// Checks if this `TokenStream` is empty.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+}\n+\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl FromStr for TokenStream {\n     type Err = LexError;\n@@ -110,19 +124,12 @@ impl fmt::Display for TokenStream {\n     }\n }\n \n-/// `quote!(..)` accepts arbitrary tokens and expands into a `TokenStream` describing the input.\n-/// For example, `quote!(a + b)` will produce a expression, that, when evaluated, constructs\n-/// the `TokenStream` `[Word(\"a\"), Op('+', Alone), Word(\"b\")]`.\n-///\n-/// Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.\n-/// To quote `$` itself, use `$$`.\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-#[macro_export]\n-macro_rules! quote { () => {} }\n-\n-#[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n-#[doc(hidden)]\n-mod quote;\n+#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n+impl fmt::Debug for TokenStream {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl From<TokenTree> for TokenStream {\n@@ -132,62 +139,79 @@ impl From<TokenTree> for TokenStream {\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl From<TokenNode> for TokenStream {\n-    fn from(kind: TokenNode) -> TokenStream {\n-        TokenTree::from(kind).into()\n-    }\n-}\n-\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl<T: Into<TokenStream>> iter::FromIterator<T> for TokenStream {\n-    fn from_iter<I: IntoIterator<Item = T>>(streams: I) -> Self {\n+impl iter::FromIterator<TokenTree> for TokenStream {\n+    fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n         let mut builder = tokenstream::TokenStreamBuilder::new();\n-        for stream in streams {\n-            builder.push(stream.into().0);\n+        for tree in trees {\n+            builder.push(tree.to_internal());\n         }\n         TokenStream(builder.build())\n     }\n }\n \n+/// Implementation details for the `TokenTree` type, such as iterators.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl IntoIterator for TokenStream {\n-    type Item = TokenTree;\n-    type IntoIter = TokenTreeIter;\n+pub mod token_stream {\n+    use syntax::tokenstream;\n+    use syntax_pos::DUMMY_SP;\n+\n+    use {TokenTree, TokenStream, Delimiter};\n \n-    fn into_iter(self) -> TokenTreeIter {\n-        TokenTreeIter { cursor: self.0.trees(), stack: Vec::new() }\n+    /// An iterator over `TokenTree`s.\n+    #[derive(Clone)]\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub struct IntoIter {\n+        cursor: tokenstream::Cursor,\n+        stack: Vec<TokenTree>,\n     }\n-}\n \n-impl TokenStream {\n-    /// Returns an empty `TokenStream`.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn empty() -> TokenStream {\n-        TokenStream(tokenstream::TokenStream::empty())\n+    impl Iterator for IntoIter {\n+        type Item = TokenTree;\n+\n+        fn next(&mut self) -> Option<TokenTree> {\n+            loop {\n+                let tree = self.stack.pop().or_else(|| {\n+                    let next = self.cursor.next_as_stream()?;\n+                    Some(TokenTree::from_internal(next, &mut self.stack))\n+                })?;\n+                if tree.span().0 == DUMMY_SP {\n+                    if let TokenTree::Group(ref group) = tree {\n+                        if group.delimiter() == Delimiter::None {\n+                            self.cursor.insert(group.stream.clone().0);\n+                            continue\n+                        }\n+                    }\n+                }\n+                return Some(tree);\n+            }\n+        }\n     }\n \n-    /// Checks if this `TokenStream` is empty.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn is_empty(&self) -> bool {\n-        self.0.is_empty()\n+    impl IntoIterator for TokenStream {\n+        type Item = TokenTree;\n+        type IntoIter = IntoIter;\n+\n+        fn into_iter(self) -> IntoIter {\n+            IntoIter { cursor: self.0.trees(), stack: Vec::new() }\n+        }\n     }\n }\n \n-/// A region of source code, along with macro expansion information.\n+/// `quote!(..)` accepts arbitrary tokens and expands into a `TokenStream` describing the input.\n+/// For example, `quote!(a + b)` will produce a expression, that, when evaluated, constructs\n+/// the `TokenStream` `[Word(\"a\"), Op('+', Alone), Word(\"b\")]`.\n+///\n+/// Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.\n+/// To quote `$` itself, use `$$`.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct Span(syntax_pos::Span);\n+#[macro_export]\n+macro_rules! quote { () => {} }\n \n-impl Span {\n-    /// A span that resolves at the macro definition site.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn def_site() -> Span {\n-        ::__internal::with_sess(|(_, mark)| {\n-            let call_site = mark.expn_info().unwrap().call_site;\n-            Span(call_site.with_ctxt(SyntaxContext::empty().apply_mark(mark)))\n-        })\n-    }\n-}\n+#[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n+#[doc(hidden)]\n+mod quote;\n \n /// Quote a `Span` into a `TokenStream`.\n /// This is needed to implement a custom quoter.\n@@ -196,6 +220,11 @@ pub fn quote_span(span: Span) -> TokenStream {\n     quote::Quote::quote(span)\n }\n \n+/// A region of source code, along with macro expansion information.\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[derive(Copy, Clone, Debug)]\n+pub struct Span(syntax_pos::Span);\n+\n macro_rules! diagnostic_method {\n     ($name:ident, $level:expr) => (\n         /// Create a new `Diagnostic` with the given `message` at the span\n@@ -208,6 +237,15 @@ macro_rules! diagnostic_method {\n }\n \n impl Span {\n+    /// A span that resolves at the macro definition site.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn def_site() -> Span {\n+        ::__internal::with_sess(|(_, mark)| {\n+            let call_site = mark.expn_info().unwrap().call_site;\n+            Span(call_site.with_ctxt(SyntaxContext::empty().apply_mark(mark)))\n+        })\n+    }\n+\n     /// The span of the invocation of the current procedural macro.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn call_site() -> Span {\n@@ -284,6 +322,12 @@ impl Span {\n         other.resolved_at(*self)\n     }\n \n+    /// Compares to spans to see if they're equal.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn eq(&self, other: &Span) -> bool {\n+        self.0 == other.0\n+    }\n+\n     diagnostic_method!(error, Level::Error);\n     diagnostic_method!(warning, Level::Warning);\n     diagnostic_method!(note, Level::Note);\n@@ -379,39 +423,97 @@ impl PartialEq<FileName> for SourceFile {\n /// A single token or a delimited sequence of token trees (e.g. `[1, (), ..]`).\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n #[derive(Clone, Debug)]\n-pub struct TokenTree {\n-    /// The `TokenTree`'s span\n-    pub span: Span,\n-    /// Description of the `TokenTree`\n-    pub kind: TokenNode,\n+pub enum TokenTree {\n+    /// A delimited tokenstream\n+    Group(Group),\n+    /// A unicode identifier\n+    Term(Term),\n+    /// A punctuation character (`+`, `,`, `$`, etc.).\n+    Op(Op),\n+    /// A literal character (`'a'`), string (`\"hello\"`), number (`2.3`), etc.\n+    Literal(Literal),\n+}\n+\n+impl TokenTree {\n+    /// Returns the span of this token, accessing the `span` method of each of\n+    /// the internal tokens.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn span(&self) -> Span {\n+        match *self {\n+            TokenTree::Group(ref t) => t.span(),\n+            TokenTree::Term(ref t) => t.span(),\n+            TokenTree::Op(ref t) => t.span(),\n+            TokenTree::Literal(ref t) => t.span(),\n+        }\n+    }\n+\n+    /// Configures the span for *only this token*.\n+    ///\n+    /// Note that if this token is a `Group` then this method will not configure\n+    /// the span of each of the internal tokens, this will simply delegate to\n+    /// the `set_span` method of each variant.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn set_span(&mut self, span: Span) {\n+        match *self {\n+            TokenTree::Group(ref mut t) => t.set_span(span),\n+            TokenTree::Term(ref mut t) => t.set_span(span),\n+            TokenTree::Op(ref mut t) => t.set_span(span),\n+            TokenTree::Literal(ref mut t) => t.set_span(span),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl From<Group> for TokenTree {\n+    fn from(g: Group) -> TokenTree {\n+        TokenTree::Group(g)\n+    }\n+}\n+\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl From<Term> for TokenTree {\n+    fn from(g: Term) -> TokenTree {\n+        TokenTree::Term(g)\n+    }\n+}\n+\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl From<Op> for TokenTree {\n+    fn from(g: Op) -> TokenTree {\n+        TokenTree::Op(g)\n+    }\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl From<TokenNode> for TokenTree {\n-    fn from(kind: TokenNode) -> TokenTree {\n-        TokenTree { span: Span::def_site(), kind: kind }\n+impl From<Literal> for TokenTree {\n+    fn from(g: Literal) -> TokenTree {\n+        TokenTree::Literal(g)\n     }\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl fmt::Display for TokenTree {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        TokenStream::from(self.clone()).fmt(f)\n+        match *self {\n+            TokenTree::Group(ref t) => t.fmt(f),\n+            TokenTree::Term(ref t) => t.fmt(f),\n+            TokenTree::Op(ref t) => t.fmt(f),\n+            TokenTree::Literal(ref t) => t.fmt(f),\n+        }\n     }\n }\n \n-/// Description of a `TokenTree`\n+/// A delimited token stream\n+///\n+/// A `Group` internally contains a `TokenStream` which is delimited by a\n+/// `Delimiter`. Groups represent multiple tokens internally and have a `Span`\n+/// for the entire stream.\n #[derive(Clone, Debug)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-pub enum TokenNode {\n-    /// A delimited tokenstream.\n-    Group(Delimiter, TokenStream),\n-    /// A unicode identifier.\n-    Term(Term),\n-    /// A punctuation character (`+`, `,`, `$`, etc.).\n-    Op(char, Spacing),\n-    /// A literal character (`'a'`), string (`\"hello\"`), or number (`2.3`).\n-    Literal(Literal),\n+pub struct Group {\n+    delimiter: Delimiter,\n+    stream: TokenStream,\n+    span: Span,\n }\n \n /// Describes how a sequence of token trees is delimited.\n@@ -428,25 +530,74 @@ pub enum Delimiter {\n     None,\n }\n \n-/// An interned string.\n-#[derive(Copy, Clone, Debug)]\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-pub struct Term(Symbol);\n+impl Group {\n+    /// Creates a new `group` with the given delimiter and token stream.\n+    ///\n+    /// This constructor will set the span for this group to\n+    /// `Span::call_site()`. To change the span you can use the `set_span`\n+    /// method below.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn new(delimiter: Delimiter, stream: TokenStream) -> Group {\n+        Group {\n+            delimiter: delimiter,\n+            stream: stream,\n+            span: Span::call_site(),\n+        }\n+    }\n \n-impl Term {\n-    /// Intern a string into a `Term`.\n+    /// Returns the delimiter of this `Group`\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn intern(string: &str) -> Term {\n-        Term(Symbol::intern(string))\n+    pub fn delimiter(&self) -> Delimiter {\n+        self.delimiter\n     }\n \n-    /// Get a reference to the interned string.\n+    /// Returns the `TokenStream` of tokens that are delimited in this `Group`.\n+    ///\n+    /// Note that the returned token stream does not include the delimiter\n+    /// returned above.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn as_str(&self) -> &str {\n-        unsafe { &*(&*self.0.as_str() as *const str) }\n+    pub fn stream(&self) -> TokenStream {\n+        self.stream.clone()\n+    }\n+\n+    /// Returns the span for the delimiters of this token stream, spanning the\n+    /// entire `Group`.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn span(&self) -> Span {\n+        self.span\n+    }\n+\n+    /// Configures the span for this `Group`'s delimiters, but not its internal\n+    /// tokens.\n+    ///\n+    /// This method will **not** set the span of all the internal tokens spanned\n+    /// by this group, but rather it will only set the span of the delimiter\n+    /// tokens at the level of the `Group`.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn set_span(&mut self, span: Span) {\n+        self.span = span;\n     }\n }\n \n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl fmt::Display for Group {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        TokenStream::from(TokenTree::from(self.clone())).fmt(f)\n+    }\n+}\n+\n+/// An `Op` is an operator like `+` or `-`, and only represents one character.\n+///\n+/// Operators like `+=` are represented as two instance of `Op` with different\n+/// forms of `Spacing` returned.\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[derive(Copy, Clone, Debug)]\n+pub struct Op {\n+    op: char,\n+    spacing: Spacing,\n+    span: Span,\n+}\n+\n /// Whether an `Op` is either followed immediately by another `Op` or followed by whitespace.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n@@ -457,68 +608,285 @@ pub enum Spacing {\n     Joint,\n }\n \n-/// A literal character (`'a'`), string (`\"hello\"`), or number (`2.3`).\n-#[derive(Clone, Debug)]\n+impl Op {\n+    /// Creates a new `Op` from the given character and spacing.\n+    ///\n+    /// The returned `Op` will have the default span of `Span::call_site()`\n+    /// which can be further configured with the `set_span` method below.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn new(op: char, spacing: Spacing) -> Op {\n+        Op {\n+            op: op,\n+            spacing: spacing,\n+            span: Span::call_site(),\n+        }\n+    }\n+\n+    /// Returns the character this operation represents, for example `'+'`\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn op(&self) -> char {\n+        self.op\n+    }\n+\n+    /// Returns the spacing of this operator, indicating whether it's a joint\n+    /// operator with more operators coming next in the token stream or an\n+    /// `Alone` meaning that the operator has ended.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn spacing(&self) -> Spacing {\n+        self.spacing\n+    }\n+\n+    /// Returns the span for this operator character\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn span(&self) -> Span {\n+        self.span\n+    }\n+\n+    /// Configure the span for this operator's character\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn set_span(&mut self, span: Span) {\n+        self.span = span;\n+    }\n+}\n+\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-pub struct Literal(token::Token);\n+impl fmt::Display for Op {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        TokenStream::from(TokenTree::from(self.clone())).fmt(f)\n+    }\n+}\n \n+/// An interned string.\n+#[derive(Copy, Clone, Debug)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl fmt::Display for Literal {\n+pub struct Term {\n+    sym: Symbol,\n+    span: Span,\n+}\n+\n+impl Term {\n+    /// Creates a new `Term` with the given `string` as well as the specified\n+    /// `span`.\n+    ///\n+    /// Note that `span`, currently in rustc, configures the hygiene information\n+    /// for this identifier. As of this time `Span::call_site()` explicitly\n+    /// opts-in to **non-hygienic** information (aka copy/pasted code) while\n+    /// spans like `Span::def_site()` will opt-in to hygienic information,\n+    /// meaning that code at the call site of the macro can't access this\n+    /// identifier.\n+    ///\n+    /// Due to the current importance of hygiene this constructor, unlike other\n+    /// tokens, requires a `Span` to be specified at construction.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn new(string: &str, span: Span) -> Term {\n+        Term {\n+            sym: Symbol::intern(string),\n+            span,\n+        }\n+    }\n+\n+    /// Get a reference to the interned string.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn as_str(&self) -> &str {\n+        unsafe { &*(&*self.sym.as_str() as *const str) }\n+    }\n+\n+    /// Returns the span of this `Term`, encompassing the entire string returned\n+    /// by `as_str`.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn span(&self) -> Span {\n+        self.span\n+    }\n+\n+    /// Configures the span of this `Term`, possibly changing hygiene\n+    /// information.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn set_span(&mut self, span: Span) {\n+        self.span = span;\n+    }\n+}\n+\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+impl fmt::Display for Term {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        TokenTree { kind: TokenNode::Literal(self.clone()), span: Span(DUMMY_SP) }.fmt(f)\n+        self.as_str().fmt(f)\n     }\n }\n \n-macro_rules! int_literals {\n-    ($($int_kind:ident),*) => {$(\n-        /// Integer literal.\n+/// A literal character (`'a'`), string (`\"hello\"`), a number (`2.3`), etc.\n+#[derive(Clone, Debug)]\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+pub struct Literal {\n+    token: token::Token,\n+    span: Span,\n+}\n+\n+macro_rules! suffixed_int_literals {\n+    ($($name:ident => $kind:ident,)*) => ($(\n+        /// Creates a new suffixed integer literal with the specified value.\n+        ///\n+        /// This function will create an integer like `1u32` where the integer\n+        /// value specified is the first part of the token and the integral is\n+        /// also suffixed at the end.\n+        ///\n+        /// Literals created through this method have the `Span::call_site()`\n+        /// span by default, which can be configured with the `set_span` method\n+        /// below.\n         #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-        pub fn $int_kind(n: $int_kind) -> Literal {\n-            Literal::typed_integer(n as i128, stringify!($int_kind))\n+        pub fn $name(n: $kind) -> Literal {\n+            let lit = token::Lit::Integer(Symbol::intern(&n.to_string()));\n+            let ty = Some(Symbol::intern(stringify!($kind)));\n+            Literal {\n+                token: token::Literal(lit, ty),\n+                span: Span::call_site(),\n+            }\n         }\n-    )*}\n+    )*)\n+}\n+\n+macro_rules! unsuffixed_int_literals {\n+    ($($name:ident => $kind:ident,)*) => ($(\n+        /// Creates a new unsuffixed integer literal with the specified value.\n+        ///\n+        /// This function will create an integer like `1` where the integer\n+        /// value specified is the first part of the token. No suffix is\n+        /// specified on this token, meaning that invocations like\n+        /// `Literal::i8_unsuffixed(1)` are equivalent to\n+        /// `Literal::u32_unsuffixed(1)`.\n+        ///\n+        /// Literals created through this method have the `Span::call_site()`\n+        /// span by default, which can be configured with the `set_span` method\n+        /// below.\n+        #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+        pub fn $name(n: $kind) -> Literal {\n+            let lit = token::Lit::Integer(Symbol::intern(&n.to_string()));\n+            Literal {\n+                token: token::Literal(lit, None),\n+                span: Span::call_site(),\n+            }\n+        }\n+    )*)\n }\n \n impl Literal {\n-    /// Integer literal\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn integer(n: i128) -> Literal {\n-        Literal(token::Literal(token::Lit::Integer(Symbol::intern(&n.to_string())), None))\n+    suffixed_int_literals! {\n+        u8_suffixed => u8,\n+        u16_suffixed => u16,\n+        u32_suffixed => u32,\n+        u64_suffixed => u64,\n+        u128_suffixed => u128,\n+        usize_suffixed => usize,\n+        i8_suffixed => i8,\n+        i16_suffixed => i16,\n+        i32_suffixed => i32,\n+        i64_suffixed => i64,\n+        i128_suffixed => i128,\n+        isize_suffixed => isize,\n     }\n \n-    int_literals!(u8, i8, u16, i16, u32, i32, u64, i64, usize, isize);\n-    fn typed_integer(n: i128, kind: &'static str) -> Literal {\n-        Literal(token::Literal(token::Lit::Integer(Symbol::intern(&n.to_string())),\n-                               Some(Symbol::intern(kind))))\n+    unsuffixed_int_literals! {\n+        u8_unsuffixed => u8,\n+        u16_unsuffixed => u16,\n+        u32_unsuffixed => u32,\n+        u64_unsuffixed => u64,\n+        u128_unsuffixed => u128,\n+        usize_unsuffixed => usize,\n+        i8_unsuffixed => i8,\n+        i16_unsuffixed => i16,\n+        i32_unsuffixed => i32,\n+        i64_unsuffixed => i64,\n+        i128_unsuffixed => i128,\n+        isize_unsuffixed => isize,\n     }\n \n-    /// Floating point literal.\n+    /// Creates a new unsuffixed floating-point literal.\n+    ///\n+    /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n+    /// the float's value is emitted directly into the token but no suffix is\n+    /// used, so it may be inferred to be a `f64` later in the compiler.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function requires that the specified float is finite, for\n+    /// example if it is infinity or NaN this function will panic.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn float(n: f64) -> Literal {\n+    pub fn f32_unsuffixed(n: f32) -> Literal {\n         if !n.is_finite() {\n             panic!(\"Invalid float literal {}\", n);\n         }\n-        Literal(token::Literal(token::Lit::Float(Symbol::intern(&n.to_string())), None))\n+        let lit = token::Lit::Float(Symbol::intern(&n.to_string()));\n+        Literal {\n+            token: token::Literal(lit, None),\n+            span: Span::call_site(),\n+        }\n     }\n \n-    /// Floating point literal.\n+    /// Creates a new suffixed floating-point literal.\n+    ///\n+    /// This consturctor will create a literal like `1.0f32` where the value\n+    /// specified is the preceding part of the token and `f32` is the suffix of\n+    /// the token. This token will always be inferred to be an `f32` in the\n+    /// compiler.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function requires that the specified float is finite, for\n+    /// example if it is infinity or NaN this function will panic.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn f32(n: f32) -> Literal {\n+    pub fn f32_suffixed(n: f32) -> Literal {\n         if !n.is_finite() {\n-            panic!(\"Invalid f32 literal {}\", n);\n+            panic!(\"Invalid float literal {}\", n);\n+        }\n+        let lit = token::Lit::Float(Symbol::intern(&n.to_string()));\n+        Literal {\n+            token: token::Literal(lit, Some(Symbol::intern(\"f32\"))),\n+            span: Span::call_site(),\n         }\n-        Literal(token::Literal(token::Lit::Float(Symbol::intern(&n.to_string())),\n-                               Some(Symbol::intern(\"f32\"))))\n     }\n \n-    /// Floating point literal.\n+    /// Creates a new unsuffixed floating-point literal.\n+    ///\n+    /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n+    /// the float's value is emitted directly into the token but no suffix is\n+    /// used, so it may be inferred to be a `f64` later in the compiler.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function requires that the specified float is finite, for\n+    /// example if it is infinity or NaN this function will panic.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn f64(n: f64) -> Literal {\n+    pub fn f64_unsuffixed(n: f64) -> Literal {\n         if !n.is_finite() {\n-            panic!(\"Invalid f64 literal {}\", n);\n+            panic!(\"Invalid float literal {}\", n);\n+        }\n+        let lit = token::Lit::Float(Symbol::intern(&n.to_string()));\n+        Literal {\n+            token: token::Literal(lit, None),\n+            span: Span::call_site(),\n+        }\n+    }\n+\n+    /// Creates a new suffixed floating-point literal.\n+    ///\n+    /// This consturctor will create a literal like `1.0f64` where the value\n+    /// specified is the preceding part of the token and `f64` is the suffix of\n+    /// the token. This token will always be inferred to be an `f64` in the\n+    /// compiler.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function requires that the specified float is finite, for\n+    /// example if it is infinity or NaN this function will panic.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn f64_suffixed(n: f64) -> Literal {\n+        if !n.is_finite() {\n+            panic!(\"Invalid float literal {}\", n);\n+        }\n+        let lit = token::Lit::Float(Symbol::intern(&n.to_string()));\n+        Literal {\n+            token: token::Literal(lit, Some(Symbol::intern(\"f64\"))),\n+            span: Span::call_site(),\n         }\n-        Literal(token::Literal(token::Lit::Float(Symbol::intern(&n.to_string())),\n-                               Some(Symbol::intern(\"f64\"))))\n     }\n \n     /// String literal.\n@@ -528,52 +896,51 @@ impl Literal {\n         for ch in string.chars() {\n             escaped.extend(ch.escape_debug());\n         }\n-        Literal(token::Literal(token::Lit::Str_(Symbol::intern(&escaped)), None))\n+        Literal {\n+            token: token::Literal(token::Lit::Str_(Symbol::intern(&escaped)), None),\n+            span: Span::call_site(),\n+        }\n     }\n \n     /// Character literal.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn character(ch: char) -> Literal {\n         let mut escaped = String::new();\n         escaped.extend(ch.escape_unicode());\n-        Literal(token::Literal(token::Lit::Char(Symbol::intern(&escaped)), None))\n+        Literal {\n+            token: token::Literal(token::Lit::Char(Symbol::intern(&escaped)), None),\n+            span: Span::call_site(),\n+        }\n     }\n \n     /// Byte string literal.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn byte_string(bytes: &[u8]) -> Literal {\n         let string = bytes.iter().cloned().flat_map(ascii::escape_default)\n             .map(Into::<char>::into).collect::<String>();\n-        Literal(token::Literal(token::Lit::ByteStr(Symbol::intern(&string)), None))\n+        Literal {\n+            token: token::Literal(token::Lit::ByteStr(Symbol::intern(&string)), None),\n+            span: Span::call_site(),\n+        }\n     }\n-}\n \n-/// An iterator over `TokenTree`s.\n-#[derive(Clone)]\n-#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-pub struct TokenTreeIter {\n-    cursor: tokenstream::Cursor,\n-    stack: Vec<TokenTree>,\n+    /// Returns the span encompassing this literal.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn span(&self) -> Span {\n+        self.span\n+    }\n+\n+    /// Configures the span associated for this literal.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn set_span(&mut self, span: Span) {\n+        self.span = span;\n+    }\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl Iterator for TokenTreeIter {\n-    type Item = TokenTree;\n-\n-    fn next(&mut self) -> Option<TokenTree> {\n-        loop {\n-            let tree = self.stack.pop().or_else(|| {\n-                let next = self.cursor.next_as_stream()?;\n-                Some(TokenTree::from_internal(next, &mut self.stack))\n-            })?;\n-            if tree.span.0 == DUMMY_SP {\n-                if let TokenNode::Group(Delimiter::None, stream) = tree.kind {\n-                    self.cursor.insert(stream.0);\n-                    continue\n-                }\n-            }\n-            return Some(tree);\n-        }\n+impl fmt::Display for Literal {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        TokenStream::from(TokenTree::from(self.clone())).fmt(f)\n     }\n }\n \n@@ -607,31 +974,34 @@ impl TokenTree {\n             tokenstream::TokenTree::Token(span, token) => (span, token),\n             tokenstream::TokenTree::Delimited(span, delimed) => {\n                 let delimiter = Delimiter::from_internal(delimed.delim);\n-                return TokenTree {\n-                    span: Span(span),\n-                    kind: TokenNode::Group(delimiter, TokenStream(delimed.tts.into())),\n-                };\n+                let mut g = Group::new(delimiter, TokenStream(delimed.tts.into()));\n+                g.set_span(Span(span));\n+                return g.into()\n             }\n         };\n \n         let op_kind = if is_joint { Spacing::Joint } else { Spacing::Alone };\n         macro_rules! tt {\n-            ($e:expr) => (TokenTree { span: Span(span), kind: $e })\n+            ($e:expr) => ({\n+                let mut x = TokenTree::from($e);\n+                x.set_span(Span(span));\n+                x\n+            })\n         }\n         macro_rules! op {\n-            ($a:expr) => (TokenNode::Op($a, op_kind));\n+            ($a:expr) => (tt!(Op::new($a, op_kind)));\n             ($a:expr, $b:expr) => ({\n-                stack.push(tt!(TokenNode::Op($b, op_kind).into()));\n-                TokenNode::Op($a, Spacing::Joint)\n+                stack.push(tt!(Op::new($b, op_kind)));\n+                tt!(Op::new($a, Spacing::Joint))\n             });\n             ($a:expr, $b:expr, $c:expr) => ({\n-                stack.push(tt!(TokenNode::Op($c, op_kind)));\n-                stack.push(tt!(TokenNode::Op($b, Spacing::Joint)));\n-                TokenNode::Op($a, Spacing::Joint)\n+                stack.push(tt!(Op::new($c, op_kind)));\n+                stack.push(tt!(Op::new($b, Spacing::Joint)));\n+                tt!(Op::new($a, Spacing::Joint))\n             })\n         }\n \n-        let kind = match token {\n+        match token {\n             Eq => op!('='),\n             Lt => op!('<'),\n             Le => op!('<', '='),\n@@ -679,80 +1049,93 @@ impl TokenTree {\n             Dollar => op!('$'),\n             Question => op!('?'),\n \n-            Ident(ident, false) | Lifetime(ident) => TokenNode::Term(Term(ident.name)),\n-            Ident(ident, true) => TokenNode::Term(Term(Symbol::intern(&format!(\"r#{}\", ident)))),\n-            Literal(..) => TokenNode::Literal(self::Literal(token)),\n+            Ident(ident, false) | Lifetime(ident) => {\n+                tt!(Term::new(&ident.name.as_str(), Span(span)))\n+            }\n+            Ident(ident, true) => {\n+                tt!(Term::new(&format!(\"r#{}\", ident), Span(span)))\n+            }\n+            Literal(..) => tt!(self::Literal { token, span: Span(span) }),\n             DocComment(c) => {\n+                let style = comments::doc_comment_style(&c.as_str());\n+                let stripped = comments::strip_doc_comment_decoration(&c.as_str());\n                 let stream = vec![\n-                    tt!(TokenNode::Term(Term::intern(\"doc\"))),\n-                    tt!(op!('=')),\n-                    tt!(TokenNode::Literal(self::Literal(Literal(Lit::Str_(c), None)))),\n+                    tt!(Term::new(\"doc\", Span(span))),\n+                    tt!(Op::new('=', Spacing::Alone)),\n+                    tt!(self::Literal::string(&stripped)),\n                 ].into_iter().collect();\n-                stack.push(tt!(TokenNode::Group(Delimiter::Bracket, stream)));\n-                op!('#')\n+                stack.push(tt!(Group::new(Delimiter::Bracket, stream)));\n+                if style == ast::AttrStyle::Inner {\n+                    stack.push(tt!(Op::new('!', Spacing::Alone)));\n+                }\n+                tt!(Op::new('#', Spacing::Alone))\n             }\n \n             Interpolated(_) => {\n                 __internal::with_sess(|(sess, _)| {\n                     let tts = token.interpolated_to_tokenstream(sess, span);\n-                    TokenNode::Group(Delimiter::None, TokenStream(tts))\n+                    tt!(Group::new(Delimiter::None, TokenStream(tts)))\n                 })\n             }\n \n             DotEq => op!('.', '='),\n             OpenDelim(..) | CloseDelim(..) => unreachable!(),\n             Whitespace | Comment | Shebang(..) | Eof => unreachable!(),\n-        };\n-\n-        TokenTree { span: Span(span), kind: kind }\n+        }\n     }\n \n     fn to_internal(self) -> tokenstream::TokenStream {\n         use syntax::parse::token::*;\n         use syntax::tokenstream::{TokenTree, Delimited};\n \n-        let (op, kind) = match self.kind {\n-            TokenNode::Op(op, kind) => (op, kind),\n-            TokenNode::Group(delimiter, tokens) => {\n-                return TokenTree::Delimited(self.span.0, Delimited {\n-                    delim: delimiter.to_internal(),\n-                    tts: tokens.0.into(),\n+        let (op, kind, span) = match self {\n+            self::TokenTree::Op(tt) => (tt.op(), tt.spacing(), tt.span()),\n+            self::TokenTree::Group(tt) => {\n+                return TokenTree::Delimited(tt.span.0, Delimited {\n+                    delim: tt.delimiter.to_internal(),\n+                    tts: tt.stream.0.into(),\n                 }).into();\n             },\n-            TokenNode::Term(symbol) => {\n-                let ident = ast::Ident { name: symbol.0, ctxt: self.span.0.ctxt() };\n-                let sym_str = symbol.0.as_str();\n+            self::TokenTree::Term(tt) => {\n+                let ident = ast::Ident { name: tt.sym, ctxt: tt.span.0.ctxt() };\n+                let sym_str = tt.sym.as_str();\n                 let token =\n                     if sym_str.starts_with(\"'\") { Lifetime(ident) }\n                     else if sym_str.starts_with(\"r#\") {\n                         let name = Symbol::intern(&sym_str[2..]);\n-                        let ident = ast::Ident { name, ctxt: self.span.0.ctxt() };\n+                        let ident = ast::Ident { name, ctxt: tt.span.0.ctxt() };\n                         Ident(ident, true)\n                     } else { Ident(ident, false) };\n-                return TokenTree::Token(self.span.0, token).into();\n+                return TokenTree::Token(tt.span.0, token).into();\n             }\n-            TokenNode::Literal(self::Literal(Literal(Lit::Integer(ref a), b)))\n+            self::TokenTree::Literal(self::Literal {\n+                token: Literal(Lit::Integer(ref a), b),\n+                span,\n+            })\n                 if a.as_str().starts_with(\"-\") =>\n             {\n                 let minus = BinOp(BinOpToken::Minus);\n                 let integer = Symbol::intern(&a.as_str()[1..]);\n                 let integer = Literal(Lit::Integer(integer), b);\n-                let a = TokenTree::Token(self.span.0, minus);\n-                let b = TokenTree::Token(self.span.0, integer);\n+                let a = TokenTree::Token(span.0, minus);\n+                let b = TokenTree::Token(span.0, integer);\n                 return vec![a, b].into_iter().collect()\n             }\n-            TokenNode::Literal(self::Literal(Literal(Lit::Float(ref a), b)))\n+            self::TokenTree::Literal(self::Literal {\n+                token: Literal(Lit::Float(ref a), b),\n+                span,\n+            })\n                 if a.as_str().starts_with(\"-\") =>\n             {\n                 let minus = BinOp(BinOpToken::Minus);\n                 let float = Symbol::intern(&a.as_str()[1..]);\n                 let float = Literal(Lit::Float(float), b);\n-                let a = TokenTree::Token(self.span.0, minus);\n-                let b = TokenTree::Token(self.span.0, float);\n+                let a = TokenTree::Token(span.0, minus);\n+                let b = TokenTree::Token(span.0, float);\n                 return vec![a, b].into_iter().collect()\n             }\n-            TokenNode::Literal(token) => {\n-                return TokenTree::Token(self.span.0, token.0).into()\n+            self::TokenTree::Literal(tt) => {\n+                return TokenTree::Token(tt.span.0, tt.token).into()\n             }\n         };\n \n@@ -781,7 +1164,7 @@ impl TokenTree {\n             _ => panic!(\"unsupported character {}\", op),\n         };\n \n-        let tree = TokenTree::Token(self.span.0, token);\n+        let tree = TokenTree::Token(span.0, token);\n         match kind {\n             Spacing::Alone => tree.into(),\n             Spacing::Joint => tree.joint(),"}, {"sha": "cc8575b88be97f9004d8dff382a0724d442a1d8c", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 83, "deletions": 55, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -14,7 +14,7 @@\n //! This quasiquoter uses macros 2.0 hygiene to reliably access\n //! items from `proc_macro`, to build a `proc_macro::TokenStream`.\n \n-use {Delimiter, Literal, Spacing, Span, Term, TokenNode, TokenStream, TokenTree};\n+use {Delimiter, Literal, Spacing, Span, Term, Op, Group, TokenStream, TokenTree};\n \n use syntax::ext::base::{ExtCtxt, ProcMacro};\n use syntax::parse::token;\n@@ -23,47 +23,59 @@ use syntax::tokenstream;\n pub struct Quoter;\n \n pub fn unquote<T: Into<TokenStream> + Clone>(tokens: &T) -> TokenStream {\n-    T::into(tokens.clone())\n+    tokens.clone().into()\n }\n \n pub trait Quote {\n     fn quote(self) -> TokenStream;\n }\n \n+macro_rules! tt2ts {\n+    ($e:expr) => (TokenStream::from(TokenTree::from($e)))\n+}\n+\n macro_rules! quote_tok {\n-    (,) => { TokenNode::Op(',', Spacing::Alone) };\n-    (.) => { TokenNode::Op('.', Spacing::Alone) };\n-    (:) => { TokenNode::Op(':', Spacing::Alone) };\n+    (,) => { tt2ts!(Op::new(',', Spacing::Alone)) };\n+    (.) => { tt2ts!(Op::new('.', Spacing::Alone)) };\n+    (:) => { tt2ts!(Op::new(':', Spacing::Alone)) };\n+    (|) => { tt2ts!(Op::new('|', Spacing::Alone)) };\n     (::) => {\n         [\n-            TokenNode::Op(':', Spacing::Joint),\n-            TokenNode::Op(':', Spacing::Alone)\n-        ].iter().cloned().collect::<TokenStream>()\n+            TokenTree::from(Op::new(':', Spacing::Joint)),\n+            TokenTree::from(Op::new(':', Spacing::Alone)),\n+        ].iter()\n+            .cloned()\n+            .map(|mut x| {\n+                x.set_span(Span::def_site());\n+                x\n+            })\n+            .collect::<TokenStream>()\n     };\n-    (!) => { TokenNode::Op('!', Spacing::Alone) };\n-    (<) => { TokenNode::Op('<', Spacing::Alone) };\n-    (>) => { TokenNode::Op('>', Spacing::Alone) };\n-    (_) => { TokenNode::Op('_', Spacing::Alone) };\n-    (0) => { TokenNode::Literal(::Literal::integer(0)) };\n-    (&) => { TokenNode::Op('&', Spacing::Alone) };\n-    ($i:ident) => { TokenNode::Term(Term::intern(stringify!($i))) };\n+    (!) => { tt2ts!(Op::new('!', Spacing::Alone)) };\n+    (<) => { tt2ts!(Op::new('<', Spacing::Alone)) };\n+    (>) => { tt2ts!(Op::new('>', Spacing::Alone)) };\n+    (_) => { tt2ts!(Op::new('_', Spacing::Alone)) };\n+    (0) => { tt2ts!(Literal::i8_unsuffixed(0)) };\n+    (&) => { tt2ts!(Op::new('&', Spacing::Alone)) };\n+    ($i:ident) => { tt2ts!(Term::new(stringify!($i), Span::def_site())) };\n }\n \n macro_rules! quote_tree {\n     ((unquote $($t:tt)*)) => { $($t)* };\n     ((quote $($t:tt)*)) => { ($($t)*).quote() };\n-    (($($t:tt)*)) => { TokenNode::Group(Delimiter::Parenthesis, quote!($($t)*)) };\n-    ([$($t:tt)*]) => { TokenNode::Group(Delimiter::Bracket, quote!($($t)*)) };\n-    ({$($t:tt)*}) => { TokenNode::Group(Delimiter::Brace, quote!($($t)*)) };\n+    (($($t:tt)*)) => { tt2ts!(Group::new(Delimiter::Parenthesis, quote!($($t)*))) };\n+    ([$($t:tt)*]) => { tt2ts!(Group::new(Delimiter::Bracket, quote!($($t)*))) };\n+    ({$($t:tt)*}) => { tt2ts!(Group::new(Delimiter::Brace, quote!($($t)*))) };\n     ($t:tt) => { quote_tok!($t) };\n }\n \n macro_rules! quote {\n     () => { TokenStream::empty() };\n     ($($t:tt)*) => {\n-        [\n-            $(TokenStream::from(quote_tree!($t)),)*\n-        ].iter().cloned().collect::<TokenStream>()\n+        [$(quote_tree!($t),)*].iter()\n+            .cloned()\n+            .flat_map(|x| x.into_iter())\n+            .collect::<TokenStream>()\n     };\n }\n \n@@ -97,72 +109,81 @@ impl Quote for TokenStream {\n         let tokens = self.into_iter().filter_map(|tree| {\n             if after_dollar {\n                 after_dollar = false;\n-                match tree.kind {\n-                    TokenNode::Term(_) => {\n+                match tree {\n+                    TokenTree::Term(_) => {\n+                        let tree = TokenStream::from(tree);\n                         return Some(quote!(::__internal::unquote(&(unquote tree)),));\n                     }\n-                    TokenNode::Op('$', _) => {}\n+                    TokenTree::Op(ref tt) if tt.op() == '$' => {}\n                     _ => panic!(\"`$` must be followed by an ident or `$` in `quote!`\"),\n                 }\n-            } else if let TokenNode::Op('$', _) = tree.kind {\n-                after_dollar = true;\n-                return None;\n+            } else if let TokenTree::Op(tt) = tree {\n+                if tt.op() == '$' {\n+                    after_dollar = true;\n+                    return None;\n+                }\n             }\n \n             Some(quote!(::TokenStream::from((quote tree)),))\n-        }).collect::<TokenStream>();\n+        }).flat_map(|t| t.into_iter()).collect::<TokenStream>();\n \n         if after_dollar {\n             panic!(\"unexpected trailing `$` in `quote!`\");\n         }\n \n-        quote!([(unquote tokens)].iter().cloned().collect::<::TokenStream>())\n+        quote!(\n+            [(unquote tokens)].iter()\n+                .cloned()\n+                .flat_map(|x| x.into_iter())\n+                .collect::<::TokenStream>()\n+        )\n     }\n }\n \n impl Quote for TokenTree {\n     fn quote(self) -> TokenStream {\n-        quote!(::TokenTree { span: (quote self.span), kind: (quote self.kind) })\n+        match self {\n+            TokenTree::Op(tt) => quote!(::TokenTree::Op( (quote tt) )),\n+            TokenTree::Group(tt) => quote!(::TokenTree::Group( (quote tt) )),\n+            TokenTree::Term(tt) => quote!(::TokenTree::Term( (quote tt) )),\n+            TokenTree::Literal(tt) => quote!(::TokenTree::Literal( (quote tt) )),\n+        }\n     }\n }\n \n-impl Quote for TokenNode {\n+impl Quote for char {\n     fn quote(self) -> TokenStream {\n-        macro_rules! gen_match {\n-            ($($i:ident($($arg:ident),+)),*) => {\n-                match self {\n-                    $(TokenNode::$i($($arg),+) => quote! {\n-                        ::TokenNode::$i($((quote $arg)),+)\n-                    },)*\n-                }\n-            }\n-        }\n+        TokenTree::from(Literal::character(self)).into()\n+    }\n+}\n \n-        gen_match! { Op(op, kind), Group(delim, tokens), Term(term), Literal(lit) }\n+impl<'a> Quote for &'a str {\n+    fn quote(self) -> TokenStream {\n+        TokenTree::from(Literal::string(self)).into()\n     }\n }\n \n-impl Quote for char {\n+impl Quote for usize {\n     fn quote(self) -> TokenStream {\n-        TokenNode::Literal(Literal::character(self)).into()\n+        TokenTree::from(Literal::usize_unsuffixed(self)).into()\n     }\n }\n \n-impl<'a> Quote for &'a str {\n+impl Quote for Group {\n     fn quote(self) -> TokenStream {\n-        TokenNode::Literal(Literal::string(self)).into()\n+        quote!(::Group::new((quote self.delimiter()), (quote self.stream())))\n     }\n }\n \n-impl Quote for usize {\n+impl Quote for Op {\n     fn quote(self) -> TokenStream {\n-        TokenNode::Literal(Literal::integer(self as i128)).into()\n+        quote!(::Op::new((quote self.op()), (quote self.spacing())))\n     }\n }\n \n impl Quote for Term {\n     fn quote(self) -> TokenStream {\n-        quote!(::Term::intern((quote self.as_str())))\n+        quote!(::Term::new((quote self.as_str()), (quote self.span())))\n     }\n }\n \n@@ -182,31 +203,38 @@ macro_rules! literals {\n         impl LiteralKind {\n             pub fn with_contents_and_suffix(self, contents: Term, suffix: Option<Term>)\n                                             -> Literal {\n-                let contents = contents.0;\n-                let suffix = suffix.map(|t| t.0);\n+                let sym = contents.sym;\n+                let suffix = suffix.map(|t| t.sym);\n                 match self {\n                     $(LiteralKind::$i => {\n-                        Literal(token::Literal(token::Lit::$i(contents), suffix))\n+                        Literal {\n+                            token: token::Literal(token::Lit::$i(sym), suffix),\n+                            span: contents.span,\n+                        }\n                     })*\n                     $(LiteralKind::$raw(n) => {\n-                        Literal(token::Literal(token::Lit::$raw(contents, n), suffix))\n+                        Literal {\n+                            token: token::Literal(token::Lit::$raw(sym, n), suffix),\n+                            span: contents.span,\n+                        }\n                     })*\n                 }\n             }\n         }\n \n         impl Literal {\n             fn kind_contents_and_suffix(self) -> (LiteralKind, Term, Option<Term>) {\n-                let (lit, suffix) = match self.0 {\n+                let (lit, suffix) = match self.token {\n                     token::Literal(lit, suffix) => (lit, suffix),\n-                    _ => panic!(\"unsupported literal {:?}\", self.0),\n+                    _ => panic!(\"unsupported literal {:?}\", self.token),\n                 };\n \n                 let (kind, contents) = match lit {\n                     $(token::Lit::$i(contents) => (LiteralKind::$i, contents),)*\n                     $(token::Lit::$raw(contents, n) => (LiteralKind::$raw(n), contents),)*\n                 };\n-                (kind, Term(contents), suffix.map(Term))\n+                let suffix = suffix.map(|sym| Term::new(&sym.as_str(), self.span()));\n+                (kind, Term::new(&contents.as_str(), self.span()), suffix)\n             }\n         }\n "}, {"sha": "b767ede5faa702810212f8e9f0c4448b4396a2d2", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -2724,6 +2724,7 @@ impl<'a> LoweringContext<'a> {\n                         hir::ForeignItemStatic(this.lower_ty(t, ImplTraitContext::Disallowed), m)\n                     }\n                     ForeignItemKind::Ty => hir::ForeignItemType,\n+                    ForeignItemKind::Macro(_) => panic!(\"shouldn't exist here\"),\n                 },\n                 vis: this.lower_visibility(&i.vis, None),\n                 span: i.span,"}, {"sha": "20f46cb348d1d905914bb2ad76bf07b00c9a3a00", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -181,6 +181,10 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n+        if let ForeignItemKind::Macro(_) = foreign_item.node {\n+            return self.visit_macro_invoc(foreign_item.id, false);\n+        }\n+\n         let def = self.create_def(foreign_item.id,\n                                   DefPathData::ValueNs(foreign_item.ident.name.as_str()),\n                                   REGULAR_SPACE,"}, {"sha": "da1a2592f14db64a88b9c5b7f7ac44e64222a86a", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -1392,6 +1392,12 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Goal<'tcx> {\n     }\n }\n \n+impl_stable_hash_for!(\n+    impl<'tcx> for struct traits::ProgramClause<'tcx> {\n+        goal, hypotheses\n+    }\n+);\n+\n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Clause<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -1400,11 +1406,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Clause<'tcx> {\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n-            Implies(hypotheses, goal) => {\n-                hypotheses.hash_stable(hcx, hasher);\n-                goal.hash_stable(hcx, hasher);\n-            }\n-            DomainGoal(domain_goal) => domain_goal.hash_stable(hcx, hasher),\n+            Implies(clause) => clause.hash_stable(hcx, hasher),\n             ForAll(clause) => clause.hash_stable(hcx, hasher),\n         }\n     }"}, {"sha": "b30fb2ce016dff62ac902dc6a3ca408d165462cc", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -272,6 +272,8 @@ pub enum DomainGoal<'tcx> {\n     TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n }\n \n+pub type PolyDomainGoal<'tcx> = ty::Binder<DomainGoal<'tcx>>;\n+\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum QuantifierKind {\n     Universal,\n@@ -294,20 +296,39 @@ impl<'tcx> From<DomainGoal<'tcx>> for Goal<'tcx> {\n     }\n }\n \n-impl<'tcx> From<DomainGoal<'tcx>> for Clause<'tcx> {\n-    fn from(domain_goal: DomainGoal<'tcx>) -> Self {\n-        Clause::DomainGoal(domain_goal)\n+impl<'tcx> From<PolyDomainGoal<'tcx>> for Goal<'tcx> {\n+    fn from(domain_goal: PolyDomainGoal<'tcx>) -> Self {\n+        match domain_goal.no_late_bound_regions() {\n+            Some(p) => p.into(),\n+            None => Goal::Quantified(\n+                QuantifierKind::Universal,\n+                Box::new(domain_goal.map_bound(|p| p.into()))\n+            ),\n+        }\n     }\n }\n \n /// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n /// Harrop Formulas\".\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Clause<'tcx> {\n-    // FIXME: again, use interned refs instead of `Box`\n-    Implies(Vec<Goal<'tcx>>, DomainGoal<'tcx>),\n-    DomainGoal(DomainGoal<'tcx>),\n-    ForAll(Box<ty::Binder<Clause<'tcx>>>),\n+    Implies(ProgramClause<'tcx>),\n+    ForAll(ty::Binder<ProgramClause<'tcx>>),\n+}\n+\n+/// A \"program clause\" has the form `D :- G1, ..., Gn`. It is saying\n+/// that the domain goal `D` is true if `G1...Gn` are provable. This\n+/// is equivalent to the implication `G1..Gn => D`; we usually write\n+/// it with the reverse implication operator `:-` to emphasize the way\n+/// that programs are actually solved (via backchaining, which starts\n+/// with the goal to solve and proceeds from there).\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct ProgramClause<'tcx> {\n+    /// This goal will be considered true...\n+    pub goal: DomainGoal<'tcx>,\n+\n+    /// ...if we can prove these hypotheses (there may be no hypotheses at all):\n+    pub hypotheses: Vec<Goal<'tcx>>,\n }\n \n pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;"}, {"sha": "865a9a34aaa25614fa50021f004e7f21f0d4a191", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -493,25 +493,29 @@ impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n     }\n }\n \n+impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let traits::ProgramClause { goal, hypotheses } = self;\n+        write!(fmt, \"{}\", goal)?;\n+        if !hypotheses.is_empty() {\n+            write!(fmt, \" :- \")?;\n+            for (index, condition) in hypotheses.iter().enumerate() {\n+                if index > 0 {\n+                    write!(fmt, \", \")?;\n+                }\n+                write!(fmt, \"{}\", condition)?;\n+            }\n+        }\n+        write!(fmt, \".\")\n+    }\n+}\n+\n impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         use traits::Clause::*;\n \n         match self {\n-            Implies(hypotheses, goal) => {\n-                write!(fmt, \"{}\", goal)?;\n-                if !hypotheses.is_empty() {\n-                    write!(fmt, \" :- \")?;\n-                    for (index, condition) in hypotheses.iter().enumerate() {\n-                        if index > 0 {\n-                            write!(fmt, \", \")?;\n-                        }\n-                        write!(fmt, \"{}\", condition)?;\n-                    }\n-                }\n-                write!(fmt, \".\")\n-            }\n-            DomainGoal(domain_goal) => write!(fmt, \"{}.\", domain_goal),\n+            Implies(clause) => write!(fmt, \"{}\", clause),\n             ForAll(clause) => {\n                 // FIXME: appropriate binder names\n                 write!(fmt, \"forall<> {{ {} }}\", clause.skip_binder())\n@@ -553,10 +557,16 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for traits::ProgramClause<'tcx> {\n+        goal,\n+        hypotheses\n+    }\n+}\n+\n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for traits::Clause<'tcx> {\n-        (traits::Clause::Implies)(hypotheses, goal),\n-        (traits::Clause::DomainGoal)(domain_goal),\n+        (traits::Clause::Implies)(clause),\n         (traits::Clause::ForAll)(clause),\n     }\n }"}, {"sha": "b34decc1c69a5f937b920d9dbbff2c46a0d5cc27", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -381,7 +381,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         .span_label(span, \"pattern not allowed in foreign function\").emit();\n                 });\n             }\n-            ForeignItemKind::Static(..) | ForeignItemKind::Ty => {}\n+            ForeignItemKind::Static(..) | ForeignItemKind::Ty | ForeignItemKind::Macro(..) => {}\n         }\n \n         visit::walk_foreign_item(self, fi)\n@@ -460,6 +460,14 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         self.check_late_bound_lifetime_defs(&t.bound_generic_params);\n         visit::walk_poly_trait_ref(self, t, m);\n     }\n+\n+    fn visit_mac(&mut self, mac: &Spanned<Mac_>) {\n+        // when a new macro kind is added but the author forgets to set it up for expansion\n+        // because that's the only part that won't cause a compiler error\n+        self.session.diagnostic()\n+            .span_bug(mac.span, \"macro invocation missed in expansion; did you forget to override \\\n+                                 the relevant `fold_*()` method in `PlaceholderExpander`?\");\n+    }\n }\n \n // Bans nested `impl Trait`, e.g. `impl Into<impl Debug>`.\n@@ -522,6 +530,10 @@ impl<'a> Visitor<'a> for NestedImplTraitVisitor<'a> {\n             }\n         }\n     }\n+\n+    fn visit_mac(&mut self, _mac: &Spanned<Mac_>) {\n+        // covered in AstValidator\n+    }\n }\n \n // Bans `impl Trait` in path projections like `<impl Iterator>::Item` or `Foo::Bar<impl Trait>`.\n@@ -583,6 +595,10 @@ impl<'a> Visitor<'a> for ImplTraitProjectionVisitor<'a> {\n             _ => visit::walk_ty(self, t),\n         }\n     }\n+\n+    fn visit_mac(&mut self, _mac: &Spanned<Mac_>) {\n+        // covered in AstValidator\n+    }\n }\n \n pub fn check_crate(session: &Session, krate: &Crate) {"}, {"sha": "397590012fd7334716e97c906734631364d2895f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -456,6 +456,7 @@ impl<'a> Resolver<'a> {\n             ForeignItemKind::Ty => {\n                 (Def::TyForeign(self.definitions.local_def_id(item.id)), TypeNS)\n             }\n+            ForeignItemKind::Macro(_) => unreachable!(),\n         };\n         let parent = self.current_module;\n         let vis = self.resolve_visibility(&item.vis);\n@@ -816,6 +817,11 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n+        if let ForeignItemKind::Macro(_) = foreign_item.node {\n+            self.visit_invoc(foreign_item.id);\n+            return;\n+        }\n+\n         self.resolver.build_reduced_graph_for_foreign_item(foreign_item, self.expansion);\n         visit::walk_foreign_item(self, foreign_item);\n     }"}, {"sha": "64d57ea34c22934bfb3bda29fecef0f25a1871b9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -863,6 +863,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n             }\n             ForeignItemKind::Static(..) => NoTypeParameters,\n             ForeignItemKind::Ty => NoTypeParameters,\n+            ForeignItemKind::Macro(..) => NoTypeParameters,\n         };\n         self.with_type_parameter_rib(type_parameters, |this| {\n             visit::walk_foreign_item(this, foreign_item);"}, {"sha": "5e51797d720660f6b44b194030176e0d47cd2736", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -1812,6 +1812,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     self.dumper.dump_def(&access, var_data);\n                 }\n             }\n+            ast::ForeignItemKind::Macro(..) => {}\n         }\n     }\n }"}, {"sha": "fb4cb2afe5a663c2a49493bf38695c6c21b5bdaf", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -182,6 +182,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             // FIXME(plietar): needs a new DefKind in rls-data\n             ast::ForeignItemKind::Ty => None,\n+            ast::ForeignItemKind::Macro(..) => None,\n         }\n     }\n "}, {"sha": "fd4d3e76386425e3d6b440d343e74a44f91fd5e9", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -822,6 +822,7 @@ impl Sig for ast::ForeignItem {\n                     refs: vec![],\n                 })\n             }\n+            ast::ForeignItemKind::Macro(..) => Err(\"macro\"),\n         }\n     }\n }"}, {"sha": "153b2e730337dadd3b1519e5ad58521e4e1e4a0b", "filename": "src/librustc_traits/lowering.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -13,7 +13,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::subst::Substs;\n-use rustc::traits::{QuantifierKind, Goal, DomainGoal, Clause, WhereClauseAtom};\n+use rustc::traits::{WhereClauseAtom, PolyDomainGoal, DomainGoal, ProgramClause, Clause};\n use syntax::ast;\n use rustc_data_structures::sync::Lrc;\n \n@@ -61,36 +61,27 @@ impl<'tcx> Lower<DomainGoal<'tcx>> for ty::TypeOutlivesPredicate<'tcx> {\n /// `ty::Binder` is used for wrapping a rustc construction possibly containing generic\n /// lifetimes, e.g. `for<'a> T: Fn(&'a i32)`. Instead of representing higher-ranked things\n /// in that leaf-form (i.e. `Holds(Implemented(Binder<TraitPredicate>))` in the previous\n-/// example), we model them with quantified goals, e.g. as for the previous example:\n+/// example), we model them with quantified domain goals, e.g. as for the previous example:\n /// `forall<'a> { T: Fn(&'a i32) }` which corresponds to something like\n /// `Binder<Holds(Implemented(TraitPredicate))>`.\n-///\n-/// Also, if `self` does not contain generic lifetimes, we can safely drop the binder and we\n-/// can directly lower to a leaf goal instead of a quantified goal.\n-impl<'tcx, T> Lower<Goal<'tcx>> for ty::Binder<T>\n-    where T: Lower<DomainGoal<'tcx>> + ty::fold::TypeFoldable<'tcx> + Copy\n+impl<'tcx, T> Lower<PolyDomainGoal<'tcx>> for ty::Binder<T>\n+    where T: Lower<DomainGoal<'tcx>> + ty::fold::TypeFoldable<'tcx>\n {\n-    fn lower(&self) -> Goal<'tcx> {\n-        match self.no_late_bound_regions() {\n-            Some(p) => p.lower().into(),\n-            None => Goal::Quantified(\n-                QuantifierKind::Universal,\n-                Box::new(self.map_bound(|p| p.lower().into()))\n-            ),\n-        }\n+    fn lower(&self) -> PolyDomainGoal<'tcx> {\n+        self.map_bound_ref(|p| p.lower())\n     }\n }\n \n-impl<'tcx> Lower<Goal<'tcx>> for ty::Predicate<'tcx> {\n-    fn lower(&self) -> Goal<'tcx> {\n+impl<'tcx> Lower<PolyDomainGoal<'tcx>> for ty::Predicate<'tcx> {\n+    fn lower(&self) -> PolyDomainGoal<'tcx> {\n         use rustc::ty::Predicate::*;\n \n         match self {\n             Trait(predicate) => predicate.lower(),\n             RegionOutlives(predicate) => predicate.lower(),\n             TypeOutlives(predicate) => predicate.lower(),\n             Projection(predicate) => predicate.lower(),\n-            WellFormed(ty) => DomainGoal::WellFormedTy(*ty).into(),\n+            WellFormed(ty) => ty::Binder::dummy(DomainGoal::WellFormedTy(*ty)),\n             ObjectSafe(..) |\n             ClosureKind(..) |\n             Subtype(..) |\n@@ -134,13 +125,16 @@ fn program_clauses_for_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefI\n         }\n     };\n     // `FromEnv(Self: Trait<P1..Pn>)`\n-    let from_env = Goal::DomainGoal(DomainGoal::FromEnv(trait_pred.lower()));\n+    let from_env = DomainGoal::FromEnv(trait_pred.lower()).into();\n     // `Implemented(Self: Trait<P1..Pn>)`\n     let impl_trait = DomainGoal::Holds(WhereClauseAtom::Implemented(trait_pred));\n \n     // `Implemented(Self: Trait<P1..Pn>) :- FromEnv(Self: Trait<P1..Pn>)`\n-    let clause = Clause::Implies(vec![from_env], impl_trait);\n-    Lrc::new(vec![clause])\n+    let clause = ProgramClause {\n+        goal: impl_trait,\n+        hypotheses: vec![from_env],\n+    };\n+    Lrc::new(vec![Clause::ForAll(ty::Binder::dummy(clause))])\n }\n \n fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n@@ -167,8 +161,11 @@ fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n     let where_clauses = tcx.predicates_of(def_id).predicates.lower();\n \n      // `Implemented(A0: Trait<A1..An>) :- WC`\n-    let clause = Clause::Implies(where_clauses, trait_pred);\n-    Lrc::new(vec![clause])\n+    let clause = ProgramClause {\n+        goal: trait_pred,\n+        hypotheses: where_clauses.into_iter().map(|wc| wc.into()).collect()\n+    };\n+    Lrc::new(vec![Clause::ForAll(ty::Binder::dummy(clause))])\n }\n \n pub fn dump_program_clauses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -184,14 +181,19 @@ struct ClauseDumper<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n-impl <'a, 'tcx> ClauseDumper<'a, 'tcx > {\n+impl<'a, 'tcx> ClauseDumper<'a, 'tcx > {\n     fn process_attrs(&mut self, node_id: ast::NodeId, attrs: &[ast::Attribute]) {\n         let def_id = self.tcx.hir.local_def_id(node_id);\n         for attr in attrs {\n             if attr.check_name(\"rustc_dump_program_clauses\") {\n                 let clauses = self.tcx.program_clauses_for(def_id);\n                 for clause in &*clauses {\n-                    self.tcx.sess.struct_span_err(attr.span, &format!(\"{}\", clause)).emit();\n+                    // Skip the top-level binder for a less verbose output\n+                    let program_clause = match clause {\n+                        Clause::Implies(program_clause) => program_clause,\n+                        Clause::ForAll(program_clause) => program_clause.skip_binder(),\n+                    };\n+                    self.tcx.sess.struct_span_err(attr.span, &format!(\"{}\", program_clause)).emit();\n                 }\n             }\n         }"}, {"sha": "6f6abfdd31e57e81eab965d54199119e73742b7a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -378,7 +378,7 @@ extern crate compiler_builtins;\n // During testing, this crate is not actually the \"real\" std library, but rather\n // it links to the real std library, which was compiled from this same source\n // code. So any lang items std defines are conditionally excluded (or else they\n-// wolud generate duplicate lang item errors), and any globals it defines are\n+// would generate duplicate lang item errors), and any globals it defines are\n // _not_ the globals used by \"real\" std. So this import, defined only during\n // testing gives test-std access to real-std lang items and globals. See #2912\n #[cfg(test)] extern crate std as realstd;"}, {"sha": "28c178307a51049aa413d236a1ccd6d0561440e9", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -188,7 +188,7 @@ pub struct AssertUnwindSafe<T>(\n // * By default everything is unwind safe\n // * pointers T contains mutability of some form are not unwind safe\n // * Unique, an owning pointer, lifts an implementation\n-// * Types like Mutex/RwLock which are explicilty poisoned are unwind safe\n+// * Types like Mutex/RwLock which are explicitly poisoned are unwind safe\n // * Our custom AssertUnwindSafe wrapper is indeed unwind safe\n \n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]"}, {"sha": "df1dd7401af619476582db504075646df2ea6109", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -236,7 +236,7 @@ enum State {\n impl<'a> AsyncPipe<'a> {\n     fn new(pipe: Handle, dst: &'a mut Vec<u8>) -> io::Result<AsyncPipe<'a>> {\n         // Create an event which we'll use to coordinate our overlapped\n-        // opreations, this event will be used in WaitForMultipleObjects\n+        // operations, this event will be used in WaitForMultipleObjects\n         // and passed as part of the OVERLAPPED handle.\n         //\n         // Note that we do a somewhat clever thing here by flagging the"}, {"sha": "9d0c85a34f935d3beae11c48e5feb32c2b1e2c4a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -2192,6 +2192,8 @@ pub enum ForeignItemKind {\n     Static(P<Ty>, bool),\n     /// A foreign type\n     Ty,\n+    /// A macro invocation\n+    Macro(Mac),\n }\n \n impl ForeignItemKind {\n@@ -2200,6 +2202,7 @@ impl ForeignItemKind {\n             ForeignItemKind::Fn(..) => \"foreign function\",\n             ForeignItemKind::Static(..) => \"foreign static item\",\n             ForeignItemKind::Ty => \"foreign type\",\n+            ForeignItemKind::Macro(..) => \"macro in foreign module\",\n         }\n     }\n }"}, {"sha": "5a735be55c0e652ec439a29f772e550e055bfabd", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -38,6 +38,7 @@ pub enum Annotatable {\n     Item(P<ast::Item>),\n     TraitItem(P<ast::TraitItem>),\n     ImplItem(P<ast::ImplItem>),\n+    ForeignItem(P<ast::ForeignItem>),\n     Stmt(P<ast::Stmt>),\n     Expr(P<ast::Expr>),\n }\n@@ -48,6 +49,7 @@ impl HasAttrs for Annotatable {\n             Annotatable::Item(ref item) => &item.attrs,\n             Annotatable::TraitItem(ref trait_item) => &trait_item.attrs,\n             Annotatable::ImplItem(ref impl_item) => &impl_item.attrs,\n+            Annotatable::ForeignItem(ref foreign_item) => &foreign_item.attrs,\n             Annotatable::Stmt(ref stmt) => stmt.attrs(),\n             Annotatable::Expr(ref expr) => &expr.attrs,\n         }\n@@ -58,6 +60,8 @@ impl HasAttrs for Annotatable {\n             Annotatable::Item(item) => Annotatable::Item(item.map_attrs(f)),\n             Annotatable::TraitItem(trait_item) => Annotatable::TraitItem(trait_item.map_attrs(f)),\n             Annotatable::ImplItem(impl_item) => Annotatable::ImplItem(impl_item.map_attrs(f)),\n+            Annotatable::ForeignItem(foreign_item) =>\n+                Annotatable::ForeignItem(foreign_item.map_attrs(f)),\n             Annotatable::Stmt(stmt) => Annotatable::Stmt(stmt.map_attrs(f)),\n             Annotatable::Expr(expr) => Annotatable::Expr(expr.map_attrs(f)),\n         }\n@@ -70,6 +74,7 @@ impl Annotatable {\n             Annotatable::Item(ref item) => item.span,\n             Annotatable::TraitItem(ref trait_item) => trait_item.span,\n             Annotatable::ImplItem(ref impl_item) => impl_item.span,\n+            Annotatable::ForeignItem(ref foreign_item) => foreign_item.span,\n             Annotatable::Stmt(ref stmt) => stmt.span,\n             Annotatable::Expr(ref expr) => expr.span,\n         }\n@@ -106,6 +111,13 @@ impl Annotatable {\n         }\n     }\n \n+    pub fn expect_foreign_item(self) -> ast::ForeignItem {\n+        match self {\n+            Annotatable::ForeignItem(i) => i.into_inner(),\n+            _ => panic!(\"expected foreign item\")\n+        }\n+    }\n+\n     pub fn derive_allowed(&self) -> bool {\n         match *self {\n             Annotatable::Item(ref item) => match item.node {\n@@ -317,6 +329,9 @@ pub trait MacResult {\n         None\n     }\n \n+    /// Create zero or more items in an `extern {}` block\n+    fn make_foreign_items(self: Box<Self>) -> Option<SmallVector<ast::ForeignItem>> { None }\n+\n     /// Create a pattern.\n     fn make_pat(self: Box<Self>) -> Option<P<ast::Pat>> {\n         None\n@@ -365,6 +380,7 @@ make_MacEager! {\n     items: SmallVector<P<ast::Item>>,\n     impl_items: SmallVector<ast::ImplItem>,\n     trait_items: SmallVector<ast::TraitItem>,\n+    foreign_items: SmallVector<ast::ForeignItem>,\n     stmts: SmallVector<ast::Stmt>,\n     ty: P<ast::Ty>,\n }\n@@ -386,6 +402,10 @@ impl MacResult for MacEager {\n         self.trait_items\n     }\n \n+    fn make_foreign_items(self: Box<Self>) -> Option<SmallVector<ast::ForeignItem>> {\n+        self.foreign_items\n+    }\n+\n     fn make_stmts(self: Box<Self>) -> Option<SmallVector<ast::Stmt>> {\n         match self.stmts.as_ref().map_or(0, |s| s.len()) {\n             0 => make_stmts_default!(self),\n@@ -502,6 +522,14 @@ impl MacResult for DummyResult {\n         }\n     }\n \n+    fn make_foreign_items(self: Box<Self>) -> Option<SmallVector<ast::ForeignItem>> {\n+        if self.expr_only {\n+            None\n+        } else {\n+            Some(SmallVector::new())\n+        }\n+    }\n+\n     fn make_stmts(self: Box<DummyResult>) -> Option<SmallVector<ast::Stmt>> {\n         Some(SmallVector::one(ast::Stmt {\n             id: ast::DUMMY_NODE_ID,"}, {"sha": "105de13b976a1950102e528a3ed441adc1b892b3", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -133,6 +133,8 @@ expansions! {\n         \"trait item\", .make_trait_items, lift .fold_trait_item, lift .visit_trait_item;\n     ImplItems: SmallVector<ast::ImplItem> [SmallVector, ast::ImplItem],\n         \"impl item\",  .make_impl_items,  lift .fold_impl_item,  lift .visit_impl_item;\n+    ForeignItems: SmallVector<ast::ForeignItem> [SmallVector, ast::ForeignItem],\n+        \"foreign item\", .make_foreign_items, lift .fold_foreign_item, lift .visit_foreign_item;\n }\n \n impl ExpansionKind {\n@@ -149,6 +151,8 @@ impl ExpansionKind {\n                 Expansion::ImplItems(items.map(Annotatable::expect_impl_item).collect()),\n             ExpansionKind::TraitItems =>\n                 Expansion::TraitItems(items.map(Annotatable::expect_trait_item).collect()),\n+            ExpansionKind::ForeignItems =>\n+                Expansion::ForeignItems(items.map(Annotatable::expect_foreign_item).collect()),\n             _ => unreachable!(),\n         }\n     }\n@@ -435,6 +439,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             Annotatable::ImplItem(item) => {\n                 Annotatable::ImplItem(item.map(|item| cfg.fold_impl_item(item).pop().unwrap()))\n             }\n+            Annotatable::ForeignItem(item) => {\n+                Annotatable::ForeignItem(\n+                    item.map(|item| cfg.fold_foreign_item(item).pop().unwrap())\n+                )\n+            }\n             Annotatable::Stmt(stmt) => {\n                 Annotatable::Stmt(stmt.map(|stmt| cfg.fold_stmt(stmt).pop().unwrap()))\n             }\n@@ -509,6 +518,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     Annotatable::Item(item) => token::NtItem(item),\n                     Annotatable::TraitItem(item) => token::NtTraitItem(item.into_inner()),\n                     Annotatable::ImplItem(item) => token::NtImplItem(item.into_inner()),\n+                    Annotatable::ForeignItem(item) => token::NtForeignItem(item.into_inner()),\n                     Annotatable::Stmt(stmt) => token::NtStmt(stmt.into_inner()),\n                     Annotatable::Expr(expr) => token::NtExpr(expr),\n                 })).into();\n@@ -793,6 +803,15 @@ impl<'a> Parser<'a> {\n                 }\n                 Expansion::ImplItems(items)\n             }\n+            ExpansionKind::ForeignItems => {\n+                let mut items = SmallVector::new();\n+                while self.token != token::Eof {\n+                    if let Some(item) = self.parse_foreign_item()? {\n+                        items.push(item);\n+                    }\n+                }\n+                Expansion::ForeignItems(items)\n+            }\n             ExpansionKind::Stmts => {\n                 let mut stmts = SmallVector::new();\n                 while self.token != token::Eof &&\n@@ -1166,6 +1185,44 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         noop_fold_foreign_mod(self.cfg.configure_foreign_mod(foreign_mod), self)\n     }\n \n+    fn fold_foreign_item(&mut self,\n+                         foreign_item: ast::ForeignItem) -> SmallVector<ast::ForeignItem> {\n+        let (attr, traits, foreign_item) = self.classify_item(foreign_item);\n+\n+        let explain = if self.cx.ecfg.proc_macro_enabled() {\n+            feature_gate::EXPLAIN_PROC_MACROS_IN_EXTERN\n+        } else {\n+            feature_gate::EXPLAIN_MACROS_IN_EXTERN\n+        };\n+\n+        if attr.is_some() || !traits.is_empty()  {\n+            if !self.cx.ecfg.macros_in_extern_enabled() {\n+                if let Some(ref attr) = attr {\n+                    emit_feature_err(&self.cx.parse_sess, \"macros_in_extern\", attr.span,\n+                                     GateIssue::Language, explain);\n+                }\n+            }\n+\n+            let item = Annotatable::ForeignItem(P(foreign_item));\n+            return self.collect_attr(attr, traits, item, ExpansionKind::ForeignItems)\n+                .make_foreign_items();\n+        }\n+\n+        if let ast::ForeignItemKind::Macro(mac) = foreign_item.node {\n+            self.check_attributes(&foreign_item.attrs);\n+\n+            if !self.cx.ecfg.macros_in_extern_enabled() {\n+                emit_feature_err(&self.cx.parse_sess, \"macros_in_extern\", foreign_item.span,\n+                                 GateIssue::Language, explain);\n+            }\n+\n+            return self.collect_bang(mac, foreign_item.span, ExpansionKind::ForeignItems)\n+                .make_foreign_items();\n+        }\n+\n+        noop_fold_foreign_item(foreign_item, self)\n+    }\n+\n     fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n         match item {\n             ast::ItemKind::MacroDef(..) => item,\n@@ -1311,6 +1368,7 @@ impl<'feat> ExpansionConfig<'feat> {\n         fn enable_allow_internal_unstable = allow_internal_unstable,\n         fn enable_custom_derive = custom_derive,\n         fn proc_macro_enabled = proc_macro,\n+        fn macros_in_extern_enabled = macros_in_extern,\n     }\n }\n "}, {"sha": "9f60882ca29fc408224b388e1de08f181847cda3", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -60,6 +60,10 @@ pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n             defaultness: ast::Defaultness::Final,\n             tokens: None,\n         })),\n+        ExpansionKind::ForeignItems => Expansion::ForeignItems(SmallVector::one(ast::ForeignItem {\n+            id, span, ident, vis, attrs,\n+            node: ast::ForeignItemKind::Macro(mac_placeholder()),\n+        })),\n         ExpansionKind::Pat => Expansion::Pat(P(ast::Pat {\n             id, span, node: ast::PatKind::Mac(mac_placeholder()),\n         })),\n@@ -132,6 +136,13 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n         }\n     }\n \n+    fn fold_foreign_item(&mut self, item: ast::ForeignItem) -> SmallVector<ast::ForeignItem> {\n+        match item.node {\n+            ast::ForeignItemKind::Macro(_) => self.remove(item.id).make_foreign_items(),\n+            _ => noop_fold_foreign_item(item, self),\n+        }\n+    }\n+\n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         match expr.node {\n             ast::ExprKind::Mac(_) => self.remove(expr.id).make_expr(),"}, {"sha": "9d1f4ccf8a3d2bccb72be6e9cd6ebd10a446f755", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -443,6 +443,9 @@ declare_features! (\n \n     // Allows keywords to be escaped for use as identifiers\n     (active, raw_identifiers, \"1.26.0\", Some(48589), None),\n+\n+    // Allows macro invocations in `extern {}` blocks\n+    (active, macros_in_extern, \"1.27.0\", Some(49476), None),\n );\n \n declare_features! (\n@@ -1291,6 +1294,13 @@ pub const EXPLAIN_UNSIZED_TUPLE_COERCION: &'static str =\n pub const EXPLAIN_MACRO_AT_MOST_ONCE_REP: &'static str =\n     \"Using the `?` macro Kleene operator for \\\"at most one\\\" repetition is unstable\";\n \n+pub const EXPLAIN_MACROS_IN_EXTERN: &'static str =\n+    \"Macro invocations in `extern {}` blocks are experimental.\";\n+\n+// mention proc-macros when enabled\n+pub const EXPLAIN_PROC_MACROS_IN_EXTERN: &'static str =\n+    \"Macro and proc-macro invocations in `extern {}` blocks are experimental.\";\n+\n struct PostExpansionVisitor<'a> {\n     context: &'a Context<'a>,\n }\n@@ -1595,6 +1605,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     gate_feature_post!(&self, extern_types, i.span,\n                                        \"extern types are experimental\");\n             }\n+            ast::ForeignItemKind::Macro(..) => {}\n         }\n \n         visit::walk_foreign_item(self, i)"}, {"sha": "1bee67bf3604ad1febed19853ec16ec022e34b06", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -60,10 +60,14 @@ pub trait Folder : Sized {\n         noop_fold_use_tree(use_tree, self)\n     }\n \n-    fn fold_foreign_item(&mut self, ni: ForeignItem) -> ForeignItem {\n+    fn fold_foreign_item(&mut self, ni: ForeignItem) -> SmallVector<ForeignItem> {\n         noop_fold_foreign_item(ni, self)\n     }\n \n+    fn fold_foreign_item_simple(&mut self, ni: ForeignItem) -> ForeignItem {\n+        noop_fold_foreign_item_simple(ni, self)\n+    }\n+\n     fn fold_item(&mut self, i: P<Item>) -> SmallVector<P<Item>> {\n         noop_fold_item(i, self)\n     }\n@@ -414,7 +418,7 @@ pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, items}: ForeignMod,\n                                         fld: &mut T) -> ForeignMod {\n     ForeignMod {\n         abi,\n-        items: items.move_map(|x| fld.fold_foreign_item(x)),\n+        items: items.move_flat_map(|x| fld.fold_foreign_item(x)),\n     }\n }\n \n@@ -648,6 +652,10 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtArg(arg) => token::NtArg(fld.fold_arg(arg)),\n         token::NtVis(vis) => token::NtVis(fld.fold_vis(vis)),\n         token::NtLifetime(lifetime) => token::NtLifetime(fld.fold_lifetime(lifetime)),\n+        token::NtForeignItem(ni) =>\n+            token::NtForeignItem(fld.fold_foreign_item(ni)\n+                                 // see reasoning above\n+                                 .expect_one(\"expected fold to produce exactly one item\")),\n     }\n }\n \n@@ -1072,7 +1080,12 @@ pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span,\n     }\n }\n \n-pub fn noop_fold_foreign_item<T: Folder>(ni: ForeignItem, folder: &mut T) -> ForeignItem {\n+pub fn noop_fold_foreign_item<T: Folder>(ni: ForeignItem, folder: &mut T)\n+-> SmallVector<ForeignItem> {\n+    SmallVector::one(folder.fold_foreign_item_simple(ni))\n+}\n+\n+pub fn noop_fold_foreign_item_simple<T: Folder>(ni: ForeignItem, folder: &mut T) -> ForeignItem {\n     ForeignItem {\n         id: folder.new_id(ni.id),\n         vis: folder.fold_vis(ni.vis),\n@@ -1086,6 +1099,7 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: ForeignItem, folder: &mut T) -> For\n                 ForeignItemKind::Static(folder.fold_ty(t), m)\n             }\n             ForeignItemKind::Ty => ForeignItemKind::Ty,\n+            ForeignItemKind::Macro(mac) => ForeignItemKind::Macro(folder.fold_mac(mac)),\n         },\n         span: folder.new_span(ni.span)\n     }"}, {"sha": "9936eea935684a0f0ea52e0bc72624d9b2d52859", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 69, "deletions": 55, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -26,7 +26,7 @@ use ast::{Ident, ImplItem, IsAuto, Item, ItemKind};\n use ast::{Label, Lifetime, LifetimeDef, Lit, LitKind, UintTy};\n use ast::Local;\n use ast::MacStmtStyle;\n-use ast::Mac_;\n+use ast::{Mac, Mac_};\n use ast::{MutTy, Mutability};\n use ast::{Pat, PatKind, PathSegment};\n use ast::{PolyTraitRef, QSelf};\n@@ -1417,28 +1417,8 @@ impl<'a> Parser<'a> {\n                 None\n             };\n             (ident, TraitItemKind::Const(ty, default), ast::Generics::default())\n-        } else if self.token.is_path_start() && !self.is_extern_non_path() {\n+        } else if let Some(mac) = self.parse_assoc_macro_invoc(\"trait\", None, &mut false)? {\n             // trait item macro.\n-            // code copied from parse_macro_use_or_failure... abstraction!\n-            let prev_span = self.prev_span;\n-            let lo = self.span;\n-            let pth = self.parse_path(PathStyle::Mod)?;\n-\n-            if pth.segments.len() == 1 {\n-                if !self.eat(&token::Not) {\n-                    return Err(self.missing_assoc_item_kind_err(\"trait\", prev_span));\n-                }\n-            } else {\n-                self.expect(&token::Not)?;\n-            }\n-\n-            // eat a matched-delimiter token tree:\n-            let (delim, tts) = self.expect_delimited_token_tree()?;\n-            if delim != token::Brace {\n-                self.expect(&token::Semi)?\n-            }\n-\n-            let mac = respan(lo.to(self.prev_span), Mac_ { path: pth, tts: tts });\n             (keywords::Invalid.ident(), ast::TraitItemKind::Macro(mac), ast::Generics::default())\n         } else {\n             let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n@@ -5393,6 +5373,12 @@ impl<'a> Parser<'a> {\n     fn missing_assoc_item_kind_err(&mut self, item_type: &str, prev_span: Span)\n                                    -> DiagnosticBuilder<'a>\n     {\n+        let expected_kinds = if item_type == \"extern\" {\n+            \"missing `fn`, `type`, or `static`\"\n+        } else {\n+            \"missing `fn`, `type`, or `const`\"\n+        };\n+\n         // Given this code `path(`, it seems like this is not\n         // setting the visibility of a macro invocation, but rather\n         // a mistyped method declaration.\n@@ -5405,9 +5391,9 @@ impl<'a> Parser<'a> {\n         let sp = prev_span.between(self.prev_span);\n         let mut err = self.diagnostic().struct_span_err(\n             sp,\n-            &format!(\"missing `fn`, `type`, or `const` for {}-item declaration\",\n-                     item_type));\n-        err.span_label(sp, \"missing `fn`, `type`, or `const`\");\n+            &format!(\"{} for {}-item declaration\",\n+                     expected_kinds, item_type));\n+        err.span_label(sp, expected_kinds);\n         err\n     }\n \n@@ -5416,31 +5402,8 @@ impl<'a> Parser<'a> {\n                          -> PResult<'a, (Ident, Vec<Attribute>, ast::Generics,\n                              ast::ImplItemKind)> {\n         // code copied from parse_macro_use_or_failure... abstraction!\n-        if self.token.is_path_start() && !self.is_extern_non_path() {\n+        if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(vis), at_end)? {\n             // Method macro.\n-\n-            let prev_span = self.prev_span;\n-\n-            let lo = self.span;\n-            let pth = self.parse_path(PathStyle::Mod)?;\n-            if pth.segments.len() == 1 {\n-                if !self.eat(&token::Not) {\n-                    return Err(self.missing_assoc_item_kind_err(\"impl\", prev_span));\n-                }\n-            } else {\n-                self.expect(&token::Not)?;\n-            }\n-\n-            self.complain_if_pub_macro(&vis.node, prev_span);\n-\n-            // eat a matched-delimiter token tree:\n-            *at_end = true;\n-            let (delim, tts) = self.expect_delimited_token_tree()?;\n-            if delim != token::Brace {\n-                self.expect(&token::Semi)?\n-            }\n-\n-            let mac = respan(lo.to(self.prev_span), Mac_ { path: pth, tts: tts });\n             Ok((keywords::Invalid.ident(), vec![], ast::Generics::default(),\n                 ast::ImplItemKind::Macro(mac)))\n         } else {\n@@ -6786,7 +6749,9 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a foreign item.\n-    fn parse_foreign_item(&mut self) -> PResult<'a, Option<ForeignItem>> {\n+    pub fn parse_foreign_item(&mut self) -> PResult<'a, Option<ForeignItem>> {\n+        maybe_whole!(self, NtForeignItem, |ni| Some(ni));\n+\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.span;\n         let visibility = self.parse_visibility(false)?;\n@@ -6812,12 +6777,26 @@ impl<'a> Parser<'a> {\n             return Ok(Some(self.parse_item_foreign_type(visibility, lo, attrs)?));\n         }\n \n-        // FIXME #5668: this will occur for a macro invocation:\n-        match self.parse_macro_use_or_failure(attrs, true, false, lo, visibility)? {\n-            Some(item) => {\n-                return Err(self.span_fatal(item.span, \"macros cannot expand to foreign items\"));\n+        match self.parse_assoc_macro_invoc(\"extern\", Some(&visibility), &mut false)? {\n+            Some(mac) => {\n+                Ok(Some(\n+                    ForeignItem {\n+                        ident: keywords::Invalid.ident(),\n+                        span: lo.to(self.prev_span),\n+                        id: ast::DUMMY_NODE_ID,\n+                        attrs,\n+                        vis: visibility,\n+                        node: ForeignItemKind::Macro(mac),\n+                    }\n+                ))\n+            }\n+            None => {\n+                if !attrs.is_empty() {\n+                    self.expected_item_err(&attrs);\n+                }\n+\n+                Ok(None)\n             }\n-            None => Ok(None)\n         }\n     }\n \n@@ -6881,6 +6860,41 @@ impl<'a> Parser<'a> {\n         Ok(None)\n     }\n \n+    /// Parse a macro invocation inside a `trait`, `impl` or `extern` block\n+    fn parse_assoc_macro_invoc(&mut self, item_kind: &str, vis: Option<&Visibility>,\n+                               at_end: &mut bool) -> PResult<'a, Option<Mac>>\n+    {\n+        if self.token.is_path_start() && !self.is_extern_non_path() {\n+            let prev_span = self.prev_span;\n+            let lo = self.span;\n+            let pth = self.parse_path(PathStyle::Mod)?;\n+\n+            if pth.segments.len() == 1 {\n+                if !self.eat(&token::Not) {\n+                    return Err(self.missing_assoc_item_kind_err(item_kind, prev_span));\n+                }\n+            } else {\n+                self.expect(&token::Not)?;\n+            }\n+\n+            if let Some(vis) = vis {\n+                self.complain_if_pub_macro(&vis.node, prev_span);\n+            }\n+\n+            *at_end = true;\n+\n+            // eat a matched-delimiter token tree:\n+            let (delim, tts) = self.expect_delimited_token_tree()?;\n+            if delim != token::Brace {\n+                self.expect(&token::Semi)?\n+            }\n+\n+            Ok(Some(respan(lo.to(self.prev_span), Mac_ { path: pth, tts: tts })))\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n     fn collect_tokens<F, R>(&mut self, f: F) -> PResult<'a, (R, TokenStream)>\n         where F: FnOnce(&mut Self) -> PResult<'a, R>\n     {"}, {"sha": "5fe2b081566a13453875e4ef7da6d0b45e407d50", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -581,6 +581,7 @@ pub enum Nonterminal {\n     NtArm(ast::Arm),\n     NtImplItem(ast::ImplItem),\n     NtTraitItem(ast::TraitItem),\n+    NtForeignItem(ast::ForeignItem),\n     NtGenerics(ast::Generics),\n     NtWhereClause(ast::WhereClause),\n     NtArg(ast::Arg),\n@@ -603,6 +604,7 @@ impl fmt::Debug for Nonterminal {\n             NtArm(..) => f.pad(\"NtArm(..)\"),\n             NtImplItem(..) => f.pad(\"NtImplItem(..)\"),\n             NtTraitItem(..) => f.pad(\"NtTraitItem(..)\"),\n+            NtForeignItem(..) => f.pad(\"NtForeignItem(..)\"),\n             NtGenerics(..) => f.pad(\"NtGenerics(..)\"),\n             NtWhereClause(..) => f.pad(\"NtWhereClause(..)\"),\n             NtArg(..) => f.pad(\"NtArg(..)\"),"}, {"sha": "1bed6109dd26e44afc9c77e107f80a6cc2af29c9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -281,6 +281,7 @@ pub fn token_to_string(tok: &Token) -> String {\n             token::NtArg(ref e)          => arg_to_string(e),\n             token::NtVis(ref e)          => vis_to_string(e),\n             token::NtLifetime(ref e)     => lifetime_to_string(e),\n+            token::NtForeignItem(ref ni) => foreign_item_to_string(ni),\n         }\n     }\n }\n@@ -422,6 +423,10 @@ pub fn mac_to_string(arg: &ast::Mac) -> String {\n     to_string(|s| s.print_mac(arg, ::parse::token::Paren))\n }\n \n+pub fn foreign_item_to_string(arg: &ast::ForeignItem) -> String {\n+    to_string(|s| s.print_foreign_item(arg))\n+}\n+\n pub fn visibility_qualified(vis: &ast::Visibility, s: &str) -> String {\n     format!(\"{}{}\", to_string(|s| s.print_visibility(vis)), s)\n }\n@@ -1127,6 +1132,10 @@ impl<'a> State<'a> {\n                 self.end()?; // end the head-ibox\n                 self.end() // end the outer cbox\n             }\n+            ast::ForeignItemKind::Macro(ref m) => {\n+                self.print_mac(m, token::Paren)?;\n+                self.s.word(\";\")\n+            }\n         }\n     }\n "}, {"sha": "3a2069efd89e7e8ad85287a0808388ed69d0440c", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -460,6 +460,7 @@ pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, foreign_item: &'a\n         }\n         ForeignItemKind::Static(ref typ, _) => visitor.visit_ty(typ),\n         ForeignItemKind::Ty => (),\n+        ForeignItemKind::Macro(ref mac) => visitor.visit_mac(mac),\n     }\n \n     walk_list!(visitor, visit_attribute, &foreign_item.attrs);"}, {"sha": "5fd5e29948852589b585a25df482ee72b82509a6", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -55,6 +55,7 @@ impl MultiItemModifier for ProcMacroDerive {\n             Annotatable::Item(item) => item,\n             Annotatable::ImplItem(_) |\n             Annotatable::TraitItem(_) |\n+            Annotatable::ForeignItem(_) |\n             Annotatable::Stmt(_) |\n             Annotatable::Expr(_) => {\n                 ecx.span_err(span, \"proc-macro derives may only be \\"}, {"sha": "bc51b4061ed6bdd79f63499613cc190029dfa4bb", "filename": "src/test/compile-fail-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -93,7 +93,9 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n                 }\n             })\n         }\n-        // these are covered in proc_macro/attr-stmt-expr.rs\n+        // covered in proc_macro/macros-in-extern.rs\n+        Annotatable::ForeignItem(_) => unimplemented!(),\n+        // covered in proc_macro/attr-stmt-expr.rs\n         Annotatable::Stmt(_) | Annotatable::Expr(_) => panic!(\"expected item\")\n     }\n }\n@@ -147,6 +149,8 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n             new_it.ident = copy_name;\n             push(Annotatable::TraitItem(P(new_it)));\n         }\n+        // covered in proc_macro/macros-in-extern.rs\n+        Annotatable::ForeignItem(_) => unimplemented!(),\n         // covered in proc_macro/attr-stmt-expr.rs\n         Annotatable::Stmt(_) | Annotatable::Expr(_) => panic!(\"expected item\")\n     }"}, {"sha": "bbfec5815ba5c17262c9c7fe12864b9b58358c6b", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/attributes-included.rs", "status": "modified", "additions": 47, "deletions": 40, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -16,7 +16,7 @@\n \n extern crate proc_macro;\n \n-use proc_macro::{TokenStream, TokenTree, TokenNode, Delimiter, Literal, Spacing};\n+use proc_macro::{TokenStream, TokenTree, Delimiter, Literal, Spacing, Group};\n \n #[proc_macro_attribute]\n pub fn foo(attr: TokenStream, input: TokenStream) -> TokenStream {\n@@ -52,24 +52,30 @@ pub fn bar(attr: TokenStream, input: TokenStream) -> TokenStream {\n }\n \n fn assert_inline(slice: &mut &[TokenTree]) {\n-    match slice[0].kind {\n-        TokenNode::Op('#', _) => {}\n+    match &slice[0] {\n+        TokenTree::Op(tt) => assert_eq!(tt.op(), '#'),\n         _ => panic!(\"expected '#' char\"),\n     }\n-    match slice[1].kind {\n-        TokenNode::Group(Delimiter::Bracket, _) => {}\n+    match &slice[1] {\n+        TokenTree::Group(tt) => assert_eq!(tt.delimiter(), Delimiter::Bracket),\n         _ => panic!(\"expected brackets\"),\n     }\n     *slice = &slice[2..];\n }\n \n fn assert_doc(slice: &mut &[TokenTree]) {\n-    match slice[0].kind {\n-        TokenNode::Op('#', Spacing::Alone) => {}\n+    match &slice[0] {\n+        TokenTree::Op(tt) => {\n+            assert_eq!(tt.op(), '#');\n+            assert_eq!(tt.spacing(), Spacing::Alone);\n+        }\n         _ => panic!(\"expected #\"),\n     }\n-    let inner = match slice[1].kind {\n-        TokenNode::Group(Delimiter::Bracket, ref s) => s.clone(),\n+    let inner = match &slice[1] {\n+        TokenTree::Group(tt) => {\n+            assert_eq!(tt.delimiter(), Delimiter::Bracket);\n+            tt.stream()\n+        }\n         _ => panic!(\"expected brackets\"),\n     };\n     let tokens = inner.into_iter().collect::<Vec<_>>();\n@@ -79,49 +85,55 @@ fn assert_doc(slice: &mut &[TokenTree]) {\n         panic!(\"expected three tokens in doc\")\n     }\n \n-    match tokens[0].kind {\n-        TokenNode::Term(ref t) => assert_eq!(\"doc\", t.as_str()),\n+    match &tokens[0] {\n+        TokenTree::Term(tt) => assert_eq!(\"doc\", tt.as_str()),\n         _ => panic!(\"expected `doc`\"),\n     }\n-    match tokens[1].kind {\n-        TokenNode::Op('=', Spacing::Alone) => {}\n+    match &tokens[1] {\n+        TokenTree::Op(tt) => {\n+            assert_eq!(tt.op(), '=');\n+            assert_eq!(tt.spacing(), Spacing::Alone);\n+        }\n         _ => panic!(\"expected equals\"),\n     }\n-    match tokens[2].kind {\n-        TokenNode::Literal(_) => {}\n+    match tokens[2] {\n+        TokenTree::Literal(_) => {}\n         _ => panic!(\"expected literal\"),\n     }\n \n     *slice = &slice[2..];\n }\n \n fn assert_invoc(slice: &mut &[TokenTree]) {\n-    match slice[0].kind {\n-        TokenNode::Op('#', _) => {}\n+    match &slice[0] {\n+        TokenTree::Op(tt) => assert_eq!(tt.op(), '#'),\n         _ => panic!(\"expected '#' char\"),\n     }\n-    match slice[1].kind {\n-        TokenNode::Group(Delimiter::Bracket, _) => {}\n+    match &slice[1] {\n+        TokenTree::Group(tt) => assert_eq!(tt.delimiter(), Delimiter::Bracket),\n         _ => panic!(\"expected brackets\"),\n     }\n     *slice = &slice[2..];\n }\n \n fn assert_foo(slice: &mut &[TokenTree]) {\n-    match slice[0].kind {\n-        TokenNode::Term(ref name) => assert_eq!(name.as_str(), \"fn\"),\n+    match &slice[0] {\n+        TokenTree::Term(tt) => assert_eq!(tt.as_str(), \"fn\"),\n         _ => panic!(\"expected fn\"),\n     }\n-    match slice[1].kind {\n-        TokenNode::Term(ref name) => assert_eq!(name.as_str(), \"foo\"),\n+    match &slice[1] {\n+        TokenTree::Term(tt) => assert_eq!(tt.as_str(), \"foo\"),\n         _ => panic!(\"expected foo\"),\n     }\n-    match slice[2].kind {\n-        TokenNode::Group(Delimiter::Parenthesis, ref s) => assert!(s.is_empty()),\n+    match &slice[2] {\n+        TokenTree::Group(tt) => {\n+            assert_eq!(tt.delimiter(), Delimiter::Parenthesis);\n+            assert!(tt.stream().is_empty());\n+        }\n         _ => panic!(\"expected parens\"),\n     }\n-    match slice[3].kind {\n-        TokenNode::Group(Delimiter::Brace, _) => {}\n+    match &slice[3] {\n+        TokenTree::Group(tt) => assert_eq!(tt.delimiter(), Delimiter::Brace),\n         _ => panic!(\"expected braces\"),\n     }\n     *slice = &slice[4..];\n@@ -132,22 +144,17 @@ fn fold_stream(input: TokenStream) -> TokenStream {\n }\n \n fn fold_tree(input: TokenTree) -> TokenTree {\n-    TokenTree {\n-        span: input.span,\n-        kind: fold_node(input.kind),\n-    }\n-}\n-\n-fn fold_node(input: TokenNode) -> TokenNode {\n     match input {\n-        TokenNode::Group(a, b) => TokenNode::Group(a, fold_stream(b)),\n-        TokenNode::Op(a, b) => TokenNode::Op(a, b),\n-        TokenNode::Term(a) => TokenNode::Term(a),\n-        TokenNode::Literal(a) => {\n+        TokenTree::Group(b) => {\n+            TokenTree::Group(Group::new(b.delimiter(), fold_stream(b.stream())))\n+        }\n+        TokenTree::Op(b) => TokenTree::Op(b),\n+        TokenTree::Term(a) => TokenTree::Term(a),\n+        TokenTree::Literal(a) => {\n             if a.to_string() != \"\\\"foo\\\"\" {\n-                TokenNode::Literal(a)\n+                TokenTree::Literal(a)\n             } else {\n-                TokenNode::Literal(Literal::integer(3))\n+                TokenTree::Literal(Literal::i32_unsuffixed(3))\n             }\n         }\n     }"}, {"sha": "d1c5b9050aa8788743c77d66cf436d77c9a21276", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/test-macros.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_attribute]\n+pub fn nop_attr(_attr: TokenStream, input: TokenStream) -> TokenStream {\n+    assert!(_attr.to_string().is_empty());\n+    input\n+}\n+\n+#[proc_macro_attribute]\n+pub fn no_output(_attr: TokenStream, _input: TokenStream) -> TokenStream {\n+    assert!(_attr.to_string().is_empty());\n+    assert!(!_input.to_string().is_empty());\n+    \"\".parse().unwrap()\n+}\n+\n+#[proc_macro]\n+pub fn emit_input(input: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "4c88df332460b39a368f82c05f1da1496ef55d5b", "filename": "src/test/compile-fail-fulldeps/proc-macro/macros-in-extern.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacros-in-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacros-in-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fmacros-in-extern.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:test-macros.rs\n+// ignore-stage1\n+// ignore-wasm32\n+\n+#![feature(proc_macro)]\n+\n+extern crate test_macros;\n+\n+use test_macros::{nop_attr, no_output, emit_input};\n+\n+fn main() {\n+    assert_eq!(unsafe { rust_get_test_int() }, 0isize);\n+    assert_eq!(unsafe { rust_dbg_extern_identity_u32(0xDEADBEEF) }, 0xDEADBEEF);\n+}\n+\n+#[link(name = \"rust_test_helpers\", kind = \"static\")]\n+extern {\n+    #[no_output]\n+    //~^ ERROR Macro and proc-macro invocations in `extern {}` blocks are experimental.\n+    fn some_definitely_unknown_symbol_which_should_be_removed();\n+\n+    #[nop_attr]\n+    //~^ ERROR Macro and proc-macro invocations in `extern {}` blocks are experimental.\n+    fn rust_get_test_int() -> isize;\n+\n+    emit_input!(fn rust_dbg_extern_identity_u32(arg: u32) -> u32;);\n+    //~^ ERROR Macro and proc-macro invocations in `extern {}` blocks are experimental.\n+}"}, {"sha": "7d7f95cbbf5cbc8635b2da7166994eca88c72b94", "filename": "src/test/compile-fail/macros-in-extern.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fcompile-fail%2Fmacros-in-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fcompile-fail%2Fmacros-in-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacros-in-extern.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-wasm32\n+\n+#![feature(decl_macro)]\n+\n+macro_rules! returns_isize(\n+    ($ident:ident) => (\n+        fn $ident() -> isize;\n+    )\n+);\n+\n+macro takes_u32_returns_u32($ident:ident) {\n+    fn $ident (arg: u32) -> u32;\n+}\n+\n+macro_rules! emits_nothing(\n+    () => ()\n+);\n+\n+fn main() {\n+    assert_eq!(unsafe { rust_get_test_int() }, 0isize);\n+    assert_eq!(unsafe { rust_dbg_extern_identity_u32(0xDEADBEEF) }, 0xDEADBEEFu32);\n+}\n+\n+#[link(name = \"rust_test_helpers\", kind = \"static\")]\n+extern {\n+    returns_isize!(rust_get_test_int);\n+    //~^ ERROR Macro invocations in `extern {}` blocks are experimental.\n+    takes_u32_returns_u32!(rust_dbg_extern_identity_u32);\n+    //~^ ERROR Macro invocations in `extern {}` blocks are experimental.\n+    emits_nothing!();\n+    //~^ ERROR Macro invocations in `extern {}` blocks are experimental.\n+}"}, {"sha": "6899caa7153bb57c091ec13be5d5cec186b76c72", "filename": "src/test/parse-fail/duplicate-visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fparse-fail%2Fduplicate-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fparse-fail%2Fduplicate-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fduplicate-visibility.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: -Z parse-only\n \n-// error-pattern:unmatched visibility `pub`\n+// error-pattern:expected one of `(`, `fn`, `static`, `type`, or `}` here\n extern {\n     pub pub fn foo();\n }"}, {"sha": "aa0dbd4d4fc1b35957bbbd3f2399370215e0ae09", "filename": "src/test/parse-fail/extern-no-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fparse-fail%2Fextern-no-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fparse-fail%2Fextern-no-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fextern-no-fn.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -10,8 +10,8 @@\n \n // compile-flags: -Z parse-only\n \n-extern {\n-    f(); //~ ERROR expected one of `!` or `::`, found `(`\n+extern { //~ ERROR missing `fn`, `type`, or `static` for extern-item declaration\n+    f();\n }\n \n fn main() {"}, {"sha": "281ee70815e11c80442dfce57c8735435ef49c9a", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_plugin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -15,15 +15,15 @@\n \n extern crate proc_macro;\n \n-use proc_macro::{TokenStream, TokenNode, quote};\n+use proc_macro::*;\n \n #[proc_macro]\n pub fn cond(input: TokenStream) -> TokenStream {\n     let mut conds = Vec::new();\n     let mut input = input.into_iter().peekable();\n     while let Some(tree) = input.next() {\n-        let cond = match tree.kind {\n-            TokenNode::Group(_, cond) => cond,\n+        let cond = match tree {\n+            TokenTree::Group(tt) => tt.stream(),\n             _ => panic!(\"Invalid input\"),\n         };\n         let mut cond_trees = cond.clone().into_iter();\n@@ -32,8 +32,8 @@ pub fn cond(input: TokenStream) -> TokenStream {\n         if rhs.is_empty() {\n             panic!(\"Invalid macro usage in cond: {}\", cond);\n         }\n-        let is_else = match test.kind {\n-            TokenNode::Term(word) => word.as_str() == \"else\",\n+        let is_else = match test {\n+            TokenTree::Term(word) => word.as_str() == \"else\",\n             _ => false,\n         };\n         conds.push(if is_else || input.peek().is_none() {\n@@ -43,5 +43,5 @@ pub fn cond(input: TokenStream) -> TokenStream {\n         });\n     }\n \n-    conds.into_iter().collect()\n+    conds.into_iter().flat_map(|x| x.into_iter()).collect()\n }"}, {"sha": "6612fe45b81d370d4d3029663e1ebd0f70a3e4f5", "filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -96,7 +96,9 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n                 }\n             })\n         ],\n-        // these are covered in proc_macro/attr-stmt-expr.rs\n+        // covered in proc_macro/macros-in-extern.rs\n+        Annotatable::ForeignItem(..) => unimplemented!(),\n+        // covered in proc_macro/attr-stmt-expr.rs\n         Annotatable::Stmt(_) | Annotatable::Expr(_) => panic!(\"expected item\"),\n     }\n }\n@@ -142,7 +144,9 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n             new_it.ident = copy_name;\n             push(Annotatable::TraitItem(P(new_it)));\n         }\n-        // these are covered in proc_macro/attr-stmt-expr.rs\n+        // covered in proc_macro/macros-in-extern.rs\n+        Annotatable::ForeignItem(..) => unimplemented!(),\n+        // covered in proc_macro/attr-stmt-expr.rs\n         Annotatable::Stmt(_) | Annotatable::Expr(_) => panic!(\"expected item\")\n     }\n }"}, {"sha": "d3670ae66feedf01ba43f5870b6b5131d3375afd", "filename": "src/test/run-pass-fulldeps/auxiliary/proc_macro_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -15,7 +15,7 @@\n \n extern crate proc_macro;\n \n-use proc_macro::{TokenStream, quote};\n+use proc_macro::*;\n \n #[proc_macro_attribute]\n pub fn attr_tru(_attr: TokenStream, item: TokenStream) -> TokenStream {"}, {"sha": "063d8dc40536dc5a737ca96020bafc1d8af0e2a9", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/count_compound_ops.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcount_compound_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcount_compound_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcount_compound_ops.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -15,20 +15,25 @@\n \n extern crate proc_macro;\n \n-use proc_macro::{TokenStream, TokenNode, Spacing, Literal, quote};\n+use proc_macro::{TokenStream, TokenTree, Spacing, Literal, quote};\n \n #[proc_macro]\n pub fn count_compound_ops(input: TokenStream) -> TokenStream {\n     assert_eq!(count_compound_ops_helper(quote!(++ (&&) 4@a)), 3);\n-    TokenNode::Literal(Literal::u32(count_compound_ops_helper(input))).into()\n+    let l = Literal::u32_suffixed(count_compound_ops_helper(input));\n+    TokenTree::from(l).into()\n }\n \n fn count_compound_ops_helper(input: TokenStream) -> u32 {\n     let mut count = 0;\n     for token in input {\n-        match token.kind {\n-            TokenNode::Op(c, Spacing::Alone) => count += 1,\n-            TokenNode::Group(_, tokens) => count += count_compound_ops_helper(tokens),\n+        match &token {\n+            TokenTree::Op(tt) if tt.spacing() == Spacing::Alone => {\n+                count += 1;\n+            }\n+            TokenTree::Group(tt) => {\n+                count += count_compound_ops_helper(tt.stream());\n+            }\n             _ => {}\n         }\n     }"}, {"sha": "e76e4d585f497562691d16094397c253923e04e1", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/negative-token.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fnegative-token.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fnegative-token.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fnegative-token.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -19,16 +19,10 @@ use proc_macro::*;\n \n #[proc_macro]\n pub fn neg_one(_input: TokenStream) -> TokenStream {\n-    TokenTree {\n-        span: Span::call_site(),\n-        kind: TokenNode::Literal(Literal::i32(-1)),\n-    }.into()\n+    TokenTree::Literal(Literal::i32_suffixed(-1)).into()\n }\n \n #[proc_macro]\n pub fn neg_one_float(_input: TokenStream) -> TokenStream {\n-    TokenTree {\n-        span: Span::call_site(),\n-        kind: TokenNode::Literal(Literal::f32(-1.0)),\n-    }.into()\n+    TokenTree::Literal(Literal::f32_suffixed(-1.0)).into()\n }"}, {"sha": "6ab9d6d0b8a7ce1dc688b54a6ce7161ee02f6c2c", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/span-api-tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fspan-api-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fspan-api-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fspan-api-tests.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -27,7 +27,7 @@ pub fn reemit(input: TokenStream) -> TokenStream {\n #[proc_macro]\n pub fn assert_fake_source_file(input: TokenStream) -> TokenStream {\n     for tk in input {\n-        let source_file = tk.span.source_file();\n+        let source_file = tk.span().source_file();\n         assert!(!source_file.is_real(), \"Source file is real: {:?}\", source_file);\n     }\n \n@@ -37,7 +37,7 @@ pub fn assert_fake_source_file(input: TokenStream) -> TokenStream {\n #[proc_macro]\n pub fn assert_source_file(input: TokenStream) -> TokenStream {\n     for tk in input {\n-        let source_file = tk.span.source_file();\n+        let source_file = tk.span().source_file();\n         assert!(source_file.is_real(), \"Source file is not real: {:?}\", source_file);\n     }\n "}, {"sha": "d1c5b9050aa8788743c77d66cf436d77c9a21276", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/test-macros.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_attribute]\n+pub fn nop_attr(_attr: TokenStream, input: TokenStream) -> TokenStream {\n+    assert!(_attr.to_string().is_empty());\n+    input\n+}\n+\n+#[proc_macro_attribute]\n+pub fn no_output(_attr: TokenStream, _input: TokenStream) -> TokenStream {\n+    assert!(_attr.to_string().is_empty());\n+    assert!(!_input.to_string().is_empty());\n+    \"\".parse().unwrap()\n+}\n+\n+#[proc_macro]\n+pub fn emit_input(input: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "59b9b0baa8a4535e35d46ea0317e084038529d72", "filename": "src/test/run-pass-fulldeps/proc-macro/macros-in-extern.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fmacros-in-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fmacros-in-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fmacros-in-extern.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:test-macros.rs\n+// ignore-stage1\n+// ignore-wasm32\n+\n+#![feature(proc_macro, macros_in_extern)]\n+\n+extern crate test_macros;\n+\n+use test_macros::{nop_attr, no_output, emit_input};\n+\n+fn main() {\n+    assert_eq!(unsafe { rust_get_test_int() }, 1isize);\n+    assert_eq!(unsafe { rust_dbg_extern_identity_u32(0xDEADBEEF) }, 0xDEADBEEF);\n+}\n+\n+#[link(name = \"rust_test_helpers\", kind = \"static\")]\n+extern {\n+    #[no_output]\n+    fn some_definitely_unknown_symbol_which_should_be_removed();\n+\n+    #[nop_attr]\n+    fn rust_get_test_int() -> isize;\n+\n+    emit_input!(fn rust_dbg_extern_identity_u32(arg: u32) -> u32;);\n+}"}, {"sha": "d9094934356fc1d7b4ce8514de8b79a841715a39", "filename": "src/test/run-pass/macros-in-extern.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass%2Fmacros-in-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Frun-pass%2Fmacros-in-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacros-in-extern.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-wasm32\n+\n+#![feature(decl_macro, macros_in_extern)]\n+\n+macro_rules! returns_isize(\n+    ($ident:ident) => (\n+        fn $ident() -> isize;\n+    )\n+);\n+\n+macro takes_u32_returns_u32($ident:ident) {\n+    fn $ident (arg: u32) -> u32;\n+}\n+\n+macro_rules! emits_nothing(\n+    () => ()\n+);\n+\n+fn main() {\n+    assert_eq!(unsafe { rust_get_test_int() }, 1isize);\n+    assert_eq!(unsafe { rust_dbg_extern_identity_u32(0xDEADBEEF) }, 0xDEADBEEFu32);\n+}\n+\n+#[link(name = \"rust_test_helpers\", kind = \"static\")]\n+extern {\n+    returns_isize!(rust_get_test_int);\n+    takes_u32_returns_u32!(rust_dbg_extern_identity_u32);\n+    emits_nothing!();\n+}"}, {"sha": "ed11b2db2f5ffb235eaecd81e7a1d621642eb1f5", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/parent-source-spans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fparent-source-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fparent-source-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fparent-source-spans.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -14,12 +14,12 @@\n \n extern crate proc_macro;\n \n-use proc_macro::{TokenStream, TokenTree, TokenNode, Span};\n+use proc_macro::{TokenStream, TokenTree, Span};\n \n fn lit_span(tt: TokenTree) -> (Span, String) {\n-    use TokenNode::*;\n-    match tt.kind {\n-        Literal(..) | Group(..) => (tt.span, tt.to_string().trim().into()),\n+    match tt {\n+        TokenTree::Literal(..) |\n+        TokenTree::Group(..) => (tt.span(), tt.to_string().trim().into()),\n         _ => panic!(\"expected a literal in token tree, got: {:?}\", tt)\n     }\n }"}, {"sha": "fda0e28891f26b0712f7b264f3b8070a8348e100", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/three-equals.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -14,26 +14,27 @@\n \n extern crate proc_macro;\n \n-use proc_macro::{TokenStream, TokenNode, Span, Diagnostic};\n+use proc_macro::{TokenStream, TokenTree, Span, Diagnostic};\n \n fn parse(input: TokenStream) -> Result<(), Diagnostic> {\n     let mut count = 0;\n     let mut last_span = Span::def_site();\n     for tree in input {\n-        let span = tree.span;\n+        let span = tree.span();\n         if count >= 3 {\n             return Err(span.error(format!(\"expected EOF, found `{}`.\", tree))\n                            .span_note(last_span, \"last good input was here\")\n                            .help(\"input must be: `===`\"))\n         }\n \n-        if let TokenNode::Op('=', _) = tree.kind {\n-            count += 1;\n-        } else {\n-            return Err(span.error(format!(\"expected `=`, found `{}`.\", tree)));\n+        if let TokenTree::Op(tt) = tree {\n+            if tt.op() == '=' {\n+                count += 1;\n+                last_span = span;\n+                continue\n+            }\n         }\n-\n-        last_span = span;\n+        return Err(span.error(format!(\"expected `=`, found `{}`.\", tree)));\n     }\n \n     if count < 3 {"}, {"sha": "9c758241ea1b871ae3d07c6f29e9bcabd871aaa2", "filename": "src/test/ui/feature-gate-macros_in_extern.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fui%2Ffeature-gate-macros_in_extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fui%2Ffeature-gate-macros_in_extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-macros_in_extern.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(decl_macro)]\n+\n+macro_rules! returns_isize(\n+    ($ident:ident) => (\n+        fn $ident() -> isize;\n+    )\n+);\n+\n+macro takes_u32_returns_u32($ident:ident) {\n+    fn $ident (arg: u32) -> u32;\n+}\n+\n+macro_rules! emits_nothing(\n+    () => ()\n+);\n+\n+#[link(name = \"rust_test_helpers\", kind = \"static\")]\n+extern {\n+    returns_isize!(rust_get_test_int);\n+    //~^ ERROR Macro invocations in `extern {}` blocks are experimental.\n+    takes_u32_returns_u32!(rust_dbg_extern_identity_u32);\n+    //~^ ERROR Macro invocations in `extern {}` blocks are experimental.\n+    emits_nothing!();\n+    //~^ ERROR Macro invocations in `extern {}` blocks are experimental.\n+}"}, {"sha": "49aca0db2d46c1c8f737e5fd0b1808de5461302d", "filename": "src/test/ui/feature-gate-macros_in_extern.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fui%2Ffeature-gate-macros_in_extern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftest%2Fui%2Ffeature-gate-macros_in_extern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-macros_in_extern.stderr?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -0,0 +1,27 @@\n+error[E0658]: Macro invocations in `extern {}` blocks are experimental. (see issue #49476)\n+  --> $DIR/feature-gate-macros_in_extern.rs:29:5\n+   |\n+LL |     returns_isize!(rust_get_test_int);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(macros_in_extern)] to the crate attributes to enable\n+\n+error[E0658]: Macro invocations in `extern {}` blocks are experimental. (see issue #49476)\n+  --> $DIR/feature-gate-macros_in_extern.rs:31:5\n+   |\n+LL |     takes_u32_returns_u32!(rust_dbg_extern_identity_u32);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(macros_in_extern)] to the crate attributes to enable\n+\n+error[E0658]: Macro invocations in `extern {}` blocks are experimental. (see issue #49476)\n+  --> $DIR/feature-gate-macros_in_extern.rs:33:5\n+   |\n+LL |     emits_nothing!();\n+   |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(macros_in_extern)] to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "0f482c95e05a27a7774bd558a439f35313b42e11", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48fa6f9631868b07309b02f479e2ec523bb58c2b/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=48fa6f9631868b07309b02f479e2ec523bb58c2b", "patch": "@@ -356,6 +356,28 @@ impl Builder {\n                 target: \"*\".to_string(),\n             });\n \n+            // If the components/extensions don't actually exist for this\n+            // particular host/target combination then nix it entirely from our\n+            // lists.\n+            {\n+                let has_component = |c: &Component| {\n+                    if c.target == \"*\" {\n+                        return true\n+                    }\n+                    let pkg = match manifest.pkg.get(&c.pkg) {\n+                        Some(p) => p,\n+                        None => return false,\n+                    };\n+                    let target = match pkg.target.get(&c.target) {\n+                        Some(t) => t,\n+                        None => return false,\n+                    };\n+                    target.available\n+                };\n+                extensions.retain(&has_component);\n+                components.retain(&has_component);\n+            }\n+\n             pkg.target.insert(host.to_string(), Target {\n                 available: true,\n                 url: Some(self.url(&filename)),"}]}