{"sha": "9aee7ed335cfcaad33a6f6492497588b3d421b2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhZWU3ZWQzMzVjZmNhYWQzM2E2ZjY0OTI0OTc1ODhiM2Q0MjFiMmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-13T22:20:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-13T22:20:43Z"}, "message": "Auto merge of #57580 - Centril:rollup, r=Centril\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #56874 (Simplify foreign type rendering.)\n - #57113 (Move diagnostics out from QueryJob and optimize for the case with no diagnostics)\n - #57366 (Point at match discriminant on type error in match arm pattern)\n - #57538 (librustc_mir: Fix ICE with slice patterns)\n\nFailed merges:\n\n - #57381 (Tweak output of type mismatch between \"then\" and `else` `if` arms)\n\nr? @ghost", "tree": {"sha": "dacbbb5fc2990b30e063fd8c0e65a88e556718b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dacbbb5fc2990b30e063fd8c0e65a88e556718b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9aee7ed335cfcaad33a6f6492497588b3d421b2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9aee7ed335cfcaad33a6f6492497588b3d421b2d", "html_url": "https://github.com/rust-lang/rust/commit/9aee7ed335cfcaad33a6f6492497588b3d421b2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9aee7ed335cfcaad33a6f6492497588b3d421b2d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fadb0a16c8737a45746e95df9138912590ed8ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fadb0a16c8737a45746e95df9138912590ed8ad", "html_url": "https://github.com/rust-lang/rust/commit/2fadb0a16c8737a45746e95df9138912590ed8ad"}, {"sha": "35af111232f887a1173106a2038094c165bee1ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/35af111232f887a1173106a2038094c165bee1ff", "html_url": "https://github.com/rust-lang/rust/commit/35af111232f887a1173106a2038094c165bee1ff"}], "stats": {"total": 639, "additions": 419, "deletions": 220}, "files": [{"sha": "501ef01d74c6e783cd5dc8e6e3ff55b72803dfdc", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -696,7 +696,7 @@ impl DepGraph {\n \n                 // Promote the previous diagnostics to the current session.\n                 tcx.queries.on_disk_cache\n-                   .store_diagnostics(dep_node_index, diagnostics.clone());\n+                   .store_diagnostics(dep_node_index, diagnostics.clone().into());\n \n                 for diagnostic in diagnostics {\n                     DiagnosticBuilder::new_diagnostic(handle, diagnostic).emit();"}, {"sha": "f71cce8273c46db336fee0eb92e96708457bf842", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -487,6 +487,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     fn note_error_origin(&self, err: &mut DiagnosticBuilder<'tcx>, cause: &ObligationCause<'tcx>) {\n         match cause.code {\n+            ObligationCauseCode::MatchExpressionArmPattern { span, ty } => {\n+                if ty.is_suggestable() {  // don't show type `_`\n+                    err.span_label(span, format!(\"this match expression has type `{}`\", ty));\n+                }\n+            }\n             ObligationCauseCode::MatchExpressionArm { arm_span, source } => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n                     let msg = \"`if let` arm with an incompatible type\";"}, {"sha": "7d9e80fd60f5c345020a1e72739539d3703f62a4", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1444,15 +1444,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         match *cause_code {\n             ObligationCauseCode::ExprAssignable |\n             ObligationCauseCode::MatchExpressionArm { .. } |\n+            ObligationCauseCode::MatchExpressionArmPattern { .. } |\n             ObligationCauseCode::IfExpression |\n             ObligationCauseCode::IfExpressionWithNoElse |\n             ObligationCauseCode::MainFunctionType |\n             ObligationCauseCode::StartFunctionType |\n             ObligationCauseCode::IntrinsicType |\n             ObligationCauseCode::MethodReceiver |\n             ObligationCauseCode::ReturnNoExpression |\n-            ObligationCauseCode::MiscObligation => {\n-            }\n+            ObligationCauseCode::MiscObligation => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }"}, {"sha": "14c25b77a1b8213f855f2dfde4dc3129c2a7e3c2", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -220,8 +220,13 @@ pub enum ObligationCauseCode<'tcx> {\n     ExprAssignable,\n \n     /// Computing common supertype in the arms of a match expression\n-    MatchExpressionArm { arm_span: Span,\n-                         source: hir::MatchSource },\n+    MatchExpressionArm {\n+        arm_span: Span,\n+        source: hir::MatchSource,\n+    },\n+\n+    /// Computing common supertype in the pattern guard for the arms of a match expression\n+    MatchExpressionArmPattern { span: Span, ty: Ty<'tcx> },\n \n     /// Computing common supertype in an if expression\n     IfExpression,"}, {"sha": "277e2ed0e87d26980ba2f021a23a891847c7a3c5", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -517,6 +517,9 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n                 arm_span,\n                 source: source,\n             }),\n+            super::MatchExpressionArmPattern { span, ty } => {\n+                tcx.lift(&ty).map(|ty| super::MatchExpressionArmPattern { span, ty })\n+            }\n             super::IfExpression => Some(super::IfExpression),\n             super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n             super::MainFunctionType => Some(super::MainFunctionType),"}, {"sha": "d69219efbd8847a2d519f1a3777ae15a46d242d5", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1682,6 +1682,7 @@ impl<'gcx> GlobalCtxt<'gcx> {\n             let new_icx = ty::tls::ImplicitCtxt {\n                 tcx,\n                 query: icx.query.clone(),\n+                diagnostics: icx.diagnostics,\n                 layout_depth: icx.layout_depth,\n                 task_deps: icx.task_deps,\n             };\n@@ -1792,6 +1793,7 @@ pub mod tls {\n     use errors::{Diagnostic, TRACK_DIAGNOSTICS};\n     use rustc_data_structures::OnDrop;\n     use rustc_data_structures::sync::{self, Lrc, Lock};\n+    use rustc_data_structures::thin_vec::ThinVec;\n     use dep_graph::TaskDeps;\n \n     #[cfg(not(parallel_queries))]\n@@ -1811,10 +1813,14 @@ pub mod tls {\n         /// by `enter_local` with a new local interner\n         pub tcx: TyCtxt<'tcx, 'gcx, 'tcx>,\n \n-        /// The current query job, if any. This is updated by start_job in\n+        /// The current query job, if any. This is updated by JobOwner::start in\n         /// ty::query::plumbing when executing a query\n         pub query: Option<Lrc<query::QueryJob<'gcx>>>,\n \n+        /// Where to store diagnostics for the current query job, if any.\n+        /// This is updated by JobOwner::start in ty::query::plumbing when executing a query\n+        pub diagnostics: Option<&'a Lock<ThinVec<Diagnostic>>>,\n+\n         /// Used to prevent layout from recursing too deeply.\n         pub layout_depth: usize,\n \n@@ -1880,8 +1886,9 @@ pub mod tls {\n     fn track_diagnostic(diagnostic: &Diagnostic) {\n         with_context_opt(|icx| {\n             if let Some(icx) = icx {\n-                if let Some(ref query) = icx.query {\n-                    query.diagnostics.lock().push(diagnostic.clone());\n+                if let Some(ref diagnostics) = icx.diagnostics {\n+                    let mut diagnostics = diagnostics.lock();\n+                    diagnostics.extend(Some(diagnostic.clone()));\n                 }\n             }\n         })\n@@ -1948,6 +1955,7 @@ pub mod tls {\n             let icx = ImplicitCtxt {\n                 tcx,\n                 query: None,\n+                diagnostics: None,\n                 layout_depth: 0,\n                 task_deps: None,\n             };\n@@ -1977,6 +1985,7 @@ pub mod tls {\n         };\n         let icx = ImplicitCtxt {\n             query: None,\n+            diagnostics: None,\n             tcx,\n             layout_depth: 0,\n             task_deps: None,"}, {"sha": "d794429a8a7064cb12e1a3f4ac8b3f487359663e", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -14,7 +14,6 @@ use ty::query::{\n     config::QueryDescription,\n };\n use ty::context::TyCtxt;\n-use errors::Diagnostic;\n use std::process;\n use std::{fmt, ptr};\n \n@@ -54,9 +53,6 @@ pub struct QueryJob<'tcx> {\n     /// The parent query job which created this job and is implicitly waiting on it.\n     pub parent: Option<Lrc<QueryJob<'tcx>>>,\n \n-    /// Diagnostic messages which are emitted while the query executes\n-    pub diagnostics: Lock<Vec<Diagnostic>>,\n-\n     /// The latch which is used to wait on this job\n     #[cfg(parallel_queries)]\n     latch: QueryLatch<'tcx>,\n@@ -66,7 +62,6 @@ impl<'tcx> QueryJob<'tcx> {\n     /// Creates a new query job\n     pub fn new(info: QueryInfo<'tcx>, parent: Option<Lrc<QueryJob<'tcx>>>) -> Self {\n         QueryJob {\n-            diagnostics: Lock::new(Vec::new()),\n             info,\n             parent,\n             #[cfg(parallel_queries)]"}, {"sha": "a674e942b3893c97049123eb9d632903770d374d", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -7,6 +7,7 @@ use ich::{CachingSourceMapView, Fingerprint};\n use mir::{self, interpret};\n use mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::sync::{Lrc, Lock, HashMapExt, Once};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n@@ -341,11 +342,13 @@ impl<'sess> OnDiskCache<'sess> {\n     /// Store a diagnostic emitted during the current compilation session.\n     /// Anything stored like this will be available via `load_diagnostics` in\n     /// the next compilation session.\n+    #[inline(never)]\n+    #[cold]\n     pub fn store_diagnostics(&self,\n                              dep_node_index: DepNodeIndex,\n-                             diagnostics: Vec<Diagnostic>) {\n+                             diagnostics: ThinVec<Diagnostic>) {\n         let mut current_diagnostics = self.current_diagnostics.borrow_mut();\n-        let prev = current_diagnostics.insert(dep_node_index, diagnostics);\n+        let prev = current_diagnostics.insert(dep_node_index, diagnostics.into());\n         debug_assert!(prev.is_none());\n     }\n \n@@ -367,16 +370,16 @@ impl<'sess> OnDiskCache<'sess> {\n     /// Since many anonymous queries can share the same `DepNode`, we aggregate\n     /// them -- as opposed to regular queries where we assume that there is a\n     /// 1:1 relationship between query-key and `DepNode`.\n+    #[inline(never)]\n+    #[cold]\n     pub fn store_diagnostics_for_anon_node(&self,\n                                            dep_node_index: DepNodeIndex,\n-                                           mut diagnostics: Vec<Diagnostic>) {\n+                                           diagnostics: ThinVec<Diagnostic>) {\n         let mut current_diagnostics = self.current_diagnostics.borrow_mut();\n \n-        let x = current_diagnostics.entry(dep_node_index).or_insert_with(|| {\n-            mem::replace(&mut diagnostics, Vec::new())\n-        });\n+        let x = current_diagnostics.entry(dep_node_index).or_insert(Vec::new());\n \n-        x.extend(diagnostics.into_iter());\n+        x.extend(Into::<Vec<_>>::into(diagnostics));\n     }\n \n     fn load_indexed<'tcx, T>(&self,"}, {"sha": "32d4070dfed2af5deaae70cfbb9ea628a866c0c5", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -18,6 +18,7 @@ use util::common::{profq_msg, ProfileQueriesMsg, QueryMsg};\n \n use rustc_data_structures::fx::{FxHashMap};\n use rustc_data_structures::sync::{Lrc, Lock};\n+use rustc_data_structures::thin_vec::ThinVec;\n use std::mem;\n use std::ptr;\n use std::collections::hash_map::Entry;\n@@ -195,19 +196,21 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n     pub(super) fn start<'lcx, F, R>(\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'lcx>,\n+        diagnostics: Option<&Lock<ThinVec<Diagnostic>>>,\n         compute: F)\n-    -> (R, Vec<Diagnostic>)\n+    -> R\n     where\n         F: for<'b> FnOnce(TyCtxt<'b, 'tcx, 'lcx>) -> R\n     {\n         // The TyCtxt stored in TLS has the same global interner lifetime\n         // as `tcx`, so we use `with_related_context` to relate the 'gcx lifetimes\n         // when accessing the ImplicitCtxt\n-        let r = tls::with_related_context(tcx, move |current_icx| {\n+        tls::with_related_context(tcx, move |current_icx| {\n             // Update the ImplicitCtxt to point to our new query job\n             let new_icx = tls::ImplicitCtxt {\n                 tcx: tcx.global_tcx(),\n                 query: Some(self.job.clone()),\n+                diagnostics,\n                 layout_depth: current_icx.layout_depth,\n                 task_deps: current_icx.task_deps,\n             };\n@@ -216,13 +219,19 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             tls::enter_context(&new_icx, |_| {\n                 compute(tcx)\n             })\n-        });\n+        })\n+    }\n \n-        // Extract the diagnostic from the job\n-        let diagnostics = mem::replace(&mut *self.job.diagnostics.lock(), Vec::new());\n+}\n \n-        (r, diagnostics)\n-    }\n+#[inline(always)]\n+fn with_diagnostics<F, R>(f: F) -> (R, ThinVec<Diagnostic>)\n+where\n+    F: FnOnce(Option<&Lock<ThinVec<Diagnostic>>>) -> R\n+{\n+    let diagnostics = Lock::new(ThinVec::new());\n+    let result = f(Some(&diagnostics));\n+    (result, diagnostics.into_inner())\n }\n \n impl<'a, 'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'a, 'tcx, Q> {\n@@ -402,20 +411,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n             self.sess.profiler(|p| p.start_activity(Q::CATEGORY));\n \n-            let res = job.start(self, |tcx| {\n-                tcx.dep_graph.with_anon_task(dep_node.kind, || {\n-                    Q::compute(tcx.global_tcx(), key)\n+            let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n+                job.start(self, diagnostics, |tcx| {\n+                    tcx.dep_graph.with_anon_task(dep_node.kind, || {\n+                        Q::compute(tcx.global_tcx(), key)\n+                    })\n                 })\n             });\n \n             self.sess.profiler(|p| p.end_activity(Q::CATEGORY));\n             profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n-            let ((result, dep_node_index), diagnostics) = res;\n \n             self.dep_graph.read_index(dep_node_index);\n \n-            self.queries.on_disk_cache\n-                .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n+            if unlikely!(!diagnostics.is_empty()) {\n+                self.queries.on_disk_cache\n+                    .store_diagnostics_for_anon_node(dep_node_index, diagnostics);\n+            }\n \n             job.complete(&result, dep_node_index);\n \n@@ -487,7 +499,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // The diagnostics for this query have already been\n             // promoted to the current session during\n             // try_mark_green(), so we can ignore them here.\n-            let (result, _) = job.start(self, |tcx| {\n+            let result = job.start(self, None, |tcx| {\n                 // The dep-graph for this computation is already in\n                 // place\n                 tcx.dep_graph.with_ignore(|| {\n@@ -566,32 +578,34 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n         self.sess.profiler(|p| p.start_activity(Q::CATEGORY));\n \n-        let res = job.start(self, |tcx| {\n-            if dep_node.kind.is_eval_always() {\n-                tcx.dep_graph.with_eval_always_task(dep_node,\n-                                                    tcx,\n-                                                    key,\n-                                                    Q::compute)\n-            } else {\n-                tcx.dep_graph.with_task(dep_node,\n-                                        tcx,\n-                                        key,\n-                                        Q::compute)\n-            }\n+        let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n+            job.start(self, diagnostics, |tcx| {\n+                if dep_node.kind.is_eval_always() {\n+                    tcx.dep_graph.with_eval_always_task(dep_node,\n+                                                        tcx,\n+                                                        key,\n+                                                        Q::compute)\n+                } else {\n+                    tcx.dep_graph.with_task(dep_node,\n+                                            tcx,\n+                                            key,\n+                                            Q::compute)\n+                }\n+            })\n         });\n \n         self.sess.profiler(|p| p.end_activity(Q::CATEGORY));\n         profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n-        let ((result, dep_node_index), diagnostics) = res;\n-\n         if unlikely!(self.sess.opts.debugging_opts.query_dep_graph) {\n             self.dep_graph.mark_loaded_from_cache(dep_node_index, false);\n         }\n \n         if dep_node.kind != ::dep_graph::DepKind::Null {\n-            self.queries.on_disk_cache\n-                .store_diagnostics(dep_node_index, diagnostics);\n+            if unlikely!(!diagnostics.is_empty()) {\n+                self.queries.on_disk_cache\n+                    .store_diagnostics(dep_node_index, diagnostics);\n+            }\n         }\n \n         job.complete(&result, dep_node_index);"}, {"sha": "188a1120442983dfba44c786cb5a4b6047a04590", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1372,7 +1372,14 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n                     let is_visible = adt.is_enum()\n                         || field.vis.is_accessible_from(cx.module, cx.tcx);\n                     if is_visible {\n-                        field.ty(cx.tcx, substs)\n+                        let ty = field.ty(cx.tcx, substs);\n+                        match ty.sty {\n+                            // If the field type returned is an array of an unknown\n+                            // size return an TyErr.\n+                            ty::Array(_, len) if len.assert_usize(cx.tcx).is_none() =>\n+                                cx.tcx.types.err,\n+                            _ => ty,\n+                        }\n                     } else {\n                         // Treat all non-visible fields as TyErr. They\n                         // can't appear in any other pattern from"}, {"sha": "1767af4870d3b27eca2564d33b461a746e2f54d4", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 104, "deletions": 69, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -20,21 +20,33 @@ use std::cmp;\n use super::report_unexpected_variant_def;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    /// The `is_arg` argument indicates whether this pattern is the\n-    /// *outermost* pattern in an argument (e.g., in `fn foo(&x:\n-    /// &u32)`, it is true for the `&x` pattern but not `x`). This is\n-    /// used to tailor error reporting.\n+    /// `match_discrim_span` argument having a `Span` indicates that this pattern is part of\n+    /// a match expression arm guard, and it points to the match discriminant to add context\n+    /// in type errors. In the folloowing example, `match_discrim_span` corresponds to the\n+    /// `a + b` expression:\n+    ///\n+    /// ```text\n+    /// error[E0308]: mismatched types\n+    ///  --> src/main.rs:5:9\n+    ///   |\n+    /// 4 |    let temp: usize = match a + b {\n+    ///   |                            ----- this expression has type `usize`\n+    /// 5 |         Ok(num) => num,\n+    ///   |         ^^^^^^^ expected usize, found enum `std::result::Result`\n+    ///   |\n+    ///   = note: expected type `usize`\n+    ///              found type `std::result::Result<_, _>`\n+    /// ```\n     pub fn check_pat_walk(\n         &self,\n         pat: &'gcx hir::Pat,\n         mut expected: Ty<'tcx>,\n         mut def_bm: ty::BindingMode,\n-        is_arg: bool)\n-    {\n+        match_discrim_span: Option<Span>,\n+    ) {\n         let tcx = self.tcx;\n \n-        debug!(\"check_pat_walk(pat={:?},expected={:?},def_bm={:?},is_arg={})\",\n-            pat, expected, def_bm, is_arg);\n+        debug!(\"check_pat_walk(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n \n         let is_non_ref_pat = match pat.node {\n             PatKind::Struct(..) |\n@@ -210,8 +222,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let common_type = self.resolve_type_vars_if_possible(&lhs_ty);\n \n                 // subtyping doesn't matter here, as the value is some kind of scalar\n-                self.demand_eqtype(pat.span, expected, lhs_ty);\n-                self.demand_eqtype(pat.span, expected, rhs_ty);\n+                self.demand_eqtype_pat(pat.span, expected, lhs_ty, match_discrim_span);\n+                self.demand_eqtype_pat(pat.span, expected, rhs_ty, match_discrim_span);\n                 common_type\n             }\n             PatKind::Binding(ba, var_id, _, ref sub) => {\n@@ -240,37 +252,45 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n                         // required. However, we use equality, which is stronger. See (*) for\n                         // an explanation.\n-                        self.demand_eqtype(pat.span, region_ty, local_ty);\n+                        self.demand_eqtype_pat(pat.span, region_ty, local_ty, match_discrim_span);\n                     }\n                     // otherwise the type of x is the expected type T\n                     ty::BindByValue(_) => {\n                         // As above, `T <: typeof(x)` is required but we\n                         // use equality, see (*) below.\n-                        self.demand_eqtype(pat.span, expected, local_ty);\n+                        self.demand_eqtype_pat(pat.span, expected, local_ty, match_discrim_span);\n                     }\n                 }\n \n                 // if there are multiple arms, make sure they all agree on\n                 // what the type of the binding `x` ought to be\n                 if var_id != pat.id {\n                     let vt = self.local_ty(pat.span, var_id).decl_ty;\n-                    self.demand_eqtype(pat.span, vt, local_ty);\n+                    self.demand_eqtype_pat(pat.span, vt, local_ty, match_discrim_span);\n                 }\n \n                 if let Some(ref p) = *sub {\n-                    self.check_pat_walk(&p, expected, def_bm, true);\n+                    self.check_pat_walk(&p, expected, def_bm, match_discrim_span);\n                 }\n \n                 local_ty\n             }\n             PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n-                self.check_pat_tuple_struct(pat, qpath, &subpats, ddpos, expected, def_bm)\n+                self.check_pat_tuple_struct(\n+                    pat,\n+                    qpath,\n+                    &subpats,\n+                    ddpos,\n+                    expected,\n+                    def_bm,\n+                    match_discrim_span,\n+                )\n             }\n             PatKind::Path(ref qpath) => {\n                 self.check_pat_path(pat, qpath, expected)\n             }\n             PatKind::Struct(ref qpath, ref fields, etc) => {\n-                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm)\n+                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, match_discrim_span)\n             }\n             PatKind::Tuple(ref elements, ddpos) => {\n                 let mut expected_len = elements.len();\n@@ -295,12 +315,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // further errors being emitted when using the bindings. #50333\n                     let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n                     for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                        self.check_pat_walk(elem, &tcx.types.err, def_bm, true);\n+                        self.check_pat_walk(elem, &tcx.types.err, def_bm, match_discrim_span);\n                     }\n                     tcx.mk_tup(element_tys_iter)\n                 } else {\n                     for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                        self.check_pat_walk(elem, &element_tys[i], def_bm, true);\n+                        self.check_pat_walk(elem, &element_tys[i], def_bm, match_discrim_span);\n                     }\n                     pat_ty\n                 }\n@@ -313,11 +333,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // Here, `demand::subtype` is good enough, but I don't\n                     // think any errors can be introduced by using\n                     // `demand::eqtype`.\n-                    self.demand_eqtype(pat.span, expected, uniq_ty);\n-                    self.check_pat_walk(&inner, inner_ty, def_bm, true);\n+                    self.demand_eqtype_pat(pat.span, expected, uniq_ty, match_discrim_span);\n+                    self.check_pat_walk(&inner, inner_ty, def_bm, match_discrim_span);\n                     uniq_ty\n                 } else {\n-                    self.check_pat_walk(&inner, tcx.types.err, def_bm, true);\n+                    self.check_pat_walk(&inner, tcx.types.err, def_bm, match_discrim_span);\n                     tcx.types.err\n                 }\n             }\n@@ -349,15 +369,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             // Look for a case like `fn foo(&foo: u32)` and suggest\n                             // `fn foo(foo: &u32)`\n                             if let Some(mut err) = err {\n-                                if is_arg {\n-                                    if let PatKind::Binding(..) = inner.node {\n-                                        if let Ok(snippet) = tcx.sess.source_map()\n-                                                                     .span_to_snippet(pat.span)\n-                                        {\n-                                            err.help(&format!(\"did you mean `{}: &{}`?\",\n-                                                              &snippet[1..],\n-                                                              expected));\n-                                        }\n+                                if let PatKind::Binding(..) = inner.node {\n+                                    if let Ok(snippet) = tcx.sess.source_map()\n+                                                                    .span_to_snippet(pat.span)\n+                                    {\n+                                        err.help(&format!(\"did you mean `{}: &{}`?\",\n+                                                            &snippet[1..],\n+                                                            expected));\n                                     }\n                                 }\n                                 err.emit();\n@@ -366,10 +384,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     };\n \n-                    self.check_pat_walk(&inner, inner_ty, def_bm, true);\n+                    self.check_pat_walk(&inner, inner_ty, def_bm, match_discrim_span);\n                     rptr_ty\n                 } else {\n-                    self.check_pat_walk(&inner, tcx.types.err, def_bm, true);\n+                    self.check_pat_walk(&inner, tcx.types.err, def_bm, match_discrim_span);\n                     tcx.types.err\n                 }\n             }\n@@ -427,13 +445,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n \n                 for elt in before {\n-                    self.check_pat_walk(&elt, inner_ty, def_bm, true);\n+                    self.check_pat_walk(&elt, inner_ty, def_bm, match_discrim_span);\n                 }\n                 if let Some(ref slice) = *slice {\n-                    self.check_pat_walk(&slice, slice_ty, def_bm, true);\n+                    self.check_pat_walk(&slice, slice_ty, def_bm, match_discrim_span);\n                 }\n                 for elt in after {\n-                    self.check_pat_walk(&elt, inner_ty, def_bm, true);\n+                    self.check_pat_walk(&elt, inner_ty, def_bm, match_discrim_span);\n                 }\n                 expected_ty\n             }\n@@ -524,12 +542,14 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         true\n     }\n \n-    pub fn check_match(&self,\n-                       expr: &'gcx hir::Expr,\n-                       discrim: &'gcx hir::Expr,\n-                       arms: &'gcx [hir::Arm],\n-                       expected: Expectation<'tcx>,\n-                       match_src: hir::MatchSource) -> Ty<'tcx> {\n+    pub fn check_match(\n+        &self,\n+        expr: &'gcx hir::Expr,\n+        discrim: &'gcx hir::Expr,\n+        arms: &'gcx [hir::Arm],\n+        expected: Expectation<'tcx>,\n+        match_src: hir::MatchSource,\n+    ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n         // Not entirely obvious: if matches may create ref bindings, we want to\n@@ -624,8 +644,12 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             let mut all_pats_diverge = Diverges::WarnedAlways;\n             for p in &arm.pats {\n                 self.diverges.set(Diverges::Maybe);\n-                self.check_pat_walk(&p, discrim_ty,\n-                    ty::BindingMode::BindByValue(hir::Mutability::MutImmutable), true);\n+                self.check_pat_walk(\n+                    &p,\n+                    discrim_ty,\n+                    ty::BindingMode::BindByValue(hir::Mutability::MutImmutable),\n+                    Some(discrim.span),\n+                );\n                 all_pats_diverge &= self.diverges.get();\n             }\n \n@@ -703,26 +727,34 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         coercion.complete(self)\n     }\n \n-    fn check_pat_struct(&self,\n-                        pat: &'gcx hir::Pat,\n-                        qpath: &hir::QPath,\n-                        fields: &'gcx [Spanned<hir::FieldPat>],\n-                        etc: bool,\n-                        expected: Ty<'tcx>,\n-                        def_bm: ty::BindingMode) -> Ty<'tcx>\n+    fn check_pat_struct(\n+        &self,\n+        pat: &'gcx hir::Pat,\n+        qpath: &hir::QPath,\n+        fields: &'gcx [Spanned<hir::FieldPat>],\n+        etc: bool,\n+        expected: Ty<'tcx>,\n+        def_bm: ty::BindingMode,\n+        match_discrim_span: Option<Span>,\n+    ) -> Ty<'tcx>\n     {\n         // Resolve the path and check the definition for errors.\n         let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.id) {\n             variant_ty\n         } else {\n             for field in fields {\n-                self.check_pat_walk(&field.node.pat, self.tcx.types.err, def_bm, true);\n+                self.check_pat_walk(\n+                    &field.node.pat,\n+                    self.tcx.types.err,\n+                    def_bm,\n+                    match_discrim_span,\n+                );\n             }\n             return self.tcx.types.err;\n         };\n \n         // Type-check the path.\n-        self.demand_eqtype(pat.span, expected, pat_ty);\n+        self.demand_eqtype_pat(pat.span, expected, pat_ty, match_discrim_span);\n \n         // Type-check subpatterns.\n         if self.check_struct_pat_fields(pat_ty, pat.id, pat.span, variant, fields, etc, def_bm) {\n@@ -732,11 +764,12 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         }\n     }\n \n-    fn check_pat_path(&self,\n-                      pat: &hir::Pat,\n-                      qpath: &hir::QPath,\n-                      expected: Ty<'tcx>) -> Ty<'tcx>\n-    {\n+    fn check_pat_path(\n+        &self,\n+        pat: &hir::Pat,\n+        qpath: &hir::QPath,\n+        expected: Ty<'tcx>,\n+    ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n         // Resolve the path and check the definition for errors.\n@@ -767,18 +800,20 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         pat_ty\n     }\n \n-    fn check_pat_tuple_struct(&self,\n-                              pat: &hir::Pat,\n-                              qpath: &hir::QPath,\n-                              subpats: &'gcx [P<hir::Pat>],\n-                              ddpos: Option<usize>,\n-                              expected: Ty<'tcx>,\n-                              def_bm: ty::BindingMode) -> Ty<'tcx>\n-    {\n+    fn check_pat_tuple_struct(\n+        &self,\n+        pat: &hir::Pat,\n+        qpath: &hir::QPath,\n+        subpats: &'gcx [P<hir::Pat>],\n+        ddpos: Option<usize>,\n+        expected: Ty<'tcx>,\n+        def_bm: ty::BindingMode,\n+        match_arm_pat_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let on_error = || {\n             for pat in subpats {\n-                self.check_pat_walk(&pat, tcx.types.err, def_bm, true);\n+                self.check_pat_walk(&pat, tcx.types.err, def_bm, match_arm_pat_span);\n             }\n         };\n         let report_unexpected_def = |def: Def| {\n@@ -826,7 +861,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let pat_ty = pat_ty.fn_sig(tcx).output();\n         let pat_ty = pat_ty.no_bound_vars().expect(\"expected fn type\");\n \n-        self.demand_eqtype(pat.span, expected, pat_ty);\n+        self.demand_eqtype_pat(pat.span, expected, pat_ty, match_arm_pat_span);\n \n         // Type-check subpatterns.\n         if subpats.len() == variant.fields.len() ||\n@@ -837,7 +872,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n-                self.check_pat_walk(&subpat, field_ty, def_bm, true);\n+                self.check_pat_walk(&subpat, field_ty, def_bm, match_arm_pat_span);\n \n                 self.tcx.check_stability(variant.fields[i].did, Some(pat.id), subpat.span);\n             }\n@@ -917,7 +952,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 }\n             };\n \n-            self.check_pat_walk(&field.pat, field_ty, def_bm, true);\n+            self.check_pat_walk(&field.pat, field_ty, def_bm, None);\n         }\n         let mut unmentioned_fields = variant.fields\n                 .iter()"}, {"sha": "c0cedd77440d9898e47352a5fb717cc918a51512", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1,6 +1,6 @@\n use check::FnCtxt;\n use rustc::infer::InferOk;\n-use rustc::traits::ObligationCause;\n+use rustc::traits::{ObligationCause, ObligationCauseCode};\n \n use syntax::ast;\n use syntax::util::parser::PREC_POSTFIX;\n@@ -66,6 +66,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn demand_eqtype_pat(\n+        &self,\n+        cause_span: Span,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+        match_expr_span: Option<Span>,\n+    ) {\n+        let cause = if let Some(span) = match_expr_span {\n+            self.cause(\n+                cause_span,\n+                ObligationCauseCode::MatchExpressionArmPattern { span, ty: expected },\n+            )\n+        } else {\n+            self.misc(cause_span)\n+        };\n+        self.demand_eqtype_with_origin(&cause, expected, actual).map(|mut err| err.emit());\n+    }\n+\n+\n     pub fn demand_coerce(&self,\n                          expr: &hir::Expr,\n                          checked_ty: Ty<'tcx>,"}, {"sha": "dbbb7f42feb242bf98e71148c5c8c24049622413", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1092,8 +1092,12 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     // Add formal parameters.\n     for (arg_ty, arg) in fn_sig.inputs().iter().zip(&body.arguments) {\n         // Check the pattern.\n-        fcx.check_pat_walk(&arg.pat, arg_ty,\n-            ty::BindingMode::BindByValue(hir::Mutability::MutImmutable), true);\n+        fcx.check_pat_walk(\n+            &arg.pat,\n+            arg_ty,\n+            ty::BindingMode::BindByValue(hir::Mutability::MutImmutable),\n+            None,\n+        );\n \n         // Check that argument is Sized.\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n@@ -4731,9 +4735,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        self.check_pat_walk(&local.pat, t,\n-                            ty::BindingMode::BindByValue(hir::Mutability::MutImmutable),\n-                            true);\n+        self.check_pat_walk(\n+            &local.pat,\n+            t,\n+            ty::BindingMode::BindByValue(hir::Mutability::MutImmutable),\n+            None,\n+        );\n         let pat_ty = self.node_ty(local.pat.hir_id);\n         if pat_ty.references_error() {\n             self.write_ty(local.hir_id, pat_ty);"}, {"sha": "31e06cb1a045fb6164ab683e27ce3a92a25ee696", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 19, "deletions": 51, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -3059,7 +3059,7 @@ fn item_trait(\n         let item_type = m.type_();\n         let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n         let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-        write!(w, \"{extra}<h3 id='{id}' class='method'><code id='{ns_id}'>\",\n+        write!(w, \"<h3 id='{id}' class='method'>{extra}<code id='{ns_id}'>\",\n                extra = render_spotlight_traits(m)?,\n                id = id,\n                ns_id = ns_id)?;\n@@ -3444,7 +3444,7 @@ fn item_union(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             let id = format!(\"{}.{}\", ItemType::StructField, name);\n             write!(w, \"<span id=\\\"{id}\\\" class=\\\"{shortty} small-section-header\\\">\\\n                            <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n-                           <span class='invisible'><code>{name}: {ty}</code></span>\\\n+                           <code>{name}: {ty}</code>\\\n                        </span>\",\n                    id = id,\n                    name = name,\n@@ -3999,8 +3999,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             None => \"impl\".to_string(),\n         });\n         if let Some(use_absolute) = use_absolute {\n-            write!(w, \"<h3 id='{}' class='impl'><span class='in-band'><table class='table-display'>\\\n-                       <tbody><tr><td><code>\", id)?;\n+            write!(w, \"<h3 id='{}' class='impl'><code class='in-band'>\", id)?;\n             fmt_impl_for_trait_page(&i.inner_impl(), w, use_absolute)?;\n             if show_def_docs {\n                 for it in &i.inner_impl().items {\n@@ -4014,22 +4013,18 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             }\n             write!(w, \"</code>\")?;\n         } else {\n-            write!(w, \"<h3 id='{}' class='impl'><span class='in-band'><table class='table-display'>\\\n-                       <tbody><tr><td><code>{}</code>\",\n-                   id, i.inner_impl())?;\n+            write!(w, \"<h3 id='{}' class='impl'><code class='in-band'>{}</code>\",\n+                id, i.inner_impl()\n+            )?;\n         }\n         write!(w, \"<a href='#{}' class='anchor'></a>\", id)?;\n-        write!(w, \"</td><td><span class='out-of-band'>\")?;\n         let since = i.impl_item.stability.as_ref().map(|s| &s.since[..]);\n+        render_stability_since_raw(w, since, outer_version)?;\n         if let Some(l) = (Item { item: &i.impl_item, cx: cx }).src_href() {\n-            write!(w, \"<div class='ghost'></div>\")?;\n-            render_stability_since_raw(w, since, outer_version)?;\n             write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n                    l, \"goto source code\")?;\n-        } else {\n-            render_stability_since_raw(w, since, outer_version)?;\n         }\n-        write!(w, \"</span></td></tr></tbody></table></span></h3>\")?;\n+        write!(w, \"</h3>\")?;\n         if let Some(ref dox) = cx.shared.maybe_collapsed_doc_value(&i.impl_item) {\n             let mut ids = cx.id_map.borrow_mut();\n             write!(w, \"<div class='docblock'>{}</div>\",\n@@ -4065,20 +4060,15 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                     let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                     write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class)?;\n                     write!(w, \"{}\", spotlight_decl(decl)?)?;\n-                    write!(w, \"<table id='{}' class='table-display'><tbody><tr><td><code>\", ns_id)?;\n+                    write!(w, \"<code id='{}'>\", ns_id)?;\n                     render_assoc_item(w, item, link.anchor(&id), ItemType::Impl)?;\n                     write!(w, \"</code>\")?;\n+                    render_stability_since_raw(w, item.stable_since(), outer_version)?;\n                     if let Some(l) = (Item { cx, item }).src_href() {\n-                        write!(w, \"</td><td><span class='out-of-band'>\")?;\n-                        write!(w, \"<div class='ghost'></div>\")?;\n-                        render_stability_since_raw(w, item.stable_since(), outer_version)?;\n-                        write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a></span>\",\n+                        write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n                                l, \"goto source code\")?;\n-                    } else {\n-                        write!(w, \"</td><td>\")?;\n-                        render_stability_since_raw(w, item.stable_since(), outer_version)?;\n                     }\n-                    write!(w, \"</td></tr></tbody></table></h4>\")?;\n+                    write!(w, \"</h4>\")?;\n                 }\n             }\n             clean::TypedefItem(ref tydef, _) => {\n@@ -4090,40 +4080,18 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                 write!(w, \"</code></h4>\")?;\n             }\n             clean::AssociatedConstItem(ref ty, ref default) => {\n-                let mut version = String::new();\n-\n-                render_stability_since_raw(&mut version, item.stable_since(), outer_version)?;\n-\n                 let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n                 let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                 write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class)?;\n-                if !version.is_empty() {\n-                    write!(w, \"<table id='{}' class='table-display'><tbody><tr><td><code>\", ns_id)?;\n-                } else {\n-                    write!(w, \"<code id='{}'>\", ns_id)?;\n-                }\n+                write!(w, \"<code id='{}'>\", ns_id)?;\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id))?;\n-                if !version.is_empty() {\n-                    write!(w, \"</code>\")?;\n-                }\n-                let src = if let Some(l) = (Item { cx, item }).src_href() {\n-                    if !version.is_empty() {\n-                        write!(w, \"</td><td><span class='out-of-band'>\")?;\n-                        write!(w, \"<div class='ghost'></div>{}\", version)?;\n-                    }\n-                    format!(\"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n-                            l, \"goto source code\")\n-                } else {\n-                    if !version.is_empty() {\n-                        write!(w, \"</td><td>{}\", version)?;\n-                    }\n-                    String::new()\n-                };\n-                if version.is_empty() {\n-                    write!(w, \"</code>{}</h4>\", src)?;\n-                } else {\n-                    write!(w, \"{}</span></td></tr></tbody></table></h4>\", src)?;\n+                write!(w, \"</code>\")?;\n+                render_stability_since_raw(w, item.stable_since(), outer_version)?;\n+                if let Some(l) = (Item { cx, item }).src_href() {\n+                    write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n+                            l, \"goto source code\")?;\n                 }\n+                write!(w, \"</h4>\")?;\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n                 let id = cx.derive_id(format!(\"{}.{}\", item_type, name));"}, {"sha": "9db1c686090399570951f5cf8caa2c9ea0ef54e2", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -2409,8 +2409,17 @@ if (!DOMTokenList.prototype.remove) {\n             e.remove();\n         });\n         onEachLazy(main.childNodes, function(e) {\n+            // Unhide the actual content once loading is complete. Headers get\n+            // flex treatment for their horizontal layout, divs get block treatment\n+            // for vertical layout (column-oriented flex layout for divs caused\n+            // errors in mobile browsers).\n             if (e.tagName === \"H2\" || e.tagName === \"H3\") {\n-                e.nextElementSibling.style.display = \"block\";\n+                let nextTagName = e.nextElementSibling.tagName;\n+                if (nextTagName == \"H2\" || nextTagName == \"H3\") {\n+                    e.nextElementSibling.style.display = \"flex\";\n+                } else {\n+                    e.nextElementSibling.style.display = \"block\";\n+                }\n             }\n         });\n     }"}, {"sha": "8a8b7adcf7d4a0384735615565119368d0dca2d8", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -89,8 +89,9 @@ h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.t\n \tborder-bottom: 1px solid;\n }\n h3.impl, h3.method, h4.method, h3.type, h4.type, h4.associatedconstant {\n+\tflex-basis: 100%;\n \tfont-weight: 600;\n-\tmargin-top: 10px;\n+\tmargin-top: 16px;\n \tmargin-bottom: 10px;\n \tposition: relative;\n }\n@@ -356,7 +357,8 @@ nav.sub {\n #main > .docblock h3, #main > .docblock h4, #main > .docblock h5 { font-size: 1em; }\n \n #main > h2 + div, #main > h2 + h3, #main > h3 + div {\n-\tdisplay: none;\n+\tdisplay: none; /* Changed to flex or block via js once the page is loaded */\n+\tflex-wrap: wrap;\n }\n \n .docblock h1 { font-size: 1em; }\n@@ -390,7 +392,7 @@ h4 > code, h3 > code, .invisible > code {\n }\n \n .in-band, code {\n-\tz-index: 5;\n+\tz-index: -5;\n }\n \n .invisible {\n@@ -534,6 +536,10 @@ h4 > code, h3 > code, .invisible > code {\n \tmargin-top: -8px;\n }\n \n+.impl-items {\n+\tflex-basis: 100%;\n+}\n+\n #main > .stability {\n \tmargin-top: 0;\n }\n@@ -784,6 +790,33 @@ body.blur > :not(#help) {\n \ttop: 0;\n }\n \n+.impl-items .since, .impl .since {\n+\tflex-grow: 0;\n+\tpadding-left: 12px;\n+\tpadding-right: 2px;\n+\tposition: initial;\n+}\n+\n+.impl-items .srclink, .impl .srclink {\n+\tflex-grow: 0;\n+\t/* Override header settings otherwise it's too bold */\n+\tfont-size: 17px;\n+\tfont-weight: normal;\n+}\n+\n+.impl-items code, .impl code {\n+\tflex-grow: 1;\n+}\n+\n+.impl-items h4, h4.impl, h3.impl {\n+\tdisplay: flex;\n+\tflex-basis: 100%;\n+\tfont-size: 16px;\n+\tmargin-bottom: 12px;\n+\t/* Push the src link out to the right edge consistently */\n+\tjustify-content: space-between;\n+}\n+\n .variants_table {\n \twidth: 100%;\n }\n@@ -871,15 +904,6 @@ h3 > .collapse-toggle, h4 > .collapse-toggle {\n \tmargin-left: 20px;\n }\n \n-.ghost {\n-\tdisplay: none;\n-}\n-\n-.ghost + .since {\n-\tposition: initial;\n-\tdisplay: table-cell;\n-}\n-\n .since + .srclink {\n \tdisplay: table-cell;\n \tpadding-left: 10px;\n@@ -1119,7 +1143,7 @@ span.since {\n \tmargin-left: 5px;\n \ttop: -5px;\n \tleft: 105%;\n-\tz-index: 1;\n+\tz-index: 10;\n }\n \n .tooltip:hover .tooltiptext {\n@@ -1361,8 +1385,9 @@ h3.important {\n \tmargin-top: 16px;\n }\n \n-.content > .methods > div.important-traits {\n+.content > .methods > .method > div.important-traits {\n \tposition: absolute;\n+\tfont-weight: 400;\n \tleft: -42px;\n \tmargin-top: 2px;\n }"}, {"sha": "c561269cf9a856fab03feacda61a7ccb061fabb7", "filename": "src/test/rustdoc/assoc-consts-version.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fassoc-consts-version.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fassoc-consts-version.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-consts-version.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -10,7 +10,7 @@\n pub struct SomeStruct;\n \n impl SomeStruct {\n-    // @has 'foo/struct.SomeStruct.html' '//*[@id=\"SOME_CONST.v\"]//div[@class=\"since\"]' '1.1.2'\n+    // @has 'foo/struct.SomeStruct.html' '//*[@id=\"associatedconstant.SOME_CONST\"]//div[@class=\"since\"]' '1.1.2'\n     #[stable(since=\"1.1.2\", feature=\"rust2\")]\n     pub const SOME_CONST: usize = 0;\n }"}, {"sha": "c33db5809cc7c5d685e47d439e66523f7d65a527", "filename": "src/test/rustdoc/const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fconst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fconst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -3,7 +3,7 @@\n pub struct Foo;\n \n impl Foo {\n-    // @has const/struct.Foo.html '//*[@id=\"new.v\"]//code' 'const unsafe fn new'\n+    // @has const/struct.Foo.html '//code[@id=\"new.v\"]' 'const unsafe fn new'\n     pub const unsafe fn new() -> Foo {\n         Foo\n     }"}, {"sha": "55d8ee394385b50b4bc4c49c59784e0ef39bb6de", "filename": "src/test/rustdoc/issue-25001.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fissue-25001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fissue-25001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-25001.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -9,17 +9,17 @@ pub trait Bar {\n \n impl Foo<u8> {\n     // @has - '//*[@id=\"method.pass\"]//code' 'fn pass()'\n-    // @has - '//*[@id=\"pass.v\"]//code' 'fn pass()'\n+    // @has - '//code[@id=\"pass.v\"]' 'fn pass()'\n     pub fn pass() {}\n }\n impl Foo<u16> {\n     // @has - '//*[@id=\"method.pass-1\"]//code' 'fn pass() -> usize'\n-    // @has - '//*[@id=\"pass.v-1\"]//code' 'fn pass() -> usize'\n+    // @has - '//code[@id=\"pass.v-1\"]' 'fn pass() -> usize'\n     pub fn pass() -> usize { 42 }\n }\n impl Foo<u32> {\n     // @has - '//*[@id=\"method.pass-2\"]//code' 'fn pass() -> isize'\n-    // @has - '//*[@id=\"pass.v-2\"]//code' 'fn pass() -> isize'\n+    // @has - '//code[@id=\"pass.v-2\"]' 'fn pass() -> isize'\n     pub fn pass() -> isize { 42 }\n }\n "}, {"sha": "d9accf9c5998b355c6f139af54aa738fb8e44557", "filename": "src/test/rustdoc/issue-51236.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fissue-51236.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fissue-51236.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-51236.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -7,7 +7,7 @@ pub mod traits {\n }\n \n // @has issue_51236/struct.Owned.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<T> Send for \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<T> Send for \\\n // Owned<T> where <T as Owned<'static>>::Reader: Send\"\n pub struct Owned<T> where T: for<'a> ::traits::Owned<'a> {\n     marker: PhantomData<<T as ::traits::Owned<'static>>::Reader>,"}, {"sha": "263b1eb0bd65aad1cbcbcf0130804d482c187088", "filename": "src/test/rustdoc/issue-54705.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fissue-54705.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fissue-54705.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-54705.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -3,10 +3,10 @@ pub trait ScopeHandle<'scope> {}\n \n \n // @has issue_54705/struct.ScopeFutureContents.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<'scope, S> \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<'scope, S> \\\n // Send for ScopeFutureContents<'scope, S> where S: Sync\"\n //\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<'scope, S> \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<'scope, S> \\\n // Sync for ScopeFutureContents<'scope, S> where S: Sync\"\n pub struct ScopeFutureContents<'scope, S>\n     where S: ScopeHandle<'scope>,"}, {"sha": "257cb32c65c259261b177e7791dacadf6594ccbb", "filename": "src/test/rustdoc/issue-55321.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fissue-55321.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fissue-55321.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-55321.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1,16 +1,16 @@\n #![feature(optin_builtin_traits)]\n \n // @has issue_55321/struct.A.html\n-// @has - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl !Send for A\"\n-// @has - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl !Sync for A\"\n+// @has - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]//code' \"impl !Send for A\"\n+// @has - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]//code' \"impl !Sync for A\"\n pub struct A();\n \n impl !Send for A {}\n impl !Sync for A {}\n \n // @has issue_55321/struct.B.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<T> !Send for \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<T> !Send for \\\n // B<T>\"\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<T> !Sync for \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<T> !Sync for \\\n // B<T>\"\n pub struct B<T: ?Sized>(A, Box<T>);"}, {"sha": "5b67817fa4caaf6d4dfac69a4521f10d38429aa4", "filename": "src/test/rustdoc/issue-56822.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fissue-56822.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fissue-56822.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-56822.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -17,7 +17,7 @@ impl<'a, T> MyTrait for Inner<'a, T> {\n }\n \n // @has issue_56822/struct.Parser.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<'a> Send for \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<'a> Send for \\\n // Parser<'a>\"\n pub struct Parser<'a> {\n     field: <Wrapper<Inner<'a, u8>> as MyTrait>::Output"}, {"sha": "609cefc7115e2d19b8f8443d759d53f69d324b6c", "filename": "src/test/rustdoc/synthetic_auto/complex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcomplex.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -20,7 +20,7 @@ mod foo {\n }\n \n // @has complex/struct.NotOuter.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<'a, T, K: \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<'a, T, K: \\\n // ?Sized> Send for NotOuter<'a, T, K> where K: for<'b> Fn((&'b bool, &'a u8)) \\\n // -> &'b i8, T: MyTrait<'a>, <T as MyTrait<'a>>::MyItem: Copy, 'a: 'static\"\n "}, {"sha": "6d0a68f9b0734eeaaf7c0f465e012d1593df9a5c", "filename": "src/test/rustdoc/synthetic_auto/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Flifetimes.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -9,10 +9,10 @@ where\n {}\n \n // @has lifetimes/struct.Foo.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<'c, K> Send \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<'c, K> Send \\\n // for Foo<'c, K> where K: for<'b> Fn(&'b bool) -> &'c u8, 'c: 'static\"\n //\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<'c, K> Sync \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<'c, K> Sync \\\n // for Foo<'c, K> where K: Sync\"\n pub struct Foo<'c, K: 'c> {\n     inner_field: Inner<'c, K>,"}, {"sha": "413ba187f4556410a3267dd1b3b3bc168783d408", "filename": "src/test/rustdoc/synthetic_auto/manual.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fmanual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fmanual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fmanual.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1,8 +1,8 @@\n // @has manual/struct.Foo.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' 'impl<T> Sync for \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' 'impl<T> Sync for \\\n // Foo<T> where T: Sync'\n //\n-// @has - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]//*/code' \\\n+// @has - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]//code' \\\n // 'impl<T> Send for Foo<T>'\n //\n // @count - '//*[@id=\"implementations-list\"]/*[@class=\"impl\"]' 1"}, {"sha": "30713849da221fd6bcf278778cbff88aa19d2658", "filename": "src/test/rustdoc/synthetic_auto/negative.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnegative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnegative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnegative.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -3,10 +3,10 @@ pub struct Inner<T: Copy> {\n }\n \n // @has negative/struct.Outer.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<T> !Send for \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<T> !Send for \\\n // Outer<T>\"\n //\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<T> \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<T> \\\n // !Sync for Outer<T>\"\n pub struct Outer<T: Copy> {\n     inner_field: Inner<T>,"}, {"sha": "e710ce1c2ed95eb1c49a21da5a81d28ecabc9998", "filename": "src/test/rustdoc/synthetic_auto/nested.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fnested.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -9,10 +9,10 @@ where\n }\n \n // @has nested/struct.Foo.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' 'impl<T> Send for \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' 'impl<T> Send for \\\n // Foo<T> where T: Copy'\n //\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \\\n // 'impl<T> Sync for Foo<T> where T: Sync'\n pub struct Foo<T> {\n     inner_field: Inner<T>,"}, {"sha": "cf173111ec1e27ebdab26114d4315721d1ccff01", "filename": "src/test/rustdoc/synthetic_auto/no-redundancy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fno-redundancy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fno-redundancy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fno-redundancy.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -9,7 +9,7 @@ where\n }\n \n // @has no_redundancy/struct.Outer.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<T> Send for \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<T> Send for \\\n // Outer<T> where T: Copy + Send\"\n pub struct Outer<T> {\n     inner_field: Inner<T>,"}, {"sha": "5346521f8d2e365cbffabda500186b9e781605fc", "filename": "src/test/rustdoc/synthetic_auto/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fproject.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -23,10 +23,10 @@ where\n }\n \n // @has project/struct.Foo.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<'c, K> Send \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<'c, K> Send \\\n // for Foo<'c, K> where K: MyTrait<MyItem = bool>, 'c: 'static\"\n //\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<'c, K> Sync \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<'c, K> Sync \\\n // for Foo<'c, K> where K: MyTrait, <K as MyTrait>::MyItem: OtherTrait, 'c: 'static,\"\n pub struct Foo<'c, K: 'c> {\n     inner_field: Inner<'c, K>,"}, {"sha": "7d15434afe6dbb9cfd12fb50b768be211b1bcc83", "filename": "src/test/rustdoc/synthetic_auto/self-referential.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fself-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fself-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fself-referential.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -23,7 +23,7 @@ impl<T> Pattern for Wrapper<T> {\n \n \n // @has self_referential/struct.WriteAndThen.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<P1> Send for \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<P1> Send for \\\n // WriteAndThen<P1>  where  <P1 as Pattern>::Value: Send\"\n pub struct WriteAndThen<P1>(pub P1::Value,pub <Constrain<P1, Wrapper<P1::Value>> as Pattern>::Value)\n     where P1: Pattern;"}, {"sha": "59493744b623d7155f82ad268e1939cb9eda97af", "filename": "src/test/rustdoc/synthetic_auto/static-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fstatic-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fstatic-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fstatic-region.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -3,7 +3,7 @@ pub trait OwnedTrait<'a> {\n }\n \n // @has static_region/struct.Owned.html\n-// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//*/code' \"impl<T> Send for \\\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<T> Send for \\\n // Owned<T> where <T as OwnedTrait<'static>>::Reader: Send\"\n pub struct Owned<T> where T: OwnedTrait<'static> {\n     marker: <T as OwnedTrait<'static>>::Reader,"}, {"sha": "417667a5354fd723d445c5e9271bb60ccf7d59e1", "filename": "src/test/ui/block-result/issue-13624.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -12,6 +12,8 @@ LL |     Enum::EnumStructVariant { x: 1, y: 2, z: 3 }\n error[E0308]: mismatched types\n   --> $DIR/issue-13624.rs:22:9\n    |\n+LL |       match enum_struct_variant {\n+   |             ------------------- this match expression has type `()`\n LL |         a::Enum::EnumStructVariant { x, y, z } => {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found enum `a::Enum`\n    |"}, {"sha": "f69a389336590817614194480b0a7f037ada8ca2", "filename": "src/test/ui/error-codes/E0308-4.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Ferror-codes%2FE0308-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Ferror-codes%2FE0308-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0308-4.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/E0308-4.rs:4:9\n    |\n+LL |     match x {\n+   |           - this match expression has type `u8`\n LL |         0u8..=3i8 => (), //~ ERROR E0308\n    |         ^^^^^^^^^ expected u8, found i8\n "}, {"sha": "683ad48ff52c0b4249eefe376f2474f353961678", "filename": "src/test/ui/issues/issue-11844.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-11844.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-11844.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11844.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-11844.rs:6:9\n    |\n+LL |     match a {\n+   |           - this match expression has type `std::option::Option<std::boxed::Box<{integer}>>`\n LL |         Ok(a) => //~ ERROR: mismatched types\n    |         ^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n    |"}, {"sha": "768d11bf899a1f333f33f22c15aeb0c8769305aa", "filename": "src/test/ui/issues/issue-12552.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-12552.rs:6:5\n    |\n+LL |   match t {\n+   |         - this match expression has type `std::result::Result<_, {integer}>`\n LL |     Some(k) => match k { //~ ERROR mismatched types\n    |     ^^^^^^^ expected enum `std::result::Result`, found enum `std::option::Option`\n    |"}, {"sha": "66255891f469a01534d355464546a796ca3c14f1", "filename": "src/test/ui/issues/issue-13466.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-13466.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-13466.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13466.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-13466.rs:8:9\n    |\n+LL |     let _x: usize = match Some(1) {\n+   |                           ------- this match expression has type `std::option::Option<{integer}>`\n LL |         Ok(u) => u,\n    |         ^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n    |\n@@ -10,6 +12,9 @@ LL |         Ok(u) => u,\n error[E0308]: mismatched types\n   --> $DIR/issue-13466.rs:14:9\n    |\n+LL |     let _x: usize = match Some(1) {\n+   |                           ------- this match expression has type `std::option::Option<{integer}>`\n+...\n LL |         Err(e) => panic!(e)\n    |         ^^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n    |"}, {"sha": "de9757d5d32ed912e4cc322177d84d0b9b74e658", "filename": "src/test/ui/issues/issue-15896.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-15896.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-15896.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15896.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1,6 +1,9 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-15896.rs:11:11\n    |\n+LL |     let u = match e {\n+   |                   - this match expression has type `main::R`\n+LL |         E::B(\n LL |           Tau{t: x},\n    |           ^^^^^^^^^ expected enum `main::R`, found struct `main::Tau`\n    |"}, {"sha": "1779d0befd871faab0eb4d6751dcb64ce5fa8d9f", "filename": "src/test/ui/issues/issue-16401.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-16401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-16401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16401.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-16401.rs:8:9\n    |\n+LL |     match () {\n+   |           -- this match expression has type `()`\n LL |         Slice { data: data, len: len } => (),\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found struct `Slice`\n    |"}, {"sha": "51903cfadab15e4ee9096679d32a83cb3a1a4634", "filename": "src/test/ui/issues/issue-3680.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-3680.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-3680.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3680.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-3680.rs:3:9\n    |\n+LL |     match None {\n+   |           ---- this match expression has type `std::option::Option<_>`\n LL |         Err(_) => ()\n    |         ^^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n    |"}, {"sha": "0a918a789703e5f0e66725373b2e78026dfe3575", "filename": "src/test/ui/issues/issue-5100.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -28,6 +28,8 @@ LL |         (true, false, false) => ()\n error[E0308]: mismatched types\n   --> $DIR/issue-5100.rs:33:9\n    |\n+LL |     match (true, false) {\n+   |           ------------- this match expression has type `(bool, bool)`\n LL |         box (true, false) => ()\n    |         ^^^^^^^^^^^^^^^^^ expected tuple, found struct `std::boxed::Box`\n    |"}, {"sha": "649a0c1581a687e0069b1e2504d13e5d7722d46c", "filename": "src/test/ui/issues/issue-5358-1.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-5358-1.rs:6:9\n    |\n+LL |     match S(Either::Left(5)) {\n+   |           ------------------ this match expression has type `S`\n LL |         Either::Right(_) => {}\n    |         ^^^^^^^^^^^^^^^^ expected struct `S`, found enum `Either`\n    |"}, {"sha": "1131006374c64eb70672e54783d1351ef6ef8401", "filename": "src/test/ui/issues/issue-57472.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-57472.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-57472.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57472.rs?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -0,0 +1,35 @@\n+#![crate_type=\"lib\"]\n+#![deny(unreachable_patterns)]\n+\n+mod test_struct {\n+    // Test the exact copy of the minimal example\n+    // posted in the issue.\n+    pub struct Punned {\n+        foo: [u8; 1],\n+        bar: [u8; 1],\n+    }\n+\n+    pub fn test(punned: Punned) {\n+        match punned {\n+            Punned { foo: [_], .. } => println!(\"foo\"),\n+            Punned { bar: [_], .. } => println!(\"bar\"),\n+            //~^ ERROR unreachable pattern [unreachable_patterns]\n+        }\n+    }\n+}\n+\n+mod test_union {\n+    // Test the same thing using a union.\n+    pub union Punned {\n+        foo: [u8; 1],\n+        bar: [u8; 1],\n+    }\n+\n+    pub fn test(punned: Punned) {\n+        match punned {\n+            Punned { foo: [_] } => println!(\"foo\"),\n+            Punned { bar: [_] } => println!(\"bar\"),\n+            //~^ ERROR unreachable pattern [unreachable_patterns]\n+        }\n+    }\n+}"}, {"sha": "b6dd7e249418691fbfc63a874d46f7c0db96f3fe", "filename": "src/test/ui/issues/issue-57472.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-57472.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-57472.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57472.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -0,0 +1,20 @@\n+error: unreachable pattern\n+  --> $DIR/issue-57472.rs:15:13\n+   |\n+LL |             Punned { bar: [_], .. } => println!(\"bar\"),\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-57472.rs:2:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/issue-57472.rs:31:13\n+   |\n+LL |             Punned { bar: [_] } => println!(\"bar\"),\n+   |             ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "7bb682028748706ea5aa1c406e11c5de8035d7b6", "filename": "src/test/ui/issues/issue-7092.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-7092.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fissues%2Fissue-7092.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-7092.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/issue-7092.rs:6:9\n    |\n+LL |     match x {\n+   |           - this match expression has type `Whatever`\n LL |         Some(field) =>\n    |         ^^^^^^^^^^^ expected enum `Whatever`, found enum `std::option::Option`\n    |"}, {"sha": "2a24a293e98364e68c6a3a4c47fbecac7ace3e05", "filename": "src/test/ui/match/match-struct.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fmatch%2Fmatch-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fmatch%2Fmatch-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-struct.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/match-struct.rs:6:9\n    |\n+LL |     match (S { a: 1 }) {\n+   |           ------------ this match expression has type `S`\n LL |         E::C(_) => (),\n    |         ^^^^^^^ expected struct `S`, found enum `E`\n    |"}, {"sha": "53b663513696626d0b3a3a09eafb8fa17dc5bd9f", "filename": "src/test/ui/match/match-tag-unary.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-unary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-unary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-unary.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/match-tag-unary.rs:4:43\n    |\n LL | fn main() { let x: A = A::A(0); match x { B::B(y) => { } } } //~ ERROR mismatched types\n-   |                                           ^^^^^^^ expected enum `A`, found enum `B`\n+   |                                       -   ^^^^^^^ expected enum `A`, found enum `B`\n+   |                                       |\n+   |                                       this match expression has type `A`\n    |\n    = note: expected type `A`\n               found type `B`"}, {"sha": "c2810d764c2ceba3d2247485e1f357aa962d755b", "filename": "src/test/ui/pattern/pattern-error-continue.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -21,6 +21,8 @@ LL |         A::B(_, _, _) => (), //~ ERROR this pattern has 3 fields, but\n error[E0308]: mismatched types\n   --> $DIR/pattern-error-continue.rs:22:9\n    |\n+LL |     match 'c' {\n+   |           --- this match expression has type `char`\n LL |         S { .. } => (),\n    |         ^^^^^^^^ expected char, found struct `S`\n    |"}, {"sha": "69cd552aabd1bf56c29f311977558064e6daa56a", "filename": "src/test/ui/pattern/pattern-tyvar.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/pattern-tyvar.rs:5:18\n    |\n+LL |     match t {\n+   |           - this match expression has type `std::option::Option<std::vec::Vec<isize>>`\n LL |       Bar::T1(_, Some::<isize>(x)) => { //~ ERROR mismatched types\n    |                  ^^^^^^^^^^^^^^^^ expected struct `std::vec::Vec`, found isize\n    |"}, {"sha": "cc62316bec1851c82be12ddd0c97d37f075e199b", "filename": "src/test/ui/structs/structure-constructor-type-mismatch.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fstructs%2Fstructure-constructor-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9aee7ed335cfcaad33a6f6492497588b3d421b2d/src%2Ftest%2Fui%2Fstructs%2Fstructure-constructor-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstructure-constructor-type-mismatch.stderr?ref=9aee7ed335cfcaad33a6f6492497588b3d421b2d", "patch": "@@ -109,6 +109,8 @@ LL |         PointF::<u32> { .. } => {} //~ ERROR wrong number of type arguments\n error[E0308]: mismatched types\n   --> $DIR/structure-constructor-type-mismatch.rs:54:9\n    |\n+LL |     match (Point { x: 1, y: 2 }) {\n+   |           ---------------------- this match expression has type `Point<{integer}>`\n LL |         PointF::<u32> { .. } => {} //~ ERROR wrong number of type arguments\n    |         ^^^^^^^^^^^^^^^^^^^^ expected integer, found f32\n    |\n@@ -118,6 +120,8 @@ LL |         PointF::<u32> { .. } => {} //~ ERROR wrong number of type arguments\n error[E0308]: mismatched types\n   --> $DIR/structure-constructor-type-mismatch.rs:59:9\n    |\n+LL |     match (Point { x: 1, y: 2 }) {\n+   |           ---------------------- this match expression has type `Point<{integer}>`\n LL |         PointF { .. } => {} //~ ERROR mismatched types\n    |         ^^^^^^^^^^^^^ expected integer, found f32\n    |\n@@ -127,6 +131,8 @@ LL |         PointF { .. } => {} //~ ERROR mismatched types\n error[E0308]: mismatched types\n   --> $DIR/structure-constructor-type-mismatch.rs:67:9\n    |\n+LL |     match (Pair { x: 1, y: 2 }) {\n+   |           --------------------- this match expression has type `Pair<{integer}, {integer}>`\n LL |         PairF::<u32> { .. } => {} //~ ERROR mismatched types\n    |         ^^^^^^^^^^^^^^^^^^^ expected integer, found f32\n    |"}]}