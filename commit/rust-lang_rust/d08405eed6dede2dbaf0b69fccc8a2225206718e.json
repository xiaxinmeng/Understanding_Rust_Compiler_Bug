{"sha": "d08405eed6dede2dbaf0b69fccc8a2225206718e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwODQwNWVlZDZkZWRlMmRiYWYwYjY5ZmNjYzhhMjIyNTIwNjcxOGU=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-08-31T05:18:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-31T05:18:45Z"}, "message": "Merge pull request #1931 from topecongiro/cargo-clippy\n\nApply refactoring from cargo clippy", "tree": {"sha": "4f8d296af924d5e221eee756c35cdb8f11f17985", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f8d296af924d5e221eee756c35cdb8f11f17985"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d08405eed6dede2dbaf0b69fccc8a2225206718e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d08405eed6dede2dbaf0b69fccc8a2225206718e", "html_url": "https://github.com/rust-lang/rust/commit/d08405eed6dede2dbaf0b69fccc8a2225206718e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d08405eed6dede2dbaf0b69fccc8a2225206718e/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5a5db2b2be097a525ef351a070e8ed0805e9a24", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5a5db2b2be097a525ef351a070e8ed0805e9a24", "html_url": "https://github.com/rust-lang/rust/commit/c5a5db2b2be097a525ef351a070e8ed0805e9a24"}, {"sha": "9d49bd22f05cc00ec6f98c4614610e17605165dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d49bd22f05cc00ec6f98c4614610e17605165dd", "html_url": "https://github.com/rust-lang/rust/commit/9d49bd22f05cc00ec6f98c4614610e17605165dd"}], "stats": {"total": 398, "additions": 185, "deletions": 213}, "files": [{"sha": "3d0a5589d37a95d0107c7cc9e4862581a09de077", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -84,7 +84,7 @@ fn execute() -> i32 {\n \n     let workspace_hitlist = WorkspaceHitlist::from_matches(&matches);\n \n-    match format_crate(verbosity, workspace_hitlist) {\n+    match format_crate(verbosity, &workspace_hitlist) {\n         Err(e) => {\n             print_usage(&opts, &e.to_string());\n             failure\n@@ -115,7 +115,7 @@ pub enum Verbosity {\n \n fn format_crate(\n     verbosity: Verbosity,\n-    workspace_hitlist: WorkspaceHitlist,\n+    workspace_hitlist: &WorkspaceHitlist,\n ) -> Result<ExitStatus, std::io::Error> {\n     let targets = get_targets(workspace_hitlist)?;\n \n@@ -178,9 +178,9 @@ pub enum WorkspaceHitlist {\n }\n \n impl WorkspaceHitlist {\n-    pub fn get_some<'a>(&'a self) -> Option<&'a [String]> {\n-        if let &WorkspaceHitlist::Some(ref hitlist) = self {\n-            Some(&hitlist)\n+    pub fn get_some(&self) -> Option<&[String]> {\n+        if let WorkspaceHitlist::Some(ref hitlist) = *self {\n+            Some(hitlist)\n         } else {\n             None\n         }\n@@ -196,9 +196,9 @@ impl WorkspaceHitlist {\n }\n \n // Returns a vector of all compile targets of a crate\n-fn get_targets(workspace_hitlist: WorkspaceHitlist) -> Result<Vec<Target>, std::io::Error> {\n+fn get_targets(workspace_hitlist: &WorkspaceHitlist) -> Result<Vec<Target>, std::io::Error> {\n     let mut targets: Vec<Target> = vec![];\n-    if workspace_hitlist == WorkspaceHitlist::None {\n+    if *workspace_hitlist == WorkspaceHitlist::None {\n         let output = Command::new(\"cargo\").arg(\"read-manifest\").output()?;\n         if output.status.success() {\n             // None of the unwraps should fail if output of `cargo read-manifest` is correct\n@@ -229,7 +229,7 @@ fn get_targets(workspace_hitlist: WorkspaceHitlist) -> Result<Vec<Target>, std::\n         let data = &String::from_utf8(output.stdout).unwrap();\n         let json: Value = json::from_str(data).unwrap();\n         let json_obj = json.as_object().unwrap();\n-        let mut hitlist: HashSet<&String> = if workspace_hitlist != WorkspaceHitlist::All {\n+        let mut hitlist: HashSet<&String> = if *workspace_hitlist != WorkspaceHitlist::All {\n             HashSet::from_iter(workspace_hitlist.get_some().unwrap())\n         } else {\n             HashSet::new() // Unused\n@@ -240,15 +240,15 @@ fn get_targets(workspace_hitlist: WorkspaceHitlist) -> Result<Vec<Target>, std::\n             .as_array()\n             .unwrap()\n             .into_iter()\n-            .filter(|member| if workspace_hitlist == WorkspaceHitlist::All {\n+            .filter(|member| if *workspace_hitlist == WorkspaceHitlist::All {\n                 true\n             } else {\n                 let member_obj = member.as_object().unwrap();\n                 let member_name = member_obj.get(\"name\").unwrap().as_str().unwrap();\n                 hitlist.take(&member_name.to_string()).is_some()\n             })\n             .collect();\n-        if hitlist.len() != 0 {\n+        if hitlist.is_empty() {\n             // Mimick cargo of only outputting one <package> spec.\n             return Err(std::io::Error::new(\n                 std::io::ErrorKind::InvalidInput,"}, {"sha": "5b891dfd1db7a18ce4226da1d1d55da1c5c00565", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -104,7 +104,7 @@ fn match_cli_path_or_file(\n         let toml = Config::from_toml_path(config_file.as_ref())?;\n         return Ok((toml, Some(config_file)));\n     }\n-    Config::from_resolved_toml_path(input_file).map_err(|e| FmtError::from(e))\n+    Config::from_resolved_toml_path(input_file).map_err(FmtError::from)\n }\n \n fn make_opts() -> Options {\n@@ -161,21 +161,21 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n         Operation::Help => {\n             print_usage(opts, \"\");\n             Summary::print_exit_codes();\n-            Ok(Summary::new())\n+            Ok(Summary::default())\n         }\n         Operation::Version => {\n             print_version();\n-            Ok(Summary::new())\n+            Ok(Summary::default())\n         }\n         Operation::ConfigHelp => {\n             Config::print_docs();\n-            Ok(Summary::new())\n+            Ok(Summary::default())\n         }\n         Operation::ConfigOutputDefault { path } => {\n             let mut file = File::create(path)?;\n             let toml = Config::default().all_options().to_toml()?;\n             file.write_all(toml.as_bytes())?;\n-            Ok(Summary::new())\n+            Ok(Summary::default())\n         }\n         Operation::Stdin { input, config_path } => {\n             // try to read config from local directory\n@@ -222,7 +222,7 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n                 }\n             }\n \n-            let mut error_summary = Summary::new();\n+            let mut error_summary = Summary::default();\n             for file in files {\n                 if !file.exists() {\n                     println!(\"Error: file `{}` does not exist\", file.to_str().unwrap());\n@@ -354,7 +354,7 @@ fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n                 return config_path_not_found(path.to_str().unwrap());\n             }\n         }\n-        path @ _ => path,\n+        path => path,\n     };\n \n     // If no path is given, we won't output a minimal config."}, {"sha": "411c3c7f45ff599a70ec6e3826c72ae05be6a25d", "filename": "src/chains.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -256,7 +256,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n             \"{}{}{}\",\n             parent_rewrite,\n             first_connector,\n-            join_rewrites(&rewrites, &subexpr_list, &connector)\n+            join_rewrites(&rewrites, subexpr_list, &connector)\n         )\n     };\n     let result = format!(\"{}{}\", result, repeat_try(suffix_try_num));\n@@ -475,7 +475,7 @@ fn rewrite_method_call(\n         let type_list: Vec<_> =\n             try_opt!(types.iter().map(|ty| ty.rewrite(context, shape)).collect());\n \n-        let type_str = if context.config.spaces_within_angle_brackets() && type_list.len() > 0 {\n+        let type_str = if context.config.spaces_within_angle_brackets() && !type_list.is_empty() {\n             format!(\"::< {} >\", type_list.join(\", \"))\n         } else {\n             format!(\"::<{}>\", type_list.join(\", \"))"}, {"sha": "f62bb16dfa22acc93970c30363ce4fadef0b0fd3", "filename": "src/codemap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodemap.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! This module contains utilities that work with the `CodeMap` from libsyntax / syntex_syntax.\n+//! This module contains utilities that work with the `CodeMap` from `libsyntax` / `syntex_syntax`.\n //! This includes extension traits and methods for looking up spans and line ranges for AST nodes.\n \n use std::rc::Rc;\n@@ -77,8 +77,9 @@ impl LineRangeUtils for CodeMap {\n         let lo = self.lookup_char_pos(span.lo());\n         let hi = self.lookup_char_pos(span.hi());\n \n-        assert!(\n-            lo.file.name == hi.file.name,\n+        assert_eq!(\n+            lo.file.name,\n+            hi.file.name,\n             \"span crossed file boundary: lo: {:?}, hi: {:?}\",\n             lo,\n             hi"}, {"sha": "4cb8325d25eac9c66a03f4b14bc9711879a7f8f8", "filename": "src/comment.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -23,16 +23,14 @@ use utils::{first_line_width, last_line_width, wrap_str};\n fn is_custom_comment(comment: &str) -> bool {\n     if !comment.starts_with(\"//\") {\n         false\n+    } else if let Some(c) = comment.chars().nth(2) {\n+        !c.is_alphanumeric() && !c.is_whitespace()\n     } else {\n-        if let Some(c) = comment.chars().nth(2) {\n-            !c.is_alphanumeric() && !c.is_whitespace()\n-        } else {\n-            false\n-        }\n+        false\n     }\n }\n \n-#[derive(PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq, Eq)]\n pub enum CommentStyle<'a> {\n     DoubleSlash,\n     TripleSlash,\n@@ -194,17 +192,15 @@ pub fn combine_strs_with_missing_comments(\n     };\n     let second_sep = if missing_comment.is_empty() || next_str.is_empty() {\n         String::new()\n+    } else if missing_comment.starts_with(\"//\") {\n+        format!(\"\\n{}\", indent_str)\n     } else {\n-        if missing_comment.starts_with(\"//\") {\n-            format!(\"\\n{}\", indent_str)\n+        one_line_width += missing_comment.len() + first_sep.len() + 1;\n+        allow_one_line &= !missing_comment.starts_with(\"//\") && !missing_comment.contains('\\n');\n+        if prefer_same_line && allow_one_line && one_line_width <= shape.width {\n+            String::from(\" \")\n         } else {\n-            one_line_width += missing_comment.len() + first_sep.len() + 1;\n-            allow_one_line &= !missing_comment.starts_with(\"//\") && !missing_comment.contains('\\n');\n-            if prefer_same_line && allow_one_line && one_line_width <= shape.width {\n-                String::from(\" \")\n-            } else {\n-                format!(\"\\n{}\", indent_str)\n-            }\n+            format!(\"\\n{}\", indent_str)\n         }\n     };\n     Some(format!(\n@@ -314,7 +310,7 @@ fn rewrite_comment_inner(\n             line = line.trim();\n             // Drop old closer.\n             if i == line_breaks && line.ends_with(\"*/\") && !line.starts_with(\"//\") {\n-                line = &line[..(line.len() - 2)].trim_right();\n+                line = line[..(line.len() - 2)].trim_right();\n             }\n \n             line\n@@ -339,7 +335,7 @@ fn rewrite_comment_inner(\n         }\n \n         if config.wrap_comments() && line.len() > max_chars {\n-            let rewrite = rewrite_string(line, &fmt).unwrap_or(line.to_owned());\n+            let rewrite = rewrite_string(line, &fmt).unwrap_or_else(|| line.to_owned());\n             result.push_str(&rewrite);\n         } else {\n             if line.is_empty() && result.ends_with(' ') {\n@@ -412,7 +408,7 @@ fn light_rewrite_comment(orig: &str, offset: Indent, config: &Config) -> Option<\n             // `*` in `/*`.\n             let first_non_whitespace = l.find(|c| !char::is_whitespace(c));\n             if let Some(fnw) = first_non_whitespace {\n-                if l.as_bytes()[fnw] == '*' as u8 && fnw > 0 {\n+                if l.as_bytes()[fnw] == b'*' && fnw > 0 {\n                     &l[fnw - 1..]\n                 } else {\n                     &l[fnw..]\n@@ -432,7 +428,7 @@ fn left_trim_comment_line<'a>(line: &'a str, style: &CommentStyle) -> &'a str {\n         line.starts_with(\"/** \")\n     {\n         &line[4..]\n-    } else if let &CommentStyle::Custom(opener) = style {\n+    } else if let CommentStyle::Custom(opener) = *style {\n         if line.starts_with(opener) {\n             &line[opener.len()..]\n         } else {\n@@ -646,7 +642,7 @@ where\n                 _ => CharClassesStatus::Normal,\n             },\n             CharClassesStatus::BlockComment(deepness) => {\n-                assert!(deepness != 0);\n+                assert_ne!(deepness, 0);\n                 self.status = match self.base.peek() {\n                     Some(next) if next.get_char() == '/' && chr == '*' => {\n                         CharClassesStatus::BlockCommentClosing(deepness - 1)\n@@ -901,10 +897,8 @@ impl<'a> Iterator for CommentReducer<'a> {\n                 if c == '*' {\n                     c = try_opt!(self.iter.next());\n                 }\n-            } else {\n-                if c == '\\n' {\n-                    self.at_start_line = true;\n-                }\n+            } else if c == '\\n' {\n+                self.at_start_line = true;\n             }\n             if !c.is_whitespace() {\n                 return Some(c);"}, {"sha": "30d79cdc562983b00017c01c574c3b4e346d0e4c", "filename": "src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -306,7 +306,7 @@ macro_rules! create_config {\n                     let table = parsed\n                         .as_table()\n                         .ok_or(String::from(\"Parsed config was not table\"))?;\n-                    for (key, _) in table {\n+                    for key in table.keys() {\n                         match &**key {\n                             $(\n                                 stringify!($i) => (),"}, {"sha": "3cfbf023faf7641d1c91403b99e295286aa4fe39", "filename": "src/expr.rs", "status": "modified", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -44,7 +44,7 @@ impl Rewrite for ast::Expr {\n     }\n }\n \n-#[derive(PartialEq)]\n+#[derive(Copy, Clone, PartialEq)]\n pub enum ExprType {\n     Statement,\n     SubExpression,\n@@ -249,31 +249,31 @@ pub fn format_expr(\n             }\n \n             match (lhs.as_ref().map(|x| &**x), rhs.as_ref().map(|x| &**x)) {\n-                (Some(ref lhs), Some(ref rhs)) => {\n+                (Some(lhs), Some(rhs)) => {\n                     let sp_delim = if context.config.spaces_around_ranges() {\n                         format!(\" {} \", delim)\n                     } else if needs_space_before_range(context, lhs) {\n                         format!(\" {}\", delim)\n                     } else {\n                         delim.into()\n                     };\n-                    rewrite_pair(&**lhs, &**rhs, \"\", &sp_delim, \"\", context, shape)\n+                    rewrite_pair(&*lhs, &*rhs, \"\", &sp_delim, \"\", context, shape)\n                 }\n-                (None, Some(ref rhs)) => {\n+                (None, Some(rhs)) => {\n                     let sp_delim = if context.config.spaces_around_ranges() {\n                         format!(\"{} \", delim)\n                     } else {\n                         delim.into()\n                     };\n-                    rewrite_unary_prefix(context, &sp_delim, &**rhs, shape)\n+                    rewrite_unary_prefix(context, &sp_delim, &*rhs, shape)\n                 }\n-                (Some(ref lhs), None) => {\n+                (Some(lhs), None) => {\n                     let sp_delim = if context.config.spaces_around_ranges() {\n                         format!(\" {}\", delim)\n                     } else {\n                         delim.into()\n                     };\n-                    rewrite_unary_suffix(context, &sp_delim, &**lhs, shape)\n+                    rewrite_unary_suffix(context, &sp_delim, &*lhs, shape)\n                 }\n                 (None, None) => wrap_str(delim.into(), context.config.max_width(), shape),\n             }\n@@ -488,7 +488,7 @@ where\n     let result = if context.config.array_layout() == IndentStyle::Visual ||\n         tactic == DefinitiveListTactic::Horizontal\n     {\n-        if context.config.spaces_within_square_brackets() && list_str.len() > 0 {\n+        if context.config.spaces_within_square_brackets() && !list_str.is_empty() {\n             format!(\"[ {} ]\", list_str)\n         } else {\n             format!(\"[{}]\", list_str)\n@@ -631,7 +631,7 @@ fn rewrite_closure(\n         };\n         if no_return_type && !needs_block {\n             // lock.stmts.len() == 1\n-            if let Some(ref expr) = stmt_expr(&block.stmts[0]) {\n+            if let Some(expr) = stmt_expr(&block.stmts[0]) {\n                 if let Some(rw) = rewrite_closure_expr(expr, &prefix, context, body_shape) {\n                     return Some(rw);\n                 }\n@@ -651,7 +651,7 @@ fn rewrite_closure(\n         }\n \n         // Either we require a block, or tried without and failed.\n-        rewrite_closure_block(&block, &prefix, context, body_shape)\n+        rewrite_closure_block(block, &prefix, context, body_shape)\n     } else {\n         rewrite_closure_expr(body, &prefix, context, body_shape).or_else(|| {\n             // The closure originally had a non-block expression, but we can't fit on\n@@ -715,7 +715,7 @@ fn rewrite_closure_block(\n     // closure is large.\n     let block_threshold = context.config.closure_block_indent_threshold();\n     if block_threshold >= 0 {\n-        if let Some(block_str) = block.rewrite(&context, shape) {\n+        if let Some(block_str) = block.rewrite(context, shape) {\n             if block_str.matches('\\n').count() <= block_threshold as usize &&\n                 !need_block_indent(&block_str, shape)\n             {\n@@ -729,7 +729,7 @@ fn rewrite_closure_block(\n     // The body of the closure is big enough to be block indented, that\n     // means we must re-format.\n     let block_shape = shape.block();\n-    let block_str = try_opt!(block.rewrite(&context, block_shape));\n+    let block_str = try_opt!(block.rewrite(context, block_shape));\n     Some(format!(\"{} {}\", prefix, block_str))\n }\n \n@@ -1644,7 +1644,7 @@ fn rewrite_match_arm(\n \n fn rewrite_match_pattern(\n     context: &RewriteContext,\n-    pats: &Vec<ptr::P<ast::Pat>>,\n+    pats: &[ptr::P<ast::Pat>],\n     guard: &Option<ptr::P<ast::Expr>>,\n     shape: Shape,\n ) -> Option<String> {\n@@ -1722,9 +1722,9 @@ fn rewrite_match_body(\n     has_guard: bool,\n     is_last: bool,\n ) -> Option<String> {\n-    let (extend, body) = flatten_arm_body(context, &body);\n+    let (extend, body) = flatten_arm_body(context, body);\n \n-    let comma = arm_comma(&context.config, body, is_last);\n+    let comma = arm_comma(context.config, body, is_last);\n     let alt_block_sep = String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n     let alt_block_sep = alt_block_sep.as_str();\n     let (is_block, is_empty_block) = if let ast::ExprKind::Block(ref block) = body.node {\n@@ -1790,7 +1790,7 @@ fn rewrite_match_body(\n     // Let's try and get the arm body on the same line as the condition.\n     // 4 = ` => `.len()\n     let orig_body_shape = shape\n-        .offset_left(extra_offset(&pats_str, shape) + 4)\n+        .offset_left(extra_offset(pats_str, shape) + 4)\n         .and_then(|shape| shape.sub_width(comma.len()));\n     let orig_body = if let Some(body_shape) = orig_body_shape {\n         let rewrite = nop_block_collapse(\n@@ -1985,10 +1985,8 @@ fn string_requires_rewrite(\n             if line.len() > shape.width {\n                 return true;\n             }\n-        } else {\n-            if line.len() > shape.width + shape.indent.width() {\n-                return true;\n-            }\n+        } else if line.len() > shape.width + shape.indent.width() {\n+            return true;\n         }\n     }\n \n@@ -2049,7 +2047,7 @@ pub fn rewrite_call(\n     };\n     rewrite_call_inner(\n         context,\n-        &callee,\n+        callee,\n         &args.iter().map(|x| &**x).collect::<Vec<_>>(),\n         span,\n         shape,\n@@ -2076,7 +2074,7 @@ where\n     } else {\n         1\n     };\n-    let used_width = extra_offset(&callee_str, shape);\n+    let used_width = extra_offset(callee_str, shape);\n     let one_line_width = shape\n         .width\n         .checked_sub(used_width + 2 * paren_overhead)\n@@ -2117,7 +2115,7 @@ where\n     }\n \n     let args_shape = shape\n-        .sub_width(last_line_width(&callee_str))\n+        .sub_width(last_line_width(callee_str))\n         .ok_or(Ordering::Less)?;\n     Ok(format!(\n         \"{}{}\",\n@@ -2203,19 +2201,18 @@ fn try_overflow_last_arg<'a, T>(\n where\n     T: Rewrite + Spanned + ToExpr + 'a,\n {\n-    let overflow_last = can_be_overflowed(&context, args);\n+    let overflow_last = can_be_overflowed(context, args);\n \n     // Replace the last item with its first line to see if it fits with\n     // first arguments.\n     let placeholder = if overflow_last {\n         let mut context = context.clone();\n         if let Some(expr) = args[args.len() - 1].to_expr() {\n-            match expr.node {\n-                ast::ExprKind::MethodCall(..) => context.force_one_line_chain = true,\n-                _ => (),\n+            if let ast::ExprKind::MethodCall(..) = expr.node {\n+                context.force_one_line_chain = true;\n             }\n         }\n-        last_arg_shape(&context, &item_vec, shape, args_max_width).and_then(|arg_shape| {\n+        last_arg_shape(&context, item_vec, shape, args_max_width).and_then(|arg_shape| {\n             rewrite_last_arg_with_overflow(&context, args, &mut item_vec[args.len() - 1], arg_shape)\n         })\n     } else {\n@@ -2253,12 +2250,12 @@ where\n \n fn last_arg_shape(\n     context: &RewriteContext,\n-    items: &Vec<ListItem>,\n+    items: &[ListItem],\n     shape: Shape,\n     args_max_width: usize,\n ) -> Option<Shape> {\n     let overhead = items.iter().rev().skip(1).fold(0, |acc, i| {\n-        acc + i.item.as_ref().map_or(0, |s| first_line_width(&s))\n+        acc + i.item.as_ref().map_or(0, |s| first_line_width(s))\n     });\n     let max_width = min(args_max_width, shape.width);\n     let arg_indent = if context.use_block_indent() {\n@@ -2413,7 +2410,7 @@ pub fn wrap_args_with_parens(\n         (context.inside_macro && !args_str.contains('\\n') &&\n             args_str.len() + paren_overhead(context) <= shape.width) || is_extendable\n     {\n-        if context.config.spaces_within_parens() && args_str.len() > 0 {\n+        if context.config.spaces_within_parens() && !args_str.is_empty() {\n             format!(\"( {} )\", args_str)\n         } else {\n             format!(\"({})\", args_str)\n@@ -2445,7 +2442,7 @@ fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, shape: Shape) ->\n             .and_then(|s| s.sub_width(paren_overhead))\n     );\n \n-    let paren_wrapper = |s: &str| if context.config.spaces_within_parens() && s.len() > 0 {\n+    let paren_wrapper = |s: &str| if context.config.spaces_within_parens() && !s.is_empty() {\n         format!(\"( {} )\", s)\n     } else {\n         format!(\"({})\", s)\n@@ -2505,15 +2502,15 @@ fn rewrite_index(\n         (_, Some(ref new_index_str)) if !new_index_str.contains('\\n') => Some(format!(\n             \"{}\\n{}{}{}{}\",\n             expr_str,\n-            indent.to_string(&context.config),\n+            indent.to_string(context.config),\n             lbr,\n             new_index_str,\n             rbr\n         )),\n         (None, Some(ref new_index_str)) => Some(format!(\n             \"{}\\n{}{}{}{}\",\n             expr_str,\n-            indent.to_string(&context.config),\n+            indent.to_string(context.config),\n             lbr,\n             new_index_str,\n             rbr\n@@ -2556,7 +2553,7 @@ fn rewrite_struct_lit<'a>(\n         path_shape,\n     ));\n \n-    if fields.len() == 0 && base.is_none() {\n+    if fields.is_empty() && base.is_none() {\n         return Some(format!(\"{} {{}}\", path_str));\n     }\n \n@@ -2706,7 +2703,7 @@ pub fn rewrite_field(\n                         \"{}{}:\\n{}{}\",\n                         attrs_str,\n                         name,\n-                        expr_offset.to_string(&context.config),\n+                        expr_offset.to_string(context.config),\n                         s\n                     )\n                 })\n@@ -2789,7 +2786,7 @@ where\n     };\n     let list_str = try_opt!(write_list(&item_vec, &fmt));\n \n-    if context.config.spaces_within_parens() && list_str.len() > 0 {\n+    if context.config.spaces_within_parens() && !list_str.is_empty() {\n         Some(format!(\"( {} )\", list_str))\n     } else {\n         Some(format!(\"({})\", list_str))"}, {"sha": "704a89017d0141f7b0eb3323f9a87f8828af67b6", "filename": "src/file_lines.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffile_lines.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -95,7 +95,7 @@ fn normalize_ranges(ranges: &mut HashMap<String, Vec<Range>>) {\n         {\n             let mut iter = ranges.into_iter().peekable();\n             while let Some(next) = iter.next() {\n-                let mut next = next.clone();\n+                let mut next = *next;\n                 while let Some(&&mut peek) = iter.peek() {\n                     if let Some(merged) = next.merge(peek) {\n                         iter.next().unwrap();\n@@ -166,7 +166,7 @@ impl FileLines {\n     }\n }\n \n-/// FileLines files iterator.\n+/// `FileLines` files iterator.\n pub struct Files<'a>(\n     Option<::std::collections::hash_map::Keys<'a, String, Vec<Range>>>,\n );\n@@ -197,9 +197,9 @@ impl str::FromStr for FileLines {\n     fn from_str(s: &str) -> Result<FileLines, String> {\n         let v: Vec<JsonSpan> = json::from_str(s).map_err(|e| e.to_string())?;\n         let mut m = HashMap::new();\n-        for js in v.into_iter() {\n+        for js in v {\n             let (s, r) = JsonSpan::into_tuple(js)?;\n-            m.entry(s).or_insert(vec![]).push(r);\n+            m.entry(s).or_insert_with(|| vec![]).push(r);\n         }\n         Ok(FileLines::from_ranges(m))\n     }"}, {"sha": "33efce19a40ae1adf6fe952b44812c931459679b", "filename": "src/imports.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -25,8 +25,8 @@ use visitor::FmtVisitor;\n \n fn path_of(a: &ast::ViewPath_) -> &ast::Path {\n     match *a {\n-        ast::ViewPath_::ViewPathSimple(_, ref p) => p,\n-        ast::ViewPath_::ViewPathGlob(ref p) => p,\n+        ast::ViewPath_::ViewPathSimple(_, ref p) |\n+        ast::ViewPath_::ViewPathGlob(ref p) |\n         ast::ViewPath_::ViewPathList(ref p, _) => p,\n     }\n }\n@@ -54,12 +54,10 @@ fn compare_path_list_items(a: &ast::PathListItem, b: &ast::PathListItem) -> Orde\n         } else {\n             Ordering::Less\n         }\n+    } else if b_name_str == \"self\" {\n+        Ordering::Greater\n     } else {\n-        if b_name_str == \"self\" {\n-            Ordering::Greater\n-        } else {\n-            a_name_str.cmp(&b_name_str)\n-        }\n+        a_name_str.cmp(b_name_str)\n     };\n     if name_ordering == Ordering::Equal {\n         match a.node.rename {\n@@ -137,7 +135,7 @@ fn rewrite_view_path_prefix(\n         path.segments.len() > 1\n     {\n         let path = &ast::Path {\n-            span: path.span.clone(),\n+            span: path.span,\n             segments: path.segments[..path.segments.len() - 1].to_owned(),\n         };\n         try_opt!(rewrite_path("}, {"sha": "d5369e33ef8aae7ec3611b78b0a7e6b0945985b7", "filename": "src/items.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -80,7 +80,7 @@ impl Rewrite for ast::Local {\n         let pat_shape = try_opt!(shape.offset_left(4));\n         // 1 = ;\n         let pat_shape = try_opt!(pat_shape.sub_width(1));\n-        let pat_str = try_opt!(self.pat.rewrite(&context, pat_shape));\n+        let pat_str = try_opt!(self.pat.rewrite(context, pat_shape));\n         result.push_str(&pat_str);\n \n         // String that is placed within the assignment pattern and expression.\n@@ -111,7 +111,7 @@ impl Rewrite for ast::Local {\n             // 1 = trailing semicolon;\n             let nested_shape = try_opt!(shape.sub_width(1));\n \n-            result = try_opt!(rewrite_assign_rhs(&context, result, ex, nested_shape));\n+            result = try_opt!(rewrite_assign_rhs(context, result, ex, nested_shape));\n         }\n \n         result.push(';');\n@@ -195,7 +195,7 @@ impl<'a> FmtVisitor<'a> {\n \n     fn format_body_element(&mut self, element: &BodyElement) {\n         match *element {\n-            BodyElement::ForeignItem(ref item) => self.format_foreign_item(item),\n+            BodyElement::ForeignItem(item) => self.format_foreign_item(item),\n         }\n     }\n \n@@ -321,7 +321,7 @@ impl<'a> FmtVisitor<'a> {\n \n         if self.config.fn_single_line() && is_simple_block_stmt(block, codemap) {\n             let rewrite = {\n-                if let Some(ref stmt) = block.stmts.first() {\n+                if let Some(stmt) = block.stmts.first() {\n                     match stmt_expr(stmt) {\n                         Some(e) => {\n                             let suffix = if semicolon_for_expr(&self.get_context(), e) {\n@@ -568,10 +568,10 @@ pub fn format_impl(\n \n         if try_opt!(is_impl_single_line(\n             context,\n-            &items,\n+            items,\n             &result,\n             &where_clause_str,\n-            &item,\n+            item,\n         )) {\n             result.push_str(&where_clause_str);\n             if where_clause_str.contains('\\n') || last_line_contains_single_line_comment(&result) {\n@@ -674,7 +674,7 @@ fn format_impl_ref_and_type(\n         let mut result = String::with_capacity(128);\n \n         result.push_str(&format_visibility(&item.vis));\n-        result.push_str(&format_defaultness(defaultness));\n+        result.push_str(format_defaultness(defaultness));\n         result.push_str(format_unsafety(unsafety));\n         result.push_str(\"impl\");\n \n@@ -707,7 +707,7 @@ fn format_impl_ref_and_type(\n             let result_len = result.len();\n             if let Some(trait_ref_str) = rewrite_trait_ref(\n                 context,\n-                &trait_ref,\n+                trait_ref,\n                 offset,\n                 &generics_str,\n                 true,\n@@ -725,7 +725,7 @@ fn format_impl_ref_and_type(\n                 ));\n                 result.push_str(&try_opt!(rewrite_trait_ref(\n                     context,\n-                    &trait_ref,\n+                    trait_ref,\n                     offset,\n                     &generics_str,\n                     false,\n@@ -1079,7 +1079,7 @@ pub fn format_struct_struct(\n     {\n         result.push('\\n');\n         result.push_str(&offset.to_string(context.config));\n-        result.push_str(&generics_str.trim_left());\n+        result.push_str(generics_str.trim_left());\n     } else {\n         result.push_str(&generics_str);\n     }\n@@ -1090,7 +1090,7 @@ pub fn format_struct_struct(\n             // `struct S {}`\n         } else if snippet.trim_right_matches(&[' ', '\\t'][..]).ends_with('\\n') {\n             // fix indent\n-            result.push_str(&snippet.trim_right());\n+            result.push_str(snippet.trim_right());\n             result.push('\\n');\n             result.push_str(&offset.to_string(context.config));\n         } else {\n@@ -1153,7 +1153,7 @@ fn format_tuple_struct(\n     } else {\n         // This is a dirty hack to work around a missing `)` from the span of the last field.\n         let last_arg_span = fields[fields.len() - 1].span;\n-        if context.snippet(last_arg_span).ends_with(\")\") {\n+        if context.snippet(last_arg_span).ends_with(')') {\n             last_arg_span.hi()\n         } else {\n             context\n@@ -1201,7 +1201,7 @@ fn format_tuple_struct(\n         if snippet.is_empty() {\n             // `struct S ()`\n         } else if snippet.trim_right_matches(&[' ', '\\t'][..]).ends_with('\\n') {\n-            result.push_str(&snippet.trim_right());\n+            result.push_str(snippet.trim_right());\n             result.push('\\n');\n             result.push_str(&offset.to_string(context.config));\n         } else {\n@@ -1401,7 +1401,7 @@ pub fn rewrite_struct_field(\n     let ty_rewritten = rewrite_struct_field_type(context, overhead, field, &spacing, shape);\n     if let Some(ref ty) = ty_rewritten {\n         if !ty.contains('\\n') {\n-            return Some(attr_prefix + &ty);\n+            return Some(attr_prefix + ty);\n         }\n     }\n \n@@ -1422,17 +1422,17 @@ pub fn rewrite_struct_field(\n             Some(ref new_ty) if !new_ty.contains('\\n') => format!(\n                 \"{}\\n{}{}\",\n                 prefix,\n-                type_offset.to_string(&context.config),\n+                type_offset.to_string(context.config),\n                 &new_ty\n             ),\n-            _ => prefix + &ty,\n+            _ => prefix + ty,\n         },\n         _ => {\n             let ty = try_opt!(rewrite_type_in_next_line());\n             format!(\n                 \"{}\\n{}{}\",\n                 prefix,\n-                type_offset.to_string(&context.config),\n+                type_offset.to_string(context.config),\n                 &ty\n             )\n         }\n@@ -1515,7 +1515,7 @@ pub fn rewrite_associated_type(\n                 .map(|ty_bound| ty_bound.rewrite(context, shape))\n                 .collect::<Option<Vec<_>>>()\n         );\n-        if bounds.len() > 0 {\n+        if !bounds.is_empty() {\n             format!(\": {}\", join_bounds(context, shape, &bound_str))\n         } else {\n             String::new()\n@@ -1755,7 +1755,7 @@ fn rewrite_fn_base(\n     // return type later anyway.\n     let ret_str = try_opt!(\n         fd.output\n-            .rewrite(&context, Shape::indented(indent, context.config))\n+            .rewrite(context, Shape::indented(indent, context.config))\n     );\n \n     let multi_line_ret_str = ret_str.contains('\\n');\n@@ -1783,26 +1783,24 @@ fn rewrite_fn_base(\n     if one_line_budget == 0 {\n         if snuggle_angle_bracket {\n             result.push('(');\n+        } else if context.config.fn_args_paren_newline() {\n+            result.push('\\n');\n+            result.push_str(&arg_indent.to_string(context.config));\n+            if context.config.fn_args_layout() == IndentStyle::Visual {\n+                arg_indent = arg_indent + 1; // extra space for `(`\n+            }\n+            result.push('(');\n         } else {\n-            if context.config.fn_args_paren_newline() {\n+            result.push_str(\"(\");\n+            if context.config.fn_args_layout() == IndentStyle::Visual {\n                 result.push('\\n');\n                 result.push_str(&arg_indent.to_string(context.config));\n-                if context.config.fn_args_layout() == IndentStyle::Visual {\n-                    arg_indent = arg_indent + 1; // extra space for `(`\n-                }\n-                result.push('(');\n-            } else {\n-                result.push_str(\"(\");\n-                if context.config.fn_args_layout() == IndentStyle::Visual {\n-                    result.push('\\n');\n-                    result.push_str(&arg_indent.to_string(context.config));\n-                }\n             }\n         }\n     } else {\n         result.push('(');\n     }\n-    if context.config.spaces_within_parens() && fd.inputs.len() > 0 && result.ends_with('(') {\n+    if context.config.spaces_within_parens() && !fd.inputs.is_empty() && result.ends_with('(') {\n         result.push(' ')\n     }\n \n@@ -1857,10 +1855,10 @@ fn rewrite_fn_base(\n         let used_width = last_line_used_width(&result, indent.width()) + first_line_width(&ret_str);\n         // Put the closing brace on the next line if it overflows the max width.\n         // 1 = `)`\n-        if fd.inputs.len() == 0 && used_width + 1 > context.config.max_width() {\n+        if fd.inputs.is_empty() && used_width + 1 > context.config.max_width() {\n             result.push('\\n');\n         }\n-        if context.config.spaces_within_parens() && fd.inputs.len() > 0 {\n+        if context.config.spaces_within_parens() && !fd.inputs.is_empty() {\n             result.push(' ')\n         }\n         // If the last line of args contains comment, we cannot put the closing paren\n@@ -1881,7 +1879,7 @@ fn rewrite_fn_base(\n     if let ast::FunctionRetTy::Ty(..) = fd.output {\n         let ret_should_indent = match context.config.fn_args_layout() {\n             // If our args are block layout then we surely must have space.\n-            IndentStyle::Block if put_args_in_block || fd.inputs.len() == 0 => false,\n+            IndentStyle::Block if put_args_in_block || fd.inputs.is_empty() => false,\n             _ if args_last_line_contains_comment => false,\n             _ if result.contains('\\n') || multi_line_ret_str => true,\n             _ => {\n@@ -2024,9 +2022,10 @@ fn rewrite_fn_base(\n     result.push_str(&where_clause_str);\n \n     force_new_line_for_brace |= last_line_contains_single_line_comment(&result);\n-    return Some((result, force_new_line_for_brace));\n+    Some((result, force_new_line_for_brace))\n }\n \n+#[derive(Copy, Clone)]\n struct WhereClauseOption {\n     suppress_comma: bool, // Force no trailing comma\n     snuggle: bool,        // Do not insert newline before `where`\n@@ -2074,7 +2073,7 @@ fn rewrite_args(\n     let mut arg_item_strs = try_opt!(\n         args.iter()\n             .map(|arg| {\n-                arg.rewrite(&context, Shape::legacy(multi_line_budget, arg_indent))\n+                arg.rewrite(context, Shape::legacy(multi_line_budget, arg_indent))\n             })\n             .collect::<Option<Vec<_>>>()\n     );\n@@ -2156,7 +2155,7 @@ fn rewrite_args(\n     }\n \n     let fits_in_one_line = !generics_str_contains_newline &&\n-        (arg_items.len() == 0 || arg_items.len() == 1 && arg_item_strs[0].len() <= one_line_budget);\n+        (arg_items.is_empty() || arg_items.len() == 1 && arg_item_strs[0].len() <= one_line_budget);\n \n     for (item, arg) in arg_items.iter_mut().zip(arg_item_strs) {\n         item.item = Some(arg);\n@@ -2441,7 +2440,7 @@ fn rewrite_trait_bounds(\n     let bound_str = try_opt!(\n         bounds\n             .iter()\n-            .map(|ty_bound| ty_bound.rewrite(&context, shape))\n+            .map(|ty_bound| ty_bound.rewrite(context, shape))\n             .collect::<Option<Vec<_>>>()\n     );\n     Some(format!(\": {}\", join_bounds(context, shape, &bound_str)))"}, {"sha": "3c070d25c004b95c6b2a6f59c765d84b97775d0a", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -504,7 +504,7 @@ impl FormattingError {\n \n     fn msg_suffix(&self) -> String {\n         match self.kind {\n-            ErrorKind::LineOverflow(..) if self.is_comment => format!(\n+            ErrorKind::LineOverflow(..) if self.is_comment => String::from(\n                 \"use `error_on_line_overflow_comments = false` to suppress \\\n                  the warning against line comments\\n\",\n             ),\n@@ -802,9 +802,8 @@ fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &m\n                     last_wspace = Some(b);\n                 }\n             } else if c == '/' {\n-                match prev_char {\n-                    Some('/') => is_comment = true,\n-                    _ => (),\n+                if let Some('/') = prev_char {\n+                    is_comment = true;\n                 }\n                 last_wspace = None;\n             } else {\n@@ -869,7 +868,7 @@ pub fn format_input<T: Write>(\n     config: &Config,\n     mut out: Option<&mut T>,\n ) -> Result<(Summary, FileMap, FormatReport), (io::Error, Summary)> {\n-    let mut summary = Summary::new();\n+    let mut summary = Summary::default();\n     if config.disable_all_formatting() {\n         return Ok((summary, FileMap::new(), FormatReport::new()));\n     }"}, {"sha": "301e9101c8f5288c4f33ff4129e01adec1aa9392", "filename": "src/lists.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -20,7 +20,7 @@ use rewrite::RewriteContext;\n use utils::{first_line_width, last_line_width, mk_sp};\n \n /// Formatting tactic for lists. This will be cast down to a\n-/// DefinitiveListTactic depending on the number and length of the items and\n+/// `DefinitiveListTactic` depending on the number and length of the items and\n /// their comments.\n #[derive(Eq, PartialEq, Debug, Copy, Clone)]\n pub enum ListTactic {\n@@ -172,7 +172,7 @@ impl DefinitiveListTactic {\n }\n \n /// The type of separator for lists.\n-#[derive(Eq, PartialEq, Debug)]\n+#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n pub enum Separator {\n     Comma,\n     VerticalBar,\n@@ -346,9 +346,9 @@ where\n \n             if tactic == DefinitiveListTactic::Vertical {\n                 // We cannot keep pre-comments on the same line if the comment if normalized.\n-                let keep_comment = if formatting.config.normalize_comments() {\n-                    false\n-                } else if item.pre_comment_style == ListItemCommentStyle::DifferentLine {\n+                let keep_comment = if formatting.config.normalize_comments() ||\n+                    item.pre_comment_style == ListItemCommentStyle::DifferentLine\n+                {\n                     false\n                 } else {\n                     // We will try to keep the comment on the same line with the item here.\n@@ -405,7 +405,7 @@ where\n                         formatting.config.max_width(),\n                     ));\n                 }\n-                let overhead = if let &mut Some(max_width) = item_max_width {\n+                let overhead = if let Some(max_width) = *item_max_width {\n                     max_width + 2\n                 } else {\n                     // 1 = space between item and comment.\n@@ -548,8 +548,7 @@ where\n                     .chars()\n                     .rev()\n                     .take(comment_end + 1)\n-                    .find(|c| *c == '\\n')\n-                    .is_some()\n+                    .any(|c| c == '\\n')\n                 {\n                     (\n                         Some(trimmed_pre_snippet.to_owned()),\n@@ -612,7 +611,7 @@ where\n                 }\n                 None => post_snippet\n                     .find_uncommented(self.terminator)\n-                    .unwrap_or(post_snippet.len()),\n+                    .unwrap_or_else(|| post_snippet.len()),\n             };\n \n             if !post_snippet.is_empty() && comment_end > 0 {\n@@ -621,12 +620,14 @@ where\n \n                 // Everything from the separator to the next item.\n                 let test_snippet = &post_snippet[comment_end - 1..];\n-                let first_newline = test_snippet.find('\\n').unwrap_or(test_snippet.len());\n+                let first_newline = test_snippet\n+                    .find('\\n')\n+                    .unwrap_or_else(|| test_snippet.len());\n                 // From the end of the first line of comments.\n                 let test_snippet = &test_snippet[first_newline..];\n                 let first = test_snippet\n                     .find(|c: char| !c.is_whitespace())\n-                    .unwrap_or(test_snippet.len());\n+                    .unwrap_or_else(|| test_snippet.len());\n                 // From the end of the first line of comments to the next non-whitespace char.\n                 let test_snippet = &test_snippet[..first];\n \n@@ -747,7 +748,7 @@ pub fn struct_lit_shape(\n         IndentStyle::Block => {\n             let shape = shape.block_indent(context.config.tab_spaces());\n             Shape {\n-                width: try_opt!(context.config.max_width().checked_sub(shape.indent.width())),\n+                width: context.budget(shape.indent.width()),\n                 ..shape\n             }\n         }"}, {"sha": "4378febc2c37bbaffd84377f8e08ce3472a10e72", "filename": "src/macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -224,7 +224,7 @@ pub fn rewrite_macro(\n                 // If we are rewriting `vec!` macro or other special macros,\n                 // then we can rewrite this as an usual array literal.\n                 // Otherwise, we must preserve the original existence of trailing comma.\n-                if FORCED_BRACKET_MACROS.contains(&&macro_name.as_str()) {\n+                if FORCED_BRACKET_MACROS.contains(&macro_name.as_str()) {\n                     context.inside_macro = false;\n                     trailing_comma = false;\n                 }\n@@ -355,8 +355,7 @@ fn indent_macro_snippet(\n \n fn get_prefix_space_width(context: &RewriteContext, s: &str) -> usize {\n     let mut width = 0;\n-    let mut iter = s.chars();\n-    while let Some(c) = iter.next() {\n+    for c in s.chars() {\n         match c {\n             ' ' => width += 1,\n             '\\t' => width += context.config.tab_spaces(),"}, {"sha": "301e1583029c8d3ef4b28e86bcba7e138c3b2688", "filename": "src/missed_spans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -90,7 +90,7 @@ impl<'a> FmtVisitor<'a> {\n         let big_snippet = &local_begin.fm.src.as_ref().unwrap()[start_index..end_index];\n \n         let big_diff = (span.lo() - big_span_lo).to_usize();\n-        let snippet = self.snippet(span.clone());\n+        let snippet = self.snippet(span);\n \n         debug!(\"write_snippet `{}`\", snippet);\n \n@@ -180,7 +180,7 @@ impl<'a> FmtVisitor<'a> {\n                     last_wspace = None;\n                     line_start = offset + subslice.len();\n \n-                    if let Some('/') = subslice.chars().skip(1).next() {\n+                    if let Some('/') = subslice.chars().nth(1) {\n                         // check that there are no contained block comments\n                         if !subslice\n                             .split('\\n')"}, {"sha": "c3475dfba73a73473d914397c2ad7c5da03e9bd2", "filename": "src/patterns.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -139,7 +139,7 @@ fn rewrite_struct_pat(\n         path_shape,\n     ));\n \n-    if fields.len() == 0 && !elipses {\n+    if fields.is_empty() && !elipses {\n         return Some(format!(\"{} {{}}\", path_str));\n     }\n \n@@ -223,7 +223,7 @@ pub enum TuplePatField<'a> {\n impl<'a> Rewrite for TuplePatField<'a> {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         match *self {\n-            TuplePatField::Pat(ref p) => p.rewrite(context, shape),\n+            TuplePatField::Pat(p) => p.rewrite(context, shape),\n             TuplePatField::Dotdot(_) => Some(\"..\".to_string()),\n         }\n     }\n@@ -232,15 +232,15 @@ impl<'a> Rewrite for TuplePatField<'a> {\n impl<'a> Spanned for TuplePatField<'a> {\n     fn span(&self) -> Span {\n         match *self {\n-            TuplePatField::Pat(ref p) => p.span(),\n+            TuplePatField::Pat(p) => p.span(),\n             TuplePatField::Dotdot(span) => span,\n         }\n     }\n }\n \n pub fn can_be_overflowed_pat(context: &RewriteContext, pat: &TuplePatField, len: usize) -> bool {\n-    match pat {\n-        &TuplePatField::Pat(ref pat) => match pat.node {\n+    match *pat {\n+        TuplePatField::Pat(pat) => match pat.node {\n             ast::PatKind::Path(..) | ast::PatKind::Tuple(..) | ast::PatKind::Struct(..) => {\n                 context.use_block_indent() && len == 1\n             }\n@@ -250,7 +250,7 @@ pub fn can_be_overflowed_pat(context: &RewriteContext, pat: &TuplePatField, len:\n             ast::PatKind::Lit(ref expr) => can_be_overflowed_expr(context, expr, len),\n             _ => false,\n         },\n-        &TuplePatField::Dotdot(..) => false,\n+        TuplePatField::Dotdot(..) => false,\n     }\n }\n \n@@ -288,7 +288,7 @@ fn rewrite_tuple_pat(\n     }\n \n     if pat_vec.is_empty() {\n-        return Some(format!(\"{}()\", path_str.unwrap_or(String::new())));\n+        return Some(format!(\"{}()\", path_str.unwrap_or_default()));\n     }\n \n     let wildcard_suffix_len = count_wildcard_suffix_len(context, &pat_vec, span, shape);\n@@ -313,20 +313,21 @@ fn rewrite_tuple_pat(\n     if let Some(&TuplePatField::Dotdot(..)) = pat_vec.last() {\n         context.inside_macro = true;\n     }\n-    let path_str = path_str.unwrap_or(String::new());\n+    let path_str = path_str.unwrap_or_default();\n     let mut pat_ref_vec = Vec::with_capacity(pat_vec.len());\n     for pat in pat_vec {\n         pat_ref_vec.push(pat);\n     }\n-    return rewrite_call_inner(\n+\n+    rewrite_call_inner(\n         &context,\n         &path_str,\n         &pat_ref_vec[..],\n         span,\n         shape,\n         shape.width,\n         add_comma,\n-    ).ok();\n+    ).ok()\n }\n \n fn count_wildcard_suffix_len("}, {"sha": "7ca885a645c2d01edf60a3618a70ab18ff04c928", "filename": "src/summary.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fsummary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fsummary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsummary.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -1,5 +1,5 @@\n #[must_use]\n-#[derive(Debug, Clone)]\n+#[derive(Debug, Default, Clone)]\n pub struct Summary {\n     // Encountered e.g. an IO error.\n     has_operational_errors: bool,\n@@ -15,15 +15,6 @@ pub struct Summary {\n }\n \n impl Summary {\n-    pub fn new() -> Summary {\n-        Summary {\n-            has_operational_errors: false,\n-            has_parsing_errors: false,\n-            has_formatting_errors: false,\n-            has_diff: false,\n-        }\n-    }\n-\n     pub fn has_operational_errors(&self) -> bool {\n         self.has_operational_errors\n     }"}, {"sha": "027f9a9baffe25b1ab1e1828993faa7d7619cc34", "filename": "src/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -447,7 +447,7 @@ impl Rewrite for ast::WherePredicate {\n                     );\n                     let bounds_str = join_bounds(context, ty_shape, &bounds);\n \n-                    if context.config.spaces_within_angle_brackets() && lifetime_str.len() > 0 {\n+                    if context.config.spaces_within_angle_brackets() && !lifetime_str.is_empty() {\n                         format!(\n                             \"for< {} > {}{}{}\",\n                             lifetime_str,\n@@ -635,7 +635,7 @@ impl Rewrite for ast::PolyTraitRef {\n             ));\n \n             Some(\n-                if context.config.spaces_within_angle_brackets() && lifetime_str.len() > 0 {\n+                if context.config.spaces_within_angle_brackets() && !lifetime_str.is_empty() {\n                     format!(\"for< {} > {}\", lifetime_str, path_str)\n                 } else {\n                     format!(\"for<{}> {}\", lifetime_str, path_str)\n@@ -812,7 +812,7 @@ fn rewrite_bare_fn(\n     Some(result)\n }\n \n-pub fn join_bounds(context: &RewriteContext, shape: Shape, type_strs: &Vec<String>) -> String {\n+pub fn join_bounds(context: &RewriteContext, shape: Shape, type_strs: &[String]) -> String {\n     // Try to join types in a single line\n     let joiner = match context.config.type_punctuation_density() {\n         TypeDensity::Compressed => \"+\","}, {"sha": "438bb027637e107f848ac2fd36b2877eb211f20c", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -123,7 +123,7 @@ pub fn last_line_contains_single_line_comment(s: &str) -> bool {\n \n #[inline]\n pub fn is_attributes_extendable(attrs_str: &str) -> bool {\n-    !attrs_str.contains('\\n') && !last_line_contains_single_line_comment(&attrs_str)\n+    !attrs_str.contains('\\n') && !last_line_contains_single_line_comment(attrs_str)\n }\n \n // The width of the first line in s."}, {"sha": "f0cb887c59dcc637def6d4703525629f79e0b436", "filename": "src/vertical.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -284,13 +284,7 @@ fn group_aligned_items<T: AlignedItem>(\n             .skip(1)\n             .collect::<Vec<_>>()\n             .join(\"\\n\");\n-        let spacings = if snippet\n-            .lines()\n-            .rev()\n-            .skip(1)\n-            .find(|l| l.trim().is_empty())\n-            .is_some()\n-        {\n+        let spacings = if snippet.lines().rev().skip(1).any(|l| l.trim().is_empty()) {\n             \"\\n\"\n         } else {\n             \"\""}, {"sha": "56c1783476aa87ff0f237321abfbfd1b1bf3a798", "filename": "src/visitor.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -260,7 +260,7 @@ impl<'a> FmtVisitor<'a> {\n                     abi,\n                     vis,\n                     mk_sp(s.lo(), b.span.lo()),\n-                    &b,\n+                    b,\n                 )\n             }\n             visit::FnKind::Method(ident, sig, vis, b) => {\n@@ -276,7 +276,7 @@ impl<'a> FmtVisitor<'a> {\n                     sig.abi,\n                     vis.unwrap_or(&ast::Visibility::Inherited),\n                     mk_sp(s.lo(), b.span.lo()),\n-                    &b,\n+                    b,\n                 )\n             }\n             visit::FnKind::Closure(_) => unreachable!(),\n@@ -503,8 +503,8 @@ impl<'a> FmtVisitor<'a> {\n             }\n             ast::ItemKind::MacroDef(..) => {\n                 // FIXME(#1539): macros 2.0\n-                let snippet = Some(self.snippet(item.span));\n-                self.push_rewrite(item.span, snippet);\n+                let mac_snippet = Some(self.snippet(item.span));\n+                self.push_rewrite(item.span, mac_snippet);\n             }\n         }\n     }\n@@ -719,15 +719,15 @@ impl<'a> FmtVisitor<'a> {\n             // next item for output.\n             if self.config.reorder_imports() && is_use_item(&*items_left[0]) {\n                 let used_items_len = self.reorder_items(\n-                    &items_left,\n+                    items_left,\n                     &is_use_item,\n                     self.config.reorder_imports_in_group(),\n                 );\n                 let (_, rest) = items_left.split_at(used_items_len);\n                 items_left = rest;\n             } else if self.config.reorder_extern_crates() && is_extern_crate(&*items_left[0]) {\n                 let used_items_len = self.reorder_items(\n-                    &items_left,\n+                    items_left,\n                     &is_extern_crate,\n                     self.config.reorder_extern_crates_in_group(),\n                 );\n@@ -863,10 +863,7 @@ impl Rewrite for ast::MetaItem {\n                             .unwrap_or(0),\n                         ..shape\n                     };\n-                    format!(\n-                        \"{}\",\n-                        try_opt!(rewrite_comment(&value, false, doc_shape, context.config))\n-                    )\n+                    try_opt!(rewrite_comment(&value, false, doc_shape, context.config))\n                 } else {\n                     format!(\"{} = {}\", name, value)\n                 }\n@@ -923,7 +920,7 @@ impl<'a> Rewrite for [ast::Attribute] {\n                 {\n                     // Look at before and after comment and see if there are any empty lines.\n                     let comment_begin = comment.chars().position(|c| c == '/');\n-                    let len = comment_begin.unwrap_or(comment.len());\n+                    let len = comment_begin.unwrap_or_else(|| comment.len());\n                     let mlb = comment.chars().take(len).filter(|c| *c == '\\n').count() > 1;\n                     let mla = if comment_begin.is_none() {\n                         mlb"}, {"sha": "ce575f9f49231619e32472bab71d970711a34f1f", "filename": "tests/system.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d08405eed6dede2dbaf0b69fccc8a2225206718e/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08405eed6dede2dbaf0b69fccc8a2225206718e/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=d08405eed6dede2dbaf0b69fccc8a2225206718e", "patch": "@@ -45,7 +45,7 @@ fn system_tests() {\n \n     // Display results.\n     println!(\"Ran {} system tests.\", count);\n-    assert!(fails == 0, \"{} system tests failed\", fails);\n+    assert_eq!(fails, 0, \"{} system tests failed\", fails);\n }\n \n // Do the same for tests/coverage-source directory\n@@ -57,7 +57,7 @@ fn coverage_tests() {\n     let (_reports, count, fails) = check_files(files);\n \n     println!(\"Ran {} tests in coverage mode.\", count);\n-    assert!(fails == 0, \"{} tests failed\", fails);\n+    assert_eq!(fails, 0, \"{} tests failed\", fails);\n }\n \n #[test]\n@@ -71,7 +71,7 @@ fn checkstyle_test() {\n // Helper function for comparing the results of rustfmt\n // to a known output file generated by one of the write modes.\n fn assert_output(source: &str, expected_filename: &str) {\n-    let config = read_config(&source);\n+    let config = read_config(source);\n     let (file_map, _report) = format_file(source, &config);\n \n     // Populate output by writing to a vec.\n@@ -86,7 +86,7 @@ fn assert_output(source: &str, expected_filename: &str) {\n         .expect(\"Failed reading target\");\n \n     let compare = make_diff(&expected_text, &output, DIFF_CONTEXT_SIZE);\n-    if compare.len() > 0 {\n+    if !compare.is_empty() {\n         let mut failures = HashMap::new();\n         failures.insert(source.to_string(), compare);\n         print_mismatches(failures);\n@@ -106,7 +106,7 @@ fn idempotence_tests() {\n \n     // Display results.\n     println!(\"Ran {} idempotent tests.\", count);\n-    assert!(fails == 0, \"{} idempotent tests failed\", fails);\n+    assert_eq!(fails, 0, \"{} idempotent tests failed\", fails);\n }\n \n // Run rustfmt on itself. This operation must be idempotent. We also check that\n@@ -126,15 +126,16 @@ fn self_tests() {\n \n     // Display results.\n     println!(\"Ran {} self tests.\", count);\n-    assert!(fails == 0, \"{} self tests failed\", fails);\n+    assert_eq!(fails, 0, \"{} self tests failed\", fails);\n \n     for format_report in reports {\n         println!(\"{}\", format_report);\n         warnings += format_report.warning_count();\n     }\n \n-    assert!(\n-        warnings == 0,\n+    assert_eq!(\n+        warnings,\n+        0,\n         \"Rustfmt's code generated {} warnings\",\n         warnings\n     );\n@@ -149,7 +150,7 @@ fn stdin_formatting_smoke_test() {\n     assert!(error_summary.has_no_errors());\n     for &(ref file_name, ref text) in &file_map {\n         if file_name == \"stdin\" {\n-            assert!(text.to_string() == \"fn main() {}\\n\");\n+            assert_eq!(text.to_string(), \"fn main() {}\\n\");\n             return;\n         }\n     }\n@@ -210,7 +211,7 @@ fn print_mismatches(result: HashMap<String, Vec<Mismatch>>) {\n }\n \n fn read_config(filename: &str) -> Config {\n-    let sig_comments = read_significant_comments(&filename);\n+    let sig_comments = read_significant_comments(filename);\n     // Look for a config file... If there is a 'config' property in the significant comments, use\n     // that. Otherwise, if there are no significant comments at all, look for a config file with\n     // the same name as the test file.\n@@ -241,8 +242,8 @@ fn format_file<P: Into<PathBuf>>(filepath: P, config: &Config) -> (FileMap, Form\n     let filepath = filepath.into();\n     let input = Input::File(filepath);\n     let (_error_summary, file_map, report) =\n-        format_input::<io::Stdout>(input, &config, None).unwrap();\n-    return (file_map, report);\n+        format_input::<io::Stdout>(input, config, None).unwrap();\n+    (file_map, report)\n }\n \n pub fn idempotent_check(filename: String) -> Result<FormatReport, HashMap<String, Vec<Mismatch>>> {\n@@ -273,7 +274,7 @@ fn get_config(config_file: Option<&str>) -> Config {\n         None => return Default::default(),\n         Some(file_name) => {\n             let mut full_path = \"tests/config/\".to_owned();\n-            full_path.push_str(&file_name);\n+            full_path.push_str(file_name);\n             if !Path::new(&full_path).exists() {\n                 return Default::default();\n             };\n@@ -296,7 +297,7 @@ fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n     let file = fs::File::open(file_name).expect(&format!(\"Couldn't read file {}\", file_name));\n     let reader = BufReader::new(file);\n     let pattern = r\"^\\s*//\\s*rustfmt-([^:]+):\\s*(\\S+)\";\n-    let regex = regex::Regex::new(&pattern).expect(\"Failed creating pattern 1\");\n+    let regex = regex::Regex::new(pattern).expect(\"Failed creating pattern 1\");\n \n     // Matches lines containing significant comments or whitespace.\n     let line_regex = regex::Regex::new(r\"(^\\s*$)|(^\\s*//\\s*rustfmt-[^:]+:\\s*\\S+)\")\n@@ -305,7 +306,7 @@ fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n     reader\n         .lines()\n         .map(|line| line.expect(\"Failed getting line\"))\n-        .take_while(|line| line_regex.is_match(&line))\n+        .take_while(|line| line_regex.is_match(line))\n         .filter_map(|line| {\n             regex.captures_iter(&line).next().map(|capture| {\n                 ("}]}