{"sha": "2ea63794a47f57144e9efcf9531cd235406cdb8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYTYzNzk0YTQ3ZjU3MTQ0ZTllZmNmOTUzMWNkMjM1NDA2Y2RiOGQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-08-22T00:14:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-22T00:14:56Z"}, "message": "Rollup merge of #75782 - GuillaumeGomez:more-links, r=jyn514\n\nConvert core/src/str/pattern.rs to Intra-doc links\n\nPart of #75080.", "tree": {"sha": "6f3713c8aa3f95ce6e51d9bc98dc9fa4f961626d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f3713c8aa3f95ce6e51d9bc98dc9fa4f961626d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ea63794a47f57144e9efcf9531cd235406cdb8d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfQGOACRBK7hj4Ov3rIwAAdHIIAINf1VMMjfVAzsYMlJvHNTXM\nr4gi+bFpC1nYOyQTKwGxnw+G2drARQCNgYtNhwQfGF4v1IB44w5pyGl2jBctI+1b\n4uXSP3KVI19RDVXk5x8MfG2n0a4O8ffGO4TNYmo9FmsP8oAYKDovWtaib3xsf5R/\ngEVcziFoWQyFVnuBjRqXzfRWqBPg6aoItaX4jJOmvQkklZQt6p8Y1+/2u63pXxLM\nsOkqIbtVQEvrsJdzWzFzQspdkLv+ZmWxOWTgYQX4jOZN7eFzDQRqORbKMXdW7IWV\nczAsmPxypmIeSHwuZkRK/JcY+E77Fr1ENrLCelLzPFVlEZlThVI1/JNsBHVe4/U=\n=DkiJ\n-----END PGP SIGNATURE-----\n", "payload": "tree 6f3713c8aa3f95ce6e51d9bc98dc9fa4f961626d\nparent cb9ef0988e8f49d45c184dc68c57a93bfcca399f\nparent 385a1b247663a487e681bf522dac99c656209782\nauthor Dylan DPC <dylan.dpc@gmail.com> 1598055296 +0200\ncommitter GitHub <noreply@github.com> 1598055296 +0200\n\nRollup merge of #75782 - GuillaumeGomez:more-links, r=jyn514\n\nConvert core/src/str/pattern.rs to Intra-doc links\n\nPart of #75080.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ea63794a47f57144e9efcf9531cd235406cdb8d", "html_url": "https://github.com/rust-lang/rust/commit/2ea63794a47f57144e9efcf9531cd235406cdb8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ea63794a47f57144e9efcf9531cd235406cdb8d/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb9ef0988e8f49d45c184dc68c57a93bfcca399f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb9ef0988e8f49d45c184dc68c57a93bfcca399f", "html_url": "https://github.com/rust-lang/rust/commit/cb9ef0988e8f49d45c184dc68c57a93bfcca399f"}, {"sha": "385a1b247663a487e681bf522dac99c656209782", "url": "https://api.github.com/repos/rust-lang/rust/commits/385a1b247663a487e681bf522dac99c656209782", "html_url": "https://github.com/rust-lang/rust/commit/385a1b247663a487e681bf522dac99c656209782"}], "stats": {"total": 114, "additions": 57, "deletions": 57}, "files": [{"sha": "1cc2de5b8756a8bdc8cc06e2fd26374aa1c45f90", "filename": "library/core/src/str/pattern.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/2ea63794a47f57144e9efcf9531cd235406cdb8d/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ea63794a47f57144e9efcf9531cd235406cdb8d/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs?ref=2ea63794a47f57144e9efcf9531cd235406cdb8d", "patch": "@@ -12,7 +12,7 @@\n //! # Examples\n //!\n //! [`Pattern`] is [implemented][pattern-impls] in the stable API for\n-//! [`&str`], [`char`], slices of [`char`], and functions and closures\n+//! [`&str`][`str`], [`char`], slices of [`char`], and functions and closures\n //! implementing `FnMut(char) -> bool`.\n //!\n //! ```\n@@ -28,13 +28,6 @@\n //! assert_eq!(s.find(|c: char| c.is_ascii_punctuation()), Some(35));\n //! ```\n //!\n-//! [`&str`]: ../../../std/primitive.str.html\n-//! [`char`]: ../../../std/primitive.char.html\n-//! [`str`]: ../../../std/primitive.str.html\n-//! [`DoubleEndedSearcher`]: trait.DoubleEndedSearcher.html\n-//! [`Pattern`]: trait.Pattern.html\n-//! [`ReverseSearcher`]: trait.ReverseSearcher.html\n-//! [`Searcher`]: trait.Searcher.html\n //! [pattern-impls]: trait.Pattern.html#implementors\n \n #![unstable(\n@@ -52,13 +45,13 @@ use crate::slice::memchr;\n /// A string pattern.\n ///\n /// A `Pattern<'a>` expresses that the implementing type\n-/// can be used as a string pattern for searching in a `&'a str`.\n+/// can be used as a string pattern for searching in a [`&'a str`][str].\n ///\n /// For example, both `'a'` and `\"aa\"` are patterns that\n /// would match at index `1` in the string `\"baaaab\"`.\n ///\n /// The trait itself acts as a builder for an associated\n-/// `Searcher` type, which does the actual work of finding\n+/// [`Searcher`] type, which does the actual work of finding\n /// occurrences of the pattern in a string.\n ///\n /// Depending on the type of the pattern, the behaviour of methods like\n@@ -75,6 +68,7 @@ use crate::slice::memchr;\n /// | `&String`                | is substring                              |\n ///\n /// # Examples\n+///\n /// ```\n /// // &str\n /// assert_eq!(\"abaaa\".find(\"ba\"), Some(1));\n@@ -94,9 +88,6 @@ use crate::slice::memchr;\n /// assert_eq!(\"abcdef_z\".find(|ch| ch > 'd' && ch < 'y'), Some(4));\n /// assert_eq!(\"abcddd_z\".find(|ch| ch > 'd' && ch < 'y'), None);\n /// ```\n-///\n-/// [`str::find`]: ../../../std/primitive.str.html#method.find\n-/// [`str::contains`]: ../../../std/primitive.str.html#method.contains\n pub trait Pattern<'a>: Sized {\n     /// Associated searcher for this pattern\n     type Searcher: Searcher<'a>;\n@@ -165,7 +156,7 @@ pub trait Pattern<'a>: Sized {\n \n // Searcher\n \n-/// Result of calling `Searcher::next()` or `ReverseSearcher::next_back()`.\n+/// Result of calling [`Searcher::next()`] or [`ReverseSearcher::next_back()`].\n #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n pub enum SearchStep {\n     /// Expresses that a match of the pattern has been found at\n@@ -188,44 +179,47 @@ pub enum SearchStep {\n /// matches of a pattern starting from the front (left) of a string.\n ///\n /// It will be implemented by associated `Searcher`\n-/// types of the `Pattern` trait.\n+/// types of the [`Pattern`] trait.\n ///\n /// The trait is marked unsafe because the indices returned by the\n-/// `next()` methods are required to lie on valid utf8 boundaries in\n-/// the haystack. This enables consumers of this trait to\n+/// [`next()`][Searcher::next] methods are required to lie on valid utf8\n+/// boundaries in the haystack. This enables consumers of this trait to\n /// slice the haystack without additional runtime checks.\n pub unsafe trait Searcher<'a> {\n     /// Getter for the underlying string to be searched in\n     ///\n-    /// Will always return the same `&str`\n+    /// Will always return the same [`&str`][str].\n     fn haystack(&self) -> &'a str;\n \n     /// Performs the next search step starting from the front.\n     ///\n-    /// - Returns `Match(a, b)` if `haystack[a..b]` matches the pattern.\n-    /// - Returns `Reject(a, b)` if `haystack[a..b]` can not match the\n-    ///   pattern, even partially.\n-    /// - Returns `Done` if every byte of the haystack has been visited\n+    /// - Returns [`Match(a, b)`][SearchStep::Match] if `haystack[a..b]` matches\n+    ///   the pattern.\n+    /// - Returns [`Reject(a, b)`][SearchStep::Reject] if `haystack[a..b]` can\n+    ///   not match the pattern, even partially.\n+    /// - Returns [`Done`][SearchStep::Done] if every byte of the haystack has\n+    ///   been visited.\n     ///\n-    /// The stream of `Match` and `Reject` values up to a `Done`\n+    /// The stream of [`Match`][SearchStep::Match] and\n+    /// [`Reject`][SearchStep::Reject] values up to a [`Done`][SearchStep::Done]\n     /// will contain index ranges that are adjacent, non-overlapping,\n     /// covering the whole haystack, and laying on utf8 boundaries.\n     ///\n-    /// A `Match` result needs to contain the whole matched pattern,\n-    /// however `Reject` results may be split up into arbitrary\n-    /// many adjacent fragments. Both ranges may have zero length.\n+    /// A [`Match`][SearchStep::Match] result needs to contain the whole matched\n+    /// pattern, however [`Reject`][SearchStep::Reject] results may be split up\n+    /// into arbitrary many adjacent fragments. Both ranges may have zero length.\n     ///\n     /// As an example, the pattern `\"aaa\"` and the haystack `\"cbaaaaab\"`\n     /// might produce the stream\n     /// `[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]`\n     fn next(&mut self) -> SearchStep;\n \n-    /// Finds the next `Match` result. See `next()`\n+    /// Finds the next [`Match`][SearchStep::Match] result. See [`next()`][Searcher::next].\n     ///\n-    /// Unlike next(), there is no guarantee that the returned ranges\n-    /// of this and next_reject will overlap. This will return (start_match, end_match),\n-    /// where start_match is the index of where the match begins, and end_match is\n-    /// the index after the end of the match.\n+    /// Unlike [`next()`][Searcher::next], there is no guarantee that the returned ranges\n+    /// of this and [`next_reject`][Searcher::next_reject] will overlap. This will return\n+    /// `(start_match, end_match)`, where start_match is the index of where\n+    /// the match begins, and end_match is the index after the end of the match.\n     #[inline]\n     fn next_match(&mut self) -> Option<(usize, usize)> {\n         loop {\n@@ -237,10 +231,11 @@ pub unsafe trait Searcher<'a> {\n         }\n     }\n \n-    /// Finds the next `Reject` result. See `next()` and `next_match()`\n+    /// Finds the next [`Reject`][SearchStep::Reject] result. See [`next()`][Searcher::next]\n+    /// and [`next_match()`][Searcher::next_match].\n     ///\n-    /// Unlike next(), there is no guarantee that the returned ranges\n-    /// of this and next_match will overlap.\n+    /// Unlike [`next()`][Searcher::next], there is no guarantee that the returned ranges\n+    /// of this and [`next_match`][Searcher::next_match] will overlap.\n     #[inline]\n     fn next_reject(&mut self) -> Option<(usize, usize)> {\n         loop {\n@@ -258,37 +253,41 @@ pub unsafe trait Searcher<'a> {\n /// This trait provides methods for searching for non-overlapping\n /// matches of a pattern starting from the back (right) of a string.\n ///\n-/// It will be implemented by associated `Searcher`\n-/// types of the `Pattern` trait if the pattern supports searching\n+/// It will be implemented by associated [`Searcher`]\n+/// types of the [`Pattern`] trait if the pattern supports searching\n /// for it from the back.\n ///\n /// The index ranges returned by this trait are not required\n /// to exactly match those of the forward search in reverse.\n ///\n /// For the reason why this trait is marked unsafe, see them\n-/// parent trait `Searcher`.\n+/// parent trait [`Searcher`].\n pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n     /// Performs the next search step starting from the back.\n     ///\n-    /// - Returns `Match(a, b)` if `haystack[a..b]` matches the pattern.\n-    /// - Returns `Reject(a, b)` if `haystack[a..b]` can not match the\n-    ///   pattern, even partially.\n-    /// - Returns `Done` if every byte of the haystack has been visited\n+    /// - Returns [`Match(a, b)`][SearchStep::Match] if `haystack[a..b]`\n+    ///   matches the pattern.\n+    /// - Returns [`Reject(a, b)`][SearchStep::Reject] if `haystack[a..b]`\n+    ///   can not match the pattern, even partially.\n+    /// - Returns [`Done`][SearchStep::Done] if every byte of the haystack\n+    ///   has been visited\n     ///\n-    /// The stream of `Match` and `Reject` values up to a `Done`\n+    /// The stream of [`Match`][SearchStep::Match] and\n+    /// [`Reject`][SearchStep::Reject] values up to a [`Done`][SearchStep::Done]\n     /// will contain index ranges that are adjacent, non-overlapping,\n     /// covering the whole haystack, and laying on utf8 boundaries.\n     ///\n-    /// A `Match` result needs to contain the whole matched pattern,\n-    /// however `Reject` results may be split up into arbitrary\n-    /// many adjacent fragments. Both ranges may have zero length.\n+    /// A [`Match`][SearchStep::Match] result needs to contain the whole matched\n+    /// pattern, however [`Reject`][SearchStep::Reject] results may be split up\n+    /// into arbitrary many adjacent fragments. Both ranges may have zero length.\n     ///\n     /// As an example, the pattern `\"aaa\"` and the haystack `\"cbaaaaab\"`\n     /// might produce the stream\n-    /// `[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]`\n+    /// `[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]`.\n     fn next_back(&mut self) -> SearchStep;\n \n-    /// Finds the next `Match` result. See `next_back()`\n+    /// Finds the next [`Match`][SearchStep::Match] result.\n+    /// See [`next_back()`][ReverseSearcher::next_back].\n     #[inline]\n     fn next_match_back(&mut self) -> Option<(usize, usize)> {\n         loop {\n@@ -300,7 +299,8 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n         }\n     }\n \n-    /// Finds the next `Reject` result. See `next_back()`\n+    /// Finds the next [`Reject`][SearchStep::Reject] result.\n+    /// See [`next_back()`][ReverseSearcher::next_back].\n     #[inline]\n     fn next_reject_back(&mut self) -> Option<(usize, usize)> {\n         loop {\n@@ -313,10 +313,10 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n     }\n }\n \n-/// A marker trait to express that a `ReverseSearcher`\n-/// can be used for a `DoubleEndedIterator` implementation.\n+/// A marker trait to express that a [`ReverseSearcher`]\n+/// can be used for a [`DoubleEndedIterator`] implementation.\n ///\n-/// For this, the impl of `Searcher` and `ReverseSearcher` need\n+/// For this, the impl of [`Searcher`] and [`ReverseSearcher`] need\n /// to follow these conditions:\n ///\n /// - All results of `next()` need to be identical\n@@ -328,7 +328,7 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n /// # Examples\n ///\n /// `char::Searcher` is a `DoubleEndedSearcher` because searching for a\n-/// `char` only requires looking at one at a time, which behaves the same\n+/// [`char`] only requires looking at one at a time, which behaves the same\n /// from both ends.\n ///\n /// `(&str)::Searcher` is not a `DoubleEndedSearcher` because\n@@ -355,13 +355,13 @@ pub struct CharSearcher<'a> {\n     /// `finger_back` is the current byte index of the reverse search.\n     /// Imagine that it exists after the byte at its index, i.e.\n     /// haystack[finger_back - 1] is the last byte of the slice we must inspect during\n-    /// forward searching (and thus the first byte to be inspected when calling next_back())\n+    /// forward searching (and thus the first byte to be inspected when calling next_back()).\n     finger_back: usize,\n     /// The character being searched for\n     needle: char,\n \n     // safety invariant: `utf8_size` must be less than 5\n-    /// The number of bytes `needle` takes up when encoded in utf8\n+    /// The number of bytes `needle` takes up when encoded in utf8.\n     utf8_size: usize,\n     /// A utf8 encoded copy of the `needle`\n     utf8_encoded: [u8; 4],\n@@ -521,7 +521,7 @@ unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n \n impl<'a> DoubleEndedSearcher<'a> for CharSearcher<'a> {}\n \n-/// Searches for chars that are equal to a given `char`.\n+/// Searches for chars that are equal to a given [`char`].\n ///\n /// # Examples\n ///\n@@ -772,7 +772,7 @@ unsafe impl<'a, 'b> ReverseSearcher<'a> for CharSliceSearcher<'a, 'b> {\n \n impl<'a, 'b> DoubleEndedSearcher<'a> for CharSliceSearcher<'a, 'b> {}\n \n-/// Searches for chars that are equal to any of the chars in the slice.\n+/// Searches for chars that are equal to any of the [`char`]s in the slice.\n ///\n /// # Examples\n ///\n@@ -821,7 +821,7 @@ where\n \n impl<'a, F> DoubleEndedSearcher<'a> for CharPredicateSearcher<'a, F> where F: FnMut(char) -> bool {}\n \n-/// Searches for chars that match the given predicate.\n+/// Searches for [`char`]s that match the given predicate.\n ///\n /// # Examples\n ///"}]}