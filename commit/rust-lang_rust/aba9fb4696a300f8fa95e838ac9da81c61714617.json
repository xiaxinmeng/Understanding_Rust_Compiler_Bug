{"sha": "aba9fb4696a300f8fa95e838ac9da81c61714617", "node_id": "C_kwDOAAsO6NoAKGFiYTlmYjQ2OTZhMzAwZjhmYTk1ZTgzOGFjOWRhODFjNjE3MTQ2MTc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-28T20:56:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-28T20:56:44Z"}, "message": "Rollup merge of #110877 - compiler-errors:binop-err, r=cjgillot\n\nProvide better type hints when a type doesn't support a binary operator\n\nFor example, when checking whether `vec![A] == vec![A]` holds, we first evaluate the LHS's ty, then probe for any `PartialEq` implementations for that. If none is found, we report an error by evaluating `Vec<A>: PartialEq<?0>` for fulfillment errors, but the RHS is not yet evaluated and remains an inference variable `?0`!\n\nTo fix this, we evaluate the RHS and equate it to that RHS infer var `?0`, so that we are able to provide more detailed fulfillment errors for why `Vec<A>: PartialEq<Vec<A>>` doesn't hold (namely, the nested obligation `A: PartialEq<A>` doesn't hold).\n\nFixes #95285\nFixes #110867", "tree": {"sha": "1a5024987358c39a5fc6de1d2c49b1328c3a7326", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a5024987358c39a5fc6de1d2c49b1328c3a7326"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aba9fb4696a300f8fa95e838ac9da81c61714617", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkTDMMCRBK7hj4Ov3rIwAAKIYIABHQ2l3fmtqvU1mtdynC9Bay\nAesINPQvTynz+ELZgLIhgub+fi+UfEMOmHGVARdk+6rXHQGzptzbKXzmtV7Jyyw9\nrORbWYNzjCmY7QbufRQoTpqm7qDgEsly7UHOU3BS8pVgx+t8fmghmfypq6SGQvHp\nKvrcLmkFx0IZfzjHRaOruHtbhYRxnVCAsJXBmUfhRUIvF7C+pGV/7YYwXJSG0cHB\nfJZd079WkIvFrZ6qrLCoi9Af1jzUypQ1ZpoRbISzWPXhlvf0VWnpeidEiZCUWEip\nlQBkgmmZNoOxZTHfsvXtKRr6CwLhbpJBkOhXxCJNArK+QBhspeiGI1mF7cqo/U8=\n=0REG\n-----END PGP SIGNATURE-----\n", "payload": "tree 1a5024987358c39a5fc6de1d2c49b1328c3a7326\nparent f35747517052240277835b6b2dec553ba547ec00\nparent 3125979b78db0d4e2151f430d6f3f4464c086569\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1682715404 +0200\ncommitter GitHub <noreply@github.com> 1682715404 +0200\n\nRollup merge of #110877 - compiler-errors:binop-err, r=cjgillot\n\nProvide better type hints when a type doesn't support a binary operator\n\nFor example, when checking whether `vec![A] == vec![A]` holds, we first evaluate the LHS's ty, then probe for any `PartialEq` implementations for that. If none is found, we report an error by evaluating `Vec<A>: PartialEq<?0>` for fulfillment errors, but the RHS is not yet evaluated and remains an inference variable `?0`!\n\nTo fix this, we evaluate the RHS and equate it to that RHS infer var `?0`, so that we are able to provide more detailed fulfillment errors for why `Vec<A>: PartialEq<Vec<A>>` doesn't hold (namely, the nested obligation `A: PartialEq<A>` doesn't hold).\n\nFixes #95285\nFixes #110867\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aba9fb4696a300f8fa95e838ac9da81c61714617", "html_url": "https://github.com/rust-lang/rust/commit/aba9fb4696a300f8fa95e838ac9da81c61714617", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aba9fb4696a300f8fa95e838ac9da81c61714617/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f35747517052240277835b6b2dec553ba547ec00", "url": "https://api.github.com/repos/rust-lang/rust/commits/f35747517052240277835b6b2dec553ba547ec00", "html_url": "https://github.com/rust-lang/rust/commit/f35747517052240277835b6b2dec553ba547ec00"}, {"sha": "3125979b78db0d4e2151f430d6f3f4464c086569", "url": "https://api.github.com/repos/rust-lang/rust/commits/3125979b78db0d4e2151f430d6f3f4464c086569", "html_url": "https://github.com/rust-lang/rust/commit/3125979b78db0d4e2151f430d6f3f4464c086569"}], "stats": {"total": 332, "additions": 215, "deletions": 117}, "files": [{"sha": "d50be47c915134d851315d36a904d581228e9259", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -455,15 +455,9 @@ fn fatally_break_rust(sess: &Session) {\n     ));\n }\n \n-fn has_expected_num_generic_args(\n-    tcx: TyCtxt<'_>,\n-    trait_did: Option<DefId>,\n-    expected: usize,\n-) -> bool {\n-    trait_did.map_or(true, |trait_did| {\n-        let generics = tcx.generics_of(trait_did);\n-        generics.count() == expected + if generics.has_self { 1 } else { 0 }\n-    })\n+fn has_expected_num_generic_args(tcx: TyCtxt<'_>, trait_did: DefId, expected: usize) -> bool {\n+    let generics = tcx.generics_of(trait_did);\n+    generics.count() == expected + if generics.has_self { 1 } else { 0 }\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "43f40ada5acb612a54fcf4ce9cc158cccff3023d", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -27,8 +27,8 @@ use rustc_middle::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::DeepRejectCtxt;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::{with_crate_prefix, with_forced_trimmed_paths};\n+use rustc_middle::ty::IsSuggestable;\n use rustc_middle::ty::{self, GenericArgKind, Ty, TyCtxt, TypeVisitableExt};\n-use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n use rustc_span::{edit_distance, source_map, ExpnKind, FileName, MacroKind, Span};\n@@ -2068,7 +2068,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut derives = Vec::<(String, Span, Symbol)>::new();\n         let mut traits = Vec::new();\n         for (pred, _, _) in unsatisfied_predicates {\n-            let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = pred.kind().skip_binder() else { continue };\n+            let Some(ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))) =\n+                pred.kind().no_bound_vars()\n+            else {\n+                continue\n+            };\n             let adt = match trait_pred.self_ty().ty_adt_def() {\n                 Some(adt) if adt.did().is_local() => adt,\n                 _ => continue,\n@@ -2085,22 +2089,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     | sym::Hash\n                     | sym::Debug => true,\n                     _ => false,\n+                } && match trait_pred.trait_ref.substs.as_slice() {\n+                    // Only suggest deriving if lhs == rhs...\n+                    [lhs, rhs] => {\n+                        if let Some(lhs) = lhs.as_type()\n+                            && let Some(rhs) = rhs.as_type()\n+                        {\n+                            self.can_eq(self.param_env, lhs, rhs)\n+                        } else {\n+                            false\n+                        }\n+                    },\n+                    // Unary ops can always be derived\n+                    [_] => true,\n+                    _ => false,\n                 };\n                 if can_derive {\n                     let self_name = trait_pred.self_ty().to_string();\n                     let self_span = self.tcx.def_span(adt.did());\n-                    if let Some(poly_trait_ref) = pred.to_opt_poly_trait_pred() {\n-                        for super_trait in supertraits(self.tcx, poly_trait_ref.to_poly_trait_ref())\n+                    for super_trait in\n+                        supertraits(self.tcx, ty::Binder::dummy(trait_pred.trait_ref))\n+                    {\n+                        if let Some(parent_diagnostic_name) =\n+                            self.tcx.get_diagnostic_name(super_trait.def_id())\n                         {\n-                            if let Some(parent_diagnostic_name) =\n-                                self.tcx.get_diagnostic_name(super_trait.def_id())\n-                            {\n-                                derives.push((\n-                                    self_name.clone(),\n-                                    self_span,\n-                                    parent_diagnostic_name,\n-                                ));\n-                            }\n+                            derives.push((self_name.clone(), self_span, parent_diagnostic_name));\n                         }\n                     }\n                     derives.push((self_name, self_span, diagnostic_name));"}, {"sha": "e91ae4466eb87a20ef6a81e9301858c10c500c0d", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -408,14 +408,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 };\n \n-                let is_compatible = |lhs_ty, rhs_ty| {\n+                let is_compatible_after_call = |lhs_ty, rhs_ty| {\n                     self.lookup_op_method(\n                         lhs_ty,\n                         Some((rhs_expr, rhs_ty)),\n                         Op::Binary(op, is_assign),\n                         expected,\n                     )\n                     .is_ok()\n+                        // Suggest calling even if, after calling, the types don't\n+                        // implement the operator, since it'll lead to better\n+                        // diagnostics later.\n+                        || self.can_eq(self.param_env, lhs_ty, rhs_ty)\n                 };\n \n                 // We should suggest `a + b` => `*a + b` if `a` is copy, and suggest\n@@ -436,16 +440,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         suggest_deref_binop(*lhs_deref_ty);\n                     }\n                 } else if self.suggest_fn_call(&mut err, lhs_expr, lhs_ty, |lhs_ty| {\n-                    is_compatible(lhs_ty, rhs_ty)\n+                    is_compatible_after_call(lhs_ty, rhs_ty)\n                 }) || self.suggest_fn_call(&mut err, rhs_expr, rhs_ty, |rhs_ty| {\n-                    is_compatible(lhs_ty, rhs_ty)\n+                    is_compatible_after_call(lhs_ty, rhs_ty)\n                 }) || self.suggest_two_fn_call(\n                     &mut err,\n                     rhs_expr,\n                     rhs_ty,\n                     lhs_expr,\n                     lhs_ty,\n-                    |lhs_ty, rhs_ty| is_compatible(lhs_ty, rhs_ty),\n+                    |lhs_ty, rhs_ty| is_compatible_after_call(lhs_ty, rhs_ty),\n                 ) {\n                     // Cool\n                 }\n@@ -719,7 +723,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Op::Binary(op, _) => op.span,\n             Op::Unary(_, span) => span,\n         };\n-        let (opname, trait_did) = lang_item_for_op(self.tcx, op, span);\n+        let (opname, Some(trait_did)) = lang_item_for_op(self.tcx, op, span) else {\n+            // Bail if the operator trait is not defined.\n+            return Err(vec![]);\n+        };\n \n         debug!(\n             \"lookup_op_method(lhs_ty={:?}, op={:?}, opname={:?}, trait_did={:?})\",\n@@ -759,18 +766,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n         );\n \n-        let method = trait_did.and_then(|trait_did| {\n-            self.lookup_method_in_trait(cause.clone(), opname, trait_did, lhs_ty, Some(input_types))\n-        });\n-\n-        match (method, trait_did) {\n-            (Some(ok), _) => {\n+        let method = self.lookup_method_in_trait(\n+            cause.clone(),\n+            opname,\n+            trait_did,\n+            lhs_ty,\n+            Some(input_types),\n+        );\n+        match method {\n+            Some(ok) => {\n                 let method = self.register_infer_ok_obligations(ok);\n                 self.select_obligations_where_possible(|_| {});\n                 Ok(method)\n             }\n-            (None, None) => Err(vec![]),\n-            (None, Some(trait_did)) => {\n+            None => {\n+                // This path may do some inference, so make sure we've really\n+                // doomed compilation so as to not accidentally stabilize new\n+                // inference or something here...\n+                self.tcx.sess.delay_span_bug(span, \"this path really should be doomed...\");\n+                // Guide inference for the RHS expression if it's provided --\n+                // this will allow us to better error reporting, at the expense\n+                // of making some error messages a bit more specific.\n+                if let Some((rhs_expr, rhs_ty)) = opt_rhs\n+                    && rhs_ty.is_ty_var()\n+                {\n+                    self.check_expr_coercible_to_type(rhs_expr, rhs_ty, None);\n+                }\n+\n                 let (obligation, _) =\n                     self.obligation_for_method(cause, trait_did, lhs_ty, Some(input_types));\n                 // FIXME: This should potentially just add the obligation to the `FnCtxt`"}, {"sha": "1f7e7ba9f5b2d0ed900b3603ca70e1867d02bbca", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -200,9 +200,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         debug!(\"try_overloaded_place_op({:?},{:?},{:?})\", span, base_ty, op);\n \n-        let (imm_tr, imm_op) = match op {\n+        let (Some(imm_tr), imm_op) = (match op {\n             PlaceOp::Deref => (self.tcx.lang_items().deref_trait(), sym::deref),\n             PlaceOp::Index => (self.tcx.lang_items().index_trait(), sym::index),\n+        }) else {\n+            // Bail if `Deref` or `Index` isn't defined.\n+            return None;\n         };\n \n         // If the lang item was declared incorrectly, stop here so that we don't\n@@ -219,15 +222,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return None;\n         }\n \n-        imm_tr.and_then(|trait_did| {\n-            self.lookup_method_in_trait(\n-                self.misc(span),\n-                Ident::with_dummy_span(imm_op),\n-                trait_did,\n-                base_ty,\n-                Some(arg_tys),\n-            )\n-        })\n+        self.lookup_method_in_trait(\n+            self.misc(span),\n+            Ident::with_dummy_span(imm_op),\n+            imm_tr,\n+            base_ty,\n+            Some(arg_tys),\n+        )\n     }\n \n     fn try_mutable_overloaded_place_op(\n@@ -239,9 +240,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         debug!(\"try_mutable_overloaded_place_op({:?},{:?},{:?})\", span, base_ty, op);\n \n-        let (mut_tr, mut_op) = match op {\n+        let (Some(mut_tr), mut_op) = (match op {\n             PlaceOp::Deref => (self.tcx.lang_items().deref_mut_trait(), sym::deref_mut),\n             PlaceOp::Index => (self.tcx.lang_items().index_mut_trait(), sym::index_mut),\n+        }) else {\n+            // Bail if `DerefMut` or `IndexMut` isn't defined.\n+            return None;\n         };\n \n         // If the lang item was declared incorrectly, stop here so that we don't\n@@ -258,15 +262,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return None;\n         }\n \n-        mut_tr.and_then(|trait_did| {\n-            self.lookup_method_in_trait(\n-                self.misc(span),\n-                Ident::with_dummy_span(mut_op),\n-                trait_did,\n-                base_ty,\n-                Some(arg_tys),\n-            )\n-        })\n+        self.lookup_method_in_trait(\n+            self.misc(span),\n+            Ident::with_dummy_span(mut_op),\n+            mut_tr,\n+            base_ty,\n+            Some(arg_tys),\n+        )\n     }\n \n     /// Convert auto-derefs, indices, etc of an expression from `Deref` and `Index`"}, {"sha": "a77c4c5aabcddac8a560cc0b8df6f3ad7339ed79", "filename": "tests/ui/binop/eq-arr.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fbinop%2Feq-arr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fbinop%2Feq-arr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbinop%2Feq-arr.rs?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    struct X;\n+    //~^ HELP consider annotating `X` with `#[derive(PartialEq)]`\n+    let xs = [X, X, X];\n+    let eq = xs == [X, X, X];\n+    //~^ ERROR binary operation `==` cannot be applied to type `[X; 3]`\n+}"}, {"sha": "a22f8e3ab0c7923fccdfa2218e4f1a4609abbc32", "filename": "tests/ui/binop/eq-arr.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fbinop%2Feq-arr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fbinop%2Feq-arr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbinop%2Feq-arr.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -0,0 +1,22 @@\n+error[E0369]: binary operation `==` cannot be applied to type `[X; 3]`\n+  --> $DIR/eq-arr.rs:5:17\n+   |\n+LL |     let eq = xs == [X, X, X];\n+   |              -- ^^ --------- [X; 3]\n+   |              |\n+   |              [X; 3]\n+   |\n+note: an implementation of `PartialEq` might be missing for `X`\n+  --> $DIR/eq-arr.rs:2:5\n+   |\n+LL |     struct X;\n+   |     ^^^^^^^^ must implement `PartialEq`\n+help: consider annotating `X` with `#[derive(PartialEq)]`\n+   |\n+LL +     #[derive(PartialEq)]\n+LL |     struct X;\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "17ce8df8564253b7757a25db2b870716fe793290", "filename": "tests/ui/binop/eq-vec.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fbinop%2Feq-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fbinop%2Feq-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbinop%2Feq-vec.rs?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -0,0 +1,13 @@\n+fn main() {\n+    #[derive(Debug)]\n+    enum Foo {\n+        //~^ HELP consider annotating `Foo` with `#[derive(PartialEq)]`\n+        Bar,\n+        Qux,\n+    }\n+\n+    let vec1 = vec![Foo::Bar, Foo::Qux];\n+    let vec2 = vec![Foo::Bar, Foo::Qux];\n+    assert_eq!(vec1, vec2);\n+    //~^ ERROR binary operation `==` cannot be applied to type `Vec<Foo>`\n+}"}, {"sha": "0a98cddfe05a996f87f46abe316bc2a1939d5227", "filename": "tests/ui/binop/eq-vec.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fbinop%2Feq-vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fbinop%2Feq-vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbinop%2Feq-vec.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -0,0 +1,24 @@\n+error[E0369]: binary operation `==` cannot be applied to type `Vec<Foo>`\n+  --> $DIR/eq-vec.rs:11:5\n+   |\n+LL |     assert_eq!(vec1, vec2);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     Vec<Foo>\n+   |     Vec<Foo>\n+   |\n+note: an implementation of `PartialEq` might be missing for `Foo`\n+  --> $DIR/eq-vec.rs:3:5\n+   |\n+LL |     enum Foo {\n+   |     ^^^^^^^^ must implement `PartialEq`\n+   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider annotating `Foo` with `#[derive(PartialEq)]`\n+   |\n+LL +     #[derive(PartialEq)]\n+LL |     enum Foo {\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "6c98edd3af8e8032f29c8a413d019b79983760b6", "filename": "tests/ui/binop/issue-28837.stderr", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fbinop%2Fissue-28837.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fbinop%2Fissue-28837.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbinop%2Fissue-28837.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -6,11 +6,11 @@ LL |     a + a;\n    |     |\n    |     A\n    |\n-note: an implementation of `Add<_>` might be missing for `A`\n+note: an implementation of `Add` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `Add<_>`\n+   | ^^^^^^^^ must implement `Add`\n note: the trait `Add` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n \n@@ -22,11 +22,11 @@ LL |     a - a;\n    |     |\n    |     A\n    |\n-note: an implementation of `Sub<_>` might be missing for `A`\n+note: an implementation of `Sub` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `Sub<_>`\n+   | ^^^^^^^^ must implement `Sub`\n note: the trait `Sub` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n \n@@ -38,11 +38,11 @@ LL |     a * a;\n    |     |\n    |     A\n    |\n-note: an implementation of `Mul<_>` might be missing for `A`\n+note: an implementation of `Mul` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `Mul<_>`\n+   | ^^^^^^^^ must implement `Mul`\n note: the trait `Mul` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n \n@@ -54,11 +54,11 @@ LL |     a / a;\n    |     |\n    |     A\n    |\n-note: an implementation of `Div<_>` might be missing for `A`\n+note: an implementation of `Div` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `Div<_>`\n+   | ^^^^^^^^ must implement `Div`\n note: the trait `Div` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n \n@@ -70,11 +70,11 @@ LL |     a % a;\n    |     |\n    |     A\n    |\n-note: an implementation of `Rem<_>` might be missing for `A`\n+note: an implementation of `Rem` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `Rem<_>`\n+   | ^^^^^^^^ must implement `Rem`\n note: the trait `Rem` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n \n@@ -86,11 +86,11 @@ LL |     a & a;\n    |     |\n    |     A\n    |\n-note: an implementation of `BitAnd<_>` might be missing for `A`\n+note: an implementation of `BitAnd` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `BitAnd<_>`\n+   | ^^^^^^^^ must implement `BitAnd`\n note: the trait `BitAnd` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n \n@@ -102,11 +102,11 @@ LL |     a | a;\n    |     |\n    |     A\n    |\n-note: an implementation of `BitOr<_>` might be missing for `A`\n+note: an implementation of `BitOr` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `BitOr<_>`\n+   | ^^^^^^^^ must implement `BitOr`\n note: the trait `BitOr` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n \n@@ -118,11 +118,11 @@ LL |     a << a;\n    |     |\n    |     A\n    |\n-note: an implementation of `Shl<_>` might be missing for `A`\n+note: an implementation of `Shl` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `Shl<_>`\n+   | ^^^^^^^^ must implement `Shl`\n note: the trait `Shl` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n \n@@ -134,11 +134,11 @@ LL |     a >> a;\n    |     |\n    |     A\n    |\n-note: an implementation of `Shr<_>` might be missing for `A`\n+note: an implementation of `Shr` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `Shr<_>`\n+   | ^^^^^^^^ must implement `Shr`\n note: the trait `Shr` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n \n@@ -150,11 +150,11 @@ LL |     a == a;\n    |     |\n    |     A\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `A`\n+note: an implementation of `PartialEq` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `PartialEq<_>`\n+   | ^^^^^^^^ must implement `PartialEq`\n help: consider annotating `A` with `#[derive(PartialEq)]`\n    |\n LL + #[derive(PartialEq)]\n@@ -169,11 +169,11 @@ LL |     a != a;\n    |     |\n    |     A\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `A`\n+note: an implementation of `PartialEq` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `PartialEq<_>`\n+   | ^^^^^^^^ must implement `PartialEq`\n help: consider annotating `A` with `#[derive(PartialEq)]`\n    |\n LL + #[derive(PartialEq)]\n@@ -188,11 +188,11 @@ LL |     a < a;\n    |     |\n    |     A\n    |\n-note: an implementation of `PartialOrd<_>` might be missing for `A`\n+note: an implementation of `PartialOrd` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `PartialOrd<_>`\n+   | ^^^^^^^^ must implement `PartialOrd`\n help: consider annotating `A` with `#[derive(PartialEq, PartialOrd)]`\n    |\n LL + #[derive(PartialEq, PartialOrd)]\n@@ -207,11 +207,11 @@ LL |     a <= a;\n    |     |\n    |     A\n    |\n-note: an implementation of `PartialOrd<_>` might be missing for `A`\n+note: an implementation of `PartialOrd` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `PartialOrd<_>`\n+   | ^^^^^^^^ must implement `PartialOrd`\n help: consider annotating `A` with `#[derive(PartialEq, PartialOrd)]`\n    |\n LL + #[derive(PartialEq, PartialOrd)]\n@@ -226,11 +226,11 @@ LL |     a > a;\n    |     |\n    |     A\n    |\n-note: an implementation of `PartialOrd<_>` might be missing for `A`\n+note: an implementation of `PartialOrd` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `PartialOrd<_>`\n+   | ^^^^^^^^ must implement `PartialOrd`\n help: consider annotating `A` with `#[derive(PartialEq, PartialOrd)]`\n    |\n LL + #[derive(PartialEq, PartialOrd)]\n@@ -245,11 +245,11 @@ LL |     a >= a;\n    |     |\n    |     A\n    |\n-note: an implementation of `PartialOrd<_>` might be missing for `A`\n+note: an implementation of `PartialOrd` might be missing for `A`\n   --> $DIR/issue-28837.rs:1:1\n    |\n LL | struct A;\n-   | ^^^^^^^^ must implement `PartialOrd<_>`\n+   | ^^^^^^^^ must implement `PartialOrd`\n help: consider annotating `A` with `#[derive(PartialEq, PartialOrd)]`\n    |\n LL + #[derive(PartialEq, PartialOrd)]"}, {"sha": "cfa78a41dbf08a8047f5704555060f6ab0595b00", "filename": "tests/ui/binop/issue-3820.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fbinop%2Fissue-3820.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fbinop%2Fissue-3820.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbinop%2Fissue-3820.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -6,11 +6,11 @@ LL |     let w = u * 3;\n    |             |\n    |             Thing\n    |\n-note: an implementation of `Mul<_>` might be missing for `Thing`\n+note: an implementation of `Mul<{integer}>` might be missing for `Thing`\n   --> $DIR/issue-3820.rs:1:1\n    |\n LL | struct Thing {\n-   | ^^^^^^^^^^^^ must implement `Mul<_>`\n+   | ^^^^^^^^^^^^ must implement `Mul<{integer}>`\n note: the trait `Mul` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n "}, {"sha": "e3b17431f89af3d6fa481a3a19a8b4769109446b", "filename": "tests/ui/derives/derives-span-PartialEq-enum-struct-variant.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -7,11 +7,11 @@ LL | #[derive(PartialEq)]\n LL |      x: Error\n    |      ^^^^^^^^\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `Error`\n+note: an implementation of `PartialEq` might be missing for `Error`\n   --> $DIR/derives-span-PartialEq-enum-struct-variant.rs:4:1\n    |\n LL | struct Error;\n-   | ^^^^^^^^^^^^ must implement `PartialEq<_>`\n+   | ^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `Error` with `#[derive(PartialEq)]`\n    |"}, {"sha": "d1631732a34f488adaedd3a455a2242ae2aa86be", "filename": "tests/ui/derives/derives-span-PartialEq-enum.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fderives%2Fderives-span-PartialEq-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fderives%2Fderives-span-PartialEq-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderives-span-PartialEq-enum.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -7,11 +7,11 @@ LL | #[derive(PartialEq)]\n LL |      Error\n    |      ^^^^^\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `Error`\n+note: an implementation of `PartialEq` might be missing for `Error`\n   --> $DIR/derives-span-PartialEq-enum.rs:4:1\n    |\n LL | struct Error;\n-   | ^^^^^^^^^^^^ must implement `PartialEq<_>`\n+   | ^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `Error` with `#[derive(PartialEq)]`\n    |"}, {"sha": "ab6c6951fc634bba8a039cc73bbe4e5666b6a4a6", "filename": "tests/ui/derives/derives-span-PartialEq-struct.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fderives%2Fderives-span-PartialEq-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fderives%2Fderives-span-PartialEq-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderives-span-PartialEq-struct.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -7,11 +7,11 @@ LL | struct Struct {\n LL |     x: Error\n    |     ^^^^^^^^\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `Error`\n+note: an implementation of `PartialEq` might be missing for `Error`\n   --> $DIR/derives-span-PartialEq-struct.rs:4:1\n    |\n LL | struct Error;\n-   | ^^^^^^^^^^^^ must implement `PartialEq<_>`\n+   | ^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `Error` with `#[derive(PartialEq)]`\n    |"}, {"sha": "865ecad0e8e6d2556f8b120df40f4d1758be6ccb", "filename": "tests/ui/derives/derives-span-PartialEq-tuple-struct.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -7,11 +7,11 @@ LL | struct Struct(\n LL |     Error\n    |     ^^^^^\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `Error`\n+note: an implementation of `PartialEq` might be missing for `Error`\n   --> $DIR/derives-span-PartialEq-tuple-struct.rs:4:1\n    |\n LL | struct Error;\n-   | ^^^^^^^^^^^^ must implement `PartialEq<_>`\n+   | ^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `Error` with `#[derive(PartialEq)]`\n    |"}, {"sha": "ab99ba9fab5a693ff3bdc5120b9770d217c44ca0", "filename": "tests/ui/derives/deriving-no-inner-impl-error-message.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -7,11 +7,11 @@ LL | struct E {\n LL |     x: NoCloneOrEq\n    |     ^^^^^^^^^^^^^^\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `NoCloneOrEq`\n+note: an implementation of `PartialEq` might be missing for `NoCloneOrEq`\n   --> $DIR/deriving-no-inner-impl-error-message.rs:1:1\n    |\n LL | struct NoCloneOrEq;\n-   | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq<_>`\n+   | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `NoCloneOrEq` with `#[derive(PartialEq)]`\n    |"}, {"sha": "f556330070cb1dcae9379829587d50edd08155b8", "filename": "tests/ui/destructuring-assignment/note-unsupported.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -44,11 +44,11 @@ LL |     S { x: a, y: b } += s;\n    |     |\n    |     cannot use `+=` on type `S`\n    |\n-note: an implementation of `AddAssign<_>` might be missing for `S`\n+note: an implementation of `AddAssign` might be missing for `S`\n   --> $DIR/note-unsupported.rs:1:1\n    |\n LL | struct S { x: u8, y: u8 }\n-   | ^^^^^^^^ must implement `AddAssign<_>`\n+   | ^^^^^^^^ must implement `AddAssign`\n note: the trait `AddAssign` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n "}, {"sha": "cd632e64fe5fccf2c5b589f8820a82bb1e2f1c4b", "filename": "tests/ui/issues/issue-62375.stderr", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fissues%2Fissue-62375.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fissues%2Fissue-62375.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-62375.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -6,16 +6,17 @@ LL |     a == A::Value;\n    |     |\n    |     A\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `A`\n+note: an implementation of `PartialEq<fn(()) -> A {A::Value}>` might be missing for `A`\n   --> $DIR/issue-62375.rs:1:1\n    |\n LL | enum A {\n-   | ^^^^^^ must implement `PartialEq<_>`\n-help: consider annotating `A` with `#[derive(PartialEq)]`\n-   |\n-LL + #[derive(PartialEq)]\n-LL | enum A {\n+   | ^^^^^^ must implement `PartialEq<fn(()) -> A {A::Value}>`\n+note: the trait `PartialEq` must be implemented\n+  --> $SRC_DIR/core/src/cmp.rs:LL:COL\n+help: use parentheses to construct this tuple variant\n    |\n+LL |     a == A::Value(/* () */);\n+   |                  ++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "66a85c4656af536677c42ccd9673b316b8b88da6", "filename": "tests/ui/mismatched_types/assignment-operator-unimplemented.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fmismatched_types%2Fassignment-operator-unimplemented.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fmismatched_types%2Fassignment-operator-unimplemented.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fassignment-operator-unimplemented.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -6,11 +6,11 @@ LL |   a += *b;\n    |   |\n    |   cannot use `+=` on type `Foo`\n    |\n-note: an implementation of `AddAssign<_>` might be missing for `Foo`\n+note: an implementation of `AddAssign` might be missing for `Foo`\n   --> $DIR/assignment-operator-unimplemented.rs:1:1\n    |\n LL | struct Foo;\n-   | ^^^^^^^^^^ must implement `AddAssign<_>`\n+   | ^^^^^^^^^^ must implement `AddAssign`\n note: the trait `AddAssign` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n "}, {"sha": "604bba417e6cc0c4698f2a947e42c86ad9cf2dc2", "filename": "tests/ui/or-patterns/or-patterns-syntactic-fail.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -30,11 +30,11 @@ LL |     let _ = |A | B: E| ();\n    |                  |\n    |                  E\n    |\n-note: an implementation of `BitOr<_>` might be missing for `E`\n+note: an implementation of `BitOr<()>` might be missing for `E`\n   --> $DIR/or-patterns-syntactic-fail.rs:6:1\n    |\n LL | enum E { A, B }\n-   | ^^^^^^ must implement `BitOr<_>`\n+   | ^^^^^^ must implement `BitOr<()>`\n note: the trait `BitOr` must be implemented\n   --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n "}, {"sha": "bae936392717414e6adf33e70115c12928083a1b", "filename": "tests/ui/span/issue-39018.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fspan%2Fissue-39018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fspan%2Fissue-39018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspan%2Fissue-39018.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -21,11 +21,11 @@ LL |     let y = World::Hello + World::Goodbye;\n    |             |\n    |             World\n    |\n-note: an implementation of `Add<_>` might be missing for `World`\n+note: an implementation of `Add` might be missing for `World`\n   --> $DIR/issue-39018.rs:15:1\n    |\n LL | enum World {\n-   | ^^^^^^^^^^ must implement `Add<_>`\n+   | ^^^^^^^^^^ must implement `Add`\n note: the trait `Add` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n "}, {"sha": "570afcea6434baba4803a1b970656475b79895a2", "filename": "tests/ui/suggestions/invalid-bin-op.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -6,11 +6,11 @@ LL |     let _ = s == t;\n    |             |\n    |             S<T>\n    |\n-note: an implementation of `PartialEq<_>` might be missing for `S<T>`\n+note: an implementation of `PartialEq` might be missing for `S<T>`\n   --> $DIR/invalid-bin-op.rs:5:1\n    |\n LL | struct S<T>(T);\n-   | ^^^^^^^^^^^ must implement `PartialEq<_>`\n+   | ^^^^^^^^^^^ must implement `PartialEq`\n help: consider annotating `S<T>` with `#[derive(PartialEq)]`\n    |\n LL + #[derive(PartialEq)]"}, {"sha": "3c7d42888d83342fe2625886cb127d7e67843ba8", "filename": "tests/ui/suggestions/restrict-type-not-param.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fsuggestions%2Frestrict-type-not-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Fsuggestions%2Frestrict-type-not-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Frestrict-type-not-param.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -6,11 +6,11 @@ LL |     a + b\n    |     |\n    |     Wrapper<T>\n    |\n-note: an implementation of `Add<_>` might be missing for `Wrapper<T>`\n+note: an implementation of `Add<T>` might be missing for `Wrapper<T>`\n   --> $DIR/restrict-type-not-param.rs:3:1\n    |\n LL | struct Wrapper<T>(T);\n-   | ^^^^^^^^^^^^^^^^^ must implement `Add<_>`\n+   | ^^^^^^^^^^^^^^^^^ must implement `Add<T>`\n note: the trait `Add` must be implemented\n   --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement"}, {"sha": "0b76ba8eb7e837245a28f7ee7580b02829d57a90", "filename": "tests/ui/type/type-unsatisfiable.usage.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Ftype%2Ftype-unsatisfiable.usage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba9fb4696a300f8fa95e838ac9da81c61714617/tests%2Fui%2Ftype%2Ftype-unsatisfiable.usage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-unsatisfiable.usage.stderr?ref=aba9fb4696a300f8fa95e838ac9da81c61714617", "patch": "@@ -1,8 +1,8 @@\n-error[E0369]: cannot subtract `(dyn Vector2<ScalarType = i32> + 'static)` from `dyn Vector2<ScalarType = i32>`\n+error[E0369]: cannot subtract `dyn Vector2<ScalarType = i32>` from `dyn Vector2<ScalarType = i32>`\n   --> $DIR/type-unsatisfiable.rs:57:20\n    |\n LL |     let bar = *hey - *word;\n-   |               ---- ^ ----- (dyn Vector2<ScalarType = i32> + 'static)\n+   |               ---- ^ ----- dyn Vector2<ScalarType = i32>\n    |               |\n    |               dyn Vector2<ScalarType = i32>\n "}]}