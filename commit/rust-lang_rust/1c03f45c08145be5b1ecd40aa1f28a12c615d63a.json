{"sha": "1c03f45c08145be5b1ecd40aa1f28a12c615d63a", "node_id": "C_kwDOAAsO6NoAKDFjMDNmNDVjMDgxNDViZTViMWVjZDQwYWExZjI4YTEyYzYxNWQ2M2E", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-02T19:50:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-02T19:50:01Z"}, "message": "Auto merge of #12837 - DorianListens:dscheidt/generate-enum-data, r=Veykril\n\nfeat: support associated values in \"Generate Enum Variant\" assist\n\nThis change adds support for associated values to the \"Generate Enum Variant\" assist.\n\nI've split the implementation out into 4 steps to make code review easier:\n- Add \"add_variant\" support to the structural ast editing system in `edit_in_place`\n- Migrate `generate_enum_variant` to use structural ast editing instead of string manipulation\n- Support tuple fields\n- Support record fields\n\nPlease let me know if I should leave the commits as-is, or squash before merging.\n\nFixes #12797", "tree": {"sha": "b3f0239668b4e9b1aa520e15f04cdc25485f5240", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3f0239668b4e9b1aa520e15f04cdc25485f5240"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c03f45c08145be5b1ecd40aa1f28a12c615d63a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c03f45c08145be5b1ecd40aa1f28a12c615d63a", "html_url": "https://github.com/rust-lang/rust/commit/1c03f45c08145be5b1ecd40aa1f28a12c615d63a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c03f45c08145be5b1ecd40aa1f28a12c615d63a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "113f1dbc9102d8eb693fefc1f369868c2a497910", "url": "https://api.github.com/repos/rust-lang/rust/commits/113f1dbc9102d8eb693fefc1f369868c2a497910", "html_url": "https://github.com/rust-lang/rust/commit/113f1dbc9102d8eb693fefc1f369868c2a497910"}, {"sha": "1980c1192c7bcfb10e1ed380ee90bcaa7153d58d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1980c1192c7bcfb10e1ed380ee90bcaa7153d58d", "html_url": "https://github.com/rust-lang/rust/commit/1980c1192c7bcfb10e1ed380ee90bcaa7153d58d"}], "stats": {"total": 551, "additions": 504, "deletions": 47}, "files": [{"sha": "35cd42908af2c0d225d3fa5d0fb3336fb3629d96", "filename": "crates/ide-assists/src/handlers/generate_enum_variant.rs", "status": "modified", "additions": 356, "deletions": 19, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/1c03f45c08145be5b1ecd40aa1f28a12c615d63a/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c03f45c08145be5b1ecd40aa1f28a12c615d63a/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs?ref=1c03f45c08145be5b1ecd40aa1f28a12c615d63a", "patch": "@@ -1,8 +1,8 @@\n-use hir::{HasSource, InFile};\n+use hir::{HasSource, HirDisplay, InFile};\n use ide_db::assists::{AssistId, AssistKind};\n use syntax::{\n-    ast::{self, edit::IndentLevel},\n-    AstNode, TextSize,\n+    ast::{self, make, HasArgList},\n+    match_ast, AstNode, SyntaxNode,\n };\n \n use crate::assist_context::{AssistContext, Assists};\n@@ -32,8 +32,8 @@ use crate::assist_context::{AssistContext, Assists};\n // }\n // ```\n pub(crate) fn generate_enum_variant(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n-    let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n-    let path = path_expr.path()?;\n+    let path: ast::Path = ctx.find_node_at_offset()?;\n+    let parent = path_parent(&path)?;\n \n     if ctx.sema.resolve_path(&path).is_some() {\n         // No need to generate anything if the path resolves\n@@ -50,45 +50,152 @@ pub(crate) fn generate_enum_variant(acc: &mut Assists, ctx: &AssistContext<'_>)\n         ctx.sema.resolve_path(&path.qualifier()?)\n     {\n         let target = path.syntax().text_range();\n-        return add_variant_to_accumulator(acc, ctx, target, e, &name_ref);\n+        return add_variant_to_accumulator(acc, ctx, target, e, &name_ref, parent);\n     }\n \n     None\n }\n \n+#[derive(Debug)]\n+enum PathParent {\n+    PathExpr(ast::PathExpr),\n+    RecordExpr(ast::RecordExpr),\n+    PathPat(ast::PathPat),\n+    UseTree(ast::UseTree),\n+}\n+\n+impl PathParent {\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            PathParent::PathExpr(it) => it.syntax(),\n+            PathParent::RecordExpr(it) => it.syntax(),\n+            PathParent::PathPat(it) => it.syntax(),\n+            PathParent::UseTree(it) => it.syntax(),\n+        }\n+    }\n+\n+    fn make_field_list(&self, ctx: &AssistContext<'_>) -> Option<ast::FieldList> {\n+        let scope = ctx.sema.scope(self.syntax())?;\n+\n+        match self {\n+            PathParent::PathExpr(it) => {\n+                if let Some(call_expr) = it.syntax().parent().and_then(ast::CallExpr::cast) {\n+                    make_tuple_field_list(call_expr, ctx, &scope)\n+                } else {\n+                    None\n+                }\n+            }\n+            PathParent::RecordExpr(it) => make_record_field_list(it, ctx, &scope),\n+            PathParent::UseTree(_) | PathParent::PathPat(_) => None,\n+        }\n+    }\n+}\n+\n+fn path_parent(path: &ast::Path) -> Option<PathParent> {\n+    let parent = path.syntax().parent()?;\n+\n+    match_ast! {\n+        match parent {\n+            ast::PathExpr(it) => Some(PathParent::PathExpr(it)),\n+            ast::RecordExpr(it) => Some(PathParent::RecordExpr(it)),\n+            ast::PathPat(it) => Some(PathParent::PathPat(it)),\n+            ast::UseTree(it) => Some(PathParent::UseTree(it)),\n+            _ => None\n+        }\n+    }\n+}\n+\n fn add_variant_to_accumulator(\n     acc: &mut Assists,\n     ctx: &AssistContext<'_>,\n     target: syntax::TextRange,\n     adt: hir::Enum,\n     name_ref: &ast::NameRef,\n+    parent: PathParent,\n ) -> Option<()> {\n     let db = ctx.db();\n     let InFile { file_id, value: enum_node } = adt.source(db)?.original_ast_node(db)?;\n-    let enum_indent = IndentLevel::from_node(&enum_node.syntax());\n-\n-    let variant_list = enum_node.variant_list()?;\n-    let offset = variant_list.syntax().text_range().end() - TextSize::of('}');\n-    let empty_enum = variant_list.variants().next().is_none();\n \n     acc.add(\n         AssistId(\"generate_enum_variant\", AssistKind::Generate),\n         \"Generate variant\",\n         target,\n         |builder| {\n             builder.edit_file(file_id.original_file(db));\n-            let text = format!(\n-                \"{maybe_newline}{indent_1}{name},\\n{enum_indent}\",\n-                maybe_newline = if empty_enum { \"\\n\" } else { \"\" },\n-                indent_1 = IndentLevel(1),\n-                name = name_ref,\n-                enum_indent = enum_indent\n-            );\n-            builder.insert(offset, text)\n+            let node = builder.make_mut(enum_node);\n+            let variant = make_variant(ctx, name_ref, parent);\n+            node.variant_list().map(|it| it.add_variant(variant.clone_for_update()));\n         },\n     )\n }\n \n+fn make_variant(\n+    ctx: &AssistContext<'_>,\n+    name_ref: &ast::NameRef,\n+    parent: PathParent,\n+) -> ast::Variant {\n+    let field_list = parent.make_field_list(ctx);\n+    make::variant(make::name(&name_ref.text()), field_list)\n+}\n+\n+fn make_record_field_list(\n+    record: &ast::RecordExpr,\n+    ctx: &AssistContext<'_>,\n+    scope: &hir::SemanticsScope<'_>,\n+) -> Option<ast::FieldList> {\n+    let fields = record.record_expr_field_list()?.fields();\n+    let record_fields = fields.map(|field| {\n+        let name = name_from_field(&field);\n+\n+        let ty = field\n+            .expr()\n+            .and_then(|it| expr_ty(ctx, it, scope))\n+            .unwrap_or_else(make::ty_placeholder);\n+\n+        make::record_field(None, name, ty)\n+    });\n+    Some(make::record_field_list(record_fields).into())\n+}\n+\n+fn name_from_field(field: &ast::RecordExprField) -> ast::Name {\n+    let text = match field.name_ref() {\n+        Some(it) => it.to_string(),\n+        None => name_from_field_shorthand(field).unwrap_or(\"unknown\".to_string()),\n+    };\n+    make::name(&text)\n+}\n+\n+fn name_from_field_shorthand(field: &ast::RecordExprField) -> Option<String> {\n+    let path = match field.expr()? {\n+        ast::Expr::PathExpr(path_expr) => path_expr.path(),\n+        _ => None,\n+    }?;\n+    Some(path.as_single_name_ref()?.to_string())\n+}\n+\n+fn make_tuple_field_list(\n+    call_expr: ast::CallExpr,\n+    ctx: &AssistContext<'_>,\n+    scope: &hir::SemanticsScope<'_>,\n+) -> Option<ast::FieldList> {\n+    let args = call_expr.arg_list()?.args();\n+    let tuple_fields = args.map(|arg| {\n+        let ty = expr_ty(ctx, arg, &scope).unwrap_or_else(make::ty_placeholder);\n+        make::tuple_field(None, ty)\n+    });\n+    Some(make::tuple_field_list(tuple_fields).into())\n+}\n+\n+fn expr_ty(\n+    ctx: &AssistContext<'_>,\n+    arg: ast::Expr,\n+    scope: &hir::SemanticsScope<'_>,\n+) -> Option<ast::Type> {\n+    let ty = ctx.sema.type_of_expr(&arg).map(|it| it.adjusted())?;\n+    let text = ty.display_source_code(ctx.db(), scope.module().into()).ok()?;\n+    Some(make::ty(&text))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -221,6 +328,236 @@ mod m {\n fn main() {\n     m::Foo::Baz\n }\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_single_element_tuple() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::Bar$0(true)\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar(bool),\n+}\n+fn main() {\n+    Foo::Bar(true)\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_single_element_tuple_unknown_type() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::Bar$0(x)\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar(_),\n+}\n+fn main() {\n+    Foo::Bar(x)\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_multi_element_tuple() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+struct Struct {}\n+enum Foo {}\n+fn main() {\n+    Foo::Bar$0(true, x, Struct {})\n+}\n+\",\n+            r\"\n+struct Struct {}\n+enum Foo {\n+    Bar(bool, _, Struct),\n+}\n+fn main() {\n+    Foo::Bar(true, x, Struct {})\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::$0Bar { x: true }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar { x: bool },\n+}\n+fn main() {\n+    Foo::Bar { x: true }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record_unknown_type() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::$0Bar { x: y }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar { x: _ },\n+}\n+fn main() {\n+    Foo::Bar { x: y }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record_field_shorthand() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    let x = true;\n+    Foo::$0Bar { x }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar { x: bool },\n+}\n+fn main() {\n+    let x = true;\n+    Foo::Bar { x }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record_field_shorthand_unknown_type() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::$0Bar { x }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar { x: _ },\n+}\n+fn main() {\n+    Foo::Bar { x }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record_field_multiple_fields() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+struct Struct {}\n+enum Foo {}\n+fn main() {\n+    Foo::$0Bar { x, y: x, s: Struct {} }\n+}\n+\",\n+            r\"\n+struct Struct {}\n+enum Foo {\n+    Bar { x: _, y: _, s: Struct },\n+}\n+fn main() {\n+    Foo::Bar { x, y: x, s: Struct {} }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn use_tree() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+//- /main.rs\n+mod foo;\n+use foo::Foo::Bar$0;\n+\n+//- /foo.rs\n+enum Foo {}\n+\",\n+            r\"\n+enum Foo {\n+    Bar,\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_path_type() {\n+        check_assist_not_applicable(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+impl Foo::Bar$0 {}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn path_pat() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn foo(x: Foo) {\n+    match x {\n+        Foo::Bar$0 =>\n+    }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar,\n+}\n+fn foo(x: Foo) {\n+    match x {\n+        Foo::Bar =>\n+    }\n+}\n \",\n         )\n     }"}, {"sha": "8efd58e2c39aa48c098844ad853a30993d314f42", "filename": "crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 144, "deletions": 27, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/1c03f45c08145be5b1ecd40aa1f28a12c615d63a/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c03f45c08145be5b1ecd40aa1f28a12c615d63a/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=1c03f45c08145be5b1ecd40aa1f28a12c615d63a", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     ted::{self, Position},\n     AstNode, AstToken, Direction,\n     SyntaxKind::{ATTR, COMMENT, WHITESPACE},\n-    SyntaxNode,\n+    SyntaxNode, SyntaxToken,\n };\n \n use super::HasName;\n@@ -506,19 +506,7 @@ impl ast::RecordExprFieldList {\n \n         let position = match self.fields().last() {\n             Some(last_field) => {\n-                let comma = match last_field\n-                    .syntax()\n-                    .siblings_with_tokens(Direction::Next)\n-                    .filter_map(|it| it.into_token())\n-                    .find(|it| it.kind() == T![,])\n-                {\n-                    Some(it) => it,\n-                    None => {\n-                        let comma = ast::make::token(T![,]);\n-                        ted::insert(Position::after(last_field.syntax()), &comma);\n-                        comma\n-                    }\n-                };\n+                let comma = get_or_insert_comma_after(last_field.syntax());\n                 Position::after(comma)\n             }\n             None => match self.l_curly_token() {\n@@ -579,19 +567,8 @@ impl ast::RecordPatFieldList {\n \n         let position = match self.fields().last() {\n             Some(last_field) => {\n-                let comma = match last_field\n-                    .syntax()\n-                    .siblings_with_tokens(Direction::Next)\n-                    .filter_map(|it| it.into_token())\n-                    .find(|it| it.kind() == T![,])\n-                {\n-                    Some(it) => it,\n-                    None => {\n-                        let comma = ast::make::token(T![,]);\n-                        ted::insert(Position::after(last_field.syntax()), &comma);\n-                        comma\n-                    }\n-                };\n+                let syntax = last_field.syntax();\n+                let comma = get_or_insert_comma_after(syntax);\n                 Position::after(comma)\n             }\n             None => match self.l_curly_token() {\n@@ -606,12 +583,53 @@ impl ast::RecordPatFieldList {\n         }\n     }\n }\n+\n+fn get_or_insert_comma_after(syntax: &SyntaxNode) -> SyntaxToken {\n+    let comma = match syntax\n+        .siblings_with_tokens(Direction::Next)\n+        .filter_map(|it| it.into_token())\n+        .find(|it| it.kind() == T![,])\n+    {\n+        Some(it) => it,\n+        None => {\n+            let comma = ast::make::token(T![,]);\n+            ted::insert(Position::after(syntax), &comma);\n+            comma\n+        }\n+    };\n+    comma\n+}\n+\n impl ast::StmtList {\n     pub fn push_front(&self, statement: ast::Stmt) {\n         ted::insert(Position::after(self.l_curly_token().unwrap()), statement.syntax());\n     }\n }\n \n+impl ast::VariantList {\n+    pub fn add_variant(&self, variant: ast::Variant) {\n+        let (indent, position) = match self.variants().last() {\n+            Some(last_item) => (\n+                IndentLevel::from_node(last_item.syntax()),\n+                Position::after(get_or_insert_comma_after(last_item.syntax())),\n+            ),\n+            None => match self.l_curly_token() {\n+                Some(l_curly) => {\n+                    normalize_ws_between_braces(self.syntax());\n+                    (IndentLevel::from_token(&l_curly) + 1, Position::after(&l_curly))\n+                }\n+                None => (IndentLevel::single(), Position::last_child_of(self.syntax())),\n+            },\n+        };\n+        let elements: Vec<SyntaxElement<_>> = vec![\n+            make::tokens::whitespace(&format!(\"{}{}\", \"\\n\", indent)).into(),\n+            variant.syntax().clone().into(),\n+            ast::make::token(T![,]).into(),\n+        ];\n+        ted::insert_all(position, elements);\n+    }\n+}\n+\n fn normalize_ws_between_braces(node: &SyntaxNode) -> Option<()> {\n     let l = node\n         .children_with_tokens()\n@@ -661,6 +679,9 @@ impl<N: AstNode + Clone> Indent for N {}\n mod tests {\n     use std::fmt;\n \n+    use stdx::trim_indent;\n+    use test_utils::assert_eq_text;\n+\n     use crate::SourceFile;\n \n     use super::*;\n@@ -714,4 +735,100 @@ mod tests {\n         }\",\n         );\n     }\n+\n+    #[test]\n+    fn add_variant_to_empty_enum() {\n+        let variant = make::variant(make::name(\"Bar\"), None).clone_for_update();\n+\n+        check_add_variant(\n+            r#\"\n+enum Foo {}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar,\n+}\n+\"#,\n+            variant,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_variant_to_non_empty_enum() {\n+        let variant = make::variant(make::name(\"Baz\"), None).clone_for_update();\n+\n+        check_add_variant(\n+            r#\"\n+enum Foo {\n+    Bar,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar,\n+    Baz,\n+}\n+\"#,\n+            variant,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_variant_with_tuple_field_list() {\n+        let variant = make::variant(\n+            make::name(\"Baz\"),\n+            Some(ast::FieldList::TupleFieldList(make::tuple_field_list(std::iter::once(\n+                make::tuple_field(None, make::ty(\"bool\")),\n+            )))),\n+        )\n+        .clone_for_update();\n+\n+        check_add_variant(\n+            r#\"\n+enum Foo {\n+    Bar,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar,\n+    Baz(bool),\n+}\n+\"#,\n+            variant,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_variant_with_record_field_list() {\n+        let variant = make::variant(\n+            make::name(\"Baz\"),\n+            Some(ast::FieldList::RecordFieldList(make::record_field_list(std::iter::once(\n+                make::record_field(None, make::name(\"x\"), make::ty(\"bool\")),\n+            )))),\n+        )\n+        .clone_for_update();\n+\n+        check_add_variant(\n+            r#\"\n+enum Foo {\n+    Bar,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar,\n+    Baz { x: bool },\n+}\n+\"#,\n+            variant,\n+        );\n+    }\n+\n+    fn check_add_variant(before: &str, expected: &str, variant: ast::Variant) {\n+        let enum_ = ast_mut_from_text::<ast::Enum>(before);\n+        enum_.variant_list().map(|it| it.add_variant(variant));\n+        let after = enum_.to_string();\n+        assert_eq_text!(&trim_indent(expected.trim()), &trim_indent(&after.trim()));\n+    }\n }"}, {"sha": "037de876d45c94f16955502621129bc2872b2b85", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c03f45c08145be5b1ecd40aa1f28a12c615d63a/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c03f45c08145be5b1ecd40aa1f28a12c615d63a/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=1c03f45c08145be5b1ecd40aa1f28a12c615d63a", "patch": "@@ -745,7 +745,10 @@ pub fn tuple_field(visibility: Option<ast::Visibility>, ty: ast::Type) -> ast::T\n pub fn variant(name: ast::Name, field_list: Option<ast::FieldList>) -> ast::Variant {\n     let field_list = match field_list {\n         None => String::new(),\n-        Some(it) => format!(\"{}\", it),\n+        Some(it) => match it {\n+            ast::FieldList::RecordFieldList(record) => format!(\" {}\", record),\n+            ast::FieldList::TupleFieldList(tuple) => format!(\"{}\", tuple),\n+        },\n     };\n     ast_from_text(&format!(\"enum f {{ {}{} }}\", name, field_list))\n }"}]}