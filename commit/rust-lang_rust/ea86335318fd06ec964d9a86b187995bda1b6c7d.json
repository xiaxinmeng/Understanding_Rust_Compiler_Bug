{"sha": "ea86335318fd06ec964d9a86b187995bda1b6c7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhODYzMzUzMThmZDA2ZWM5NjRkOWE4NmIxODc5OTViZGExYjZjN2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-20T17:35:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-20T17:35:48Z"}, "message": "Auto merge of #1716 - tmiasko:rustup, r=RalfJung\n\nrustup to e7c23ab933ebc1f205c3b59f4ebc85d40f67d404", "tree": {"sha": "e1a4a42eea4b8ef0805b744de5db701d02959b18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1a4a42eea4b8ef0805b744de5db701d02959b18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea86335318fd06ec964d9a86b187995bda1b6c7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea86335318fd06ec964d9a86b187995bda1b6c7d", "html_url": "https://github.com/rust-lang/rust/commit/ea86335318fd06ec964d9a86b187995bda1b6c7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea86335318fd06ec964d9a86b187995bda1b6c7d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "277b59c0b373be0cd1c4448a7539329fa44a04ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/277b59c0b373be0cd1c4448a7539329fa44a04ae", "html_url": "https://github.com/rust-lang/rust/commit/277b59c0b373be0cd1c4448a7539329fa44a04ae"}, {"sha": "0eb341417cc2261a664a83f26b6c04bf1e16e295", "url": "https://api.github.com/repos/rust-lang/rust/commits/0eb341417cc2261a664a83f26b6c04bf1e16e295", "html_url": "https://github.com/rust-lang/rust/commit/0eb341417cc2261a664a83f26b6c04bf1e16e295"}], "stats": {"total": 1007, "additions": 505, "deletions": 502}, "files": [{"sha": "6c6212ec839cc13f8344d28640684dc49c010ca4", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -1 +1 @@\n-d1462d8558cf4551608457f63d9b999185ebf3bf\n+e7c23ab933ebc1f205c3b59f4ebc85d40f67d404"}, {"sha": "dcff896c1f1616dec280c21feb162415415a1538", "filename": "src/data_race.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -446,7 +446,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// Atomic variant of read_scalar_at_offset.\n     fn read_scalar_at_offset_atomic(\n         &self,\n-        op: OpTy<'tcx, Tag>,\n+        op: &OpTy<'tcx, Tag>,\n         offset: u64,\n         layout: TyAndLayout<'tcx>,\n         atomic: AtomicReadOp,\n@@ -458,13 +458,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         // Ensure that the following read at an offset is within bounds.\n         assert!(op_place.layout.size >= offset + layout.size);\n         let value_place = op_place.offset(offset, MemPlaceMeta::None, layout, this)?;\n-        this.read_scalar_atomic(value_place, atomic)\n+        this.read_scalar_atomic(&value_place, atomic)\n     }\n \n     /// Atomic variant of write_scalar_at_offset.\n     fn write_scalar_at_offset_atomic(\n         &mut self,\n-        op: OpTy<'tcx, Tag>,\n+        op: &OpTy<'tcx, Tag>,\n         offset: u64,\n         value: impl Into<ScalarMaybeUninit<Tag>>,\n         layout: TyAndLayout<'tcx>,\n@@ -477,17 +477,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         // Ensure that the following read at an offset is within bounds.\n         assert!(op_place.layout.size >= offset + layout.size);\n         let value_place = op_place.offset(offset, MemPlaceMeta::None, layout, this)?;\n-        this.write_scalar_atomic(value.into(), value_place, atomic)\n+        this.write_scalar_atomic(value.into(), &value_place, atomic)\n     }\n \n     /// Perform an atomic read operation at the memory location.\n     fn read_scalar_atomic(\n         &self,\n-        place: MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Tag>,\n         atomic: AtomicReadOp,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         let this = self.eval_context_ref();\n-        let scalar = this.allow_data_races_ref(move |this| this.read_scalar(place.into()))?;\n+        let scalar = this.allow_data_races_ref(move |this| this.read_scalar(&place.into()))?;\n         self.validate_atomic_load(place, atomic)?;\n         Ok(scalar)\n     }\n@@ -496,31 +496,31 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     fn write_scalar_atomic(\n         &mut self,\n         val: ScalarMaybeUninit<Tag>,\n-        dest: MPlaceTy<'tcx, Tag>,\n+        dest: &MPlaceTy<'tcx, Tag>,\n         atomic: AtomicWriteOp,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        this.allow_data_races_mut(move |this| this.write_scalar(val, dest.into()))?;\n+        this.allow_data_races_mut(move |this| this.write_scalar(val, &(*dest).into()))?;\n         self.validate_atomic_store(dest, atomic)\n     }\n \n     /// Perform a atomic operation on a memory location.\n     fn atomic_op_immediate(\n         &mut self,\n-        place: MPlaceTy<'tcx, Tag>,\n-        rhs: ImmTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Tag>,\n+        rhs: &ImmTy<'tcx, Tag>,\n         op: mir::BinOp,\n         neg: bool,\n         atomic: AtomicRwOp,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n         let this = self.eval_context_mut();\n \n-        let old = this.allow_data_races_mut(|this| this.read_immediate(place.into()))?;\n+        let old = this.allow_data_races_mut(|this| this.read_immediate(&place.into()))?;\n \n         // Atomics wrap around on overflow.\n-        let val = this.binary_op(op, old, rhs)?;\n-        let val = if neg { this.unary_op(mir::UnOp::Not, val)? } else { val };\n-        this.allow_data_races_mut(|this| this.write_immediate(*val, place.into()))?;\n+        let val = this.binary_op(op, &old, rhs)?;\n+        let val = if neg { this.unary_op(mir::UnOp::Not, &val)? } else { val };\n+        this.allow_data_races_mut(|this| this.write_immediate(*val, &(*place).into()))?;\n \n         this.validate_atomic_rmw(place, atomic)?;\n         Ok(old)\n@@ -530,14 +530,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// scalar value, the old value is returned.\n     fn atomic_exchange_scalar(\n         &mut self,\n-        place: MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Tag>,\n         new: ScalarMaybeUninit<Tag>,\n         atomic: AtomicRwOp,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         let this = self.eval_context_mut();\n \n-        let old = this.allow_data_races_mut(|this| this.read_scalar(place.into()))?;\n-        this.allow_data_races_mut(|this| this.write_scalar(new, place.into()))?;\n+        let old = this.allow_data_races_mut(|this| this.read_scalar(&place.into()))?;\n+        this.allow_data_races_mut(|this| this.write_scalar(new, &(*place).into()))?;\n         this.validate_atomic_rmw(place, atomic)?;\n         Ok(old)\n     }\n@@ -550,8 +550,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// identical.\n     fn atomic_compare_exchange_scalar(\n         &mut self,\n-        place: MPlaceTy<'tcx, Tag>,\n-        expect_old: ImmTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Tag>,\n+        expect_old: &ImmTy<'tcx, Tag>,\n         new: ScalarMaybeUninit<Tag>,\n         success: AtomicRwOp,\n         fail: AtomicReadOp,\n@@ -564,9 +564,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         // to read with the failure ordering and if successful then try again with the success\n         // read ordering and write in the success case.\n         // Read as immediate for the sake of `binary_op()`\n-        let old = this.allow_data_races_mut(|this| this.read_immediate(place.into()))?;\n+        let old = this.allow_data_races_mut(|this| this.read_immediate(&(place.into())))?;\n         // `binary_op` will bail if either of them is not a scalar.\n-        let eq = this.overflowing_binary_op(mir::BinOp::Eq, old, expect_old)?.0;\n+        let eq = this.overflowing_binary_op(mir::BinOp::Eq, &old, expect_old)?.0;\n         // If the operation would succeed, but is \"weak\", fail some portion\n         // of the time, based on `rate`.\n         let rate = this.memory.extra.cmpxchg_weak_failure_rate;\n@@ -581,7 +581,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         // if successful, perform a full rw-atomic validation\n         // otherwise treat this as an atomic load with the fail ordering.\n         if cmpxchg_success {\n-            this.allow_data_races_mut(|this| this.write_scalar(new, place.into()))?;\n+            this.allow_data_races_mut(|this| this.write_scalar(new, &(*place).into()))?;\n             this.validate_atomic_rmw(place, success)?;\n         } else {\n             this.validate_atomic_load(place, fail)?;\n@@ -595,7 +595,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// associated memory-place and on the current thread.\n     fn validate_atomic_load(\n         &self,\n-        place: MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Tag>,\n         atomic: AtomicReadOp,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n@@ -617,7 +617,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// associated memory-place and on the current thread.\n     fn validate_atomic_store(\n         &mut self,\n-        place: MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Tag>,\n         atomic: AtomicWriteOp,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n@@ -639,7 +639,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// at the associated memory place and on the current thread.\n     fn validate_atomic_rmw(\n         &mut self,\n-        place: MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Tag>,\n         atomic: AtomicRwOp,\n     ) -> InterpResult<'tcx> {\n         use AtomicRwOp::*;\n@@ -973,7 +973,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// atomic-stores/atomic-rmw?\n     fn validate_atomic_op<A: Debug + Copy>(\n         &self,\n-        place: MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Tag>,\n         atomic: A,\n         description: &str,\n         mut op: impl FnMut("}, {"sha": "7a29d91d2d8ede0b8950afbd66bbc4d4abadef85", "filename": "src/eval.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -138,8 +138,8 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n             ecx.layout_of(tcx.mk_array(tcx.mk_imm_ptr(tcx.types.u8), u64::try_from(argvs.len()).unwrap()))?;\n         let argvs_place = ecx.allocate(argvs_layout, MiriMemoryKind::Machine.into());\n         for (idx, arg) in argvs.into_iter().enumerate() {\n-            let place = ecx.mplace_field(argvs_place, idx)?;\n-            ecx.write_scalar(arg, place.into())?;\n+            let place = ecx.mplace_field(&argvs_place, idx)?;\n+            ecx.write_scalar(arg, &place.into())?;\n         }\n         ecx.memory.mark_immutable(argvs_place.ptr.assert_ptr().alloc_id)?;\n         // A pointer to that place is the 3rd argument for main.\n@@ -148,14 +148,14 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         {\n             let argc_place =\n                 ecx.allocate(ecx.machine.layouts.isize, MiriMemoryKind::Machine.into());\n-            ecx.write_scalar(argc, argc_place.into())?;\n+            ecx.write_scalar(argc, &argc_place.into())?;\n             ecx.machine.argc = Some(argc_place.ptr);\n \n             let argv_place = ecx.allocate(\n                 ecx.layout_of(tcx.mk_imm_ptr(tcx.types.unit))?,\n                 MiriMemoryKind::Machine.into(),\n             );\n-            ecx.write_scalar(argv, argv_place.into())?;\n+            ecx.write_scalar(argv, &argv_place.into())?;\n             ecx.machine.argv = Some(argv_place.ptr);\n         }\n         // Store command line as UTF-16 for Windows `GetCommandLineW`.\n@@ -177,8 +177,8 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n             ecx.machine.cmd_line = Some(cmd_place.ptr);\n             // Store the UTF-16 string. We just allocated so we know the bounds are fine.\n             for (idx, &c) in cmd_utf16.iter().enumerate() {\n-                let place = ecx.mplace_field(cmd_place, idx)?;\n-                ecx.write_scalar(Scalar::from_u16(c), place.into())?;\n+                let place = ecx.mplace_field(&cmd_place, idx)?;\n+                ecx.write_scalar(Scalar::from_u16(c), &place.into())?;\n             }\n         }\n         argv\n@@ -190,7 +190,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     ecx.call_function(\n         start_instance,\n         &[main_ptr.into(), argc.into(), argv.into()],\n-        Some(ret_place.into()),\n+        Some(&ret_place.into()),\n         StackPopCleanup::None { cleanup: true },\n     )?;\n \n@@ -239,7 +239,7 @@ pub fn eval_main<'tcx>(tcx: TyCtxt<'tcx>, main_id: DefId, config: MiriConfig) ->\n             }\n             ecx.process_diagnostics(info);\n         }\n-        let return_code = ecx.read_scalar(ret_place.into())?.check_init()?.to_machine_isize(&ecx)?;\n+        let return_code = ecx.read_scalar(&ret_place.into())?.check_init()?.to_machine_isize(&ecx)?;\n         Ok(return_code)\n     })();\n "}, {"sha": "2baaebb0ae20607c41d1e7aff1c1514fe32cc7d4", "filename": "src/helpers.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -61,7 +61,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let instance = this.resolve_path(path);\n         let cid = GlobalId { instance, promoted: None };\n         let const_val = this.eval_to_allocation(cid)?;\n-        let const_val = this.read_scalar(const_val.into())?;\n+        let const_val = this.read_scalar(&const_val.into())?;\n         return Ok(const_val);\n     }\n \n@@ -106,7 +106,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// Write a 0 of the appropriate size to `dest`.\n-    fn write_null(&mut self, dest: PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+    fn write_null(&mut self, dest: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n         self.eval_context_mut().write_scalar(Scalar::from_int(0, dest.layout.size), dest)\n     }\n \n@@ -162,7 +162,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         f: ty::Instance<'tcx>,\n         args: &[Immediate<Tag>],\n-        dest: Option<PlaceTy<'tcx, Tag>>,\n+        dest: Option<&PlaceTy<'tcx, Tag>>,\n         stack_pop: StackPopCleanup,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -177,7 +177,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             let callee_arg = this.local_place(\n                 callee_args.next().expect(\"callee has fewer arguments than expected\"),\n             )?;\n-            this.write_immediate(*arg, callee_arg)?;\n+            this.write_immediate(*arg, &callee_arg)?;\n         }\n         callee_args.next().expect_none(\"callee has more arguments than expected\");\n \n@@ -188,7 +188,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// will be true if this is frozen, false if this is in an `UnsafeCell`.\n     fn visit_freeze_sensitive(\n         &self,\n-        place: MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Tag>,\n         size: Size,\n         mut action: impl FnMut(Pointer<Tag>, Size, bool) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n@@ -237,7 +237,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     trace!(\"unsafe_cell_action on {:?}\", place.ptr);\n                     // We need a size to go on.\n                     let unsafe_cell_size = this\n-                        .size_and_align_of_mplace(place)?\n+                        .size_and_align_of_mplace(&place)?\n                         .map(|(size, _)| size)\n                         // for extern types, just cover what we can\n                         .unwrap_or_else(|| place.layout.size);\n@@ -261,7 +261,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         /// whether we are inside an `UnsafeCell` or not.\n         struct UnsafeCellVisitor<'ecx, 'mir, 'tcx, F>\n         where\n-            F: FnMut(MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>,\n+            F: FnMut(&MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>,\n         {\n             ecx: &'ecx MiriEvalContext<'mir, 'tcx>,\n             unsafe_cell_action: F,\n@@ -270,7 +270,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         impl<'ecx, 'mir, 'tcx: 'mir, F> ValueVisitor<'mir, 'tcx, Evaluator<'mir, 'tcx>>\n             for UnsafeCellVisitor<'ecx, 'mir, 'tcx, F>\n         where\n-            F: FnMut(MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>,\n+            F: FnMut(&MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>,\n         {\n             type V = MPlaceTy<'tcx, Tag>;\n \n@@ -280,7 +280,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // Hook to detect `UnsafeCell`.\n-            fn visit_value(&mut self, v: MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+            fn visit_value(&mut self, v: &MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n                 trace!(\"UnsafeCellVisitor: {:?} {:?}\", *v, v.layout.ty);\n                 let is_unsafe_cell = match v.layout.ty.kind() {\n                     ty::Adt(adt, _) =>\n@@ -323,7 +323,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Make sure we visit aggregrates in increasing offset order.\n             fn visit_aggregate(\n                 &mut self,\n-                place: MPlaceTy<'tcx, Tag>,\n+                place: &MPlaceTy<'tcx, Tag>,\n                 fields: impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Tag>>>,\n             ) -> InterpResult<'tcx> {\n                 match place.layout.fields {\n@@ -346,7 +346,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n \n-            fn visit_union(&mut self, _v: MPlaceTy<'tcx, Tag>, _fields: NonZeroUsize) -> InterpResult<'tcx> {\n+            fn visit_union(&mut self, _v: &MPlaceTy<'tcx, Tag>, _fields: NonZeroUsize) -> InterpResult<'tcx> {\n                 bug!(\"we should have already handled unions in `visit_value`\")\n             }\n         }\n@@ -356,7 +356,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     // different values into a struct.\n     fn write_packed_immediates(\n         &mut self,\n-        place: MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Tag>,\n         imms: &[ImmTy<'tcx, Tag>],\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -366,7 +366,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         for &imm in imms {\n             this.write_immediate_to_mplace(\n                 *imm,\n-                place.offset(offset, MemPlaceMeta::None, imm.layout, &*this.tcx)?,\n+                &place.offset(offset, MemPlaceMeta::None, imm.layout, &*this.tcx)?,\n             )?;\n             offset += imm.layout.size;\n         }\n@@ -406,7 +406,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Allocate new place, set initial value to 0.\n             let errno_layout = this.machine.layouts.u32;\n             let errno_place = this.allocate(errno_layout, MiriMemoryKind::Machine.into());\n-            this.write_scalar(Scalar::from_u32(0), errno_place.into())?;\n+            this.write_scalar(Scalar::from_u32(0), &errno_place.into())?;\n             this.active_thread_mut().last_error = Some(errno_place);\n             Ok(errno_place)\n         }\n@@ -416,14 +416,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn set_last_error(&mut self, scalar: Scalar<Tag>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let errno_place = this.last_error_place()?;\n-        this.write_scalar(scalar, errno_place.into())\n+        this.write_scalar(scalar, &errno_place.into())\n     }\n \n     /// Gets the last error variable.\n     fn get_last_error(&mut self) -> InterpResult<'tcx, Scalar<Tag>> {\n         let this = self.eval_context_mut();\n         let errno_place = this.last_error_place()?;\n-        this.read_scalar(errno_place.into())?.check_init()\n+        this.read_scalar(&errno_place.into())?.check_init()\n     }\n \n     /// Sets the last OS error using a `std::io::Error`. This function tries to produce the most\n@@ -486,7 +486,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn read_scalar_at_offset(\n         &self,\n-        op: OpTy<'tcx, Tag>,\n+        op: &OpTy<'tcx, Tag>,\n         offset: u64,\n         layout: TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n@@ -496,12 +496,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Ensure that the following read at an offset is within bounds\n         assert!(op_place.layout.size >= offset + layout.size);\n         let value_place = op_place.offset(offset, MemPlaceMeta::None, layout, this)?;\n-        this.read_scalar(value_place.into())\n+        this.read_scalar(&value_place.into())\n     }\n \n     fn write_scalar_at_offset(\n         &mut self,\n-        op: OpTy<'tcx, Tag>,\n+        op: &OpTy<'tcx, Tag>,\n         offset: u64,\n         value: impl Into<ScalarMaybeUninit<Tag>>,\n         layout: TyAndLayout<'tcx>,\n@@ -512,23 +512,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Ensure that the following read at an offset is within bounds\n         assert!(op_place.layout.size >= offset + layout.size);\n         let value_place = op_place.offset(offset, MemPlaceMeta::None, layout, this)?;\n-        this.write_scalar(value, value_place.into())\n+        this.write_scalar(value, &value_place.into())\n     }\n \n     /// Parse a `timespec` struct and return it as a `std::time::Duration`. It returns `None`\n     /// if the value in the `timespec` struct is invalid. Some libc functions will return\n     /// `EINVAL` in this case.\n     fn read_timespec(\n         &mut self,\n-        timespec_ptr_op: OpTy<'tcx, Tag>,\n+        timespec_ptr_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, Option<Duration>> {\n         let this = self.eval_context_mut();\n         let tp = this.deref_operand(timespec_ptr_op)?;\n-        let seconds_place = this.mplace_field(tp, 0)?;\n-        let seconds_scalar = this.read_scalar(seconds_place.into())?;\n+        let seconds_place = this.mplace_field(&tp, 0)?;\n+        let seconds_scalar = this.read_scalar(&seconds_place.into())?;\n         let seconds = seconds_scalar.to_machine_isize(this)?;\n-        let nanoseconds_place = this.mplace_field(tp, 1)?;\n-        let nanoseconds_scalar = this.read_scalar(nanoseconds_place.into())?;\n+        let nanoseconds_place = this.mplace_field(&tp, 1)?;\n+        let nanoseconds_scalar = this.read_scalar(&nanoseconds_place.into())?;\n         let nanoseconds = nanoseconds_scalar.to_machine_isize(this)?;\n \n         Ok(try {"}, {"sha": "32aae4a8c8e51efe938f03f6cd812833c3ee5143", "filename": "src/machine.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -193,7 +193,7 @@ impl MemoryExtra {\n                 // This should be all-zero, pointer-sized.\n                 let layout = this.machine.layouts.usize;\n                 let place = this.allocate(layout, MiriMemoryKind::ExternStatic.into());\n-                this.write_scalar(Scalar::from_machine_usize(0, this), place.into())?;\n+                this.write_scalar(Scalar::from_machine_usize(0, this), &place.into())?;\n                 Self::add_extern_static(this, \"__cxa_thread_atexit_impl\", place.ptr);\n                 // \"environ\"\n                 Self::add_extern_static(this, \"environ\", this.machine.env_vars.environ.unwrap().ptr);\n@@ -203,7 +203,7 @@ impl MemoryExtra {\n                 // This is some obscure hack that is part of the Windows TLS story. It's a `u8`.\n                 let layout = this.machine.layouts.u8;\n                 let place = this.allocate(layout, MiriMemoryKind::ExternStatic.into());\n-                this.write_scalar(Scalar::from_u8(0), place.into())?;\n+                this.write_scalar(Scalar::from_u8(0), &place.into())?;\n                 Self::add_extern_static(this, \"_tls_used\", place.ptr);\n             }\n             _ => {} // No \"extern statics\" supported on this target\n@@ -359,7 +359,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         instance: ty::Instance<'tcx>,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n-        ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         ecx.find_mir_or_eval_fn(instance, abi, args, ret, unwind)\n@@ -371,7 +371,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         fn_val: Dlsym,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n-        ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         ecx.call_dlsym(fn_val, abi, args, ret)\n@@ -382,7 +382,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ecx: &mut rustc_mir::interpret::InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n-        ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         ecx.call_intrinsic(instance, args, ret, unwind)\n@@ -406,15 +406,15 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     fn binary_ptr_op(\n         ecx: &rustc_mir::interpret::InterpCx<'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n-        left: ImmTy<'tcx, Tag>,\n-        right: ImmTy<'tcx, Tag>,\n+        left: &ImmTy<'tcx, Tag>,\n+        right: &ImmTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, (Scalar<Tag>, bool, ty::Ty<'tcx>)> {\n         ecx.binary_ptr_op(bin_op, left, right)\n     }\n \n     fn box_alloc(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        dest: PlaceTy<'tcx, Tag>,\n+        dest: &PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"box_alloc for {:?}\", dest.layout.ty);\n         let layout = ecx.layout_of(dest.layout.ty.builtin_deref(false).unwrap().ty)?;\n@@ -542,7 +542,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     fn retag(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         kind: mir::RetagKind,\n-        place: PlaceTy<'tcx, Tag>,\n+        place: &PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         if ecx.memory.extra.stacked_borrows.is_some() {\n             ecx.retag(kind, place)"}, {"sha": "cf92aed9ccb2c5edcf98e451e042f56b142198e3", "filename": "src/operator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -8,8 +8,8 @@ pub trait EvalContextExt<'tcx> {\n     fn binary_ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: ImmTy<'tcx, Tag>,\n-        right: ImmTy<'tcx, Tag>,\n+        left: &ImmTy<'tcx, Tag>,\n+        right: &ImmTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, (Scalar<Tag>, bool, Ty<'tcx>)>;\n \n     fn ptr_eq(&self, left: Scalar<Tag>, right: Scalar<Tag>) -> InterpResult<'tcx, bool>;\n@@ -19,8 +19,8 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n     fn binary_ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: ImmTy<'tcx, Tag>,\n-        right: ImmTy<'tcx, Tag>,\n+        left: &ImmTy<'tcx, Tag>,\n+        right: &ImmTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, (Scalar<Tag>, bool, Ty<'tcx>)> {\n         use rustc_middle::mir::BinOp::*;\n \n@@ -30,7 +30,7 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n             Eq | Ne => {\n                 // This supports fat pointers.\n                 #[rustfmt::skip]\n-                let eq = match (*left, *right) {\n+                let eq = match (**left, **right) {\n                     (Immediate::Scalar(left), Immediate::Scalar(right)) => {\n                         self.ptr_eq(left.check_init()?, right.check_init()?)?\n                     }"}, {"sha": "159a0bc1f8cdf6e013740254d9deb1fa35a6cf36", "filename": "src/shims/backtrace.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fbacktrace.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -13,11 +13,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn handle_miri_get_backtrace(\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n-        dest: PlaceTy<'tcx, Tag>\n+        dest: &PlaceTy<'tcx, Tag>\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let tcx = this.tcx;\n-        let &[flags] = check_arg_count(args)?;\n+        let &[ref flags] = check_arg_count(args)?;\n \n         let flags = this.read_scalar(flags)?.to_u64()?;\n         if flags != 0 {\n@@ -59,8 +59,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Write pointers into array\n         let alloc = this.allocate(this.layout_of(array_ty).unwrap(), MiriMemoryKind::Rust.into());\n         for (i, ptr) in ptrs.into_iter().enumerate() {\n-            let place = this.mplace_index(alloc, i as u64)?;\n-            this.write_immediate_to_mplace(ptr.into(), place)?;\n+            let place = this.mplace_index(&alloc, i as u64)?;\n+            this.write_immediate_to_mplace(ptr.into(), &place)?;\n         }\n \n         this.write_immediate(Immediate::new_slice(alloc.ptr.into(), len.try_into().unwrap(), this), dest)?;\n@@ -70,11 +70,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn handle_miri_resolve_frame(\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n-        dest: PlaceTy<'tcx, Tag>\n+        dest: &PlaceTy<'tcx, Tag>\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let tcx = this.tcx;\n-        let &[ptr, flags] = check_arg_count(args)?;\n+        let &[ref ptr, ref flags] = check_arg_count(args)?;\n \n         let flags = this.read_scalar(flags)?.to_u64()?;\n         if flags != 0 {\n@@ -125,15 +125,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         }\n \n-        this.write_immediate(name_alloc.to_ref(), this.mplace_field(dest, 0)?.into())?;\n-        this.write_immediate(filename_alloc.to_ref(), this.mplace_field(dest, 1)?.into())?;\n-        this.write_scalar(lineno_alloc, this.mplace_field(dest, 2)?.into())?;\n-        this.write_scalar(colno_alloc, this.mplace_field(dest, 3)?.into())?;\n+        this.write_immediate(name_alloc.to_ref(), &this.mplace_field(&dest, 0)?.into())?;\n+        this.write_immediate(filename_alloc.to_ref(), &this.mplace_field(&dest, 1)?.into())?;\n+        this.write_scalar(lineno_alloc, &this.mplace_field(&dest, 2)?.into())?;\n+        this.write_scalar(colno_alloc, &this.mplace_field(&dest, 3)?.into())?;\n \n         // Support a 4-field struct for now - this is deprecated\n         // and slated for removal.\n         if num_fields == 5 {\n-            this.write_scalar(fn_ptr, this.mplace_field(dest, 4)?.into())?;\n+            this.write_scalar(fn_ptr, &this.mplace_field(&dest, 4)?.into())?;\n         }\n \n         Ok(())"}, {"sha": "e45556f9a1d135d2eeb3f18629ddbdb46ddb3e8b", "filename": "src/shims/dlsym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fdlsym.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -32,7 +32,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         dlsym: Dlsym,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n-        ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         match dlsym {"}, {"sha": "53770fd4f05ba45b9564c048831d5e192e1944b3", "filename": "src/shims/env.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -69,7 +69,7 @@ impl<'tcx> EnvVars<'tcx> {\n         }\n         // Deallocate environ var list.\n         let environ = ecx.machine.env_vars.environ.unwrap();\n-        let old_vars_ptr = ecx.read_scalar(environ.into())?.check_init()?;\n+        let old_vars_ptr = ecx.read_scalar(&environ.into())?.check_init()?;\n         ecx.memory.deallocate(ecx.force_ptr(old_vars_ptr)?, None, MiriMemoryKind::Env.into())?;\n         Ok(())\n     }\n@@ -99,7 +99,7 @@ fn alloc_env_var_as_wide_str<'mir, 'tcx>(\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    fn getenv(&mut self, name_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, Scalar<Tag>> {\n+    fn getenv(&mut self, name_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, Scalar<Tag>> {\n         let this = self.eval_context_mut();\n         let target_os = &this.tcx.sess.target.os;\n         assert!(target_os == \"linux\" || target_os == \"macos\", \"`getenv` is only available for the UNIX target family\");\n@@ -118,9 +118,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn GetEnvironmentVariableW(\n         &mut self,\n-        name_op: OpTy<'tcx, Tag>,  // LPCWSTR\n-        buf_op: OpTy<'tcx, Tag>,   // LPWSTR\n-        size_op: OpTy<'tcx, Tag>,  // DWORD\n+        name_op: &OpTy<'tcx, Tag>,  // LPCWSTR\n+        buf_op: &OpTy<'tcx, Tag>,   // LPWSTR\n+        size_op: &OpTy<'tcx, Tag>,  // DWORD\n     ) -> InterpResult<'tcx, u32> { // Returns DWORD (u32 in Windows)\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"GetEnvironmentVariableW\");\n@@ -169,7 +169,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[allow(non_snake_case)]\n-    fn FreeEnvironmentStringsW(&mut self, env_block_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn FreeEnvironmentStringsW(&mut self, env_block_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"FreeEnvironmentStringsW\");\n \n@@ -181,8 +181,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn setenv(\n         &mut self,\n-        name_op: OpTy<'tcx, Tag>,\n-        value_op: OpTy<'tcx, Tag>,\n+        name_op: &OpTy<'tcx, Tag>,\n+        value_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let mut this = self.eval_context_mut();\n         let target_os = &this.tcx.sess.target.os;\n@@ -218,8 +218,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn SetEnvironmentVariableW(\n         &mut self,\n-        name_op: OpTy<'tcx, Tag>,  // LPCWSTR\n-        value_op: OpTy<'tcx, Tag>, // LPCWSTR\n+        name_op: &OpTy<'tcx, Tag>,  // LPCWSTR\n+        value_op: &OpTy<'tcx, Tag>, // LPCWSTR\n     ) -> InterpResult<'tcx, i32> {\n         let mut this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"SetEnvironmentVariableW\");\n@@ -256,7 +256,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn unsetenv(&mut self, name_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn unsetenv(&mut self, name_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         let target_os = &this.tcx.sess.target.os;\n         assert!(target_os == \"linux\" || target_os == \"macos\", \"`unsetenv` is only available for the UNIX target family\");\n@@ -286,17 +286,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn getcwd(\n         &mut self,\n-        buf_op: OpTy<'tcx, Tag>,\n-        size_op: OpTy<'tcx, Tag>,\n+        buf_op: &OpTy<'tcx, Tag>,\n+        size_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, Scalar<Tag>> {\n         let this = self.eval_context_mut();\n         let target_os = &this.tcx.sess.target.os;\n         assert!(target_os == \"linux\" || target_os == \"macos\", \"`getcwd` is only available for the UNIX target family\");\n \n         this.check_no_isolation(\"`getcwd`\")?;\n \n-        let buf = this.read_scalar(buf_op)?.check_init()?;\n-        let size = this.read_scalar(size_op)?.to_machine_usize(&*this.tcx)?;\n+        let buf = this.read_scalar(&buf_op)?.check_init()?;\n+        let size = this.read_scalar(&size_op)?.to_machine_usize(&*this.tcx)?;\n         // If we cannot get the current directory, we return null\n         match env::current_dir() {\n             Ok(cwd) => {\n@@ -314,8 +314,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn GetCurrentDirectoryW(\n         &mut self,\n-        size_op: OpTy<'tcx, Tag>, // DWORD\n-        buf_op: OpTy<'tcx, Tag>,  // LPTSTR\n+        size_op: &OpTy<'tcx, Tag>, // DWORD\n+        buf_op: &OpTy<'tcx, Tag>,  // LPTSTR\n     ) -> InterpResult<'tcx, u32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"GetCurrentDirectoryW\");\n@@ -334,7 +334,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn chdir(&mut self, path_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn chdir(&mut self, path_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         let target_os = &this.tcx.sess.target.os;\n         assert!(target_os == \"linux\" || target_os == \"macos\", \"`getcwd` is only available for the UNIX target family\");\n@@ -355,7 +355,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn SetCurrentDirectoryW (\n         &mut self,\n-        path_op: OpTy<'tcx, Tag>   // LPCTSTR\n+        path_op: &OpTy<'tcx, Tag>   // LPCTSTR\n     ) -> InterpResult<'tcx, i32> { // Returns BOOL (i32 in Windows)\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"SetCurrentDirectoryW\");\n@@ -379,7 +379,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         // Deallocate the old environ list, if any.\n         if let Some(environ) = this.machine.env_vars.environ {\n-            let old_vars_ptr = this.read_scalar(environ.into())?.check_init()?;\n+            let old_vars_ptr = this.read_scalar(&environ.into())?.check_init()?;\n             this.memory.deallocate(this.force_ptr(old_vars_ptr)?, None, MiriMemoryKind::Env.into())?;\n         } else {\n             // No `environ` allocated yet, let's do that.\n@@ -399,12 +399,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.layout_of(tcx.mk_array(tcx.types.usize, u64::try_from(vars.len()).unwrap()))?;\n         let vars_place = this.allocate(vars_layout, MiriMemoryKind::Env.into());\n         for (idx, var) in vars.into_iter().enumerate() {\n-            let place = this.mplace_field(vars_place, idx)?;\n-            this.write_scalar(var, place.into())?;\n+            let place = this.mplace_field(&vars_place, idx)?;\n+            this.write_scalar(var, &place.into())?;\n         }\n         this.write_scalar(\n             vars_place.ptr,\n-            this.machine.env_vars.environ.unwrap().into(),\n+            &this.machine.env_vars.environ.unwrap().into(),\n         )?;\n \n         Ok(())"}, {"sha": "9203aafd576733784c689c242be813f9afefba89", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -114,7 +114,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         def_id: DefId,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n-        ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         let this = self.eval_context_mut();\n@@ -147,7 +147,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 | \"ExitProcess\"\n                 => {\n                     check_abi(abi, if link_name == \"exit\" { Abi::C } else { Abi::System })?;\n-                    let &[code] = check_arg_count(args)?;\n+                    let &[ref code] = check_arg_count(args)?;\n                     // it's really u32 for ExitProcess, but we have to put it into the `Exit` variant anyway\n                     let code = this.read_scalar(code)?.to_i32()?;\n                     throw_machine_stop!(TerminationInfo::Exit(code.into()));\n@@ -186,7 +186,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Third: functions that return.\n         if this.emulate_foreign_item_by_name(link_name, abi, args, dest, ret)? {\n-            trace!(\"{:?}\", this.dump_place(*dest));\n+            trace!(\"{:?}\", this.dump_place(**dest));\n             this.go_to_block(ret);\n         }\n \n@@ -201,7 +201,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         link_name: &str,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n-        dest: PlaceTy<'tcx, Tag>,\n+        dest: &PlaceTy<'tcx, Tag>,\n         ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n@@ -212,7 +212,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Miri-specific extern functions\n             \"miri_static_root\" => {\n                 check_abi(abi, Abi::Rust)?;\n-                let &[ptr] = check_arg_count(args)?;\n+                let &[ref ptr] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let ptr = this.force_ptr(ptr)?;\n                 if ptr.offset != Size::ZERO {\n@@ -237,14 +237,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Standard C allocation\n             \"malloc\" => {\n                 check_abi(abi, Abi::C)?;\n-                let &[size] = check_arg_count(args)?;\n+                let &[ref size] = check_arg_count(args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let res = this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n             \"calloc\" => {\n                 check_abi(abi, Abi::C)?;\n-                let &[items, len] = check_arg_count(args)?;\n+                let &[ref items, ref len] = check_arg_count(args)?;\n                 let items = this.read_scalar(items)?.to_machine_usize(this)?;\n                 let len = this.read_scalar(len)?.to_machine_usize(this)?;\n                 let size =\n@@ -254,13 +254,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"free\" => {\n                 check_abi(abi, Abi::C)?;\n-                let &[ptr] = check_arg_count(args)?;\n+                let &[ref ptr] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 this.free(ptr, MiriMemoryKind::C)?;\n             }\n             \"realloc\" => {\n                 check_abi(abi, Abi::C)?;\n-                let &[old_ptr, new_size] = check_arg_count(args)?;\n+                let &[ref old_ptr, ref new_size] = check_arg_count(args)?;\n                 let old_ptr = this.read_scalar(old_ptr)?.check_init()?;\n                 let new_size = this.read_scalar(new_size)?.to_machine_usize(this)?;\n                 let res = this.realloc(old_ptr, new_size, MiriMemoryKind::C)?;\n@@ -272,7 +272,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // allocation that also checks that all conditions are met, such as not permitting zero-sized allocations.)\n             \"__rust_alloc\" => {\n                 check_abi(abi, Abi::Rust)?;\n-                let &[size, align] = check_arg_count(args)?;\n+                let &[ref size, ref align] = check_arg_count(args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n                 Self::check_alloc_request(size, align)?;\n@@ -285,7 +285,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"__rust_alloc_zeroed\" => {\n                 check_abi(abi, Abi::Rust)?;\n-                let &[size, align] = check_arg_count(args)?;\n+                let &[ref size, ref align] = check_arg_count(args)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n                 Self::check_alloc_request(size, align)?;\n@@ -300,7 +300,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"__rust_dealloc\" => {\n                 check_abi(abi, Abi::Rust)?;\n-                let &[ptr, old_size, align] = check_arg_count(args)?;\n+                let &[ref ptr, ref old_size, ref align] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n@@ -314,7 +314,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"__rust_realloc\" => {\n                 check_abi(abi, Abi::Rust)?;\n-                let &[ptr, old_size, align, new_size] = check_arg_count(args)?;\n+                let &[ref ptr, ref old_size, ref align, ref new_size] = check_arg_count(args)?;\n                 let ptr = this.force_ptr(this.read_scalar(ptr)?.check_init()?)?;\n                 let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n@@ -335,7 +335,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // C memory handling functions\n             \"memcmp\" => {\n                 check_abi(abi, Abi::C)?;\n-                let &[left, right, n] = check_arg_count(args)?;\n+                let &[ref left, ref right, ref n] = check_arg_count(args)?;\n                 let left = this.read_scalar(left)?.check_init()?;\n                 let right = this.read_scalar(right)?.check_init()?;\n                 let n = Size::from_bytes(this.read_scalar(n)?.to_machine_usize(this)?);\n@@ -356,7 +356,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"memrchr\" => {\n                 check_abi(abi, Abi::C)?;\n-                let &[ptr, val, num] = check_arg_count(args)?;\n+                let &[ref ptr, ref val, ref num] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let val = this.read_scalar(val)?.to_i32()? as u8;\n                 let num = this.read_scalar(num)?.to_machine_usize(this)?;\n@@ -375,7 +375,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"memchr\" => {\n                 check_abi(abi, Abi::C)?;\n-                let &[ptr, val, num] = check_arg_count(args)?;\n+                let &[ref ptr, ref val, ref num] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let val = this.read_scalar(val)?.to_i32()? as u8;\n                 let num = this.read_scalar(num)?.to_machine_usize(this)?;\n@@ -393,7 +393,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"strlen\" => {\n                 check_abi(abi, Abi::C)?;\n-                let &[ptr] = check_arg_count(args)?;\n+                let &[ref ptr] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let n = this.memory.read_c_str(ptr)?.len();\n                 this.write_scalar(Scalar::from_machine_usize(u64::try_from(n).unwrap(), this), dest)?;\n@@ -409,7 +409,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"atanf\"\n             => {\n                 check_abi(abi, Abi::C)?;\n-                let &[f] = check_arg_count(args)?;\n+                let &[ref f] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n                 let f = match link_name {\n@@ -429,7 +429,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"atan2f\"\n             => {\n                 check_abi(abi, Abi::C)?;\n-                let &[f1, f2] = check_arg_count(args)?;\n+                let &[ref f1, ref f2] = check_arg_count(args)?;\n                 // underscore case for windows, here and below\n                 // (see https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/floating-point-primitives?view=vs-2019)\n                 // FIXME: Using host floats.\n@@ -451,7 +451,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"atan\"\n             => {\n                 check_abi(abi, Abi::C)?;\n-                let &[f] = check_arg_count(args)?;\n+                let &[ref f] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n                 let f = match link_name {\n@@ -471,7 +471,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"atan2\"\n             => {\n                 check_abi(abi, Abi::C)?;\n-                let &[f1, f2] = check_arg_count(args)?;\n+                let &[ref f1, ref f2] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f1 = f64::from_bits(this.read_scalar(f1)?.to_u64()?);\n                 let f2 = f64::from_bits(this.read_scalar(f2)?.to_u64()?);\n@@ -487,7 +487,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"scalbn\"\n             => {\n                 check_abi(abi, Abi::C)?;\n-                let &[x, exp] = check_arg_count(args)?;\n+                let &[ref x, ref exp] = check_arg_count(args)?;\n                 // For radix-2 (binary) systems, `ldexp` and `scalbn` are the same.\n                 let x = this.read_scalar(x)?.to_f64()?;\n                 let exp = this.read_scalar(exp)?.to_i32()?;\n@@ -514,7 +514,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"llvm.aarch64.hint\" if this.tcx.sess.target.arch == \"aarch64\" => {\n                 check_abi(abi, Abi::C)?;\n-                let &[hint] = check_arg_count(args)?;\n+                let &[ref hint] = check_arg_count(args)?;\n                 let hint = this.read_scalar(hint)?.to_i32()?;\n                 match hint {\n                     1 => { // HINT_YIELD"}, {"sha": "33aa7b28bb5b53ce769271ecd3be1215563d4fa9", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -16,7 +16,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n-        ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -36,32 +36,32 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match intrinsic_name {\n             // Miri overwriting CTFE intrinsics.\n             \"ptr_guaranteed_eq\" => {\n-                let &[left, right] = check_arg_count(args)?;\n+                let &[ref left, ref right] = check_arg_count(args)?;\n                 let left = this.read_immediate(left)?;\n                 let right = this.read_immediate(right)?;\n-                this.binop_ignore_overflow(mir::BinOp::Eq, left, right, dest)?;\n+                this.binop_ignore_overflow(mir::BinOp::Eq, &left, &right, dest)?;\n             }\n             \"ptr_guaranteed_ne\" => {\n-                let &[left, right] = check_arg_count(args)?;\n+                let &[ref left, ref right] = check_arg_count(args)?;\n                 let left = this.read_immediate(left)?;\n                 let right = this.read_immediate(right)?;\n-                this.binop_ignore_overflow(mir::BinOp::Ne, left, right, dest)?;\n+                this.binop_ignore_overflow(mir::BinOp::Ne, &left, &right, dest)?;\n             }\n \n             // Raw memory accesses\n             \"volatile_load\" => {\n-                let &[place] = check_arg_count(args)?;\n+                let &[ref place] = check_arg_count(args)?;\n                 let place = this.deref_operand(place)?;\n-                this.copy_op(place.into(), dest)?;\n+                this.copy_op(&place.into(), dest)?;\n             }\n             \"volatile_store\" => {\n-                let &[place, dest] = check_arg_count(args)?;\n+                let &[ref place, ref dest] = check_arg_count(args)?;\n                 let place = this.deref_operand(place)?;\n-                this.copy_op(dest, place.into())?;\n+                this.copy_op(dest, &place.into())?;\n             }\n \n             \"write_bytes\" => {\n-                let &[ptr, val_byte, count] = check_arg_count(args)?;\n+                let &[ref ptr, ref val_byte, ref count] = check_arg_count(args)?;\n                 let ty = instance.substs.type_at(0);\n                 let ty_layout = this.layout_of(ty)?;\n                 let val_byte = this.read_scalar(val_byte)?.to_u8()?;\n@@ -89,7 +89,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"truncf32\"\n             | \"roundf32\"\n             => {\n-                let &[f] = check_arg_count(args)?;\n+                let &[ref f] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n                 let f = match intrinsic_name {\n@@ -126,7 +126,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"truncf64\"\n             | \"roundf64\"\n             => {\n-                let &[f] = check_arg_count(args)?;\n+                let &[ref f] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n                 let f = match intrinsic_name {\n@@ -155,7 +155,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"fdiv_fast\"\n             | \"frem_fast\"\n             => {\n-                let &[a, b] = check_arg_count(args)?;\n+                let &[ref a, ref b] = check_arg_count(args)?;\n                 let a = this.read_immediate(a)?;\n                 let b = this.read_immediate(b)?;\n                 let op = match intrinsic_name {\n@@ -166,15 +166,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     \"frem_fast\" => mir::BinOp::Rem,\n                     _ => bug!(),\n                 };\n-                this.binop_ignore_overflow(op, a, b, dest)?;\n+                this.binop_ignore_overflow(op, &a, &b, dest)?;\n             }\n \n             #[rustfmt::skip]\n             | \"minnumf32\"\n             | \"maxnumf32\"\n             | \"copysignf32\"\n             => {\n-                let &[a, b] = check_arg_count(args)?;\n+                let &[ref a, ref b] = check_arg_count(args)?;\n                 let a = this.read_scalar(a)?.to_f32()?;\n                 let b = this.read_scalar(b)?.to_f32()?;\n                 let res = match intrinsic_name {\n@@ -191,7 +191,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"maxnumf64\"\n             | \"copysignf64\"\n             => {\n-                let &[a, b] = check_arg_count(args)?;\n+                let &[ref a, ref b] = check_arg_count(args)?;\n                 let a = this.read_scalar(a)?.to_f64()?;\n                 let b = this.read_scalar(b)?.to_f64()?;\n                 let res = match intrinsic_name {\n@@ -204,23 +204,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"powf32\" => {\n-                let &[f, f2] = check_arg_count(args)?;\n+                let &[ref f, ref f2] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n                 let f2 = f32::from_bits(this.read_scalar(f2)?.to_u32()?);\n                 this.write_scalar(Scalar::from_u32(f.powf(f2).to_bits()), dest)?;\n             }\n \n             \"powf64\" => {\n-                let &[f, f2] = check_arg_count(args)?;\n+                let &[ref f, ref f2] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n                 let f2 = f64::from_bits(this.read_scalar(f2)?.to_u64()?);\n                 this.write_scalar(Scalar::from_u64(f.powf(f2).to_bits()), dest)?;\n             }\n \n             \"fmaf32\" => {\n-                let &[a, b, c] = check_arg_count(args)?;\n+                let &[ref a, ref b, ref c] = check_arg_count(args)?;\n                 let a = this.read_scalar(a)?.to_f32()?;\n                 let b = this.read_scalar(b)?.to_f32()?;\n                 let c = this.read_scalar(c)?.to_f32()?;\n@@ -229,7 +229,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"fmaf64\" => {\n-                let &[a, b, c] = check_arg_count(args)?;\n+                let &[ref a, ref b, ref c] = check_arg_count(args)?;\n                 let a = this.read_scalar(a)?.to_f64()?;\n                 let b = this.read_scalar(b)?.to_f64()?;\n                 let c = this.read_scalar(c)?.to_f64()?;\n@@ -238,23 +238,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"powif32\" => {\n-                let &[f, i] = check_arg_count(args)?;\n+                let &[ref f, ref i] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n                 let i = this.read_scalar(i)?.to_i32()?;\n                 this.write_scalar(Scalar::from_u32(f.powi(i).to_bits()), dest)?;\n             }\n \n             \"powif64\" => {\n-                let &[f, i] = check_arg_count(args)?;\n+                let &[ref f, ref i] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n                 let i = this.read_scalar(i)?.to_i32()?;\n                 this.write_scalar(Scalar::from_u64(f.powi(i).to_bits()), dest)?;\n             }\n \n             \"float_to_int_unchecked\" => {\n-                let &[val] = check_arg_count(args)?;\n+                let &[ref val] = check_arg_count(args)?;\n                 let val = this.read_immediate(val)?;\n \n                 let res = match val.layout.ty.kind() {\n@@ -404,32 +404,32 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Other\n             \"exact_div\" => {\n-                let &[num, denom] = check_arg_count(args)?;\n-                this.exact_div(this.read_immediate(num)?, this.read_immediate(denom)?, dest)?;\n+                let &[ref num, ref denom] = check_arg_count(args)?;\n+                this.exact_div(&this.read_immediate(num)?, &this.read_immediate(denom)?, dest)?;\n             }\n \n             \"try\" => return this.handle_try(args, dest, ret),\n \n             name => throw_unsup_format!(\"unimplemented intrinsic: {}\", name),\n         }\n \n-        trace!(\"{:?}\", this.dump_place(*dest));\n+        trace!(\"{:?}\", this.dump_place(**dest));\n         this.go_to_block(ret);\n         Ok(())\n     }\n \n     fn atomic_load(\n-        &mut self, args: &[OpTy<'tcx, Tag>], dest: PlaceTy<'tcx, Tag>,\n+        &mut self, args: &[OpTy<'tcx, Tag>], dest: &PlaceTy<'tcx, Tag>,\n         atomic: AtomicReadOp\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n \n-        let &[place] = check_arg_count(args)?;\n+        let &[ref place] = check_arg_count(args)?;\n         let place = this.deref_operand(place)?;\n \n         // make sure it fits into a scalar; otherwise it cannot be atomic\n-        let val = this.read_scalar_atomic(place, atomic)?;\n+        let val = this.read_scalar_atomic(&place, atomic)?;\n \n         // Check alignment requirements. Atomics must always be aligned to their size,\n         // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n@@ -443,7 +443,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn atomic_store(&mut self, args: &[OpTy<'tcx, Tag>], atomic: AtomicWriteOp) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        let &[place, val] = check_arg_count(args)?;\n+        let &[ref place, ref val] = check_arg_count(args)?;\n         let place = this.deref_operand(place)?;\n         let val = this.read_scalar(val)?; // make sure it fits into a scalar; otherwise it cannot be atomic\n \n@@ -454,7 +454,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n \n         // Perform atomic store\n-        this.write_scalar_atomic(val, place, atomic)?;\n+        this.write_scalar_atomic(val, &place, atomic)?;\n         Ok(())\n     }\n \n@@ -473,12 +473,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     fn atomic_op(\n-        &mut self, args: &[OpTy<'tcx, Tag>], dest: PlaceTy<'tcx, Tag>,\n+        &mut self, args: &[OpTy<'tcx, Tag>], dest: &PlaceTy<'tcx, Tag>,\n         op: mir::BinOp, neg: bool, atomic: AtomicRwOp\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        let &[place, rhs] = check_arg_count(args)?;\n+        let &[ref place, ref rhs] = check_arg_count(args)?;\n         let place = this.deref_operand(place)?;\n         if !place.layout.ty.is_integral() {\n             bug!(\"Atomic arithmetic operations only work on integer types\");\n@@ -491,17 +491,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n         this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n         \n-        let old = this.atomic_op_immediate(place, rhs, op, neg, atomic)?;\n+        let old = this.atomic_op_immediate(&place, &rhs, op, neg, atomic)?;\n         this.write_immediate(*old, dest)?; // old value is returned\n         Ok(())\n     }\n     \n     fn atomic_exchange(\n-        &mut self, args: &[OpTy<'tcx, Tag>], dest: PlaceTy<'tcx, Tag>, atomic: AtomicRwOp\n+        &mut self, args: &[OpTy<'tcx, Tag>], dest: &PlaceTy<'tcx, Tag>, atomic: AtomicRwOp\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        let &[place, new] = check_arg_count(args)?;\n+        let &[ref place, ref new] = check_arg_count(args)?;\n         let place = this.deref_operand(place)?;\n         let new = this.read_scalar(new)?;\n \n@@ -511,18 +511,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n         this.memory.check_ptr_access(place.ptr, place.layout.size, align)?;\n \n-        let old = this.atomic_exchange_scalar(place, new, atomic)?;\n+        let old = this.atomic_exchange_scalar(&place, new, atomic)?;\n         this.write_scalar(old, dest)?; // old value is returned\n         Ok(())\n     }\n \n     fn atomic_compare_exchange_impl(\n-        &mut self, args: &[OpTy<'tcx, Tag>], dest: PlaceTy<'tcx, Tag>,\n+        &mut self, args: &[OpTy<'tcx, Tag>], dest: &PlaceTy<'tcx, Tag>,\n         success: AtomicRwOp, fail: AtomicReadOp, can_fail_spuriously: bool\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        let &[place, expect_old, new] = check_arg_count(args)?;\n+        let &[ref place, ref expect_old, ref new] = check_arg_count(args)?;\n         let place = this.deref_operand(place)?;\n         let expect_old = this.read_immediate(expect_old)?; // read as immediate for the sake of `binary_op()`\n         let new = this.read_scalar(new)?;\n@@ -536,7 +536,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         \n         let old = this.atomic_compare_exchange_scalar(\n-            place, expect_old, new, success, fail, can_fail_spuriously\n+            &place, &expect_old, new, success, fail, can_fail_spuriously\n         )?;\n \n         // Return old value.\n@@ -545,14 +545,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     fn atomic_compare_exchange(\n-        &mut self, args: &[OpTy<'tcx, Tag>], dest: PlaceTy<'tcx, Tag>,\n+        &mut self, args: &[OpTy<'tcx, Tag>], dest: &PlaceTy<'tcx, Tag>,\n         success: AtomicRwOp, fail: AtomicReadOp\n     ) -> InterpResult<'tcx> {\n         self.atomic_compare_exchange_impl(args, dest, success, fail, false)\n     }\n \n     fn atomic_compare_exchange_weak(\n-        &mut self, args: &[OpTy<'tcx, Tag>], dest: PlaceTy<'tcx, Tag>,\n+        &mut self, args: &[OpTy<'tcx, Tag>], dest: &PlaceTy<'tcx, Tag>,\n         success: AtomicRwOp, fail: AtomicReadOp\n     ) -> InterpResult<'tcx> {\n         self.atomic_compare_exchange_impl(args, dest, success, fail, true)"}, {"sha": "1605ea2f6a894ba766d2966d7ea6acaa8f90f9f5", "filename": "src/shims/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -28,15 +28,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         instance: ty::Instance<'tcx>,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n-        ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         let this = self.eval_context_mut();\n-        trace!(\"eval_fn_call: {:#?}, {:?}\", instance, ret.map(|p| *p.0));\n+        trace!(\"eval_fn_call: {:#?}, {:?}\", instance, ret.map(|p| p.0));\n \n         // There are some more lang items we want to hook that CTFE does not hook (yet).\n         if this.tcx.lang_items().align_offset_fn() == Some(instance.def.def_id()) {\n-            let &[ptr, align] = check_arg_count(args)?;\n+            let &[ref ptr, ref align] = check_arg_count(args)?;\n             if this.align_offset(ptr, align, ret, unwind)? {\n                 return Ok(None);\n             }\n@@ -61,9 +61,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// the actual MIR of `align_offset`.\n     fn align_offset(\n         &mut self,\n-        ptr_op: OpTy<'tcx, Tag>,\n-        align_op: OpTy<'tcx, Tag>,\n-        ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n+        ptr_op: &OpTy<'tcx, Tag>,\n+        align_op: &OpTy<'tcx, Tag>,\n+        ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();"}, {"sha": "abc7aa2ad1bdc64f08edaf269f2ab6631ffc6fce", "filename": "src/shims/panic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -48,7 +48,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         assert_eq!(this.tcx.sess.panic_strategy(), PanicStrategy::Unwind);\n \n         // Get the raw pointer stored in arg[0] (the panic payload).\n-        let &[payload] = check_arg_count(args)?;\n+        let &[ref payload] = check_arg_count(args)?;\n         let payload = this.read_scalar(payload)?.check_init()?;\n         let thread = this.active_thread_mut();\n         assert!(\n@@ -66,7 +66,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn handle_try(\n         &mut self,\n         args: &[OpTy<'tcx, Tag>],\n-        dest: PlaceTy<'tcx, Tag>,\n+        dest: &PlaceTy<'tcx, Tag>,\n         ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -83,7 +83,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // a pointer to `Box<dyn Any + Send + 'static>`.\n \n         // Get all the arguments.\n-        let &[try_fn, data, catch_fn] = check_arg_count(args)?;\n+        let &[ref try_fn, ref data, ref catch_fn] = check_arg_count(args)?;\n         let try_fn = this.read_scalar(try_fn)?.check_init()?;\n         let data = this.read_scalar(data)?.check_init()?;\n         let catch_fn = this.read_scalar(catch_fn)?.check_init()?;\n@@ -95,7 +95,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.call_function(\n             f_instance,\n             &[data.into()],\n-            Some(ret_place),\n+            Some(&ret_place),\n             // Directly return to caller.\n             StackPopCleanup::Goto { ret: Some(ret), unwind: None },\n         )?;\n@@ -107,7 +107,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // This lets `handle_stack_pop` (below) know that we should stop unwinding\n         // when we pop this frame.\n         if this.tcx.sess.panic_strategy() == PanicStrategy::Unwind {\n-            this.frame_mut().extra.catch_unwind = Some(CatchUnwindData { catch_fn, data, dest, ret });\n+            this.frame_mut().extra.catch_unwind = Some(CatchUnwindData { catch_fn, data, dest: *dest, ret });\n         }\n \n         return Ok(());\n@@ -133,7 +133,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             trace!(\"unwinding: found catch_panic frame during unwinding: {:?}\", this.frame().instance);\n \n             // We set the return value of `try` to 1, since there was a panic.\n-            this.write_scalar(Scalar::from_i32(1), catch_unwind.dest)?;\n+            this.write_scalar(Scalar::from_i32(1), &catch_unwind.dest)?;\n \n             // The Thread's `panic_payload` holds what was passed to `miri_start_panic`.\n             // This is exactly the second argument we need to pass to `catch_fn`.\n@@ -146,7 +146,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.call_function(\n                 f_instance,\n                 &[catch_unwind.data.into(), payload.into()],\n-                Some(ret_place),\n+                Some(&ret_place),\n                 // Directly return to caller of `try`.\n                 StackPopCleanup::Goto { ret: Some(catch_unwind.ret), unwind: None },\n             )?;\n@@ -193,9 +193,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // Forward to `panic_bounds_check` lang item.\n \n                 // First arg: index.\n-                let index = this.read_scalar(this.eval_operand(index, None)?)?;\n+                let index = this.read_scalar(&this.eval_operand(index, None)?)?;\n                 // Second arg: len.\n-                let len = this.read_scalar(this.eval_operand(len, None)?)?;\n+                let len = this.read_scalar(&this.eval_operand(len, None)?)?;\n \n                 // Call the lang item.\n                 let panic_bounds_check = this.tcx.lang_items().panic_bounds_check_fn().unwrap();"}, {"sha": "e1eccc680883f9ba5dec78cc9064bee4d120ffe9", "filename": "src/shims/posix/dlsym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fdlsym.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -31,7 +31,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         dlsym: Dlsym,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n-        ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n "}, {"sha": "21b5ed62bbb51656055fd66e8a6b9a96737e3ef1", "filename": "src/shims/posix/foreign_items.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fforeign_items.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -17,7 +17,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         link_name: &str,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n-        dest: PlaceTy<'tcx, Tag>,\n+        dest: &PlaceTy<'tcx, Tag>,\n         ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n@@ -27,35 +27,35 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             // Environment related shims\n             \"getenv\" => {\n-                let &[name] = check_arg_count(args)?;\n+                let &[ref name] = check_arg_count(args)?;\n                 let result = this.getenv(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"unsetenv\" => {\n-                let &[name] = check_arg_count(args)?;\n+                let &[ref name] = check_arg_count(args)?;\n                 let result = this.unsetenv(name)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"setenv\" => {\n-                let &[name, value, overwrite] = check_arg_count(args)?;\n+                let &[ref name, ref value, ref overwrite] = check_arg_count(args)?;\n                 this.read_scalar(overwrite)?.to_i32()?;\n                 let result = this.setenv(name, value)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"getcwd\" => {\n-                let &[buf, size] = check_arg_count(args)?;\n+                let &[ref buf, ref size] = check_arg_count(args)?;\n                 let result = this.getcwd(buf, size)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"chdir\" => {\n-                let &[path] = check_arg_count(args)?;\n+                let &[ref path] = check_arg_count(args)?;\n                 let result = this.chdir(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // File related shims\n             \"open\" | \"open64\" => {\n-                let &[path, flag, mode] = check_arg_count(args)?;\n+                let &[ref path, ref flag, ref mode] = check_arg_count(args)?;\n                 let result = this.open(path, flag, mode)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n@@ -64,15 +64,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"read\" => {\n-                let &[fd, buf, count] = check_arg_count(args)?;\n+                let &[ref fd, ref buf, ref count] = check_arg_count(args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_scalar(buf)?.check_init()?;\n                 let count = this.read_scalar(count)?.to_machine_usize(this)?;\n                 let result = this.read(fd, buf, count)?;\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"write\" => {\n-                let &[fd, buf, n] = check_arg_count(args)?;\n+                let &[ref fd, ref buf, ref n] = check_arg_count(args)?;\n                 let fd = this.read_scalar(fd)?.to_i32()?;\n                 let buf = this.read_scalar(buf)?.check_init()?;\n                 let count = this.read_scalar(n)?.to_machine_usize(this)?;\n@@ -82,60 +82,60 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"unlink\" => {\n-                let &[path] = check_arg_count(args)?;\n+                let &[ref path] = check_arg_count(args)?;\n                 let result = this.unlink(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"symlink\" => {\n-                let &[target, linkpath] = check_arg_count(args)?;\n+                let &[ref target, ref linkpath] = check_arg_count(args)?;\n                 let result = this.symlink(target, linkpath)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"rename\" => {\n-                let &[oldpath, newpath] = check_arg_count(args)?;\n+                let &[ref oldpath, ref newpath] = check_arg_count(args)?;\n                 let result = this.rename(oldpath, newpath)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"mkdir\" => {\n-                let &[path, mode] = check_arg_count(args)?;\n+                let &[ref path, ref mode] = check_arg_count(args)?;\n                 let result = this.mkdir(path, mode)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"rmdir\" => {\n-                let &[path] = check_arg_count(args)?;\n+                let &[ref path] = check_arg_count(args)?;\n                 let result = this.rmdir(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"closedir\" => {\n-                let &[dirp] = check_arg_count(args)?;\n+                let &[ref dirp] = check_arg_count(args)?;\n                 let result = this.closedir(dirp)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"lseek\" | \"lseek64\" => {\n-                let &[fd, offset, whence] = check_arg_count(args)?;\n+                let &[ref fd, ref offset, ref whence] = check_arg_count(args)?;\n                 let result = this.lseek64(fd, offset, whence)?;\n                 // \"lseek\" is only used on macOS which is 64bit-only, so `i64` always works.\n                 this.write_scalar(Scalar::from_i64(result), dest)?;\n             }\n             \"fsync\" => {\n-                let &[fd] = check_arg_count(args)?;\n+                let &[ref fd] = check_arg_count(args)?;\n                 let result = this.fsync(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fdatasync\" => {\n-                let &[fd] = check_arg_count(args)?;\n+                let &[ref fd] = check_arg_count(args)?;\n                 let result = this.fdatasync(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"readlink\" => {\n-                let &[pathname, buf, bufsize] = check_arg_count(args)?;\n+                let &[ref pathname, ref buf, ref bufsize] = check_arg_count(args)?;\n                 let result = this.readlink(pathname, buf, bufsize)?;\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n \n             // Allocation\n             \"posix_memalign\" => {\n-                let &[ret, align, size] = check_arg_count(args)?;\n+                let &[ref ret, ref align, ref size] = check_arg_count(args)?;\n                 let ret = this.deref_operand(ret)?;\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n@@ -151,21 +151,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n \n                 if size == 0 {\n-                    this.write_null(ret.into())?;\n+                    this.write_null(&ret.into())?;\n                 } else {\n                     let ptr = this.memory.allocate(\n                         Size::from_bytes(size),\n                         Align::from_bytes(align).unwrap(),\n                         MiriMemoryKind::C.into(),\n                     );\n-                    this.write_scalar(ptr, ret.into())?;\n+                    this.write_scalar(ptr, &ret.into())?;\n                 }\n                 this.write_null(dest)?;\n             }\n \n             // Dynamic symbol loading\n             \"dlsym\" => {\n-                let &[handle, symbol] = check_arg_count(args)?;\n+                let &[ref handle, ref symbol] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_usize(this)?;\n                 let symbol = this.read_scalar(symbol)?.check_init()?;\n                 let symbol_name = this.memory.read_c_str(symbol)?;\n@@ -179,7 +179,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"sysconf\" => {\n-                let &[name] = check_arg_count(args)?;\n+                let &[ref name] = check_arg_count(args)?;\n                 let name = this.read_scalar(name)?.to_i32()?;\n \n                 let sysconfs = &[\n@@ -204,7 +204,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Thread-local storage\n             \"pthread_key_create\" => {\n-                let &[key, dtor] = check_arg_count(args)?;\n+                let &[ref key, ref dtor] = check_arg_count(args)?;\n                 let key_place = this.deref_operand(key)?;\n                 let dtor = this.read_scalar(dtor)?.check_init()?;\n \n@@ -226,27 +226,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 // Create key and write it into the memory where `key_ptr` wants it.\n                 let key = this.machine.tls.create_tls_key(dtor, key_layout.size)?;\n-                this.write_scalar(Scalar::from_uint(key, key_layout.size), key_place.into())?;\n+                this.write_scalar(Scalar::from_uint(key, key_layout.size), &key_place.into())?;\n \n                 // Return success (`0`).\n                 this.write_null(dest)?;\n             }\n             \"pthread_key_delete\" => {\n-                let &[key] = check_arg_count(args)?;\n+                let &[ref key] = check_arg_count(args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n                 this.machine.tls.delete_tls_key(key)?;\n                 // Return success (0)\n                 this.write_null(dest)?;\n             }\n             \"pthread_getspecific\" => {\n-                let &[key] = check_arg_count(args)?;\n+                let &[ref key] = check_arg_count(args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n                 let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"pthread_setspecific\" => {\n-                let &[key, new_ptr] = check_arg_count(args)?;\n+                let &[ref key, ref new_ptr] = check_arg_count(args)?;\n                 let key = this.force_bits(this.read_scalar(key)?.check_init()?, key.layout.size)?;\n                 let active_thread = this.get_active_thread();\n                 let new_ptr = this.read_scalar(new_ptr)?.check_init()?;\n@@ -258,128 +258,128 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Synchronization primitives\n             \"pthread_mutexattr_init\" => {\n-                let &[attr] = check_arg_count(args)?;\n+                let &[ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_mutexattr_init(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutexattr_settype\" => {\n-                let &[attr, kind] = check_arg_count(args)?;\n+                let &[ref attr, ref kind] = check_arg_count(args)?;\n                 let result = this.pthread_mutexattr_settype(attr, kind)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutexattr_destroy\" => {\n-                let &[attr] = check_arg_count(args)?;\n+                let &[ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_mutexattr_destroy(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_init\" => {\n-                let &[mutex, attr] = check_arg_count(args)?;\n+                let &[ref mutex, ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_init(mutex, attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_lock\" => {\n-                let &[mutex] = check_arg_count(args)?;\n+                let &[ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_lock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_trylock\" => {\n-                let &[mutex] = check_arg_count(args)?;\n+                let &[ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_trylock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_unlock\" => {\n-                let &[mutex] = check_arg_count(args)?;\n+                let &[ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_unlock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_destroy\" => {\n-                let &[mutex] = check_arg_count(args)?;\n+                let &[ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_mutex_destroy(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_rdlock\" => {\n-                let &[rwlock] = check_arg_count(args)?;\n+                let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_rdlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_tryrdlock\" => {\n-                let &[rwlock] = check_arg_count(args)?;\n+                let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_tryrdlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_wrlock\" => {\n-                let &[rwlock] = check_arg_count(args)?;\n+                let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_wrlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_trywrlock\" => {\n-                let &[rwlock] = check_arg_count(args)?;\n+                let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_trywrlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_unlock\" => {\n-                let &[rwlock] = check_arg_count(args)?;\n+                let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_unlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_destroy\" => {\n-                let &[rwlock] = check_arg_count(args)?;\n+                let &[ref rwlock] = check_arg_count(args)?;\n                 let result = this.pthread_rwlock_destroy(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_init\" => {\n-                let &[attr] = check_arg_count(args)?;\n+                let &[ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_condattr_init(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_destroy\" => {\n-                let &[attr] = check_arg_count(args)?;\n+                let &[ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_condattr_destroy(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_init\" => {\n-                let &[cond, attr] = check_arg_count(args)?;\n+                let &[ref cond, ref attr] = check_arg_count(args)?;\n                 let result = this.pthread_cond_init(cond, attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_signal\" => {\n-                let &[cond] = check_arg_count(args)?;\n+                let &[ref cond] = check_arg_count(args)?;\n                 let result = this.pthread_cond_signal(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_broadcast\" => {\n-                let &[cond] = check_arg_count(args)?;\n+                let &[ref cond] = check_arg_count(args)?;\n                 let result = this.pthread_cond_broadcast(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_wait\" => {\n-                let &[cond, mutex] = check_arg_count(args)?;\n+                let &[ref cond, ref mutex] = check_arg_count(args)?;\n                 let result = this.pthread_cond_wait(cond, mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_cond_timedwait\" => {\n-                let &[cond, mutex, abstime] = check_arg_count(args)?;\n+                let &[ref cond, ref mutex, ref abstime] = check_arg_count(args)?;\n                 this.pthread_cond_timedwait(cond, mutex, abstime, dest)?;\n             }\n             \"pthread_cond_destroy\" => {\n-                let &[cond] = check_arg_count(args)?;\n+                let &[ref cond] = check_arg_count(args)?;\n                 let result = this.pthread_cond_destroy(cond)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Threading\n             \"pthread_create\" => {\n-                let &[thread, attr, start, arg] = check_arg_count(args)?;\n+                let &[ref thread, ref attr, ref start, ref arg] = check_arg_count(args)?;\n                 let result = this.pthread_create(thread, attr, start, arg)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_join\" => {\n-                let &[thread, retval] = check_arg_count(args)?;\n+                let &[ref thread, ref retval] = check_arg_count(args)?;\n                 let result = this.pthread_join(thread, retval)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_detach\" => {\n-                let &[thread] = check_arg_count(args)?;\n+                let &[ref thread] = check_arg_count(args)?;\n                 let result = this.pthread_detach(thread)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n@@ -393,14 +393,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"nanosleep\" => {\n-                let &[req, rem] = check_arg_count(args)?;\n+                let &[ref req, ref rem] = check_arg_count(args)?;\n                 let result = this.nanosleep(req, rem)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Miscellaneous\n             \"isatty\" => {\n-                let &[fd] = check_arg_count(args)?;\n+                let &[ref fd] = check_arg_count(args)?;\n                 this.read_scalar(fd)?.to_i32()?;\n                 // \"returns 1 if fd is an open file descriptor referring to a terminal; otherwise 0 is returned, and errno is set to indicate the error\"\n                 // FIXME: we just say nothing is a terminal.\n@@ -409,7 +409,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"pthread_atfork\" => {\n-                let &[prepare, parent, child] = check_arg_count(args)?;\n+                let &[ref prepare, ref parent, ref child] = check_arg_count(args)?;\n                 this.force_bits(this.read_scalar(prepare)?.check_init()?, this.memory.pointer_size())?;\n                 this.force_bits(this.read_scalar(parent)?.check_init()?, this.memory.pointer_size())?;\n                 this.force_bits(this.read_scalar(child)?.check_init()?, this.memory.pointer_size())?;\n@@ -421,10 +421,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // These shims are enabled only when the caller is in the standard library.\n             \"pthread_attr_getguardsize\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n-                let &[_attr, guard_size] = check_arg_count(args)?;\n+                let &[ref _attr, ref guard_size] = check_arg_count(args)?;\n                 let guard_size = this.deref_operand(guard_size)?;\n                 let guard_size_layout = this.libc_ty_layout(\"size_t\")?;\n-                this.write_scalar(Scalar::from_uint(crate::PAGE_SIZE, guard_size_layout.size), guard_size.into())?;\n+                this.write_scalar(Scalar::from_uint(crate::PAGE_SIZE, guard_size_layout.size), &guard_size.into())?;\n \n                 // Return success (`0`).\n                 this.write_null(dest)?;"}, {"sha": "2f1efee8c8937f1b29a1fc471ad0a3290d283f9d", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -237,8 +237,8 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, '\n     fn macos_stat_or_lstat(\n         &mut self,\n         follow_symlink: bool,\n-        path_op: OpTy<'tcx, Tag>,\n-        buf_op: OpTy<'tcx, Tag>,\n+        path_op: &OpTy<'tcx, Tag>,\n+        buf_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -255,7 +255,7 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, '\n     fn macos_stat_write_buf(\n         &mut self,\n         metadata: FileMetadata,\n-        buf_op: OpTy<'tcx, Tag>,\n+        buf_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -303,7 +303,7 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, '\n         ];\n \n         let buf = this.deref_operand(buf_op)?;\n-        this.write_packed_immediates(buf, &imms)?;\n+        this.write_packed_immediates(&buf, &imms)?;\n \n         Ok(0)\n     }\n@@ -412,9 +412,9 @@ impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mi\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn open(\n         &mut self,\n-        path_op: OpTy<'tcx, Tag>,\n-        flag_op: OpTy<'tcx, Tag>,\n-        mode_op: OpTy<'tcx, Tag>,\n+        path_op: &OpTy<'tcx, Tag>,\n+        flag_op: &OpTy<'tcx, Tag>,\n+        mode_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -516,8 +516,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if args.len() < 2 {\n             throw_ub_format!(\"incorrect number of arguments for fcntl: got {}, expected at least 2\", args.len());\n         }\n-        let fd = this.read_scalar(args[0])?.to_i32()?;\n-        let cmd = this.read_scalar(args[1])?.to_i32()?;\n+        let fd = this.read_scalar(&args[0])?.to_i32()?;\n+        let cmd = this.read_scalar(&args[1])?.to_i32()?;\n         // We only support getting the flags for a descriptor.\n         if cmd == this.eval_libc_i32(\"F_GETFD\")? {\n             // Currently this is the only flag that `F_GETFD` returns. It is OK to just return the\n@@ -537,7 +537,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // because exec() isn't supported. The F_DUPFD and F_DUPFD_CLOEXEC commands only\n             // differ in whether the FD_CLOEXEC flag is pre-set on the new file descriptor,\n             // thus they can share the same implementation here.\n-            let &[_, _, start] = check_arg_count(args)?;\n+            let &[_, _, ref start] = check_arg_count(args)?;\n             let start = this.read_scalar(start)?.to_i32()?;\n \n             let fh = &mut this.machine.file_handler;\n@@ -572,7 +572,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn close(&mut self, fd_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn close(&mut self, fd_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n@@ -671,9 +671,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn lseek64(\n         &mut self,\n-        fd_op: OpTy<'tcx, Tag>,\n-        offset_op: OpTy<'tcx, Tag>,\n-        whence_op: OpTy<'tcx, Tag>,\n+        fd_op: &OpTy<'tcx, Tag>,\n+        offset_op: &OpTy<'tcx, Tag>,\n+        whence_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n \n@@ -705,7 +705,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn unlink(&mut self, path_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn unlink(&mut self, path_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.check_no_isolation(\"`unlink`\")?;\n@@ -718,8 +718,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn symlink(\n         &mut self,\n-        target_op: OpTy<'tcx, Tag>,\n-        linkpath_op: OpTy<'tcx, Tag>\n+        target_op: &OpTy<'tcx, Tag>,\n+        linkpath_op: &OpTy<'tcx, Tag>\n     ) -> InterpResult<'tcx, i32> {\n         #[cfg(unix)]\n         fn create_link(src: &Path, dst: &Path) -> std::io::Result<()> {\n@@ -749,8 +749,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn macos_stat(\n         &mut self,\n-        path_op: OpTy<'tcx, Tag>,\n-        buf_op: OpTy<'tcx, Tag>,\n+        path_op: &OpTy<'tcx, Tag>,\n+        buf_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"macos\", \"stat\");\n@@ -762,8 +762,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     // `lstat` is used to get symlink metadata.\n     fn macos_lstat(\n         &mut self,\n-        path_op: OpTy<'tcx, Tag>,\n-        buf_op: OpTy<'tcx, Tag>,\n+        path_op: &OpTy<'tcx, Tag>,\n+        buf_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"macos\", \"lstat\");\n@@ -773,8 +773,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn macos_fstat(\n         &mut self,\n-        fd_op: OpTy<'tcx, Tag>,\n-        buf_op: OpTy<'tcx, Tag>,\n+        fd_op: &OpTy<'tcx, Tag>,\n+        buf_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -792,11 +792,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn linux_statx(\n         &mut self,\n-        dirfd_op: OpTy<'tcx, Tag>,    // Should be an `int`\n-        pathname_op: OpTy<'tcx, Tag>, // Should be a `const char *`\n-        flags_op: OpTy<'tcx, Tag>,    // Should be an `int`\n-        _mask_op: OpTy<'tcx, Tag>,    // Should be an `unsigned int`\n-        statxbuf_op: OpTy<'tcx, Tag>, // Should be a `struct statx *`\n+        dirfd_op: &OpTy<'tcx, Tag>,    // Should be an `int`\n+        pathname_op: &OpTy<'tcx, Tag>, // Should be a `const char *`\n+        flags_op: &OpTy<'tcx, Tag>,    // Should be an `int`\n+        _mask_op: &OpTy<'tcx, Tag>,    // Should be an `unsigned int`\n+        statxbuf_op: &OpTy<'tcx, Tag>, // Should be a `struct statx *`\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -827,7 +827,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             let statxbuf_ty = this.tcx.mk_mut_ptr(statx_ty);\n             let statxbuf_layout = this.layout_of(statxbuf_ty)?;\n             let statxbuf_imm = ImmTy::from_scalar(statxbuf_scalar, statxbuf_layout);\n-            this.ref_to_mplace(statxbuf_imm)?\n+            this.ref_to_mplace(&statxbuf_imm)?\n         };\n \n         let path = this.read_path_from_c_str(pathname_scalar)?.into_owned();\n@@ -941,15 +941,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             immty_from_uint_checked(0u128, __u64_layout)?, // stx_dev_minor\n         ];\n \n-        this.write_packed_immediates(statxbuf_place, &imms)?;\n+        this.write_packed_immediates(&statxbuf_place, &imms)?;\n \n         Ok(0)\n     }\n \n     fn rename(\n         &mut self,\n-        oldpath_op: OpTy<'tcx, Tag>,\n-        newpath_op: OpTy<'tcx, Tag>,\n+        oldpath_op: &OpTy<'tcx, Tag>,\n+        newpath_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -974,8 +974,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn mkdir(\n         &mut self,\n-        path_op: OpTy<'tcx, Tag>,\n-        mode_op: OpTy<'tcx, Tag>,\n+        path_op: &OpTy<'tcx, Tag>,\n+        mode_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -1008,7 +1008,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn rmdir(\n         &mut self,\n-        path_op: OpTy<'tcx, Tag>,\n+        path_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -1021,7 +1021,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.try_unwrap_io_result(result)\n     }\n \n-    fn opendir(&mut self, name_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, Scalar<Tag>> {\n+    fn opendir(&mut self, name_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, Scalar<Tag>> {\n         let this = self.eval_context_mut();\n \n         this.check_no_isolation(\"`opendir`\")?;\n@@ -1048,9 +1048,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn linux_readdir64_r(\n         &mut self,\n-        dirp_op: OpTy<'tcx, Tag>,\n-        entry_op: OpTy<'tcx, Tag>,\n-        result_op: OpTy<'tcx, Tag>,\n+        dirp_op: &OpTy<'tcx, Tag>,\n+        entry_op: &OpTy<'tcx, Tag>,\n+        result_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -1078,7 +1078,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // }\n \n                 let entry_place = this.deref_operand(entry_op)?;\n-                let name_place = this.mplace_field(entry_place, 4)?;\n+                let name_place = this.mplace_field(&entry_place, 4)?;\n \n                 let file_name = dir_entry.file_name(); // not a Path as there are no separators!\n                 let (name_fits, _) = this.write_os_str_to_c_str(\n@@ -1111,16 +1111,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     immty_from_uint_checked(0u128, c_ushort_layout)?, // d_reclen\n                     immty_from_int_checked(file_type, c_uchar_layout)?, // d_type\n                 ];\n-                this.write_packed_immediates(entry_place, &imms)?;\n+                this.write_packed_immediates(&entry_place, &imms)?;\n \n                 let result_place = this.deref_operand(result_op)?;\n-                this.write_scalar(this.read_scalar(entry_op)?, result_place.into())?;\n+                this.write_scalar(this.read_scalar(entry_op)?, &result_place.into())?;\n \n                 Ok(0)\n             }\n             None => {\n                 // end of stream: return 0, assign *result=NULL\n-                this.write_null(this.deref_operand(result_op)?.into())?;\n+                this.write_null(&this.deref_operand(result_op)?.into())?;\n                 Ok(0)\n             }\n             Some(Err(e)) => match e.raw_os_error() {\n@@ -1135,9 +1135,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn macos_readdir_r(\n         &mut self,\n-        dirp_op: OpTy<'tcx, Tag>,\n-        entry_op: OpTy<'tcx, Tag>,\n-        result_op: OpTy<'tcx, Tag>,\n+        dirp_op: &OpTy<'tcx, Tag>,\n+        entry_op: &OpTy<'tcx, Tag>,\n+        result_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -1166,7 +1166,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // }\n \n                 let entry_place = this.deref_operand(entry_op)?;\n-                let name_place = this.mplace_field(entry_place, 5)?;\n+                let name_place = this.mplace_field(&entry_place, 5)?;\n \n                 let file_name = dir_entry.file_name(); // not a Path as there are no separators!\n                 let (name_fits, file_name_len) = this.write_os_str_to_c_str(\n@@ -1200,16 +1200,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     immty_from_uint_checked(file_name_len, c_ushort_layout)?, // d_namlen\n                     immty_from_int_checked(file_type, c_uchar_layout)?, // d_type\n                 ];\n-                this.write_packed_immediates(entry_place, &imms)?;\n+                this.write_packed_immediates(&entry_place, &imms)?;\n \n                 let result_place = this.deref_operand(result_op)?;\n-                this.write_scalar(this.read_scalar(entry_op)?, result_place.into())?;\n+                this.write_scalar(this.read_scalar(entry_op)?, &result_place.into())?;\n \n                 Ok(0)\n             }\n             None => {\n                 // end of stream: return 0, assign *result=NULL\n-                this.write_null(this.deref_operand(result_op)?.into())?;\n+                this.write_null(&this.deref_operand(result_op)?.into())?;\n                 Ok(0)\n             }\n             Some(Err(e)) => match e.raw_os_error() {\n@@ -1222,7 +1222,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn closedir(&mut self, dirp_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn closedir(&mut self, dirp_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.check_no_isolation(\"`closedir`\")?;\n@@ -1239,8 +1239,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn ftruncate64(\n         &mut self,\n-        fd_op: OpTy<'tcx, Tag>,\n-        length_op: OpTy<'tcx, Tag>,\n+        fd_op: &OpTy<'tcx, Tag>,\n+        length_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -1271,7 +1271,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn fsync(&mut self, fd_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn fsync(&mut self, fd_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         // On macOS, `fsync` (unlike `fcntl(F_FULLFSYNC)`) does not wait for the\n         // underlying disk to finish writing. In the interest of host compatibility,\n         // we conservatively implement this with `sync_all`, which\n@@ -1292,7 +1292,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn fdatasync(&mut self, fd_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn fdatasync(&mut self, fd_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.check_no_isolation(\"`fdatasync`\")?;\n@@ -1310,10 +1310,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn sync_file_range(\n         &mut self,\n-        fd_op: OpTy<'tcx, Tag>,\n-        offset_op: OpTy<'tcx, Tag>,\n-        nbytes_op: OpTy<'tcx, Tag>,\n-        flags_op: OpTy<'tcx, Tag>,\n+        fd_op: &OpTy<'tcx, Tag>,\n+        offset_op: &OpTy<'tcx, Tag>,\n+        nbytes_op: &OpTy<'tcx, Tag>,\n+        flags_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -1350,9 +1350,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn readlink(\n         &mut self,\n-        pathname_op: OpTy<'tcx, Tag>,\n-        buf_op: OpTy<'tcx, Tag>,\n-        bufsize_op: OpTy<'tcx, Tag>\n+        pathname_op: &OpTy<'tcx, Tag>,\n+        buf_op: &OpTy<'tcx, Tag>,\n+        bufsize_op: &OpTy<'tcx, Tag>\n     ) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n "}, {"sha": "e7ffb68ff2ec08b84cbb45ccbb8936d8e84505ab", "filename": "src/shims/posix/linux/dlsym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Flinux%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Flinux%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fdlsym.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -25,7 +25,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         dlsym: Dlsym,\n         _args: &[OpTy<'tcx, Tag>],\n-        ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let (_dest, _ret) = ret.expect(\"we don't support any diverging dlsym\");"}, {"sha": "2a3b512bcdb95aa8f70d9c5032383abdf6141bc9", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -13,7 +13,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         link_name: &str,\n         args: &[OpTy<'tcx, Tag>],\n-        dest: PlaceTy<'tcx, Tag>,\n+        dest: &PlaceTy<'tcx, Tag>,\n         _ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n@@ -30,28 +30,28 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // These symbols have different names on Linux and macOS, which is the only reason they are not\n             // in the `posix` module.\n             \"close\" => {\n-                let &[fd] = check_arg_count(args)?;\n+                let &[ref fd] = check_arg_count(args)?;\n                 let result = this.close(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"opendir\" => {\n-                let &[name] = check_arg_count(args)?;\n+                let &[ref name] = check_arg_count(args)?;\n                 let result = this.opendir(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"readdir64_r\" => {\n-                let &[dirp, entry, result] = check_arg_count(args)?;\n+                let &[ref dirp, ref entry, ref result] = check_arg_count(args)?;\n                 let result = this.linux_readdir64_r(dirp, entry, result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"ftruncate64\" => {\n-                let &[fd, length] = check_arg_count(args)?;\n+                let &[ref fd, ref length] = check_arg_count(args)?;\n                 let result = this.ftruncate64(fd, length)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             // Linux-only\n             \"posix_fadvise\" => {\n-                let &[fd, offset, len, advice] = check_arg_count(args)?;\n+                let &[ref fd, ref offset, ref len, ref advice] = check_arg_count(args)?;\n                 this.read_scalar(fd)?.to_i32()?;\n                 this.read_scalar(offset)?.to_machine_isize(this)?;\n                 this.read_scalar(len)?.to_machine_isize(this)?;\n@@ -60,34 +60,34 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"sync_file_range\" => {\n-                let &[fd, offset, nbytes, flags] = check_arg_count(args)?;\n+                let &[ref fd, ref offset, ref nbytes, ref flags] = check_arg_count(args)?;\n                 let result = this.sync_file_range(fd, offset, nbytes, flags)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Time related shims\n             \"clock_gettime\" => {\n                 // This is a POSIX function but it has only been tested on linux.\n-                let &[clk_id, tp] = check_arg_count(args)?;\n+                let &[ref clk_id, ref tp] = check_arg_count(args)?;\n                 let result = this.clock_gettime(clk_id, tp)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Querying system information\n             \"pthread_attr_getstack\" => {\n                 // We don't support \"pthread_attr_setstack\", so we just pretend all stacks have the same values here.\n-                let &[attr_place, addr_place, size_place] = check_arg_count(args)?;\n+                let &[ref attr_place, ref addr_place, ref size_place] = check_arg_count(args)?;\n                 this.deref_operand(attr_place)?;\n                 let addr_place = this.deref_operand(addr_place)?;\n                 let size_place = this.deref_operand(size_place)?;\n \n                 this.write_scalar(\n                     Scalar::from_uint(STACK_ADDR, this.pointer_size()),\n-                    addr_place.into(),\n+                    &addr_place.into(),\n                 )?;\n                 this.write_scalar(\n                     Scalar::from_uint(STACK_SIZE, this.pointer_size()),\n-                    size_place.into(),\n+                    &size_place.into(),\n                 )?;\n \n                 // Return success (`0`).\n@@ -96,17 +96,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Threading\n             \"prctl\" => {\n-                let &[option, arg2, arg3, arg4, arg5] = check_arg_count(args)?;\n+                let &[ref option, ref arg2, ref arg3, ref arg4, ref arg5] = check_arg_count(args)?;\n                 let result = this.prctl(option, arg2, arg3, arg4, arg5)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_setclock\" => {\n-                let &[attr, clock_id] = check_arg_count(args)?;\n+                let &[ref attr, ref clock_id] = check_arg_count(args)?;\n                 let result = this.pthread_condattr_setclock(attr, clock_id)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_condattr_getclock\" => {\n-                let &[attr, clock_id] = check_arg_count(args)?;\n+                let &[ref attr, ref clock_id] = check_arg_count(args)?;\n                 let result = this.pthread_condattr_getclock(attr, clock_id)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n@@ -137,15 +137,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 if args.is_empty() {\n                     throw_ub_format!(\"incorrect number of arguments for syscall: got 0, expected at least 1\");\n                 }\n-                match this.read_scalar(args[0])?.to_machine_usize(this)? {\n+                match this.read_scalar(&args[0])?.to_machine_usize(this)? {\n                     // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n                     // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n                     id if id == sys_getrandom => {\n                         // The first argument is the syscall id, so skip over it.\n                         if args.len() < 4 {\n                             throw_ub_format!(\"incorrect number of arguments for `getrandom` syscall: got {}, expected at least 4\", args.len());\n                         }\n-                        getrandom(this, args[1], args[2], args[3], dest)?;\n+                        getrandom(this, &args[1], &args[2], &args[3], dest)?;\n                     }\n                     // `statx` is used by `libstd` to retrieve metadata information on `linux`\n                     // instead of using `stat`,`lstat` or `fstat` as on `macos`.\n@@ -154,7 +154,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         if args.len() < 6 {\n                             throw_ub_format!(\"incorrect number of arguments for `statx` syscall: got {}, expected at least 6\", args.len());\n                         }\n-                        let result = this.linux_statx(args[1], args[2], args[3], args[4], args[5])?;\n+                        let result = this.linux_statx(&args[1], &args[2], &args[3], &args[4], &args[5])?;\n                         this.write_scalar(Scalar::from_machine_isize(result.into(), this), dest)?;\n                     }\n                     // `futex` is used by some synchonization primitives.\n@@ -167,11 +167,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Miscelanneous\n             \"getrandom\" => {\n-                let &[ptr, len, flags] = check_arg_count(args)?;\n+                let &[ref ptr, ref len, ref flags] = check_arg_count(args)?;\n                 getrandom(this, ptr, len, flags, dest)?;\n             }\n             \"sched_getaffinity\" => {\n-                let &[pid, cpusetsize, mask] = check_arg_count(args)?;\n+                let &[ref pid, ref cpusetsize, ref mask] = check_arg_count(args)?;\n                 this.read_scalar(pid)?.to_i32()?;\n                 this.read_scalar(cpusetsize)?.to_machine_usize(this)?;\n                 this.deref_operand(mask)?;\n@@ -184,7 +184,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             \"pthread_getattr_np\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n-                let &[_thread, _attr] = check_arg_count(args)?;\n+                let &[ref _thread, ref _attr] = check_arg_count(args)?;\n                 this.write_null(dest)?;\n             }\n \n@@ -198,10 +198,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n // Shims the linux `getrandom` syscall.\n fn getrandom<'tcx>(\n     this: &mut MiriEvalContext<'_, 'tcx>,\n-    ptr: OpTy<'tcx, Tag>,\n-    len: OpTy<'tcx, Tag>,\n-    flags: OpTy<'tcx, Tag>,\n-    dest: PlaceTy<'tcx, Tag>,\n+    ptr: &OpTy<'tcx, Tag>,\n+    len: &OpTy<'tcx, Tag>,\n+    flags: &OpTy<'tcx, Tag>,\n+    dest: &PlaceTy<'tcx, Tag>,\n ) -> InterpResult<'tcx> {\n     let ptr = this.read_scalar(ptr)?.check_init()?;\n     let len = this.read_scalar(len)?.to_machine_usize(this)?;"}, {"sha": "fdd11fd73e40889b2a86b5c1c23e11ac0b8591ba", "filename": "src/shims/posix/linux/sync.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fsync.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -7,7 +7,7 @@ use std::time::{Instant, SystemTime};\n pub fn futex<'tcx>(\n     this: &mut MiriEvalContext<'_, 'tcx>,\n     args: &[OpTy<'tcx, Tag>],\n-    dest: PlaceTy<'tcx, Tag>,\n+    dest: &PlaceTy<'tcx, Tag>,\n ) -> InterpResult<'tcx> {\n     // The amount of arguments used depends on the type of futex operation.\n     // The full futex syscall takes six arguments (excluding the syscall\n@@ -24,9 +24,9 @@ pub fn futex<'tcx>(\n     // The first three arguments (after the syscall number itself) are the same to all futex operations:\n     //     (int *addr, int op, int val).\n     // We checked above that these definitely exist.\n-    let addr = this.read_immediate(args[1])?;\n-    let op = this.read_scalar(args[2])?.to_i32()?;\n-    let val = this.read_scalar(args[3])?.to_i32()?;\n+    let addr = this.read_immediate(&args[1])?;\n+    let op = this.read_scalar(&args[2])?.to_i32()?;\n+    let val = this.read_scalar(&args[3])?.to_i32()?;\n \n     // The raw pointer value is used to identify the mutex.\n     // Not all mutex operations actually read from this address or even require this address to exist.\n@@ -51,7 +51,7 @@ pub fn futex<'tcx>(\n             if args.len() < 5 {\n                 throw_ub_format!(\"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT`: got {}, expected at least 5\", args.len());\n             }\n-            let timeout = args[4];\n+            let timeout = &args[4];\n             let timeout_time = if this.is_null(this.read_scalar(timeout)?.check_init()?)? {\n                 None\n             } else {\n@@ -88,7 +88,7 @@ pub fn futex<'tcx>(\n             // SeqCst is total order over all operations.\n             // FIXME: check if this should be changed when weak memory orders are added.\n             let futex_val = this.read_scalar_at_offset_atomic(\n-                addr.into(), 0, this.machine.layouts.i32, AtomicReadOp::SeqCst\n+                &addr.into(), 0, this.machine.layouts.i32, AtomicReadOp::SeqCst\n             )?.to_i32()?;\n             if val == futex_val {\n                 // The value still matches, so we block the trait make it wait for FUTEX_WAKE.\n@@ -98,6 +98,7 @@ pub fn futex<'tcx>(\n                 this.write_scalar(Scalar::from_machine_isize(0, this), dest)?;\n                 // Register a timeout callback if a timeout was specified.\n                 // This callback will override the return value when the timeout triggers.\n+                let dest = *dest;\n                 if let Some(timeout_time) = timeout_time {\n                     this.register_timeout_callback(\n                         thread,\n@@ -107,7 +108,7 @@ pub fn futex<'tcx>(\n                             this.futex_remove_waiter(futex_ptr, thread);\n                             let etimedout = this.eval_libc(\"ETIMEDOUT\")?;\n                             this.set_last_error(etimedout)?;\n-                            this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n+                            this.write_scalar(Scalar::from_machine_isize(-1, this), &dest)?;\n                             Ok(())\n                         }),\n                     );"}, {"sha": "7f3958797449c121f147cda60deb64b78260fb1d", "filename": "src/shims/posix/macos/dlsym.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Fmacos%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Fmacos%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmacos%2Fdlsym.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -28,23 +28,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         dlsym: Dlsym,\n         args: &[OpTy<'tcx, Tag>],\n-        ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let (dest, ret) = ret.expect(\"we don't support any diverging dlsym\");\n         assert!(this.tcx.sess.target.os == \"macos\");\n \n         match dlsym {\n             Dlsym::getentropy => {\n-                let &[ptr, len] = check_arg_count(args)?;\n+                let &[ref ptr, ref len] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let len = this.read_scalar(len)?.to_machine_usize(this)?;\n                 this.gen_random(ptr, len)?;\n                 this.write_null(dest)?;\n             }\n         }\n \n-        trace!(\"{:?}\", this.dump_place(*dest));\n+        trace!(\"{:?}\", this.dump_place(**dest));\n         this.go_to_block(ret);\n         Ok(())\n     }"}, {"sha": "1ea12148303e261540485360783b61ba123e724e", "filename": "src/shims/posix/macos/foreign_items.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -11,7 +11,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         link_name: &str,\n         args: &[OpTy<'tcx, Tag>],\n-        dest: PlaceTy<'tcx, Tag>,\n+        dest: &PlaceTy<'tcx, Tag>,\n         _ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n@@ -26,37 +26,37 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // File related shims\n             \"close\" | \"close$NOCANCEL\" => {\n-                let &[result] = check_arg_count(args)?;\n+                let &[ref result] = check_arg_count(args)?;\n                 let result = this.close(result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"stat\" | \"stat$INODE64\" => {\n-                let &[path, buf] = check_arg_count(args)?;\n+                let &[ref path, ref buf] = check_arg_count(args)?;\n                 let result = this.macos_stat(path, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"lstat\" | \"lstat$INODE64\" => {\n-                let &[path, buf] = check_arg_count(args)?;\n+                let &[ref path, ref buf] = check_arg_count(args)?;\n                 let result = this.macos_lstat(path, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fstat\" | \"fstat$INODE64\" => {\n-                let &[fd, buf] = check_arg_count(args)?;\n+                let &[ref fd, ref buf] = check_arg_count(args)?;\n                 let result = this.macos_fstat(fd, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"opendir\" | \"opendir$INODE64\" => {\n-                let &[name] = check_arg_count(args)?;\n+                let &[ref name] = check_arg_count(args)?;\n                 let result = this.opendir(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"readdir_r\" | \"readdir_r$INODE64\" => {\n-                let &[dirp, entry, result] = check_arg_count(args)?;\n+                let &[ref dirp, ref entry, ref result] = check_arg_count(args)?;\n                 let result = this.macos_readdir_r(dirp, entry, result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"ftruncate\" => {\n-                let &[fd, length] = check_arg_count(args)?;\n+                let &[ref fd, ref length] = check_arg_count(args)?;\n                 let result = this.ftruncate64(fd, length)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n@@ -69,7 +69,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Time related shims\n             \"gettimeofday\" => {\n-                let &[tv, tz] = check_arg_count(args)?;\n+                let &[ref tv, ref tz] = check_arg_count(args)?;\n                 let result = this.gettimeofday(tv, tz)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n@@ -80,7 +80,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"mach_timebase_info\" => {\n-                let &[info] = check_arg_count(args)?;\n+                let &[ref info] = check_arg_count(args)?;\n                 let result = this.mach_timebase_info(info)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             },\n@@ -97,7 +97,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Thread-local storage\n             \"_tlv_atexit\" => {\n-                let &[dtor, data] = check_arg_count(args)?;\n+                let &[ref dtor, ref data] = check_arg_count(args)?;\n                 let dtor = this.read_scalar(dtor)?.check_init()?;\n                 let dtor = this.memory.get_fn(dtor)?.as_instance()?;\n                 let data = this.read_scalar(data)?.check_init()?;\n@@ -107,21 +107,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"pthread_get_stackaddr_np\" => {\n-                let &[thread] = check_arg_count(args)?;\n+                let &[ref thread] = check_arg_count(args)?;\n                 this.read_scalar(thread)?.to_machine_usize(this)?;\n                 let stack_addr = Scalar::from_uint(STACK_ADDR, this.pointer_size());\n                 this.write_scalar(stack_addr, dest)?;\n             }\n             \"pthread_get_stacksize_np\" => {\n-                let &[thread] = check_arg_count(args)?;\n+                let &[ref thread] = check_arg_count(args)?;\n                 this.read_scalar(thread)?.to_machine_usize(this)?;\n                 let stack_size = Scalar::from_uint(STACK_SIZE, this.pointer_size());\n                 this.write_scalar(stack_size, dest)?;\n             }\n \n             // Threading\n             \"pthread_setname_np\" => {\n-                let &[name] = check_arg_count(args)?;\n+                let &[ref name] = check_arg_count(args)?;\n                 let name = this.read_scalar(name)?.check_init()?;\n                 this.pthread_setname_np(name)?;\n             }\n@@ -130,7 +130,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // These shims are enabled only when the caller is in the standard library.\n             \"mmap\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n                 // This is a horrible hack, but since the guard page mechanism calls mmap and expects a particular return value, we just give it that value.\n-                let &[addr, _, _, _, _, _] = check_arg_count(args)?;\n+                let &[ref addr, _, _, _, _, _] = check_arg_count(args)?;\n                 let addr = this.read_scalar(addr)?.check_init()?;\n                 this.write_scalar(addr, dest)?;\n             }"}, {"sha": "0688614a383d61d512f4e8d33bc5aef2a920900b", "filename": "src/shims/posix/sync.rs", "status": "modified", "additions": 54, "deletions": 52, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fsync.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -35,14 +35,14 @@ fn is_mutex_kind_normal<'mir, 'tcx: 'mir>(\n \n fn mutexattr_get_kind<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n-    attr_op: OpTy<'tcx, Tag>,\n+    attr_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n     ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)\n }\n \n fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    attr_op: OpTy<'tcx, Tag>,\n+    attr_op: &OpTy<'tcx, Tag>,\n     kind: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset(attr_op, 0, kind, ecx.machine.layouts.i32)\n@@ -59,7 +59,7 @@ fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n \n fn mutex_get_kind<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    mutex_op: OpTy<'tcx, Tag>,\n+    mutex_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n     ecx.read_scalar_at_offset_atomic(\n@@ -70,7 +70,7 @@ fn mutex_get_kind<'mir, 'tcx: 'mir>(\n \n fn mutex_set_kind<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    mutex_op: OpTy<'tcx, Tag>,\n+    mutex_op: &OpTy<'tcx, Tag>,\n     kind: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n@@ -82,7 +82,7 @@ fn mutex_set_kind<'mir, 'tcx: 'mir>(\n \n fn mutex_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n-    mutex_op: OpTy<'tcx, Tag>,\n+    mutex_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n     ecx.read_scalar_at_offset_atomic(\n         mutex_op, 4, ecx.machine.layouts.u32, \n@@ -92,7 +92,7 @@ fn mutex_get_id<'mir, 'tcx: 'mir>(\n \n fn mutex_set_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    mutex_op: OpTy<'tcx, Tag>,\n+    mutex_op: &OpTy<'tcx, Tag>,\n     id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset_atomic(\n@@ -103,7 +103,7 @@ fn mutex_set_id<'mir, 'tcx: 'mir>(\n \n fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    mutex_op: OpTy<'tcx, Tag>,\n+    mutex_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, MutexId> {\n     let id = mutex_get_id(ecx, mutex_op)?.to_u32()?;\n     if id == 0 {\n@@ -126,7 +126,7 @@ fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n \n fn rwlock_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n-    rwlock_op: OpTy<'tcx, Tag>,\n+    rwlock_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n     ecx.read_scalar_at_offset_atomic(\n         rwlock_op, 4, ecx.machine.layouts.u32,\n@@ -136,7 +136,7 @@ fn rwlock_get_id<'mir, 'tcx: 'mir>(\n \n fn rwlock_set_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    rwlock_op: OpTy<'tcx, Tag>,\n+    rwlock_op: &OpTy<'tcx, Tag>,\n     id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset_atomic(\n@@ -147,7 +147,7 @@ fn rwlock_set_id<'mir, 'tcx: 'mir>(\n \n fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    rwlock_op: OpTy<'tcx, Tag>,\n+    rwlock_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, RwLockId> {\n     let id = rwlock_get_id(ecx, rwlock_op)?.to_u32()?;\n     if id == 0 {\n@@ -169,14 +169,14 @@ fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n \n fn condattr_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n-    attr_op: OpTy<'tcx, Tag>,\n+    attr_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n     ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)\n }\n \n fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    attr_op: OpTy<'tcx, Tag>,\n+    attr_op: &OpTy<'tcx, Tag>,\n     clock_id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset(attr_op, 0, clock_id, ecx.machine.layouts.i32)\n@@ -193,7 +193,7 @@ fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n \n fn cond_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n-    cond_op: OpTy<'tcx, Tag>,\n+    cond_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n     ecx.read_scalar_at_offset_atomic(\n         cond_op, 4, ecx.machine.layouts.u32,\n@@ -203,7 +203,7 @@ fn cond_get_id<'mir, 'tcx: 'mir>(\n \n fn cond_set_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    cond_op: OpTy<'tcx, Tag>,\n+    cond_op: &OpTy<'tcx, Tag>,\n     id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset_atomic(\n@@ -214,7 +214,7 @@ fn cond_set_id<'mir, 'tcx: 'mir>(\n \n fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    cond_op: OpTy<'tcx, Tag>,\n+    cond_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, CondvarId> {\n     let id = cond_get_id(ecx, cond_op)?.to_u32()?;\n     if id == 0 {\n@@ -230,14 +230,14 @@ fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n \n fn cond_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n-    cond_op: OpTy<'tcx, Tag>,\n+    cond_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n     ecx.read_scalar_at_offset(cond_op, 8, ecx.machine.layouts.i32)\n }\n \n fn cond_set_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    cond_op: OpTy<'tcx, Tag>,\n+    cond_op: &OpTy<'tcx, Tag>,\n     clock_id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset(cond_op, 8, clock_id, ecx.machine.layouts.i32)\n@@ -294,7 +294,7 @@ fn release_cond_mutex_and_block<'mir, 'tcx: 'mir>(\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    fn pthread_mutexattr_init(&mut self, attr_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_mutexattr_init(&mut self, attr_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let default_kind = this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?;\n@@ -305,8 +305,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn pthread_mutexattr_settype(\n         &mut self,\n-        attr_op: OpTy<'tcx, Tag>,\n-        kind_op: OpTy<'tcx, Tag>,\n+        attr_op: &OpTy<'tcx, Tag>,\n+        kind_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -344,7 +344,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_mutexattr_destroy(&mut self, attr_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_mutexattr_destroy(&mut self, attr_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         mutexattr_set_kind(this, attr_op, ScalarMaybeUninit::Uninit)?;\n@@ -354,8 +354,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn pthread_mutex_init(\n         &mut self,\n-        mutex_op: OpTy<'tcx, Tag>,\n-        attr_op: OpTy<'tcx, Tag>,\n+        mutex_op: &OpTy<'tcx, Tag>,\n+        attr_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -374,7 +374,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_mutex_lock(&mut self, mutex_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_mutex_lock(&mut self, mutex_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?.check_init()?;\n@@ -411,7 +411,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn pthread_mutex_trylock(&mut self, mutex_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_mutex_trylock(&mut self, mutex_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?.check_init()?;\n@@ -444,7 +444,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn pthread_mutex_unlock(&mut self, mutex_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_mutex_unlock(&mut self, mutex_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?.check_init()?;\n@@ -476,7 +476,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn pthread_mutex_destroy(&mut self, mutex_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_mutex_destroy(&mut self, mutex_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let id = mutex_get_or_create_id(this, mutex_op)?;\n@@ -492,7 +492,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_rwlock_rdlock(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_rwlock_rdlock(&mut self, rwlock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n@@ -507,7 +507,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn pthread_rwlock_tryrdlock(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_rwlock_tryrdlock(&mut self, rwlock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n@@ -521,7 +521,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn pthread_rwlock_wrlock(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_rwlock_wrlock(&mut self, rwlock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n@@ -548,7 +548,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_rwlock_trywrlock(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_rwlock_trywrlock(&mut self, rwlock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n@@ -562,7 +562,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn pthread_rwlock_unlock(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_rwlock_unlock(&mut self, rwlock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n@@ -577,7 +577,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn pthread_rwlock_destroy(&mut self, rwlock_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_rwlock_destroy(&mut self, rwlock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n@@ -592,7 +592,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_condattr_init(&mut self, attr_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_condattr_init(&mut self, attr_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         // The default value of the clock attribute shall refer to the system\n@@ -606,8 +606,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn pthread_condattr_setclock(\n         &mut self,\n-        attr_op: OpTy<'tcx, Tag>,\n-        clock_id_op: OpTy<'tcx, Tag>,\n+        attr_op: &OpTy<'tcx, Tag>,\n+        clock_id_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -626,18 +626,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn pthread_condattr_getclock(\n         &mut self,\n-        attr_op: OpTy<'tcx, Tag>,\n-        clk_id_op: OpTy<'tcx, Tag>,\n+        attr_op: &OpTy<'tcx, Tag>,\n+        clk_id_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let clock_id = condattr_get_clock_id(this, attr_op)?;\n-        this.write_scalar(clock_id, this.deref_operand(clk_id_op)?.into())?;\n+        this.write_scalar(clock_id, &this.deref_operand(clk_id_op)?.into())?;\n \n         Ok(0)\n     }\n \n-    fn pthread_condattr_destroy(&mut self, attr_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_condattr_destroy(&mut self, attr_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         condattr_set_clock_id(this, attr_op, ScalarMaybeUninit::Uninit)?;\n@@ -647,8 +647,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn pthread_cond_init(\n         &mut self,\n-        cond_op: OpTy<'tcx, Tag>,\n-        attr_op: OpTy<'tcx, Tag>,\n+        cond_op: &OpTy<'tcx, Tag>,\n+        attr_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -667,7 +667,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_cond_signal(&mut self, cond_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_cond_signal(&mut self, cond_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         let id = cond_get_or_create_id(this, cond_op)?;\n         if let Some((thread, mutex)) = this.condvar_signal(id) {\n@@ -677,7 +677,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_cond_broadcast(&mut self, cond_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_cond_broadcast(&mut self, cond_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         let id = cond_get_or_create_id(this, cond_op)?;\n \n@@ -690,8 +690,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn pthread_cond_wait(\n         &mut self,\n-        cond_op: OpTy<'tcx, Tag>,\n-        mutex_op: OpTy<'tcx, Tag>,\n+        cond_op: &OpTy<'tcx, Tag>,\n+        mutex_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -707,10 +707,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn pthread_cond_timedwait(\n         &mut self,\n-        cond_op: OpTy<'tcx, Tag>,\n-        mutex_op: OpTy<'tcx, Tag>,\n-        abstime_op: OpTy<'tcx, Tag>,\n-        dest: PlaceTy<'tcx, Tag>,\n+        cond_op: &OpTy<'tcx, Tag>,\n+        mutex_op: &OpTy<'tcx, Tag>,\n+        abstime_op: &OpTy<'tcx, Tag>,\n+        dest: &PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -745,6 +745,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // We return success for now and override it in the timeout callback.\n         this.write_scalar(Scalar::from_i32(0), dest)?;\n \n+        let dest = *dest;\n+\n         // Register the timeout callback.\n         this.register_timeout_callback(\n             active_thread,\n@@ -759,7 +761,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 // Set the return value: we timed out.\n                 let etimedout = ecx.eval_libc(\"ETIMEDOUT\")?;\n-                ecx.write_scalar(etimedout, dest)?;\n+                ecx.write_scalar(etimedout, &dest)?;\n \n                 Ok(())\n             }),\n@@ -768,7 +770,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(())\n     }\n \n-    fn pthread_cond_destroy(&mut self, cond_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_cond_destroy(&mut self, cond_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let id = cond_get_or_create_id(this, cond_op)?;"}, {"sha": "40663326b4651508843239c51665071b7e2b012c", "filename": "src/shims/posix/thread.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fposix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fthread.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -7,10 +7,10 @@ impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tc\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn pthread_create(\n         &mut self,\n-        thread: OpTy<'tcx, Tag>,\n-        _attr: OpTy<'tcx, Tag>,\n-        start_routine: OpTy<'tcx, Tag>,\n-        arg: OpTy<'tcx, Tag>,\n+        thread: &OpTy<'tcx, Tag>,\n+        _attr: &OpTy<'tcx, Tag>,\n+        start_routine: &OpTy<'tcx, Tag>,\n+        arg: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -26,7 +26,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let thread_info_place = this.deref_operand(thread)?;\n         this.write_scalar(\n             Scalar::from_uint(new_thread_id.to_u32(), thread_info_place.layout.size),\n-            thread_info_place.into(),\n+            &thread_info_place.into(),\n         )?;\n \n         // Read the function argument that will be sent to the new thread\n@@ -51,7 +51,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.call_function(\n             instance,\n             &[*func_arg],\n-            Some(ret_place.into()),\n+            Some(&ret_place.into()),\n             StackPopCleanup::None { cleanup: true },\n         )?;\n \n@@ -63,8 +63,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn pthread_join(\n         &mut self,\n-        thread: OpTy<'tcx, Tag>,\n-        retval: OpTy<'tcx, Tag>,\n+        thread: &OpTy<'tcx, Tag>,\n+        retval: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -79,7 +79,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_detach(&mut self, thread: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_detach(&mut self, thread: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let thread_id = this.read_scalar(thread)?.to_machine_usize(this)?;\n@@ -88,7 +88,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_self(&mut self, dest: PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+    fn pthread_self(&mut self, dest: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n         let thread_id = this.get_active_thread();\n@@ -97,11 +97,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn prctl(\n         &mut self,\n-        option: OpTy<'tcx, Tag>,\n-        arg2: OpTy<'tcx, Tag>,\n-        _arg3: OpTy<'tcx, Tag>,\n-        _arg4: OpTy<'tcx, Tag>,\n-        _arg5: OpTy<'tcx, Tag>,\n+        option: &OpTy<'tcx, Tag>,\n+        arg2: &OpTy<'tcx, Tag>,\n+        _arg3: &OpTy<'tcx, Tag>,\n+        _arg4: &OpTy<'tcx, Tag>,\n+        _arg5: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"linux\", \"prctl\");"}, {"sha": "5af2e5ab67e7fc43f55c2e9d0ae6fcc2a955717a", "filename": "src/shims/time.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -16,8 +16,8 @@ impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mi\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn clock_gettime(\n         &mut self,\n-        clk_id_op: OpTy<'tcx, Tag>,\n-        tp_op: OpTy<'tcx, Tag>,\n+        clk_id_op: &OpTy<'tcx, Tag>,\n+        tp_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -47,15 +47,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             immty_from_int_checked(tv_nsec, this.libc_ty_layout(\"c_long\")?)?,\n         ];\n \n-        this.write_packed_immediates(tp, &imms)?;\n+        this.write_packed_immediates(&tp, &imms)?;\n \n         Ok(0)\n     }\n \n     fn gettimeofday(\n         &mut self,\n-        tv_op: OpTy<'tcx, Tag>,\n-        tz_op: OpTy<'tcx, Tag>,\n+        tv_op: &OpTy<'tcx, Tag>,\n+        tz_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -81,13 +81,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             immty_from_int_checked(tv_usec, this.libc_ty_layout(\"suseconds_t\")?)?,\n         ];\n \n-        this.write_packed_immediates(tv, &imms)?;\n+        this.write_packed_immediates(&tv, &imms)?;\n \n         Ok(0)\n     }\n \n     #[allow(non_snake_case)]\n-    fn GetSystemTimeAsFileTime(&mut self, LPFILETIME_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+    fn GetSystemTimeAsFileTime(&mut self, LPFILETIME_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"windows\", \"GetSystemTimeAsFileTime\");\n@@ -110,12 +110,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             immty_from_uint_checked(dwLowDateTime, DWORD_tylayout)?,\n             immty_from_uint_checked(dwHighDateTime, DWORD_tylayout)?,\n         ];\n-        this.write_packed_immediates(this.deref_operand(LPFILETIME_op)?, &imms)?;\n+        this.write_packed_immediates(&this.deref_operand(LPFILETIME_op)?, &imms)?;\n         Ok(())\n     }\n \n     #[allow(non_snake_case)]\n-    fn QueryPerformanceCounter(&mut self, lpPerformanceCount_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn QueryPerformanceCounter(&mut self, lpPerformanceCount_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"windows\", \"QueryPerformanceCounter\");\n@@ -126,12 +126,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let duration = Instant::now().duration_since(this.machine.time_anchor);\n         let qpc = i64::try_from(duration.as_nanos())\n             .map_err(|_| err_unsup_format!(\"programs running longer than 2^63 nanoseconds are not supported\"))?;\n-        this.write_scalar(Scalar::from_i64(qpc), this.deref_operand(lpPerformanceCount_op)?.into())?;\n+        this.write_scalar(Scalar::from_i64(qpc), &this.deref_operand(lpPerformanceCount_op)?.into())?;\n         Ok(-1) // return non-zero on success\n     }\n \n     #[allow(non_snake_case)]\n-    fn QueryPerformanceFrequency(&mut self, lpFrequency_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn QueryPerformanceFrequency(&mut self, lpFrequency_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"windows\", \"QueryPerformanceFrequency\");\n@@ -142,7 +142,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // is consistent across all processors.\n         // Miri emulates a \"hardware\" performance counter with a resolution of 1ns,\n         // and thus 10^9 counts per second.\n-        this.write_scalar(Scalar::from_i64(1_000_000_000), this.deref_operand(lpFrequency_op)?.into())?;\n+        this.write_scalar(Scalar::from_i64(1_000_000_000), &this.deref_operand(lpFrequency_op)?.into())?;\n         Ok(-1) // Return non-zero on success\n     }\n \n@@ -159,7 +159,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             .map_err(|_| err_unsup_format!(\"programs running longer than 2^64 nanoseconds are not supported\").into())\n     }\n \n-    fn mach_timebase_info(&mut self, info_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn mach_timebase_info(&mut self, info_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"macos\", \"mach_timebase_info\");\n@@ -175,14 +175,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             immty_from_int_checked(denom, this.machine.layouts.u32)?\n         ];\n \n-        this.write_packed_immediates(info, &imms)?;\n+        this.write_packed_immediates(&info, &imms)?;\n         Ok(0) // KERN_SUCCESS\n     }\n \n     fn nanosleep(\n         &mut self,\n-        req_op: OpTy<'tcx, Tag>,\n-        _rem: OpTy<'tcx, Tag>,\n+        req_op: &OpTy<'tcx, Tag>,\n+        _rem: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         // Signal handlers are not supported, so rem will never be written to.\n "}, {"sha": "7f19fd1673660581d71cec14f59645d03d656d98", "filename": "src/shims/tls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -245,7 +245,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.call_function(\n             thread_callback,\n             &[Scalar::null_ptr(this).into(), reason.into(), Scalar::null_ptr(this).into()],\n-            Some(ret_place),\n+            Some(&ret_place),\n             StackPopCleanup::None { cleanup: true },\n         )?;\n \n@@ -267,7 +267,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.call_function(\n                 instance,\n                 &[data.into()],\n-                Some(ret_place),\n+                Some(&ret_place),\n                 StackPopCleanup::None { cleanup: true },\n             )?;\n \n@@ -307,7 +307,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             this.call_function(\n                 instance,\n                 &[ptr.into()],\n-                Some(ret_place),\n+                Some(&ret_place),\n                 StackPopCleanup::None { cleanup: true },\n             )?;\n "}, {"sha": "1f136060259a1af73057924bb90b6c11160034cb", "filename": "src/shims/windows/dlsym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fdlsym.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -26,7 +26,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         dlsym: Dlsym,\n         abi: Abi,\n         _args: &[OpTy<'tcx, Tag>],\n-        ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let (_dest, _ret) = ret.expect(\"we don't support any diverging dlsym\");"}, {"sha": "f8d62f6b323bf3bcde9ad60fef877b6b8740c94f", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -15,7 +15,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         link_name: &str,\n         abi: Abi,\n         args: &[OpTy<'tcx, Tag>],\n-        dest: PlaceTy<'tcx, Tag>,\n+        dest: &PlaceTy<'tcx, Tag>,\n         _ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n@@ -30,12 +30,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             // Environment related shims\n             \"GetEnvironmentVariableW\" => {\n-                let &[name, buf, size] = check_arg_count(args)?;\n+                let &[ref name, ref buf, ref size] = check_arg_count(args)?;\n                 let result = this.GetEnvironmentVariableW(name, buf, size)?;\n                 this.write_scalar(Scalar::from_u32(result), dest)?;\n             }\n             \"SetEnvironmentVariableW\" => {\n-                let &[name, value] = check_arg_count(args)?;\n+                let &[ref name, ref value] = check_arg_count(args)?;\n                 let result = this.SetEnvironmentVariableW(name, value)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n@@ -45,38 +45,38 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(result, dest)?;\n             }\n             \"FreeEnvironmentStringsW\" => {\n-                let &[env_block] = check_arg_count(args)?;\n+                let &[ref env_block] = check_arg_count(args)?;\n                 let result = this.FreeEnvironmentStringsW(env_block)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"GetCurrentDirectoryW\" => {\n-                let &[size, buf] = check_arg_count(args)?;\n+                let &[ref size, ref buf] = check_arg_count(args)?;\n                 let result = this.GetCurrentDirectoryW(size, buf)?;\n                 this.write_scalar(Scalar::from_u32(result), dest)?;\n             }\n             \"SetCurrentDirectoryW\" => {\n-                let &[path] = check_arg_count(args)?;\n+                let &[ref path] = check_arg_count(args)?;\n                 let result = this.SetCurrentDirectoryW(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // File related shims\n             \"GetStdHandle\" => {\n-                let &[which] = check_arg_count(args)?;\n+                let &[ref which] = check_arg_count(args)?;\n                 let which = this.read_scalar(which)?.to_i32()?;\n                 // We just make this the identity function, so we know later in `WriteFile`\n                 // which one it is.\n                 this.write_scalar(Scalar::from_machine_isize(which.into(), this), dest)?;\n             }\n             \"WriteFile\" => {\n-                let &[handle, buf, n, written_ptr, overlapped] = check_arg_count(args)?;\n+                let &[ref handle, ref buf, ref n, ref written_ptr, ref overlapped] = check_arg_count(args)?;\n                 this.read_scalar(overlapped)?.to_machine_usize(this)?; // this is a poiner, that we ignore\n                 let handle = this.read_scalar(handle)?.to_machine_isize(this)?;\n                 let buf = this.read_scalar(buf)?.check_init()?;\n                 let n = this.read_scalar(n)?.to_u32()?;\n                 let written_place = this.deref_operand(written_ptr)?;\n                 // Spec says to always write `0` first.\n-                this.write_null(written_place.into())?;\n+                this.write_null(&written_place.into())?;\n                 let written = if handle == -11 || handle == -12 {\n                     // stdout/stderr\n                     use std::io::{self, Write};\n@@ -93,7 +93,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 };\n                 // If there was no error, write back how much was written.\n                 if let Some(n) = written {\n-                    this.write_scalar(Scalar::from_u32(n), written_place.into())?;\n+                    this.write_scalar(Scalar::from_u32(n), &written_place.into())?;\n                 }\n                 // Return whether this was a success.\n                 this.write_scalar(\n@@ -104,7 +104,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Allocation\n             \"HeapAlloc\" => {\n-                let &[handle, flags, size] = check_arg_count(args)?;\n+                let &[ref handle, ref flags, ref size] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 let flags = this.read_scalar(flags)?.to_u32()?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n@@ -113,15 +113,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(res, dest)?;\n             }\n             \"HeapFree\" => {\n-                let &[handle, flags, ptr] = check_arg_count(args)?;\n+                let &[ref handle, ref flags, ref ptr] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 this.read_scalar(flags)?.to_u32()?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 this.free(ptr, MiriMemoryKind::WinHeap)?;\n                 this.write_scalar(Scalar::from_i32(1), dest)?;\n             }\n             \"HeapReAlloc\" => {\n-                let &[handle, flags, ptr, size] = check_arg_count(args)?;\n+                let &[ref handle, ref flags, ref ptr, ref size] = check_arg_count(args)?;\n                 this.read_scalar(handle)?.to_machine_isize(this)?;\n                 this.read_scalar(flags)?.to_u32()?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n@@ -132,7 +132,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // errno\n             \"SetLastError\" => {\n-                let &[error] = check_arg_count(args)?;\n+                let &[ref error] = check_arg_count(args)?;\n                 let error = this.read_scalar(error)?.check_init()?;\n                 this.set_last_error(error)?;\n             }\n@@ -144,7 +144,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"GetSystemInfo\" => {\n-                let &[system_info] = check_arg_count(args)?;\n+                let &[ref system_info] = check_arg_count(args)?;\n                 let system_info = this.deref_operand(system_info)?;\n                 // Initialize with `0`.\n                 this.memory.write_bytes(\n@@ -153,8 +153,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 )?;\n                 // Set number of processors.\n                 let dword_size = Size::from_bytes(4);\n-                let num_cpus = this.mplace_field(system_info, 6)?;\n-                this.write_scalar(Scalar::from_int(NUM_CPUS, dword_size), num_cpus.into())?;\n+                let num_cpus = this.mplace_field(&system_info, 6)?;\n+                this.write_scalar(Scalar::from_int(NUM_CPUS, dword_size), &num_cpus.into())?;\n             }\n \n             // Thread-local storage\n@@ -167,14 +167,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_uint(key, dest.layout.size), dest)?;\n             }\n             \"TlsGetValue\" => {\n-                let &[key] = check_arg_count(args)?;\n+                let &[ref key] = check_arg_count(args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n                 let active_thread = this.get_active_thread();\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"TlsSetValue\" => {\n-                let &[key, new_ptr] = check_arg_count(args)?;\n+                let &[ref key, ref new_ptr] = check_arg_count(args)?;\n                 let key = u128::from(this.read_scalar(key)?.to_u32()?);\n                 let active_thread = this.get_active_thread();\n                 let new_ptr = this.read_scalar(new_ptr)?.check_init()?;\n@@ -196,54 +196,54 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Time related shims\n             \"GetSystemTimeAsFileTime\" => {\n                 #[allow(non_snake_case)]\n-                let &[LPFILETIME] = check_arg_count(args)?;\n+                let &[ref LPFILETIME] = check_arg_count(args)?;\n                 this.GetSystemTimeAsFileTime(LPFILETIME)?;\n             }\n             \"QueryPerformanceCounter\" => {\n                 #[allow(non_snake_case)]\n-                let &[lpPerformanceCount] = check_arg_count(args)?;\n+                let &[ref lpPerformanceCount] = check_arg_count(args)?;\n                 let result = this.QueryPerformanceCounter(lpPerformanceCount)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"QueryPerformanceFrequency\" => {\n                 #[allow(non_snake_case)]\n-                let &[lpFrequency] = check_arg_count(args)?;\n+                let &[ref lpFrequency] = check_arg_count(args)?;\n                 let result = this.QueryPerformanceFrequency(lpFrequency)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Synchronization primitives\n             \"AcquireSRWLockExclusive\" => {\n-                let &[ptr] = check_arg_count(args)?;\n+                let &[ref ptr] = check_arg_count(args)?;\n                 this.AcquireSRWLockExclusive(ptr)?;\n             }\n             \"ReleaseSRWLockExclusive\" => {\n-                let &[ptr] = check_arg_count(args)?;\n+                let &[ref ptr] = check_arg_count(args)?;\n                 this.ReleaseSRWLockExclusive(ptr)?;\n             }\n             \"TryAcquireSRWLockExclusive\" => {\n-                let &[ptr] = check_arg_count(args)?;\n+                let &[ref ptr] = check_arg_count(args)?;\n                 let ret = this.TryAcquireSRWLockExclusive(ptr)?;\n                 this.write_scalar(Scalar::from_u8(ret), dest)?;\n             }\n             \"AcquireSRWLockShared\" => {\n-                let &[ptr] = check_arg_count(args)?;\n+                let &[ref ptr] = check_arg_count(args)?;\n                 this.AcquireSRWLockShared(ptr)?;\n             }\n             \"ReleaseSRWLockShared\" => {\n-                let &[ptr] = check_arg_count(args)?;\n+                let &[ref ptr] = check_arg_count(args)?;\n                 this.ReleaseSRWLockShared(ptr)?;\n             }\n             \"TryAcquireSRWLockShared\" => {\n-                let &[ptr] = check_arg_count(args)?;\n+                let &[ref ptr] = check_arg_count(args)?;\n                 let ret = this.TryAcquireSRWLockShared(ptr)?;\n                 this.write_scalar(Scalar::from_u8(ret), dest)?;\n             }\n \n             // Dynamic symbol loading\n             \"GetProcAddress\" => {\n                 #[allow(non_snake_case)]\n-                let &[hModule, lpProcName] = check_arg_count(args)?;\n+                let &[ref hModule, ref lpProcName] = check_arg_count(args)?;\n                 this.read_scalar(hModule)?.to_machine_isize(this)?;\n                 let name = this.memory.read_c_str(this.read_scalar(lpProcName)?.check_init()?)?;\n                 if let Some(dlsym) = Dlsym::from_str(name, &this.tcx.sess.target.os)? {\n@@ -257,15 +257,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Miscellaneous\n             \"SystemFunction036\" => {\n                 // The actual name of 'RtlGenRandom'\n-                let &[ptr, len] = check_arg_count(args)?;\n+                let &[ref ptr, ref len] = check_arg_count(args)?;\n                 let ptr = this.read_scalar(ptr)?.check_init()?;\n                 let len = this.read_scalar(len)?.to_u32()?;\n                 this.gen_random(ptr, len.into())?;\n                 this.write_scalar(Scalar::from_bool(true), dest)?;\n             }\n             \"GetConsoleScreenBufferInfo\" => {\n                 // `term` needs this, so we fake it.\n-                let &[console, buffer_info] = check_arg_count(args)?;\n+                let &[ref console, ref buffer_info] = check_arg_count(args)?;\n                 this.read_scalar(console)?.to_machine_isize(this)?;\n                 this.deref_operand(buffer_info)?;\n                 // Indicate an error.\n@@ -274,7 +274,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"GetConsoleMode\" => {\n                 // Windows \"isatty\" (in libtest) needs this, so we fake it.\n-                let &[console, mode] = check_arg_count(args)?;\n+                let &[ref console, ref mode] = check_arg_count(args)?;\n                 this.read_scalar(console)?.to_machine_isize(this)?;\n                 this.deref_operand(mode)?;\n                 // Indicate an error.\n@@ -302,13 +302,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"SetConsoleTextAttribute\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n                 #[allow(non_snake_case)]\n-                let &[_hConsoleOutput, _wAttribute] = check_arg_count(args)?;\n+                let &[ref _hConsoleOutput, ref _wAttribute] = check_arg_count(args)?;\n                 // Pretend these does not exist / nothing happened, by returning zero.\n                 this.write_null(dest)?;\n             }\n             \"AddVectoredExceptionHandler\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n                 #[allow(non_snake_case)]\n-                let &[_First, _Handler] = check_arg_count(args)?;\n+                let &[ref _First, ref _Handler] = check_arg_count(args)?;\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n                 this.write_scalar(Scalar::from_machine_usize(1, this), dest)?;\n             }\n@@ -324,7 +324,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"DeleteCriticalSection\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n                 #[allow(non_snake_case)]\n-                let &[_lpCriticalSection] = check_arg_count(args)?;\n+                let &[ref _lpCriticalSection] = check_arg_count(args)?;\n                 assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n                 // Nothing to do, not even a return value.\n                 // (Windows locks are reentrant, and we have only 1 thread,\n@@ -333,7 +333,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"TryEnterCriticalSection\"\n             if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n                 #[allow(non_snake_case)]\n-                let &[_lpCriticalSection] = check_arg_count(args)?;\n+                let &[ref _lpCriticalSection] = check_arg_count(args)?;\n                 assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n                 // There is only one thread, so this always succeeds and returns TRUE.\n                 this.write_scalar(Scalar::from_i32(1), dest)?;"}, {"sha": "caf8942afd9303fb860b6822a8a7468b0d7b0457", "filename": "src/shims/windows/sync.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fsync.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -5,7 +5,7 @@ use crate::*;\n \n fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    lock_op: OpTy<'tcx, Tag>,\n+    lock_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, RwLockId> {\n     let id = ecx.read_scalar_at_offset(lock_op, 0, ecx.machine.layouts.u32)?.to_u32()?;\n     if id == 0 {\n@@ -24,7 +24,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn AcquireSRWLockExclusive(\n         &mut self,\n-        lock_op: OpTy<'tcx, Tag>,\n+        lock_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n@@ -49,7 +49,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn TryAcquireSRWLockExclusive(\n         &mut self,\n-        lock_op: OpTy<'tcx, Tag>,\n+        lock_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, u8> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n@@ -67,7 +67,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn ReleaseSRWLockExclusive(\n         &mut self,\n-        lock_op: OpTy<'tcx, Tag>,\n+        lock_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n@@ -84,7 +84,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn AcquireSRWLockShared(\n         &mut self,\n-        lock_op: OpTy<'tcx, Tag>,\n+        lock_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n@@ -102,7 +102,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn TryAcquireSRWLockShared(\n         &mut self,\n-        lock_op: OpTy<'tcx, Tag>,\n+        lock_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, u8> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n@@ -119,7 +119,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn ReleaseSRWLockShared(\n         &mut self,\n-        lock_op: OpTy<'tcx, Tag>,\n+        lock_op: &OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;"}, {"sha": "52f4ddbc386c879ba2487758cce67ed7dde7f7b3", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea86335318fd06ec964d9a86b187995bda1b6c7d/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=ea86335318fd06ec964d9a86b187995bda1b6c7d", "patch": "@@ -521,7 +521,7 @@ impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for crate::MiriEvalContext\n trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn reborrow(\n         &mut self,\n-        place: MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Tag>,\n         size: Size,\n         kind: RefKind,\n         new_tag: Tag,\n@@ -577,15 +577,15 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// `mutbl` can be `None` to make this a raw pointer.\n     fn retag_reference(\n         &mut self,\n-        val: ImmTy<'tcx, Tag>,\n+        val: &ImmTy<'tcx, Tag>,\n         kind: RefKind,\n         protect: bool,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n         let this = self.eval_context_mut();\n         // We want a place for where the ptr *points to*, so we get one.\n         let place = this.ref_to_mplace(val)?;\n         let size = this\n-            .size_and_align_of_mplace(place)?\n+            .size_and_align_of_mplace(&place)?\n             .map(|(size, _)| size)\n             .unwrap_or_else(|| place.layout.size);\n         // `reborrow` relies on getting a `Pointer` and everything being in-bounds,\n@@ -595,7 +595,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let place = this.mplace_access_checked(place, Some(Align::from_bytes(1).unwrap()))?;\n         // Nothing to do for ZSTs.\n         if size == Size::ZERO {\n-            return Ok(val);\n+            return Ok(*val);\n         }\n \n         // Compute new borrow.\n@@ -610,7 +610,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         };\n \n         // Reborrow.\n-        this.reborrow(place, size, kind, new_tag, protect)?;\n+        this.reborrow(&place, size, kind, new_tag, protect)?;\n         let new_place = place.replace_tag(new_tag);\n \n         // Return new pointer.\n@@ -620,7 +620,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    fn retag(&mut self, kind: RetagKind, place: PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+    fn retag(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         // Determine mutability and whether to add a protector.\n         // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n@@ -649,8 +649,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // but might also cost us optimization and analyses. We will have to experiment more with this.\n         if let Some((mutbl, protector)) = qualify(place.layout.ty, kind) {\n             // Fast path.\n-            let val = this.read_immediate(this.place_to_op(place)?)?;\n-            let val = this.retag_reference(val, mutbl, protector)?;\n+            let val = this.read_immediate(&this.place_to_op(place)?)?;\n+            let val = this.retag_reference(&val, mutbl, protector)?;\n             this.write_immediate(*val, place)?;\n         }\n \n@@ -675,16 +675,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return Ok(());\n         }\n         // We need this to be in-memory to use tagged pointers.\n-        let return_place = this.force_allocation(return_place)?;\n+        let return_place = this.force_allocation(&return_place)?;\n \n         // We have to turn the place into a pointer to use the existing code.\n         // (The pointer type does not matter, so we use a raw pointer.)\n         let ptr_layout = this.layout_of(this.tcx.mk_mut_ptr(return_place.layout.ty))?;\n         let val = ImmTy::from_immediate(return_place.to_ref(), ptr_layout);\n         // Reborrow it.\n-        let val = this.retag_reference(val, RefKind::Unique { two_phase: false }, /*protector*/ true)?;\n+        let val = this.retag_reference(&val, RefKind::Unique { two_phase: false }, /*protector*/ true)?;\n         // And use reborrowed pointer for return place.\n-        let return_place = this.ref_to_mplace(val)?;\n+        let return_place = this.ref_to_mplace(&val)?;\n         this.frame_mut().return_place = Some(return_place.into());\n \n         Ok(())"}]}