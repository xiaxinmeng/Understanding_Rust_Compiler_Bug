{"sha": "cbb32a94181d359ca16659b3e74303e945e8ea92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiYjMyYTk0MTgxZDM1OWNhMTY2NTliM2U3NDMwM2U5NDVlOGVhOTI=", "commit": {"author": {"name": "Malo Jaffr\u00e9", "email": "jaffre.malo@gmail.com", "date": "2017-12-31T16:17:01Z"}, "committer": {"name": "Malo Jaffr\u00e9", "email": "jaffre.malo@gmail.com", "date": "2018-01-01T13:44:12Z"}, "message": "Fix docs for future pulldown migration", "tree": {"sha": "785a92dda4d9ec7b385d05d81db60a8a615cd5a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/785a92dda4d9ec7b385d05d81db60a8a615cd5a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbb32a94181d359ca16659b3e74303e945e8ea92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbb32a94181d359ca16659b3e74303e945e8ea92", "html_url": "https://github.com/rust-lang/rust/commit/cbb32a94181d359ca16659b3e74303e945e8ea92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbb32a94181d359ca16659b3e74303e945e8ea92/comments", "author": {"login": "MaloJaffre", "id": 16278359, "node_id": "MDQ6VXNlcjE2Mjc4MzU5", "avatar_url": "https://avatars.githubusercontent.com/u/16278359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MaloJaffre", "html_url": "https://github.com/MaloJaffre", "followers_url": "https://api.github.com/users/MaloJaffre/followers", "following_url": "https://api.github.com/users/MaloJaffre/following{/other_user}", "gists_url": "https://api.github.com/users/MaloJaffre/gists{/gist_id}", "starred_url": "https://api.github.com/users/MaloJaffre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MaloJaffre/subscriptions", "organizations_url": "https://api.github.com/users/MaloJaffre/orgs", "repos_url": "https://api.github.com/users/MaloJaffre/repos", "events_url": "https://api.github.com/users/MaloJaffre/events{/privacy}", "received_events_url": "https://api.github.com/users/MaloJaffre/received_events", "type": "User", "site_admin": false}, "committer": {"login": "MaloJaffre", "id": 16278359, "node_id": "MDQ6VXNlcjE2Mjc4MzU5", "avatar_url": "https://avatars.githubusercontent.com/u/16278359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/MaloJaffre", "html_url": "https://github.com/MaloJaffre", "followers_url": "https://api.github.com/users/MaloJaffre/followers", "following_url": "https://api.github.com/users/MaloJaffre/following{/other_user}", "gists_url": "https://api.github.com/users/MaloJaffre/gists{/gist_id}", "starred_url": "https://api.github.com/users/MaloJaffre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/MaloJaffre/subscriptions", "organizations_url": "https://api.github.com/users/MaloJaffre/orgs", "repos_url": "https://api.github.com/users/MaloJaffre/repos", "events_url": "https://api.github.com/users/MaloJaffre/events{/privacy}", "received_events_url": "https://api.github.com/users/MaloJaffre/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8395798d1aa33bb6ee74d05825bb775a75a9b70e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8395798d1aa33bb6ee74d05825bb775a75a9b70e", "html_url": "https://github.com/rust-lang/rust/commit/8395798d1aa33bb6ee74d05825bb775a75a9b70e"}], "stats": {"total": 222, "additions": 128, "deletions": 94}, "files": [{"sha": "e635df5204007e7496256236695ad80f154370f8", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -148,10 +148,11 @@ impl<T> TypedArena<T> {\n         }\n     }\n \n-    /// Allocates a slice of objects that are copy into the `TypedArena`, returning a mutable\n+    /// Allocates a slice of objects that are copied into the `TypedArena`, returning a mutable\n     /// reference to it. Will panic if passed a zero-sized types.\n     ///\n     /// Panics:\n+    ///\n     ///  - Zero-sized types\n     ///  - Zero-length slices\n     #[inline]\n@@ -369,6 +370,7 @@ impl DroplessArena {\n     /// reference to it. Will panic if passed a zero-sized type.\n     ///\n     /// Panics:\n+    ///\n     ///  - Zero-sized types\n     ///  - Zero-length slices\n     #[inline]"}, {"sha": "cd893b9784ab6aa4a117587df3348aa5a74d0428", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -306,7 +306,7 @@ pub enum LabelText<'a> {\n     LabelStr(Cow<'a, str>),\n \n     /// This kind of label uses the graphviz label escString type:\n-    /// http://www.graphviz.org/content/attrs#kescString\n+    /// <http://www.graphviz.org/content/attrs#kescString>\n     ///\n     /// Occurrences of backslashes (`\\`) are not escaped; instead they\n     /// are interpreted as initiating an escString escape sequence.\n@@ -326,7 +326,7 @@ pub enum LabelText<'a> {\n }\n \n /// The style for a node or edge.\n-/// See http://www.graphviz.org/doc/info/attrs.html#k:style for descriptions.\n+/// See <http://www.graphviz.org/doc/info/attrs.html#k:style> for descriptions.\n /// Note that some of these are not valid for edges.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum Style {"}, {"sha": "7e46c202a84d43d561e6b368d53a5225584fa23b", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -56,7 +56,7 @@ impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     /// map; and `CurrentTask` represents the current task when\n     /// `memoize` is invoked.\n     ///\n-    /// **Important:* when `op` is invoked, the current task will be\n+    /// **Important:** when `op` is invoked, the current task will be\n     /// switched to `Map(key)`. Therefore, if `op` makes use of any\n     /// HIR nodes or shared state accessed through its closure\n     /// environment, it must explicitly register a read of that"}, {"sha": "8e4a4d32c0badd5df7c597f3bece364c2b4fc0cb", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -71,13 +71,16 @@ pub enum Def {\n /// `base_def` is definition of resolved part of the\n /// path, `unresolved_segments` is the number of unresolved\n /// segments.\n-///     module::Type::AssocX::AssocY::MethodOrAssocType\n-///     ^~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-///     base_def      unresolved_segments = 3\n ///\n-///     <T as Trait>::AssocX::AssocY::MethodOrAssocType\n-///           ^~~~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~\n-///           base_def        unresolved_segments = 2\n+/// ```text\n+/// module::Type::AssocX::AssocY::MethodOrAssocType\n+/// ^~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+/// base_def      unresolved_segments = 3\n+///\n+/// <T as Trait>::AssocX::AssocY::MethodOrAssocType\n+///       ^~~~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~\n+///       base_def        unresolved_segments = 2\n+/// ```\n #[derive(Copy, Clone, Debug)]\n pub struct PathResolution {\n     base_def: Def,"}, {"sha": "1eaacdb1d7ff341cba89d1ccc922cdc5dc87bda0", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -33,6 +33,7 @@ use syntax_pos::Span;\n /// and a body (as well as a NodeId, a span, etc).\n ///\n /// More specifically, it is one of either:\n+///\n ///   - A function item,\n ///   - A closure expr (i.e. an ExprClosure), or\n ///   - The default implementation for a trait method."}, {"sha": "f5b88dbc2a9c77aab5b619f5b9a524a80440ae28", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -147,21 +147,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Let's work through an example to explain how it works.  Assume\n     /// the current function is as follows:\n     ///\n-    ///     fn foo<'a, 'b>(..) -> (impl Bar<'a>, impl Bar<'b>)\n+    /// ```text\n+    /// fn foo<'a, 'b>(..) -> (impl Bar<'a>, impl Bar<'b>)\n+    /// ```\n     ///\n     /// Here, we have two `impl Trait` types whose values are being\n     /// inferred (the `impl Bar<'a>` and the `impl\n     /// Bar<'b>`). Conceptually, this is sugar for a setup where we\n     /// define underlying abstract types (`Foo1`, `Foo2`) and then, in\n     /// the return type of `foo`, we *reference* those definitions:\n     ///\n-    ///     abstract type Foo1<'x>: Bar<'x>;\n-    ///     abstract type Foo2<'x>: Bar<'x>;\n-    ///     fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n-    ///                        //  ^^^^ ^^\n-    ///                        //  |    |\n-    ///                        //  |    substs\n-    ///                        //  def_id\n+    /// ```text\n+    /// abstract type Foo1<'x>: Bar<'x>;\n+    /// abstract type Foo2<'x>: Bar<'x>;\n+    /// fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n+    ///                    //  ^^^^ ^^\n+    ///                    //  |    |\n+    ///                    //  |    substs\n+    ///                    //  def_id\n+    /// ```\n     ///\n     /// As indicating in the comments above, each of those references\n     /// is (in the compiler) basically a substitution (`substs`)\n@@ -175,8 +179,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// `Foo2`.  That is, this gives rise to higher-order (pattern) unification\n     /// constraints like:\n     ///\n-    ///     for<'a> (Foo1<'a> = C1)\n-    ///     for<'b> (Foo1<'b> = C2)\n+    /// ```text\n+    /// for<'a> (Foo1<'a> = C1)\n+    /// for<'b> (Foo1<'b> = C2)\n+    /// ```\n     ///\n     /// For these equation to be satisfiable, the types `C1` and `C2`\n     /// can only refer to a limited set of regions. For example, `C1`\n@@ -189,15 +195,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// regions. In fact, it is fairly likely that they do! Consider\n     /// this possible definition of `foo`:\n     ///\n-    ///     fn foo<'a, 'b>(x: &'a i32, y: &'b i32) -> (impl Bar<'a>, impl Bar<'b>) {\n+    /// ```text\n+    /// fn foo<'a, 'b>(x: &'a i32, y: &'b i32) -> (impl Bar<'a>, impl Bar<'b>) {\n     ///         (&*x, &*y)\n     ///     }\n+    /// ```\n     ///\n     /// Here, the values for the concrete types of the two impl\n     /// traits will include inference variables:\n     ///\n-    ///     &'0 i32\n-    ///     &'1 i32\n+    /// ```text\n+    /// &'0 i32\n+    /// &'1 i32\n+    /// ```\n     ///\n     /// Ordinarily, the subtyping rules would ensure that these are\n     /// sufficiently large. But since `impl Bar<'a>` isn't a specific\n@@ -207,7 +217,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// inferred type are regions that could validly appear.\n     ///\n     /// This is actually a bit of a tricky constraint in general. We\n-    /// want to say that each variable (e.g., `'0``) can only take on\n+    /// want to say that each variable (e.g., `'0`) can only take on\n     /// values that were supplied as arguments to the abstract type\n     /// (e.g., `'a` for `Foo1<'a>`) or `'static`, which is always in\n     /// scope. We don't have a constraint quite of this kind in the current\n@@ -225,7 +235,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// In some cases, there is no minimum. Consider this example:\n     ///\n-    ///    fn baz<'a, 'b>() -> impl Trait<'a, 'b> { ... }\n+    /// ```text\n+    /// fn baz<'a, 'b>() -> impl Trait<'a, 'b> { ... }\n+    /// ```\n     ///\n     /// Here we would report an error, because `'a` and `'b` have no\n     /// relation to one another.\n@@ -245,8 +257,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// which is the current function. It also means that we can\n     /// take \"implied bounds\" into account in some cases:\n     ///\n-    ///     trait SomeTrait<'a, 'b> { }\n-    ///     fn foo<'a, 'b>(_: &'a &'b u32) -> impl SomeTrait<'a, 'b> { .. }\n+    /// ```text\n+    /// trait SomeTrait<'a, 'b> { }\n+    /// fn foo<'a, 'b>(_: &'a &'b u32) -> impl SomeTrait<'a, 'b> { .. }\n+    /// ```\n     ///\n     /// Here, the fact that `'b: 'a` is known only because of the\n     /// implied bounds from the `&'a &'b u32` parameter, and is not"}, {"sha": "049bf4470cbc64575b8ef5754a0d81b30590caeb", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -53,9 +53,9 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n /// expression for the indexed statement, until the end of the block.\n ///\n /// So: the following code can be broken down into the scopes beneath:\n-/// ```\n+///\n+/// ```text\n /// let a = f().g( 'b: { let x = d(); let y = d(); x.h(y)  }   ) ;\n-/// ```\n ///\n ///                                                              +-+ (D12.)\n ///                                                        +-+       (D11.)\n@@ -82,6 +82,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n /// (R10.): Remainder scope for block `'b:`, stmt 1 (let y = ...).\n /// (D11.): DestructionScope for temporaries and bindings from block `'b:`.\n /// (D12.): DestructionScope for temporaries created during M1 (e.g. f()).\n+/// ```\n ///\n /// Note that while the above picture shows the destruction scopes\n /// as following their corresponding node scopes, in the internal"}, {"sha": "3aa94b3469942bea97eedf6ef9e9b42779cf58fe", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -497,6 +497,7 @@ pub struct LocalDecl<'tcx> {\n     ///\n     /// That's it, if we have a let-statement like the one in this\n     /// function:\n+    ///\n     /// ```\n     /// fn foo(x: &str) {\n     ///     #[allow(unused_mut)]\n@@ -540,6 +541,7 @@ pub struct LocalDecl<'tcx> {\n     ///\n     /// The end result looks like this:\n     ///\n+    /// ```text\n     /// ROOT SCOPE\n     ///  \u2502{ argument x: &str }\n     ///  \u2502\n@@ -559,6 +561,7 @@ pub struct LocalDecl<'tcx> {\n     ///  \u2502 \u2502{ let x: u32 }\n     ///  \u2502 \u2502\u2190 x.source_info.scope\n     ///  \u2502 \u2502\u2190 `drop(x)` // this accesses `x: u32`\n+    /// ```\n     pub syntactic_scope: VisibilityScope,\n }\n "}, {"sha": "6482ecc7ee16124f8597c8905f5a975f017ba189", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -906,6 +906,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// For defaulted traits, we use a co-inductive strategy to solve, so\n     /// that recursion is ok. This routine returns true if the top of the\n     /// stack (`cycle[0]`):\n+    ///\n     /// - is a defaulted trait, and\n     /// - it also appears in the backtrace at some position `X`; and,\n     /// - all the predicates at positions `X..` between `X` an the top are"}, {"sha": "6df6bb9df232044512896ae1db652ae9787fb40b", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -22,38 +22,38 @@ use ty::subst::Substs;\n /// Here are some common scenarios:\n ///\n /// 1. The simplest cases are where a pointer is not adjusted fat vs thin.\n-/// Here the pointer will be dereferenced N times (where a dereference can\n-/// happen to raw or borrowed pointers or any smart pointer which implements\n-/// Deref, including Box<_>). The types of dereferences is given by\n-/// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n-/// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n-/// `false`.\n+///    Here the pointer will be dereferenced N times (where a dereference can\n+///    happen to raw or borrowed pointers or any smart pointer which implements\n+///    Deref, including Box<_>). The types of dereferences is given by\n+///    `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n+///    by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n+///    `false`.\n ///\n /// 2. A thin-to-fat coercion involves unsizing the underlying data. We start\n-/// with a thin pointer, deref a number of times, unsize the underlying data,\n-/// then autoref. The 'unsize' phase may change a fixed length array to a\n-/// dynamically sized one, a concrete object to a trait object, or statically\n-/// sized struct to a dynamically sized one. E.g., &[i32; 4] -> &[i32] is\n-/// represented by:\n+///    with a thin pointer, deref a number of times, unsize the underlying data,\n+///    then autoref. The 'unsize' phase may change a fixed length array to a\n+///    dynamically sized one, a concrete object to a trait object, or statically\n+///    sized struct to a dynamically sized one. E.g., &[i32; 4] -> &[i32] is\n+///    represented by:\n ///\n-/// ```\n-/// Deref(None) -> [i32; 4],\n-/// Borrow(AutoBorrow::Ref) -> &[i32; 4],\n-/// Unsize -> &[i32],\n-/// ```\n+///    ```\n+///    Deref(None) -> [i32; 4],\n+///    Borrow(AutoBorrow::Ref) -> &[i32; 4],\n+///    Unsize -> &[i32],\n+///    ```\n ///\n-/// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n-/// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n-/// The autoderef and -ref are the same as in the above example, but the type\n-/// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n-/// the underlying conversions from `[i32; 4]` to `[i32]`.\n+///    Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n+///    E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n+///    The autoderef and -ref are the same as in the above example, but the type\n+///    stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n+///    the underlying conversions from `[i32; 4]` to `[i32]`.\n ///\n /// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n-/// that case, we have the pointer we need coming in, so there are no\n-/// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n-/// At some point, of course, `Box` should move out of the compiler, in which\n-/// case this is analogous to transforming a struct. E.g., Box<[i32; 4]> ->\n-/// Box<[i32]> is an `Adjust::Unsize` with the target `Box<[i32]>`.\n+///    that case, we have the pointer we need coming in, so there are no\n+///    autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n+///    At some point, of course, `Box` should move out of the compiler, in which\n+///    case this is analogous to transforming a struct. E.g., Box<[i32; 4]> ->\n+///    Box<[i32]> is an `Adjust::Unsize` with the target `Box<[i32]>`.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Adjustment<'tcx> {\n     pub kind: Adjust<'tcx>,"}, {"sha": "63bf52a9bdf786d7603cf2cf43f8e4a012927d0f", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -28,7 +28,7 @@ pub enum InstanceDef<'tcx> {\n     Item(DefId),\n     Intrinsic(DefId),\n \n-    /// <fn() as FnTrait>::call_*\n+    /// \\<fn() as FnTrait>::call_*\n     /// def-id is FnTrait::call_*\n     FnPtrShim(DefId, Ty<'tcx>),\n "}, {"sha": "2a8c259dff89b4bab9009a3a75d3d1424dd7b366", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -340,8 +340,8 @@ impl AddAssign for Size {\n \n /// Alignment of a type in bytes, both ABI-mandated and preferred.\n /// Each field is a power of two, giving the alignment a maximum\n-/// value of 2^(2^8 - 1), which is limited by LLVM to a i32, with\n-/// a maximum capacity of 2^31 - 1 or 2147483647.\n+/// value of 2<sup>(2<sup>8</sup> - 1)</sup>, which is limited by LLVM to a i32, with\n+/// a maximum capacity of 2<sup>31</sup> - 1 or 2147483647.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Align {\n     abi: u8,\n@@ -651,11 +651,13 @@ impl Scalar {\n }\n \n /// The first half of a fat pointer.\n+///\n /// - For a trait object, this is the address of the box.\n /// - For a slice, this is the base address.\n pub const FAT_PTR_ADDR: usize = 0;\n \n /// The second half of a fat pointer.\n+///\n /// - For a trait object, this is the address of the vtable.\n /// - For a slice, this is the length.\n pub const FAT_PTR_EXTRA: usize = 1;"}, {"sha": "2cea8c01cdf9604fde2adbe03f19928c67542618", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -1098,8 +1098,8 @@ pub type PolySubtypePredicate<'tcx> = ty::Binder<SubtypePredicate<'tcx>>;\n /// In particular, form #1 is \"desugared\" to the combination of a\n /// normal trait predicate (`T : TraitRef<...>`) and one of these\n /// predicates. Form #2 is a broader form in that it also permits\n-/// equality between arbitrary types. Processing an instance of Form\n-/// #2 eventually yields one of these `ProjectionPredicate`\n+/// equality between arbitrary types. Processing an instance of\n+/// Form #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct ProjectionPredicate<'tcx> {\n@@ -1401,7 +1401,7 @@ bitflags! {\n         /// fields/variants) and as such, whether downstream crates must match exhaustively on the\n         /// fields/variants of this data type.\n         ///\n-        /// See RFC 2008 (https://github.com/rust-lang/rfcs/pull/2008).\n+        /// See RFC 2008 (<https://github.com/rust-lang/rfcs/pull/2008>).\n         const IS_NON_EXHAUSTIVE   = 1 << 5;\n     }\n }"}, {"sha": "433c72f4b2ca67c503ccbb82974896d474c1f152", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -673,6 +673,7 @@ impl<T> Binder<T> {\n     /// accounting.\n     ///\n     /// Some examples where `skip_binder` is reasonable:\n+    ///\n     /// - extracting the def-id from a PolyTraitRef;\n     /// - comparing the self type of a PolyTraitRef to see if it is equal to\n     ///   a type parameter `X`, since the type `X`  does not reference any regions\n@@ -992,8 +993,8 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// happen, you can use `leak_check`. This is more clearly explained\n /// by infer/higher_ranked/README.md.\n ///\n-/// [1] http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n-/// [2] http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n+/// [1]: http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n+/// [2]: http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n #[derive(Clone, PartialEq, Eq, Hash, Copy, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n pub enum RegionKind {\n     // Region bound in a type or fn declaration which will be"}, {"sha": "3e76b60b84a13ad69b53a51d30a6e007c2fa6e08", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -65,11 +65,11 @@ pub trait Semantics: Sized {\n     /// Number of bits in the significand. This includes the integer bit.\n     const PRECISION: usize;\n \n-    /// The largest E such that 2^E is representable; this matches the\n+    /// The largest E such that 2<sup>E</sup> is representable; this matches the\n     /// definition of IEEE 754.\n     const MAX_EXP: ExpInt;\n \n-    /// The smallest E such that 2^E is a normalized number; this\n+    /// The smallest E such that 2<sup>E</sup> is a normalized number; this\n     /// matches the definition of IEEE 754.\n     const MIN_EXP: ExpInt = -Self::MAX_EXP + 1;\n \n@@ -2608,7 +2608,7 @@ mod sig {\n     ///\n     /// `(n - 1) * (n - 1) + 2 * (n - 1) == (n - 1) * (n + 1)`\n     ///\n-    /// which is less than n^2.\n+    /// which is less than n<sup>2</sup>.\n     pub(super) fn widening_mul(a: Limb, b: Limb) -> [Limb; 2] {\n         let mut wide = [0, 0];\n "}, {"sha": "3afc2f684009d41e8d23b113bd2d9a9a59fd2dd8", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -10,7 +10,8 @@\n \n //! Port of LLVM's APFloat software floating-point implementation from the\n //! following C++ sources (please update commit hash when backporting):\n-//! https://github.com/llvm-mirror/llvm/tree/23efab2bbd424ed13495a420ad8641cb2c6c28f9\n+//! <https://github.com/llvm-mirror/llvm/tree/23efab2bbd424ed13495a420ad8641cb2c6c28f9>\n+//!\n //! * `include/llvm/ADT/APFloat.h` -> `Float` and `FloatConvert` traits\n //! * `lib/Support/APFloat.cpp` -> `ieee` and `ppc` modules\n //! * `unittests/ADT/APFloatTest.cpp` -> `tests` directory\n@@ -221,8 +222,8 @@ pub struct ParseError(pub &'static str);\n ///\n /// `apfloat` does not provide any exception handling beyond default exception\n /// handling. We represent Signaling NaNs via IEEE-754R 2008 6.2.1 should clause\n-/// by encoding Signaling NaNs with the first bit of its trailing significand as\n-/// 0.\n+/// by encoding Signaling NaNs with the first bit of its trailing significand\n+/// as 0.\n ///\n /// Future work\n /// ===========\n@@ -259,11 +260,11 @@ pub trait Float\n     /// Number of bits in the significand. This includes the integer bit.\n     const PRECISION: usize;\n \n-    /// The largest E such that 2^E is representable; this matches the\n+    /// The largest E such that 2<sup>E</sup> is representable; this matches the\n     /// definition of IEEE 754.\n     const MAX_EXP: ExpInt;\n \n-    /// The smallest E such that 2^E is a normalized number; this\n+    /// The smallest E such that 2<sup>E</sup> is a normalized number; this\n     /// matches the definition of IEEE 754.\n     const MIN_EXP: ExpInt;\n \n@@ -571,7 +572,7 @@ pub trait Float\n     ///\n     fn ilogb(self) -> ExpInt;\n \n-    /// Returns: self * 2^exp for integral exponents.\n+    /// Returns: self * 2<sup>exp</sup> for integral exponents.\n     fn scalbn_r(self, exp: ExpInt, round: Round) -> Self;\n     fn scalbn(self, exp: ExpInt) -> Self {\n         self.scalbn_r(exp, Round::NearestTiesToEven)"}, {"sha": "6fcdedfb3404211de8df2d057cf83711826ec2bf", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -367,7 +367,7 @@ pub struct TargetOptions {\n     /// Whether the linker support GNU-like arguments such as -O. Defaults to false.\n     pub linker_is_gnu: bool,\n     /// The MinGW toolchain has a known issue that prevents it from correctly\n-    /// handling COFF object files with more than 2^15 sections. Since each weak\n+    /// handling COFF object files with more than 2<sup>15</sup> sections. Since each weak\n     /// symbol needs its own COMDAT section, weak linkage implies a large\n     /// number sections that easily exceeds the given limit for larger\n     /// codebases. Consequently we want a way to disallow weak linkage on some"}, {"sha": "dc487f1162ca9d074b8735937e069b846a7dbc60", "filename": "src/librustc_data_structures/control_flow_graph/dominators/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -12,7 +12,7 @@\n //! A Simple, Fast Dominance Algorithm.\n //! Keith D. Cooper, Timothy J. Harvey, and Ken Kennedy\n //! Rice Computer Science TS-06-33870\n-//! https://www.cs.rice.edu/~keith/EMBED/dom.pdf\n+//! <https://www.cs.rice.edu/~keith/EMBED/dom.pdf>\n \n use super::ControlFlowGraph;\n use super::iterate::reverse_post_order;"}, {"sha": "e9a8c2427b3734ba5135ad7e28822bf4aa622998", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -149,7 +149,7 @@\n //! The binary of a crate will not only contain machine code for the items\n //! defined in the source code of that crate. It will also contain monomorphic\n //! instantiations of any extern generic functions and of functions marked with\n-//! #[inline].\n+//! `#[inline]`.\n //! The collection algorithm handles this more or less mono. If it is\n //! about to create a mono item for something with an external `DefId`,\n //! it will take a look if the MIR for that item is available, and if so just"}, {"sha": "996195800cef891664b3c6a4cc4104fefd808d98", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -94,7 +94,7 @@\n //!   inlined, so it can distribute function instantiations accordingly. Since\n //!   there is no way of knowing for sure which functions LLVM will decide to\n //!   inline in the end, we apply a heuristic here: Only functions marked with\n-//!   #[inline] are considered for inlining by the partitioner. The current\n+//!   `#[inline]` are considered for inlining by the partitioner. The current\n //!   implementation will not try to determine if a function is likely to be\n //!   inlined by looking at the functions definition.\n //!"}, {"sha": "15682b2d459fa30dde1f820a1ae04441985a2988", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -1543,7 +1543,7 @@ pub enum TraitObjectSyntax {\n \n /// Inline assembly dialect.\n ///\n-/// E.g. `\"intel\"` as in `asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")``\n+/// E.g. `\"intel\"` as in `asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum AsmDialect {\n     Att,\n@@ -1552,7 +1552,7 @@ pub enum AsmDialect {\n \n /// Inline assembly.\n ///\n-/// E.g. `\"={eax}\"(result)` as in `asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")``\n+/// E.g. `\"={eax}\"(result)` as in `asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsmOutput {\n     pub constraint: Symbol,"}, {"sha": "129defd20932499e1773d6457f4f588a75b237c0", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -391,6 +391,7 @@ impl CodeMap {\n     /// Returns `Some(span)`, a union of the lhs and rhs span.  The lhs must precede the rhs. If\n     /// there are gaps between lhs and rhs, the resulting union will cross these gaps.\n     /// For this to work, the spans have to be:\n+    ///\n     ///    * the ctxt of both spans much match\n     ///    * the lhs span needs to end on the same line the rhs span begins\n     ///    * the lhs span must start at or before the rhs span"}, {"sha": "0d3be28ffefe56915d83dff535199bf30b65611e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -776,7 +776,8 @@ impl<'a> ExtCtxt<'a> {\n     /// Emit `msg` attached to `sp`, and stop compilation immediately.\n     ///\n     /// `span_err` should be strongly preferred where-ever possible:\n-    /// this should *only* be used when\n+    /// this should *only* be used when:\n+    ///\n     /// - continuing has a high risk of flow-on errors (e.g. errors in\n     ///   declaring a macro would cause all uses of that macro to\n     ///   complain about \"undefined macro\"), or"}, {"sha": "e5ef9393e7bf7067c5f27c48b47ee0104f854555", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -63,9 +63,9 @@ macro_rules! declare_features {\n \n         /// A set of features to be used by later passes.\n         pub struct Features {\n-            /// #![feature] attrs for stable language features, for error reporting\n+            /// `#![feature]` attrs for stable language features, for error reporting\n             pub declared_stable_lang_features: Vec<(Symbol, Span)>,\n-            /// #![feature] attrs for non-language (library) features\n+            /// `#![feature]` attrs for non-language (library) features\n             pub declared_lib_features: Vec<(Symbol, Span)>,\n             $(pub $feature: bool),+\n         }"}, {"sha": "06a9306501c04fa24e41d98647509d11c272ddda", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -10,10 +10,10 @@\n \n //! Machinery for hygienic macros, inspired by the MTWT[1] paper.\n //!\n-//! [1] Matthew Flatt, Ryan Culpepper, David Darais, and Robert Bruce Findler.\n-//! 2012. *Macros that work together: Compile-time bindings, partial expansion,\n+//! [1] Matthew Flatt, Ryan Culpepper, David Darais, and Robert Bruce Findler. 2012.\n+//! *Macros that work together: Compile-time bindings, partial expansion,\n //! and definition contexts*. J. Funct. Program. 22, 2 (March 2012), 181-216.\n-//! DOI=10.1017/S0956796812000093 http://dx.doi.org/10.1017/S0956796812000093\n+//! DOI=10.1017/S0956796812000093 <http://dx.doi.org/10.1017/S0956796812000093>\n \n use Span;\n use symbol::{Ident, Symbol};\n@@ -224,6 +224,7 @@ impl SyntaxContext {\n \n     /// Adjust this context for resolution in a scope created by the given expansion.\n     /// For example, consider the following three resolutions of `f`:\n+    ///\n     /// ```rust\n     /// mod foo { pub fn f() {} } // `f`'s `SyntaxContext` is empty.\n     /// m!(f);\n@@ -255,7 +256,8 @@ impl SyntaxContext {\n \n     /// Adjust this context for resolution in a scope created by the given expansion\n     /// via a glob import with the given `SyntaxContext`.\n-    /// For example,\n+    /// For example:\n+    ///\n     /// ```rust\n     /// m!(f);\n     /// macro m($i:ident) {\n@@ -293,6 +295,7 @@ impl SyntaxContext {\n     }\n \n     /// Undo `glob_adjust` if possible:\n+    ///\n     /// ```rust\n     /// if let Some(privacy_checking_scope) = self.reverse_glob_adjust(expansion, glob_ctxt) {\n     ///     assert!(self.glob_adjust(expansion, glob_ctxt) == Some(privacy_checking_scope));"}, {"sha": "9f8b4a73d0cc0c6369a6cb7236d2e154d94cc270", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb32a94181d359ca16659b3e74303e945e8ea92/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=cbb32a94181d359ca16659b3e74303e945e8ea92", "patch": "@@ -53,13 +53,13 @@ pub trait Stats {\n \n     /// Arithmetic mean (average) of the samples: sum divided by sample-count.\n     ///\n-    /// See: https://en.wikipedia.org/wiki/Arithmetic_mean\n+    /// See: <https://en.wikipedia.org/wiki/Arithmetic_mean>\n     fn mean(&self) -> f64;\n \n     /// Median of the samples: value separating the lower half of the samples from the higher half.\n     /// Equal to `self.percentile(50.0)`.\n     ///\n-    /// See: https://en.wikipedia.org/wiki/Median\n+    /// See: <https://en.wikipedia.org/wiki/Median>\n     fn median(&self) -> f64;\n \n     /// Variance of the samples: bias-corrected mean of the squares of the differences of each\n@@ -68,15 +68,15 @@ pub trait Stats {\n     /// bias that would appear if we calculated a population variance, by dividing by `(n-1)` rather\n     /// than `n`.\n     ///\n-    /// See: https://en.wikipedia.org/wiki/Variance\n+    /// See: <https://en.wikipedia.org/wiki/Variance>\n     fn var(&self) -> f64;\n \n     /// Standard deviation: the square root of the sample variance.\n     ///\n     /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n     /// `median_abs_dev` for unknown distributions.\n     ///\n-    /// See: https://en.wikipedia.org/wiki/Standard_deviation\n+    /// See: <https://en.wikipedia.org/wiki/Standard_deviation>\n     fn std_dev(&self) -> f64;\n \n     /// Standard deviation as a percent of the mean value. See `std_dev` and `mean`.\n@@ -91,7 +91,7 @@ pub trait Stats {\n     /// by the constant `1.4826` to allow its use as a consistent estimator for the standard\n     /// deviation.\n     ///\n-    /// See: http://en.wikipedia.org/wiki/Median_absolute_deviation\n+    /// See: <http://en.wikipedia.org/wiki/Median_absolute_deviation>\n     fn median_abs_dev(&self) -> f64;\n \n     /// Median absolute deviation as a percent of the median. See `median_abs_dev` and `median`.\n@@ -103,21 +103,21 @@ pub trait Stats {\n     ///\n     /// Calculated by linear interpolation between closest ranks.\n     ///\n-    /// See: http://en.wikipedia.org/wiki/Percentile\n+    /// See: <http://en.wikipedia.org/wiki/Percentile>\n     fn percentile(&self, pct: f64) -> f64;\n \n     /// Quartiles of the sample: three values that divide the sample into four equal groups, each\n     /// with 1/4 of the data. The middle value is the median. See `median` and `percentile`. This\n     /// function may calculate the 3 quartiles more efficiently than 3 calls to `percentile`, but\n     /// is otherwise equivalent.\n     ///\n-    /// See also: https://en.wikipedia.org/wiki/Quartile\n+    /// See also: <https://en.wikipedia.org/wiki/Quartile>\n     fn quartiles(&self) -> (f64, f64, f64);\n \n     /// Inter-quartile range: the difference between the 25th percentile (1st quartile) and the 75th\n     /// percentile (3rd quartile). See `quartiles`.\n     ///\n-    /// See also: https://en.wikipedia.org/wiki/Interquartile_range\n+    /// See also: <https://en.wikipedia.org/wiki/Interquartile_range>\n     fn iqr(&self) -> f64;\n }\n \n@@ -311,7 +311,7 @@ fn percentile_of_sorted(sorted_samples: &[f64], pct: f64) -> f64 {\n /// It differs from trimming in that it does not change the number of samples,\n /// just changes the values of those that are outliers.\n ///\n-/// See: http://en.wikipedia.org/wiki/Winsorising\n+/// See: <http://en.wikipedia.org/wiki/Winsorising>\n pub fn winsorize(samples: &mut [f64], pct: f64) {\n     let mut tmp = samples.to_vec();\n     local_sort(&mut tmp);"}]}