{"sha": "dafb310ba131b34a8819566201dc8d0af9bbd406", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZmIzMTBiYTEzMWIzNGE4ODE5NTY2MjAxZGM4ZDBhZjliYmQ0MDY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-13T01:20:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-24T22:42:00Z"}, "message": "std: Delete rt::test\n\nThis module contains many M:N specific concepts. This will no longer be\navailable with libgreen, and most functions aren't really that necessary today\nanyway. New testing primitives will be introduced as they become available for\n1:1 and M:N.\n\nA new io::test module is introduced with the new ip4/ip6 address helpers to\ncontinue usage in io tests.", "tree": {"sha": "865428479b868978c74cfc040a600b37cdf89a7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/865428479b868978c74cfc040a600b37cdf89a7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dafb310ba131b34a8819566201dc8d0af9bbd406", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dafb310ba131b34a8819566201dc8d0af9bbd406", "html_url": "https://github.com/rust-lang/rust/commit/dafb310ba131b34a8819566201dc8d0af9bbd406", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dafb310ba131b34a8819566201dc8d0af9bbd406/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1815aea36818cd86ebae607522318f56e35c01a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1815aea36818cd86ebae607522318f56e35c01a2", "html_url": "https://github.com/rust-lang/rust/commit/1815aea36818cd86ebae607522318f56e35c01a2"}], "stats": {"total": 1613, "additions": 583, "deletions": 1030}, "files": [{"sha": "db51653d665c9e1d3cdae62e494c379769731190", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 313, "deletions": 346, "changes": 659, "blob_url": "https://github.com/rust-lang/rust/blob/dafb310ba131b34a8819566201dc8d0af9bbd406/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dafb310ba131b34a8819566201dc8d0af9bbd406/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=dafb310ba131b34a8819566201dc8d0af9bbd406", "patch": "@@ -147,468 +147,439 @@ impl Acceptor<TcpStream> for TcpAcceptor {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use rt::test::*;\n     use io::net::ip::{Ipv4Addr, SocketAddr};\n     use io::*;\n+    use io::test::{next_test_ip4, next_test_ip6};\n     use prelude::*;\n \n     #[test] #[ignore]\n     fn bind_error() {\n-        do run_in_mt_newsched_task {\n-            let mut called = false;\n-            io_error::cond.trap(|e| {\n-                assert!(e.kind == PermissionDenied);\n-                called = true;\n-            }).inside(|| {\n-                let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-                let listener = TcpListener::bind(addr);\n-                assert!(listener.is_none());\n-            });\n-            assert!(called);\n-        }\n+        let mut called = false;\n+        io_error::cond.trap(|e| {\n+            assert!(e.kind == PermissionDenied);\n+            called = true;\n+        }).inside(|| {\n+            let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n+            let listener = TcpListener::bind(addr);\n+            assert!(listener.is_none());\n+        });\n+        assert!(called);\n     }\n \n     #[test]\n     fn connect_error() {\n-        do run_in_mt_newsched_task {\n-            let mut called = false;\n-            io_error::cond.trap(|e| {\n-                let expected_error = if cfg!(unix) {\n-                    ConnectionRefused\n-                } else {\n-                    // On Win32, opening port 1 gives WSAEADDRNOTAVAIL error.\n-                    OtherIoError\n-                };\n-                assert_eq!(e.kind, expected_error);\n-                called = true;\n-            }).inside(|| {\n-                let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-                let stream = TcpStream::connect(addr);\n-                assert!(stream.is_none());\n-            });\n-            assert!(called);\n-        }\n+        let mut called = false;\n+        io_error::cond.trap(|e| {\n+            let expected_error = if cfg!(unix) {\n+                ConnectionRefused\n+            } else {\n+                // On Win32, opening port 1 gives WSAEADDRNOTAVAIL error.\n+                OtherIoError\n+            };\n+            assert_eq!(e.kind, expected_error);\n+            called = true;\n+        }).inside(|| {\n+            let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n+            let stream = TcpStream::connect(addr);\n+            assert!(stream.is_none());\n+        });\n+        assert!(called);\n     }\n \n     #[test]\n     fn smoke_test_ip4() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip4();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                let mut stream = acceptor.accept();\n-                let mut buf = [0];\n-                stream.read(buf);\n-                assert!(buf[0] == 99);\n-            }\n+        let addr = next_test_ip4();\n+        let (port, chan) = oneshot();\n \n+        do spawn {\n             port.recv();\n             let mut stream = TcpStream::connect(addr);\n             stream.write([99]);\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        stream.read(buf);\n+        assert!(buf[0] == 99);\n     }\n \n     #[test]\n     fn smoke_test_ip6() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip6();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                let mut stream = acceptor.accept();\n-                let mut buf = [0];\n-                stream.read(buf);\n-                assert!(buf[0] == 99);\n-            }\n+        let addr = next_test_ip6();\n+        let (port, chan) = oneshot();\n \n+        do spawn {\n             port.recv();\n             let mut stream = TcpStream::connect(addr);\n             stream.write([99]);\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        stream.read(buf);\n+        assert!(buf[0] == 99);\n     }\n \n     #[test]\n     fn read_eof_ip4() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip4();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                let mut stream = acceptor.accept();\n-                let mut buf = [0];\n-                let nread = stream.read(buf);\n-                assert!(nread.is_none());\n-            }\n+        let addr = next_test_ip4();\n+        let (port, chan) = oneshot();\n \n+        do spawn {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        let nread = stream.read(buf);\n+        assert!(nread.is_none());\n     }\n \n     #[test]\n     fn read_eof_ip6() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip6();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                let mut stream = acceptor.accept();\n-                let mut buf = [0];\n-                let nread = stream.read(buf);\n-                assert!(nread.is_none());\n-            }\n+        let addr = next_test_ip6();\n+        let (port, chan) = oneshot();\n \n+        do spawn {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        let nread = stream.read(buf);\n+        assert!(nread.is_none());\n     }\n \n     #[test]\n     fn read_eof_twice_ip4() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip4();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                let mut stream = acceptor.accept();\n-                let mut buf = [0];\n-                let nread = stream.read(buf);\n-                assert!(nread.is_none());\n-                io_error::cond.trap(|e| {\n-                    if cfg!(windows) {\n-                        assert_eq!(e.kind, NotConnected);\n-                    } else {\n-                        fail!();\n-                    }\n-                }).inside(|| {\n-                    let nread = stream.read(buf);\n-                    assert!(nread.is_none());\n-                })\n-            }\n+        let addr = next_test_ip4();\n+        let (port, chan) = oneshot();\n \n-            port.recv();\n+        do spawn {\n+            port.take().recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        let nread = stream.read(buf);\n+        assert!(nread.is_none());\n+        io_error::cond.trap(|e| {\n+            if cfg!(windows) {\n+                assert_eq!(e.kind, NotConnected);\n+            } else {\n+                fail!();\n+            }\n+        }).inside(|| {\n+            let nread = stream.read(buf);\n+            assert!(nread.is_none());\n+        })\n     }\n \n     #[test]\n     fn read_eof_twice_ip6() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip6();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                let mut stream = acceptor.accept();\n-                let mut buf = [0];\n-                let nread = stream.read(buf);\n-                assert!(nread.is_none());\n-                io_error::cond.trap(|e| {\n-                    if cfg!(windows) {\n-                        assert_eq!(e.kind, NotConnected);\n-                    } else {\n-                        fail!();\n-                    }\n-                }).inside(|| {\n-                    let nread = stream.read(buf);\n-                    assert!(nread.is_none());\n-                })\n-            }\n+        let addr = next_test_ip6();\n+        let (port, chan) = oneshot();\n \n+        do spawn {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        let mut stream = acceptor.accept();\n+        let mut buf = [0];\n+        let nread = stream.read(buf);\n+        assert!(nread.is_none());\n+        io_error::cond.trap(|e| {\n+            if cfg!(windows) {\n+                assert_eq!(e.kind, NotConnected);\n+            } else {\n+                fail!();\n+            }\n+        }).inside(|| {\n+            let nread = stream.read(buf);\n+            assert!(nread.is_none());\n+        })\n     }\n \n     #[test]\n     fn write_close_ip4() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip4();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                let mut stream = acceptor.accept();\n-                let buf = [0];\n-                loop {\n-                    let mut stop = false;\n-                    io_error::cond.trap(|e| {\n-                        // NB: ECONNRESET on linux, EPIPE on mac, ECONNABORTED\n-                        //     on windows\n-                        assert!(e.kind == ConnectionReset ||\n-                                e.kind == BrokenPipe ||\n-                                e.kind == ConnectionAborted,\n-                                \"unknown error: {:?}\", e);\n-                        stop = true;\n-                    }).inside(|| {\n-                        stream.write(buf);\n-                    });\n-                    if stop { break }\n-                }\n-            }\n+        let addr = next_test_ip4();\n+        let (port, chan) = oneshot();\n \n+        do spawn {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        let mut stream = acceptor.accept();\n+        let buf = [0];\n+        loop {\n+            let mut stop = false;\n+            io_error::cond.trap(|e| {\n+                // NB: ECONNRESET on linux, EPIPE on mac, ECONNABORTED\n+                //     on windows\n+                assert!(e.kind == ConnectionReset ||\n+                        e.kind == BrokenPipe ||\n+                        e.kind == ConnectionAborted,\n+                        \"unknown error: {:?}\", e);\n+                stop = true;\n+            }).inside(|| {\n+                stream.write(buf);\n+            });\n+            if stop { break }\n+        }\n     }\n \n     #[test]\n     fn write_close_ip6() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip6();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                let mut stream = acceptor.accept();\n-                let buf = [0];\n-                loop {\n-                    let mut stop = false;\n-                    io_error::cond.trap(|e| {\n-                        // NB: ECONNRESET on linux, EPIPE on mac, ECONNABORTED\n-                        //     on windows\n-                        assert!(e.kind == ConnectionReset ||\n-                                e.kind == BrokenPipe ||\n-                                e.kind == ConnectionAborted,\n-                                \"unknown error: {:?}\", e);\n-                        stop = true;\n-                    }).inside(|| {\n-                        stream.write(buf);\n-                    });\n-                    if stop { break }\n-                }\n-            }\n+        let addr = next_test_ip6();\n+        let (port, chan) = oneshot();\n \n+        do spawn {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        let mut stream = acceptor.accept();\n+        let buf = [0];\n+        loop {\n+            let mut stop = false;\n+            io_error::cond.trap(|e| {\n+                // NB: ECONNRESET on linux, EPIPE on mac, ECONNABORTED\n+                //     on windows\n+                assert!(e.kind == ConnectionReset ||\n+                        e.kind == BrokenPipe ||\n+                        e.kind == ConnectionAborted,\n+                        \"unknown error: {:?}\", e);\n+                stop = true;\n+            }).inside(|| {\n+                stream.write(buf);\n+            });\n+            if stop { break }\n+        }\n     }\n \n     #[test]\n     fn multiple_connect_serial_ip4() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip4();\n-            let max = 10;\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                for ref mut stream in acceptor.incoming().take(max) {\n-                    let mut buf = [0];\n-                    stream.read(buf);\n-                    assert_eq!(buf[0], 99);\n-                }\n-            }\n+        let addr = next_test_ip4();\n+        let max = 10;\n+        let (port, chan) = oneshot();\n \n+        do spawn {\n             port.recv();\n             max.times(|| {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write([99]);\n             });\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        for ref mut stream in acceptor.incoming().take(max) {\n+            let mut buf = [0];\n+            stream.read(buf);\n+            assert_eq!(buf[0], 99);\n+        }\n     }\n \n     #[test]\n     fn multiple_connect_serial_ip6() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip6();\n-            let max = 10;\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                for ref mut stream in acceptor.incoming().take(max) {\n-                    let mut buf = [0];\n-                    stream.read(buf);\n-                    assert_eq!(buf[0], 99);\n-                }\n-            }\n+        let addr = next_test_ip6();\n+        let max = 10;\n+        let (port, chan) = oneshot();\n \n+        do spawn {\n             port.recv();\n             max.times(|| {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write([99]);\n             });\n         }\n+\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        chan.send(());\n+        for ref mut stream in acceptor.incoming().take(max) {\n+            let mut buf = [0];\n+            stream.read(buf);\n+            assert_eq!(buf[0], 99);\n+        }\n     }\n \n     #[test]\n     fn multiple_connect_interleaved_greedy_schedule_ip4() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip4();\n-            static MAX: int = 10;\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n-                    // Start another task to handle the connection\n-                    do spawntask {\n-                        let mut stream = stream;\n-                        let mut buf = [0];\n-                        stream.read(buf);\n-                        assert!(buf[0] == i as u8);\n-                        debug!(\"read\");\n-                    }\n+        let addr = next_test_ip4();\n+        static MAX: int = 10;\n+        let (port, chan) = oneshot();\n+\n+        do spawn {\n+            let mut acceptor = TcpListener::bind(addr).listen();\n+            chan.send(());\n+            for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n+                let stream = Cell::new(stream);\n+                // Start another task to handle the connection\n+                do spawn {\n+                    let mut stream = stream.take();\n+                    let mut buf = [0];\n+                    stream.read(buf);\n+                    assert!(buf[0] == i as u8);\n+                    debug!(\"read\");\n                 }\n             }\n+        }\n \n-            port.recv();\n-            connect(0, addr);\n-\n-            fn connect(i: int, addr: SocketAddr) {\n-                if i == MAX { return }\n-\n-                do spawntask {\n-                    debug!(\"connecting\");\n-                    let mut stream = TcpStream::connect(addr);\n-                    // Connect again before writing\n-                    connect(i + 1, addr);\n-                    debug!(\"writing\");\n-                    stream.write([i as u8]);\n-                }\n+        port.recv();\n+        connect(0, addr);\n+\n+        fn connect(i: int, addr: SocketAddr) {\n+            if i == MAX { return }\n+\n+            do spawn {\n+                debug!(\"connecting\");\n+                let mut stream = TcpStream::connect(addr);\n+                // Connect again before writing\n+                connect(i + 1, addr);\n+                debug!(\"writing\");\n+                stream.write([i as u8]);\n             }\n         }\n     }\n \n     #[test]\n     fn multiple_connect_interleaved_greedy_schedule_ip6() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip6();\n-            static MAX: int = 10;\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n-                    // Start another task to handle the connection\n-                    do spawntask {\n-                        let mut stream = stream;\n-                        let mut buf = [0];\n-                        stream.read(buf);\n-                        assert!(buf[0] == i as u8);\n-                        debug!(\"read\");\n-                    }\n+        let addr = next_test_ip6();\n+        static MAX: int = 10;\n+        let (port, chan) = oneshot();\n+\n+        do spawn {\n+            let mut acceptor = TcpListener::bind(addr).listen();\n+            for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n+                let stream = Cell::new(stream);\n+                // Start another task to handle the connection\n+                do spawn {\n+                    let mut stream = stream.take();\n+                    let mut buf = [0];\n+                    stream.read(buf);\n+                    assert!(buf[0] == i as u8);\n+                    debug!(\"read\");\n                 }\n             }\n+        }\n \n-            port.recv();\n-            connect(0, addr);\n-\n-            fn connect(i: int, addr: SocketAddr) {\n-                if i == MAX { return }\n-\n-                do spawntask {\n-                    debug!(\"connecting\");\n-                    let mut stream = TcpStream::connect(addr);\n-                    // Connect again before writing\n-                    connect(i + 1, addr);\n-                    debug!(\"writing\");\n-                    stream.write([i as u8]);\n-                }\n+        port.recv();\n+        connect(0, addr);\n+\n+        fn connect(i: int, addr: SocketAddr) {\n+            if i == MAX { return }\n+\n+            do spawn {\n+                debug!(\"connecting\");\n+                let mut stream = TcpStream::connect(addr);\n+                // Connect again before writing\n+                connect(i + 1, addr);\n+                debug!(\"writing\");\n+                stream.write([i as u8]);\n             }\n         }\n     }\n \n     #[test]\n     fn multiple_connect_interleaved_lazy_schedule_ip4() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip4();\n-            static MAX: int = 10;\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                for stream in acceptor.incoming().take(MAX as uint) {\n-                    // Start another task to handle the connection\n-                    do spawntask_later {\n-                        let mut stream = stream;\n-                        let mut buf = [0];\n-                        stream.read(buf);\n-                        assert!(buf[0] == 99);\n-                        debug!(\"read\");\n-                    }\n+        let addr = next_test_ip4();\n+        static MAX: int = 10;\n+        let (port, chan) = oneshot();\n+\n+        do spawn {\n+            let mut acceptor = TcpListener::bind(addr).listen();\n+            chan.send(());\n+            for stream in acceptor.incoming().take(MAX as uint) {\n+                let stream = Cell::new(stream);\n+                // Start another task to handle the connection\n+                do spawn {\n+                    let mut stream = stream.take();\n+                    let mut buf = [0];\n+                    stream.read(buf);\n+                    assert!(buf[0] == 99);\n+                    debug!(\"read\");\n                 }\n             }\n+        }\n \n-            port.recv();\n-            connect(0, addr);\n-\n-            fn connect(i: int, addr: SocketAddr) {\n-                if i == MAX { return }\n-\n-                do spawntask_later {\n-                    debug!(\"connecting\");\n-                    let mut stream = TcpStream::connect(addr);\n-                    // Connect again before writing\n-                    connect(i + 1, addr);\n-                    debug!(\"writing\");\n-                    stream.write([99]);\n-                }\n+        port.recv();\n+        connect(0, addr);\n+\n+        fn connect(i: int, addr: SocketAddr) {\n+            if i == MAX { return }\n+\n+            do spawn {\n+                debug!(\"connecting\");\n+                let mut stream = TcpStream::connect(addr);\n+                // Connect again before writing\n+                connect(i + 1, addr);\n+                debug!(\"writing\");\n+                stream.write([99]);\n             }\n         }\n     }\n     #[test]\n     fn multiple_connect_interleaved_lazy_schedule_ip6() {\n-        do run_in_mt_newsched_task {\n-            let addr = next_test_ip6();\n-            static MAX: int = 10;\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-                for stream in acceptor.incoming().take(MAX as uint) {\n-                    // Start another task to handle the connection\n-                    do spawntask_later {\n-                        let mut stream = stream;\n-                        let mut buf = [0];\n-                        stream.read(buf);\n-                        assert!(buf[0] == 99);\n-                        debug!(\"read\");\n-                    }\n+        let addr = next_test_ip6();\n+        static MAX: int = 10;\n+        let (port, chan) = oneshot();\n+\n+        do spawn {\n+            let mut acceptor = TcpListener::bind(addr).listen();\n+            chan.send(());\n+            for stream in acceptor.incoming().take(MAX as uint) {\n+                let stream = Cell::new(stream);\n+                // Start another task to handle the connection\n+                do spawn {\n+                    let mut stream = stream.take();\n+                    let mut buf = [0];\n+                    stream.read(buf);\n+                    assert!(buf[0] == 99);\n+                    debug!(\"read\");\n                 }\n             }\n+        }\n \n-            port.recv();\n-            connect(0, addr);\n-\n-            fn connect(i: int, addr: SocketAddr) {\n-                if i == MAX { return }\n-\n-                do spawntask_later {\n-                    debug!(\"connecting\");\n-                    let mut stream = TcpStream::connect(addr);\n-                    // Connect again before writing\n-                    connect(i + 1, addr);\n-                    debug!(\"writing\");\n-                    stream.write([99]);\n-                }\n+        port.recv();\n+        connect(0, addr);\n+\n+        fn connect(i: int, addr: SocketAddr) {\n+            if i == MAX { return }\n+\n+            do spawn {\n+                debug!(\"connecting\");\n+                let mut stream = TcpStream::connect(addr);\n+                // Connect again before writing\n+                connect(i + 1, addr);\n+                debug!(\"writing\");\n+                stream.write([99]);\n             }\n         }\n     }\n@@ -631,29 +602,26 @@ mod test {\n \n     #[cfg(test)]\n     fn peer_name(addr: SocketAddr) {\n-        do run_in_mt_newsched_task {\n-            let (port, chan) = Chan::new();\n+        let (port, chan) = oneshot();\n \n-            do spawntask {\n-                let mut acceptor = TcpListener::bind(addr).listen();\n-                chan.send(());\n-\n-                acceptor.accept();\n-            }\n+        do spawn {\n+            let mut acceptor = TcpListener::bind(addr).listen();\n+            chan.send(());\n+            acceptor.accept();\n+        }\n \n-            port.recv();\n-            let stream = TcpStream::connect(addr);\n+        port.recv();\n+        let stream = TcpStream::connect(addr);\n \n-            assert!(stream.is_some());\n-            let mut stream = stream.unwrap();\n+        assert!(stream.is_some());\n+        let mut stream = stream.unwrap();\n \n-            // Make sure peer_name gives us the\n-            // address/port of the peer we've\n-            // connected to.\n-            let peer_name = stream.peer_name();\n-            assert!(peer_name.is_some());\n-            assert_eq!(addr, peer_name.unwrap());\n-        }\n+        // Make sure peer_name gives us the\n+        // address/port of the peer we've\n+        // connected to.\n+        let peer_name = stream.peer_name();\n+        assert!(peer_name.is_some());\n+        assert_eq!(addr, peer_name.unwrap());\n     }\n \n     #[test]\n@@ -668,5 +636,4 @@ mod test {\n         //peer_name(next_test_ip6());\n         socket_name(next_test_ip6());\n     }\n-\n }"}, {"sha": "0a277ee4347b3c2d172719c58acb5ef22cd5463b", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 97, "deletions": 114, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/dafb310ba131b34a8819566201dc8d0af9bbd406/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dafb310ba131b34a8819566201dc8d0af9bbd406/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=dafb310ba131b34a8819566201dc8d0af9bbd406", "patch": "@@ -104,52 +104,31 @@ impl Writer for UdpStream {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use rt::test::*;\n     use io::net::ip::{Ipv4Addr, SocketAddr};\n     use io::*;\n     use prelude::*;\n \n     #[test]  #[ignore]\n     fn bind_error() {\n-        do run_in_mt_newsched_task {\n-            let mut called = false;\n-            io_error::cond.trap(|e| {\n-                assert!(e.kind == PermissionDenied);\n-                called = true;\n-            }).inside(|| {\n-                let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-                let socket = UdpSocket::bind(addr);\n-                assert!(socket.is_none());\n-            });\n-            assert!(called);\n-        }\n+        let mut called = false;\n+        io_error::cond.trap(|e| {\n+            assert!(e.kind == PermissionDenied);\n+            called = true;\n+        }).inside(|| {\n+            let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n+            let socket = UdpSocket::bind(addr);\n+            assert!(socket.is_none());\n+        });\n+        assert!(called);\n     }\n \n     #[test]\n     fn socket_smoke_test_ip4() {\n-        do run_in_mt_newsched_task {\n-            let server_ip = next_test_ip4();\n-            let client_ip = next_test_ip4();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                match UdpSocket::bind(server_ip) {\n-                    Some(ref mut server) => {\n-                        chan.send(());\n-                        let mut buf = [0];\n-                        match server.recvfrom(buf) {\n-                            Some((nread, src)) => {\n-                                assert_eq!(nread, 1);\n-                                assert_eq!(buf[0], 99);\n-                                assert_eq!(src, client_ip);\n-                            }\n-                            None => fail!()\n-                        }\n-                    }\n-                    None => fail!()\n-                }\n-            }\n+        let server_ip = next_test_ip4();\n+        let client_ip = next_test_ip4();\n+        let (port, chan) = oneshot();\n \n+        do spawn {\n             match UdpSocket::bind(client_ip) {\n                 Some(ref mut client) => {\n                     port.recv();\n@@ -158,33 +137,31 @@ mod test {\n                 None => fail!()\n             }\n         }\n-    }\n \n-    #[test]\n-    fn socket_smoke_test_ip6() {\n-        do run_in_mt_newsched_task {\n-            let server_ip = next_test_ip6();\n-            let client_ip = next_test_ip6();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                match UdpSocket::bind(server_ip) {\n-                    Some(ref mut server) => {\n-                        chan.send(());\n-                        let mut buf = [0];\n-                        match server.recvfrom(buf) {\n-                            Some((nread, src)) => {\n-                                assert_eq!(nread, 1);\n-                                assert_eq!(buf[0], 99);\n-                                assert_eq!(src, client_ip);\n-                            }\n-                            None => fail!()\n-                        }\n+        match UdpSocket::bind(server_ip) {\n+            Some(ref mut server) => {\n+                chan.send(());\n+                let mut buf = [0];\n+                match server.recvfrom(buf) {\n+                    Some((nread, src)) => {\n+                        assert_eq!(nread, 1);\n+                        assert_eq!(buf[0], 99);\n+                        assert_eq!(src, client_ip);\n                     }\n                     None => fail!()\n                 }\n             }\n+            None => fail!()\n+        }\n+    }\n \n+    #[test]\n+    fn socket_smoke_test_ip6() {\n+        let server_ip = next_test_ip6();\n+        let client_ip = next_test_ip6();\n+        let (port, chan) = oneshot();\n+\n+        do spawn {\n             match UdpSocket::bind(client_ip) {\n                 Some(ref mut client) => {\n                     port.recv();\n@@ -193,34 +170,31 @@ mod test {\n                 None => fail!()\n             }\n         }\n-    }\n \n-    #[test]\n-    fn stream_smoke_test_ip4() {\n-        do run_in_mt_newsched_task {\n-            let server_ip = next_test_ip4();\n-            let client_ip = next_test_ip4();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                match UdpSocket::bind(server_ip) {\n-                    Some(server) => {\n-                        let server = ~server;\n-                        let mut stream = server.connect(client_ip);\n-                        chan.send(());\n-                        let mut buf = [0];\n-                        match stream.read(buf) {\n-                            Some(nread) => {\n-                                assert_eq!(nread, 1);\n-                                assert_eq!(buf[0], 99);\n-                            }\n-                            None => fail!()\n-                        }\n+        match UdpSocket::bind(server_ip) {\n+            Some(ref mut server) => {\n+                chan.take().send(());\n+                let mut buf = [0];\n+                match server.recvfrom(buf) {\n+                    Some((nread, src)) => {\n+                        assert_eq!(nread, 1);\n+                        assert_eq!(buf[0], 99);\n+                        assert_eq!(src, client_ip);\n                     }\n                     None => fail!()\n                 }\n             }\n+            None => fail!()\n+        }\n+    }\n+\n+    #[test]\n+    fn stream_smoke_test_ip4() {\n+        let server_ip = next_test_ip4();\n+        let client_ip = next_test_ip4();\n+        let (port, chan) = oneshot();\n \n+        do spawn {\n             match UdpSocket::bind(client_ip) {\n                 Some(client) => {\n                     let client = ~client;\n@@ -231,34 +205,32 @@ mod test {\n                 None => fail!()\n             }\n         }\n-    }\n \n-    #[test]\n-    fn stream_smoke_test_ip6() {\n-        do run_in_mt_newsched_task {\n-            let server_ip = next_test_ip6();\n-            let client_ip = next_test_ip6();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                match UdpSocket::bind(server_ip) {\n-                    Some(server) => {\n-                        let server = ~server;\n-                        let mut stream = server.connect(client_ip);\n-                        chan.send(());\n-                        let mut buf = [0];\n-                        match stream.read(buf) {\n-                            Some(nread) => {\n-                                assert_eq!(nread, 1);\n-                                assert_eq!(buf[0], 99);\n-                            }\n-                            None => fail!()\n-                        }\n+        match UdpSocket::bind(server_ip) {\n+            Some(server) => {\n+                let server = ~server;\n+                let mut stream = server.connect(client_ip);\n+                chan.send(());\n+                let mut buf = [0];\n+                match stream.read(buf) {\n+                    Some(nread) => {\n+                        assert_eq!(nread, 1);\n+                        assert_eq!(buf[0], 99);\n                     }\n                     None => fail!()\n                 }\n             }\n+            None => fail!()\n+        }\n+    }\n+\n+    #[test]\n+    fn stream_smoke_test_ip6() {\n+        let server_ip = next_test_ip6();\n+        let client_ip = next_test_ip6();\n+        let (port, chan) = oneshot();\n \n+        do spawn {\n             match UdpSocket::bind(client_ip) {\n                 Some(client) => {\n                     let client = ~client;\n@@ -269,25 +241,36 @@ mod test {\n                 None => fail!()\n             }\n         }\n+\n+        match UdpSocket::bind(server_ip) {\n+            Some(server) => {\n+                let server = ~server;\n+                let mut stream = server.connect(client_ip);\n+                chan.send(());\n+                let mut buf = [0];\n+                match stream.read(buf) {\n+                    Some(nread) => {\n+                        assert_eq!(nread, 1);\n+                        assert_eq!(buf[0], 99);\n+                    }\n+                    None => fail!()\n+                }\n+            }\n+            None => fail!()\n+        }\n     }\n \n-    #[cfg(test)]\n     fn socket_name(addr: SocketAddr) {\n-        do run_in_mt_newsched_task {\n-            do spawntask {\n-                let server = UdpSocket::bind(addr);\n-\n-                assert!(server.is_some());\n-                let mut server = server.unwrap();\n+        let server = UdpSocket::bind(addr);\n \n-                // Make sure socket_name gives\n-                // us the socket we binded to.\n-                let so_name = server.socket_name();\n-                assert!(so_name.is_some());\n-                assert_eq!(addr, so_name.unwrap());\n+        assert!(server.is_some());\n+        let mut server = server.unwrap();\n \n-            }\n-        }\n+        // Make sure socket_name gives\n+        // us the socket we binded to.\n+        let so_name = server.socket_name();\n+        assert!(so_name.is_some());\n+        assert_eq!(addr, so_name.unwrap());\n     }\n \n     #[test]"}, {"sha": "d8abd1fe50d7c2f8892d4d1e9c99c5912cb036ca", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 43, "deletions": 55, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/dafb310ba131b34a8819566201dc8d0af9bbd406/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dafb310ba131b34a8819566201dc8d0af9bbd406/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=dafb310ba131b34a8819566201dc8d0af9bbd406", "patch": "@@ -150,55 +150,47 @@ impl Acceptor<UnixStream> for UnixAcceptor {\n mod tests {\n     use prelude::*;\n     use super::*;\n-    use rt::test::*;\n     use io::*;\n \n     fn smalltest(server: proc(UnixStream), client: proc(UnixStream)) {\n-        do run_in_mt_newsched_task {\n-            let path1 = next_test_unix();\n-            let path2 = path1.clone();\n-            let (client, server) = (client, server);\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = UnixListener::bind(&path1).listen();\n-                chan.send(());\n-                server(acceptor.accept().unwrap());\n-            }\n+        let path1 = next_test_unix();\n+        let path2 = path1.clone();\n+        let (port, chan) = oneshot();\n \n+        do spawn {\n             port.recv();\n             client(UnixStream::connect(&path2).unwrap());\n         }\n+\n+        let mut acceptor = UnixListener::bind(&path1).listen();\n+        chan.send(());\n+        server(acceptor.accept().unwrap());\n     }\n \n     #[test]\n     fn bind_error() {\n-        do run_in_mt_newsched_task {\n-            let mut called = false;\n-            io_error::cond.trap(|e| {\n-                assert!(e.kind == PermissionDenied);\n-                called = true;\n-            }).inside(|| {\n-                let listener = UnixListener::bind(&(\"path/to/nowhere\"));\n-                assert!(listener.is_none());\n-            });\n-            assert!(called);\n-        }\n+        let mut called = false;\n+        io_error::cond.trap(|e| {\n+            assert!(e.kind == PermissionDenied);\n+            called = true;\n+        }).inside(|| {\n+            let listener = UnixListener::bind(&(\"path/to/nowhere\"));\n+            assert!(listener.is_none());\n+        });\n+        assert!(called);\n     }\n \n     #[test]\n     fn connect_error() {\n-        do run_in_mt_newsched_task {\n-            let mut called = false;\n-            io_error::cond.trap(|e| {\n-                assert_eq!(e.kind, FileNotFound);\n-                called = true;\n-            }).inside(|| {\n-                let stream = UnixStream::connect(&(\"path/to/nowhere\"));\n-                assert!(stream.is_none());\n-            });\n-            assert!(called);\n-        }\n+        let mut called = false;\n+        io_error::cond.trap(|e| {\n+            assert_eq!(e.kind, OtherIoError);\n+            called = true;\n+        }).inside(|| {\n+            let stream = UnixStream::connect(&(\"path/to/nowhere\"));\n+            assert!(stream.is_none());\n+        });\n+        assert!(called);\n     }\n \n     #[test]\n@@ -244,37 +236,33 @@ mod tests {\n \n     #[test]\n     fn accept_lots() {\n-        do run_in_mt_newsched_task {\n-            let times = 10;\n-            let path1 = next_test_unix();\n-            let path2 = path1.clone();\n-            let (port, chan) = Chan::new();\n-\n-            do spawntask {\n-                let mut acceptor = UnixListener::bind(&path1).listen();\n-                chan.send(());\n-                times.times(|| {\n-                    let mut client = acceptor.accept();\n-                    let mut buf = [0];\n-                    client.read(buf);\n-                    assert_eq!(buf[0], 100);\n-                })\n-            }\n+        let times = 10;\n+        let path1 = next_test_unix();\n+        let path2 = path1.clone();\n+        let (port, chan) = oneshot();\n \n+        do spawn {\n             port.recv();\n             times.times(|| {\n                 let mut stream = UnixStream::connect(&path2);\n                 stream.write([100]);\n             })\n         }\n+\n+        let mut acceptor = UnixListener::bind(&path1).listen();\n+        chan.send(());\n+        times.times(|| {\n+            let mut client = acceptor.accept();\n+            let mut buf = [0];\n+            client.read(buf);\n+            assert_eq!(buf[0], 100);\n+        })\n     }\n \n     #[test]\n     fn path_exists() {\n-        do run_in_mt_newsched_task {\n-            let path = next_test_unix();\n-            let _acceptor = UnixListener::bind(&path).listen();\n-            assert!(path.exists());\n-        }\n+        let path = next_test_unix();\n+        let _acceptor = UnixListener::bind(&path).listen();\n+        assert!(path.exists());\n     }\n }"}, {"sha": "a661d6ab7eb79f784057481492539341acdedc78", "filename": "src/libstd/io/option.rs", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/dafb310ba131b34a8819566201dc8d0af9bbd406/src%2Flibstd%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dafb310ba131b34a8819566201dc8d0af9bbd406/src%2Flibstd%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Foption.rs?ref=dafb310ba131b34a8819566201dc8d0af9bbd406", "patch": "@@ -106,53 +106,46 @@ impl<T, A: Acceptor<T>> Acceptor<T> for Option<A> {\n mod test {\n     use option::*;\n     use super::super::mem::*;\n-    use rt::test::*;\n     use super::super::{PreviousIoError, io_error};\n \n     #[test]\n     fn test_option_writer() {\n-        do run_in_mt_newsched_task {\n-            let mut writer: Option<MemWriter> = Some(MemWriter::new());\n-            writer.write([0, 1, 2]);\n-            writer.flush();\n-            assert_eq!(writer.unwrap().inner(), ~[0, 1, 2]);\n-        }\n+        let mut writer: Option<MemWriter> = Some(MemWriter::new());\n+        writer.write([0, 1, 2]);\n+        writer.flush();\n+        assert_eq!(writer.unwrap().inner(), ~[0, 1, 2]);\n     }\n \n     #[test]\n     fn test_option_writer_error() {\n-        do run_in_mt_newsched_task {\n-            let mut writer: Option<MemWriter> = None;\n-\n-            let mut called = false;\n-            io_error::cond.trap(|err| {\n-                assert_eq!(err.kind, PreviousIoError);\n-                called = true;\n-            }).inside(|| {\n-                writer.write([0, 0, 0]);\n-            });\n-            assert!(called);\n-\n-            let mut called = false;\n-            io_error::cond.trap(|err| {\n-                assert_eq!(err.kind, PreviousIoError);\n-                called = true;\n-            }).inside(|| {\n-                writer.flush();\n-            });\n-            assert!(called);\n-        }\n+        let mut writer: Option<MemWriter> = None;\n+\n+        let mut called = false;\n+        io_error::cond.trap(|err| {\n+            assert_eq!(err.kind, PreviousIoError);\n+            called = true;\n+        }).inside(|| {\n+            writer.write([0, 0, 0]);\n+        });\n+        assert!(called);\n+\n+        let mut called = false;\n+        io_error::cond.trap(|err| {\n+            assert_eq!(err.kind, PreviousIoError);\n+            called = true;\n+        }).inside(|| {\n+            writer.flush();\n+        });\n+        assert!(called);\n     }\n \n     #[test]\n     fn test_option_reader() {\n-        do run_in_mt_newsched_task {\n-            let mut reader: Option<MemReader> = Some(MemReader::new(~[0, 1, 2, 3]));\n-            let mut buf = [0, 0];\n-            reader.read(buf);\n-            assert_eq!(buf, [0, 1]);\n-            assert!(!reader.eof());\n-        }\n+        let mut reader: Option<MemReader> = Some(MemReader::new(~[0, 1, 2, 3]));\n+        let mut buf = [0, 0];\n+        reader.read(buf);\n+        assert_eq!(buf, [0, 1]);\n+        assert!(!reader.eof());\n     }\n \n     #[test]"}, {"sha": "212e4ebffa890e29e1073dc09eb44fe93ae7d801", "filename": "src/libstd/io/test.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/dafb310ba131b34a8819566201dc8d0af9bbd406/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dafb310ba131b34a8819566201dc8d0af9bbd406/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=dafb310ba131b34a8819566201dc8d0af9bbd406", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Get a port number, starting at 9600, for use in tests\n+pub fn next_test_port() -> u16 {\n+    use unstable::atomics::{AtomicUint, INIT_ATOMIC_UINT, Relaxed};\n+    static mut next_offset: AtomicUint = INIT_ATOMIC_UINT;\n+    unsafe {\n+        base_port() + next_offset.fetch_add(1, Relaxed) as u16\n+    }\n+}\n+\n+/// Get a temporary path which could be the location of a unix socket\n+pub fn next_test_unix() -> Path {\n+    if cfg!(unix) {\n+        os::tmpdir().join(rand::task_rng().gen_ascii_str(20))\n+    } else {\n+        Path::new(r\"\\\\.\\pipe\\\" + rand::task_rng().gen_ascii_str(20))\n+    }\n+}\n+\n+/// Get a unique IPv4 localhost:port pair starting at 9600\n+pub fn next_test_ip4() -> SocketAddr {\n+    SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: next_test_port() }\n+}\n+\n+/// Get a unique IPv6 localhost:port pair starting at 9600\n+pub fn next_test_ip6() -> SocketAddr {\n+    SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1), port: next_test_port() }\n+}\n+\n+/*\n+XXX: Welcome to MegaHack City.\n+\n+The bots run multiple builds at the same time, and these builds\n+all want to use ports. This function figures out which workspace\n+it is running in and assigns a port range based on it.\n+*/\n+fn base_port() -> u16 {\n+    use os;\n+    use str::StrSlice;\n+    use vec::ImmutableVector;\n+\n+    let base = 9600u16;\n+    let range = 1000u16;\n+\n+    let bases = [\n+        (\"32-opt\", base + range * 1),\n+        (\"32-noopt\", base + range * 2),\n+        (\"64-opt\", base + range * 3),\n+        (\"64-noopt\", base + range * 4),\n+        (\"64-opt-vg\", base + range * 5),\n+        (\"all-opt\", base + range * 6),\n+        (\"snap3\", base + range * 7),\n+        (\"dist\", base + range * 8)\n+    ];\n+\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let path = os::getcwd();\n+    let path_s = path.as_str().unwrap();\n+\n+    let mut final_base = base;\n+\n+    for &(dir, base) in bases.iter() {\n+        if path_s.contains(dir) {\n+            final_base = base;\n+            break;\n+        }\n+    }\n+\n+    return final_base;\n+}"}, {"sha": "c86e1a1890baf9d6536c4f9dc33ef7b4906ebc7f", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 23, "deletions": 40, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/dafb310ba131b34a8819566201dc8d0af9bbd406/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dafb310ba131b34a8819566201dc8d0af9bbd406/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=dafb310ba131b34a8819566201dc8d0af9bbd406", "patch": "@@ -108,77 +108,60 @@ impl Timer {\n mod test {\n     use prelude::*;\n     use super::*;\n-    use rt::test::*;\n \n     #[test]\n     fn test_io_timer_sleep_simple() {\n-        do run_in_mt_newsched_task {\n-            let mut timer = Timer::new().unwrap();\n-            timer.sleep(1);\n-        }\n+        let mut timer = Timer::new().unwrap();\n+        timer.sleep(1);\n     }\n \n     #[test]\n     fn test_io_timer_sleep_oneshot() {\n-        do run_in_mt_newsched_task {\n-            let mut timer = Timer::new().unwrap();\n-            timer.oneshot(1).recv();\n-        }\n+        let mut timer = Timer::new().unwrap();\n+        timer.oneshot(1).recv();\n     }\n \n     #[test]\n     fn test_io_timer_sleep_oneshot_forget() {\n-        do run_in_mt_newsched_task {\n-            let mut timer = Timer::new().unwrap();\n-            timer.oneshot(100000000000);\n-        }\n+        let mut timer = Timer::new().unwrap();\n+        timer.oneshot(100000000000);\n     }\n \n     #[test]\n     fn oneshot_twice() {\n-        do run_in_mt_newsched_task {\n-            let mut timer = Timer::new().unwrap();\n-            let port1 = timer.oneshot(10000);\n-            let port = timer.oneshot(1);\n-            port.recv();\n-            assert_eq!(port1.try_recv(), None);\n-        }\n+        let mut timer = Timer::new().unwrap();\n+        let port1 = timer.oneshot(10000);\n+        let port = timer.oneshot(1);\n+        port.recv();\n+        assert_eq!(port1.try_recv(), None);\n     }\n \n     #[test]\n     fn test_io_timer_oneshot_then_sleep() {\n-        do run_in_mt_newsched_task {\n-            let mut timer = Timer::new().unwrap();\n-            let port = timer.oneshot(100000000000);\n-            timer.sleep(1); // this should invalidate the port\n+        let mut timer = Timer::new().unwrap();\n+        let port = timer.oneshot(100000000000);\n+        timer.sleep(1); // this should invalidate the port\n \n-            assert_eq!(port.try_recv(), None);\n-        }\n+        assert_eq!(port.try_recv(), None);\n     }\n \n     #[test]\n     fn test_io_timer_sleep_periodic() {\n-        do run_in_mt_newsched_task {\n-            let mut timer = Timer::new().unwrap();\n-            let port = timer.periodic(1);\n-            port.recv();\n-            port.recv();\n-            port.recv();\n-        }\n+        let mut timer = Timer::new().unwrap();\n+        let port = timer.periodic(1);\n+        port.recv();\n+        port.recv();\n+        port.recv();\n     }\n \n     #[test]\n     fn test_io_timer_sleep_periodic_forget() {\n-        do run_in_mt_newsched_task {\n-            let mut timer = Timer::new().unwrap();\n-            timer.periodic(100000000000);\n-        }\n+        let mut timer = Timer::new().unwrap();\n+        timer.periodic(100000000000);\n     }\n \n     #[test]\n     fn test_io_timer_sleep_standalone() {\n-        do run_in_mt_newsched_task {\n-            sleep(1)\n-        }\n+        sleep(1)\n     }\n }"}, {"sha": "2b48b396c99e9fe5439bc1169b27e0db1b6c10be", "filename": "src/libstd/rt/test.rs", "status": "removed", "additions": 0, "deletions": 440, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/1815aea36818cd86ebae607522318f56e35c01a2/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1815aea36818cd86ebae607522318f56e35c01a2/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=1815aea36818cd86ebae607522318f56e35c01a2", "patch": "@@ -1,440 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n-\n-use clone::Clone;\n-use container::Container;\n-use iter::{Iterator, range};\n-use option::{Some, None};\n-use os;\n-use path::GenericPath;\n-use path::Path;\n-use rand::Rng;\n-use rand;\n-use result::{Result, Ok, Err};\n-use rt::basic;\n-use rt::deque::BufferPool;\n-use comm::Chan;\n-use rt::new_event_loop;\n-use rt::sched::Scheduler;\n-use rt::sleeper_list::SleeperList;\n-use rt::task::Task;\n-use rt::thread::Thread;\n-use task::TaskResult;\n-use unstable::{run_in_bare_thread};\n-use vec;\n-use vec::{OwnedVector, MutableVector, ImmutableVector};\n-\n-pub fn new_test_uv_sched() -> Scheduler {\n-\n-    let mut pool = BufferPool::new();\n-    let (worker, stealer) = pool.deque();\n-\n-    let mut sched = Scheduler::new(new_event_loop(),\n-                                   worker,\n-                                   ~[stealer],\n-                                   SleeperList::new());\n-\n-    // Don't wait for the Shutdown message\n-    sched.no_sleep = true;\n-    return sched;\n-\n-}\n-\n-pub fn new_test_sched() -> Scheduler {\n-    let mut pool = BufferPool::new();\n-    let (worker, stealer) = pool.deque();\n-\n-    let mut sched = Scheduler::new(basic::event_loop(),\n-                                   worker,\n-                                   ~[stealer],\n-                                   SleeperList::new());\n-\n-    // Don't wait for the Shutdown message\n-    sched.no_sleep = true;\n-    return sched;\n-}\n-\n-pub fn run_in_uv_task(f: proc()) {\n-    do run_in_bare_thread {\n-        run_in_uv_task_core(f);\n-    }\n-}\n-\n-pub fn run_in_newsched_task(f: proc()) {\n-    do run_in_bare_thread {\n-        run_in_newsched_task_core(f);\n-    }\n-}\n-\n-pub fn run_in_uv_task_core(f: proc()) {\n-\n-    use rt::sched::Shutdown;\n-\n-    let mut sched = ~new_test_uv_sched();\n-    let exit_handle = sched.make_handle();\n-\n-    let on_exit: proc(TaskResult) = proc(exit_status: TaskResult) {\n-        let mut exit_handle = exit_handle;\n-        exit_handle.send(Shutdown);\n-        rtassert!(exit_status.is_ok());\n-    };\n-    let mut task = ~Task::new_root(&mut sched.stack_pool, None, f);\n-    task.death.on_exit = Some(on_exit);\n-\n-    sched.bootstrap(task);\n-}\n-\n-pub fn run_in_newsched_task_core(f: proc()) {\n-    use rt::sched::Shutdown;\n-\n-    let mut sched = ~new_test_sched();\n-    let exit_handle = sched.make_handle();\n-\n-    let on_exit: proc(TaskResult) = proc(exit_status: TaskResult) {\n-        let mut exit_handle = exit_handle;\n-        exit_handle.send(Shutdown);\n-        rtassert!(exit_status.is_ok());\n-    };\n-    let mut task = ~Task::new_root(&mut sched.stack_pool, None, f);\n-    task.death.on_exit = Some(on_exit);\n-\n-    sched.bootstrap(task);\n-}\n-\n-#[cfg(target_os=\"macos\")]\n-#[allow(non_camel_case_types)]\n-mod darwin_fd_limit {\n-    /*!\n-     * darwin_fd_limit exists to work around an issue where launchctl on Mac OS X defaults the\n-     * rlimit maxfiles to 256/unlimited. The default soft limit of 256 ends up being far too low\n-     * for our multithreaded scheduler testing, depending on the number of cores available.\n-     *\n-     * This fixes issue #7772.\n-     */\n-\n-    use libc;\n-    type rlim_t = libc::uint64_t;\n-    struct rlimit {\n-        rlim_cur: rlim_t,\n-        rlim_max: rlim_t\n-    }\n-    #[nolink]\n-    extern {\n-        // name probably doesn't need to be mut, but the C function doesn't specify const\n-        fn sysctl(name: *mut libc::c_int, namelen: libc::c_uint,\n-                  oldp: *mut libc::c_void, oldlenp: *mut libc::size_t,\n-                  newp: *mut libc::c_void, newlen: libc::size_t) -> libc::c_int;\n-        fn getrlimit(resource: libc::c_int, rlp: *mut rlimit) -> libc::c_int;\n-        fn setrlimit(resource: libc::c_int, rlp: *rlimit) -> libc::c_int;\n-    }\n-    static CTL_KERN: libc::c_int = 1;\n-    static KERN_MAXFILESPERPROC: libc::c_int = 29;\n-    static RLIMIT_NOFILE: libc::c_int = 8;\n-\n-    pub unsafe fn raise_fd_limit() {\n-        // The strategy here is to fetch the current resource limits, read the kern.maxfilesperproc\n-        // sysctl value, and bump the soft resource limit for maxfiles up to the sysctl value.\n-        use ptr::{to_unsafe_ptr, to_mut_unsafe_ptr, mut_null};\n-        use mem::size_of_val;\n-        use os::last_os_error;\n-\n-        // Fetch the kern.maxfilesperproc value\n-        let mut mib: [libc::c_int, ..2] = [CTL_KERN, KERN_MAXFILESPERPROC];\n-        let mut maxfiles: libc::c_int = 0;\n-        let mut size: libc::size_t = size_of_val(&maxfiles) as libc::size_t;\n-        if sysctl(to_mut_unsafe_ptr(&mut mib[0]), 2,\n-                  to_mut_unsafe_ptr(&mut maxfiles) as *mut libc::c_void,\n-                  to_mut_unsafe_ptr(&mut size),\n-                  mut_null(), 0) != 0 {\n-            let err = last_os_error();\n-            error!(\"raise_fd_limit: error calling sysctl: {}\", err);\n-            return;\n-        }\n-\n-        // Fetch the current resource limits\n-        let mut rlim = rlimit{rlim_cur: 0, rlim_max: 0};\n-        if getrlimit(RLIMIT_NOFILE, to_mut_unsafe_ptr(&mut rlim)) != 0 {\n-            let err = last_os_error();\n-            error!(\"raise_fd_limit: error calling getrlimit: {}\", err);\n-            return;\n-        }\n-\n-        // Bump the soft limit to the smaller of kern.maxfilesperproc and the hard limit\n-        rlim.rlim_cur = ::cmp::min(maxfiles as rlim_t, rlim.rlim_max);\n-\n-        // Set our newly-increased resource limit\n-        if setrlimit(RLIMIT_NOFILE, to_unsafe_ptr(&rlim)) != 0 {\n-            let err = last_os_error();\n-            error!(\"raise_fd_limit: error calling setrlimit: {}\", err);\n-            return;\n-        }\n-    }\n-}\n-\n-#[cfg(not(target_os=\"macos\"))]\n-mod darwin_fd_limit {\n-    pub unsafe fn raise_fd_limit() {}\n-}\n-\n-#[doc(hidden)]\n-pub fn prepare_for_lots_of_tests() {\n-    // Bump the fd limit on OS X. See darwin_fd_limit for an explanation.\n-    unsafe { darwin_fd_limit::raise_fd_limit() }\n-}\n-\n-/// Create more than one scheduler and run a function in a task\n-/// in one of the schedulers. The schedulers will stay alive\n-/// until the function `f` returns.\n-pub fn run_in_mt_newsched_task(f: proc()) {\n-    use os;\n-    use from_str::FromStr;\n-    use rt::sched::Shutdown;\n-    use rt::util;\n-\n-    // see comment in other function (raising fd limits)\n-    prepare_for_lots_of_tests();\n-\n-    do run_in_bare_thread {\n-        let nthreads = match os::getenv(\"RUST_RT_TEST_THREADS\") {\n-            Some(nstr) => FromStr::from_str(nstr).unwrap(),\n-            None => {\n-                if util::limit_thread_creation_due_to_osx_and_valgrind() {\n-                    1\n-                } else {\n-                    // Using more threads than cores in test code\n-                    // to force the OS to preempt them frequently.\n-                    // Assuming that this help stress test concurrent types.\n-                    util::num_cpus() * 2\n-                }\n-            }\n-        };\n-\n-        let sleepers = SleeperList::new();\n-\n-        let mut handles = ~[];\n-        let mut scheds = ~[];\n-\n-        let mut pool = BufferPool::<~Task>::new();\n-        let workers = range(0, nthreads).map(|_| pool.deque());\n-        let (workers, stealers) = vec::unzip(workers);\n-\n-        for worker in workers.move_iter() {\n-            let loop_ = new_event_loop();\n-            let mut sched = ~Scheduler::new(loop_,\n-                                            worker,\n-                                            stealers.clone(),\n-                                            sleepers.clone());\n-            let handle = sched.make_handle();\n-\n-            handles.push(handle);\n-            scheds.push(sched);\n-        }\n-\n-        let handles = handles;  // Work around not being able to capture mut\n-        let on_exit: proc(TaskResult) = proc(exit_status: TaskResult) {\n-            // Tell schedulers to exit\n-            let mut handles = handles;\n-            for handle in handles.mut_iter() {\n-                handle.send(Shutdown);\n-            }\n-\n-            rtassert!(exit_status.is_ok());\n-        };\n-        let mut main_task = ~Task::new_root(&mut scheds[0].stack_pool,\n-                                            None,\n-                                            f);\n-        main_task.death.on_exit = Some(on_exit);\n-\n-        let mut threads = ~[];\n-\n-        let main_thread = {\n-            let sched = scheds.pop();\n-            let main_task = main_task;\n-            do Thread::start {\n-                sched.bootstrap(main_task);\n-            }\n-        };\n-        threads.push(main_thread);\n-\n-        while !scheds.is_empty() {\n-            let mut sched = scheds.pop();\n-            let bootstrap_task = ~do Task::new_root(&mut sched.stack_pool, None) || {\n-                rtdebug!(\"bootstrapping non-primary scheduler\");\n-            };\n-            let sched = sched;\n-            let thread = do Thread::start {\n-                sched.bootstrap(bootstrap_task);\n-            };\n-\n-            threads.push(thread);\n-        }\n-\n-        // Wait for schedulers\n-        for thread in threads.move_iter() {\n-            thread.join();\n-        }\n-    }\n-\n-}\n-\n-/// Test tasks will abort on failure instead of unwinding\n-pub fn spawntask(f: proc()) {\n-    Scheduler::run_task(Task::build_child(None, f));\n-}\n-\n-/// Create a new task and run it right now. Aborts on failure\n-pub fn spawntask_later(f: proc()) {\n-    Scheduler::run_task_later(Task::build_child(None, f));\n-}\n-\n-pub fn spawntask_random(f: proc()) {\n-    use rand::{Rand, rng};\n-\n-    let mut rng = rng();\n-    let run_now: bool = Rand::rand(&mut rng);\n-\n-    if run_now {\n-        spawntask(f)\n-    } else {\n-        spawntask_later(f)\n-    }\n-}\n-\n-pub fn spawntask_try(f: proc()) -> Result<(),()> {\n-\n-    let (port, chan) = Chan::new();\n-    let on_exit: proc(TaskResult) = proc(exit_status) {\n-        chan.send(exit_status)\n-    };\n-\n-    let mut new_task = Task::build_root(None, f);\n-    new_task.death.on_exit = Some(on_exit);\n-\n-    Scheduler::run_task(new_task);\n-\n-    let exit_status = port.recv();\n-    if exit_status.is_ok() { Ok(()) } else { Err(()) }\n-\n-}\n-\n-/// Spawn a new task in a new scheduler and return a thread handle.\n-pub fn spawntask_thread(f: proc()) -> Thread<()> {\n-    let thread = do Thread::start {\n-        run_in_newsched_task_core(f);\n-    };\n-\n-    return thread;\n-}\n-\n-/// Get a ~Task for testing purposes other than actually scheduling it.\n-pub fn with_test_task(blk: proc(~Task) -> ~Task) {\n-    do run_in_bare_thread {\n-        let mut sched = ~new_test_sched();\n-        let task = blk(~Task::new_root(&mut sched.stack_pool,\n-                                       None,\n-                                       proc() {}));\n-        cleanup_task(task);\n-    }\n-}\n-\n-/// Use to cleanup tasks created for testing but not \"run\".\n-pub fn cleanup_task(mut task: ~Task) {\n-    task.destroyed = true;\n-}\n-\n-/// Get a port number, starting at 9600, for use in tests\n-pub fn next_test_port() -> u16 {\n-    use unstable::mutex::{Mutex, MUTEX_INIT};\n-    static mut lock: Mutex = MUTEX_INIT;\n-    static mut next_offset: u16 = 0;\n-    unsafe {\n-        let base = base_port();\n-        lock.lock();\n-        let ret = base + next_offset;\n-        next_offset += 1;\n-        lock.unlock();\n-        return ret;\n-    }\n-}\n-\n-/// Get a temporary path which could be the location of a unix socket\n-pub fn next_test_unix() -> Path {\n-    if cfg!(unix) {\n-        os::tmpdir().join(rand::task_rng().gen_ascii_str(20))\n-    } else {\n-        Path::new(r\"\\\\.\\pipe\\\" + rand::task_rng().gen_ascii_str(20))\n-    }\n-}\n-\n-/// Get a unique IPv4 localhost:port pair starting at 9600\n-pub fn next_test_ip4() -> SocketAddr {\n-    SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: next_test_port() }\n-}\n-\n-/// Get a unique IPv6 localhost:port pair starting at 9600\n-pub fn next_test_ip6() -> SocketAddr {\n-    SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1), port: next_test_port() }\n-}\n-\n-/*\n-XXX: Welcome to MegaHack City.\n-\n-The bots run multiple builds at the same time, and these builds\n-all want to use ports. This function figures out which workspace\n-it is running in and assigns a port range based on it.\n-*/\n-fn base_port() -> u16 {\n-    use os;\n-    use str::StrSlice;\n-    use vec::ImmutableVector;\n-\n-    let base = 9600u16;\n-    let range = 1000u16;\n-\n-    let bases = [\n-        (\"32-opt\", base + range * 1),\n-        (\"32-noopt\", base + range * 2),\n-        (\"64-opt\", base + range * 3),\n-        (\"64-noopt\", base + range * 4),\n-        (\"64-opt-vg\", base + range * 5),\n-        (\"all-opt\", base + range * 6),\n-        (\"snap3\", base + range * 7),\n-        (\"dist\", base + range * 8)\n-    ];\n-\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let path = os::getcwd();\n-    let path_s = path.as_str().unwrap();\n-\n-    let mut final_base = base;\n-\n-    for &(dir, base) in bases.iter() {\n-        if path_s.contains(dir) {\n-            final_base = base;\n-            break;\n-        }\n-    }\n-\n-    return final_base;\n-}\n-\n-/// Get a constant that represents the number of times to repeat\n-/// stress tests. Default 1.\n-pub fn stress_factor() -> uint {\n-    use os::getenv;\n-    use from_str::from_str;\n-\n-    match getenv(\"RUST_RT_STRESS\") {\n-        Some(val) => from_str::<uint>(val).unwrap(),\n-        None => 1\n-    }\n-}"}]}