{"sha": "eee892c4beec9d037cfa68089334af7c9dd07401", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZTg5MmM0YmVlYzlkMDM3Y2ZhNjgwODkzMzRhZjdjOWRkMDc0MDE=", "commit": {"author": {"name": "Joshua Yanovski", "email": "pythonesque@gmail.com", "date": "2013-10-30T06:34:43Z"}, "committer": {"name": "Joshua Yanovski", "email": "pythonesque@gmail.com", "date": "2013-10-30T11:48:53Z"}, "message": "Special-casing iter_vec_raw to use a counter for zero-size types (Closes #9890).", "tree": {"sha": "41c96289a942c2a7758f8c664e087ecb8c3bbe0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41c96289a942c2a7758f8c664e087ecb8c3bbe0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eee892c4beec9d037cfa68089334af7c9dd07401", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eee892c4beec9d037cfa68089334af7c9dd07401", "html_url": "https://github.com/rust-lang/rust/commit/eee892c4beec9d037cfa68089334af7c9dd07401", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eee892c4beec9d037cfa68089334af7c9dd07401/comments", "author": {"login": "pythonesque", "id": 923144, "node_id": "MDQ6VXNlcjkyMzE0NA==", "avatar_url": "https://avatars.githubusercontent.com/u/923144?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pythonesque", "html_url": "https://github.com/pythonesque", "followers_url": "https://api.github.com/users/pythonesque/followers", "following_url": "https://api.github.com/users/pythonesque/following{/other_user}", "gists_url": "https://api.github.com/users/pythonesque/gists{/gist_id}", "starred_url": "https://api.github.com/users/pythonesque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pythonesque/subscriptions", "organizations_url": "https://api.github.com/users/pythonesque/orgs", "repos_url": "https://api.github.com/users/pythonesque/repos", "events_url": "https://api.github.com/users/pythonesque/events{/privacy}", "received_events_url": "https://api.github.com/users/pythonesque/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pythonesque", "id": 923144, "node_id": "MDQ6VXNlcjkyMzE0NA==", "avatar_url": "https://avatars.githubusercontent.com/u/923144?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pythonesque", "html_url": "https://github.com/pythonesque", "followers_url": "https://api.github.com/users/pythonesque/followers", "following_url": "https://api.github.com/users/pythonesque/following{/other_user}", "gists_url": "https://api.github.com/users/pythonesque/gists{/gist_id}", "starred_url": "https://api.github.com/users/pythonesque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pythonesque/subscriptions", "organizations_url": "https://api.github.com/users/pythonesque/orgs", "repos_url": "https://api.github.com/users/pythonesque/repos", "events_url": "https://api.github.com/users/pythonesque/events{/privacy}", "received_events_url": "https://api.github.com/users/pythonesque/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0e6e0e9b7bc468b9e31d22c6f82a391ad7ba90a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0e6e0e9b7bc468b9e31d22c6f82a391ad7ba90a", "html_url": "https://github.com/rust-lang/rust/commit/a0e6e0e9b7bc468b9e31d22c6f82a391ad7ba90a"}], "stats": {"total": 197, "additions": 126, "deletions": 71}, "files": [{"sha": "1f9e9037179313b0375ab0a0942558ada62fd8df", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 97, "deletions": 71, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/eee892c4beec9d037cfa68089334af7c9dd07401/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee892c4beec9d037cfa68089334af7c9dd07401/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=eee892c4beec9d037cfa68089334af7c9dd07401", "patch": "@@ -22,7 +22,7 @@ use middle::trans::datum::*;\n use middle::trans::expr::{Dest, Ignore, SaveIn};\n use middle::trans::expr;\n use middle::trans::glue;\n-use middle::trans::machine::{llsize_of, nonzero_llsize_of};\n+use middle::trans::machine::{llsize_of, nonzero_llsize_of, llsize_of_alloc};\n use middle::trans::type_of;\n use middle::ty;\n use util::common::indenter;\n@@ -144,16 +144,19 @@ pub struct VecTypes {\n     vec_ty: ty::t,\n     unit_ty: ty::t,\n     llunit_ty: Type,\n-    llunit_size: ValueRef\n+    llunit_size: ValueRef,\n+    llunit_alloc_size: uint\n }\n \n impl VecTypes {\n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n-        format!(\"VecTypes \\\\{vec_ty={}, unit_ty={}, llunit_ty={}, llunit_size={}\\\\}\",\n+        format!(\"VecTypes \\\\{vec_ty={}, unit_ty={}, llunit_ty={}, llunit_size={}, \\\n+                 llunit_alloc_size={}\\\\}\",\n              ty_to_str(ccx.tcx, self.vec_ty),\n              ty_to_str(ccx.tcx, self.unit_ty),\n              ccx.tn.type_to_str(self.llunit_ty),\n-             ccx.tn.val_to_str(self.llunit_size))\n+             ccx.tn.val_to_str(self.llunit_size),\n+             self.llunit_alloc_size)\n     }\n }\n \n@@ -416,48 +419,10 @@ pub fn write_content(bcx: @mut Block,\n                         expr::trans_to_datum(bcx, element)\n                     });\n \n-                    let next_bcx = sub_block(bcx, \"expr_repeat: while next\");\n-                    let loop_bcx = loop_scope_block(bcx, next_bcx, None, \"expr_repeat\", None);\n-                    let cond_bcx = scope_block(loop_bcx, None, \"expr_repeat: loop cond\");\n-                    let set_bcx = scope_block(loop_bcx, None, \"expr_repeat: body: set\");\n-                    let inc_bcx = scope_block(loop_bcx, None, \"expr_repeat: body: inc\");\n-                    Br(bcx, loop_bcx.llbb);\n-\n-                    let loop_counter = {\n-                        // i = 0\n-                        let i = alloca(loop_bcx, bcx.ccx().int_type, \"__i\");\n-                        Store(loop_bcx, C_uint(bcx.ccx(), 0), i);\n-\n-                        Br(loop_bcx, cond_bcx.llbb);\n-                        i\n-                    };\n-\n-                    { // i < count\n-                        let lhs = Load(cond_bcx, loop_counter);\n-                        let rhs = C_uint(bcx.ccx(), count);\n-                        let cond_val = ICmp(cond_bcx, lib::llvm::IntULT, lhs, rhs);\n-\n-                        CondBr(cond_bcx, cond_val, set_bcx.llbb, next_bcx.llbb);\n-                    }\n-\n-                    { // v[i] = elem\n-                        let i = Load(set_bcx, loop_counter);\n-                        let lleltptr = InBoundsGEP(set_bcx, lldest, [i]);\n-                        let set_bcx = elem.copy_to(set_bcx, INIT, lleltptr);\n-\n-                        Br(set_bcx, inc_bcx.llbb);\n-                    }\n-\n-                    { // i += 1\n-                        let i = Load(inc_bcx, loop_counter);\n-                        let plusone = Add(inc_bcx, i, C_uint(bcx.ccx(), 1));\n-                        Store(inc_bcx, plusone, loop_counter);\n-\n-                        Br(inc_bcx, cond_bcx.llbb);\n-                    }\n-\n-                    return next_bcx;\n-\n+                    iter_vec_loop(bcx, lldest, vt,\n+                                  C_uint(bcx.ccx(), count), |set_bcx, lleltptr, _| {\n+                        elem.copy_to(set_bcx, INIT, lleltptr)\n+                    })\n                 }\n             }\n         }\n@@ -478,11 +443,13 @@ pub fn vec_types(bcx: @mut Block, vec_ty: ty::t) -> VecTypes {\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let llunit_ty = type_of::type_of(ccx, unit_ty);\n     let llunit_size = nonzero_llsize_of(ccx, llunit_ty);\n+    let llunit_alloc_size = llsize_of_alloc(ccx, llunit_ty);\n \n     VecTypes {vec_ty: vec_ty,\n               unit_ty: unit_ty,\n               llunit_ty: llunit_ty,\n-              llunit_size: llunit_size}\n+              llunit_size: llunit_size,\n+              llunit_alloc_size: llunit_alloc_size}\n }\n \n pub fn elements_required(bcx: @mut Block, content_expr: &ast::Expr) -> uint {\n@@ -574,35 +541,94 @@ pub fn get_base_and_len(bcx: @mut Block, llval: ValueRef, vec_ty: ty::t) -> (Val\n \n pub type iter_vec_block<'self> = &'self fn(@mut Block, ValueRef, ty::t) -> @mut Block;\n \n+pub fn iter_vec_loop(bcx: @mut Block,\n+                     data_ptr: ValueRef,\n+                     vt: &VecTypes,\n+                     count: ValueRef,\n+                     f: iter_vec_block\n+                     ) -> @mut Block {\n+    let _icx = push_ctxt(\"tvec::iter_vec_loop\");\n+\n+    let next_bcx = sub_block(bcx, \"iter_vec_loop: while next\");\n+    let loop_bcx = loop_scope_block(bcx, next_bcx, None, \"iter_vec_loop\", None);\n+    let cond_bcx = scope_block(loop_bcx, None, \"iter_vec_loop: loop cond\");\n+    let body_bcx = scope_block(loop_bcx, None, \"iter_vec_loop: body: main\");\n+    let inc_bcx = scope_block(loop_bcx, None, \"iter_vec_loop: loop inc\");\n+    Br(bcx, loop_bcx.llbb);\n+\n+    let loop_counter = {\n+        // i = 0\n+        let i = alloca(loop_bcx, bcx.ccx().int_type, \"__i\");\n+        Store(loop_bcx, C_uint(bcx.ccx(), 0), i);\n+\n+        Br(loop_bcx, cond_bcx.llbb);\n+        i\n+    };\n+\n+    { // i < count\n+        let lhs = Load(cond_bcx, loop_counter);\n+        let rhs = count;\n+        let cond_val = ICmp(cond_bcx, lib::llvm::IntULT, lhs, rhs);\n+\n+        CondBr(cond_bcx, cond_val, body_bcx.llbb, next_bcx.llbb);\n+    }\n+\n+    { // loop body\n+        let i = Load(body_bcx, loop_counter);\n+        let lleltptr = if vt.llunit_alloc_size == 0 {\n+            data_ptr\n+        } else {\n+            InBoundsGEP(body_bcx, data_ptr, [i])\n+        };\n+        let body_bcx = f(body_bcx, lleltptr, vt.unit_ty);\n+\n+        Br(body_bcx, inc_bcx.llbb);\n+    }\n+\n+    { // i += 1\n+        let i = Load(inc_bcx, loop_counter);\n+        let plusone = Add(inc_bcx, i, C_uint(bcx.ccx(), 1));\n+        Store(inc_bcx, plusone, loop_counter);\n+\n+        Br(inc_bcx, cond_bcx.llbb);\n+    }\n+\n+    next_bcx\n+}\n+\n pub fn iter_vec_raw(bcx: @mut Block, data_ptr: ValueRef, vec_ty: ty::t,\n                     fill: ValueRef, f: iter_vec_block) -> @mut Block {\n     let _icx = push_ctxt(\"tvec::iter_vec_raw\");\n \n-    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-\n-    // Calculate the last pointer address we want to handle.\n-    // FIXME (#3729): Optimize this when the size of the unit type is\n-    // statically known to not use pointer casts, which tend to confuse\n-    // LLVM.\n-    let data_end_ptr = pointer_add_byte(bcx, data_ptr, fill);\n-\n-    // Now perform the iteration.\n-    let header_bcx = base::sub_block(bcx, \"iter_vec_loop_header\");\n-    Br(bcx, header_bcx.llbb);\n-    let data_ptr =\n-        Phi(header_bcx, val_ty(data_ptr), [data_ptr], [bcx.llbb]);\n-    let not_yet_at_end =\n-        ICmp(header_bcx, lib::llvm::IntULT, data_ptr, data_end_ptr);\n-    let body_bcx = base::sub_block(header_bcx, \"iter_vec_loop_body\");\n-    let next_bcx = base::sub_block(header_bcx, \"iter_vec_next\");\n-    CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb);\n-    let body_bcx = f(body_bcx, data_ptr, unit_ty);\n-    AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,\n-                                           [C_int(bcx.ccx(), 1)]),\n-                     body_bcx.llbb);\n-    Br(body_bcx, header_bcx.llbb);\n-    return next_bcx;\n+    let vt = vec_types(bcx, vec_ty);\n+    if (vt.llunit_alloc_size == 0) {\n+        // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n+        iter_vec_loop(bcx, data_ptr, &vt, fill, f)\n+    } else {\n+        // Calculate the last pointer address we want to handle.\n+        // FIXME (#3729): Optimize this when the size of the unit type is\n+        // statically known to not use pointer casts, which tend to confuse\n+        // LLVM.\n+        let data_end_ptr = pointer_add_byte(bcx, data_ptr, fill);\n+\n+        // Now perform the iteration.\n+        let header_bcx = base::sub_block(bcx, \"iter_vec_loop_header\");\n+        Br(bcx, header_bcx.llbb);\n+        let data_ptr =\n+            Phi(header_bcx, val_ty(data_ptr), [data_ptr], [bcx.llbb]);\n+        let not_yet_at_end =\n+            ICmp(header_bcx, lib::llvm::IntULT, data_ptr, data_end_ptr);\n+        let body_bcx = base::sub_block(header_bcx, \"iter_vec_loop_body\");\n+        let next_bcx = base::sub_block(header_bcx, \"iter_vec_next\");\n+        CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb);\n+        let body_bcx = f(body_bcx, data_ptr, vt.unit_ty);\n+        AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,\n+                                               [C_int(bcx.ccx(), 1)]),\n+                         body_bcx.llbb);\n+        Br(body_bcx, header_bcx.llbb);\n+        next_bcx\n \n+    }\n }\n \n pub fn iter_vec_uniq(bcx: @mut Block, vptr: ValueRef, vec_ty: ty::t,"}, {"sha": "fd272a47de9c25736f4cd91d6800b13e598a63cd", "filename": "src/test/run-pass/zero-size-type-destructors.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/eee892c4beec9d037cfa68089334af7c9dd07401/src%2Ftest%2Frun-pass%2Fzero-size-type-destructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee892c4beec9d037cfa68089334af7c9dd07401/src%2Ftest%2Frun-pass%2Fzero-size-type-destructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzero-size-type-destructors.rs?ref=eee892c4beec9d037cfa68089334af7c9dd07401", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static mut destructions : int = 3;\n+\n+pub fn foo() {\n+    #[unsafe_no_drop_flag]\n+    struct Foo;\n+\n+    impl Drop for Foo {\n+        fn drop(&mut self) {\n+          unsafe { destructions -= 1 };\n+        }\n+    };\n+\n+    let _x = [Foo, Foo, Foo];\n+}\n+\n+pub fn main() {\n+  foo();\n+  assert!((unsafe { destructions } == 0));\n+}"}]}