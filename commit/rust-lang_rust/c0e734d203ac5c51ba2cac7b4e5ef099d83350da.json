{"sha": "c0e734d203ac5c51ba2cac7b4e5ef099d83350da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwZTczNGQyMDNhYzVjNTFiYTJjYWM3YjRlNWVmMDk5ZDgzMzUwZGE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-24T02:21:37Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-24T06:52:56Z"}, "message": "core::rt: Add more I/O docs", "tree": {"sha": "c05500c9f0958b860a97920f54b2579d99eab962", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c05500c9f0958b860a97920f54b2579d99eab962"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0e734d203ac5c51ba2cac7b4e5ef099d83350da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0e734d203ac5c51ba2cac7b4e5ef099d83350da", "html_url": "https://github.com/rust-lang/rust/commit/c0e734d203ac5c51ba2cac7b4e5ef099d83350da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0e734d203ac5c51ba2cac7b4e5ef099d83350da/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6373861510795bcaa6e98e97942c32eb26263bd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6373861510795bcaa6e98e97942c32eb26263bd8", "html_url": "https://github.com/rust-lang/rust/commit/6373861510795bcaa6e98e97942c32eb26263bd8"}], "stats": {"total": 175, "additions": 153, "deletions": 22}, "files": [{"sha": "ced4ba0ee23094cd34aea77b105616df04bf951e", "filename": "src/libcore/rt/io/mod.rs", "status": "modified", "additions": 151, "deletions": 22, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/c0e734d203ac5c51ba2cac7b4e5ef099d83350da/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0e734d203ac5c51ba2cac7b4e5ef099d83350da/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmod.rs?ref=c0e734d203ac5c51ba2cac7b4e5ef099d83350da", "patch": "@@ -10,12 +10,14 @@\n \n /*! Synchronous I/O\n \n-This module defines the Rust interface for synchronous I/O.  It is\n-build around Reader and Writer traits that define byte stream sources\n-and sinks.  Implementations are provided for common I/O streams like\n-file, TCP, UDP, Unix domain sockets, multiple types of memory bufers.\n-Readers and Writers may be composed to add things like string parsing,\n-and compression.\n+This module defines the Rust interface for synchronous I/O.\n+It models byte-oriented input and output with the Reader and Writer traits.\n+Types that implement both `Reader` and `Writer` and called 'streams',\n+and automatically implement trait `Stream`.\n+Implementations are provided for common I/O streams like\n+file, TCP, UDP, Unix domain sockets.\n+Readers and Writers may be composed to add capabilities like string\n+parsing, encoding, and compression.\n \n This will likely live in core::io, not core::rt::io.\n \n@@ -31,22 +33,22 @@ Some examples of obvious things you might want to do\n \n * Read a complete file to a string, (converting newlines?)\n \n-    let contents = FileStream::open(\"message.txt\").read_to_str(); // read_to_str??\n+    let contents = File::open(\"message.txt\").read_to_str(); // read_to_str??\n \n * Write a line to a file\n \n-    let file = FileStream::open(\"message.txt\", Create, Write);\n+    let file = File::open(\"message.txt\", Create, Write);\n     file.write_line(\"hello, file!\");\n \n * Iterate over the lines of a file\n \n-    do FileStream::open(\"message.txt\").each_line |line| {\n+    do File::open(\"message.txt\").each_line |line| {\n         println(line)\n     }\n \n * Pull the lines of a file into a vector of strings\n \n-    let lines = FileStream::open(\"message.txt\").line_iter().to_vec();\n+    let lines = File::open(\"message.txt\").line_iter().to_vec();\n \n * Make an simple HTTP request\n \n@@ -63,25 +65,145 @@ Some examples of obvious things you might want to do\n \n # Terms\n \n-* reader\n-* writer\n-* stream\n-* Blocking vs. non-blocking\n-* synchrony and asynchrony\n-\n-I tend to call this implementation non-blocking, because performing I/O\n-doesn't block the progress of other tasks. Is that how we want to present\n-it, 'synchronous but non-blocking'?\n+* Reader - An I/O source, reads bytes into a buffer\n+* Writer - An I/O sink, writes bytes from a buffer\n+* Stream - Typical I/O sources like files and sockets are both Readers and Writers,\n+  and are collectively referred to a `streams`.\n+* Decorator - A Reader or Writer that composes with others to add additional capabilities\n+  such as encoding or decoding\n+\n+# Blocking and synchrony\n+\n+When discussing I/O you often hear the terms 'synchronous' and\n+'asynchronous', along with 'blocking' and 'non-blocking' compared and\n+contrasted. A synchronous I/O interface performs each I/O operation to\n+completion before proceeding to the next. Synchronous interfaces are\n+usually used in imperative style as a sequence of commands. An\n+asynchronous interface allows multiple I/O requests to be issued\n+simultaneously, without waiting for each to complete before proceeding\n+to the next.\n+\n+Asynchronous interfaces are used to achieve 'non-blocking' I/O. In\n+traditional single-threaded systems, performing a synchronous I/O\n+operation means that the program stops all activity (it 'blocks')\n+until the I/O is complete. Blocking is bad for performance when\n+there are other computations that could be done.\n+\n+Asynchronous interfaces are most often associated with the callback\n+(continuation-passing) style popularised by node.js. Such systems rely\n+on all computations being run inside an event loop which maintains a\n+list of all pending I/O events; when one completes the registered\n+callback is run and the code that made the I/O request continiues.\n+Such interfaces achieve non-blocking at the expense of being more\n+difficult to reason about.\n+\n+Rust's I/O interface is synchronous - easy to read - and non-blocking by default.\n+\n+Remember that Rust tasks are 'green threads', lightweight threads that\n+are multiplexed onto a single operating system thread. If that system\n+thread blocks then no other task may proceed. Rust tasks are\n+relatively cheap to create, so as long as other tasks are free to\n+execute then non-blocking code may be written by simply creating a new\n+task.\n+\n+When discussing blocking in regards to Rust's I/O model, we are\n+concerned with whether performing I/O blocks other Rust tasks from\n+proceeding. In other words, when a task calls `read`, it must then\n+wait (or 'sleep', or 'block') until the call to `read` is complete.\n+During this time, other tasks may or may not be executed, depending on\n+how `read` is implemented.\n+\n+\n+Rust's default I/O implementation is non-blocking; by cooperating\n+directly with the task scheduler it arranges to never block progress\n+of *other* tasks. Under the hood, Rust uses asynchronous I/O via a\n+per-scheduler (and hence per-thread) event loop. Synchronous I/O\n+requests are implemented by descheduling the running task and\n+performing an asynchronous request; the task is only resumed once the\n+asynchronous request completes.\n+\n+For blocking (but possibly more efficient) implementations, look\n+in the `io::native` module.\n \n # Error Handling\n \n+I/O is an area where nearly every operation can result in unexpected\n+errors. It should allow errors to be handled efficiently.\n+It needs to be convenient to use I/O when you don't care\n+about dealing with specific errors.\n+\n+Rust's I/O employs a combination of techniques to reduce boilerplate\n+while still providing feedback about errors. The basic strategy:\n+\n+* Errors are fatal by default, resulting in task failure\n+* Errors raise the `io_error` conditon which provides an opportunity to inspect\n+  an IoError object containing details.\n+* Return values must have a sensible null or zero value which is returned\n+  if a condition is handled successfully. This may be an `Option`, an empty\n+  vector, or other designated error value.\n+* Common traits are implemented for `Option`, e.g. `impl<R: Reader> Reader for Option<R>`,\n+  so that nullable values do not have to be 'unwrapped' before use.\n+\n+These features combine in the API to allow for expressions like\n+`File::new(\"diary.txt\").write_line(\"met a girl\")` without having to\n+worry about whether \"diary.txt\" exists or whether the write\n+succeeds. As written, if either `new` or `write_line` encounters\n+an error the task will fail.\n+\n+If you wanted to handle the error though you might write\n+\n+    let mut error = None;\n+    do io_error::cond(|e: IoError| {\n+        error = Some(e);\n+    }).in {\n+        File::new(\"diary.txt\").write_line(\"met a girl\");\n+    }\n+\n+    if error.is_some() {\n+        println(\"failed to write my diary\");\n+    }\n+\n+XXX: Need better condition handling syntax\n+\n+In this case the condition handler will have the opportunity to\n+inspect the IoError raised by either the call to `new` or the call to\n+`write_line`, but then execution will continue.\n+\n+So what actually happens if `new` encounters an error? To understand\n+that it's important to know that what `new` returns is not a `File`\n+but an `Option<File>`.  If the file does not open, and the condition\n+is handled, then `new` will simply return `None`. Because there is an\n+implementation of `Writer` (the trait required ultimately required for\n+types to implement `write_line`) there is no need to inspect or unwrap\n+the `Option<File>` and we simply call `write_line` on it.  If `new`\n+returned a `None` then the followup call to `write_line` will also\n+raise an error.\n+\n+## Concerns about this strategy\n+\n+This structure will encourage a programming style that is prone\n+to errors similar to null pointer dereferences.\n+In particular code written to ignore errors and expect conditions to be unhandled\n+will start passing around null or zero objects when wrapped in a condition handler.\n+\n+* XXX: How should we use condition handlers that return values?\n+\n+\n+# Issues withi/o scheduler affinity, work stealing, task pinning\n+\n # Resource management\n \n * `close` vs. RAII\n \n-# Paths and URLs\n+# Paths, URLs and overloaded constructors\n+\n+\n \n-# std\n+# Scope\n+\n+In scope for core\n+\n+* Url?\n \n Some I/O things don't belong in core\n \n@@ -90,7 +212,12 @@ Some I/O things don't belong in core\n     - http\n   - flate\n \n-# XXX\n+Out of scope\n+\n+* Async I/O. We'll probably want it eventually\n+\n+\n+# XXX Questions and issues\n \n * Should default constructors take `Path` or `&str`? `Path` makes simple cases verbose.\n   Overloading would be nice.\n@@ -100,6 +227,7 @@ Some I/O things don't belong in core\n * fsync\n * relationship with filesystem querying, Directory, File types etc.\n * Rename Reader/Writer to ByteReader/Writer, make Reader/Writer generic?\n+* Can Port and Chan be implementations of a generic Reader<T>/Writer<T>?\n * Trait for things that are both readers and writers, Stream?\n * How to handle newline conversion\n * String conversion\n@@ -109,6 +237,7 @@ Some I/O things don't belong in core\n * Do we need `close` at all? dtors might be good enough\n * How does I/O relate to the Iterator trait?\n * std::base64 filters\n+* Using conditions is a big unknown since we don't have much experience with them\n \n */\n "}, {"sha": "56ed7dc95b6dfaad3764742c1f1e11300509a848", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0e734d203ac5c51ba2cac7b4e5ef099d83350da/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0e734d203ac5c51ba2cac7b4e5ef099d83350da/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=c0e734d203ac5c51ba2cac7b4e5ef099d83350da", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*! The Rust runtime, including the scheduler and I/O interface */\n+\n #[doc(hidden)];\n \n use libc::c_char;"}]}