{"sha": "484c61943f818272719bac81f6d5709fc5456438", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NGM2MTk0M2Y4MTgyNzI3MTliYWM4MWY2ZDU3MDlmYzU0NTY0Mzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-23T15:45:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-23T15:45:52Z"}, "message": "Auto merge of #84457 - jyn514:cleanup-crate, r=GuillaumeGomez\n\nrustdoc: Remove most fields from ExternalCrate\n\nOnce https://github.com/rust-lang/rust/issues/84304 is fixed, I can get rid of ExternCrate altogether in favor of CrateNum, but in the meantime, this shrinks ExternalCrate quite a lot.\n\nThis might hurt compile-times; if it does, I can add `primitive` and `keyword` queries. I expect this to improve compilemem.\n\nHelps with https://github.com/rust-lang/rust/issues/76382.\n\nr? GuillaumeGomez", "tree": {"sha": "0d3640b416901dac00a3f1a1edfd7f39a3e55e9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d3640b416901dac00a3f1a1edfd7f39a3e55e9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/484c61943f818272719bac81f6d5709fc5456438", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/484c61943f818272719bac81f6d5709fc5456438", "html_url": "https://github.com/rust-lang/rust/commit/484c61943f818272719bac81f6d5709fc5456438", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/484c61943f818272719bac81f6d5709fc5456438/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a352326112e4fd993e339cbd4eabae06d4979b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a352326112e4fd993e339cbd4eabae06d4979b9", "html_url": "https://github.com/rust-lang/rust/commit/9a352326112e4fd993e339cbd4eabae06d4979b9"}, {"sha": "6c6bd88ab36593f60e9dcf252a3bd9511374874a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c6bd88ab36593f60e9dcf252a3bd9511374874a", "html_url": "https://github.com/rust-lang/rust/commit/6c6bd88ab36593f60e9dcf252a3bd9511374874a"}], "stats": {"total": 282, "additions": 150, "deletions": 132}, "files": [{"sha": "72046645e3a97a894178e3550c1b8a8963eedca2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 116, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/484c61943f818272719bac81f6d5709fc5456438/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/484c61943f818272719bac81f6d5709fc5456438/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=484c61943f818272719bac81f6d5709fc5456438", "patch": "@@ -84,123 +84,8 @@ impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n \n impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &mut DocContext<'_>) -> ExternalCrate {\n-        let tcx = cx.tcx;\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n-        let krate_span = tcx.def_span(root);\n-        let krate_src = cx.sess().source_map().span_to_filename(krate_span);\n-\n-        // Collect all inner modules which are tagged as implementations of\n-        // primitives.\n-        //\n-        // Note that this loop only searches the top-level items of the crate,\n-        // and this is intentional. If we were to search the entire crate for an\n-        // item tagged with `#[doc(primitive)]` then we would also have to\n-        // search the entirety of external modules for items tagged\n-        // `#[doc(primitive)]`, which is a pretty inefficient process (decoding\n-        // all that metadata unconditionally).\n-        //\n-        // In order to keep the metadata load under control, the\n-        // `#[doc(primitive)]` feature is explicitly designed to only allow the\n-        // primitive tags to show up as the top level items in a crate.\n-        //\n-        // Also note that this does not attempt to deal with modules tagged\n-        // duplicately for the same primitive. This is handled later on when\n-        // rendering by delegating everything to a hash map.\n-        let mut as_primitive = |res: Res| {\n-            if let Res::Def(DefKind::Mod, def_id) = res {\n-                let attrs = cx.tcx.get_attrs(def_id).clean(cx);\n-                let mut prim = None;\n-                for attr in attrs.lists(sym::doc) {\n-                    if let Some(v) = attr.value_str() {\n-                        if attr.has_name(sym::primitive) {\n-                            prim = PrimitiveType::from_symbol(v);\n-                            if prim.is_some() {\n-                                break;\n-                            }\n-                            // FIXME: should warn on unknown primitives?\n-                        }\n-                    }\n-                }\n-                return prim.map(|p| (def_id, p));\n-            }\n-            None\n-        };\n-        let primitives = if root.is_local() {\n-            tcx.hir()\n-                .krate()\n-                .item\n-                .item_ids\n-                .iter()\n-                .filter_map(|&id| {\n-                    let item = tcx.hir().item(id);\n-                    match item.kind {\n-                        hir::ItemKind::Mod(_) => {\n-                            as_primitive(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n-                        }\n-                        hir::ItemKind::Use(ref path, hir::UseKind::Single)\n-                            if item.vis.node.is_pub() =>\n-                        {\n-                            as_primitive(path.res).map(|(_, prim)| {\n-                                // Pretend the primitive is local.\n-                                (id.def_id.to_def_id(), prim)\n-                            })\n-                        }\n-                        _ => None,\n-                    }\n-                })\n-                .collect()\n-        } else {\n-            tcx.item_children(root).iter().map(|item| item.res).filter_map(as_primitive).collect()\n-        };\n-\n-        let mut as_keyword = |res: Res| {\n-            if let Res::Def(DefKind::Mod, def_id) = res {\n-                let attrs = tcx.get_attrs(def_id).clean(cx);\n-                let mut keyword = None;\n-                for attr in attrs.lists(sym::doc) {\n-                    if attr.has_name(sym::keyword) {\n-                        if let Some(v) = attr.value_str() {\n-                            keyword = Some(v);\n-                            break;\n-                        }\n-                    }\n-                }\n-                return keyword.map(|p| (def_id, p));\n-            }\n-            None\n-        };\n-        let keywords = if root.is_local() {\n-            tcx.hir()\n-                .krate()\n-                .item\n-                .item_ids\n-                .iter()\n-                .filter_map(|&id| {\n-                    let item = tcx.hir().item(id);\n-                    match item.kind {\n-                        hir::ItemKind::Mod(_) => {\n-                            as_keyword(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n-                        }\n-                        hir::ItemKind::Use(ref path, hir::UseKind::Single)\n-                            if item.vis.node.is_pub() =>\n-                        {\n-                            as_keyword(path.res).map(|(_, prim)| (id.def_id.to_def_id(), prim))\n-                        }\n-                        _ => None,\n-                    }\n-                })\n-                .collect()\n-        } else {\n-            tcx.item_children(root).iter().map(|item| item.res).filter_map(as_keyword).collect()\n-        };\n-\n-        ExternalCrate {\n-            name: tcx.crate_name(*self),\n-            src: krate_src,\n-            attrs: tcx.get_attrs(root).clean(cx),\n-            primitives,\n-            keywords,\n-        }\n+        ExternalCrate { crate_num: *self, attrs: cx.tcx.get_attrs(root).clean(cx) }\n     }\n }\n "}, {"sha": "1acde8401b21efc88aeca31436f636700551e2cc", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 133, "deletions": 6, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/484c61943f818272719bac81f6d5709fc5456438/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/484c61943f818272719bac81f6d5709fc5456438/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=484c61943f818272719bac81f6d5709fc5456438", "patch": "@@ -17,8 +17,8 @@ use rustc_attr::{ConstStability, Deprecation, Stability, StabilityLevel};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex};\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{BodyId, Mutability};\n use rustc_index::vec::IndexVec;\n@@ -72,11 +72,138 @@ crate struct TraitWithExtraInfo {\n \n #[derive(Clone, Debug)]\n crate struct ExternalCrate {\n-    crate name: Symbol,\n-    crate src: FileName,\n+    crate crate_num: CrateNum,\n     crate attrs: Attributes,\n-    crate primitives: ThinVec<(DefId, PrimitiveType)>,\n-    crate keywords: ThinVec<(DefId, Symbol)>,\n+}\n+\n+impl ExternalCrate {\n+    #[inline]\n+    fn def_id(&self) -> DefId {\n+        DefId { krate: self.crate_num, index: CRATE_DEF_INDEX }\n+    }\n+\n+    crate fn src(&self, tcx: TyCtxt<'_>) -> FileName {\n+        let krate_span = tcx.def_span(self.def_id());\n+        tcx.sess.source_map().span_to_filename(krate_span)\n+    }\n+\n+    crate fn name(&self, tcx: TyCtxt<'_>) -> Symbol {\n+        tcx.crate_name(self.crate_num)\n+    }\n+\n+    crate fn keywords(&self, tcx: TyCtxt<'_>) -> ThinVec<(DefId, Symbol)> {\n+        let root = self.def_id();\n+\n+        let as_keyword = |res: Res| {\n+            if let Res::Def(DefKind::Mod, def_id) = res {\n+                let attrs = tcx.get_attrs(def_id);\n+                let mut keyword = None;\n+                for attr in attrs.lists(sym::doc) {\n+                    if attr.has_name(sym::keyword) {\n+                        if let Some(v) = attr.value_str() {\n+                            keyword = Some(v);\n+                            break;\n+                        }\n+                    }\n+                }\n+                return keyword.map(|p| (def_id, p));\n+            }\n+            None\n+        };\n+        if root.is_local() {\n+            tcx.hir()\n+                .krate()\n+                .item\n+                .item_ids\n+                .iter()\n+                .filter_map(|&id| {\n+                    let item = tcx.hir().item(id);\n+                    match item.kind {\n+                        hir::ItemKind::Mod(_) => {\n+                            as_keyword(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n+                        }\n+                        hir::ItemKind::Use(ref path, hir::UseKind::Single)\n+                            if item.vis.node.is_pub() =>\n+                        {\n+                            as_keyword(path.res).map(|(_, prim)| (id.def_id.to_def_id(), prim))\n+                        }\n+                        _ => None,\n+                    }\n+                })\n+                .collect()\n+        } else {\n+            tcx.item_children(root).iter().map(|item| item.res).filter_map(as_keyword).collect()\n+        }\n+    }\n+\n+    crate fn primitives(&self, tcx: TyCtxt<'_>) -> ThinVec<(DefId, PrimitiveType)> {\n+        let root = self.def_id();\n+\n+        // Collect all inner modules which are tagged as implementations of\n+        // primitives.\n+        //\n+        // Note that this loop only searches the top-level items of the crate,\n+        // and this is intentional. If we were to search the entire crate for an\n+        // item tagged with `#[doc(primitive)]` then we would also have to\n+        // search the entirety of external modules for items tagged\n+        // `#[doc(primitive)]`, which is a pretty inefficient process (decoding\n+        // all that metadata unconditionally).\n+        //\n+        // In order to keep the metadata load under control, the\n+        // `#[doc(primitive)]` feature is explicitly designed to only allow the\n+        // primitive tags to show up as the top level items in a crate.\n+        //\n+        // Also note that this does not attempt to deal with modules tagged\n+        // duplicately for the same primitive. This is handled later on when\n+        // rendering by delegating everything to a hash map.\n+        let as_primitive = |res: Res| {\n+            if let Res::Def(DefKind::Mod, def_id) = res {\n+                let attrs = tcx.get_attrs(def_id);\n+                let mut prim = None;\n+                for attr in attrs.lists(sym::doc) {\n+                    if let Some(v) = attr.value_str() {\n+                        if attr.has_name(sym::primitive) {\n+                            prim = PrimitiveType::from_symbol(v);\n+                            if prim.is_some() {\n+                                break;\n+                            }\n+                            // FIXME: should warn on unknown primitives?\n+                        }\n+                    }\n+                }\n+                return prim.map(|p| (def_id, p));\n+            }\n+            None\n+        };\n+\n+        if root.is_local() {\n+            tcx.hir()\n+                .krate()\n+                .item\n+                .item_ids\n+                .iter()\n+                .filter_map(|&id| {\n+                    let item = tcx.hir().item(id);\n+                    match item.kind {\n+                        hir::ItemKind::Mod(_) => {\n+                            as_primitive(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n+                        }\n+                        hir::ItemKind::Use(ref path, hir::UseKind::Single)\n+                            if item.vis.node.is_pub() =>\n+                        {\n+                            as_primitive(path.res).map(|(_, prim)| {\n+                                // Pretend the primitive is local.\n+                                (id.def_id.to_def_id(), prim)\n+                            })\n+                        }\n+                        _ => None,\n+                    }\n+                })\n+                .collect()\n+        } else {\n+            tcx.item_children(root).iter().map(|item| item.res).filter_map(as_primitive).collect()\n+        }\n+    }\n }\n \n /// Anything with a source location and set of attributes and, optionally, a"}, {"sha": "55a0cb42a2081e3c9dd28f424eac4515c2c1ba91", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/484c61943f818272719bac81f6d5709fc5456438/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/484c61943f818272719bac81f6d5709fc5456438/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=484c61943f818272719bac81f6d5709fc5456438", "patch": "@@ -1,9 +1,9 @@\n use crate::clean::auto_trait::AutoTraitFinder;\n use crate::clean::blanket_impl::BlanketImplFinder;\n use crate::clean::{\n-    inline, Clean, Crate, ExternalCrate, Generic, GenericArg, GenericArgs, ImportSource, Item,\n-    ItemKind, Lifetime, MacroKind, Path, PathSegment, Primitive, PrimitiveType, ResolvedPath, Type,\n-    TypeBinding, TypeKind,\n+    inline, Clean, Crate, Generic, GenericArg, GenericArgs, ImportSource, Item, ItemKind, Lifetime,\n+    MacroKind, Path, PathSegment, Primitive, PrimitiveType, ResolvedPath, Type, TypeBinding,\n+    TypeKind,\n };\n use crate::core::DocContext;\n \n@@ -54,7 +54,11 @@ crate fn krate(cx: &mut DocContext<'_>) -> Crate {\n         _ => unreachable!(),\n     }\n \n-    let ExternalCrate { name, src, primitives, keywords, .. } = LOCAL_CRATE.clean(cx);\n+    let local_crate = LOCAL_CRATE.clean(cx);\n+    let src = local_crate.src(cx.tcx);\n+    let name = local_crate.name(cx.tcx);\n+    let primitives = local_crate.primitives(cx.tcx);\n+    let keywords = local_crate.keywords(cx.tcx);\n     {\n         let m = match *module.kind {\n             ItemKind::ModuleItem(ref mut m) => m,"}, {"sha": "9a61f963a3ec35b6fcddf6881a15883edb241ace", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/484c61943f818272719bac81f6d5709fc5456438/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/484c61943f818272719bac81f6d5709fc5456438/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=484c61943f818272719bac81f6d5709fc5456438", "patch": "@@ -155,27 +155,28 @@ impl Cache {\n         // Cache where all our extern crates are located\n         // FIXME: this part is specific to HTML so it'd be nice to remove it from the common code\n         for &(n, ref e) in &krate.externs {\n-            let src_root = match e.src {\n+            let src_root = match e.src(tcx) {\n                 FileName::Real(ref p) => match p.local_path().parent() {\n                     Some(p) => p.to_path_buf(),\n                     None => PathBuf::new(),\n                 },\n                 _ => PathBuf::new(),\n             };\n-            let extern_url = extern_html_root_urls.get(&*e.name.as_str()).map(|u| &**u);\n+            let name = e.name(tcx);\n+            let extern_url = extern_html_root_urls.get(&*name.as_str()).map(|u| &**u);\n             self.extern_locations\n-                .insert(n, (e.name, src_root, extern_location(e, extern_url, &dst)));\n+                .insert(n, (name, src_root, extern_location(e, extern_url, &dst, tcx)));\n \n             let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n-            self.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n+            self.external_paths.insert(did, (vec![name.to_string()], ItemType::Module));\n         }\n \n         // Cache where all known primitives have their documentation located.\n         //\n         // Favor linking to as local extern as possible, so iterate all crates in\n         // reverse topological order.\n         for &(_, ref e) in krate.externs.iter().rev() {\n-            for &(def_id, prim) in &e.primitives {\n+            for &(def_id, prim) in &e.primitives(tcx) {\n                 self.primitive_locations.insert(prim, def_id);\n             }\n         }"}, {"sha": "b8544a0f439a7e757fb2eb133da253dacaa3ab28", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/484c61943f818272719bac81f6d5709fc5456438/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/484c61943f818272719bac81f6d5709fc5456438/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=484c61943f818272719bac81f6d5709fc5456438", "patch": "@@ -31,10 +31,11 @@ crate fn extern_location(\n     e: &clean::ExternalCrate,\n     extern_url: Option<&str>,\n     dst: &Path,\n+    tcx: TyCtxt<'_>,\n ) -> ExternalLocation {\n     use ExternalLocation::*;\n     // See if there's documentation generated into the local directory\n-    let local_location = dst.join(&*e.name.as_str());\n+    let local_location = dst.join(&*e.name(tcx).as_str());\n     if local_location.is_dir() {\n         return Local;\n     }"}]}