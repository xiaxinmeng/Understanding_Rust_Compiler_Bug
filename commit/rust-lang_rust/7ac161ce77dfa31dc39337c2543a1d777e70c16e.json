{"sha": "7ac161ce77dfa31dc39337c2543a1d777e70c16e", "node_id": "C_kwDOAAsO6NoAKDdhYzE2MWNlNzdkZmEzMWRjMzkzMzdjMjU0M2ExZDc3N2U3MGMxNmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-21T12:40:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-21T12:40:29Z"}, "message": "Auto merge of #14863 - lowr:fix/extract-fn-nested-tt, r=lnicola\n\nfix: consider all tokens in macro expr when analyzing locals\n\nFixes #14687\n\n2 fixes for `extract_function` assist (related closely enough that I squashed into one commit):\n\n- Locals in macro expressions have been analyzed only when they are in the top-level token tree the macro call wraps. We should consider all descendant tokens.\n- `self` in macro expressions haven't been analyzed.", "tree": {"sha": "b25477f1987e18f486757c08eae51702ef35be33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b25477f1987e18f486757c08eae51702ef35be33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ac161ce77dfa31dc39337c2543a1d777e70c16e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ac161ce77dfa31dc39337c2543a1d777e70c16e", "html_url": "https://github.com/rust-lang/rust/commit/7ac161ce77dfa31dc39337c2543a1d777e70c16e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ac161ce77dfa31dc39337c2543a1d777e70c16e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a04d8456be1d289c814846178cc1ff63b4fc297b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a04d8456be1d289c814846178cc1ff63b4fc297b", "html_url": "https://github.com/rust-lang/rust/commit/a04d8456be1d289c814846178cc1ff63b4fc297b"}, {"sha": "7b70988d48373f6d43874346c1cbcd15712a88c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b70988d48373f6d43874346c1cbcd15712a88c7", "html_url": "https://github.com/rust-lang/rust/commit/7b70988d48373f6d43874346c1cbcd15712a88c7"}], "stats": {"total": 93, "additions": 86, "deletions": 7}, "files": [{"sha": "c29721b4648782f0ae05337b438d08d09eaaa14a", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 86, "deletions": 7, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7ac161ce77dfa31dc39337c2543a1d777e70c16e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac161ce77dfa31dc39337c2543a1d777e70c16e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=7ac161ce77dfa31dc39337c2543a1d777e70c16e", "patch": "@@ -707,7 +707,7 @@ impl FunctionBody {\n     ) -> (FxIndexSet<Local>, Option<ast::SelfParam>) {\n         let mut self_param = None;\n         let mut res = FxIndexSet::default();\n-        let mut cb = |name_ref: Option<_>| {\n+        let mut add_name_if_local = |name_ref: Option<_>| {\n             let local_ref =\n                 match name_ref.and_then(|name_ref| NameRefClass::classify(sema, &name_ref)) {\n                     Some(\n@@ -731,21 +731,24 @@ impl FunctionBody {\n         };\n         self.walk_expr(&mut |expr| match expr {\n             ast::Expr::PathExpr(path_expr) => {\n-                cb(path_expr.path().and_then(|it| it.as_single_name_ref()))\n+                add_name_if_local(path_expr.path().and_then(|it| it.as_single_name_ref()))\n             }\n             ast::Expr::ClosureExpr(closure_expr) => {\n                 if let Some(body) = closure_expr.body() {\n-                    body.syntax().descendants().map(ast::NameRef::cast).for_each(|it| cb(it));\n+                    body.syntax()\n+                        .descendants()\n+                        .map(ast::NameRef::cast)\n+                        .for_each(&mut add_name_if_local);\n                 }\n             }\n             ast::Expr::MacroExpr(expr) => {\n                 if let Some(tt) = expr.macro_call().and_then(|call| call.token_tree()) {\n                     tt.syntax()\n-                        .children_with_tokens()\n-                        .flat_map(SyntaxElement::into_token)\n-                        .filter(|it| it.kind() == SyntaxKind::IDENT)\n+                        .descendants_with_tokens()\n+                        .filter_map(SyntaxElement::into_token)\n+                        .filter(|it| matches!(it.kind(), SyntaxKind::IDENT | T![self]))\n                         .flat_map(|t| sema.descend_into_macros(t))\n-                        .for_each(|t| cb(t.parent().and_then(ast::NameRef::cast)));\n+                        .for_each(|t| add_name_if_local(t.parent().and_then(ast::NameRef::cast)));\n                 }\n             }\n             _ => (),\n@@ -4344,6 +4347,82 @@ fn $0fun_name(n: i32) -> i32 {\n         );\n     }\n \n+    #[test]\n+    fn param_usage_in_macro_with_nested_tt() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+macro_rules! m {\n+    ($val:expr) => { $val };\n+}\n+\n+fn foo() {\n+    let n = 1;\n+    let t = 1;\n+    $0let k = n * m!((n) + { t });$0\n+    let m = k + 1;\n+}\n+\"#,\n+            r#\"\n+macro_rules! m {\n+    ($val:expr) => { $val };\n+}\n+\n+fn foo() {\n+    let n = 1;\n+    let t = 1;\n+    let k = fun_name(n, t);\n+    let m = k + 1;\n+}\n+\n+fn $0fun_name(n: i32, t: i32) -> i32 {\n+    let k = n * m!((n) + { t });\n+    k\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn param_usage_in_macro_with_nested_tt_2() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+macro_rules! m {\n+    ($val:expr) => { $val };\n+}\n+\n+struct S(i32);\n+impl S {\n+    fn foo(&self) {\n+        let n = 1;\n+        $0let k = n * m!((n) + { self.0 });$0\n+        let m = k + 1;\n+    }\n+}\n+\"#,\n+            r#\"\n+macro_rules! m {\n+    ($val:expr) => { $val };\n+}\n+\n+struct S(i32);\n+impl S {\n+    fn foo(&self) {\n+        let n = 1;\n+        let k = self.fun_name(n);\n+        let m = k + 1;\n+    }\n+\n+    fn $0fun_name(&self, n: i32) -> i32 {\n+        let k = n * m!((n) + { self.0 });\n+        k\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn extract_with_await() {\n         check_assist("}]}