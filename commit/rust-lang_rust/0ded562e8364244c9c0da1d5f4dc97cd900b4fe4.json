{"sha": "0ded562e8364244c9c0da1d5f4dc97cd900b4fe4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkZWQ1NjJlODM2NDI0NGM5YzBkYTFkNWY0ZGM5N2NkOTAwYjRmZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-26T22:03:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-26T22:03:52Z"}, "message": "auto merge of #5023 : mitsuhiko/rust/make-absolute-refactor, r=catamorphism\n\nThis pull request moves the logic from os::make_absolute() into the path module and fixes path joining for Windows.  It does this by adding an ``unsafe_join()`` function that implements the operating system's path joining semantics.\r\n\r\nAdditionally it also adds an ``is_restricted()`` method to the trait which will return true if the path points to a windows device file.", "tree": {"sha": "df36457cac6b8b3b91ad1ef51fd8811f8a98e7cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df36457cac6b8b3b91ad1ef51fd8811f8a98e7cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ded562e8364244c9c0da1d5f4dc97cd900b4fe4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ded562e8364244c9c0da1d5f4dc97cd900b4fe4", "html_url": "https://github.com/rust-lang/rust/commit/0ded562e8364244c9c0da1d5f4dc97cd900b4fe4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ded562e8364244c9c0da1d5f4dc97cd900b4fe4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44acefd1017ae61d71a468961ba8f6131701dee5", "url": "https://api.github.com/repos/rust-lang/rust/commits/44acefd1017ae61d71a468961ba8f6131701dee5", "html_url": "https://github.com/rust-lang/rust/commit/44acefd1017ae61d71a468961ba8f6131701dee5"}, {"sha": "c77c5c4674c92b342132a56bd1b59f86af3d5a63", "url": "https://api.github.com/repos/rust-lang/rust/commits/c77c5c4674c92b342132a56bd1b59f86af3d5a63", "html_url": "https://github.com/rust-lang/rust/commit/c77c5c4674c92b342132a56bd1b59f86af3d5a63"}], "stats": {"total": 156, "additions": 145, "deletions": 11}, "files": [{"sha": "9cd5e8f4965d2f759f947c8d0ecdbf89cdb35c27", "filename": "src/libcore/os.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ded562e8364244c9c0da1d5f4dc97cd900b4fe4/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ded562e8364244c9c0da1d5f4dc97cd900b4fe4/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=0ded562e8364244c9c0da1d5f4dc97cd900b4fe4", "patch": "@@ -566,17 +566,13 @@ pub fn path_exists(p: &Path) -> bool {\n  *\n  * If the given path is relative, return it prepended with the current working\n  * directory. If the given path is already an absolute path, return it\n- * as is.\n+ * as is.  This is a shortcut for calling os::getcwd().unsafe_join(p)\n  */\n // NB: this is here rather than in path because it is a form of environment\n // querying; what it does depends on the process working directory, not just\n // the input paths.\n pub fn make_absolute(p: &Path) -> Path {\n-    if p.is_absolute {\n-        copy *p\n-    } else {\n-        getcwd().push_many(p.components)\n-    }\n+    getcwd().unsafe_join(p)\n }\n \n "}, {"sha": "1753862649f57387072e06a6b25a9353e1597608", "filename": "src/libcore/path.rs", "status": "modified", "additions": 143, "deletions": 5, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/0ded562e8364244c9c0da1d5f4dc97cd900b4fe4/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ded562e8364244c9c0da1d5f4dc97cd900b4fe4/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=0ded562e8364244c9c0da1d5f4dc97cd900b4fe4", "patch": "@@ -64,6 +64,9 @@ pub trait GenericPath {\n     pure fn push_many((&[~str])) -> Self;\n     pure fn pop() -> Self;\n \n+    pure fn unsafe_join((&Self)) -> Self;\n+    pure fn is_restricted() -> bool;\n+\n     pure fn normalize() -> Self;\n }\n \n@@ -485,6 +488,19 @@ impl GenericPath for PosixPath {\n         self.push_many(other.components)\n     }\n \n+    pure fn unsafe_join(other: &PosixPath) -> PosixPath {\n+        if other.is_absolute {\n+            PosixPath { is_absolute: true,\n+                        components: copy other.components }\n+        } else {\n+            self.push_rel(other)\n+        }\n+    }\n+\n+    pure fn is_restricted() -> bool {\n+        false\n+    }\n+\n     pure fn push_many(cs: &[~str]) -> PosixPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n@@ -685,6 +701,61 @@ impl GenericPath for WindowsPath {\n         self.push_many(other.components)\n     }\n \n+    pure fn unsafe_join(other: &WindowsPath) -> WindowsPath {\n+        /* rhs not absolute is simple push */\n+        if !other.is_absolute {\n+            return self.push_many(other.components);\n+        }\n+\n+        /* if rhs has a host set, then the whole thing wins */\n+        match other.host {\n+            Some(copy host) => {\n+                return WindowsPath {\n+                    host: Some(host),\n+                    device: copy other.device,\n+                    is_absolute: true,\n+                    components: copy other.components\n+                };\n+            }\n+            _ => {}\n+        }\n+\n+        /* if rhs has a device set, then a part wins */\n+        match other.device {\n+            Some(copy device) => {\n+                return WindowsPath {\n+                    host: None,\n+                    device: Some(device),\n+                    is_absolute: true,\n+                    components: copy other.components\n+                };\n+            }\n+            _ => {}\n+        }\n+\n+        /* fallback: host and device of lhs win, but the\n+           whole path of the right */\n+        WindowsPath {\n+            host: copy self.host,\n+            device: copy self.device,\n+            is_absolute: self.is_absolute || other.is_absolute,\n+            components: copy other.components\n+        }\n+    }\n+\n+    pure fn is_restricted() -> bool {\n+        match self.filestem() {\n+            Some(stem) => {\n+                match stem.to_lower() {\n+                    ~\"con\" | ~\"aux\" | ~\"com1\" | ~\"com2\" | ~\"com3\" | ~\"com4\" |\n+                    ~\"lpt1\" | ~\"lpt2\" | ~\"lpt3\" | ~\"prn\" | ~\"nul\" => true,\n+                    _ => false\n+                }\n+            },\n+            None => false\n+        }\n+    }\n+\n     pure fn push_many(cs: &[~str]) -> WindowsPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n@@ -725,7 +796,10 @@ impl GenericPath for WindowsPath {\n     pure fn normalize() -> WindowsPath {\n         return WindowsPath {\n             host: copy self.host,\n-            device: copy self.device,\n+            device: match self.device {\n+                None => None,\n+                Some(ref device) => Some(device.to_upper())\n+            },\n             is_absolute: self.is_absolute,\n             components: normalize(self.components)\n         }\n@@ -764,13 +838,13 @@ pub mod windows {\n \n     pub pure fn extract_unc_prefix(s: &str) -> Option<(~str,~str)> {\n         if (s.len() > 1 &&\n-            s[0] == '\\\\' as u8 &&\n-            s[1] == '\\\\' as u8) {\n+            (s[0] == '\\\\' as u8 || s[0] == '/' as u8) &&\n+            s[0] == s[1]) {\n             let mut i = 2;\n             while i < s.len() {\n-                if s[i] == '\\\\' as u8 {\n+                if is_sep(s[i]) {\n                     let pre = s.slice(2, i);\n-                    let rest = s.slice(i, s.len());\n+                    let mut rest = s.slice(i, s.len());\n                     return Some((pre, rest));\n                 }\n                 i += 1;\n@@ -916,13 +990,21 @@ mod tests {\n     #[test]\n     fn test_extract_unc_prefixes() {\n         assert windows::extract_unc_prefix(\"\\\\\\\\\").is_none();\n+        assert windows::extract_unc_prefix(\"//\").is_none();\n         assert windows::extract_unc_prefix(\"\\\\\\\\hi\").is_none();\n+        assert windows::extract_unc_prefix(\"//hi\").is_none();\n         assert windows::extract_unc_prefix(\"\\\\\\\\hi\\\\\") ==\n             Some((~\"hi\", ~\"\\\\\"));\n+        assert windows::extract_unc_prefix(\"//hi\\\\\") ==\n+            Some((~\"hi\", ~\"\\\\\"));\n         assert windows::extract_unc_prefix(\"\\\\\\\\hi\\\\there\") ==\n             Some((~\"hi\", ~\"\\\\there\"));\n+        assert windows::extract_unc_prefix(\"//hi/there\") ==\n+            Some((~\"hi\", ~\"/there\"));\n         assert windows::extract_unc_prefix(\"\\\\\\\\hi\\\\there\\\\friends.txt\") ==\n             Some((~\"hi\", ~\"\\\\there\\\\friends.txt\"));\n+        assert windows::extract_unc_prefix(\"//hi\\\\there\\\\friends.txt\") ==\n+            Some((~\"hi\", ~\"\\\\there\\\\friends.txt\"));\n     }\n \n     #[test]\n@@ -981,5 +1063,61 @@ mod tests {\n             .push_many([~\"lib\", ~\"thingy.dll\"])\n             .with_filename(\"librustc.dll\")),\n           \"c:\\\\program files (x86)\\\\rust\\\\lib\\\\librustc.dll\");\n+\n+        t(&(WindowsPath(\"\\\\\\\\computer\\\\share\")\n+            .unsafe_join(&WindowsPath(\"\\\\a\"))),\n+          \"\\\\\\\\computer\\\\a\");\n+\n+        t(&(WindowsPath(\"//computer/share\")\n+            .unsafe_join(&WindowsPath(\"\\\\a\"))),\n+          \"\\\\\\\\computer\\\\a\");\n+\n+        t(&(WindowsPath(\"//computer/share\")\n+            .unsafe_join(&WindowsPath(\"\\\\\\\\computer\\\\share\"))),\n+          \"\\\\\\\\computer\\\\share\");\n+\n+        t(&(WindowsPath(\"C:/whatever\")\n+            .unsafe_join(&WindowsPath(\"//computer/share/a/b\"))),\n+          \"\\\\\\\\computer\\\\share\\\\a\\\\b\");\n+\n+        t(&(WindowsPath(\"C:\")\n+            .unsafe_join(&WindowsPath(\"D:/foo\"))),\n+          \"D:\\\\foo\");\n+\n+        t(&(WindowsPath(\"C:\")\n+            .unsafe_join(&WindowsPath(\"B\"))),\n+          \"C:B\");\n+\n+        t(&(WindowsPath(\"C:\")\n+            .unsafe_join(&WindowsPath(\"/foo\"))),\n+          \"C:\\\\foo\");\n+\n+        t(&(WindowsPath(\"C:\\\\\")\n+            .unsafe_join(&WindowsPath(\"\\\\bar\"))),\n+          \"C:\\\\bar\");\n+\n+        t(&(WindowsPath(\"\")\n+            .unsafe_join(&WindowsPath(\"\"))),\n+          \"\");\n+\n+        t(&(WindowsPath(\"\")\n+            .unsafe_join(&WindowsPath(\"a\"))),\n+          \"a\");\n+\n+        t(&(WindowsPath(\"\")\n+            .unsafe_join(&WindowsPath(\"C:\\\\a\"))),\n+          \"C:\\\\a\");\n+\n+        t(&(WindowsPath(\"c:\\\\foo\")\n+            .normalize()),\n+          \"C:\\\\foo\");\n+    }\n+\n+    #[test]\n+    fn test_windows_path_restrictions() {\n+        assert WindowsPath(\"hi\").is_restricted() == false;\n+        assert WindowsPath(\"C:\\\\NUL\").is_restricted() == true;\n+        assert WindowsPath(\"C:\\\\COM1.TXT\").is_restricted() == true;\n+        assert WindowsPath(\"c:\\\\prn.exe\").is_restricted() == true;\n     }\n }"}]}