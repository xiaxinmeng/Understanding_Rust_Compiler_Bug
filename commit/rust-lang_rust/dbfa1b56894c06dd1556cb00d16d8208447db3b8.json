{"sha": "dbfa1b56894c06dd1556cb00d16d8208447db3b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiZmExYjU2ODk0YzA2ZGQxNTU2Y2IwMGQxNmQ4MjA4NDQ3ZGIzYjg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2011-12-16T21:01:47Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2011-12-16T21:01:47Z"}, "message": "Merge pull request #1317 from boggle/fix1315\n\nfix to #1315 + small additions to std::either and result", "tree": {"sha": "3d1a7d7821acf8220e0618ba4c67595491c4a000", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d1a7d7821acf8220e0618ba4c67595491c4a000"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbfa1b56894c06dd1556cb00d16d8208447db3b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbfa1b56894c06dd1556cb00d16d8208447db3b8", "html_url": "https://github.com/rust-lang/rust/commit/dbfa1b56894c06dd1556cb00d16d8208447db3b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbfa1b56894c06dd1556cb00d16d8208447db3b8/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bf078f988498ddbdbbfd5c58f850bce14518db6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bf078f988498ddbdbbfd5c58f850bce14518db6", "html_url": "https://github.com/rust-lang/rust/commit/1bf078f988498ddbdbbfd5c58f850bce14518db6"}, {"sha": "7d786318a1b0f9315164716b46306d68e3b9560f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d786318a1b0f9315164716b46306d68e3b9560f", "html_url": "https://github.com/rust-lang/rust/commit/7d786318a1b0f9315164716b46306d68e3b9560f"}], "stats": {"total": 83, "additions": 58, "deletions": 25}, "files": [{"sha": "af4b752f4dd1a7e556168154eb94d1acf637ff30", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=dbfa1b56894c06dd1556cb00d16d8208447db3b8", "patch": "@@ -123,7 +123,7 @@ Returns:\n \n An u8 whose first bit is set if `if_true(v)` holds\n */\n-fn to_bit(v: t) -> u8 { if v { 1u8 } else { 0u8 } }\n+pure fn to_bit(v: t) -> u8 { if v { 1u8 } else { 0u8 } }\n \n // Local Variables:\n // mode: rust;"}, {"sha": "23b5889bc6a4e5f6ce31574dec81e5841e47f716", "filename": "src/libcore/box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbox.rs?ref=dbfa1b56894c06dd1556cb00d16d8208447db3b8", "patch": "@@ -10,7 +10,7 @@ Function: ptr_eq\n \n Determine if two shared boxes point to the same object\n */\n-fn ptr_eq<T>(a: @T, b: @T) -> bool {\n+pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     // FIXME: ptr::addr_of\n     unsafe {\n         let a_ptr: uint = unsafe::reinterpret_cast(a);"}, {"sha": "2648c8481dfa17134100188232cbde7aa2e3a8fa", "filename": "src/libcore/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=dbfa1b56894c06dd1556cb00d16d8208447db3b8", "patch": "@@ -122,7 +122,7 @@ pure fn to_digit(c: char) -> u8 unsafe {\n  Convert a char to the corresponding digit. Returns none when the\n  character is not a valid hexadecimal digit.\n */\n-fn maybe_digit(c: char) -> option::t<u8> {\n+pure fn maybe_digit(c: char) -> option::t<u8> {\n     alt c {\n       '0' to '9' { option::some(c as u8 - ('0' as u8)) }\n       'a' to 'z' { option::some(c as u8 + 10u8 - ('a' as u8)) }\n@@ -143,7 +143,7 @@ fn maybe_digit(c: char) -> option::t<u8> {\n  Returns:\n   -1 if a<b, 0 if a==b, +1 if a>b\n */\n-fn cmp(a: char, b: char) -> int {\n+pure fn cmp(a: char, b: char) -> int {\n     ret  if b > a { -1 }\n     else if b < a { 1 }\n     else { 0 }"}, {"sha": "60ad12d2e026aebfbe714b9863f7ca34852774d2", "filename": "src/libcore/either.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=dbfa1b56894c06dd1556cb00d16d8208447db3b8", "patch": "@@ -78,6 +78,31 @@ fn partition<copy T, copy U>(eithers: [t<T, U>])\n     ret {lefts: lefts, rights: rights};\n }\n \n+/*\n+Function: flip\n+\n+Flips between left and right of a given either\n+*/\n+pure fn flip<copy T, copy U>(eith: t<T, U>) -> t<U, T> {\n+    alt eith {\n+      right(r) { left(r) }\n+      left(l) { right(l) }\n+    }\n+}\n+\n+/*\n+Function: to_result\n+\n+Converts either::t to a result::t, making the \"right\" choice\n+an ok result, and the \"left\" choice a fail\n+*/\n+pure fn to_result<copy T, copy U>(eith: t<T, U>) -> result::t<U, T> {\n+    alt eith {\n+      right(r) { result::ok(r) }\n+      left(l) { result::err(l) }\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "aaaf82eb7cd3981ed305321f56f666557e3006ef", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=dbfa1b56894c06dd1556cb00d16d8208447db3b8", "patch": "@@ -30,7 +30,7 @@ Failure:\n \n Fails if the value equals `none`.\n */\n-fn get<copy T>(opt: t<T>) -> T {\n+pure fn get<copy T>(opt: t<T>) -> T {\n     alt opt { some(x) { ret x; } none. { fail \"option none\"; } }\n }\n \n@@ -61,7 +61,7 @@ Function: from_maybe\n \n Returns the contained value or a default\n */\n-fn from_maybe<T>(def: T, opt: t<T>) -> T {\n+pure fn from_maybe<T>(def: T, opt: t<T>) -> T {\n     alt opt { some(x) { x } none. { def } }\n }\n "}, {"sha": "84fbc3b7f90e0a6bc16d57dac25dd986d96b6124", "filename": "src/libcore/result.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=dbfa1b56894c06dd1556cb00d16d8208447db3b8", "patch": "@@ -42,7 +42,7 @@ fn get<T, U>(res: t<T, U>) -> T {\n       ok(t) { t }\n       err(_) {\n         // FIXME: Serialize the error value\n-        // and include it in the fail message\n+        // and include it in the fail message (maybe just note it)\n         fail \"get called on error result\";\n       }\n     }\n@@ -71,7 +71,7 @@ Function: success\n \n Returns true if the result is <ok>\n */\n-fn success<T, U>(res: t<T, U>) -> bool {\n+pure fn success<T, U>(res: t<T, U>) -> bool {\n     alt res {\n       ok(_) { true }\n       err(_) { false }\n@@ -83,10 +83,17 @@ Function: failure\n \n Returns true if the result is <error>\n */\n-fn failure<T, U>(res: t<T, U>) -> bool {\n+pure fn failure<T, U>(res: t<T, U>) -> bool {\n     !success(res)\n }\n \n+pure fn to_either<copy T, copy U>(res: t<U, T>) -> either::t<T, U> {\n+    alt res {\n+      ok(res) { either::right(res) }\n+      err(fail_) { either::left(fail_) }\n+    }\n+}\n+\n /*\n Function: chain\n "}, {"sha": "802297223e9bce490dda0f670d91c9e45bff7119", "filename": "src/libcore/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=dbfa1b56894c06dd1556cb00d16d8208447db3b8", "patch": "@@ -26,14 +26,14 @@ Function: eq\n \n Bytewise string equality\n */\n-fn eq(&&a: str, &&b: str) -> bool { a == b }\n+pure fn eq(&&a: str, &&b: str) -> bool { a == b }\n \n /*\n Function: lteq\n \n Bytewise less than or equal\n */\n-fn lteq(&&a: str, &&b: str) -> bool { a <= b }\n+pure fn lteq(&&a: str, &&b: str) -> bool { a <= b }\n \n /*\n Function: hash\n@@ -131,7 +131,7 @@ Function: byte_len\n \n Returns the length in bytes of a string\n */\n-fn byte_len(s: str) -> uint unsafe {\n+pure fn byte_len(s: str) -> uint unsafe {\n     let v: [u8] = unsafe::reinterpret_cast(s);\n     let vlen = vec::len(v);\n     unsafe::leak(v);\n@@ -261,7 +261,7 @@ Function: utf8_char_width\n \n FIXME: What does this function do?\n */\n-fn utf8_char_width(b: u8) -> uint {\n+pure fn utf8_char_width(b: u8) -> uint {\n     let byte: uint = b as uint;\n     if byte < 128u { ret 1u; }\n     if byte < 192u {"}, {"sha": "9c8b097211173a63bb518885834d8e1117af8e9d", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=dbfa1b56894c06dd1556cb00d16d8208447db3b8", "patch": "@@ -42,7 +42,7 @@ Function: last_os_error\n Get a string representing the platform-dependent last error\n */\n fn last_os_error() -> str {\n-    ret rustrt::last_os_error();\n+    rustrt::last_os_error()\n }\n \n /*"}, {"sha": "97821aed2feb6377810cf37146bf96bb648e332c", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=dbfa1b56894c06dd1556cb00d16d8208447db3b8", "patch": "@@ -181,7 +181,7 @@ Returns the first element of a vector\n Predicates:\n <is_not_empty> (v)\n */\n-fn head<copy T>(v: [const T]) : is_not_empty(v) -> T { ret v[0]; }\n+pure fn head<copy T>(v: [const T]) : is_not_empty(v) -> T { ret v[0]; }\n \n /*\n Function: tail\n@@ -221,7 +221,7 @@ Returns:\n An option containing the last element of `v` if `v` is not empty, or\n none if `v` is empty.\n */\n-fn last<copy T>(v: [const T]) -> option::t<T> {\n+pure fn last<copy T>(v: [const T]) -> option::t<T> {\n     if len(v) == 0u { ret none; }\n     ret some(v[len(v) - 1u]);\n }\n@@ -234,7 +234,7 @@ Returns the last element of a non-empty vector `v`\n Predicates:\n <is_not_empty> (v)\n */\n-fn last_total<copy T>(v: [const T]) : is_not_empty(v) -> T {\n+pure fn last_total<copy T>(v: [const T]) : is_not_empty(v) -> T {\n     ret v[len(v) - 1u];\n }\n "}, {"sha": "6f68b66617424c6f8047cd30631e18bd2d77e8b0", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=dbfa1b56894c06dd1556cb00d16d8208447db3b8", "patch": "@@ -128,7 +128,7 @@ Function: get\n \n Retreive the value at index `i`\n */\n-fn get(v: t, i: uint) -> bool {\n+pure fn get(v: t, i: uint) -> bool {\n     assert (i < v.nbits);\n     let bits = uint_bits;\n     let w = i / bits;"}, {"sha": "c6a24d275eb3484dfe85bebf1c587f3f9722a55a", "filename": "src/libstd/list.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=dbfa1b56894c06dd1556cb00d16d8208447db3b8", "patch": "@@ -112,7 +112,7 @@ Function: tail\n \n Returns all but the first element of a list\n */\n-fn tail<copy T>(ls: list<T>) -> list<T> {\n+pure fn tail<copy T>(ls: list<T>) -> list<T> {\n     alt ls { cons(_, tl) { ret *tl; } nil. { fail \"list empty\" } }\n }\n \n@@ -121,7 +121,7 @@ Function: head\n \n Returns the first element of a list\n */\n-fn head<copy T>(ls: list<T>) -> T {\n+pure fn head<copy T>(ls: list<T>) -> T {\n     alt ls { cons(hd, _) { ret hd; } nil. { fail \"list empty\" } }\n }\n \n@@ -130,7 +130,7 @@ Function: append\n \n Appends one list to another\n */\n-fn append<copy T>(l: list<T>, m: list<T>) -> list<T> {\n+pure fn append<copy T>(l: list<T>, m: list<T>) -> list<T> {\n     alt l {\n       nil. { ret m; }\n       cons(x, xs) { let rest = append(*xs, m); ret cons(x, @rest); }"}, {"sha": "e774650f980b5b208fc585e03865a0d6603ea880", "filename": "src/libstd/posix_fs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibstd%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibstd%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fposix_fs.rs?ref=dbfa1b56894c06dd1556cb00d16d8208447db3b8", "patch": "@@ -30,6 +30,7 @@ fn list_dir(path: str) -> [str] {\n \n }\n \n+// FIXME make pure when str::char_at is\n fn path_is_absolute(p: str) -> bool { ret str::char_at(p, 0u) == '/'; }\n \n const path_sep: char = '/';"}, {"sha": "bd07b6a8bc7e6d61aba056de57e8940401a65991", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=dbfa1b56894c06dd1556cb00d16d8208447db3b8", "patch": "@@ -310,7 +310,7 @@ Returns:\n \n A negative value if `left < right`, 0 if eq(left, right) or a positive\n value if `left > right`\n- */\n+*/\n fn cmp(left: rope, right: rope) -> int {\n     alt((left, right)) {\n       (node::empty., node::empty.) { ret 0; }"}, {"sha": "a3d11cbc55b23f38940f33092f09db53e953c2c8", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbfa1b56894c06dd1556cb00d16d8208447db3b8/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=dbfa1b56894c06dd1556cb00d16d8208447db3b8", "patch": "@@ -151,16 +151,16 @@ mod icu {\n     #[link_name = \"icuuc\"]\n     #[abi = \"cdecl\"]\n     native mod libicu {\n-        fn u_hasBinaryProperty(c: UChar32, which: UProperty) -> UBool;\n+        pure fn u_hasBinaryProperty(c: UChar32, which: UProperty) -> UBool;\n     }\n }\n \n-fn is_XID_start(c: char) -> bool {\n+pure fn is_XID_start(c: char) -> bool {\n     ret icu::libicu::u_hasBinaryProperty(c, icu::UCHAR_XID_START)\n         == icu::TRUE;\n }\n \n-fn is_XID_continue(c: char) -> bool {\n+pure fn is_XID_continue(c: char) -> bool {\n     ret icu::libicu::u_hasBinaryProperty(c, icu::UCHAR_XID_START)\n         == icu::TRUE;\n }"}]}