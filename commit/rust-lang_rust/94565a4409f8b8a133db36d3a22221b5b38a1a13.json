{"sha": "94565a4409f8b8a133db36d3a22221b5b38a1a13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NTY1YTQ0MDlmOGI4YTEzM2RiMzZkM2EyMjIyMWI1YjM4YTFhMTM=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-10-04T00:41:01Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-10-04T21:55:25Z"}, "message": "Rename StringReader::pos as next_pos.\n\nThis is a [breaking-change] for libsyntax.", "tree": {"sha": "acb57b7d094d36f1f3baa5a1597053880cb6774c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acb57b7d094d36f1f3baa5a1597053880cb6774c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94565a4409f8b8a133db36d3a22221b5b38a1a13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94565a4409f8b8a133db36d3a22221b5b38a1a13", "html_url": "https://github.com/rust-lang/rust/commit/94565a4409f8b8a133db36d3a22221b5b38a1a13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94565a4409f8b8a133db36d3a22221b5b38a1a13/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c4c85947cddac2d36854e5bf8c7a8edb32e1245", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c4c85947cddac2d36854e5bf8c7a8edb32e1245", "html_url": "https://github.com/rust-lang/rust/commit/3c4c85947cddac2d36854e5bf8c7a8edb32e1245"}], "stats": {"total": 36, "additions": 18, "deletions": 18}, "files": [{"sha": "f5545b8eb7a45c873ef439e6a44f39404b658757", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/94565a4409f8b8a133db36d3a22221b5b38a1a13/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94565a4409f8b8a133db36d3a22221b5b38a1a13/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=94565a4409f8b8a133db36d3a22221b5b38a1a13", "patch": "@@ -77,7 +77,7 @@ pub struct TokenAndSpan {\n pub struct StringReader<'a> {\n     pub span_diagnostic: &'a Handler,\n     /// The absolute offset within the codemap of the next character to read\n-    pub pos: BytePos,\n+    pub next_pos: BytePos,\n     /// The absolute offset within the codemap of the last character read(curr)\n     pub last_pos: BytePos,\n     /// The column of the next character to read\n@@ -107,7 +107,7 @@ impl<'a> Reader for StringReader<'a> {\n         }\n \n         match self.terminator {\n-            Some(t) => self.pos > t,\n+            Some(t) => self.next_pos > t,\n             None => false,\n         }\n     }\n@@ -173,7 +173,7 @@ impl<'a> Reader for TtReader<'a> {\n }\n \n impl<'a> StringReader<'a> {\n-    /// For comments.rs, which hackily pokes into pos and curr\n+    /// For comments.rs, which hackily pokes into next_pos and curr\n     pub fn new_raw<'b>(span_diagnostic: &'b Handler,\n                        filemap: Rc<syntax_pos::FileMap>)\n                        -> StringReader<'b> {\n@@ -195,7 +195,7 @@ impl<'a> StringReader<'a> {\n \n         StringReader {\n             span_diagnostic: span_diagnostic,\n-            pos: filemap.start_pos,\n+            next_pos: filemap.start_pos,\n             last_pos: filemap.start_pos,\n             col: CharPos(0),\n             curr: Some('\\n'),\n@@ -414,13 +414,13 @@ impl<'a> StringReader<'a> {\n     /// Advance the StringReader by one character. If a newline is\n     /// discovered, add it to the FileMap's list of line start offsets.\n     pub fn bump(&mut self) {\n-        self.last_pos = self.pos;\n-        let current_byte_offset = self.byte_offset(self.pos).to_usize();\n+        self.last_pos = self.next_pos;\n+        let current_byte_offset = self.byte_offset(self.next_pos).to_usize();\n         if current_byte_offset < self.source_text.len() {\n             let last_char = self.curr.unwrap();\n             let ch = char_at(&self.source_text, current_byte_offset);\n             let byte_offset_diff = ch.len_utf8();\n-            self.pos = self.pos + Pos::from_usize(byte_offset_diff);\n+            self.next_pos = self.next_pos + Pos::from_usize(byte_offset_diff);\n             self.curr = Some(ch);\n             self.col = self.col + CharPos(1);\n             if last_char == '\\n' {\n@@ -439,7 +439,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     pub fn nextch(&self) -> Option<char> {\n-        let offset = self.byte_offset(self.pos).to_usize();\n+        let offset = self.byte_offset(self.next_pos).to_usize();\n         if offset < self.source_text.len() {\n             Some(char_at(&self.source_text, offset))\n         } else {\n@@ -452,7 +452,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     pub fn nextnextch(&self) -> Option<char> {\n-        let offset = self.byte_offset(self.pos).to_usize();\n+        let offset = self.byte_offset(self.next_pos).to_usize();\n         let s = &self.source_text[..];\n         if offset >= s.len() {\n             return None;\n@@ -518,7 +518,7 @@ impl<'a> StringReader<'a> {\n                                     break;\n                                 } else if doc_comment {\n                                     self.err_span_(self.last_pos,\n-                                                   self.pos,\n+                                                   self.next_pos,\n                                                    \"bare CR not allowed in doc-comment\");\n                                 }\n                             }\n@@ -695,7 +695,7 @@ impl<'a> StringReader<'a> {\n                     // in range for the true radix\n                     if c.unwrap().to_digit(real_radix).is_none() {\n                         self.err_span_(self.last_pos,\n-                                       self.pos,\n+                                       self.next_pos,\n                                        &format!(\"invalid digit for a base {} literal\", real_radix));\n                     }\n                     len += 1;\n@@ -809,7 +809,7 @@ impl<'a> StringReader<'a> {\n             accum_int *= 16;\n             accum_int += c.to_digit(16).unwrap_or_else(|| {\n                 self.err_span_char(self.last_pos,\n-                                   self.pos,\n+                                   self.next_pos,\n                                    \"invalid character in numeric character escape\",\n                                    c);\n \n@@ -980,11 +980,11 @@ impl<'a> StringReader<'a> {\n             accum_int += c.to_digit(16).unwrap_or_else(|| {\n                 if c == delim {\n                     panic!(self.fatal_span_(self.last_pos,\n-                                            self.pos,\n+                                            self.next_pos,\n                                             \"unterminated unicode escape (needed a `}`)\"));\n                 } else {\n                     self.err_span_char(self.last_pos,\n-                                       self.pos,\n+                                       self.next_pos,\n                                        \"invalid character in unicode escape\",\n                                        c);\n                 }\n@@ -1022,7 +1022,7 @@ impl<'a> StringReader<'a> {\n             }\n             if self.scan_digits(10, 10) == 0 {\n                 self.err_span_(self.last_pos,\n-                               self.pos,\n+                               self.next_pos,\n                                \"expected at least one digit in exponent\")\n             }\n         }\n@@ -1259,7 +1259,7 @@ impl<'a> StringReader<'a> {\n                     // if we find one, then this is an invalid character literal\n                     if self.curr_is('\\'') {\n                         panic!(self.fatal_span_verbose(\n-                               start_with_quote, self.pos,\n+                               start_with_quote, self.next_pos,\n                                String::from(\"character literal may only contain one codepoint\")));\n \n                     }\n@@ -1467,7 +1467,7 @@ impl<'a> StringReader<'a> {\n             }\n             c => {\n                 let last_bpos = self.last_pos;\n-                let bpos = self.pos;\n+                let bpos = self.next_pos;\n                 let mut err = self.struct_fatal_span_char(last_bpos,\n                                                           bpos,\n                                                           \"unknown start of token\","}, {"sha": "b59f54dd7c94d85b5e3403929fef1d915d24deec", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94565a4409f8b8a133db36d3a22221b5b38a1a13/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94565a4409f8b8a133db36d3a22221b5b38a1a13/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=94565a4409f8b8a133db36d3a22221b5b38a1a13", "patch": "@@ -234,7 +234,7 @@ pub fn check_for_substitution<'a>(reader: &StringReader<'a>,\n     .iter()\n     .find(|&&(c, _, _)| c == ch)\n     .map(|&(_, u_name, ascii_char)| {\n-        let span = make_span(reader.last_pos, reader.pos);\n+        let span = make_span(reader.last_pos, reader.next_pos);\n         match ASCII_ARRAY.iter().find(|&&(c, _)| c == ascii_char) {\n             Some(&(ascii_char, ascii_name)) => {\n                 let msg ="}]}