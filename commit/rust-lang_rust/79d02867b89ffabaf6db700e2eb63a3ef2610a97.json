{"sha": "79d02867b89ffabaf6db700e2eb63a3ef2610a97", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZDAyODY3Yjg5ZmZhYmFmNmRiNzAwZTJlYjYzYTNlZjI2MTBhOTc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-11T16:40:56Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-15T07:27:52Z"}, "message": "move parse_lit to expr.rs", "tree": {"sha": "9f4761c426f12132509c87b7fac68db711370c53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f4761c426f12132509c87b7fac68db711370c53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79d02867b89ffabaf6db700e2eb63a3ef2610a97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79d02867b89ffabaf6db700e2eb63a3ef2610a97", "html_url": "https://github.com/rust-lang/rust/commit/79d02867b89ffabaf6db700e2eb63a3ef2610a97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79d02867b89ffabaf6db700e2eb63a3ef2610a97/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1", "html_url": "https://github.com/rust-lang/rust/commit/52d0e86b9a46ab74f76c0bc7b2b9df3d32fcfbc1"}], "stats": {"total": 347, "additions": 170, "deletions": 177}, "files": [{"sha": "fbd409b0de4f236956c55bdbe542a72a2c0f749b", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 2, "deletions": 165, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/79d02867b89ffabaf6db700e2eb63a3ef2610a97/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02867b89ffabaf6db700e2eb63a3ef2610a97/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=79d02867b89ffabaf6db700e2eb63a3ef2610a97", "patch": "@@ -1,14 +1,10 @@\n //! Code related to parsing literals.\n \n use crate::ast::{self, Lit, LitKind};\n-use crate::parse::parser::Parser;\n-use crate::parse::PResult;\n-use crate::parse::token::{self, Token, TokenKind};\n-use crate::print::pprust;\n+use crate::parse::token::{self, Token};\n use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{TokenStream, TokenTree};\n \n-use errors::{Applicability, Handler};\n use log::debug;\n use rustc_data_structures::sync::Lrc;\n use syntax_pos::Span;\n@@ -28,72 +24,6 @@ crate enum LitError {\n     IntTooLarge,\n }\n \n-impl LitError {\n-    fn report(&self, diag: &Handler, lit: token::Lit, span: Span) {\n-        let token::Lit { kind, suffix, .. } = lit;\n-        match *self {\n-            // `NotLiteral` is not an error by itself, so we don't report\n-            // it and give the parser opportunity to try something else.\n-            LitError::NotLiteral => {}\n-            // `LexerError` *is* an error, but it was already reported\n-            // by lexer, so here we don't report it the second time.\n-            LitError::LexerError => {}\n-            LitError::InvalidSuffix => {\n-                expect_no_suffix(\n-                    diag, span, &format!(\"{} {} literal\", kind.article(), kind.descr()), suffix\n-                );\n-            }\n-            LitError::InvalidIntSuffix => {\n-                let suf = suffix.expect(\"suffix error with no suffix\").as_str();\n-                if looks_like_width_suffix(&['i', 'u'], &suf) {\n-                    // If it looks like a width, try to be helpful.\n-                    let msg = format!(\"invalid width `{}` for integer literal\", &suf[1..]);\n-                    diag.struct_span_err(span, &msg)\n-                        .help(\"valid widths are 8, 16, 32, 64 and 128\")\n-                        .emit();\n-                } else {\n-                    let msg = format!(\"invalid suffix `{}` for integer literal\", suf);\n-                    diag.struct_span_err(span, &msg)\n-                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n-                        .help(\"the suffix must be one of the integral types (`u32`, `isize`, etc)\")\n-                        .emit();\n-                }\n-            }\n-            LitError::InvalidFloatSuffix => {\n-                let suf = suffix.expect(\"suffix error with no suffix\").as_str();\n-                if looks_like_width_suffix(&['f'], &suf) {\n-                    // If it looks like a width, try to be helpful.\n-                    let msg = format!(\"invalid width `{}` for float literal\", &suf[1..]);\n-                    diag.struct_span_err(span, &msg)\n-                        .help(\"valid widths are 32 and 64\")\n-                        .emit();\n-                } else {\n-                    let msg = format!(\"invalid suffix `{}` for float literal\", suf);\n-                    diag.struct_span_err(span, &msg)\n-                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n-                        .help(\"valid suffixes are `f32` and `f64`\")\n-                        .emit();\n-                }\n-            }\n-            LitError::NonDecimalFloat(base) => {\n-                let descr = match base {\n-                    16 => \"hexadecimal\",\n-                    8 => \"octal\",\n-                    2 => \"binary\",\n-                    _ => unreachable!(),\n-                };\n-                diag.struct_span_err(span, &format!(\"{} float literal is not supported\", descr))\n-                    .span_label(span, \"not supported\")\n-                    .emit();\n-            }\n-            LitError::IntTooLarge => {\n-                diag.struct_span_err(span, \"integer literal is too large\")\n-                    .emit();\n-            }\n-        }\n-    }\n-}\n-\n impl LitKind {\n     /// Converts literal token into a semantic literal.\n     fn from_lit_token(lit: token::Lit) -> Result<LitKind, LitError> {\n@@ -254,7 +184,7 @@ impl LitKind {\n \n impl Lit {\n     /// Converts literal token into an AST literal.\n-    fn from_lit_token(token: token::Lit, span: Span) -> Result<Lit, LitError> {\n+    crate fn from_lit_token(token: token::Lit, span: Span) -> Result<Lit, LitError> {\n         Ok(Lit { token, kind: LitKind::from_lit_token(token)?, span })\n     }\n \n@@ -296,99 +226,6 @@ impl Lit {\n     }\n }\n \n-impl<'a> Parser<'a> {\n-    /// Matches `lit = true | false | token_lit`.\n-    crate fn parse_lit(&mut self) -> PResult<'a, Lit> {\n-        let mut recovered = None;\n-        if self.token == token::Dot {\n-            // Attempt to recover `.4` as `0.4`.\n-            recovered = self.look_ahead(1, |next_token| {\n-                if let token::Literal(token::Lit { kind: token::Integer, symbol, suffix })\n-                        = next_token.kind {\n-                    if self.token.span.hi() == next_token.span.lo() {\n-                        let s = String::from(\"0.\") + &symbol.as_str();\n-                        let kind = TokenKind::lit(token::Float, Symbol::intern(&s), suffix);\n-                        return Some(Token::new(kind, self.token.span.to(next_token.span)));\n-                    }\n-                }\n-                None\n-            });\n-            if let Some(token) = &recovered {\n-                self.bump();\n-                self.diagnostic()\n-                    .struct_span_err(token.span, \"float literals must have an integer part\")\n-                    .span_suggestion(\n-                        token.span,\n-                        \"must have an integer part\",\n-                        pprust::token_to_string(token),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n-            }\n-        }\n-\n-        let token = recovered.as_ref().unwrap_or(&self.token);\n-        match Lit::from_token(token) {\n-            Ok(lit) => {\n-                self.bump();\n-                Ok(lit)\n-            }\n-            Err(LitError::NotLiteral) => {\n-                let msg = format!(\"unexpected token: {}\", self.this_token_descr());\n-                Err(self.span_fatal(token.span, &msg))\n-            }\n-            Err(err) => {\n-                let (lit, span) = (token.expect_lit(), token.span);\n-                self.bump();\n-                err.report(&self.sess.span_diagnostic, lit, span);\n-                // Pack possible quotes and prefixes from the original literal into\n-                // the error literal's symbol so they can be pretty-printed faithfully.\n-                let suffixless_lit = token::Lit::new(lit.kind, lit.symbol, None);\n-                let symbol = Symbol::intern(&suffixless_lit.to_string());\n-                let lit = token::Lit::new(token::Err, symbol, lit.suffix);\n-                Lit::from_lit_token(lit, span).map_err(|_| unreachable!())\n-            }\n-        }\n-    }\n-}\n-\n-crate fn expect_no_suffix(diag: &Handler, sp: Span, kind: &str, suffix: Option<Symbol>) {\n-    if let Some(suf) = suffix {\n-        let mut err = if kind == \"a tuple index\" &&\n-                         [sym::i32, sym::u32, sym::isize, sym::usize].contains(&suf) {\n-            // #59553: warn instead of reject out of hand to allow the fix to percolate\n-            // through the ecosystem when people fix their macros\n-            let mut err = diag.struct_span_warn(\n-                sp,\n-                &format!(\"suffixes on {} are invalid\", kind),\n-            );\n-            err.note(&format!(\n-                \"`{}` is *temporarily* accepted on tuple index fields as it was \\\n-                    incorrectly accepted on stable for a few releases\",\n-                suf,\n-            ));\n-            err.help(\n-                \"on proc macros, you'll want to use `syn::Index::from` or \\\n-                    `proc_macro::Literal::*_unsuffixed` for code that will desugar \\\n-                    to tuple field access\",\n-            );\n-            err.note(\n-                \"for more context, see https://github.com/rust-lang/rust/issues/60210\",\n-            );\n-            err\n-        } else {\n-            diag.struct_span_err(sp, &format!(\"suffixes on {} are invalid\", kind))\n-        };\n-        err.span_label(sp, format!(\"invalid suffix `{}`\", suf));\n-        err.emit();\n-    }\n-}\n-\n-// Checks if `s` looks like i32 or u1234 etc.\n-fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n-    s.len() > 1 && s.starts_with(first_chars) && s[1..].chars().all(|c| c.is_ascii_digit())\n-}\n-\n fn strip_underscores(symbol: Symbol) -> Symbol {\n     // Do not allocate a new string unless necessary.\n     let s = symbol.as_str();"}, {"sha": "a3ac6d0c81f30e24c5af21f66e4f25d5873ed46d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79d02867b89ffabaf6db700e2eb63a3ef2610a97/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02867b89ffabaf6db700e2eb63a3ef2610a97/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=79d02867b89ffabaf6db700e2eb63a3ef2610a97", "patch": "@@ -15,10 +15,10 @@ use crate::ast::{\n     self, DUMMY_NODE_ID, AttrStyle, Attribute, CrateSugar, Ident,\n     IsAsync, MacDelimiter, Mutability, StrStyle, Visibility, VisibilityKind, Unsafety,\n };\n-use crate::parse::{ParseSess, PResult, Directory, DirectoryOwnership, SeqSep, literal, token};\n+use crate::parse::{ParseSess, PResult, Directory, DirectoryOwnership, SeqSep};\n use crate::parse::lexer::UnmatchedBrace;\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n-use crate::parse::token::{Token, TokenKind, DelimToken};\n+use crate::parse::token::{self, Token, TokenKind, DelimToken};\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::source_map::respan;\n@@ -637,10 +637,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn expect_no_suffix(&self, sp: Span, kind: &str, suffix: Option<ast::Name>) {\n-        literal::expect_no_suffix(&self.sess.span_diagnostic, sp, kind, suffix)\n-    }\n-\n     /// Attempts to consume a `<`. If `<<` is seen, replaces it with a single\n     /// `<` and continue. If `<-` is seen, replaces it with a single `<`\n     /// and continue. If a `<` is not seen, returns false."}, {"sha": "dd0fd834fb0c901d76fbbbe415fc84a097b4abb1", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 166, "deletions": 6, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/79d02867b89ffabaf6db700e2eb63a3ef2610a97/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d02867b89ffabaf6db700e2eb63a3ef2610a97/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=79d02867b89ffabaf6db700e2eb63a3ef2610a97", "patch": "@@ -1,17 +1,17 @@\n-use super::{\n-    Parser, PResult, Restrictions, PrevTokenKind, TokenType, PathStyle, BlockMode, SemiColonMode,\n-    SeqSep, TokenExpectType,\n-};\n+use super::{Parser, PResult, Restrictions, PrevTokenKind, TokenType, PathStyle, BlockMode};\n+use super::{SemiColonMode, SeqSep, TokenExpectType};\n use super::pat::{GateOr, PARAM_EXPECTED};\n \n+use crate::parse::literal::LitError;\n+\n use crate::ast::{\n     self, DUMMY_NODE_ID, Attribute, AttrStyle, Ident, CaptureBy, BlockCheckMode,\n     Expr, ExprKind, RangeLimits, Label, Movability, IsAsync, Arm, Ty, TyKind,\n-    FunctionRetTy, Param, FnDecl, BinOpKind, BinOp, UnOp, Mac, AnonConst, Field,\n+    FunctionRetTy, Param, FnDecl, BinOpKind, BinOp, UnOp, Mac, AnonConst, Field, Lit,\n };\n use crate::maybe_recover_from_interpolated_ty_qpath;\n use crate::parse::classify;\n-use crate::parse::token::{self, Token};\n+use crate::parse::token::{self, Token, TokenKind};\n use crate::parse::diagnostics::Error;\n use crate::print::pprust;\n use crate::ptr::P;\n@@ -20,6 +20,7 @@ use crate::symbol::{kw, sym};\n use crate::util::parser::{AssocOp, Fixity, prec_let_scrutinee_needs_par};\n \n use errors::Applicability;\n+use syntax_pos::Symbol;\n use std::mem;\n use rustc_data_structures::thin_vec::ThinVec;\n \n@@ -1072,6 +1073,165 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n+    /// Matches `lit = true | false | token_lit`.\n+    crate fn parse_lit(&mut self) -> PResult<'a, Lit> {\n+        let mut recovered = None;\n+        if self.token == token::Dot {\n+            // Attempt to recover `.4` as `0.4`.\n+            recovered = self.look_ahead(1, |next_token| {\n+                if let token::Literal(token::Lit { kind: token::Integer, symbol, suffix })\n+                        = next_token.kind {\n+                    if self.token.span.hi() == next_token.span.lo() {\n+                        let s = String::from(\"0.\") + &symbol.as_str();\n+                        let kind = TokenKind::lit(token::Float, Symbol::intern(&s), suffix);\n+                        return Some(Token::new(kind, self.token.span.to(next_token.span)));\n+                    }\n+                }\n+                None\n+            });\n+            if let Some(token) = &recovered {\n+                self.bump();\n+                self.struct_span_err(token.span, \"float literals must have an integer part\")\n+                    .span_suggestion(\n+                        token.span,\n+                        \"must have an integer part\",\n+                        pprust::token_to_string(token),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+            }\n+        }\n+\n+        let token = recovered.as_ref().unwrap_or(&self.token);\n+        match Lit::from_token(token) {\n+            Ok(lit) => {\n+                self.bump();\n+                Ok(lit)\n+            }\n+            Err(LitError::NotLiteral) => {\n+                let msg = format!(\"unexpected token: {}\", self.this_token_descr());\n+                Err(self.span_fatal(token.span, &msg))\n+            }\n+            Err(err) => {\n+                let (lit, span) = (token.expect_lit(), token.span);\n+                self.bump();\n+                self.error_literal_from_token(err, lit, span);\n+                // Pack possible quotes and prefixes from the original literal into\n+                // the error literal's symbol so they can be pretty-printed faithfully.\n+                let suffixless_lit = token::Lit::new(lit.kind, lit.symbol, None);\n+                let symbol = Symbol::intern(&suffixless_lit.to_string());\n+                let lit = token::Lit::new(token::Err, symbol, lit.suffix);\n+                Lit::from_lit_token(lit, span).map_err(|_| unreachable!())\n+            }\n+        }\n+    }\n+\n+    fn error_literal_from_token(&self, err: LitError, lit: token::Lit, span: Span) {\n+        // Checks if `s` looks like i32 or u1234 etc.\n+        fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n+            s.len() > 1\n+            && s.starts_with(first_chars)\n+            && s[1..].chars().all(|c| c.is_ascii_digit())\n+        }\n+\n+        let token::Lit { kind, suffix, .. } = lit;\n+        match err {\n+            // `NotLiteral` is not an error by itself, so we don't report\n+            // it and give the parser opportunity to try something else.\n+            LitError::NotLiteral => {}\n+            // `LexerError` *is* an error, but it was already reported\n+            // by lexer, so here we don't report it the second time.\n+            LitError::LexerError => {}\n+            LitError::InvalidSuffix => {\n+                self.expect_no_suffix(\n+                    span,\n+                    &format!(\"{} {} literal\", kind.article(), kind.descr()),\n+                    suffix,\n+                );\n+            }\n+            LitError::InvalidIntSuffix => {\n+                let suf = suffix.expect(\"suffix error with no suffix\").as_str();\n+                if looks_like_width_suffix(&['i', 'u'], &suf) {\n+                    // If it looks like a width, try to be helpful.\n+                    let msg = format!(\"invalid width `{}` for integer literal\", &suf[1..]);\n+                    self.struct_span_err(span, &msg)\n+                        .help(\"valid widths are 8, 16, 32, 64 and 128\")\n+                        .emit();\n+                } else {\n+                    let msg = format!(\"invalid suffix `{}` for integer literal\", suf);\n+                    self.struct_span_err(span, &msg)\n+                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n+                        .help(\"the suffix must be one of the integral types (`u32`, `isize`, etc)\")\n+                        .emit();\n+                }\n+            }\n+            LitError::InvalidFloatSuffix => {\n+                let suf = suffix.expect(\"suffix error with no suffix\").as_str();\n+                if looks_like_width_suffix(&['f'], &suf) {\n+                    // If it looks like a width, try to be helpful.\n+                    let msg = format!(\"invalid width `{}` for float literal\", &suf[1..]);\n+                    self.struct_span_err(span, &msg)\n+                        .help(\"valid widths are 32 and 64\")\n+                        .emit();\n+                } else {\n+                    let msg = format!(\"invalid suffix `{}` for float literal\", suf);\n+                    self.struct_span_err(span, &msg)\n+                        .span_label(span, format!(\"invalid suffix `{}`\", suf))\n+                        .help(\"valid suffixes are `f32` and `f64`\")\n+                        .emit();\n+                }\n+            }\n+            LitError::NonDecimalFloat(base) => {\n+                let descr = match base {\n+                    16 => \"hexadecimal\",\n+                    8 => \"octal\",\n+                    2 => \"binary\",\n+                    _ => unreachable!(),\n+                };\n+                self.struct_span_err(span, &format!(\"{} float literal is not supported\", descr))\n+                    .span_label(span, \"not supported\")\n+                    .emit();\n+            }\n+            LitError::IntTooLarge => {\n+                self.struct_span_err(span, \"integer literal is too large\")\n+                    .emit();\n+            }\n+        }\n+    }\n+\n+    pub(super) fn expect_no_suffix(&self, sp: Span, kind: &str, suffix: Option<Symbol>) {\n+        if let Some(suf) = suffix {\n+            let mut err = if kind == \"a tuple index\"\n+                && [sym::i32, sym::u32, sym::isize, sym::usize].contains(&suf)\n+            {\n+                // #59553: warn instead of reject out of hand to allow the fix to percolate\n+                // through the ecosystem when people fix their macros\n+                let mut err = self.sess.span_diagnostic.struct_span_warn(\n+                    sp,\n+                    &format!(\"suffixes on {} are invalid\", kind),\n+                );\n+                err.note(&format!(\n+                    \"`{}` is *temporarily* accepted on tuple index fields as it was \\\n+                        incorrectly accepted on stable for a few releases\",\n+                    suf,\n+                ));\n+                err.help(\n+                    \"on proc macros, you'll want to use `syn::Index::from` or \\\n+                        `proc_macro::Literal::*_unsuffixed` for code that will desugar \\\n+                        to tuple field access\",\n+                );\n+                err.note(\n+                    \"for more context, see https://github.com/rust-lang/rust/issues/60210\",\n+                );\n+                err\n+            } else {\n+                self.struct_span_err(sp, &format!(\"suffixes on {} are invalid\", kind))\n+            };\n+            err.span_label(sp, format!(\"invalid suffix `{}`\", suf));\n+            err.emit();\n+        }\n+    }\n+\n     /// Matches `'-' lit | lit` (cf. `ast_validation::AstValidator::check_expr_within_pat`).\n     crate fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n         maybe_whole_expr!(self);"}]}