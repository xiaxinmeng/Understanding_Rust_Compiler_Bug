{"sha": "8da694a42138ac74047d989abd3c7daf0edcbe93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYTY5NGE0MjEzOGFjNzQwNDdkOTg5YWJkM2M3ZGFmMGVkY2JlOTM=", "commit": {"author": {"name": "Federico Mena Quintero", "email": "federico@gnome.org", "date": "2017-09-23T01:36:44Z"}, "committer": {"name": "Federico Mena Quintero", "email": "federico@gnome.org", "date": "2017-09-25T18:51:48Z"}, "message": "Overhaul the ffi::CString docs\n\nExplain the struct's reason for being, and its most common usage\npatterns.  Add a bunch of links.\n\nClarify the method docs a bit.\n\nPart of https://github.com/rust-lang/rust/issues/29354", "tree": {"sha": "69ae8038b24dd91d680f9cc316925d0f27bbf0cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69ae8038b24dd91d680f9cc316925d0f27bbf0cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8da694a42138ac74047d989abd3c7daf0edcbe93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8da694a42138ac74047d989abd3c7daf0edcbe93", "html_url": "https://github.com/rust-lang/rust/commit/8da694a42138ac74047d989abd3c7daf0edcbe93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8da694a42138ac74047d989abd3c7daf0edcbe93/comments", "author": {"login": "federicomenaquintero", "id": 7617, "node_id": "MDQ6VXNlcjc2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/7617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/federicomenaquintero", "html_url": "https://github.com/federicomenaquintero", "followers_url": "https://api.github.com/users/federicomenaquintero/followers", "following_url": "https://api.github.com/users/federicomenaquintero/following{/other_user}", "gists_url": "https://api.github.com/users/federicomenaquintero/gists{/gist_id}", "starred_url": "https://api.github.com/users/federicomenaquintero/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/federicomenaquintero/subscriptions", "organizations_url": "https://api.github.com/users/federicomenaquintero/orgs", "repos_url": "https://api.github.com/users/federicomenaquintero/repos", "events_url": "https://api.github.com/users/federicomenaquintero/events{/privacy}", "received_events_url": "https://api.github.com/users/federicomenaquintero/received_events", "type": "User", "site_admin": false}, "committer": {"login": "federicomenaquintero", "id": 7617, "node_id": "MDQ6VXNlcjc2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/7617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/federicomenaquintero", "html_url": "https://github.com/federicomenaquintero", "followers_url": "https://api.github.com/users/federicomenaquintero/followers", "following_url": "https://api.github.com/users/federicomenaquintero/following{/other_user}", "gists_url": "https://api.github.com/users/federicomenaquintero/gists{/gist_id}", "starred_url": "https://api.github.com/users/federicomenaquintero/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/federicomenaquintero/subscriptions", "organizations_url": "https://api.github.com/users/federicomenaquintero/orgs", "repos_url": "https://api.github.com/users/federicomenaquintero/repos", "events_url": "https://api.github.com/users/federicomenaquintero/events{/privacy}", "received_events_url": "https://api.github.com/users/federicomenaquintero/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5451b722b0d564e8e376ef89920de5d97b01eac3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5451b722b0d564e8e376ef89920de5d97b01eac3", "html_url": "https://github.com/rust-lang/rust/commit/5451b722b0d564e8e376ef89920de5d97b01eac3"}], "stats": {"total": 146, "additions": 115, "deletions": 31}, "files": [{"sha": "f0a691fd6686f07498f14a6b8e8f4a93681071f6", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 115, "deletions": 31, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/8da694a42138ac74047d989abd3c7daf0edcbe93/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da694a42138ac74047d989abd3c7daf0edcbe93/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=8da694a42138ac74047d989abd3c7daf0edcbe93", "patch": "@@ -23,19 +23,68 @@ use ptr;\n use slice;\n use str::{self, Utf8Error};\n \n-/// A type representing an owned C-compatible string.\n+/// A type representing an owned, C-compatible, UTF-8 string.\n ///\n-/// This type serves the primary purpose of being able to safely generate a\n-/// C-compatible string from a Rust byte slice or vector. An instance of this\n+/// This type serves the purpose of being able to safely generate a\n+/// C-compatible UTF-8 string from a Rust byte slice or vector. An instance of this\n /// type is a static guarantee that the underlying bytes contain no interior 0\n-/// bytes and the final byte is 0.\n+/// bytes (\"nul characters\") and that the final byte is 0 (\"nul terminator\").\n ///\n-/// A `CString` is created from either a byte slice or a byte vector. A [`u8`]\n-/// slice can be obtained with the `as_bytes` method. Slices produced from a\n-/// `CString` do *not* contain the trailing nul terminator unless otherwise\n-/// specified.\n+/// `CString` is to [`CStr`] as [`String`] is to [`&str`]: the former\n+/// in each pair are owned strings; the latter are borrowed\n+/// references.\n ///\n+/// # Creating a `CString`\n+///\n+/// A `CString` is created from either a byte slice or a byte vector,\n+/// or anything that implements [`Into`]`<`[`Vec`]`<`[`u8`]`>>` (for\n+/// example, you can build a `CString` straight out of a [`String`] or\n+/// a [`&str`], since both implement that trait).\n+///\n+/// The [`new`] method will actually check that the provided `&[u8]`\n+/// does not have 0 bytes in the middle, and return an error if it\n+/// finds one.\n+///\n+/// # Extracting a raw pointer to the whole C string\n+///\n+/// `CString` implements a [`as_ptr`] method through the [`Deref`]\n+/// trait.  This method will give you a `*const c_char` which you can\n+/// feed directly to extern functions that expect a nul-terminated\n+/// string, like C's `strdup()`.\n+///\n+/// # Extracting a slice of the whole C string\n+///\n+/// Alternatively, you can obtain a `&[`[`u8`]`]` slice from a\n+/// `CString` with the [`as_bytes`] method. Slices produced in this\n+/// way do *not* contain the trailing nul terminator. This is useful\n+/// when you will be calling an extern function that takes a `*const\n+/// u8` argument which is not necessarily nul-terminated, plus another\n+/// argument with the length of the string \u2014 like C's `strndup()`.\n+/// You can of course get the slice's length with its\n+/// [`len`][slice.len] method.\n+///\n+/// If you need a `&[`[`u8`]`]` slice *with* the nul terminator, you\n+/// can use [`as_bytes_with_nul`] instead.\n+///\n+/// Once you have the kind of slice you need (with or without a nul\n+/// terminator), you can call the slice's own\n+/// [`as_ptr`][slice.as_ptr] method to get a raw pointer to pass to\n+/// extern functions.  See the documentation for that function for a\n+/// discussion on ensuring the lifetime of the raw pointer.\n+///\n+/// [`Into`]: ../convert/trait.Into.html\n+/// [`Vec`]: ../vec/struct.Vec.html\n+/// [`String`]: ../string/struct.String.html\n+/// [`&str`]: ../primitive.str.html\n /// [`u8`]: ../primitive.u8.html\n+/// [`new`]: #method.new\n+/// [`as_bytes`]: #method.as_bytes\n+/// [`as_bytes_with_nul`]: #method.as_bytes_with_nul\n+/// [`as_ptr`]: #method.as_ptr\n+/// [slice.as_ptr]: ../primitive.slice.html#method.as_ptr\n+/// [slice.len]: ../primitive.slice.html#method.len\n+/// [`Deref`]: ../ops/trait.Deref.html\n+/// [`CStr`]: struct.CStr.html\n ///\n /// # Examples\n ///\n@@ -48,6 +97,8 @@ use str::{self, Utf8Error};\n ///     fn my_printer(s: *const c_char);\n /// }\n ///\n+/// // We are certain that our string doesn't have 0 bytes in the middle,\n+/// // so we can .unwrap()\n /// let c_to_print = CString::new(\"Hello, world!\").unwrap();\n /// unsafe {\n ///     my_printer(c_to_print.as_ptr());\n@@ -58,7 +109,7 @@ use str::{self, Utf8Error};\n /// # Safety\n ///\n /// `CString` is intended for working with traditional C-style strings\n-/// (a sequence of non-null bytes terminated by a single null byte); the\n+/// (a sequence of non-nul bytes terminated by a single nul byte); the\n /// primary use case for these kinds of strings is interoperating with C-like\n /// code. Often you will need to transfer ownership to/from that external\n /// code. It is strongly recommended that you thoroughly read through the\n@@ -215,8 +266,11 @@ pub struct IntoStringError {\n impl CString {\n     /// Creates a new C-compatible string from a container of bytes.\n     ///\n-    /// This method will consume the provided data and use the underlying bytes\n-    /// to construct a new string, ensuring that there is a trailing 0 byte.\n+    /// This method will consume the provided data and use the\n+    /// underlying bytes to construct a new string, ensuring that\n+    /// there is a trailing 0 byte.  This trailing 0 byte will be\n+    /// appended by this method; the provided data should *not*\n+    /// contain any 0 bytes in it.\n     ///\n     /// # Examples\n     ///\n@@ -234,9 +288,11 @@ impl CString {\n     ///\n     /// # Errors\n     ///\n-    /// This function will return an error if the bytes yielded contain an\n-    /// internal 0 byte. The error returned will contain the bytes as well as\n+    /// This function will return an error if the supplied bytes contain an\n+    /// internal 0 byte. The [`NulError`] returned will contain the bytes as well as\n     /// the position of the nul byte.\n+    ///\n+    /// [`NulError`]: struct.NulError.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> {\n         Self::_new(t.into())\n@@ -249,8 +305,8 @@ impl CString {\n         }\n     }\n \n-    /// Creates a C-compatible string from a byte vector without checking for\n-    /// interior 0 bytes.\n+    /// Creates a C-compatible string by consuming a byte vector,\n+    /// without checking for interior 0 bytes.\n     ///\n     /// This method is equivalent to [`new`] except that no runtime assertion\n     /// is made that `v` contains no 0 bytes, and it requires an actual\n@@ -275,7 +331,7 @@ impl CString {\n         CString { inner: v.into_boxed_slice() }\n     }\n \n-    /// Retakes ownership of a `CString` that was transferred to C.\n+    /// Retakes ownership of a `CString` that was transferred to C via [`into_raw`].\n     ///\n     /// Additionally, the length of the string will be recalculated from the pointer.\n     ///\n@@ -286,7 +342,14 @@ impl CString {\n     /// ownership of a string that was allocated by foreign code) is likely to lead\n     /// to undefined behavior or allocator corruption.\n     ///\n+    /// > **Note:** If you need to borrow a string that was allocated by\n+    /// > foreign code, use [`CStr`].  If you need to take ownership of\n+    /// > a string that was allocated by foreign code, you will need to\n+    /// > make your own provisions for freeing it appropriately, likely\n+    /// > with the foreign code's API to do that.\n+    ///\n     /// [`into_raw`]: #method.into_raw\n+    /// [`CStr`]: struct.CStr.html\n     ///\n     /// # Examples\n     ///\n@@ -315,11 +378,11 @@ impl CString {\n         CString { inner: mem::transmute(slice) }\n     }\n \n-    /// Transfers ownership of the string to a C caller.\n+    /// Consumes the `CString` and transfers ownership of the string to a C caller.\n     ///\n-    /// The pointer must be returned to Rust and reconstituted using\n+    /// The pointer which this function returns must be returned to Rust and reconstituted using\n     /// [`from_raw`] to be properly deallocated. Specifically, one\n-    /// should *not* use the standard C `free` function to deallocate\n+    /// should *not* use the standard C `free()` function to deallocate\n     /// this string.\n     ///\n     /// Failure to call [`from_raw`] will lead to a memory leak.\n@@ -356,6 +419,22 @@ impl CString {\n     /// On failure, ownership of the original `CString` is returned.\n     ///\n     /// [`String`]: ../string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::CString;\n+    ///\n+    /// let valid_utf8 = vec![b'f', b'o', b'o'];\n+    /// let cstring = CString::new(valid_utf8).unwrap();\n+    /// assert_eq!(cstring.into_string().unwrap(), \"foo\");\n+    ///\n+    /// let invalid_utf8 = vec![b'f', 0xff, b'o', b'o'];\n+    /// let cstring = CString::new(invalid_utf8).unwrap();\n+    /// let err = cstring.into_string().err().unwrap();\n+    /// assert_eq!(err.utf8_error().valid_up_to(), 1);\n+    /// ```\n+\n     #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_string(self) -> Result<String, IntoStringError> {\n         String::from_utf8(self.into_bytes())\n@@ -365,10 +444,11 @@ impl CString {\n             })\n     }\n \n-    /// Returns the underlying byte buffer.\n+    /// Consumes the `CString` and returns the underlying byte buffer.\n     ///\n-    /// The returned buffer does **not** contain the trailing nul separator and\n-    /// it is guaranteed to not have any interior nul bytes.\n+    /// The returned buffer does **not** contain the trailing nul\n+    /// terminator, and it is guaranteed to not have any interior nul\n+    /// bytes.\n     ///\n     /// # Examples\n     ///\n@@ -388,7 +468,7 @@ impl CString {\n     }\n \n     /// Equivalent to the [`into_bytes`] function except that the returned vector\n-    /// includes the trailing nul byte.\n+    /// includes the trailing nul terminator.\n     ///\n     /// [`into_bytes`]: #method.into_bytes\n     ///\n@@ -408,8 +488,12 @@ impl CString {\n \n     /// Returns the contents of this `CString` as a slice of bytes.\n     ///\n-    /// The returned slice does **not** contain the trailing nul separator and\n-    /// it is guaranteed to not have any interior nul bytes.\n+    /// The returned slice does **not** contain the trailing nul\n+    /// terminator, and it is guaranteed to not have any interior nul\n+    /// bytes.  If you need the nul terminator, use\n+    /// [`as_bytes_with_nul`] instead.\n+    ///\n+    /// [`as_bytes_with_nul`]: #method.as_bytes_with_nul\n     ///\n     /// # Examples\n     ///\n@@ -427,7 +511,7 @@ impl CString {\n     }\n \n     /// Equivalent to the [`as_bytes`] function except that the returned slice\n-    /// includes the trailing nul byte.\n+    /// includes the trailing nul terminator.\n     ///\n     /// [`as_bytes`]: #method.as_bytes\n     ///\n@@ -598,8 +682,8 @@ impl Default for Box<CStr> {\n }\n \n impl NulError {\n-    /// Returns the position of the nul byte in the slice that was provided to\n-    /// [`CString::new`].\n+    /// Returns the position of the nul byte in the slice that caused\n+    /// [`CString::new`] to fail.\n     ///\n     /// [`CString::new`]: struct.CString.html#method.new\n     ///\n@@ -766,7 +850,7 @@ impl CStr {\n     /// assert!(cstr.is_ok());\n     /// ```\n     ///\n-    /// Creating a `CStr` without a trailing nul byte is an error:\n+    /// Creating a `CStr` without a trailing nul terminator is an error:\n     ///\n     /// ```\n     /// use std::ffi::CStr;\n@@ -869,7 +953,7 @@ impl CStr {\n     /// requires a linear amount of work to be done) and then return the\n     /// resulting slice of `u8` elements.\n     ///\n-    /// The returned slice will **not** contain the trailing nul that this C\n+    /// The returned slice will **not** contain the trailing nul terminator that this C\n     /// string has.\n     ///\n     /// > **Note**: This method is currently implemented as a 0-cost cast, but\n@@ -894,7 +978,7 @@ impl CStr {\n     /// Converts this C string to a byte slice containing the trailing 0 byte.\n     ///\n     /// This function is the equivalent of [`to_bytes`] except that it will retain\n-    /// the trailing nul instead of chopping it off.\n+    /// the trailing nul terminator instead of chopping it off.\n     ///\n     /// > **Note**: This method is currently implemented as a 0-cost cast, but\n     /// > it is planned to alter its definition in the future to perform the"}]}