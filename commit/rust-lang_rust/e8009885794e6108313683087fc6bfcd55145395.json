{"sha": "e8009885794e6108313683087fc6bfcd55145395", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MDA5ODg1Nzk0ZTYxMDgzMTM2ODMwODdmYzZiZmNkNTUxNDUzOTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-02T07:04:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-02T07:04:07Z"}, "message": "Auto merge of #54043 - fintelia:raw_entry, r=alexcrichton\n\nAdd raw_entry API to HashMap\n\nThis is a continuation of #50821.", "tree": {"sha": "8f61794b44cc2d023c0cb278034269cd3a86accf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f61794b44cc2d023c0cb278034269cd3a86accf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8009885794e6108313683087fc6bfcd55145395", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8009885794e6108313683087fc6bfcd55145395", "html_url": "https://github.com/rust-lang/rust/commit/e8009885794e6108313683087fc6bfcd55145395", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8009885794e6108313683087fc6bfcd55145395/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad4c885225fc36cc3b58a9e71d1383c82c8198a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad4c885225fc36cc3b58a9e71d1383c82c8198a7", "html_url": "https://github.com/rust-lang/rust/commit/ad4c885225fc36cc3b58a9e71d1383c82c8198a7"}, {"sha": "daf5bd564a0eb8ff7784f85a015cbe4f06ac162e", "url": "https://api.github.com/repos/rust-lang/rust/commits/daf5bd564a0eb8ff7784f85a015cbe4f06ac162e", "html_url": "https://github.com/rust-lang/rust/commit/daf5bd564a0eb8ff7784f85a015cbe4f06ac162e"}], "stats": {"total": 679, "additions": 673, "deletions": 6}, "files": [{"sha": "aea4522892cba3839ae2188df0fcbd195ec8799a", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 672, "deletions": 6, "changes": 678, "blob_url": "https://github.com/rust-lang/rust/blob/e8009885794e6108313683087fc6bfcd55145395/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8009885794e6108313683087fc6bfcd55145395/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=e8009885794e6108313683087fc6bfcd55145395", "patch": "@@ -20,7 +20,7 @@ use fmt::{self, Debug};\n use hash::{Hash, Hasher, BuildHasher, SipHasher13};\n use iter::{FromIterator, FusedIterator};\n use mem::{self, replace};\n-use ops::{Deref, Index};\n+use ops::{Deref, DerefMut, Index};\n use sys;\n \n use super::table::{self, Bucket, EmptyBucket, Fallibility, FullBucket, FullBucketMut, RawTable,\n@@ -435,12 +435,13 @@ fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, is_match: F) -> InternalE\n         return InternalEntry::TableIsEmpty;\n     }\n \n-    search_hashed_nonempty(table, hash, is_match)\n+    search_hashed_nonempty(table, hash, is_match, true)\n }\n \n /// Search for a pre-hashed key when the hash map is known to be non-empty.\n #[inline]\n-fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n+fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F,\n+                                      compare_hashes: bool)\n     -> InternalEntry<K, V, M>\n     where M: Deref<Target = RawTable<K, V>>,\n           F: FnMut(&K) -> bool\n@@ -476,7 +477,7 @@ fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n         }\n \n         // If the hash doesn't match, it can't be this one..\n-        if hash == full.hash() {\n+        if !compare_hashes || hash == full.hash() {\n             // If the key doesn't match, it can't be this one..\n             if is_match(full.read().0) {\n                 return InternalEntry::Occupied { elem: full };\n@@ -488,6 +489,57 @@ fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n     }\n }\n \n+/// Same as `search_hashed_nonempty` but for mutable access.\n+#[inline]\n+fn search_hashed_nonempty_mut<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F,\n+                                          compare_hashes: bool)\n+    -> InternalEntry<K, V, M>\n+    where M: DerefMut<Target = RawTable<K, V>>,\n+          F: FnMut(&K) -> bool\n+{\n+    // Do not check the capacity as an extra branch could slow the lookup.\n+\n+    let size = table.size();\n+    let mut probe = Bucket::new(table, hash);\n+    let mut displacement = 0;\n+\n+    loop {\n+        let mut full = match probe.peek() {\n+            Empty(bucket) => {\n+                // Found a hole!\n+                return InternalEntry::Vacant {\n+                    hash,\n+                    elem: NoElem(bucket, displacement),\n+                };\n+            }\n+            Full(bucket) => bucket,\n+        };\n+\n+        let probe_displacement = full.displacement();\n+\n+        if probe_displacement < displacement {\n+            // Found a luckier bucket than me.\n+            // We can finish the search early if we hit any bucket\n+            // with a lower distance to initial bucket than we've probed.\n+            return InternalEntry::Vacant {\n+                hash,\n+                elem: NeqElem(full, probe_displacement),\n+            };\n+        }\n+\n+        // If the hash doesn't match, it can't be this one..\n+        if hash == full.hash() || !compare_hashes {\n+            // If the key doesn't match, it can't be this one..\n+            if is_match(full.read_mut().0) {\n+                return InternalEntry::Occupied { elem: full };\n+            }\n+        }\n+        displacement += 1;\n+        probe = full.next();\n+        debug_assert!(displacement <= size);\n+    }\n+}\n+\n fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>)\n     -> (K, V, &mut RawTable<K, V>)\n {\n@@ -593,7 +645,7 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n \n         let hash = self.make_hash(q);\n-        search_hashed_nonempty(&self.table, hash, |k| q.eq(k.borrow()))\n+        search_hashed_nonempty(&self.table, hash, |k| q.eq(k.borrow()), true)\n             .into_occupied_bucket()\n     }\n \n@@ -608,7 +660,7 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n \n         let hash = self.make_hash(q);\n-        search_hashed_nonempty(&mut self.table, hash, |k| q.eq(k.borrow()))\n+        search_hashed_nonempty(&mut self.table, hash, |k| q.eq(k.borrow()), true)\n             .into_occupied_bucket()\n     }\n \n@@ -1484,6 +1536,68 @@ impl<K, V, S> HashMap<K, V, S>\n     }\n }\n \n+impl<K, V, S> HashMap<K, V, S>\n+    where K: Eq + Hash,\n+          S: BuildHasher\n+{\n+    /// Creates a raw entry builder for the HashMap.\n+    ///\n+    /// Raw entries provide the lowest level of control for searching and\n+    /// manipulating a map. They must be manually initialized with a hash and\n+    /// then manually searched. After this, insertions into a vacant entry\n+    /// still require an owned key to be provided.\n+    ///\n+    /// Raw entries are useful for such exotic situations as:\n+    ///\n+    /// * Hash memoization\n+    /// * Deferring the creation of an owned key until it is known to be required\n+    /// * Using a search key that doesn't work with the Borrow trait\n+    /// * Using custom comparison logic without newtype wrappers\n+    ///\n+    /// Because raw entries provide much more low-level control, it's much easier\n+    /// to put the HashMap into an inconsistent state which, while memory-safe,\n+    /// will cause the map to produce seemingly random results. Higher-level and\n+    /// more foolproof APIs like `entry` should be preferred when possible.\n+    ///\n+    /// In particular, the hash used to initialized the raw entry must still be\n+    /// consistent with the hash of the key that is ultimately stored in the entry.\n+    /// This is because implementations of HashMap may need to recompute hashes\n+    /// when resizing, at which point only the keys are available.\n+    ///\n+    /// Raw entries give mutable access to the keys. This must not be used\n+    /// to modify how the key would compare or hash, as the map will not re-evaluate\n+    /// where the key should go, meaning the keys may become \"lost\" if their\n+    /// location does not reflect their state. For instance, if you change a key\n+    /// so that the map now contains keys which compare equal, search may start\n+    /// acting eratically, with two keys randomly masking eachother. Implementations\n+    /// are free to assume this doesn't happen (within the limits of memory-safety).\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn raw_entry_mut(&mut self) -> RawEntryBuilderMut<K, V, S> {\n+        self.reserve(1);\n+        RawEntryBuilderMut { map: self }\n+    }\n+\n+    /// Creates a raw immutable entry builder for the HashMap.\n+    ///\n+    /// Raw entries provide the lowest level of control for searching and\n+    /// manipulating a map. They must be manually initialized with a hash and\n+    /// then manually searched.\n+    ///\n+    /// This is useful for\n+    /// * Hash memoization\n+    /// * Using a search key that doesn't work with the Borrow trait\n+    /// * Using custom comparison logic without newtype wrappers\n+    ///\n+    /// Unless you are in such a situation, higher-level and more foolproof APIs like\n+    /// `get` should be preferred.\n+    ///\n+    /// Immutable raw entries have very limited use; you might instead want `raw_entry_mut`.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn raw_entry(&self) -> RawEntryBuilder<K, V, S> {\n+        RawEntryBuilder { map: self }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> PartialEq for HashMap<K, V, S>\n     where K: Eq + Hash,\n@@ -1724,6 +1838,456 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n     }\n }\n \n+/// A builder for computing where in a HashMap a key-value pair would be stored.\n+///\n+/// See the [`HashMap::raw_entry_mut`] docs for usage examples.\n+///\n+/// [`HashMap::raw_entry_mut`]: struct.HashMap.html#method.raw_entry_mut\n+\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+pub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n+    map: &'a mut HashMap<K, V, S>,\n+}\n+\n+/// A view into a single entry in a map, which may either be vacant or occupied.\n+///\n+/// This is a lower-level version of [`Entry`].\n+///\n+/// This `enum` is constructed from the [`raw_entry`] method on [`HashMap`].\n+///\n+/// [`HashMap`]: struct.HashMap.html\n+/// [`Entry`]: enum.Entry.html\n+/// [`raw_entry`]: struct.HashMap.html#method.raw_entry\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+pub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n+    /// An occupied entry.\n+    Occupied(RawOccupiedEntryMut<'a, K, V>),\n+    /// A vacant entry.\n+    Vacant(RawVacantEntryMut<'a, K, V, S>),\n+}\n+\n+/// A view into an occupied entry in a `HashMap`.\n+/// It is part of the [`RawEntryMut`] enum.\n+///\n+/// [`RawEntryMut`]: enum.RawEntryMut.html\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+pub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a> {\n+    elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n+}\n+\n+/// A view into a vacant entry in a `HashMap`.\n+/// It is part of the [`RawEntryMut`] enum.\n+///\n+/// [`RawEntryMut`]: enum.RawEntryMut.html\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+pub struct RawVacantEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n+    elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n+    hash_builder: &'a S,\n+}\n+\n+/// A builder for computing where in a HashMap a key-value pair would be stored.\n+///\n+/// See the [`HashMap::raw_entry`] docs for usage examples.\n+///\n+/// [`HashMap::raw_entry`]: struct.HashMap.html#method.raw_entry\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+pub struct RawEntryBuilder<'a, K: 'a, V: 'a, S: 'a> {\n+    map: &'a HashMap<K, V, S>,\n+}\n+\n+impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n+    where S: BuildHasher,\n+          K: Eq + Hash,\n+{\n+    /// Create a `RawEntryMut` from the given key.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn from_key<Q: ?Sized>(self, k: &Q) -> RawEntryMut<'a, K, V, S>\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n+    {\n+        let mut hasher = self.map.hash_builder.build_hasher();\n+        k.hash(&mut hasher);\n+        self.from_key_hashed_nocheck(hasher.finish(), k)\n+    }\n+\n+    /// Create a `RawEntryMut` from the given key and its hash.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> RawEntryMut<'a, K, V, S>\n+        where K: Borrow<Q>,\n+              Q: Eq\n+    {\n+        self.from_hash(hash, |q| q.borrow().eq(k))\n+    }\n+\n+    fn search<F>(self, hash: u64, is_match: F, compare_hashes: bool)  -> RawEntryMut<'a, K, V, S>\n+        where for<'b> F: FnMut(&'b K) -> bool,\n+    {\n+        match search_hashed_nonempty_mut(&mut self.map.table,\n+                                         SafeHash::new(hash),\n+                                         is_match,\n+                                         compare_hashes) {\n+            InternalEntry::Occupied { elem } => {\n+                RawEntryMut::Occupied(RawOccupiedEntryMut { elem })\n+            }\n+            InternalEntry::Vacant { elem, .. } => {\n+                RawEntryMut::Vacant(RawVacantEntryMut {\n+                    elem,\n+                    hash_builder: &self.map.hash_builder,\n+                })\n+            }\n+            InternalEntry::TableIsEmpty => {\n+                unreachable!()\n+            }\n+        }\n+    }\n+    /// Create a `RawEntryMut` from the given hash.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn from_hash<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>\n+        where for<'b> F: FnMut(&'b K) -> bool,\n+    {\n+        self.search(hash, is_match, true)\n+    }\n+\n+    /// Search possible locations for an element with hash `hash` until `is_match` returns true for\n+    /// one of them. There is no guarantee that all keys passed to `is_match` will have the provided\n+    /// hash.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn search_bucket<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>\n+        where for<'b> F: FnMut(&'b K) -> bool,\n+    {\n+        self.search(hash, is_match, false)\n+    }\n+}\n+\n+impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\n+    where S: BuildHasher,\n+{\n+    /// Access an entry by key.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn from_key<Q: ?Sized>(self, k: &Q) -> Option<(&'a K, &'a V)>\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n+    {\n+        let mut hasher = self.map.hash_builder.build_hasher();\n+        k.hash(&mut hasher);\n+        self.from_key_hashed_nocheck(hasher.finish(), k)\n+    }\n+\n+    /// Access an entry by a key and its hash.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> Option<(&'a K, &'a V)>\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n+\n+    {\n+        self.from_hash(hash, |q| q.borrow().eq(k))\n+    }\n+\n+    fn search<F>(self, hash: u64, is_match: F, compare_hashes: bool) -> Option<(&'a K, &'a V)>\n+        where F: FnMut(&K) -> bool\n+    {\n+        match search_hashed_nonempty(&self.map.table,\n+                                     SafeHash::new(hash),\n+                                     is_match,\n+                                     compare_hashes) {\n+            InternalEntry::Occupied { elem } => Some(elem.into_refs()),\n+            InternalEntry::Vacant { .. } => None,\n+            InternalEntry::TableIsEmpty => unreachable!(),\n+        }\n+    }\n+\n+    /// Access an entry by hash.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn from_hash<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>\n+        where F: FnMut(&K) -> bool\n+    {\n+        self.search(hash, is_match, true)\n+    }\n+\n+    /// Search possible locations for an element with hash `hash` until `is_match` returns true for\n+    /// one of them. There is no guarantee that all keys passed to `is_match` will have the provided\n+    /// hash.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn search_bucket<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>\n+        where F: FnMut(&K) -> bool\n+    {\n+        self.search(hash, is_match, false)\n+    }\n+}\n+\n+impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n+    /// Ensures a value is in the entry by inserting the default if empty, and returns\n+    /// mutable references to the key and value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(hash_raw_entry)]\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.raw_entry_mut().from_key(\"poneyland\").or_insert(\"poneyland\", 12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    ///\n+    /// *map.raw_entry_mut().from_key(\"poneyland\").or_insert(\"poneyland\", 12).1 += 10;\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn or_insert(self, default_key: K, default_val: V) -> (&'a mut K, &'a mut V)\n+        where K: Hash,\n+              S: BuildHasher,\n+    {\n+        match self {\n+            RawEntryMut::Occupied(entry) => entry.into_key_value(),\n+            RawEntryMut::Vacant(entry) => entry.insert(default_key, default_val),\n+        }\n+    }\n+\n+    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n+    /// and returns mutable references to the key and value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(hash_raw_entry)]\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, String> = HashMap::new();\n+    ///\n+    /// map.raw_entry_mut().from_key(\"poneyland\").or_insert_with(|| {\n+    ///     (\"poneyland\", \"hoho\".to_string())\n+    /// });\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n+    /// ```\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn or_insert_with<F>(self, default: F) -> (&'a mut K, &'a mut V)\n+        where F: FnOnce() -> (K, V),\n+              K: Hash,\n+              S: BuildHasher,\n+    {\n+        match self {\n+            RawEntryMut::Occupied(entry) => entry.into_key_value(),\n+            RawEntryMut::Vacant(entry) => {\n+                let (k, v) = default();\n+                entry.insert(k, v)\n+            }\n+        }\n+    }\n+\n+    /// Provides in-place mutable access to an occupied entry before any\n+    /// potential inserts into the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(hash_raw_entry)]\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    ///\n+    /// map.raw_entry_mut()\n+    ///    .from_key(\"poneyland\")\n+    ///    .and_modify(|_k, v| { *v += 1 })\n+    ///    .or_insert(\"poneyland\", 42);\n+    /// assert_eq!(map[\"poneyland\"], 42);\n+    ///\n+    /// map.raw_entry_mut()\n+    ///    .from_key(\"poneyland\")\n+    ///    .and_modify(|_k, v| { *v += 1 })\n+    ///    .or_insert(\"poneyland\", 0);\n+    /// assert_eq!(map[\"poneyland\"], 43);\n+    /// ```\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn and_modify<F>(self, f: F) -> Self\n+        where F: FnOnce(&mut K, &mut V)\n+    {\n+        match self {\n+            RawEntryMut::Occupied(mut entry) => {\n+                {\n+                    let (k, v) = entry.get_key_value_mut();\n+                    f(k, v);\n+                }\n+                RawEntryMut::Occupied(entry)\n+            },\n+            RawEntryMut::Vacant(entry) => RawEntryMut::Vacant(entry),\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> RawOccupiedEntryMut<'a, K, V> {\n+    /// Gets a reference to the key in the entry.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn key(&self) -> &K {\n+        self.elem.read().0\n+    }\n+\n+    /// Gets a mutable reference to the key in the entry.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn key_mut(&mut self) -> &mut K {\n+        self.elem.read_mut().0\n+    }\n+\n+    /// Converts the entry into a mutable reference to the key in the entry\n+    /// with a lifetime bound to the map itself.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn into_key(self) -> &'a mut K {\n+        self.elem.into_mut_refs().0\n+    }\n+\n+    /// Gets a reference to the value in the entry.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn get(&self) -> &V {\n+        self.elem.read().1\n+    }\n+\n+    /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n+    /// with a lifetime bound to the map itself.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn into_mut(self) -> &'a mut V {\n+        self.elem.into_mut_refs().1\n+    }\n+\n+    /// Gets a mutable reference to the value in the entry.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn get_mut(&mut self) -> &mut V {\n+        self.elem.read_mut().1\n+    }\n+\n+    /// Gets a reference to the key and value in the entry.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn get_key_value(&mut self) -> (&K, &V) {\n+        self.elem.read()\n+    }\n+\n+    /// Gets a mutable reference to the key and value in the entry.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn get_key_value_mut(&mut self) -> (&mut K, &mut V) {\n+        self.elem.read_mut()\n+    }\n+\n+    /// Converts the OccupiedEntry into a mutable reference to the key and value in the entry\n+    /// with a lifetime bound to the map itself.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn into_key_value(self) -> (&'a mut K, &'a mut V) {\n+        self.elem.into_mut_refs()\n+    }\n+\n+    /// Sets the value of the entry, and returns the entry's old value.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn insert(&mut self, value: V) -> V {\n+        mem::replace(self.get_mut(), value)\n+    }\n+\n+    /// Sets the value of the entry, and returns the entry's old value.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn insert_key(&mut self, key: K) -> K {\n+        mem::replace(self.key_mut(), key)\n+    }\n+\n+    /// Takes the value out of the entry, and returns it.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn remove(self) -> V {\n+        pop_internal(self.elem).1\n+    }\n+\n+    /// Take the ownership of the key and value from the map.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn remove_entry(self) -> (K, V) {\n+        let (k, v, _) = pop_internal(self.elem);\n+        (k, v)\n+    }\n+}\n+\n+impl<'a, K, V, S> RawVacantEntryMut<'a, K, V, S> {\n+    /// Sets the value of the entry with the VacantEntry's key,\n+    /// and returns a mutable reference to it.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn insert(self, key: K, value: V) -> (&'a mut K, &'a mut V)\n+        where K: Hash,\n+              S: BuildHasher,\n+    {\n+        let mut hasher = self.hash_builder.build_hasher();\n+        key.hash(&mut hasher);\n+        self.insert_hashed_nocheck(hasher.finish(), key, value)\n+    }\n+\n+    /// Sets the value of the entry with the VacantEntry's key,\n+    /// and returns a mutable reference to it.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&'a mut K, &'a mut V) {\n+        let hash = SafeHash::new(hash);\n+        let b = match self.elem {\n+            NeqElem(mut bucket, disp) => {\n+                if disp >= DISPLACEMENT_THRESHOLD {\n+                    bucket.table_mut().set_tag(true);\n+                }\n+                robin_hood(bucket, disp, hash, key, value)\n+            },\n+            NoElem(mut bucket, disp) => {\n+                if disp >= DISPLACEMENT_THRESHOLD {\n+                    bucket.table_mut().set_tag(true);\n+                }\n+                bucket.put(hash, key, value)\n+            },\n+        };\n+        b.into_mut_refs()\n+    }\n+}\n+\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+impl<'a, K, V, S> Debug for RawEntryBuilderMut<'a, K, V, S> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RawEntryBuilder\")\n+         .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+impl<'a, K: Debug, V: Debug, S> Debug for RawEntryMut<'a, K, V, S> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            RawEntryMut::Vacant(ref v) => {\n+                f.debug_tuple(\"RawEntry\")\n+                    .field(v)\n+                    .finish()\n+            }\n+            RawEntryMut::Occupied(ref o) => {\n+                f.debug_tuple(\"RawEntry\")\n+                    .field(o)\n+                    .finish()\n+            }\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+impl<'a, K: Debug, V: Debug> Debug for RawOccupiedEntryMut<'a, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RawOccupiedEntryMut\")\n+         .field(\"key\", self.key())\n+         .field(\"value\", self.get())\n+         .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+impl<'a, K, V, S> Debug for RawVacantEntryMut<'a, K, V, S> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RawVacantEntryMut\")\n+         .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+impl<'a, K, V, S> Debug for RawEntryBuilder<'a, K, V, S> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RawEntryBuilder\")\n+         .finish()\n+    }\n+}\n+\n /// A view into a single entry in a map, which may either be vacant or occupied.\n ///\n /// This `enum` is constructed from the [`entry`] method on [`HashMap`].\n@@ -3681,4 +4245,106 @@ mod test_map {\n         }\n     }\n \n+    #[test]\n+    fn test_raw_entry() {\n+        use super::RawEntryMut::{Occupied, Vacant};\n+\n+        let xs = [(1i32, 10i32), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n+\n+        let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n+\n+        let compute_hash = |map: &HashMap<i32, i32>, k: i32| -> u64 {\n+            use core::hash::{BuildHasher, Hash, Hasher};\n+\n+            let mut hasher = map.hasher().build_hasher();\n+            k.hash(&mut hasher);\n+            hasher.finish()\n+        };\n+\n+        // Existing key (insert)\n+        match map.raw_entry_mut().from_key(&1) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(mut view) => {\n+                assert_eq!(view.get(), &10);\n+                assert_eq!(view.insert(100), 10);\n+            }\n+        }\n+        let hash1 = compute_hash(&map, 1);\n+        assert_eq!(map.raw_entry().from_key(&1).unwrap(), (&1, &100));\n+        assert_eq!(map.raw_entry().from_hash(hash1, |k| *k == 1).unwrap(), (&1, &100));\n+        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash1, &1).unwrap(), (&1, &100));\n+        assert_eq!(map.raw_entry().search_bucket(hash1, |k| *k == 1).unwrap(), (&1, &100));\n+        assert_eq!(map.len(), 6);\n+\n+        // Existing key (update)\n+        match map.raw_entry_mut().from_key(&2) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(mut view) => {\n+                let v = view.get_mut();\n+                let new_v = (*v) * 10;\n+                *v = new_v;\n+            }\n+        }\n+        let hash2 = compute_hash(&map, 2);\n+        assert_eq!(map.raw_entry().from_key(&2).unwrap(), (&2, &200));\n+        assert_eq!(map.raw_entry().from_hash(hash2, |k| *k == 2).unwrap(), (&2, &200));\n+        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash2, &2).unwrap(), (&2, &200));\n+        assert_eq!(map.raw_entry().search_bucket(hash2, |k| *k == 2).unwrap(), (&2, &200));\n+        assert_eq!(map.len(), 6);\n+\n+        // Existing key (take)\n+        let hash3 = compute_hash(&map, 3);\n+        match map.raw_entry_mut().from_key_hashed_nocheck(hash3, &3) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(view) => {\n+                assert_eq!(view.remove_entry(), (3, 30));\n+            }\n+        }\n+        assert_eq!(map.raw_entry().from_key(&3), None);\n+        assert_eq!(map.raw_entry().from_hash(hash3, |k| *k == 3), None);\n+        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash3, &3), None);\n+        assert_eq!(map.raw_entry().search_bucket(hash3, |k| *k == 3), None);\n+        assert_eq!(map.len(), 5);\n+\n+\n+        // Nonexistent key (insert)\n+        match map.raw_entry_mut().from_key(&10) {\n+            Occupied(_) => unreachable!(),\n+            Vacant(view) => {\n+                assert_eq!(view.insert(10, 1000), (&mut 10, &mut 1000));\n+            }\n+        }\n+        assert_eq!(map.raw_entry().from_key(&10).unwrap(), (&10, &1000));\n+        assert_eq!(map.len(), 6);\n+\n+        // Ensure all lookup methods produce equivalent results.\n+        for k in 0..12 {\n+            let hash = compute_hash(&map, k);\n+            let v = map.get(&k).cloned();\n+            let kv = v.as_ref().map(|v| (&k, v));\n+\n+            assert_eq!(map.raw_entry().from_key(&k), kv);\n+            assert_eq!(map.raw_entry().from_hash(hash, |q| *q == k), kv);\n+            assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &k), kv);\n+            assert_eq!(map.raw_entry().search_bucket(hash, |q| *q == k), kv);\n+\n+            match map.raw_entry_mut().from_key(&k) {\n+                Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n+                Vacant(_) => assert_eq!(v, None),\n+            }\n+            match map.raw_entry_mut().from_key_hashed_nocheck(hash, &k) {\n+                Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n+                Vacant(_) => assert_eq!(v, None),\n+            }\n+            match map.raw_entry_mut().from_hash(hash, |q| *q == k) {\n+                Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n+                Vacant(_) => assert_eq!(v, None),\n+            }\n+            match map.raw_entry_mut().search_bucket(hash, |q| *q == k) {\n+                Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n+                Vacant(_) => assert_eq!(v, None),\n+            }\n+        }\n+    }\n+\n }"}, {"sha": "ab3e97d1d9241fd52186a8963bf3261f1970a185", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8009885794e6108313683087fc6bfcd55145395/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8009885794e6108313683087fc6bfcd55145395/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=e8009885794e6108313683087fc6bfcd55145395", "patch": "@@ -283,6 +283,7 @@\n #![feature(prelude_import)]\n #![feature(ptr_internals)]\n #![feature(raw)]\n+#![feature(hash_raw_entry)]\n #![feature(rustc_attrs)]\n #![feature(rustc_const_unstable)]\n #![feature(std_internals)]"}]}