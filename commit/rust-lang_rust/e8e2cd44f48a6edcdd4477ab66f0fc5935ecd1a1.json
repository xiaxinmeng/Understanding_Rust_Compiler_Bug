{"sha": "e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZTJjZDQ0ZjQ4YTZlZGNkZDQ0NzdhYjY2ZjBmYzU5MzVlY2QxYTE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-01T11:26:17Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-01T11:46:46Z"}, "message": "Add syntax highlighting to the code snippets in the tutorial\n\nUsing the CodeMirror Rust mode.", "tree": {"sha": "26c4cf692d124b6bbefc10b9a17b3e9e06044855", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26c4cf692d124b6bbefc10b9a17b3e9e06044855"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1", "html_url": "https://github.com/rust-lang/rust/commit/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b57cb90e50b600824c967470483462aeb663e50", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b57cb90e50b600824c967470483462aeb663e50", "html_url": "https://github.com/rust-lang/rust/commit/8b57cb90e50b600824c967470483462aeb663e50"}], "stats": {"total": 647, "additions": 631, "deletions": 16}, "files": [{"sha": "308954b0be95c04a3ee10fdfb5fccb98d62bd336", "filename": "doc/tutorial/build.js", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/doc%2Ftutorial%2Fbuild.js", "raw_url": "https://github.com/rust-lang/rust/raw/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/doc%2Ftutorial%2Fbuild.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fbuild.js?ref=e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1", "patch": "@@ -1,4 +1,22 @@\n var fs = require(\"fs\"), md = require(\"./lib/markdown\");\n+CodeMirror = require(\"./lib/codemirror-node\");\n+require(\"./lib/codemirror-rust\");\n+\n+md.Markdown.dialects.Maruku.block.code = function code(block, next) {\n+  if (block.match(/^    /)) {\n+    var text = block.replace(/(^|\\n)    /g, \"$1\"), accum = [], curstr = \"\", curstyle = null;\n+    function add(str, style) {\n+      if (style != curstyle) {\n+        if (curstyle) accum.push([\"span\", {\"class\": \"cm-\" + curstyle}, curstr]);\n+        else if (curstr) accum.push(curstr);\n+        curstr = str; curstyle = style;\n+      } else curstr += str;\n+    }\n+    CodeMirror.runMode(text, \"rust\", add);\n+    add(\"\", \"bogus\"); // Flush pending string.\n+    return [[\"pre\", {\"class\": \"cm-s-default\"}].concat(accum)];\n+  }\n+};    \n \n function markdown(str) { return md.toHTML(str, \"Maruku\"); }\n \n@@ -19,6 +37,7 @@ function fileDates(file, c) {\n \n function head(title) {\n   return \"<html><head><link rel='stylesheet' href='style.css' type='text/css'>\" +\n+    \"<link rel='stylesheet' href='default.css' type='text/css'>\" +\n     \"<meta http-equiv='Content-Type' content='text/html; charset=utf-8'><title>\" +\n     title + \"</title></head><body>\\n\";\n }"}, {"sha": "638db23cb0806419f73c1fefbef1d854c285f017", "filename": "doc/tutorial/data.md", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/doc%2Ftutorial%2Fdata.md", "raw_url": "https://github.com/rust-lang/rust/raw/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/doc%2Ftutorial%2Fdata.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fdata.md?ref=e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1", "patch": "@@ -13,11 +13,11 @@ types).\n \n ## Records\n \n-Rust record types are written `{field1: TYPE, field2: TYPE [,\n-...]}`, and record literals are written in the same way, but with\n-expressions instead of types. They are quite similar to C structs, and\n-even laid out the same way in memory (so you can read from a Rust\n-struct in C, and vice-versa).\n+Rust record types are written `{field1: TYPE, field2: TYPE [, ...]}`,\n+and record literals are written in the same way, but with expressions\n+instead of types. They are quite similar to C structs, and even laid\n+out the same way in memory (so you can read from a Rust struct in C,\n+and vice-versa).\n \n The dot operator is used to access record fields (`mypoint.x`).\n \n@@ -100,6 +100,8 @@ equivalent to an `enum` in C:\n This will define `north`, `east`, `south`, and `west` as constants,\n all of which have type `direction`.\n \n+<a name=\"single_variant_tag\"></a>\n+\n There is a special case for tags with a single variant. These are used\n to define new types in such a way that the new name is not just a\n synonym for an existing type, but its own distinct type. If you say:"}, {"sha": "fac4c076d480c868217da4d351dd9f9d83e0f508", "filename": "doc/tutorial/lib/codemirror-node.js", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/doc%2Ftutorial%2Flib%2Fcodemirror-node.js", "raw_url": "https://github.com/rust-lang/rust/raw/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/doc%2Ftutorial%2Flib%2Fcodemirror-node.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Flib%2Fcodemirror-node.js?ref=e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1", "patch": "@@ -0,0 +1,124 @@\n+exports.htmlEscape = function(text) {\n+  var replacements = {\"<\": \"&lt;\", \">\": \"&gt;\",\n+                      \"&\": \"&amp;\", \"\\\"\": \"&quot;\"};\n+  return text.replace(/[<>&\"]/g, function(character) {\n+    return replacements[character];\n+  });\n+};\n+\n+exports.splitLines = function(string){return string.split(/\\r?\\n/);};\n+\n+// Counts the column offset in a string, taking tabs into account.\n+// Used mostly to find indentation.\n+function countColumn(string, end) {\n+  if (end == null) {\n+    end = string.search(/[^\\s\\u00a0]/);\n+    if (end == -1) end = string.length;\n+  }\n+  for (var i = 0, n = 0; i < end; ++i) {\n+    if (string.charAt(i) == \"\\t\") n += tabSize - (n % tabSize);\n+    else ++n;\n+  }\n+  return n;\n+}\n+\n+function StringStream(string) {\n+  this.pos = this.start = 0;\n+  this.string = string;\n+}\n+StringStream.prototype = {\n+  eol: function() {return this.pos >= this.string.length;},\n+  sol: function() {return this.pos == 0;},\n+  peek: function() {return this.string.charAt(this.pos);},\n+  next: function() {\n+    if (this.pos < this.string.length)\n+      return this.string.charAt(this.pos++);\n+  },\n+  eat: function(match) {\n+    var ch = this.string.charAt(this.pos);\n+    if (typeof match == \"string\") var ok = ch == match;\n+    else var ok = ch && (match.test ? match.test(ch) : match(ch));\n+    if (ok) {++this.pos; return ch;}\n+  },\n+  eatWhile: function(match) {\n+    var start = this.pos;\n+    while (this.eat(match)){}\n+    return this.pos > start;\n+  },\n+  eatSpace: function() {\n+    var start = this.pos;\n+    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n+    return this.pos > start;\n+  },\n+  skipToEnd: function() {this.pos = this.string.length;},\n+  skipTo: function(ch) {\n+    var found = this.string.indexOf(ch, this.pos);\n+    if (found > -1) {this.pos = found; return true;}\n+  },\n+  backUp: function(n) {this.pos -= n;},\n+  column: function() {return countColumn(this.string, this.start);},\n+  indentation: function() {return countColumn(this.string);},\n+  match: function(pattern, consume, caseInsensitive) {\n+    if (typeof pattern == \"string\") {\n+      function cased(str) {return caseInsensitive ? str.toLowerCase() : str;}\n+      if (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {\n+        if (consume !== false) this.pos += pattern.length;\n+        return true;\n+      }\n+    }\n+    else {\n+      var match = this.string.slice(this.pos).match(pattern);\n+      if (match && consume !== false) this.pos += match[0].length;\n+      return match;\n+    }\n+  },\n+  current: function(){return this.string.slice(this.start, this.pos);}\n+};\n+exports.StringStream = StringStream;\n+\n+exports.startState = function(mode, a1, a2) {\n+  return mode.startState ? mode.startState(a1, a2) : true;\n+};\n+\n+var modes = {}, mimeModes = {};\n+exports.defineMode = function(name, mode) { modes[name] = mode; };\n+exports.defineMIME = function(mime, spec) { mimeModes[mime] = spec; };\n+exports.getMode = function(options, spec) {\n+  if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec))\n+    spec = mimeModes[spec];\n+  if (typeof spec == \"string\")\n+    var mname = spec, config = {};\n+  else if (spec != null)\n+    var mname = spec.name, config = spec;\n+  var mfactory = modes[mname];\n+  if (!mfactory) throw new Error(\"Unknown mode: \" + spec);\n+  return mfactory(options, config || {});\n+};\n+\n+exports.runMode = function(string, modespec, callback) {\n+  var mode = exports.getMode({indentUnit: 2}, modespec);\n+  var isNode = callback.nodeType == 1;\n+  if (isNode) {\n+    var node = callback, accum = [];\n+    callback = function(string, style) {\n+      if (string == \"\\n\")\n+        accum.push(\"<br>\");\n+      else if (style)\n+        accum.push(\"<span class=\\\"cm-\" + exports.htmlEscape(style) + \"\\\">\" + exports.htmlEscape(string) + \"</span>\");\n+      else\n+        accum.push(exports.htmlEscape(string));\n+    }\n+  }\n+  var lines = exports.splitLines(string), state = exports.startState(mode);\n+  for (var i = 0, e = lines.length; i < e; ++i) {\n+    if (i) callback(\"\\n\");\n+    var stream = new exports.StringStream(lines[i]);\n+    while (!stream.eol()) {\n+      var style = mode.token(stream, state);\n+      callback(stream.current(), style, i, stream.start);\n+      stream.start = stream.pos;\n+    }\n+  }\n+  if (isNode)\n+    node.innerHTML = accum.join(\"\");\n+};"}, {"sha": "8a251c9a61611d8f68d6c9c6e1bdcb83a0598260", "filename": "doc/tutorial/lib/codemirror-rust.js", "status": "added", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/doc%2Ftutorial%2Flib%2Fcodemirror-rust.js", "raw_url": "https://github.com/rust-lang/rust/raw/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/doc%2Ftutorial%2Flib%2Fcodemirror-rust.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Flib%2Fcodemirror-rust.js?ref=e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1", "patch": "@@ -0,0 +1,405 @@\n+CodeMirror.defineMode(\"rust\", function() {\n+  var indentUnit = 4, altIndentUnit = 2;\n+  var valKeywords = {\n+    \"if\": \"if-style\", \"while\": \"if-style\", \"else\": \"else-style\",\n+    \"do\": \"else-style\", \"ret\": \"else-style\", \"fail\": \"else-style\",\n+    \"break\": \"atom\", \"cont\": \"atom\", \"const\": \"let\", \"resource\": \"fn\",\n+    \"let\": \"let\", \"fn\": \"fn\", \"for\": \"for\", \"alt\": \"alt\", \"obj\": \"fn\",\n+    \"lambda\": \"fn\", \"type\": \"type\", \"tag\": \"tag\", \"mod\": \"mod\",\n+    \"as\": \"op\", \"true\": \"atom\", \"false\": \"atom\", \"assert\": \"op\", \"check\": \"op\",\n+    \"claim\": \"op\", \"native\": \"ignore\", \"unsafe\": \"ignore\", \"import\": \"else-style\",\n+    \"export\": \"else-style\", \"copy\": \"op\", \"log\": \"op\", \"log_err\": \"op\", \"use\": \"op\"\n+  };\n+  var typeKeywords = function() {\n+    var keywords = {\"fn\": \"fn\", \"block\": \"fn\", \"obj\": \"obj\"};\n+    var atoms = \"bool uint int i8 i16 i32 i64 u8 u16 u32 u64 float f32 f64 str char\".split(\" \");\n+    for (var i = 0, e = atoms.length; i < e; ++i) keywords[atoms[i]] = \"atom\";\n+    return keywords;\n+  }();\n+  var operatorChar = /[+\\-*&%=<>!?|\\.@]/;\n+\n+  // Tokenizer\n+\n+  // Used as scratch variable to communicate multiple values without\n+  // consing up tons of objects.\n+  var tcat, content;\n+  function r(tc, style) {\n+    tcat = tc;\n+    return style;\n+  }\n+\n+  function tokenBase(stream, state) {\n+    var ch = stream.next();\n+    if (ch == '\"') {\n+      state.tokenize = tokenString;\n+      return state.tokenize(stream, state);\n+    }\n+    if (ch == \"'\") {\n+      tcat = \"atom\";\n+      if (stream.eat(\"\\\\\")) {\n+        if (stream.skipTo(\"'\")) { stream.next(); return \"string\"; }\n+        else { return \"error\"; }\n+      } else {\n+        stream.next();\n+        return stream.eat(\"'\") ? \"string\" : \"error\";\n+      }\n+    }\n+    if (ch == \"/\") {\n+      if (stream.eat(\"/\")) { stream.skipToEnd(); return \"comment\"; }\n+      if (stream.eat(\"*\")) {\n+        state.tokenize = tokenComment(1);\n+        return state.tokenize(stream, state);\n+      }\n+    }\n+    if (ch == \"#\") {\n+      if (stream.eat(\"[\")) { tcat = \"open-attr\"; return null; }\n+      stream.eatWhile(/\\w/);\n+      return r(\"macro\", \"meta\");\n+    }\n+    if (ch == \":\" && stream.match(\":<\")) {\n+      return r(\"op\", null);\n+    }\n+    if (ch.match(/\\d/) || (ch == \".\" && stream.eat(/\\d/))) {\n+      var flp = false;\n+      if (!stream.match(/^x[\\da-f]+/i) && !stream.match(/^b[01]+/)) {\n+        stream.eatWhile(/\\d/);\n+        if (stream.eat(\".\")) { flp = true; stream.eatWhile(/\\d/); }\n+        if (stream.match(/^e[+\\-]?\\d+/i)) { flp = true; }\n+      }\n+      if (flp) stream.match(/^f(?:32|64)/);\n+      else stream.match(/^[ui](?:8|16|32|64)/);\n+      return r(\"atom\", \"number\");\n+    }\n+    if (ch.match(/[()\\[\\]{}:;,]/)) return r(ch, null);\n+    if (ch == \"-\" && stream.eat(\">\")) return r(\"->\", null);\n+    if (ch.match(operatorChar)) {\n+      stream.eatWhile(operatorChar);\n+      return r(\"op\", null);\n+    }\n+    stream.eatWhile(/\\w/);\n+    content = stream.current();\n+    if (stream.match(/^::\\w/)) {\n+      stream.backUp(1);\n+      return r(\"prefix\", \"variable-2\");\n+    }\n+    if (state.keywords.propertyIsEnumerable(content))\n+      return r(state.keywords[content], content.match(/true|false/) ? \"atom\" : \"keyword\");\n+    return r(\"name\", \"variable\");\n+  }\n+\n+  function tokenString(stream, state) {\n+    var ch, escaped = false;\n+    while (ch = stream.next()) {\n+      if (ch == '\"' && !escaped) {\n+        state.tokenize = tokenBase;\n+        return r(\"atom\", \"string\");\n+      }\n+      escaped = !escaped && ch == \"\\\\\";\n+    }\n+    // Hack to not confuse the parser when a string is split in\n+    // pieces.\n+    return r(\"op\", \"string\");\n+  }\n+\n+  function tokenComment(depth) {\n+    return function(stream, state) {\n+      var lastCh = null, ch;\n+      while (ch = stream.next()) {\n+        if (ch == \"/\" && lastCh == \"*\") {\n+          if (depth == 1) {\n+            state.tokenize = tokenBase;\n+            break;\n+          } else {\n+            state.tokenize = tokenComment(depth - 1);\n+            return state.tokenize(stream, state);\n+          }\n+        }\n+        if (ch == \"*\" && lastCh == \"/\") {\n+          state.tokenize = tokenComment(depth + 1);\n+          return state.tokenize(stream, state);\n+        }\n+        lastCh = ch;\n+      }\n+      return \"comment\";\n+    };\n+  }\n+\n+  // Parser\n+\n+  var cx = {state: null, stream: null, marked: null, cc: null};\n+  function pass() {\n+    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n+  }\n+  function cont() {\n+    pass.apply(null, arguments);\n+    return true;\n+  }\n+\n+  function pushlex(type, info) {\n+    var result = function() {\n+      var state = cx.state;\n+      state.lexical = {indented: state.indented, column: cx.stream.column(),\n+                       type: type, prev: state.lexical, info: info};\n+    };\n+    result.lex = true;\n+    return result;\n+  }\n+  function poplex() {\n+    var state = cx.state;\n+    if (state.lexical.prev) {\n+      if (state.lexical.type == \")\")\n+        state.indented = state.lexical.indented;\n+      state.lexical = state.lexical.prev;\n+    }\n+  }\n+  function typecx() { cx.state.keywords = typeKeywords; }\n+  function valcx() { cx.state.keywords = valKeywords; }\n+  poplex.lex = typecx.lex = valcx.lex = true;\n+\n+  function commasep(comb, end) {\n+    function more(type) {\n+      if (type == \",\") return cont(comb, more);\n+      if (type == end) return cont();\n+      return cont(more);\n+    }\n+    return function(type) {\n+      if (type == end) return cont();\n+      return pass(comb, more);\n+    };\n+  }\n+\n+  function block(type) {\n+    if (type == \"}\") return cont();\n+    if (type == \"let\") return cont(pushlex(\"stat\", \"let\"), letdef1, poplex, block);\n+    if (type == \"fn\") return cont(pushlex(\"stat\"), fndef, poplex, block);\n+    if (type == \"type\") return cont(pushlex(\"stat\"), tydef, endstatement, poplex, block);\n+    if (type == \"tag\") return cont(pushlex(\"stat\"), tagdef, poplex, block);\n+    if (type == \"mod\") return cont(pushlex(\"stat\"), mod, poplex, block);\n+    if (type == \"open-attr\") return cont(pushlex(\"]\"), commasep(expression, \"]\"), poplex);\n+    if (type == \"ignore\" || type.match(/[\\]\\);,]/)) return cont(block);\n+    return pass(pushlex(\"stat\"), expression, poplex, endstatement, block);\n+  }\n+  function endstatement(type) {\n+    if (type == \";\") return cont();\n+    return pass();\n+  }\n+  function expression(type) {\n+    if (type == \"atom\" || type == \"name\") return cont(maybeop);\n+    if (type == \"{\") return cont(pushlex(\"}\"), exprbrace, poplex);\n+    if (type.match(/[\\[\\(]/)) return matchBrackets(type, expression);\n+    if (type.match(/[\\]\\)\\};,]/)) return pass();\n+    if (type == \"if-style\") return cont(expression, expression);\n+    if (type == \"else-style\" || type == \"op\") return cont(expression);\n+    if (type == \"for\") return cont(pattern, maybetype, inop, expression, expression);\n+    if (type == \"alt\") return cont(expression, altbody);\n+    if (type == \"fn\") return cont(fndef);\n+    if (type == \"macro\") return cont(macro);\n+    return cont();\n+  }\n+  function maybeop(type) {\n+    if (content == \".\") return cont(maybeprop);\n+    if (content == \"::<\"){return cont(typarams, maybeop);}\n+    if (type == \"op\" || content == \":\") return cont(expression);\n+    if (type == \"(\" || type == \"[\") return matchBrackets(type, expression);\n+    return pass();\n+  }\n+  function maybeprop(type) {\n+    if (content.match(/^\\w+$/)) {cx.marked = \"variable\"; return cont(maybeop);}\n+    return pass(expression);\n+  }\n+  function exprbrace(type) {\n+    if (type == \"op\") {\n+      if (content == \"|\") return cont(blockvars, poplex, pushlex(\"}\", \"block\"), block);\n+      if (content == \"||\") return cont(poplex, pushlex(\"}\", \"block\"), block);\n+    }\n+    if (content == \"mutable\" || (content.match(/^\\w+$/) && cx.stream.peek() == \":\"\n+                                 && !cx.stream.match(\"::\", false))) return pass(recliteral);\n+    return pass(block);\n+  }\n+  function recliteral(type) {\n+    if (content == \"mutable\" || content == \"with\") {cx.marked = \"keyword\"; return cont(recliteral);}\n+    if (content.match(/^\\w*$/)) {cx.marked = \"variable\"; return cont(recliteral);}\n+    if (type == \":\") return cont(expression, recliteral);\n+    if (type == \"}\") return cont();\n+    return cont(recliteral);\n+  }\n+  function blockvars(type) {\n+    if (type == \"name\") {cx.marked = \"def\"; return cont(blockvars);}\n+    if (type == \"op\" && content == \"|\") return cont();\n+    return cont(blockvars);\n+  }\n+\n+  function letdef1(type) {\n+    if (type == \";\") return cont();\n+    if (content == \"=\") return cont(expression, letdef2);\n+    if (type == \",\") return cont(letdef1);\n+    return pass(pattern, maybetype, letdef1);\n+  }\n+  function letdef2(type) {\n+    if (type.match(/[\\]\\)\\};,]/)) return pass(letdef1);\n+    else return pass(expression, letdef2);\n+  }\n+  function maybetype(type) {\n+    if (type == \":\") return cont(typecx, rtype, valcx);\n+    return pass();\n+  }\n+  function inop(type) {\n+    if (type == \"name\" && content == \"in\") {cx.marked = \"keyword\"; return cont();}\n+    return pass();\n+  }\n+  function fndef(type) {\n+    if (type == \"name\") {cx.marked = \"def\"; return cont(fndef);}\n+    if (content == \"<\") return cont(typarams, fndef);\n+    if (type == \"{\") return pass(expression);\n+    if (type == \"(\") return cont(pushlex(\")\"), commasep(argdef, \")\"), poplex, fndef);\n+    if (type == \"->\") return cont(typecx, rtype, valcx, fndef);\n+    return cont(fndef);\n+  }\n+  function tydef(type) {\n+    if (type == \"name\") {cx.marked = \"def\"; return cont(tydef);}\n+    if (content == \"<\") return cont(typarams, tydef);\n+    if (content == \"=\") return cont(typecx, rtype, valcx);\n+    return cont(tydef);\n+  }\n+  function tagdef(type) {\n+    if (type == \"name\") {cx.marked = \"def\"; return cont(tagdef);}\n+    if (content == \"<\") return cont(typarams, tagdef);\n+    if (content == \"=\") return cont(typecx, rtype, valcx, endstatement);\n+    if (type == \"{\") return cont(pushlex(\"}\"), typecx, tagblock, valcx, poplex);\n+    return cont(tagdef);\n+  }\n+  function tagblock(type) {\n+    if (type == \"}\") return cont();\n+    if (type == \"(\") return cont(pushlex(\")\"), commasep(rtype, \")\"), poplex, tagblock);\n+    if (content.match(/^\\w+$/)) cx.marked = \"def\";\n+    return cont(tagblock);\n+  }\n+  function mod(type) {\n+    if (type == \"name\") {cx.marked = \"def\"; return cont(mod);}\n+    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n+    return pass();\n+  }\n+  function typarams(type) {\n+    if (content == \">\") return cont();\n+    if (content == \",\") return cont(typarams);\n+    return pass(rtype, typarams);\n+  }\n+  function argdef(type) {\n+    if (type == \"name\") {cx.marked = \"def\"; return cont(argdef);}\n+    if (type == \":\") return cont(typecx, rtype, valcx);\n+    return pass();\n+  }\n+  function rtype(type) {\n+    if (type == \"name\") {cx.marked = \"variable-3\"; return cont(rtypemaybeparam); }\n+    if (content == \"mutable\") {cx.marked = \"keyword\"; return cont(rtype);}\n+    if (type == \"atom\") return cont(rtypemaybeparam);\n+    if (type == \"op\" || type == \"obj\") return cont(rtype);\n+    if (type == \"fn\") return cont(fntype);\n+    return matchBrackets(type, rtype);\n+  }\n+  function rtypemaybeparam(type) {\n+    if (content == \"<\") return cont(typarams);\n+    return pass();\n+  }\n+  function fntype(type) {\n+    if (type == \"(\") return cont(pushlex(\"(\"), commasep(rtype, \")\"), poplex, fntype);\n+    if (type == \"->\") return cont(rtype);\n+    return pass();\n+  }\n+  function pattern(type) {\n+    if (type == \"name\") {cx.marked = \"def\"; return cont(patternmaybeop);}\n+    if (type == \"atom\") return cont(patternmaybeop);\n+    if (type == \"op\") return cont(pattern);\n+    if (type.match(/[\\]\\)\\};,]/)) return pass();\n+    return matchBrackets(type, pattern);\n+  }\n+  function patternmaybeop(type) {\n+    if (type == \"op\" && content == \".\") return cont();\n+    if (content == \"to\") {cx.marked = \"keyword\"; return cont(pattern);}\n+    else return pass();\n+  }\n+  function altbody(type) {\n+    if (type == \"{\") return cont(pushlex(\"}\", \"alt\"), altblock1, poplex);\n+    return pass();\n+  }\n+  function altblock1(type) {\n+    if (type == \"}\") return cont();\n+    if (type == \"|\") return cont(altblock1);\n+    if (content == \"when\") {cx.marked = \"keyword\"; return cont(expression, altblock2);}\n+    if (type.match(/[\\]\\);,]/)) return cont(altblock1);\n+    return pass(pattern, altblock2);\n+  }\n+  function altblock2(type) {\n+    if (type == \"{\") return cont(pushlex(\"}\", \"alt\"), block, poplex, altblock1);\n+    else return pass(altblock1);\n+  }\n+\n+  function macro(type) {\n+    if (type.match(/[\\[\\(\\{]/)) return matchBrackets(type, expression);\n+    return pass();\n+  }\n+  function matchBrackets(type, comb) {\n+    if (type == \"[\") return cont(pushlex(\"]\"), commasep(comb, \"]\"), poplex);\n+    if (type == \"(\") return cont(pushlex(\")\"), commasep(comb, \")\"), poplex);\n+    if (type == \"{\") return cont(pushlex(\"}\"), commasep(comb, \"}\"), poplex);\n+    return cont();\n+  }\n+\n+  function parse(state, stream, style) {\n+    var cc = state.cc;\n+    // Communicate our context to the combinators.\n+    // (Less wasteful than consing up a hundred closures on every call.)\n+    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n+\n+    while (true) {\n+      var combinator = cc.length ? cc.pop() : block;\n+      if (combinator(tcat)) {\n+        while(cc.length && cc[cc.length - 1].lex)\n+          cc.pop()();\n+        return cx.marked || style;\n+      }\n+    }\n+  }\n+\n+  return {\n+    startState: function() {\n+      return {\n+        tokenize: tokenBase,\n+        cc: [],\n+        lexical: {indented: -indentUnit, column: 0, type: \"top\", align: false},\n+        keywords: valKeywords,\n+        indented: 0\n+      };\n+    },\n+\n+    token: function(stream, state) {\n+      if (stream.sol()) {\n+        if (!state.lexical.hasOwnProperty(\"align\"))\n+          state.lexical.align = false;\n+        state.indented = stream.indentation();\n+      }\n+      if (stream.eatSpace()) return null;\n+      tcat = content = null;\n+      var style = state.tokenize(stream, state);\n+      if (style == \"comment\") return style;\n+      if (!state.lexical.hasOwnProperty(\"align\"))\n+        state.lexical.align = true;\n+      if (tcat == \"prefix\") return style;\n+      if (!content) content = stream.current();\n+      return parse(state, stream, style);\n+    },\n+\n+    indent: function(state, textAfter) {\n+      if (state.tokenize != tokenBase) return 0;\n+      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical,\n+          type = lexical.type, closing = firstChar == type;\n+      if (type == \"stat\") return lexical.indented + indentUnit;\n+      if (lexical.align) return lexical.column + (closing ? 0 : 1);\n+      return lexical.indented + (closing ? 0 : (lexical.info == \"alt\" ? altIndentUnit : indentUnit));\n+    },\n+\n+    electricChars: \"{}\"\n+  };\n+});\n+\n+CodeMirror.defineMIME(\"text/x-rustsrc\", \"rust\");"}, {"sha": "4d3bfaeb77f23145490619f765bf2ce9c03c051d", "filename": "doc/tutorial/lib/markdown.js", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/doc%2Ftutorial%2Flib%2Fmarkdown.js", "raw_url": "https://github.com/rust-lang/rust/raw/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/doc%2Ftutorial%2Flib%2Fmarkdown.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Flib%2Fmarkdown.js?ref=e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1", "patch": "@@ -252,8 +252,6 @@ Markdown.prototype.toTree = function toTree( source, custom_root ) {\n Markdown.prototype.debug = function () {\n   var args = Array.prototype.slice.call( arguments);\n   args.unshift(this.debug_indent);\n-  if (typeof print !== \"undefined\")\n-      print.apply( print, args );\n   if (typeof console !== \"undefined\" && typeof console.log !== \"undefined\")\n       console.log.apply( null, args );\n }\n@@ -1125,6 +1123,10 @@ Markdown.dialects.Maruku.block.definition_list = function definition_list( block\n   return [ list ];\n }\n \n+Markdown.dialects.Maruku.block.html_paragraph = function html_paragraph( block, next ) {\n+  if (block.match(/^<\\w/)) return [[\"RAW\", block.toString()]];\n+}\n+\n Markdown.dialects.Maruku.inline[ \"{:\" ] = function inline_meta( text, matches, out ) {\n   if ( !out.length ) {\n     return [ 2, \"{:\" ];\n@@ -1297,6 +1299,7 @@ function render_tree( jsonml ) {\n   var tag = jsonml.shift(),\n       attributes = {},\n       content = [];\n+  if (tag == \"RAW\") return jsonml[0];\n \n   if ( jsonml.length && typeof jsonml[ 0 ] === \"object\" && !( jsonml[ 0 ] instanceof Array ) ) {\n     attributes = jsonml.shift();"}, {"sha": "a40c9822152a6efdfdfcb46def0fc8f257ff483c", "filename": "doc/tutorial/syntax.md", "status": "modified", "additions": 50, "deletions": 6, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/doc%2Ftutorial%2Fsyntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/doc%2Ftutorial%2Fsyntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fsyntax.md?ref=e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1", "patch": "@@ -1,7 +1,5 @@\n # Syntax Basics\n \n-FIXME: mention the module separator `::` somewhere\n-\n ## Braces\n \n Assuming you've programmed in any C-family language (C++, Java,\n@@ -75,6 +73,19 @@ only have a trailing expression when you want to use their value for\n something\u2014in which case you'll have embedded it in a bigger statement,\n like the `let x = ...` example above.\n \n+## Identifiers\n+\n+Rust identifiers must start with an alphabetic character or an\n+underscore, and after that may contain any alphanumeric character, and\n+more underscores.\n+\n+NOTE: The parser doesn't currently recognize non-ascii alphabetic\n+characters. This is a bug that will eventually be fixed.\n+\n+The double-colon (`::`) is used as a module separator, so\n+`std::io::println` means 'the thing named `println` in the module\n+named `io` in the module named `std`'.\n+\n ## Types\n \n The `-> bool` in the last example is the way a function's return type\n@@ -158,10 +169,10 @@ Types can be given names with `type` declarations:\n This will provide a synonym, `monster_size`, for unsigned integers. It\n will not actually create a new type\u2014`monster_size` and `uint` can be\n used interchangeably, and using one where the other is expected is not\n-a type error. Read about [single-variant tags][svt] in the next\n-section if you need to create a type name that's not just a synonym.\n+a type error. Read about [single-variant tags][svt] further on if you\n+need to create a type name that's not just a synonym.\n \n-[svt]: FIXME\n+[svt]: data.html#single_variant_tag\n \n ## Literals\n \n@@ -211,4 +222,37 @@ following it, will not appear in the resulting string literal.\n \n ## Operators\n \n-FIXME recap C-style operators, ?:, explain `as`\n+Rust's set of operators contains very few surprises. The main\n+difference with C is that `++` and `--` are missing, and that the\n+logical binary operators have higher precedence\u2014in C, `x & 2 > 0`\n+comes out as `x & (2 > 0)`, in Rust, it means `(x & 2) > 0`, which is\n+more likely to be what you expect (unless you are a C veteran).\n+\n+Thus, binary arithmetic is done with `*`, `/`, `%`, `+`, and `-`\n+(multiply, divide, remainder, plus, minus). `-` is also a unary prefix\n+operator (there are no unary postfix operators in Rust) that does\n+negation.\n+\n+Binary shifting is done with `>>` (shift right), `>>>` (arithmetic\n+shift right), and `<<` (shift left). Logical bitwise operators are\n+`&`, `|`, and `^` (and, or, and exclusive or), and unary `!` for\n+bitwise negation (or boolean negation when applied to a boolean\n+value).\n+\n+The comparison operators are the traditional `==`, `!=`, `<`, `>`,\n+`<=`, and `>=`. Short-circuiting (lazy) boolean operators are written\n+`&&` (and) and `||` (or).\n+\n+Rust has a ternary conditional operator `?:`, as in:\n+\n+    let message = badness < 10 ? \"error\" : \"FATAL ERROR\";\n+\n+For type casting, Rust uses the binary `as` operator, which has a\n+precedence between the bitwise combination operators (`&`, `|`, `^`)\n+and the comparison operators. It takes an expression on the left side,\n+and a type on the right side, and will, if a meaningful conversion\n+exists, convert the result of the expression to the given type.\n+\n+    let x: float = 4.0;\n+    let y: uint = x as uint;\n+    assert y == 4u;"}, {"sha": "e68f0fb378c2c942f3cbfe30915a52378624d587", "filename": "doc/tutorial/web/default.css", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/doc%2Ftutorial%2Fweb%2Fdefault.css", "raw_url": "https://github.com/rust-lang/rust/raw/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/doc%2Ftutorial%2Fweb%2Fdefault.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fweb%2Fdefault.css?ref=e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1", "patch": "@@ -0,0 +1,19 @@\n+.cm-s-default span.cm-keyword {color: #708;}\n+.cm-s-default span.cm-atom {color: #219;}\n+.cm-s-default span.cm-number {color: #164;}\n+.cm-s-default span.cm-def {color: #00f;}\n+.cm-s-default span.cm-variable {color: black;}\n+.cm-s-default span.cm-variable-2 {color: #05a;}\n+.cm-s-default span.cm-variable-3 {color: #0a5;}\n+.cm-s-default span.cm-property {color: black;}\n+.cm-s-default span.cm-operator {color: black;}\n+.cm-s-default span.cm-comment {color: #a50;}\n+.cm-s-default span.cm-string {color: #a11;}\n+.cm-s-default span.cm-string-2 {color: #f50;}\n+.cm-s-default span.cm-meta {color: #555;}\n+.cm-s-default span.cm-error {color: #f00;}\n+.cm-s-default span.cm-qualifier {color: #555;}\n+.cm-s-default span.cm-builtin {color: #30a;}\n+.cm-s-default span.cm-bracket {color: #cc7;}\n+.cm-s-default span.cm-tag {color: #170;}\n+.cm-s-default span.cm-attribute {color: #00c;}"}, {"sha": "c3d8fa43441789ef0b352c7e7bd1b197957a6aa9", "filename": "doc/tutorial/web/style.css", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/doc%2Ftutorial%2Fweb%2Fstyle.css", "raw_url": "https://github.com/rust-lang/rust/raw/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1/doc%2Ftutorial%2Fweb%2Fstyle.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fweb%2Fstyle.css?ref=e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1", "patch": "@@ -18,9 +18,8 @@ code {\n }\n \n pre {\n-  margin: 1.1em 12px;\n-  border: 1px solid #CCCCCC;\n-  padding: .4em;\n+  margin: 1.1em 0;\n+  padding: .4em .4em .4em 1em;\n   font-size: 120%;\n }\n "}]}