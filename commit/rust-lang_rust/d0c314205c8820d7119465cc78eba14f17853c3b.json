{"sha": "d0c314205c8820d7119465cc78eba14f17853c3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwYzMxNDIwNWM4ODIwZDcxMTk0NjVjYzc4ZWJhMTRmMTc4NTNjM2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-24T03:10:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-24T03:10:59Z"}, "message": "auto merge of #16698 : bluss/rust/slice-bloat, r=huonw\n\nThese are somewhat stop-gap solutions to address #16625 \r\n\r\ncore: Separate failure formatting in str methods slice, slice_to, slice_from\r\n\r\nUse a separate inline-never function to format failure message for\r\nstr::slice() errors.\r\n\r\nUsing strcat's idea, this makes sure no formatting code from failure is\r\ninlined when str::slice() is inlined. The number of `unreachable` being\r\ninlined when usingi `.slice()` drops from 5 to just 1.\r\n\r\n\r\n\r\nThe testcase:\r\n\r\n```\r\n#![crate_type = \"lib\"]\r\npub fn slice(x: &str, a: uint, b: uint) -> &str {\r\n    x.slice(a, b)\r\n}\r\n```\r\n\r\nshrinks from 16.9 kB to 3.3 kB llvm IR, and the number of `unreachable` drops from 5 to 1.", "tree": {"sha": "e4d8d98edd1e1477802ffe27ca49147ddf56102f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4d8d98edd1e1477802ffe27ca49147ddf56102f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0c314205c8820d7119465cc78eba14f17853c3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0c314205c8820d7119465cc78eba14f17853c3b", "html_url": "https://github.com/rust-lang/rust/commit/d0c314205c8820d7119465cc78eba14f17853c3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0c314205c8820d7119465cc78eba14f17853c3b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "904d88c2be3e99177745fc45870304e78d610e8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/904d88c2be3e99177745fc45870304e78d610e8c", "html_url": "https://github.com/rust-lang/rust/commit/904d88c2be3e99177745fc45870304e78d610e8c"}, {"sha": "b3b7c2e97b8e34ebc2597c21653df4b2d7a37575", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3b7c2e97b8e34ebc2597c21653df4b2d7a37575", "html_url": "https://github.com/rust-lang/rust/commit/b3b7c2e97b8e34ebc2597c21653df4b2d7a37575"}], "stats": {"total": 42, "additions": 31, "deletions": 11}, "files": [{"sha": "b9d9c060a41f4ebcc307e7b3c5e4b5575c6f3c49", "filename": "src/libcore/str.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d0c314205c8820d7119465cc78eba14f17853c3b/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0c314205c8820d7119465cc78eba14f17853c3b/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=d0c314205c8820d7119465cc78eba14f17853c3b", "patch": "@@ -1717,6 +1717,13 @@ pub trait StrSlice<'a> {\n     fn utf16_units(&self) -> Utf16CodeUnits<'a>;\n }\n \n+#[inline(never)]\n+fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! {\n+    assert!(begin <= end);\n+    fail!(\"index {} and/or {} in `{}` do not lie on character boundary\",\n+          begin, end, s);\n+}\n+\n impl<'a> StrSlice<'a> for &'a str {\n     #[inline]\n     fn contains<'a>(&self, needle: &'a str) -> bool {\n@@ -1820,22 +1827,34 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn slice(&self, begin: uint, end: uint) -> &'a str {\n-        assert!(self.is_char_boundary(begin) && self.is_char_boundary(end),\n-                \"index {} and/or {} in `{}` do not lie on character boundary\", begin,\n-                end, *self);\n-        unsafe { raw::slice_bytes(*self, begin, end) }\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if begin <= end &&\n+           self.is_char_boundary(begin) &&\n+           self.is_char_boundary(end) {\n+            unsafe { raw::slice_unchecked(*self, begin, end) }\n+        } else {\n+            slice_error_fail(*self, begin, end)\n+        }\n     }\n \n     #[inline]\n     fn slice_from(&self, begin: uint) -> &'a str {\n-        self.slice(begin, self.len())\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if self.is_char_boundary(begin) {\n+            unsafe { raw::slice_unchecked(*self, begin, self.len()) }\n+        } else {\n+            slice_error_fail(*self, begin, self.len())\n+        }\n     }\n \n     #[inline]\n     fn slice_to(&self, end: uint) -> &'a str {\n-        assert!(self.is_char_boundary(end), \"index {} in `{}` does not lie on \\\n-                a character boundary\", end, *self);\n-        unsafe { raw::slice_bytes(*self, 0, end) }\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if self.is_char_boundary(end) {\n+            unsafe { raw::slice_unchecked(*self, 0, end) }\n+        } else {\n+            slice_error_fail(*self, 0, end)\n+        }\n     }\n \n     fn slice_chars(&self, begin: uint, end: uint) -> &'a str {\n@@ -1910,9 +1929,10 @@ impl<'a> StrSlice<'a> for &'a str {\n     #[inline]\n     fn is_char_boundary(&self, index: uint) -> bool {\n         if index == self.len() { return true; }\n-        if index > self.len() { return false; }\n-        let b = self.as_bytes()[index];\n-        return b < 128u8 || b >= 192u8;\n+        match self.as_bytes().get(index) {\n+            None => false,\n+            Some(&b) => b < 128u8 || b >= 192u8,\n+        }\n     }\n \n     #[inline]"}]}