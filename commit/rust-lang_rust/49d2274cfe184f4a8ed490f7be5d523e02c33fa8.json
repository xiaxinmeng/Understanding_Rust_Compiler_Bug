{"sha": "49d2274cfe184f4a8ed490f7be5d523e02c33fa8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ZDIyNzRjZmUxODRmNGE4ZWQ0OTBmN2JlNWQ1MjNlMDJjMzNmYTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-20T21:43:09Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-04T14:14:35Z"}, "message": "constraint_generation: create liveness constraints more thoroughly\n\nWe now visit just the stuff in the CFG, and we add liveness\nconstraints for all the random types, regions etc that appear within\nrvalues and statements.", "tree": {"sha": "6bc1e29b4e277dcb9d61ee2bb20f9abe9fa1d7bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bc1e29b4e277dcb9d61ee2bb20f9abe9fa1d7bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49d2274cfe184f4a8ed490f7be5d523e02c33fa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49d2274cfe184f4a8ed490f7be5d523e02c33fa8", "html_url": "https://github.com/rust-lang/rust/commit/49d2274cfe184f4a8ed490f7be5d523e02c33fa8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49d2274cfe184f4a8ed490f7be5d523e02c33fa8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4de73368627067a0b35b09ea7319cef2b0358248", "url": "https://api.github.com/repos/rust-lang/rust/commits/4de73368627067a0b35b09ea7319cef2b0358248", "html_url": "https://github.com/rust-lang/rust/commit/4de73368627067a0b35b09ea7319cef2b0358248"}], "stats": {"total": 265, "additions": 155, "deletions": 110}, "files": [{"sha": "42225536357dae585d6252aa7a962ae2740692c7", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 151, "deletions": 102, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/49d2274cfe184f4a8ed490f7be5d523e02c33fa8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d2274cfe184f4a8ed490f7be5d523e02c33fa8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=49d2274cfe184f4a8ed490f7be5d523e02c33fa8", "patch": "@@ -9,20 +9,22 @@\n // except according to those terms.\n \n use rustc::hir;\n-use rustc::mir::{Local, Location, Place, Mir, Rvalue};\n+use rustc::mir::{BasicBlock, BasicBlockData, Location, Place, Mir, Rvalue};\n use rustc::mir::visit::Visitor;\n use rustc::mir::Place::Projection;\n-use rustc::mir::{PlaceProjection, ProjectionElem};\n+use rustc::mir::{Local, PlaceProjection, ProjectionElem};\n+use rustc::mir::visit::TyContext;\n use rustc::infer::InferCtxt;\n use rustc::traits::{self, ObligationCause};\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, ClosureSubsts, Ty};\n+use rustc::ty::subst::Substs;\n use rustc::ty::fold::TypeFoldable;\n use rustc::util::common::ErrorReported;\n use rustc_data_structures::fx::FxHashSet;\n use syntax::codemap::DUMMY_SP;\n use borrow_check::FlowInProgress;\n use dataflow::MaybeInitializedLvals;\n-use dataflow::move_paths::{MoveData, HasMoveData};\n+use dataflow::move_paths::{HasMoveData, MoveData};\n \n use super::LivenessResults;\n use super::ToRegionVid;\n@@ -37,15 +39,19 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     flow_inits: &mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) {\n-    ConstraintGeneration {\n+    let mut cg = ConstraintGeneration {\n         infcx,\n         regioncx,\n         mir,\n         liveness,\n         param_env,\n         flow_inits,\n         move_data,\n-    }.add_constraints();\n+    };\n+\n+    for (bb, data) in mir.basic_blocks().iter_enumerated() {\n+        cg.visit_basic_block_data(bb, data);\n+    }\n }\n \n /// 'cg = the duration of the constraint generation process itself.\n@@ -59,75 +65,147 @@ struct ConstraintGeneration<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n     move_data: &'cg MoveData<'tcx>,\n }\n \n-impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n-    fn add_constraints(&mut self) {\n-        self.add_liveness_constraints();\n-        self.add_borrow_constraints();\n+\n+impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx, 'tcx> {\n+    fn visit_basic_block_data(&mut self, bb: BasicBlock, data: &BasicBlockData<'tcx>) {\n+        self.add_liveness_constraints(bb);\n+        self.super_basic_block_data(bb, data);\n+    }\n+\n+    /// We sometimes have `substs` within an rvalue, or within a\n+    /// call. Make them live at the location where they appear.\n+    fn visit_substs(&mut self, substs: &&'tcx Substs<'tcx>, location: Location) {\n+        self.add_regular_live_constraint(*substs, location);\n+        self.super_substs(substs);\n+    }\n+\n+    /// We sometimes have `region` within an rvalue, or within a\n+    /// call. Make them live at the location where they appear.\n+    fn visit_region(&mut self, region: &ty::Region<'tcx>, location: Location) {\n+        self.add_regular_live_constraint(*region, location);\n+        self.super_region(region);\n     }\n \n+    /// We sometimes have `ty` within an rvalue, or within a\n+    /// call. Make them live at the location where they appear.\n+    fn visit_ty(&mut self, ty: &ty::Ty<'tcx>, ty_context: TyContext) {\n+        match ty_context {\n+            TyContext::ReturnTy(source_info) |\n+            TyContext::LocalDecl { source_info, .. } => {\n+                span_bug!(source_info.span,\n+                          \"should not be visiting outside of the CFG: {:?}\",\n+                          ty_context);\n+            }\n+            TyContext::Location(location) => {\n+                self.add_regular_live_constraint(*ty, location);\n+            }\n+        }\n+\n+        self.super_ty(ty);\n+    }\n+\n+    /// We sometimes have `closure_substs` within an rvalue, or within a\n+    /// call. Make them live at the location where they appear.\n+    fn visit_closure_substs(&mut self, substs: &ClosureSubsts<'tcx>, location: Location) {\n+        self.add_regular_live_constraint(*substs, location);\n+        self.super_closure_substs(substs);\n+    }\n+\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        debug!(\"visit_rvalue(rvalue={:?}, location={:?})\", rvalue, location);\n+\n+        // Look for an rvalue like:\n+        //\n+        //     & L\n+        //\n+        // where L is the path that is borrowed. In that case, we have\n+        // to add the reborrow constraints (which don't fall out\n+        // naturally from the type-checker).\n+        if let Rvalue::Ref(region, _bk, ref borrowed_lv) = *rvalue {\n+            self.add_reborrow_constraint(location, region, borrowed_lv);\n+        }\n+\n+        self.super_rvalue(rvalue, location);\n+    }\n+}\n+\n+impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n     /// Liveness constraints:\n     ///\n     /// > If a variable V is live at point P, then all regions R in the type of V\n     /// > must include the point P.\n-    fn add_liveness_constraints(&mut self) {\n-        debug!(\"add_liveness_constraints()\");\n-        for bb in self.mir.basic_blocks().indices() {\n-            debug!(\"add_liveness_constraints: bb={:?}\", bb);\n-\n-            self.liveness\n-                .regular\n-                .simulate_block(self.mir, bb, |location, live_locals| {\n-                    for live_local in live_locals.iter() {\n-                        let live_local_ty = self.mir.local_decls[live_local].ty;\n-                        self.add_regular_live_constraint(live_local_ty, location);\n-                    }\n-                });\n+    fn add_liveness_constraints(&mut self, bb: BasicBlock) {\n+        debug!(\"add_liveness_constraints(bb={:?})\", bb);\n \n-            let mut all_live_locals: Vec<(Location, Vec<Local>)> = vec![];\n-            self.liveness.drop.simulate_block(self.mir, bb, |location, live_locals| {\n+        self.liveness\n+            .regular\n+            .simulate_block(self.mir, bb, |location, live_locals| {\n+                for live_local in live_locals.iter() {\n+                    let live_local_ty = self.mir.local_decls[live_local].ty;\n+                    self.add_regular_live_constraint(live_local_ty, location);\n+                }\n+            });\n+\n+        let mut all_live_locals: Vec<(Location, Vec<Local>)> = vec![];\n+        self.liveness\n+            .drop\n+            .simulate_block(self.mir, bb, |location, live_locals| {\n                 all_live_locals.push((location, live_locals.iter().collect()));\n             });\n-            debug!(\"add_liveness_constraints: all_live_locals={:#?}\", all_live_locals);\n-\n-            let terminator_index = self.mir.basic_blocks()[bb].statements.len();\n-            self.flow_inits.reset_to_entry_of(bb);\n-            while let Some((location, live_locals)) = all_live_locals.pop() {\n-                for live_local in live_locals {\n-                    debug!(\"add_liveness_constraints: location={:?} live_local={:?}\", location,\n-                           live_local);\n-\n-                    self.flow_inits.each_state_bit(|mpi_init| {\n-                        debug!(\"add_liveness_constraints: location={:?} initialized={:?}\",\n-                               location,\n-                               &self.flow_inits\n-                                   .base_results\n-                                   .operator()\n-                                   .move_data()\n-                                   .move_paths[mpi_init]);\n-                    });\n-\n-                    let mpi = self.move_data.rev_lookup.find_local(live_local);\n-                    if let Some(initialized_child) = self.flow_inits.has_any_child_of(mpi) {\n-                        debug!(\"add_liveness_constraints: mpi={:?} has initialized child {:?}\",\n-                               self.move_data.move_paths[mpi],\n-                               self.move_data.move_paths[initialized_child]);\n-\n-                        let live_local_ty = self.mir.local_decls[live_local].ty;\n-                        self.add_drop_live_constraint(live_local_ty, location);\n-                    }\n-                }\n+        debug!(\n+            \"add_liveness_constraints: all_live_locals={:#?}\",\n+            all_live_locals\n+        );\n \n-                if location.statement_index == terminator_index {\n-                    debug!(\"add_liveness_constraints: reconstruct_terminator_effect from {:#?}\",\n-                           location);\n-                    self.flow_inits.reconstruct_terminator_effect(location);\n-                } else {\n-                    debug!(\"add_liveness_constraints: reconstruct_statement_effect from {:#?}\",\n-                           location);\n-                    self.flow_inits.reconstruct_statement_effect(location);\n+        let terminator_index = self.mir.basic_blocks()[bb].statements.len();\n+        self.flow_inits.reset_to_entry_of(bb);\n+        while let Some((location, live_locals)) = all_live_locals.pop() {\n+            for live_local in live_locals {\n+                debug!(\n+                    \"add_liveness_constraints: location={:?} live_local={:?}\",\n+                    location,\n+                    live_local\n+                );\n+\n+                self.flow_inits.each_state_bit(|mpi_init| {\n+                    debug!(\n+                        \"add_liveness_constraints: location={:?} initialized={:?}\",\n+                        location,\n+                        &self.flow_inits\n+                            .base_results\n+                            .operator()\n+                            .move_data()\n+                            .move_paths[mpi_init]\n+                    );\n+                });\n+\n+                let mpi = self.move_data.rev_lookup.find_local(live_local);\n+                if let Some(initialized_child) = self.flow_inits.has_any_child_of(mpi) {\n+                    debug!(\n+                        \"add_liveness_constraints: mpi={:?} has initialized child {:?}\",\n+                        self.move_data.move_paths[mpi],\n+                        self.move_data.move_paths[initialized_child]\n+                    );\n+\n+                    let live_local_ty = self.mir.local_decls[live_local].ty;\n+                    self.add_drop_live_constraint(live_local_ty, location);\n                 }\n-                self.flow_inits.apply_local_effect();\n             }\n+\n+            if location.statement_index == terminator_index {\n+                debug!(\n+                    \"add_liveness_constraints: reconstruct_terminator_effect from {:#?}\",\n+                    location\n+                );\n+                self.flow_inits.reconstruct_terminator_effect(location);\n+            } else {\n+                debug!(\n+                    \"add_liveness_constraints: reconstruct_statement_effect from {:#?}\",\n+                    location\n+                );\n+                self.flow_inits.reconstruct_statement_effect(location);\n+            }\n+            self.flow_inits.apply_local_effect();\n         }\n     }\n \n@@ -185,13 +263,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n             // All things in the `outlives` array may be touched by\n             // the destructor and must be live at this point.\n             for outlive in outlives {\n-                if let Some(ty) = outlive.as_type() {\n-                    self.add_regular_live_constraint(ty, location);\n-                } else if let Some(r) = outlive.as_region() {\n-                    self.add_regular_live_constraint(r, location);\n-                } else {\n-                    bug!()\n-                }\n+                self.add_regular_live_constraint(outlive, location);\n             }\n \n             // However, there may also be some types that\n@@ -228,10 +300,6 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn add_borrow_constraints(&mut self) {\n-        self.visit_mir(self.mir);\n-    }\n-\n     fn add_reborrow_constraint(\n         &mut self,\n         location: Location,\n@@ -246,43 +314,24 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n                 let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n                 let base_sty = &base_ty.sty;\n \n-                if let ty::TyRef(base_region, ty::TypeAndMut{ ty: _, mutbl }) = *base_sty {\n+                if let ty::TyRef(base_region, ty::TypeAndMut { ty: _, mutbl }) = *base_sty {\n                     match mutbl {\n-                        hir::Mutability::MutImmutable => { },\n+                        hir::Mutability::MutImmutable => {}\n \n                         hir::Mutability::MutMutable => {\n                             self.add_reborrow_constraint(location, borrow_region, base);\n-                        },\n+                        }\n                     }\n \n                     let span = self.mir.source_info(location).span;\n-                    self.regioncx.add_outlives(span,\n-                                               base_region.to_region_vid(),\n-                                               borrow_region.to_region_vid(),\n-                                               location.successor_within_block());\n+                    self.regioncx.add_outlives(\n+                        span,\n+                        base_region.to_region_vid(),\n+                        borrow_region.to_region_vid(),\n+                        location.successor_within_block(),\n+                    );\n                 }\n             }\n         }\n     }\n }\n-\n-impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx, 'tcx> {\n-    fn visit_rvalue(&mut self,\n-                    rvalue: &Rvalue<'tcx>,\n-                    location: Location) {\n-        debug!(\"visit_rvalue(rvalue={:?}, location={:?})\", rvalue, location);\n-\n-        // Look for an rvalue like:\n-        //\n-        //     & L\n-        //\n-        // where L is the path that is borrowed. In that case, we have\n-        // to add the reborrow constraints (which don't fall out\n-        // naturally from the type-checker).\n-        if let Rvalue::Ref(region, _bk, ref borrowed_place) = *rvalue {\n-            self.add_reborrow_constraint(location, region, borrowed_place);\n-        }\n-\n-        self.super_rvalue(rvalue, location);\n-    }\n-}"}, {"sha": "2bba3e263f3c63df89c7a3fbc4cbeb8136dc4044", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49d2274cfe184f4a8ed490f7be5d523e02c33fa8/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d2274cfe184f4a8ed490f7be5d523e02c33fa8/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=49d2274cfe184f4a8ed490f7be5d523e02c33fa8", "patch": "@@ -132,10 +132,6 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n         &self.borrows[idx].location\n     }\n \n-    pub fn nonlexical_regioncx(&self) -> Option<&'a RegionInferenceContext<'tcx>> {\n-        self.nonlexical_regioncx\n-    }\n-\n     /// Returns the span for the \"end point\" given region. This will\n     /// return `None` if NLL is enabled, since that concept has no\n     /// meaning there.  Otherwise, return region span if it exists and"}, {"sha": "cfbc51f9e18613ee5430548235daa6846612ebee", "filename": "src/test/mir-opt/nll/region-liveness-basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49d2274cfe184f4a8ed490f7be5d523e02c33fa8/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d2274cfe184f4a8ed490f7be5d523e02c33fa8/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs?ref=49d2274cfe184f4a8ed490f7be5d523e02c33fa8", "patch": "@@ -31,7 +31,7 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#1r: {bb2[1], bb3[0], bb3[1]}\n+// | '_#1r: {bb2[0], bb2[1], bb3[0], bb3[1]}\n // | '_#2r: {bb2[1], bb3[0], bb3[1]}\n // ...\n //             let _2: &'_#2r usize;"}, {"sha": "679f31fdab9035161302651afba534ba69044b31", "filename": "src/test/mir-opt/nll/region-liveness-two-disjoint-uses.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49d2274cfe184f4a8ed490f7be5d523e02c33fa8/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d2274cfe184f4a8ed490f7be5d523e02c33fa8/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs?ref=49d2274cfe184f4a8ed490f7be5d523e02c33fa8", "patch": "@@ -36,9 +36,9 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#1r: {bb2[1], bb3[0], bb3[1]}\n+// | '_#1r: {bb2[0], bb2[1], bb3[0], bb3[1]}\n // ...\n-// | '_#3r: {bb8[2], bb8[3], bb8[4]}\n+// | '_#3r: {bb8[1], bb8[2], bb8[3], bb8[4]}\n // | '_#4r: {bb2[1], bb3[0], bb3[1], bb8[2], bb8[3], bb8[4]}\n // ...\n // let mut _2: &'_#4r usize;"}, {"sha": "471d77aefac622bc0e5a2286e6de587a4dd25c4f", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49d2274cfe184f4a8ed490f7be5d523e02c33fa8/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d2274cfe184f4a8ed490f7be5d523e02c33fa8/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=49d2274cfe184f4a8ed490f7be5d523e02c33fa8", "patch": "@@ -32,7 +32,7 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#1r: {bb2[1], bb2[2], bb2[3], bb2[4], bb2[5], bb2[6], bb3[0], bb3[1]}\n+// | '_#1r: {bb2[0], bb2[1], bb2[2], bb2[3], bb2[4], bb2[5], bb2[6], bb3[0], bb3[1]}\n // | '_#2r: {bb2[1], bb2[2], bb2[3], bb2[4], bb2[5], bb2[6], bb3[0], bb3[1]}\n // | '_#3r: {bb2[5], bb2[6], bb3[0], bb3[1]}\n // END rustc.main.nll.0.mir"}]}