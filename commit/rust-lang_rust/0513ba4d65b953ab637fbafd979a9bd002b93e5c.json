{"sha": "0513ba4d65b953ab637fbafd979a9bd002b93e5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MTNiYTRkNjViOTUzYWI2MzdmYmFmZDk3OWE5YmQwMDJiOTNlNWM=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2021-02-21T11:08:04Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2021-04-04T02:42:49Z"}, "message": "perform filesystem probe once before running bins checks concurrently\n\nthis avoids concurrent write attempts to the output directory", "tree": {"sha": "ea78d60236472004ef01641dd9edf63a31e27f55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea78d60236472004ef01641dd9edf63a31e27f55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0513ba4d65b953ab637fbafd979a9bd002b93e5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0513ba4d65b953ab637fbafd979a9bd002b93e5c", "html_url": "https://github.com/rust-lang/rust/commit/0513ba4d65b953ab637fbafd979a9bd002b93e5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0513ba4d65b953ab637fbafd979a9bd002b93e5c/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "207104010a5c60ac31d52a834f9d45094b927c48", "url": "https://api.github.com/repos/rust-lang/rust/commits/207104010a5c60ac31d52a834f9d45094b927c48", "html_url": "https://github.com/rust-lang/rust/commit/207104010a5c60ac31d52a834f9d45094b927c48"}], "stats": {"total": 190, "additions": 110, "deletions": 80}, "files": [{"sha": "1d5ec5c31c67ff326e35a48c86be0a5e335b5930", "filename": "src/tools/tidy/src/bins.rs", "status": "modified", "additions": 102, "deletions": 70, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/0513ba4d65b953ab637fbafd979a9bd002b93e5c/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0513ba4d65b953ab637fbafd979a9bd002b93e5c/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs?ref=0513ba4d65b953ab637fbafd979a9bd002b93e5c", "patch": "@@ -5,94 +5,126 @@\n //! huge amount of bloat to the Git history, so it's good to just ensure we\n //! don't do that again.\n \n-use std::path::Path;\n+pub use os_impl::*;\n \n // All files are executable on Windows, so just check on Unix.\n #[cfg(windows)]\n-pub fn check(_path: &Path, _output: &Path, _bad: &mut bool) {}\n+mod os_impl {\n+    use std::path::Path;\n+\n+    pub fn check_filesystem_support(_sources: &[&Path], _output: &Path) -> bool {\n+        return false;\n+    }\n+\n+    pub fn check(_path: &Path, _bad: &mut bool) {}\n+}\n \n #[cfg(unix)]\n-pub fn check(path: &Path, output: &Path, bad: &mut bool) {\n+mod os_impl {\n     use std::fs;\n     use std::os::unix::prelude::*;\n+    use std::path::Path;\n     use std::process::{Command, Stdio};\n \n+    enum FilesystemSupport {\n+        Supported,\n+        Unsupported,\n+        ReadOnlyFs,\n+    }\n+\n+    use FilesystemSupport::*;\n+\n     fn is_executable(path: &Path) -> std::io::Result<bool> {\n         Ok(path.metadata()?.mode() & 0o111 != 0)\n     }\n \n-    // We want to avoid false positives on filesystems that do not support the\n-    // executable bit. This occurs on some versions of Window's linux subsystem,\n-    // for example.\n-    //\n-    // We try to create the temporary file first in the src directory, which is\n-    // the preferred location as it's most likely to be on the same filesystem,\n-    // and then in the output (`build`) directory if that fails. Sometimes we\n-    // see the source directory mounted as read-only which means we can't\n-    // readily create a file there to test.\n-    //\n-    // See #36706 and #74753 for context.\n-    //\n-    // We also add the thread ID to avoid threads trampling on each others files.\n-    let file_name = format!(\"t{}.tidy-test-file\", std::thread::current().id().as_u64());\n-    let mut temp_path = path.join(&file_name);\n-    match fs::File::create(&temp_path).or_else(|_| {\n-        temp_path = output.join(&file_name);\n-        fs::File::create(&temp_path)\n-    }) {\n-        Ok(file) => {\n-            let exec = is_executable(&temp_path).unwrap_or(false);\n-            std::mem::drop(file);\n-            std::fs::remove_file(&temp_path).expect(\"Deleted temp file\");\n-            if exec {\n-                // If the file is executable, then we assume that this\n-                // filesystem does not track executability, so skip this check.\n-                return;\n-            }\n+    pub fn check_filesystem_support(sources: &[&Path], output: &Path) -> bool {\n+        // We want to avoid false positives on filesystems that do not support the\n+        // executable bit. This occurs on some versions of Window's linux subsystem,\n+        // for example.\n+        //\n+        // We try to create the temporary file first in the src directory, which is\n+        // the preferred location as it's most likely to be on the same filesystem,\n+        // and then in the output (`build`) directory if that fails. Sometimes we\n+        // see the source directory mounted as read-only which means we can't\n+        // readily create a file there to test.\n+        //\n+        // See #36706 and #74753 for context.\n+\n+        fn check_dir(dir: &Path) -> FilesystemSupport {\n+            let path = dir.join(\"tidy-test-file\");\n+            match fs::File::create(&path) {\n+                Ok(file) => {\n+                    let exec = is_executable(&path).unwrap_or(false);\n+                    std::mem::drop(file);\n+                    std::fs::remove_file(&path).expect(\"Deleted temp file\");\n+                    // If the file is executable, then we assume that this\n+                    // filesystem does not track executability, so skip this check.\n+                    return if exec { Unsupported } else { Supported };\n+                }\n+                Err(e) => {\n+                    // If the directory is read-only or we otherwise don't have rights,\n+                    // just don't run this check.\n+                    //\n+                    // 30 is the \"Read-only filesystem\" code at least in one CI\n+                    //    environment.\n+                    if e.raw_os_error() == Some(30) {\n+                        eprintln!(\"tidy: Skipping binary file check, read-only filesystem\");\n+                        return ReadOnlyFs;\n+                    }\n+\n+                    panic!(\"unable to create temporary file `{:?}`: {:?}\", path, e);\n+                }\n+            };\n         }\n-        Err(e) => {\n-            // If the directory is read-only or we otherwise don't have rights,\n-            // just don't run this check.\n-            //\n-            // 30 is the \"Read-only filesystem\" code at least in one CI\n-            //    environment.\n-            if e.raw_os_error() == Some(30) {\n-                eprintln!(\"tidy: Skipping binary file check, read-only filesystem\");\n-                return;\n-            }\n \n-            panic!(\"unable to create temporary file `{:?}`: {:?}\", temp_path, e);\n+        for &source_dir in sources {\n+            match check_dir(source_dir) {\n+                Unsupported => return false,\n+                ReadOnlyFs => {\n+                    return match check_dir(output) {\n+                        Supported => true,\n+                        _ => false,\n+                    };\n+                }\n+                _ => {}\n+            }\n         }\n+\n+        return true;\n     }\n \n-    super::walk_no_read(\n-        path,\n-        &mut |path| super::filter_dirs(path) || path.ends_with(\"src/etc\"),\n-        &mut |entry| {\n-            let file = entry.path();\n-            let filename = file.file_name().unwrap().to_string_lossy();\n-            let extensions = [\".py\", \".sh\"];\n-            if extensions.iter().any(|e| filename.ends_with(e)) {\n-                return;\n-            }\n+    #[cfg(unix)]\n+    pub fn check(path: &Path, bad: &mut bool) {\n+        crate::walk_no_read(\n+            path,\n+            &mut |path| crate::filter_dirs(path) || path.ends_with(\"src/etc\"),\n+            &mut |entry| {\n+                let file = entry.path();\n+                let filename = file.file_name().unwrap().to_string_lossy();\n+                let extensions = [\".py\", \".sh\"];\n+                if extensions.iter().any(|e| filename.ends_with(e)) {\n+                    return;\n+                }\n \n-            if t!(is_executable(&file), file) {\n-                let rel_path = file.strip_prefix(path).unwrap();\n-                let git_friendly_path = rel_path.to_str().unwrap().replace(\"\\\\\", \"/\");\n-                let output = Command::new(\"git\")\n-                    .arg(\"ls-files\")\n-                    .arg(&git_friendly_path)\n-                    .current_dir(path)\n-                    .stderr(Stdio::null())\n-                    .output()\n-                    .unwrap_or_else(|e| {\n-                        panic!(\"could not run git ls-files: {}\", e);\n-                    });\n-                let path_bytes = rel_path.as_os_str().as_bytes();\n-                if output.status.success() && output.stdout.starts_with(path_bytes) {\n-                    tidy_error!(bad, \"binary checked into source: {}\", file.display());\n+                if t!(is_executable(&file), file) {\n+                    let rel_path = file.strip_prefix(path).unwrap();\n+                    let git_friendly_path = rel_path.to_str().unwrap().replace(\"\\\\\", \"/\");\n+                    let output = Command::new(\"git\")\n+                        .arg(\"ls-files\")\n+                        .arg(&git_friendly_path)\n+                        .current_dir(path)\n+                        .stderr(Stdio::null())\n+                        .output()\n+                        .unwrap_or_else(|e| {\n+                            panic!(\"could not run git ls-files: {}\", e);\n+                        });\n+                    let path_bytes = rel_path.as_os_str().as_bytes();\n+                    if output.status.success() && output.stdout.starts_with(path_bytes) {\n+                        tidy_error!(bad, \"binary checked into source: {}\", file.display());\n+                    }\n                 }\n-            }\n-        },\n-    )\n+            },\n+        )\n+    }\n }"}, {"sha": "11d36751f67bb0b6a2b725d877a2e152164a3f0d", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0513ba4d65b953ab637fbafd979a9bd002b93e5c/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0513ba4d65b953ab637fbafd979a9bd002b93e5c/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=0513ba4d65b953ab637fbafd979a9bd002b93e5c", "patch": "@@ -4,7 +4,6 @@\n //! to be used by tools.\n \n #![cfg_attr(bootstrap, feature(str_split_once))]\n-#![feature(thread_id_value)]\n \n use std::fs::File;\n use std::io::Read;\n@@ -55,12 +54,6 @@ pub mod unit_tests;\n pub mod unstable_book;\n \n fn filter_dirs(path: &Path) -> bool {\n-    // Filter out temporary files used by the bins module to probe the filesystem\n-    match path.extension() {\n-        Some(ext) if ext == \"tidy-test-file\" => return true,\n-        _ => {}\n-    }\n-\n     let skip = [\n         \"compiler/rustc_codegen_cranelift\",\n         \"src/llvm-project\","}, {"sha": "f190a9e57cecb39084dd0990d16bf1b470394b1c", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0513ba4d65b953ab637fbafd979a9bd002b93e5c/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0513ba4d65b953ab637fbafd979a9bd002b93e5c/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=0513ba4d65b953ab637fbafd979a9bd002b93e5c", "patch": "@@ -75,9 +75,14 @@ fn main() {\n         check!(unit_tests, &compiler_path);\n         check!(unit_tests, &library_path);\n \n-        check!(bins, &src_path, &output_directory);\n-        check!(bins, &compiler_path, &output_directory);\n-        check!(bins, &library_path, &output_directory);\n+        if bins::check_filesystem_support(\n+            &[&src_path, &compiler_path, &library_path],\n+            &output_directory,\n+        ) {\n+            check!(bins, &src_path);\n+            check!(bins, &compiler_path);\n+            check!(bins, &library_path);\n+        }\n \n         check!(style, &src_path);\n         check!(style, &compiler_path);"}]}