{"sha": "2067a01ff14b9cbf2548457403a3722cc36775f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwNjdhMDFmZjE0YjljYmYyNTQ4NDU3NDAzYTM3MjJjYzM2Nzc1ZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-08T22:03:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-08T22:03:27Z"}, "message": "Auto merge of #6267 - camsteffen:or-fun-idx, r=flip1995\n\nFix or_fun_call for index operator\n\nchangelog: Fix or_fun_call for index operator\n\nFixes #6266", "tree": {"sha": "65bf60aaca05223825d774bc61a7154550f48427", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65bf60aaca05223825d774bc61a7154550f48427"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2067a01ff14b9cbf2548457403a3722cc36775f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2067a01ff14b9cbf2548457403a3722cc36775f6", "html_url": "https://github.com/rust-lang/rust/commit/2067a01ff14b9cbf2548457403a3722cc36775f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2067a01ff14b9cbf2548457403a3722cc36775f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "040d0ca4dad523a029ec1186cd3b07bb2176a2a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/040d0ca4dad523a029ec1186cd3b07bb2176a2a1", "html_url": "https://github.com/rust-lang/rust/commit/040d0ca4dad523a029ec1186cd3b07bb2176a2a1"}, {"sha": "9cab08465b5d5b4bb4f5ff406b2e18ca550f7d93", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cab08465b5d5b4bb4f5ff406b2e18ca550f7d93", "html_url": "https://github.com/rust-lang/rust/commit/9cab08465b5d5b4bb4f5ff406b2e18ca550f7d93"}], "stats": {"total": 108, "additions": 68, "deletions": 40}, "files": [{"sha": "b6fb3d06934ed40a5fcbb011f810813a4b1d9c08", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2067a01ff14b9cbf2548457403a3722cc36775f6/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2067a01ff14b9cbf2548457403a3722cc36775f6/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=2067a01ff14b9cbf2548457403a3722cc36775f6", "patch": "@@ -1797,12 +1797,20 @@ fn lint_or_fun_call<'tcx>(\n         cx: &LateContext<'tcx>,\n         name: &str,\n         method_span: Span,\n-        fun_span: Span,\n         self_expr: &hir::Expr<'_>,\n         arg: &'tcx hir::Expr<'_>,\n-        or_has_args: bool,\n         span: Span,\n+        // None if lambda is required\n+        fun_span: Option<Span>,\n     ) {\n+        // (path, fn_has_argument, methods, suffix)\n+        static KNOW_TYPES: [(&[&str], bool, &[&str], &str); 4] = [\n+            (&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+            (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+            (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n+            (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n+        ];\n+\n         if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = &arg.kind {\n             if path.ident.as_str() == \"len\" {\n                 let ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n@@ -1818,32 +1826,32 @@ fn lint_or_fun_call<'tcx>(\n             }\n         }\n \n-        // (path, fn_has_argument, methods, suffix)\n-        let know_types: &[(&[_], _, &[_], _)] = &[\n-            (&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-            (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-            (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n-            (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n-        ];\n-\n         if_chain! {\n-            if know_types.iter().any(|k| k.2.contains(&name));\n+            if KNOW_TYPES.iter().any(|k| k.2.contains(&name));\n \n             if is_lazyness_candidate(cx, arg);\n             if !contains_return(&arg);\n \n             let self_ty = cx.typeck_results().expr_ty(self_expr);\n \n             if let Some(&(_, fn_has_arguments, poss, suffix)) =\n-                know_types.iter().find(|&&i| match_type(cx, self_ty, i.0));\n+                KNOW_TYPES.iter().find(|&&i| match_type(cx, self_ty, i.0));\n \n             if poss.contains(&name);\n \n             then {\n-                let sugg: Cow<'_, _> = match (fn_has_arguments, !or_has_args) {\n-                    (true, _) => format!(\"|_| {}\", snippet_with_macro_callsite(cx, arg.span, \"..\")).into(),\n-                    (false, false) => format!(\"|| {}\", snippet_with_macro_callsite(cx, arg.span, \"..\")).into(),\n-                    (false, true) => snippet_with_macro_callsite(cx, fun_span, \"..\"),\n+                let sugg: Cow<'_, str> = {\n+                    let (snippet_span, use_lambda) = match (fn_has_arguments, fun_span) {\n+                        (false, Some(fun_span)) => (fun_span, false),\n+                        _ => (arg.span, true),\n+                    };\n+                    let snippet = snippet_with_macro_callsite(cx, snippet_span, \"..\");\n+                    if use_lambda {\n+                        let l_arg = if fn_has_arguments { \"_\" } else { \"\" };\n+                        format!(\"|{}| {}\", l_arg, snippet).into()\n+                    } else {\n+                        snippet\n+                    }\n                 };\n                 let span_replace_word = method_span.with_hi(span.hi());\n                 span_lint_and_sugg(\n@@ -1864,28 +1872,13 @@ fn lint_or_fun_call<'tcx>(\n             hir::ExprKind::Call(ref fun, ref or_args) => {\n                 let or_has_args = !or_args.is_empty();\n                 if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n-                    check_general_case(\n-                        cx,\n-                        name,\n-                        method_span,\n-                        fun.span,\n-                        &args[0],\n-                        &args[1],\n-                        or_has_args,\n-                        expr.span,\n-                    );\n+                    let fun_span = if or_has_args { None } else { Some(fun.span) };\n+                    check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, fun_span);\n                 }\n             },\n-            hir::ExprKind::MethodCall(_, span, ref or_args, _) => check_general_case(\n-                cx,\n-                name,\n-                method_span,\n-                span,\n-                &args[0],\n-                &args[1],\n-                !or_args.is_empty(),\n-                expr.span,\n-            ),\n+            hir::ExprKind::Index(..) | hir::ExprKind::MethodCall(..) => {\n+                check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, None);\n+            },\n             _ => {},\n         }\n     }"}, {"sha": "8fe5ddee1ca8d8cf11d4ad300904cae10cc82ddf", "filename": "clippy_lints/src/utils/eager_or_lazy.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2067a01ff14b9cbf2548457403a3722cc36775f6/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2067a01ff14b9cbf2548457403a3722cc36775f6/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs?ref=2067a01ff14b9cbf2548457403a3722cc36775f6", "patch": "@@ -9,7 +9,7 @@\n //!  - or-fun-call\n //!  - option-if-let-else\n \n-use crate::utils::is_ctor_or_promotable_const_function;\n+use crate::utils::{is_ctor_or_promotable_const_function, is_type_diagnostic_item, match_type, paths};\n use rustc_hir::def::{DefKind, Res};\n \n use rustc_hir::intravisit;\n@@ -96,6 +96,11 @@ fn identify_some_potentially_expensive_patterns<'tcx>(cx: &LateContext<'tcx>, ex\n             let call_found = match &expr.kind {\n                 // ignore enum and struct constructors\n                 ExprKind::Call(..) => !is_ctor_or_promotable_const_function(self.cx, expr),\n+                ExprKind::Index(obj, _) => {\n+                    let ty = self.cx.typeck_results().expr_ty(obj);\n+                    is_type_diagnostic_item(self.cx, ty, sym!(hashmap_type))\n+                        || match_type(self.cx, ty, &paths::BTREEMAP)\n+                },\n                 ExprKind::MethodCall(..) => true,\n                 _ => false,\n             };"}, {"sha": "20e5016bc17a08086610e45d052cca0b00de92fd", "filename": "tests/ui/or_fun_call.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2067a01ff14b9cbf2548457403a3722cc36775f6/tests%2Fui%2For_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2067a01ff14b9cbf2548457403a3722cc36775f6/tests%2Fui%2For_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.fixed?ref=2067a01ff14b9cbf2548457403a3722cc36775f6", "patch": "@@ -70,6 +70,15 @@ fn or_fun_call() {\n     let opt = Some(1);\n     let hello = \"Hello\";\n     let _ = opt.ok_or(format!(\"{} world.\", hello));\n+\n+    // index\n+    let map = HashMap::<u64, u64>::new();\n+    let _ = Some(1).unwrap_or_else(|| map[&1]);\n+    let map = BTreeMap::<u64, u64>::new();\n+    let _ = Some(1).unwrap_or_else(|| map[&1]);\n+    // don't lint index vec\n+    let vec = vec![1];\n+    let _ = Some(1).unwrap_or(vec[1]);\n }\n \n struct Foo(u8);"}, {"sha": "e7192deeebb3632b0d8b3166f6baee6674f51d69", "filename": "tests/ui/or_fun_call.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2067a01ff14b9cbf2548457403a3722cc36775f6/tests%2Fui%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2067a01ff14b9cbf2548457403a3722cc36775f6/tests%2Fui%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.rs?ref=2067a01ff14b9cbf2548457403a3722cc36775f6", "patch": "@@ -70,6 +70,15 @@ fn or_fun_call() {\n     let opt = Some(1);\n     let hello = \"Hello\";\n     let _ = opt.ok_or(format!(\"{} world.\", hello));\n+\n+    // index\n+    let map = HashMap::<u64, u64>::new();\n+    let _ = Some(1).unwrap_or(map[&1]);\n+    let map = BTreeMap::<u64, u64>::new();\n+    let _ = Some(1).unwrap_or(map[&1]);\n+    // don't lint index vec\n+    let vec = vec![1];\n+    let _ = Some(1).unwrap_or(vec[1]);\n }\n \n struct Foo(u8);"}, {"sha": "d0c4df0e0081761eb36a7820db58db9aa3a40d17", "filename": "tests/ui/or_fun_call.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2067a01ff14b9cbf2548457403a3722cc36775f6/tests%2Fui%2For_fun_call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2067a01ff14b9cbf2548457403a3722cc36775f6/tests%2Fui%2For_fun_call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.stderr?ref=2067a01ff14b9cbf2548457403a3722cc36775f6", "patch": "@@ -78,17 +78,29 @@ error: use of `unwrap_or` followed by a function call\n LL |     let _ = stringy.unwrap_or(\"\".to_owned());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| \"\".to_owned())`\n \n+error: use of `unwrap_or` followed by a function call\n+  --> $DIR/or_fun_call.rs:76:21\n+   |\n+LL |     let _ = Some(1).unwrap_or(map[&1]);\n+   |                     ^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| map[&1])`\n+\n+error: use of `unwrap_or` followed by a function call\n+  --> $DIR/or_fun_call.rs:78:21\n+   |\n+LL |     let _ = Some(1).unwrap_or(map[&1]);\n+   |                     ^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| map[&1])`\n+\n error: use of `or` followed by a function call\n-  --> $DIR/or_fun_call.rs:93:35\n+  --> $DIR/or_fun_call.rs:102:35\n    |\n LL |     let _ = Some(\"a\".to_string()).or(Some(\"b\".to_string()));\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_else(|| Some(\"b\".to_string()))`\n \n error: use of `or` followed by a function call\n-  --> $DIR/or_fun_call.rs:97:10\n+  --> $DIR/or_fun_call.rs:106:10\n    |\n LL |         .or(Some(Bar(b, Duration::from_secs(2))));\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_else(|| Some(Bar(b, Duration::from_secs(2))))`\n \n-error: aborting due to 15 previous errors\n+error: aborting due to 17 previous errors\n "}]}