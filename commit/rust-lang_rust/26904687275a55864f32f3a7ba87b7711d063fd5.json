{"sha": "26904687275a55864f32f3a7ba87b7711d063fd5", "node_id": "C_kwDOAAsO6NoAKDI2OTA0Njg3Mjc1YTU1ODY0ZjMyZjNhN2JhODdiNzcxMWQwNjNmZDU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-19T23:25:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-19T23:25:06Z"}, "message": "Auto merge of #92911 - nbdd0121:unwind, r=Amanieu\n\nGuard against unwinding in cleanup code\n\nCurrently the only safe guard we have against double unwind is the panic count (which is local to Rust). When double unwinds indeed happen (e.g. C++ exception + Rust panic, or two C++ exceptions), then the second unwind actually goes through and the first unwind is leaked. This can cause UB. cc rust-lang/project-ffi-unwind#6\n\nE.g. given the following C++ code:\n```c++\nextern \"C\" void foo() {\n    throw \"A\";\n}\n\nextern \"C\" void execute(void (*fn)()) {\n    try {\n        fn();\n    } catch(...) {\n    }\n}\n```\n\nThis program is well-defined to terminate:\n```c++\nstruct dtor {\n    ~dtor() noexcept(false) {\n        foo();\n    }\n};\n\nvoid a() {\n    dtor a;\n    dtor b;\n}\n\nint main() {\n    execute(a);\n    return 0;\n}\n```\n\nBut this Rust code doesn't catch the double unwind:\n```rust\nextern \"C-unwind\" {\n    fn foo();\n    fn execute(f: unsafe extern \"C-unwind\" fn());\n}\n\nstruct Dtor;\n\nimpl Drop for Dtor {\n    fn drop(&mut self) {\n        unsafe { foo(); }\n    }\n}\n\nextern \"C-unwind\" fn a() {\n    let _a = Dtor;\n    let _b = Dtor;\n}\n\nfn main() {\n    unsafe { execute(a) };\n}\n```\n\nTo address this issue, this PR adds an unwind edge to an abort block, so that the Rust example aborts. This is similar to how clang guards against double unwind (except clang calls terminate per C++ spec and we abort).\n\nThe cost should be very small; it's an additional trap instruction (well, two for now, since we use TrapUnreachable, but that's a different issue) for each function with landing pads; if LLVM gains support to encode \"abort/terminate\" info directly in LSDA like GCC does, then it'll be free. It's an additional basic block though so compile time may be worse, so I'd like a perf run.\n\nr? `@ghost`\n`@rustbot` label: F-c_unwind", "tree": {"sha": "c444f4b096246a42957bc14f2c898da5fffc8cba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c444f4b096246a42957bc14f2c898da5fffc8cba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26904687275a55864f32f3a7ba87b7711d063fd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26904687275a55864f32f3a7ba87b7711d063fd5", "html_url": "https://github.com/rust-lang/rust/commit/26904687275a55864f32f3a7ba87b7711d063fd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26904687275a55864f32f3a7ba87b7711d063fd5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b348d932aa5c9884310d025cf7c516023fd0d9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b348d932aa5c9884310d025cf7c516023fd0d9a", "html_url": "https://github.com/rust-lang/rust/commit/3b348d932aa5c9884310d025cf7c516023fd0d9a"}, {"sha": "7d683f525a6cd807f7bcb1293c71bce613936e79", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d683f525a6cd807f7bcb1293c71bce613936e79", "html_url": "https://github.com/rust-lang/rust/commit/7d683f525a6cd807f7bcb1293c71bce613936e79"}], "stats": {"total": 159, "additions": 132, "deletions": 27}, "files": [{"sha": "33f883f9b6c3011e37ecf6d09c1c130a6e3e3658", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 56, "deletions": 13, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/26904687275a55864f32f3a7ba87b7711d063fd5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26904687275a55864f32f3a7ba87b7711d063fd5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=26904687275a55864f32f3a7ba87b7711d063fd5", "patch": "@@ -135,21 +135,38 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         // If there is a cleanup block and the function we're calling can unwind, then\n         // do an invoke, otherwise do a call.\n         let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n-        if let Some(cleanup) = cleanup.filter(|_| fn_abi.can_unwind) {\n+\n+        let unwind_block = if let Some(cleanup) = cleanup.filter(|_| fn_abi.can_unwind) {\n+            Some(self.llblock(fx, cleanup))\n+        } else if fx.mir[self.bb].is_cleanup\n+            && fn_abi.can_unwind\n+            && !base::wants_msvc_seh(fx.cx.tcx().sess)\n+        {\n+            // Exception must not propagate out of the execution of a cleanup (doing so\n+            // can cause undefined behaviour). We insert a double unwind guard for\n+            // functions that can potentially unwind to protect against this.\n+            //\n+            // This is not necessary for SEH which does not use successive unwinding\n+            // like Itanium EH. EH frames in SEH are different from normal function\n+            // frames and SEH will abort automatically if an exception tries to\n+            // propagate out from cleanup.\n+            Some(fx.double_unwind_guard())\n+        } else {\n+            None\n+        };\n+\n+        if let Some(unwind_block) = unwind_block {\n             let ret_llbb = if let Some((_, target)) = destination {\n                 fx.llbb(target)\n             } else {\n                 fx.unreachable_block()\n             };\n-            let invokeret = bx.invoke(\n-                fn_ty,\n-                fn_ptr,\n-                &llargs,\n-                ret_llbb,\n-                self.llblock(fx, cleanup),\n-                self.funclet(fx),\n-            );\n+            let invokeret =\n+                bx.invoke(fn_ty, fn_ptr, &llargs, ret_llbb, unwind_block, self.funclet(fx));\n             bx.apply_attrs_callsite(&fn_abi, invokeret);\n+            if fx.mir[self.bb].is_cleanup {\n+                bx.apply_attrs_to_cleanup_callsite(invokeret);\n+            }\n \n             if let Some((ret_dest, target)) = destination {\n                 let mut ret_bx = fx.build_block(target);\n@@ -486,17 +503,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let span = terminator.source_info.span;\n         self.set_debug_loc(&mut bx, terminator.source_info);\n \n-        // Get the location information.\n-        let location = self.get_caller_location(&mut bx, terminator.source_info).immediate();\n-\n         // Obtain the panic entry point.\n         let def_id = common::langcall(bx.tcx(), Some(span), \"\", LangItem::PanicNoUnwind);\n         let instance = ty::Instance::mono(bx.tcx(), def_id);\n         let fn_abi = bx.fn_abi_of_instance(instance, ty::List::empty());\n         let llfn = bx.get_fn_addr(instance);\n \n         // Codegen the actual panic invoke/call.\n-        helper.do_call(self, &mut bx, fn_abi, llfn, &[location], None, None);\n+        helper.do_call(self, &mut bx, fn_abi, llfn, &[], None, None);\n     }\n \n     /// Returns `true` if this is indeed a panic intrinsic and codegen is done.\n@@ -1398,6 +1412,35 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         })\n     }\n \n+    fn double_unwind_guard(&mut self) -> Bx::BasicBlock {\n+        self.double_unwind_guard.unwrap_or_else(|| {\n+            assert!(!base::wants_msvc_seh(self.cx.sess()));\n+\n+            let mut bx = self.new_block(\"abort\");\n+            self.set_debug_loc(&mut bx, mir::SourceInfo::outermost(self.mir.span));\n+\n+            let llpersonality = self.cx.eh_personality();\n+            let llretty = self.landing_pad_type();\n+            bx.cleanup_landing_pad(llretty, llpersonality);\n+\n+            let def_id = common::langcall(bx.tcx(), None, \"\", LangItem::PanicNoUnwind);\n+            let instance = ty::Instance::mono(bx.tcx(), def_id);\n+            let fn_abi = bx.fn_abi_of_instance(instance, ty::List::empty());\n+            let fn_ptr = bx.get_fn_addr(instance);\n+            let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n+\n+            let llret = bx.call(fn_ty, fn_ptr, &[], None);\n+            bx.apply_attrs_callsite(&fn_abi, llret);\n+            bx.apply_attrs_to_cleanup_callsite(llret);\n+\n+            bx.unreachable();\n+            let llbb = bx.llbb();\n+\n+            self.double_unwind_guard = Some(llbb);\n+            llbb\n+        })\n+    }\n+\n     // FIXME(eddyb) replace with `build_sibling_block`/`append_sibling_block`\n     // (which requires having a `Bx` already, and not all callers do).\n     fn new_block(&self, name: &str) -> Bx {"}, {"sha": "4f05d02526e550582b6eebdfed62719349f9b3b4", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26904687275a55864f32f3a7ba87b7711d063fd5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26904687275a55864f32f3a7ba87b7711d063fd5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=26904687275a55864f32f3a7ba87b7711d063fd5", "patch": "@@ -62,6 +62,9 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     /// Cached unreachable block\n     unreachable_block: Option<Bx::BasicBlock>,\n \n+    /// Cached double unwind guarding block\n+    double_unwind_guard: Option<Bx::BasicBlock>,\n+\n     /// The location where each MIR arg/var/tmp/ret is stored. This is\n     /// usually an `PlaceRef` representing an alloca, but not always:\n     /// sometimes we can skip the alloca and just store the value\n@@ -169,6 +172,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         personality_slot: None,\n         cached_llbbs,\n         unreachable_block: None,\n+        double_unwind_guard: None,\n         cleanup_kinds,\n         landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n         funclets: IndexVec::from_fn_n(|_| None, mir.basic_blocks().len()),"}, {"sha": "2b720fc4192a7e04ee212a1961635ebba41f79dd", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26904687275a55864f32f3a7ba87b7711d063fd5/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26904687275a55864f32f3a7ba87b7711d063fd5/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=26904687275a55864f32f3a7ba87b7711d063fd5", "patch": "@@ -87,8 +87,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n #[cfg(not(bootstrap))]\n #[cold]\n-#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n-#[track_caller]\n+#[inline(never)]\n #[lang = \"panic_no_unwind\"] // needed by codegen for panic in nounwind function\n fn panic_no_unwind() -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {"}, {"sha": "994028271583f09c7e6a6f97fee3a55661ec3027", "filename": "src/test/codegen/drop.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/26904687275a55864f32f3a7ba87b7711d063fd5/src%2Ftest%2Fcodegen%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26904687275a55864f32f3a7ba87b7711d063fd5/src%2Ftest%2Fcodegen%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdrop.rs?ref=26904687275a55864f32f3a7ba87b7711d063fd5", "patch": "@@ -23,17 +23,7 @@ pub fn droppy() {\n // FIXME(eddyb) the `void @` forces a match on the instruction, instead of the\n // comment, that's `; call core::ptr::drop_in_place::<drop::SomeUniqueName>`\n // for the `v0` mangling, should switch to matching on that once `legacy` is gone.\n-// CHECK-NOT: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n-// CHECK: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n-// CHECK: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n-// CHECK-NOT: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n-// CHECK: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n-// CHECK-NOT: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n-// CHECK: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n-// CHECK-NOT: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n-// CHECK: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n-// CHECK-NOT: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n-// CHECK: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK-COUNT-6: {{(call|invoke) void @.*}}drop_in_place{{.*}}SomeUniqueName\n // CHECK-NOT: {{(call|invoke) void @.*}}drop_in_place{{.*}}SomeUniqueName\n // The next line checks for the } that ends the function definition\n // CHECK-LABEL: {{^[}]}}"}, {"sha": "aa00b7936541e5fbfbca919f5a8503952b774629", "filename": "src/test/codegen/unwind-landingpad-cold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26904687275a55864f32f3a7ba87b7711d063fd5/src%2Ftest%2Fcodegen%2Funwind-landingpad-cold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26904687275a55864f32f3a7ba87b7711d063fd5/src%2Ftest%2Fcodegen%2Funwind-landingpad-cold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funwind-landingpad-cold.rs?ref=26904687275a55864f32f3a7ba87b7711d063fd5", "patch": "@@ -6,7 +6,7 @@\n // get the `cold` attribute.\n \n // CHECK-LABEL: @check_cold\n-// CHECK: call void {{.+}}drop_in_place{{.+}} [[ATTRIBUTES:#[0-9]+]]\n+// CHECK: {{(call|invoke) void .+}}drop_in_place{{.+}} [[ATTRIBUTES:#[0-9]+]]\n // CHECK: attributes [[ATTRIBUTES]] = { cold }\n #[no_mangle]\n pub fn check_cold(f: fn(), x: Box<u32>) {"}, {"sha": "27cf4d19ce0677e765a3a20cf8182fb3eea2d30e", "filename": "src/test/run-make-fulldeps/foreign-double-unwind/Makefile", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26904687275a55864f32f3a7ba87b7711d063fd5/src%2Ftest%2Frun-make-fulldeps%2Fforeign-double-unwind%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/26904687275a55864f32f3a7ba87b7711d063fd5/src%2Ftest%2Frun-make-fulldeps%2Fforeign-double-unwind%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-double-unwind%2FMakefile?ref=26904687275a55864f32f3a7ba87b7711d063fd5", "patch": "@@ -0,0 +1,10 @@\n+-include ../tools.mk\n+\n+all: foo\n+\t$(call RUN,foo) | $(CGREP) -v unreachable\n+\n+foo: foo.rs $(call NATIVE_STATICLIB,foo)\n+\t$(RUSTC) $< -lfoo $(EXTRARSCXXFLAGS)\n+\n+$(TMPDIR)/libfoo.o: foo.cpp\n+\t$(call COMPILE_OBJ_CXX,$@,$<)"}, {"sha": "69a8f11c2db78e9bf83352b73f558b0f6c2f9f74", "filename": "src/test/run-make-fulldeps/foreign-double-unwind/foo.cpp", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/26904687275a55864f32f3a7ba87b7711d063fd5/src%2Ftest%2Frun-make-fulldeps%2Fforeign-double-unwind%2Ffoo.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/26904687275a55864f32f3a7ba87b7711d063fd5/src%2Ftest%2Frun-make-fulldeps%2Fforeign-double-unwind%2Ffoo.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-double-unwind%2Ffoo.cpp?ref=26904687275a55864f32f3a7ba87b7711d063fd5", "patch": "@@ -0,0 +1,33 @@\n+#include <cstdio>\n+#include <exception>\n+\n+void println(const char* s) {\n+    puts(s);\n+    fflush(stdout);\n+}\n+\n+struct outer_exception {};\n+struct inner_exception {};\n+\n+extern \"C\" {\n+    void throw_cxx_exception() {\n+        if (std::uncaught_exception()) {\n+            println(\"throwing inner C++ exception\");\n+            throw inner_exception();\n+        } else {\n+            println(\"throwing outer C++ exception\");\n+            throw outer_exception();\n+        }\n+    }\n+\n+    void cxx_catch_callback(void (*cb)()) {\n+        try {\n+            cb();\n+            println(\"unreachable: callback returns\");\n+        } catch (outer_exception) {\n+            println(\"unreachable: caught outer exception in catch (...)\");\n+        } catch (inner_exception) {\n+            println(\"unreachable: caught inner exception in catch (...)\");\n+        }\n+    }\n+}"}, {"sha": "cae8aa9402d88f7c5e6534b1dbf6936da438c90a", "filename": "src/test/run-make-fulldeps/foreign-double-unwind/foo.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/26904687275a55864f32f3a7ba87b7711d063fd5/src%2Ftest%2Frun-make-fulldeps%2Fforeign-double-unwind%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26904687275a55864f32f3a7ba87b7711d063fd5/src%2Ftest%2Frun-make-fulldeps%2Fforeign-double-unwind%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-double-unwind%2Ffoo.rs?ref=26904687275a55864f32f3a7ba87b7711d063fd5", "patch": "@@ -0,0 +1,26 @@\n+// Tests that C++ double unwinding through Rust code will be properly guarded\n+// against instead of exhibiting undefined behaviour.\n+\n+#![feature(c_unwind)]\n+\n+extern \"C-unwind\" {\n+    fn throw_cxx_exception();\n+    fn cxx_catch_callback(cb: extern \"C-unwind\" fn());\n+}\n+\n+struct ThrowOnDrop;\n+\n+impl Drop for ThrowOnDrop {\n+    fn drop(&mut self) {\n+        unsafe { throw_cxx_exception() };\n+    }\n+}\n+\n+extern \"C-unwind\" fn test_double_unwind() {\n+    let _a = ThrowOnDrop;\n+    let _b = ThrowOnDrop;\n+}\n+\n+fn main() {\n+    unsafe { cxx_catch_callback(test_double_unwind) };\n+}"}]}