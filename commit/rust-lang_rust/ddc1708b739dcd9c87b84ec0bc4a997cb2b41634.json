{"sha": "ddc1708b739dcd9c87b84ec0bc4a997cb2b41634", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYzE3MDhiNzM5ZGNkOWM4N2I4NGVjMGJjNGE5OTdjYjJiNDE2MzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-13T09:57:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-13T09:57:38Z"}, "message": "Auto merge of #40385 - arielb1:packed-again, r=eddyb\n\nemit !align attributes on stores of operand pairs\n\nThis avoids another case of missing-align UB. cc #40373\n\nr? @eddyb", "tree": {"sha": "1b63e24495f8d94fd871f23a111099d4d32fd379", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b63e24495f8d94fd871f23a111099d4d32fd379"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddc1708b739dcd9c87b84ec0bc4a997cb2b41634", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddc1708b739dcd9c87b84ec0bc4a997cb2b41634", "html_url": "https://github.com/rust-lang/rust/commit/ddc1708b739dcd9c87b84ec0bc4a997cb2b41634", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddc1708b739dcd9c87b84ec0bc4a997cb2b41634/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40e5b18609c015cf6e331a08aa1e2f13c0d52b82", "url": "https://api.github.com/repos/rust-lang/rust/commits/40e5b18609c015cf6e331a08aa1e2f13c0d52b82", "html_url": "https://github.com/rust-lang/rust/commit/40e5b18609c015cf6e331a08aa1e2f13c0d52b82"}, {"sha": "32c9893432634a4de0ad9f743e28e87f60a1b778", "url": "https://api.github.com/repos/rust-lang/rust/commits/32c9893432634a4de0ad9f743e28e87f60a1b778", "html_url": "https://github.com/rust-lang/rust/commit/32c9893432634a4de0ad9f743e28e87f60a1b778"}], "stats": {"total": 61, "additions": 57, "deletions": 4}, "files": [{"sha": "9d40419d338b8a50b2a2f5322b897dd61314885b", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ddc1708b739dcd9c87b84ec0bc4a997cb2b41634/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc1708b739dcd9c87b84ec0bc4a997cb2b41634/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=ddc1708b739dcd9c87b84ec0bc4a997cb2b41634", "patch": "@@ -833,8 +833,21 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             self.trans_lvalue(bcx, dest)\n         };\n         if fn_ret_ty.is_indirect() {\n-            llargs.push(dest.llval);\n-            ReturnDest::Nothing\n+            match dest.alignment {\n+                Alignment::AbiAligned => {\n+                    llargs.push(dest.llval);\n+                    ReturnDest::Nothing\n+                },\n+                Alignment::Packed => {\n+                    // Currently, MIR code generation does not create calls\n+                    // that store directly to fields of packed structs (in\n+                    // fact, the calls it creates write only to temps),\n+                    //\n+                    // If someone changes that, please update this code path\n+                    // to create a temporary.\n+                    span_bug!(self.mir.span, \"can't directly store to unaligned value\");\n+                }\n+            }\n         } else {\n             ReturnDest::Store(dest.llval)\n         }"}, {"sha": "3f29545ecf45a16c2bf8c59607503ce69a903322", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ddc1708b739dcd9c87b84ec0bc4a997cb2b41634/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc1708b739dcd9c87b84ec0bc4a997cb2b41634/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=ddc1708b739dcd9c87b84ec0bc4a997cb2b41634", "patch": "@@ -268,10 +268,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 bcx.store(base::from_immediate(bcx, s), lldest, align);\n             }\n             OperandValue::Pair(a, b) => {\n+                let f_align = match *bcx.ccx.layout_of(operand.ty) {\n+                    Layout::Univariant { ref variant, .. } if variant.packed => {\n+                        Some(1)\n+                    }\n+                    _ => align\n+                };\n+\n                 let a = base::from_immediate(bcx, a);\n                 let b = base::from_immediate(bcx, b);\n-                bcx.store(a, bcx.struct_gep(lldest, 0), align);\n-                bcx.store(b, bcx.struct_gep(lldest, 1), align);\n+                bcx.store(a, bcx.struct_gep(lldest, 0), f_align);\n+                bcx.store(b, bcx.struct_gep(lldest, 1), f_align);\n             }\n         }\n     }"}, {"sha": "99e6e38a3bf0bd97654846d3f5c6e151d1d2b822", "filename": "src/test/codegen/packed.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ddc1708b739dcd9c87b84ec0bc4a997cb2b41634/src%2Ftest%2Fcodegen%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddc1708b739dcd9c87b84ec0bc4a997cb2b41634/src%2Ftest%2Fcodegen%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpacked.rs?ref=ddc1708b739dcd9c87b84ec0bc4a997cb2b41634", "patch": "@@ -27,3 +27,36 @@ pub fn write_pkd(pkd: &mut Packed) -> u32 {\n     pkd.data = 42;\n     result\n }\n+\n+pub struct Array([i32; 8]);\n+#[repr(packed)]\n+pub struct BigPacked {\n+    dealign: u8,\n+    data: Array\n+}\n+\n+// CHECK-LABEL: @call_pkd\n+#[no_mangle]\n+pub fn call_pkd(f: fn() -> Array) -> BigPacked {\n+// CHECK: [[ALLOCA:%[_a-z0-9]+]] = alloca %Array\n+// CHECK: call void %{{.*}}(%Array* noalias nocapture sret dereferenceable(32) [[ALLOCA]])\n+// CHECK: call void @llvm.memcpy.{{.*}}(i8* %{{.*}}, i8* %{{.*}}, i{{[0-9]+}} 32, i32 1, i1 false)\n+    // check that calls whose destination is a field of a packed struct\n+    // go through an alloca rather than calling the function with an\n+    // unaligned destination.\n+    BigPacked { dealign: 0, data: f() }\n+}\n+\n+#[repr(packed)]\n+#[derive(Copy, Clone)]\n+pub struct PackedPair(u8, u32);\n+\n+// CHECK-LABEL: @pkd_pair\n+#[no_mangle]\n+pub fn pkd_pair(pair1: &mut PackedPair, pair2: &mut PackedPair) {\n+    // CHECK: [[V1:%[a-z0-9]+]] = load i8, i8* %{{.*}}, align 1\n+    // CHECK: [[V2:%[a-z0-9]+]] = load i32, i32* %{{.*}}, align 1\n+    // CHECK: store i8 [[V1]], i8* {{.*}}, align 1\n+    // CHECK: store i32 [[V2]], i32* {{.*}}, align 1\n+    *pair2 = *pair1;\n+}"}]}