{"sha": "336c8d2e9c6b276b162bdb3edd43706372e6eddd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzNmM4ZDJlOWM2YjI3NmIxNjJiZGIzZWRkNDM3MDYzNzJlNmVkZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-03T07:59:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-03T07:59:04Z"}, "message": "Auto merge of #21613 - alfie:suffix-small, r=alexcrichton", "tree": {"sha": "ce8b369728b285ce16ea77a7e43d8e9ce05b1be5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce8b369728b285ce16ea77a7e43d8e9ce05b1be5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/336c8d2e9c6b276b162bdb3edd43706372e6eddd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/336c8d2e9c6b276b162bdb3edd43706372e6eddd", "html_url": "https://github.com/rust-lang/rust/commit/336c8d2e9c6b276b162bdb3edd43706372e6eddd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/336c8d2e9c6b276b162bdb3edd43706372e6eddd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7858cb432d3f2efc0374424cb2b51518f697c172", "url": "https://api.github.com/repos/rust-lang/rust/commits/7858cb432d3f2efc0374424cb2b51518f697c172", "html_url": "https://github.com/rust-lang/rust/commit/7858cb432d3f2efc0374424cb2b51518f697c172"}, {"sha": "8f4844d58b0a84792e85a650c510270559b81022", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f4844d58b0a84792e85a650c510270559b81022", "html_url": "https://github.com/rust-lang/rust/commit/8f4844d58b0a84792e85a650c510270559b81022"}], "stats": {"total": 364, "additions": 182, "deletions": 182}, "files": [{"sha": "005ec013b8e6dd5acc3c638b2478a3944305ee39", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -300,8 +300,8 @@ fn parse_exec_env(line: &str) -> Option<(String, String)> {\n                                       .collect();\n \n         match strs.len() {\n-          1u => (strs.pop().unwrap(), \"\".to_string()),\n-          2u => {\n+          1 => (strs.pop().unwrap(), \"\".to_string()),\n+          2 => {\n               let end = strs.pop().unwrap();\n               (strs.pop().unwrap(), end)\n           }"}, {"sha": "a8e644dba99d18a8552d1d359f272f5a96d54840", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -230,9 +230,9 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n             let s = File::open(&filepath).read_to_end().unwrap();\n             String::from_utf8(s).unwrap()\n         }\n-        None => { srcs[srcs.len() - 2u].clone() }\n+        None => { srcs[srcs.len() - 2].clone() }\n     };\n-    let mut actual = srcs[srcs.len() - 1u].clone();\n+    let mut actual = srcs[srcs.len() - 1].clone();\n \n     if props.pp_exact.is_some() {\n         // Now we have to care about line endings\n@@ -842,7 +842,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n             }).collect();\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n-        let mut i = 0u;\n+        let mut i = 0;\n         for line in debugger_run_result.stdout.lines() {\n             let mut rest = line.trim();\n             let mut first = true;\n@@ -869,7 +869,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n                 first = false;\n             }\n             if !failed && rest.len() == 0 {\n-                i += 1u;\n+                i += 1;\n             }\n             if i == num_check_lines {\n                 // all lines checked\n@@ -892,13 +892,13 @@ fn check_error_patterns(props: &TestProps,\n         fatal(format!(\"no error pattern specified in {:?}\",\n                       testfile.display()).as_slice());\n     }\n-    let mut next_err_idx = 0u;\n+    let mut next_err_idx = 0;\n     let mut next_err_pat = &props.error_patterns[next_err_idx];\n     let mut done = false;\n     for line in output_to_check.lines() {\n         if line.contains(next_err_pat.as_slice()) {\n             debug!(\"found error pattern {}\", next_err_pat);\n-            next_err_idx += 1u;\n+            next_err_idx += 1;\n             if next_err_idx == props.error_patterns.len() {\n                 debug!(\"found all error patterns\");\n                 done = true;\n@@ -910,7 +910,7 @@ fn check_error_patterns(props: &TestProps,\n     if done { return; }\n \n     let missing_patterns = &props.error_patterns[next_err_idx..];\n-    if missing_patterns.len() == 1u {\n+    if missing_patterns.len() == 1 {\n         fatal_proc_rec(format!(\"error pattern '{}' not found!\",\n                               missing_patterns[0]).as_slice(),\n                       proc_res);\n@@ -1025,7 +1025,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n }\n \n fn is_compiler_error_or_warning(line: &str) -> bool {\n-    let mut i = 0u;\n+    let mut i = 0;\n     return\n         scan_until_char(line, ':', &mut i) &&\n         scan_char(line, ':', &mut i) &&\n@@ -1084,7 +1084,7 @@ fn scan_integer(haystack: &str, idx: &mut uint) -> bool {\n \n fn scan_string(haystack: &str, needle: &str, idx: &mut uint) -> bool {\n     let mut haystack_i = *idx;\n-    let mut needle_i = 0u;\n+    let mut needle_i = 0;\n     while needle_i < needle.len() {\n         if haystack_i >= haystack.len() {\n             return false;"}, {"sha": "62d103ae06a88fb20773326e8b6076e4d7ee9052", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -101,7 +101,7 @@ pub struct Arena {\n impl Arena {\n     /// Allocates a new Arena with 32 bytes preallocated.\n     pub fn new() -> Arena {\n-        Arena::new_with_size(32u)\n+        Arena::new_with_size(32)\n     }\n \n     /// Allocates a new Arena with `initial_size` bytes preallocated.\n@@ -117,7 +117,7 @@ impl Arena {\n fn chunk(size: uint, is_copy: bool) -> Chunk {\n     Chunk {\n         data: Rc::new(RefCell::new(Vec::with_capacity(size))),\n-        fill: Cell::new(0u),\n+        fill: Cell::new(0),\n         is_copy: Cell::new(is_copy),\n     }\n }\n@@ -193,7 +193,7 @@ impl Arena {\n         self.chunks.borrow_mut().push(self.copy_head.borrow().clone());\n \n         *self.copy_head.borrow_mut() =\n-            chunk((new_min_chunk_size + 1u).next_power_of_two(), true);\n+            chunk((new_min_chunk_size + 1).next_power_of_two(), true);\n \n         return self.alloc_copy_inner(n_bytes, align);\n     }\n@@ -234,7 +234,7 @@ impl Arena {\n         self.chunks.borrow_mut().push(self.head.borrow().clone());\n \n         *self.head.borrow_mut() =\n-            chunk((new_min_chunk_size + 1u).next_power_of_two(), false);\n+            chunk((new_min_chunk_size + 1).next_power_of_two(), false);\n \n         return self.alloc_noncopy_inner(n_bytes, align);\n     }\n@@ -308,7 +308,7 @@ impl Arena {\n #[test]\n fn test_arena_destructors() {\n     let arena = Arena::new();\n-    for i in 0u..10 {\n+    for i in 0..10 {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n         arena.alloc(|| Rc::new(i));\n@@ -337,7 +337,7 @@ fn test_arena_alloc_nested() {\n fn test_arena_destructors_fail() {\n     let arena = Arena::new();\n     // Put some stuff in the arena.\n-    for i in 0u..10 {\n+    for i in 0..10 {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n         arena.alloc(|| { Rc::new(i) });\n@@ -527,7 +527,7 @@ mod tests {\n     #[test]\n     pub fn test_copy() {\n         let arena = TypedArena::new();\n-        for _ in 0u..100000 {\n+        for _ in 0..100000 {\n             arena.alloc(Point {\n                 x: 1,\n                 y: 2,\n@@ -582,7 +582,7 @@ mod tests {\n     #[test]\n     pub fn test_noncopy() {\n         let arena = TypedArena::new();\n-        for _ in 0u..100000 {\n+        for _ in 0..100000 {\n             arena.alloc(Noncopy {\n                 string: \"hello world\".to_string(),\n                 array: vec!( 1, 2, 3, 4, 5 ),"}, {"sha": "4921a4470895a4b930b1990e4c7dbf44a225a359", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -138,14 +138,14 @@ mod tests {\n     fn test_flate_round_trip() {\n         let mut r = rand::thread_rng();\n         let mut words = vec!();\n-        for _ in 0u..20 {\n-            let range = r.gen_range(1u, 10);\n+        for _ in 0..20 {\n+            let range = r.gen_range(1, 10);\n             let v = r.gen_iter::<u8>().take(range).collect::<Vec<u8>>();\n             words.push(v);\n         }\n-        for _ in 0u..20 {\n+        for _ in 0..20 {\n             let mut input = vec![];\n-            for _ in 0u..2000 {\n+            for _ in 0..2000 {\n                 input.push_all(r.choose(words.as_slice()).unwrap().as_slice());\n             }\n             debug!(\"de/inflate of {} bytes of random word-sequences\","}, {"sha": "9cfd4933ac22980c9264f1f768ca7fd0ef6c61a2", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -227,8 +227,8 @@ pub type Result = result::Result<Matches, Fail>;\n \n impl Name {\n     fn from_str(nm: &str) -> Name {\n-        if nm.len() == 1u {\n-            Short(nm.char_at(0u))\n+        if nm.len() == 1 {\n+            Short(nm.char_at(0))\n         } else {\n             Long(nm.to_string())\n         }\n@@ -694,7 +694,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n         }\n         i += 1;\n     }\n-    for i in 0u..n_opts {\n+    for i in 0..n_opts {\n         let n = vals[i].len();\n         let occ = opts[i].occur;\n         if occ == Req && n == 0 {"}, {"sha": "b33ca3fd7ec01d35639341adc458458629b5351e", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -715,7 +715,7 @@ mod tests {\n \n     impl<'a> GraphWalk<'a, Node, &'a Edge> for LabelledGraph {\n         fn nodes(&'a self) -> Nodes<'a,Node> {\n-            (0u..self.node_labels.len()).collect()\n+            (0..self.node_labels.len()).collect()\n         }\n         fn edges(&'a self) -> Edges<'a,&'a Edge> {\n             self.edges.iter().collect()"}, {"sha": "c5ea10beb83c525303da145b09541e5870eecf44", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -1935,7 +1935,7 @@ pub mod types {\n                     pub iSecurityScheme: c_int,\n                     pub dwMessageSize: DWORD,\n                     pub dwProviderReserved: DWORD,\n-                    pub szProtocol: [u8; (WSAPROTOCOL_LEN as uint) + 1u],\n+                    pub szProtocol: [u8; (WSAPROTOCOL_LEN as uint) + 1us],\n                 }\n \n                 pub type LPWSAPROTOCOL_INFO = *mut WSAPROTOCOL_INFO;"}, {"sha": "4a9a9bd40600b73d736244b022a68a46cab331fb", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -24,7 +24,7 @@\n /// fn main() {\n ///     log!(log::WARN, \"this is a warning {}\", \"message\");\n ///     log!(log::DEBUG, \"this is a debug message\");\n-///     log!(6, \"this is a custom logging level: {level}\", level=6u);\n+///     log!(6, \"this is a custom logging level: {level}\", level=6);\n /// }\n /// ```\n ///\n@@ -70,7 +70,7 @@ macro_rules! log {\n /// #[macro_use] extern crate log;\n ///\n /// fn main() {\n-///     let error = 3u;\n+///     let error = 3;\n ///     error!(\"the build has failed with error code: {}\", error);\n /// }\n /// ```\n@@ -95,7 +95,7 @@ macro_rules! error {\n /// #[macro_use] extern crate log;\n ///\n /// fn main() {\n-///     let code = 3u;\n+///     let code = 3;\n ///     warn!(\"you may like to know that a process exited with: {}\", code);\n /// }\n /// ```"}, {"sha": "9f44f9debf6e2e9fb362b88c4f6903cbbf72036c", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -268,9 +268,9 @@ mod test {\n         // Store the 17*i-th 32-bit word,\n         // i.e., the i-th word of the i-th 16-word block\n         let mut v : Vec<u32> = Vec::new();\n-        for _ in 0u..16 {\n+        for _ in 0..16 {\n             v.push(ra.next_u32());\n-            for _ in 0u..16 {\n+            for _ in 0..16 {\n                 ra.next_u32();\n             }\n         }\n@@ -287,7 +287,7 @@ mod test {\n         let seed : &[_] = &[0u32; 8];\n         let mut rng: ChaChaRng = SeedableRng::from_seed(seed);\n         let mut clone = rng.clone();\n-        for _ in 0u..16 {\n+        for _ in 0..16 {\n             assert_eq!(rng.next_u64(), clone.next_u64());\n         }\n     }"}, {"sha": "e4927902cb3bb66184ad59f4c360818ee39491af", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -103,7 +103,7 @@ mod test {\n     fn test_exp() {\n         let mut exp = Exp::new(10.0);\n         let mut rng = ::test::rng();\n-        for _ in 0u..1000 {\n+        for _ in 0..1000 {\n             assert!(exp.sample(&mut rng) >= 0.0);\n             assert!(exp.ind_sample(&mut rng) >= 0.0);\n         }"}, {"sha": "38eba0cfc712f7221961113775972f80ad76cdc0", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -332,7 +332,7 @@ mod test {\n     fn test_chi_squared_one() {\n         let mut chi = ChiSquared::new(1.0);\n         let mut rng = ::test::rng();\n-        for _ in 0u..1000 {\n+        for _ in 0..1000 {\n             chi.sample(&mut rng);\n             chi.ind_sample(&mut rng);\n         }\n@@ -341,7 +341,7 @@ mod test {\n     fn test_chi_squared_small() {\n         let mut chi = ChiSquared::new(0.5);\n         let mut rng = ::test::rng();\n-        for _ in 0u..1000 {\n+        for _ in 0..1000 {\n             chi.sample(&mut rng);\n             chi.ind_sample(&mut rng);\n         }\n@@ -350,7 +350,7 @@ mod test {\n     fn test_chi_squared_large() {\n         let mut chi = ChiSquared::new(30.0);\n         let mut rng = ::test::rng();\n-        for _ in 0u..1000 {\n+        for _ in 0..1000 {\n             chi.sample(&mut rng);\n             chi.ind_sample(&mut rng);\n         }\n@@ -365,7 +365,7 @@ mod test {\n     fn test_f() {\n         let mut f = FisherF::new(2.0, 32.0);\n         let mut rng = ::test::rng();\n-        for _ in 0u..1000 {\n+        for _ in 0..1000 {\n             f.sample(&mut rng);\n             f.ind_sample(&mut rng);\n         }\n@@ -375,7 +375,7 @@ mod test {\n     fn test_t() {\n         let mut t = StudentT::new(11.0);\n         let mut rng = ::test::rng();\n-        for _ in 0u..1000 {\n+        for _ in 0..1000 {\n             t.sample(&mut rng);\n             t.ind_sample(&mut rng);\n         }"}, {"sha": "180248aa1560a5e1d20bbf63b47a7b812672d922", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -97,7 +97,7 @@ pub struct Weighted<T> {\n ///                      Weighted { weight: 1, item: 'c' });\n /// let wc = WeightedChoice::new(items.as_mut_slice());\n /// let mut rng = rand::thread_rng();\n-/// for _ in 0u..16 {\n+/// for _ in 0..16 {\n ///      // on average prints 'a' 4 times, 'b' 8 and 'c' twice.\n ///      println!(\"{}\", wc.ind_sample(&mut rng));\n /// }\n@@ -118,7 +118,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n         // strictly speaking, this is subsumed by the total weight == 0 case\n         assert!(!items.is_empty(), \"WeightedChoice::new called with no items\");\n \n-        let mut running_total = 0u;\n+        let mut running_total = 0;\n \n         // we convert the list from individual weights to cumulative\n         // weights so we can binary search. This *could* drop elements"}, {"sha": "83f202742d3f33da9dbdf016c32b1cbe541f93ce", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -169,7 +169,7 @@ mod tests {\n     fn test_normal() {\n         let mut norm = Normal::new(10.0, 10.0);\n         let mut rng = ::test::rng();\n-        for _ in 0u..1000 {\n+        for _ in 0..1000 {\n             norm.sample(&mut rng);\n             norm.ind_sample(&mut rng);\n         }\n@@ -185,7 +185,7 @@ mod tests {\n     fn test_log_normal() {\n         let mut lnorm = LogNormal::new(10.0, 10.0);\n         let mut rng = ::test::rng();\n-        for _ in 0u..1000 {\n+        for _ in 0..1000 {\n             lnorm.sample(&mut rng);\n             lnorm.ind_sample(&mut rng);\n         }"}, {"sha": "6eb1d68a081aa9d48632a383bfe0315d7f994214", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -38,10 +38,10 @@ use distributions::{Sample, IndependentSample};\n /// use std::rand::distributions::{IndependentSample, Range};\n ///\n /// fn main() {\n-///     let between = Range::new(10u, 10000u);\n+///     let between = Range::new(10, 10000);\n ///     let mut rng = std::rand::thread_rng();\n ///     let mut sum = 0;\n-///     for _ in 0u..1000 {\n+///     for _ in 0..1000 {\n ///         sum += between.ind_sample(&mut rng);\n ///     }\n ///     println!(\"{}\", sum);\n@@ -190,7 +190,7 @@ mod tests {\n                                             (Int::min_value(), Int::max_value())];\n                    for &(low, high) in v {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n-                        for _ in 0u..1000 {\n+                        for _ in 0..1000 {\n                             let v = sampler.sample(&mut rng);\n                             assert!(low <= v && v < high);\n                             let v = sampler.ind_sample(&mut rng);\n@@ -216,7 +216,7 @@ mod tests {\n                                             (-1e35, 1e35)];\n                    for &(low, high) in v {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n-                        for _ in 0u..1000 {\n+                        for _ in 0..1000 {\n                             let v = sampler.sample(&mut rng);\n                             assert!(low <= v && v < high);\n                             let v = sampler.ind_sample(&mut rng);"}, {"sha": "d399c244e83b8fe4ee8367dc2f56ac2f5b6bdcb4", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -82,7 +82,7 @@ impl IsaacRng {\n             }}\n         }\n \n-        for _ in 0u..4 {\n+        for _ in 0..4 {\n             mix!();\n         }\n \n@@ -166,7 +166,7 @@ impl IsaacRng {\n                 }}\n             }\n \n-            for i in range_step(0u, MIDPOINT, 4) {\n+            for i in range_step(0, MIDPOINT, 4) {\n                 rngstepp!(i + 0, 13);\n                 rngstepn!(i + 1, 6);\n                 rngstepp!(i + 2, 2);\n@@ -323,7 +323,7 @@ impl Isaac64Rng {\n             }}\n         }\n \n-        for _ in 0u..4 {\n+        for _ in 0..4 {\n             mix!();\n         }\n \n@@ -412,10 +412,10 @@ impl Isaac64Rng {\n                     }}\n                 }\n \n-                rngstepp!(0u, 21);\n-                rngstepn!(1u, 5);\n-                rngstepp!(2u, 12);\n-                rngstepn!(3u, 33);\n+                rngstepp!(0, 21);\n+                rngstepn!(1, 5);\n+                rngstepp!(2, 12);\n+                rngstepn!(3, 33);\n             }\n         }\n \n@@ -581,7 +581,7 @@ mod test {\n         let seed: &[_] = &[12345, 67890, 54321, 9876];\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n-        for _ in 0u..10000 { rb.next_u32(); }\n+        for _ in 0..10000 { rb.next_u32(); }\n \n         let v = (0..10).map(|_| rb.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n@@ -603,7 +603,7 @@ mod test {\n         let seed: &[_] = &[12345, 67890, 54321, 9876];\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n-        for _ in 0u..10000 { rb.next_u64(); }\n+        for _ in 0..10000 { rb.next_u64(); }\n \n         let v = (0..10).map(|_| rb.next_u64()).collect::<Vec<_>>();\n         assert_eq!(v,\n@@ -618,7 +618,7 @@ mod test {\n         let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut rng: Isaac64Rng = SeedableRng::from_seed(seed);\n         let mut clone = rng.clone();\n-        for _ in 0u..16 {\n+        for _ in 0..16 {\n             assert_eq!(rng.next_u64(), clone.next_u64());\n         }\n     }"}, {"sha": "afb5d0c6eaab185227c5ded016dd4593c2c8b820", "filename": "src/librand/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -222,7 +222,7 @@ pub trait Rng : Sized {\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n-    /// let n: uint = rng.gen_range(0u, 10);\n+    /// let n: uint = rng.gen_range(0, 10);\n     /// println!(\"{}\", n);\n     /// let m: f64 = rng.gen_range(-40.0f64, 1.3e5f64);\n     /// println!(\"{}\", m);\n@@ -278,7 +278,7 @@ pub trait Rng : Sized {\n         if values.is_empty() {\n             None\n         } else {\n-            Some(&values[self.gen_range(0u, values.len())])\n+            Some(&values[self.gen_range(0, values.len())])\n         }\n     }\n \n@@ -298,11 +298,11 @@ pub trait Rng : Sized {\n     /// ```\n     fn shuffle<T>(&mut self, values: &mut [T]) {\n         let mut i = values.len();\n-        while i >= 2u {\n+        while i >= 2 {\n             // invariant: elements with index >= i have been locked in place.\n-            i -= 1u;\n+            i -= 1;\n             // lock element i in place.\n-            values.swap(i, self.gen_range(0u, i + 1u));\n+            values.swap(i, self.gen_range(0, i + 1));\n         }\n     }\n }"}, {"sha": "d5c5d5004657e7facfdee32003e8ef9440d5a073", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -241,7 +241,7 @@ mod tests {\n         // this is unlikely to catch an incorrect implementation that\n         // generates exactly 0 or 1, but it keeps it sane.\n         let mut rng = thread_rng();\n-        for _ in 0u..1_000 {\n+        for _ in 0..1_000 {\n             // strict inequalities\n             let Open01(f) = rng.gen::<Open01<f64>>();\n             assert!(0.0 < f && f < 1.0);\n@@ -254,7 +254,7 @@ mod tests {\n     #[test]\n     fn rand_closed() {\n         let mut rng = thread_rng();\n-        for _ in 0u..1_000 {\n+        for _ in 0..1_000 {\n             // strict inequalities\n             let Closed01(f) = rng.gen::<Closed01<f64>>();\n             assert!(0.0 <= f && f <= 1.0);"}, {"sha": "26c7afc21eb9571dc6bf2485dedbbc1b13d66029", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -187,7 +187,7 @@ mod test {\n         let mut rs = ReseedingRng::new(Counter {i:0}, 400, ReseedWithDefault);\n \n         let mut i = 0;\n-        for _ in 0u..1000 {\n+        for _ in 0..1000 {\n             assert_eq!(rs.next_u32(), i % 100);\n             i += 1;\n         }"}, {"sha": "cf5397de149b7c4029a095160ab89b2e9cd89d93", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -56,7 +56,7 @@ pub struct Doc<'a> {\n \n impl<'doc> Doc<'doc> {\n     pub fn new(data: &'doc [u8]) -> Doc<'doc> {\n-        Doc { data: data, start: 0u, end: data.len() }\n+        Doc { data: data, start: 0, end: data.len() }\n     }\n \n     pub fn get<'a>(&'a self, tag: uint) -> Doc<'a> {\n@@ -170,25 +170,25 @@ pub mod reader {\n     fn vuint_at_slow(data: &[u8], start: uint) -> DecodeResult<Res> {\n         let a = data[start];\n         if a & 0x80u8 != 0u8 {\n-            return Ok(Res {val: (a & 0x7fu8) as uint, next: start + 1u});\n+            return Ok(Res {val: (a & 0x7fu8) as uint, next: start + 1});\n         }\n         if a & 0x40u8 != 0u8 {\n-            return Ok(Res {val: ((a & 0x3fu8) as uint) << 8u |\n-                        (data[start + 1u] as uint),\n-                    next: start + 2u});\n+            return Ok(Res {val: ((a & 0x3fu8) as uint) << 8 |\n+                        (data[start + 1] as uint),\n+                    next: start + 2});\n         }\n         if a & 0x20u8 != 0u8 {\n-            return Ok(Res {val: ((a & 0x1fu8) as uint) << 16u |\n-                        (data[start + 1u] as uint) << 8u |\n-                        (data[start + 2u] as uint),\n-                    next: start + 3u});\n+            return Ok(Res {val: ((a & 0x1fu8) as uint) << 16 |\n+                        (data[start + 1] as uint) << 8 |\n+                        (data[start + 2] as uint),\n+                    next: start + 3});\n         }\n         if a & 0x10u8 != 0u8 {\n-            return Ok(Res {val: ((a & 0x0fu8) as uint) << 24u |\n-                        (data[start + 1u] as uint) << 16u |\n-                        (data[start + 2u] as uint) << 8u |\n-                        (data[start + 3u] as uint),\n-                    next: start + 4u});\n+            return Ok(Res {val: ((a & 0x0fu8) as uint) << 24 |\n+                        (data[start + 1] as uint) << 16 |\n+                        (data[start + 2] as uint) << 8 |\n+                        (data[start + 3] as uint),\n+                    next: start + 4});\n         }\n         Err(IntTooBig(a as uint))\n     }\n@@ -225,7 +225,7 @@ pub mod reader {\n             let ptr = data.as_ptr().offset(start as int) as *const u32;\n             let val = Int::from_be(*ptr);\n \n-            let i = (val >> 28u) as uint;\n+            let i = (val >> 28) as uint;\n             let (shift, mask) = SHIFT_MASK_TABLE[i];\n             Ok(Res {\n                 val: ((val >> shift) & mask) as uint,\n@@ -311,23 +311,23 @@ pub mod reader {\n \n \n     pub fn doc_as_u8(d: Doc) -> u8 {\n-        assert_eq!(d.end, d.start + 1u);\n+        assert_eq!(d.end, d.start + 1);\n         d.data[d.start]\n     }\n \n     pub fn doc_as_u16(d: Doc) -> u16 {\n-        assert_eq!(d.end, d.start + 2u);\n-        u64_from_be_bytes(d.data, d.start, 2u) as u16\n+        assert_eq!(d.end, d.start + 2);\n+        u64_from_be_bytes(d.data, d.start, 2) as u16\n     }\n \n     pub fn doc_as_u32(d: Doc) -> u32 {\n-        assert_eq!(d.end, d.start + 4u);\n-        u64_from_be_bytes(d.data, d.start, 4u) as u32\n+        assert_eq!(d.end, d.start + 4);\n+        u64_from_be_bytes(d.data, d.start, 4) as u32\n     }\n \n     pub fn doc_as_u64(d: Doc) -> u64 {\n-        assert_eq!(d.end, d.start + 8u);\n-        u64_from_be_bytes(d.data, d.start, 8u)\n+        assert_eq!(d.end, d.start + 8);\n+        u64_from_be_bytes(d.data, d.start, 8)\n     }\n \n     pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n@@ -712,11 +712,11 @@ pub mod writer {\n \n     fn write_sized_vuint<W: Writer>(w: &mut W, n: uint, size: uint) -> EncodeResult {\n         match size {\n-            1u => w.write_all(&[0x80u8 | (n as u8)]),\n-            2u => w.write_all(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n-            3u => w.write_all(&[0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n+            1 => w.write_all(&[0x80u8 | (n as u8)]),\n+            2 => w.write_all(&[0x40u8 | ((n >> 8) as u8), n as u8]),\n+            3 => w.write_all(&[0x20u8 | ((n >> 16) as u8), (n >> 8_u) as u8,\n                             n as u8]),\n-            4u => w.write_all(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n+            4 => w.write_all(&[0x10u8 | ((n >> 24) as u8), (n >> 16_u) as u8,\n                             (n >> 8_u) as u8, n as u8]),\n             _ => Err(old_io::IoError {\n                 kind: old_io::OtherIoError,\n@@ -727,10 +727,10 @@ pub mod writer {\n     }\n \n     fn write_vuint<W: Writer>(w: &mut W, n: uint) -> EncodeResult {\n-        if n < 0x7f_u { return write_sized_vuint(w, n, 1u); }\n-        if n < 0x4000_u { return write_sized_vuint(w, n, 2u); }\n-        if n < 0x200000_u { return write_sized_vuint(w, n, 3u); }\n-        if n < 0x10000000_u { return write_sized_vuint(w, n, 4u); }\n+        if n < 0x7f { return write_sized_vuint(w, n, 1); }\n+        if n < 0x4000 { return write_sized_vuint(w, n, 2); }\n+        if n < 0x200000 { return write_sized_vuint(w, n, 3); }\n+        if n < 0x10000000 { return write_sized_vuint(w, n, 4); }\n         Err(old_io::IoError {\n             kind: old_io::OtherIoError,\n             desc: \"int too big\",\n@@ -772,7 +772,7 @@ pub mod writer {\n             let cur_pos = try!(self.writer.tell());\n             try!(self.writer.seek(last_size_pos as i64, old_io::SeekSet));\n             let size = cur_pos as uint - last_size_pos - 4;\n-            try!(write_sized_vuint(self.writer, size, 4u));\n+            try!(write_sized_vuint(self.writer, size, 4));\n             let r = try!(self.writer.seek(cur_pos as i64, old_io::SeekSet));\n \n             debug!(\"End tag (size = {:?})\", size);\n@@ -794,19 +794,19 @@ pub mod writer {\n         }\n \n         pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) -> EncodeResult {\n-            u64_to_be_bytes(v, 8u, |v| {\n+            u64_to_be_bytes(v, 8, |v| {\n                 self.wr_tagged_bytes(tag_id, v)\n             })\n         }\n \n         pub fn wr_tagged_u32(&mut self, tag_id: uint, v: u32)  -> EncodeResult{\n-            u64_to_be_bytes(v as u64, 4u, |v| {\n+            u64_to_be_bytes(v as u64, 4, |v| {\n                 self.wr_tagged_bytes(tag_id, v)\n             })\n         }\n \n         pub fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) -> EncodeResult {\n-            u64_to_be_bytes(v as u64, 2u, |v| {\n+            u64_to_be_bytes(v as u64, 2, |v| {\n                 self.wr_tagged_bytes(tag_id, v)\n             })\n         }\n@@ -816,19 +816,19 @@ pub mod writer {\n         }\n \n         pub fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) -> EncodeResult {\n-            u64_to_be_bytes(v as u64, 8u, |v| {\n+            u64_to_be_bytes(v as u64, 8, |v| {\n                 self.wr_tagged_bytes(tag_id, v)\n             })\n         }\n \n         pub fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) -> EncodeResult {\n-            u64_to_be_bytes(v as u64, 4u, |v| {\n+            u64_to_be_bytes(v as u64, 4, |v| {\n                 self.wr_tagged_bytes(tag_id, v)\n             })\n         }\n \n         pub fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) -> EncodeResult {\n-            u64_to_be_bytes(v as u64, 2u, |v| {\n+            u64_to_be_bytes(v as u64, 2, |v| {\n                 self.wr_tagged_bytes(tag_id, v)\n             })\n         }\n@@ -1190,7 +1190,7 @@ mod bench {\n               _ => i as u8,\n             }\n         }).collect::<Vec<_>>();\n-        let mut sum = 0u;\n+        let mut sum = 0;\n         b.iter(|| {\n             let mut i = 0;\n             while i < data.len() {\n@@ -1208,7 +1208,7 @@ mod bench {\n               _ => i as u8\n             }\n         }).collect::<Vec<_>>();\n-        let mut sum = 0u;\n+        let mut sum = 0;\n         b.iter(|| {\n             let mut i = 1;\n             while i < data.len() {\n@@ -1227,7 +1227,7 @@ mod bench {\n               _ => 0u8\n             }\n         }).collect::<Vec<_>>();\n-        let mut sum = 0u;\n+        let mut sum = 0;\n         b.iter(|| {\n             let mut i = 0;\n             while i < data.len() {\n@@ -1246,7 +1246,7 @@ mod bench {\n               _ => 0u8\n             }\n         }).collect::<Vec<_>>();\n-        let mut sum = 0u;\n+        let mut sum = 0;\n         b.iter(|| {\n             let mut i = 1;\n             while i < data.len() {"}, {"sha": "4b9064aaa05f9ecc8e6970457ed6062a00361b96", "filename": "src/librustc_back/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_back%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_back%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fabi.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub const BOX_FIELD_DROP_GLUE: uint = 1u;\n-pub const BOX_FIELD_BODY: uint = 4u;\n+pub const BOX_FIELD_DROP_GLUE: uint = 1;\n+pub const BOX_FIELD_BODY: uint = 4;\n \n /// The first half of a fat pointer.\n /// - For a closure, this is the code address.\n@@ -21,4 +21,4 @@ pub const FAT_PTR_ADDR: uint = 0;\n /// - For a closure, this is the address of the environment.\n /// - For an object or trait instance, this is the address of the vtable.\n /// - For a slice, this is the length.\n-pub const FAT_PTR_EXTRA: uint = 1u;\n+pub const FAT_PTR_EXTRA: uint = 1;"}, {"sha": "693c75cbbcc5d2d35a74e69bbae2c49f59295cdf", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -40,7 +40,7 @@ fn read_u32_be(input: &[u8]) -> u32 {\n /// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n     assert!(dst.len() * 4 == input.len());\n-    let mut pos = 0u;\n+    let mut pos = 0;\n     for chunk in input.chunks(4) {\n         dst[pos] = read_u32_be(chunk);\n         pos += 1;\n@@ -366,7 +366,7 @@ impl Engine256State {\n \n         // Putting the message schedule inside the same loop as the round calculations allows for\n         // the compiler to generate better code.\n-        for t in range_step(0u, 48, 8) {\n+        for t in range_step(0, 48, 8) {\n             schedule_round!(t + 16);\n             schedule_round!(t + 17);\n             schedule_round!(t + 18);\n@@ -386,7 +386,7 @@ impl Engine256State {\n             sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n         }\n \n-        for t in range_step(48u, 64, 8) {\n+        for t in range_step(48, 64, 8) {\n             sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n             sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n             sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);\n@@ -569,8 +569,8 @@ mod tests {\n             sh.reset();\n             let len = t.input.len();\n             let mut left = len;\n-            while left > 0u {\n-                let take = (left + 1u) / 2u;\n+            while left > 0 {\n+                let take = (left + 1) / 2;\n                 sh.input_str(&t.input[len - left..take + len - left]);\n                 left = left - take;\n             }"}, {"sha": "2823b2e9d74c3a30cc032938702bf50d2207fe92", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -103,7 +103,7 @@ impl Svh {\n \n         let hash = state.finish();\n         return Svh {\n-            hash: range_step(0u, 64u, 4u).map(|i| hex(hash >> i)).collect()\n+            hash: range_step(0, 64, 4).map(|i| hex(hash >> i)).collect()\n         };\n \n         fn hex(b: u64) -> char {"}, {"sha": "4fe037d852f49c715adf497772a746db53f146dd", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -126,7 +126,7 @@ fn run_compiler(args: &[String]) {\n     let odir = matches.opt_str(\"out-dir\").map(|o| Path::new(o));\n     let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n     let (input, input_file_path) = match matches.free.len() {\n-        0u => {\n+        0 => {\n             if sopts.describe_lints {\n                 let mut ls = lint::LintStore::new();\n                 ls.register_builtin(None);\n@@ -139,7 +139,7 @@ fn run_compiler(args: &[String]) {\n             }\n             early_error(\"no input filename given\");\n         }\n-        1u => {\n+        1 => {\n             let ifile = &matches.free[0][];\n             if ifile == \"-\" {\n                 let contents = old_io::stdin().read_to_end().unwrap();"}, {"sha": "ea7e59560cda9bb75dd22f7a2f607af10a03c6cb", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -399,7 +399,7 @@ impl UserIdentifiedItem {\n         };\n \n         let mut saw_node = ast::DUMMY_NODE_ID;\n-        let mut seen = 0u;\n+        let mut seen = 0;\n         for node in self.all_matching_node_ids(map) {\n             saw_node = node;\n             seen += 1;"}, {"sha": "d87039cbaefc18b4e3fabb0f8ee304ca57389f00", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -997,7 +997,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n     fn resolve_imports(&mut self) {\n-        let mut i = 0u;\n+        let mut i = 0;\n         let mut prev_unresolved_imports = 0;\n         loop {\n             debug!(\"(resolving imports) iteration {}, {} imports left\","}, {"sha": "1cfb019395870fa63ec47d6b6125f52dfc270764", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -347,9 +347,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let num_supplied_types = supplied_method_types.len();\n         let num_method_types = pick.method_ty.generics.types.len(subst::FnSpace);\n         let method_types = {\n-            if num_supplied_types == 0u {\n+            if num_supplied_types == 0 {\n                 self.fcx.infcx().next_ty_vars(num_method_types)\n-            } else if num_method_types == 0u {\n+            } else if num_method_types == 0 {\n                 span_err!(self.tcx().sess, self.span, E0035,\n                     \"does not take type parameters\");\n                 self.fcx.infcx().next_ty_vars(num_method_types)"}, {"sha": "7ec690b83d313d26ff8d027c1e2e3c74e799d2da", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -127,7 +127,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n                     span_note!(fcx.sess(), method_span,\n                                \"candidate #{} is defined in an impl{} for the type `{}`\",\n-                               idx + 1u,\n+                               idx + 1,\n                                insertion,\n                                impl_ty.user_string(fcx.tcx()));\n                 }\n@@ -136,7 +136,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     let method_span = fcx.tcx().map.def_id_span(method.def_id, span);\n                     span_note!(fcx.sess(), method_span,\n                                \"candidate #{} is defined in the trait `{}`\",\n-                               idx + 1u,\n+                               idx + 1,\n                                ty::item_path_str(fcx.tcx(), trait_did));\n                 }\n             }"}, {"sha": "07b67d543a87e4f21243c9ca9b17a55bf0b6aeb0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -5193,7 +5193,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n            tps.len(), ppaux::ty_to_string(ccx.tcx, ty));\n \n     // make a vector of booleans initially false, set to true when used\n-    if tps.len() == 0u { return; }\n+    if tps.len() == 0 { return; }\n     let mut tps_used: Vec<_> = repeat(false).take(tps.len()).collect();\n \n     ty::walk_ty(ty, |t| {\n@@ -5259,13 +5259,13 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         let (n_tps, inputs, output) = match name.get() {\n             \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n             \"size_of\" |\n-            \"pref_align_of\" | \"min_align_of\" => (1u, Vec::new(), ccx.tcx.types.uint),\n-            \"init\" => (1u, Vec::new(), param(ccx, 0)),\n-            \"uninit\" => (1u, Vec::new(), param(ccx, 0)),\n-            \"forget\" => (1u, vec!( param(ccx, 0) ), ty::mk_nil(tcx)),\n+            \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.uint),\n+            \"init\" => (1, Vec::new(), param(ccx, 0)),\n+            \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n+            \"forget\" => (1, vec!( param(ccx, 0) ), ty::mk_nil(tcx)),\n             \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),\n             \"move_val_init\" => {\n-                (1u,\n+                (1,\n                  vec!(\n                     ty::mk_mut_rptr(tcx,\n                                     tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n@@ -5275,8 +5275,8 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                   ),\n                ty::mk_nil(tcx))\n             }\n-            \"needs_drop\" => (1u, Vec::new(), ccx.tcx.types.bool),\n-            \"owns_managed\" => (1u, Vec::new(), ccx.tcx.types.bool),\n+            \"needs_drop\" => (1, Vec::new(), ccx.tcx.types.bool),\n+            \"owns_managed\" => (1, Vec::new(), ccx.tcx.types.bool),\n \n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n@@ -5287,9 +5287,9 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                   ty: tydesc_ty,\n                   mutbl: ast::MutImmutable\n               });\n-              (1u, Vec::new(), td_ptr)\n+              (1, Vec::new(), td_ptr)\n             }\n-            \"type_id\" => (1u, Vec::new(), ccx.tcx.types.u64),\n+            \"type_id\" => (1, Vec::new(), ccx.tcx.types.u64),\n             \"offset\" => {\n               (1,\n                vec!("}, {"sha": "d5baff3a0c4a37a0ba1cad683c2d2200576d0ae4", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -921,7 +921,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n            derefd_ty.repr(rcx.tcx()));\n \n     let r_deref_expr = ty::ReScope(CodeExtent::from_node_id(deref_expr.id));\n-    for i in 0u..derefs {\n+    for i in 0..derefs {\n         let method_call = MethodCall::autoderef(deref_expr.id, i);\n         debug!(\"constrain_autoderefs: method_call={:?} (of {:?} total)\", method_call, derefs);\n "}, {"sha": "be7abfe6aca3b7a8038fdac57c4590877c1684b6", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -36,7 +36,7 @@ impl<T:Decodable> Decodable for DList<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<DList<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut list = DList::new();\n-            for i in 0u..len {\n+            for i in 0..len {\n                 list.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n             Ok(list)\n@@ -59,7 +59,7 @@ impl<T:Decodable> Decodable for RingBuf<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<RingBuf<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut deque: RingBuf<T> = RingBuf::new();\n-            for i in 0u..len {\n+            for i in 0..len {\n                 deque.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n             Ok(deque)\n@@ -91,7 +91,7 @@ impl<\n     fn decode<D: Decoder>(d: &mut D) -> Result<BTreeMap<K, V>, D::Error> {\n         d.read_map(|d, len| {\n             let mut map = BTreeMap::new();\n-            for i in 0u..len {\n+            for i in 0..len {\n                 let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n                 let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n                 map.insert(key, val);\n@@ -122,7 +122,7 @@ impl<\n     fn decode<D: Decoder>(d: &mut D) -> Result<BTreeSet<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut set = BTreeSet::new();\n-            for i in 0u..len {\n+            for i in 0..len {\n                 set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n             Ok(set)\n@@ -186,7 +186,7 @@ impl<K, V, S> Decodable for HashMap<K, V, S>\n         d.read_map(|d, len| {\n             let state = Default::default();\n             let mut map = HashMap::with_capacity_and_hash_state(len, state);\n-            for i in 0u..len {\n+            for i in 0..len {\n                 let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n                 let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n                 map.insert(key, val);\n@@ -222,7 +222,7 @@ impl<T, S> Decodable for HashSet<T, S>\n         d.read_seq(|d, len| {\n             let state = Default::default();\n             let mut set = HashSet::with_capacity_and_hash_state(len, state);\n-            for i in 0u..len {\n+            for i in 0..len {\n                 set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n             Ok(set)\n@@ -246,7 +246,7 @@ impl<V: Decodable> Decodable for VecMap<V> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<VecMap<V>, D::Error> {\n         d.read_map(|d, len| {\n             let mut map = VecMap::new();\n-            for i in 0u..len {\n+            for i in 0..len {\n                 let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n                 let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n                 map.insert(key, val);"}, {"sha": "a3cc2d6b935d9fab31d9bea4d38968ea822132e1", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -185,14 +185,14 @@ mod tests {\n \n     #[test]\n     pub fn test_to_hex_all_bytes() {\n-        for i in 0u..256 {\n+        for i in 0..256 {\n             assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as uint));\n         }\n     }\n \n     #[test]\n     pub fn test_from_hex_all_bytes() {\n-        for i in 0u..256 {\n+        for i in 0..256 {\n             let ii: &[u8] = &[i as u8];\n             assert_eq!(format!(\"{:02x}\", i as uint).from_hex()\n                                                    .unwrap(),"}, {"sha": "4f62cca3c68c285fe1c70ff190c8cfe5cba1c6a5", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -457,8 +457,8 @@ fn spaces(wr: &mut fmt::Writer, mut n: uint) -> EncodeResult {\n fn fmt_number_or_null(v: f64) -> string::String {\n     match v.classify() {\n         Fp::Nan | Fp::Infinite => string::String::from_str(\"null\"),\n-        _ if v.fract() != 0f64 => f64::to_str_digits(v, 6u),\n-        _ => f64::to_str_digits(v, 6u) + \".0\",\n+        _ if v.fract() != 0f64 => f64::to_str_digits(v, 6),\n+        _ => f64::to_str_digits(v, 6) + \".0\",\n     }\n }\n \n@@ -1474,10 +1474,10 @@ impl<T: Iterator<Item=char>> Parser<T> {\n         self.ch = self.rdr.next();\n \n         if self.ch_is('\\n') {\n-            self.line += 1u;\n-            self.col = 1u;\n+            self.line += 1;\n+            self.col = 1;\n         } else {\n-            self.col += 1u;\n+            self.col += 1;\n         }\n     }\n \n@@ -1614,7 +1614,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n     fn parse_exponent(&mut self, mut res: f64) -> Result<f64, ParserError> {\n         self.bump();\n \n-        let mut exp = 0u;\n+        let mut exp = 0;\n         let mut neg_exp = false;\n \n         if self.ch_is('+') {\n@@ -1652,7 +1652,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n     }\n \n     fn decode_hex_escape(&mut self) -> Result<u16, ParserError> {\n-        let mut i = 0u;\n+        let mut i = 0;\n         let mut n = 0u16;\n         while i < 4 && !self.eof() {\n             self.bump();\n@@ -1667,7 +1667,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n                 _ => return self.error(InvalidEscape)\n             };\n \n-            i += 1u;\n+            i += 1;\n         }\n \n         // Error out if we didn't parse 4 digits.\n@@ -2638,7 +2638,7 @@ mod tests {\n     fn test_decode_option_some() {\n         let s = \"{ \\\"opt\\\": 10 }\";\n         let obj: OptionData = super::decode(s).unwrap();\n-        assert_eq!(obj, OptionData { opt: Some(10u) });\n+        assert_eq!(obj, OptionData { opt: Some(10) });\n     }\n \n     #[test]\n@@ -3092,10 +3092,10 @@ mod tests {\n     #[test]\n     fn test_decode_tuple() {\n         let t: (uint, uint, uint) = super::decode(\"[1, 2, 3]\").unwrap();\n-        assert_eq!(t, (1u, 2, 3));\n+        assert_eq!(t, (1, 2, 3));\n \n         let t: (uint, string::String) = super::decode(\"[1, \\\"two\\\"]\").unwrap();\n-        assert_eq!(t, (1u, \"two\".to_string()));\n+        assert_eq!(t, (1, \"two\".to_string()));\n     }\n \n     #[test]\n@@ -3228,7 +3228,7 @@ mod tests {\n     #[test]\n     fn test_multiline_errors() {\n         assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),\n-            Err(SyntaxError(EOFWhileParsingObject, 3u, 8u)));\n+            Err(SyntaxError(EOFWhileParsingObject, 3, 8)));\n     }\n \n     #[derive(RustcDecodable)]\n@@ -3512,7 +3512,7 @@ mod tests {\n         }\n \n         // Test up to 4 spaces of indents (more?)\n-        for i in 0..4u {\n+        for i in 0..4 {\n             let mut writer = Vec::new();\n             write!(&mut writer, \"{}\",\n                    super::as_pretty_json(&json).indent(i)).unwrap();\n@@ -3924,22 +3924,22 @@ mod tests {\n         assert_eq!(false.to_json(), Boolean(false));\n         assert_eq!(\"abc\".to_json(), String(\"abc\".to_string()));\n         assert_eq!(\"abc\".to_string().to_json(), String(\"abc\".to_string()));\n-        assert_eq!((1u, 2u).to_json(), array2);\n-        assert_eq!((1u, 2u, 3u).to_json(), array3);\n-        assert_eq!([1u, 2].to_json(), array2);\n-        assert_eq!((&[1u, 2, 3]).to_json(), array3);\n-        assert_eq!((vec![1u, 2]).to_json(), array2);\n-        assert_eq!(vec!(1u, 2, 3).to_json(), array3);\n+        assert_eq!((1us, 2us).to_json(), array2);\n+        assert_eq!((1us, 2us, 3us).to_json(), array3);\n+        assert_eq!([1us, 2us].to_json(), array2);\n+        assert_eq!((&[1us, 2us, 3us]).to_json(), array3);\n+        assert_eq!((vec![1us, 2us]).to_json(), array2);\n+        assert_eq!(vec!(1us, 2us, 3us).to_json(), array3);\n         let mut tree_map = BTreeMap::new();\n-        tree_map.insert(\"a\".to_string(), 1u);\n+        tree_map.insert(\"a\".to_string(), 1us);\n         tree_map.insert(\"b\".to_string(), 2);\n         assert_eq!(tree_map.to_json(), object);\n         let mut hash_map = HashMap::new();\n-        hash_map.insert(\"a\".to_string(), 1u);\n+        hash_map.insert(\"a\".to_string(), 1us);\n         hash_map.insert(\"b\".to_string(), 2);\n         assert_eq!(hash_map.to_json(), object);\n         assert_eq!(Some(15).to_json(), I64(15));\n-        assert_eq!(Some(15u).to_json(), U64(15));\n+        assert_eq!(Some(15us).to_json(), U64(15));\n         assert_eq!(None::<int>.to_json(), Null);\n     }\n "}, {"sha": "3d7c91ad1885925e82bd9500a41ebdca3714f6d1", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -498,7 +498,7 @@ macro_rules! peel {\n \n /// Evaluates to the number of identifiers passed to it, for example: `count_idents!(a, b, c) == 3\n macro_rules! count_idents {\n-    () => { 0u };\n+    () => { 0 };\n     ($_i:ident, $($rest:ident,)*) => { 1 + count_idents!($($rest,)*) }\n }\n "}, {"sha": "c369e354875b5be7367c14d9817fc4ebbca53f73", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -464,14 +464,14 @@ impl<T: Writer> ConsoleTestState<T> {\n             out: out,\n             log_out: log_out,\n             use_color: use_color(opts),\n-            total: 0u,\n-            passed: 0u,\n-            failed: 0u,\n-            ignored: 0u,\n-            measured: 0u,\n+            total: 0,\n+            passed: 0,\n+            failed: 0,\n+            ignored: 0,\n+            measured: 0,\n             metrics: MetricMap::new(),\n             failures: Vec::new(),\n-            max_name_len: 0u,\n+            max_name_len: 0,\n         })\n     }\n \n@@ -601,7 +601,7 @@ impl<T: Writer> ConsoleTestState<T> {\n     pub fn write_run_finish(&mut self) -> old_io::IoResult<bool> {\n         assert!(self.passed + self.failed + self.ignored + self.measured == self.total);\n \n-        let success = self.failed == 0u;\n+        let success = self.failed == 0;\n         if !success {\n             try!(self.write_failures());\n         }\n@@ -679,7 +679,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> old_io:\n     let mut st = try!(ConsoleTestState::new(opts, None::<StdWriter>));\n     fn len_if_padded(t: &TestDescAndFn) -> uint {\n         match t.testfn.padding() {\n-            PadNone => 0u,\n+            PadNone => 0,\n             PadOnLeft | PadOnRight => t.desc.name.as_slice().len(),\n         }\n     }\n@@ -712,12 +712,12 @@ fn should_sort_failures_before_printing_them() {\n         log_out: None,\n         out: Raw(Vec::new()),\n         use_color: false,\n-        total: 0u,\n-        passed: 0u,\n-        failed: 0u,\n-        ignored: 0u,\n-        measured: 0u,\n-        max_name_len: 10u,\n+        total: 0,\n+        passed: 0,\n+        failed: 0,\n+        ignored: 0,\n+        measured: 0,\n+        max_name_len: 10,\n         metrics: MetricMap::new(),\n         failures: vec!((test_b, Vec::new()), (test_a, Vec::new()))\n     };"}, {"sha": "ff8246a0e3f875023ab849f72790febd4a6bfd62", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336c8d2e9c6b276b162bdb3edd43706372e6eddd/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=336c8d2e9c6b276b162bdb3edd43706372e6eddd", "patch": "@@ -153,7 +153,7 @@ impl<'a> Iterator for Graphemes<'a> {\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         let slen = self.string.len();\n-        (cmp::min(slen, 1u), Some(slen))\n+        (cmp::min(slen, 1), Some(slen))\n     }\n \n     #[inline]"}]}