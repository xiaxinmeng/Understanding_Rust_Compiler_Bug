{"sha": "dae8864dbe1b81e4cd3b2a6b046a95db337b3098", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZTg4NjRkYmUxYjgxZTRjZDNiMmE2YjA0NmE5NWRiMzM3YjMwOTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-04T15:03:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-04T15:03:00Z"}, "message": "Auto merge of #43600 - scalexm:issue-35976, r=nikomatsakis\n\nAdd a more precise error message for issue #35976\n\nWhen trying to perform static dispatch on something which derefs to a trait object, and the target trait is not in scope, we had confusing error messages if the target method had a `Self: Sized` bound. We add a more precise error message in this case: \"consider using trait ...\".\n\nFixes #35976.\n\nr? @nikomatsakis", "tree": {"sha": "dba045764cfc1edd13ab4d60866110e8836f20e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dba045764cfc1edd13ab4d60866110e8836f20e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dae8864dbe1b81e4cd3b2a6b046a95db337b3098", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dae8864dbe1b81e4cd3b2a6b046a95db337b3098", "html_url": "https://github.com/rust-lang/rust/commit/dae8864dbe1b81e4cd3b2a6b046a95db337b3098", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dae8864dbe1b81e4cd3b2a6b046a95db337b3098/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2a5af7a4c7424acc9acc52161fb57210a4bb219", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2a5af7a4c7424acc9acc52161fb57210a4bb219", "html_url": "https://github.com/rust-lang/rust/commit/f2a5af7a4c7424acc9acc52161fb57210a4bb219"}, {"sha": "e7e620d0cc4ca1a971d8381a65e64efd5b66e489", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7e620d0cc4ca1a971d8381a65e64efd5b66e489", "html_url": "https://github.com/rust-lang/rust/commit/e7e620d0cc4ca1a971d8381a65e64efd5b66e489"}], "stats": {"total": 278, "additions": 229, "deletions": 49}, "files": [{"sha": "eef0bcc375358050d86e52cd8ada0e7905695996", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dae8864dbe1b81e4cd3b2a6b046a95db337b3098/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae8864dbe1b81e4cd3b2a6b046a95db337b3098/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=dae8864dbe1b81e4cd3b2a6b046a95db337b3098", "patch": "@@ -160,7 +160,7 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct AssociatedItem {\n     pub def_id: DefId,\n     pub name: Name,"}, {"sha": "b6a5ce0a6ce5adeef49a88d7733fa6a329da2ea0", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 48, "deletions": 5, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/dae8864dbe1b81e4cd3b2a6b046a95db337b3098/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae8864dbe1b81e4cd3b2a6b046a95db337b3098/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=dae8864dbe1b81e4cd3b2a6b046a95db337b3098", "patch": "@@ -38,6 +38,11 @@ impl<'a, 'gcx, 'tcx> Deref for ConfirmContext<'a, 'gcx, 'tcx> {\n     }\n }\n \n+pub struct ConfirmResult<'tcx> {\n+    pub callee: MethodCallee<'tcx>,\n+    pub illegal_sized_bound: bool,\n+}\n+\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn confirm_method(&self,\n                           span: Span,\n@@ -46,7 +51,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           unadjusted_self_ty: Ty<'tcx>,\n                           pick: probe::Pick<'tcx>,\n                           segment: &hir::PathSegment)\n-                          -> MethodCallee<'tcx> {\n+                          -> ConfirmResult<'tcx> {\n         debug!(\"confirm(unadjusted_self_ty={:?}, pick={:?}, generic_args={:?})\",\n                unadjusted_self_ty,\n                pick,\n@@ -75,7 +80,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                unadjusted_self_ty: Ty<'tcx>,\n                pick: probe::Pick<'tcx>,\n                segment: &hir::PathSegment)\n-               -> MethodCallee<'tcx> {\n+               -> ConfirmResult<'tcx> {\n         // Adjust the self expression the user provided and obtain the adjusted type.\n         let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick);\n \n@@ -91,12 +96,26 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // Create the final signature for the method, replacing late-bound regions.\n         let (method_sig, method_predicates) = self.instantiate_method_sig(&pick, all_substs);\n \n+        // If there is a `Self: Sized` bound and `Self` is a trait object, it is possible that\n+        // something which derefs to `Self` actually implements the trait and the caller\n+        // wanted to make a static dispatch on it but forgot to import the trait.\n+        // See test `src/test/ui/issue-35976.rs`.\n+        //\n+        // In that case, we'll error anyway, but we'll also re-run the search with all traits\n+        // in scope, and if we find another method which can be used, we'll output an\n+        // appropriate hint suggesting to import the trait.\n+        let illegal_sized_bound = self.predicates_require_illegal_sized_bound(&method_predicates);\n+\n         // Unify the (adjusted) self type with what the method expects.\n         self.unify_receivers(self_ty, method_sig.inputs()[0]);\n \n         // Add any trait/regions obligations specified on the method's type parameters.\n-        let method_ty = self.tcx.mk_fn_ptr(ty::Binder(method_sig));\n-        self.add_obligations(method_ty, all_substs, &method_predicates);\n+        // We won't add these if we encountered an illegal sized bound, so that we can use\n+        // a custom error in that case.\n+        if !illegal_sized_bound {\n+            let method_ty = self.tcx.mk_fn_ptr(ty::Binder(method_sig));\n+            self.add_obligations(method_ty, all_substs, &method_predicates);\n+        }\n \n         // Create the final `MethodCallee`.\n         let callee = MethodCallee {\n@@ -109,7 +128,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             self.convert_lvalue_derefs_to_mutable();\n         }\n \n-        callee\n+        ConfirmResult { callee, illegal_sized_bound }\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -533,6 +552,30 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n \n+    fn predicates_require_illegal_sized_bound(&self,\n+                                              predicates: &ty::InstantiatedPredicates<'tcx>)\n+                                              -> bool {\n+        let sized_def_id = match self.tcx.lang_items.sized_trait() {\n+            Some(def_id) => def_id,\n+            None => return false,\n+        };\n+\n+        traits::elaborate_predicates(self.tcx, predicates.predicates.clone())\n+            .filter_map(|predicate| {\n+                match predicate {\n+                    ty::Predicate::Trait(trait_pred) if trait_pred.def_id() == sized_def_id =>\n+                        Some(trait_pred),\n+                    _ => None,\n+                }\n+            })\n+            .any(|trait_pred| {\n+                match trait_pred.0.self_ty().sty {\n+                    ty::TyDynamic(..) => true,\n+                    _ => false,\n+                }\n+            })\n+    }\n+\n     fn enforce_illegal_method_limitations(&self, pick: &probe::Pick) {\n         // Disallow calls to the method `drop` defined in the `Drop` trait.\n         match pick.item.container {"}, {"sha": "dd5b0cdda42447233e639ef8e535e12d48efb0e9", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 65, "deletions": 13, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/dae8864dbe1b81e4cd3b2a6b046a95db337b3098/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae8864dbe1b81e4cd3b2a6b046a95db337b3098/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=dae8864dbe1b81e4cd3b2a6b046a95db337b3098", "patch": "@@ -33,7 +33,7 @@ mod confirm;\n pub mod probe;\n mod suggest;\n \n-use self::probe::IsSuggestion;\n+use self::probe::{IsSuggestion, ProbeScope};\n \n #[derive(Clone, Copy, Debug)]\n pub struct MethodCallee<'tcx> {\n@@ -60,6 +60,10 @@ pub enum MethodError<'tcx> {\n \n     // Found an applicable method, but it is not visible.\n     PrivateMatch(Def),\n+\n+    // Found a `Self: Sized` bound where `Self` is a trait object, also the caller may have\n+    // forgotten to import a trait.\n+    IllegalSizedBound(Vec<DefId>),\n }\n \n // Contains a list of static methods that may apply, a list of unsatisfied trait predicates which\n@@ -106,12 +110,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          -> bool {\n         let mode = probe::Mode::MethodCall;\n         match self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n-                                  self_ty, call_expr_id) {\n+                                  self_ty, call_expr_id, ProbeScope::TraitsInScope) {\n             Ok(..) => true,\n             Err(NoMatch(..)) => false,\n             Err(Ambiguity(..)) => true,\n             Err(ClosureAmbiguity(..)) => true,\n             Err(PrivateMatch(..)) => allow_private,\n+            Err(IllegalSizedBound(..)) => true,\n         }\n     }\n \n@@ -142,10 +147,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                call_expr,\n                self_expr);\n \n-        let mode = probe::Mode::MethodCall;\n-        let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n-        let pick = self.probe_for_name(span, mode, segment.name, IsSuggestion(false),\n-                                       self_ty, call_expr.id)?;\n+        let pick = self.lookup_probe(\n+            span,\n+            segment.name,\n+            self_ty,\n+            call_expr,\n+            ProbeScope::TraitsInScope\n+        )?;\n \n         if let Some(import_id) = pick.import_id {\n             let import_def_id = self.tcx.hir.local_def_id(import_id);\n@@ -155,12 +163,56 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         self.tcx.check_stability(pick.item.def_id, call_expr.id, span);\n \n-        Ok(self.confirm_method(span,\n-                               self_expr,\n-                               call_expr,\n-                               self_ty,\n-                               pick,\n-                               segment))\n+        let result = self.confirm_method(span,\n+                                         self_expr,\n+                                         call_expr,\n+                                         self_ty,\n+                                         pick.clone(),\n+                                         segment);\n+\n+        if result.illegal_sized_bound {\n+            // We probe again, taking all traits into account (not only those in scope).\n+            let candidates =\n+                match self.lookup_probe(span,\n+                                        segment.name,\n+                                        self_ty,\n+                                        call_expr,\n+                                        ProbeScope::AllTraits) {\n+\n+                    // If we find a different result the caller probably forgot to import a trait.\n+                    Ok(ref new_pick) if *new_pick != pick => vec![new_pick.item.container.id()],\n+                    Err(Ambiguity(ref sources)) => {\n+                        sources.iter()\n+                               .filter_map(|source| {\n+                                   match *source {\n+                                       // Note: this cannot come from an inherent impl,\n+                                       // because the first probing succeeded.\n+                                       ImplSource(def) => self.tcx.trait_id_of_impl(def),\n+                                       TraitSource(_) => None,\n+                                   }\n+                               })\n+                               .collect()\n+                    }\n+                    _ => Vec::new(),\n+                };\n+\n+            return Err(IllegalSizedBound(candidates));\n+        }\n+\n+        Ok(result.callee)\n+    }\n+\n+    fn lookup_probe(&self,\n+                    span: Span,\n+                    method_name: ast::Name,\n+                    self_ty: ty::Ty<'tcx>,\n+                    call_expr: &'gcx hir::Expr,\n+                    scope: ProbeScope)\n+                    -> probe::PickResult<'tcx> {\n+        let mode = probe::Mode::MethodCall;\n+        let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n+        self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n+                            self_ty, call_expr.id, scope)\n     }\n \n     /// `lookup_method_in_trait` is used for overloaded operators.\n@@ -299,7 +351,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         -> Result<Def, MethodError<'tcx>> {\n         let mode = probe::Mode::Path;\n         let pick = self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n-                                       self_ty, expr_id)?;\n+                                       self_ty, expr_id, ProbeScope::TraitsInScope)?;\n \n         if let Some(import_id) = pick.import_id {\n             let import_def_id = self.tcx.hir.local_def_id(import_id);"}, {"sha": "3195b10404d1ca8299e316217707d915f045bb33", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dae8864dbe1b81e4cd3b2a6b046a95db337b3098/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae8864dbe1b81e4cd3b2a6b046a95db337b3098/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=dae8864dbe1b81e4cd3b2a6b046a95db337b3098", "patch": "@@ -106,7 +106,7 @@ enum CandidateKind<'tcx> {\n                          ty::PolyTraitRef<'tcx>),\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, PartialEq, Eq, Clone)]\n pub struct Pick<'tcx> {\n     pub item: ty::AssociatedItem,\n     pub kind: PickKind<'tcx>,\n@@ -130,7 +130,7 @@ pub struct Pick<'tcx> {\n     pub unsize: Option<Ty<'tcx>>,\n }\n \n-#[derive(Clone,Debug)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub enum PickKind<'tcx> {\n     InherentImplPick,\n     ExtensionImplPick(// Impl\n@@ -155,6 +155,15 @@ pub enum Mode {\n     Path,\n }\n \n+#[derive(PartialEq, Eq, Copy, Clone, Debug)]\n+pub enum ProbeScope {\n+    // Assemble candidates coming only from traits in scope.\n+    TraitsInScope,\n+\n+    // Assemble candidates coming from all traits.\n+    AllTraits,\n+}\n+\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// This is used to offer suggestions to users. It returns methods\n     /// that could have been called which have the desired return\n@@ -175,14 +184,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                scope_expr_id);\n         let method_names =\n             self.probe_op(span, mode, LookingFor::ReturnType(return_type), IsSuggestion(true),\n-                          self_ty, scope_expr_id,\n+                          self_ty, scope_expr_id, ProbeScope::TraitsInScope,\n                           |probe_cx| Ok(probe_cx.candidate_method_names()))\n                 .unwrap_or(vec![]);\n         method_names\n             .iter()\n             .flat_map(|&method_name| {\n                 match self.probe_for_name(span, mode, method_name, IsSuggestion(true), self_ty,\n-                                          scope_expr_id) {\n+                                          scope_expr_id, ProbeScope::TraitsInScope) {\n                     Ok(pick) => Some(pick.item),\n                     Err(_) => None,\n                 }\n@@ -196,7 +205,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           item_name: ast::Name,\n                           is_suggestion: IsSuggestion,\n                           self_ty: Ty<'tcx>,\n-                          scope_expr_id: ast::NodeId)\n+                          scope_expr_id: ast::NodeId,\n+                          scope: ProbeScope)\n                           -> PickResult<'tcx> {\n         debug!(\"probe(self_ty={:?}, item_name={}, scope_expr_id={})\",\n                self_ty,\n@@ -208,6 +218,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       is_suggestion,\n                       self_ty,\n                       scope_expr_id,\n+                      scope,\n                       |probe_cx| probe_cx.pick())\n     }\n \n@@ -218,6 +229,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       is_suggestion: IsSuggestion,\n                       self_ty: Ty<'tcx>,\n                       scope_expr_id: ast::NodeId,\n+                      scope: ProbeScope,\n                       op: OP)\n                       -> Result<R, MethodError<'tcx>>\n         where OP: FnOnce(ProbeContext<'a, 'gcx, 'tcx>) -> Result<R, MethodError<'tcx>>\n@@ -275,8 +287,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let mut probe_cx =\n                 ProbeContext::new(self, span, mode, looking_for,\n                                   steps, opt_simplified_steps);\n+\n             probe_cx.assemble_inherent_candidates();\n-            probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id)?;\n+            match scope {\n+                ProbeScope::TraitsInScope =>\n+                    probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id)?,\n+                ProbeScope::AllTraits =>\n+                    probe_cx.assemble_extension_candidates_for_all_traits()?,\n+            };\n             op(probe_cx)\n         })\n     }"}, {"sha": "c480febdec66f5c35be501f629ea8e409d4e7454", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 49, "deletions": 24, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/dae8864dbe1b81e4cd3b2a6b046a95db337b3098/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae8864dbe1b81e4cd3b2a6b046a95db337b3098/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=dae8864dbe1b81e4cd3b2a6b046a95db337b3098", "patch": "@@ -315,7 +315,42 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let msg = format!(\"{} `{}` is private\", def.kind_name(), item_name);\n                 self.tcx.sess.span_err(span, &msg);\n             }\n+\n+            MethodError::IllegalSizedBound(candidates) => {\n+                let msg = format!(\"the `{}` method cannot be invoked on a trait object\", item_name);\n+                let mut err = self.sess().struct_span_err(span, &msg);\n+                if !candidates.is_empty() {\n+                    let help = format!(\"{an}other candidate{s} {were} found in the following \\\n+                                        trait{s}, perhaps add a `use` for {one_of_them}:\",\n+                                    an = if candidates.len() == 1 {\"an\" } else { \"\" },\n+                                    s = if candidates.len() == 1 { \"\" } else { \"s\" },\n+                                    were = if candidates.len() == 1 { \"was\" } else { \"were\" },\n+                                    one_of_them = if candidates.len() == 1 {\n+                                        \"it\"\n+                                    } else {\n+                                        \"one_of_them\"\n+                                    });\n+                    self.suggest_use_candidates(&mut err, help, candidates);\n+                }\n+                err.emit();\n+            }\n+        }\n+    }\n+\n+    fn suggest_use_candidates(&self,\n+                              err: &mut DiagnosticBuilder,\n+                              mut msg: String,\n+                              candidates: Vec<DefId>) {\n+        let limit = if candidates.len() == 5 { 5 } else { 4 };\n+        for (i, trait_did) in candidates.iter().take(limit).enumerate() {\n+            msg.push_str(&format!(\"\\ncandidate #{}: `use {};`\",\n+                                    i + 1,\n+                                    self.tcx.item_path_str(*trait_did)));\n+        }\n+        if candidates.len() > limit {\n+            msg.push_str(&format!(\"\\nand {} others\", candidates.len() - limit));\n         }\n+        err.note(&msg[..]);\n     }\n \n     fn suggest_traits_to_import(&self,\n@@ -330,30 +365,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             candidates.sort();\n             candidates.dedup();\n             err.help(\"items from traits can only be used if the trait is in scope\");\n-            let mut msg = format!(\"the following {traits_are} implemented but not in scope, \\\n-                                   perhaps add a `use` for {one_of_them}:\",\n-                              traits_are = if candidates.len() == 1 {\n-                                  \"trait is\"\n-                              } else {\n-                                  \"traits are\"\n-                              },\n-                              one_of_them = if candidates.len() == 1 {\n-                                  \"it\"\n-                              } else {\n-                                  \"one of them\"\n-                              });\n-\n-            let limit = if candidates.len() == 5 { 5 } else { 4 };\n-            for (i, trait_did) in candidates.iter().take(limit).enumerate() {\n-                msg.push_str(&format!(\"\\ncandidate #{}: `use {};`\",\n-                                      i + 1,\n-                                      self.tcx.item_path_str(*trait_did)));\n-            }\n-            if candidates.len() > limit {\n-                msg.push_str(&format!(\"\\nand {} others\", candidates.len() - limit));\n-            }\n-            err.note(&msg[..]);\n-\n+            let msg = format!(\"the following {traits_are} implemented but not in scope, \\\n+                               perhaps add a `use` for {one_of_them}:\",\n+                            traits_are = if candidates.len() == 1 {\n+                                \"trait is\"\n+                            } else {\n+                                \"traits are\"\n+                            },\n+                            one_of_them = if candidates.len() == 1 {\n+                                \"it\"\n+                            } else {\n+                                \"one of them\"\n+                            });\n+\n+            self.suggest_use_candidates(err, msg, candidates);\n             return;\n         }\n "}, {"sha": "169d7b55916706e45a43af982a9e64cca5785abd", "filename": "src/test/ui/issue-35976.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/dae8864dbe1b81e4cd3b2a6b046a95db337b3098/src%2Ftest%2Fui%2Fissue-35976.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dae8864dbe1b81e4cd3b2a6b046a95db337b3098/src%2Ftest%2Fui%2Fissue-35976.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-35976.rs?ref=dae8864dbe1b81e4cd3b2a6b046a95db337b3098", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod private {\n+    pub trait Future {\n+        fn wait(&self) where Self: Sized;\n+    }\n+\n+    impl Future for Box<Future> {\n+        fn wait(&self) { }\n+    }\n+}\n+\n+//use private::Future;\n+\n+fn bar(arg: Box<private::Future>) {\n+    arg.wait();\n+    //~^ ERROR the `wait` method cannot be invoked on a trait object\n+    //~| another candidate was found in the following trait, perhaps add a `use` for it:\n+}\n+\n+fn main() {\n+\n+}"}, {"sha": "9fb67449734bc6615ed592cd99f84d27c93d0d2a", "filename": "src/test/ui/issue-35976.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dae8864dbe1b81e4cd3b2a6b046a95db337b3098/src%2Ftest%2Fui%2Fissue-35976.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dae8864dbe1b81e4cd3b2a6b046a95db337b3098/src%2Ftest%2Fui%2Fissue-35976.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-35976.stderr?ref=dae8864dbe1b81e4cd3b2a6b046a95db337b3098", "patch": "@@ -0,0 +1,11 @@\n+error: the `wait` method cannot be invoked on a trait object\n+  --> $DIR/issue-35976.rs:24:9\n+   |\n+24 |     arg.wait();\n+   |         ^^^^\n+   |\n+   = note: another candidate was found in the following trait, perhaps add a `use` for it:\n+           candidate #1: `use private::Future;`\n+\n+error: aborting due to previous error\n+"}]}