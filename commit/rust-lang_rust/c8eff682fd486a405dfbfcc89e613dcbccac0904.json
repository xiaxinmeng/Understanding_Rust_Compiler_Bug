{"sha": "c8eff682fd486a405dfbfcc89e613dcbccac0904", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4ZWZmNjgyZmQ0ODZhNDA1ZGZiZmNjODllNjEzZGNiY2NhYzA5MDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-17T10:36:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-17T10:36:32Z"}, "message": "Auto merge of #33090 - bluss:special-zip-2, r=aturon\n\nSpecialize .zip() for efficient slice and slice iteration\n\nThe idea is to introduce a private trait TrustedRandomAccess and specialize .zip() for random access iterators into a counted loop.\n\nThe implementation in the PR is internal and has no visible effect in the API\n\nWhy a counted loop? To have each slice iterator compile to just a pointer, and both pointers are indexed with the same loop counter value in the generated code. When this succeeds, copying loops are readily recognized and replaced with memcpy and addition loops autovectorize well.\n\nThe TrustedRandomAccess approach works very well on the surface. Microbenchmarks optimize well, following the ideas above, and that is a dramatic improvement of .zip()'s codegen.\n\n```rust\n// old zip before this PR: bad, byte-for-byte loop\n// with specialized zip: memcpy\npub fn copy_zip(xs: &[u8], ys: &mut [u8]) {\n    for (a, b) in ys.iter_mut().zip(xs) {\n        *a = *b;\n    }\n}\n\n// old zip before this PR: single addition per iteration\n// with specialized zip: vectorized\npub fn add_zip(xs: &[f32], ys: &mut [f32]) {\n    for (a, b) in ys.iter_mut().zip(xs) { *a += *b; }\n}\n\n// old zip before this PR: single addition per iteration\n// with specialized zip: vectorized (!!)\npub fn add_zip3(xs: &[f32], ys: &[f32], zs: &mut [f32]) {\n    for ((a, b), c) in zs.iter_mut().zip(xs).zip(ys) { *a += *b * *c; }\n}\n```\n\nYet in more complex situations, the .zip() loop can still fall back to its old behavior where phantom null checks throw in fake premature end of the loop conditionals. Remember that a NULL inside\nOption<(&T, &T)> makes it a `None` value and a premature (in this case)\nend of the loop.\n\nSo even if we have 1) an explicit `Some` in the code and 2) the types of the pointers are `&T` or `&mut T` which are nonnull, we can still get a phantom null check at that point.\n\nOne example that illustrates the difference is `copy_zip` with slice versus Vec arguments. The involved iterator types are exactly the same, but the Vec version doesn't compile down to memcpy. Investigating into this, the function argument metadata emitted to llvm plays the biggest role. As eddyb summarized, we need nonnull for the loop to autovectorize and noalias for it to replace with memcpy.\n\nThere was an experiment to use `assume` to add a non-null assumption on each of the two elements in the specialized zip iterator, but this only helped in some of the test cases and regressed others. Instead I think the nonnull/noalias metadata issue is something we need to solve separately anyway.\n\nThese have conditionally implemented TrustedRandomAccess\n\n- Enumerate\n- Zip\n\nThese have not implemented it\n\n- Map is sideeffectful. The forward case would be workable, but the double ended case is complicated.\n- Chain, exact length semantics unclear\n- Filter, FilterMap, FlatMap and many others don't offer random access and/or exact length", "tree": {"sha": "9a154481c711651d38c81a59e2a9a96727bff08b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a154481c711651d38c81a59e2a9a96727bff08b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8eff682fd486a405dfbfcc89e613dcbccac0904", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8eff682fd486a405dfbfcc89e613dcbccac0904", "html_url": "https://github.com/rust-lang/rust/commit/c8eff682fd486a405dfbfcc89e613dcbccac0904", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8eff682fd486a405dfbfcc89e613dcbccac0904/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be203ac258365a2fb85a40314708d26112c40381", "url": "https://api.github.com/repos/rust-lang/rust/commits/be203ac258365a2fb85a40314708d26112c40381", "html_url": "https://github.com/rust-lang/rust/commit/be203ac258365a2fb85a40314708d26112c40381"}, {"sha": "5df05c6e221b718e82c87003e8b078a9cdbefb70", "url": "https://api.github.com/repos/rust-lang/rust/commits/5df05c6e221b718e82c87003e8b078a9cdbefb70", "html_url": "https://github.com/rust-lang/rust/commit/5df05c6e221b718e82c87003e8b078a9cdbefb70"}], "stats": {"total": 284, "additions": 263, "deletions": 21}, "files": [{"sha": "8fb71295a88a6901adebe767a99c1a9c81b268c5", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8eff682fd486a405dfbfcc89e613dcbccac0904/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8eff682fd486a405dfbfcc89e613dcbccac0904/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=c8eff682fd486a405dfbfcc89e613dcbccac0904", "patch": "@@ -23,6 +23,7 @@ use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, FlatMap, Fuse,\n use super::ChainState;\n use super::{DoubleEndedIterator, ExactSizeIterator, Extend, FromIterator,\n             IntoIterator};\n+use super::ZipImpl;\n \n fn _assert_is_object_safe(_: &Iterator<Item=()>) {}\n \n@@ -383,7 +384,7 @@ pub trait Iterator {\n     fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter> where\n         Self: Sized, U: IntoIterator\n     {\n-        Zip{a: self, b: other.into_iter()}\n+        Zip::new(self, other.into_iter())\n     }\n \n     /// Takes a closure and creates an iterator which calls that closure on each"}, {"sha": "b866655bbd53d1b24688357e1e213b4171112731", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 165, "deletions": 20, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/c8eff682fd486a405dfbfcc89e613dcbccac0904/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8eff682fd486a405dfbfcc89e613dcbccac0904/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=c8eff682fd486a405dfbfcc89e613dcbccac0904", "patch": "@@ -301,7 +301,9 @@\n \n use clone::Clone;\n use cmp;\n+use default::Default;\n use fmt;\n+use iter_private::TrustedRandomAccess;\n use ops::FnMut;\n use option::Option::{self, Some, None};\n use usize;\n@@ -622,7 +624,8 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Zip<A, B> {\n     a: A,\n-    b: B\n+    b: B,\n+    spec: <(A, B) as ZipImplData>::Data,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -631,29 +634,13 @@ impl<A, B> Iterator for Zip<A, B> where A: Iterator, B: Iterator\n     type Item = (A::Item, B::Item);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(A::Item, B::Item)> {\n-        self.a.next().and_then(|x| {\n-            self.b.next().and_then(|y| {\n-                Some((x, y))\n-            })\n-        })\n+    fn next(&mut self) -> Option<Self::Item> {\n+        ZipImpl::next(self)\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (a_lower, a_upper) = self.a.size_hint();\n-        let (b_lower, b_upper) = self.b.size_hint();\n-\n-        let lower = cmp::min(a_lower, b_lower);\n-\n-        let upper = match (a_upper, b_upper) {\n-            (Some(x), Some(y)) => Some(cmp::min(x,y)),\n-            (Some(x), None) => Some(x),\n-            (None, Some(y)) => Some(y),\n-            (None, None) => None\n-        };\n-\n-        (lower, upper)\n+        ZipImpl::size_hint(self)\n     }\n }\n \n@@ -664,6 +651,61 @@ impl<A, B> DoubleEndedIterator for Zip<A, B> where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<(A::Item, B::Item)> {\n+        ZipImpl::next_back(self)\n+    }\n+}\n+\n+// Zip specialization trait\n+#[doc(hidden)]\n+trait ZipImpl<A, B> {\n+    type Item;\n+    fn new(a: A, b: B) -> Self;\n+    fn next(&mut self) -> Option<Self::Item>;\n+    fn size_hint(&self) -> (usize, Option<usize>);\n+    fn next_back(&mut self) -> Option<Self::Item>\n+        where A: DoubleEndedIterator + ExactSizeIterator,\n+              B: DoubleEndedIterator + ExactSizeIterator;\n+}\n+\n+// Zip specialization data members\n+#[doc(hidden)]\n+trait ZipImplData {\n+    type Data: 'static + Clone + Default + fmt::Debug;\n+}\n+\n+#[doc(hidden)]\n+impl<T> ZipImplData for T {\n+    default type Data = ();\n+}\n+\n+// General Zip impl\n+#[doc(hidden)]\n+impl<A, B> ZipImpl<A, B> for Zip<A, B>\n+    where A: Iterator, B: Iterator\n+{\n+    type Item = (A::Item, B::Item);\n+    default fn new(a: A, b: B) -> Self {\n+        Zip {\n+            a: a,\n+            b: b,\n+            spec: Default::default(), // unused\n+        }\n+    }\n+\n+    #[inline]\n+    default fn next(&mut self) -> Option<(A::Item, B::Item)> {\n+        self.a.next().and_then(|x| {\n+            self.b.next().and_then(|y| {\n+                Some((x, y))\n+            })\n+        })\n+    }\n+\n+    #[inline]\n+    default fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n+        where A: DoubleEndedIterator + ExactSizeIterator,\n+              B: DoubleEndedIterator + ExactSizeIterator\n+    {\n         let a_sz = self.a.len();\n         let b_sz = self.b.len();\n         if a_sz != b_sz {\n@@ -680,12 +722,106 @@ impl<A, B> DoubleEndedIterator for Zip<A, B> where\n             _ => unreachable!(),\n         }\n     }\n+\n+    #[inline]\n+    default fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (a_lower, a_upper) = self.a.size_hint();\n+        let (b_lower, b_upper) = self.b.size_hint();\n+\n+        let lower = cmp::min(a_lower, b_lower);\n+\n+        let upper = match (a_upper, b_upper) {\n+            (Some(x), Some(y)) => Some(cmp::min(x,y)),\n+            (Some(x), None) => Some(x),\n+            (None, Some(y)) => Some(y),\n+            (None, None) => None\n+        };\n+\n+        (lower, upper)\n+    }\n+}\n+\n+#[doc(hidden)]\n+#[derive(Default, Debug, Clone)]\n+struct ZipImplFields {\n+    index: usize,\n+    len: usize,\n+}\n+\n+#[doc(hidden)]\n+impl<A, B> ZipImplData for (A, B)\n+    where A: TrustedRandomAccess, B: TrustedRandomAccess\n+{\n+    type Data = ZipImplFields;\n+}\n+\n+#[doc(hidden)]\n+impl<A, B> ZipImpl<A, B> for Zip<A, B>\n+    where A: TrustedRandomAccess, B: TrustedRandomAccess\n+{\n+    fn new(a: A, b: B) -> Self {\n+        let len = cmp::min(a.len(), b.len());\n+        Zip {\n+            a: a,\n+            b: b,\n+            spec: ZipImplFields {\n+                index: 0,\n+                len: len,\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<(A::Item, B::Item)> {\n+        if self.spec.index < self.spec.len {\n+            let i = self.spec.index;\n+            self.spec.index += 1;\n+            unsafe {\n+                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.spec.len - self.spec.index;\n+        (len, Some(len))\n+    }\n+\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n+        where A: DoubleEndedIterator + ExactSizeIterator,\n+              B: DoubleEndedIterator + ExactSizeIterator\n+    {\n+        if self.spec.index < self.spec.len {\n+            self.spec.len -= 1;\n+            let i = self.spec.len;\n+            unsafe {\n+                Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> ExactSizeIterator for Zip<A, B>\n     where A: ExactSizeIterator, B: ExactSizeIterator {}\n \n+#[doc(hidden)]\n+unsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n+    where A: TrustedRandomAccess,\n+          B: TrustedRandomAccess,\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> (A::Item, B::Item) {\n+        (self.a.get_unchecked(i), self.b.get_unchecked(i))\n+    }\n+\n+}\n+\n /// An iterator that maps the values of `iter` with `f`.\n ///\n /// This `struct` is created by the [`map()`] method on [`Iterator`]. See its\n@@ -982,6 +1118,15 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}\n \n+#[doc(hidden)]\n+unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n+    where I: TrustedRandomAccess\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> (usize, I::Item) {\n+        (self.count + i, self.iter.get_unchecked(i))\n+    }\n+}\n+\n /// An iterator with a `peek()` that returns an optional reference to the next\n /// element.\n ///"}, {"sha": "effe43cc67cea8912573c96abd40afb00612b99f", "filename": "src/libcore/iter_private.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c8eff682fd486a405dfbfcc89e613dcbccac0904/src%2Flibcore%2Fiter_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8eff682fd486a405dfbfcc89e613dcbccac0904/src%2Flibcore%2Fiter_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter_private.rs?ref=c8eff682fd486a405dfbfcc89e613dcbccac0904", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+use iter::ExactSizeIterator;\n+\n+/// An iterator whose items are random accessible efficiently\n+///\n+/// # Safety\n+///\n+/// The iterator's .len() and size_hint() must be exact.\n+///\n+/// .get_unchecked() must return distinct mutable references for distinct\n+/// indices (if applicable), and must return a valid reference if index is in\n+/// 0..self.len().\n+#[doc(hidden)]\n+pub unsafe trait TrustedRandomAccess : ExactSizeIterator {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item;\n+}\n+"}, {"sha": "db73f4759a5ffcd368d38646b35e8a65d6c49a95", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8eff682fd486a405dfbfcc89e613dcbccac0904/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8eff682fd486a405dfbfcc89e613dcbccac0904/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=c8eff682fd486a405dfbfcc89e613dcbccac0904", "patch": "@@ -156,4 +156,5 @@ pub mod hash;\n pub mod fmt;\n \n // note: does not need to be public\n+mod iter_private;\n mod tuple;"}, {"sha": "727c26ba9abd144c9910ff1f864b73dfbea3b6ae", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c8eff682fd486a405dfbfcc89e613dcbccac0904/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8eff682fd486a405dfbfcc89e613dcbccac0904/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=c8eff682fd486a405dfbfcc89e613dcbccac0904", "patch": "@@ -50,6 +50,7 @@ use result::Result::{Ok, Err};\n use ptr;\n use mem;\n use marker::{Copy, Send, Sync, self};\n+use iter_private::TrustedRandomAccess;\n \n #[repr(C)]\n struct Repr<T> {\n@@ -1942,3 +1943,17 @@ macro_rules! impl_marker_for {\n \n impl_marker_for!(BytewiseEquality,\n                  u8 i8 u16 i16 u32 i32 u64 i64 usize isize char bool);\n+\n+#[doc(hidden)]\n+unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n+        &*self.ptr.offset(i as isize)\n+    }\n+}\n+\n+#[doc(hidden)]\n+unsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n+        &mut *self.ptr.offset(i as isize)\n+    }\n+}"}, {"sha": "a2848faa105e9a89cf2d53ac158cc181720eb43c", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c8eff682fd486a405dfbfcc89e613dcbccac0904/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8eff682fd486a405dfbfcc89e613dcbccac0904/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=c8eff682fd486a405dfbfcc89e613dcbccac0904", "patch": "@@ -13,6 +13,7 @@ use core::{i8, i16, isize};\n use core::usize;\n \n use test::Bencher;\n+use test::black_box;\n \n #[test]\n fn test_lt() {\n@@ -1030,3 +1031,33 @@ fn bench_max(b: &mut Bencher) {\n         it.map(scatter).max()\n     })\n }\n+\n+pub fn copy_zip(xs: &[u8], ys: &mut [u8]) {\n+    for (a, b) in ys.iter_mut().zip(xs) {\n+        *a = *b;\n+    }\n+}\n+\n+pub fn add_zip(xs: &[f32], ys: &mut [f32]) {\n+    for (a, b) in ys.iter_mut().zip(xs) {\n+        *a += *b;\n+    }\n+}\n+\n+#[bench]\n+fn bench_zip_copy(b: &mut Bencher) {\n+    let source = vec![0u8; 16 * 1024];\n+    let mut dst = black_box(vec![0u8; 16 * 1024]);\n+    b.iter(|| {\n+        copy_zip(&source, &mut dst)\n+    })\n+}\n+\n+#[bench]\n+fn bench_zip_add(b: &mut Bencher) {\n+    let source = vec![1.; 16 * 1024];\n+    let mut dst = vec![0.; 16 * 1024];\n+    b.iter(|| {\n+        add_zip(&source, &mut dst)\n+    });\n+}"}, {"sha": "6c956364bf80f060d92adc98378f19a7214cdf63", "filename": "src/test/codegen/zip.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c8eff682fd486a405dfbfcc89e613dcbccac0904/src%2Ftest%2Fcodegen%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8eff682fd486a405dfbfcc89e613dcbccac0904/src%2Ftest%2Fcodegen%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fzip.rs?ref=c8eff682fd486a405dfbfcc89e613dcbccac0904", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes -O\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @zip_copy\n+#[no_mangle]\n+pub fn zip_copy(xs: &[u8], ys: &mut [u8]) {\n+// CHECK: memcpy\n+    for (x, y) in xs.iter().zip(ys) {\n+        *y = *x;\n+    }\n+}"}]}