{"sha": "ed810385045ab0db90303574ba3ea47dfa2a36d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkODEwMzg1MDQ1YWIwZGI5MDMwMzU3NGJhM2VhNDdkZmEyYTM2ZDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-24T17:38:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-24T17:38:09Z"}, "message": "Auto merge of #23654 - alexcrichton:rollup, r=alexcrichton", "tree": {"sha": "161242c800aca625a26c56551fa5adb446c0089f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/161242c800aca625a26c56551fa5adb446c0089f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed810385045ab0db90303574ba3ea47dfa2a36d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed810385045ab0db90303574ba3ea47dfa2a36d5", "html_url": "https://github.com/rust-lang/rust/commit/ed810385045ab0db90303574ba3ea47dfa2a36d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed810385045ab0db90303574ba3ea47dfa2a36d5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28a0b25f424090255966273994748a9f9901059f", "url": "https://api.github.com/repos/rust-lang/rust/commits/28a0b25f424090255966273994748a9f9901059f", "html_url": "https://github.com/rust-lang/rust/commit/28a0b25f424090255966273994748a9f9901059f"}, {"sha": "d252d0ad5434bcf77076729ab766eeff98f20ead", "url": "https://api.github.com/repos/rust-lang/rust/commits/d252d0ad5434bcf77076729ab766eeff98f20ead", "html_url": "https://github.com/rust-lang/rust/commit/d252d0ad5434bcf77076729ab766eeff98f20ead"}], "stats": {"total": 9500, "additions": 7606, "deletions": 1894}, "files": [{"sha": "683c7fd0563961c3056d115319eefcf878cc36f4", "filename": "configure", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/configure", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -479,10 +479,19 @@ esac\n # Detect 64 bit linux systems with 32 bit userland and force 32 bit compilation\n if [ $CFG_OSTYPE = unknown-linux-gnu -a $CFG_CPUTYPE = x86_64 ]\n then\n-    file -L \"$SHELL\" | grep -q \"x86[_-]64\"\n-    if [ $? != 0 ]; then\n-        CFG_CPUTYPE=i686\n+    # $SHELL does not exist in standard 'sh', so probably only exists\n+    # if configure is running in an interactive bash shell. /usr/bin/env\n+    # exists *everywhere*.\n+    BIN_TO_PROBE=\"$SHELL\"\n+    if [ -z \"$BIN_TO_PROBE\" -a -e \"/usr/bin/env\" ]; then\n+       BIN_TO_PROBE=\"/usr/bin/env\"\n     fi\n+    if [ -n \"$BIN_TO_PROBE\" ]; then\n+       file -L \"$BIN_TO_PROBE\" | grep -q \"x86[_-]64\"\n+       if [ $? != 0 ]; then\n+            CFG_CPUTYPE=i686\n+       fi\n+     fi\n fi\n \n "}, {"sha": "1ee5917ac9c91b7dbdc734d4f114ed9b2dea7454", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -20,6 +20,8 @@\n #![feature(std_misc)]\n #![feature(test)]\n #![feature(path_ext)]\n+#![feature(convert)]\n+#![feature(str_char)]\n \n #![deny(warnings)]\n \n@@ -115,7 +117,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n \n     fn opt_path(m: &getopts::Matches, nm: &str) -> PathBuf {\n         match m.opt_str(nm) {\n-            Some(s) => PathBuf::new(&s),\n+            Some(s) => PathBuf::from(&s),\n             None => panic!(\"no option (=path) found for {}\", nm),\n         }\n     }\n@@ -130,18 +132,18 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         compile_lib_path: matches.opt_str(\"compile-lib-path\").unwrap(),\n         run_lib_path: matches.opt_str(\"run-lib-path\").unwrap(),\n         rustc_path: opt_path(matches, \"rustc-path\"),\n-        clang_path: matches.opt_str(\"clang-path\").map(|s| PathBuf::new(&s)),\n+        clang_path: matches.opt_str(\"clang-path\").map(|s| PathBuf::from(&s)),\n         valgrind_path: matches.opt_str(\"valgrind-path\"),\n         force_valgrind: matches.opt_present(\"force-valgrind\"),\n-        llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map(|s| PathBuf::new(&s)),\n+        llvm_bin_path: matches.opt_str(\"llvm-bin-path\").map(|s| PathBuf::from(&s)),\n         src_base: opt_path(matches, \"src-base\"),\n         build_base: opt_path(matches, \"build-base\"),\n         aux_base: opt_path(matches, \"aux-base\"),\n         stage_id: matches.opt_str(\"stage-id\").unwrap(),\n         mode: matches.opt_str(\"mode\").unwrap().parse().ok().expect(\"invalid mode\"),\n         run_ignored: matches.opt_present(\"ignored\"),\n         filter: filter,\n-        logfile: matches.opt_str(\"logfile\").map(|s| PathBuf::new(&s)),\n+        logfile: matches.opt_str(\"logfile\").map(|s| PathBuf::from(&s)),\n         runtool: matches.opt_str(\"runtool\"),\n         host_rustcflags: matches.opt_str(\"host-rustcflags\"),\n         target_rustcflags: matches.opt_str(\"target-rustcflags\"),"}, {"sha": "461b5af6204edced4155e7ace9b3f5ab533c3c2c", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -40,8 +40,8 @@ pub struct TestProps {\n     pub check_stdout: bool,\n     // Don't force a --crate-type=dylib flag on the command line\n     pub no_prefer_dynamic: bool,\n-    // Don't run --pretty expanded when running pretty printing tests\n-    pub no_pretty_expanded: bool,\n+    // Run --pretty expanded when running pretty printing tests\n+    pub pretty_expanded: bool,\n     // Which pretty mode are we testing with, default to 'normal'\n     pub pretty_mode: String,\n     // Only compare pretty output and don't try compiling\n@@ -62,7 +62,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n     let mut force_host = false;\n     let mut check_stdout = false;\n     let mut no_prefer_dynamic = false;\n-    let mut no_pretty_expanded = false;\n+    let mut pretty_expanded = false;\n     let mut pretty_mode = None;\n     let mut pretty_compare_only = false;\n     let mut forbid_output = Vec::new();\n@@ -96,8 +96,8 @@ pub fn load_props(testfile: &Path) -> TestProps {\n             no_prefer_dynamic = parse_no_prefer_dynamic(ln);\n         }\n \n-        if !no_pretty_expanded {\n-            no_pretty_expanded = parse_no_pretty_expanded(ln);\n+        if !pretty_expanded {\n+            pretty_expanded = parse_pretty_expanded(ln);\n         }\n \n         if pretty_mode.is_none() {\n@@ -152,7 +152,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n         force_host: force_host,\n         check_stdout: check_stdout,\n         no_prefer_dynamic: no_prefer_dynamic,\n-        no_pretty_expanded: no_pretty_expanded,\n+        pretty_expanded: pretty_expanded,\n         pretty_mode: pretty_mode.unwrap_or(\"normal\".to_string()),\n         pretty_compare_only: pretty_compare_only,\n         forbid_output: forbid_output,\n@@ -295,8 +295,8 @@ fn parse_no_prefer_dynamic(line: &str) -> bool {\n     parse_name_directive(line, \"no-prefer-dynamic\")\n }\n \n-fn parse_no_pretty_expanded(line: &str) -> bool {\n-    parse_name_directive(line, \"no-pretty-expanded\")\n+fn parse_pretty_expanded(line: &str) -> bool {\n+    parse_name_directive(line, \"pretty-expanded\")\n }\n \n fn parse_pretty_mode(line: &str) -> Option<String> {\n@@ -328,10 +328,10 @@ fn parse_exec_env(line: &str) -> Option<(String, String)> {\n \n fn parse_pp_exact(line: &str, testfile: &Path) -> Option<PathBuf> {\n     match parse_name_value_directive(line, \"pp-exact\") {\n-      Some(s) => Some(PathBuf::new(&s)),\n+      Some(s) => Some(PathBuf::from(&s)),\n       None => {\n         if parse_name_directive(line, \"pp-exact\") {\n-            testfile.file_name().map(|s| PathBuf::new(s))\n+            testfile.file_name().map(|s| PathBuf::from(s))\n         } else {\n             None\n         }\n@@ -340,7 +340,8 @@ fn parse_pp_exact(line: &str, testfile: &Path) -> Option<PathBuf> {\n }\n \n fn parse_name_directive(line: &str, directive: &str) -> bool {\n-    line.contains(directive)\n+    // This 'no-' rule is a quick hack to allow pretty-expanded and no-pretty-expanded to coexist\n+    line.contains(directive) && !line.contains(&(\"no-\".to_string() + directive))\n }\n \n pub fn parse_name_value_directive(line: &str, directive: &str)"}, {"sha": "1666124b46a6185febf95b484ba3546645abbeab", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -245,7 +245,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n     if !proc_res.status.success() {\n         fatal_proc_rec(\"pretty-printed source does not typecheck\", &proc_res);\n     }\n-    if props.no_pretty_expanded { return }\n+    if !props.pretty_expanded { return }\n \n     // additionally, run `--pretty expanded` and try to build it.\n     let proc_res = print_source(config, props, testfile, srcs[round].clone(), \"expanded\");\n@@ -1440,7 +1440,7 @@ fn aux_output_dir_name(config: &Config, testfile: &Path) -> PathBuf {\n }\n \n fn output_testname(testfile: &Path) -> PathBuf {\n-    PathBuf::new(testfile.file_stem().unwrap())\n+    PathBuf::from(testfile.file_stem().unwrap())\n }\n \n fn output_base_name(config: &Config, testfile: &Path) -> PathBuf {"}, {"sha": "b711085ddbd9c298cd5b641d4d4711617d02224a", "filename": "src/doc/intro.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -446,16 +446,16 @@ It gives us this error:\n error: aborting due to previous error\n ```\n \n-It mentions that \"captured outer variable in an `FnMut` closure\".\n-Because we declared the closure as a moving closure, and it referred\n-to `numbers`, the closure will try to take ownership of the\n-vector. But the closure itself is created in a loop, and hence we will\n-actually create three closures, one for every iteration of the\n-loop. This means that all three of those closures would try to own\n-`numbers`, which is impossible -- `numbers` must have just one\n-owner. Rust detects this and gives us the error: we claim that\n-`numbers` has ownership, but our code tries to make three owners. This\n-may cause a safety problem, so Rust disallows it.\n+This is a little confusing because there are two closures here: the one passed\n+to `map`, and the one passed to `thread::scoped`. In this case, the closure for\n+`thread::scoped` is attempting to reference `numbers`, a `Vec<i32>`. This\n+closure is a `FnOnce` closure, as that\u2019s what `thread::scoped` takes as an\n+argument. `FnOnce` closures take ownership of their environment. That\u2019s fine,\n+but there\u2019s one detail: because of `map`, we\u2019re going to make three of these\n+closures. And since all three try to take ownership of `numbers`, that would be\n+a problem. That\u2019s what it means by \u2018cannot move out of captured outer\n+variable\u2019: our `thread::scoped` closure wants to take ownership, and it can\u2019t,\n+because the closure for `map` won\u2019t let it.\n \n What to do here? Rust has two types that helps us: `Arc<T>` and `Mutex<T>`.\n *Arc* stands for \"atomically reference counted\". In other words, an Arc will"}, {"sha": "07df3bdad34900ff00de2e1a6e6ed8c03ae2130e", "filename": "src/doc/reference.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -816,8 +816,7 @@ may optionally begin with any number of `attributes` that apply to the\n containing module. Attributes on the anonymous crate module define important\n metadata that influences the behavior of the compiler.\n \n-```{.rust}\n-# #![allow(unused_attribute)]\n+```no_run\n // Crate name\n #![crate_name = \"projx\"]\n \n@@ -1020,6 +1019,7 @@ Use declarations support a number of convenient shortcuts:\n An example of `use` declarations:\n \n ```\n+# #![feature(core)]\n use std::iter::range_step;\n use std::option::Option::{Some, None};\n use std::collections::hash_map::{self, HashMap};\n@@ -1080,6 +1080,7 @@ declarations.\n An example of what will and will not work for `use` items:\n \n ```\n+# #![feature(core)]\n # #![allow(unused_imports)]\n use foo::core::iter;  // good: foo is at the root of the crate\n use foo::baz::foobaz;    // good: foo is at the root of the crate\n@@ -1781,6 +1782,7 @@ functions, with the exception that they may not have a body and are instead\n terminated by a semicolon.\n \n ```\n+# #![feature(libc)]\n extern crate libc;\n use libc::{c_char, FILE};\n "}, {"sha": "d531a22d0e0dd55d2b2a0d5d913b88f9d3912c73", "filename": "src/doc/trpl/compound-data-types.md", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -47,7 +47,7 @@ This pattern is very powerful, and we'll see it repeated more later.\n \n There are also a few things you can do with a tuple as a whole, without\n destructuring. You can assign one tuple into another, if they have the same\n-contained types and arity. Tuples have the same arity when they have the same\n+contained types and [arity]. Tuples have the same arity when they have the same\n length.\n \n ```rust\n@@ -196,8 +196,9 @@ Now, we have actual names, rather than positions. Good names are important,\n and with a struct, we have actual names.\n \n There _is_ one case when a tuple struct is very useful, though, and that's a\n-tuple struct with only one element. We call this a *newtype*, because it lets\n-you create a new type that's similar to another one:\n+tuple struct with only one element. We call this the *newtype* pattern, because\n+it allows you to create a new type, distinct from that of its contained value\n+and expressing its own semantic meaning:\n \n ```{rust}\n struct Inches(i32);\n@@ -216,7 +217,7 @@ destructuring `let`, as we discussed previously in 'tuples.' In this case, the\n \n Finally, Rust has a \"sum type\", an *enum*. Enums are an incredibly useful\n feature of Rust, and are used throughout the standard library. An `enum` is\n-a type which ties a set of alternates to a specific name. For example, below\n+a type which relates a set of alternates to a specific name. For example, below\n we define `Character` to be either a `Digit` or something else. These\n can be used via their fully scoped names: `Character::Other` (more about `::`\n below).\n@@ -228,8 +229,8 @@ enum Character {\n }\n ```\n \n-An `enum` variant can be defined as most normal types. Below are some example\n-types which also would be allowed in an `enum`.\n+Most normal types are allowed as the variant components of an `enum`. Here are\n+some examples:\n \n ```rust\n struct Empty;\n@@ -239,15 +240,15 @@ struct Status { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n struct HeightDatabase(Vec<i32>);\n ```\n \n-So you see that depending on the sub-datastructure, the `enum` variant, same as\n-a struct, may or may not hold data. That is, in `Character`, `Digit` is a name\n-tied to an `i32` where `Other` is just a name. However, the fact that they are\n-distinct makes this very useful.\n+You see that, depending on its type, an `enum` variant may or may not hold data.\n+In `Character`, for instance, `Digit` gives a meaningful name for an `i32`\n+value, where `Other` is only a name. However, the fact that they represent\n+distinct categories of `Character` is a very useful property.\n \n-As with structures, enums don't by default have access to operators such as\n-compare ( `==` and `!=`), binary operations (`*` and `+`), and order\n-(`<` and `>=`). As such, using the previous `Character` type, the\n-following code is invalid:\n+As with structures, the variants of an enum by default are not comparable with\n+equality operators (`==`, `!=`), have no ordering (`<`, `>=`, etc.), and do not\n+support other binary operations such as `*` and `+`. As such, the following code\n+is invalid for the example `Character` type:\n \n ```{rust,ignore}\n // These assignments both succeed\n@@ -265,9 +266,10 @@ let four_equals_ten = four == ten;\n ```\n \n This may seem rather limiting, but it's a limitation which we can overcome.\n-There are two ways: by implementing equality ourselves, or by using the\n-[`match`][match] keyword. We don't know enough about Rust to implement equality\n-yet, but we can use the `Ordering` enum from the standard library, which does:\n+There are two ways: by implementing equality ourselves, or by pattern matching\n+variants with [`match`][match] expressions, which you'll learn in the next\n+chapter. We don't know enough about Rust to implement equality yet, but we can\n+use the `Ordering` enum from the standard library, which does:\n \n ```\n enum Ordering {\n@@ -277,9 +279,8 @@ enum Ordering {\n }\n ```\n \n-Because we did not define `Ordering`, we must import it (from the std\n-library) with the `use` keyword. Here's an example of how `Ordering` is\n-used:\n+Because `Ordering` has already been defined for us, we will import it with the\n+`use` keyword. Here's an example of how it is used:\n \n ```{rust}\n use std::cmp::Ordering;\n@@ -313,17 +314,17 @@ the standard library if you need them.\n \n Okay, let's talk about the actual code in the example. `cmp` is a function that\n compares two things, and returns an `Ordering`. We return either\n-`Ordering::Less`, `Ordering::Greater`, or `Ordering::Equal`, depending on if\n-the two values are less, greater, or equal. Note that each variant of the\n-`enum` is namespaced under the `enum` itself: it's `Ordering::Greater` not\n-`Greater`.\n+`Ordering::Less`, `Ordering::Greater`, or `Ordering::Equal`, depending on\n+whether the first value is less than, greater than, or equal to the second. Note\n+that each variant of the `enum` is namespaced under the `enum` itself: it's\n+`Ordering::Greater`, not `Greater`.\n \n The `ordering` variable has the type `Ordering`, and so contains one of the\n three values. We then do a bunch of `if`/`else` comparisons to check which\n one it is.\n \n-This `Ordering::Greater` notation is too long. Let's use `use` to import the\n-`enum` variants instead. This will avoid full scoping:\n+This `Ordering::Greater` notation is too long. Let's use another form of `use`\n+to import the `enum` variants instead. This will avoid full scoping:\n \n ```{rust}\n use std::cmp::Ordering::{self, Equal, Less, Greater};\n@@ -347,16 +348,18 @@ fn main() {\n ```\n \n Importing variants is convenient and compact, but can also cause name conflicts,\n-so do this with caution. It's considered good style to rarely import variants\n-for this reason.\n+so do this with caution. For this reason, it's normally considered better style\n+to `use` an enum rather than its variants directly.\n \n-As you can see, `enum`s are quite a powerful tool for data representation, and are\n-even more useful when they're [generic][generics] across types. Before we\n-get to generics, though, let's talk about how to use them with pattern matching, a\n-tool that will let us deconstruct this sum type (the type theory term for enums)\n-in a very elegant way and avoid all these messy `if`/`else`s.\n+As you can see, `enum`s are quite a powerful tool for data representation, and\n+are even more useful when they're [generic][generics] across types. Before we\n+get to generics, though, let's talk about how to use enums with pattern\n+matching, a tool that will let us deconstruct sum types (the type theory term\n+for enums) like `Ordering` in a very elegant way that avoids all these messy\n+and brittle `if`/`else`s.\n \n \n+[arity]: ./glossary.html#arity\n [match]: ./match.html\n [game]: ./guessing-game.html#comparing-guesses\n [generics]: ./generics.html"}, {"sha": "79cb3117c0ef2ea7c249ca5303f0eadaa1f0a860", "filename": "src/doc/trpl/concurrency.md", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconcurrency.md?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -40,14 +40,14 @@ us enforce that it can't leave the current thread.\n \n ### `Sync`\n \n-The second of these two trait is called [`Sync`](../std/marker/trait.Sync.html).\n+The second of these traits is called [`Sync`](../std/marker/trait.Sync.html).\n When a type `T` implements `Sync`, it indicates to the compiler that something\n of this type has no possibility of introducing memory unsafety when used from\n multiple threads concurrently.\n \n For example, sharing immutable data with an atomic reference count is\n threadsafe. Rust provides a type like this, `Arc<T>`, and it implements `Sync`,\n-so that it could be safely shared between threads.\n+so it is safe to share between threads.\n \n These two traits allow you to use the type system to make strong guarantees\n about the properties of your code under concurrency. Before we demonstrate\n@@ -69,7 +69,7 @@ fn main() {\n }\n ```\n \n-The `Thread::scoped()` method accepts a closure, which is executed in a new\n+The `thread::scoped()` method accepts a closure, which is executed in a new\n thread. It's called `scoped` because this thread returns a join guard:\n \n ```\n@@ -88,6 +88,7 @@ When `guard` goes out of scope, it will block execution until the thread is\n finished. If we didn't want this behaviour, we could use `thread::spawn()`:\n \n ```\n+# #![feature(old_io, std_misc)]\n use std::thread;\n use std::old_io::timer;\n use std::time::Duration;\n@@ -146,6 +147,7 @@ As an example, here is a Rust program that would have a data race in many\n languages. It will not compile:\n \n ```ignore\n+# #![feature(old_io, std_misc)]\n use std::thread;\n use std::old_io::timer;\n use std::time::Duration;\n@@ -185,6 +187,7 @@ only one person at a time can mutate what's inside. For that, we can use the\n but for a different reason:\n \n ```ignore\n+# #![feature(old_io, std_misc)]\n use std::thread;\n use std::old_io::timer;\n use std::time::Duration;\n@@ -208,10 +211,10 @@ Here's the error:\n \n ```text\n <anon>:11:9: 11:22 error: the trait `core::marker::Send` is not implemented for the type `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` [E0277]\n-<anon>:11         Thread::spawn(move || {\n+<anon>:11         thread::spawn(move || {\n                   ^~~~~~~~~~~~~\n <anon>:11:9: 11:22 note: `std::sync::mutex::MutexGuard<'_, collections::vec::Vec<u32>>` cannot be sent between threads safely\n-<anon>:11         Thread::spawn(move || {\n+<anon>:11         thread::spawn(move || {\n                   ^~~~~~~~~~~~~\n ```\n \n@@ -229,6 +232,7 @@ guard across thread boundaries, which gives us our error.\n We can use `Arc<T>` to fix this. Here's the working version:\n \n ```\n+# #![feature(old_io, std_misc)]\n use std::sync::{Arc, Mutex};\n use std::thread;\n use std::old_io::timer;\n@@ -254,6 +258,7 @@ handle is then moved into the new thread. Let's examine the body of the\n thread more closely:\n \n ```\n+# #![feature(old_io, std_misc)]\n # use std::sync::{Arc, Mutex};\n # use std::thread;\n # use std::old_io::timer;\n@@ -322,7 +327,6 @@ While this channel is just sending a generic signal, we can send any data that\n is `Send` over the channel!\n \n ```\n-use std::sync::{Arc, Mutex};\n use std::thread;\n use std::sync::mpsc;\n "}, {"sha": "0cc54c9b16598b10eb2e8b945cc6224b6fbea20b", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 22, "deletions": 74, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -1,6 +1,6 @@\n % Crates and Modules\n \n-When a project starts getting large, it's considered a good software\n+When a project starts getting large, it's considered good software\n engineering practice to split it up into a bunch of smaller pieces, and then\n fit them together. It's also important to have a well-defined interface, so\n that some of your functionality is private, and some is public. To facilitate\n@@ -24,23 +24,23 @@ in different languages. To keep things simple, we'll stick to \"greetings\" and\n two languages for those phrases to be in. We'll use this module layout:\n \n ```text\n-                                +-----------+\n-                            +---| greetings |\n-                            |   +-----------+\n-              +---------+   |\n-              | english |---+\n-              +---------+   |   +-----------+\n-              |             +---| farewells |\n-+---------+   |                 +-----------+\n+                                    +-----------+\n+                                +---| greetings |\n+                                |   +-----------+\n+                  +---------+   |\n+              +---| english |---+\n+              |   +---------+   |   +-----------+\n+              |                 +---| farewells |\n++---------+   |                     +-----------+\n | phrases |---+\n-+---------+   |                  +-----------+\n-              |              +---| greetings |\n-              +----------+   |   +-----------+\n-              | japanese |---+\n-              +----------+   |\n-                             |   +-----------+\n-                             +---| farewells |\n-                                 +-----------+\n++---------+   |                     +-----------+\n+              |                 +---| greetings |\n+              |   +----------+  |   +-----------+\n+              +---| japanese |--+\n+                  +----------+  |\n+                                |   +-----------+\n+                                +---| farewells |\n+                                    +-----------+\n ```\n \n In this example, `phrases` is the name of our crate. All of the rest are\n@@ -76,25 +76,19 @@ To define each of our modules, we use the `mod` keyword. Let's make our\n `src/lib.rs` look like this:\n \n ```\n-// in src/lib.rs\n-\n mod english {\n     mod greetings {\n-\n     }\n \n     mod farewells {\n-\n     }\n }\n \n mod japanese {\n     mod greetings {\n-\n     }\n \n     mod farewells {\n-\n     }\n }\n ```\n@@ -145,11 +139,7 @@ mod english;\n ```\n \n If we do that, Rust will expect to find either a `english.rs` file, or a\n-`english/mod.rs` file with the contents of our module:\n-\n-```{rust,ignore}\n-// contents of our module go here\n-```\n+`english/mod.rs` file with the contents of our module.\n \n Note that in these files, you don't need to re-declare the module: that's\n already been done with the initial `mod` declaration.\n@@ -181,10 +171,7 @@ $ tree .\n `src/lib.rs` is our crate root, and looks like this:\n \n ```{rust,ignore}\n-// in src/lib.rs\n-\n mod english;\n-\n mod japanese;\n ```\n \n@@ -195,10 +182,7 @@ chosen the second. Both `src/english/mod.rs` and `src/japanese/mod.rs` look\n like this:\n \n ```{rust,ignore}\n-// both src/english/mod.rs and src/japanese/mod.rs\n-\n mod greetings;\n-\n mod farewells;\n ```\n \n@@ -214,8 +198,6 @@ both empty at the moment. Let's add some functions.\n Put this in `src/english/greetings.rs`:\n \n ```rust\n-// in src/english/greetings.rs\n-\n fn hello() -> String {\n     \"Hello!\".to_string()\n }\n@@ -224,8 +206,6 @@ fn hello() -> String {\n Put this in `src/english/farewells.rs`:\n \n ```rust\n-// in src/english/farewells.rs\n-\n fn goodbye() -> String {\n     \"Goodbye.\".to_string()\n }\n@@ -248,8 +228,6 @@ about the module system.\n Put this in `src/japanese/farewells.rs`:\n \n ```rust\n-// in src/japanese/farewells.rs\n-\n fn goodbye() -> String {\n     \"\u3055\u3088\u3046\u306a\u3089\".to_string()\n }\n@@ -265,11 +243,9 @@ another crate.\n We have a library crate. Let's make an executable crate that imports and uses\n our library.\n \n-Make a `src/main.rs` and put this in it: (it won't quite compile yet)\n+Make a `src/main.rs` and put this in it (it won't quite compile yet):\n \n ```rust,ignore\n-// in src/main.rs\n-\n extern crate phrases;\n \n fn main() {\n@@ -320,8 +296,6 @@ keyword. Let's focus on the `english` module first, so let's reduce our `src/mai\n to just this:\n \n ```{rust,ignore}\n-// in src/main.rs\n-\n extern crate phrases;\n \n fn main() {\n@@ -333,28 +307,20 @@ fn main() {\n In our `src/lib.rs`, let's add `pub` to the `english` module declaration:\n \n ```{rust,ignore}\n-// in src/lib.rs\n-\n pub mod english;\n-\n mod japanese;\n ```\n \n And in our `src/english/mod.rs`, let's make both `pub`:\n \n ```{rust,ignore}\n-// in src/english/mod.rs\n-\n pub mod greetings;\n-\n pub mod farewells;\n ```\n \n In our `src/english/greetings.rs`, let's add `pub` to our `fn` declaration:\n \n ```{rust,ignore}\n-// in src/english/greetings.rs\n-\n pub fn hello() -> String {\n     \"Hello!\".to_string()\n }\n@@ -363,8 +329,6 @@ pub fn hello() -> String {\n And also in `src/english/farewells.rs`:\n \n ```{rust,ignore}\n-// in src/english/farewells.rs\n-\n pub fn goodbye() -> String {\n     \"Goodbye.\".to_string()\n }\n@@ -400,8 +364,6 @@ Rust has a `use` keyword, which allows us to import names into our local scope.\n Let's change our `src/main.rs` to look like this:\n \n ```{rust,ignore}\n-// in src/main.rs\n-\n extern crate phrases;\n \n use phrases::english::greetings;\n@@ -430,7 +392,7 @@ fn main() {\n }\n ```\n \n-But it is not idiomatic. This is significantly more likely to introducing a\n+But it is not idiomatic. This is significantly more likely to introduce a\n naming conflict. In our short program, it's not a big deal, but as it grows, it\n becomes a problem. If we have conflicting names, Rust will give a compilation\n error. For example, if we made the `japanese` functions public, and tried to do\n@@ -460,21 +422,19 @@ Could not compile `phrases`.\n ```\n \n If we're importing multiple names from the same module, we don't have to type it out\n-twice. Rust has a shortcut syntax for writing this:\n+twice. Instead of this:\n \n ```{rust,ignore}\n use phrases::english::greetings;\n use phrases::english::farewells;\n ```\n \n-You use curly braces:\n+We can use this shortcut:\n \n ```{rust,ignore}\n use phrases::english::{greetings, farewells};\n ```\n \n-These two declarations are equivalent, but the second is a lot less typing.\n-\n ## Re-exporting with `pub use`\n \n You don't just use `use` to shorten identifiers. You can also use it inside of your crate\n@@ -484,8 +444,6 @@ interface that may not directly map to your internal code organization.\n Let's look at an example. Modify your `src/main.rs` to read like this:\n \n ```{rust,ignore}\n-// in src/main.rs\n-\n extern crate phrases;\n \n use phrases::english::{greetings,farewells};\n@@ -503,18 +461,13 @@ fn main() {\n Then, modify your `src/lib.rs` to make the `japanese` mod public:\n \n ```{rust,ignore}\n-// in src/lib.rs\n-\n pub mod english;\n-\n pub mod japanese;\n ```\n \n Next, make the two functions public, first in `src/japanese/greetings.rs`:\n \n ```{rust,ignore}\n-// in src/japanese/greetings.rs\n-\n pub fn hello() -> String {\n     \"\u3053\u3093\u306b\u3061\u306f\".to_string()\n }\n@@ -523,8 +476,6 @@ pub fn hello() -> String {\n And then in `src/japanese/farewells.rs`:\n \n ```{rust,ignore}\n-// in src/japanese/farewells.rs\n-\n pub fn goodbye() -> String {\n     \"\u3055\u3088\u3046\u306a\u3089\".to_string()\n }\n@@ -533,13 +484,10 @@ pub fn goodbye() -> String {\n Finally, modify your `src/japanese/mod.rs` to read like this:\n \n ```{rust,ignore}\n-// in src/japanese/mod.rs\n-\n pub use self::greetings::hello;\n pub use self::farewells::goodbye;\n \n mod greetings;\n-\n mod farewells;\n ```\n "}, {"sha": "54821e3ce304d5dfc05045c397e56260116bc416", "filename": "src/doc/trpl/documentation.md", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdocumentation.md?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -237,14 +237,17 @@ fn main() {\n }\n ```\n \n-Here's the full algorithm:\n-\n-1. Given a code block, if it does not contain `fn main()`, it is wrapped in\n-   `fn main() { your_code }`\n-2. Given that result, if it contains no `extern crate` directives but it also\n-   contains the name of the crate being tested, then `extern crate <name>` is\n-   injected at the top.\n-3. Some common allow attributes are added for documentation examples at the top.\n+Here's the full algorithm rustdoc uses to postprocess examples:\n+\n+1. Any leading `#![foo]` attributes are left intact as crate attributes.\n+2. Some common `allow` attributes are inserted, including\n+   `unused_variables`, `unused_assignments`, `unused_mut`,\n+   `unused_attributes`, and `dead_code`. Small examples often trigger\n+   these lints.\n+3. If the example does not contain `extern crate`, then `extern crate\n+   <mycrate>;` is inserted.\n+2. Finally, if the example does not contain `fn main`, the remainder of the\n+   text is wrapped in `fn main() { your_code }`\n \n Sometimes, this isn't enough, though. For example, all of these code samples\n with `///` we've been talking about? The raw text:\n@@ -333,6 +336,42 @@ By repeating all parts of the example, you can ensure that your example still\n compiles, while only showing the parts that are relevant to that part of your\n explanation.\n \n+### Documenting macros\n+\n+Here\u2019s an example of documenting a macro:\n+\n+```\n+/// Panic with a given message unless an expression evaluates to true.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #[macro_use] extern crate foo;\n+/// # fn main() {\n+/// panic_unless!(1 + 1 == 2, \u201cMath is broken.\u201d);\n+/// # }\n+/// ```\n+///\n+/// ```should_fail\n+/// # #[macro_use] extern crate foo;\n+/// # fn main() {\n+/// panic_unless!(true == false, \u201cI\u2019m broken.\u201d);\n+/// # }\n+/// ```\n+#[macro_export]\n+macro_rules! panic_unless {\n+    ($condition:expr, $($rest:expr),+) => ({ if ! $condition { panic!($($rest),+); } });\n+}\n+# fn main() {}\n+```\n+\n+You\u2019ll note three things: we need to add our own `extern crate` line, so that\n+we can add the `#[macro_use]` attribute. Second, we\u2019ll need to add our own\n+`main()` as well. Finally, a judicious use of `#` to comment out those two\n+things, so they don\u2019t show up in the output.\n+\n+### Running documentation tests\n+\n To run the tests, either\n \n ```bash"}, {"sha": "695279e2d5bb6983cd34a3c6903633969fa2992a", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -12,6 +12,7 @@ The following is a minimal example of calling a foreign function which will\n compile if snappy is installed:\n \n ```no_run\n+# #![feature(libc)]\n extern crate libc;\n use libc::size_t;\n \n@@ -45,6 +46,7 @@ keeping the binding correct at runtime.\n The `extern` block can be extended to cover the entire snappy API:\n \n ```no_run\n+# #![feature(libc)]\n extern crate libc;\n use libc::{c_int, size_t};\n \n@@ -80,6 +82,7 @@ length is number of elements currently contained, and the capacity is the total\n the allocated memory. The length is less than or equal to the capacity.\n \n ```\n+# #![feature(libc)]\n # extern crate libc;\n # use libc::{c_int, size_t};\n # unsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -> c_int { 0 }\n@@ -104,6 +107,7 @@ required capacity to hold the compressed output. The vector can then be passed t\n the true length after compression for setting the length.\n \n ```\n+# #![feature(libc)]\n # extern crate libc;\n # use libc::{size_t, c_int};\n # unsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,\n@@ -130,6 +134,7 @@ Decompression is similar, because snappy stores the uncompressed size as part of\n format and `snappy_uncompressed_length` will retrieve the exact buffer size required.\n \n ```\n+# #![feature(libc)]\n # extern crate libc;\n # use libc::{size_t, c_int};\n # unsafe fn snappy_uncompress(compressed: *const u8,\n@@ -408,6 +413,7 @@ global state. In order to access these variables, you declare them in `extern`\n blocks with the `static` keyword:\n \n ```no_run\n+# #![feature(libc)]\n extern crate libc;\n \n #[link(name = \"readline\")]\n@@ -426,6 +432,7 @@ interface. To do this, statics can be declared with `mut` so we can mutate\n them.\n \n ```no_run\n+# #![feature(libc)]\n extern crate libc;\n \n use std::ffi::CString;\n@@ -458,6 +465,7 @@ calling foreign functions. Some foreign functions, most notably the Windows API,\n conventions. Rust provides a way to tell the compiler which convention to use:\n \n ```\n+# #![feature(libc)]\n extern crate libc;\n \n #[cfg(all(target_os = \"win32\", target_arch = \"x86\"))]"}, {"sha": "8d7b1c3bd83932dbaab824ac5752d1ca87f64d1e", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -246,6 +246,7 @@ These two basic iterators should serve you well. There are some more\n advanced iterators, including ones that are infinite. Like `count`:\n \n ```rust\n+# #![feature(core)]\n std::iter::count(1, 5);\n ```\n \n@@ -294,6 +295,7 @@ has no side effect on the original iterator. Let's try it out with our infinite\n iterator from before, `count()`:\n \n ```rust\n+# #![feature(core)]\n for i in std::iter::count(1, 5).take(5) {\n     println!(\"{}\", i);\n }"}, {"sha": "8cb16f7ab33406422659b3d3a57eb82a7de220ec", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -23,6 +23,7 @@ the ability to use this *method call syntax* via the `impl` keyword.\n Here's how it works:\n \n ```{rust}\n+# #![feature(core)]\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -87,6 +88,7 @@ original example, `foo.bar().baz()`? This is called 'method chaining', and we\n can do it by returning `self`.\n \n ```\n+# #![feature(core)]\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -164,6 +166,7 @@ have method overloading, named arguments, or variable arguments. We employ\n the builder pattern instead. It looks like this:\n \n ```\n+# #![feature(core)]\n struct Circle {\n     x: f64,\n     y: f64,"}, {"sha": "c46f84caa860cbcd681f4019634eadaeddbd433b", "filename": "src/doc/trpl/more-strings.md", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmore-strings.md?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -12,7 +12,7 @@ Additionally, strings are not null-terminated and can contain null bytes.\n \n Rust has two main types of strings: `&str` and `String`.\n \n-# &str\n+# `&str`\n \n The first kind is a `&str`. This is pronounced a 'string slice'.\n String literals are of the type `&str`:\n@@ -36,7 +36,36 @@ Like vector slices, string slices are simply a pointer plus a length. This\n means that they're a 'view' into an already-allocated string, such as a\n string literal or a `String`.\n \n-# String\n+## `str`\n+\n+You may occasionally see references to a `str` type, without the `&`. While\n+this type does exist, it\u2019s not something you want to use yourself. Sometimes,\n+people confuse `str` for `String`, and write this:\n+\n+```rust\n+struct S {\n+    s: str,\n+}\n+```\n+\n+This leads to ugly errors:\n+\n+```text\n+error: the trait `core::marker::Sized` is not implemented for the type `str` [E0277]\n+note: `str` does not have a constant size known at compile-time\n+```\n+\n+Instead, this `struct` should be\n+\n+```rust\n+struct S {\n+    s: String,\n+}\n+```\n+\n+So let\u2019s talk about `String`s.\n+\n+# `String`\n \n A `String` is a heap-allocated string. This string is growable, and is\n also guaranteed to be UTF-8. `String`s are commonly created by\n@@ -148,6 +177,7 @@ Rust provides iterators for each of these situations:\n Usually, the `graphemes()` method on `&str` is what you want:\n \n ```\n+# #![feature(unicode)]\n let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n \n for l in s.graphemes(true) {"}, {"sha": "bd9b449fc087e7db4c0aab4b0cba53656063f2a2", "filename": "src/doc/trpl/pointers.md", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fpointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fpointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpointers.md?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -498,13 +498,10 @@ they go out of scope:\n However, boxes do _not_ use reference counting or garbage collection. Boxes are\n what's called an *affine type*. This means that the Rust compiler, at compile\n time, determines when the box comes into and goes out of scope, and inserts the\n-appropriate calls there. Furthermore, boxes are a specific kind of affine type,\n-known as a *region*. You can read more about regions [in this paper on the\n-Cyclone programming\n-language](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf).\n+appropriate calls there.\n \n-You don't need to fully grok the theory of affine types or regions to grok\n-boxes, though. As a rough approximation, you can treat this Rust code:\n+You don't need to fully grok the theory of affine types to grok boxes, though.\n+As a rough approximation, you can treat this Rust code:\n \n ```{rust}\n {"}, {"sha": "a296e1311e6d16472e1df9427dfee03c8971fec1", "filename": "src/doc/trpl/standard-input.md", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstandard-input.md?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -5,7 +5,7 @@ we haven't seen before. Here's a simple program that reads some input,\n and then prints it back out:\n \n ```{rust,ignore}\n-fn main() {\n+corefn main() {\n     println!(\"Type something!\");\n \n     let input = std::old_io::stdin().read_line().ok().expect(\"Failed to read line\");\n@@ -28,6 +28,7 @@ Since writing the fully qualified name all the time is annoying, we can use\n the `use` statement to import it in:\n \n ```{rust}\n+# #![feature(old_io)]\n use std::old_io::stdin;\n \n stdin();\n@@ -37,6 +38,7 @@ However, it's considered better practice to not import individual functions, but\n to import the module, and only use one level of qualification:\n \n ```{rust}\n+# #![feature(old_io)]\n use std::old_io;\n \n old_io::stdin();\n@@ -115,8 +117,9 @@ doesn't work, so we're okay with that. In most cases, we would want to handle\n the error case explicitly. `expect()` allows us to give an error message if\n this crash happens.\n \n-We will cover the exact details of how all of this works later in the Guide.\n-For now, this gives you enough of a basic understanding to work with.\n+We will cover the exact details of how all of this works later in the Guide in\n+[Error Handling]. For now, this gives you enough of a basic understanding to\n+work with.\n \n Back to the code we were working on! Here's a refresher:\n \n@@ -157,3 +160,6 @@ here.\n \n That's all you need to get basic input from the standard input! It's not too\n complicated, but there are a number of small parts.\n+\n+\n+[Error Handling]: ./error-handling.html"}, {"sha": "8fb08e1c6cfdea4f529e051e98cdd66b3e1b169f", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -546,6 +546,8 @@ is an opaque \"black box\" to the optimizer and so forces it to consider any\n argument as used.\n \n ```rust\n+# #![feature(test)]\n+\n extern crate test;\n \n # fn main() {"}, {"sha": "fe26fc5e1eb200a71cd45f74b8c826dfb7f7a573", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -4,6 +4,7 @@ Do you remember the `impl` keyword, used to call a function with method\n syntax?\n \n ```{rust}\n+# #![feature(core)]\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -21,6 +22,7 @@ Traits are similar, except that we define a trait with just the method\n signature, then implement the trait for that struct. Like this:\n \n ```{rust}\n+# #![feature(core)]\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -84,6 +86,7 @@ which implements `HasArea` will have an `.area()` method.\n Here's an extended example of how this works:\n \n ```{rust}\n+# #![feature(core)]\n trait HasArea {\n     fn area(&self) -> f64;\n }\n@@ -225,6 +228,7 @@ If we add a `use` line right above `main` and make the right things public,\n everything is fine:\n \n ```{rust}\n+# #![feature(core)]\n use shapes::HasArea;\n \n mod shapes {\n@@ -408,6 +412,7 @@ but instead, we found a floating-point variable. We need a different bound. `Flo\n to the rescue:\n \n ```\n+# #![feature(std_misc)]\n use std::num::Float;\n \n fn inverse<T: Float>(x: T) -> Result<T, String> {\n@@ -423,6 +428,7 @@ from the `Float` trait. Both `f32` and `f64` implement `Float`, so our function\n works just fine:\n \n ```\n+# #![feature(std_misc)]\n # use std::num::Float;\n # fn inverse<T: Float>(x: T) -> Result<T, String> {\n #     if x == Float::zero() { return Err(\"x cannot be zero!\".to_string()) }"}, {"sha": "2116976d55a4d56764bad679633c3cbb27d14533", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -187,6 +187,7 @@ As an example, we give a reimplementation of owned boxes by wrapping\n reimplementation is as safe as the `Box` type.\n \n ```\n+# #![feature(libc)]\n #![feature(unsafe_destructor)]\n \n extern crate libc;\n@@ -443,6 +444,7 @@ The function marked `#[start]` is passed the command line parameters\n in the same format as C:\n \n ```\n+# #![feature(libc)]\n #![feature(lang_items, start, no_std)]\n #![no_std]\n \n@@ -470,6 +472,7 @@ correct ABI and the correct name, which requires overriding the\n compiler's name mangling too:\n \n ```ignore\n+# #![feature(libc)]\n #![feature(no_std)]\n #![no_std]\n #![no_main]\n@@ -526,6 +529,7 @@ As an example, here is a program that will calculate the dot product of two\n vectors provided from C, using idiomatic Rust practices.\n \n ```\n+# #![feature(libc, core)]\n #![feature(lang_items, start, no_std)]\n #![no_std]\n \n@@ -650,6 +654,7 @@ and one for deallocation. A freestanding program that uses the `Box`\n sugar for dynamic allocations via `malloc` and `free`:\n \n ```\n+# #![feature(libc)]\n #![feature(lang_items, box_syntax, start, no_std)]\n #![no_std]\n "}, {"sha": "c9bbc0d74cddc8d745dedf6c2382767e0ceacbd8", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 50, "deletions": 34, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -95,6 +95,7 @@ use heap::deallocate;\n /// task.\n ///\n /// ```\n+/// # #![feature(alloc, core)]\n /// use std::sync::Arc;\n /// use std::thread;\n ///\n@@ -127,8 +128,8 @@ unsafe impl<T: Sync + Send> Sync for Arc<T> { }\n \n /// A weak pointer to an `Arc`.\n ///\n-/// Weak pointers will not keep the data inside of the `Arc` alive, and can be used to break cycles\n-/// between `Arc` pointers.\n+/// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n+/// used to break cycles between `Arc` pointers.\n #[unsafe_no_drop_flag]\n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n@@ -185,6 +186,7 @@ impl<T> Arc<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(alloc)]\n     /// use std::sync::Arc;\n     ///\n     /// let five = Arc::new(5);\n@@ -216,8 +218,8 @@ impl<T> Arc<T> {\n     unsafe fn drop_slow(&mut self) {\n         let ptr = *self._ptr;\n \n-        // Destroy the data at this time, even though we may not free the box allocation itself\n-        // (there may still be weak pointers lying around).\n+        // Destroy the data at this time, even though we may not free the box\n+        // allocation itself (there may still be weak pointers lying around).\n         drop(ptr::read(&self.inner().data));\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n@@ -246,6 +248,7 @@ impl<T> Clone for Arc<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(alloc)]\n     /// use std::sync::Arc;\n     ///\n     /// let five = Arc::new(5);\n@@ -283,12 +286,13 @@ impl<T> Deref for Arc<T> {\n impl<T: Send + Sync + Clone> Arc<T> {\n     /// Make a mutable reference from the given `Arc<T>`.\n     ///\n-    /// This is also referred to as a copy-on-write operation because the inner data is cloned if\n-    /// the reference count is greater than one.\n+    /// This is also referred to as a copy-on-write operation because the inner\n+    /// data is cloned if the reference count is greater than one.\n     ///\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(alloc)]\n     /// use std::sync::Arc;\n     ///\n     /// let mut five = Arc::new(5);\n@@ -298,16 +302,18 @@ impl<T: Send + Sync + Clone> Arc<T> {\n     #[inline]\n     #[unstable(feature = \"alloc\")]\n     pub fn make_unique(&mut self) -> &mut T {\n-        // Note that we hold a strong reference, which also counts as a weak reference, so we only\n-        // clone if there is an additional reference of either kind.\n+        // Note that we hold a strong reference, which also counts as a weak\n+        // reference, so we only clone if there is an additional reference of\n+        // either kind.\n         if self.inner().strong.load(SeqCst) != 1 ||\n            self.inner().weak.load(SeqCst) != 1 {\n             *self = Arc::new((**self).clone())\n         }\n-        // This unsafety is ok because we're guaranteed that the pointer returned is the *only*\n-        // pointer that will ever be returned to T. Our reference count is guaranteed to be 1 at\n-        // this point, and we required the Arc itself to be `mut`, so we're returning the only\n-        // possible reference to the inner data.\n+        // This unsafety is ok because we're guaranteed that the pointer\n+        // returned is the *only* pointer that will ever be returned to T. Our\n+        // reference count is guaranteed to be 1 at this point, and we required\n+        // the Arc itself to be `mut`, so we're returning the only possible\n+        // reference to the inner data.\n         let inner = unsafe { &mut **self._ptr };\n         &mut inner.data\n     }\n@@ -318,12 +324,14 @@ impl<T: Send + Sync + Clone> Arc<T> {\n impl<T: Sync + Send> Drop for Arc<T> {\n     /// Drops the `Arc<T>`.\n     ///\n-    /// This will decrement the strong reference count. If the strong reference count becomes zero\n-    /// and the only other references are `Weak<T>` ones, `drop`s the inner value.\n+    /// This will decrement the strong reference count. If the strong reference\n+    /// count becomes zero and the only other references are `Weak<T>` ones,\n+    /// `drop`s the inner value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(alloc)]\n     /// use std::sync::Arc;\n     ///\n     /// {\n@@ -342,29 +350,32 @@ impl<T: Sync + Send> Drop for Arc<T> {\n     /// ```\n     #[inline]\n     fn drop(&mut self) {\n-        // This structure has #[unsafe_no_drop_flag], so this drop glue may run more than once (but\n-        // it is guaranteed to be zeroed after the first if it's run more than once)\n+        // This structure has #[unsafe_no_drop_flag], so this drop glue may run\n+        // more than once (but it is guaranteed to be zeroed after the first if\n+        // it's run more than once)\n         let ptr = *self._ptr;\n         if ptr.is_null() { return }\n \n-        // Because `fetch_sub` is already atomic, we do not need to synchronize with other threads\n-        // unless we are going to delete the object. This same logic applies to the below\n-        // `fetch_sub` to the `weak` count.\n+        // Because `fetch_sub` is already atomic, we do not need to synchronize\n+        // with other threads unless we are going to delete the object. This\n+        // same logic applies to the below `fetch_sub` to the `weak` count.\n         if self.inner().strong.fetch_sub(1, Release) != 1 { return }\n \n-        // This fence is needed to prevent reordering of use of the data and deletion of the data.\n-        // Because it is marked `Release`, the decreasing of the reference count synchronizes with\n-        // this `Acquire` fence. This means that use of the data happens before decreasing the\n-        // reference count, which happens before this fence, which happens before the deletion of\n-        // the data.\n+        // This fence is needed to prevent reordering of use of the data and\n+        // deletion of the data.  Because it is marked `Release`, the decreasing\n+        // of the reference count synchronizes with this `Acquire` fence. This\n+        // means that use of the data happens before decreasing the reference\n+        // count, which happens before this fence, which happens before the\n+        // deletion of the data.\n         //\n         // As explained in the [Boost documentation][1],\n         //\n-        // > It is important to enforce any possible access to the object in one thread (through an\n-        // > existing reference) to *happen before* deleting the object in a different thread. This\n-        // > is achieved by a \"release\" operation after dropping a reference (any access to the\n-        // > object through this reference must obviously happened before), and an \"acquire\"\n-        // > operation before deleting the object.\n+        // > It is important to enforce any possible access to the object in one\n+        // > thread (through an existing reference) to *happen before* deleting\n+        // > the object in a different thread. This is achieved by a \"release\"\n+        // > operation after dropping a reference (any access to the object\n+        // > through this reference must obviously happened before), and an\n+        // > \"acquire\" operation before deleting the object.\n         //\n         // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n         atomic::fence(Acquire);\n@@ -382,11 +393,13 @@ impl<T: Sync + Send> Weak<T> {\n     ///\n     /// Upgrades the `Weak<T>` reference to an `Arc<T>`, if possible.\n     ///\n-    /// Returns `None` if there were no strong references and the data was destroyed.\n+    /// Returns `None` if there were no strong references and the data was\n+    /// destroyed.\n     ///\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(alloc)]\n     /// use std::sync::Arc;\n     ///\n     /// let five = Arc::new(5);\n@@ -396,8 +409,8 @@ impl<T: Sync + Send> Weak<T> {\n     /// let strong_five: Option<Arc<_>> = weak_five.upgrade();\n     /// ```\n     pub fn upgrade(&self) -> Option<Arc<T>> {\n-        // We use a CAS loop to increment the strong count instead of a fetch_add because once the\n-        // count hits 0 is must never be above 0.\n+        // We use a CAS loop to increment the strong count instead of a\n+        // fetch_add because once the count hits 0 is must never be above 0.\n         let inner = self.inner();\n         loop {\n             let n = inner.strong.load(SeqCst);\n@@ -424,6 +437,7 @@ impl<T: Sync + Send> Clone for Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(alloc)]\n     /// use std::sync::Arc;\n     ///\n     /// let weak_five = Arc::new(5).downgrade();\n@@ -448,6 +462,7 @@ impl<T: Sync + Send> Drop for Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(alloc)]\n     /// use std::sync::Arc;\n     ///\n     /// {\n@@ -472,8 +487,9 @@ impl<T: Sync + Send> Drop for Weak<T> {\n         // see comments above for why this check is here\n         if ptr.is_null() { return }\n \n-        // If we find out that we were the last weak pointer, then its time to deallocate the data\n-        // entirely. See the discussion in Arc::drop() about the memory orderings\n+        // If we find out that we were the last weak pointer, then its time to\n+        // deallocate the data entirely. See the discussion in Arc::drop() about\n+        // the memory orderings\n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n             unsafe { deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(),"}, {"sha": "8b18fbf554a4cad6218fb0bf99b79135c637aa1b", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -65,6 +65,7 @@ use core::raw::TraitObject;\n /// The following two examples are equivalent:\n ///\n /// ```\n+/// # #![feature(alloc)]\n /// #![feature(box_syntax)]\n /// use std::boxed::HEAP;\n ///\n@@ -135,6 +136,7 @@ impl<T : ?Sized> Box<T> {\n ///\n /// # Examples\n /// ```\n+/// # #![feature(alloc)]\n /// use std::boxed;\n ///\n /// let seventeen = Box::new(17u32);\n@@ -178,6 +180,7 @@ impl<T: Clone> Clone for Box<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(alloc, core)]\n     /// let x = Box::new(5);\n     /// let mut y = Box::new(10);\n     ///"}, {"sha": "3733350412e499a8c4d3623cf6fea8aeea403bc6", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -26,6 +26,9 @@ pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n ///\n /// On failure, return a null pointer and leave the original allocation intact.\n ///\n+/// If the allocation was relocated, the memory at the passed-in pointer is\n+/// undefined after the call.\n+///\n /// Behavior is undefined if the requested size is 0 or the alignment is not a\n /// power of 2. The alignment must be no larger than the largest supported page\n /// size on the platform."}, {"sha": "541de2d37fbe0cf68f47a6c51d6c9df8e96a2203", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -66,6 +66,7 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n+#![doc(test(no_crate_inject))]\n \n #![feature(no_std)]\n #![no_std]"}, {"sha": "eb3c5c167268bfe143f68dbef5fb449e6443b8b9", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 62, "deletions": 40, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -32,6 +32,7 @@\n //! and have the `Owner` remain allocated as long as any `Gadget` points at it.\n //!\n //! ```rust\n+//! # #![feature(alloc, collections)]\n //! use std::rc::Rc;\n //!\n //! struct Owner {\n@@ -58,12 +59,12 @@\n //!\n //!     drop(gadget_owner);\n //!\n-//!     // Despite dropping gadget_owner, we're still able to print out the name of\n-//!     // the Owner of the Gadgets. This is because we've only dropped the\n+//!     // Despite dropping gadget_owner, we're still able to print out the name\n+//!     // of the Owner of the Gadgets. This is because we've only dropped the\n //!     // reference count object, not the Owner it wraps. As long as there are\n-//!     // other `Rc<T>` objects pointing at the same Owner, it will remain allocated. Notice\n-//!     // that the `Rc<T>` wrapper around Gadget.owner gets automatically dereferenced\n-//!     // for us.\n+//!     // other `Rc<T>` objects pointing at the same Owner, it will remain\n+//!     // allocated. Notice that the `Rc<T>` wrapper around Gadget.owner gets\n+//!     // automatically dereferenced for us.\n //!     println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n //!     println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n //!\n@@ -73,21 +74,25 @@\n //! }\n //! ```\n //!\n-//! If our requirements change, and we also need to be able to traverse from Owner \u2192\u00a0Gadget, we\n-//! will run into problems: an `Rc<T>` pointer from Owner \u2192\u00a0Gadget introduces a cycle between the\n-//! objects. This means that their reference counts can never reach 0, and the objects will remain\n-//! allocated: a memory leak. In order to get around this, we can use `Weak<T>` pointers. These\n-//! pointers don't contribute to the total count.\n+//! If our requirements change, and we also need to be able to traverse from\n+//! Owner \u2192\u00a0Gadget, we will run into problems: an `Rc<T>` pointer from Owner\n+//! \u2192\u00a0Gadget introduces a cycle between the objects. This means that their\n+//! reference counts can never reach 0, and the objects will remain allocated: a\n+//! memory leak. In order to get around this, we can use `Weak<T>` pointers.\n+//! These pointers don't contribute to the total count.\n //!\n-//! Rust actually makes it somewhat difficult to produce this loop in the first place: in order to\n-//! end up with two objects that point at each other, one of them needs to be mutable. This is\n-//! problematic because `Rc<T>` enforces memory safety by only giving out shared references to the\n-//! object it wraps, and these don't allow direct mutation. We need to wrap the part of the object\n-//! we wish to mutate in a `RefCell`, which provides *interior mutability*: a method to achieve\n-//! mutability through a shared reference. `RefCell` enforces Rust's borrowing rules at runtime.\n-//! Read the `Cell` documentation for more details on interior mutability.\n+//! Rust actually makes it somewhat difficult to produce this loop in the first\n+//! place: in order to end up with two objects that point at each other, one of\n+//! them needs to be mutable. This is problematic because `Rc<T>` enforces\n+//! memory safety by only giving out shared references to the object it wraps,\n+//! and these don't allow direct mutation. We need to wrap the part of the\n+//! object we wish to mutate in a `RefCell`, which provides *interior\n+//! mutability*: a method to achieve mutability through a shared reference.\n+//! `RefCell` enforces Rust's borrowing rules at runtime.  Read the `Cell`\n+//! documentation for more details on interior mutability.\n //!\n //! ```rust\n+//! # #![feature(alloc)]\n //! use std::rc::Rc;\n //! use std::rc::Weak;\n //! use std::cell::RefCell;\n@@ -128,9 +133,10 @@\n //!     for gadget_opt in gadget_owner.gadgets.borrow().iter() {\n //!\n //!         // gadget_opt is a Weak<Gadget>. Since weak pointers can't guarantee\n-//!         // that their object is still allocated, we need to call upgrade() on them\n-//!         // to turn them into a strong reference. This returns an Option, which\n-//!         // contains a reference to our object if it still exists.\n+//!         // that their object is still allocated, we need to call upgrade()\n+//!         // on them to turn them into a strong reference. This returns an\n+//!         // Option, which contains a reference to our object if it still\n+//!         // exists.\n //!         let gadget = gadget_opt.upgrade().unwrap();\n //!         println!(\"Gadget {} owned by {}\", gadget.id, gadget.owner.name);\n //!     }\n@@ -178,8 +184,8 @@ struct RcBox<T> {\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T> {\n-    // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n-    // type via Deref\n+    // FIXME #12808: strange names to try to avoid interfering with field\n+    // accesses of the contained type via Deref\n     _ptr: NonZero<*mut RcBox<T>>,\n }\n \n@@ -201,9 +207,10 @@ impl<T> Rc<T> {\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n             Rc {\n-                // there is an implicit weak pointer owned by all the strong pointers, which\n-                // ensures that the weak destructor never frees the allocation while the strong\n-                // destructor is running, even if the weak pointer is stored inside the strong one.\n+                // there is an implicit weak pointer owned by all the strong\n+                // pointers, which ensures that the weak destructor never frees\n+                // the allocation while the strong destructor is running, even\n+                // if the weak pointer is stored inside the strong one.\n                 _ptr: NonZero::new(boxed::into_raw(box RcBox {\n                     value: value,\n                     strong: Cell::new(1),\n@@ -218,6 +225,7 @@ impl<T> Rc<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(alloc)]\n     /// use std::rc::Rc;\n     ///\n     /// let five = Rc::new(5);\n@@ -242,11 +250,13 @@ pub fn weak_count<T>(this: &Rc<T>) -> usize { this.weak() - 1 }\n #[unstable(feature = \"alloc\")]\n pub fn strong_count<T>(this: &Rc<T>) -> usize { this.strong() }\n \n-/// Returns true if there are no other `Rc` or `Weak<T>` values that share the same inner value.\n+/// Returns true if there are no other `Rc` or `Weak<T>` values that share the\n+/// same inner value.\n ///\n /// # Examples\n ///\n /// ```\n+/// # #![feature(alloc)]\n /// use std::rc;\n /// use std::rc::Rc;\n ///\n@@ -267,6 +277,7 @@ pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(alloc)]\n /// use std::rc::{self, Rc};\n ///\n /// let x = Rc::new(3);\n@@ -301,6 +312,7 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(alloc)]\n /// use std::rc::{self, Rc};\n ///\n /// let mut x = Rc::new(3);\n@@ -324,12 +336,13 @@ pub fn get_mut<'a, T>(rc: &'a mut Rc<T>) -> Option<&'a mut T> {\n impl<T: Clone> Rc<T> {\n     /// Make a mutable reference from the given `Rc<T>`.\n     ///\n-    /// This is also referred to as a copy-on-write operation because the inner data is cloned if\n-    /// the reference count is greater than one.\n+    /// This is also referred to as a copy-on-write operation because the inner\n+    /// data is cloned if the reference count is greater than one.\n     ///\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(alloc)]\n     /// use std::rc::Rc;\n     ///\n     /// let mut five = Rc::new(5);\n@@ -342,10 +355,11 @@ impl<T: Clone> Rc<T> {\n         if !is_unique(self) {\n             *self = Rc::new((**self).clone())\n         }\n-        // This unsafety is ok because we're guaranteed that the pointer returned is the *only*\n-        // pointer that will ever be returned to T. Our reference count is guaranteed to be 1 at\n-        // this point, and we required the `Rc<T>` itself to be `mut`, so we're returning the only\n-        // possible reference to the inner value.\n+        // This unsafety is ok because we're guaranteed that the pointer\n+        // returned is the *only* pointer that will ever be returned to T. Our\n+        // reference count is guaranteed to be 1 at this point, and we required\n+        // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n+        // reference to the inner value.\n         let inner = unsafe { &mut **self._ptr };\n         &mut inner.value\n     }\n@@ -366,12 +380,14 @@ impl<T> Deref for Rc<T> {\n impl<T> Drop for Rc<T> {\n     /// Drops the `Rc<T>`.\n     ///\n-    /// This will decrement the strong reference count. If the strong reference count becomes zero\n-    /// and the only other references are `Weak<T>` ones, `drop`s the inner value.\n+    /// This will decrement the strong reference count. If the strong reference\n+    /// count becomes zero and the only other references are `Weak<T>` ones,\n+    /// `drop`s the inner value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(alloc)]\n     /// use std::rc::Rc;\n     ///\n     /// {\n@@ -396,8 +412,8 @@ impl<T> Drop for Rc<T> {\n                 if self.strong() == 0 {\n                     ptr::read(&**self); // destroy the contained object\n \n-                    // remove the implicit \"strong weak\" pointer now that we've destroyed the\n-                    // contents.\n+                    // remove the implicit \"strong weak\" pointer now that we've\n+                    // destroyed the contents.\n                     self.dec_weak();\n \n                     if self.weak() == 0 {\n@@ -420,6 +436,7 @@ impl<T> Clone for Rc<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(alloc)]\n     /// use std::rc::Rc;\n     ///\n     /// let five = Rc::new(5);\n@@ -618,7 +635,8 @@ impl<T: fmt::Debug> fmt::Debug for Rc<T> {\n \n /// A weak version of `Rc<T>`.\n ///\n-/// Weak references do not count when determining if the inner value should be dropped.\n+/// Weak references do not count when determining if the inner value should be\n+/// dropped.\n ///\n /// See the [module level documentation](./index.html) for more.\n #[unsafe_no_drop_flag]\n@@ -643,11 +661,13 @@ impl<T> Weak<T> {\n     ///\n     /// Upgrades the `Weak<T>` reference to an `Rc<T>`, if possible.\n     ///\n-    /// Returns `None` if there were no strong references and the data was destroyed.\n+    /// Returns `None` if there were no strong references and the data was\n+    /// destroyed.\n     ///\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(alloc)]\n     /// use std::rc::Rc;\n     ///\n     /// let five = Rc::new(5);\n@@ -676,6 +696,7 @@ impl<T> Drop for Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(alloc)]\n     /// use std::rc::Rc;\n     ///\n     /// {\n@@ -699,8 +720,8 @@ impl<T> Drop for Weak<T> {\n             let ptr = *self._ptr;\n             if !ptr.is_null() {\n                 self.dec_weak();\n-                // the weak count starts at 1, and will only go to zero if all the strong pointers\n-                // have disappeared.\n+                // the weak count starts at 1, and will only go to zero if all\n+                // the strong pointers have disappeared.\n                 if self.weak() == 0 {\n                     deallocate(ptr as *mut u8, size_of::<RcBox<T>>(),\n                                min_align_of::<RcBox<T>>())\n@@ -721,6 +742,7 @@ impl<T> Clone for Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(alloc)]\n     /// use std::rc::Rc;\n     ///\n     /// let weak_five = Rc::new(5).downgrade();"}, {"sha": "6edee82dc30afe6e5d26ef498761197a9fb15739", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -216,6 +216,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BinaryHeap;\n     /// let heap = BinaryHeap::from_vec(vec![9, 1, 2, 7, 3, 2]);\n     /// ```\n@@ -235,6 +236,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BinaryHeap;\n     /// let heap = BinaryHeap::from_vec(vec![1, 2, 3, 4]);\n     ///\n@@ -255,6 +257,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BinaryHeap;\n     /// let heap = BinaryHeap::from_vec(vec![1, 2, 3, 4]);\n     ///\n@@ -360,6 +363,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::from_vec(vec![1, 3]);\n     ///\n@@ -405,6 +409,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n     /// heap.push(1);\n@@ -436,6 +441,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n     ///\n@@ -461,6 +467,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BinaryHeap;\n     /// let heap = BinaryHeap::from_vec(vec![1, 2, 3, 4, 5, 6, 7]);\n     /// let vec = heap.into_vec();\n@@ -478,6 +485,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BinaryHeap;\n     ///\n     /// let mut heap = BinaryHeap::from_vec(vec![1, 2, 4, 5, 7]);"}, {"sha": "377b52a3dbe292d4380c10816327493f3480e5f4", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -38,6 +38,7 @@\n //! [sieve]: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n //!\n //! ```\n+//! # #![feature(collections, core)]\n //! use std::collections::{BitSet, BitVec};\n //! use std::num::Float;\n //! use std::iter;\n@@ -134,6 +135,7 @@ static FALSE: bool = false;\n /// # Examples\n ///\n /// ```\n+/// # #![feature(collections)]\n /// use std::collections::BitVec;\n ///\n /// let mut bv = BitVec::from_elem(10, false);\n@@ -169,6 +171,8 @@ pub struct BitVec {\n impl Index<usize> for BitVec {\n     type Output = bool;\n \n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, i: &usize) -> &bool {\n         if self.get(*i).expect(\"index out of bounds\") {\n@@ -177,6 +181,16 @@ impl Index<usize> for BitVec {\n             &FALSE\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, i: usize) -> &bool {\n+        if self.get(i).expect(\"index out of bounds\") {\n+            &TRUE\n+        } else {\n+            &FALSE\n+        }\n+    }\n }\n \n /// Computes how many blocks are needed to store that many bits\n@@ -250,6 +264,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     /// let mut bv = BitVec::new();\n     /// ```\n@@ -264,6 +279,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_elem(10, false);\n@@ -304,6 +320,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let bv = BitVec::from_bytes(&[0b10100000, 0b00010010]);\n@@ -346,6 +363,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let bv = BitVec::from_fn(5, |i| { i % 2 == 0 });\n@@ -364,6 +382,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let bv = BitVec::from_bytes(&[0b01100000]);\n@@ -396,6 +415,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_elem(5, false);\n@@ -420,6 +440,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let before = 0b01100000;\n@@ -440,6 +461,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let before = 0b01100000;\n@@ -468,6 +490,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let a   = 0b01100100;\n@@ -498,6 +521,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let a   = 0b01100100;\n@@ -528,6 +552,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let a   = 0b01100100;\n@@ -557,6 +582,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_elem(5, true);\n@@ -581,6 +607,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let bv = BitVec::from_bytes(&[0b01110100, 0b10010010]);\n@@ -597,6 +624,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_elem(10, false);\n@@ -614,6 +642,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_elem(10, false);\n@@ -635,6 +664,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_elem(3, true);\n@@ -682,6 +712,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let bv = BitVec::from_bytes(&[0b10100000]);\n@@ -702,6 +733,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_bytes(&[0b01001011]);\n@@ -728,6 +760,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_elem(3, false);\n@@ -758,6 +791,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_elem(3, false);\n@@ -780,6 +814,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::new();\n@@ -801,6 +836,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_bytes(&[0b01001011]);\n@@ -851,6 +887,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::from_bytes(&[0b01001001]);\n@@ -881,6 +918,7 @@ impl BitVec {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitVec;\n     ///\n     /// let mut bv = BitVec::new();\n@@ -1091,6 +1129,7 @@ impl<'a> IntoIterator for &'a BitVec {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(collections)]\n /// use std::collections::{BitSet, BitVec};\n ///\n /// // It's a regular set\n@@ -1187,6 +1226,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitSet;\n     ///\n     /// let mut s = BitSet::new();\n@@ -1203,6 +1243,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitSet;\n     ///\n     /// let mut s = BitSet::with_capacity(100);\n@@ -1220,6 +1261,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::{BitVec, BitSet};\n     ///\n     /// let bv = BitVec::from_bytes(&[0b01100000]);\n@@ -1249,6 +1291,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitSet;\n     ///\n     /// let mut s = BitSet::with_capacity(100);\n@@ -1270,6 +1313,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitSet;\n     ///\n     /// let mut s = BitSet::new();\n@@ -1296,6 +1340,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitSet;\n     ///\n     /// let mut s = BitSet::new();\n@@ -1316,6 +1361,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitSet;\n     ///\n     /// let mut s = BitSet::new();\n@@ -1336,6 +1382,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitSet;\n     ///\n     /// let mut s = BitSet::new();\n@@ -1382,6 +1429,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BitSet;\n     ///\n     /// let mut s = BitSet::new();\n@@ -1414,6 +1462,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::{BitVec, BitSet};\n     ///\n     /// let s = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01001010]));\n@@ -1435,6 +1484,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::{BitVec, BitSet};\n     ///\n     /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n@@ -1465,6 +1515,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::{BitVec, BitSet};\n     ///\n     /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n@@ -1495,6 +1546,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n@@ -1533,6 +1585,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b01101000]));\n@@ -1562,6 +1615,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n@@ -1585,6 +1639,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n@@ -1609,6 +1664,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n@@ -1641,6 +1697,7 @@ impl BitSet {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::{BitSet, BitVec};\n     ///\n     /// let a   = 0b01101000;\n@@ -1792,12 +1849,16 @@ struct TwoBitPositions<'a> {\n     next_idx: usize\n }\n \n+#[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a>(TwoBitPositions<'a>);\n+#[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a>(Take<TwoBitPositions<'a>>);\n+#[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a>(TwoBitPositions<'a>);\n+#[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a>(TwoBitPositions<'a>);\n "}, {"sha": "88d59f699d183030c7c2f665ee3ecd2bd813813a", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,7 @@\n \n use core::clone::Clone;\n use core::cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n+use core::convert::AsRef;\n use core::hash::{Hash, Hasher};\n use core::marker::Sized;\n use core::ops::Deref;\n@@ -291,10 +292,9 @@ impl<'a, B: ?Sized> Hash for Cow<'a, B> where B: Hash + ToOwned\n }\n \n /// Trait for moving into a `Cow`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\")]\n pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n     /// Moves `self` into `Cow`\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn into_cow(self) -> Cow<'a, B>;\n }\n \n@@ -304,3 +304,10 @@ impl<'a,  B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n         self\n     }\n }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: Clone> AsRef<T> for Cow<'a, T> {\n+    fn as_ref(&self) -> &T {\n+        self\n+    }\n+}"}, {"sha": "c2f6fbc0b2602cb62c537c23d9c2eb3c9e3905c9", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -78,6 +78,7 @@ pub struct BTreeMap<K, V> {\n }\n \n /// An abstract base over-which all other BTree iterators are built.\n+#[derive(Clone)]\n struct AbsIter<T> {\n     traversals: VecDeque<T>,\n     size: usize,\n@@ -124,26 +125,26 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n }\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n-#[unstable(feature = \"collections\",\n-           reason = \"precise API still under development\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Entry<'a, K:'a, V:'a> {\n     /// A vacant Entry\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Vacant(VacantEntry<'a, K, V>),\n+\n     /// An occupied Entry\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Occupied(OccupiedEntry<'a, K, V>),\n }\n \n /// A vacant Entry.\n-#[unstable(feature = \"collections\",\n-           reason = \"precise API still under development\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VacantEntry<'a, K:'a, V:'a> {\n     key: K,\n     stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n \n /// An occupied Entry.\n-#[unstable(feature = \"collections\",\n-           reason = \"precise API still under development\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n     stack: stack::SearchStack<'a, K, V, node::handle::KV, node::handle::LeafOrInternal>,\n }\n@@ -264,7 +265,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n     /// }\n-    /// assert_eq!(map[1], \"b\");\n+    /// assert_eq!(map[&1], \"b\");\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -326,7 +327,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// map.insert(37, \"b\");\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n-    /// assert_eq!(map[37], \"c\");\n+    /// assert_eq!(map[&37], \"c\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, mut key: K, mut value: V) -> Option<V> {\n@@ -914,12 +915,27 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n     }\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n     where K: Borrow<Q>, Q: Ord\n {\n     type Output = V;\n \n+    #[inline]\n+    fn index(&self, key: &Q) -> &V {\n+        self.get(key).expect(\"no entry found for key\")\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n+    where K: Borrow<Q>, Q: Ord\n+{\n+    type Output = V;\n+\n+    #[inline]\n     fn index(&self, key: &Q) -> &V {\n         self.get(key).expect(\"no entry found for key\")\n     }\n@@ -1025,6 +1041,9 @@ impl<K, V, E, T> DoubleEndedIterator for AbsIter<T> where\n     }\n }\n \n+impl<'a, K, V> Clone for Iter<'a, K, V> {\n+    fn clone(&self) -> Iter<'a, K, V> { Iter { inner: self.inner.clone() } }\n+}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n@@ -1067,6 +1086,9 @@ impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {}\n \n+impl<'a, K, V> Clone for Keys<'a, K, V> {\n+    fn clone(&self) -> Keys<'a, K, V> { Keys { inner: self.inner.clone() } }\n+}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n@@ -1082,6 +1104,9 @@ impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {\n impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {}\n \n \n+impl<'a, K, V> Clone for Values<'a, K, V> {\n+    fn clone(&self) -> Values<'a, K, V> { Values { inner: self.inner.clone() } }\n+}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n@@ -1096,6 +1121,9 @@ impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n+impl<'a, K, V> Clone for Range<'a, K, V> {\n+    fn clone(&self) -> Range<'a, K, V> { Range { inner: self.inner.clone() } }\n+}\n impl<'a, K, V> Iterator for Range<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n@@ -1115,9 +1143,9 @@ impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n }\n \n impl<'a, K: Ord, V> Entry<'a, K, V> {\n-    #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"will soon be replaced by or_insert\")]\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n         match self {\n             Occupied(entry) => Ok(entry.into_mut()),\n@@ -1269,6 +1297,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut a = BTreeMap::new();\n@@ -1291,6 +1320,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut a = BTreeMap::new();\n@@ -1478,6 +1508,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BTreeMap;\n     /// use std::collections::Bound::{Included, Unbounded};\n     ///\n@@ -1504,6 +1535,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BTreeMap;\n     /// use std::collections::Bound::{Included, Excluded};\n     ///\n@@ -1529,6 +1561,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BTreeMap;\n     /// use std::collections::btree_map::Entry;\n     ///"}, {"sha": "23eafa41d8a01d4075737d74cae3b39171b6a5cd", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -1326,6 +1326,7 @@ trait TraversalImpl {\n \n /// A `TraversalImpl` that actually is backed by two iterators. This works in the non-moving case,\n /// as no deallocation needs to be done.\n+#[derive(Clone)]\n struct ElemsAndEdges<Elems, Edges>(Elems, Edges);\n \n impl<K, V, E, Elems: DoubleEndedIterator, Edges: DoubleEndedIterator>\n@@ -1404,6 +1405,7 @@ impl<K, V> Drop for MoveTraversalImpl<K, V> {\n }\n \n /// An abstraction over all the different kinds of traversals a node supports\n+#[derive(Clone)]\n struct AbsTraversal<Impl> {\n     inner: Impl,\n     head_is_edge: bool,\n@@ -1522,6 +1524,7 @@ macro_rules! node_slice_impl {\n             }\n \n             /// Returns a sub-slice with elements starting with `min_key`.\n+            #[cfg(stage0)]\n             pub fn slice_from(self, min_key: &K) -> $NodeSlice<'a, K, V> {\n                 //  _______________\n                 // |_1_|_3_|_5_|_7_|\n@@ -1549,7 +1552,37 @@ macro_rules! node_slice_impl {\n                 }\n             }\n \n+            /// Returns a sub-slice with elements starting with `min_key`.\n+            #[cfg(not(stage0))]\n+            pub fn slice_from(self, min_key: &K) -> $NodeSlice<'a, K, V> {\n+                //  _______________\n+                // |_1_|_3_|_5_|_7_|\n+                // |   |   |   |   |\n+                // 0 0 1 1 2 2 3 3 4  index\n+                // |   |   |   |   |\n+                // \\___|___|___|___/  slice_from(&0); pos = 0\n+                //     \\___|___|___/  slice_from(&2); pos = 1\n+                //     |___|___|___/  slice_from(&3); pos = 1; result.head_is_edge = false\n+                //         \\___|___/  slice_from(&4); pos = 2\n+                //             \\___/  slice_from(&6); pos = 3\n+                //                \\|/ slice_from(&999); pos = 4\n+                let (pos, pos_is_kv) = self.search_linear(min_key);\n+                $NodeSlice {\n+                    has_edges: self.has_edges,\n+                    edges: if !self.has_edges {\n+                        self.edges\n+                    } else {\n+                        self.edges.$index(pos ..)\n+                    },\n+                    keys: &self.keys[pos ..],\n+                    vals: self.vals.$index(pos ..),\n+                    head_is_edge: !pos_is_kv,\n+                    tail_is_edge: self.tail_is_edge,\n+                }\n+            }\n+\n             /// Returns a sub-slice with elements up to and including `max_key`.\n+            #[cfg(stage0)]\n             pub fn slice_to(self, max_key: &K) -> $NodeSlice<'a, K, V> {\n                 //  _______________\n                 // |_1_|_3_|_5_|_7_|\n@@ -1577,6 +1610,36 @@ macro_rules! node_slice_impl {\n                     tail_is_edge: !pos_is_kv,\n                 }\n             }\n+\n+            /// Returns a sub-slice with elements up to and including `max_key`.\n+            #[cfg(not(stage0))]\n+            pub fn slice_to(self, max_key: &K) -> $NodeSlice<'a, K, V> {\n+                //  _______________\n+                // |_1_|_3_|_5_|_7_|\n+                // |   |   |   |   |\n+                // 0 0 1 1 2 2 3 3 4  index\n+                // |   |   |   |   |\n+                //\\|/  |   |   |   |  slice_to(&0); pos = 0\n+                // \\___/   |   |   |  slice_to(&2); pos = 1\n+                // \\___|___|   |   |  slice_to(&3); pos = 1; result.tail_is_edge = false\n+                // \\___|___/   |   |  slice_to(&4); pos = 2\n+                // \\___|___|___/   |  slice_to(&6); pos = 3\n+                // \\___|___|___|___/  slice_to(&999); pos = 4\n+                let (pos, pos_is_kv) = self.search_linear(max_key);\n+                let pos = pos + if pos_is_kv { 1 } else { 0 };\n+                $NodeSlice {\n+                    has_edges: self.has_edges,\n+                    edges: if !self.has_edges {\n+                        self.edges\n+                    } else {\n+                        self.edges.$index(.. (pos + 1))\n+                    },\n+                    keys: &self.keys[..pos],\n+                    vals: self.vals.$index(.. pos),\n+                    head_is_edge: self.head_is_edge,\n+                    tail_is_edge: !pos_is_kv,\n+                }\n+            }\n         }\n \n         impl<'a, K: 'a, V: 'a> $NodeSlice<'a, K, V> {"}, {"sha": "08ee5801482fdb44e81a4531142527c987315401", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -116,6 +116,7 @@ impl<T> BTreeSet<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::BTreeSet;\n     ///\n     /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().cloned().collect();\n@@ -137,6 +138,7 @@ impl<T> BTreeSet<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::BTreeSet;\n     ///\n     /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().cloned().collect();\n@@ -162,6 +164,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::BTreeSet;\n     /// use std::collections::Bound::{Included, Unbounded};\n     ///\n@@ -190,6 +193,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut a = BTreeSet::new();\n@@ -213,6 +217,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut a = BTreeSet::new();\n@@ -237,6 +242,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut a = BTreeSet::new();\n@@ -261,6 +267,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut a = BTreeSet::new();\n@@ -333,6 +340,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::BTreeSet;\n     ///\n     /// let set: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\n@@ -350,6 +358,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::BTreeSet;\n     ///\n     /// let a: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\n@@ -371,6 +380,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::BTreeSet;\n     ///\n     /// let sup: BTreeSet<_> = [1, 2, 3].iter().cloned().collect();\n@@ -413,6 +423,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::BTreeSet;\n     ///\n     /// let sub: BTreeSet<_> = [1, 2].iter().cloned().collect();\n@@ -628,6 +639,9 @@ impl<T: Debug> Debug for BTreeSet<T> {\n     }\n }\n \n+impl<'a, T> Clone for Iter<'a, T> {\n+    fn clone(&self) -> Iter<'a, T> { Iter { iter: self.iter.clone() } }\n+}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Iter<'a, T> {\n     type Item = &'a T;\n@@ -658,6 +672,9 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n \n+impl<'a, T> Clone for Range<'a, T> {\n+    fn clone(&self) -> Range<'a, T> { Range { iter: self.iter.clone() } }\n+}\n impl<'a, T> Iterator for Range<'a, T> {\n     type Item = &'a T;\n \n@@ -677,6 +694,11 @@ fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n     }\n }\n \n+impl<'a, T> Clone for Difference<'a, T> {\n+    fn clone(&self) -> Difference<'a, T> {\n+        Difference { a: self.a.clone(), b: self.b.clone() }\n+    }\n+}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     type Item = &'a T;\n@@ -692,6 +714,11 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     }\n }\n \n+impl<'a, T> Clone for SymmetricDifference<'a, T> {\n+    fn clone(&self) -> SymmetricDifference<'a, T> {\n+        SymmetricDifference { a: self.a.clone(), b: self.b.clone() }\n+    }\n+}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n     type Item = &'a T;\n@@ -707,6 +734,11 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n     }\n }\n \n+impl<'a, T> Clone for Intersection<'a, T> {\n+    fn clone(&self) -> Intersection<'a, T> {\n+        Intersection { a: self.a.clone(), b: self.b.clone() }\n+    }\n+}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     type Item = &'a T;\n@@ -728,6 +760,11 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     }\n }\n \n+impl<'a, T> Clone for Union<'a, T> {\n+    fn clone(&self) -> Union<'a, T> {\n+        Union { a: self.a.clone(), b: self.b.clone() }\n+    }\n+}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Union<'a, T> {\n     type Item = &'a T;"}, {"sha": "b106f4adbc708219524bf1a368cdac19211c7689", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -174,6 +174,7 @@\n //! like:\n //!\n //! ```\n+//! # #![feature(core, std_misc)]\n //! use std::fmt;\n //! use std::f64;\n //! use std::num::Float;\n@@ -261,6 +262,7 @@\n //! Example usage is:\n //!\n //! ```\n+//! # #![feature(old_io)]\n //! # #![allow(unused_must_use)]\n //! use std::io::Write;\n //! let mut w = Vec::new();\n@@ -288,6 +290,7 @@\n //! off, some example usage is:\n //!\n //! ```\n+//! # #![feature(old_io)]\n //! use std::fmt;\n //! use std::io::{self, Write};\n //!"}, {"sha": "da2c61b6fd394a47cb1946a149376655c582010f", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -22,6 +22,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n+#![doc(test(no_crate_inject))]\n \n #![feature(alloc)]\n #![feature(box_syntax)]\n@@ -36,7 +37,8 @@\n #![feature(unsafe_no_drop_flag)]\n #![feature(step_by)]\n #![feature(str_char)]\n-#![cfg_attr(test, feature(rand, rustc_private, test))]\n+#![feature(convert)]\n+#![cfg_attr(test, feature(rand, rustc_private, test, hash, collections))]\n #![cfg_attr(test, allow(deprecated))] // rand\n \n #![feature(no_std)]"}, {"sha": "908c78a17f4f96ef2743f5b9a52dc3e56a5d4952", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -235,6 +235,7 @@ impl<T> LinkedList<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::LinkedList;\n     ///\n     /// let mut a = LinkedList::new();\n@@ -483,6 +484,7 @@ impl<T> LinkedList<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::LinkedList;\n     ///\n     /// let mut dl = LinkedList::new();\n@@ -530,6 +532,7 @@ impl<T> LinkedList<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::LinkedList;\n     ///\n     /// let mut d = LinkedList::new();\n@@ -548,6 +551,7 @@ impl<T> LinkedList<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::LinkedList;\n     ///\n     /// let mut d = LinkedList::new();\n@@ -573,6 +577,7 @@ impl<T> LinkedList<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::LinkedList;\n     ///\n     /// let mut d = LinkedList::new();\n@@ -765,6 +770,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::LinkedList;\n     ///\n     /// let mut list: LinkedList<_> = vec![1, 3, 4].into_iter().collect();\n@@ -792,6 +798,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::LinkedList;\n     ///\n     /// let mut list: LinkedList<_> = vec![1, 2, 3].into_iter().collect();\n@@ -832,6 +839,8 @@ impl<A> DoubleEndedIterator for IntoIter<A> {\n     fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n }\n \n+impl<A> ExactSizeIterator for IntoIter<A> {}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> FromIterator<A> for LinkedList<A> {\n     fn from_iter<T: IntoIterator<Item=A>>(iter: T) -> LinkedList<A> {"}, {"sha": "2a668b0869d2529ab61a18611a59ba5bc5d976bf", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,7 @@\n //! Slices are a view into a block of memory represented as a pointer and a length.\n //!\n //! ```rust\n+//! # #![feature(core)]\n //! // slicing a Vec\n //! let vec = vec!(1, 2, 3);\n //! let int_slice = vec.as_slice();\n@@ -88,6 +89,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use alloc::boxed::Box;\n+use core::convert::AsRef;\n use core::clone::Clone;\n use core::cmp::Ordering::{self, Greater, Less};\n use core::cmp::{self, Ord, PartialEq};\n@@ -270,6 +272,7 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```rust\n+    /// # #![feature(collections)]\n     /// let mut a = [1, 2, 3, 4, 5];\n     /// let b = vec![6, 7, 8];\n     /// let num_moved = a.move_from(b, 0, 3);\n@@ -560,6 +563,7 @@ impl<T> [T] {\n     /// found; the fourth could match any position in `[1,4]`.\n     ///\n     /// ```rust\n+    /// # #![feature(core)]\n     /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n     /// let s = s.as_slice();\n     ///\n@@ -842,6 +846,7 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```rust\n+    /// # #![feature(collections)]\n     /// let v = [1, 2, 3];\n     /// let mut perms = v.permutations();\n     ///\n@@ -853,6 +858,7 @@ impl<T> [T] {\n     /// Iterating through permutations one by one.\n     ///\n     /// ```rust\n+    /// # #![feature(collections)]\n     /// let v = [1, 2, 3];\n     /// let mut perms = v.permutations();\n     ///\n@@ -874,6 +880,7 @@ impl<T> [T] {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![feature(collections)]\n     /// let mut dst = [0, 0, 0];\n     /// let src = [1, 2];\n     ///\n@@ -921,6 +928,7 @@ impl<T> [T] {\n     /// found; the fourth could match any position in `[1,4]`.\n     ///\n     /// ```rust\n+    /// # #![feature(core)]\n     /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n     /// let s = s.as_slice();\n     ///\n@@ -950,6 +958,7 @@ impl<T> [T] {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![feature(collections)]\n     /// let v: &mut [_] = &mut [0, 1, 2];\n     /// v.next_permutation();\n     /// let b: &mut [_] = &mut [0, 2, 1];\n@@ -972,6 +981,7 @@ impl<T> [T] {\n     /// # Example\n     ///\n     /// ```rust\n+    /// # #![feature(collections)]\n     /// let v: &mut [_] = &mut [1, 0, 2];\n     /// v.prev_permutation();\n     /// let b: &mut [_] = &mut [0, 2, 1];\n@@ -1088,23 +1098,23 @@ pub trait SliceConcatExt<T: ?Sized, U> {\n     fn connect(&self, sep: &T) -> U;\n }\n \n-impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n+impl<T: Clone, V: AsRef<[T]>> SliceConcatExt<T, Vec<T>> for [V] {\n     fn concat(&self) -> Vec<T> {\n-        let size = self.iter().fold(0, |acc, v| acc + v.as_slice().len());\n+        let size = self.iter().fold(0, |acc, v| acc + v.as_ref().len());\n         let mut result = Vec::with_capacity(size);\n         for v in self {\n-            result.push_all(v.as_slice())\n+            result.push_all(v.as_ref())\n         }\n         result\n     }\n \n     fn connect(&self, sep: &T) -> Vec<T> {\n-        let size = self.iter().fold(0, |acc, v| acc + v.as_slice().len());\n+        let size = self.iter().fold(0, |acc, v| acc + v.as_ref().len());\n         let mut result = Vec::with_capacity(size + self.len());\n         let mut first = true;\n         for v in self {\n             if first { first = false } else { result.push(sep.clone()) }\n-            result.push_all(v.as_slice())\n+            result.push_all(v.as_ref())\n         }\n         result\n     }"}, {"sha": "ca2786e843e97031c56e1d37d7b63aa443d096ab", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 63, "deletions": 25, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -61,10 +61,10 @@ use core::iter::AdditiveIterator;\n use core::iter::{Iterator, IteratorExt, Extend};\n use core::option::Option::{self, Some, None};\n use core::result::Result;\n-use core::slice::AsSlice;\n use core::str as core_str;\n use unicode::str::{UnicodeStr, Utf16Encoder};\n \n+use core::convert::AsRef;\n use vec_deque::VecDeque;\n use borrow::{Borrow, ToOwned};\n use string::String;\n@@ -74,8 +74,8 @@ use slice::SliceConcatExt;\n \n pub use core::str::{FromStr, Utf8Error, Str};\n pub use core::str::{Lines, LinesAny, MatchIndices, SplitStr, CharRange};\n-pub use core::str::{Split, SplitTerminator};\n-pub use core::str::{SplitN, RSplitN};\n+pub use core::str::{Split, SplitTerminator, SplitN};\n+pub use core::str::{RSplit, RSplitN};\n pub use core::str::{from_utf8, CharEq, Chars, CharIndices, Bytes};\n pub use core::str::{from_utf8_unchecked, from_c_str, ParseBoolError};\n pub use unicode::str::{Words, Graphemes, GraphemeIndices};\n@@ -86,51 +86,47 @@ pub use core::str::{Searcher, ReverseSearcher, DoubleEndedSearcher, SearchStep};\n Section: Creating a string\n */\n \n-impl<S: Str> SliceConcatExt<str, String> for [S] {\n+impl<S: AsRef<str>> SliceConcatExt<str, String> for [S] {\n     fn concat(&self) -> String {\n-        let s = self.as_slice();\n-\n-        if s.is_empty() {\n+        if self.is_empty() {\n             return String::new();\n         }\n \n         // `len` calculation may overflow but push_str will check boundaries\n-        let len = s.iter().map(|s| s.as_slice().len()).sum();\n+        let len = self.iter().map(|s| s.as_ref().len()).sum();\n         let mut result = String::with_capacity(len);\n \n-        for s in s {\n-            result.push_str(s.as_slice())\n+        for s in self {\n+            result.push_str(s.as_ref())\n         }\n \n         result\n     }\n \n     fn connect(&self, sep: &str) -> String {\n-        let s = self.as_slice();\n-\n-        if s.is_empty() {\n+        if self.is_empty() {\n             return String::new();\n         }\n \n         // concat is faster\n         if sep.is_empty() {\n-            return s.concat();\n+            return self.concat();\n         }\n \n         // this is wrong without the guarantee that `self` is non-empty\n         // `len` calculation may overflow but push_str but will check boundaries\n-        let len = sep.len() * (s.len() - 1)\n-            + s.iter().map(|s| s.as_slice().len()).sum();\n+        let len = sep.len() * (self.len() - 1)\n+            + self.iter().map(|s| s.as_ref().len()).sum();\n         let mut result = String::with_capacity(len);\n         let mut first = true;\n \n-        for s in s {\n+        for s in self {\n             if first {\n                 first = false;\n             } else {\n                 result.push_str(sep);\n             }\n-            result.push_str(s.as_slice());\n+            result.push_str(s.as_ref());\n         }\n         result\n     }\n@@ -548,6 +544,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// assert!(\"hello\".contains_char('e'));\n     ///\n     /// assert!(!\"hello\".contains_char('z'));\n@@ -699,23 +696,48 @@ impl str {\n         core_str::StrExt::split_terminator(&self[..], pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters matched by a pattern,\n+    /// An iterator over substrings of `self`, separated by a pattern,\n     /// starting from the end of the string.\n     ///\n-    /// Restricted to splitting at most `count` times.\n+    /// # Examples\n     ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplit(|c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rsplit(&self[..], pat)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by a pattern,\n+    /// starting from the end of the string, restricted to splitting\n+    /// at most `count` times.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n     /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(1, \"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n     /// ```\n     ///\n     /// More complex patterns with a lambda:\n@@ -725,7 +747,9 @@ impl str {\n     /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P> {\n+    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n         core_str::StrExt::rsplitn(&self[..], count, pat)\n     }\n \n@@ -739,6 +763,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n     /// assert_eq!(v, [(0,3), (6,9), (12,15)]);\n     ///\n@@ -761,6 +786,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let v: Vec<&str> = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n     /// assert_eq!(v, [\"\", \"XXX\", \"YYY\", \"\"]);\n     ///\n@@ -869,6 +895,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n@@ -1019,6 +1046,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(str_char)]\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// assert!(s.is_char_boundary(0));\n     /// // start of `\u8001`\n@@ -1055,6 +1083,7 @@ impl str {\n     /// done by `.chars()` or `.char_indices()`.\n     ///\n     /// ```\n+    /// # #![feature(str_char, core)]\n     /// use std::str::CharRange;\n     ///\n     /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n@@ -1105,6 +1134,7 @@ impl str {\n     /// done by `.chars().rev()` or `.char_indices()`.\n     ///\n     /// ```\n+    /// # #![feature(str_char, core)]\n     /// use std::str::CharRange;\n     ///\n     /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n@@ -1148,6 +1178,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(str_char)]\n     /// let s = \"ab\u03c0c\";\n     /// assert_eq!(s.char_at(1), 'b');\n     /// assert_eq!(s.char_at(2), '\u03c0');\n@@ -1172,6 +1203,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(str_char)]\n     /// let s = \"ab\u03c0c\";\n     /// assert_eq!(s.char_at_reverse(1), 'a');\n     /// assert_eq!(s.char_at_reverse(2), 'b');\n@@ -1286,6 +1318,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n@@ -1307,6 +1340,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(str_char)]\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// let (c, s1) = s.slice_shift_char().unwrap();\n     ///\n@@ -1335,6 +1369,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let string = \"a\\nb\\nc\";\n     /// let lines: Vec<&str> = string.lines().collect();\n     ///\n@@ -1434,6 +1469,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(unicode, core)]\n     /// let gr1 = \"a\\u{310}e\\u{301}o\\u{308}\\u{332}\".graphemes(true).collect::<Vec<&str>>();\n     /// let b: &[_] = &[\"a\\u{310}\", \"e\\u{301}\", \"o\\u{308}\\u{332}\"];\n     ///\n@@ -1456,6 +1492,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(unicode, core)]\n     /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(usize, &str)>>();\n     /// let b: &[_] = &[(0, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n     ///\n@@ -1475,6 +1512,7 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(str_words)]\n     /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n     /// let v: Vec<&str> = some_words.words().collect();\n     ///"}, {"sha": "a61eaecd2b1ea36dcf2b892b05c0df9a6eac7f50", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -25,6 +25,7 @@ use core::mem;\n use core::ops::{self, Deref, Add, Index};\n use core::ptr;\n use core::slice;\n+use core::str::Pattern;\n use unicode::str as unicode_str;\n use unicode::str::Utf16Item;\n \n@@ -90,6 +91,7 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections, core)]\n     /// let s = String::from_str(\"hello\");\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n@@ -122,6 +124,7 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::str::Utf8Error;\n     ///\n     /// let hello_vec = vec![104, 101, 108, 108, 111];\n@@ -350,6 +353,7 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let s = String::from_str(\"hello\");\n     /// let bytes = s.into_bytes();\n     /// assert_eq!(bytes, [104, 101, 108, 108, 111]);\n@@ -365,6 +369,7 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let mut s = String::from_str(\"foo\");\n     /// s.push_str(\"bar\");\n     /// assert_eq!(s, \"foobar\");\n@@ -441,6 +446,7 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let mut s = String::from_str(\"foo\");\n     /// s.reserve(100);\n     /// assert!(s.capacity() >= 100);\n@@ -458,6 +464,7 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let mut s = String::from_str(\"abc\");\n     /// s.push('1');\n     /// s.push('2');\n@@ -493,6 +500,7 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let s = String::from_str(\"hello\");\n     /// let b: &[_] = &[104, 101, 108, 108, 111];\n     /// assert_eq!(s.as_bytes(), b);\n@@ -513,6 +521,7 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let mut s = String::from_str(\"hello\");\n     /// s.truncate(2);\n     /// assert_eq!(s, \"he\");\n@@ -530,6 +539,7 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let mut s = String::from_str(\"foo\");\n     /// assert_eq!(s.pop(), Some('o'));\n     /// assert_eq!(s.pop(), Some('o'));\n@@ -567,6 +577,7 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let mut s = String::from_str(\"foo\");\n     /// assert_eq!(s.remove(0), 'f');\n     /// assert_eq!(s.remove(1), 'o');\n@@ -629,6 +640,7 @@ impl String {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let mut s = String::from_str(\"hello\");\n     /// unsafe {\n     ///     let vec = s.as_mut_vec();\n@@ -765,6 +777,25 @@ impl<'a> Extend<&'a str> for String {\n     }\n }\n \n+/// A convenience impl that delegates to the impl for `&str`\n+impl<'a, 'b> Pattern<'a> for &'b String {\n+    type Searcher = <&'b str as Pattern<'a>>::Searcher;\n+\n+    fn into_searcher(self, haystack: &'a str) -> <&'b str as Pattern<'a>>::Searcher {\n+        self[..].into_searcher(haystack)\n+    }\n+\n+    #[inline]\n+    fn is_contained_in(self, haystack: &'a str) -> bool {\n+        self[..].is_contained_in(haystack)\n+    }\n+\n+    #[inline]\n+    fn is_prefix_of(self, haystack: &'a str) -> bool {\n+        self[..].is_prefix_of(haystack)\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl PartialEq for String {\n     #[inline]\n@@ -814,6 +845,7 @@ impl<'a, 'b> PartialEq<Cow<'a, str>> for &'b str {\n }\n \n #[unstable(feature = \"collections\", reason = \"waiting on Str stabilization\")]\n+#[allow(deprecated)]\n impl Str for String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -870,34 +902,66 @@ impl<'a> Add<&'a str> for String {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::Range<usize>> for String {\n     type Output = str;\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &str {\n         &self[..][*index]\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::Range<usize>) -> &str {\n+        &self[..][index]\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeTo<usize>> for String {\n     type Output = str;\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n         &self[..][*index]\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeTo<usize>) -> &str {\n+        &self[..][index]\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFrom<usize>> for String {\n     type Output = str;\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n         &self[..][*index]\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n+        &self[..][index]\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFull> for String {\n     type Output = str;\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, _index: &ops::RangeFull) -> &str {\n         unsafe { mem::transmute(&*self.vec) }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, _index: ops::RangeFull) -> &str {\n+        unsafe { mem::transmute(&*self.vec) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -930,6 +994,7 @@ impl<'a> Deref for DerefString<'a> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(collections)]\n /// use std::string::as_string;\n ///\n /// fn string_consumer(s: String) {\n@@ -973,6 +1038,27 @@ impl<T: fmt::Display + ?Sized> ToString for T {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<str> for String {\n+    fn as_ref(&self) -> &str {\n+        self\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a str> for String {\n+    fn from(s: &'a str) -> String {\n+        s.to_string()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Into<Vec<u8>> for String {\n+    fn into(self) -> Vec<u8> {\n+        self.into_bytes()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl IntoCow<'static, str> for String {\n     #[inline]\n@@ -989,6 +1075,7 @@ impl<'a> IntoCow<'a, str> for &'a str {\n     }\n }\n \n+#[allow(deprecated)]\n impl<'a> Str for Cow<'a, str> {\n     #[inline]\n     fn as_slice<'b>(&'b self) -> &'b str {"}, {"sha": "59819d01bc601aeb2f651d4d332474b743c74f7d", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 156, "deletions": 17, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A growable list type with heap-allocated contents, written `Vec<T>` but pronounced 'vector.'\n+//! A growable list type with heap-allocated contents, written `Vec<T>` but\n+//! pronounced 'vector.'\n //!\n //! Vectors have `O(1)` indexing, push (to the end) and pop (from the end).\n //!\n@@ -73,6 +74,7 @@ use borrow::{Cow, IntoCow};\n /// # Examples\n ///\n /// ```\n+/// # #![feature(collections)]\n /// let mut vec = Vec::new();\n /// vec.push(1);\n /// vec.push(2);\n@@ -123,17 +125,19 @@ use borrow::{Cow, IntoCow};\n ///\n /// # Capacity and reallocation\n ///\n-/// The capacity of a vector is the amount of space allocated for any future elements that will be\n-/// added onto the vector. This is not to be confused with the *length* of a vector, which\n-/// specifies the number of actual elements within the vector. If a vector's length exceeds its\n-/// capacity, its capacity will automatically be increased, but its elements will have to be\n+/// The capacity of a vector is the amount of space allocated for any future\n+/// elements that will be added onto the vector. This is not to be confused with\n+/// the *length* of a vector, which specifies the number of actual elements\n+/// within the vector. If a vector's length exceeds its capacity, its capacity\n+/// will automatically be increased, but its elements will have to be\n /// reallocated.\n ///\n-/// For example, a vector with capacity 10 and length 0 would be an empty vector with space for 10\n-/// more elements. Pushing 10 or fewer elements onto the vector will not change its capacity or\n-/// cause reallocation to occur. However, if the vector's length is increased to 11, it will have\n-/// to reallocate, which can be slow. For this reason, it is recommended to use\n-/// `Vec::with_capacity` whenever possible to specify how big the vector is expected to get.\n+/// For example, a vector with capacity 10 and length 0 would be an empty vector\n+/// with space for 10 more elements. Pushing 10 or fewer elements onto the\n+/// vector will not change its capacity or cause reallocation to occur. However,\n+/// if the vector's length is increased to 11, it will have to reallocate, which\n+/// can be slow. For this reason, it is recommended to use `Vec::with_capacity`\n+/// whenever possible to specify how big the vector is expected to get.\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n@@ -345,6 +349,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let mut vec = Vec::with_capacity(10);\n     /// vec.push_all(&[1, 2, 3]);\n     /// assert_eq!(vec.capacity(), 10);\n@@ -400,6 +405,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let mut vec = vec![1, 2, 3, 4];\n     /// vec.truncate(2);\n     /// assert_eq!(vec, [1, 2]);\n@@ -565,6 +571,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let mut v = vec![1, 2, 3];\n     /// assert_eq!(v.remove(1), 2);\n     /// assert_eq!(v, [1, 3]);\n@@ -696,6 +703,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let mut vec = vec![1, 2, 3];\n     /// let mut vec2 = vec![4, 5, 6];\n     /// vec.append(&mut vec2);\n@@ -732,6 +740,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let mut v = vec![\"a\".to_string(), \"b\".to_string()];\n     /// for s in v.drain() {\n     ///     // s has type String, not &String\n@@ -813,6 +822,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections, core)]\n     /// let v = vec![0, 1, 2];\n     /// let w = v.map_in_place(|i| i + 3);\n     /// assert_eq!(w.as_slice(), [3, 4, 5].as_slice());\n@@ -1015,6 +1025,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let mut vec = vec![1,2,3];\n     /// let vec2 = vec.split_off(1);\n     /// assert_eq!(vec, [1]);\n@@ -1053,6 +1064,7 @@ impl<T: Clone> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let mut vec = vec![\"hello\"];\n     /// vec.resize(3, \"world\");\n     /// assert_eq!(vec, [\"hello\", \"world\", \"world\"]);\n@@ -1081,6 +1093,7 @@ impl<T: Clone> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// let mut vec = vec![1];\n     /// vec.push_all(&[2, 3, 4]);\n     /// assert_eq!(vec, [1, 2, 3, 4]);\n@@ -1323,90 +1336,178 @@ impl<T: Hash> Hash for Vec<T> {\n impl<T> Index<usize> for Vec<T> {\n     type Output = T;\n \n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &usize) -> &T {\n         // NB built-in indexing via `&[T]`\n         &(**self)[*index]\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: usize) -> &T {\n+        // NB built-in indexing via `&[T]`\n+        &(**self)[index]\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> IndexMut<usize> for Vec<T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &usize) -> &mut T {\n         // NB built-in indexing via `&mut [T]`\n         &mut (**self)[*index]\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: usize) -> &mut T {\n+        // NB built-in indexing via `&mut [T]`\n+        &mut (**self)[index]\n+    }\n }\n \n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         Index::index(&**self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::Range<usize>) -> &[T] {\n+        Index::index(&**self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         Index::index(&**self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n+        Index::index(&**self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         Index::index(&**self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n+        Index::index(&**self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, _index: &ops::RangeFull) -> &[T] {\n-        self.as_slice()\n+        self\n+    }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, _index: ops::RangeFull) -> &[T] {\n+        self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, _index: &ops::RangeFull) -> &mut [T] {\n         self.as_mut_slice()\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, _index: ops::RangeFull) -> &mut [T] {\n+        self.as_mut_slice()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Deref for Vec<T> {\n     type Target = [T];\n \n-    fn deref(&self) -> &[T] { self.as_slice() }\n+    fn deref(&self) -> &[T] {\n+        unsafe {\n+            let p = *self.ptr;\n+            assume(p != 0 as *mut T);\n+            slice::from_raw_parts(p, self.len)\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1548,12 +1649,14 @@ impl<T: Ord> Ord for Vec<T> {\n     }\n }\n \n+#[allow(deprecated)]\n impl<T> AsSlice<T> for Vec<T> {\n     /// Returns a slice into `self`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// fn foo(slice: &[i32]) {}\n     ///\n     /// let vec = vec![1, 2];\n@@ -1562,11 +1665,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice(&self) -> &[T] {\n-        unsafe {\n-            let p = *self.ptr;\n-            assume(p != 0 as *mut T);\n-            slice::from_raw_parts(p, self.len)\n-        }\n+        self\n     }\n }\n \n@@ -1614,6 +1713,46 @@ impl<T: fmt::Debug> fmt::Debug for Vec<T> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> AsRef<Vec<T>> for Vec<T> {\n+    fn as_ref(&self) -> &Vec<T> {\n+        self\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> Into<Vec<T>> for Vec<T> {\n+    fn into(self) -> Vec<T> {\n+        self\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> AsRef<[T]> for Vec<T> {\n+    fn as_ref(&self) -> &[T] {\n+        self\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T: Clone> From<&'a [T]> for Vec<T> {\n+    #[cfg(not(test))]\n+    fn from(s: &'a [T]) -> Vec<T> {\n+        s.to_vec()\n+    }\n+    #[cfg(test)]\n+    fn from(s: &'a [T]) -> Vec<T> {\n+        ::slice::to_vec(s)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a str> for Vec<u8> {\n+    fn from(s: &'a str) -> Vec<u8> {\n+        From::from(s.as_bytes())\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Clone-on-write\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "af9db46f810b96b4a3fac3fcb3e97ef50f4cfb1f", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -257,6 +257,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -284,6 +285,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let buf: VecDeque<i32> = VecDeque::with_capacity(10);\n@@ -307,6 +309,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf: VecDeque<i32> = vec![1].into_iter().collect();\n@@ -328,6 +331,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf: VecDeque<i32> = vec![1].into_iter().collect();\n@@ -403,6 +407,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::with_capacity(15);\n@@ -489,6 +494,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -512,6 +518,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -535,6 +542,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -556,7 +564,7 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n-    /// Consumes the list into an iterator yielding elements by value.\n+    /// Consumes the list into a front-to-back iterator yielding elements by value.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n         IntoIter {\n@@ -644,6 +652,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut v = VecDeque::new();\n@@ -882,6 +891,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -915,6 +925,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -948,6 +959,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Examples\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -1321,6 +1333,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf: VecDeque<_> = vec![1,2,3].into_iter().collect();\n@@ -1383,6 +1396,7 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf: VecDeque<_> = vec![1, 2, 3].into_iter().collect();\n@@ -1407,6 +1421,7 @@ impl<T: Clone> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n@@ -1573,6 +1588,7 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// A by-value VecDeque iterator\n+#[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     inner: VecDeque<T>,\n@@ -1689,18 +1705,32 @@ impl<A: Hash> Hash for VecDeque<A> {\n impl<A> Index<usize> for VecDeque<A> {\n     type Output = A;\n \n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, i: &usize) -> &A {\n         self.get(*i).expect(\"Out of bounds access\")\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, i: usize) -> &A {\n+        self.get(i).expect(\"Out of bounds access\")\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> IndexMut<usize> for VecDeque<A> {\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, i: &usize) -> &mut A {\n         self.get_mut(*i).expect(\"Out of bounds access\")\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, i: usize) -> &mut A {\n+        self.get_mut(i).expect(\"Out of bounds access\")\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "c994064d34724e8917c809c7a20f23725b5b6f66", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 71, "deletions": 8, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -34,6 +34,7 @@ use vec::Vec;\n /// # Examples\n ///\n /// ```\n+/// # #![feature(collections)]\n /// use std::collections::VecMap;\n ///\n /// let mut months = VecMap::new();\n@@ -67,26 +68,28 @@ pub struct VecMap<V> {\n }\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n-#[unstable(feature = \"collections\",\n-           reason = \"precise API still under development\")]\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Entry<'a, V:'a> {\n     /// A vacant Entry\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Vacant(VacantEntry<'a, V>),\n+\n     /// An occupied Entry\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Occupied(OccupiedEntry<'a, V>),\n }\n \n /// A vacant Entry.\n-#[unstable(feature = \"collections\",\n-           reason = \"precise API still under development\")]\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VacantEntry<'a, V:'a> {\n     map: &'a mut VecMap<V>,\n     index: usize,\n }\n \n /// An occupied Entry.\n-#[unstable(feature = \"collections\",\n-           reason = \"precise API still under development\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, V:'a> {\n     map: &'a mut VecMap<V>,\n     index: usize,\n@@ -132,6 +135,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::new();\n     /// ```\n@@ -144,6 +148,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::with_capacity(10);\n     /// ```\n@@ -158,6 +163,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     /// let map: VecMap<String> = VecMap::with_capacity(10);\n     /// assert!(map.capacity() >= 10);\n@@ -177,6 +183,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::new();\n     /// map.reserve_len(10);\n@@ -201,6 +208,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     /// let mut map: VecMap<&str> = VecMap::new();\n     /// map.reserve_len_exact(10);\n@@ -240,6 +248,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -268,6 +277,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -299,6 +309,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -325,6 +336,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut a = VecMap::new();\n@@ -360,6 +372,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut a = VecMap::new();\n@@ -416,6 +429,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -443,6 +457,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut a = VecMap::new();\n@@ -460,6 +475,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut a = VecMap::new();\n@@ -477,6 +493,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut a = VecMap::new();\n@@ -492,6 +509,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -516,6 +534,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -534,6 +553,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -562,6 +582,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -587,6 +608,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     ///\n     /// let mut map = VecMap::new();\n@@ -608,6 +630,7 @@ impl<V> VecMap<V> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(collections)]\n     /// use std::collections::VecMap;\n     /// use std::collections::vec_map::Entry;\n     ///\n@@ -651,7 +674,7 @@ impl<V> VecMap<V> {\n \n impl<'a, V> Entry<'a, V> {\n     #[unstable(feature = \"collections\",\n-               reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+               reason = \"will soon be replaced by or_insert\")]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, V>> {\n         match self {\n@@ -798,6 +821,7 @@ impl<V> Extend<(usize, V)> for VecMap<V> {\n     }\n }\n \n+#[cfg(stage0)]\n impl<V> Index<usize> for VecMap<V> {\n     type Output = V;\n \n@@ -807,10 +831,49 @@ impl<V> Index<usize> for VecMap<V> {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<V> Index<usize> for VecMap<V> {\n+    type Output = V;\n+\n+    #[inline]\n+    fn index<'a>(&'a self, i: usize) -> &'a V {\n+        self.get(&i).expect(\"key not present\")\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<'a,V> Index<&'a usize> for VecMap<V> {\n+    type Output = V;\n+\n+    #[inline]\n+    fn index(&self, i: &usize) -> &V {\n+        self.get(i).expect(\"key not present\")\n+    }\n+}\n+\n+#[cfg(stage0)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<V> IndexMut<usize> for VecMap<V> {\n+    #[inline]\n+    fn index_mut(&mut self, i: &usize) -> &mut V {\n+        self.get_mut(&i).expect(\"key not present\")\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> IndexMut<usize> for VecMap<V> {\n     #[inline]\n-    fn index_mut<'a>(&'a mut self, i: &usize) -> &'a mut V {\n+    fn index_mut(&mut self, i: usize) -> &mut V {\n+        self.get_mut(&i).expect(\"key not present\")\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, V> IndexMut<&'a usize> for VecMap<V> {\n+    #[inline]\n+    fn index_mut(&mut self, i: &usize) -> &mut V {\n         self.get_mut(i).expect(\"key not present\")\n     }\n }"}, {"sha": "f03a073e274e389712b6f994c74228073dda25b1", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -20,6 +20,8 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unsafe_destructor)]\n+#![feature(into_cow)]\n+#![cfg_attr(test, feature(str_char))]\n \n #[macro_use] extern crate log;\n "}, {"sha": "4168fe88a4b562bd7d09e259abba3535a869e355", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -1428,7 +1428,7 @@ mod bench {\n             let mut v = Vec::<u8>::with_capacity(1024);\n             unsafe {\n                 let vp = v.as_mut_ptr();\n-                ptr::set_memory(vp, 0, 1024);\n+                ptr::write_bytes(vp, 0, 1024);\n                 v.set_len(1024);\n             }\n             v"}, {"sha": "5cfa800905415dd855554be725c97731ac513448", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -910,6 +910,34 @@ fn test_split_char_iterator_no_trailing() {\n     assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n }\n \n+#[test]\n+fn test_rsplit() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.rsplit(' ').collect();\n+    assert_eq!(split, [\"l\u00e4mb\\n\", \"l\u00e4mb\\nLittle\", \"little\", \"\u00e4\", \"h\u00e4d\", \"\\nM\u00e4ry\"]);\n+\n+    let split: Vec<&str> = data.rsplit(\"l\u00e4mb\").collect();\n+    assert_eq!(split, [\"\\n\", \"\\nLittle \", \"\\nM\u00e4ry h\u00e4d \u00e4 little \"]);\n+\n+    let split: Vec<&str> = data.rsplit(|c: char| c == '\u00e4').collect();\n+    assert_eq!(split, [\"mb\\n\", \"mb\\nLittle l\", \" little l\", \"d \", \"ry h\", \"\\nM\"]);\n+}\n+\n+#[test]\n+fn test_rsplitn() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.rsplitn(1, ' ').collect();\n+    assert_eq!(split, [\"l\u00e4mb\\n\", \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle\"]);\n+\n+    let split: Vec<&str> = data.rsplitn(1, \"l\u00e4mb\").collect();\n+    assert_eq!(split, [\"\\n\", \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle \"]);\n+\n+    let split: Vec<&str> = data.rsplitn(1, |c: char| c == '\u00e4').collect();\n+    assert_eq!(split, [\"mb\\n\", \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\"]);\n+}\n+\n #[test]\n fn test_words() {\n     let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";"}, {"sha": "b2c23f051d5f1d1b96dd9eecd3b71915717c4078", "filename": "src/libcore/array.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,8 @@\n \n #![unstable(feature = \"core\")] // not yet reviewed\n \n+#![doc(primitive = \"array\")]\n+\n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use fmt;"}, {"sha": "a9c5de23d948bcbcde2650ae9833ecd172670fe7", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -220,6 +220,7 @@ impl<T:Copy> Cell<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::cell::Cell;\n     ///\n     /// let c = Cell::new(5);"}, {"sha": "9ab8ab8672dfac71670014abe794beab39f3c505", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -19,7 +19,8 @@\n //! could do the following:\n //!\n //! ```\n-//! use core::num::SignedInt;\n+//! # #![feature(core)]\n+//! use std::num::SignedInt;\n //!\n //! struct FuzzyNum {\n //!     num: i32,\n@@ -398,6 +399,7 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(core)]\n /// use std::cmp;\n ///\n /// assert_eq!(Some(1), cmp::partial_min(1, 2));\n@@ -407,6 +409,7 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n /// When comparison is impossible:\n ///\n /// ```\n+/// # #![feature(core)]\n /// use std::cmp;\n ///\n /// let result = cmp::partial_min(std::f64::NAN, 1.0);\n@@ -429,6 +432,7 @@ pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(core)]\n /// use std::cmp;\n ///\n /// assert_eq!(Some(2), cmp::partial_max(1, 2));\n@@ -438,6 +442,7 @@ pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n /// When comparison is impossible:\n ///\n /// ```\n+/// # #![feature(core)]\n /// use std::cmp;\n ///\n /// let result = cmp::partial_max(std::f64::NAN, 1.0);"}, {"sha": "65a226d37cbc038c80f38c3ef532bc66a2c27ac6", "filename": "src/libcore/convert.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Traits for conversions between types.\n+//!\n+//! The traits in this module provide a general way to talk about\n+//! conversions from one type to another. They follow the standard\n+//! Rust conventions of `as`/`to`/`into`/`from`.\n+\n+#![unstable(feature = \"convert\",\n+            reason = \"recently added, experimental traits\")]\n+\n+use marker::Sized;\n+\n+/// A cheap, reference-to-reference conversion.\n+pub trait AsRef<T: ?Sized> {\n+    /// Perform the conversion.\n+    fn as_ref(&self) -> &T;\n+}\n+\n+/// A cheap, mutable reference-to-mutable reference conversion.\n+pub trait AsMut<T: ?Sized> {\n+    /// Perform the conversion.\n+    fn as_mut(&mut self) -> &mut T;\n+}\n+\n+/// A conversion that consumes `self`, which may or may not be\n+/// expensive.\n+pub trait Into<T>: Sized {\n+    /// Perform the conversion.\n+    fn into(self) -> T;\n+}\n+\n+/// Construct `Self` via a conversion.\n+pub trait From<T> {\n+    /// Perform the conversion.\n+    fn from(T) -> Self;\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// GENERIC IMPLS\n+////////////////////////////////////////////////////////////////////////////////\n+\n+// As implies Into\n+impl<'a, T: ?Sized, U: ?Sized> Into<&'a U> for &'a T where T: AsRef<U> {\n+    fn into(self) -> &'a U {\n+        self.as_ref()\n+    }\n+}\n+\n+// As lifts over &\n+impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a T where T: AsRef<U> {\n+    fn as_ref(&self) -> &U {\n+        <T as AsRef<U>>::as_ref(*self)\n+    }\n+}\n+\n+// As lifts over &mut\n+impl<'a, T: ?Sized, U: ?Sized> AsRef<U> for &'a mut T where T: AsRef<U> {\n+    fn as_ref(&self) -> &U {\n+        <T as AsRef<U>>::as_ref(*self)\n+    }\n+}\n+\n+// AsMut implies Into\n+impl<'a, T: ?Sized, U: ?Sized> Into<&'a mut U> for &'a mut T where T: AsMut<U> {\n+    fn into(self) -> &'a mut U {\n+        (*self).as_mut()\n+    }\n+}\n+\n+// AsMut lifts over &mut\n+impl<'a, T: ?Sized, U: ?Sized> AsMut<U> for &'a mut T where T: AsMut<U> {\n+    fn as_mut(&mut self) -> &mut U {\n+        (*self).as_mut()\n+    }\n+}\n+\n+// From implies Into\n+impl<T, U> Into<U> for T where U: From<T> {\n+    fn into(self) -> U {\n+        U::from(self)\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// CONCRETE IMPLS\n+////////////////////////////////////////////////////////////////////////////////\n+\n+impl<T> AsRef<[T]> for [T] {\n+    fn as_ref(&self) -> &[T] {\n+        self\n+    }\n+}\n+\n+impl<T> AsMut<[T]> for [T] {\n+    fn as_mut(&mut self) -> &mut [T] {\n+        self\n+    }\n+}\n+\n+impl AsRef<str> for str {\n+    fn as_ref(&self) -> &str {\n+        self\n+    }\n+}"}, {"sha": "d7b4c9411fb4efc0bfbd9f715dc5ab7cb2df5356", "filename": "src/libcore/error.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ferror.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -48,6 +48,7 @@\n //! For example,\n //!\n //! ```\n+//! # #![feature(os, old_io, old_path)]\n //! use std::error::FromError;\n //! use std::old_io::{File, IoError};\n //! use std::os::{MemoryMap, MapError};\n@@ -82,16 +83,21 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use prelude::*;\n-use fmt::Display;\n+use fmt::{Debug, Display};\n \n /// Base functionality for all errors in Rust.\n-#[unstable(feature = \"core\",\n-           reason = \"the exact API of this trait may change\")]\n-pub trait Error: Display {\n-    /// A short description of the error; usually a static string.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Error: Debug + Display + Send {\n+    /// A short description of the error.\n+    ///\n+    /// The description should not contain newlines or sentence-ending\n+    /// punctuation, to facilitate embedding in larger user-facing\n+    /// strings.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn description(&self) -> &str;\n \n     /// The lower-level cause of this error, if any.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cause(&self) -> Option<&Error> { None }\n }\n "}, {"sha": "93a7d2bb17b92237a305a8b5ac033060b51a12b1", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -19,6 +19,7 @@\n //! # Examples\n //!\n //! ```\n+//! # #![feature(core)]\n //! # #![feature(unboxed_closures)]\n //!\n //! use std::finally::Finally;\n@@ -70,6 +71,7 @@ impl<T, F> Finally<T> for F where F: FnMut() -> T {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(core)]\n /// use std::finally::try_finally;\n ///\n /// struct State<'a> { buffer: &'a mut [u8], len: usize }"}, {"sha": "cf427c16588d9add3682c30ff51449be8380151f", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -624,6 +624,7 @@ impl<'a> Formatter<'a> {\n     /// # Examples\n     ///\n     /// ```rust\n+    /// # #![feature(debug_builders, core)]\n     /// use std::fmt;\n     ///\n     /// struct Foo {\n@@ -655,6 +656,7 @@ impl<'a> Formatter<'a> {\n     /// # Examples\n     ///\n     /// ```rust\n+    /// # #![feature(debug_builders, core)]\n     /// use std::fmt;\n     ///\n     /// struct Foo(i32, String);\n@@ -683,6 +685,7 @@ impl<'a> Formatter<'a> {\n     /// # Examples\n     ///\n     /// ```rust\n+    /// # #![feature(debug_builders, core)]\n     /// use std::fmt;\n     ///\n     /// struct Foo(Vec<i32>);\n@@ -712,6 +715,7 @@ impl<'a> Formatter<'a> {\n     /// # Examples\n     ///\n     /// ```rust\n+    /// # #![feature(debug_builders, core)]\n     /// use std::fmt;\n     ///\n     /// struct Foo(Vec<(String, i32)>);"}, {"sha": "49da99b97cb206571b768a1e88e94b6ae86a6d1e", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -146,6 +146,7 @@ pub struct RadixFmt<T, R>(T, R);\n /// # Examples\n ///\n /// ```\n+/// # #![feature(core)]\n /// use std::fmt::radix;\n /// assert_eq!(format!(\"{}\", radix(55, 36)), \"1j\".to_string());\n /// ```"}, {"sha": "1d5e174a8dc99ebf1fe59d769951ea8a2b7497e8", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -16,6 +16,7 @@\n //! # Examples\n //!\n //! ```rust\n+//! # #![feature(hash)]\n //! use std::hash::{hash, Hash, SipHasher};\n //!\n //! #[derive(Hash)]\n@@ -35,6 +36,7 @@\n //! the trait `Hash`:\n //!\n //! ```rust\n+//! # #![feature(hash)]\n //! use std::hash::{hash, Hash, Hasher, SipHasher};\n //!\n //! struct Person {\n@@ -90,7 +92,7 @@ pub trait Hash {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hasher {\n     /// Completes a round of hashing, producing the output hash generated.\n-    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn finish(&self) -> u64;\n \n     /// Writes some data into this `Hasher`"}, {"sha": "1f1044b0b21520d0148877edbe132faf6e9c5a6e", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -44,6 +44,10 @@\n \n use marker::Sized;\n \n+#[cfg(stage0)] pub use self::copy_memory as copy;\n+#[cfg(stage0)] pub use self::set_memory as write_bytes;\n+#[cfg(stage0)] pub use self::copy_nonoverlapping_memory as copy_nonoverlapping;\n+\n extern \"rust-intrinsic\" {\n \n     // NB: These intrinsics take unsafe pointers because they mutate aliased\n@@ -246,7 +250,7 @@ extern \"rust-intrinsic\" {\n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n     /// and destination may *not* overlap.\n     ///\n-    /// `copy_nonoverlapping_memory` is semantically equivalent to C's `memcpy`.\n+    /// `copy_nonoverlapping` is semantically equivalent to C's `memcpy`.\n     ///\n     /// # Safety\n     ///\n@@ -262,6 +266,7 @@ extern \"rust-intrinsic\" {\n     /// A safe swap function:\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::mem;\n     /// use std::ptr;\n     ///\n@@ -271,9 +276,9 @@ extern \"rust-intrinsic\" {\n     ///         let mut t: T = mem::uninitialized();\n     ///\n     ///         // Perform the swap, `&mut` pointers never alias\n-    ///         ptr::copy_nonoverlapping_memory(&mut t, &*x, 1);\n-    ///         ptr::copy_nonoverlapping_memory(x, &*y, 1);\n-    ///         ptr::copy_nonoverlapping_memory(y, &t, 1);\n+    ///         ptr::copy_nonoverlapping(&mut t, &*x, 1);\n+    ///         ptr::copy_nonoverlapping(x, &*y, 1);\n+    ///         ptr::copy_nonoverlapping(y, &t, 1);\n     ///\n     ///         // y and t now point to the same thing, but we need to completely forget `tmp`\n     ///         // because it's no longer relevant.\n@@ -282,12 +287,18 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg(not(stage0))]\n+    pub fn copy_nonoverlapping<T>(dst: *mut T, src: *const T, count: usize);\n+\n+    /// dox\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg(stage0)]\n     pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n \n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n     /// and destination may overlap.\n     ///\n-    /// `copy_memory` is semantically equivalent to C's `memmove`.\n+    /// `copy` is semantically equivalent to C's `memmove`.\n     ///\n     /// # Safety\n     ///\n@@ -301,21 +312,34 @@ extern \"rust-intrinsic\" {\n     /// Efficiently create a Rust vector from an unsafe buffer:\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::ptr;\n     ///\n     /// unsafe fn from_buf_raw<T>(ptr: *const T, elts: uint) -> Vec<T> {\n     ///     let mut dst = Vec::with_capacity(elts);\n     ///     dst.set_len(elts);\n-    ///     ptr::copy_memory(dst.as_mut_ptr(), ptr, elts);\n+    ///     ptr::copy(dst.as_mut_ptr(), ptr, elts);\n     ///     dst\n     /// }\n     /// ```\n     ///\n+    #[cfg(not(stage0))]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn copy<T>(dst: *mut T, src: *const T, count: usize);\n+\n+    /// dox\n+    #[cfg(stage0)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n \n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n     /// bytes of memory starting at `dst` to `c`.\n+    #[cfg(not(stage0))]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n+\n+    /// dox\n+    #[cfg(stage0)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set_memory<T>(dst: *mut T, val: u8, count: usize);\n "}, {"sha": "5f5b8ef73ef54edf1702e92c64369b5e318a38d6", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -334,6 +334,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// let xs = [100, 200, 300];\n     /// let mut it = xs.iter().cloned().peekable();\n     /// assert_eq!(*it.peek().unwrap(), 100);\n@@ -465,6 +466,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// let xs = [2, 3];\n     /// let ys = [0, 1, 0, 1, 2];\n     /// let it = xs.iter().flat_map(|&x| std::iter::count(0, 1).take(x));\n@@ -521,6 +523,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::iter::AdditiveIterator;\n     ///\n     /// let a = [1, 4, 2, 3, 8, 9, 6];\n@@ -563,6 +566,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// let a = [1, 2, 3, 4, 5];\n     /// let b: Vec<_> = a.iter().cloned().collect();\n     /// assert_eq!(a, b);\n@@ -579,6 +583,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// do not.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// let vec = vec![1, 2, 3, 4];\n     /// let (even, odd): (Vec<_>, Vec<_>) = vec.into_iter().partition(|&n| n % 2 == 0);\n     /// assert_eq!(even, [2, 4]);\n@@ -648,6 +653,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.any(|x| *x == 3));\n@@ -668,6 +674,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert_eq!(it.find(|&x| *x == 3).unwrap(), &3);\n@@ -690,6 +697,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert_eq!(it.position(|x| *x == 3).unwrap(), 2);\n@@ -718,6 +726,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// let a = [1, 2, 2, 4, 5];\n     /// let mut it = a.iter();\n     /// assert_eq!(it.rposition(|x| *x == 2).unwrap(), 2);\n@@ -795,6 +804,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::iter::MinMaxResult::{NoElements, OneElement, MinMax};\n     ///\n     /// let a: [i32; 0] = [];\n@@ -860,7 +870,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Examples\n     ///\n     /// ```\n-    /// use core::num::SignedInt;\n+    /// # #![feature(core)]\n+    /// use std::num::SignedInt;\n     ///\n     /// let a = [-3, 0, 1, 5, -10];\n     /// assert_eq!(*a.iter().max_by(|x| x.abs()).unwrap(), -10);\n@@ -890,7 +901,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Examples\n     ///\n     /// ```\n-    /// use core::num::SignedInt;\n+    /// # #![feature(core)]\n+    /// use std::num::SignedInt;\n     ///\n     /// let a = [-3, 0, 1, 5, -10];\n     /// assert_eq!(*a.iter().min_by(|x| x.abs()).unwrap(), 0);\n@@ -940,6 +952,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// let a = [(1, 2), (3, 4)];\n     /// let (left, right): (Vec<_>, Vec<_>) = a.iter().cloned().unzip();\n     /// assert_eq!([1, 3], left);\n@@ -1146,6 +1159,7 @@ pub trait AdditiveIterator<A> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::iter::AdditiveIterator;\n     ///\n     /// let a = [1, 2, 3, 4, 5];\n@@ -1188,6 +1202,7 @@ pub trait MultiplicativeIterator<A> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::iter::{count, MultiplicativeIterator};\n     ///\n     /// fn factorial(n: usize) -> usize {\n@@ -1248,6 +1263,7 @@ impl<T: Clone> MinMaxResult<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::iter::MinMaxResult::{self, NoElements, OneElement, MinMax};\n     ///\n     /// let r: MinMaxResult<i32> = NoElements;\n@@ -2292,6 +2308,7 @@ impl<I: RandomAccessIterator, F> RandomAccessIterator for Inspect<I, F>\n /// An iterator that yields sequential Fibonacci numbers, and stops on overflow.\n ///\n /// ```\n+/// # #![feature(core)]\n /// use std::iter::Unfold;\n /// use std::num::Int; // For `.checked_add()`\n ///\n@@ -2693,6 +2710,7 @@ pub struct RangeStepInclusive<A> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(core)]\n /// use std::iter::range_step_inclusive;\n ///\n /// for i in range_step_inclusive(0, 10, 2) {"}, {"sha": "a2b13584270940317f8935b3a7674d5e4d841b22", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -56,6 +56,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n+#![doc(test(no_crate_inject))]\n \n #![feature(no_std)]\n #![no_std]\n@@ -125,6 +126,7 @@ pub mod ops;\n pub mod cmp;\n pub mod clone;\n pub mod default;\n+pub mod convert;\n \n /* Core types and methods on primitives */\n "}, {"sha": "40e32f4171a2d509900ccc4f685374710dfbef1f", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -231,6 +231,7 @@ macro_rules! writeln {\n /// Iterators:\n ///\n /// ```\n+/// # #![feature(core)]\n /// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n ///     for i in std::iter::count(0, 1) {\n ///         if 3*i < i { panic!(\"u32 overflow\"); }"}, {"sha": "88c10e3661e7a7714bea28e9c8f7d6788cbcf743", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -39,6 +39,8 @@ pub unsafe trait Send : MarkerTrait {\n     // empty.\n }\n \n+unsafe impl Send for .. { }\n+\n impl<T> !Send for *const T { }\n impl<T> !Send for *mut T { }\n impl !Send for Managed { }\n@@ -203,6 +205,8 @@ pub unsafe trait Sync : MarkerTrait {\n     // Empty\n }\n \n+unsafe impl Sync for .. { }\n+\n impl<T> !Sync for *const T { }\n impl<T> !Sync for *mut T { }\n impl !Sync for Managed { }\n@@ -270,6 +274,7 @@ macro_rules! impls{\n /// any methods, but instead is used to gate access to data.\n ///\n /// FIXME. Better documentation needed here!\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait MarkerTrait : PhantomFn<Self,Self> { }\n //                                    ~~~~~ <-- FIXME(#22806)?\n //\n@@ -319,6 +324,7 @@ impl<T:?Sized> MarkerTrait for T { }\n /// `MarkerTrait`:\n ///\n /// ```\n+/// # #![feature(core)]\n /// use std::marker::MarkerTrait;\n /// trait Even : MarkerTrait { }\n /// ```"}, {"sha": "d211b0f9928cd2db17e276f8c72611462ff97b5e", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -282,7 +282,8 @@ impl Float for f32 {\n     /// The fractional part of the number, satisfying:\n     ///\n     /// ```\n-    /// use core::num::Float;\n+    /// # #![feature(core)]\n+    /// use std::num::Float;\n     ///\n     /// let x = 1.65f32;\n     /// assert!(x == x.trunc() + x.fract())"}, {"sha": "1421fdd72f2335c09855183f991cedc228d9b754", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -289,7 +289,8 @@ impl Float for f64 {\n     /// The fractional part of the number, satisfying:\n     ///\n     /// ```\n-    /// use core::num::Float;\n+    /// # #![feature(core)]\n+    /// use std::num::Float;\n     ///\n     /// let x = 1.65f64;\n     /// assert!(x == x.trunc() + x.fract())"}, {"sha": "9ca7b48fbe5ef05b9a125ea7323266ce44cb0b4d", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -85,6 +85,7 @@ pub trait Int\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Int;\n     ///\n     /// let n = 0b01001100u8;\n@@ -100,6 +101,7 @@ pub trait Int\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Int;\n     ///\n     /// let n = 0b01001100u8;\n@@ -119,6 +121,7 @@ pub trait Int\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Int;\n     ///\n     /// let n = 0b0101000u16;\n@@ -135,6 +138,7 @@ pub trait Int\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Int;\n     ///\n     /// let n = 0b0101000u16;\n@@ -151,6 +155,7 @@ pub trait Int\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Int;\n     ///\n     /// let n = 0x0123456789ABCDEFu64;\n@@ -168,6 +173,7 @@ pub trait Int\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Int;\n     ///\n     /// let n = 0x0123456789ABCDEFu64;\n@@ -392,6 +398,7 @@ pub trait Int\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Int;\n     ///\n     /// assert_eq!(2.pow(4), 16);\n@@ -787,6 +794,7 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n+        /// # #![feature(core)]\n         /// use std::num::Int;\n         ///\n         /// let n = 0b01001100u8;\n@@ -803,6 +811,7 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n+        /// # #![feature(core)]\n         /// use std::num::Int;\n         ///\n         /// let n = 0b01001100u8;\n@@ -822,6 +831,7 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n+        /// # #![feature(core)]\n         /// use std::num::Int;\n         ///\n         /// let n = 0b0101000u16;\n@@ -841,6 +851,7 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n+        /// # #![feature(core)]\n         /// use std::num::Int;\n         ///\n         /// let n = 0b0101000u16;\n@@ -860,6 +871,7 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n+        /// # #![feature(core)]\n         /// use std::num::Int;\n         ///\n         /// let n = 0x0123456789ABCDEFu64;\n@@ -881,6 +893,7 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n+        /// # #![feature(core)]\n         /// use std::num::Int;\n         ///\n         /// let n = 0x0123456789ABCDEFu64;\n@@ -1112,6 +1125,7 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n+        /// # #![feature(core)]\n         /// use std::num::Int;\n         ///\n         /// assert_eq!(2.pow(4), 16);\n@@ -1277,6 +1291,7 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n+        /// # #![feature(core)]\n         /// use std::num::Int;\n         ///\n         /// let n = 0b01001100u8;\n@@ -1295,6 +1310,7 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n+        /// # #![feature(core)]\n         /// use std::num::Int;\n         ///\n         /// let n = 0b01001100u8;\n@@ -1314,6 +1330,7 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n+        /// # #![feature(core)]\n         /// use std::num::Int;\n         ///\n         /// let n = 0b0101000u16;\n@@ -1333,6 +1350,7 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n+        /// # #![feature(core)]\n         /// use std::num::Int;\n         ///\n         /// let n = 0b0101000u16;\n@@ -1352,6 +1370,7 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n+        /// # #![feature(core)]\n         /// use std::num::Int;\n         ///\n         /// let n = 0x0123456789ABCDEFu64;\n@@ -1375,6 +1394,7 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n+        /// # #![feature(core)]\n         /// use std::num::Int;\n         ///\n         /// let n = 0x0123456789ABCDEFu64;\n@@ -1606,6 +1626,7 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n+        /// # #![feature(core)]\n         /// use std::num::Int;\n         ///\n         /// assert_eq!(2.pow(4), 16);\n@@ -2266,6 +2287,7 @@ impl_from_primitive! { f64, to_f64 }\n /// # Examples\n ///\n /// ```\n+/// # #![feature(core)]\n /// use std::num;\n ///\n /// let twenty: f32 = num::cast(0x14).unwrap();"}, {"sha": "6e6f97a7af7d9e1d2595309f78ef918885ba4965", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -898,7 +898,7 @@ shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// impl Index<Bar> for Foo {\n ///     type Output = Foo;\n ///\n-///     fn index<'a>(&'a self, _index: &Bar) -> &'a Foo {\n+///     fn index<'a>(&'a self, _index: Bar) -> &'a Foo {\n ///         println!(\"Indexing!\");\n ///         self\n ///     }\n@@ -917,8 +917,14 @@ pub trait Index<Idx: ?Sized> {\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n+    #[cfg(stage0)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index<'a>(&'a self, index: &Idx) -> &'a Self::Output;\n+\n+    /// The method for the indexing (`Foo[Bar]`) operation\n+    #[cfg(not(stage0))]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn index<'a>(&'a self, index: Idx) -> &'a Self::Output;\n }\n \n /// The `IndexMut` trait is used to specify the functionality of indexing\n@@ -939,13 +945,13 @@ pub trait Index<Idx: ?Sized> {\n /// impl Index<Bar> for Foo {\n ///     type Output = Foo;\n ///\n-///     fn index<'a>(&'a self, _index: &Bar) -> &'a Foo {\n+///     fn index<'a>(&'a self, _index: Bar) -> &'a Foo {\n ///         self\n ///     }\n /// }\n ///\n /// impl IndexMut<Bar> for Foo {\n-///     fn index_mut<'a>(&'a mut self, _index: &Bar) -> &'a mut Foo {\n+///     fn index_mut<'a>(&'a mut self, _index: Bar) -> &'a mut Foo {\n ///         println!(\"Indexing!\");\n ///         self\n ///     }\n@@ -960,8 +966,14 @@ pub trait Index<Idx: ?Sized> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n     /// The method for the indexing (`Foo[Bar]`) operation\n+    #[cfg(stage0)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index_mut<'a>(&'a mut self, index: &Idx) -> &'a mut Self::Output;\n+\n+    /// The method for the indexing (`Foo[Bar]`) operation\n+    #[cfg(not(stage0))]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn index_mut<'a>(&'a mut self, index: Idx) -> &'a mut Self::Output;\n }\n \n /// An unbounded range."}, {"sha": "a565b137cc852a5f84cd33885f87f0a954cd3e13", "filename": "src/libcore/option.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -154,6 +154,7 @@ use mem;\n use ops::{Deref, FnOnce};\n use result::Result::{Ok, Err};\n use result::Result;\n+#[allow(deprecated)]\n use slice::AsSlice;\n use slice;\n \n@@ -275,6 +276,7 @@ impl<T> Option<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// let mut x = Some(\"Diamonds\");\n     /// {\n     ///     let v = x.as_mut_slice();\n@@ -470,6 +472,7 @@ impl<T> Option<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// let x = Some(\"foo\");\n     /// assert_eq!(x.ok_or(0), Ok(\"foo\"));\n     ///\n@@ -491,6 +494,7 @@ impl<T> Option<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// let x = Some(\"foo\");\n     /// assert_eq!(x.ok_or_else(|| 0), Ok(\"foo\"));\n     ///\n@@ -532,6 +536,7 @@ impl<T> Option<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// let mut x = Some(4);\n     /// match x.iter_mut().next() {\n     ///     Some(&mut ref mut v) => *v = 42,\n@@ -701,6 +706,19 @@ impl<T> Option<T> {\n     pub fn take(&mut self) -> Option<T> {\n         mem::replace(self, None)\n     }\n+\n+    /// Convert from `Option<T>` to `&[T]` (without copying)\n+    #[inline]\n+    #[unstable(feature = \"as_slice\", since = \"unsure of the utility here\")]\n+    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n+        match *self {\n+            Some(ref x) => slice::ref_slice(x),\n+            None => {\n+                let result: &[_] = &[];\n+                result\n+            }\n+        }\n+    }\n }\n \n impl<'a, T: Clone, D: Deref<Target=T>> Option<D> {\n@@ -752,6 +770,9 @@ impl<T: Default> Option<T> {\n \n #[unstable(feature = \"core\",\n            reason = \"waiting on the stability of the trait itself\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use the inherent method instead\")]\n+#[allow(deprecated)]\n impl<T> AsSlice<T> for Option<T> {\n     /// Convert from `Option<T>` to `&[T]` (without copying)\n     #[inline]"}, {"sha": "424829939b92e89fbea8898bdcb7b71ff09dba54", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -36,6 +36,7 @@ pub use mem::drop;\n pub use char::CharExt;\n pub use clone::Clone;\n pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n+pub use convert::{AsRef, AsMut, Into, From};\n pub use iter::{Extend, IteratorExt};\n pub use iter::{Iterator, DoubleEndedIterator};\n pub use iter::{ExactSizeIterator};"}, {"sha": "d92622eeb70e3c4e83c1db5de34c765fe3a8c211", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -15,12 +15,9 @@\n //! Working with unsafe pointers in Rust is uncommon,\n //! typically limited to a few patterns.\n //!\n-//! Use the [`null` function](fn.null.html) to create null pointers,\n-//! the [`is_null`](trait.PtrExt.html#tymethod.is_null)\n-//! methods of the [`PtrExt` trait](trait.PtrExt.html) to check for null.\n-//! The `PtrExt` trait is imported by the prelude, so `is_null` etc.\n-//! work everywhere. The `PtrExt` also defines the `offset` method,\n-//! for pointer math.\n+//! Use the [`null` function](fn.null.html) to create null pointers, and\n+//! the `is_null` method of the `*const T` type  to check for null.\n+//! The `*const T` type also defines the `offset` method, for pointer math.\n //!\n //! # Common ways to create unsafe pointers\n //!\n@@ -52,6 +49,7 @@\n //! the raw pointer. It doesn't destroy `T` or deallocate any memory.\n //!\n //! ```\n+//! # #![feature(alloc)]\n //! use std::boxed;\n //!\n //! unsafe {\n@@ -70,6 +68,7 @@\n //! ## 3. Get it from C.\n //!\n //! ```\n+//! # #![feature(libc)]\n //! extern crate libc;\n //!\n //! use std::mem;\n@@ -105,27 +104,13 @@ use cmp::Ordering::{self, Less, Equal, Greater};\n // FIXME #19649: intrinsic docs don't render, so these have no docs :(\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use intrinsics::copy_nonoverlapping_memory as copy_nonoverlapping;\n+pub use intrinsics::copy_nonoverlapping;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use intrinsics::copy_memory as copy;\n+pub use intrinsics::copy;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use intrinsics::set_memory as write_bytes;\n-\n-extern \"rust-intrinsic\" {\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to `copy_nonoverlapping`\")]\n-    pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n-    #[unstable(feature = \"core\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to `copy`\")]\n-    pub fn copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n-\n-    #[unstable(feature = \"core\",\n-               reason = \"uncertain about naming and semantics\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to `write_bytes`\")]\n-    pub fn set_memory<T>(dst: *mut T, val: u8, count: usize);\n-}\n+pub use intrinsics::write_bytes;\n \n /// Creates a null raw pointer.\n ///"}, {"sha": "8502a9c53c4a88cc4a0b24fd3dc0d98e08eeca35", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -48,6 +48,7 @@ use mem;\n /// # Examples\n ///\n /// ```\n+/// # #![feature(core)]\n /// use std::raw::{self, Repr};\n ///\n /// let slice: &[u16] = &[1, 2, 3, 4];\n@@ -106,6 +107,7 @@ pub struct Closure {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(core)]\n /// use std::mem;\n /// use std::raw;\n ///"}, {"sha": "62e1bcd827ae7ccbac2b0a2c20965d84aa0f94d8", "filename": "src/libcore/result.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -95,6 +95,7 @@\n //! by the [`Writer`](../io/trait.Writer.html) trait:\n //!\n //! ```\n+//! # #![feature(old_io)]\n //! use std::old_io::IoError;\n //!\n //! trait Writer {\n@@ -110,6 +111,7 @@\n //! something like this:\n //!\n //! ```{.ignore}\n+//! # #![feature(old_io)]\n //! use std::old_io::*;\n //! use std::old_path::Path;\n //!\n@@ -129,6 +131,7 @@\n //! a marginally useful message indicating why:\n //!\n //! ```{.no_run}\n+//! # #![feature(old_io, old_path)]\n //! use std::old_io::*;\n //! use std::old_path::Path;\n //!\n@@ -140,6 +143,7 @@\n //! You might also simply assert success:\n //!\n //! ```{.no_run}\n+//! # #![feature(old_io, old_path)]\n //! # use std::old_io::*;\n //! # use std::old_path::Path;\n //!\n@@ -151,6 +155,7 @@\n //! Or propagate the error up the call stack with `try!`:\n //!\n //! ```\n+//! # #![feature(old_io, old_path)]\n //! # use std::old_io::*;\n //! # use std::old_path::Path;\n //! fn write_message() -> Result<(), IoError> {\n@@ -171,6 +176,7 @@\n //! It replaces this:\n //!\n //! ```\n+//! # #![feature(old_io, old_path)]\n //! use std::old_io::*;\n //! use std::old_path::Path;\n //!\n@@ -196,6 +202,7 @@\n //! With this:\n //!\n //! ```\n+//! # #![feature(old_io, old_path)]\n //! use std::old_io::*;\n //! use std::old_path::Path;\n //!\n@@ -240,6 +247,7 @@ use iter::{Iterator, IteratorExt, DoubleEndedIterator,\n            FromIterator, ExactSizeIterator, IntoIterator};\n use ops::{FnMut, FnOnce};\n use option::Option::{self, None, Some};\n+#[allow(deprecated)]\n use slice::AsSlice;\n use slice;\n \n@@ -408,9 +416,24 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n+    /// Convert from `Result<T, E>` to `&[T]` (without copying)\n+    #[inline]\n+    #[unstable(feature = \"as_slice\", since = \"unsure of the utility here\")]\n+    pub fn as_slice(&self) -> &[T] {\n+        match *self {\n+            Ok(ref x) => slice::ref_slice(x),\n+            Err(_) => {\n+                // work around lack of implicit coercion from fixed-size array to slice\n+                let emp: &[_] = &[];\n+                emp\n+            }\n+        }\n+    }\n+\n     /// Convert from `Result<T, E>` to `&mut [T]` (without copying)\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// let mut x: Result<&str, u32> = Ok(\"Gold\");\n     /// {\n     ///     let v = x.as_mut_slice();\n@@ -452,6 +475,7 @@ impl<T, E> Result<T, E> {\n     /// ignoring I/O and parse errors:\n     ///\n     /// ```\n+    /// # #![feature(old_io)]\n     /// use std::old_io::*;\n     ///\n     /// let mut buffer: &[u8] = b\"1\\n2\\n3\\n4\\n\";\n@@ -788,10 +812,14 @@ impl<T: fmt::Debug, E> Result<T, E> {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n+#[unstable(feature = \"core\",\n+           reason = \"waiting on the stability of the trait itself\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use inherent method instead\")]\n+#[allow(deprecated)]\n impl<T, E> AsSlice<T> for Result<T, E> {\n     /// Convert from `Result<T, E>` to `&[T]` (without copying)\n     #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match *self {\n             Ok(ref x) => slice::ref_slice(x),"}, {"sha": "21cff3021abea400af1831356fe2644b384e1bf0", "filename": "src/libcore/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -19,7 +19,7 @@\n //! provided beyond this module.\n //!\n //! ```rust\n-//!\n+//! # #![feature(core)]\n //! fn main() {\n //!     use std::simd::f32x4;\n //!     let a = f32x4(40.0, 41.0, 42.0, 43.0);"}, {"sha": "fce29abed7300c161c416be5f78b8f379cb92594", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -263,6 +263,7 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn as_mut_slice(&mut self) -> &mut [T] { self }\n \n+    #[cfg(stage0)]\n     #[inline]\n     fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n         unsafe {\n@@ -273,6 +274,17 @@ impl<T> SliceExt for [T] {\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n+        unsafe {\n+            let self2: &mut [T] = mem::transmute_copy(&self);\n+\n+            (ops::IndexMut::index_mut(self, ops::RangeTo { end: mid } ),\n+             ops::IndexMut::index_mut(self2, ops::RangeFrom { start: mid } ))\n+        }\n+    }\n+\n     #[inline]\n     fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         unsafe {\n@@ -495,25 +507,45 @@ impl<T> SliceExt for [T] {\n impl<T> ops::Index<usize> for [T] {\n     type Output = T;\n \n+    #[cfg(stage0)]\n     fn index(&self, &index: &usize) -> &T {\n         assert!(index < self.len());\n \n         unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n     }\n+\n+    #[cfg(not(stage0))]\n+    fn index(&self, index: usize) -> &T {\n+        assert!(index < self.len());\n+\n+        unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<usize> for [T] {\n+    #[cfg(stage0)]\n+    #[inline]\n     fn index_mut(&mut self, &index: &usize) -> &mut T {\n         assert!(index < self.len());\n \n         unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: usize) -> &mut T {\n+        assert!(index < self.len());\n+\n+        unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::Range<usize>> for [T] {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         assert!(index.start <= index.end);\n@@ -525,34 +557,72 @@ impl<T> ops::Index<ops::Range<usize>> for [T] {\n             )\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::Range<usize>) -> &[T] {\n+        assert!(index.start <= index.end);\n+        assert!(index.end <= self.len());\n+        unsafe {\n+            from_raw_parts (\n+                self.as_ptr().offset(index.start as isize),\n+                index.end - index.start\n+            )\n+        }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         self.index(&ops::Range{ start: 0, end: index.end })\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n+        self.index(ops::Range{ start: 0, end: index.end })\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFrom<usize>> for [T] {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         self.index(&ops::Range{ start: index.start, end: self.len() })\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n+        self.index(ops::Range{ start: index.start, end: self.len() })\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<RangeFull> for [T] {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, _index: &RangeFull) -> &[T] {\n         self\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, _index: RangeFull) -> &[T] {\n+        self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n         assert!(index.start <= index.end);\n@@ -564,28 +634,64 @@ impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n             )\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n+        assert!(index.start <= index.end);\n+        assert!(index.end <= self.len());\n+        unsafe {\n+            from_raw_parts_mut(\n+                self.as_mut_ptr().offset(index.start as isize),\n+                index.end - index.start\n+            )\n+        }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for [T] {\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n         self.index_mut(&ops::Range{ start: 0, end: index.end })\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n+        self.index_mut(ops::Range{ start: 0, end: index.end })\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] {\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n         let len = self.len();\n         self.index_mut(&ops::Range{ start: index.start, end: len })\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n+        let len = self.len();\n+        self.index_mut(ops::Range{ start: index.start, end: len })\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<RangeFull> for [T] {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, _index: &RangeFull) -> &mut [T] {\n         self\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, _index: RangeFull) -> &mut [T] {\n+        self\n+    }\n }\n \n \n@@ -596,24 +702,29 @@ impl<T> ops::IndexMut<RangeFull> for [T] {\n /// Data that is viewable as a slice.\n #[unstable(feature = \"core\",\n            reason = \"will be replaced by slice syntax\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use std::convert::AsRef<[T]> instead\")]\n pub trait AsSlice<T> {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a [T];\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<T> AsSlice<T> for [T] {\n     #[inline(always)]\n     fn as_slice<'a>(&'a self) -> &'a [T] { self }\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n+#[allow(deprecated)]\n impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a mut U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n@@ -763,37 +874,69 @@ unsafe impl<'a, T: Sync> Send for Iter<'a, T> {}\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::Range<usize>> for Iter<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         self.as_slice().index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::Range<usize>) -> &[T] {\n+        self.as_slice().index(index)\n+    }\n }\n \n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeTo<usize>> for Iter<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         self.as_slice().index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n+        self.as_slice().index(index)\n+    }\n }\n \n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeFrom<usize>> for Iter<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         self.as_slice().index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n+        self.as_slice().index(index)\n+    }\n }\n \n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<RangeFull> for Iter<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, _index: &RangeFull) -> &[T] {\n         self.as_slice()\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, _index: RangeFull) -> &[T] {\n+        self.as_slice()\n+    }\n }\n \n impl<'a, T> Iter<'a, T> {\n@@ -856,63 +999,126 @@ unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::Range<usize>> for IterMut<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         self.index(&RangeFull).index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::Range<usize>) -> &[T] {\n+        self.index(RangeFull).index(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeTo<usize>> for IterMut<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         self.index(&RangeFull).index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n+        self.index(RangeFull).index(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeFrom<usize>> for IterMut<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         self.index(&RangeFull).index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n+        self.index(RangeFull).index(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<RangeFull> for IterMut<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, _index: &RangeFull) -> &[T] {\n         make_slice!(T => &[T]: self.ptr, self.end)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, _index: RangeFull) -> &[T] {\n+        make_slice!(T => &[T]: self.ptr, self.end)\n+    }\n }\n \n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::Range<usize>> for IterMut<'a, T> {\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n         self.index_mut(&RangeFull).index_mut(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n+        self.index_mut(RangeFull).index_mut(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::RangeTo<usize>> for IterMut<'a, T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n         self.index_mut(&RangeFull).index_mut(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n+        self.index_mut(RangeFull).index_mut(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::RangeFrom<usize>> for IterMut<'a, T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n         self.index_mut(&RangeFull).index_mut(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n+        self.index_mut(RangeFull).index_mut(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<RangeFull> for IterMut<'a, T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, _index: &RangeFull) -> &mut [T] {\n         make_mut_slice!(T => &mut [T]: self.ptr, self.end)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, _index: RangeFull) -> &mut [T] {\n+        make_mut_slice!(T => &mut [T]: self.ptr, self.end)\n+    }\n }\n \n \n@@ -1491,6 +1697,7 @@ pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n /// # Examples\n ///\n /// ```\n+/// #![feature(core)]\n /// use std::slice;\n ///\n /// // manifest a slice out of thin air!"}, {"sha": "b7285d30a7309cc9451a22aef5e4ba7170a3c250", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 206, "deletions": 30, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -111,7 +111,24 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n-    }\n+    };\n+    (pattern reverse $te:ty : $ti:ty) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl<'a, P: Pattern<'a>> Iterator for $ti\n+            where P::Searcher: ReverseSearcher<'a>\n+        {\n+            type Item = $te;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<$te> {\n+                self.0.next()\n+            }\n+            #[inline]\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n+                self.0.size_hint()\n+            }\n+        }\n+    };\n }\n \n /// A trait to abstract the idea of creating a new instance of a type from a\n@@ -550,7 +567,26 @@ struct CharSplitsN<'a, P: Pattern<'a>> {\n     iter: CharSplits<'a, P>,\n     /// The number of splits remaining\n     count: usize,\n-    invert: bool,\n+}\n+\n+/// An iterator over the substrings of a string, separated by a\n+/// pattern, in reverse order.\n+struct RCharSplits<'a, P: Pattern<'a>> {\n+    /// The slice remaining to be iterated\n+    start: usize,\n+    end: usize,\n+    matcher: P::Searcher,\n+    /// Whether an empty string at the end of iteration is allowed\n+    allow_final_empty: bool,\n+    finished: bool,\n+}\n+\n+/// An iterator over the substrings of a string, separated by a\n+/// pattern, splitting at most `count` times, in reverse order.\n+struct RCharSplitsN<'a, P: Pattern<'a>> {\n+    iter: RCharSplits<'a, P>,\n+    /// The number of splits remaining\n+    count: usize,\n }\n \n /// An iterator over the lines of a string, separated by `\\n`.\n@@ -631,21 +667,74 @@ where P::Searcher: DoubleEndedSearcher<'a> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> Iterator for CharSplitsN<'a, P>\n-where P::Searcher: DoubleEndedSearcher<'a> {\n+impl<'a, P: Pattern<'a>> Iterator for CharSplitsN<'a, P> {\n     type Item = &'a str;\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         if self.count != 0 {\n             self.count -= 1;\n-            if self.invert { self.iter.next_back() } else { self.iter.next() }\n+            self.iter.next()\n         } else {\n             self.iter.get_end()\n         }\n     }\n }\n \n+impl<'a, P: Pattern<'a>> RCharSplits<'a, P> {\n+    #[inline]\n+    fn get_remainder(&mut self) -> Option<&'a str> {\n+        if !self.finished && (self.allow_final_empty || self.end - self.start > 0) {\n+            self.finished = true;\n+            unsafe {\n+                let string = self.matcher.haystack().slice_unchecked(self.start, self.end);\n+                Some(string)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, P: Pattern<'a>> Iterator for RCharSplits<'a, P>\n+    where P::Searcher: ReverseSearcher<'a>\n+{\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        if self.finished { return None }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match_back() {\n+            Some((a, b)) => unsafe {\n+                let elt = haystack.slice_unchecked(b, self.end);\n+                self.end = a;\n+                Some(elt)\n+            },\n+            None => self.get_remainder(),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, P: Pattern<'a>> Iterator for RCharSplitsN<'a, P>\n+    where P::Searcher: ReverseSearcher<'a>\n+{\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        if self.count != 0 {\n+            self.count -= 1;\n+            self.iter.next()\n+        } else {\n+            self.iter.get_remainder()\n+        }\n+    }\n+}\n+\n /// The internal state of an iterator that searches for matches of a substring\n /// within a larger string using two-way search\n #[derive(Clone)]\n@@ -1203,6 +1292,7 @@ mod traits {\n     /// // byte 100 is outside the string\n     /// // &s[3 .. 100];\n     /// ```\n+    #[cfg(stage0)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::Range<usize>> for str {\n         type Output = str;\n@@ -1219,6 +1309,49 @@ mod traits {\n         }\n     }\n \n+    /// Returns a slice of the given string from the byte range\n+    /// [`begin`..`end`).\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Panics when `begin` and `end` do not point to valid characters\n+    /// or point beyond the last character of the string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(&s[0 .. 1], \"L\");\n+    ///\n+    /// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n+    ///\n+    /// // these will panic:\n+    /// // byte 2 lies within `\u00f6`:\n+    /// // &s[2 ..3];\n+    ///\n+    /// // byte 8 lies within `\u8001`\n+    /// // &s[1 .. 8];\n+    ///\n+    /// // byte 100 is outside the string\n+    /// // &s[3 .. 100];\n+    /// ```\n+    #[cfg(not(stage0))]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl ops::Index<ops::Range<usize>> for str {\n+        type Output = str;\n+        #[inline]\n+        fn index(&self, index: ops::Range<usize>) -> &str {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if index.start <= index.end &&\n+               self.is_char_boundary(index.start) &&\n+               self.is_char_boundary(index.end) {\n+                unsafe { self.slice_unchecked(index.start, index.end) }\n+            } else {\n+                super::slice_error_fail(self, index.start, index.end)\n+            }\n+        }\n+    }\n+\n     /// Returns a slice of the string from the beginning to byte\n     /// `end`.\n     ///\n@@ -1229,6 +1362,8 @@ mod traits {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeTo<usize>> for str {\n         type Output = str;\n+\n+        #[cfg(stage0)]\n         #[inline]\n         fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n@@ -1238,6 +1373,17 @@ mod traits {\n                 super::slice_error_fail(self, 0, index.end)\n             }\n         }\n+\n+        #[cfg(not(stage0))]\n+        #[inline]\n+        fn index(&self, index: ops::RangeTo<usize>) -> &str {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.end) {\n+                unsafe { self.slice_unchecked(0, index.end) }\n+            } else {\n+                super::slice_error_fail(self, 0, index.end)\n+            }\n+        }\n     }\n \n     /// Returns a slice of the string from `begin` to its end.\n@@ -1249,6 +1395,8 @@ mod traits {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeFrom<usize>> for str {\n         type Output = str;\n+\n+        #[cfg(stage0)]\n         #[inline]\n         fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n@@ -1258,15 +1406,34 @@ mod traits {\n                 super::slice_error_fail(self, index.start, self.len())\n             }\n         }\n+\n+        #[cfg(not(stage0))]\n+        #[inline]\n+        fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.start) {\n+                unsafe { self.slice_unchecked(index.start, self.len()) }\n+            } else {\n+                super::slice_error_fail(self, index.start, self.len())\n+            }\n+        }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeFull> for str {\n         type Output = str;\n+\n+        #[cfg(stage0)]\n         #[inline]\n         fn index(&self, _index: &ops::RangeFull) -> &str {\n             self\n         }\n+\n+        #[cfg(not(stage0))]\n+        #[inline]\n+        fn index(&self, _index: ops::RangeFull) -> &str {\n+            self\n+        }\n     }\n }\n \n@@ -1275,16 +1442,20 @@ mod traits {\n            reason = \"Instead of taking this bound generically, this trait will be \\\n                      replaced with one of slicing syntax (&foo[..]), deref coercions, or \\\n                      a more generic conversion trait\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use std::convert::AsRef<str> instead\")]\n pub trait Str {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a str;\n }\n \n+#[allow(deprecated)]\n impl Str for str {\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str { self }\n }\n \n+#[allow(deprecated)]\n impl<'a, S: ?Sized> Str for &'a S where S: Str {\n     #[inline]\n     fn as_slice(&self) -> &str { Str::as_slice(*self) }\n@@ -1293,23 +1464,7 @@ impl<'a, S: ?Sized> Str for &'a S where S: Str {\n /// Return type of `StrExt::split`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Split<'a, P: Pattern<'a>>(CharSplits<'a, P>);\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> Iterator for Split<'a, P> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        self.0.next()\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> DoubleEndedIterator for Split<'a, P>\n-where P::Searcher: DoubleEndedSearcher<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        self.0.next_back()\n-    }\n-}\n+delegate_iter!{pattern &'a str : Split<'a, P>}\n \n /// Return type of `StrExt::split_terminator`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1321,10 +1476,15 @@ delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}\n pub struct SplitN<'a, P: Pattern<'a>>(CharSplitsN<'a, P>);\n delegate_iter!{pattern forward &'a str : SplitN<'a, P>}\n \n+/// Return type of `StrExt::rsplit`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct RSplit<'a, P: Pattern<'a>>(RCharSplits<'a, P>);\n+delegate_iter!{pattern reverse &'a str : RSplit<'a, P>}\n+\n /// Return type of `StrExt::rsplitn`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RSplitN<'a, P: Pattern<'a>>(CharSplitsN<'a, P>);\n-delegate_iter!{pattern forward &'a str : RSplitN<'a, P>}\n+pub struct RSplitN<'a, P: Pattern<'a>>(RCharSplitsN<'a, P>);\n+delegate_iter!{pattern reverse &'a str : RSplitN<'a, P>}\n \n /// Methods for string slices\n #[allow(missing_docs)]\n@@ -1340,7 +1500,10 @@ pub trait StrExt {\n     fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P>;\n     fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;\n     fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n-    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>;\n+    fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>;\n+    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>;\n     fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P>;\n     #[allow(deprecated) /* for SplitStr */]\n     fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P>;\n@@ -1424,7 +1587,6 @@ impl StrExt for str {\n         SplitN(CharSplitsN {\n             iter: self.split(pat).0,\n             count: count,\n-            invert: false,\n         })\n     }\n \n@@ -1437,11 +1599,25 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P> {\n-        RSplitN(CharSplitsN {\n-            iter: self.split(pat).0,\n+    fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        RSplit(RCharSplits {\n+            start: 0,\n+            end: self.len(),\n+            matcher: pat.into_searcher(self),\n+            allow_final_empty: true,\n+            finished: false,\n+        })\n+    }\n+\n+    #[inline]\n+    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        RSplitN(RCharSplitsN {\n+            iter: self.rsplit(pat).0,\n             count: count,\n-            invert: true,\n         })\n     }\n "}, {"sha": "98b6533980dd913728ff45724e01793ee26d1122", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -474,22 +474,16 @@ impl<'a, 'b> Pattern<'a> for &'b [char] {\n                       s, CharEqPattern(s));\n }\n \n+/// A convenience impl that delegates to the impl for `&str`\n+impl<'a, 'b> Pattern<'a> for &'b &'b str {\n+    type Searcher =   <&'b str as Pattern<'a>>::Searcher;\n+    associated_items!(<&'b str as Pattern<'a>>::Searcher,\n+                      s, (*s));\n+}\n+\n /// Searches for chars that match the given predicate\n impl<'a, F> Pattern<'a> for F where F: FnMut(char) -> bool {\n     type Searcher =   <CharEqPattern<Self> as Pattern<'a>>::Searcher;\n     associated_items!(<CharEqPattern<Self> as Pattern<'a>>::Searcher,\n                       s, CharEqPattern(s));\n }\n-\n-// Deref-forward impl\n-\n-use ops::Deref;\n-\n-/// Delegates to the next deref coercion of `Self` that implements `Pattern`\n-impl<'a, 'b, P: 'b + ?Sized, T: Deref<Target = P> + ?Sized> Pattern<'a> for &'b T\n-    where &'b P: Pattern<'a>\n-{\n-    type Searcher =   <&'b P as Pattern<'a>>::Searcher;\n-    associated_items!(<&'b P as Pattern<'a>>::Searcher,\n-                      s, (&**s));\n-}"}, {"sha": "33f9b63bc4907d006439c5a77f5d61a6ee8ea788", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -24,6 +24,8 @@\n #![feature(io)]\n #![feature(collections)]\n #![feature(debug_builders)]\n+#![feature(unique)]\n+#![feature(step_by)]\n #![allow(deprecated)] // rand\n \n extern crate core;"}, {"sha": "adc15b9fbc27ffcd6bf38f74d4d9ec8246850baf", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -35,18 +35,18 @@ fn test() {\n         let v0 = vec![32000u16, 32001u16, 32002u16];\n         let mut v1 = vec![0u16, 0u16, 0u16];\n \n-        copy_memory(v1.as_mut_ptr().offset(1),\n-                    v0.as_ptr().offset(1), 1);\n+        copy(v1.as_mut_ptr().offset(1),\n+             v0.as_ptr().offset(1), 1);\n         assert!((v1[0] == 0u16 &&\n                  v1[1] == 32001u16 &&\n                  v1[2] == 0u16));\n-        copy_memory(v1.as_mut_ptr(),\n-                    v0.as_ptr().offset(2), 1);\n+        copy(v1.as_mut_ptr(),\n+             v0.as_ptr().offset(2), 1);\n         assert!((v1[0] == 32002u16 &&\n                  v1[1] == 32001u16 &&\n                  v1[2] == 0u16));\n-        copy_memory(v1.as_mut_ptr().offset(2),\n-                    v0.as_ptr(), 1);\n+        copy(v1.as_mut_ptr().offset(2),\n+             v0.as_ptr(), 1);\n         assert!((v1[0] == 32002u16 &&\n                  v1[1] == 32001u16 &&\n                  v1[2] == 32000u16));\n@@ -164,7 +164,7 @@ fn test_ptr_subtraction() {\n fn test_set_memory() {\n     let mut xs = [0u8; 20];\n     let ptr = xs.as_mut_ptr();\n-    unsafe { set_memory(ptr, 5u8, xs.len()); }\n+    unsafe { write_bytes(ptr, 5u8, xs.len()); }\n     assert!(xs == [5u8; 20]);\n }\n "}, {"sha": "38cab4f0e0942440063c16e0bd3b1a3813fd9451", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -13,9 +13,7 @@ fn test_pattern_deref_forward() {\n     let data = \"aabcdaa\";\n     assert!(data.contains(\"bcd\"));\n     assert!(data.contains(&\"bcd\"));\n-    assert!(data.contains(&&\"bcd\"));\n     assert!(data.contains(&\"bcd\".to_string()));\n-    assert!(data.contains(&&\"bcd\".to_string()));\n }\n \n #[test]"}, {"sha": "63d1fe968fe1b6a0a3aa4c53a0b78f287e1d1d1e", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -28,6 +28,7 @@\n #![feature(libc)]\n #![feature(staged_api)]\n #![feature(unique)]\n+#![cfg_attr(test, feature(rustc_private, rand, collections))]\n \n #[cfg(test)] #[macro_use] extern crate log;\n "}, {"sha": "ccf4a3f48d9a15aa2cc7106b9a878df808c556f2", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -47,12 +47,13 @@\n //! which is cyclic.\n //!\n //! ```rust\n+//! # #![feature(rustc_private, core, into_cow)]\n //! use std::borrow::IntoCow;\n //! use std::io::Write;\n //! use graphviz as dot;\n //!\n-//! type Nd = int;\n-//! type Ed = (int,int);\n+//! type Nd = isize;\n+//! type Ed = (isize,isize);\n //! struct Edges(Vec<Ed>);\n //!\n //! pub fn render_to<W: Write>(output: &mut W) {\n@@ -132,7 +133,7 @@\n //! direct reference to the `(source,target)` pair stored in the graph's\n //! internal vector (rather than passing around a copy of the pair\n //! itself). Note that this implies that `fn edges(&'a self)` must\n-//! construct a fresh `Vec<&'a (uint,uint)>` from the `Vec<(uint,uint)>`\n+//! construct a fresh `Vec<&'a (usize,usize)>` from the `Vec<(usize,usize)>`\n //! edges stored in `self`.\n //!\n //! Since both the set of nodes and the set of edges are always\n@@ -148,13 +149,14 @@\n //! entity `&sube`).\n //!\n //! ```rust\n+//! # #![feature(rustc_private, core, into_cow)]\n //! use std::borrow::IntoCow;\n //! use std::io::Write;\n //! use graphviz as dot;\n //!\n-//! type Nd = uint;\n-//! type Ed<'a> = &'a (uint, uint);\n-//! struct Graph { nodes: Vec<&'static str>, edges: Vec<(uint,uint)> }\n+//! type Nd = usize;\n+//! type Ed<'a> = &'a (usize, usize);\n+//! struct Graph { nodes: Vec<&'static str>, edges: Vec<(usize,usize)> }\n //!\n //! pub fn render_to<W: Write>(output: &mut W) {\n //!     let nodes = vec!(\"{x,y}\",\"{x}\",\"{y}\",\"{}\");\n@@ -205,13 +207,14 @@\n //! Hasse-diagram for the subsets of the set `{x, y}`.\n //!\n //! ```rust\n+//! # #![feature(rustc_private, core, into_cow)]\n //! use std::borrow::IntoCow;\n //! use std::io::Write;\n //! use graphviz as dot;\n //!\n-//! type Nd<'a> = (uint, &'a str);\n+//! type Nd<'a> = (usize, &'a str);\n //! type Ed<'a> = (Nd<'a>, Nd<'a>);\n-//! struct Graph { nodes: Vec<&'static str>, edges: Vec<(uint,uint)> }\n+//! struct Graph { nodes: Vec<&'static str>, edges: Vec<(usize,usize)> }\n //!\n //! pub fn render_to<W: Write>(output: &mut W) {\n //!     let nodes = vec!(\"{x,y}\",\"{x}\",\"{y}\",\"{}\");\n@@ -228,7 +231,7 @@\n //!     }\n //!     fn node_label<'b>(&'b self, n: &Nd<'b>) -> dot::LabelText<'b> {\n //!         let &(i, _) = n;\n-//!         dot::LabelText::LabelStr(self.nodes[i].as_slice().into_cow())\n+//!         dot::LabelText::LabelStr(self.nodes[i].into_cow())\n //!     }\n //!     fn edge_label<'b>(&'b self, _: &Ed<'b>) -> dot::LabelText<'b> {\n //!         dot::LabelText::LabelStr(\"&sube;\".into_cow())\n@@ -237,12 +240,12 @@\n //!\n //! impl<'a> dot::GraphWalk<'a, Nd<'a>, Ed<'a>> for Graph {\n //!     fn nodes(&'a self) -> dot::Nodes<'a,Nd<'a>> {\n-//!         self.nodes.iter().map(|s|s.as_slice()).enumerate().collect()\n+//!         self.nodes.iter().map(|s| &s[..]).enumerate().collect()\n //!     }\n //!     fn edges(&'a self) -> dot::Edges<'a,Ed<'a>> {\n //!         self.edges.iter()\n-//!             .map(|&(i,j)|((i, self.nodes[i].as_slice()),\n-//!                           (j, self.nodes[j].as_slice())))\n+//!             .map(|&(i,j)|((i, &self.nodes[i][..]),\n+//!                           (j, &self.nodes[j][..])))\n //!             .collect()\n //!     }\n //!     fn source(&self, e: &Ed<'a>) -> Nd<'a> { let &(s,_) = e; s }\n@@ -280,6 +283,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n #![feature(int_uint)]\n #![feature(collections)]\n+#![feature(into_cow)]\n \n use self::LabelText::*;\n \n@@ -381,7 +385,7 @@ impl<'a> Id<'a> {\n             is_letter_or_underscore(c) || in_range('0', c, '9')\n         }\n         fn in_range(low: char, c: char, high: char) -> bool {\n-            low as uint <= c as uint && c as uint <= high as uint\n+            low as usize <= c as usize && c as usize <= high as usize\n         }\n     }\n \n@@ -598,12 +602,12 @@ mod tests {\n     use std::iter::repeat;\n \n     /// each node is an index in a vector in the graph.\n-    type Node = uint;\n+    type Node = usize;\n     struct Edge {\n-        from: uint, to: uint, label: &'static str\n+        from: usize, to: usize, label: &'static str\n     }\n \n-    fn edge(from: uint, to: uint, label: &'static str) -> Edge {\n+    fn edge(from: usize, to: usize, label: &'static str) -> Edge {\n         Edge { from: from, to: to, label: label }\n     }\n \n@@ -633,7 +637,7 @@ mod tests {\n \n     enum NodeLabels<L> {\n         AllNodesLabelled(Vec<L>),\n-        UnlabelledNodes(uint),\n+        UnlabelledNodes(usize),\n         SomeNodesLabelled(Vec<Option<L>>),\n     }\n "}, {"sha": "0043f574cc90dbb237738ae33e725c0f6c3d44eb", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 107, "deletions": 13, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -2495,10 +2495,24 @@ pub mod consts {\n \n             pub const TCP_NODELAY: c_int = 0x0001;\n             pub const SOL_SOCKET: c_int = 0xffff;\n-            pub const SO_KEEPALIVE: c_int = 8;\n-            pub const SO_BROADCAST: c_int = 32;\n-            pub const SO_REUSEADDR: c_int = 4;\n+\n+            pub const SO_DEBUG: c_int = 0x0001;\n+            pub const SO_ACCEPTCONN: c_int = 0x0002;\n+            pub const SO_REUSEADDR: c_int = 0x0004;\n+            pub const SO_KEEPALIVE: c_int = 0x0008;\n+            pub const SO_DONTROUTE: c_int = 0x0010;\n+            pub const SO_BROADCAST: c_int = 0x0020;\n+            pub const SO_USELOOPBACK: c_int = 0x0040;\n+            pub const SO_LINGER: c_int = 0x0080;\n+            pub const SO_OOBINLINE: c_int = 0x0100;\n+            pub const SO_SNDBUF: c_int = 0x1001;\n+            pub const SO_RCVBUF: c_int = 0x1002;\n+            pub const SO_SNDLOWAT: c_int = 0x1003;\n+            pub const SO_RCVLOWAT: c_int = 0x1004;\n+            pub const SO_SNDTIMEO: c_int = 0x1005;\n+            pub const SO_RCVTIMEO: c_int = 0x1006;\n             pub const SO_ERROR: c_int = 0x1007;\n+            pub const SO_TYPE: c_int = 0x1008;\n \n             pub const IFF_LOOPBACK: c_int = 4;\n \n@@ -3441,10 +3455,24 @@ pub mod consts {\n \n             pub const TCP_NODELAY: c_int = 1;\n             pub const SOL_SOCKET: c_int = 1;\n-            pub const SO_KEEPALIVE: c_int = 9;\n-            pub const SO_BROADCAST: c_int = 6;\n+\n+            pub const SO_DEBUG: c_int = 1;\n             pub const SO_REUSEADDR: c_int = 2;\n+            pub const SO_TYPE: c_int = 3;\n             pub const SO_ERROR: c_int = 4;\n+            pub const SO_DONTROUTE: c_int = 5;\n+            pub const SO_BROADCAST: c_int = 6;\n+            pub const SO_SNDBUF: c_int = 7;\n+            pub const SO_RCVBUF: c_int = 8;\n+            pub const SO_KEEPALIVE: c_int = 9;\n+            pub const SO_OOBINLINE: c_int = 10;\n+            pub const SO_LINGER: c_int = 13;\n+            pub const SO_REUSEPORT: c_int = 15;\n+            pub const SO_RCVLOWAT: c_int = 18;\n+            pub const SO_SNDLOWAT: c_int = 19;\n+            pub const SO_RCVTIMEO: c_int = 20;\n+            pub const SO_SNDTIMEO: c_int = 21;\n+            pub const SO_ACCEPTCONN: c_int = 30;\n \n             pub const SHUT_RD: c_int = 0;\n             pub const SHUT_WR: c_int = 1;\n@@ -3487,10 +3515,24 @@ pub mod consts {\n \n             pub const TCP_NODELAY: c_int = 1;\n             pub const SOL_SOCKET: c_int = 65535;\n-            pub const SO_KEEPALIVE: c_int = 8;\n-            pub const SO_BROADCAST: c_int = 32;\n-            pub const SO_REUSEADDR: c_int = 4;\n-            pub const SO_ERROR: c_int = 4103;\n+\n+            pub const SO_DEBUG: c_int = 0x0001;\n+            pub const SO_REUSEADDR: c_int = 0x0004;\n+            pub const SO_KEEPALIVE: c_int = 0x0008;\n+            pub const SO_DONTROUTE: c_int = 0x0010;\n+            pub const SO_BROADCAST: c_int = 0x0020;\n+            pub const SO_LINGER: c_int = 0x0080;\n+            pub const SO_OOBINLINE: c_int = 0x100;\n+            pub const SO_REUSEPORT: c_int = 0x0200;\n+            pub const SO_SNDBUF: c_int = 0x1001;\n+            pub const SO_RCVBUF: c_int = 0x1002;\n+            pub const SO_SNDLOWAT: c_int = 0x1003;\n+            pub const SO_RCVLOWAT: c_int = 0x1004;\n+            pub const SO_SNDTIMEO: c_int = 0x1005;\n+            pub const SO_RCVTIMEO: c_int = 0x1006;\n+            pub const SO_ERROR: c_int = 0x1007;\n+            pub const SO_TYPE: c_int = 0x1008;\n+            pub const SO_ACCEPTCONN: c_int = 0x1009;\n \n             pub const SHUT_RD: c_int = 0;\n             pub const SHUT_WR: c_int = 1;\n@@ -4002,10 +4044,24 @@ pub mod consts {\n             pub const TCP_NODELAY: c_int = 1;\n             pub const TCP_KEEPIDLE: c_int = 256;\n             pub const SOL_SOCKET: c_int = 0xffff;\n+            pub const SO_DEBUG: c_int = 0x01;\n+            pub const SO_ACCEPTCONN: c_int = 0x0002;\n+            pub const SO_REUSEADDR: c_int = 0x0004;\n             pub const SO_KEEPALIVE: c_int = 0x0008;\n+            pub const SO_DONTROUTE: c_int = 0x0010;\n             pub const SO_BROADCAST: c_int = 0x0020;\n-            pub const SO_REUSEADDR: c_int = 0x0004;\n+            pub const SO_USELOOPBACK: c_int = 0x0040;\n+            pub const SO_LINGER: c_int = 0x0080;\n+            pub const SO_OOBINLINE: c_int = 0x0100;\n+            pub const SO_REUSEPORT: c_int = 0x0200;\n+            pub const SO_SNDBUF: c_int = 0x1001;\n+            pub const SO_RCVBUF: c_int = 0x1002;\n+            pub const SO_SNDLOWAT: c_int = 0x1003;\n+            pub const SO_RCVLOWAT: c_int = 0x1004;\n+            pub const SO_SNDTIMEO: c_int = 0x1005;\n+            pub const SO_RCVTIMEO: c_int = 0x1006;\n             pub const SO_ERROR: c_int = 0x1007;\n+            pub const SO_TYPE: c_int = 0x1008;\n \n             pub const IFF_LOOPBACK: c_int = 0x8;\n \n@@ -4403,10 +4459,24 @@ pub mod consts {\n \n             pub const TCP_NODELAY: c_int = 0x01;\n             pub const SOL_SOCKET: c_int = 0xffff;\n+            pub const SO_DEBUG: c_int = 0x01;\n+            pub const SO_ACCEPTCONN: c_int = 0x0002;\n+            pub const SO_REUSEADDR: c_int = 0x0004;\n             pub const SO_KEEPALIVE: c_int = 0x0008;\n+            pub const SO_DONTROUTE: c_int = 0x0010;\n             pub const SO_BROADCAST: c_int = 0x0020;\n-            pub const SO_REUSEADDR: c_int = 0x0004;\n+            pub const SO_USELOOPBACK: c_int = 0x0040;\n+            pub const SO_LINGER: c_int = 0x0080;\n+            pub const SO_OOBINLINE: c_int = 0x0100;\n+            pub const SO_REUSEPORT: c_int = 0x0200;\n+            pub const SO_SNDBUF: c_int = 0x1001;\n+            pub const SO_RCVBUF: c_int = 0x1002;\n+            pub const SO_SNDLOWAT: c_int = 0x1003;\n+            pub const SO_RCVLOWAT: c_int = 0x1004;\n+            pub const SO_SNDTIMEO: c_int = 0x1005;\n+            pub const SO_RCVTIMEO: c_int = 0x1006;\n             pub const SO_ERROR: c_int = 0x1007;\n+            pub const SO_TYPE: c_int = 0x1008;\n \n             pub const IFF_LOOPBACK: c_int = 0x8;\n \n@@ -4820,10 +4890,25 @@ pub mod consts {\n             pub const TCP_NODELAY: c_int = 0x01;\n             pub const TCP_KEEPALIVE: c_int = 0x10;\n             pub const SOL_SOCKET: c_int = 0xffff;\n+\n+            pub const SO_DEBUG: c_int = 0x01;\n+            pub const SO_ACCEPTCONN: c_int = 0x0002;\n+            pub const SO_REUSEADDR: c_int = 0x0004;\n             pub const SO_KEEPALIVE: c_int = 0x0008;\n+            pub const SO_DONTROUTE: c_int = 0x0010;\n             pub const SO_BROADCAST: c_int = 0x0020;\n-            pub const SO_REUSEADDR: c_int = 0x0004;\n+            pub const SO_USELOOPBACK: c_int = 0x0040;\n+            pub const SO_LINGER: c_int = 0x0080;\n+            pub const SO_OOBINLINE: c_int = 0x0100;\n+            pub const SO_REUSEPORT: c_int = 0x0200;\n+            pub const SO_SNDBUF: c_int = 0x1001;\n+            pub const SO_RCVBUF: c_int = 0x1002;\n+            pub const SO_SNDLOWAT: c_int = 0x1003;\n+            pub const SO_RCVLOWAT: c_int = 0x1004;\n+            pub const SO_SNDTIMEO: c_int = 0x1005;\n+            pub const SO_RCVTIMEO: c_int = 0x1006;\n             pub const SO_ERROR: c_int = 0x1007;\n+            pub const SO_TYPE: c_int = 0x1008;\n \n             pub const IFF_LOOPBACK: c_int = 0x8;\n \n@@ -4849,6 +4934,15 @@ pub mod consts {\n             pub const MAP_STACK : c_int = 0;\n \n             pub const IPPROTO_RAW : c_int = 255;\n+\n+            pub const SO_NREAD: c_int = 0x1020;\n+            pub const SO_NKE: c_int = 0x1021;\n+            pub const SO_NOSIGPIPE: c_int = 0x1022;\n+            pub const SO_NOADDRERR: c_int = 0x1023;\n+            pub const SO_NWRITE: c_int = 0x1024;\n+            pub const SO_DONTTRUNC: c_int = 0x2000;\n+            pub const SO_WANTMORE: c_int = 0x4000;\n+            pub const SO_WANTOOBFLAG: c_int = 0x8000;\n         }\n         pub mod sysconf {\n             use types::os::arch::c95::c_int;\n@@ -5031,7 +5125,7 @@ pub mod funcs {\n                 ///\n                 /// # Examples\n                 ///\n-                /// ```no_run\n+                /// ```no_run,ignore\n                 /// extern crate libc;\n                 ///\n                 /// fn main() {"}, {"sha": "0c5f5cb0d444ee44962375c1b6a8818dde76b294", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -60,6 +60,7 @@ impl Rand for Exp1 {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(rand)]\n /// use std::rand;\n /// use std::rand::distributions::{Exp, IndependentSample};\n ///"}, {"sha": "d04e83e84f7289e1a8cecbec01d1048bb1503b06", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -40,6 +40,7 @@ use super::{IndependentSample, Sample, Exp};\n /// # Examples\n ///\n /// ```\n+/// # #![feature(rand)]\n /// use std::rand;\n /// use std::rand::distributions::{IndependentSample, Gamma};\n ///\n@@ -187,6 +188,7 @@ impl IndependentSample<f64> for GammaLargeShape {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(rand)]\n /// use std::rand;\n /// use std::rand::distributions::{ChiSquared, IndependentSample};\n ///\n@@ -244,6 +246,7 @@ impl IndependentSample<f64> for ChiSquared {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(rand)]\n /// use std::rand;\n /// use std::rand::distributions::{FisherF, IndependentSample};\n ///\n@@ -288,6 +291,7 @@ impl IndependentSample<f64> for FisherF {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(rand)]\n /// use std::rand;\n /// use std::rand::distributions::{StudentT, IndependentSample};\n ///"}, {"sha": "5cafb8d2e5eae2ab6f61339c9f4f2c42536d75d8", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -94,6 +94,7 @@ pub struct Weighted<T> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(rand)]\n /// use std::rand;\n /// use std::rand::distributions::{Weighted, WeightedChoice, IndependentSample};\n ///"}, {"sha": "7cecc6ac611e2af1e6b587b03b2adaa228974f0b", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -76,6 +76,7 @@ impl Rand for StandardNormal {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(rand)]\n /// use std::rand;\n /// use std::rand::distributions::{Normal, IndependentSample};\n ///\n@@ -124,6 +125,7 @@ impl IndependentSample<f64> for Normal {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(rand)]\n /// use std::rand;\n /// use std::rand::distributions::{LogNormal, IndependentSample};\n ///"}, {"sha": "e6f27a28ffa7ca118d7d6595c33afe8ae54b5b51", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -36,6 +36,7 @@ use distributions::{Sample, IndependentSample};\n /// # Examples\n ///\n /// ```\n+/// # #![feature(rand)]\n /// use std::rand::distributions::{IndependentSample, Range};\n ///\n /// fn main() {"}, {"sha": "9f6399ff12dd659f792aa448eb1cb377456d06ca", "filename": "src/librand/lib.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -34,7 +34,7 @@\n #![deprecated(reason = \"use the crates.io `rand` library instead\",\n               since = \"1.0.0-alpha\")]\n \n-#![cfg_attr(test, feature(test, rand))]\n+#![cfg_attr(test, feature(test, rand, rustc_private))]\n \n #![allow(deprecated)]\n \n@@ -149,6 +149,7 @@ pub trait Rng : Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(rand, core)]\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut v = [0; 13579];\n@@ -184,6 +185,7 @@ pub trait Rng : Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(rand)]\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n@@ -202,6 +204,7 @@ pub trait Rng : Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(rand)]\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n@@ -229,6 +232,7 @@ pub trait Rng : Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(rand)]\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n@@ -247,6 +251,7 @@ pub trait Rng : Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(rand)]\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n@@ -261,6 +266,7 @@ pub trait Rng : Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(rand)]\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let s: String = thread_rng().gen_ascii_chars().take(10).collect();\n@@ -277,6 +283,7 @@ pub trait Rng : Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(rand)]\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let choices = [1, 2, 4, 8, 16, 32];\n@@ -297,6 +304,7 @@ pub trait Rng : Sized {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(rand, core)]\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n@@ -360,6 +368,7 @@ pub trait SeedableRng<Seed>: Rng {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(rand)]\n     /// use std::rand::{Rng, SeedableRng, StdRng};\n     ///\n     /// let seed: &[_] = &[1, 2, 3, 4];\n@@ -375,6 +384,7 @@ pub trait SeedableRng<Seed>: Rng {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(rand)]\n     /// use std::rand::{Rng, SeedableRng, StdRng};\n     ///\n     /// let seed: &[_] = &[1, 2, 3, 4];\n@@ -480,6 +490,7 @@ impl Rand for XorShiftRng {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(rand)]\n /// use std::rand::{random, Open01};\n ///\n /// let Open01(val) = random::<Open01<f32>>();\n@@ -497,6 +508,7 @@ pub struct Open01<F>(pub F);\n /// # Examples\n ///\n /// ```\n+/// # #![feature(rand)]\n /// use std::rand::{random, Closed01};\n ///\n /// let Closed01(val) = random::<Closed01<f32>>();"}, {"sha": "95dd986d2e3c7be0556708349b6b55f3411ccdf5", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -103,6 +103,7 @@ impl<S, R: SeedableRng<S>, Rsdr: Reseeder<R> + Default>\n /// # Examples\n ///\n /// ```\n+/// # #![feature(rand)]\n /// use std::rand::{Rng, SeedableRng, StdRng};\n /// use std::rand::reseeding::{Reseeder, ReseedingRng};\n ///"}, {"sha": "793eff6a9da6fc9763c02e68a72ee7ccecd5a5f6", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -43,6 +43,8 @@\n #![feature(path_ext)]\n #![feature(str_words)]\n #![feature(str_char)]\n+#![feature(convert)]\n+#![feature(into_cow)]\n #![cfg_attr(test, feature(test))]\n \n extern crate arena;"}, {"sha": "9688447dc046a50f3f3996333d98c82354d20442", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -212,7 +212,7 @@ impl LintStore {\n     fn maybe_stage_features(&mut self, sess: &Session) {\n         let lvl = match sess.opts.unstable_features {\n             UnstableFeatures::Default => return,\n-            UnstableFeatures::Disallow => Warn,\n+            UnstableFeatures::Disallow => Forbid,\n             UnstableFeatures::Cheat => Allow\n         };\n         match self.by_name.get(\"unstable_features\") {"}, {"sha": "f201ff374ea0f058db497bebce436a4dc34d06ea", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -111,7 +111,7 @@ impl CStore {\n     }\n \n     pub fn get_crate_data(&self, cnum: ast::CrateNum) -> Rc<crate_metadata> {\n-        (*self.metas.borrow())[cnum].clone()\n+        self.metas.borrow().get(&cnum).unwrap().clone()\n     }\n \n     pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> Svh {\n@@ -243,7 +243,7 @@ impl crate_metadata {\n impl MetadataBlob {\n     pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n         let slice = match *self {\n-            MetadataVec(ref vec) => vec.as_slice(),\n+            MetadataVec(ref vec) => &vec[..],\n             MetadataArchive(ref ar) => ar.as_slice(),\n         };\n         if slice.len() < 4 {"}, {"sha": "fa8d0b2a56e4ee34b8e062ed0bac19948f730897", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -375,7 +375,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n     match ecx.tcx.inherent_impls.borrow().get(&exp.def_id) {\n         Some(implementations) => {\n             for base_impl_did in &**implementations {\n-                for &method_did in &*(*impl_items)[*base_impl_did] {\n+                for &method_did in impl_items.get(base_impl_did).unwrap() {\n                     let impl_item = ty::impl_or_trait_item(\n                         ecx.tcx,\n                         method_did.def_id());\n@@ -1175,7 +1175,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impl_items = tcx.impl_items.borrow();\n-        let items = &(*impl_items)[def_id];\n+        let items = impl_items.get(&def_id).unwrap();\n \n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n@@ -1816,7 +1816,7 @@ struct ImplVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         if let ast::ItemImpl(_, _, _, Some(ref trait_ref), _, _) = item.node {\n-            let def_id = self.ecx.tcx.def_map.borrow()[trait_ref.ref_id].def_id();\n+            let def_id = self.ecx.tcx.def_map.borrow().get(&trait_ref.ref_id).unwrap().def_id();\n \n             // Load eagerly if this is an implementation of the Drop trait\n             // or if the trait is not defined in this crate."}, {"sha": "284e76b328a6912323692c82f0f6180e8f29f97e", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -156,7 +156,7 @@ impl<'a> FileSearch<'a> {\n \n     // Returns a list of directories where target-specific tool binaries are located.\n     pub fn get_tools_search_paths(&self) -> Vec<PathBuf> {\n-        let mut p = PathBuf::new(self.sysroot);\n+        let mut p = PathBuf::from(self.sysroot);\n         p.push(&find_libdir(self.sysroot));\n         p.push(&rustlibdir());\n         p.push(&self.triple);\n@@ -166,7 +166,7 @@ impl<'a> FileSearch<'a> {\n }\n \n pub fn relative_target_lib_path(sysroot: &Path, target_triple: &str) -> PathBuf {\n-    let mut p = PathBuf::new(&find_libdir(sysroot));\n+    let mut p = PathBuf::from(&find_libdir(sysroot));\n     assert!(p.is_relative());\n     p.push(&rustlibdir());\n     p.push(target_triple);\n@@ -224,7 +224,7 @@ pub fn rust_path() -> Vec<PathBuf> {\n         Some(env_path) => {\n             let env_path_components =\n                 env_path.split(PATH_ENTRY_SEPARATOR);\n-            env_path_components.map(|s| PathBuf::new(s)).collect()\n+            env_path_components.map(|s| PathBuf::from(s)).collect()\n         }\n         None => Vec::new()\n     };"}, {"sha": "7854db811466517bbd3f675ab3ac0e80b9edc643", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -628,7 +628,7 @@ impl<'a> Context<'a> {\n         let mut rlibs = HashMap::new();\n         let mut dylibs = HashMap::new();\n         {\n-            let locs = locs.iter().map(|l| PathBuf::new(&l[..])).filter(|loc| {\n+            let locs = locs.iter().map(|l| PathBuf::from(l)).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\"extern location for {} does not exist: {}\",\n                                      self.crate_name, loc.display()));"}, {"sha": "801350e8a1e9c1d50d29d9f28d66f9c7add566ad", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -1228,7 +1228,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                     var_id: var_id,\n                     closure_expr_id: id\n                 };\n-                let upvar_capture = tcx.upvar_capture_map.borrow()[upvar_id].clone();\n+                let upvar_capture = tcx.upvar_capture_map.borrow().get(&upvar_id).unwrap().clone();\n                 var_id.encode(rbml_w);\n                 upvar_capture.encode(rbml_w);\n             })"}, {"sha": "97cd9456098b1bbab4fb5b8947975d9d46af1399", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -874,7 +874,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         ast::PatEnum(_, ref args) => {\n-            let def = cx.tcx.def_map.borrow()[pat_id].full_def();\n+            let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n                 DefConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n@@ -892,7 +892,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n \n         ast::PatStruct(_, ref pattern_fields, _) => {\n             // Is this a struct or an enum variant?\n-            let def = cx.tcx.def_map.borrow()[pat_id].full_def();\n+            let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             let class_id = match def {\n                 DefConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\"}, {"sha": "f9598237ff460805cc0494475f97820ff385fb3d", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -150,7 +150,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n             ast::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect()),\n \n         ast::ExprCall(ref callee, ref args) => {\n-            let def = tcx.def_map.borrow()[callee.id];\n+            let def = *tcx.def_map.borrow().get(&callee.id).unwrap();\n             if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n                entry.insert(def);\n             }"}, {"sha": "6d4d759476ed5330edde04b58b498f294dc99498", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -158,7 +158,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &ast::Pat,\n                                   pats: &[codemap::Spanned<ast::FieldPat>]) {\n-        let id = match self.tcx.def_map.borrow()[lhs.id].full_def() {\n+        let id = match self.tcx.def_map.borrow().get(&lhs.id).unwrap().full_def() {\n             def::DefVariant(_, id, _) => id,\n             _ => {\n                 match ty::ty_to_def_id(ty::node_id_to_type(self.tcx,\n@@ -496,7 +496,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             None => (),\n             Some(impl_list) => {\n                 for impl_did in &**impl_list {\n-                    for item_did in &(*impl_items)[*impl_did] {\n+                    for item_did in &*impl_items.get(impl_did).unwrap() {\n                         if self.live_symbols.contains(&item_did.def_id()\n                                                                .node) {\n                             return true;"}, {"sha": "5d970c59f639bd5e3b4a289a7419ce7ddb52dfd0", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -141,7 +141,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             ast::ExprMethodCall(_, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = (*self.tcx.method_map.borrow())[method_call].ty;\n+                let base_type = self.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n                 debug!(\"effect: method call case, base type is {}\",\n                        ppaux::ty_to_string(self.tcx, base_type));\n                 if type_is_unsafe_function(base_type) {"}, {"sha": "97314b57ef656802a6b773495566051c7a27978c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -442,7 +442,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 if !self.walk_overloaded_operator(expr,\n                                                   &**lhs,\n                                                   vec![&**rhs],\n-                                                  PassArgs::ByRef) {\n+                                                  PassArgs::ByValue) {\n                     self.select_from_expr(&**lhs);\n                     self.consume_expr(&**rhs);\n                 }\n@@ -1012,7 +1012,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n-                let def = def_map.borrow()[pat.id].full_def();\n+                let def = def_map.borrow().get(&pat.id).unwrap().full_def();\n                 match mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                     Ok(binding_cmt) => {\n                         delegate.mutate(pat.id, pat.span, binding_cmt, Init);"}, {"sha": "930e95d1f939a474590138324dbacc9dd1b5dac7", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -557,18 +557,7 @@ pub fn super_tys<'tcx, C>(this: &C,\n \n         (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n             let r = try!(this.regions_with_variance(ty::Contravariant, *a_r, *b_r));\n-\n-            // FIXME(14985)  If we have mutable references to trait objects, we\n-            // used to use covariant subtyping. I have preserved this behaviour,\n-            // even though it is probably incorrect. So don't go down the usual\n-            // path which would require invariance.\n-            let mt = match (&a_mt.ty.sty, &b_mt.ty.sty) {\n-                (&ty::ty_trait(..), &ty::ty_trait(..)) if a_mt.mutbl == b_mt.mutbl => {\n-                    let ty = try!(this.tys(a_mt.ty, b_mt.ty));\n-                    ty::mt { ty: ty, mutbl: a_mt.mutbl }\n-                }\n-                _ => try!(this.mts(a_mt, b_mt))\n-            };\n+            let mt = try!(this.mts(a_mt, b_mt));\n             Ok(ty::mk_rptr(tcx, tcx.mk_region(r), mt))\n         }\n "}, {"sha": "553e3601806677ed1bc37f4ba22ddc4a9fbe7a3e", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -1533,7 +1533,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     ConstrainVarSubReg(_, region) => {\n                         state.result.push(RegionAndOrigin {\n                             region: region,\n-                            origin: this.constraints.borrow()[edge.data].clone()\n+                            origin: this.constraints.borrow().get(&edge.data).unwrap().clone()\n                         });\n                     }\n                 }"}, {"sha": "705f20559afde27711c2c0934f7aba5c68aa5df0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -448,7 +448,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       ast::ExprPath(..) => {\n-        let def = ir.tcx.def_map.borrow()[expr.id].full_def();\n+        let def = ir.tcx.def_map.borrow().get(&expr.id).unwrap().full_def();\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if let DefLocal(..) = def {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -1302,7 +1302,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n-        match self.ir.tcx.def_map.borrow()[expr.id].full_def() {\n+        match self.ir.tcx.def_map.borrow().get(&expr.id).unwrap().full_def() {\n           DefLocal(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0 {\n@@ -1564,7 +1564,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n             ast::ExprPath(..) => {\n-                if let DefLocal(nid) = self.ir.tcx.def_map.borrow()[expr.id].full_def() {\n+                if let DefLocal(nid) = self.ir.tcx.def_map.borrow().get(&expr.id)\n+                                                                   .unwrap()\n+                                                                   .full_def() {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability"}, {"sha": "bdcfc67f92b997a370cad0693f2eab1f729c626f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -531,7 +531,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::ExprPath(..) => {\n-            let def = self.tcx().def_map.borrow()[expr.id].full_def();\n+            let def = self.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n "}, {"sha": "4f365beed213f2a44f57d238779cb69d84cebcd7", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -119,6 +119,24 @@ pub fn pat_contains_bindings(dm: &DefMap, pat: &ast::Pat) -> bool {\n     contains_bindings\n }\n \n+/// Checks if the pattern contains any `ref` or `ref mut` bindings.\n+pub fn pat_contains_ref_binding(dm: &DefMap, pat: &ast::Pat) -> bool {\n+    let mut result = false;\n+    pat_bindings(dm, pat, |mode, _, _, _| {\n+        match mode {\n+            ast::BindingMode::BindByRef(_) => { result = true; }\n+            ast::BindingMode::BindByValue(_) => { }\n+        }\n+    });\n+    result\n+}\n+\n+/// Checks if the patterns for this arm contain any `ref` or `ref mut`\n+/// bindings.\n+pub fn arm_contains_ref_binding(dm: &DefMap, arm: &ast::Arm) -> bool {\n+    arm.pats.iter().any(|pat| pat_contains_ref_binding(dm, pat))\n+}\n+\n /// Checks if the pattern contains any patterns that bind something to\n /// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &ast::Pat) -> bool {"}, {"sha": "1bd45b5fc86017cd5a8afea2c994c2e181397d9e", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             }\n             ast::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                match (*self.tcx.method_map.borrow())[method_call].origin {\n+                match (*self.tcx.method_map.borrow()).get(&method_call).unwrap().origin {\n                     ty::MethodStatic(def_id) => {\n                         if is_local(def_id) {\n                             if self.def_id_represents_local_inlined_item(def_id) {"}, {"sha": "7043b2613605d4b9ddf16bbab1d2d0550c9b454a", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -26,7 +26,7 @@ use syntax::ast::{Item, Generics, StructField};\n use syntax::ast_util::is_local;\n use syntax::attr::{Stability, AttrMetaMethods};\n use syntax::visit::{FnKind, Visitor};\n-use syntax::feature_gate::emit_feature_warn;\n+use syntax::feature_gate::emit_feature_err;\n use util::nodemap::{NodeMap, DefIdMap, FnvHashSet, FnvHashMap};\n use util::ppaux::Repr;\n \n@@ -237,7 +237,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                         None => format!(\"use of unstable library feature '{}'\", &feature)\n                     };\n \n-                    emit_feature_warn(&self.tcx.sess.parse_sess.span_diagnostic,\n+                    emit_feature_err(&self.tcx.sess.parse_sess.span_diagnostic,\n                                       &feature, span, &msg);\n                 }\n             }\n@@ -319,7 +319,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n         // individually as it's possible to have a stable trait with unstable\n         // items.\n         ast::ItemImpl(_, _, _, Some(ref t), _, ref impl_items) => {\n-            let trait_did = tcx.def_map.borrow()[t.ref_id].def_id();\n+            let trait_did = tcx.def_map.borrow().get(&t.ref_id).unwrap().def_id();\n             let trait_items = ty::trait_items(tcx, trait_did);\n \n             for impl_item in impl_items {"}, {"sha": "d10ff060418ccb05cdca1061c2e816224c9fbacf", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -12,6 +12,7 @@ use super::{\n     FulfillmentError,\n     FulfillmentErrorCode,\n     MismatchedProjectionTypes,\n+    Obligation,\n     ObligationCauseCode,\n     OutputTypeParameterMismatch,\n     PredicateObligation,\n@@ -21,6 +22,7 @@ use super::{\n use fmt_macros::{Parser, Piece, Position};\n use middle::infer::InferCtxt;\n use middle::ty::{self, AsPredicate, ReferencesError, ToPolyTraitRef, TraitRef};\n+use middle::ty_fold::TypeFoldable;\n use std::collections::HashMap;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n@@ -137,24 +139,36 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     report\n }\n \n+/// Reports that an overflow has occurred and halts compilation. We\n+/// halt compilation unconditionally because it is important that\n+/// overflows never be masked -- they basically represent computations\n+/// whose result could not be truly determined and thus we can't say\n+/// if the program type checks or not -- and they are unusual\n+/// occurrences in any case.\n+pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n+                                          obligation: &Obligation<'tcx, T>)\n+                                          -> !\n+    where T: UserString<'tcx> + TypeFoldable<'tcx>\n+{\n+    let predicate =\n+        infcx.resolve_type_vars_if_possible(&obligation.predicate);\n+    span_err!(infcx.tcx.sess, obligation.cause.span, E0275,\n+              \"overflow evaluating the requirement `{}`\",\n+              predicate.user_string(infcx.tcx));\n+\n+    suggest_new_overflow_limit(infcx.tcx, obligation.cause.span);\n+\n+    note_obligation_cause(infcx, obligation);\n+\n+    infcx.tcx.sess.abort_if_errors();\n+    unreachable!();\n+}\n+\n pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                         obligation: &PredicateObligation<'tcx>,\n                                         error: &SelectionError<'tcx>)\n {\n     match *error {\n-        SelectionError::Overflow => {\n-            // We could track the stack here more precisely if we wanted, I imagine.\n-            let predicate =\n-                infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-            span_err!(infcx.tcx.sess, obligation.cause.span, E0275,\n-                    \"overflow evaluating the requirement `{}`\",\n-                    predicate.user_string(infcx.tcx));\n-\n-            suggest_new_overflow_limit(infcx.tcx, obligation.cause.span);\n-\n-            note_obligation_cause(infcx, obligation);\n-        }\n-\n         SelectionError::Unimplemented => {\n             match &obligation.cause.code {\n                 &ObligationCauseCode::CompareImplMethodObligation => {\n@@ -309,19 +323,21 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n-fn note_obligation_cause<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                   obligation: &PredicateObligation<'tcx>)\n+fn note_obligation_cause<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n+                                      obligation: &Obligation<'tcx, T>)\n+    where T: UserString<'tcx>\n {\n     note_obligation_cause_code(infcx,\n                                &obligation.predicate,\n                                obligation.cause.span,\n                                &obligation.cause.code);\n }\n \n-fn note_obligation_cause_code<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                        predicate: &ty::Predicate<'tcx>,\n-                                        cause_span: Span,\n-                                        cause_code: &ObligationCauseCode<'tcx>)\n+fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n+                                           predicate: &T,\n+                                           cause_span: Span,\n+                                           cause_code: &ObligationCauseCode<'tcx>)\n+    where T: UserString<'tcx>\n {\n     let tcx = infcx.tcx;\n     match *cause_code {"}, {"sha": "24b201c960f16ffe001b9914c2010b81170e4946", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 30, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -23,9 +23,10 @@ use std::slice::Iter;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n-use util::ppaux::{Repr, UserString};\n+use util::ppaux::Repr;\n \n pub use self::error_reporting::report_fulfillment_errors;\n+pub use self::error_reporting::report_overflow_error;\n pub use self::error_reporting::suggest_new_overflow_limit;\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n@@ -151,7 +152,6 @@ pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n #[derive(Clone,Debug)]\n pub enum SelectionError<'tcx> {\n     Unimplemented,\n-    Overflow,\n     OutputTypeParameterMismatch(ty::PolyTraitRef<'tcx>,\n                                 ty::PolyTraitRef<'tcx>,\n                                 ty::type_err<'tcx>),\n@@ -327,16 +327,9 @@ pub fn evaluate_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     let result = match fulfill_cx.select_all_or_error(infcx, typer) {\n         Ok(()) => Ok(Some(())), // Success, we know it implements Copy.\n         Err(errors) => {\n-            // Check if overflow occurred anywhere and propagate that.\n-            if errors.iter().any(\n-                |err| match err.code { CodeSelectionError(Overflow) => true, _ => false })\n-            {\n-                return Err(Overflow);\n-            }\n-\n-            // Otherwise, if there were any hard errors, propagate an\n-            // arbitrary one of those. If no hard errors at all,\n-            // report ambiguity.\n+            // If there were any hard errors, propagate an arbitrary\n+            // one of those. If no hard errors at all, report\n+            // ambiguity.\n             let sel_error =\n                 errors.iter()\n                       .filter_map(|err| {\n@@ -384,16 +377,8 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n             // soldering on, so just treat this like not implemented\n             false\n         }\n-        Err(Overflow) => {\n-            span_err!(infcx.tcx.sess, span, E0285,\n-                \"overflow evaluating whether `{}` is `{}`\",\n-                      ty.user_string(infcx.tcx),\n-                      bound.user_string(infcx.tcx));\n-            suggest_new_overflow_limit(infcx.tcx, span);\n-            false\n-        }\n         Err(_) => {\n-            // other errors: not implemented.\n+            // errors: not implemented.\n             false\n         }\n     }\n@@ -652,15 +637,6 @@ impl<'tcx> FulfillmentError<'tcx> {\n     {\n         FulfillmentError { obligation: obligation, code: code }\n     }\n-\n-    pub fn is_overflow(&self) -> bool {\n-        match self.code {\n-            CodeAmbiguity => false,\n-            CodeSelectionError(Overflow) => true,\n-            CodeSelectionError(_) => false,\n-            CodeProjectionError(_) => false,\n-        }\n-    }\n }\n \n impl<'tcx> TraitObligation<'tcx> {"}, {"sha": "92d54887308d645e1de0e11c96b388aca2721060", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -11,9 +11,9 @@\n //! Code for projecting associated types out of trait references.\n \n use super::elaborate_predicates;\n+use super::report_overflow_error;\n use super::Obligation;\n use super::ObligationCause;\n-use super::Overflow;\n use super::PredicateObligation;\n use super::SelectionContext;\n use super::SelectionError;\n@@ -442,7 +442,7 @@ fn project_type<'cx,'tcx>(\n     let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n     if obligation.recursion_depth >= recursion_limit {\n         debug!(\"project: overflow!\");\n-        return Err(ProjectionTyError::TraitSelectionError(Overflow));\n+        report_overflow_error(selcx.infcx(), &obligation);\n     }\n \n     let obligation_trait_ref =\n@@ -854,10 +854,10 @@ fn confirm_impl_candidate<'cx,'tcx>(\n     let impl_items_map = selcx.tcx().impl_items.borrow();\n     let impl_or_trait_items_map = selcx.tcx().impl_or_trait_items.borrow();\n \n-    let impl_items = &impl_items_map[impl_vtable.impl_def_id];\n+    let impl_items = impl_items_map.get(&impl_vtable.impl_def_id).unwrap();\n     let mut impl_ty = None;\n     for impl_item in impl_items {\n-        let assoc_type = match impl_or_trait_items_map[impl_item.def_id()] {\n+        let assoc_type = match *impl_or_trait_items_map.get(&impl_item.def_id()).unwrap() {\n             ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n             ty::MethodTraitItem(..) => { continue; }\n         };"}, {"sha": "9878661c9f69c414221e9378eab8ba2d69812592", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -21,8 +21,9 @@ use super::DerivedObligationCause;\n use super::project;\n use super::project::{normalize_with_depth, Normalized};\n use super::{PredicateObligation, TraitObligation, ObligationCause};\n+use super::{report_overflow_error};\n use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation};\n-use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n+use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n use super::{Selection};\n use super::{SelectionResult};\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure,\n@@ -561,10 +562,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // not update) the cache.\n         let recursion_limit = self.infcx.tcx.sess.recursion_limit.get();\n         if stack.obligation.recursion_depth >= recursion_limit {\n-            debug!(\"{} --> overflow (limit={})\",\n-                   stack.obligation.repr(self.tcx()),\n-                   recursion_limit);\n-            return Err(Overflow)\n+            report_overflow_error(self.infcx(), &stack.obligation);\n         }\n \n         // Check the cache. Note that we skolemize the trait-ref\n@@ -1762,7 +1760,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match obligations {\n             Ok(mut obls) => {\n-                obls.push_all(normalized.obligations.as_slice());\n+                obls.push_all(&normalized.obligations);\n                 obls\n             },\n             Err(ErrorReported) => Vec::new()\n@@ -2582,11 +2580,13 @@ impl<'o, 'tcx> Repr<'tcx> for TraitObligationStack<'o, 'tcx> {\n impl<'tcx> EvaluationResult<'tcx> {\n     fn may_apply(&self) -> bool {\n         match *self {\n-            EvaluatedToOk\n-            | EvaluatedToAmbig\n-            | EvaluatedToErr(Overflow)\n-            | EvaluatedToErr(OutputTypeParameterMismatch(..)) => true,\n-            EvaluatedToErr(Unimplemented) => false,\n+            EvaluatedToOk |\n+            EvaluatedToAmbig |\n+            EvaluatedToErr(OutputTypeParameterMismatch(..)) =>\n+                true,\n+\n+            EvaluatedToErr(Unimplemented) =>\n+                false,\n         }\n     }\n }"}, {"sha": "965aaf12044ec20692b20ca403d9234580c25a04", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -514,9 +514,6 @@ impl<'tcx> Repr<'tcx> for super::VtableObjectData<'tcx> {\n impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n-            super::Overflow =>\n-                format!(\"Overflow\"),\n-\n             super::Unimplemented =>\n                 format!(\"Unimplemented\"),\n "}, {"sha": "e5e89c3fbd4b9802ed729631f7ad8dbafec6195f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -52,6 +52,7 @@ use middle::mem_categorization as mc;\n use middle::region;\n use middle::resolve_lifetime;\n use middle::infer;\n+use middle::pat_util;\n use middle::stability;\n use middle::subst::{self, ParamSpace, Subst, Substs, VecPerParamSpace};\n use middle::traits;\n@@ -2667,22 +2668,30 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n-        self.closure_kinds.borrow()[def_id]\n+        *self.closure_kinds.borrow().get(&def_id).unwrap()\n     }\n \n     pub fn closure_type(&self,\n                         def_id: ast::DefId,\n                         substs: &subst::Substs<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n-        self.closure_tys.borrow()[def_id].subst(self, substs)\n+        self.closure_tys.borrow().get(&def_id).unwrap().subst(self, substs)\n     }\n \n     pub fn type_parameter_def(&self,\n                               node_id: ast::NodeId)\n                               -> TypeParameterDef<'tcx>\n     {\n-        self.ty_param_defs.borrow()[node_id].clone()\n+        self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n+    }\n+\n+    pub fn pat_contains_ref_binding(&self, pat: &ast::Pat) -> bool {\n+        pat_util::pat_contains_ref_binding(&self.def_map, pat)\n+    }\n+\n+    pub fn arm_contains_ref_binding(&self, arm: &ast::Arm) -> bool {\n+        pat_util::arm_contains_ref_binding(&self.def_map, arm)\n     }\n }\n \n@@ -5980,10 +5989,7 @@ pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n \n pub fn trait_has_default_impl(tcx: &ctxt, trait_def_id: DefId) -> bool {\n     populate_implementations_for_trait_if_necessary(tcx, trait_def_id);\n-    match tcx.lang_items.to_builtin_kind(trait_def_id) {\n-        Some(BoundSend) | Some(BoundSync) => true,\n-        _ => tcx.traits_with_default_impls.borrow().contains_key(&trait_def_id),\n-    }\n+    tcx.traits_with_default_impls.borrow().contains_key(&trait_def_id)\n }\n \n /// Records a trait-to-implementation mapping.\n@@ -6540,7 +6546,7 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n-        Some(self.upvar_capture_map.borrow()[upvar_id].clone())\n+        Some(self.upvar_capture_map.borrow().get(&upvar_id).unwrap().clone())\n     }\n }\n "}, {"sha": "a7c67a0863182e6af468f5e4ba104a01b3c5a50c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -907,7 +907,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let cg = build_codegen_options(matches);\n \n-    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| PathBuf::new(&m));\n+    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| PathBuf::from(&m));\n     let target = matches.opt_str(\"target\").unwrap_or(\n         host_triple().to_string());\n     let opt_level = {"}, {"sha": "3dc31f9524effe1e5b32668c7c7d707bbf9ce1fb", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -54,7 +54,7 @@ impl SearchPaths {\n         if path.is_empty() {\n             early_error(\"empty search path given via `-L`\");\n         }\n-        self.paths.push((kind, PathBuf::new(path)));\n+        self.paths.push((kind, PathBuf::from(path)));\n     }\n \n     pub fn iter(&self, kind: PathKind) -> Iter {"}, {"sha": "2cc51a723f2370c96a362fb87b2de0e83ecd18ed", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -319,7 +319,7 @@ impl<'a> ArchiveBuilder<'a> {\n             };\n             let new_filename = self.work_dir.path().join(&filename[..]);\n             try!(fs::rename(&file, &new_filename));\n-            self.members.push(PathBuf::new(&filename));\n+            self.members.push(PathBuf::from(filename));\n         }\n         Ok(())\n     }"}, {"sha": "6d8891dd4fe078f058ed3ed958ede8b891013147", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -19,7 +19,7 @@ use std::path::{Path, PathBuf};\n pub fn realpath(original: &Path) -> io::Result<PathBuf> {\n     let old = old_path::Path::new(original.to_str().unwrap());\n     match old_realpath(&old) {\n-        Ok(p) => Ok(PathBuf::new(p.as_str().unwrap())),\n+        Ok(p) => Ok(PathBuf::from(p.as_str().unwrap())),\n         Err(e) => Err(io::Error::new(io::ErrorKind::Other,\n                                      \"realpath error\",\n                                      Some(e.to_string())))"}, {"sha": "f7ee76c0a4397450ce8a258e67d51439bd90ac3f", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -36,7 +36,6 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(old_fs)]\n-#![feature(hash)]\n #![feature(int_uint)]\n #![feature(io)]\n #![feature(old_io)]\n@@ -47,8 +46,9 @@\n #![feature(rand)]\n #![feature(path_ext)]\n #![feature(std_misc)]\n-#![feature(path_relative_from)]\n #![feature(step_by)]\n+#![feature(convert)]\n+#![cfg_attr(test, feature(test, rand))]\n \n extern crate syntax;\n extern crate serialize;"}, {"sha": "ff3f0b78f91b317fae4c0485a0a835c796fdb8cf", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -99,30 +99,58 @@ fn get_rpath_relative_to_output(config: &mut RPathConfig, lib: &Path) -> String\n     lib.pop();\n     let mut output = (config.realpath)(&cwd.join(&config.out_filename)).unwrap();\n     output.pop();\n-    let relative = relativize(&lib, &output);\n+    let relative = path_relative_from(&lib, &output)\n+        .expect(&format!(\"couldn't create relative path from {:?} to {:?}\", output, lib));\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     format!(\"{}/{}\", prefix,\n             relative.to_str().expect(\"non-utf8 component in path\"))\n }\n \n-fn relativize(path: &Path, rel: &Path) -> PathBuf {\n-    let mut res = PathBuf::new(\"\");\n-    let mut cur = rel;\n-    while !path.starts_with(cur) {\n-        res.push(\"..\");\n-        match cur.parent() {\n-            Some(p) => cur = p,\n-            None => panic!(\"can't create relative paths across filesystems\"),\n+// This routine is adapted from the *old* Path's `path_relative_from`\n+// function, which works differently from the new `relative_from` function.\n+// In particular, this handles the case on unix where both paths are\n+// absolute but with only the root as the common directory.\n+fn path_relative_from(path: &Path, base: &Path) -> Option<PathBuf> {\n+    use std::path::Component;\n+\n+    if path.is_absolute() != base.is_absolute() {\n+        if path.is_absolute() {\n+            Some(PathBuf::from(path))\n+        } else {\n+            None\n         }\n+    } else {\n+        let mut ita = path.components();\n+        let mut itb = base.components();\n+        let mut comps: Vec<Component> = vec![];\n+        loop {\n+            match (ita.next(), itb.next()) {\n+                (None, None) => break,\n+                (Some(a), None) => {\n+                    comps.push(a);\n+                    comps.extend(ita.by_ref());\n+                    break;\n+                }\n+                (None, _) => comps.push(Component::ParentDir),\n+                (Some(a), Some(b)) if comps.is_empty() && a == b => (),\n+                (Some(a), Some(b)) if b == Component::CurDir => comps.push(a),\n+                (Some(_), Some(b)) if b == Component::ParentDir => return None,\n+                (Some(a), Some(_)) => {\n+                    comps.push(Component::ParentDir);\n+                    for _ in itb {\n+                        comps.push(Component::ParentDir);\n+                    }\n+                    comps.push(a);\n+                    comps.extend(ita.by_ref());\n+                    break;\n+                }\n+            }\n+        }\n+        Some(comps.iter().map(|c| c.as_os_str()).collect())\n     }\n-    match path.relative_from(cur) {\n-        Some(s) => { res.push(s); res }\n-        None => panic!(\"couldn't create relative path from {:?} to {:?}\",\n-                       rel, path),\n-    }\n-\n }\n \n+\n fn get_install_prefix_rpath(config: &mut RPathConfig) -> String {\n     let path = (config.get_install_prefix_lib_path)();\n     let path = env::current_dir().unwrap().join(&path);\n@@ -200,7 +228,7 @@ mod test {\n                 used_crates: Vec::new(),\n                 has_rpath: true,\n                 is_like_osx: true,\n-                out_filename: PathBuf::new(\"bin/rustc\"),\n+                out_filename: PathBuf::from(\"bin/rustc\"),\n                 get_install_prefix_lib_path: &mut || panic!(),\n                 realpath: &mut |p| Ok(p.to_path_buf()),\n             };\n@@ -210,7 +238,7 @@ mod test {\n         } else {\n             let config = &mut RPathConfig {\n                 used_crates: Vec::new(),\n-                out_filename: PathBuf::new(\"bin/rustc\"),\n+                out_filename: PathBuf::from(\"bin/rustc\"),\n                 get_install_prefix_lib_path: &mut || panic!(),\n                 has_rpath: true,\n                 is_like_osx: false,"}, {"sha": "c464658f447acd973d1568b93dca9285c59dd21b", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -393,11 +393,11 @@ impl Target {\n         let path = {\n             let mut target = target.to_string();\n             target.push_str(\".json\");\n-            PathBuf::new(&target)\n+            PathBuf::from(target)\n         };\n \n         let target_path = env::var_os(\"RUST_TARGET_PATH\")\n-                              .unwrap_or(OsString::from_str(\"\"));\n+                              .unwrap_or(OsString::new());\n \n         // FIXME 16351: add a sane default search path?\n "}, {"sha": "93a2a5d125778eeab36329aa661ec2dec366a926", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -18,6 +18,7 @@\n #![feature(no_std)]\n #![no_std]\n #![unstable(feature = \"rustc_private\")]\n+#![cfg_attr(test, feature(hash))]\n \n //! A typesafe bitmask flag generator.\n \n@@ -32,6 +33,7 @@\n /// # Examples\n ///\n /// ```{.rust}\n+/// # #![feature(rustc_private)]\n /// #[macro_use] extern crate rustc_bitflags;\n ///\n /// bitflags! {\n@@ -58,6 +60,7 @@\n /// The generated `struct`s can also be extended with type and trait implementations:\n ///\n /// ```{.rust}\n+/// # #![feature(rustc_private)]\n /// #[macro_use] extern crate rustc_bitflags;\n ///\n /// use std::fmt;"}, {"sha": "2834fce5278c85ab7b3caf36f3de0a47425e6a30", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -486,7 +486,7 @@ impl<'tcx> MoveData<'tcx> {\n             match path.loan_path.kind {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = path.loan_path.kill_scope(tcx);\n-                    let path = self.path_map.borrow()[path.loan_path];\n+                    let path = *self.path_map.borrow().get(&path.loan_path).unwrap();\n                     self.kill_moves(path, kill_scope.node_id(), dfcx_moves);\n                 }\n                 LpExtend(..) => {}"}, {"sha": "e927ea5b86cdd27bc3416ced57069c96bf3b5e22", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -28,6 +28,7 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(unsafe_destructor)]\n+#![feature(into_cow)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "4c654cbf27de05fd5bfecd79ba31d0b91a3a857e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -468,7 +468,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             // dependent dlls. Note that this uses cfg!(windows) as opposed to\n             // targ_cfg because syntax extensions are always loaded for the host\n             // compiler, not for the target.\n-            let mut _old_path = OsString::from_str(\"\");\n+            let mut _old_path = OsString::new();\n             if cfg!(windows) {\n                 _old_path = env::var_os(\"PATH\").unwrap_or(_old_path);\n                 let mut new_path = sess.host_filesearch(PathKind::All).get_dylib_search_paths();\n@@ -752,7 +752,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n pub fn phase_6_link_output(sess: &Session,\n                            trans: &trans::CrateTranslation,\n                            outputs: &OutputFilenames) {\n-    let old_path = env::var_os(\"PATH\").unwrap_or(OsString::from_str(\"\"));\n+    let old_path = env::var_os(\"PATH\").unwrap_or(OsString::new());\n     let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths();\n     new_path.extend(env::split_paths(&old_path));\n     env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n@@ -927,7 +927,7 @@ pub fn build_output_filenames(input: &Input,\n             // We want to toss everything after the final '.'\n             let dirpath = match *odir {\n                 Some(ref d) => d.clone(),\n-                None => PathBuf::new(\"\")\n+                None => PathBuf::new()\n             };\n \n             // If a crate name is present, we use it as the link name"}, {"sha": "5e6f2fb835bb2a01787ebf36f027bcf5e1a4ed58", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -39,6 +39,7 @@\n #![feature(io)]\n #![feature(set_stdio)]\n #![feature(unicode)]\n+#![feature(convert)]\n \n extern crate arena;\n extern crate flate;\n@@ -163,8 +164,8 @@ pub fn run_compiler<'a>(args: &[String],\n \n // Extract output directory and file from matches.\n fn make_output(matches: &getopts::Matches) -> (Option<PathBuf>, Option<PathBuf>) {\n-    let odir = matches.opt_str(\"out-dir\").map(|o| PathBuf::new(&o));\n-    let ofile = matches.opt_str(\"o\").map(|o| PathBuf::new(&o));\n+    let odir = matches.opt_str(\"out-dir\").map(|o| PathBuf::from(&o));\n+    let ofile = matches.opt_str(\"o\").map(|o| PathBuf::from(&o));\n     (odir, ofile)\n }\n \n@@ -177,7 +178,7 @@ fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>)> {\n             io::stdin().read_to_string(&mut src).unwrap();\n             Some((Input::Str(src), None))\n         } else {\n-            Some((Input::File(PathBuf::new(ifile)), Some(PathBuf::new(ifile))))\n+            Some((Input::File(PathBuf::from(ifile)), Some(PathBuf::from(ifile))))\n         }\n     } else {\n         None\n@@ -858,9 +859,9 @@ pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n     use syntax::diagnostics::registry::Registry;\n \n     let all_errors = Vec::new() +\n-        rustc::diagnostics::DIAGNOSTICS.as_slice() +\n-        rustc_typeck::diagnostics::DIAGNOSTICS.as_slice() +\n-        rustc_resolve::diagnostics::DIAGNOSTICS.as_slice();\n+        &rustc::diagnostics::DIAGNOSTICS[..] +\n+        &rustc_typeck::diagnostics::DIAGNOSTICS[..] +\n+        &rustc_resolve::diagnostics::DIAGNOSTICS[..];\n \n     Registry::new(&*all_errors)\n }"}, {"sha": "e65fe904dd29af28eb5e1a3e1dad8e836afde366", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -418,7 +418,7 @@ struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_def(&mut self, sp: Span, id: ast::NodeId) {\n-        match self.cx.tcx.def_map.borrow()[id].full_def() {\n+        match self.cx.tcx.def_map.borrow().get(&id).unwrap().full_def() {\n             def::DefPrimTy(ast::TyInt(ast::TyIs(_))) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                   \"found rust type `isize` in foreign module, while \\\n@@ -2056,15 +2056,15 @@ impl LintPass for InvalidNoMangleItems {\n                 }\n             },\n             ast::ItemStatic(..) => {\n-                if attr::contains_name(it.attrs.as_slice(), \"no_mangle\") &&\n+                if attr::contains_name(&it.attrs, \"no_mangle\") &&\n                        !cx.exported_items.contains(&it.id) {\n                     let msg = format!(\"static {} is marked #[no_mangle], but not exported\",\n                                       it.ident);\n                     cx.span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, &msg);\n                 }\n             },\n             ast::ItemConst(..) => {\n-                if attr::contains_name(it.attrs.as_slice(), \"no_mangle\") {\n+                if attr::contains_name(&it.attrs, \"no_mangle\") {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n                     let msg = \"const items should never be #[no_mangle], consider instead using \\"}, {"sha": "ef65acf8b13f4838d5f848de3e0051f86eb17aa0", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -40,7 +40,6 @@\n #![feature(rustc_private)]\n #![feature(unsafe_destructor)]\n #![feature(staged_api)]\n-#![feature(std_misc)]\n #![feature(str_char)]\n #![cfg_attr(test, feature(test))]\n "}, {"sha": "2e7fe91365a13475dabf5e99106be2e2b82421dd", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             ast::ItemImpl(_, _, _, _, ref ty, ref impl_items) => {\n                 let public_ty = match ty.node {\n                     ast::TyPath(..) => {\n-                        match self.tcx.def_map.borrow()[ty.id].full_def() {\n+                        match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n                             def::DefPrimTy(..) => true,\n                             def => {\n                                 let did = def.def_id();\n@@ -317,7 +317,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n \n             ast::ItemTy(ref ty, _) if public_first => {\n                 if let ast::TyPath(..) = ty.node {\n-                    match self.tcx.def_map.borrow()[ty.id].full_def() {\n+                    match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n                         def::DefPrimTy(..) | def::DefTyParam(..) => {},\n                         def => {\n                             let did = def.def_id();\n@@ -349,7 +349,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         // crate module gets processed as well.\n         if self.prev_exported {\n             assert!(self.export_map.contains_key(&id), \"wut {}\", id);\n-            for export in &self.export_map[id] {\n+            for export in self.export_map.get(&id).unwrap() {\n                 if is_local(export.def_id) {\n                     self.reexports.insert(export.def_id.node);\n                 }\n@@ -525,7 +525,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             // if we've reached the root, then everything was allowable and this\n             // access is public.\n             if closest_private_id == ast::CRATE_NODE_ID { return Allowable }\n-            closest_private_id = self.parents[closest_private_id];\n+            closest_private_id = *self.parents.get(&closest_private_id).unwrap();\n \n             // If we reached the top, then we were public all the way down and\n             // we can allow this access.\n@@ -543,7 +543,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     /// whether the node is accessible by the current module that iteration is\n     /// inside.\n     fn private_accessible(&self, id: ast::NodeId) -> bool {\n-        let parent = self.parents[id];\n+        let parent = *self.parents.get(&id).unwrap();\n         debug!(\"privacy - accessible parent {}\", self.nodestr(parent));\n \n         // After finding `did`'s closest private member, we roll ourselves back\n@@ -567,7 +567,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 _ => {}\n             }\n \n-            cur = self.parents[cur];\n+            cur = *self.parents.get(&cur).unwrap();\n         }\n     }\n \n@@ -622,7 +622,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             ast::TyPath(..) => {}\n                             _ => return Some((err_span, err_msg, None)),\n                         };\n-                        let def = self.tcx.def_map.borrow()[ty.id].full_def();\n+                        let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n                         let did = def.def_id();\n                         assert!(is_local(did));\n                         match self.tcx.map.get(did.node) {\n@@ -708,7 +708,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     // Checks that a path is in scope.\n     fn check_path(&mut self, span: Span, path_id: ast::NodeId, last: ast::Ident) {\n         debug!(\"privacy - path {}\", self.nodestr(path_id));\n-        let path_res = self.tcx.def_map.borrow()[path_id];\n+        let path_res = *self.tcx.def_map.borrow().get(&path_id).unwrap();\n         let ck = |tyname: &str| {\n             let ck_public = |def: ast::DefId| {\n                 debug!(\"privacy - ck_public {:?}\", def);\n@@ -881,7 +881,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.borrow()[expr.id].full_def() {\n+                        match self.tcx.def_map.borrow().get(&expr.id).unwrap().full_def() {\n                             def::DefVariant(_, variant_id, _) => {\n                                 for field in fields {\n                                     self.check_field(expr.span, variant_id,"}, {"sha": "bb7880161d5d4e364b2ebc7701468e64d3820a77", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -877,7 +877,7 @@ fn link_args(cmd: &mut Command,\n         if t.options.is_like_osx {\n             let morestack = lib_path.join(\"libmorestack.a\");\n \n-            let mut v = OsString::from_str(\"-Wl,-force_load,\");\n+            let mut v = OsString::from(\"-Wl,-force_load,\");\n             v.push(&morestack);\n             cmd.arg(&v);\n         } else {\n@@ -1002,7 +1002,7 @@ fn link_args(cmd: &mut Command,\n             cmd.args(&[\"-dynamiclib\", \"-Wl,-dylib\"]);\n \n             if sess.opts.cg.rpath {\n-                let mut v = OsString::from_str(\"-Wl,-install_name,@rpath/\");\n+                let mut v = OsString::from(\"-Wl,-install_name,@rpath/\");\n                 v.push(out_filename.file_name().unwrap());\n                 cmd.arg(&v);\n             }\n@@ -1020,7 +1020,7 @@ fn link_args(cmd: &mut Command,\n         let mut get_install_prefix_lib_path = || {\n             let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n             let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n-            let mut path = PathBuf::new(install_prefix);\n+            let mut path = PathBuf::from(install_prefix);\n             path.push(&tlib);\n \n             path\n@@ -1102,7 +1102,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n                                             &sess.target.target.options.staticlib_suffix,\n                                             &search_path[..],\n                                             &sess.diagnostic().handler);\n-            let mut v = OsString::from_str(\"-Wl,-force_load,\");\n+            let mut v = OsString::from(\"-Wl,-force_load,\");\n             v.push(&lib);\n             cmd.arg(&v);\n         }\n@@ -1141,9 +1141,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n     // involves just passing the right -l flag.\n \n     let data = if dylib {\n-        &trans.crate_formats[config::CrateTypeDylib]\n+        trans.crate_formats.get(&config::CrateTypeDylib).unwrap()\n     } else {\n-        &trans.crate_formats[config::CrateTypeExecutable]\n+        trans.crate_formats.get(&config::CrateTypeExecutable).unwrap()\n     };\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of"}, {"sha": "b9ec22b86f0769e5b4ebf25c6fdecee6e365f55f", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -40,7 +40,7 @@\n #![feature(unicode)]\n #![feature(path_ext)]\n #![feature(fs)]\n-#![feature(hash)]\n+#![feature(convert)]\n #![feature(path_relative_from)]\n \n extern crate arena;"}, {"sha": "53aa6d44fe7e86f014df2b7a65737af761883975", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -219,7 +219,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n                                   ref_id));\n         }\n-        let def = self.analysis.ty_cx.def_map.borrow()[ref_id].full_def();\n+        let def = self.analysis.ty_cx.def_map.borrow().get(&ref_id).unwrap().full_def();\n         match def {\n             def::DefPrimTy(_) => None,\n             _ => Some(def.def_id()),\n@@ -232,7 +232,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.span_bug(span, &format!(\"def_map has no key for {} in lookup_def_kind\",\n                                              ref_id));\n         }\n-        let def = def_map[ref_id].full_def();\n+        let def = def_map.get(&ref_id).unwrap().full_def();\n         match def {\n             def::DefMod(_) |\n             def::DefForeignMod(_) => Some(recorder::ModRef),\n@@ -269,8 +269,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.collecting = false;\n             let span_utils = self.span.clone();\n             for &(id, ref p, _, _) in &self.collected_paths {\n-                let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n-                    (*self.analysis.ty_cx.node_types.borrow())[id]);\n+                let typ =\n+                    ppaux::ty_to_string(\n+                        &self.analysis.ty_cx,\n+                        *self.analysis.ty_cx.node_types.borrow().get(&id).unwrap());\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 self.fmt.formal_str(p.span,\n@@ -431,8 +433,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             ast::NamedField(ident, _) => {\n                 let name = get_ident(ident);\n                 let qualname = format!(\"{}::{}\", qualname, name);\n-                let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n-                    (*self.analysis.ty_cx.node_types.borrow())[field.node.id]);\n+                let typ =\n+                    ppaux::ty_to_string(\n+                        &self.analysis.ty_cx,\n+                        *self.analysis.ty_cx.node_types.borrow().get(&field.node.id).unwrap());\n                 match self.span.sub_span_before_token(field.span, token::Colon) {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n@@ -789,7 +793,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.span_bug(span,\n                                &format!(\"def_map has no key for {} in visit_expr\", id));\n         }\n-        let def = def_map[id].full_def();\n+        let def = def_map.get(&id).unwrap().full_def();\n         let sub_span = self.span.span_for_last_ident(span);\n         match def {\n             def::DefUpvar(..) |\n@@ -832,7 +836,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                  .ty_cx\n                                                  .impl_items\n                                                  .borrow();\n-                            Some((*impl_items)[def_id]\n+                            Some(impl_items.get(&def_id)\n+                                           .unwrap()\n                                            .iter()\n                                            .find(|mr| {\n                                                 ty::impl_or_trait_item(\n@@ -941,7 +946,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                            ex: &ast::Expr,\n                            args: &Vec<P<ast::Expr>>) {\n         let method_map = self.analysis.ty_cx.method_map.borrow();\n-        let method_callee = &(*method_map)[ty::MethodCall::expr(ex.id)];\n+        let method_callee = method_map.get(&ty::MethodCall::expr(ex.id)).unwrap();\n         let (def_id, decl_id) = match method_callee.origin {\n             ty::MethodStatic(def_id) |\n             ty::MethodStaticClosure(def_id) => {\n@@ -1001,7 +1006,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 self.collected_paths.push((p.id, path.clone(), false, recorder::StructRef));\n                 visit::walk_path(self, path);\n \n-                let def = self.analysis.ty_cx.def_map.borrow()[p.id].full_def();\n+                let def = self.analysis.ty_cx.def_map.borrow().get(&p.id).unwrap().full_def();\n                 let struct_def = match def {\n                     def::DefConst(..) => None,\n                     def::DefVariant(_, variant_id, _) => Some(variant_id),\n@@ -1113,7 +1118,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                         let glob_map = &self.analysis.glob_map;\n                         let glob_map = glob_map.as_ref().unwrap();\n                         if glob_map.contains_key(&item.id) {\n-                            for n in &glob_map[item.id] {\n+                            for n in glob_map.get(&item.id).unwrap() {\n                                 if name_string.len() > 0 {\n                                     name_string.push_str(\", \");\n                                 }\n@@ -1406,7 +1411,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                    &format!(\"def_map has no key for {} in visit_arm\",\n                                            id));\n             }\n-            let def = def_map[id].full_def();\n+            let def = def_map.get(&id).unwrap().full_def();\n             match def {\n                 def::DefLocal(id)  => {\n                     let value = if *immut {\n@@ -1467,7 +1472,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         for &(id, ref p, ref immut, _) in &self.collected_paths {\n             let value = if *immut { value.to_string() } else { \"<mutable>\".to_string() };\n             let types = self.analysis.ty_cx.node_types.borrow();\n-            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, (*types)[id]);\n+            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, *types.get(&id).unwrap());\n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n             let sub_span = self.span.span_for_last_ident(p.span);\n@@ -1509,10 +1514,10 @@ pub fn process_crate(sess: &Session,\n \n     // find a path to dump our data to\n     let mut root_path = match env::var_os(\"DXR_RUST_TEMP_FOLDER\") {\n-        Some(val) => PathBuf::new(&val),\n+        Some(val) => PathBuf::from(val),\n         None => match odir {\n             Some(val) => val.join(\"dxr\"),\n-            None => PathBuf::new(\"dxr-temp\"),\n+            None => PathBuf::from(\"dxr-temp\"),\n         },\n     };\n "}, {"sha": "eb759393ac6eca125f2432641e792c9d37575c2d", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -1017,7 +1017,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         None => {\n             let data = &m[0].data;\n             for &(ref ident, ref value_ptr) in &m[0].bound_ptrs {\n-                let binfo = data.bindings_map[*ident];\n+                let binfo = *data.bindings_map.get(ident).unwrap();\n                 call_lifetime_start(bcx, binfo.llmatch);\n                 if binfo.trmode == TrByRef && type_is_fat_ptr(bcx.tcx(), binfo.ty) {\n                     expr::copy_fat_ptr(bcx, *value_ptr, binfo.llmatch);"}, {"sha": "d6c85e8b173459c5449a60a68dbccc6bdb6d7e99", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 25, "deletions": 47, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -76,43 +76,33 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     // no failure occurred preparing operands, no need to cleanup\n     fcx.pop_custom_cleanup_scope(temp_scope);\n \n-    let mut constraints = constraints.iter()\n-                                     .map(|s| s.to_string())\n-                                     .chain(ext_constraints.into_iter())\n-                                     .collect::<Vec<String>>()\n-                                     .connect(\",\");\n-\n-    let mut clobbers = ia.clobbers.iter()\n-                                  .map(|s| format!(\"~{{{}}}\", &s))\n-                                  .collect::<Vec<String>>()\n-                                  .connect(\",\");\n-    let more_clobbers = get_clobbers();\n-    if !more_clobbers.is_empty() {\n-        if !clobbers.is_empty() {\n-            clobbers.push(',');\n-        }\n-        clobbers.push_str(&more_clobbers[..]);\n-    }\n-\n-    // Add the clobbers to our constraints list\n-    if clobbers.len() != 0 && constraints.len() != 0 {\n-        constraints.push(',');\n-        constraints.push_str(&clobbers[..]);\n-    } else {\n-        constraints.push_str(&clobbers[..]);\n-    }\n+    let clobbers = ia.clobbers.iter()\n+                              .map(|s| format!(\"~{{{}}}\", &s));\n+\n+    // Default per-arch clobbers\n+    // Basically what clang does\n+    let arch_clobbers = match &bcx.sess().target.target.arch[..] {\n+        \"x86\" | \"x86_64\" => vec!(\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"),\n+        _                => Vec::new()\n+    };\n \n-    debug!(\"Asm Constraints: {}\", &constraints[..]);\n+    let all_constraints= constraints.iter()\n+                                    .map(|s| s.to_string())\n+                                    .chain(ext_constraints.into_iter())\n+                                    .chain(clobbers)\n+                                    .chain(arch_clobbers.iter()\n+                                               .map(|s| s.to_string()))\n+                                    .collect::<Vec<String>>()\n+                                    .connect(\",\");\n \n-    let num_outputs = outputs.len();\n+    debug!(\"Asm Constraints: {}\", &all_constraints[..]);\n \n     // Depending on how many outputs we have, the return type is different\n-    let output_type = if num_outputs == 0 {\n-        Type::void(bcx.ccx())\n-    } else if num_outputs == 1 {\n-        output_types[0]\n-    } else {\n-        Type::struct_(bcx.ccx(), &output_types[..], false)\n+    let num_outputs = outputs.len();\n+    let output_type = match num_outputs {\n+        0 => Type::void(bcx.ccx()),\n+        1 => output_types[0],\n+        _ => Type::struct_(bcx.ccx(), &output_types[..], false)\n     };\n \n     let dialect = match ia.dialect {\n@@ -121,10 +111,10 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     };\n \n     let asm = CString::new(ia.asm.as_bytes()).unwrap();\n-    let constraints = CString::new(constraints).unwrap();\n+    let constraint_cstr = CString::new(all_constraints).unwrap();\n     let r = InlineAsmCall(bcx,\n                           asm.as_ptr(),\n-                          constraints.as_ptr(),\n+                          constraint_cstr.as_ptr(),\n                           &inputs,\n                           output_type,\n                           ia.volatile,\n@@ -158,15 +148,3 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n \n }\n \n-// Default per-arch clobbers\n-// Basically what clang does\n-\n-#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-fn get_clobbers() -> String {\n-    \"\".to_string()\n-}\n-\n-#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn get_clobbers() -> String {\n-    \"~{dirflag},~{fpsr},~{flags}\".to_string()\n-}"}, {"sha": "2f944e49b15161dc6d6243d9aebed4eb49fdb95f", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 10, "deletions": 79, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -269,7 +269,7 @@ pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn kind_for_closure(ccx: &CrateContext, closure_id: ast::DefId) -> ty::ClosureKind {\n-    ccx.tcx().closure_kinds.borrow()[closure_id]\n+    *ccx.tcx().closure_kinds.borrow().get(&closure_id).unwrap()\n }\n \n pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -428,11 +428,6 @@ pub fn set_llvm_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: Val\n         let mut used = true;\n         match &attr.name()[..] {\n             \"no_stack_check\" => unset_split_stack(llfn),\n-            \"no_split_stack\" => {\n-                unset_split_stack(llfn);\n-                ccx.sess().span_warn(attr.span,\n-                                     \"no_split_stack is a deprecated synonym for no_stack_check\");\n-            }\n             \"cold\" => unsafe {\n                 llvm::LLVMAddFunctionAttribute(llfn,\n                                                llvm::FunctionIndex as c_uint,\n@@ -1591,55 +1586,6 @@ fn copy_args_to_allocas<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     bcx\n }\n \n-fn copy_closure_args_to_allocas<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                            arg_scope: cleanup::CustomScopeIndex,\n-                                            args: &[ast::Arg],\n-                                            arg_datums: Vec<RvalueDatum<'tcx>>,\n-                                            monomorphized_arg_types: &[Ty<'tcx>])\n-                                            -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"copy_closure_args_to_allocas\");\n-    let arg_scope_id = cleanup::CustomScope(arg_scope);\n-\n-    assert_eq!(arg_datums.len(), 1);\n-\n-    let arg_datum = arg_datums.into_iter().next().unwrap();\n-\n-    // Untuple the rest of the arguments.\n-    let tuple_datum =\n-        unpack_datum!(bcx,\n-                      arg_datum.to_lvalue_datum_in_scope(bcx,\n-                                                         \"argtuple\",\n-                                                         arg_scope_id));\n-    let untupled_arg_types = match monomorphized_arg_types[0].sty {\n-        ty::ty_tup(ref types) => &types[..],\n-        _ => {\n-            bcx.tcx().sess.span_bug(args[0].pat.span,\n-                                    \"first arg to `rust-call` ABI function \\\n-                                     wasn't a tuple?!\")\n-        }\n-    };\n-    for j in 0..args.len() {\n-        let tuple_element_type = untupled_arg_types[j];\n-        let tuple_element_datum =\n-            tuple_datum.get_element(bcx,\n-                                    tuple_element_type,\n-                                    |llval| GEPi(bcx, llval, &[0, j]));\n-        let tuple_element_datum = tuple_element_datum.to_expr_datum();\n-        let tuple_element_datum =\n-            unpack_datum!(bcx,\n-                          tuple_element_datum.to_rvalue_datum(bcx,\n-                                                              \"arg\"));\n-        bcx = _match::store_arg(bcx,\n-                                &*args[j].pat,\n-                                tuple_element_datum,\n-                                arg_scope_id);\n-\n-        debuginfo::create_argument_metadata(bcx, &args[j]);\n-    }\n-\n-    bcx\n-}\n-\n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n@@ -1797,33 +1743,18 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"trans_closure: function lltype: {}\",\n            bcx.fcx.ccx.tn().val_to_string(bcx.fcx.llfn));\n \n-    let arg_datums = if abi != RustCall {\n-        create_datums_for_fn_args(&fcx,\n-                                  &monomorphized_arg_types[..])\n-    } else {\n-        create_datums_for_fn_args_under_call_abi(\n-            bcx,\n-            arg_scope,\n-            &monomorphized_arg_types[..])\n-    };\n-\n-    bcx = match closure_env {\n-        closure::ClosureEnv::NotClosure => {\n-            copy_args_to_allocas(bcx,\n-                                 arg_scope,\n-                                 &decl.inputs,\n-                                 arg_datums)\n+    let arg_datums = match closure_env {\n+        closure::ClosureEnv::NotClosure if abi == RustCall => {\n+            create_datums_for_fn_args_under_call_abi(bcx, arg_scope, &monomorphized_arg_types[..])\n         }\n-        closure::ClosureEnv::Closure(_) => {\n-            copy_closure_args_to_allocas(\n-                bcx,\n-                arg_scope,\n-                &decl.inputs,\n-                arg_datums,\n-                &monomorphized_arg_types[..])\n+        _ => {\n+            let arg_tys = untuple_arguments_if_necessary(ccx, &monomorphized_arg_types, abi);\n+            create_datums_for_fn_args(&fcx, &arg_tys)\n         }\n     };\n \n+    bcx = copy_args_to_allocas(bcx, arg_scope, &decl.inputs, arg_datums);\n+\n     bcx = closure_env.load(bcx, cleanup::CustomScope(arg_scope));\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with\n@@ -2322,7 +2253,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                                          static\");\n               }\n \n-              let v = ccx.static_values().borrow()[item.id].clone();\n+              let v = ccx.static_values().borrow().get(&item.id).unwrap().clone();\n               unsafe {\n                   if !(llvm::LLVMConstIntGetZExtValue(v) != 0) {\n                       ccx.sess().span_fatal(expr.span, \"static assertion failed\");"}, {"sha": "088a34857e753a8991be403b55d93da17de960b4", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -511,7 +511,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n             let ref_ty = match node {\n                 ExprId(id) => ty::node_id_to_type(tcx, id),\n                 MethodCallKey(method_call) => {\n-                    (*tcx.method_map.borrow())[method_call].ty\n+                    tcx.method_map.borrow().get(&method_call).unwrap().ty\n                 }\n             };\n             let ref_ty = monomorphize::apply_param_substs(tcx,"}, {"sha": "61cdde3bfbecd775a24346f063341a12e8bff644", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -709,7 +709,7 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     }\n \n     fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n-        Some(self.tcx().upvar_capture_map.borrow()[upvar_id].clone())\n+        Some(self.tcx().upvar_capture_map.borrow().get(&upvar_id).unwrap().clone())\n     }\n \n     fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n@@ -1025,8 +1025,9 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // shallow result we are looking for -- that is, what specific impl.\n     let typer = NormalizingClosureTyper::new(tcx);\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n-    let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n-                                             trait_ref.to_poly_trait_predicate());\n+    let obligation =\n+        traits::Obligation::new(traits::ObligationCause::misc(span, ast::DUMMY_NODE_ID),\n+                                trait_ref.to_poly_trait_predicate());\n     let selection = match selcx.select(&obligation) {\n         Ok(Some(selection)) => selection,\n         Ok(None) => {\n@@ -1081,7 +1082,7 @@ pub fn predicates_hold<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(), predicate);\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }\n-    drain_fulfillment_cx(DUMMY_SP, &infcx, &mut fulfill_cx, &()).is_ok()\n+    drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()).is_ok()\n }\n \n pub struct NormalizingClosureTyper<'a,'tcx:'a> {\n@@ -1138,7 +1139,7 @@ pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n                                                 -> T\n     where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n-    match drain_fulfillment_cx(span, infcx, fulfill_cx, result) {\n+    match drain_fulfillment_cx(infcx, fulfill_cx, result) {\n         Ok(v) => v,\n         Err(errors) => {\n             infcx.tcx.sess.span_bug(\n@@ -1156,8 +1157,7 @@ pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n /// inference variables that appear in `result` to be unified, and\n /// hence we need to process those obligations to get the complete\n /// picture of the type.\n-pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n-                                       infcx: &infer::InferCtxt<'a,'tcx>,\n+pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &infer::InferCtxt<'a,'tcx>,\n                                        fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n                                        result: &T)\n                                        -> StdResult<T,Vec<traits::FulfillmentError<'tcx>>>\n@@ -1173,14 +1173,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n     match fulfill_cx.select_all_or_error(infcx, &typer) {\n         Ok(()) => { }\n         Err(errors) => {\n-            // We always want to surface any overflow errors, no matter what.\n-            if errors.iter().all(|e| e.is_overflow()) {\n-                infcx.tcx.sess.span_fatal(\n-                    span,\n-                    \"reached the recursion limit during monomorphization\");\n-            } else {\n-                return Err(errors);\n-            }\n+            return Err(errors);\n         }\n     }\n \n@@ -1213,7 +1206,7 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             ty::node_id_item_substs(tcx, id).substs\n         }\n         MethodCallKey(method_call) => {\n-            (*tcx.method_map.borrow())[method_call].substs.clone()\n+            tcx.method_map.borrow().get(&method_call).unwrap().substs.clone()\n         }\n     };\n "}, {"sha": "4b1a03e47e7aebb1f2ef30bf261659b61204e2b4", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -187,7 +187,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Special-case constants to cache a common global for all uses.\n     match expr.node {\n         ast::ExprPath(..) => {\n-            let def = ccx.tcx().def_map.borrow()[expr.id].full_def();\n+            let def = ccx.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n             match def {\n                 def::DefConst(def_id) => {\n                     if !ccx.tcx().adjustments.borrow().contains_key(&expr.id) {\n@@ -665,7 +665,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n           }\n           ast::ExprPath(..) => {\n-            let def = cx.tcx().def_map.borrow()[e.id].full_def();\n+            let def = cx.tcx().def_map.borrow().get(&e.id).unwrap().full_def();\n             match def {\n                 def::DefFn(..) | def::DefMethod(..) => {\n                     expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n@@ -751,7 +751,7 @@ pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n-        let v = ccx.static_values().borrow()[id].clone();\n+        let v = ccx.static_values().borrow().get(&id).unwrap().clone();\n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n         let v = if llvm::LLVMTypeOf(v) == Type::i1(ccx).to_ref() {"}, {"sha": "b9c59a0bc78d671f59e3b8a13b74a8b4612f9931", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -1695,7 +1695,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     let name = CString::new(name.as_bytes()).unwrap();\n-    match (variable_access, [].as_slice()) {\n+    match (variable_access, &[][..]) {\n         (DirectVariable { alloca }, address_operations) |\n         (IndirectVariable {alloca, address_operations}, _) => {\n             let metadata = unsafe {"}, {"sha": "ceb9a29efa8879a9d30ad4544d812c579e87f97f", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -126,7 +126,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         return datum.store_to_dest(bcx, dest, expr.id);\n     }\n \n-    let qualif = bcx.tcx().const_qualif_map.borrow()[expr.id];\n+    let qualif = *bcx.tcx().const_qualif_map.borrow().get(&expr.id).unwrap();\n     if !qualif.intersects(check_const::NOT_CONST | check_const::NEEDS_DROP) {\n         if !qualif.intersects(check_const::PREFER_IN_PLACE) {\n             if let SaveIn(lldest) = dest {\n@@ -209,7 +209,7 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let mut bcx = bcx;\n     let fcx = bcx.fcx;\n-    let qualif = bcx.tcx().const_qualif_map.borrow()[expr.id];\n+    let qualif = *bcx.tcx().const_qualif_map.borrow().get(&expr.id).unwrap();\n     let adjusted_global = !qualif.intersects(check_const::NON_STATIC_BORROWS);\n     let global = if !qualif.intersects(check_const::NOT_CONST | check_const::NEEDS_DROP) {\n         let global = consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n@@ -843,7 +843,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                base_datum,\n                                                vec![(ix_datum, idx.id)],\n                                                Some(SaveIn(scratch.val)),\n-                                               true));\n+                                               false));\n             let datum = scratch.to_expr_datum();\n             if type_is_sized(bcx.tcx(), elt_ty) {\n                 Datum::new(datum.to_llscalarish(bcx), elt_ty, LvalueExpr)\n@@ -1405,7 +1405,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                         ty.repr(tcx)));\n                 }\n                 Some(node_id) => {\n-                    let def = tcx.def_map.borrow()[node_id].full_def();\n+                    let def = tcx.def_map.borrow().get(&node_id).unwrap().full_def();\n                     match def {\n                         def::DefVariant(enum_id, variant_id, _) => {\n                             let variant_info = ty::enum_variant_with_id(tcx, enum_id, variant_id);\n@@ -1964,7 +1964,7 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    dest: Option<Dest>,\n                                    autoref: bool)\n                                    -> Result<'blk, 'tcx> {\n-    let method_ty = (*bcx.tcx().method_map.borrow())[method_call].ty;\n+    let method_ty = bcx.tcx().method_map.borrow().get(&method_call).unwrap().ty;\n     callee::trans_call_inner(bcx,\n                              expr.debug_loc(),\n                              monomorphize_type(bcx, method_ty),\n@@ -1985,10 +1985,12 @@ fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                          dest: Option<Dest>)\n                                          -> Block<'blk, 'tcx> {\n     let method_call = MethodCall::expr(expr.id);\n-    let method_type = (*bcx.tcx()\n-                           .method_map\n-                           .borrow())[method_call]\n-                           .ty;\n+    let method_type = bcx.tcx()\n+                         .method_map\n+                         .borrow()\n+                         .get(&method_call)\n+                         .unwrap()\n+                         .ty;\n     let mut all_args = vec!(callee);\n     all_args.extend(args.iter().map(|e| &**e));\n     unpack_result!(bcx,"}, {"sha": "f714c5800c57b3717f5fb2532413b7e5159f17a3", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -386,7 +386,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             InBoundsGEP(bcx, ptr, &[offset])\n         }\n \n-        (_, \"copy_nonoverlapping_memory\") => {\n+        (_, \"copy_nonoverlapping\") => {\n             copy_intrinsic(bcx,\n                            false,\n                            false,\n@@ -396,7 +396,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                            llargs[2],\n                            call_debug_location)\n         }\n-        (_, \"copy_memory\") => {\n+        (_, \"copy\") => {\n             copy_intrinsic(bcx,\n                            true,\n                            false,\n@@ -406,7 +406,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                            llargs[2],\n                            call_debug_location)\n         }\n-        (_, \"set_memory\") => {\n+        (_, \"write_bytes\") => {\n             memset_intrinsic(bcx,\n                              false,\n                              *substs.types.get(FnSpace, 0),"}, {"sha": "71900855266e9f4e7fc1b411d13cd65909460e11", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -1046,7 +1046,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         return (tcx.types.err, ty_path_def);\n     };\n \n-    let ty_param_name = tcx.ty_param_defs.borrow()[ty_param_node_id].name;\n+    let ty_param_name = tcx.ty_param_defs.borrow().get(&ty_param_node_id).unwrap().name;\n \n     let bounds = match this.get_type_parameter_bounds(span, ty_param_node_id) {\n         Ok(v) => v,"}, {"sha": "e8da19efa06afd790bb966de830e877e5f9e498f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -119,7 +119,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n         ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n-            let const_did = tcx.def_map.borrow()[pat.id].def_id();\n+            let const_did = tcx.def_map.borrow().get(&pat.id).unwrap().def_id();\n             let const_scheme = ty::lookup_item_type(tcx, const_did);\n             assert!(const_scheme.generics.is_empty());\n             let const_ty = pcx.fcx.instantiate_type_scheme(pat.span,\n@@ -163,7 +163,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             // if there are multiple arms, make sure they all agree on\n             // what the type of the binding `x` ought to be\n-            let canon_id = pcx.map[path.node];\n+            let canon_id = *pcx.map.get(&path.node).unwrap();\n             if canon_id != pat.id {\n                 let ct = fcx.local_ty(pat.span, canon_id);\n                 demand::eqtype(fcx, pat.span, ct, typ);\n@@ -287,10 +287,11 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     // (nmatsakis) an hour or two debugging to remember, so I thought\n     // I'd write them down this time.\n     //\n-    // 1. Most importantly, there is no loss of expressiveness\n-    // here. What we are saying is that the type of `x`\n-    // becomes *exactly* what is expected. This might seem\n-    // like it will cause errors in a case like this:\n+    // 1. There is no loss of expressiveness here, though it does\n+    // cause some inconvenience. What we are saying is that the type\n+    // of `x` becomes *exactly* what is expected. This can cause unnecessary\n+    // errors in some cases, such as this one:\n+    // it will cause errors in a case like this:\n     //\n     // ```\n     // fn foo<'x>(x: &'x int) {\n@@ -361,8 +362,21 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              match_src: ast::MatchSource) {\n     let tcx = fcx.ccx.tcx;\n \n-    let discrim_ty = fcx.infcx().next_ty_var();\n-    check_expr_has_type(fcx, discrim, discrim_ty);\n+    // Not entirely obvious: if matches may create ref bindings, we\n+    // want to use the *precise* type of the discriminant, *not* some\n+    // supertype, as the \"discriminant type\" (issue #23116).\n+    let contains_ref_bindings = arms.iter().any(|a| tcx.arm_contains_ref_binding(a));\n+    let discrim_ty;\n+    if contains_ref_bindings {\n+        check_expr(fcx, discrim);\n+        discrim_ty = fcx.expr_ty(discrim);\n+    } else {\n+        // ...but otherwise we want to use any supertype of the\n+        // discriminant. This is sort of a workaround, see note (*) in\n+        // `check_pat` for some details.\n+        discrim_ty = fcx.infcx().next_ty_var();\n+        check_expr_has_type(fcx, discrim, discrim_ty);\n+    };\n \n     // Typecheck the patterns first, so that we get types for all the\n     // bindings.\n@@ -449,7 +463,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow()[pat.id].full_def();\n+    let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n     let (enum_def_id, variant_def_id) = match def {\n         def::DefTrait(_) => {\n             let name = pprust::path_to_string(path);\n@@ -518,7 +532,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow()[pat.id].full_def();\n+    let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n     let enum_def = def.variant_def_ids()\n         .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n "}, {"sha": "f731507ba906dbeb7f0af6bfbc8bf6ea17ac875b", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -92,6 +92,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         Ok(None) // No coercion required.\n     }\n \n+    fn outlives(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ()> {\n+        let sub = Sub(self.fcx.infcx().combine_fields(false, self.trace.clone()));\n+        try!(sub.regions(b, a));\n+        Ok(())\n+    }\n+\n     fn unpack_actual_value<T, F>(&self, a: Ty<'tcx>, f: F) -> T where\n         F: FnOnce(Ty<'tcx>) -> T,\n     {\n@@ -340,21 +346,40 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     Some((ty, ty::UnsizeLength(len)))\n                 }\n                 (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n-                    // For now, we only support upcasts from\n-                    // `Foo+Send` to `Foo` (really, any time there are\n-                    // fewer builtin bounds then before). These are\n-                    // convenient because they don't require any sort\n-                    // of change to the vtable at runtime.\n-                    if data_a.bounds.builtin_bounds != data_b.bounds.builtin_bounds &&\n-                        data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds)\n-                    {\n+                    // Upcasts permit two things:\n+                    //\n+                    // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n+                    // 2. Tightening the region bound, e.g. `Foo+'a` to `Foo+'b` if `'a : 'b`\n+                    //\n+                    // Note that neither of these changes requires any\n+                    // change at runtime.  Eventually this will be\n+                    // generalized.\n+                    //\n+                    // We always upcast when we can because of reason\n+                    // #2 (region bounds).\n+                    if data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds) {\n+                        // construct a type `a1` which is a version of\n+                        // `a` using the upcast bounds from `b`\n                         let bounds_a1 = ty::ExistentialBounds {\n-                            region_bound: data_a.bounds.region_bound,\n+                            // From type b\n+                            region_bound: data_b.bounds.region_bound,\n                             builtin_bounds: data_b.bounds.builtin_bounds,\n+\n+                            // From type a\n                             projection_bounds: data_a.bounds.projection_bounds.clone(),\n                         };\n                         let ty_a1 = ty::mk_trait(tcx, data_a.principal.clone(), bounds_a1);\n-                        match self.fcx.infcx().try(|_| self.subtype(ty_a1, ty_b)) {\n+\n+                        // relate `a1` to `b`\n+                        let result = self.fcx.infcx().try(|_| {\n+                            // it's ok to upcast from Foo+'a to Foo+'b so long as 'a : 'b\n+                            try!(self.outlives(data_a.bounds.region_bound,\n+                                               data_b.bounds.region_bound));\n+                            self.subtype(ty_a1, ty_b)\n+                        });\n+\n+                        // if that was successful, we have a coercion\n+                        match result {\n                             Ok(_) => Some((ty_b, ty::UnsizeUpcast(ty_b))),\n                             Err(_) => None,\n                         }"}, {"sha": "c3f4937d26b045d9e788bfee33102aaebc456f41", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -368,7 +368,7 @@ impl<'a, 'tcx> ty::ClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n                     substs: &subst::Substs<'tcx>)\n                     -> ty::ClosureTy<'tcx>\n     {\n-        self.inh.closure_tys.borrow()[def_id].subst(self.tcx(), substs)\n+        self.inh.closure_tys.borrow().get(&def_id).unwrap().subst(self.tcx(), substs)\n     }\n \n     fn closure_upvars(&self,\n@@ -549,7 +549,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n         debug!(\"Local variable {} is assigned type {}\",\n                self.fcx.pat_to_string(&*local.pat),\n                self.fcx.infcx().ty_to_string(\n-                   self.fcx.inh.locals.borrow()[local.id].clone()));\n+                   self.fcx.inh.locals.borrow().get(&local.id).unwrap().clone()));\n         visit::walk_local(self, local);\n     }\n \n@@ -565,7 +565,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                 debug!(\"Pattern binding {} is assigned to {} with type {}\",\n                        token::get_ident(path1.node),\n                        self.fcx.infcx().ty_to_string(\n-                           self.fcx.inh.locals.borrow()[p.id].clone()),\n+                           self.fcx.inh.locals.borrow().get(&p.id).unwrap().clone()),\n                        var_ty.repr(self.fcx.tcx()));\n             }\n         }\n@@ -3327,7 +3327,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 let mut missing_fields = Vec::new();\n                 for class_field in field_types {\n                     let name = class_field.name;\n-                    let (_, seen) = class_field_map[name];\n+                    let (_, seen) = *class_field_map.get(&name).unwrap();\n                     if !seen {\n                         missing_fields.push(\n                             format!(\"`{}`\", &token::get_name(name)))\n@@ -4242,11 +4242,27 @@ impl<'tcx> Repr<'tcx> for Expectation<'tcx> {\n }\n \n pub fn check_decl_initializer<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                                       nid: ast::NodeId,\n+                                       local: &'tcx ast::Local,\n                                        init: &'tcx ast::Expr)\n {\n-    let local_ty = fcx.local_ty(init.span, nid);\n-    check_expr_coercable_to_type(fcx, init, local_ty)\n+    let ref_bindings = fcx.tcx().pat_contains_ref_binding(&local.pat);\n+\n+    let local_ty = fcx.local_ty(init.span, local.id);\n+    if !ref_bindings {\n+        check_expr_coercable_to_type(fcx, init, local_ty)\n+    } else {\n+        // Somewhat subtle: if we have a `ref` binding in the pattern,\n+        // we want to avoid introducing coercions for the RHS. This is\n+        // both because it helps preserve sanity and, in the case of\n+        // ref mut, for soundness (issue #23116). In particular, in\n+        // the latter case, we need to be clear that the type of the\n+        // referent for the reference that results is *equal to* the\n+        // type of the lvalue it is referencing, and not some\n+        // supertype thereof.\n+        check_expr(fcx, init);\n+        let init_ty = fcx.expr_ty(init);\n+        demand::eqtype(fcx, init.span, init_ty, local_ty);\n+    };\n }\n \n pub fn check_decl_local<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, local: &'tcx ast::Local)  {\n@@ -4256,7 +4272,7 @@ pub fn check_decl_local<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, local: &'tcx ast::Local)\n     fcx.write_ty(local.id, t);\n \n     if let Some(ref init) = local.init {\n-        check_decl_initializer(fcx, local.id, &**init);\n+        check_decl_initializer(fcx, local, &**init);\n         let init_ty = fcx.expr_ty(&**init);\n         if ty::type_is_error(init_ty) {\n             fcx.write_ty(local.id, init_ty);\n@@ -4428,7 +4444,7 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let inh = static_inherited_fields(ccx);\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n-    let declty = (*fcx.ccx.tcx.tcache.borrow())[local_def(id)].ty;\n+    let declty = fcx.ccx.tcx.tcache.borrow().get(&local_def(id)).unwrap().ty;\n     check_const_with_ty(&fcx, sp, e, declty);\n }\n \n@@ -5365,7 +5381,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                    mutbl: ast::MutImmutable\n                }))\n             }\n-            \"copy_memory\" | \"copy_nonoverlapping_memory\" |\n+            \"copy\" | \"copy_nonoverlapping\" |\n             \"volatile_copy_memory\" | \"volatile_copy_nonoverlapping_memory\" => {\n               (1,\n                vec!(\n@@ -5381,7 +5397,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                ),\n                ty::mk_nil(tcx))\n             }\n-            \"set_memory\" | \"volatile_set_memory\" => {\n+            \"write_bytes\" | \"volatile_set_memory\" => {\n               (1,\n                vec!(\n                   ty::mk_ptr(tcx, ty::mt {"}, {"sha": "340cca7d47e7a395619bb5ae60ce9d1724e800a6", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -448,7 +448,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n \n         let closure_def_id = ast_util::local_def(closure_id);\n         let mut closure_kinds = self.fcx.inh.closure_kinds.borrow_mut();\n-        let existing_kind = closure_kinds[closure_def_id];\n+        let existing_kind = *closure_kinds.get(&closure_def_id).unwrap();\n \n         debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\",\n                closure_id, existing_kind, new_kind);"}, {"sha": "ffd99ff2eece081f7390195ea24506fe83ebb302", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n     fn get_self_type_for_implementation(&self, impl_did: DefId)\n                                         -> TypeScheme<'tcx> {\n-        self.crate_context.tcx.tcache.borrow()[impl_did].clone()\n+        self.crate_context.tcx.tcache.borrow().get(&impl_did).unwrap().clone()\n     }\n \n     // Converts an implementation in the AST to a vector of items.\n@@ -387,7 +387,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         };\n \n         for &impl_did in &*trait_impls.borrow() {\n-            let items = &(*impl_items)[impl_did];\n+            let items = impl_items.get(&impl_did).unwrap();\n             if items.len() < 1 {\n                 // We'll error out later. For now, just don't ICE.\n                 continue;"}, {"sha": "e4926b119d5dbe551808b3e8bb2db99d0afd7d12", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 52, "deletions": 41, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -27,55 +27,66 @@ struct UnsafetyChecker<'cx, 'tcx:'cx> {\n     tcx: &'cx ty::ctxt<'tcx>\n }\n \n-impl<'cx, 'tcx,'v> visit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n-    fn visit_item(&mut self, item: &'v ast::Item) {\n-        match item.node {\n-            ast::ItemImpl(unsafety, polarity, _, _, _, _) => {\n-                match ty::impl_trait_ref(self.tcx, ast_util::local_def(item.id)) {\n-                    None => {\n-                        // Inherent impl.\n-                        match unsafety {\n-                            ast::Unsafety::Normal => { /* OK */ }\n-                            ast::Unsafety::Unsafe => {\n-                                span_err!(self.tcx.sess, item.span, E0197,\n-                                    \"inherent impls cannot be declared as unsafe\");\n-                            }\n-                        }\n+impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n+    fn check_unsafety_coherence(&mut self, item: &'v ast::Item,\n+                                unsafety: ast::Unsafety,\n+                                polarity: ast::ImplPolarity) {\n+        match ty::impl_trait_ref(self.tcx, ast_util::local_def(item.id)) {\n+            None => {\n+                // Inherent impl.\n+                match unsafety {\n+                    ast::Unsafety::Normal => { /* OK */ }\n+                    ast::Unsafety::Unsafe => {\n+                        span_err!(self.tcx.sess, item.span, E0197,\n+                                  \"inherent impls cannot be declared as unsafe\");\n                     }\n+                }\n+            }\n \n-                    Some(trait_ref) => {\n-                        let trait_def = ty::lookup_trait_def(self.tcx, trait_ref.def_id);\n-                        match (trait_def.unsafety, unsafety, polarity) {\n-                            (ast::Unsafety::Unsafe,\n-                             ast::Unsafety::Unsafe, ast::ImplPolarity::Negative) => {\n-                                span_err!(self.tcx.sess, item.span, E0198,\n-                                    \"negative implementations are not unsafe\");\n-                            }\n+            Some(trait_ref) => {\n+                let trait_def = ty::lookup_trait_def(self.tcx, trait_ref.def_id);\n+                match (trait_def.unsafety, unsafety, polarity) {\n+                    (ast::Unsafety::Unsafe,\n+                     ast::Unsafety::Unsafe, ast::ImplPolarity::Negative) => {\n+                        span_err!(self.tcx.sess, item.span, E0198,\n+                                  \"negative implementations are not unsafe\");\n+                    }\n \n-                            (ast::Unsafety::Normal, ast::Unsafety::Unsafe, _) => {\n-                                span_err!(self.tcx.sess, item.span, E0199,\n-                                    \"implementing the trait `{}` is not unsafe\",\n-                                            trait_ref.user_string(self.tcx));\n-                            }\n+                    (ast::Unsafety::Normal, ast::Unsafety::Unsafe, _) => {\n+                        span_err!(self.tcx.sess, item.span, E0199,\n+                                  \"implementing the trait `{}` is not unsafe\",\n+                                  trait_ref.user_string(self.tcx));\n+                    }\n \n-                            (ast::Unsafety::Unsafe,\n-                             ast::Unsafety::Normal, ast::ImplPolarity::Positive) => {\n-                                span_err!(self.tcx.sess, item.span, E0200,\n-                                    \"the trait `{}` requires an `unsafe impl` declaration\",\n-                                            trait_ref.user_string(self.tcx));\n-                            }\n+                    (ast::Unsafety::Unsafe,\n+                     ast::Unsafety::Normal, ast::ImplPolarity::Positive) => {\n+                        span_err!(self.tcx.sess, item.span, E0200,\n+                                  \"the trait `{}` requires an `unsafe impl` declaration\",\n+                                  trait_ref.user_string(self.tcx));\n+                    }\n \n-                            (ast::Unsafety::Unsafe,\n-                             ast::Unsafety::Normal, ast::ImplPolarity::Negative) |\n-                            (ast::Unsafety::Unsafe,\n-                             ast::Unsafety::Unsafe, ast::ImplPolarity::Positive) |\n-                            (ast::Unsafety::Normal, ast::Unsafety::Normal, _) => {\n-                                /* OK */\n-                            }\n-                        }\n+                    (ast::Unsafety::Unsafe,\n+                     ast::Unsafety::Normal, ast::ImplPolarity::Negative) |\n+                    (ast::Unsafety::Unsafe,\n+                     ast::Unsafety::Unsafe, ast::ImplPolarity::Positive) |\n+                    (ast::Unsafety::Normal, ast::Unsafety::Normal, _) => {\n+                        /* OK */\n                     }\n                 }\n             }\n+        }\n+    }\n+}\n+\n+impl<'cx, 'tcx,'v> visit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n+    fn visit_item(&mut self, item: &'v ast::Item) {\n+        match item.node {\n+            ast::ItemDefaultImpl(unsafety, _) => {\n+                self.check_unsafety_coherence(item, unsafety, ast::ImplPolarity::Positive);\n+            }\n+            ast::ItemImpl(unsafety, polarity, _, _, _, _) => {\n+                self.check_unsafety_coherence(item, unsafety, polarity);\n+            }\n             _ => { }\n         }\n "}, {"sha": "5efc26825eab19ef63b9c939aa5ee9c2ad588980", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -194,7 +194,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n \n     fn method_ty(&self, method_id: ast::NodeId) -> Rc<ty::Method<'tcx>> {\n         let def_id = local_def(method_id);\n-        match self.tcx.impl_or_trait_items.borrow()[def_id] {\n+        match *self.tcx.impl_or_trait_items.borrow().get(&def_id).unwrap() {\n             ty::MethodTraitItem(ref mty) => mty.clone(),\n             ty::TypeTraitItem(..) => {\n                 self.tcx.sess.bug(&format!(\"method with id {} has the wrong type\", method_id));\n@@ -545,7 +545,7 @@ fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,\n                   -> bool\n {\n     if let ast::TyPath(None, _) = ast_ty.node {\n-        let path_res = tcx.def_map.borrow()[ast_ty.id];\n+        let path_res = *tcx.def_map.borrow().get(&ast_ty.id).unwrap();\n         match path_res.base_def {\n             def::DefSelfTy(node_id) =>\n                 path_res.depth == 0 && node_id == param_id,\n@@ -690,7 +690,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+fn as_refsociated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      container: ImplOrTraitItemContainer,\n                                      ident: ast::Ident,\n                                      id: ast::NodeId,\n@@ -835,7 +835,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                               \"associated items are not allowed in inherent impls\");\n                         }\n \n-                        convert_associated_type(ccx, ImplContainer(local_def(it.id)),\n+                        as_refsociated_type(ccx, ImplContainer(local_def(it.id)),\n                                                 impl_item.ident, impl_item.id, impl_item.vis);\n \n                         let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n@@ -917,7 +917,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 match trait_item.node {\n                     ast::MethodTraitItem(..) => {}\n                     ast::TypeTraitItem(..) => {\n-                        convert_associated_type(ccx, TraitContainer(local_def(it.id)),\n+                        as_refsociated_type(ccx, TraitContainer(local_def(it.id)),\n                                                 trait_item.ident, trait_item.id, ast::Public);\n                     }\n                 }\n@@ -1040,9 +1040,13 @@ fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n             } else if struct_def.fields[0].node.kind.is_unnamed() {\n                 // Tuple-like.\n-                let inputs: Vec<_> = struct_def.fields.iter().map(\n-                        |field| (*tcx.tcache.borrow())[\n-                            local_def(field.node.id)].ty).collect();\n+                let inputs: Vec<_> =\n+                    struct_def.fields\n+                              .iter()\n+                              .map(|field| tcx.tcache.borrow().get(&local_def(field.node.id))\n+                                                              .unwrap()\n+                                                              .ty)\n+                              .collect();\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n                                                 local_def(ctor_id),\n                                                 &inputs[..],\n@@ -1987,7 +1991,7 @@ fn conv_param_bounds<'a,'tcx>(astconv: &AstConv<'tcx>,\n         builtin_bounds,\n         trait_bounds,\n         region_bounds\n-    } = astconv::partition_bounds(tcx, span, ast_bounds.as_slice());\n+    } = astconv::partition_bounds(tcx, span, &ast_bounds);\n \n     let mut projection_bounds = Vec::new();\n "}, {"sha": "4e7e63a5d7779a6787e1d732aa67e22646ecdbe1", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -80,7 +80,6 @@ This API is completely unstable and subject to change.\n #![feature(collections)]\n #![feature(core)]\n #![feature(int_uint)]\n-#![feature(std_misc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "41e05ff5162cfca0e849b00ca76d13f981572a2e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -188,7 +188,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n \n         let src = match cx.input {\n             Input::File(ref path) => path.clone(),\n-            Input::Str(_) => PathBuf::new(\"\") // FIXME: this is wrong\n+            Input::Str(_) => PathBuf::new() // FIXME: this is wrong\n         };\n \n         Crate {\n@@ -1322,7 +1322,8 @@ pub enum Type {\n     /// For parameterized types, so the consumer of the JSON don't go\n     /// looking for types which don't exist anywhere.\n     Generic(String),\n-    /// Primitives are just the fixed-size numeric types (plus int/uint/float), and char.\n+    /// Primitives are the fixed-size numeric types (plus int/uint/float), char,\n+    /// arrays, slices, and tuples.\n     Primitive(PrimitiveType),\n     /// extern \"ABI\" fn\n     BareFunction(Box<BareFunctionDecl>),\n@@ -1362,6 +1363,7 @@ pub enum PrimitiveType {\n     Bool,\n     Str,\n     Slice,\n+    Array,\n     PrimitiveTuple,\n }\n \n@@ -1396,6 +1398,7 @@ impl PrimitiveType {\n             \"str\" => Some(Str),\n             \"f32\" => Some(F32),\n             \"f64\" => Some(F64),\n+            \"array\" => Some(Array),\n             \"slice\" => Some(Slice),\n             \"tuple\" => Some(PrimitiveTuple),\n             _ => None,\n@@ -1440,6 +1443,7 @@ impl PrimitiveType {\n             Str => \"str\",\n             Bool => \"bool\",\n             Char => \"char\",\n+            Array => \"array\",\n             Slice => \"slice\",\n             PrimitiveTuple => \"tuple\",\n         }"}, {"sha": "57cb87e1b2d011fb7a4c08147bfc1a491e687f8c", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -47,7 +47,7 @@ pub fn load_string(input: &Path) -> io::Result<Option<String>> {\n macro_rules! load_or_return {\n     ($input: expr, $cant_read: expr, $not_utf8: expr) => {\n         {\n-            let input = PathBuf::new($input);\n+            let input = PathBuf::from(&$input[..]);\n             match ::externalfiles::load_string(&input) {\n                 Err(e) => {\n                     let _ = writeln!(&mut io::stderr(),"}, {"sha": "df6beab0f5832ebc75bbfdf62fbd0b6a412bbeef", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -290,7 +290,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: ast::DefId, p: &clean::Path,\n             if ast_util::is_local(did) || cache.inlined.contains(&did) {\n                 Some(repeat(\"../\").take(loc.len()).collect::<String>())\n             } else {\n-                match cache.extern_locations[did.krate] {\n+                match cache.extern_locations[&did.krate] {\n                     render::Remote(ref s) => Some(s.to_string()),\n                     render::Local => {\n                         Some(repeat(\"../\").take(loc.len()).collect::<String>())\n@@ -404,11 +404,11 @@ fn primitive_link(f: &mut fmt::Formatter,\n             needs_termination = true;\n         }\n         Some(&cnum) => {\n-            let path = &m.paths[ast::DefId {\n+            let path = &m.paths[&ast::DefId {\n                 krate: cnum,\n                 node: ast::CRATE_NODE_ID,\n             }];\n-            let loc = match m.extern_locations[cnum] {\n+            let loc = match m.extern_locations[&cnum] {\n                 render::Remote(ref s) => Some(s.to_string()),\n                 render::Local => {\n                     let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n@@ -486,7 +486,7 @@ impl fmt::Display for clean::Type {\n                 primitive_link(f, clean::Slice, &format!(\"[{}]\", **t))\n             }\n             clean::FixedVector(ref t, ref s) => {\n-                primitive_link(f, clean::Slice,\n+                primitive_link(f, clean::PrimitiveType::Array,\n                                &format!(\"[{}; {}]\", **t, *s))\n             }\n             clean::Bottom => f.write_str(\"!\"),"}, {"sha": "cdd8457687ac60d1b6cf9866303cb34083453d44", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -230,7 +230,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                         stripped_filtered_line(l).unwrap_or(l)\n                     }).collect::<Vec<&str>>().connect(\"\\n\");\n                     let krate = krate.as_ref().map(|s| &**s);\n-                    let test = test::maketest(&test, krate, false, false);\n+                    let test = test::maketest(&test, krate, false, false, true);\n                     s.push_str(&format!(\"<span class='rusttest'>{}</span>\", Escape(&test)));\n                 });\n                 s.push_str(&highlight::highlight(&text,"}, {"sha": "d57739c4002494165c4f48cf4fbc7abbce720425", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -300,7 +300,7 @@ pub fn run(mut krate: clean::Crate,\n            passes: HashSet<String>) -> io::Result<()> {\n     let src_root = match krate.src.parent() {\n         Some(p) => p.to_path_buf(),\n-        None => PathBuf::new(\"\"),\n+        None => PathBuf::new(),\n     };\n     let mut cx = Context {\n         dst: dst,\n@@ -784,7 +784,7 @@ impl<'a> DocFolder for SourceCollector<'a> {\n impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &str) -> io::Result<()> {\n-        let p = PathBuf::new(filename);\n+        let p = PathBuf::from(filename);\n \n         // If we couldn't open this file, then just returns because it\n         // probably means that it's some standard library macro thing and we\n@@ -819,7 +819,7 @@ impl<'a> SourceCollector<'a> {\n         let mut fname = p.file_name().expect(\"source has no filename\")\n                          .to_os_string();\n         fname.push(\".html\");\n-        cur.push(&fname);\n+        cur.push(&fname[..]);\n         let mut w = BufWriter::new(try!(File::create(&cur)));\n \n         let title = format!(\"{} -- source\", cur.file_name().unwrap()\n@@ -1026,7 +1026,8 @@ impl DocFolder for Cache {\n                 match item {\n                     clean::Item{ attrs, inner: clean::ImplItem(i), .. } => {\n                         use clean::{Primitive, Vector, ResolvedPath, BorrowedRef};\n-                        use clean::{FixedVector, Slice, Tuple, PrimitiveTuple};\n+                        use clean::PrimitiveType::{Array, Slice, PrimitiveTuple};\n+                        use clean::{FixedVector, Tuple};\n \n                         // extract relevant documentation for this impl\n                         let dox = match attrs.into_iter().find(|a| {\n@@ -1056,12 +1057,16 @@ impl DocFolder for Cache {\n                                 Some(ast_util::local_def(p.to_node_id()))\n                             }\n \n-                            // In a DST world, we may only need\n-                            // Vector/FixedVector, but for now we also pick up\n-                            // borrowed references\n-                            Vector(..) | FixedVector(..) |\n-                                BorrowedRef{ type_: box Vector(..), ..  } |\n-                                BorrowedRef{ type_: box FixedVector(..), .. } =>\n+                            FixedVector(..) |\n+                                BorrowedRef { type_: box FixedVector(..), .. } =>\n+                            {\n+                                Some(ast_util::local_def(Array.to_node_id()))\n+                            }\n+\n+                            // In a DST world, we may only need Vector, but for now we\n+                            // also pick up borrowed references\n+                            Vector(..) |\n+                                BorrowedRef{ type_: box Vector(..), ..  } =>\n                             {\n                                 Some(ast_util::local_def(Slice.to_node_id()))\n                             }\n@@ -1404,8 +1409,8 @@ impl<'a> Item<'a> {\n         // located, then we return `None`.\n         } else {\n             let cache = cache();\n-            let path = &cache.external_paths[self.item.def_id];\n-            let root = match cache.extern_locations[self.item.def_id.krate] {\n+            let path = &cache.external_paths[&self.item.def_id];\n+            let root = match cache.extern_locations[&self.item.def_id.krate] {\n                 Remote(ref s) => s.to_string(),\n                 Local => self.cx.root_path.clone(),\n                 Unknown => return None,\n@@ -1863,7 +1868,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 path = if ast_util::is_local(it.def_id) {\n                     cx.current.connect(\"/\")\n                 } else {\n-                    let path = &cache.external_paths[it.def_id];\n+                    let path = &cache.external_paths[&it.def_id];\n                     path[..path.len() - 1].connect(\"/\")\n                 },\n                 ty = shortty(it).to_static_str(),"}, {"sha": "9f1d876432c389c55cdf55e6c8d18f1fb25dfda5", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -38,6 +38,7 @@\n #![feature(file_path)]\n #![feature(path_ext)]\n #![feature(path_relative_from)]\n+#![feature(convert)]\n \n extern crate arena;\n extern crate getopts;\n@@ -51,6 +52,7 @@ extern crate rustc_back;\n extern crate serialize;\n extern crate syntax;\n extern crate \"test\" as testing;\n+extern crate unicode;\n #[macro_use] extern crate log;\n \n extern crate \"serialize\" as rustc_serialize; // used by deriving\n@@ -251,7 +253,7 @@ pub fn main_args(args: &[String]) -> int {\n     let should_test = matches.opt_present(\"test\");\n     let markdown_input = input.ends_with(\".md\") || input.ends_with(\".markdown\");\n \n-    let output = matches.opt_str(\"o\").map(|s| PathBuf::new(&s));\n+    let output = matches.opt_str(\"o\").map(|s| PathBuf::from(&s));\n     let cfgs = matches.opt_strs(\"cfg\");\n \n     let external_html = match ExternalHtml::load(\n@@ -271,7 +273,7 @@ pub fn main_args(args: &[String]) -> int {\n             return test::run(input, cfgs, libs, externs, test_args, crate_name)\n         }\n         (false, true) => return markdown::render(input,\n-                                                 output.unwrap_or(PathBuf::new(\"doc\")),\n+                                                 output.unwrap_or(PathBuf::from(\"doc\")),\n                                                  &matches, &external_html,\n                                                  !matches.opt_present(\"markdown-no-toc\")),\n         (false, false) => {}\n@@ -289,15 +291,15 @@ pub fn main_args(args: &[String]) -> int {\n     match matches.opt_str(\"w\").as_ref().map(|s| &**s) {\n         Some(\"html\") | None => {\n             match html::render::run(krate, &external_html,\n-                                    output.unwrap_or(PathBuf::new(\"doc\")),\n+                                    output.unwrap_or(PathBuf::from(\"doc\")),\n                                     passes.into_iter().collect()) {\n                 Ok(()) => {}\n                 Err(e) => panic!(\"failed to generate documentation: {}\", e),\n             }\n         }\n         Some(\"json\") => {\n             match json_output(krate, json_plugins,\n-                              output.unwrap_or(PathBuf::new(\"doc.json\"))) {\n+                              output.unwrap_or(PathBuf::from(\"doc.json\"))) {\n                 Ok(()) => {}\n                 Err(e) => panic!(\"failed to write json: {}\", e),\n             }\n@@ -376,7 +378,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     let cfgs = matches.opt_strs(\"cfg\");\n     let triple = matches.opt_str(\"target\");\n \n-    let cr = PathBuf::new(cratefile);\n+    let cr = PathBuf::from(cratefile);\n     info!(\"starting to run rustc\");\n \n     let (tx, rx) = channel();"}, {"sha": "f3d7ae19f4d3c1f978000636c5bf765381698e6e", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -143,7 +143,7 @@ pub fn test(input: &str, libs: SearchPaths, externs: core::Externs,\n             mut test_args: Vec<String>) -> int {\n     let input_str = load_or_return!(input, 1, 2);\n \n-    let mut collector = Collector::new(input.to_string(), libs, externs, true);\n+    let mut collector = Collector::new(input.to_string(), libs, externs, true, false);\n     find_testable_code(&input_str, &mut collector);\n     test_args.insert(0, \"rustdoctest\".to_string());\n     testing::test_main(&test_args, collector.tests);"}, {"sha": "7b37a5a9d1c8167e6fd19f3f60aa1222b291cc47", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 82, "deletions": 11, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -46,7 +46,7 @@ pub fn run(input: &str,\n            mut test_args: Vec<String>,\n            crate_name: Option<String>)\n            -> int {\n-    let input_path = PathBuf::new(input);\n+    let input_path = PathBuf::from(input);\n     let input = config::Input::File(input_path.clone());\n \n     let sessopts = config::Options {\n@@ -76,6 +76,8 @@ pub fn run(input: &str,\n                                                      \"rustdoc-test\", None)\n         .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n+    let inject_crate = should_inject_crate(&krate);\n+\n     let ctx = core::DocContext {\n         krate: &krate,\n         maybe_typed: core::NotTyped(sess),\n@@ -100,7 +102,8 @@ pub fn run(input: &str,\n     let mut collector = Collector::new(krate.name.to_string(),\n                                        libs,\n                                        externs,\n-                                       false);\n+                                       false,\n+                                       inject_crate);\n     collector.fold_crate(krate);\n \n     test_args.insert(0, \"rustdoctest\".to_string());\n@@ -110,13 +113,42 @@ pub fn run(input: &str,\n     0\n }\n \n+// Look for #![doc(test(no_crate_inject))], used by crates in the std facade\n+fn should_inject_crate(krate: &::syntax::ast::Crate) -> bool {\n+    use syntax::attr::AttrMetaMethods;\n+\n+    let mut inject_crate = true;\n+\n+    for attr in &krate.attrs {\n+        if attr.check_name(\"doc\") {\n+            for list in attr.meta_item_list().into_iter() {\n+                for attr in list {\n+                    if attr.check_name(\"test\") {\n+                        for list in attr.meta_item_list().into_iter() {\n+                            for attr in list {\n+                                if attr.check_name(\"no_crate_inject\") {\n+                                    inject_crate = false;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    return inject_crate;\n+}\n+\n #[allow(deprecated)]\n fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n            externs: core::Externs,\n-           should_panic: bool, no_run: bool, as_test_harness: bool) {\n+           should_panic: bool, no_run: bool, as_test_harness: bool,\n+           inject_crate: bool) {\n     // the test harness wants its own `main` & top level functions, so\n     // never wrap the test in `fn main() { ... }`\n-    let test = maketest(test, Some(cratename), true, as_test_harness);\n+    let test = maketest(test, Some(cratename), true, as_test_harness,\n+                        inject_crate);\n     let input = config::Input::Str(test.to_string());\n \n     let sessopts = config::Options {\n@@ -218,8 +250,16 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     }\n }\n \n-pub fn maketest(s: &str, cratename: Option<&str>, lints: bool, dont_insert_main: bool) -> String {\n+pub fn maketest(s: &str, cratename: Option<&str>, lints: bool,\n+                dont_insert_main: bool, inject_crate: bool) -> String {\n+    let (crate_attrs, everything_else) = partition_source(s);\n+\n     let mut prog = String::new();\n+\n+    // First push any outer attributes from the example, assuming they\n+    // are intended to be crate attributes.\n+    prog.push_str(&crate_attrs);\n+\n     if lints {\n         prog.push_str(r\"\n #![allow(unused_variables, unused_assignments, unused_mut, unused_attributes, dead_code)]\n@@ -228,7 +268,7 @@ pub fn maketest(s: &str, cratename: Option<&str>, lints: bool, dont_insert_main:\n \n     // Don't inject `extern crate std` because it's already injected by the\n     // compiler.\n-    if !s.contains(\"extern crate\") && cratename != Some(\"std\") {\n+    if !s.contains(\"extern crate\") && inject_crate {\n         match cratename {\n             Some(cratename) => {\n                 if s.contains(cratename) {\n@@ -240,16 +280,42 @@ pub fn maketest(s: &str, cratename: Option<&str>, lints: bool, dont_insert_main:\n         }\n     }\n     if dont_insert_main || s.contains(\"fn main\") {\n-        prog.push_str(s);\n+        prog.push_str(&everything_else);\n     } else {\n         prog.push_str(\"fn main() {\\n    \");\n-        prog.push_str(&s.replace(\"\\n\", \"\\n    \"));\n+        prog.push_str(&everything_else.replace(\"\\n\", \"\\n    \"));\n         prog.push_str(\"\\n}\");\n     }\n \n+    info!(\"final test program: {}\", prog);\n+\n     return prog\n }\n \n+fn partition_source(s: &str) -> (String, String) {\n+    use unicode::str::UnicodeStr;\n+\n+    let mut after_header = false;\n+    let mut before = String::new();\n+    let mut after = String::new();\n+\n+    for line in s.lines() {\n+        let trimline = line.trim();\n+        let header = trimline.is_whitespace() ||\n+            trimline.starts_with(\"#![feature\");\n+        if !header || after_header {\n+            after_header = true;\n+            after.push_str(line);\n+            after.push_str(\"\\n\");\n+        } else {\n+            before.push_str(line);\n+            before.push_str(\"\\n\");\n+        }\n+    }\n+\n+    return (before, after);\n+}\n+\n pub struct Collector {\n     pub tests: Vec<testing::TestDescAndFn>,\n     names: Vec<String>,\n@@ -259,11 +325,12 @@ pub struct Collector {\n     use_headers: bool,\n     current_header: Option<String>,\n     cratename: String,\n+    inject_crate: bool\n }\n \n impl Collector {\n     pub fn new(cratename: String, libs: SearchPaths, externs: core::Externs,\n-               use_headers: bool) -> Collector {\n+               use_headers: bool, inject_crate: bool) -> Collector {\n         Collector {\n             tests: Vec::new(),\n             names: Vec::new(),\n@@ -273,11 +340,13 @@ impl Collector {\n             use_headers: use_headers,\n             current_header: None,\n             cratename: cratename,\n+            inject_crate: inject_crate\n         }\n     }\n \n     pub fn add_test(&mut self, test: String,\n-                    should_panic: bool, no_run: bool, should_ignore: bool, as_test_harness: bool) {\n+                    should_panic: bool, no_run: bool, should_ignore: bool,\n+                    as_test_harness: bool) {\n         let name = if self.use_headers {\n             let s = self.current_header.as_ref().map(|s| &**s).unwrap_or(\"\");\n             format!(\"{}_{}\", s, self.cnt)\n@@ -288,6 +357,7 @@ impl Collector {\n         let libs = self.libs.clone();\n         let externs = self.externs.clone();\n         let cratename = self.cratename.to_string();\n+        let inject_crate = self.inject_crate;\n         debug!(\"Creating test {}: {}\", name, test);\n         self.tests.push(testing::TestDescAndFn {\n             desc: testing::TestDesc {\n@@ -302,7 +372,8 @@ impl Collector {\n                         externs,\n                         should_panic,\n                         no_run,\n-                        as_test_harness);\n+                        as_test_harness,\n+                        inject_crate);\n             }))\n         });\n     }"}, {"sha": "11e10cc2aa7a16cf004fdb8933d7e47283df978d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -196,7 +196,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Some(tcx) => tcx,\n             None => return false\n         };\n-        let def = tcx.def_map.borrow()[id].def_id();\n+        let def = tcx.def_map.borrow()[&id].def_id();\n         if !ast_util::is_local(def) { return false }\n         let analysis = match self.analysis {\n             Some(analysis) => analysis, None => return false"}, {"sha": "e42aa1835dc4466e46e6429eaa292b801267bd54", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -32,6 +32,7 @@ impl ToHex for [u8] {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(rustc_private)]\n     /// extern crate serialize;\n     /// use serialize::hex::ToHex;\n     ///\n@@ -101,6 +102,7 @@ impl FromHex for str {\n     /// This converts a string literal to hexadecimal and back.\n     ///\n     /// ```\n+    /// # #![feature(rustc_private)]\n     /// extern crate serialize;\n     /// use serialize::hex::{FromHex, ToHex};\n     ///"}, {"sha": "abbfc82319f5b30e24035442aedaaa532c0e80a4", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -1218,6 +1218,7 @@ impl Json {\n     }\n }\n \n+#[cfg(stage0)]\n impl<'a> Index<&'a str>  for Json {\n     type Output = Json;\n \n@@ -1226,6 +1227,16 @@ impl<'a> Index<&'a str>  for Json {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<'a> Index<&'a str>  for Json {\n+    type Output = Json;\n+\n+    fn index(&self, idx: &'a str) -> &Json {\n+        self.find(idx).unwrap()\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl Index<uint> for Json {\n     type Output = Json;\n \n@@ -1237,6 +1248,18 @@ impl Index<uint> for Json {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl Index<uint> for Json {\n+    type Output = Json;\n+\n+    fn index<'a>(&'a self, idx: uint) -> &'a Json {\n+        match self {\n+            &Json::Array(ref v) => &v[idx],\n+            _ => panic!(\"can only index Json with uint if it is an array\")\n+        }\n+    }\n+}\n+\n /// The output of the streaming parser.\n #[derive(PartialEq, Clone, Debug)]\n pub enum JsonEvent {"}, {"sha": "482e0d1d0eed3739d1bedc6d018d6bd102e9673f", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -37,7 +37,8 @@ Core encoding and decoding interfaces.\n #![feature(std_misc)]\n #![feature(unicode)]\n #![feature(str_char)]\n-#![cfg_attr(test, feature(test))]\n+#![feature(convert)]\n+#![cfg_attr(test, feature(test, old_io))]\n \n // test harness access\n #[cfg(test)] extern crate test;"}, {"sha": "5e9baa9b9e903557236e407db817a01b0790fe3b", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -579,7 +579,7 @@ impl Encodable for path::PathBuf {\n impl Decodable for path::PathBuf {\n     fn decode<D: Decoder>(d: &mut D) -> Result<path::PathBuf, D::Error> {\n         let bytes: String = try!(Decodable::decode(d));\n-        Ok(path::PathBuf::new(&bytes))\n+        Ok(path::PathBuf::from(bytes))\n     }\n }\n "}, {"sha": "a6b8cd71a3b3d31ae2e8955993431d88b4377387", "filename": "src/libstd/array.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farray.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! The fixed-size array type (`[T; n]`).\n \n-#[deriving(Clone)] //~ ERROR `deriving` has been renamed to `derive`\n-struct Foo;\n-\n-fn main() {}\n+#![doc(primitive = \"array\")]", "previous_filename": "src/test/compile-fail/deriving-is-deprecated.rs"}, {"sha": "f9558b85825d2ee03ebacde2850aa347441a4d3e", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -538,6 +538,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::collections::HashMap;\n     /// use std::collections::hash_map::RandomState;\n     ///\n@@ -566,6 +567,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::collections::HashMap;\n     /// use std::collections::hash_map::RandomState;\n     ///\n@@ -981,6 +983,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::collections::HashMap;\n     ///\n     /// let mut a = HashMap::new();\n@@ -1088,7 +1091,7 @@ impl<K, V, S> HashMap<K, V, S>\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n     /// }\n-    /// assert_eq!(map[1], \"b\");\n+    /// assert_eq!(map[&1], \"b\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n@@ -1111,7 +1114,7 @@ impl<K, V, S> HashMap<K, V, S>\n     ///\n     /// map.insert(37, \"b\");\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n-    /// assert_eq!(map[37], \"c\");\n+    /// assert_eq!(map[&37], \"c\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n@@ -1244,6 +1247,7 @@ impl<K, V, S> Default for HashMap<K, V, S>\n     }\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, Q: ?Sized, V, S> Index<Q> for HashMap<K, V, S>\n     where K: Eq + Hash + Borrow<Q>,\n@@ -1258,6 +1262,21 @@ impl<K, Q: ?Sized, V, S> Index<Q> for HashMap<K, V, S>\n     }\n }\n \n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K, Q: ?Sized, V, S> Index<&'a Q> for HashMap<K, V, S>\n+    where K: Eq + Hash + Borrow<Q>,\n+          Q: Eq + Hash,\n+          S: HashState,\n+{\n+    type Output = V;\n+\n+    #[inline]\n+    fn index(&self, index: &Q) -> &V {\n+        self.get(index).expect(\"no entry found for key\")\n+    }\n+}\n+\n /// HashMap iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n@@ -1323,28 +1342,28 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n }\n \n /// A view into a single occupied location in a HashMap.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"precise API still being fleshed out\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n }\n \n /// A view into a single empty location in a HashMap.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"precise API still being fleshed out\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n     key: K,\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n }\n \n /// A view into a single location in a map, which may be vacant or occupied.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"precise API still being fleshed out\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// An occupied Entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Occupied(OccupiedEntry<'a, K, V>),\n+\n     /// A vacant Entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Vacant(VacantEntry<'a, K, V>),\n }\n \n@@ -1465,10 +1484,10 @@ impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[unstable(feature = \"std_misc\",\n-           reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n impl<'a, K, V> Entry<'a, K, V> {\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant.\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"will soon be replaced by or_insert\")]\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n         match self {\n             Occupied(entry) => Ok(entry.into_mut()),\n@@ -2185,7 +2204,7 @@ mod test_map {\n         map.insert(2, 1);\n         map.insert(3, 4);\n \n-        assert_eq!(map[2], 1);\n+        assert_eq!(map[&2], 1);\n     }\n \n     #[test]\n@@ -2197,7 +2216,7 @@ mod test_map {\n         map.insert(2, 1);\n         map.insert(3, 4);\n \n-        map[4];\n+        map[&4];\n     }\n \n     #[test]"}, {"sha": "0933b4f662a9d744fbec130c491ea1d842e3d944", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -145,6 +145,7 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::collections::HashSet;\n     /// use std::collections::hash_map::RandomState;\n     ///\n@@ -169,6 +170,7 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::collections::HashSet;\n     /// use std::collections::hash_map::RandomState;\n     ///\n@@ -295,6 +297,7 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::HashSet;\n     /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n     /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n@@ -325,6 +328,7 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::HashSet;\n     /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n     /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n@@ -351,6 +355,7 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::HashSet;\n     /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n     /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n@@ -376,6 +381,7 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::HashSet;\n     /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n     /// let b: HashSet<_> = [4, 2, 3, 4].iter().cloned().collect();\n@@ -458,6 +464,7 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::HashSet;\n     ///\n     /// let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n@@ -477,6 +484,7 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::HashSet;\n     ///\n     /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n@@ -498,6 +506,7 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::HashSet;\n     ///\n     /// let sup: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n@@ -519,6 +528,7 @@ impl<T, S> HashSet<T, S>\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::collections::HashSet;\n     ///\n     /// let sub: HashSet<_> = [1, 2].iter().cloned().collect();\n@@ -853,6 +863,9 @@ impl<T, S> IntoIterator for HashSet<T, S>\n     }\n }\n \n+impl<'a, K> Clone for Iter<'a, K> {\n+    fn clone(&self) -> Iter<'a, K> { Iter { iter: self.iter.clone() } }\n+}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> Iterator for Iter<'a, K> {\n     type Item = &'a K;\n@@ -889,6 +902,12 @@ impl<'a, K> ExactSizeIterator for Drain<'a, K> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n+impl<'a, T, S> Clone for Intersection<'a, T, S> {\n+    fn clone(&self) -> Intersection<'a, T, S> {\n+        Intersection { iter: self.iter.clone(), ..*self }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for Intersection<'a, T, S>\n     where T: Eq + Hash, S: HashState\n@@ -912,6 +931,12 @@ impl<'a, T, S> Iterator for Intersection<'a, T, S>\n     }\n }\n \n+impl<'a, T, S> Clone for Difference<'a, T, S> {\n+    fn clone(&self) -> Difference<'a, T, S> {\n+        Difference { iter: self.iter.clone(), ..*self }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for Difference<'a, T, S>\n     where T: Eq + Hash, S: HashState\n@@ -935,6 +960,12 @@ impl<'a, T, S> Iterator for Difference<'a, T, S>\n     }\n }\n \n+impl<'a, T, S> Clone for SymmetricDifference<'a, T, S> {\n+    fn clone(&self) -> SymmetricDifference<'a, T, S> {\n+        SymmetricDifference { iter: self.iter.clone() }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for SymmetricDifference<'a, T, S>\n     where T: Eq + Hash, S: HashState\n@@ -945,6 +976,10 @@ impl<'a, T, S> Iterator for SymmetricDifference<'a, T, S>\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n+impl<'a, T, S> Clone for Union<'a, T, S> {\n+    fn clone(&self) -> Union<'a, T, S> { Union { iter: self.iter.clone() } }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for Union<'a, T, S>\n     where T: Eq + Hash, S: HashState"}, {"sha": "8d24f6b191659f622aa6379aa4dc968ed8a2e499", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -300,6 +300,7 @@\n //! #### Counting the number of times each character in a string occurs\n //!\n //! ```\n+//! # #![feature(collections)]\n //! use std::collections::btree_map::{BTreeMap, Entry};\n //!\n //! let mut count = BTreeMap::new();\n@@ -327,6 +328,7 @@\n //! #### Tracking the inebriation of customers at a bar\n //!\n //! ```\n+//! # #![feature(collections)]\n //! use std::collections::btree_map::{BTreeMap, Entry};\n //!\n //! // A client of the bar. They have an id and a blood alcohol level."}, {"sha": "71f072302fb21c8fef6cf1b7a6e55075e0fc8e96", "filename": "src/libstd/env.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -23,7 +23,7 @@ use error::Error;\n use ffi::{OsString, AsOsStr};\n use fmt;\n use io;\n-use path::{AsPath, PathBuf};\n+use path::{Path, PathBuf};\n use sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT, Ordering};\n use sync::{StaticMutex, MUTEX_INIT};\n use sys::os as os_imp;\n@@ -67,8 +67,8 @@ pub fn current_dir() -> io::Result<PathBuf> {\n /// println!(\"Successfully changed working directory to {}!\", root.display());\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub fn set_current_dir<P: AsPath + ?Sized>(p: &P) -> io::Result<()> {\n-    os_imp::chdir(p.as_path())\n+pub fn set_current_dir<P: AsRef<Path> + ?Sized>(p: &P) -> io::Result<()> {\n+    os_imp::chdir(p.as_ref())\n }\n \n static ENV_LOCK: StaticMutex = MUTEX_INIT;\n@@ -327,12 +327,13 @@ pub struct JoinPathsError {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(convert)]\n /// use std::env;\n /// use std::path::PathBuf;\n ///\n /// if let Some(path) = env::var_os(\"PATH\") {\n ///     let mut paths = env::split_paths(&path).collect::<Vec<_>>();\n-///     paths.push(PathBuf::new(\"/home/xyz/bin\"));\n+///     paths.push(PathBuf::from(\"/home/xyz/bin\"));\n ///     let new_path = env::join_paths(paths.iter()).unwrap();\n ///     env::set_var(\"PATH\", &new_path);\n /// }\n@@ -833,7 +834,7 @@ mod tests {\n     fn split_paths_windows() {\n         fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n             split_paths(unparsed).collect::<Vec<_>>() ==\n-                parsed.iter().map(|s| PathBuf::new(*s)).collect::<Vec<_>>()\n+                parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n         }\n \n         assert!(check_parse(\"\", &mut [\"\"]));\n@@ -853,7 +854,7 @@ mod tests {\n     fn split_paths_unix() {\n         fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n             split_paths(unparsed).collect::<Vec<_>>() ==\n-                parsed.iter().map(|s| PathBuf::new(*s)).collect::<Vec<_>>()\n+                parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n         }\n \n         assert!(check_parse(\"\", &mut [\"\"]));"}, {"sha": "8b19d16017280ccce55b6458778101f02c5a81c2", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -10,6 +10,7 @@\n \n #![unstable(feature = \"std_misc\")]\n \n+use convert::Into;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use error::{Error, FromError};\n use fmt;\n@@ -44,6 +45,7 @@ use vec::Vec;\n /// # Examples\n ///\n /// ```no_run\n+/// # #![feature(libc)]\n /// # extern crate libc;\n /// # fn main() {\n /// use std::ffi::CString;\n@@ -82,6 +84,7 @@ pub struct CString {\n /// Inspecting a foreign C string\n ///\n /// ```no_run\n+/// # #![feature(libc)]\n /// extern crate libc;\n /// use std::ffi::CStr;\n ///\n@@ -98,6 +101,7 @@ pub struct CString {\n /// Passing a Rust-originating C string\n ///\n /// ```no_run\n+/// # #![feature(libc)]\n /// extern crate libc;\n /// use std::ffi::{CString, CStr};\n ///\n@@ -130,6 +134,8 @@ pub struct NulError(usize, Vec<u8>);\n \n /// A conversion trait used by the constructor of `CString` for types that can\n /// be converted to a vector of bytes.\n+#[deprecated(since = \"1.0.0\", reason = \"use std::convert::Into<Vec<u8>> instead\")]\n+#[unstable(feature = \"std_misc\")]\n pub trait IntoBytes {\n     /// Consumes this container, returning a vector of bytes.\n     fn into_bytes(self) -> Vec<u8>;\n@@ -144,6 +150,7 @@ impl CString {\n     /// # Examples\n     ///\n     /// ```no_run\n+    /// # #![feature(libc)]\n     /// extern crate libc;\n     /// use std::ffi::CString;\n     ///\n@@ -163,8 +170,8 @@ impl CString {\n     /// internal 0 byte. The error returned will contain the bytes as well as\n     /// the position of the nul byte.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new<T: IntoBytes>(t: T) -> Result<CString, NulError> {\n-        let bytes = t.into_bytes();\n+    pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> {\n+        let bytes = t.into();\n         match bytes.iter().position(|x| *x == 0) {\n             Some(i) => Err(NulError(i, bytes)),\n             None => Ok(unsafe { CString::from_vec_unchecked(bytes) }),\n@@ -179,6 +186,7 @@ impl CString {\n     /// # Examples\n     ///\n     /// ```no_run\n+    /// # #![feature(libc)]\n     /// extern crate libc;\n     /// use std::ffi::CString;\n     ///\n@@ -329,6 +337,7 @@ impl CStr {\n     /// # Examples\n     ///\n     /// ```no_run\n+    /// # #![feature(libc)]\n     /// # extern crate libc;\n     /// # fn main() {\n     /// use std::ffi::CStr;\n@@ -433,15 +442,19 @@ pub unsafe fn c_str_to_bytes_with_nul<'a>(raw: &'a *const libc::c_char)\n     slice::from_raw_parts(*(raw as *const _ as *const *const u8), len as usize)\n }\n \n+#[allow(deprecated)]\n impl<'a> IntoBytes for &'a str {\n     fn into_bytes(self) -> Vec<u8> { self.as_bytes().to_vec() }\n }\n+#[allow(deprecated)]\n impl<'a> IntoBytes for &'a [u8] {\n     fn into_bytes(self) -> Vec<u8> { self.to_vec() }\n }\n+#[allow(deprecated)]\n impl IntoBytes for String {\n     fn into_bytes(self) -> Vec<u8> { self.into_bytes() }\n }\n+#[allow(deprecated)]\n impl IntoBytes for Vec<u8> {\n     fn into_bytes(self) -> Vec<u8> { self }\n }"}, {"sha": "5851c6e2998095923c744da0d01fceeb6556355b", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 85, "deletions": 4, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -63,16 +63,18 @@ pub struct OsStr {\n impl OsString {\n     /// Constructs an `OsString` at no cost by consuming a `String`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use `from` instead\")]\n     pub fn from_string(s: String) -> OsString {\n-        OsString { inner: Buf::from_string(s) }\n+        OsString::from(s)\n     }\n \n     /// Constructs an `OsString` by copying from a `&str` slice.\n     ///\n     /// Equivalent to: `OsString::from_string(String::from_str(s))`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use `from` instead\")]\n     pub fn from_str(s: &str) -> OsString {\n-        OsString { inner: Buf::from_str(s) }\n+        OsString::from(s)\n     }\n \n     /// Constructs a new empty `OsString`.\n@@ -98,11 +100,40 @@ impl OsString {\n \n     /// Extend the string with the given `&OsStr` slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn push<T: AsOsStr + ?Sized>(&mut self, s: &T) {\n-        self.inner.push_slice(&s.as_os_str().inner)\n+    pub fn push<T: AsRef<OsStr>>(&mut self, s: T) {\n+        self.inner.push_slice(&s.as_ref().inner)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl From<String> for OsString {\n+    fn from(s: String) -> OsString {\n+        OsString { inner: Buf::from_string(s) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a String> for OsString {\n+    fn from(s: &'a String) -> OsString {\n+        OsString { inner: Buf::from_str(s) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a str> for OsString {\n+    fn from(s: &'a str) -> OsString {\n+        OsString { inner: Buf::from_str(s) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a OsStr> for OsString {\n+    fn from(s: &'a OsStr) -> OsString {\n+        OsString { inner: s.inner.to_owned() }\n     }\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFull> for OsString {\n     type Output = OsStr;\n@@ -113,6 +144,17 @@ impl ops::Index<ops::RangeFull> for OsString {\n     }\n }\n \n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ops::Index<ops::RangeFull> for OsString {\n+    type Output = OsStr;\n+\n+    #[inline]\n+    fn index(&self, _index: ops::RangeFull) -> &OsStr {\n+        unsafe { mem::transmute(self.inner.as_slice()) }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Deref for OsString {\n     type Target = OsStr;\n@@ -316,37 +358,76 @@ impl ToOwned for OsStr {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl<'a, T: AsOsStr + ?Sized> AsOsStr for &'a T {\n     fn as_os_str(&self) -> &OsStr {\n         (*self).as_os_str()\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl AsOsStr for OsStr {\n     fn as_os_str(&self) -> &OsStr {\n         self\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl AsOsStr for OsString {\n     fn as_os_str(&self) -> &OsStr {\n         &self[..]\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl AsOsStr for str {\n     fn as_os_str(&self) -> &OsStr {\n         OsStr::from_str(self)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl AsOsStr for String {\n     fn as_os_str(&self) -> &OsStr {\n         OsStr::from_str(&self[..])\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<OsStr> for OsStr {\n+    fn as_ref(&self) -> &OsStr {\n+        self\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<OsStr> for OsString {\n+    fn as_ref(&self) -> &OsStr {\n+        self\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<OsStr> for str {\n+    fn as_ref(&self) -> &OsStr {\n+        OsStr::from_str(self)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<OsStr> for String {\n+    fn as_ref(&self) -> &OsStr {\n+        OsStr::from_str(&self[..])\n+    }\n+}\n+\n #[allow(deprecated)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl AsOsStr for Path {\n     #[cfg(unix)]\n     fn as_os_str(&self) -> &OsStr {"}, {"sha": "2546aace2659c562f1329f4b696334bc5e2c6f1b", "filename": "src/libstd/fs/mod.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Ffs%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Ffs%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -20,7 +20,7 @@\n use core::prelude::*;\n \n use io::{self, Error, ErrorKind, SeekFrom, Seek, Read, Write};\n-use path::{AsPath, Path, PathBuf};\n+use path::{Path, PathBuf};\n use sys::fs2 as fs_imp;\n use sys_common::{AsInnerMut, FromInner, AsInner};\n use vec::Vec;\n@@ -129,7 +129,7 @@ impl File {\n     /// This function will return an error if `path` does not already exist.\n     /// Other errors may also be returned according to `OpenOptions::open`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn open<P: AsPath>(path: P) -> io::Result<File> {\n+    pub fn open<P: AsRef<Path>>(path: P) -> io::Result<File> {\n         OpenOptions::new().read(true).open(path)\n     }\n \n@@ -140,7 +140,7 @@ impl File {\n     ///\n     /// See the `OpenOptions::open` function for more details.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn create<P: AsPath>(path: P) -> io::Result<File> {\n+    pub fn create<P: AsRef<Path>>(path: P) -> io::Result<File> {\n         OpenOptions::new().write(true).create(true).truncate(true).open(path)\n     }\n \n@@ -302,8 +302,8 @@ impl OpenOptions {\n     ///   permissions for\n     /// * Filesystem-level errors (full disk, etc)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn open<P: AsPath>(&self, path: P) -> io::Result<File> {\n-        let path = path.as_path();\n+    pub fn open<P: AsRef<Path>>(&self, path: P) -> io::Result<File> {\n+        let path = path.as_ref();\n         let inner = try!(fs_imp::File::open(path, &self.0));\n         Ok(File { path: path.to_path_buf(), inner: inner })\n     }\n@@ -415,8 +415,8 @@ impl DirEntry {\n /// user lacks permissions to remove the file, or if some other filesystem-level\n /// error occurs.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn remove_file<P: AsPath>(path: P) -> io::Result<()> {\n-    fs_imp::unlink(path.as_path())\n+pub fn remove_file<P: AsRef<Path>>(path: P) -> io::Result<()> {\n+    fs_imp::unlink(path.as_ref())\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -443,8 +443,8 @@ pub fn remove_file<P: AsPath>(path: P) -> io::Result<()> {\n /// permissions to perform a `metadata` call on the given `path` or if there\n /// is no entry in the filesystem at the provided path.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn metadata<P: AsPath>(path: P) -> io::Result<Metadata> {\n-    fs_imp::stat(path.as_path()).map(Metadata)\n+pub fn metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n+    fs_imp::stat(path.as_ref()).map(Metadata)\n }\n \n /// Rename a file or directory to a new name.\n@@ -464,8 +464,8 @@ pub fn metadata<P: AsPath>(path: P) -> io::Result<Metadata> {\n /// reside on separate filesystems, or if some other intermittent I/O error\n /// occurs.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn rename<P: AsPath, Q: AsPath>(from: P, to: Q) -> io::Result<()> {\n-    fs_imp::rename(from.as_path(), to.as_path())\n+pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()> {\n+    fs_imp::rename(from.as_ref(), to.as_ref())\n }\n \n /// Copies the contents of one file to another. This function will also\n@@ -494,9 +494,9 @@ pub fn rename<P: AsPath, Q: AsPath>(from: P, to: Q) -> io::Result<()> {\n /// * The current process does not have the permission rights to access\n ///   `from` or write `to`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn copy<P: AsPath, Q: AsPath>(from: P, to: Q) -> io::Result<u64> {\n-    let from = from.as_path();\n-    let to = to.as_path();\n+pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {\n+    let from = from.as_ref();\n+    let to = to.as_ref();\n     if !from.is_file() {\n         return Err(Error::new(ErrorKind::InvalidInput,\n                               \"the source path is not an existing file\",\n@@ -517,16 +517,16 @@ pub fn copy<P: AsPath, Q: AsPath>(from: P, to: Q) -> io::Result<u64> {\n /// The `dst` path will be a link pointing to the `src` path. Note that systems\n /// often require these two paths to both be located on the same filesystem.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn hard_link<P: AsPath, Q: AsPath>(src: P, dst: Q) -> io::Result<()> {\n-    fs_imp::link(src.as_path(), dst.as_path())\n+pub fn hard_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n+    fs_imp::link(src.as_ref(), dst.as_ref())\n }\n \n /// Creates a new soft link on the filesystem.\n ///\n /// The `dst` path will be a soft link pointing to the `src` path.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn soft_link<P: AsPath, Q: AsPath>(src: P, dst: Q) -> io::Result<()> {\n-    fs_imp::symlink(src.as_path(), dst.as_path())\n+pub fn soft_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n+    fs_imp::symlink(src.as_ref(), dst.as_ref())\n }\n \n /// Reads a soft link, returning the file that the link points to.\n@@ -537,8 +537,8 @@ pub fn soft_link<P: AsPath, Q: AsPath>(src: P, dst: Q) -> io::Result<()> {\n /// reading a file that does not exist or reading a file that is not a soft\n /// link.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn read_link<P: AsPath>(path: P) -> io::Result<PathBuf> {\n-    fs_imp::readlink(path.as_path())\n+pub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n+    fs_imp::readlink(path.as_ref())\n }\n \n /// Create a new, empty directory at the provided path\n@@ -556,8 +556,8 @@ pub fn read_link<P: AsPath>(path: P) -> io::Result<PathBuf> {\n /// This function will return an error if the user lacks permissions to make a\n /// new directory at the provided `path`, or if the directory already exists.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn create_dir<P: AsPath>(path: P) -> io::Result<()> {\n-    fs_imp::mkdir(path.as_path())\n+pub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n+    fs_imp::mkdir(path.as_ref())\n }\n \n /// Recursively create a directory and all of its parent components if they\n@@ -570,9 +570,9 @@ pub fn create_dir<P: AsPath>(path: P) -> io::Result<()> {\n /// error conditions for when a directory is being created (after it is\n /// determined to not exist) are outlined by `fs::create_dir`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn create_dir_all<P: AsPath>(path: P) -> io::Result<()> {\n-    let path = path.as_path();\n-    if path.is_dir() { return Ok(()) }\n+pub fn create_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n+    let path = path.as_ref();\n+    if path == Path::new(\"\") || path.is_dir() { return Ok(()) }\n     if let Some(p) = path.parent() { try!(create_dir_all(p)) }\n     create_dir(path)\n }\n@@ -592,8 +592,8 @@ pub fn create_dir_all<P: AsPath>(path: P) -> io::Result<()> {\n /// This function will return an error if the user lacks permissions to remove\n /// the directory at the provided `path`, or if the directory isn't empty.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn remove_dir<P: AsPath>(path: P) -> io::Result<()> {\n-    fs_imp::rmdir(path.as_path())\n+pub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n+    fs_imp::rmdir(path.as_ref())\n }\n \n /// Removes a directory at this path, after removing all its contents. Use\n@@ -606,8 +606,8 @@ pub fn remove_dir<P: AsPath>(path: P) -> io::Result<()> {\n ///\n /// See `file::remove_file` and `fs::remove_dir`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn remove_dir_all<P: AsPath>(path: P) -> io::Result<()> {\n-    let path = path.as_path();\n+pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n+    let path = path.as_ref();\n     for child in try!(read_dir(path)) {\n         let child = try!(child).path();\n         let stat = try!(lstat(&*child));\n@@ -633,6 +633,7 @@ pub fn remove_dir_all<P: AsPath>(path: P) -> io::Result<()> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(path_ext)]\n /// use std::io;\n /// use std::fs::{self, PathExt, DirEntry};\n /// use std::path::Path;\n@@ -659,8 +660,8 @@ pub fn remove_dir_all<P: AsPath>(path: P) -> io::Result<()> {\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn read_dir<P: AsPath>(path: P) -> io::Result<ReadDir> {\n-    fs_imp::readdir(path.as_path()).map(ReadDir)\n+pub fn read_dir<P: AsRef<Path>>(path: P) -> io::Result<ReadDir> {\n+    fs_imp::readdir(path.as_ref()).map(ReadDir)\n }\n \n /// Returns an iterator that will recursively walk the directory structure\n@@ -675,7 +676,7 @@ pub fn read_dir<P: AsPath>(path: P) -> io::Result<ReadDir> {\n            reason = \"the precise semantics and defaults for a recursive walk \\\n                      may change and this may end up accounting for files such \\\n                      as symlinks differently\")]\n-pub fn walk_dir<P: AsPath>(path: P) -> io::Result<WalkDir> {\n+pub fn walk_dir<P: AsRef<Path>>(path: P) -> io::Result<WalkDir> {\n     let start = try!(read_dir(path));\n     Ok(WalkDir { cur: Some(start), stack: Vec::new() })\n }\n@@ -761,16 +762,17 @@ impl PathExt for Path {\n            reason = \"the argument type of u64 is not quite appropriate for \\\n                      this function and may change if the standard library \\\n                      gains a type to represent a moment in time\")]\n-pub fn set_file_times<P: AsPath>(path: P, accessed: u64,\n+pub fn set_file_times<P: AsRef<Path>>(path: P, accessed: u64,\n                                  modified: u64) -> io::Result<()> {\n-    fs_imp::utimes(path.as_path(), accessed, modified)\n+    fs_imp::utimes(path.as_ref(), accessed, modified)\n }\n \n /// Changes the permissions found on a file or a directory.\n ///\n /// # Examples\n ///\n /// ```\n+/// # #![feature(fs)]\n /// # fn foo() -> std::io::Result<()> {\n /// use std::fs;\n ///\n@@ -790,8 +792,8 @@ pub fn set_file_times<P: AsPath>(path: P, accessed: u64,\n            reason = \"a more granual ability to set specific permissions may \\\n                      be exposed on the Permissions structure itself and this \\\n                      method may not always exist\")]\n-pub fn set_permissions<P: AsPath>(path: P, perm: Permissions) -> io::Result<()> {\n-    fs_imp::set_perm(path.as_path(), perm.0)\n+pub fn set_permissions<P: AsRef<Path>>(path: P, perm: Permissions) -> io::Result<()> {\n+    fs_imp::set_perm(path.as_ref(), perm.0)\n }\n \n #[cfg(test)]"}, {"sha": "a9717e36323392a74e55325916a306f9b52bd503", "filename": "src/libstd/fs/tempdir.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Ffs%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Ffs%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Ftempdir.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -18,7 +18,7 @@ use prelude::v1::*;\n use env;\n use io::{self, Error, ErrorKind};\n use fs;\n-use path::{self, PathBuf, AsPath};\n+use path::{self, PathBuf};\n use rand::{thread_rng, Rng};\n \n /// A wrapper for a path to temporary directory implementing automatic\n@@ -43,10 +43,9 @@ impl TempDir {\n     ///\n     /// If no directory can be created, `Err` is returned.\n     #[allow(deprecated)] // rand usage\n-    pub fn new_in<P: AsPath + ?Sized>(tmpdir: &P, prefix: &str)\n-                                      -> io::Result<TempDir> {\n+    pub fn new_in<P: AsRef<path::Path>>(tmpdir: P, prefix: &str) -> io::Result<TempDir> {\n         let storage;\n-        let mut tmpdir = tmpdir.as_path();\n+        let mut tmpdir = tmpdir.as_ref();\n         if !tmpdir.is_absolute() {\n             let cur_dir = try!(env::current_dir());\n             storage = cur_dir.join(tmpdir);"}, {"sha": "4def601f1c0e7657f6a3e7da1c057ec3c53da99a", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -258,7 +258,7 @@ impl<W> FromError<IntoInnerError<W>> for Error {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W> error::Error for IntoInnerError<W> {\n+impl<W: Send + fmt::Debug> error::Error for IntoInnerError<W> {\n     fn description(&self) -> &str {\n         error::Error::description(self.error())\n     }"}, {"sha": "79f0af670b44624ea031136bf95654877ed3bcdb", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -17,20 +17,18 @@ use iter::repeat;\n use num::Int;\n use slice;\n \n-/// A `Cursor` is a type which wraps another I/O object to provide a `Seek`\n+/// A `Cursor` is a type which wraps a non-I/O object to provide a `Seek`\n /// implementation.\n ///\n-/// Cursors are currently typically used with memory buffer objects in order to\n-/// allow `Seek` plus `Read` and `Write` implementations. For example, common\n-/// cursor types include:\n+/// Cursors are typically used with memory buffer objects in order to allow\n+/// `Seek`, `Read`, and `Write` implementations. For example, common cursor types\n+/// include `Cursor<Vec<u8>>` and `Cursor<&[u8]>`.\n ///\n-/// * `Cursor<Vec<u8>>`\n-/// * `Cursor<&[u8]>`\n-///\n-/// Implementations of the I/O traits for `Cursor<T>` are not currently generic\n+/// Implementations of the I/O traits for `Cursor<T>` are currently not generic\n /// over `T` itself. Instead, specific implementations are provided for various\n /// in-memory buffer types like `Vec<u8>` and `&[u8]`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone, Debug)]\n pub struct Cursor<T> {\n     inner: T,\n     pos: u64,"}, {"sha": "39c718c96b38a014583a3f557b8c8cdfff9f3fb6", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -558,6 +558,12 @@ pub trait BufRead: Read {\n     /// This function does not perform any I/O, it simply informs this object\n     /// that some amount of its buffer, returned from `fill_buf`, has been\n     /// consumed and should no longer be returned.\n+    ///\n+    /// This function is used to tell the buffer how many bytes you've consumed\n+    /// from the return value of `fill_buf`, and so may do odd things if\n+    /// `fill_buf` isn't called before calling this.\n+    ///\n+    /// The `amt` must be `<=` the number of bytes in the buffer returned by `fill_buf`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn consume(&mut self, amt: usize);\n "}, {"sha": "90eca6168f266cd8c4c82ba8de0f76a5f58c914b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -40,11 +40,11 @@\n //!\n //! ## Vectors, slices and strings\n //!\n-//! The common container type, `Vec`, a growable vector backed by an\n-//! array, lives in the [`vec`](vec/index.html) module. References to\n-//! arrays, `&[T]`, more commonly called \"slices\", are built-in types\n-//! for which the [`slice`](slice/index.html) module defines many\n-//! methods.\n+//! The common container type, `Vec`, a growable vector backed by an array,\n+//! lives in the [`vec`](vec/index.html) module. Contiguous, unsized regions\n+//! of memory, `[T]`, commonly called \"slices\", and their borrowed versions,\n+//! `&[T]`, commonly called \"borrowed slices\", are built-in types for which the\n+//! for which the [`slice`](slice/index.html) module defines many methods.\n //!\n //! `&str`, a UTF-8 string, is a built-in type, and the standard library\n //! defines methods for it on a variety of traits in the\n@@ -75,7 +75,7 @@\n //!\n //! The [`thread`](thread/index.html) module contains Rust's threading abstractions.\n //! [`sync`](sync/index.html) contains further, primitive, shared memory types,\n-//! including [`atomic`](sync/atomic/index.html), and [`mpsc`](sync/mpmc/index.html),\n+//! including [`atomic`](sync/atomic/index.html), and [`mpsc`](sync/mpsc/index.html),\n //! which contains the channel types for message passing.\n //!\n //! Common types of I/O, including files, TCP, UDP, pipes, Unix domain sockets,\n@@ -105,12 +105,12 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n+#![doc(test(no_crate_inject))]\n \n #![feature(alloc)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(hash)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(linkage, thread_local, asm)]\n@@ -123,12 +123,13 @@\n #![feature(unsafe_destructor)]\n #![feature(unsafe_no_drop_flag)]\n #![feature(macro_reexport)]\n-#![feature(hash)]\n #![feature(int_uint)]\n #![feature(unique)]\n+#![feature(convert)]\n #![feature(allow_internal_unstable)]\n #![feature(str_char)]\n-#![cfg_attr(test, feature(test, rustc_private))]\n+#![feature(into_cow)]\n+#![cfg_attr(test, feature(test, rustc_private, std_misc))]\n \n // Don't link to std. We are std.\n #![feature(no_std)]\n@@ -169,6 +170,7 @@ pub use core::any;\n pub use core::cell;\n pub use core::clone;\n #[cfg(not(test))] pub use core::cmp;\n+pub use core::convert;\n pub use core::default;\n #[allow(deprecated)]\n pub use core::finally;\n@@ -212,6 +214,9 @@ pub mod prelude;\n \n /* Primitive types */\n \n+// NB: slice and str are primitive types too, but their module docs + primitive doc pages\n+// are inlined from the public re-exports of core_collections::{slice, str} above.\n+\n #[path = \"num/float_macros.rs\"]\n #[macro_use]\n mod float_macros;\n@@ -249,30 +254,23 @@ pub mod num;\n /* Runtime and platform support */\n \n #[macro_use]\n-pub mod thread_local;\n+pub mod thread;\n \n+pub mod collections;\n pub mod dynamic_lib;\n+pub mod env;\n pub mod ffi;\n-pub mod old_io;\n-pub mod io;\n pub mod fs;\n+pub mod io;\n pub mod net;\n+pub mod old_io;\n+pub mod old_path;\n pub mod os;\n-pub mod env;\n pub mod path;\n-pub mod old_path;\n pub mod process;\n pub mod rand;\n-pub mod time;\n-\n-/* Common data structures */\n-\n-pub mod collections;\n-\n-/* Threads and communication */\n-\n-pub mod thread;\n pub mod sync;\n+pub mod time;\n \n #[macro_use]\n #[path = \"sys/common/mod.rs\"] mod sys_common;\n@@ -285,8 +283,9 @@ pub mod sync;\n pub mod rt;\n mod panicking;\n \n-// Documentation for primitive types\n+// Modules that exist purely to document + host impl docs for primitive types\n \n+mod array;\n mod bool;\n mod unit;\n mod tuple;\n@@ -305,7 +304,7 @@ mod std {\n     pub use rt; // used for panic!()\n     pub use vec; // used for vec![]\n     pub use cell; // used for tls!\n-    pub use thread_local; // used for thread_local!\n+    pub use thread; // used for thread_local!\n     pub use marker;  // used for tls!\n     pub use ops; // used for bitflags!\n "}, {"sha": "1681ed4282f48c9e2fa767e1868ab82674084aea", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -90,8 +90,7 @@ macro_rules! println {\n }\n \n /// Helper macro for unwrapping `Result` values while returning early with an\n-/// error if the value of the expression is `Err`. For more information, see\n-/// `std::io`.\n+/// error if the value of the expression is `Err`.\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! try {\n@@ -112,6 +111,7 @@ macro_rules! try {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(std_misc)]\n /// use std::thread;\n /// use std::sync::mpsc;\n ///"}, {"sha": "e8187dc2c402720453e8083195224bb6f4010d25", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -263,6 +263,7 @@ impl hash::Hash for SocketAddrV6 {\n /// Some examples:\n ///\n /// ```no_run\n+/// # #![feature(net)]\n /// use std::net::{SocketAddrV4, TcpStream, UdpSocket, TcpListener, Ipv4Addr};\n ///\n /// fn main() {"}, {"sha": "d737ad17ff8ecf7220cdb3d894b735ef3246b151", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -374,7 +374,6 @@ impl fmt::Display for Ipv6Addr {\n                             .iter()\n                             .map(|&seg| format!(\"{:x}\", seg))\n                             .collect::<Vec<String>>()\n-                            .as_slice()\n                             .connect(\":\")\n                     }\n "}, {"sha": "48b3247f2127abd143646e0243add745cb9129bd", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -91,6 +91,7 @@ impl Iterator for LookupHost {\n /// # Examples\n ///\n /// ```no_run\n+/// # #![feature(net)]\n /// use std::net;\n ///\n /// # fn foo() -> std::io::Result<()> {"}, {"sha": "869faa795f9c3fb1c0cd506578ac26cc67360bb4", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -27,6 +27,7 @@ use sys_common::AsInner;\n /// # Examples\n ///\n /// ```no_run\n+/// # #![feature(net)]\n /// use std::io::prelude::*;\n /// use std::net::TcpStream;\n ///\n@@ -46,6 +47,7 @@ pub struct TcpStream(net_imp::TcpStream);\n /// # Examples\n ///\n /// ```no_run\n+/// # #![feature(net)]\n /// use std::net::{TcpListener, TcpStream};\n /// use std::thread;\n ///"}, {"sha": "e593bbe8e489b526e67eb1e94da25dd25c9d378d", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -27,6 +27,7 @@ use sys_common::AsInner;\n /// # Examples\n ///\n /// ```no_run\n+/// # #![feature(net)]\n /// use std::net::UdpSocket;\n ///\n /// # fn foo() -> std::io::Result<()> {"}, {"sha": "a4f06f14d49df4d77a0a5de8f190d2d5928281c9", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -365,6 +365,7 @@ impl f32 {\n     /// Returns the `NaN` value.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let nan: f32 = Float::nan();\n@@ -379,6 +380,7 @@ impl f32 {\n     /// Returns the infinite value.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f32;\n     ///\n@@ -396,6 +398,7 @@ impl f32 {\n     /// Returns the negative infinite value.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f32;\n     ///\n@@ -413,6 +416,7 @@ impl f32 {\n     /// Returns `0.0`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let inf: f32 = Float::infinity();\n@@ -431,6 +435,7 @@ impl f32 {\n     /// Returns `-0.0`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let inf: f32 = Float::infinity();\n@@ -449,6 +454,7 @@ impl f32 {\n     /// Returns `1.0`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let one: f32 = Float::one();\n@@ -525,6 +531,7 @@ impl f32 {\n     /// Returns the smallest finite value that this type can represent.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -548,6 +555,7 @@ impl f32 {\n     /// Returns the largest finite value that this type can represent.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -563,6 +571,7 @@ impl f32 {\n     /// Returns `true` if this value is `NaN` and false otherwise.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -580,6 +589,7 @@ impl f32 {\n     /// false otherwise.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f32;\n     ///\n@@ -601,6 +611,7 @@ impl f32 {\n     /// Returns `true` if this number is neither infinite nor `NaN`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f32;\n     ///\n@@ -623,6 +634,7 @@ impl f32 {\n     /// [subnormal][subnormal], or `NaN`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f32;\n     ///\n@@ -650,6 +662,7 @@ impl f32 {\n     /// predicate instead.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::{Float, FpCategory};\n     /// use std::f32;\n     ///\n@@ -668,6 +681,7 @@ impl f32 {\n     /// The floating point encoding is documented in the [Reference][floating-point].\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let num = 2.0f32;\n@@ -770,6 +784,7 @@ impl f32 {\n     /// number is `Float::nan()`.\n     ///\n     /// ```\n+    /// # #![feature(core, std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -795,6 +810,7 @@ impl f32 {\n     /// - `Float::nan()` if the number is `Float::nan()`\n     ///\n     /// ```\n+    /// # #![feature(core, std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -856,6 +872,7 @@ impl f32 {\n     /// a separate multiplication operation followed by an add.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let m = 10.0;\n@@ -875,6 +892,7 @@ impl f32 {\n     /// Take the reciprocal (inverse) of a number, `1/x`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 2.0;\n@@ -922,6 +940,7 @@ impl f32 {\n     /// Returns NaN if `self` is a negative number.\n     ///\n     /// ```\n+    /// # #![feature(core, std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let positive = 4.0;\n@@ -940,6 +959,7 @@ impl f32 {\n     /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let f = 4.0;\n@@ -1061,6 +1081,7 @@ impl f32 {\n     /// Convert radians to degrees.\n     ///\n     /// ```\n+    /// # #![feature(std_misc, core)]\n     /// use std::num::Float;\n     /// use std::f64::consts;\n     ///\n@@ -1077,6 +1098,7 @@ impl f32 {\n     /// Convert degrees to radians.\n     ///\n     /// ```\n+    /// # #![feature(std_misc, core)]\n     /// use std::num::Float;\n     /// use std::f64::consts;\n     ///\n@@ -1093,6 +1115,7 @@ impl f32 {\n     /// Constructs a floating point number of `x*2^exp`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// // 3*2^2 - 12 == 0\n@@ -1114,6 +1137,7 @@ impl f32 {\n     ///  * `0.5 <= abs(x) < 1.0`\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 4.0;\n@@ -1141,6 +1165,7 @@ impl f32 {\n     /// `other`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 1.0f32;\n@@ -1194,6 +1219,7 @@ impl f32 {\n     /// * Else: `self - other`\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 3.0;\n@@ -1214,6 +1240,7 @@ impl f32 {\n     /// Take the cubic root of a number.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 8.0;\n@@ -1233,6 +1260,7 @@ impl f32 {\n     /// legs of length `x` and `y`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 2.0;\n@@ -1253,6 +1281,7 @@ impl f32 {\n     /// Computes the sine of a number (in radians).\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1271,6 +1300,7 @@ impl f32 {\n     /// Computes the cosine of a number (in radians).\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1289,6 +1319,7 @@ impl f32 {\n     /// Computes the tangent of a number (in radians).\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1308,6 +1339,7 @@ impl f32 {\n     /// [-1, 1].\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1329,6 +1361,7 @@ impl f32 {\n     /// [-1, 1].\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1372,6 +1405,7 @@ impl f32 {\n     /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1401,6 +1435,7 @@ impl f32 {\n     /// `(sin(x), cos(x))`.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1423,6 +1458,7 @@ impl f32 {\n     /// number is close to zero.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 7.0;\n@@ -1442,6 +1478,7 @@ impl f32 {\n     /// the operations were performed separately.\n     ///\n     /// ```\n+    /// # #![feature(std_misc, core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1461,6 +1498,7 @@ impl f32 {\n     /// Hyperbolic sine function.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1483,6 +1521,7 @@ impl f32 {\n     /// Hyperbolic cosine function.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1505,6 +1544,7 @@ impl f32 {\n     /// Hyperbolic tangent function.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1527,6 +1567,7 @@ impl f32 {\n     /// Inverse hyperbolic sine function.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     ///\n     /// let x = 1.0;\n@@ -1548,6 +1589,7 @@ impl f32 {\n     /// Inverse hyperbolic cosine function.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     ///\n     /// let x = 1.0;\n@@ -1569,6 +1611,7 @@ impl f32 {\n     /// Inverse hyperbolic tangent function.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///"}, {"sha": "9306804d1f787aa34f8345fd5595ffa4da96bf7f", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -374,6 +374,7 @@ impl f64 {\n     /// Returns the `NaN` value.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let nan: f32 = Float::nan();\n@@ -388,6 +389,7 @@ impl f64 {\n     /// Returns the infinite value.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f32;\n     ///\n@@ -405,6 +407,7 @@ impl f64 {\n     /// Returns the negative infinite value.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f32;\n     ///\n@@ -422,6 +425,7 @@ impl f64 {\n     /// Returns `0.0`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let inf: f32 = Float::infinity();\n@@ -440,6 +444,7 @@ impl f64 {\n     /// Returns `-0.0`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let inf: f32 = Float::infinity();\n@@ -458,6 +463,7 @@ impl f64 {\n     /// Returns `1.0`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let one: f32 = Float::one();\n@@ -534,6 +540,7 @@ impl f64 {\n     /// Returns the smallest finite value that this type can represent.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -557,6 +564,7 @@ impl f64 {\n     /// Returns the largest finite value that this type can represent.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -572,6 +580,7 @@ impl f64 {\n     /// Returns `true` if this value is `NaN` and false otherwise.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -589,6 +598,7 @@ impl f64 {\n     /// false otherwise.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f32;\n     ///\n@@ -610,6 +620,7 @@ impl f64 {\n     /// Returns `true` if this number is neither infinite nor `NaN`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f32;\n     ///\n@@ -632,6 +643,7 @@ impl f64 {\n     /// [subnormal][subnormal], or `NaN`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f32;\n     ///\n@@ -659,6 +671,7 @@ impl f64 {\n     /// predicate instead.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::{Float, FpCategory};\n     /// use std::f32;\n     ///\n@@ -677,6 +690,7 @@ impl f64 {\n     /// The floating point encoding is documented in the [Reference][floating-point].\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let num = 2.0f32;\n@@ -779,6 +793,7 @@ impl f64 {\n     /// number is `Float::nan()`.\n     ///\n     /// ```\n+    /// # #![feature(core, std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -804,6 +819,7 @@ impl f64 {\n     /// - `Float::nan()` if the number is `Float::nan()`\n     ///\n     /// ```\n+    /// # #![feature(core, std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -865,6 +881,7 @@ impl f64 {\n     /// a separate multiplication operation followed by an add.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let m = 10.0;\n@@ -884,6 +901,7 @@ impl f64 {\n     /// Take the reciprocal (inverse) of a number, `1/x`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 2.0;\n@@ -931,6 +949,7 @@ impl f64 {\n     /// Returns NaN if `self` is a negative number.\n     ///\n     /// ```\n+    /// # #![feature(core, std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let positive = 4.0;\n@@ -948,6 +967,7 @@ impl f64 {\n     /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let f = 4.0;\n@@ -1069,6 +1089,7 @@ impl f64 {\n     /// Convert radians to degrees.\n     ///\n     /// ```\n+    /// # #![feature(std_misc, core)]\n     /// use std::num::Float;\n     /// use std::f64::consts;\n     ///\n@@ -1085,6 +1106,7 @@ impl f64 {\n     /// Convert degrees to radians.\n     ///\n     /// ```\n+    /// # #![feature(std_misc, core)]\n     /// use std::num::Float;\n     /// use std::f64::consts;\n     ///\n@@ -1101,6 +1123,7 @@ impl f64 {\n     /// Constructs a floating point number of `x*2^exp`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// // 3*2^2 - 12 == 0\n@@ -1122,6 +1145,7 @@ impl f64 {\n     ///  * `0.5 <= abs(x) < 1.0`\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 4.0;\n@@ -1149,6 +1173,7 @@ impl f64 {\n     /// `other`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 1.0f32;\n@@ -1202,6 +1227,7 @@ impl f64 {\n     /// * Else: `self - other`\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 3.0;\n@@ -1222,6 +1248,7 @@ impl f64 {\n     /// Take the cubic root of a number.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 8.0;\n@@ -1241,6 +1268,7 @@ impl f64 {\n     /// legs of length `x` and `y`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 2.0;\n@@ -1261,6 +1289,7 @@ impl f64 {\n     /// Computes the sine of a number (in radians).\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1279,6 +1308,7 @@ impl f64 {\n     /// Computes the cosine of a number (in radians).\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1297,6 +1327,7 @@ impl f64 {\n     /// Computes the tangent of a number (in radians).\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1316,6 +1347,7 @@ impl f64 {\n     /// [-1, 1].\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1337,6 +1369,7 @@ impl f64 {\n     /// [-1, 1].\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1380,6 +1413,7 @@ impl f64 {\n     /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1409,6 +1443,7 @@ impl f64 {\n     /// `(sin(x), cos(x))`.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1431,6 +1466,7 @@ impl f64 {\n     /// number is close to zero.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 7.0;\n@@ -1450,6 +1486,7 @@ impl f64 {\n     /// the operations were performed separately.\n     ///\n     /// ```\n+    /// # #![feature(std_misc, core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1469,6 +1506,7 @@ impl f64 {\n     /// Hyperbolic sine function.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1491,6 +1529,7 @@ impl f64 {\n     /// Hyperbolic cosine function.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1513,6 +1552,7 @@ impl f64 {\n     /// Hyperbolic tangent function.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1577,6 +1617,7 @@ impl f64 {\n     /// Inverse hyperbolic tangent function.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///"}, {"sha": "b9e9433e3ee5addbd0ae3765286e817eb1bc7ba9", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -55,6 +55,7 @@ pub trait Float\n     /// Returns the `NaN` value.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let nan: f32 = Float::nan();\n@@ -67,6 +68,7 @@ pub trait Float\n     /// Returns the infinite value.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f32;\n     ///\n@@ -82,6 +84,7 @@ pub trait Float\n     /// Returns the negative infinite value.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f32;\n     ///\n@@ -97,6 +100,7 @@ pub trait Float\n     /// Returns `0.0`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let inf: f32 = Float::infinity();\n@@ -113,6 +117,7 @@ pub trait Float\n     /// Returns `-0.0`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let inf: f32 = Float::infinity();\n@@ -129,6 +134,7 @@ pub trait Float\n     /// Returns `1.0`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let one: f32 = Float::one();\n@@ -182,6 +188,7 @@ pub trait Float\n     /// Returns the smallest finite value that this type can represent.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -199,6 +206,7 @@ pub trait Float\n     /// Returns the largest finite value that this type can represent.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -211,6 +219,7 @@ pub trait Float\n     /// Returns `true` if this value is `NaN` and false otherwise.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -226,6 +235,7 @@ pub trait Float\n     /// false otherwise.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f32;\n     ///\n@@ -245,6 +255,7 @@ pub trait Float\n     /// Returns `true` if this number is neither infinite nor `NaN`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f32;\n     ///\n@@ -265,6 +276,7 @@ pub trait Float\n     /// [subnormal][subnormal], or `NaN`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f32;\n     ///\n@@ -291,6 +303,7 @@ pub trait Float\n     /// predicate instead.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::{Float, FpCategory};\n     /// use std::f32;\n     ///\n@@ -308,6 +321,7 @@ pub trait Float\n     /// The floating point encoding is documented in the [Reference][floating-point].\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let num = 2.0f32;\n@@ -399,6 +413,7 @@ pub trait Float\n     /// number is `Float::nan()`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -422,6 +437,7 @@ pub trait Float\n     /// - `Float::nan()` if the number is `Float::nan()`\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -478,6 +494,7 @@ pub trait Float\n     /// a separate multiplication operation followed by an add.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let m = 10.0;\n@@ -495,6 +512,7 @@ pub trait Float\n     /// Take the reciprocal (inverse) of a number, `1/x`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 2.0;\n@@ -537,6 +555,7 @@ pub trait Float\n     /// Returns NaN if `self` is a negative number.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let positive = 4.0;\n@@ -553,6 +572,7 @@ pub trait Float\n     /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let f = 4.0;\n@@ -662,6 +682,7 @@ pub trait Float\n     /// Convert radians to degrees.\n     ///\n     /// ```\n+    /// # #![feature(std_misc, core)]\n     /// use std::num::Float;\n     /// use std::f64::consts;\n     ///\n@@ -676,6 +697,7 @@ pub trait Float\n     /// Convert degrees to radians.\n     ///\n     /// ```\n+    /// # #![feature(std_misc, core)]\n     /// use std::num::Float;\n     /// use std::f64::consts;\n     ///\n@@ -690,6 +712,7 @@ pub trait Float\n     /// Constructs a floating point number of `x*2^exp`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// // 3*2^2 - 12 == 0\n@@ -707,6 +730,7 @@ pub trait Float\n     ///  * `0.5 <= abs(x) < 1.0`\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 4.0;\n@@ -726,6 +750,7 @@ pub trait Float\n     /// `other`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 1.0f32;\n@@ -769,6 +794,7 @@ pub trait Float\n     /// * Else: `self - other`\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 3.0;\n@@ -785,6 +811,7 @@ pub trait Float\n     /// Take the cubic root of a number.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 8.0;\n@@ -800,6 +827,7 @@ pub trait Float\n     /// legs of length `x` and `y`.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 2.0;\n@@ -817,6 +845,7 @@ pub trait Float\n     /// Computes the sine of a number (in radians).\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -831,6 +860,7 @@ pub trait Float\n     /// Computes the cosine of a number (in radians).\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -845,6 +875,7 @@ pub trait Float\n     /// Computes the tangent of a number (in radians).\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -860,6 +891,7 @@ pub trait Float\n     /// [-1, 1].\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -877,6 +909,7 @@ pub trait Float\n     /// [-1, 1].\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -912,6 +945,7 @@ pub trait Float\n     /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -937,6 +971,7 @@ pub trait Float\n     /// `(sin(x), cos(x))`.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -956,6 +991,7 @@ pub trait Float\n     /// number is close to zero.\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::num::Float;\n     ///\n     /// let x = 7.0;\n@@ -971,6 +1007,7 @@ pub trait Float\n     /// the operations were performed separately.\n     ///\n     /// ```\n+    /// # #![feature(std_misc, core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -987,6 +1024,7 @@ pub trait Float\n     /// Hyperbolic sine function.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1005,6 +1043,7 @@ pub trait Float\n     /// Hyperbolic cosine function.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1023,6 +1062,7 @@ pub trait Float\n     /// Hyperbolic tangent function.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///\n@@ -1069,6 +1109,7 @@ pub trait Float\n     /// Inverse hyperbolic tangent function.\n     ///\n     /// ```\n+    /// # #![feature(core)]\n     /// use std::num::Float;\n     /// use std::f64;\n     ///"}, {"sha": "cb67d709a143ab6d289a8750ef65768cb28e302f", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -33,6 +33,7 @@ use vec::Vec;\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io, old_path)]\n /// use std::old_io::*;\n /// use std::old_path::Path;\n ///\n@@ -137,6 +138,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io, old_path)]\n /// use std::old_io::*;\n /// use std::old_path::Path;\n ///\n@@ -324,6 +326,7 @@ impl<W: Reader> Reader for InternalBufferedWriter<W> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io, old_path)]\n /// # #![allow(unused_must_use)]\n /// use std::old_io::*;\n /// use std::old_path::Path;"}, {"sha": "cd8252540dacce9eaa1ccc4445856479e4e27b45", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -23,6 +23,7 @@ use vec::Vec;\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io)]\n /// use std::sync::mpsc::channel;\n /// use std::old_io::*;\n ///\n@@ -114,6 +115,7 @@ impl Reader for ChanReader {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io, io)]\n /// # #![allow(unused_must_use)]\n /// use std::sync::mpsc::channel;\n /// use std::old_io::*;"}, {"sha": "5b1b9471b075c5247e9a8a5338a8970684ff31e8", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -159,7 +159,7 @@ pub fn u64_to_be_bytes<T, F>(n: u64, size: uint, f: F) -> T where\n ///           that many bytes are parsed. For example, if `size` is 4, then a\n ///           32-bit value is parsed.\n pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n-    use ptr::{copy_nonoverlapping_memory};\n+    use ptr::{copy_nonoverlapping};\n \n     assert!(size <= 8);\n \n@@ -171,7 +171,7 @@ pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n     unsafe {\n         let ptr = data.as_ptr().offset(start as int);\n         let out = buf.as_mut_ptr();\n-        copy_nonoverlapping_memory(out.offset((8 - size) as int), ptr, size);\n+        copy_nonoverlapping(out.offset((8 - size) as int), ptr, size);\n         (*(out as *const u64)).to_be()\n     }\n }"}, {"sha": "40a7cce81dd01ebb8b85c7e481f30d0848612084", "filename": "src/libstd/old_io/fs.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -30,6 +30,7 @@\n //! # Examples\n //!\n //! ```rust\n+//! # #![feature(old_io, io, old_path)]\n //! # #![allow(unused_must_use)]\n //! use std::old_io::fs::PathExtensions;\n //! use std::old_io::*;\n@@ -105,6 +106,7 @@ impl File {\n     /// # Examples\n     ///\n     /// ```rust,should_fail\n+    /// # #![feature(old_io, old_path)]\n     /// use std::old_io::*;\n     /// use std::old_path::Path;\n     ///\n@@ -177,6 +179,7 @@ impl File {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_io, old_path)]\n     /// use std::old_io::*;\n     /// use std::old_path::Path;\n     ///\n@@ -197,6 +200,7 @@ impl File {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_io, old_path, io)]\n     /// # #![allow(unused_must_use)]\n     /// use std::old_io::*;\n     /// use std::old_path::Path;\n@@ -289,6 +293,7 @@ impl File {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io, old_path)]\n /// # #![allow(unused_must_use)]\n /// use std::old_io::*;\n /// use std::old_path::Path;\n@@ -321,6 +326,7 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io, old_path)]\n /// use std::old_io::*;\n /// use std::old_path::Path;\n ///\n@@ -364,6 +370,7 @@ pub fn lstat(path: &Path) -> IoResult<FileStat> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io, old_path)]\n /// # #![allow(unused_must_use)]\n /// use std::old_io::*;\n /// use std::old_path::Path;\n@@ -393,6 +400,7 @@ pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io, old_path)]\n /// # #![allow(unused_must_use)]\n /// use std::old_io::*;\n /// use std::old_path::Path;\n@@ -444,6 +452,7 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io, old_path)]\n /// # #![allow(unused_must_use)]\n /// use std::old_io;\n /// use std::old_io::*;\n@@ -516,6 +525,7 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io, old_path, old_fs)]\n /// # #![allow(unused_must_use)]\n /// use std::old_io;\n /// use std::old_io::*;\n@@ -541,6 +551,7 @@ pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io, old_path)]\n /// # #![allow(unused_must_use)]\n /// use std::old_io::*;\n /// use std::old_path::Path;\n@@ -566,6 +577,7 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io, old_path)]\n /// use std::old_io::fs::PathExtensions;\n /// use std::old_io;\n /// use std::old_io::*;"}, {"sha": "d877a60b079d7f6c8b8e1f2986c6055ea1d22f67", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -54,6 +54,7 @@ impl Writer for Vec<u8> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io, io)]\n /// # #![allow(unused_must_use)]\n /// use std::old_io::*;\n ///\n@@ -114,6 +115,7 @@ impl Writer for MemWriter {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io)]\n /// # #![allow(unused_must_use)]\n /// use std::old_io::*;\n ///\n@@ -244,6 +246,7 @@ impl<'a> Buffer for &'a [u8] {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io, io)]\n /// # #![allow(unused_must_use)]\n /// use std::old_io::*;\n ///\n@@ -316,6 +319,7 @@ impl<'a> Seek for BufWriter<'a> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io)]\n /// # #![allow(unused_must_use)]\n /// use std::old_io::*;\n ///"}, {"sha": "ac908c529dca661b0a6c2b70e59932919ff663ba", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -48,6 +48,7 @@\n //! * Read lines from stdin\n //!\n //!     ```rust\n+//!     # #![feature(old_io, old_path)]\n //!     use std::old_io as io;\n //!     use std::old_io::*;\n //!\n@@ -60,6 +61,7 @@\n //! * Read a complete file\n //!\n //!     ```rust\n+//!     # #![feature(old_io, old_path)]\n //!     use std::old_io::*;\n //!     use std::old_path::Path;\n //!\n@@ -69,6 +71,7 @@\n //! * Write a line to a file\n //!\n //!     ```rust\n+//!     # #![feature(old_io, old_path)]\n //!     # #![allow(unused_must_use)]\n //!     use std::old_io::*;\n //!     use std::old_path::Path;\n@@ -82,6 +85,7 @@\n //! * Iterate over the lines of a file\n //!\n //!     ```rust,no_run\n+//!     # #![feature(old_io, old_path)]\n //!     use std::old_io::*;\n //!     use std::old_path::Path;\n //!\n@@ -95,6 +99,7 @@\n //! * Pull the lines of a file into a vector of strings\n //!\n //!     ```rust,no_run\n+//!     # #![feature(old_io, old_path)]\n //!     use std::old_io::*;\n //!     use std::old_path::Path;\n //!\n@@ -106,6 +111,7 @@\n //! * Make a simple TCP client connection and request\n //!\n //!     ```rust\n+//!     # #![feature(old_io)]\n //!     # #![allow(unused_must_use)]\n //!     use std::old_io::*;\n //!\n@@ -122,6 +128,7 @@\n //! * Make a simple TCP server\n //!\n //!     ```rust\n+//!     # #![feature(old_io)]\n //!     # fn main() { }\n //!     # fn foo() {\n //!     # #![allow(dead_code)]\n@@ -186,6 +193,7 @@\n //! If you wanted to handle the error though you might write:\n //!\n //! ```rust\n+//! # #![feature(old_io, old_path)]\n //! # #![allow(unused_must_use)]\n //! use std::old_io::*;\n //! use std::old_path::Path;\n@@ -221,6 +229,7 @@\n //! If you wanted to read several `u32`s from a file and return their product:\n //!\n //! ```rust\n+//! # #![feature(old_io, old_path)]\n //! use std::old_io::*;\n //! use std::old_path::Path;\n //!\n@@ -948,6 +957,7 @@ unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io)]\n /// use std::old_io as io;\n /// use std::old_io::*;\n /// use std::old_io::util::LimitReader;\n@@ -1282,6 +1292,7 @@ impl<'a> Writer for &'a mut (Writer+'a) {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io)]\n /// use std::old_io::util::TeeReader;\n /// use std::old_io::*;\n ///\n@@ -1407,6 +1418,7 @@ pub trait Buffer: Reader {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_io)]\n     /// use std::old_io::*;\n     ///\n     /// let mut reader = BufReader::new(b\"hello\\nworld\");\n@@ -1631,6 +1643,7 @@ impl<'a, T, A: ?Sized + Acceptor<T>> Iterator for IncomingConnections<'a, A> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io)]\n /// use std::old_io as io;\n ///\n /// let eof = io::standard_error(io::EndOfFile);\n@@ -1719,6 +1732,7 @@ pub enum FileType {\n /// # Examples\n ///\n /// ```no_run\n+/// # #![feature(old_io, old_path)]\n ///\n /// use std::old_io::fs::PathExtensions;\n /// use std::old_path::Path;"}, {"sha": "f7953ac51b8e63e74146211226cb64399b8e7477", "filename": "src/libstd/old_io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -414,6 +414,7 @@ pub struct ParseError;\n /// Some examples:\n ///\n /// ```rust,no_run\n+/// # #![feature(old_io, core)]\n /// # #![allow(unused_must_use)]\n ///\n /// use std::old_io::{TcpStream, TcpListener};"}, {"sha": "f9e5ae71e12e5b737e7d92a62b3c17ba70e7077d", "filename": "src/libstd/old_io/net/pipe.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -54,6 +54,7 @@ impl UnixStream {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_io, old_path, io)]\n     /// # #![allow(unused_must_use)]\n     /// use std::old_io::net::pipe::UnixStream;\n     /// use std::old_io::*;\n@@ -181,6 +182,7 @@ impl UnixListener {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_io, io, old_path)]\n     /// # fn foo() {\n     /// use std::old_io::net::pipe::UnixListener;\n     /// use std::old_io::*;"}, {"sha": "75f786f0bb1e4d7271f4d5d312adabbecb116f58", "filename": "src/libstd/old_io/net/tcp.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -41,6 +41,7 @@ use sys_common;\n /// # Examples\n ///\n /// ```no_run\n+/// # #![feature(old_io, io)]\n /// use std::old_io::*;\n ///\n /// {\n@@ -133,6 +134,7 @@ impl TcpStream {\n     /// # Examples\n     ///\n     /// ```no_run\n+    /// # #![feature(old_io, std_misc)]\n     /// # #![allow(unused_must_use)]\n     /// use std::old_io::*;\n     /// use std::time::Duration;\n@@ -278,6 +280,7 @@ impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io)]\n /// # fn foo() {\n /// use std::old_io::*;\n /// use std::thread;\n@@ -374,6 +377,7 @@ impl TcpAcceptor {\n     /// # Examples\n     ///\n     /// ```no_run\n+    /// # #![feature(old_io, io)]\n     /// use std::old_io::*;\n     ///\n     /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n@@ -417,6 +421,7 @@ impl TcpAcceptor {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_io, io)]\n     /// use std::old_io::*;\n     /// use std::thread;\n     ///"}, {"sha": "3aa811974b3aa965364da836c355e9a5694a9516", "filename": "src/libstd/old_io/net/udp.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -31,6 +31,7 @@ use sys_common;\n /// # Examples\n ///\n /// ```rust,no_run\n+/// # #![feature(old_io)]\n /// # #![allow(unused_must_use)]\n ///\n /// use std::old_io::net::udp::UdpSocket;"}, {"sha": "0b555e2f0ff7e9c5eed72f11e3f135cc6c71070e", "filename": "src/libstd/old_io/pipe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fpipe.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -46,6 +46,7 @@ impl PipeStream {\n     /// # Examples\n     ///\n     /// ```{rust,no_run}\n+    /// # #![feature(old_io, libc, io)]\n     /// # #![allow(unused_must_use)]\n     /// extern crate libc;\n     ///"}, {"sha": "d7ede451fb8b79460b3916374ac59b4de9aad267", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -61,6 +61,7 @@ use thread;\n /// # Examples\n ///\n /// ```should_fail\n+/// # #![feature(old_io)]\n /// use std::old_io::*;\n ///\n /// let mut child = match Command::new(\"/bin/cat\").arg(\"file.txt\").spawn() {\n@@ -164,6 +165,7 @@ pub type EnvMap = HashMap<EnvKey, CString>;\n /// to be changed (for example, by adding arguments) prior to spawning:\n ///\n /// ```\n+/// # #![feature(old_io)]\n /// use std::old_io::*;\n ///\n /// let mut process = match Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").spawn() {\n@@ -365,6 +367,7 @@ impl Command {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_io, core)]\n     /// use std::old_io::Command;\n     ///\n     /// let output = match Command::new(\"cat\").arg(\"foot.txt\").output() {\n@@ -386,6 +389,7 @@ impl Command {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_io)]\n     /// use std::old_io::Command;\n     ///\n     /// let status = match Command::new(\"ls\").status() {\n@@ -660,6 +664,7 @@ impl Process {\n     /// # Examples\n     ///\n     /// ```no_run\n+    /// # #![feature(old_io, io)]\n     /// use std::old_io::{Command, IoResult};\n     /// use std::old_io::process::ProcessExit;\n     ///"}, {"sha": "ef811f832b394133a47b69f3591624db41ed8160", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -18,6 +18,7 @@\n //! # Examples\n //!\n //! ```rust\n+//! # #![feature(old_io)]\n //! # #![allow(unused_must_use)]\n //! use std::old_io;\n //! use std::old_io::*;\n@@ -140,6 +141,7 @@ impl StdinReader {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_io)]\n     /// use std::old_io;\n     /// use std::old_io::*;\n     ///"}, {"sha": "c0f6ddaaef7cc3e7264ea3a465e6c34fcc72bff4", "filename": "src/libstd/old_io/tempfile.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -29,6 +29,7 @@ use string::String;\n /// # Examples\n ///\n /// ```no_run\n+/// # #![feature(old_io, old_path)]\n /// use std::old_io::*;\n /// use std::old_path::{Path, GenericPath};\n ///"}, {"sha": "f8cba0444433175b02a141ed88cdd62b234b81c5", "filename": "src/libstd/old_io/timer.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_io%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftimer.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -31,6 +31,7 @@ use sys::timer::Timer as TimerImp;\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_io, std_misc)]\n /// # fn foo() {\n /// use std::old_io::Timer;\n /// use std::time::Duration;\n@@ -54,6 +55,7 @@ use sys::timer::Timer as TimerImp;\n /// the `old_io::timer` module.\n ///\n /// ```\n+/// # #![feature(old_io, std_misc)]\n /// # fn foo() {\n /// use std::old_io::timer;\n /// use std::time::Duration;\n@@ -116,6 +118,7 @@ impl Timer {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_io, std_misc)]\n     /// use std::old_io::Timer;\n     /// use std::time::Duration;\n     ///\n@@ -129,6 +132,7 @@ impl Timer {\n     /// ```\n     ///\n     /// ```\n+    /// # #![feature(old_io, std_misc)]\n     /// use std::old_io::Timer;\n     /// use std::time::Duration;\n     ///\n@@ -168,6 +172,7 @@ impl Timer {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_io, std_misc)]\n     /// use std::old_io::Timer;\n     /// use std::time::Duration;\n     ///\n@@ -187,6 +192,7 @@ impl Timer {\n     /// ```\n     ///\n     /// ```\n+    /// # #![feature(old_io, std_misc)]\n     /// use std::old_io::Timer;\n     /// use std::time::Duration;\n     ///"}, {"sha": "50bda04b5d0745c33ce30b2baab8b886e472923e", "filename": "src/libstd/old_path/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -49,6 +49,7 @@\n //! ## Examples\n //!\n //! ```rust\n+//! # #![feature(old_path, old_io)]\n //! use std::old_io::fs::PathExtensions;\n //! use std::old_path::{Path, GenericPath};\n //!\n@@ -143,6 +144,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -168,6 +170,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -191,6 +194,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -209,6 +213,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -224,6 +229,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -240,6 +246,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -259,6 +266,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -277,6 +285,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -293,6 +302,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -313,6 +323,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -329,6 +340,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -349,6 +361,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -377,6 +390,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -398,6 +412,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -426,6 +441,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -445,6 +461,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -472,6 +489,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -523,6 +541,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -549,6 +568,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -574,6 +594,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -594,6 +615,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -610,6 +632,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -635,6 +658,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -665,6 +689,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -683,6 +708,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -709,6 +735,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -732,6 +759,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -750,6 +778,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -769,6 +798,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -789,6 +819,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}\n@@ -806,6 +837,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// # foo();\n     /// # #[cfg(windows)] fn foo() {}"}, {"sha": "4f367e3052673eb839b7f32ff656588a2d627b01", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -605,6 +605,7 @@ impl Path {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// println!(\"{}\", Path::new(r\"C:\\some\\path\").display());\n     /// ```\n@@ -620,6 +621,7 @@ impl Path {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(old_path)]\n     /// use std::old_path::{Path, GenericPath};\n     /// let path = Path::new_opt(r\"C:\\some\\path\");\n     ///"}, {"sha": "40aaea7aca0b796b98504c164bc8c35e373e393b", "filename": "src/libstd/os.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -38,6 +38,7 @@ use self::MapError::*;\n \n use boxed::Box;\n use clone::Clone;\n+use convert::From;\n use env;\n use error::{FromError, Error};\n use ffi::{OsString, OsStr};\n@@ -79,12 +80,12 @@ fn err2old(new: ::io::Error) -> IoError {\n \n #[cfg(windows)]\n fn path2new(path: &Path) -> PathBuf {\n-    PathBuf::new(path.as_str().unwrap())\n+    PathBuf::from(path.as_str().unwrap())\n }\n #[cfg(unix)]\n fn path2new(path: &Path) -> PathBuf {\n     use os::unix::prelude::*;\n-    PathBuf::new(<OsStr as OsStrExt>::from_bytes(path.as_vec()))\n+    PathBuf::from(<OsStr as OsStrExt>::from_bytes(path.as_vec()))\n }\n \n #[cfg(unix)]\n@@ -125,6 +126,7 @@ pub const TMPBUF_SZ : uint = 1000;\n /// # Examples\n ///\n /// ```\n+/// # #![feature(os, old_path)]\n /// use std::os;\n /// use std::old_path::{Path, GenericPath};\n ///\n@@ -146,6 +148,7 @@ pub fn getcwd() -> IoResult<Path> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(os)]\n /// use std::os;\n ///\n /// // We will iterate through the references to the element returned by os::env();\n@@ -182,6 +185,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>, Vec<u8>)> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(os)]\n /// use std::os;\n ///\n /// let key = \"HOME\";\n@@ -224,6 +228,7 @@ fn byteify(s: OsString) -> Vec<u8> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(os)]\n /// use std::os;\n ///\n /// let key = \"KEY\";\n@@ -265,6 +270,7 @@ pub fn unsetenv(n: &str) {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(old_path, os)]\n /// use std::os;\n /// use std::old_path::{Path, GenericPath};\n ///\n@@ -298,6 +304,7 @@ pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(os, old_path, core)]\n /// use std::os;\n /// use std::old_path::Path;\n ///\n@@ -359,6 +366,7 @@ pub fn dll_filename(base: &str) -> String {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(os, old_path)]\n /// use std::os;\n /// use std::old_path::{Path, GenericPath};\n ///\n@@ -380,6 +388,7 @@ pub fn self_exe_name() -> Option<Path> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(os, old_path)]\n /// use std::os;\n /// use std::old_path::{Path, GenericPath};\n ///\n@@ -410,6 +419,7 @@ pub fn self_exe_path() -> Option<Path> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(os, old_path)]\n /// use std::os;\n /// use std::old_path::{Path, GenericPath};\n ///\n@@ -501,6 +511,7 @@ pub fn tmpdir() -> Path {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(os, old_path)]\n /// use std::os;\n /// use std::old_path::{Path, GenericPath};\n ///\n@@ -533,6 +544,7 @@ pub fn make_absolute(p: &Path) -> IoResult<Path> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(os, old_path)]\n /// use std::os;\n /// use std::old_path::{Path, GenericPath};\n ///\n@@ -555,6 +567,7 @@ pub fn errno() -> i32 {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(os)]\n /// use std::os;\n ///\n /// // Same as println!(\"{}\", last_os_error());\n@@ -751,6 +764,7 @@ extern \"system\" {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(os)]\n /// use std::os;\n ///\n /// // Prints each argument on a separate line"}, {"sha": "50f79967f555ef86a707fcd4f96d798f9eb2daa9", "filename": "src/libstd/path.rs", "status": "modified", "additions": 189, "deletions": 37, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -35,9 +35,10 @@\n //! To build or modify paths, use `PathBuf`:\n //!\n //! ```rust\n+//! # #![feature(convert)]\n //! use std::path::PathBuf;\n //!\n-//! let mut path = PathBuf::new(\"c:\\\\\");\n+//! let mut path = PathBuf::from(\"c:\\\\\");\n //! path.push(\"windows\");\n //! path.push(\"system32\");\n //! path.set_extension(\"dll\");\n@@ -106,6 +107,7 @@ use cmp;\n use iter::{self, IntoIterator};\n use mem;\n use ops::{self, Deref};\n+use string::String;\n use vec::Vec;\n use fmt;\n \n@@ -527,6 +529,13 @@ impl<'a> Component<'a> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> AsRef<OsStr> for Component<'a> {\n+    fn as_ref(&self) -> &OsStr {\n+        self.as_os_str()\n+    }\n+}\n+\n /// The core iterator giving the components of a path.\n ///\n /// See the module documentation for an in-depth explanation of components and\n@@ -601,6 +610,7 @@ impl<'a> Components<'a> {\n     }\n \n     /// Extract a slice corresponding to the portion of the path remaining for iteration.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_path(&self) -> &'a Path {\n         let mut comps = self.clone();\n         if comps.front == State::Body { comps.trim_left(); }\n@@ -695,6 +705,20 @@ impl<'a> Components<'a> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> AsRef<Path> for Components<'a> {\n+    fn as_ref(&self) -> &Path {\n+        self.as_path()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> AsRef<OsStr> for Components<'a> {\n+    fn as_ref(&self) -> &OsStr {\n+        self.as_path().as_os_str()\n+    }\n+}\n+\n impl<'a> Iter<'a> {\n     /// Extract a slice corresponding to the portion of the path remaining for iteration.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -703,6 +727,20 @@ impl<'a> Iter<'a> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> AsRef<Path> for Iter<'a> {\n+    fn as_ref(&self) -> &Path {\n+        self.as_path()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> AsRef<OsStr> for Iter<'a> {\n+    fn as_ref(&self) -> &OsStr {\n+        self.as_path().as_os_str()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Iter<'a> {\n     type Item = &'a OsStr;\n@@ -855,9 +893,10 @@ impl<'a> cmp::Ord for Components<'a> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(convert)]\n /// use std::path::PathBuf;\n ///\n-/// let mut path = PathBuf::new(\"c:\\\\\");\n+/// let mut path = PathBuf::from(\"c:\\\\\");\n /// path.push(\"windows\");\n /// path.push(\"system32\");\n /// path.set_extension(\"dll\");\n@@ -873,11 +912,10 @@ impl PathBuf {\n         unsafe { mem::transmute(self) }\n     }\n \n-    /// Allocate a `PathBuf` with initial contents given by the\n-    /// argument.\n+    /// Allocate an empty `PathBuf`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new<S: AsOsStr>(s: S) -> PathBuf {\n-        PathBuf { inner: s.as_os_str().to_os_string() }\n+    pub fn new() -> PathBuf {\n+        PathBuf { inner: OsString::new() }\n     }\n \n     /// Extend `self` with `path`.\n@@ -890,8 +928,8 @@ impl PathBuf {\n     ///   replaces everything except for the prefix (if any) of `self`.\n     /// * if `path` has a prefix but no root, it replaces `self.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn push<P: AsPath>(&mut self, path: P) {\n-        let path = path.as_path();\n+    pub fn push<P: AsRef<Path>>(&mut self, path: P) {\n+        let path = path.as_ref();\n \n         // in general, a separator is needed if the rightmost byte is not a separator\n         let mut need_sep = self.as_mut_vec().last().map(|c| !is_sep_byte(*c)).unwrap_or(false);\n@@ -947,23 +985,24 @@ impl PathBuf {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(convert)]\n     /// use std::path::PathBuf;\n     ///\n-    /// let mut buf = PathBuf::new(\"/\");\n+    /// let mut buf = PathBuf::from(\"/\");\n     /// assert!(buf.file_name() == None);\n     /// buf.set_file_name(\"bar\");\n-    /// assert!(buf == PathBuf::new(\"/bar\"));\n+    /// assert!(buf == PathBuf::from(\"/bar\"));\n     /// assert!(buf.file_name().is_some());\n     /// buf.set_file_name(\"baz.txt\");\n-    /// assert!(buf == PathBuf::new(\"/baz.txt\"));\n+    /// assert!(buf == PathBuf::from(\"/baz.txt\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn set_file_name<S: AsOsStr>(&mut self, file_name: S) {\n+    pub fn set_file_name<S: AsRef<OsStr>>(&mut self, file_name: S) {\n         if self.file_name().is_some() {\n             let popped = self.pop();\n             debug_assert!(popped);\n         }\n-        self.push(file_name.as_os_str());\n+        self.push(file_name.as_ref());\n     }\n \n     /// Updates `self.extension()` to `extension`.\n@@ -973,15 +1012,15 @@ impl PathBuf {\n     /// Otherwise, returns `true`; if `self.extension()` is `None`, the extension\n     /// is added; otherwise it is replaced.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn set_extension<S: AsOsStr>(&mut self, extension: S) -> bool {\n+    pub fn set_extension<S: AsRef<OsStr>>(&mut self, extension: S) -> bool {\n         if self.file_name().is_none() { return false; }\n \n         let mut stem = match self.file_stem() {\n             Some(stem) => stem.to_os_string(),\n-            None => OsString::from_str(\"\"),\n+            None => OsString::new(),\n         };\n \n-        let extension = extension.as_os_str();\n+        let extension = extension.as_ref();\n         if os_str_as_u8_slice(extension).len() > 0 {\n             stem.push(\".\");\n             stem.push(extension);\n@@ -999,16 +1038,65 @@ impl PathBuf {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<P: AsPath> iter::FromIterator<P> for PathBuf {\n+impl<'a> From<&'a Path> for PathBuf {\n+    fn from(s: &'a Path) -> PathBuf {\n+        s.to_path_buf()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a str> for PathBuf {\n+    fn from(s: &'a str) -> PathBuf {\n+        PathBuf::from(OsString::from(s))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a String> for PathBuf {\n+    fn from(s: &'a String) -> PathBuf {\n+        PathBuf::from(OsString::from(s))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl From<String> for PathBuf {\n+    fn from(s: String) -> PathBuf {\n+        PathBuf::from(OsString::from(s))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a OsStr> for PathBuf {\n+    fn from(s: &'a OsStr) -> PathBuf {\n+        PathBuf::from(OsString::from(s))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> From<&'a OsString> for PathBuf {\n+    fn from(s: &'a OsString) -> PathBuf {\n+        PathBuf::from(s.to_os_string())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl From<OsString> for PathBuf {\n+    fn from(s: OsString) -> PathBuf {\n+        PathBuf { inner: s }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<P: AsRef<Path>> iter::FromIterator<P> for PathBuf {\n     fn from_iter<I: IntoIterator<Item = P>>(iter: I) -> PathBuf {\n-        let mut buf = PathBuf::new(\"\");\n+        let mut buf = PathBuf::new();\n         buf.extend(iter);\n         buf\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<P: AsPath> iter::Extend<P> for PathBuf {\n+impl<P: AsRef<Path>> iter::Extend<P> for PathBuf {\n     fn extend<I: IntoIterator<Item = P>>(&mut self, iter: I) {\n         for p in iter {\n             self.push(p)\n@@ -1084,12 +1172,27 @@ impl cmp::Ord for PathBuf {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<OsStr> for PathBuf {\n+    fn as_ref(&self) -> &OsStr {\n+        &self.inner[..]\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl AsOsStr for PathBuf {\n     fn as_os_str(&self) -> &OsStr {\n         &self.inner[..]\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Into<OsString> for PathBuf {\n+    fn into(self) -> OsString {\n+        self.inner\n+    }\n+}\n+\n /// A slice of a path (akin to `str`).\n ///\n /// This type supports a number of operations for inspecting a path, including\n@@ -1133,8 +1236,14 @@ impl Path {\n     ///\n     /// This is a cost-free conversion.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new<S: ?Sized + AsOsStr>(s: &S) -> &Path {\n-        unsafe { mem::transmute(s.as_os_str()) }\n+    pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &Path {\n+        unsafe { mem::transmute(s.as_ref()) }\n+    }\n+\n+    /// Yield the underlying `OsStr` slice.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn as_os_str(&self) -> &OsStr {\n+        &self.inner\n     }\n \n     /// Yield a `&str` slice if the `Path` is valid unicode.\n@@ -1156,7 +1265,7 @@ impl Path {\n     /// Convert a `Path` to an owned `PathBuf`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_path_buf(&self) -> PathBuf {\n-        PathBuf::new(self)\n+        PathBuf::from(self.inner.to_os_string())\n     }\n \n     /// A path is *absolute* if it is independent of the current directory.\n@@ -1243,23 +1352,25 @@ impl Path {\n     }\n \n     /// Returns a path that, when joined onto `base`, yields `self`.\n+    ///\n+    /// If `base` is not a prefix of `self` (i.e. `starts_with`\n+    /// returns false), then `relative_from` returns `None`.\n     #[unstable(feature = \"path_relative_from\", reason = \"see #23284\")]\n-    pub fn relative_from<'a, P: ?Sized>(&'a self, base: &'a P) -> Option<&Path> where\n-        P: AsPath\n+    pub fn relative_from<'a, P: ?Sized + AsRef<Path>>(&'a self, base: &'a P) -> Option<&Path>\n     {\n-        iter_after(self.components(), base.as_path().components()).map(|c| c.as_path())\n+        iter_after(self.components(), base.as_ref().components()).map(|c| c.as_path())\n     }\n \n     /// Determines whether `base` is a prefix of `self`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn starts_with<P: AsPath>(&self, base: P) -> bool {\n-        iter_after(self.components(), base.as_path().components()).is_some()\n+    pub fn starts_with<P: AsRef<Path>>(&self, base: P) -> bool {\n+        iter_after(self.components(), base.as_ref().components()).is_some()\n     }\n \n     /// Determines whether `child` is a suffix of `self`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn ends_with<P: AsPath>(&self, child: P) -> bool {\n-        iter_after(self.components().rev(), child.as_path().components().rev()).is_some()\n+    pub fn ends_with<P: AsRef<Path>>(&self, child: P) -> bool {\n+        iter_after(self.components().rev(), child.as_ref().components().rev()).is_some()\n     }\n \n     /// Extract the stem (non-extension) portion of `self.file()`.\n@@ -1292,7 +1403,7 @@ impl Path {\n     ///\n     /// See `PathBuf::push` for more details on what it means to adjoin a path.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn join<P: AsPath>(&self, path: P) -> PathBuf {\n+    pub fn join<P: AsRef<Path>>(&self, path: P) -> PathBuf {\n         let mut buf = self.to_path_buf();\n         buf.push(path);\n         buf\n@@ -1302,7 +1413,7 @@ impl Path {\n     ///\n     /// See `PathBuf::set_file_name` for more details.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_file_name<S: AsOsStr>(&self, file_name: S) -> PathBuf {\n+    pub fn with_file_name<S: AsRef<OsStr>>(&self, file_name: S) -> PathBuf {\n         let mut buf = self.to_path_buf();\n         buf.set_file_name(file_name);\n         buf\n@@ -1312,7 +1423,7 @@ impl Path {\n     ///\n     /// See `PathBuf::set_extension` for more details.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_extension<S: AsOsStr>(&self, extension: S) -> PathBuf {\n+    pub fn with_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf {\n         let mut buf = self.to_path_buf();\n         buf.set_extension(extension);\n         buf\n@@ -1346,6 +1457,14 @@ impl Path {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<OsStr> for Path {\n+    fn as_ref(&self) -> &OsStr {\n+        &self.inner\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n impl AsOsStr for Path {\n     fn as_os_str(&self) -> &OsStr {\n         &self.inner\n@@ -1405,17 +1524,50 @@ impl cmp::Ord for Path {\n \n /// Freely convertible to a `Path`.\n #[unstable(feature = \"std_misc\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use std::convert::AsRef<Path> instead\")]\n pub trait AsPath {\n     /// Convert to a `Path`.\n     #[unstable(feature = \"std_misc\")]\n     fn as_path(&self) -> &Path;\n }\n \n #[unstable(feature = \"std_misc\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use std::convert::AsRef<Path> instead\")]\n+#[allow(deprecated)]\n impl<T: AsOsStr + ?Sized> AsPath for T {\n     fn as_path(&self) -> &Path { Path::new(self.as_os_str()) }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<Path> for Path {\n+    fn as_ref(&self) -> &Path { self }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<Path> for OsStr {\n+    fn as_ref(&self) -> &Path { Path::new(self) }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<Path> for OsString {\n+    fn as_ref(&self) -> &Path { Path::new(self) }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<Path> for str {\n+    fn as_ref(&self) -> &Path { Path::new(self) }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<Path> for String {\n+    fn as_ref(&self) -> &Path { Path::new(self) }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<Path> for PathBuf {\n+    fn as_ref(&self) -> &Path { self }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -1512,7 +1664,7 @@ mod tests {\n \n         let static_path = Path::new(\"/home/foo\");\n         let static_cow_path: Cow<'static, Path> = static_path.into_cow();\n-        let pathbuf = PathBuf::new(\"/home/foo\");\n+        let pathbuf = PathBuf::from(\"/home/foo\");\n \n         {\n             let path: &Path = &pathbuf;\n@@ -2394,7 +2546,7 @@ mod tests {\n     pub fn test_push() {\n         macro_rules! tp(\n             ($path:expr, $push:expr, $expected:expr) => ( {\n-                let mut actual = PathBuf::new($path);\n+                let mut actual = PathBuf::from($path);\n                 actual.push($push);\n                 assert!(actual.to_str() == Some($expected),\n                         \"pushing {:?} onto {:?}: Expected {:?}, got {:?}\",\n@@ -2482,7 +2634,7 @@ mod tests {\n     pub fn test_pop() {\n         macro_rules! tp(\n             ($path:expr, $expected:expr, $output:expr) => ( {\n-                let mut actual = PathBuf::new($path);\n+                let mut actual = PathBuf::from($path);\n                 let output = actual.pop();\n                 assert!(actual.to_str() == Some($expected) && output == $output,\n                         \"popping from {:?}: Expected {:?}/{:?}, got {:?}/{:?}\",\n@@ -2536,7 +2688,7 @@ mod tests {\n     pub fn test_set_file_name() {\n         macro_rules! tfn(\n                 ($path:expr, $file:expr, $expected:expr) => ( {\n-                let mut p = PathBuf::new($path);\n+                let mut p = PathBuf::from($path);\n                 p.set_file_name($file);\n                 assert!(p.to_str() == Some($expected),\n                         \"setting file name of {:?} to {:?}: Expected {:?}, got {:?}\",\n@@ -2570,7 +2722,7 @@ mod tests {\n     pub fn test_set_extension() {\n         macro_rules! tfe(\n                 ($path:expr, $ext:expr, $expected:expr, $output:expr) => ( {\n-                let mut p = PathBuf::new($path);\n+                let mut p = PathBuf::from($path);\n                 let output = p.set_extension($ext);\n                 assert!(p.to_str() == Some($expected) && output == $output,\n                         \"setting extension of {:?} to {:?}: Expected {:?}/{:?}, got {:?}/{:?}\","}, {"sha": "6e12ac1a226592b864354231aed50703fd0f8e4f", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -29,6 +29,8 @@\n #[doc(no_inline)] pub use clone::Clone;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n+#[unstable(feature = \"convert\")]\n+#[doc(no_inline)] pub use convert::{AsRef, AsMut, Into, From};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use iter::DoubleEndedIterator;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -40,8 +42,10 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use result::Result::{self, Ok, Err};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n #[doc(no_inline)] pub use slice::{SliceConcatExt, AsSlice};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n #[doc(no_inline)] pub use str::Str;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use string::{String, ToString};"}, {"sha": "553412c83712f6dcf4b44c275f62f628ef0109cc", "filename": "src/libstd/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -19,8 +19,8 @@ use io::prelude::*;\n use ffi::AsOsStr;\n use fmt;\n use io::{self, Error, ErrorKind};\n-use path::AsPath;\n use libc;\n+use path;\n use sync::mpsc::{channel, Receiver};\n use sys::pipe2::{self, AnonPipe};\n use sys::process2::Process as ProcessImp;\n@@ -198,8 +198,8 @@ impl Command {\n \n     /// Set the working directory for the child process.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn current_dir<P: AsPath>(&mut self, dir: P) -> &mut Command {\n-        self.inner.cwd(dir.as_path().as_os_str());\n+    pub fn current_dir<P: AsRef<path::Path>>(&mut self, dir: P) -> &mut Command {\n+        self.inner.cwd(dir.as_ref().as_os_str());\n         self\n     }\n \n@@ -770,7 +770,7 @@ mod tests {\n         // test changing to the parent of os::getcwd() because we know\n         // the path exists (and os::getcwd() is not expected to be root)\n         let parent_dir = os::getcwd().unwrap().dir_path();\n-        let result = pwd_cmd().current_dir(&parent_dir).output().unwrap();\n+        let result = pwd_cmd().current_dir(parent_dir.as_str().unwrap()).output().unwrap();\n \n         let output = String::from_utf8(result.stdout).unwrap();\n         let child_dir = old_path::Path::new(output.trim());"}, {"sha": "656ca980624dcdcf9302693bbbbb11ed3e4cbae0", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -58,6 +58,7 @@\n //! # Examples\n //!\n //! ```rust\n+//! # #![feature(rand)]\n //! use std::rand;\n //! use std::rand::Rng;\n //!\n@@ -68,6 +69,7 @@\n //! ```\n //!\n //! ```rust\n+//! # #![feature(rand)]\n //! use std::rand;\n //!\n //! let tuple = rand::random::<(f64, char)>();\n@@ -92,6 +94,7 @@\n //! multiply this fraction by 4.\n //!\n //! ```\n+//! # #![feature(rand)]\n //! use std::rand;\n //! use std::rand::distributions::{IndependentSample, Range};\n //!\n@@ -134,6 +137,7 @@\n //! [Monty Hall Problem]: http://en.wikipedia.org/wiki/Monty_Hall_problem\n //!\n //! ```\n+//! # #![feature(rand)]\n //! use std::rand;\n //! use std::rand::Rng;\n //! use std::rand::distributions::{IndependentSample, Range};\n@@ -384,6 +388,7 @@ impl Rng for ThreadRng {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(rand)]\n /// use std::rand;\n ///\n /// let x: u8 = rand::random();\n@@ -400,6 +405,7 @@ impl Rng for ThreadRng {\n /// Caching the thread local random number generator:\n ///\n /// ```\n+/// # #![feature(rand)]\n /// use std::rand;\n /// use std::rand::Rng;\n ///\n@@ -427,6 +433,7 @@ pub fn random<T: Rand>() -> T {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(rand)]\n /// use std::rand::{thread_rng, sample};\n ///\n /// let mut rng = thread_rng();"}, {"sha": "d3a8fa864fce39a0594f26cba18ffaba1dcb1cbb", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -24,6 +24,7 @@ use result::Result::{Ok, Err};\n /// # Examples\n ///\n /// ```\n+/// # #![feature(rand, old_io)]\n /// use std::rand::{reader, Rng};\n /// use std::old_io::MemReader;\n ///"}, {"sha": "69c5267ab69fccdbddf013277216c831b26d6170", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -69,6 +69,7 @@ pub struct Condvar { inner: Box<StaticCondvar> }\n /// # Examples\n ///\n /// ```\n+/// # #![feature(std_misc)]\n /// use std::sync::{StaticCondvar, CONDVAR_INIT};\n ///\n /// static CVAR: StaticCondvar = CONDVAR_INIT;"}, {"sha": "3c7fecb75153a9913473ff92f45cb835181a9497", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,7 @@\n //! # Examples\n //!\n //! ```\n+//! # #![feature(std_misc)]\n //! use std::sync::Future;\n //!\n //! // a fake, for now"}, {"sha": "7adfd9154acf86bae7f5d19812de347d3b848bf1", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -119,6 +119,7 @@\n //! after 10 seconds no matter what:\n //!\n //! ```no_run\n+//! # #![feature(std_misc, old_io)]\n //! use std::sync::mpsc::channel;\n //! use std::old_io::timer::Timer;\n //! use std::time::Duration;\n@@ -143,6 +144,7 @@\n //! has been inactive for 5 seconds:\n //!\n //! ```no_run\n+//! # #![feature(std_misc, old_io)]\n //! use std::sync::mpsc::channel;\n //! use std::old_io::timer::Timer;\n //! use std::time::Duration;\n@@ -977,7 +979,7 @@ impl<T> fmt::Display for SendError<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> error::Error for SendError<T> {\n+impl<T: Send> error::Error for SendError<T> {\n \n     fn description(&self) -> &str {\n         \"sending on a closed channel\"\n@@ -1013,7 +1015,7 @@ impl<T> fmt::Display for TrySendError<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> error::Error for TrySendError<T> {\n+impl<T: Send> error::Error for TrySendError<T> {\n \n     fn description(&self) -> &str {\n         match *self {"}, {"sha": "0f936641cdc75bb5081f3bf63a09b3d9e8e58f39", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -27,6 +27,7 @@\n //! # Examples\n //!\n //! ```rust\n+//! # #![feature(std_misc)]\n //! use std::sync::mpsc::channel;\n //!\n //! let (tx1, rx1) = channel();\n@@ -119,6 +120,7 @@ impl Select {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(std_misc)]\n     /// use std::sync::mpsc::Select;\n     ///\n     /// let select = Select::new();"}, {"sha": "2bf75cf1d3764c97ea0c89fba9e2bd206f6340f8", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -85,6 +85,7 @@ use fmt;\n /// To recover from a poisoned mutex:\n ///\n /// ```\n+/// # #![feature(std_misc)]\n /// use std::sync::{Arc, Mutex};\n /// use std::thread;\n ///\n@@ -136,6 +137,7 @@ unsafe impl<T: Send> Sync for Mutex<T> { }\n /// # Examples\n ///\n /// ```\n+/// # #![feature(std_misc)]\n /// use std::sync::{StaticMutex, MUTEX_INIT};\n ///\n /// static LOCK: StaticMutex = MUTEX_INIT;"}, {"sha": "c07c83d37f48881b041966d9c9cfbf48d82f5d8a", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -105,11 +105,11 @@ impl<T> fmt::Debug for PoisonError<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> fmt::Display for PoisonError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.description().fmt(f)\n+        \"poisoned lock: another task failed inside\".fmt(f)\n     }\n }\n \n-impl<T> Error for PoisonError<T> {\n+impl<T: Send> Error for PoisonError<T> {\n     fn description(&self) -> &str {\n         \"poisoned lock: another task failed inside\"\n     }\n@@ -161,13 +161,13 @@ impl<T> fmt::Debug for TryLockError<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> fmt::Display for TryLockError<T> {\n+impl<T: Send> fmt::Display for TryLockError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.description().fmt(f)\n     }\n }\n \n-impl<T> Error for TryLockError<T> {\n+impl<T: Send> Error for TryLockError<T> {\n     fn description(&self) -> &str {\n         match *self {\n             TryLockError::Poisoned(ref p) => p.description(),"}, {"sha": "6e94db6d7530c027a569bacbee71a9bb0b9c9401", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -77,6 +77,7 @@ unsafe impl<T: Send + Sync> Sync for RwLock<T> {}\n /// # Examples\n ///\n /// ```\n+/// # #![feature(std_misc)]\n /// use std::sync::{StaticRwLock, RW_LOCK_INIT};\n ///\n /// static LOCK: StaticRwLock = RW_LOCK_INIT;"}, {"sha": "059cce572459e61767cf4ae7235f96d6b7c77923", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -25,6 +25,7 @@ use sync::{Mutex, Condvar};\n /// # Examples\n ///\n /// ```\n+/// # #![feature(std_misc)]\n /// use std::sync::Semaphore;\n ///\n /// // Create a semaphore that represents 5 resources"}, {"sha": "51cf70e615bcc17eb1619a794b61c64ea595e37f", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -61,6 +61,7 @@ impl<'a> Drop for Sentinel<'a> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(std_misc, core)]\n /// use std::sync::TaskPool;\n /// use std::iter::AdditiveIterator;\n /// use std::sync::mpsc::channel;"}, {"sha": "90526b8f4f318faa941d26c8cdd9be788e2be001", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -15,7 +15,7 @@ use core::prelude::*;\n use cell::RefCell;\n use string::String;\n use thread::Thread;\n-use thread_local::State;\n+use thread::LocalKeyState;\n \n struct ThreadInfo {\n     stack_guard: uint,\n@@ -26,7 +26,7 @@ thread_local! { static THREAD_INFO: RefCell<Option<ThreadInfo>> = RefCell::new(N\n \n impl ThreadInfo {\n     fn with<R, F>(f: F) -> R where F: FnOnce(&mut ThreadInfo) -> R {\n-        if THREAD_INFO.state() == State::Destroyed {\n+        if THREAD_INFO.state() == LocalKeyState::Destroyed {\n             panic!(\"Use of std::thread::current() is not possible after \\\n                     the thread's local data has been destroyed\");\n         }"}, {"sha": "9f3dae34c7a4bff3a127111110fa955d335748e3", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -634,6 +634,7 @@ impl Wtf8 {\n ///\n /// Panics when `begin` and `end` do not point to code point boundaries,\n /// or point beyond the end of the string.\n+#[cfg(stage0)]\n impl ops::Index<ops::Range<usize>> for Wtf8 {\n     type Output = Wtf8;\n \n@@ -650,12 +651,36 @@ impl ops::Index<ops::Range<usize>> for Wtf8 {\n     }\n }\n \n+/// Return a slice of the given string for the byte range [`begin`..`end`).\n+///\n+/// # Panics\n+///\n+/// Panics when `begin` and `end` do not point to code point boundaries,\n+/// or point beyond the end of the string.\n+#[cfg(not(stage0))]\n+impl ops::Index<ops::Range<usize>> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, range: ops::Range<usize>) -> &Wtf8 {\n+        // is_code_point_boundary checks that the index is in [0, .len()]\n+        if range.start <= range.end &&\n+           is_code_point_boundary(self, range.start) &&\n+           is_code_point_boundary(self, range.end) {\n+            unsafe { slice_unchecked(self, range.start, range.end) }\n+        } else {\n+            slice_error_fail(self, range.start, range.end)\n+        }\n+    }\n+}\n+\n /// Return a slice of the given string from byte `begin` to its end.\n ///\n /// # Panics\n ///\n /// Panics when `begin` is not at a code point boundary,\n /// or is beyond the end of the string.\n+#[cfg(stage0)]\n impl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n     type Output = Wtf8;\n \n@@ -670,12 +695,34 @@ impl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n     }\n }\n \n+/// Return a slice of the given string from byte `begin` to its end.\n+///\n+/// # Panics\n+///\n+/// Panics when `begin` is not at a code point boundary,\n+/// or is beyond the end of the string.\n+#[cfg(not(stage0))]\n+impl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, range: ops::RangeFrom<usize>) -> &Wtf8 {\n+        // is_code_point_boundary checks that the index is in [0, .len()]\n+        if is_code_point_boundary(self, range.start) {\n+            unsafe { slice_unchecked(self, range.start, self.len()) }\n+        } else {\n+            slice_error_fail(self, range.start, self.len())\n+        }\n+    }\n+}\n+\n /// Return a slice of the given string from its beginning to byte `end`.\n ///\n /// # Panics\n ///\n /// Panics when `end` is not at a code point boundary,\n /// or is beyond the end of the string.\n+#[cfg(stage0)]\n impl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n     type Output = Wtf8;\n \n@@ -690,6 +737,28 @@ impl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n     }\n }\n \n+/// Return a slice of the given string from its beginning to byte `end`.\n+///\n+/// # Panics\n+///\n+/// Panics when `end` is not at a code point boundary,\n+/// or is beyond the end of the string.\n+#[cfg(not(stage0))]\n+impl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, range: ops::RangeTo<usize>) -> &Wtf8 {\n+        // is_code_point_boundary checks that the index is in [0, .len()]\n+        if is_code_point_boundary(self, range.end) {\n+            unsafe { slice_unchecked(self, 0, range.end) }\n+        } else {\n+            slice_error_fail(self, 0, range.end)\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl ops::Index<ops::RangeFull> for Wtf8 {\n     type Output = Wtf8;\n \n@@ -699,6 +768,16 @@ impl ops::Index<ops::RangeFull> for Wtf8 {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl ops::Index<ops::RangeFull> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, _range: ops::RangeFull) -> &Wtf8 {\n+        self\n+    }\n+}\n+\n #[inline]\n fn decode_surrogate(second_byte: u8, third_byte: u8) -> u16 {\n     // The first byte is assumed to be 0xED"}, {"sha": "202e5ddaec42bd01c77eda25d11acdba21c902fd", "filename": "src/libstd/sys/unix/fs2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -338,8 +338,7 @@ pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n         }));\n         buf.set_len(n as usize);\n     }\n-    let s: OsString = OsStringExt::from_vec(buf);\n-    Ok(PathBuf::new(&s))\n+    Ok(PathBuf::from(OsString::from_vec(buf)))\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {"}, {"sha": "6c191689255bc123ac0517fa676300ef5051f128", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -36,7 +36,7 @@ const BUF_BYTES: usize = 2048;\n const TMPBUF_SZ: usize = 128;\n \n fn bytes2path(b: &[u8]) -> PathBuf {\n-    PathBuf::new(<OsStr as OsStrExt>::from_bytes(b))\n+    PathBuf::from(<OsStr as OsStrExt>::from_bytes(b))\n }\n \n fn os2path(os: OsString) -> PathBuf {\n@@ -253,7 +253,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n         let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n         if err != 0 { return Err(io::Error::last_os_error()); }\n         v.set_len(sz as uint - 1); // chop off trailing NUL\n-        Ok(PathBuf::new(OsString::from_vec(v)))\n+        Ok(PathBuf::from(OsString::from_vec(v)))\n     }\n }\n \n@@ -466,9 +466,9 @@ pub fn page_size() -> usize {\n pub fn temp_dir() -> PathBuf {\n     getenv(\"TMPDIR\".as_os_str()).map(os2path).unwrap_or_else(|| {\n         if cfg!(target_os = \"android\") {\n-            PathBuf::new(\"/data/local/tmp\")\n+            PathBuf::from(\"/data/local/tmp\")\n         } else {\n-            PathBuf::new(\"/tmp\")\n+            PathBuf::from(\"/tmp\")\n         }\n     })\n }"}, {"sha": "eb61f21aacd5d52ee5a7c66106948e90ac835287", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -227,19 +227,16 @@ pub unsafe fn create(stack: usize, p: Thunk) -> io::Result<rust_thread> {\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n pub unsafe fn set_name(name: &str) {\n-    // pthread_setname_np() since glibc 2.12\n-    // availability autodetected via weak linkage\n-    type F = unsafe extern fn(libc::pthread_t, *const libc::c_char)\n-                              -> libc::c_int;\n+    // pthread wrapper only appeared in glibc 2.12, so we use syscall directly.\n     extern {\n-        #[linkage = \"extern_weak\"]\n-        static pthread_setname_np: *const ();\n-    }\n-    if !pthread_setname_np.is_null() {\n-        let cname = CString::new(name).unwrap();\n-        mem::transmute::<*const (), F>(pthread_setname_np)(pthread_self(),\n-                                                           cname.as_ptr());\n+        fn prctl(option: libc::c_int, arg2: libc::c_ulong, arg3: libc::c_ulong,\n+                 arg4: libc::c_ulong, arg5: libc::c_ulong) -> libc::c_int;\n     }\n+    const PR_SET_NAME: libc::c_int = 15;\n+    let cname = CString::new(name).unwrap_or_else(|_| {\n+        panic!(\"thread name may not contain interior null bytes\")\n+    });\n+    prctl(PR_SET_NAME, cname.as_ptr() as libc::c_ulong, 0, 0, 0);\n }\n \n #[cfg(any(target_os = \"freebsd\",\n@@ -314,26 +311,39 @@ pub fn sleep(dur: Duration) {\n // is created in an application with big thread-local storage requirements.\n // See #6233 for rationale and details.\n //\n-// Link weakly to the symbol for compatibility with older versions of glibc.\n-// Assumes that we've been dynamically linked to libpthread but that is\n-// currently always the case.  Note that you need to check that the symbol\n-// is non-null before calling it!\n+// Use dlsym to get the symbol value at runtime, both for\n+// compatibility with older versions of glibc, and to avoid creating\n+// dependencies on GLIBC_PRIVATE symbols.  Assumes that we've been\n+// dynamically linked to libpthread but that is currently always the\n+// case.  We previously used weak linkage (under the same assumption),\n+// but that caused Debian to detect an unnecessarily strict versioned\n+// dependency on libc6 (#23628).\n #[cfg(target_os = \"linux\")]\n fn min_stack_size(attr: *const libc::pthread_attr_t) -> libc::size_t {\n+    use dynamic_lib::DynamicLibrary;\n+    use sync::{Once, ONCE_INIT};\n+\n     type F = unsafe extern \"C\" fn(*const libc::pthread_attr_t) -> libc::size_t;\n-    extern {\n-        #[linkage = \"extern_weak\"]\n-        static __pthread_get_minstack: *const ();\n-    }\n-    if __pthread_get_minstack.is_null() {\n-        PTHREAD_STACK_MIN\n-    } else {\n-        unsafe { mem::transmute::<*const (), F>(__pthread_get_minstack)(attr) }\n+    static INIT: Once = ONCE_INIT;\n+    static mut __pthread_get_minstack: Option<F> = None;\n+\n+    INIT.call_once(|| {\n+        let lib = DynamicLibrary::open(None).unwrap();\n+        unsafe {\n+            if let Ok(f) = lib.symbol(\"__pthread_get_minstack\") {\n+                __pthread_get_minstack = Some(mem::transmute::<*const (), F>(f));\n+            }\n+        }\n+    });\n+\n+    match unsafe { __pthread_get_minstack } {\n+        None => PTHREAD_STACK_MIN,\n+        Some(f) => unsafe { f(attr) },\n     }\n }\n \n-// __pthread_get_minstack() is marked as weak but extern_weak linkage is\n-// not supported on OS X, hence this kludge...\n+// No point in looking up __pthread_get_minstack() on non-glibc\n+// platforms.\n #[cfg(not(target_os = \"linux\"))]\n fn min_stack_size(_: *const libc::pthread_attr_t) -> libc::size_t {\n     PTHREAD_STACK_MIN"}, {"sha": "998352651117bcbe99b5f9c3f54cc69b2ef3d88f", "filename": "src/libstd/sys/windows/fs2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -372,7 +372,7 @@ pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n                                   sz - 1,\n                                   libc::VOLUME_NAME_DOS)\n     }, |s| OsStringExt::from_wide(s)));\n-    Ok(PathBuf::new(&ret))\n+    Ok(PathBuf::from(&ret))\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {"}, {"sha": "b1ceac9b9025684429ad28bc8d37c90a3afeb97a", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -304,9 +304,7 @@ fn fill_utf16_buf_new<F1, F2, T>(f1: F1, f2: F2) -> io::Result<T>\n }\n \n fn os2path(s: &[u16]) -> PathBuf {\n-    let os = <OsString as OsStringExt>::from_wide(s);\n-    // FIXME(#22751) should consume `os`\n-    PathBuf::new(&os)\n+    PathBuf::from(OsString::from_wide(s))\n }\n \n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {"}, {"sha": "83d0637173444c56cb4dbb46a7dfc1f715b712a4", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -363,10 +363,7 @@ pub fn temp_dir() -> PathBuf {\n pub fn home_dir() -> Option<PathBuf> {\n     getenv(\"HOME\".as_os_str()).or_else(|| {\n         getenv(\"USERPROFILE\".as_os_str())\n-    }).map(|os| {\n-        // FIXME(#22751) should consume `os`\n-        PathBuf::new(&os)\n-    }).or_else(|| unsafe {\n+    }).map(PathBuf::from).or_else(|| unsafe {\n         let me = c::GetCurrentProcess();\n         let mut token = ptr::null_mut();\n         if c::OpenProcessToken(me, c::TOKEN_READ, &mut token) == 0 {"}, {"sha": "1bf1b09681c4a360b03232187b31610730f7200a", "filename": "src/libstd/thread/local.rs", "status": "renamed", "additions": 39, "deletions": 68, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -9,40 +9,13 @@\n // except according to those terms.\n \n //! Thread local storage\n-//!\n-//! This module provides an implementation of thread local storage for Rust\n-//! programs. Thread local storage is a method of storing data into a global\n-//! variable which each thread in the program will have its own copy of.\n-//! Threads do not share this data, so accesses do not need to be synchronized.\n-//!\n-//! At a high level, this module provides two variants of storage:\n-//!\n-//! * Owning thread local storage. This is a type of thread local key which\n-//!   owns the value that it contains, and will destroy the value when the\n-//!   thread exits. This variant is created with the `thread_local!` macro and\n-//!   can contain any value which is `'static` (no borrowed pointers.\n-//!\n-//! * Scoped thread local storage. This type of key is used to store a reference\n-//!   to a value into local storage temporarily for the scope of a function\n-//!   call. There are no restrictions on what types of values can be placed\n-//!   into this key.\n-//!\n-//! Both forms of thread local storage provide an accessor function, `with`,\n-//! which will yield a shared reference to the value to the specified\n-//! closure. Thread local keys only allow shared access to values as there is no\n-//! way to guarantee uniqueness if a mutable borrow was allowed. Most values\n-//! will want to make use of some form of **interior mutability** through the\n-//! `Cell` or `RefCell` types.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+#![unstable(feature = \"thread_local_internals\")]\n \n use prelude::v1::*;\n \n use cell::UnsafeCell;\n \n-#[macro_use]\n-pub mod scoped;\n-\n // Sure wish we had macro hygiene, no?\n #[doc(hidden)]\n #[unstable(feature = \"thread_local_internals\")]\n@@ -95,7 +68,7 @@ pub mod __impl {\n /// });\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Key<T> {\n+pub struct LocalKey<T> {\n     // The key itself may be tagged with #[thread_local], and this `Key` is\n     // stored as a `static`, and it's not valid for a static to reference the\n     // address of another thread_local static. For this reason we kinda wonkily\n@@ -114,15 +87,15 @@ pub struct Key<T> {\n     pub init: fn() -> T,\n }\n \n-/// Declare a new thread local storage key of type `std::thread_local::Key`.\n+/// Declare a new thread local storage key of type `std::thread::LocalKey`.\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable]\n macro_rules! thread_local {\n     (static $name:ident: $t:ty = $init:expr) => (\n-        static $name: ::std::thread_local::Key<$t> = {\n+        static $name: ::std::thread::LocalKey<$t> = {\n             use std::cell::UnsafeCell as __UnsafeCell;\n-            use std::thread_local::__impl::KeyInner as __KeyInner;\n+            use std::thread::__local::__impl::KeyInner as __KeyInner;\n             use std::option::Option as __Option;\n             use std::option::Option::None as __None;\n \n@@ -133,13 +106,13 @@ macro_rules! thread_local {\n             fn __getit() -> &'static __KeyInner<__UnsafeCell<__Option<$t>>> {\n                 &__KEY\n             }\n-            ::std::thread_local::Key { inner: __getit, init: __init }\n+            ::std::thread::LocalKey { inner: __getit, init: __init }\n         };\n     );\n     (pub static $name:ident: $t:ty = $init:expr) => (\n-        pub static $name: ::std::thread_local::Key<$t> = {\n+        pub static $name: ::std::thread::LocalKey<$t> = {\n             use std::cell::UnsafeCell as __UnsafeCell;\n-            use std::thread_local::__impl::KeyInner as __KeyInner;\n+            use std::thread::__local::__impl::KeyInner as __KeyInner;\n             use std::option::Option as __Option;\n             use std::option::Option::None as __None;\n \n@@ -150,7 +123,7 @@ macro_rules! thread_local {\n             fn __getit() -> &'static __KeyInner<__UnsafeCell<__Option<$t>>> {\n                 &__KEY\n             }\n-            ::std::thread_local::Key { inner: __getit, init: __init }\n+            ::std::thread::LocalKey { inner: __getit, init: __init }\n         };\n     );\n }\n@@ -183,37 +156,35 @@ macro_rules! __thread_local_inner {\n         #[cfg_attr(all(any(target_os = \"macos\", target_os = \"linux\"),\n                        not(target_arch = \"aarch64\")),\n                    thread_local)]\n-        static $name: ::std::thread_local::__impl::KeyInner<$t> =\n+        static $name: ::std::thread::__local::__impl::KeyInner<$t> =\n             __thread_local_inner!($init, $t);\n     );\n     (pub static $name:ident: $t:ty = $init:expr) => (\n         #[cfg_attr(all(any(target_os = \"macos\", target_os = \"linux\"),\n                        not(target_arch = \"aarch64\")),\n                    thread_local)]\n-        pub static $name: ::std::thread_local::__impl::KeyInner<$t> =\n+        pub static $name: ::std::thread::__local::__impl::KeyInner<$t> =\n             __thread_local_inner!($init, $t);\n     );\n     ($init:expr, $t:ty) => ({\n         #[cfg(all(any(target_os = \"macos\", target_os = \"linux\"), not(target_arch = \"aarch64\")))]\n-        const _INIT: ::std::thread_local::__impl::KeyInner<$t> = {\n-            ::std::thread_local::__impl::KeyInner {\n+        const _INIT: ::std::thread::__local::__impl::KeyInner<$t> = {\n+            ::std::thread::__local::__impl::KeyInner {\n                 inner: ::std::cell::UnsafeCell { value: $init },\n                 dtor_registered: ::std::cell::UnsafeCell { value: false },\n                 dtor_running: ::std::cell::UnsafeCell { value: false },\n             }\n         };\n \n         #[cfg(any(not(any(target_os = \"macos\", target_os = \"linux\")), target_arch = \"aarch64\"))]\n-        const _INIT: ::std::thread_local::__impl::KeyInner<$t> = {\n-            unsafe extern fn __destroy(ptr: *mut u8) {\n-                ::std::thread_local::__impl::destroy_value::<$t>(ptr);\n-            }\n-\n-            ::std::thread_local::__impl::KeyInner {\n+        const _INIT: ::std::thread::__local::__impl::KeyInner<$t> = {\n+            ::std::thread::__local::__impl::KeyInner {\n                 inner: ::std::cell::UnsafeCell { value: $init },\n-                os: ::std::thread_local::__impl::OsStaticKey {\n-                    inner: ::std::thread_local::__impl::OS_INIT_INNER,\n-                    dtor: ::std::option::Option::Some(__destroy as unsafe extern fn(*mut u8)),\n+                os: ::std::thread::__local::__impl::OsStaticKey {\n+                    inner: ::std::thread::__local::__impl::OS_INIT_INNER,\n+                    dtor: ::std::option::Option::Some(\n+                        ::std::thread::__local::__impl::destroy_value::<$t>\n+                    ),\n                 },\n             }\n         };\n@@ -226,7 +197,7 @@ macro_rules! __thread_local_inner {\n #[unstable(feature = \"std_misc\",\n            reason = \"state querying was recently added\")]\n #[derive(Eq, PartialEq, Copy)]\n-pub enum State {\n+pub enum LocalKeyState {\n     /// All keys are in this state whenever a thread starts. Keys will\n     /// transition to the `Valid` state once the first call to `with` happens\n     /// and the initialization expression succeeds.\n@@ -253,7 +224,7 @@ pub enum State {\n     Destroyed,\n }\n \n-impl<T: 'static> Key<T> {\n+impl<T: 'static> LocalKey<T> {\n     /// Acquire a reference to the value in this TLS key.\n     ///\n     /// This will lazily initialize the value if this thread has not referenced\n@@ -309,16 +280,16 @@ impl<T: 'static> Key<T> {\n     /// any call to `with`.\n     #[unstable(feature = \"std_misc\",\n                reason = \"state querying was recently added\")]\n-    pub fn state(&'static self) -> State {\n+    pub fn state(&'static self) -> LocalKeyState {\n         unsafe {\n             match (self.inner)().get() {\n                 Some(cell) => {\n                     match *cell.get() {\n-                        Some(..) => State::Valid,\n-                        None => State::Uninitialized,\n+                        Some(..) => LocalKeyState::Valid,\n+                        None => LocalKeyState::Uninitialized,\n                     }\n                 }\n-                None => State::Destroyed,\n+                None => LocalKeyState::Destroyed,\n             }\n         }\n     }\n@@ -327,7 +298,7 @@ impl<T: 'static> Key<T> {\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"function renamed to state() and returns more info\")]\n-    pub fn destroyed(&'static self) -> bool { self.state() == State::Destroyed }\n+    pub fn destroyed(&'static self) -> bool { self.state() == LocalKeyState::Destroyed }\n }\n \n #[cfg(all(any(target_os = \"macos\", target_os = \"linux\"), not(target_arch = \"aarch64\")))]\n@@ -553,7 +524,7 @@ mod tests {\n \n     use sync::mpsc::{channel, Sender};\n     use cell::UnsafeCell;\n-    use super::State;\n+    use super::LocalKeyState;\n     use thread;\n \n     struct Foo(Sender<()>);\n@@ -592,21 +563,21 @@ mod tests {\n         struct Foo;\n         impl Drop for Foo {\n             fn drop(&mut self) {\n-                assert!(FOO.state() == State::Destroyed);\n+                assert!(FOO.state() == LocalKeyState::Destroyed);\n             }\n         }\n         fn foo() -> Foo {\n-            assert!(FOO.state() == State::Uninitialized);\n+            assert!(FOO.state() == LocalKeyState::Uninitialized);\n             Foo\n         }\n         thread_local!(static FOO: Foo = foo());\n \n         thread::spawn(|| {\n-            assert!(FOO.state() == State::Uninitialized);\n+            assert!(FOO.state() == LocalKeyState::Uninitialized);\n             FOO.with(|_| {\n-                assert!(FOO.state() == State::Valid);\n+                assert!(FOO.state() == LocalKeyState::Valid);\n             });\n-            assert!(FOO.state() == State::Valid);\n+            assert!(FOO.state() == LocalKeyState::Valid);\n         }).join().ok().unwrap();\n     }\n \n@@ -642,7 +613,7 @@ mod tests {\n             fn drop(&mut self) {\n                 unsafe {\n                     HITS += 1;\n-                    if K2.state() == State::Destroyed {\n+                    if K2.state() == LocalKeyState::Destroyed {\n                         assert_eq!(HITS, 3);\n                     } else {\n                         if HITS == 1 {\n@@ -658,7 +629,7 @@ mod tests {\n             fn drop(&mut self) {\n                 unsafe {\n                     HITS += 1;\n-                    assert!(K1.state() != State::Destroyed);\n+                    assert!(K1.state() != LocalKeyState::Destroyed);\n                     assert_eq!(HITS, 2);\n                     K1.with(|s| *s.get() = Some(S1));\n                 }\n@@ -679,7 +650,7 @@ mod tests {\n \n         impl Drop for S1 {\n             fn drop(&mut self) {\n-                assert!(K1.state() == State::Destroyed);\n+                assert!(K1.state() == LocalKeyState::Destroyed);\n             }\n         }\n \n@@ -702,7 +673,7 @@ mod tests {\n             fn drop(&mut self) {\n                 let S1(ref tx) = *self;\n                 unsafe {\n-                    if K2.state() != State::Destroyed {\n+                    if K2.state() != LocalKeyState::Destroyed {\n                         K2.with(|s| *s.get() = Some(Foo(tx.clone())));\n                     }\n                 }\n@@ -745,7 +716,7 @@ mod dynamic_tests {\n         thread_local!(static FOO: RefCell<HashMap<i32, i32>> = map());\n \n         FOO.with(|map| {\n-            assert_eq!(map.borrow()[1], 2);\n+            assert_eq!(map.borrow()[&1], 2);\n         });\n     }\n ", "previous_filename": "src/libstd/thread_local/mod.rs"}, {"sha": "57baeb1fb74860a8573a47c36ae4db07b51b79c5", "filename": "src/libstd/thread/mod.rs", "status": "renamed", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -138,9 +138,43 @@\n //!   synchronization primitives; the threads already provide basic blocking/signaling.\n //!\n //! * It can be implemented very efficiently on many platforms.\n+//!\n+//! ## Thread-local storage\n+//!\n+//! This module also provides an implementation of thread local storage for Rust\n+//! programs. Thread local storage is a method of storing data into a global\n+//! variable which each thread in the program will have its own copy of.\n+//! Threads do not share this data, so accesses do not need to be synchronized.\n+//!\n+//! At a high level, this module provides two variants of storage:\n+//!\n+//! * Owned thread-local storage. This is a type of thread local key which\n+//!   owns the value that it contains, and will destroy the value when the\n+//!   thread exits. This variant is created with the `thread_local!` macro and\n+//!   can contain any value which is `'static` (no borrowed pointers).\n+//!\n+//! * Scoped thread-local storage. This type of key is used to store a reference\n+//!   to a value into local storage temporarily for the scope of a function\n+//!   call. There are no restrictions on what types of values can be placed\n+//!   into this key.\n+//!\n+//! Both forms of thread local storage provide an accessor function, `with`,\n+//! which will yield a shared reference to the value to the specified\n+//! closure. Thread-local keys only allow shared access to values as there is no\n+//! way to guarantee uniqueness if a mutable borrow was allowed. Most values\n+//! will want to make use of some form of **interior mutability** through the\n+//! `Cell` or `RefCell` types.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::__local::{LocalKey, LocalKeyState};\n+\n+#[unstable(feature = \"scoped_tls\",\n+            reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n+                      stabilizing its interface\")]\n+pub use self::__scoped::ScopedKey;\n+\n use prelude::v1::*;\n \n use any::Any;\n@@ -157,6 +191,22 @@ use time::Duration;\n \n #[allow(deprecated)] use old_io::Writer;\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Thread-local storage\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#[macro_use]\n+#[doc(hidden)]\n+#[path = \"local.rs\"] pub mod __local;\n+\n+#[macro_use]\n+#[doc(hidden)]\n+#[path = \"scoped.rs\"] pub mod __scoped;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Builder\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// Thread configuration. Provides detailed control over the properties\n /// and behavior of new threads.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -322,6 +372,10 @@ impl Builder {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Free functions\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// Spawn a new thread, returning a `JoinHandle` for it.\n ///\n /// The join handle will implicitly *detach* the child thread upon being\n@@ -433,6 +487,10 @@ pub fn park_timeout(duration: Duration) {\n     *guard = false;\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Thread\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// The internal representation of a `Thread` handle\n struct Inner {\n     name: Option<String>,\n@@ -557,6 +615,10 @@ impl thread_info::NewThread for Thread {\n     fn new(name: Option<String>) -> Thread { Thread::new(name) }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// JoinHandle and JoinGuard\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// Indicates the manner in which a thread exited.\n ///\n /// A thread that completes without panicking is considered to exit successfully.\n@@ -689,6 +751,10 @@ impl<'a, T: Send + 'a> Drop for JoinGuard<'a, T> {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Tests\n+////////////////////////////////////////////////////////////////////////////////\n+\n #[cfg(test)]\n mod test {\n     use prelude::v1::*;", "previous_filename": "src/libstd/thread.rs"}, {"sha": "b384879d7a956751daba630d1061a14a27857117", "filename": "src/libstd/thread/scoped.rs", "status": "renamed", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fthread%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibstd%2Fthread%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fscoped.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -24,6 +24,7 @@\n //! # Examples\n //!\n //! ```\n+//! # #![feature(scoped_tls)]\n //! scoped_thread_local!(static FOO: u32);\n //!\n //! // Initially each scoped slot is empty.\n@@ -38,9 +39,7 @@\n //! });\n //! ```\n \n-#![unstable(feature = \"std_misc\",\n-            reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n-                      stabilizing its interface\")]\n+#![unstable(feature = \"thread_local_internals\")]\n \n use prelude::v1::*;\n \n@@ -58,7 +57,10 @@ pub mod __impl {\n /// type `T` scoped to a particular lifetime. Keys provides two methods, `set`\n /// and `with`, both of which currently use closures to control the scope of\n /// their contents.\n-pub struct Key<T> { #[doc(hidden)] pub inner: __impl::KeyInner<T> }\n+#[unstable(feature = \"scoped_tls\",\n+           reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n+                     stabilizing its interface\")]\n+pub struct ScopedKey<T> { #[doc(hidden)] pub inner: __impl::KeyInner<T> }\n \n /// Declare a new scoped thread local storage key.\n ///\n@@ -86,7 +88,7 @@ macro_rules! __scoped_thread_local_inner {\n                            target_os = \"openbsd\",\n                            target_arch = \"aarch64\")),\n                    thread_local)]\n-        static $name: ::std::thread_local::scoped::Key<$t> =\n+        static $name: ::std::thread::ScopedKey<$t> =\n             __scoped_thread_local_inner!($t);\n     );\n     (pub static $name:ident: $t:ty) => (\n@@ -96,19 +98,19 @@ macro_rules! __scoped_thread_local_inner {\n                            target_os = \"openbsd\",\n                            target_arch = \"aarch64\")),\n                    thread_local)]\n-        pub static $name: ::std::thread_local::scoped::Key<$t> =\n+        pub static $name: ::std::thread::ScopedKey<$t> =\n             __scoped_thread_local_inner!($t);\n     );\n     ($t:ty) => ({\n-        use std::thread_local::scoped::Key as __Key;\n+        use std::thread::ScopedKey as __Key;\n \n         #[cfg(not(any(windows,\n                       target_os = \"android\",\n                       target_os = \"ios\",\n                       target_os = \"openbsd\",\n                       target_arch = \"aarch64\")))]\n         const _INIT: __Key<$t> = __Key {\n-            inner: ::std::thread_local::scoped::__impl::KeyInner {\n+            inner: ::std::thread::__scoped::__impl::KeyInner {\n                 inner: ::std::cell::UnsafeCell { value: 0 as *mut _ },\n             }\n         };\n@@ -119,8 +121,8 @@ macro_rules! __scoped_thread_local_inner {\n                   target_os = \"openbsd\",\n                   target_arch = \"aarch64\"))]\n         const _INIT: __Key<$t> = __Key {\n-            inner: ::std::thread_local::scoped::__impl::KeyInner {\n-                inner: ::std::thread_local::scoped::__impl::OS_INIT,\n+            inner: ::std::thread::__scoped::__impl::KeyInner {\n+                inner: ::std::thread::__scoped::__impl::OS_INIT,\n                 marker: ::std::marker::PhantomData::<::std::cell::Cell<$t>>,\n             }\n         };\n@@ -129,7 +131,10 @@ macro_rules! __scoped_thread_local_inner {\n     })\n }\n \n-impl<T> Key<T> {\n+#[unstable(feature = \"scoped_tls\",\n+           reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n+                     stabilizing its interface\")]\n+impl<T> ScopedKey<T> {\n     /// Insert a value into this scoped thread local storage slot for a\n     /// duration of a closure.\n     ///\n@@ -142,6 +147,7 @@ impl<T> Key<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// # #![feature(scoped_tls)]\n     /// scoped_thread_local!(static FOO: u32);\n     ///\n     /// FOO.set(&100, || {\n@@ -194,6 +200,7 @@ impl<T> Key<T> {\n     /// # Examples\n     ///\n     /// ```no_run\n+    /// # #![feature(scoped_tls)]\n     /// scoped_thread_local!(static FOO: u32);\n     ///\n     /// FOO.with(|slot| {", "previous_filename": "src/libstd/thread_local/scoped.rs"}, {"sha": "1abe8d0a3c1b1352e77100adb0f246b130981a04", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -351,8 +351,7 @@ impl Encodable for FileMap {\n                         let max_line_length = if lines.len() == 1 {\n                             0\n                         } else {\n-                            lines.as_slice()\n-                                 .windows(2)\n+                            lines.windows(2)\n                                  .map(|w| w[1] - w[0])\n                                  .map(|bp| bp.to_usize())\n                                  .max()"}, {"sha": "d8c50b5a0942ae37eeedfbad14a71ada51aa65af", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -78,14 +78,6 @@ pub mod totalord;\n \n pub mod generic;\n \n-fn expand_deprecated_deriving(cx: &mut ExtCtxt,\n-                              span: Span,\n-                              _: &MetaItem,\n-                              _: &Item,\n-                              _: &mut FnMut(P<Item>)) {\n-    cx.span_err(span, \"`deriving` has been renamed to `derive`\");\n-}\n-\n fn expand_derive(cx: &mut ExtCtxt,\n                  _: Span,\n                  mitem: &MetaItem,\n@@ -151,8 +143,6 @@ macro_rules! derive_traits {\n \n             env.insert(intern(\"derive\"),\n                        Modifier(Box::new(expand_derive)));\n-            env.insert(intern(\"deriving\"),\n-                       Decorator(Box::new(expand_deprecated_deriving)));\n         }\n \n         fn is_builtin_trait(name: &str) -> bool {"}, {"sha": "2fe77bf7a5411cbff2ed0c49a6acfeb769e32491", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -513,7 +513,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             let lname = self.ecx.ident_of(&format!(\"__arg{}\",\n                                                   *name));\n             pats.push(self.ecx.pat_ident(e.span, lname));\n-            names[self.name_positions[*name]] =\n+            names[*self.name_positions.get(name).unwrap()] =\n                 Some(Context::format_arg(self.ecx, e.span, arg_ty,\n                                          self.ecx.expr_ident(e.span, lname)));\n             heads.push(self.ecx.expr_addr_of(e.span, e));"}, {"sha": "31d8b207bb9f080134fcbc582391391b1924c726", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -194,7 +194,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n fn res_rel_file(cx: &mut ExtCtxt, sp: codemap::Span, arg: &Path) -> PathBuf {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute() {\n-        let mut cu = PathBuf::new(&cx.codemap().span_to_filename(sp));\n+        let mut cu = PathBuf::from(&cx.codemap().span_to_filename(sp));\n         cu.pop();\n         cu.push(arg);\n         cu"}, {"sha": "5940b791843797cacf97c7225dd9a413e27d74c8", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -236,7 +236,7 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n                                      argument_gram);\n \n     // Extract the arguments:\n-    let lhses = match *argument_map[lhs_nm] {\n+    let lhses = match **argument_map.get(&lhs_nm).unwrap() {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n     };\n@@ -245,7 +245,7 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n         check_lhs_nt_follows(cx, &**lhs, def.span);\n     }\n \n-    let rhses = match *argument_map[rhs_nm] {\n+    let rhses = match **argument_map.get(&rhs_nm).unwrap() {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n     };"}, {"sha": "60f81dac1e9abaf09fc2e1c7cba5c113b9030fdc", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -201,7 +201,6 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n     (\"no_mangle\", Normal),\n     (\"no_link\", Normal),\n     (\"derive\", Normal),\n-    (\"deriving\", Normal), // deprecation err in expansion\n     (\"should_fail\", Normal),\n     (\"should_panic\", Normal),\n     (\"ignore\", Normal),\n@@ -259,7 +258,6 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n     (\"link_section\", Whitelisted),\n     (\"no_builtins\", Whitelisted),\n     (\"no_mangle\", Whitelisted),\n-    (\"no_split_stack\", Whitelisted),\n     (\"no_stack_check\", Whitelisted),\n     (\"packed\", Whitelisted),\n     (\"static_assert\", Gated(\"static_assert\",\n@@ -563,6 +561,13 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n+            ast::ItemDefaultImpl(..) => {\n+                self.gate_feature(\"optin_builtin_traits\",\n+                                  i.span,\n+                                  \"default trait implementations are experimental \\\n+                                   and possibly buggy\");\n+            }\n+\n             ast::ItemImpl(_, polarity, _, _, _, _) => {\n                 match polarity {\n                     ast::ImplPolarity::Negative => {"}, {"sha": "9af7b9ab633116619c2e9ff3cc12b4ad28e5ad74", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -39,6 +39,8 @@\n #![feature(unicode)]\n #![feature(path_ext)]\n #![feature(str_char)]\n+#![feature(convert)]\n+#![feature(into_cow)]\n \n extern crate arena;\n extern crate fmt_macros;"}, {"sha": "7da0a6de5479cb7594fbd37a7f743c46c7b7ccfd", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -22,9 +22,6 @@ use ptr::P;\n /// The specific types of unsupported syntax\n #[derive(Copy, PartialEq, Eq, Hash)]\n pub enum ObsoleteSyntax {\n-    Sized,\n-    ForSized,\n-    ClosureType,\n     ClosureKind,\n     EmptyIndex,\n }\n@@ -49,27 +46,11 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n     /// Reports an obsolete syntax non-fatal error.\n     fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax) {\n         let (kind_str, desc, error) = match kind {\n-            ObsoleteSyntax::ForSized => (\n-                \"for Sized?\",\n-                \"no longer required. Traits (and their `Self` type) do not have the `Sized` bound \\\n-                 by default\",\n-                true,\n-            ),\n-            ObsoleteSyntax::ClosureType => (\n-                \"`|usize| -> bool` closure type\",\n-                \"use unboxed closures instead, no type annotation needed\",\n-                true,\n-            ),\n             ObsoleteSyntax::ClosureKind => (\n                 \"`:`, `&mut:`, or `&:`\",\n                 \"rely on inference instead\",\n                 true,\n             ),\n-            ObsoleteSyntax::Sized => (\n-                \"`Sized? T` for removing the `Sized` bound\",\n-                \"write `T: ?Sized` instead\",\n-                true,\n-            ),\n             ObsoleteSyntax::EmptyIndex => (\n                 \"[]\",\n                 \"write `[..]` instead\","}, {"sha": "4ae5e0faa310552144a04720e950c6c5d88d8dcd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 262, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -516,11 +516,7 @@ impl<'a> Parser<'a> {\n \n     pub fn parse_path_list_item(&mut self) -> ast::PathListItem {\n         let lo = self.span.lo;\n-        let node = if self.eat_keyword_noexpect(keywords::Mod) {\n-            let span = self.last_span;\n-            self.span_warn(span, \"deprecated syntax; use the `self` keyword now\");\n-            ast::PathListMod { id: ast::DUMMY_NODE_ID }\n-        } else if self.eat_keyword(keywords::SelfValue) {\n+        let node = if self.eat_keyword(keywords::SelfValue) {\n             ast::PathListMod { id: ast::DUMMY_NODE_ID }\n         } else {\n             let ident = self.parse_ident();\n@@ -619,23 +615,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Expect and consume a `|`. If `||` is seen, replace it with a single\n-    /// `|` and continue. If a `|` is not seen, signal an error.\n-    fn expect_or(&mut self) {\n-        self.expected_tokens.push(TokenType::Token(token::BinOp(token::Or)));\n-        match self.token {\n-            token::BinOp(token::Or) => self.bump(),\n-            token::OrOr => {\n-                let span = self.span;\n-                let lo = span.lo + BytePos(1);\n-                self.replace_token(token::BinOp(token::Or), lo, span.hi)\n-            }\n-            _ => {\n-                self.expect_one_of(&[], &[]);\n-            }\n-        }\n-    }\n-\n     pub fn expect_no_suffix(&self, sp: Span, kind: &str, suffix: Option<ast::Name>) {\n         match suffix {\n             None => {/* everything ok */}\n@@ -675,28 +654,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse a sequence bracketed by `|` and `|`, stopping before the `|`.\n-    fn parse_seq_to_before_or<T, F>(&mut self,\n-                                    sep: &token::Token,\n-                                    mut f: F)\n-                                    -> Vec<T> where\n-        F: FnMut(&mut Parser) -> T,\n-    {\n-        let mut first = true;\n-        let mut vector = Vec::new();\n-        while self.token != token::BinOp(token::Or) &&\n-                self.token != token::OrOr {\n-            if first {\n-                first = false\n-            } else {\n-                self.expect(sep)\n-            }\n-\n-            vector.push(f(self))\n-        }\n-        vector\n-    }\n-\n     /// Expect and consume a GT. if a >> is seen, replace it\n     /// with a single > and continue. If a GT is not seen,\n     /// signal an error.\n@@ -1008,11 +965,6 @@ impl<'a> Parser<'a> {\n             self.check_keyword(keywords::Extern)\n     }\n \n-    /// Is the current token one of the keywords that signals a closure type?\n-    pub fn token_is_closure_keyword(&mut self) -> bool {\n-        self.check_keyword(keywords::Unsafe)\n-    }\n-\n     pub fn get_lifetime(&mut self) -> ast::Ident {\n         match self.token {\n             token::Lifetime(ref ident) => *ident,\n@@ -1042,12 +994,9 @@ impl<'a> Parser<'a> {\n         let lifetime_defs = self.parse_late_bound_lifetime_defs();\n \n         // examine next token to decide to do\n-        if self.token_is_bare_fn_keyword() || self.token_is_closure_keyword() {\n-            self.parse_ty_bare_fn_or_ty_closure(lifetime_defs)\n-        } else if self.check(&token::ModSep) ||\n-                  self.token.is_ident() ||\n-                  self.token.is_path()\n-        {\n+        if self.token_is_bare_fn_keyword() {\n+            self.parse_ty_bare_fn(lifetime_defs)\n+        } else {\n             let hi = self.span.hi;\n             let trait_ref = self.parse_trait_ref();\n             let poly_trait_ref = ast::PolyTraitRef { bound_lifetimes: lifetime_defs,\n@@ -1063,8 +1012,6 @@ impl<'a> Parser<'a> {\n                 .chain(other_bounds.into_vec().into_iter())\n                 .collect();\n             ast::TyPolyTraitRef(all_bounds)\n-        } else {\n-            self.parse_ty_closure(lifetime_defs)\n         }\n     }\n \n@@ -1094,7 +1041,6 @@ impl<'a> Parser<'a> {\n         };\n \n         self.expect_keyword(keywords::Fn);\n-        let lifetime_defs = self.parse_legacy_lifetime_defs(lifetime_defs);\n         let (inputs, variadic) = self.parse_fn_args(false, true);\n         let ret_ty = self.parse_ret_ty();\n         let decl = P(FnDecl {\n@@ -1139,71 +1085,6 @@ impl<'a> Parser<'a> {\n          self.obsolete(span, ObsoleteSyntax::ClosureKind);\n     }\n \n-    pub fn parse_ty_bare_fn_or_ty_closure(&mut self, lifetime_defs: Vec<LifetimeDef>) -> Ty_ {\n-        // Both bare fns and closures can begin with stuff like unsafe\n-        // and extern. So we just scan ahead a few tokens to see if we see\n-        // a `fn`.\n-        //\n-        // Closure:  [unsafe] <'lt> |S| [:Bounds] -> T\n-        // Fn:       [unsafe] [extern \"ABI\"] fn <'lt> (S) -> T\n-\n-        if self.check_keyword(keywords::Fn) {\n-            self.parse_ty_bare_fn(lifetime_defs)\n-        } else if self.check_keyword(keywords::Extern) {\n-            self.parse_ty_bare_fn(lifetime_defs)\n-        } else if self.check_keyword(keywords::Unsafe) {\n-            if self.look_ahead(1, |t| t.is_keyword(keywords::Fn) ||\n-                                      t.is_keyword(keywords::Extern)) {\n-                self.parse_ty_bare_fn(lifetime_defs)\n-            } else {\n-                self.parse_ty_closure(lifetime_defs)\n-            }\n-        } else {\n-            self.parse_ty_closure(lifetime_defs)\n-        }\n-    }\n-\n-    /// Parse a TyClosure type\n-    pub fn parse_ty_closure(&mut self, lifetime_defs: Vec<ast::LifetimeDef>) -> Ty_ {\n-        /*\n-\n-        [unsafe] <'lt> |S| [:Bounds] -> T\n-        ^~~~~~~^ ^~~~^  ^  ^~~~~~~~^    ^\n-          |        |       |      |        |\n-          |        |       |      |      Return type\n-          |        |       |  Closure bounds\n-          |        |     Argument types\n-          |      Deprecated lifetime defs\n-          |\n-        Function Style\n-\n-        */\n-\n-        let ty_closure_span = self.last_span;\n-\n-        // To be helpful, parse the closure type as ever\n-        let _ = self.parse_unsafety();\n-\n-        let _ = self.parse_legacy_lifetime_defs(lifetime_defs);\n-\n-        if !self.eat(&token::OrOr) {\n-            self.expect_or();\n-\n-            let _ = self.parse_seq_to_before_or(\n-                &token::Comma,\n-                |p| p.parse_arg_general(false));\n-            self.expect_or();\n-        }\n-\n-        let _ = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Bare);\n-\n-        let _ = self.parse_ret_ty();\n-\n-        self.obsolete(ty_closure_span, ObsoleteSyntax::ClosureType);\n-\n-        TyInfer\n-    }\n-\n     pub fn parse_unsafety(&mut self) -> Unsafety {\n         if self.eat_keyword(keywords::Unsafe) {\n             return Unsafety::Unsafe;\n@@ -1212,27 +1093,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses `[ 'for' '<' lifetime_defs '>' ]'\n-    fn parse_legacy_lifetime_defs(&mut self,\n-                                  lifetime_defs: Vec<ast::LifetimeDef>)\n-                                  -> Vec<ast::LifetimeDef>\n-    {\n-        if self.token == token::Lt {\n-            self.bump();\n-            if lifetime_defs.is_empty() {\n-                self.warn(\"deprecated syntax; use the `for` keyword now \\\n-                            (e.g. change `fn<'a>` to `for<'a> fn`)\");\n-                let lifetime_defs = self.parse_lifetime_defs();\n-                self.expect_gt();\n-                lifetime_defs\n-            } else {\n-                self.fatal(\"cannot use new `for` keyword and older syntax together\");\n-            }\n-        } else {\n-            lifetime_defs\n-        }\n-    }\n-\n     /// Parse the items in a trait declaration\n     pub fn parse_trait_items(&mut self) -> Vec<P<TraitItem>> {\n         self.parse_unspanned_seq(\n@@ -1321,19 +1181,7 @@ impl<'a> Parser<'a> {\n             if self.eat(&token::Not) {\n                 NoReturn(self.span)\n             } else {\n-                let t = self.parse_ty();\n-\n-                // We used to allow `fn foo() -> &T + U`, but don't\n-                // anymore. If we see it, report a useful error.  This\n-                // only makes sense because `parse_ret_ty` is only\n-                // used in fn *declarations*, not fn types or where\n-                // clauses (i.e., not when parsing something like\n-                // `FnMut() -> T + Send`, where the `+` is legal).\n-                if self.token == token::BinOp(token::Plus) {\n-                    self.warn(\"deprecated syntax: `()` are required, see RFC 438 for details\");\n-                }\n-\n-                Return(t)\n+                Return(self.parse_ty())\n             }\n         } else {\n             let pos = self.span.lo;\n@@ -1421,18 +1269,9 @@ impl<'a> Parser<'a> {\n             self.parse_borrowed_pointee()\n         } else if self.check_keyword(keywords::For) {\n             self.parse_for_in_type()\n-        } else if self.token_is_bare_fn_keyword() ||\n-                  self.token_is_closure_keyword() {\n-            // BARE FUNCTION OR CLOSURE\n-            self.parse_ty_bare_fn_or_ty_closure(Vec::new())\n-        } else if self.check(&token::BinOp(token::Or)) ||\n-                  self.token == token::OrOr ||\n-                  (self.token == token::Lt &&\n-                   self.look_ahead(1, |t| {\n-                       *t == token::Gt || t.is_lifetime()\n-                   })) {\n-            // CLOSURE\n-            self.parse_ty_closure(Vec::new())\n+        } else if self.token_is_bare_fn_keyword() {\n+            // BARE FUNCTION\n+            self.parse_ty_bare_fn(Vec::new())\n         } else if self.eat_keyword_noexpect(keywords::Typeof) {\n             // TYPEOF\n             // In order to not be ambiguous, the type must be surrounded by parens.\n@@ -3974,56 +3813,19 @@ impl<'a> Parser<'a> {\n         return OwnedSlice::from_vec(result);\n     }\n \n-    fn trait_ref_from_ident(ident: Ident, span: Span) -> TraitRef {\n-        let segment = ast::PathSegment {\n-            identifier: ident,\n-            parameters: ast::PathParameters::none()\n-        };\n-        let path = ast::Path {\n-            span: span,\n-            global: false,\n-            segments: vec![segment],\n-        };\n-        ast::TraitRef {\n-            path: path,\n-            ref_id: ast::DUMMY_NODE_ID,\n-        }\n-    }\n-\n-    /// Matches typaram = (unbound `?`)? IDENT (`?` unbound)? optbounds ( EQ ty )?\n+    /// Matches typaram = IDENT (`?` unbound)? optbounds ( EQ ty )?\n     fn parse_ty_param(&mut self) -> TyParam {\n-        // This is a bit hacky. Currently we are only interested in a single\n-        // unbound, and it may only be `Sized`. To avoid backtracking and other\n-        // complications, we parse an ident, then check for `?`. If we find it,\n-        // we use the ident as the unbound, otherwise, we use it as the name of\n-        // type param. Even worse, we need to check for `?` before or after the\n-        // bound.\n-        let mut span = self.span;\n-        let mut ident = self.parse_ident();\n-        let mut unbound = None;\n-        if self.eat(&token::Question) {\n-            let tref = Parser::trait_ref_from_ident(ident, span);\n-            unbound = Some(tref);\n-            span = self.span;\n-            ident = self.parse_ident();\n-            self.obsolete(span, ObsoleteSyntax::Sized);\n-        }\n+        let span = self.span;\n+        let ident = self.parse_ident();\n \n-        let mut bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Modified);\n-        if let Some(unbound) = unbound {\n-            let mut bounds_as_vec = bounds.into_vec();\n-            bounds_as_vec.push(TraitTyParamBound(PolyTraitRef { bound_lifetimes: vec![],\n-                                                                trait_ref: unbound,\n-                                                                span: span },\n-                                                 TraitBoundModifier::Maybe));\n-            bounds = OwnedSlice::from_vec(bounds_as_vec);\n-        };\n+        let bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Modified);\n \n         let default = if self.check(&token::Eq) {\n             self.bump();\n             Some(self.parse_ty_sum())\n-        }\n-        else { None };\n+        } else {\n+            None\n+        };\n \n         TyParam {\n             ident: ident,\n@@ -4654,22 +4456,9 @@ impl<'a> Parser<'a> {\n \n         let ident = self.parse_ident();\n         let mut tps = self.parse_generics();\n-        // This is not very accurate, but since unbound only exists to catch\n-        // obsolete syntax, the span is unlikely to ever be used.\n-        let unbound_span = self.span;\n-        let unbound = self.parse_for_sized();\n \n         // Parse supertrait bounds.\n-        let mut bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Bare);\n-\n-        if let Some(unbound) = unbound {\n-            let mut bounds_as_vec = bounds.into_vec();\n-            bounds_as_vec.push(TraitTyParamBound(PolyTraitRef { bound_lifetimes: vec![],\n-                                                                trait_ref: unbound,\n-                                                                span:  unbound_span },\n-                                                 TraitBoundModifier::Maybe));\n-            bounds = OwnedSlice::from_vec(bounds_as_vec);\n-        };\n+        let bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Bare);\n \n         self.parse_where_clause(&mut tps);\n \n@@ -4956,39 +4745,6 @@ impl<'a> Parser<'a> {\n         else { Inherited }\n     }\n \n-    fn parse_for_sized(&mut self) -> Option<ast::TraitRef> {\n-        // FIXME, this should really use TraitBoundModifier, but it will get\n-        // re-jigged shortly in any case, so leaving the hacky version for now.\n-        if self.eat_keyword(keywords::For) {\n-            let span = self.span;\n-\n-            let mut ate_question = false;\n-            if self.eat(&token::Question) {\n-                ate_question = true;\n-            }\n-            let ident = self.parse_ident();\n-            if self.eat(&token::Question) {\n-                if ate_question {\n-                    self.span_err(span,\n-                        \"unexpected `?`\");\n-                }\n-                ate_question = true;\n-            }\n-            if !ate_question {\n-                self.span_err(span,\n-                    \"expected `?Sized` after `for` in trait item\");\n-                return None;\n-            }\n-            let _tref = Parser::trait_ref_from_ident(ident, span);\n-\n-            self.obsolete(span, ObsoleteSyntax::ForSized);\n-\n-            None\n-        } else {\n-            None\n-        }\n-    }\n-\n     /// Given a termination token, parse all of the items in a module\n     fn parse_mod_items(&mut self, term: &token::Token, inner_lo: BytePos) -> Mod {\n         let mut items = vec![];\n@@ -5064,8 +4820,8 @@ impl<'a> Parser<'a> {\n                     outer_attrs: &[ast::Attribute],\n                     id_sp: Span)\n                     -> (ast::Item_, Vec<ast::Attribute> ) {\n-        let mut prefix = PathBuf::new(&self.sess.span_diagnostic.cm\n-                                           .span_to_filename(self.span));\n+        let mut prefix = PathBuf::from(&self.sess.span_diagnostic.cm\n+                                            .span_to_filename(self.span));\n         prefix.pop();\n         let mut dir_path = prefix;\n         for part in &self.mod_path_stack {"}, {"sha": "828d085fd432eb835fb5bf399ea8e0995d8260ee", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -2712,8 +2712,20 @@ impl<'a> State<'a> {\n                        opt_explicit_self: Option<&ast::ExplicitSelf_>)\n                        -> io::Result<()> {\n         try!(self.ibox(indent_unit));\n+        if generics.lifetimes.len() > 0 || generics.ty_params.len() > 0 {\n+            try!(word(&mut self.s, \"for\"));\n+            try!(self.print_generics(generics));\n+        }\n+        let generics = ast::Generics {\n+            lifetimes: Vec::new(),\n+            ty_params: OwnedSlice::empty(),\n+            where_clause: ast::WhereClause {\n+                id: ast::DUMMY_NODE_ID,\n+                predicates: Vec::new(),\n+            },\n+        };\n         try!(self.print_fn(decl, unsafety, abi, name,\n-                           generics, opt_explicit_self,\n+                           &generics, opt_explicit_self,\n                            ast::Inherited));\n         self.end()\n     }"}, {"sha": "c907b87bc3c66e9f3ec9f5a9dd81abf8cadd559c", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -19,6 +19,7 @@\n //! # Examples\n //!\n //! ```no_run\n+//! # #![feature(rustc_private)]\n //! extern crate term;\n //!\n //! use std::io::prelude::*;\n@@ -62,6 +63,7 @@\n #![feature(std_misc)]\n #![feature(str_char)]\n #![feature(path_ext)]\n+#![feature(convert)]\n #![cfg_attr(windows, feature(libc))]\n \n #[macro_use] extern crate log;"}, {"sha": "66ee2b1ba87cbee6337302ff195d21093564ae41", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -31,7 +31,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<PathBuf>> {\n \n     // Find search directory\n     match env::var_os(\"TERMINFO\") {\n-        Some(dir) => dirs_to_search.push(PathBuf::new(&dir)),\n+        Some(dir) => dirs_to_search.push(PathBuf::from(dir)),\n         None => {\n             if homedir.is_some() {\n                 // ncurses compatibility;\n@@ -40,19 +40,19 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<PathBuf>> {\n             match env::var(\"TERMINFO_DIRS\") {\n                 Ok(dirs) => for i in dirs.split(':') {\n                     if i == \"\" {\n-                        dirs_to_search.push(PathBuf::new(\"/usr/share/terminfo\"));\n+                        dirs_to_search.push(PathBuf::from(\"/usr/share/terminfo\"));\n                     } else {\n-                        dirs_to_search.push(PathBuf::new(i));\n+                        dirs_to_search.push(PathBuf::from(i));\n                     }\n                 },\n                 // Found nothing in TERMINFO_DIRS, use the default paths:\n                 // According to  /etc/terminfo/README, after looking at\n                 // ~/.terminfo, ncurses will search /etc/terminfo, then\n                 // /lib/terminfo, and eventually /usr/share/terminfo.\n                 Err(..) => {\n-                    dirs_to_search.push(PathBuf::new(\"/etc/terminfo\"));\n-                    dirs_to_search.push(PathBuf::new(\"/lib/terminfo\"));\n-                    dirs_to_search.push(PathBuf::new(\"/usr/share/terminfo\"));\n+                    dirs_to_search.push(PathBuf::from(\"/etc/terminfo\"));\n+                    dirs_to_search.push(PathBuf::from(\"/lib/terminfo\"));\n+                    dirs_to_search.push(PathBuf::from(\"/usr/share/terminfo\"));\n                 }\n             }\n         }"}, {"sha": "402774321bfcbccbd1475b2b46a7b86915c8ab2e", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -45,6 +45,8 @@\n #![feature(libc)]\n #![feature(set_stdio)]\n #![feature(os)]\n+#![feature(convert)]\n+#![cfg_attr(test, feature(old_io))]\n \n extern crate getopts;\n extern crate serialize;\n@@ -382,7 +384,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     let run_ignored = matches.opt_present(\"ignored\");\n \n     let logfile = matches.opt_str(\"logfile\");\n-    let logfile = logfile.map(|s| PathBuf::new(&s));\n+    let logfile = logfile.map(|s| PathBuf::from(&s));\n \n     let run_benchmarks = matches.opt_present(\"bench\");\n     let run_tests = ! run_benchmarks ||\n@@ -696,7 +698,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> io::Res\n     match tests.iter().max_by(|t|len_if_padded(*t)) {\n         Some(t) => {\n             let n = t.desc.name.as_slice();\n-            st.max_name_len = n.as_slice().len();\n+            st.max_name_len = n.len();\n         },\n         None => {}\n     }"}, {"sha": "db5a25b9bedcaf9e2352a9284566ba2626e99c14", "filename": "src/libunicode/char.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibunicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibunicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fchar.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -209,6 +209,7 @@ pub trait CharExt {\n     /// In both of these examples, '\u00df' takes two bytes to encode.\n     ///\n     /// ```\n+    /// # #![feature(unicode)]\n     /// let mut b = [0; 2];\n     ///\n     /// let result = '\u00df'.encode_utf8(&mut b);\n@@ -219,6 +220,7 @@ pub trait CharExt {\n     /// A buffer that's too small:\n     ///\n     /// ```\n+    /// # #![feature(unicode)]\n     /// let mut b = [0; 1];\n     ///\n     /// let result = '\u00df'.encode_utf8(&mut b);\n@@ -241,6 +243,7 @@ pub trait CharExt {\n     /// In both of these examples, '\u00df' takes one `u16` to encode.\n     ///\n     /// ```\n+    /// # #![feature(unicode)]\n     /// let mut b = [0; 1];\n     ///\n     /// let result = '\u00df'.encode_utf16(&mut b);\n@@ -251,6 +254,7 @@ pub trait CharExt {\n     /// A buffer that's too small:\n     ///\n     /// ```\n+    /// # #![feature(unicode)]\n     /// let mut b = [0; 0];\n     ///\n     /// let result = '\u00df'.encode_utf8(&mut b);\n@@ -653,6 +657,7 @@ impl char {\n     /// In both of these examples, '\u00df' takes two bytes to encode.\n     ///\n     /// ```\n+    /// # #![feature(unicode)]\n     /// let mut b = [0; 2];\n     ///\n     /// let result = '\u00df'.encode_utf8(&mut b);\n@@ -663,6 +668,7 @@ impl char {\n     /// A buffer that's too small:\n     ///\n     /// ```\n+    /// # #![feature(unicode)]\n     /// let mut b = [0; 1];\n     ///\n     /// let result = '\u00df'.encode_utf8(&mut b);\n@@ -685,6 +691,7 @@ impl char {\n     /// In both of these examples, '\u00df' takes one `u16` to encode.\n     ///\n     /// ```\n+    /// # #![feature(unicode)]\n     /// let mut b = [0; 1];\n     ///\n     /// let result = '\u00df'.encode_utf16(&mut b);\n@@ -695,6 +702,7 @@ impl char {\n     /// A buffer that's too small:\n     ///\n     /// ```\n+    /// # #![feature(unicode)]\n     /// let mut b = [0; 0];\n     ///\n     /// let result = '\u00df'.encode_utf8(&mut b);"}, {"sha": "6879fa7b3ba6834a7df0543d1aef4f6e560ff94b", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -35,6 +35,7 @@\n #![feature(no_std)]\n #![no_std]\n #![feature(core)]\n+#![doc(test(no_crate_inject))]\n \n extern crate core;\n "}, {"sha": "de3a593143e79191852a1d682cea733af46c5d63", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -481,19 +481,24 @@ impl<'a> Iterator for Utf16Items<'a> {\n /// # Examples\n ///\n /// ```\n+/// # #![feature(unicode)]\n+/// extern crate unicode;\n+///\n /// use unicode::str::Utf16Item::{ScalarValue, LoneSurrogate};\n ///\n-/// // \ud834\udd1emus<invalid>ic<invalid>\n-/// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-///          0x0073, 0xDD1E, 0x0069, 0x0063,\n-///          0xD834];\n+/// fn main() {\n+///     // \ud834\udd1emus<invalid>ic<invalid>\n+///     let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///              0x0073, 0xDD1E, 0x0069, 0x0063,\n+///              0xD834];\n ///\n-/// assert_eq!(unicode::str::utf16_items(&v).collect::<Vec<_>>(),\n-///            vec![ScalarValue('\ud834\udd1e'),\n-///                 ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n-///                 LoneSurrogate(0xDD1E),\n-///                 ScalarValue('i'), ScalarValue('c'),\n-///                 LoneSurrogate(0xD834)]);\n+///     assert_eq!(unicode::str::utf16_items(&v).collect::<Vec<_>>(),\n+///                vec![ScalarValue('\ud834\udd1e'),\n+///                     ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n+///                     LoneSurrogate(0xDD1E),\n+///                     ScalarValue('i'), ScalarValue('c'),\n+///                     LoneSurrogate(0xD834)]);\n+/// }\n /// ```\n pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> {\n     Utf16Items { iter : v.iter() }"}, {"sha": "a08481f8be94e0473c8cfc6b77167bf83d7aa4c1", "filename": "src/rustbook/book.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Frustbook%2Fbook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Frustbook%2Fbook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbook.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -102,8 +102,8 @@ pub fn parse_summary(input: &mut Read, src: &Path) -> Result<Book, Vec<String>>\n     // always include the introduction\n     top_items.push(BookItem {\n         title: \"Introduction\".to_string(),\n-        path: PathBuf::new(\"README.md\"),\n-        path_to_root: PathBuf::new(\".\"),\n+        path: PathBuf::from(\"README.md\"),\n+        path_to_root: PathBuf::from(\".\"),\n         children: vec!(),\n     });\n \n@@ -133,10 +133,10 @@ pub fn parse_summary(input: &mut Read, src: &Path) -> Result<Book, Vec<String>>\n                 errors.push(format!(\"paths in SUMMARY.md must be relative, \\\n                                      but path '{}' for section '{}' is not.\",\n                                      given_path, title));\n-                PathBuf::new(\"\")\n+                PathBuf::new()\n             }\n         };\n-        let path_to_root = PathBuf::new(&iter::repeat(\"../\")\n+        let path_to_root = PathBuf::from(&iter::repeat(\"../\")\n                                          .take(path_from_root.components().count() - 1)\n                                          .collect::<String>());\n         let item = BookItem {"}, {"sha": "f06290b27cb2809583269f159f4b3313de5745ee", "filename": "src/rustbook/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -87,7 +87,7 @@ fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n         if env::args().len() < 3 {\n             src = env::current_dir().unwrap().clone();\n         } else {\n-            src = PathBuf::new(&env::args().nth(2).unwrap());\n+            src = PathBuf::from(&env::args().nth(2).unwrap());\n         }\n         // preprocess the markdown, rerouting markdown references to html references\n         let mut markdown_data = String::new();\n@@ -164,13 +164,13 @@ impl Subcommand for Build {\n         if env::args().len() < 3 {\n             src = cwd.clone();\n         } else {\n-            src = PathBuf::new(&env::args().nth(2).unwrap());\n+            src = PathBuf::from(&env::args().nth(2).unwrap());\n         }\n \n         if env::args().len() < 4 {\n             tgt = cwd.join(\"_book\");\n         } else {\n-            tgt = PathBuf::new(&env::args().nth(3).unwrap());\n+            tgt = PathBuf::from(&env::args().nth(3).unwrap());\n         }\n \n         try!(fs::create_dir(&tgt));"}, {"sha": "e896dee27919e1c4121e2be47b7c5c334e8ffa1f", "filename": "src/rustbook/error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Frustbook%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Frustbook%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Ferror.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -20,6 +20,7 @@ pub type CommandError = Box<Error + 'static>;\n pub type CommandResult<T> = Result<T, CommandError>;\n \n pub fn err(s: &str) -> CliError {\n+    #[derive(Debug)]\n     struct E(String);\n \n     impl Error for E {"}, {"sha": "4a652f846ed58bd0112c54e609a64737c8dad74f", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -15,6 +15,7 @@\n #![feature(rustdoc)]\n #![feature(rustc_private)]\n #![feature(path_relative_from)]\n+#![feature(convert)]\n \n extern crate rustdoc;\n extern crate rustc_back;"}, {"sha": "141ddba7db620dd02d763e4b73bbad6b1b7bea10", "filename": "src/snapshots.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -1,5 +1,5 @@\n S 2015-03-17 c64d671\n-  bitrig-x86_64 4b2f11a96b1b5b3782d74bda707aca33bc179880\n+  bitrig-x86_64 41de2c7a69a1ac648d3fa3b65e96a29bdc122163\n   freebsd-x86_64 14ced24e1339a4dd8baa9db69995daa52a948d54\n   linux-i386 200450ad3cc56bc715ca105b9acae35204bf7351\n   linux-x86_64 a54f50fee722ba6bc7281dec3e4d5121af7c15e3"}, {"sha": "197fb9a6d018c488ae9e81522666859c4e32d58a", "filename": "src/test/auxiliary/anon-extern-mod-cross-crate-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![crate_name=\"anonexternmod\"]\n+#![feature(libc)]\n \n extern crate libc;\n "}, {"sha": "c0d81cd8e1bad335e807e7346044895240f3e662", "filename": "src/test/auxiliary/check_static_recursion_foreign_helper.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fcheck_static_recursion_foreign_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fcheck_static_recursion_foreign_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcheck_static_recursion_foreign_helper.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -10,6 +10,8 @@\n \n // Helper definition for test/run-pass/check-static-recursion-foreign.rs.\n \n+#![feature(libc)]\n+\n #[crate_id = \"check_static_recursion_foreign_helper\"]\n #[crate_type = \"lib\"]\n "}, {"sha": "fc2e328f68657e65c58f724a1fef960d62dd688b", "filename": "src/test/auxiliary/extern-crosscrate-source.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -10,6 +10,7 @@\n \n #![crate_name=\"externcallback\"]\n #![crate_type = \"lib\"]\n+#![feature(libc)]\n \n extern crate libc;\n "}, {"sha": "92239ce55981c808dfd0991c4a7eaa2906377223", "filename": "src/test/auxiliary/foreign_lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![crate_name=\"foreign_lib\"]\n+#![feature(libc)]\n \n pub mod rustrt {\n     extern crate libc;"}, {"sha": "604a3e69a21767909233a369c61149385b64a07a", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -19,6 +19,6 @@ pub type header_map = HashMap<String, Rc<RefCell<Vec<Rc<String>>>>>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T>(req: &header_map) {\n-  let data = req[\"METHOD\".to_string()].clone();\n+  let data = req[&\"METHOD\".to_string()].clone();\n   let _x = data.borrow().clone()[0].clone();\n }"}, {"sha": "b6199f59ebe0638c9e82c3bc27ae0c129ac2104b", "filename": "src/test/auxiliary/issue-3012-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -10,6 +10,7 @@\n \n #![crate_name=\"socketlib\"]\n #![crate_type = \"lib\"]\n+#![feature(libc)]\n \n pub mod socket {\n     extern crate libc;"}, {"sha": "4a8839abc7cb2083017e8030f302d466c04266ac", "filename": "src/test/auxiliary/issue13507.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue13507.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(core)]\n+\n pub mod testtypes {\n     use std::any::TypeId;\n "}, {"sha": "58dee1216ee6047d03262e8cf8714c5bb779907f", "filename": "src/test/auxiliary/issue_16723_multiple_items_syntax_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fissue_16723_multiple_items_syntax_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fissue_16723_multiple_items_syntax_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_16723_multiple_items_syntax_ext.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -11,7 +11,7 @@\n // ignore-stage1\n // force-host\n \n-#![feature(plugin_registrar, quote)]\n+#![feature(plugin_registrar, quote, rustc_private)]\n #![crate_type = \"dylib\"]\n \n extern crate syntax;"}, {"sha": "3d5e52d709df3ec4c1966eafc87252acd368efc0", "filename": "src/test/auxiliary/issue_3907.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fissue_3907.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fissue_3907.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3907.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(core)]\n+\n use std::marker::MarkerTrait;\n \n pub trait Foo : MarkerTrait {"}, {"sha": "5c878b1e667d9f61128c7f92cd90e6a1bca13e79", "filename": "src/test/auxiliary/issue_5844_aux.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fissue_5844_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fissue_5844_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_5844_aux.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(libc)]\n+\n extern crate libc;\n \n extern \"C\" {"}, {"sha": "fd3e9b9ac9dcea8ca1de970fcddb5c8b842b0654", "filename": "src/test/auxiliary/linkage-visibility.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(std_misc, old_path)]\n+\n use std::dynamic_lib::DynamicLibrary;\n \n #[no_mangle]"}, {"sha": "3b45b0ae701061c125cca7917ab8f104c94b19da", "filename": "src/test/auxiliary/lint_for_crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Flint_for_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Flint_for_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_for_crate.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -10,7 +10,7 @@\n \n // force-host\n \n-#![feature(plugin_registrar)]\n+#![feature(plugin_registrar, rustc_private)]\n #![feature(box_syntax)]\n \n extern crate syntax;"}, {"sha": "ca5a7b75e06cfe61ac929401d378523c517fc458", "filename": "src/test/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -11,7 +11,7 @@\n // force-host\n \n #![feature(plugin_registrar)]\n-#![feature(box_syntax)]\n+#![feature(box_syntax, rustc_private)]\n \n extern crate syntax;\n "}, {"sha": "20799ce5b467f9debdb077e3479a3baef395c58a", "filename": "src/test/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -11,7 +11,7 @@\n // force-host\n \n #![feature(plugin_registrar)]\n-#![feature(box_syntax)]\n+#![feature(box_syntax, rustc_private)]\n \n extern crate syntax;\n "}, {"sha": "974db7c92463839a1a7b9bb973a30e7eddf5d225", "filename": "src/test/auxiliary/logging_right_crate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rustc_private)]\n+\n #[macro_use] extern crate log;\n \n pub fn foo<T>() {"}, {"sha": "03cd70d949428886501b663dbe60de5b64df9039", "filename": "src/test/auxiliary/macro_crate_MacroRulesTT.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fmacro_crate_MacroRulesTT.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fmacro_crate_MacroRulesTT.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_MacroRulesTT.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -10,7 +10,7 @@\n \n // force-host\n \n-#![feature(plugin_registrar)]\n+#![feature(plugin_registrar, rustc_private)]\n \n extern crate syntax;\n extern crate rustc;"}, {"sha": "5b7e52e9164e96744d8c34162eacf10d1b783cf7", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -11,7 +11,7 @@\n // force-host\n \n #![feature(plugin_registrar, quote)]\n-#![feature(box_syntax)]\n+#![feature(box_syntax, rustc_private)]\n \n extern crate syntax;\n extern crate rustc;"}, {"sha": "5a615502a95e3200a11aae532eb4c3b4a1e74ffb", "filename": "src/test/auxiliary/plugin_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fplugin_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fplugin_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_args.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -11,7 +11,7 @@\n // force-host\n \n #![feature(plugin_registrar)]\n-#![feature(box_syntax)]\n+#![feature(box_syntax, rustc_private)]\n \n extern crate syntax;\n extern crate rustc;"}, {"sha": "6f5f50475483d4ca05a5e672047551ed382e6928", "filename": "src/test/auxiliary/plugin_crate_outlive_expansion_phase.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -11,7 +11,7 @@\n // force-host\n \n #![feature(plugin_registrar)]\n-#![feature(box_syntax)]\n+#![feature(box_syntax, rustc_private)]\n \n extern crate rustc;\n "}, {"sha": "75f404c96cd0e7f380cdfb6e2f7cef70ca06fae1", "filename": "src/test/auxiliary/plugin_with_plugin_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fplugin_with_plugin_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fplugin_with_plugin_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_with_plugin_lib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -10,7 +10,7 @@\n \n // force-host\n \n-#![feature(plugin_registrar)]\n+#![feature(plugin_registrar, rustc_private)]\n #![deny(plugin_as_library)] // should have no effect in a plugin crate\n \n extern crate macro_crate_test;"}, {"sha": "dc08033602c99dfa9a6f9f3aed31ce6ddf1c7412", "filename": "src/test/auxiliary/private_trait_xc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fprivate_trait_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fprivate_trait_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprivate_trait_xc.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -8,4 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(core)]\n+\n trait Foo : ::std::marker::MarkerTrait {}"}, {"sha": "8c7ad2293e23db67cd051db94533e334486b6c07", "filename": "src/test/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -11,7 +11,7 @@\n // force-host\n \n #![crate_type=\"dylib\"]\n-#![feature(plugin_registrar, quote)]\n+#![feature(plugin_registrar, quote, rustc_private)]\n \n extern crate syntax;\n extern crate rustc;\n@@ -33,7 +33,7 @@ fn expand_mbe_matches(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n \n     let mac_expr = match TokenTree::parse(cx, &mbe_matcher[..], args) {\n         Success(map) => {\n-            match (&*map[str_to_ident(\"matched\")], &*map[str_to_ident(\"pat\")]) {\n+            match (&*map[&str_to_ident(\"matched\")], &*map[&str_to_ident(\"pat\")]) {\n                 (&MatchedNonterminal(NtExpr(ref matched_expr)),\n                  &MatchedSeq(ref pats, seq_sp)) => {\n                     let pats: Vec<P<Pat>> = pats.iter().map(|pat_nt|"}, {"sha": "86ce3df9ba6efcd0740b132c8b69c6063102d418", "filename": "src/test/auxiliary/rlib_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Frlib_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Frlib_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Frlib_crate_test.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -11,7 +11,7 @@\n // no-prefer-dynamic\n \n #![crate_type = \"rlib\"]\n-#![feature(plugin_registrar)]\n+#![feature(plugin_registrar, rustc_private)]\n \n extern crate rustc;\n "}, {"sha": "a105cb7ae6cfb6ce9db14d867c12b2e2703b4b6b", "filename": "src/test/auxiliary/roman_numerals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Froman_numerals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Froman_numerals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Froman_numerals.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -11,7 +11,7 @@\n // force-host\n \n #![crate_type=\"dylib\"]\n-#![feature(plugin_registrar)]\n+#![feature(plugin_registrar, rustc_private)]\n \n extern crate syntax;\n extern crate rustc;"}, {"sha": "6d4ea499b2bde8f623b41acaf24ddc46d911aee6", "filename": "src/test/auxiliary/svh-a-base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,7 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n+#![feature(core)]\n \n use std::marker::MarkerTrait;\n "}, {"sha": "61e4aaf32586e3d96e1ba00fcd3bee56a58f003a", "filename": "src/test/auxiliary/svh-a-change-lit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,7 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n+#![feature(core)]\n \n use std::marker::MarkerTrait;\n "}, {"sha": "cfdb0902b5d365f6d42f091258a0d27ffaa704e5", "filename": "src/test/auxiliary/svh-a-change-significant-cfg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,7 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n+#![feature(core)]\n \n use std::marker::MarkerTrait;\n "}, {"sha": "e79738c04103522746e4cd728267ff38f6fb7218", "filename": "src/test/auxiliary/svh-a-change-trait-bound.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,7 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n+#![feature(core)]\n \n use std::marker::MarkerTrait;\n "}, {"sha": "b22d553c02b5afb951a4eea095747c980e3d0253", "filename": "src/test/auxiliary/svh-a-change-type-arg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,7 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n+#![feature(core)]\n \n use std::marker::MarkerTrait;\n "}, {"sha": "78dbdc28b9f31f572a9dde4ada8260d8fc2e71d6", "filename": "src/test/auxiliary/svh-a-change-type-ret.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,7 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n+#![feature(core)]\n \n use std::marker::MarkerTrait;\n "}, {"sha": "30592827039746562b385df875af145ecb2f2a13", "filename": "src/test/auxiliary/svh-a-change-type-static.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,7 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n+#![feature(core)]\n \n use std::marker::MarkerTrait;\n "}, {"sha": "4c457b099a4b17e6590b21905d056a47683d6e85", "filename": "src/test/auxiliary/svh-a-comment.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,7 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n+#![feature(core)]\n \n use std::marker::MarkerTrait;\n "}, {"sha": "cab25ac9e4f4fbe78827cb65b74700c12f11282b", "filename": "src/test/auxiliary/svh-a-doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,7 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n+#![feature(core)]\n \n use std::marker::MarkerTrait;\n "}, {"sha": "01926dc8abc43938aef08b77287f8b9c88b7bfb4", "filename": "src/test/auxiliary/svh-a-macro.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,7 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n+#![feature(core)]\n \n use std::marker::MarkerTrait;\n "}, {"sha": "6d4ea499b2bde8f623b41acaf24ddc46d911aee6", "filename": "src/test/auxiliary/svh-a-no-change.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,7 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n+#![feature(core)]\n \n use std::marker::MarkerTrait;\n "}, {"sha": "f3a31df94b3e4e42af2d1b05f607b82e442e32aa", "filename": "src/test/auxiliary/svh-a-redundant-cfg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,7 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n+#![feature(core)]\n \n use std::marker::MarkerTrait;\n "}, {"sha": "bec6b207c071e4c5bb7072e2adae9c2532026ddd", "filename": "src/test/auxiliary/svh-a-whitespace.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,7 @@\n //! (#14132).\n \n #![crate_name = \"a\"]\n+#![feature(core)]\n \n use std::marker::MarkerTrait;\n "}, {"sha": "54da1a1e451c848b4f0ed0b04b04d79ca359b7be", "filename": "src/test/auxiliary/syntax_extension_with_dll_deps_2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsyntax_extension_with_dll_deps_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fsyntax_extension_with_dll_deps_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsyntax_extension_with_dll_deps_2.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -11,7 +11,7 @@\n // force-host\n \n #![crate_type = \"dylib\"]\n-#![feature(plugin_registrar, quote)]\n+#![feature(plugin_registrar, quote, rustc_private)]\n \n extern crate \"syntax_extension_with_dll_deps_1\" as other;\n extern crate syntax;"}, {"sha": "4a4de2455e36ea4bce9e376fa364f2a4280f1c87", "filename": "src/test/auxiliary/trait_impl_conflict.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Ftrait_impl_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Ftrait_impl_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_impl_conflict.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(core)]\n+\n pub trait Foo : ::std::marker::MarkerTrait {\n }\n "}, {"sha": "5a7a3e7bcc6942ac1b5a7495bd8a569990674cd1", "filename": "src/test/auxiliary/typeck-default-trait-impl-cross-crate-coherence-lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Ftypeck-default-trait-impl-cross-crate-coherence-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Ftypeck-default-trait-impl-cross-crate-coherence-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftypeck-default-trait-impl-cross-crate-coherence-lib.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(optin_builtin_traits)]\n+#![feature(optin_builtin_traits, core)]\n #![crate_type = \"rlib\"]\n \n use std::marker::MarkerTrait;"}, {"sha": "82d07a9df4e12662e428d1feb51cffb1ea716e81", "filename": "src/test/auxiliary/typeid-intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(core)]\n+\n use std::any::TypeId;\n \n pub struct A;"}, {"sha": "82d07a9df4e12662e428d1feb51cffb1ea716e81", "filename": "src/test/auxiliary/typeid-intrinsic2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic2.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(core)]\n+\n use std::any::TypeId;\n \n pub struct A;"}, {"sha": "ceffae79677f4100f55d7d94ef219c9383f58a1e", "filename": "src/test/auxiliary/weak-lang-items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fweak-lang-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fauxiliary%2Fweak-lang-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fweak-lang-items.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -13,7 +13,7 @@\n // This aux-file will require the eh_personality function to be codegen'd, but\n // it hasn't been defined just yet. Make sure we don't explode.\n \n-#![feature(no_std)]\n+#![feature(no_std, core)]\n #![no_std]\n #![crate_type = \"rlib\"]\n "}, {"sha": "0cff90d61ed995c95959ae57c74fcdb9a39d2509", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures)]\n+#![feature(unboxed_closures, std_misc, rand)]\n \n use std::collections::{BTreeMap, HashMap, HashSet};\n use std::env;"}, {"sha": "aeedaa288fef810f3bec9db55f07e7e93a8a9022", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-pretty very bad with line comments\n \n-#![feature(unboxed_closures)]\n+#![feature(unboxed_closures, rand, std_misc, collections)]\n \n extern crate collections;\n extern crate rand;"}, {"sha": "0344d6a46eeb58ffd54af4db766b59ec7c13785f", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -11,7 +11,7 @@\n // ignore-lexer-test FIXME #15679\n // Microbenchmarks for various functions in std and extra\n \n-#![feature(unboxed_closures)]\n+#![feature(unboxed_closures, rand, old_io, old_path, std_misc, collections)]\n \n use std::old_io::*;\n use std::old_path::{Path, GenericPath};"}, {"sha": "fb95f92da77094239763d5ee9c59a890fb0b2fc2", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -18,6 +18,8 @@\n // different scalability characteristics compared to the select\n // version.\n \n+#![feature(std_misc)]\n+\n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::env;\n use std::thread;"}, {"sha": "6d702242d765f2714ee84f327e05d779e0950de6", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -14,6 +14,8 @@\n //\n // I *think* it's the same, more or less.\n \n+#![feature(std_misc)]\n+\n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::env;\n use std::thread;"}, {"sha": "6fb2c954e020503450a4845fc49fe5bafce01f6a", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -18,6 +18,8 @@\n // no-pretty-expanded FIXME #15189\n // ignore-lexer-test FIXME #15679\n \n+#![feature(std_misc)]\n+\n use std::env;\n use std::sync::{Arc, Future, Mutex, Condvar};\n use std::time::Duration;"}, {"sha": "6cd758361870ee4e8ec84713f82b1884f4c2ab16", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -12,6 +12,8 @@\n // See https://github.com/nsf/pnoise for timings and alternative implementations.\n // ignore-lexer-test FIXME #15679\n \n+#![feature(rand, core)]\n+\n use std::f32::consts::PI;\n use std::num::Float;\n use std::rand::{Rng, StdRng};"}, {"sha": "64c3872213780beefc05796991c918f900bc4bd9", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -38,6 +38,8 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n+#![feature(rustc_private, core)]\n+\n extern crate arena;\n \n use std::iter::range_step;"}, {"sha": "e23862f4286aa33ab4790830fd7898a8e6dd483a", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -38,6 +38,8 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n+#![feature(core)]\n+\n use std::{cmp, iter, mem};\n use std::thread;\n "}, {"sha": "709b23ef9dd039c07e4cf109ad83ea4582bc25b1", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -38,6 +38,8 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n+#![feature(core, old_io, io, core)]\n+\n use std::cmp::min;\n use std::old_io::*;\n use std::iter::repeat;"}, {"sha": "78d31faeb51690c4cd8e2bc8ce6daf38ad5963e7", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -38,6 +38,8 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n+#![feature(old_io, old_path, io, core)]\n+\n use std::cmp::min;\n use std::old_io::*;\n use std::old_io;"}, {"sha": "ebdc60cdd2b0f3628894e8c7ea8cac35e07433d8", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -13,7 +13,7 @@\n \n // multi tasking k-nucleotide\n \n-#![feature(box_syntax)]\n+#![feature(box_syntax, std_misc, old_io, collections, os)]\n \n use std::ascii::{AsciiExt, OwnedAsciiExt};\n use std::cmp::Ordering::{self, Less, Greater, Equal};"}, {"sha": "ba4f2c9b1c563abbfc9a00fc9d122bb22342521a", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -40,7 +40,7 @@\n \n // ignore-android see #10393 #13206\n \n-#![feature(box_syntax)]\n+#![feature(box_syntax, std_misc, collections)]\n \n use std::ascii::OwnedAsciiExt;\n use std::env;"}, {"sha": "d248293103bdec7940ae623dd621216fe685b3ea", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -38,7 +38,7 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(simd)]\n+#![feature(simd, old_io, core, io)]\n \n // ignore-pretty very bad with line comments\n "}, {"sha": "150522fd02d4cb75ab41d8a0fb3c445bdb351b61", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed810385045ab0db90303574ba3ea47dfa2a36d5/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=ed810385045ab0db90303574ba3ea47dfa2a36d5", "patch": "@@ -40,6 +40,8 @@\n \n // no-pretty-expanded FIXME #15189\n \n+#![feature(core)]\n+\n use std::iter::repeat;\n use std::sync::Arc;\n use std::sync::mpsc::channel;"}]}