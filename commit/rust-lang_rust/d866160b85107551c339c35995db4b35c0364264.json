{"sha": "d866160b85107551c339c35995db4b35c0364264", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NjYxNjBiODUxMDc1NTFjMzM5YzM1OTk1ZGI0YjM1YzAzNjQyNjQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-07-17T12:35:14Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-07-17T12:35:49Z"}, "message": "bootstrap.py: guard against GC in NixOS patching support.", "tree": {"sha": "6711a3a2045fd213f1e230f048d68c75f4eee256", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6711a3a2045fd213f1e230f048d68c75f4eee256"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d866160b85107551c339c35995db4b35c0364264", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d866160b85107551c339c35995db4b35c0364264", "html_url": "https://github.com/rust-lang/rust/commit/d866160b85107551c339c35995db4b35c0364264", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d866160b85107551c339c35995db4b35c0364264/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2dbebd3d4ad21e80ef4e7535dd1e868aaad7e50", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2dbebd3d4ad21e80ef4e7535dd1e868aaad7e50", "html_url": "https://github.com/rust-lang/rust/commit/c2dbebd3d4ad21e80ef4e7535dd1e868aaad7e50"}], "stats": {"total": 73, "additions": 42, "deletions": 31}, "files": [{"sha": "bdf3bdf80b6d5316cf67cd80f7ded2eca3771400", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d866160b85107551c339c35995db4b35c0364264/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/d866160b85107551c339c35995db4b35c0364264/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=d866160b85107551c339c35995db4b35c0364264", "patch": "@@ -349,6 +349,7 @@ def __init__(self):\n         self.use_vendored_sources = ''\n         self.verbose = False\n         self.git_version = None\n+        self.nix_deps_dir = None\n \n     def download_stage0(self):\n         \"\"\"Fetch the build system for Rust, written in Rust\n@@ -440,8 +441,7 @@ def _download_stage0_helper(self, filename, pattern, tarball_suffix, date=None):\n             get(\"{}/{}\".format(url, filename), tarball, verbose=self.verbose)\n         unpack(tarball, tarball_suffix, self.bin_root(), match=pattern, verbose=self.verbose)\n \n-    @staticmethod\n-    def fix_executable(fname):\n+    def fix_executable(self, fname):\n         \"\"\"Modifies the interpreter section of 'fname' to fix the dynamic linker\n \n         This method is only required on NixOS and uses the PatchELF utility to\n@@ -472,38 +472,49 @@ def fix_executable(fname):\n         nix_os_msg = \"info: you seem to be running NixOS. Attempting to patch\"\n         print(nix_os_msg, fname)\n \n-        try:\n-            interpreter = subprocess.check_output(\n-                [\"patchelf\", \"--print-interpreter\", fname])\n-            interpreter = interpreter.strip().decode(default_encoding)\n-        except subprocess.CalledProcessError as reason:\n-            print(\"warning: failed to call patchelf:\", reason)\n-            return\n-\n-        loader = interpreter.split(\"/\")[-1]\n-\n-        try:\n-            ldd_output = subprocess.check_output(\n-                ['ldd', '/run/current-system/sw/bin/sh'])\n-            ldd_output = ldd_output.strip().decode(default_encoding)\n-        except subprocess.CalledProcessError as reason:\n-            print(\"warning: unable to call ldd:\", reason)\n-            return\n-\n-        for line in ldd_output.splitlines():\n-            libname = line.split()[0]\n-            if libname.endswith(loader):\n-                loader_path = libname[:len(libname) - len(loader)]\n-                break\n-        else:\n-            print(\"warning: unable to find the path to the dynamic linker\")\n-            return\n-\n-        correct_interpreter = loader_path + loader\n+        # Only build `stage0/.nix-deps` once.\n+        nix_deps_dir = self.nix_deps_dir\n+        if not nix_deps_dir:\n+            nix_deps_dir = \"{}/.nix-deps\".format(self.bin_root())\n+            if not os.path.exists(nix_deps_dir):\n+                os.makedirs(nix_deps_dir)\n+\n+            nix_deps = [\n+                # Needed for the path of `ld-linux.so` (via `nix-support/dynamic-linker`).\n+                \"stdenv.cc.bintools\",\n+\n+                # Needed for patching ELF binaries (see doc comment above).\n+                \"patchelf\",\n+            ]\n+\n+            # Run `nix-build` to \"build\" each dependency (which will likely reuse\n+            # the existing `/nix/store` copy, or at most download a pre-built copy).\n+            # Importantly, we don't rely on `nix-build` printing the `/nix/store`\n+            # path on stdout, but use `-o` to symlink it into `stage0/.nix-deps/$dep`,\n+            # ensuring garbage collection will never remove the `/nix/store` path\n+            # (which would break our patched binaries that hardcode those paths).\n+            for dep in nix_deps:\n+                try:\n+                    subprocess.check_output([\n+                        \"nix-build\", \"<nixpkgs>\",\n+                        \"-A\", dep,\n+                        \"-o\", \"{}/{}\".format(nix_deps_dir, dep),\n+                    ])\n+                except subprocess.CalledProcessError as reason:\n+                    print(\"warning: failed to call nix-build:\", reason)\n+                    return\n+\n+            self.nix_deps_dir = nix_deps_dir\n+\n+        patchelf = \"{}/patchelf/bin/patchelf\".format(nix_deps_dir)\n+        bintools_dir = \"{}/stdenv.cc.bintools\".format(nix_deps_dir)\n+\n+        with open(\"{}/nix-support/dynamic-linker\".format(bintools_dir)) as dynamic_linker:\n+            interpreter = dynamic_linker.read().rstrip()\n \n         try:\n             subprocess.check_output(\n-                [\"patchelf\", \"--set-interpreter\", correct_interpreter, fname])\n+                [patchelf, \"--set-interpreter\", interpreter, fname])\n         except subprocess.CalledProcessError as reason:\n             print(\"warning: failed to call patchelf:\", reason)\n             return"}]}