{"sha": "ffb3c2cb3d2081d295dab9ca38f3a5e1e13c863d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmYjNjMmNiM2QyMDgxZDI5NWRhYjljYTM4ZjNhNWUxZTEzYzg2M2Q=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-19T05:57:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-19T05:57:28Z"}, "message": "Rollup merge of #69036 - eddyb:monoshim, r=nikomatsakis\n\nrustc: don't resolve Instances which would produce malformed shims.\n\nThere are some `InstanceDef` variants (shims and drop \"glue\") which contain a `Ty`, and that `Ty` is used in generating the shim MIR. But if that `Ty` mentions any generic parameters, the generated shim would refer to them (but they won't match the `Substs` of the `Instance`), or worse, generating the shim would fail because not enough of the type is known.\n\nIdeally we would always produce a \"skeleton\" of the type, e.g. `(_, _)` for dropping any tuples with two elements, or `Vec<_>` for dropping any `Vec` value, but that's a lot of work, and they would still not match the `Substs` of the `Instance` as it exists today, so `Instance` would probably need to change.\n\nBy making `Instance::resolve` return `None` in the still-generic cases, we get behavior similar to specialization, where a default can only be used if there are no more generic parameters which would allow a more specialized `impl` to match.\n\n<hr/>\n\nThis was found while testing the MIR inliner with #68965, because it was trying to inline shims.\n\ncc @rust-lang/wg-mir-opt", "tree": {"sha": "e57d5f5db40badac99123f9f3bff6fde2115c436", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e57d5f5db40badac99123f9f3bff6fde2115c436"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffb3c2cb3d2081d295dab9ca38f3a5e1e13c863d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJecwnICRBK7hj4Ov3rIwAAdHIIAAp631izmW+gypQ0bG+DwXhJ\n4lL/rpWFHiTkbvwWpyH/XWm3J3zFRNoRZR6ra31nzsTudzsPIar/0CJ87zEJeHHk\nzOGZNvnKi+k2O+bemzMECLMwPJKuSDqhCqJ2G5chlQz3UUzkD5W1Ik/0qrKKMKZ1\nvMSyyz3CwnJTfb8ei4ud3/zW4V6ud78UZwYTtE0/bSwzhOL5HwWA1PO/nUqGTo/7\nF26+HdLLSVHu16MNhTkiNAHXgql56tmhohiqvr7Fkj/IwyxHOCsy3t+b8aJrjtjL\ncmwp/Tx6Da9D3QfnnAG52HUgTfyMvS5XhGc/xXAo4/G79ig2VCm9XBSEVJP4Bv0=\n=jcmZ\n-----END PGP SIGNATURE-----\n", "payload": "tree e57d5f5db40badac99123f9f3bff6fde2115c436\nparent fddbee64ac6d5ba461c8bdfdf72757dda1d35d8f\nparent bc8ff3fe8e8cebc9e4855aaf44c19c887f8f4be4\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1584597448 +0100\ncommitter GitHub <noreply@github.com> 1584597448 +0100\n\nRollup merge of #69036 - eddyb:monoshim, r=nikomatsakis\n\nrustc: don't resolve Instances which would produce malformed shims.\n\nThere are some `InstanceDef` variants (shims and drop \"glue\") which contain a `Ty`, and that `Ty` is used in generating the shim MIR. But if that `Ty` mentions any generic parameters, the generated shim would refer to them (but they won't match the `Substs` of the `Instance`), or worse, generating the shim would fail because not enough of the type is known.\n\nIdeally we would always produce a \"skeleton\" of the type, e.g. `(_, _)` for dropping any tuples with two elements, or `Vec<_>` for dropping any `Vec` value, but that's a lot of work, and they would still not match the `Substs` of the `Instance` as it exists today, so `Instance` would probably need to change.\n\nBy making `Instance::resolve` return `None` in the still-generic cases, we get behavior similar to specialization, where a default can only be used if there are no more generic parameters which would allow a more specialized `impl` to match.\n\n<hr/>\n\nThis was found while testing the MIR inliner with #68965, because it was trying to inline shims.\n\ncc @rust-lang/wg-mir-opt\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffb3c2cb3d2081d295dab9ca38f3a5e1e13c863d", "html_url": "https://github.com/rust-lang/rust/commit/ffb3c2cb3d2081d295dab9ca38f3a5e1e13c863d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffb3c2cb3d2081d295dab9ca38f3a5e1e13c863d/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fddbee64ac6d5ba461c8bdfdf72757dda1d35d8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fddbee64ac6d5ba461c8bdfdf72757dda1d35d8f", "html_url": "https://github.com/rust-lang/rust/commit/fddbee64ac6d5ba461c8bdfdf72757dda1d35d8f"}, {"sha": "bc8ff3fe8e8cebc9e4855aaf44c19c887f8f4be4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc8ff3fe8e8cebc9e4855aaf44c19c887f8f4be4", "html_url": "https://github.com/rust-lang/rust/commit/bc8ff3fe8e8cebc9e4855aaf44c19c887f8f4be4"}], "stats": {"total": 115, "additions": 83, "deletions": 32}, "files": [{"sha": "c9ad8707a7454d934a4dc189c4d75df22767a7e1", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ffb3c2cb3d2081d295dab9ca38f3a5e1e13c863d/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb3c2cb3d2081d295dab9ca38f3a5e1e13c863d/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=ffb3c2cb3d2081d295dab9ca38f3a5e1e13c863d", "patch": "@@ -39,6 +39,10 @@ pub enum InstanceDef<'tcx> {\n \n     /// `<fn() as FnTrait>::call_*`\n     /// `DefId` is `FnTrait::call_*`.\n+    ///\n+    /// NB: the (`fn` pointer) type must currently be monomorphic to avoid double substitution\n+    /// problems with the MIR shim bodies. `Instance::resolve` enforces this.\n+    // FIXME(#69925) support polymorphic MIR shim bodies properly instead.\n     FnPtrShim(DefId, Ty<'tcx>),\n \n     /// `<dyn Trait as Trait>::fn`, \"direct calls\" of which are implicitly\n@@ -57,9 +61,17 @@ pub enum InstanceDef<'tcx> {\n     /// The `DefId` is for `core::ptr::drop_in_place`.\n     /// The `Option<Ty<'tcx>>` is either `Some(T)`, or `None` for empty drop\n     /// glue.\n+    ///\n+    /// NB: the type must currently be monomorphic to avoid double substitution\n+    /// problems with the MIR shim bodies. `Instance::resolve` enforces this.\n+    // FIXME(#69925) support polymorphic MIR shim bodies properly instead.\n     DropGlue(DefId, Option<Ty<'tcx>>),\n \n     ///`<T as Clone>::clone` shim.\n+    ///\n+    /// NB: the type must currently be monomorphic to avoid double substitution\n+    /// problems with the MIR shim bodies. `Instance::resolve` enforces this.\n+    // FIXME(#69925) support polymorphic MIR shim bodies properly instead.\n     CloneShim(DefId, Ty<'tcx>),\n }\n "}, {"sha": "c1d969a4b51633c37de4e4f6b40ad44490c555a8", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ffb3c2cb3d2081d295dab9ca38f3a5e1e13c863d/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb3c2cb3d2081d295dab9ca38f3a5e1e13c863d/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=ffb3c2cb3d2081d295dab9ca38f3a5e1e13c863d", "patch": "@@ -2,13 +2,13 @@ use rustc::mir::*;\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::query::Providers;\n use rustc::ty::subst::{InternalSubsts, Subst};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n \n use rustc_index::vec::{Idx, IndexVec};\n \n-use rustc_span::{sym, Span};\n+use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n use std::fmt;\n@@ -39,6 +39,11 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n             None,\n         ),\n         ty::InstanceDef::FnPtrShim(def_id, ty) => {\n+            // FIXME(eddyb) support generating shims for a \"shallow type\",\n+            // e.g. `Foo<_>` or `[_]` instead of requiring a fully monomorphic\n+            // `Foo<Bar>` or `[String]` etc.\n+            assert!(!ty.needs_subst());\n+\n             let trait_ = tcx.trait_of_item(def_id).unwrap();\n             let adjustment = match tcx.fn_trait_kind_from_lang_item(trait_) {\n                 Some(ty::ClosureKind::FnOnce) => Adjustment::Identity,\n@@ -81,17 +86,21 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n                 None,\n             )\n         }\n-        ty::InstanceDef::DropGlue(def_id, ty) => build_drop_shim(tcx, def_id, ty),\n+        ty::InstanceDef::DropGlue(def_id, ty) => {\n+            // FIXME(eddyb) support generating shims for a \"shallow type\",\n+            // e.g. `Foo<_>` or `[_]` instead of requiring a fully monomorphic\n+            // `Foo<Bar>` or `[String]` etc.\n+            assert!(!ty.needs_subst());\n+\n+            build_drop_shim(tcx, def_id, ty)\n+        }\n         ty::InstanceDef::CloneShim(def_id, ty) => {\n-            let name = tcx.item_name(def_id);\n-            if name == sym::clone {\n-                build_clone_shim(tcx, def_id, ty)\n-            } else if name == sym::clone_from {\n-                debug!(\"make_shim({:?}: using default trait implementation\", instance);\n-                return tcx.optimized_mir(def_id);\n-            } else {\n-                bug!(\"builtin clone shim {:?} not supported\", instance)\n-            }\n+            // FIXME(eddyb) support generating shims for a \"shallow type\",\n+            // e.g. `Foo<_>` or `[_]` instead of requiring a fully monomorphic\n+            // `Foo<Bar>` or `[String]` etc.\n+            assert!(!ty.needs_subst());\n+\n+            build_clone_shim(tcx, def_id, ty)\n         }\n         ty::InstanceDef::Virtual(..) => {\n             bug!(\"InstanceDef::Virtual ({:?}) is for direct calls only\", instance)"}, {"sha": "a5abe7b6413cc23ceb6684237eeb731fbeb4b4ae", "filename": "src/librustc_ty/instance.rs", "status": "modified", "additions": 50, "deletions": 20, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ffb3c2cb3d2081d295dab9ca38f3a5e1e13c863d/src%2Flibrustc_ty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb3c2cb3d2081d295dab9ca38f3a5e1e13c863d/src%2Flibrustc_ty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Finstance.rs?ref=ffb3c2cb3d2081d295dab9ca38f3a5e1e13c863d", "patch": "@@ -1,6 +1,7 @@\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Instance, TyCtxt, TypeFoldable};\n use rustc_hir::def_id::DefId;\n+use rustc_span::sym;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n \n@@ -31,21 +32,26 @@ pub fn resolve_instance<'tcx>(\n                 debug!(\" => intrinsic\");\n                 ty::InstanceDef::Intrinsic(def_id)\n             }\n-            _ => {\n-                if Some(def_id) == tcx.lang_items().drop_in_place_fn() {\n-                    let ty = substs.type_at(0);\n-                    if ty.needs_drop(tcx, param_env.with_reveal_all()) {\n-                        debug!(\" => nontrivial drop glue\");\n-                        ty::InstanceDef::DropGlue(def_id, Some(ty))\n-                    } else {\n-                        debug!(\" => trivial drop glue\");\n-                        ty::InstanceDef::DropGlue(def_id, None)\n+            ty::FnDef(def_id, substs) if Some(def_id) == tcx.lang_items().drop_in_place_fn() => {\n+                let ty = substs.type_at(0);\n+\n+                if ty.needs_drop(tcx, param_env) {\n+                    // `DropGlue` requires a monomorphic aka concrete type.\n+                    if ty.needs_subst() {\n+                        return None;\n                     }\n+\n+                    debug!(\" => nontrivial drop glue\");\n+                    ty::InstanceDef::DropGlue(def_id, Some(ty))\n                 } else {\n-                    debug!(\" => free item\");\n-                    ty::InstanceDef::Item(def_id)\n+                    debug!(\" => trivial drop glue\");\n+                    ty::InstanceDef::DropGlue(def_id, None)\n                 }\n             }\n+            _ => {\n+                debug!(\" => free item\");\n+                ty::InstanceDef::Item(def_id)\n+            }\n         };\n         Some(Instance { def, substs })\n     };\n@@ -113,20 +119,44 @@ fn resolve_associated_item<'tcx>(\n                 trait_closure_kind,\n             ))\n         }\n-        traits::VtableFnPointer(ref data) => Some(Instance {\n-            def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n-            substs: rcvr_substs,\n-        }),\n+        traits::VtableFnPointer(ref data) => {\n+            // `FnPtrShim` requires a monomorphic aka concrete type.\n+            if data.fn_ty.needs_subst() {\n+                return None;\n+            }\n+\n+            Some(Instance {\n+                def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n+                substs: rcvr_substs,\n+            })\n+        }\n         traits::VtableObject(ref data) => {\n             let index = traits::get_vtable_index_of_object_method(tcx, data, def_id);\n             Some(Instance { def: ty::InstanceDef::Virtual(def_id, index), substs: rcvr_substs })\n         }\n         traits::VtableBuiltin(..) => {\n-            if tcx.lang_items().clone_trait().is_some() {\n-                Some(Instance {\n-                    def: ty::InstanceDef::CloneShim(def_id, trait_ref.self_ty()),\n-                    substs: rcvr_substs,\n-                })\n+            if Some(trait_ref.def_id) == tcx.lang_items().clone_trait() {\n+                // FIXME(eddyb) use lang items for methods instead of names.\n+                let name = tcx.item_name(def_id);\n+                if name == sym::clone {\n+                    let self_ty = trait_ref.self_ty();\n+\n+                    // `CloneShim` requires a monomorphic aka concrete type.\n+                    if self_ty.needs_subst() {\n+                        return None;\n+                    }\n+\n+                    Some(Instance {\n+                        def: ty::InstanceDef::CloneShim(def_id, self_ty),\n+                        substs: rcvr_substs,\n+                    })\n+                } else {\n+                    assert_eq!(name, sym::clone_from);\n+\n+                    // Use the default `fn clone_from` from `trait Clone`.\n+                    let substs = tcx.erase_regions(&rcvr_substs);\n+                    Some(ty::Instance::new(def_id, substs))\n+                }\n             } else {\n                 None\n             }"}]}