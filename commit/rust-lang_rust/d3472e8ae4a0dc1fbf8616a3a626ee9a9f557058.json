{"sha": "d3472e8ae4a0dc1fbf8616a3a626ee9a9f557058", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNDcyZThhZTRhMGRjMWZiZjg2MTZhM2E2MjZlZTlhOWY1NTcwNTg=", "commit": {"author": {"name": "Veetaha", "email": "gerzoh1@gmail.com", "date": "2020-01-29T01:52:13Z"}, "committer": {"name": "Veetaha", "email": "gerzoh1@gmail.com", "date": "2020-01-29T01:52:13Z"}, "message": "test_utils: updated documentation and some typos", "tree": {"sha": "cead56ab8f8d5f5e385d986e69e4fdf27860095c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cead56ab8f8d5f5e385d986e69e4fdf27860095c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3472e8ae4a0dc1fbf8616a3a626ee9a9f557058", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3472e8ae4a0dc1fbf8616a3a626ee9a9f557058", "html_url": "https://github.com/rust-lang/rust/commit/d3472e8ae4a0dc1fbf8616a3a626ee9a9f557058", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3472e8ae4a0dc1fbf8616a3a626ee9a9f557058/comments", "author": null, "committer": null, "parents": [{"sha": "3bdf2e0972a1458c28b3095f8d57e580130d09d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bdf2e0972a1458c28b3095f8d57e580130d09d3", "html_url": "https://github.com/rust-lang/rust/commit/3bdf2e0972a1458c28b3095f8d57e580130d09d3"}], "stats": {"total": 54, "additions": 43, "deletions": 11}, "files": [{"sha": "87778fd0400a984a37e799099b26f874aa1ff4c5", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d3472e8ae4a0dc1fbf8616a3a626ee9a9f557058/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3472e8ae4a0dc1fbf8616a3a626ee9a9f557058/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=d3472e8ae4a0dc1fbf8616a3a626ee9a9f557058", "patch": "@@ -21,6 +21,12 @@ pub use difference::Changeset as __Changeset;\n \n pub const CURSOR_MARKER: &str = \"<|>\";\n \n+/// Asserts that two strings are equal, otherwise displays a rich diff between them.\n+///\n+/// The diff shows changes from the \"original\" left string to the \"actual\" right string.\n+///\n+/// All arguments starting from and including the 3rd one are passed to\n+/// `eprintln!()` macro in case of text inequality.\n #[macro_export]\n macro_rules! assert_eq_text {\n     ($left:expr, $right:expr) => {\n@@ -42,13 +48,16 @@ macro_rules! assert_eq_text {\n     }};\n }\n \n+/// Infallible version of `try_extract_offset()`.\n pub fn extract_offset(text: &str) -> (TextUnit, String) {\n     match try_extract_offset(text) {\n         None => panic!(\"text should contain cursor marker\"),\n         Some(result) => result,\n     }\n }\n \n+/// Returns the offset of the first occurence of `<|>` marker and the copy of `text`\n+/// without the marker.\n fn try_extract_offset(text: &str) -> Option<(TextUnit, String)> {\n     let cursor_pos = text.find(CURSOR_MARKER)?;\n     let mut new_text = String::with_capacity(text.len() - CURSOR_MARKER.len());\n@@ -58,13 +67,16 @@ fn try_extract_offset(text: &str) -> Option<(TextUnit, String)> {\n     Some((cursor_pos, new_text))\n }\n \n+/// Infallible version of `try_extract_range()`.\n pub fn extract_range(text: &str) -> (TextRange, String) {\n     match try_extract_range(text) {\n         None => panic!(\"text should contain cursor marker\"),\n         Some(result) => result,\n     }\n }\n \n+/// Returns `TextRange` between the first two markers `<|>...<|>` and the copy\n+/// of `text` without both of these markers.\n fn try_extract_range(text: &str) -> Option<(TextRange, String)> {\n     let (start, text) = try_extract_offset(text)?;\n     let (end, text) = try_extract_offset(&text)?;\n@@ -85,6 +97,11 @@ impl From<RangeOrOffset> for TextRange {\n     }\n }\n \n+/// Extracts `TextRange` or `TextUnit` depending on the amount of `<|>` markers\n+/// found in `text`.\n+///\n+/// # Panics\n+/// Panics if no `<|>` marker is present in the `text`.\n pub fn extract_range_or_offset(text: &str) -> (RangeOrOffset, String) {\n     if let Some((range, text)) = try_extract_range(text) {\n         return (RangeOrOffset::Range(range), text);\n@@ -93,7 +110,7 @@ pub fn extract_range_or_offset(text: &str) -> (RangeOrOffset, String) {\n     (RangeOrOffset::Offset(offset), text)\n }\n \n-/// Extracts ranges, marked with `<tag> </tag>` paris from the `text`\n+/// Extracts ranges, marked with `<tag> </tag>` pairs from the `text`\n pub fn extract_ranges(mut text: &str, tag: &str) -> (Vec<TextRange>, String) {\n     let open = format!(\"<{}>\", tag);\n     let close = format!(\"</{}>\", tag);\n@@ -127,9 +144,9 @@ pub fn extract_ranges(mut text: &str, tag: &str) -> (Vec<TextRange>, String) {\n     (ranges, res)\n }\n \n+/// Inserts `<|>` marker into the `text` at `offset`.\n pub fn add_cursor(text: &str, offset: TextUnit) -> String {\n-    let offset: u32 = offset.into();\n-    let offset: usize = offset as usize;\n+    let offset: usize = offset.to_usize();\n     let mut res = String::new();\n     res.push_str(&text[..offset]);\n     res.push_str(\"<|>\");\n@@ -236,11 +253,10 @@ fn lines_match_works() {\n     assert!(!lines_match(\"b\", \"cb\"));\n }\n \n-// Compares JSON object for approximate equality.\n-// You can use `[..]` wildcard in strings (useful for OS dependent things such\n-// as paths).  You can use a `\"{...}\"` string literal as a wildcard for\n-// arbitrary nested JSON (useful for parts of object emitted by other programs\n-// (e.g. rustc) rather than Cargo itself).  Arrays are sorted before comparison.\n+/// Compares JSON object for approximate equality.\n+/// You can use `[..]` wildcard in strings (useful for OS dependent things such\n+/// as paths). You can use a `\"{...}\"` string literal as a wildcard for\n+/// arbitrary nested JSON. Arrays are sorted before comparison.\n pub fn find_mismatch<'a>(expected: &'a Value, actual: &'a Value) -> Option<(&'a Value, &'a Value)> {\n     use serde_json::Value::*;\n     match (expected, actual) {\n@@ -286,6 +302,14 @@ pub fn find_mismatch<'a>(expected: &'a Value, actual: &'a Value) -> Option<(&'a\n     }\n }\n \n+/// Calls callback `f` with input code and file paths of all `.rs` files from `test_data_dir`\n+/// subdirectories defined by `paths`.\n+///\n+/// If the content of the matching `.txt` file differs from the output of `f()`\n+/// the test will fail.\n+///\n+/// If there is no matching `.txt` file it will be created and filled with the\n+/// output of `f()`, but the test will fail.\n pub fn dir_tests<F>(test_data_dir: &Path, paths: &[&str], f: F)\n where\n     F: Fn(&str, &Path) -> String,\n@@ -307,6 +331,7 @@ where\n     }\n }\n \n+/// Collects all `.rs` files from `test_data_dir` subdirectories defined by `paths`.\n pub fn collect_tests(test_data_dir: &Path, paths: &[&str]) -> Vec<(PathBuf, String)> {\n     paths\n         .iter()\n@@ -321,6 +346,7 @@ pub fn collect_tests(test_data_dir: &Path, paths: &[&str]) -> Vec<(PathBuf, Stri\n         .collect()\n }\n \n+/// Collects paths to all `.rs` files from `dir` in a sorted `Vec<PathBuf>`.\n fn test_from_dir(dir: &Path) -> Vec<PathBuf> {\n     let mut acc = Vec::new();\n     for file in fs::read_dir(&dir).unwrap() {\n@@ -334,6 +360,7 @@ fn test_from_dir(dir: &Path) -> Vec<PathBuf> {\n     acc\n }\n \n+/// Returns the path to the root directory of `rust-analyzer` project.\n pub fn project_dir() -> PathBuf {\n     let dir = env!(\"CARGO_MANIFEST_DIR\");\n     PathBuf::from(dir).parent().unwrap().parent().unwrap().to_owned()\n@@ -356,6 +383,9 @@ pub fn read_text(path: &Path) -> String {\n         .replace(\"\\r\\n\", \"\\n\")\n }\n \n+/// Returns `false` if slow tests should not run, otherwise returns `true` and\n+/// also creates a file at `./target/.slow_tests_cookie` which serves as a flag\n+/// that slow tests did run.\n pub fn skip_slow_tests() -> bool {\n     let should_skip = std::env::var(\"CI\").is_err() && std::env::var(\"RUN_SLOW_TESTS\").is_err();\n     if should_skip {\n@@ -367,8 +397,9 @@ pub fn skip_slow_tests() -> bool {\n     should_skip\n }\n \n-const REWRITE: bool = false;\n-\n+/// Asserts that `expected` and `actual` strings are equal. If they differ only\n+/// in trailing or leading whitespace the test won't fail and\n+/// the contents of `actual` will be written to the file located at `path`.\n fn assert_equal_text(expected: &str, actual: &str, path: &Path) {\n     if expected == actual {\n         return;\n@@ -381,6 +412,7 @@ fn assert_equal_text(expected: &str, actual: &str, path: &Path) {\n         fs::write(path, actual).unwrap();\n         return;\n     }\n+    const REWRITE: bool = false;\n     if REWRITE {\n         println!(\"rewriting {}\", pretty_path.display());\n         fs::write(path, actual).unwrap();"}, {"sha": "f8fabfaff90324a327858bb04d24b4a053ce5213", "filename": "crates/test_utils/src/marks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3472e8ae4a0dc1fbf8616a3a626ee9a9f557058/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3472e8ae4a0dc1fbf8616a3a626ee9a9f557058/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fmarks.rs?ref=d3472e8ae4a0dc1fbf8616a3a626ee9a9f557058", "patch": "@@ -1,4 +1,4 @@\n-//! This module implements manually tracked test coverage, which useful for\n+//! This module implements manually tracked test coverage, which is useful for\n //! quickly finding a test responsible for testing a particular bit of code.\n //!\n //! See <https://matklad.github.io/2018/06/18/a-trick-for-test-maintenance.html>"}]}