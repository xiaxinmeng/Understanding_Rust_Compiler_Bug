{"sha": "fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMDI4MTRhNjNiZDc1OWY2NzI3Yzc0NzlmYzRhZWIwNGYwYmU5YjQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-08T02:40:34Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-12T18:39:08Z"}, "message": "rustc: Implement floating point literal inference. r=nmatsakis", "tree": {"sha": "7b372b7829c23190c1e6f1d187e1b316f9b67a3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b372b7829c23190c1e6f1d187e1b316f9b67a3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "html_url": "https://github.com/rust-lang/rust/commit/fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f05e2da709cca3b20e560eaf2e05d73c0ca5d91b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f05e2da709cca3b20e560eaf2e05d73c0ca5d91b", "html_url": "https://github.com/rust-lang/rust/commit/f05e2da709cca3b20e560eaf2e05d73c0ca5d91b"}], "stats": {"total": 409, "additions": 363, "deletions": 46}, "files": [{"sha": "922fff18e9e59b63434f0b5b3bbed2d93caf6208", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -286,6 +286,11 @@ fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n         w.write_char('I');\n         w.write_uint(id.to_uint());\n       }\n+      ty::ty_infer(ty::FloatVar(id)) => {\n+        w.write_char('X');\n+        w.write_char('F');\n+        w.write_uint(id.to_uint());\n+      }\n       ty::ty_param({idx: id, def_id: did}) => {\n         w.write_char('p');\n         w.write_str(cx.ds(did));"}, {"sha": "cbe5430b5be40122aaa3087cf601851564cd3a7e", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -389,6 +389,8 @@ fn lit_to_const(lit: @lit) -> const_val {\n       lit_uint(n, _) => const_uint(n),\n       lit_int_unsuffixed(n) => const_int(n),\n       lit_float(n, _) => const_float(float::from_str(*n).get() as f64),\n+      lit_float_unsuffixed(n) =>\n+        const_float(float::from_str(*n).get() as f64),\n       lit_nil => const_int(0i64),\n       lit_bool(b) => const_bool(b)\n     }"}, {"sha": "6796d139bc76fd548e329c0ab523b2c769f64a52", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -22,6 +22,19 @@ fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n         }\n       }\n       ast::lit_float(fs, t) => C_floating(*fs, T_float_ty(cx, t)),\n+      ast::lit_float_unsuffixed(fs) => {\n+        let lit_float_ty = ty::node_id_to_type(cx.tcx, e.id);\n+        match ty::get(lit_float_ty).sty {\n+          ty::ty_float(t) => {\n+            C_floating(*fs, T_float_ty(cx, t))\n+          }\n+          _ => {\n+            cx.sess.span_bug(lit.span,\n+                             ~\"floating point literal doesn't have the right \\\n+                               type\");\n+          }\n+        }\n+      }\n       ast::lit_bool(b) => C_bool(b),\n       ast::lit_nil => C_nil(),\n       ast::lit_str(s) => C_estr_slice(cx, *s)"}, {"sha": "e7cf5fa8ad8abb6b953f5b195f2a5ee500cfd342", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -21,7 +21,7 @@ use util::ppaux::{ty_to_str, proto_ty_to_str, tys_to_str};\n \n export ProvidedMethodSource;\n export InstantiatedTraitRef;\n-export TyVid, IntVid, FnVid, RegionVid, vid;\n+export TyVid, IntVid, FloatVid, FnVid, RegionVid, vid;\n export br_hashmap;\n export is_instantiable;\n export node_id_to_type;\n@@ -86,6 +86,7 @@ export ty_fn, FnTy, FnTyBase, FnMeta, FnSig, mk_fn;\n export ty_fn_proto, ty_fn_purity, ty_fn_ret, ty_fn_ret_style, tys_in_fn_ty;\n export ty_int, mk_int, mk_mach_int, mk_char;\n export mk_i8, mk_u8, mk_i16, mk_u16, mk_i32, mk_u32, mk_i64, mk_u64;\n+export mk_f32, mk_f64;\n export ty_estr, mk_estr, type_is_str;\n export ty_evec, mk_evec, type_is_vec;\n export ty_unboxed_vec, mk_unboxed_vec, mk_mut_unboxed_vec;\n@@ -102,8 +103,8 @@ export ty_tup, mk_tup;\n export ty_type, mk_type;\n export ty_uint, mk_uint, mk_mach_uint;\n export ty_uniq, mk_uniq, mk_imm_uniq, type_is_unique_box;\n-export ty_infer, mk_infer, type_is_ty_var, mk_var, mk_int_var;\n-export InferTy, TyVar, IntVar;\n+export ty_infer, mk_infer, type_is_ty_var, mk_var, mk_int_var, mk_float_var;\n+export InferTy, TyVar, IntVar, FloatVar;\n export ty_self, mk_self, type_has_self;\n export ty_class;\n export Region, bound_region, encl_region;\n@@ -172,7 +173,8 @@ export ty_sort_str;\n export normalize_ty;\n export to_str;\n export bound_const;\n-export terr_no_integral_type, terr_ty_param_size, terr_self_substs;\n+export terr_no_integral_type, terr_no_floating_point_type;\n+export terr_ty_param_size, terr_self_substs;\n export terr_in_field, terr_record_fields, terr_vstores_differ, terr_arg_count;\n export terr_sorts, terr_vec, terr_str, terr_record_size, terr_tuple_size;\n export terr_regions_does_not_outlive, terr_mutability, terr_purity_mismatch;\n@@ -666,6 +668,7 @@ enum type_err {\n     terr_sorts(expected_found<t>),\n     terr_self_substs,\n     terr_no_integral_type,\n+    terr_no_floating_point_type,\n }\n \n enum param_bound {\n@@ -678,21 +681,24 @@ enum param_bound {\n \n enum TyVid = uint;\n enum IntVid = uint;\n+enum FloatVid = uint;\n enum FnVid = uint;\n #[auto_serialize]\n #[auto_deserialize]\n enum RegionVid = uint;\n \n enum InferTy {\n     TyVar(TyVid),\n-    IntVar(IntVid)\n+    IntVar(IntVid),\n+    FloatVar(FloatVid)\n }\n \n impl InferTy : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         match self {\n           TyVar(ref tv) => to_bytes::iter_bytes_2(&0u8, tv, lsb0, f),\n-          IntVar(ref iv) => to_bytes::iter_bytes_2(&1u8, iv, lsb0, f)\n+          IntVar(ref iv) => to_bytes::iter_bytes_2(&1u8, iv, lsb0, f),\n+          FloatVar(ref fv) => to_bytes::iter_bytes_2(&2u8, fv, lsb0, f)\n         }\n     }\n }\n@@ -758,6 +764,11 @@ impl IntVid: vid {\n     pure fn to_str() -> ~str { fmt!(\"<VI%u>\", self.to_uint()) }\n }\n \n+impl FloatVid: vid {\n+    pure fn to_uint() -> uint { *self }\n+    pure fn to_str() -> ~str { fmt!(\"<VF%u>\", self.to_uint()) }\n+}\n+\n impl FnVid: vid {\n     pure fn to_uint() -> uint { *self }\n     pure fn to_str() -> ~str { fmt!(\"<F%u>\", self.to_uint()) }\n@@ -773,13 +784,15 @@ impl InferTy {\n         match self {\n             TyVar(v) => v.to_uint() << 1,\n             IntVar(v) => (v.to_uint() << 1) + 1,\n+            FloatVar(v) => (v.to_uint() << 1) + 2\n         }\n     }\n \n     pure fn to_str() -> ~str {\n         match self {\n             TyVar(v) => v.to_str(),\n             IntVar(v) => v.to_str(),\n+            FloatVar(v) => v.to_str()\n         }\n     }\n }\n@@ -812,6 +825,12 @@ impl IntVid : to_bytes::IterBytes {\n     }\n }\n \n+impl FloatVid : to_bytes::IterBytes {\n+    pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n+        (*self).iter_bytes(lsb0, f)\n+    }\n+}\n+\n impl FnVid : to_bytes::IterBytes {\n     pure fn iter_bytes(+lsb0: bool, f: to_bytes::Cb) {\n         (*self).iter_bytes(lsb0, f)\n@@ -1030,6 +1049,10 @@ fn mk_u32(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u32)) }\n \n fn mk_u64(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u64)) }\n \n+fn mk_f32(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f32)) }\n+\n+fn mk_f64(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f64)) }\n+\n fn mk_mach_int(cx: ctxt, tm: ast::int_ty) -> t { mk_t(cx, ty_int(tm)) }\n \n fn mk_mach_uint(cx: ctxt, tm: ast::uint_ty) -> t { mk_t(cx, ty_uint(tm)) }\n@@ -1110,9 +1133,9 @@ fn mk_class(cx: ctxt, class_id: ast::def_id, +substs: substs) -> t {\n \n fn mk_var(cx: ctxt, v: TyVid) -> t { mk_infer(cx, TyVar(v)) }\n \n-fn mk_int_var(cx: ctxt, v: IntVid) -> t {\n-    mk_infer(cx, IntVar(v))\n-}\n+fn mk_int_var(cx: ctxt, v: IntVid) -> t { mk_infer(cx, IntVar(v)) }\n+\n+fn mk_float_var(cx: ctxt, v: FloatVid) -> t { mk_infer(cx, FloatVar(v)) }\n \n fn mk_infer(cx: ctxt, it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n \n@@ -1661,7 +1684,8 @@ pure fn type_is_unique(ty: t) -> bool {\n pure fn type_is_scalar(ty: t) -> bool {\n     match get(ty).sty {\n       ty_nil | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_infer(IntVar(_)) | ty_type | ty_ptr(_) => true,\n+      ty_infer(IntVar(_)) | ty_infer(FloatVar(_)) | ty_type |\n+      ty_ptr(_) => true,\n       _ => false\n     }\n }\n@@ -2428,7 +2452,7 @@ fn type_is_integral(ty: t) -> bool {\n \n fn type_is_fp(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_float(_) => true,\n+      ty_infer(FloatVar(_)) | ty_float(_) => true,\n       _ => false\n     }\n }\n@@ -3260,6 +3284,7 @@ fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_tup(_) => ~\"tuple\",\n       ty_infer(TyVar(_)) => ~\"inferred type\",\n       ty_infer(IntVar(_)) => ~\"integral variable\",\n+      ty_infer(FloatVar(_)) => ~\"floating-point variable\",\n       ty_param(_) => ~\"type parameter\",\n       ty_self => ~\"self\"\n     }\n@@ -3387,6 +3412,10 @@ fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n             ~\"couldn't determine an appropriate integral type for integer \\\n               literal\"\n         }\n+        terr_no_floating_point_type => {\n+            ~\"couldn't determine an appropriate floating point type for \\\n+              floating point literal\"\n+        }\n     }\n }\n \n@@ -4000,7 +4029,7 @@ fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n         match get(ty).sty {\n           ty_bool => tycat_bool,\n           ty_int(_) | ty_uint(_) | ty_infer(IntVar(_)) => tycat_int,\n-          ty_float(_) => tycat_float,\n+          ty_float(_) | ty_infer(FloatVar(_)) => tycat_float,\n           ty_rec(_) | ty_tup(_) | ty_enum(_, _) => tycat_struct,\n           ty_bot => tycat_bot,\n           _ => tycat_other\n@@ -4230,6 +4259,11 @@ impl IntVid : cmp::Eq {\n     pure fn ne(other: &IntVid) -> bool { *self != *(*other) }\n }\n \n+impl FloatVid : cmp::Eq {\n+    pure fn eq(other: &FloatVid) -> bool { *self == *(*other) }\n+    pure fn ne(other: &FloatVid) -> bool { *self != *(*other) }\n+}\n+\n impl FnVid : cmp::Eq {\n     pure fn eq(other: &FnVid) -> bool { *self == *(*other) }\n     pure fn ne(other: &FnVid) -> bool { *self != *(*other) }"}, {"sha": "3f96f5af1a1a3fac2c16d43a178314e63e519680", "filename": "src/librustc/middle/typeck/check.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -850,6 +850,11 @@ fn check_lit(fcx: @fn_ctxt, lit: @ast::lit) -> ty::t {\n         ty::mk_int_var(tcx, fcx.infcx().next_int_var_id())\n       }\n       ast::lit_float(_, t) => ty::mk_mach_float(tcx, t),\n+      ast::lit_float_unsuffixed(_) => {\n+        // An unsuffixed floating point literal could have any floating point\n+        // type, so we create a floating point type variable for it.\n+        ty::mk_float_var(tcx, fcx.infcx().next_float_var_id())\n+      }\n       ast::lit_nil => ty::mk_nil(tcx),\n       ast::lit_bool(_) => ty::mk_bool(tcx)\n     }"}, {"sha": "ae6d7cd40e824168a80c190b5594dc71ad0c5d7c", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -664,6 +664,7 @@ impl LookupContext {\n         match ty::get(self_ty).sty {\n             ty_box(*) | ty_uniq(*) | ty_rptr(*) |\n             ty_infer(IntVar(_)) | // FIXME(#3211)---should be resolved\n+            ty_infer(FloatVar(_)) | // FIXME(#3211)---should be resolved\n             ty_self | ty_param(*) | ty_nil | ty_bot | ty_bool |\n             ty_int(*) | ty_uint(*) |\n             ty_float(*) | ty_enum(*) | ty_ptr(*) | ty_rec(*) |"}, {"sha": "edb6452ab50e4300e01491693478a9ded1375d11", "filename": "src/librustc/middle/typeck/infer.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -209,6 +209,8 @@ overconstrains the type, it's a type error; if we reach the point at\n which type variables must be resolved and an integral type variable is\n still underconstrained, it defaults to `int` as a last resort.\n \n+Floating point types are handled similarly to integral types.\n+\n ## GLB/LUB\n \n Computing the greatest-lower-bound and least-upper-bound of two\n@@ -250,8 +252,8 @@ use std::smallintmap;\n use std::smallintmap::smallintmap;\n use std::map::HashMap;\n use middle::ty;\n-use middle::ty::{TyVid, IntVid, RegionVid, vid,\n-                 ty_int, ty_uint, get, terr_fn, TyVar, IntVar};\n+use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, vid,\n+                 ty_int, ty_uint, get, terr_fn, TyVar, IntVar, FloatVar};\n use syntax::{ast, ast_util};\n use syntax::ast::{ret_style, purity};\n use util::ppaux::{ty_to_str, mt_to_str};\n@@ -272,6 +274,7 @@ use resolve::{resolve_nested_tvar, resolve_rvar, resolve_ivar, resolve_all,\n                  resolve_and_force_all_but_regions, resolver};\n use unify::{vals_and_bindings, root};\n use integral::{int_ty_set, int_ty_set_all};\n+use floating::{float_ty_set, float_ty_set_all};\n use combine::{combine_fields, eq_tys};\n use assignment::Assign;\n use to_str::ToStr;\n@@ -318,12 +321,17 @@ enum infer_ctxt = @{\n     // represented by an int_ty_set.\n     int_var_bindings: vals_and_bindings<ty::IntVid, int_ty_set>,\n \n+    // The types that might instantiate a floating-point type variable are\n+    // represented by an float_ty_set.\n+    float_var_bindings: vals_and_bindings<ty::FloatVid, float_ty_set>,\n+\n     // For region variables.\n     region_vars: RegionVarBindings,\n \n     // For keeping track of existing type and region variables.\n     ty_var_counter: @mut uint,\n     int_var_counter: @mut uint,\n+    float_var_counter: @mut uint,\n     region_var_counter: @mut uint\n };\n \n@@ -359,9 +367,11 @@ fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n     infer_ctxt(@{tcx: tcx,\n                  ty_var_bindings: new_vals_and_bindings(),\n                  int_var_bindings: new_vals_and_bindings(),\n+                 float_var_bindings: new_vals_and_bindings(),\n                  region_vars: RegionVarBindings(tcx),\n                  ty_var_counter: @mut 0u,\n                  int_var_counter: @mut 0u,\n+                 float_var_counter: @mut 0u,\n                  region_var_counter: @mut 0u})}\n \n fn mk_subty(cx: infer_ctxt, a_is_expected: bool, span: span,\n@@ -627,6 +637,18 @@ impl infer_ctxt {\n         ty::mk_int_var(self.tcx, self.next_int_var_id())\n     }\n \n+    fn next_float_var_id() -> FloatVid {\n+        let id = *self.float_var_counter;\n+        *self.float_var_counter += 1;\n+\n+        self.float_var_bindings.vals.insert(id, root(float_ty_set_all(), 0));\n+        return FloatVid(id);\n+    }\n+\n+    fn next_float_var() -> ty::t {\n+        ty::mk_float_var(self.tcx, self.next_float_var_id())\n+    }\n+\n     fn next_region_var_nb(span: span) -> ty::Region {\n         ty::re_infer(ty::ReVar(self.region_vars.new_region_var(span)))\n     }"}, {"sha": "099b0469bcf90de60012437ab91edf1406866d28", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -385,6 +385,17 @@ fn super_tys<C:combine>(\n         self.infcx().t_sub_int_var(a, b_id).then(|| Ok(a) )\n       }\n \n+      // Relate floating-point variables to other types\n+      (ty::ty_infer(FloatVar(a_id)), ty::ty_infer(FloatVar(b_id))) => {\n+        self.infcx().float_vars(a_id, b_id).then(|| Ok(a) )\n+      }\n+      (ty::ty_infer(FloatVar(a_id)), ty::ty_float(_)) => {\n+        self.infcx().float_var_sub_t(a_id, b).then(|| Ok(a) )\n+      }\n+      (ty::ty_float(_), ty::ty_infer(FloatVar(b_id))) => {\n+        self.infcx().t_sub_float_var(a, b_id).then(|| Ok(a) )\n+      }\n+\n       (ty::ty_int(_), _) |\n       (ty::ty_uint(_), _) |\n       (ty::ty_float(_), _) => {"}, {"sha": "1f2158090533b2c0986be94e069b4097efaa46f4", "filename": "src/librustc/middle/typeck/infer/floating.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ffloating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ffloating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ffloating.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -0,0 +1,48 @@\n+/*!\n+\n+Code related to floating-point type inference.\n+\n+*/\n+\n+use to_str::ToStr;\n+use middle::ty::ty_float;\n+\n+// Bitvector to represent sets of floating-point types.\n+pub enum float_ty_set = uint;\n+\n+// Constants representing singleton sets containing each of the floating-point\n+// types.\n+pub const FLOAT_TY_SET_EMPTY: uint = 0b000u;\n+pub const FLOAT_TY_SET_FLOAT: uint = 0b001u;\n+pub const FLOAT_TY_SET_F32:   uint = 0b010u;\n+pub const FLOAT_TY_SET_F64:   uint = 0b100u;\n+\n+pub fn float_ty_set_all() -> float_ty_set {\n+    float_ty_set(FLOAT_TY_SET_FLOAT | FLOAT_TY_SET_F32 | FLOAT_TY_SET_F64)\n+}\n+\n+pub fn intersection(a: float_ty_set, b: float_ty_set) -> float_ty_set {\n+    float_ty_set(*a & *b)\n+}\n+\n+pub fn single_type_contained_in(tcx: ty::ctxt, a: float_ty_set)\n+                             -> Option<ty::t> {\n+    debug!(\"single_type_contained_in(a=%s)\", uint::to_str(*a, 10));\n+\n+    if *a == FLOAT_TY_SET_FLOAT { return Some(ty::mk_float(tcx)); }\n+    if *a == FLOAT_TY_SET_F32   { return Some(ty::mk_f32(tcx));   }\n+    if *a == FLOAT_TY_SET_F64   { return Some(ty::mk_f64(tcx));   }\n+    return None;\n+}\n+\n+pub fn convert_floating_point_ty_to_float_ty_set(tcx: ty::ctxt, t: ty::t)\n+                                              -> float_ty_set {\n+    match get(t).sty {\n+        ty::ty_float(ast::ty_f)     => float_ty_set(FLOAT_TY_SET_FLOAT),\n+        ty::ty_float(ast::ty_f32)   => float_ty_set(FLOAT_TY_SET_F32),\n+        ty::ty_float(ast::ty_f64)   => float_ty_set(FLOAT_TY_SET_F64),\n+        _ => tcx.sess.bug(~\"non-floating-point type passed to \\\n+                            convert_floating_point_ty_to_float_ty_set()\")\n+    }\n+}\n+"}, {"sha": "956ab9998dea0e431372841426c3c473c80308b6", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -15,8 +15,10 @@\n // `resolve_nested_tvar` is passed, we will then go and recursively\n // resolve `<T1>`.\n //\n-// The options `resolve_rvar` and `resolve_ivar` control whether we\n-// resolve region and integral variables, respectively.\n+// The options `resolve_rvar` controls whether we resolve region\n+// variables. The options `resolve_fvar` and `resolve_ivar` control\n+// whether we resolve floating point and integral variables,\n+// respectively.\n //\n // # What do if things are unconstrained\n //\n@@ -35,16 +37,19 @@\n // probably better off writing `resolve_all - resolve_ivar`.\n \n use integral::*;\n+use floating::*;\n use to_str::ToStr;\n \n const resolve_nested_tvar: uint = 0b00000001;\n const resolve_rvar: uint        = 0b00000010;\n const resolve_ivar: uint        = 0b00000100;\n-const resolve_all: uint         = 0b00000111;\n+const resolve_fvar: uint        = 0b00001000;\n+const resolve_all: uint         = 0b00001111;\n const force_tvar: uint          = 0b00010000;\n const force_rvar: uint          = 0b00100000;\n const force_ivar: uint          = 0b01000000;\n-const force_all: uint           = 0b01110000;\n+const force_fvar: uint          = 0b11000000;\n+const force_all: uint           = 0b11110000;\n \n const not_regions: uint         = !(force_rvar | resolve_rvar);\n \n@@ -119,6 +124,9 @@ impl resolve_state {\n               ty::ty_infer(IntVar(vid)) => {\n                 self.resolve_int_var(vid)\n               }\n+              ty::ty_infer(FloatVar(vid)) => {\n+                self.resolve_float_var(vid)\n+              }\n               _ => {\n                 if !self.should(resolve_rvar) &&\n                     !self.should(resolve_nested_tvar) {\n@@ -212,7 +220,7 @@ impl resolve_state {\n \n         // If there's only one type in the set of possible types, then\n         // that's the answer.\n-        match single_type_contained_in(self.infcx.tcx, pt) {\n+        match integral::single_type_contained_in(self.infcx.tcx, pt) {\n           Some(t) => t,\n           None => {\n             if self.should(force_ivar) {\n@@ -230,5 +238,36 @@ impl resolve_state {\n           }\n         }\n     }\n+\n+    fn resolve_float_var(vid: FloatVid) -> ty::t {\n+        if !self.should(resolve_fvar) {\n+            return ty::mk_float_var(self.infcx.tcx, vid);\n+        }\n+\n+        let nde = self.infcx.get(&self.infcx.float_var_bindings, vid);\n+        let pt = nde.possible_types;\n+\n+        // If there's only one type in the set of possible types, then\n+        // that's the answer.\n+        match floating::single_type_contained_in(self.infcx.tcx, pt) {\n+          Some(t) => t,\n+          None => {\n+            if self.should(force_fvar) {\n+                // As a last resort, default to float.\n+                let ty = ty::mk_float(self.infcx.tcx);\n+                self.infcx.set(\n+                    &self.infcx.float_var_bindings,\n+                    vid,\n+                    root(\n+                        convert_floating_point_ty_to_float_ty_set(\n+                            self.infcx.tcx, ty),\n+                        nde.rank));\n+                ty\n+            } else {\n+                ty::mk_float_var(self.infcx.tcx, vid)\n+            }\n+          }\n+        }\n+    }\n }\n "}, {"sha": "73eef376b1ed29615c63815d9bf4e45e997fe95a", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -1,4 +1,5 @@\n use integral::{int_ty_set};\n+use floating::{float_ty_set};\n use unify::{var_value, redirect, root};\n \n trait ToStr {\n@@ -54,6 +55,14 @@ impl int_ty_set: ToStr {\n     }\n }\n \n+impl float_ty_set: ToStr {\n+    fn to_str(_cx: infer_ctxt) -> ~str {\n+        match self {\n+          float_ty_set(v) => uint::to_str(v, 10u)\n+        }\n+    }\n+}\n+\n impl<V:Copy vid, T:Copy ToStr> var_value<V, T>: ToStr {\n     fn to_str(cx: infer_ctxt) -> ~str {\n         match self {"}, {"sha": "88827849fa60845cf79d579a0c187297ad1aff74", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 104, "deletions": 23, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -1,5 +1,6 @@\n use combine::combine;\n use integral::*;\n+use floating::*;\n use to_str::ToStr;\n use std::smallintmap::SmallIntMap;\n \n@@ -294,6 +295,34 @@ fn bnds<C: combine>(\n // Integral variables\n \n impl infer_ctxt {\n+    fn optimize_ranks<V:Copy vid Eq,T:Copy ToStr>(vb: &vals_and_bindings<V,T>,\n+                                                  nde_a: node<V,T>,\n+                                                  nde_b: node<V,T>,\n+                                                  a_id: V,\n+                                                  b_id: V,\n+                                                  intersection: T) {\n+        if nde_a.rank > nde_b.rank {\n+            debug!(\"int_vars(): a has smaller rank\");\n+            // a has greater rank, so a should become b's parent,\n+            // i.e., b should redirect to a.\n+            self.set(vb, a_id, root(intersection, nde_a.rank));\n+            self.set(vb, b_id, redirect(a_id));\n+        } else if nde_a.rank < nde_b.rank {\n+            debug!(\"int_vars(): b has smaller rank\");\n+            // b has greater rank, so a should redirect to b.\n+            self.set(vb, b_id, root(intersection, nde_b.rank));\n+            self.set(vb, a_id, redirect(b_id));\n+        } else {\n+            debug!(\"int_vars(): a and b have equal rank\");\n+            assert nde_a.rank == nde_b.rank;\n+            // If equal, just redirect one to the other and increment\n+            // the other's rank.  We choose arbitrarily to redirect b\n+            // to a and increment a's rank.\n+            self.set(vb, a_id, root(intersection, nde_a.rank + 1u));\n+            self.set(vb, b_id, redirect(a_id));\n+        };\n+    }\n+\n     fn int_vars(a_id: ty::IntVid, b_id: ty::IntVid) -> ures {\n         let vb = &self.int_var_bindings;\n \n@@ -310,32 +339,13 @@ impl infer_ctxt {\n \n         // Otherwise, take the intersection of the two sets of\n         // possible types.\n-        let intersection = intersection(a_pt, b_pt);\n+        let intersection = integral::intersection(a_pt, b_pt);\n         if *intersection == INT_TY_SET_EMPTY {\n             return Err(ty::terr_no_integral_type);\n         }\n \n         // Rank optimization\n-        if nde_a.rank > nde_b.rank {\n-            debug!(\"int_vars(): a has smaller rank\");\n-            // a has greater rank, so a should become b's parent,\n-            // i.e., b should redirect to a.\n-            self.set(vb, a_id, root(intersection, nde_a.rank));\n-            self.set(vb, b_id, redirect(a_id));\n-        } else if nde_a.rank < nde_b.rank {\n-            debug!(\"int_vars(): b has smaller rank\");\n-            // b has greater rank, so a should redirect to b.\n-            self.set(vb, b_id, root(intersection, nde_b.rank));\n-            self.set(vb, a_id, redirect(b_id));\n-        } else {\n-            debug!(\"int_vars(): a and b have equal rank\");\n-            assert nde_a.rank == nde_b.rank;\n-            // If equal, just redirect one to the other and increment\n-            // the other's rank.  We choose arbitrarily to redirect b\n-            // to a and increment a's rank.\n-            self.set(vb, a_id, root(intersection, nde_a.rank + 1u));\n-            self.set(vb, b_id, redirect(a_id));\n-        };\n+        self.optimize_ranks(vb, nde_a, nde_b, a_id, b_id, intersection);\n \n         uok()\n     }\n@@ -349,7 +359,7 @@ impl infer_ctxt {\n         let a_pt = nde_a.possible_types;\n \n         let intersection =\n-            intersection(a_pt,\n+            integral::intersection(a_pt,\n                          convert_integral_ty_to_int_ty_set(self.tcx, b));\n         if *intersection == INT_TY_SET_EMPTY {\n             return Err(ty::terr_no_integral_type);\n@@ -367,7 +377,7 @@ impl infer_ctxt {\n         let b_pt = nde_b.possible_types;\n \n         let intersection =\n-            intersection(b_pt,\n+            integral::intersection(b_pt,\n                          convert_integral_ty_to_int_ty_set(self.tcx, a));\n         if *intersection == INT_TY_SET_EMPTY {\n             return Err(ty::terr_no_integral_type);\n@@ -378,3 +388,74 @@ impl infer_ctxt {\n \n \n }\n+\n+// ______________________________________________________________________\n+// Floating point variables\n+\n+impl infer_ctxt {\n+    fn float_vars(a_id: ty::FloatVid, b_id: ty::FloatVid) -> ures {\n+        let vb = &self.float_var_bindings;\n+\n+        let nde_a = self.get(vb, a_id);\n+        let nde_b = self.get(vb, b_id);\n+        let a_id = nde_a.root;\n+        let b_id = nde_b.root;\n+        let a_pt = nde_a.possible_types;\n+        let b_pt = nde_b.possible_types;\n+\n+        // If we're already dealing with the same two variables,\n+        // there's nothing to do.\n+        if a_id == b_id { return uok(); }\n+\n+        // Otherwise, take the intersection of the two sets of\n+        // possible types.\n+        let intersection = floating::intersection(a_pt, b_pt);\n+        if *intersection == FLOAT_TY_SET_EMPTY {\n+            return Err(ty::terr_no_floating_point_type);\n+        }\n+\n+        // Rank optimization\n+        self.optimize_ranks(vb, nde_a, nde_b, a_id, b_id, intersection);\n+\n+        uok()\n+    }\n+\n+    fn float_var_sub_t(a_id: ty::FloatVid, b: ty::t) -> ures {\n+        assert ty::type_is_fp(b);\n+\n+        let vb = &self.float_var_bindings;\n+        let nde_a = self.get(vb, a_id);\n+        let a_id = nde_a.root;\n+        let a_pt = nde_a.possible_types;\n+\n+        let intersection =\n+            floating::intersection(\n+                a_pt,\n+                convert_floating_point_ty_to_float_ty_set(self.tcx, b));\n+        if *intersection == FLOAT_TY_SET_EMPTY {\n+            return Err(ty::terr_no_floating_point_type);\n+        }\n+        self.set(vb, a_id, root(intersection, nde_a.rank));\n+        uok()\n+    }\n+\n+    fn t_sub_float_var(a: ty::t, b_id: ty::FloatVid) -> ures {\n+        assert ty::type_is_fp(a);\n+        let vb = &self.float_var_bindings;\n+\n+        let nde_b = self.get(vb, b_id);\n+        let b_id = nde_b.root;\n+        let b_pt = nde_b.possible_types;\n+\n+        let intersection =\n+            floating::intersection(\n+                b_pt,\n+                convert_floating_point_ty_to_float_ty_set(self.tcx, a));\n+        if *intersection == FLOAT_TY_SET_EMPTY {\n+            return Err(ty::terr_no_floating_point_type);\n+        }\n+        self.set(vb, b_id, root(intersection, nde_b.rank));\n+        uok()\n+    }\n+}\n+"}, {"sha": "0dd9ae7217f478641fd65049f5633891a7d6cbed", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -128,6 +128,7 @@ mod middle {\n             mod glb;\n             #[legacy_exports]\n             mod integral;\n+            mod floating;\n             #[legacy_exports]\n             mod lattice;\n             #[legacy_exports]"}, {"sha": "dd90dfee683da74f571e65f42478734187e09c5e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -862,6 +862,7 @@ enum lit_ {\n     lit_uint(u64, uint_ty),\n     lit_int_unsuffixed(i64),\n     lit_float(@~str, float_ty),\n+    lit_float_unsuffixed(@~str),\n     lit_nil,\n     lit_bool(bool),\n }\n@@ -880,13 +881,15 @@ impl ast::lit_: cmp::Eq {\n             (lit_float(val_a, ty_a), lit_float(val_b, ty_b)) => {\n                 val_a == val_b && ty_a == ty_b\n             }\n+            (lit_float_unsuffixed(a), lit_float_unsuffixed(b)) => a == b,\n             (lit_nil, lit_nil) => true,\n             (lit_bool(a), lit_bool(b)) => a == b,\n             (lit_str(_), _) => false,\n             (lit_int(*), _) => false,\n             (lit_uint(*), _) => false,\n             (lit_int_unsuffixed(*), _) => false,\n             (lit_float(*), _) => false,\n+            (lit_float_unsuffixed(*), _) => false,\n             (lit_nil, _) => false,\n             (lit_bool(_), _) => false\n         }"}, {"sha": "482813f3fd02e14c6e09b09d38137f6793d77c8d", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -385,6 +385,8 @@ fn scan_number(c: char, rdr: string_reader) -> token::Token {\n       }\n       None => ()\n     }\n+\n+    let mut is_machine_float = false;\n     if rdr.curr == 'f' {\n         bump(rdr);\n         c = rdr.curr;\n@@ -404,10 +406,14 @@ fn scan_number(c: char, rdr: string_reader) -> token::Token {\n             back-end.  */\n         } else {\n             is_float = true;\n+            is_machine_float = true;\n         }\n     }\n     if is_float {\n-        return token::LIT_FLOAT(rdr.interner.intern(@num_str), ast::ty_f);\n+        if is_machine_float {\n+            return token::LIT_FLOAT(rdr.interner.intern(@num_str), ast::ty_f);\n+        }\n+        return token::LIT_FLOAT_UNSUFFIXED(rdr.interner.intern(@num_str));\n     } else {\n         if str::len(num_str) == 0u {\n             rdr.fatal(~\"no valid digits found for number\");"}, {"sha": "f1f49c63a7d69110af66e85a5e3260a35f33988f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -43,9 +43,9 @@ use ast::{_mod, add, arg, arm, attribute,\n              ident, impure_fn, infer, inherited,\n              item, item_, item_class, item_const, item_enum, item_fn,\n              item_foreign_mod, item_impl, item_mac, item_mod, item_trait,\n-             item_ty, lit, lit_, lit_bool, lit_float, lit_int,\n-             lit_int_unsuffixed, lit_nil, lit_str, lit_uint, local, m_const,\n-             m_imm, m_mutbl, mac_, mac_aq, mac_ellipsis, mac_invoc,\n+             item_ty, lit, lit_, lit_bool, lit_float, lit_float_unsuffixed,\n+             lit_int, lit_int_unsuffixed, lit_nil, lit_str, lit_uint, local,\n+             m_const, m_imm, m_mutbl, mac_, mac_aq, mac_ellipsis, mac_invoc,\n              mac_invoc_tt, mac_var, matcher, match_nonterminal, match_seq,\n              match_tok, method, mode, module_ns, mt, mul, mutability,\n              named_field, neg, noreturn, not, pat, pat_box, pat_enum,\n@@ -787,6 +787,8 @@ impl Parser {\n           token::LIT_UINT(u, ut) => lit_uint(u, ut),\n           token::LIT_INT_UNSUFFIXED(i) => lit_int_unsuffixed(i),\n           token::LIT_FLOAT(s, ft) => lit_float(self.id_to_str(s), ft),\n+          token::LIT_FLOAT_UNSUFFIXED(s) =>\n+            lit_float_unsuffixed(self.id_to_str(s)),\n           token::LIT_STR(s) => lit_str(self.id_to_str(s)),\n           token::LPAREN => { self.expect(token::RPAREN); lit_nil },\n           _ => { self.unexpected_last(tok); }"}, {"sha": "baf963942e2b8c0eb77b6016da24889bddc32eb6", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -62,6 +62,7 @@ enum Token {\n     LIT_UINT(u64, ast::uint_ty),\n     LIT_INT_UNSUFFIXED(i64),\n     LIT_FLOAT(ast::ident, ast::float_ty),\n+    LIT_FLOAT_UNSUFFIXED(ast::ident),\n     LIT_STR(ast::ident),\n \n     /* Name components */\n@@ -164,6 +165,13 @@ fn to_str(in: @ident_interner, t: Token) -> ~str {\n         }\n         body + ast_util::float_ty_to_str(t)\n       }\n+      LIT_FLOAT_UNSUFFIXED(s) => {\n+        let mut body = *in.get(s);\n+        if body.ends_with(~\".\") {\n+            body = body + ~\"0\";  // `10.f` is not a float literal\n+        }\n+        body\n+      }\n       LIT_STR(s) => { ~\"\\\"\" + str::escape_default(*in.get(s)) + ~\"\\\"\" }\n \n       /* Name components */\n@@ -204,6 +212,7 @@ pure fn can_begin_expr(t: Token) -> bool {\n       LIT_UINT(_, _) => true,\n       LIT_INT_UNSUFFIXED(_) => true,\n       LIT_FLOAT(_, _) => true,\n+      LIT_FLOAT_UNSUFFIXED(_) => true,\n       LIT_STR(_) => true,\n       POUND => true,\n       AT => true,\n@@ -243,6 +252,7 @@ fn is_lit(t: Token) -> bool {\n       LIT_UINT(_, _) => true,\n       LIT_INT_UNSUFFIXED(_) => true,\n       LIT_FLOAT(_, _) => true,\n+      LIT_FLOAT_UNSUFFIXED(_) => true,\n       LIT_STR(_) => true,\n       _ => false\n     }\n@@ -684,6 +694,12 @@ impl Token : cmp::Eq {\n                     _ => false\n                 }\n             }\n+            LIT_FLOAT_UNSUFFIXED(e0a) => {\n+                match (*other) {\n+                    LIT_FLOAT_UNSUFFIXED(e0b) => e0a == e0b,\n+                    _ => false\n+                }\n+            }\n             LIT_STR(e0a) => {\n                 match (*other) {\n                     LIT_STR(e0b) => e0a == e0b,"}, {"sha": "54ed5085435d8daca33d183c4c32da6571879c36", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -1970,6 +1970,7 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n       ast::lit_float(f, t) => {\n         word(s.s, *f + ast_util::float_ty_to_str(t));\n       }\n+      ast::lit_float_unsuffixed(f) => word(s.s, *f),\n       ast::lit_nil => word(s.s, ~\"()\"),\n       ast::lit_bool(val) => {\n         if val { word(s.s, ~\"true\"); } else { word(s.s, ~\"false\"); }"}, {"sha": "e272b194fe1dc7ee02d689e4c44e06e522a2871c", "filename": "src/test/compile-fail/float-literal-inference-restrictions.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Ftest%2Fcompile-fail%2Ffloat-literal-inference-restrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Ftest%2Fcompile-fail%2Ffloat-literal-inference-restrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffloat-literal-inference-restrictions.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let x: f32 = 1; //~ ERROR mismatched types\n+    let y: f32 = 1f; //~ ERROR mismatched types\n+}\n+"}, {"sha": "f930537130c7deb9c49711768d0de25984656c5a", "filename": "src/test/run-pass/float-literal-inference.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Ftest%2Frun-pass%2Ffloat-literal-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe02814a63bd759f6727c7479fc4aeb04f0be9b4/src%2Ftest%2Frun-pass%2Ffloat-literal-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat-literal-inference.rs?ref=fe02814a63bd759f6727c7479fc4aeb04f0be9b4", "patch": "@@ -0,0 +1,13 @@\n+struct S {\n+    z: f64\n+}\n+\n+fn main() {\n+    let x: f32 = 4.0;\n+    io::println(x.to_str());\n+    let y: float = 64.0;\n+    io::println(y.to_str());\n+    let z = S { z: 1.0 };\n+    io::println(z.z.to_str());\n+}\n+"}]}