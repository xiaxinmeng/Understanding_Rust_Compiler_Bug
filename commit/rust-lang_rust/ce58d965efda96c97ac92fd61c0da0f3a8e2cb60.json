{"sha": "ce58d965efda96c97ac92fd61c0da0f3a8e2cb60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNThkOTY1ZWZkYTk2Yzk3YWM5MmZkNjFjMGRhMGYzYThlMmNiNjA=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-23T21:38:09Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-23T21:38:09Z"}, "message": "Update check::cast::pointer_kind logic to new rustc\n\nMake the match exhaustive, adding handling for anonymous types and\ntuple coercions on the way.\n\nAlso, exit early when type errors are detected, to avoid error cascades\nand the like.", "tree": {"sha": "aa84fefd653fa5bbfe14370e472a168e66686f71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa84fefd653fa5bbfe14370e472a168e66686f71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce58d965efda96c97ac92fd61c0da0f3a8e2cb60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce58d965efda96c97ac92fd61c0da0f3a8e2cb60", "html_url": "https://github.com/rust-lang/rust/commit/ce58d965efda96c97ac92fd61c0da0f3a8e2cb60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce58d965efda96c97ac92fd61c0da0f3a8e2cb60/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5165ee9e209e0e70d89946ccbb7e90b9c0c3a7ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/5165ee9e209e0e70d89946ccbb7e90b9c0c3a7ac", "html_url": "https://github.com/rust-lang/rust/commit/5165ee9e209e0e70d89946ccbb7e90b9c0c3a7ac"}], "stats": {"total": 151, "additions": 139, "deletions": 12}, "files": [{"sha": "7c199587c98981d385600b3154726469e501ca6c", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 53, "deletions": 12, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ce58d965efda96c97ac92fd61c0da0f3a8e2cb60/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce58d965efda96c97ac92fd61c0da0f3a8e2cb60/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=ce58d965efda96c97ac92fd61c0da0f3a8e2cb60", "patch": "@@ -48,6 +48,7 @@ use rustc::session::Session;\n use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::cast::{CastKind, CastTy};\n+use rustc::ty::subst::Substs;\n use rustc::middle::lang_items;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -77,43 +78,74 @@ enum PointerKind<'tcx> {\n     Length,\n     /// The unsize info of this projection\n     OfProjection(&'tcx ty::ProjectionTy<'tcx>),\n+    /// The unsize info of this anon ty\n+    OfAnon(DefId, &'tcx Substs<'tcx>),\n     /// The unsize info of this parameter\n     OfParam(&'tcx ty::ParamTy),\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// Returns the kind of unsize information of t, or None\n     /// if t is unknown.\n-    fn pointer_kind(&self, t: Ty<'tcx>, span: Span) -> Option<PointerKind<'tcx>> {\n+    fn pointer_kind(&self, t: Ty<'tcx>, span: Span) ->\n+        Result<Option<PointerKind<'tcx>>, ErrorReported>\n+    {\n+        debug!(\"pointer_kind({:?}, {:?})\", t, span);\n+\n+        let t = self.resolve_type_vars_if_possible(&t);\n+\n+        if t.references_error() {\n+            return Err(ErrorReported);\n+        }\n+\n         if self.type_is_known_to_be_sized(t, span) {\n-            return Some(PointerKind::Thin);\n+            return Ok(Some(PointerKind::Thin));\n         }\n \n-        match t.sty {\n+        Ok(match t.sty {\n             ty::TySlice(_) | ty::TyStr => Some(PointerKind::Length),\n             ty::TyDynamic(ref tty, ..) =>\n                 Some(PointerKind::Vtable(tty.principal().map(|p| p.def_id()))),\n             ty::TyAdt(def, substs) if def.is_struct() => {\n-                // FIXME(arielb1): do some kind of normalization\n                 match def.struct_variant().fields.last() {\n                     None => Some(PointerKind::Thin),\n-                    Some(f) => self.pointer_kind(f.ty(self.tcx, substs), span),\n+                    Some(f) => {\n+                        let field_ty = self.field_ty(span, f, substs);\n+                        self.pointer_kind(field_ty, span)?\n+                    }\n                 }\n             }\n+            ty::TyTuple(fields, _) => match fields.last() {\n+                None => Some(PointerKind::Thin),\n+                Some(f) => self.pointer_kind(f, span)?\n+            },\n+\n             // Pointers to foreign types are thin, despite being unsized\n             ty::TyForeign(..) => Some(PointerKind::Thin),\n             // We should really try to normalize here.\n             ty::TyProjection(ref pi) => Some(PointerKind::OfProjection(pi)),\n+            ty::TyAnon(def_id, substs) => Some(PointerKind::OfAnon(def_id, substs)),\n             ty::TyParam(ref p) => Some(PointerKind::OfParam(p)),\n             // Insufficient type information.\n             ty::TyInfer(_) => None,\n-            _ => panic!(),\n-        }\n+\n+            ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..) |\n+            ty::TyFloat(_) | ty::TyArray(..) |\n+            ty::TyRawPtr(_) | ty::TyRef(..) | ty::TyFnDef(..) |\n+            ty::TyFnPtr(..) | ty::TyClosure(..) | ty::TyGenerator(..) |\n+            ty::TyAdt(..) | ty::TyNever | ty::TyError => {\n+                self.tcx.sess.delay_span_bug(\n+                    span, &format!(\"`{:?}` should be sized but is not?\", t));\n+                return Err(ErrorReported);\n+            }\n+        })\n     }\n }\n \n #[derive(Copy, Clone)]\n enum CastError {\n+    ErrorReported,\n+\n     CastToBool,\n     CastToChar,\n     DifferingKinds,\n@@ -129,6 +161,12 @@ enum CastError {\n     UnknownCastPtrKind,\n }\n \n+impl From<ErrorReported> for CastError {\n+    fn from(ErrorReported: ErrorReported) -> Self {\n+        CastError::ErrorReported\n+    }\n+}\n+\n fn make_invalid_casting_error<'a, 'gcx, 'tcx>(sess: &'a Session,\n                                               span: Span,\n                                               expr_ty: Ty<'tcx>,\n@@ -173,6 +211,9 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n \n     fn report_cast_error(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, e: CastError) {\n         match e {\n+            CastError::ErrorReported => {\n+                // an error has already been reported\n+            }\n             CastError::NeedDeref => {\n                 let error_span = self.span;\n                 let mut err = make_invalid_casting_error(fcx.tcx.sess, self.span, self.expr_ty,\n@@ -480,8 +521,8 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         debug!(\"check_ptr_ptr_cast m_expr={:?} m_cast={:?}\", m_expr, m_cast);\n         // ptr-ptr cast. vtables must match.\n \n-        let expr_kind = fcx.pointer_kind(m_expr.ty, self.span);\n-        let cast_kind = fcx.pointer_kind(m_cast.ty, self.span);\n+        let expr_kind = fcx.pointer_kind(m_expr.ty, self.span)?;\n+        let cast_kind = fcx.pointer_kind(m_cast.ty, self.span)?;\n \n         let cast_kind = match cast_kind {\n             // We can't cast if target pointer kind is unknown\n@@ -519,7 +560,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                            -> Result<CastKind, CastError> {\n         // fptr-ptr cast. must be to thin ptr\n \n-        match fcx.pointer_kind(m_cast.ty, self.span) {\n+        match fcx.pointer_kind(m_cast.ty, self.span)? {\n             None => Err(CastError::UnknownCastPtrKind),\n             Some(PointerKind::Thin) => Ok(CastKind::FnPtrPtrCast),\n             _ => Err(CastError::IllegalCast),\n@@ -532,7 +573,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                            -> Result<CastKind, CastError> {\n         // ptr-addr cast. must be from thin ptr\n \n-        match fcx.pointer_kind(m_expr.ty, self.span) {\n+        match fcx.pointer_kind(m_expr.ty, self.span)? {\n             None => Err(CastError::UnknownExprPtrKind),\n             Some(PointerKind::Thin) => Ok(CastKind::PtrAddrCast),\n             _ => Err(CastError::NeedViaThinPtr),\n@@ -569,7 +610,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                            m_cast: &'tcx ty::TypeAndMut<'tcx>)\n                            -> Result<CastKind, CastError> {\n         // ptr-addr cast. pointer must be thin.\n-        match fcx.pointer_kind(m_cast.ty, self.span) {\n+        match fcx.pointer_kind(m_cast.ty, self.span)? {\n             None => Err(CastError::UnknownCastPtrKind),\n             Some(PointerKind::Thin) => Ok(CastKind::AddrPtrCast),\n             _ => Err(CastError::IllegalCast),"}, {"sha": "32a155c13e64a4252eb0c67ab359dca7cf6f08a4", "filename": "src/test/run-pass/cast-rfc0401-vtable-kinds.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce58d965efda96c97ac92fd61c0da0f3a8e2cb60/src%2Ftest%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce58d965efda96c97ac92fd61c0da0f3a8e2cb60/src%2Ftest%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs?ref=ce58d965efda96c97ac92fd61c0da0f3a8e2cb60", "patch": "@@ -11,6 +11,8 @@\n // Check that you can cast between different pointers to trait objects\n // whose vtable have the same kind (both lengths, or both trait pointers).\n \n+#![feature(unsized_tuple_coercion)]\n+\n trait Foo<T> {\n     fn foo(&self, _: T) -> u32 { 42 }\n }\n@@ -39,6 +41,11 @@ fn foo_to_bar<T:?Sized>(u: *const FooS<T>) -> *const BarS<T> {\n     u as *const BarS<T>\n }\n \n+fn tuple_i32_to_u32<T:?Sized>(u: *const (i32, T)) -> *const (u32, T) {\n+    u as *const (u32, T)\n+}\n+\n+\n fn main() {\n     let x = 4u32;\n     let y : &Foo<u32> = &x;\n@@ -51,4 +58,14 @@ fn main() {\n     let bar_ref : *const BarS<[u32]> = foo_to_bar(u);\n     let z : &BarS<[u32]> = unsafe{&*bar_ref};\n     assert_eq!(&z.0, &[0,1,2]);\n+\n+    // this assumes that tuple reprs for (i32, _) and (u32, _) are\n+    // the same.\n+    let s = (0i32, [0, 1, 2]);\n+    let u: &(i32, [u8]) = &s;\n+    let u: *const (i32, [u8]) = u;\n+    let u_u32 : *const (u32, [u8]) = tuple_i32_to_u32(u);\n+    unsafe {\n+        assert_eq!(&(*u_u32).1, &[0, 1, 2]);\n+    }\n }"}, {"sha": "74c8ff370f98b8ae356769271e51ab8111b4ed3a", "filename": "src/test/ui/casts-differing-anon.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ce58d965efda96c97ac92fd61c0da0f3a8e2cb60/src%2Ftest%2Fui%2Fcasts-differing-anon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce58d965efda96c97ac92fd61c0da0f3a8e2cb60/src%2Ftest%2Fui%2Fcasts-differing-anon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcasts-differing-anon.rs?ref=ce58d965efda96c97ac92fd61c0da0f3a8e2cb60", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait)]\n+\n+use std::fmt;\n+\n+fn foo() -> Box<impl fmt::Debug+?Sized> {\n+    let x : Box<[u8]> = Box::new([0]);\n+    x\n+}\n+fn bar() -> Box<impl fmt::Debug+?Sized> {\n+    let y: Box<fmt::Debug> = Box::new([0]);\n+    y\n+}\n+\n+fn main() {\n+    let f = foo();\n+    let b = bar();\n+\n+    // this is an `*mut [u8]` in practice\n+    let f_raw : *mut _ = Box::into_raw(f);\n+    // this is an `*mut fmt::Debug` in practice\n+    let mut b_raw = Box::into_raw(b);\n+    // ... and they should not be mixable\n+    b_raw = f_raw as *mut _; //~ ERROR is invalid\n+}"}, {"sha": "8db6854dba9b6ce8c27beea5a95a01c248bbccc0", "filename": "src/test/ui/casts-differing-anon.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce58d965efda96c97ac92fd61c0da0f3a8e2cb60/src%2Ftest%2Fui%2Fcasts-differing-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce58d965efda96c97ac92fd61c0da0f3a8e2cb60/src%2Ftest%2Fui%2Fcasts-differing-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcasts-differing-anon.stderr?ref=ce58d965efda96c97ac92fd61c0da0f3a8e2cb60", "patch": "@@ -0,0 +1,10 @@\n+error[E0606]: casting `*mut impl std::fmt::Debug+?Sized` as `*mut impl std::fmt::Debug+?Sized` is invalid\n+  --> $DIR/casts-differing-anon.rs:33:13\n+   |\n+33 |     b_raw = f_raw as *mut _; //~ ERROR is invalid\n+   |             ^^^^^^^^^^^^^^^\n+   |\n+   = note: vtable kinds may not match\n+\n+error: aborting due to previous error\n+"}, {"sha": "79f636e413f00d5118563d632cdf12311d633ca9", "filename": "src/test/ui/casts-issue-46365.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce58d965efda96c97ac92fd61c0da0f3a8e2cb60/src%2Ftest%2Fui%2Fcasts-issue-46365.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce58d965efda96c97ac92fd61c0da0f3a8e2cb60/src%2Ftest%2Fui%2Fcasts-issue-46365.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcasts-issue-46365.rs?ref=ce58d965efda96c97ac92fd61c0da0f3a8e2cb60", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Lorem {\n+    ipsum: Ipsum //~ ERROR cannot find type `Ipsum`\n+}\n+\n+fn main() {\n+    let _foo: *mut Lorem = 0 as *mut _; // no error here\n+}"}, {"sha": "ce3c8593a97ce54cc1449fe58417ec2cbdf76057", "filename": "src/test/ui/casts-issue-46365.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce58d965efda96c97ac92fd61c0da0f3a8e2cb60/src%2Ftest%2Fui%2Fcasts-issue-46365.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce58d965efda96c97ac92fd61c0da0f3a8e2cb60/src%2Ftest%2Fui%2Fcasts-issue-46365.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcasts-issue-46365.stderr?ref=ce58d965efda96c97ac92fd61c0da0f3a8e2cb60", "patch": "@@ -0,0 +1,8 @@\n+error[E0412]: cannot find type `Ipsum` in this scope\n+  --> $DIR/casts-issue-46365.rs:12:12\n+   |\n+12 |     ipsum: Ipsum //~ ERROR cannot find type `Ipsum`\n+   |            ^^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+"}]}