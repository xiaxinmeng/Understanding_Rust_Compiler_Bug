{"sha": "681aa582142abb0d74e20fc90ff93152acd2a006", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MWFhNTgyMTQyYWJiMGQ3NGUyMGZjOTBmZjkzMTUyYWNkMmEwMDY=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-20T12:28:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-07-21T16:54:31Z"}, "message": "Document Bitv.", "tree": {"sha": "eb6b7a002cc3144fcc2c3225c7e2aefdfb6f53ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb6b7a002cc3144fcc2c3225c7e2aefdfb6f53ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/681aa582142abb0d74e20fc90ff93152acd2a006", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/681aa582142abb0d74e20fc90ff93152acd2a006", "html_url": "https://github.com/rust-lang/rust/commit/681aa582142abb0d74e20fc90ff93152acd2a006", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/681aa582142abb0d74e20fc90ff93152acd2a006/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4d9dca10dfa73c7d1a9d3be7c63e943d29a43c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4d9dca10dfa73c7d1a9d3be7c63e943d29a43c9", "html_url": "https://github.com/rust-lang/rust/commit/f4d9dca10dfa73c7d1a9d3be7c63e943d29a43c9"}], "stats": {"total": 401, "additions": 307, "deletions": 94}, "files": [{"sha": "2718cb624494ed91c097712a7fd0830bf7d3f833", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 307, "deletions": 94, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/681aa582142abb0d74e20fc90ff93152acd2a006/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/681aa582142abb0d74e20fc90ff93152acd2a006/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=681aa582142abb0d74e20fc90ff93152acd2a006", "patch": "@@ -155,13 +155,32 @@ impl Bitv {\n         }\n     }\n \n-    /// Creates an empty Bitv\n+    /// Create an empty Bitv.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    /// let mut bv = Bitv::new();\n+    /// ```\n     pub fn new() -> Bitv {\n         Bitv { storage: Vec::new(), nbits: 0 }\n     }\n \n-    /// Creates a Bitv that holds `nbits` elements, setting each element\n+    /// Create a Bitv that holds `nbits` elements, setting each element\n     /// to `init`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv = Bitv::with_capacity(10u, false);\n+    /// assert_eq!(bv.len(), 10u);\n+    /// for x in bv.iter() {\n+    ///     assert_eq!(x, false);\n+    /// }\n+    /// ```\n     pub fn with_capacity(nbits: uint, init: bool) -> Bitv {\n         Bitv {\n             storage: Vec::from_elem((nbits + uint::BITS - 1) / uint::BITS,\n@@ -170,7 +189,21 @@ impl Bitv {\n         }\n     }\n \n-    /// Retrieve the value at index `i`\n+    /// Retrieve the value at index `i`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Assert if `i` out of bounds.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let bv: Bitv = [false, true].iter().map(|n| *n).collect();\n+    /// assert_eq!(bv.get(0), false);\n+    /// assert_eq!(bv.get(1), true);\n+    /// ```\n     #[inline]\n     pub fn get(&self, i: uint) -> bool {\n         assert!(i < self.nbits);\n@@ -180,11 +213,21 @@ impl Bitv {\n         x != 0\n     }\n \n-    /**\n-     * Set the value of a bit at a given index\n-     *\n-     * `i` must be less than the length of the bitvector.\n-     */\n+    /// Set the value of a bit at a index `i`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Assert if `i` out of bounds.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv = Bitv::with_capacity(5, false);\n+    /// bv.set(3, true);\n+    /// assert_eq!(bv.get(3), true);\n+    /// ```\n     #[inline]\n     pub fn set(&mut self, i: uint, x: bool) {\n         assert!(i < self.nbits);\n@@ -195,55 +238,128 @@ impl Bitv {\n                           else { *self.storage.get(w) & !flag };\n     }\n \n-    /// Set all bits to 1\n+    /// Set all bits to 1.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv: Bitv = [false, true, false].iter().map(|n| *n).collect();\n+    /// bv.set_all();\n+    /// assert!(bv.eq_vec([true, true, true]));\n     #[inline]\n     pub fn set_all(&mut self) {\n         for w in self.storage.mut_iter() { *w = !0u; }\n     }\n \n-    /// Flip all bits\n+    /// Flip all bits.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv: Bitv = [false, true, false].iter().map(|n| *n).collect();\n+    /// bv.negate();\n+    /// assert!(bv.eq_vec([true, false, true]));\n     #[inline]\n     pub fn negate(&mut self) {\n         for w in self.storage.mut_iter() { *w = !*w; }\n     }\n \n-    /**\n-     * Calculates the union of two bitvectors\n-     *\n-     * Sets `self` to the union of `self` and `v1`. Both bitvectors must be\n-     * the same length. Returns `true` if `self` changed.\n-    */\n+    /// Calculate the union of two bitvectors, acts like bitwise or.\n+    ///\n+    /// Set `self` to the union of `self` and `other`. Both bitvectors must be\n+    /// the same length. Return `true` if `self` changed.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Assert if the bitvectors are of different length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv1: Bitv = [false, true, true, false].iter().map(|n| *n).collect();\n+    /// let bv2: Bitv = [false, true, false, true].iter().map(|n| *n).collect();\n+    /// let res: Bitv = [false, true, true, true].iter().map(|n| *n).collect();\n+    ///\n+    /// assert!(bv1.union(&bv2));\n+    /// assert_eq!(bv1, res);\n+    /// ```\n     #[inline]\n     pub fn union(&mut self, other: &Bitv) -> bool {\n         self.process(other, |w1, w2| w1 | w2)\n     }\n \n-    /**\n-     * Calculates the intersection of two bitvectors\n-     *\n-     * Sets `self` to the intersection of `self` and `v1`. Both bitvectors\n-     * must be the same length. Returns `true` if `self` changed.\n-    */\n+    /// Calculate the intersection of two bitvectors, acts like bitwise and.\n+    ///\n+    /// Set `self` to the intersection of `self` and `other`. Both bitvectors\n+    /// must be the same length. Return `true` if `self` changed.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Assert if the bitvectors are of different length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv1: Bitv = [false, true, true, false].iter().map(|n| *n).collect();\n+    /// let bv2: Bitv = [false, true, false, true].iter().map(|n| *n).collect();\n+    /// let res: Bitv = [false, true, false, false].iter().map(|n| *n).collect();\n+    ///\n+    /// assert!(bv1.intersect(&bv2));\n+    /// assert_eq!(bv1, res);\n+    /// ```\n     #[inline]\n     pub fn intersect(&mut self, other: &Bitv) -> bool {\n         self.process(other, |w1, w2| w1 & w2)\n     }\n \n-    /**\n-     * Calculate the difference between two bitvectors\n-     *\n-     * Sets each element of `v0` to the value of that element minus the\n-     * element of `v1` at the same index. Both bitvectors must be the same\n-     * length.\n-     *\n-     * Returns `true` if `v0` was changed.\n-     */\n+    /// Calculate the difference between two bitvectors.\n+    ///\n+    /// Set each element of `self` to the value of that element minus the\n+    /// element of `other` at the same index. Both bitvectors must be the same\n+    /// length. Return `true` if `self` changed.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Assert if the bitvectors are of different length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let mut bv1: Bitv = [false, true, true, false].iter().map(|n| *n).collect();\n+    /// let bv2: Bitv = [false, true, false, true].iter().map(|n| *n).collect();\n+    /// let res: Bitv = [false, false, true, false].iter().map(|n| *n).collect();\n+    ///\n+    /// assert!(bv1.difference(&bv2));\n+    /// assert_eq!(bv1, res);\n+    /// ```\n     #[inline]\n     pub fn difference(&mut self, other: &Bitv) -> bool {\n         self.process(other, |w1, w2| w1 & !w2)\n     }\n \n-    /// Returns `true` if all bits are 1\n+    /// Returns `true` if all bits are 1.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::bitv::Bitv;\n+    ///\n+    /// let mut bv = Bitv::with_capacity(5, true);\n+    /// assert_eq!(bv.all(), true);\n+    ///\n+    /// bv.set(1, false);\n+    /// assert_eq!(bv.all(), false);\n+    /// ```\n     #[inline]\n     pub fn all(&self) -> bool {\n         let mut last_word = !0u;\n@@ -254,43 +370,83 @@ impl Bitv {\n         (last_word == ((1 << self.nbits % uint::BITS) - 1) || last_word == !0u)\n     }\n \n-    /// Returns an iterator over the elements of the vector in order.\n+    /// Return an iterator over the elements of the vector in order.\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// use collections::bitv::Bitv;\n+    /// ```\n+    /// use std::collections::bitv::Bitv;\n+    ///\n     /// let mut bv = Bitv::with_capacity(10, false);\n     /// bv.set(1, true);\n     /// bv.set(2, true);\n     /// bv.set(3, true);\n     /// bv.set(5, true);\n     /// bv.set(8, true);\n-    /// // Count bits set to 1; result should be 5\n-    /// println!(\"{}\", bv.iter().filter(|x| *x).count());\n+    ///\n+    /// assert_eq!(bv.iter().filter(|x| *x).count(), 5);\n     /// ```\n     #[inline]\n     pub fn iter<'a>(&'a self) -> Bits<'a> {\n         Bits {bitv: self, next_idx: 0, end_idx: self.nbits}\n     }\n \n-    /// Returns `true` if all bits are 0\n+    /// Return `true` if all bits are 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::bitv::Bitv;\n+    ///\n+    /// let mut bv = Bitv::with_capacity(10, false);\n+    /// assert_eq!(bv.none(), true);\n+    ///\n+    /// bv.set(3, true);\n+    /// assert_eq!(bv.none(), false);\n+    /// ```\n     pub fn none(&self) -> bool {\n         self.mask_words(0).all(|(_, w)| w == 0)\n     }\n \n+    /// Return `true` if any bit is 1.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::bitv::Bitv;\n+    ///\n+    /// let mut bv = Bitv::with_capacity(10, false);\n+    /// assert_eq!(bv.any(), false);\n+    ///\n+    /// bv.set(3, true);\n+    /// assert_eq!(bv.any(), true);\n+    /// ```\n     #[inline]\n-    /// Returns `true` if any bit is 1\n     pub fn any(&self) -> bool {\n         !self.none()\n     }\n \n-    /**\n-     * Organise the bits into bytes, such that the first bit in the\n-     * `Bitv` becomes the high-order bit of the first byte. If the\n-     * size of the `Bitv` is not a multiple of 8 then trailing bits\n-     * will be filled-in with false/0\n-     */\n+    /// Organise the bits into bytes, such that the first bit in the\n+    /// `Bitv` becomes the high-order bit of the first byte. If the\n+    /// size of the `Bitv` is not a multiple of 8 then trailing bits\n+    /// will be filled-in with false/0.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::bitv::Bitv;\n+    ///\n+    /// let mut bv = Bitv::with_capacity(3, true);\n+    /// bv.set(1, false);\n+    ///\n+    /// assert_eq!(bv.to_bytes(), vec!(0b10100000));\n+    ///\n+    /// let mut bv = Bitv::with_capacity(9, false);\n+    /// bv.set(2, true);\n+    /// bv.set(8, true);\n+    ///\n+    /// assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n+    /// ```\n     pub fn to_bytes(&self) -> Vec<u8> {\n         fn bit (bitv: &Bitv, byte: uint, bit: uint) -> u8 {\n             let offset = byte * 8 + bit;\n@@ -315,18 +471,35 @@ impl Bitv {\n         )\n     }\n \n-    /**\n-     * Transform `self` into a `Vec<bool>` by turning each bit into a `bool`.\n-     */\n+    /// Transform `self` into a `Vec<bool>` by turning each bit into a `bool`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::bitv::Bitv;\n+    ///\n+    /// let bv: Bitv = [true, false, true].iter().map(|n| *n).collect();\n+    /// assert_eq!(bv.to_bools(), vec!(true, false, true));\n+    /// ```\n     pub fn to_bools(&self) -> Vec<bool> {\n         Vec::from_fn(self.nbits, |i| self.get(i))\n     }\n \n-    /**\n-     * Compare a bitvector to a vector of `bool`.\n-     *\n-     * Both the bitvector and vector must have the same length.\n-     */\n+    /// Compare a bitvector to a vector of `bool`.\n+    /// Both the bitvector and vector must have the same length.\n+    /// # Failure\n+    ///\n+    /// Assert if the bitvectors are of different length.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::Bitv;\n+    ///\n+    /// let bv: Bitv = [false, true, true].iter().map(|n| *n).collect();\n+    ///\n+    /// assert!(bv.eq_vec([false, true, true]));\n+    /// ```\n     pub fn eq_vec(&self, v: &[bool]) -> bool {\n         assert_eq!(self.nbits, v.len());\n         let mut i = 0;\n@@ -344,12 +517,12 @@ impl Bitv {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// use collections::bitv::Bitv;\n-    /// let mut bvec: Bitv = vec![false, true, true, false].iter().map(|n| *n).collect();\n-    /// let expected: Bitv = vec![false, true].iter().map(|n| *n).collect();\n-    /// bvec.truncate(2);\n-    /// assert_eq!(bvec, expected);\n+    /// ```\n+    /// use std::collections::bitv::Bitv;\n+    ///\n+    /// let mut bv: Bitv = [false, true, true, false].iter().map(|n| *n).collect();\n+    /// bv.truncate(2);\n+    /// assert!(bv.eq_vec([false, true]));\n     /// ```\n     pub fn truncate(&mut self, len: uint) {\n         if len < self.len() {\n@@ -363,7 +536,18 @@ impl Bitv {\n         }\n     }\n \n-    /// Grows the vector to be able to store `size` bits without resizing\n+    /// Grow the vector to be able to store `size` bits without resizing.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::bitv::Bitv;\n+    ///\n+    /// let mut bv = Bitv::with_capacity(3, false);\n+    /// bv.reserve(10);\n+    /// assert_eq!(bv.len(), 3);\n+    /// assert!(bv.capacity() >= 10);\n+    /// ```\n     pub fn reserve(&mut self, size: uint) {\n         let old_size = self.storage.len();\n         let size = (size + uint::BITS - 1) / uint::BITS;\n@@ -372,24 +556,33 @@ impl Bitv {\n         }\n     }\n \n-    /// Returns the capacity in bits for this bit vector. Inserting any\n+    /// Return the capacity in bits for this bit vector. Inserting any\n     /// element less than this amount will not trigger a resizing.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::bitv::Bitv;\n+    ///\n+    /// let mut bv = Bitv::new();\n+    /// bv.reserve(10);\n+    /// assert!(bv.capacity() >= 10);\n+    /// ```\n     #[inline]\n     pub fn capacity(&self) -> uint {\n         self.storage.len() * uint::BITS\n     }\n \n-    /// Grows the `Bitv` in-place.\n-    ///\n-    /// Adds `n` copies of `value` to the `Bitv`.\n+    /// Grow the `Bitv` in-place. Add `n` copies of `value` to the `Bitv`.\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// use collections::bitv::Bitv;\n-    /// let mut bvec: Bitv = vec![false, true, true, false].iter().map(|n| *n).collect();\n-    /// bvec.grow(2, true);\n-    /// assert_eq!(bvec, vec![false, true, true, false, true, true].iter().map(|n| *n).collect());\n+    /// ```\n+    /// use std::collections::bitv::Bitv;\n+    ///\n+    /// let mut bv: Bitv = [false, true, true, false].iter().map(|n| *n).collect();\n+    /// bv.grow(2, true);\n+    /// assert!(bv.eq_vec([false, true, true, false, true, true]));\n     /// ```\n     pub fn grow(&mut self, n: uint, value: bool) {\n         let new_nbits = self.nbits + n;\n@@ -420,17 +613,20 @@ impl Bitv {\n         self.nbits = new_nbits;\n     }\n \n-    /// Shorten a `Bitv` by one, returning the removed element\n+    /// Shorten by one and return the removed element.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Assert if empty.\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// use collections::bitv::Bitv;\n-    /// let mut bvec: Bitv = vec![false, true, true, false].iter().map(|n| *n).collect();\n-    /// let expected: Bitv = vec![false, true, true].iter().map(|n| *n).collect();\n-    /// let popped = bvec.pop();\n-    /// assert_eq!(popped, false);\n-    /// assert_eq!(bvec, expected);\n+    /// ```\n+    /// use std::collections::bitv::Bitv;\n+    ///\n+    /// let mut bv: Bitv = [false, true, true, false].iter().map(|n| *n).collect();\n+    /// assert_eq!(bv.pop(), false);\n+    /// assert!(bv.eq_vec([false, true, true]));\n     /// ```\n     pub fn pop(&mut self) -> bool {\n         let ret = self.get(self.nbits - 1);\n@@ -442,17 +638,17 @@ impl Bitv {\n         ret\n     }\n \n-    /// Pushes a `bool` onto the `Bitv`\n+    /// Push a `bool` onto the end.\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n-    /// use collections::bitv::Bitv;\n-    /// let prototype: Bitv = vec![false, true, true, false].iter().map(|n| *n).collect();\n-    /// let mut bvec: Bitv = vec![false, true].iter().map(|n| *n).collect();\n-    /// bvec.push(true);\n-    /// bvec.push(false);\n-    /// assert_eq!(prototype, bvec);\n+    /// ```\n+    /// use std::collections::bitv::Bitv;\n+    ///\n+    /// let mut bv: Bitv = [false, true].iter().map(|n| *n).collect();\n+    /// bv.push(true);\n+    /// bv.push(false);\n+    /// assert!(bv.eq_vec([false, true, true, false]));\n     /// ```\n     pub fn push(&mut self, elem: bool) {\n         let insert_pos = self.nbits;\n@@ -464,11 +660,21 @@ impl Bitv {\n     }\n }\n \n-/**\n- * Transform a byte-vector into a `Bitv`. Each byte becomes 8 bits,\n- * with the most significant bits of each byte coming first. Each\n- * bit becomes `true` if equal to 1 or `false` if equal to 0.\n- */\n+/// Transform a byte-vector into a `Bitv`. Each byte becomes 8 bits,\n+/// with the most significant bits of each byte coming first. Each\n+/// bit becomes `true` if equal to 1 or `false` if equal to 0.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::bitv::from_bytes;\n+///\n+/// let bv = from_bytes([0b10100000, 0b00010010]);\n+/// assert!(bv.eq_vec([true, false, true, false,\n+///                    false, false, false, false,\n+///                    false, false, false, true,\n+///                    false, false, true, false]));\n+/// ```\n pub fn from_bytes(bytes: &[u8]) -> Bitv {\n     from_fn(bytes.len() * 8, |i| {\n         let b = bytes[i / 8] as uint;\n@@ -477,10 +683,17 @@ pub fn from_bytes(bytes: &[u8]) -> Bitv {\n     })\n }\n \n-/**\n- * Create a `Bitv` of the specified length where the value at each\n- * index is `f(index)`.\n- */\n+/// Create a `Bitv` of the specified length where the value at each\n+/// index is `f(index)`.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::bitv::from_fn;\n+///\n+/// let bv = from_fn(5, |i| { i % 2 == 0 });\n+/// assert!(bv.eq_vec([true, false, true, false, true]));\n+/// ```\n pub fn from_fn(len: uint, f: |index: uint| -> bool) -> Bitv {\n     let mut bitv = Bitv::with_capacity(len, false);\n     for i in range(0u, len) {"}]}