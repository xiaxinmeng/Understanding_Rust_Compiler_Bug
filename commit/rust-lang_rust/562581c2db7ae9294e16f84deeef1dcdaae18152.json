{"sha": "562581c2db7ae9294e16f84deeef1dcdaae18152", "node_id": "C_kwDOAAsO6NoAKDU2MjU4MWMyZGI3YWU5Mjk0ZTE2Zjg0ZGVlZWYxZGNkYWFlMTgxNTI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-08T17:32:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-08T17:32:41Z"}, "message": "Rollup merge of #105641 - Amanieu:btree_cursor, r=m-ou-se\n\nImplement cursors for BTreeMap\n\nSee the ACP for an overview of the API: https://github.com/rust-lang/libs-team/issues/141\n\nThe implementation is split into 2 commits:\n- The first changes the internal insertion functions to return a handle to the newly inserted element. The lifetimes involved are a bit hairy since we need a mutable handle to both the `BTreeMap` itself (which holds the root) and the nodes allocated in memory. I have tested that this passes the standard library testsuite under miri.\n- The second commit implements the cursor API itself. This is more straightforward to follow but still involves some unsafe code to deal with simultaneous mutable borrows of the tree root and the node that is currently being iterated.", "tree": {"sha": "656cd9d2677908d494525f12a4c2547206b80aed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/656cd9d2677908d494525f12a4c2547206b80aed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/562581c2db7ae9294e16f84deeef1dcdaae18152", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj49y5CRBK7hj4Ov3rIwAA+tUIAI/NAPxfbDF6pPnnt9VoatQ7\n4kCSQM+i5g2IPu0RgB3NIjPMqKFkuLJpwj74IaZXZpxYyweQDL2J80ZNi6s8pZuk\nTGUIFYgjnhNOBS/7jyi2zcpuiUMjjqZuQiibb7bSBfnHyyLEbJud0nh5XabzhQxT\n939FA7rC3F9MMfUdQ/rQ81uuYcKUSiirnT2/CsUQR84IITfiq/Vgb8mkWYS6cJOS\nhy0caGlgt8to655kfsx8G3lV9nwIollwWMYeCKWVkSJX1ip23bgzaKLOkqhgtJwi\npisrvesM0I9+e4PyxXW90Uk8SjAJ0ZavdQvx3TQ6Q9OLo5CkcuCzbBux8hiGUTA=\n=AGWq\n-----END PGP SIGNATURE-----\n", "payload": "tree 656cd9d2677908d494525f12a4c2547206b80aed\nparent a00e24d76a9ac03b146d3bf89e2161b2466c6551\nparent 36831b3ccbc4104c6b559cbd341dbd7ee6251ec7\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1675877561 +0100\ncommitter GitHub <noreply@github.com> 1675877561 +0100\n\nRollup merge of #105641 - Amanieu:btree_cursor, r=m-ou-se\n\nImplement cursors for BTreeMap\n\nSee the ACP for an overview of the API: https://github.com/rust-lang/libs-team/issues/141\n\nThe implementation is split into 2 commits:\n- The first changes the internal insertion functions to return a handle to the newly inserted element. The lifetimes involved are a bit hairy since we need a mutable handle to both the `BTreeMap` itself (which holds the root) and the nodes allocated in memory. I have tested that this passes the standard library testsuite under miri.\n- The second commit implements the cursor API itself. This is more straightforward to follow but still involves some unsafe code to deal with simultaneous mutable borrows of the tree root and the node that is currently being iterated.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/562581c2db7ae9294e16f84deeef1dcdaae18152", "html_url": "https://github.com/rust-lang/rust/commit/562581c2db7ae9294e16f84deeef1dcdaae18152", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/562581c2db7ae9294e16f84deeef1dcdaae18152/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a00e24d76a9ac03b146d3bf89e2161b2466c6551", "url": "https://api.github.com/repos/rust-lang/rust/commits/a00e24d76a9ac03b146d3bf89e2161b2466c6551", "html_url": "https://github.com/rust-lang/rust/commit/a00e24d76a9ac03b146d3bf89e2161b2466c6551"}, {"sha": "36831b3ccbc4104c6b559cbd341dbd7ee6251ec7", "url": "https://api.github.com/repos/rust-lang/rust/commits/36831b3ccbc4104c6b559cbd341dbd7ee6251ec7", "html_url": "https://github.com/rust-lang/rust/commit/36831b3ccbc4104c6b559cbd341dbd7ee6251ec7"}], "stats": {"total": 998, "additions": 957, "deletions": 41}, "files": [{"sha": "000b9bd0fab42408a790d5b811c06f94385eba8a", "filename": "library/alloc/src/collections/btree/borrow.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/562581c2db7ae9294e16f84deeef1dcdaae18152/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562581c2db7ae9294e16f84deeef1dcdaae18152/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs?ref=562581c2db7ae9294e16f84deeef1dcdaae18152", "patch": "@@ -41,6 +41,28 @@ impl<'a, T> DormantMutRef<'a, T> {\n         // SAFETY: our own safety conditions imply this reference is again unique.\n         unsafe { &mut *self.ptr.as_ptr() }\n     }\n+\n+    /// Borrows a new mutable reference from the unique borrow initially captured.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The reborrow must have ended, i.e., the reference returned by `new` and\n+    /// all pointers and references derived from it, must not be used anymore.\n+    pub unsafe fn reborrow(&mut self) -> &'a mut T {\n+        // SAFETY: our own safety conditions imply this reference is again unique.\n+        unsafe { &mut *self.ptr.as_ptr() }\n+    }\n+\n+    /// Borrows a new shared reference from the unique borrow initially captured.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The reborrow must have ended, i.e., the reference returned by `new` and\n+    /// all pointers and references derived from it, must not be used anymore.\n+    pub unsafe fn reborrow_shared(&self) -> &'a T {\n+        // SAFETY: our own safety conditions imply this reference is again unique.\n+        unsafe { &*self.ptr.as_ptr() }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "386cd1a1657e26f0dd9934dee92af16020cfe9fa", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 728, "deletions": 2, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/562581c2db7ae9294e16f84deeef1dcdaae18152/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562581c2db7ae9294e16f84deeef1dcdaae18152/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=562581c2db7ae9294e16f84deeef1dcdaae18152", "patch": "@@ -6,7 +6,7 @@ use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, FusedIterator};\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop};\n-use core::ops::{Index, RangeBounds};\n+use core::ops::{Bound, Index, RangeBounds};\n use core::ptr;\n \n use crate::alloc::{Allocator, Global};\n@@ -15,7 +15,7 @@ use super::borrow::DormantMutRef;\n use super::dedup_sorted_iter::DedupSortedIter;\n use super::navigate::{LazyLeafRange, LeafRange};\n use super::node::{self, marker, ForceResult::*, Handle, NodeRef, Root};\n-use super::search::SearchResult::*;\n+use super::search::{SearchBound, SearchResult::*};\n use super::set_val::SetValZST;\n \n mod entry;\n@@ -2422,6 +2422,732 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     pub const fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n+\n+    /// Returns a [`Cursor`] pointing at the first element that is above the\n+    /// given bound.\n+    ///\n+    /// If no such element exists then a cursor pointing at the \"ghost\"\n+    /// non-element is returned.\n+    ///\n+    /// Passing [`Bound::Unbounded`] will return a cursor pointing at the first\n+    /// element of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(btree_cursors)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::ops::Bound;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(4, \"c\");\n+    /// let cursor = a.lower_bound(Bound::Excluded(&2));\n+    /// assert_eq!(cursor.key(), Some(&3));\n+    /// ```\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn lower_bound<Q>(&self, bound: Bound<&Q>) -> Cursor<'_, K, V>\n+    where\n+        K: Borrow<Q> + Ord,\n+        Q: Ord,\n+    {\n+        let root_node = match self.root.as_ref() {\n+            None => return Cursor { current: None, root: None },\n+            Some(root) => root.reborrow(),\n+        };\n+        let edge = root_node.lower_bound(SearchBound::from_range(bound));\n+        Cursor { current: edge.next_kv().ok(), root: self.root.as_ref() }\n+    }\n+\n+    /// Returns a [`CursorMut`] pointing at the first element that is above the\n+    /// given bound.\n+    ///\n+    /// If no such element exists then a cursor pointing at the \"ghost\"\n+    /// non-element is returned.\n+    ///\n+    /// Passing [`Bound::Unbounded`] will return a cursor pointing at the first\n+    /// element of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(btree_cursors)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::ops::Bound;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(4, \"c\");\n+    /// let cursor = a.lower_bound_mut(Bound::Excluded(&2));\n+    /// assert_eq!(cursor.key(), Some(&3));\n+    /// ```\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn lower_bound_mut<Q>(&mut self, bound: Bound<&Q>) -> CursorMut<'_, K, V, A>\n+    where\n+        K: Borrow<Q> + Ord,\n+        Q: Ord,\n+    {\n+        let (root, dormant_root) = DormantMutRef::new(&mut self.root);\n+        let root_node = match root.as_mut() {\n+            None => {\n+                return CursorMut {\n+                    current: None,\n+                    root: dormant_root,\n+                    length: &mut self.length,\n+                    alloc: &mut *self.alloc,\n+                };\n+            }\n+            Some(root) => root.borrow_mut(),\n+        };\n+        let edge = root_node.lower_bound(SearchBound::from_range(bound));\n+        CursorMut {\n+            current: edge.next_kv().ok(),\n+            root: dormant_root,\n+            length: &mut self.length,\n+            alloc: &mut *self.alloc,\n+        }\n+    }\n+\n+    /// Returns a [`Cursor`] pointing at the last element that is below the\n+    /// given bound.\n+    ///\n+    /// If no such element exists then a cursor pointing at the \"ghost\"\n+    /// non-element is returned.\n+    ///\n+    /// Passing [`Bound::Unbounded`] will return a cursor pointing at the last\n+    /// element of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(btree_cursors)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::ops::Bound;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(4, \"c\");\n+    /// let cursor = a.upper_bound(Bound::Excluded(&3));\n+    /// assert_eq!(cursor.key(), Some(&2));\n+    /// ```\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn upper_bound<Q>(&self, bound: Bound<&Q>) -> Cursor<'_, K, V>\n+    where\n+        K: Borrow<Q> + Ord,\n+        Q: Ord,\n+    {\n+        let root_node = match self.root.as_ref() {\n+            None => return Cursor { current: None, root: None },\n+            Some(root) => root.reborrow(),\n+        };\n+        let edge = root_node.upper_bound(SearchBound::from_range(bound));\n+        Cursor { current: edge.next_back_kv().ok(), root: self.root.as_ref() }\n+    }\n+\n+    /// Returns a [`CursorMut`] pointing at the last element that is below the\n+    /// given bound.\n+    ///\n+    /// If no such element exists then a cursor pointing at the \"ghost\"\n+    /// non-element is returned.\n+    ///\n+    /// Passing [`Bound::Unbounded`] will return a cursor pointing at the last\n+    /// element of the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(btree_cursors)]\n+    ///\n+    /// use std::collections::BTreeMap;\n+    /// use std::ops::Bound;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    /// a.insert(3, \"c\");\n+    /// a.insert(4, \"c\");\n+    /// let cursor = a.upper_bound_mut(Bound::Excluded(&3));\n+    /// assert_eq!(cursor.key(), Some(&2));\n+    /// ```\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn upper_bound_mut<Q>(&mut self, bound: Bound<&Q>) -> CursorMut<'_, K, V, A>\n+    where\n+        K: Borrow<Q> + Ord,\n+        Q: Ord,\n+    {\n+        let (root, dormant_root) = DormantMutRef::new(&mut self.root);\n+        let root_node = match root.as_mut() {\n+            None => {\n+                return CursorMut {\n+                    current: None,\n+                    root: dormant_root,\n+                    length: &mut self.length,\n+                    alloc: &mut *self.alloc,\n+                };\n+            }\n+            Some(root) => root.borrow_mut(),\n+        };\n+        let edge = root_node.upper_bound(SearchBound::from_range(bound));\n+        CursorMut {\n+            current: edge.next_back_kv().ok(),\n+            root: dormant_root,\n+            length: &mut self.length,\n+            alloc: &mut *self.alloc,\n+        }\n+    }\n+}\n+\n+/// A cursor over a `BTreeMap`.\n+///\n+/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth.\n+///\n+/// Cursors always point to an element in the tree, and index in a logically circular way.\n+/// To accommodate this, there is a \"ghost\" non-element that yields `None` between the last and\n+/// first elements of the tree.\n+///\n+/// A `Cursor` is created with the [`BTreeMap::lower_bound`] and [`BTreeMap::upper_bound`] methods.\n+#[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+pub struct Cursor<'a, K: 'a, V: 'a> {\n+    current: Option<Handle<NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>, marker::KV>>,\n+    root: Option<&'a node::Root<K, V>>,\n+}\n+\n+#[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+impl<K, V> Clone for Cursor<'_, K, V> {\n+    fn clone(&self) -> Self {\n+        let Cursor { current, root } = *self;\n+        Cursor { current, root }\n+    }\n+}\n+\n+#[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+impl<K: Debug, V: Debug> Debug for Cursor<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"Cursor\").field(&self.key_value()).finish()\n+    }\n+}\n+\n+/// A cursor over a `BTreeMap` with editing operations.\n+///\n+/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth, and can\n+/// safely mutate the tree during iteration. This is because the lifetime of its yielded\n+/// references is tied to its own lifetime, instead of just the underlying tree. This means\n+/// cursors cannot yield multiple elements at once.\n+///\n+/// Cursors always point to an element in the tree, and index in a logically circular way.\n+/// To accommodate this, there is a \"ghost\" non-element that yields `None` between the last and\n+/// first elements of the tree.\n+///\n+/// A `Cursor` is created with the [`BTreeMap::lower_bound_mut`] and [`BTreeMap::upper_bound_mut`]\n+/// methods.\n+#[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+pub struct CursorMut<\n+    'a,\n+    K: 'a,\n+    V: 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A = Global,\n+> {\n+    current: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>>,\n+    root: DormantMutRef<'a, Option<node::Root<K, V>>>,\n+    length: &'a mut usize,\n+    alloc: &'a mut A,\n+}\n+\n+#[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+impl<K: Debug, V: Debug, A> Debug for CursorMut<'_, K, V, A> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"CursorMut\").field(&self.key_value()).finish()\n+    }\n+}\n+\n+impl<'a, K, V> Cursor<'a, K, V> {\n+    /// Moves the cursor to the next element of the `BTreeMap`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the first element of the `BTreeMap`. If it is pointing to the last\n+    /// element of the `BTreeMap` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn move_next(&mut self) {\n+        match self.current.take() {\n+            None => {\n+                self.current = self.root.and_then(|root| {\n+                    root.reborrow().first_leaf_edge().forget_node_type().right_kv().ok()\n+                });\n+            }\n+            Some(current) => {\n+                self.current = current.next_leaf_edge().next_kv().ok();\n+            }\n+        }\n+    }\n+\n+    /// Moves the cursor to the previous element of the `BTreeMap`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the last element of the `BTreeMap`. If it is pointing to the first\n+    /// element of the `BTreeMap` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn move_prev(&mut self) {\n+        match self.current.take() {\n+            None => {\n+                self.current = self.root.and_then(|root| {\n+                    root.reborrow().last_leaf_edge().forget_node_type().left_kv().ok()\n+                });\n+            }\n+            Some(current) => {\n+                self.current = current.next_back_leaf_edge().next_back_kv().ok();\n+            }\n+        }\n+    }\n+\n+    /// Returns a reference to the key of the element that the cursor is\n+    /// currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn key(&self) -> Option<&'a K> {\n+        self.current.as_ref().map(|current| current.into_kv().0)\n+    }\n+\n+    /// Returns a reference to the value of the element that the cursor is\n+    /// currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn value(&self) -> Option<&'a V> {\n+        self.current.as_ref().map(|current| current.into_kv().1)\n+    }\n+\n+    /// Returns a reference to the key and value of the element that the cursor\n+    /// is currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn key_value(&self) -> Option<(&'a K, &'a V)> {\n+        self.current.as_ref().map(|current| current.into_kv())\n+    }\n+\n+    /// Returns a reference to the next element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the first element of the `BTreeMap`. If it is pointing to the last\n+    /// element of the `BTreeMap` then this returns `None`.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn peek_next(&self) -> Option<(&'a K, &'a V)> {\n+        let mut next = self.clone();\n+        next.move_next();\n+        next.current.as_ref().map(|current| current.into_kv())\n+    }\n+\n+    /// Returns a reference to the previous element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the last element of the `BTreeMap`. If it is pointing to the first\n+    /// element of the `BTreeMap` then this returns `None`.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn peek_prev(&self) -> Option<(&'a K, &'a V)> {\n+        let mut prev = self.clone();\n+        prev.move_prev();\n+        prev.current.as_ref().map(|current| current.into_kv())\n+    }\n+}\n+\n+impl<'a, K, V, A> CursorMut<'a, K, V, A> {\n+    /// Moves the cursor to the next element of the `BTreeMap`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the first element of the `BTreeMap`. If it is pointing to the last\n+    /// element of the `BTreeMap` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn move_next(&mut self) {\n+        match self.current.take() {\n+            None => {\n+                // SAFETY: The previous borrow of root has ended.\n+                self.current = unsafe { self.root.reborrow() }.as_mut().and_then(|root| {\n+                    root.borrow_mut().first_leaf_edge().forget_node_type().right_kv().ok()\n+                });\n+            }\n+            Some(current) => {\n+                self.current = current.next_leaf_edge().next_kv().ok();\n+            }\n+        }\n+    }\n+\n+    /// Moves the cursor to the previous element of the `BTreeMap`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the last element of the `BTreeMap`. If it is pointing to the first\n+    /// element of the `BTreeMap` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn move_prev(&mut self) {\n+        match self.current.take() {\n+            None => {\n+                // SAFETY: The previous borrow of root has ended.\n+                self.current = unsafe { self.root.reborrow() }.as_mut().and_then(|root| {\n+                    root.borrow_mut().last_leaf_edge().forget_node_type().left_kv().ok()\n+                });\n+            }\n+            Some(current) => {\n+                self.current = current.next_back_leaf_edge().next_back_kv().ok();\n+            }\n+        }\n+    }\n+\n+    /// Returns a reference to the key of the element that the cursor is\n+    /// currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn key(&self) -> Option<&K> {\n+        self.current.as_ref().map(|current| current.reborrow().into_kv().0)\n+    }\n+\n+    /// Returns a reference to the value of the element that the cursor is\n+    /// currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn value(&self) -> Option<&V> {\n+        self.current.as_ref().map(|current| current.reborrow().into_kv().1)\n+    }\n+\n+    /// Returns a reference to the key and value of the element that the cursor\n+    /// is currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn key_value(&self) -> Option<(&K, &V)> {\n+        self.current.as_ref().map(|current| current.reborrow().into_kv())\n+    }\n+\n+    /// Returns a mutable reference to the value of the element that the cursor\n+    /// is currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn value_mut(&mut self) -> Option<&mut V> {\n+        self.current.as_mut().map(|current| current.kv_mut().1)\n+    }\n+\n+    /// Returns a reference to the key and mutable reference to the value of the\n+    /// element that the cursor is currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn key_value_mut(&mut self) -> Option<(&K, &mut V)> {\n+        self.current.as_mut().map(|current| {\n+            let (k, v) = current.kv_mut();\n+            (&*k, v)\n+        })\n+    }\n+\n+    /// Returns a mutable reference to the of the element that the cursor is\n+    /// currently pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This can be used to modify the key, but you must ensure that the\n+    /// `BTreeMap` invariants are maintained. Specifically:\n+    ///\n+    /// * The key must remain unique within the tree.\n+    /// * The key must remain in sorted order with regards to other elements in\n+    ///   the tree.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub unsafe fn key_mut_unchecked(&mut self) -> Option<&mut K> {\n+        self.current.as_mut().map(|current| current.kv_mut().0)\n+    }\n+\n+    /// Returns a reference to the key and value of the next element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the first element of the `BTreeMap`. If it is pointing to the last\n+    /// element of the `BTreeMap` then this returns `None`.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn peek_next(&mut self) -> Option<(&K, &mut V)> {\n+        let (k, v) = match self.current {\n+            None => {\n+                // SAFETY: The previous borrow of root has ended.\n+                unsafe { self.root.reborrow() }\n+                    .as_mut()?\n+                    .borrow_mut()\n+                    .first_leaf_edge()\n+                    .next_kv()\n+                    .ok()?\n+                    .into_kv_valmut()\n+            }\n+            // SAFETY: We're not using this to mutate the tree.\n+            Some(ref mut current) => {\n+                unsafe { current.reborrow_mut() }.next_leaf_edge().next_kv().ok()?.into_kv_valmut()\n+            }\n+        };\n+        Some((k, v))\n+    }\n+\n+    /// Returns a reference to the key and value of the previous element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the last element of the `BTreeMap`. If it is pointing to the first\n+    /// element of the `BTreeMap` then this returns `None`.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn peek_prev(&mut self) -> Option<(&K, &mut V)> {\n+        let (k, v) = match self.current.as_mut() {\n+            None => {\n+                // SAFETY: The previous borrow of root has ended.\n+                unsafe { self.root.reborrow() }\n+                    .as_mut()?\n+                    .borrow_mut()\n+                    .first_leaf_edge()\n+                    .next_kv()\n+                    .ok()?\n+                    .into_kv_valmut()\n+            }\n+            Some(current) => {\n+                // SAFETY: We're not using this to mutate the tree.\n+                unsafe { current.reborrow_mut() }\n+                    .next_back_leaf_edge()\n+                    .next_back_kv()\n+                    .ok()?\n+                    .into_kv_valmut()\n+            }\n+        };\n+        Some((k, v))\n+    }\n+\n+    /// Returns a read-only cursor pointing to the current element.\n+    ///\n+    /// The lifetime of the returned `Cursor` is bound to that of the\n+    /// `CursorMut`, which means it cannot outlive the `CursorMut` and that the\n+    /// `CursorMut` is frozen for the lifetime of the `Cursor`.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn as_cursor(&self) -> Cursor<'_, K, V> {\n+        Cursor {\n+            // SAFETY: The tree is immutable while the cursor exists.\n+            root: unsafe { self.root.reborrow_shared().as_ref() },\n+            current: self.current.as_ref().map(|current| current.reborrow()),\n+        }\n+    }\n+}\n+\n+// Now the tree editing operations\n+impl<'a, K: Ord, V, A: Allocator + Clone> CursorMut<'a, K, V, A> {\n+    /// Inserts a new element into the `BTreeMap` after the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the front of the `BTreeMap`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// You must ensure that the `BTreeMap` invariants are maintained.\n+    /// Specifically:\n+    ///\n+    /// * The key of the newly inserted element must be unique in the tree.\n+    /// * All keys in the tree must remain in sorted order.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub unsafe fn insert_after_unchecked(&mut self, key: K, value: V) {\n+        let edge = match self.current.take() {\n+            None => {\n+                // SAFETY: We have no other reference to the tree.\n+                match unsafe { self.root.reborrow() } {\n+                    root @ None => {\n+                        // Tree is empty, allocate a new root.\n+                        let mut node = NodeRef::new_leaf(self.alloc.clone());\n+                        node.borrow_mut().push(key, value);\n+                        *root = Some(node.forget_type());\n+                        *self.length += 1;\n+                        return;\n+                    }\n+                    Some(root) => root.borrow_mut().first_leaf_edge(),\n+                }\n+            }\n+            Some(current) => current.next_leaf_edge(),\n+        };\n+\n+        let handle = edge.insert_recursing(key, value, self.alloc.clone(), |ins| {\n+            drop(ins.left);\n+            // SAFETY: The handle to the newly inserted value is always on a\n+            // leaf node, so adding a new root node doesn't invalidate it.\n+            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n+            root.push_internal_level(self.alloc.clone()).push(ins.kv.0, ins.kv.1, ins.right)\n+        });\n+        self.current = handle.left_edge().next_back_kv().ok();\n+        *self.length += 1;\n+    }\n+\n+    /// Inserts a new element into the `BTreeMap` before the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the end of the `BTreeMap`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// You must ensure that the `BTreeMap` invariants are maintained.\n+    /// Specifically:\n+    ///\n+    /// * The key of the newly inserted element must be unique in the tree.\n+    /// * All keys in the tree must remain in sorted order.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub unsafe fn insert_before_unchecked(&mut self, key: K, value: V) {\n+        let edge = match self.current.take() {\n+            None => {\n+                // SAFETY: We have no other reference to the tree.\n+                match unsafe { self.root.reborrow() } {\n+                    root @ None => {\n+                        // Tree is empty, allocate a new root.\n+                        let mut node = NodeRef::new_leaf(self.alloc.clone());\n+                        node.borrow_mut().push(key, value);\n+                        *root = Some(node.forget_type());\n+                        *self.length += 1;\n+                        return;\n+                    }\n+                    Some(root) => root.borrow_mut().last_leaf_edge(),\n+                }\n+            }\n+            Some(current) => current.next_back_leaf_edge(),\n+        };\n+\n+        let handle = edge.insert_recursing(key, value, self.alloc.clone(), |ins| {\n+            drop(ins.left);\n+            // SAFETY: The handle to the newly inserted value is always on a\n+            // leaf node, so adding a new root node doesn't invalidate it.\n+            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n+            root.push_internal_level(self.alloc.clone()).push(ins.kv.0, ins.kv.1, ins.right)\n+        });\n+        self.current = handle.right_edge().next_kv().ok();\n+        *self.length += 1;\n+    }\n+\n+    /// Inserts a new element into the `BTreeMap` after the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the front of the `BTreeMap`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if:\n+    /// - the given key compares less than or equal to the current element (if\n+    ///   any).\n+    /// - the given key compares greater than or equal to the next element (if\n+    ///   any).\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn insert_after(&mut self, key: K, value: V) {\n+        if let Some(current) = self.key() {\n+            if &key <= current {\n+                panic!(\"key must be ordered above the current element\");\n+            }\n+        }\n+        if let Some((next, _)) = self.peek_prev() {\n+            if &key >= next {\n+                panic!(\"key must be ordered below the next element\");\n+            }\n+        }\n+        unsafe {\n+            self.insert_after_unchecked(key, value);\n+        }\n+    }\n+\n+    /// Inserts a new element into the `BTreeMap` before the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the end of the `BTreeMap`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if:\n+    /// - the given key compares greater than or equal to the current element\n+    ///   (if any).\n+    /// - the given key compares less than or equal to the previous element (if\n+    ///   any).\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn insert_before(&mut self, key: K, value: V) {\n+        if let Some(current) = self.key() {\n+            if &key >= current {\n+                panic!(\"key must be ordered below the current element\");\n+            }\n+        }\n+        if let Some((prev, _)) = self.peek_prev() {\n+            if &key <= prev {\n+                panic!(\"key must be ordered above the previous element\");\n+            }\n+        }\n+        unsafe {\n+            self.insert_before_unchecked(key, value);\n+        }\n+    }\n+\n+    /// Removes the current element from the `BTreeMap`.\n+    ///\n+    /// The element that was removed is returned, and the cursor is\n+    /// moved to point to the next element in the `BTreeMap`.\n+    ///\n+    /// If the cursor is currently pointing to the \"ghost\" non-element then no element\n+    /// is removed and `None` is returned. The cursor is not moved in this case.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn remove_current(&mut self) -> Option<(K, V)> {\n+        let current = self.current.take()?;\n+        let mut emptied_internal_root = false;\n+        let (kv, pos) =\n+            current.remove_kv_tracking(|| emptied_internal_root = true, self.alloc.clone());\n+        self.current = pos.next_kv().ok();\n+        *self.length -= 1;\n+        if emptied_internal_root {\n+            // SAFETY: This is safe since current does not point within the now\n+            // empty root node.\n+            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n+            root.pop_internal_level(self.alloc.clone());\n+        }\n+        Some(kv)\n+    }\n+\n+    /// Removes the current element from the `BTreeMap`.\n+    ///\n+    /// The element that was removed is returned, and the cursor is\n+    /// moved to point to the previous element in the `BTreeMap`.\n+    ///\n+    /// If the cursor is currently pointing to the \"ghost\" non-element then no element\n+    /// is removed and `None` is returned. The cursor is not moved in this case.\n+    #[unstable(feature = \"btree_cursors\", issue = \"107540\")]\n+    pub fn remove_current_and_move_back(&mut self) -> Option<(K, V)> {\n+        let current = self.current.take()?;\n+        let mut emptied_internal_root = false;\n+        let (kv, pos) =\n+            current.remove_kv_tracking(|| emptied_internal_root = true, self.alloc.clone());\n+        self.current = pos.next_back_kv().ok();\n+        *self.length -= 1;\n+        if emptied_internal_root {\n+            // SAFETY: This is safe since current does not point within the now\n+            // empty root node.\n+            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n+            root.pop_internal_level(self.alloc.clone());\n+        }\n+        Some(kv)\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "e9366eec9cec3028a05635b62672beed4602f5d3", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/562581c2db7ae9294e16f84deeef1dcdaae18152/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562581c2db7ae9294e16f84deeef1dcdaae18152/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=562581c2db7ae9294e16f84deeef1dcdaae18152", "patch": "@@ -347,7 +347,7 @@ impl<'a, K: Ord, V, A: Allocator + Clone> VacantEntry<'a, K, V, A> {\n     /// assert_eq!(map[\"poneyland\"], 37);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(self, value: V) -> &'a mut V {\n+    pub fn insert(mut self, value: V) -> &'a mut V {\n         let out_ptr = match self.handle {\n             None => {\n                 // SAFETY: There is no tree yet so no reference to it exists.\n@@ -358,25 +358,27 @@ impl<'a, K: Ord, V, A: Allocator + Clone> VacantEntry<'a, K, V, A> {\n                 map.length = 1;\n                 val_ptr\n             }\n-            Some(handle) => match handle.insert_recursing(self.key, value, self.alloc.clone()) {\n-                (None, val_ptr) => {\n-                    // SAFETY: We have consumed self.handle.\n-                    let map = unsafe { self.dormant_map.awaken() };\n-                    map.length += 1;\n-                    val_ptr\n-                }\n-                (Some(ins), val_ptr) => {\n-                    drop(ins.left);\n-                    // SAFETY: We have consumed self.handle and dropped the\n-                    // remaining reference to the tree, ins.left.\n-                    let map = unsafe { self.dormant_map.awaken() };\n-                    let root = map.root.as_mut().unwrap(); // same as ins.left\n-                    root.push_internal_level(self.alloc).push(ins.kv.0, ins.kv.1, ins.right);\n-                    map.length += 1;\n-                    val_ptr\n-                }\n-            },\n+            Some(handle) => {\n+                let new_handle =\n+                    handle.insert_recursing(self.key, value, self.alloc.clone(), |ins| {\n+                        drop(ins.left);\n+                        // SAFETY: Pushing a new root node doesn't invalidate\n+                        // handles to existing nodes.\n+                        let map = unsafe { self.dormant_map.reborrow() };\n+                        let root = map.root.as_mut().unwrap(); // same as ins.left\n+                        root.push_internal_level(self.alloc).push(ins.kv.0, ins.kv.1, ins.right)\n+                    });\n+\n+                // Get the pointer to the value\n+                let val_ptr = new_handle.into_val_mut();\n+\n+                // SAFETY: We have consumed self.handle.\n+                let map = unsafe { self.dormant_map.awaken() };\n+                map.length += 1;\n+                val_ptr\n+            }\n         };\n+\n         // Now that we have finished growing the tree using borrowed references,\n         // dereference the pointer to a part of it, that we picked up along the way.\n         unsafe { &mut *out_ptr }"}, {"sha": "76c2f27b46634a885a663a6ba53595a74f79702c", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/562581c2db7ae9294e16f84deeef1dcdaae18152/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562581c2db7ae9294e16f84deeef1dcdaae18152/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=562581c2db7ae9294e16f84deeef1dcdaae18152", "patch": "@@ -2336,3 +2336,52 @@ fn from_array() {\n     let unordered_duplicates = BTreeMap::from([(3, 4), (1, 2), (1, 2)]);\n     assert_eq!(map, unordered_duplicates);\n }\n+\n+#[test]\n+fn test_cursor() {\n+    let map = BTreeMap::from([(1, 'a'), (2, 'b'), (3, 'c')]);\n+\n+    let mut cur = map.lower_bound(Bound::Unbounded);\n+    assert_eq!(cur.key(), Some(&1));\n+    cur.move_next();\n+    assert_eq!(cur.key(), Some(&2));\n+    assert_eq!(cur.peek_next(), Some((&3, &'c')));\n+    cur.move_prev();\n+    assert_eq!(cur.key(), Some(&1));\n+    assert_eq!(cur.peek_prev(), None);\n+\n+    let mut cur = map.upper_bound(Bound::Excluded(&1));\n+    assert_eq!(cur.key(), None);\n+    cur.move_next();\n+    assert_eq!(cur.key(), Some(&1));\n+    cur.move_prev();\n+    assert_eq!(cur.key(), None);\n+    assert_eq!(cur.peek_prev(), Some((&3, &'c')));\n+}\n+\n+#[test]\n+fn test_cursor_mut() {\n+    let mut map = BTreeMap::from([(1, 'a'), (3, 'c'), (5, 'e')]);\n+    let mut cur = map.lower_bound_mut(Bound::Excluded(&3));\n+    assert_eq!(cur.key(), Some(&5));\n+    cur.insert_before(4, 'd');\n+    assert_eq!(cur.key(), Some(&5));\n+    assert_eq!(cur.peek_prev(), Some((&4, &mut 'd')));\n+    cur.move_next();\n+    assert_eq!(cur.key(), None);\n+    cur.insert_before(6, 'f');\n+    assert_eq!(cur.key(), None);\n+    assert_eq!(cur.remove_current(), None);\n+    assert_eq!(cur.key(), None);\n+    cur.insert_after(0, '?');\n+    assert_eq!(cur.key(), None);\n+    assert_eq!(map, BTreeMap::from([(0, '?'), (1, 'a'), (3, 'c'), (4, 'd'), (5, 'e'), (6, 'f')]));\n+\n+    let mut cur = map.upper_bound_mut(Bound::Included(&5));\n+    assert_eq!(cur.key(), Some(&5));\n+    assert_eq!(cur.remove_current(), Some((5, 'e')));\n+    assert_eq!(cur.key(), Some(&6));\n+    assert_eq!(cur.remove_current_and_move_back(), Some((6, 'f')));\n+    assert_eq!(cur.key(), Some(&4));\n+    assert_eq!(map, BTreeMap::from([(0, '?'), (1, 'a'), (3, 'c'), (4, 'd')]));\n+}"}, {"sha": "b890717e50b2544b62dfbc73312ba9e975db3225", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/562581c2db7ae9294e16f84deeef1dcdaae18152/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562581c2db7ae9294e16f84deeef1dcdaae18152/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=562581c2db7ae9294e16f84deeef1dcdaae18152", "patch": "@@ -4,6 +4,7 @@ use core::ops::RangeBounds;\n use core::ptr;\n \n use super::node::{marker, ForceResult::*, Handle, NodeRef};\n+use super::search::SearchBound;\n \n use crate::alloc::Allocator;\n // `front` and `back` are always both `None` or both `Some`.\n@@ -386,7 +387,7 @@ impl<BorrowType: marker::BorrowType, K, V>\n     /// Given a leaf edge handle, returns [`Result::Ok`] with a handle to the neighboring KV\n     /// on the left side, which is either in the same leaf node or in an ancestor node.\n     /// If the leaf edge is the first one in the tree, returns [`Result::Err`] with the root node.\n-    fn next_back_kv(\n+    pub fn next_back_kv(\n         self,\n     ) -> Result<\n         Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV>,\n@@ -707,7 +708,9 @@ impl<BorrowType: marker::BorrowType, K, V>\n     }\n \n     /// Returns the leaf edge closest to a KV for backward navigation.\n-    fn next_back_leaf_edge(self) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+    pub fn next_back_leaf_edge(\n+        self,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n         match self.force() {\n             Leaf(leaf_kv) => leaf_kv.left_edge(),\n             Internal(internal_kv) => {\n@@ -717,3 +720,51 @@ impl<BorrowType: marker::BorrowType, K, V>\n         }\n     }\n }\n+\n+impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+    /// Returns the leaf edge corresponding to the first point at which the\n+    /// given bound is true.\n+    pub fn lower_bound<Q: ?Sized>(\n+        self,\n+        mut bound: SearchBound<&Q>,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>\n+    where\n+        Q: Ord,\n+        K: Borrow<Q>,\n+    {\n+        let mut node = self;\n+        loop {\n+            let (edge, new_bound) = node.find_lower_bound_edge(bound);\n+            match edge.force() {\n+                Leaf(edge) => return edge,\n+                Internal(edge) => {\n+                    node = edge.descend();\n+                    bound = new_bound;\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Returns the leaf edge corresponding to the last point at which the\n+    /// given bound is true.\n+    pub fn upper_bound<Q: ?Sized>(\n+        self,\n+        mut bound: SearchBound<&Q>,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>\n+    where\n+        Q: Ord,\n+        K: Borrow<Q>,\n+    {\n+        let mut node = self;\n+        loop {\n+            let (edge, new_bound) = node.find_upper_bound_edge(bound);\n+            match edge.force() {\n+                Leaf(edge) => return edge,\n+                Internal(edge) => {\n+                    node = edge.descend();\n+                    bound = new_bound;\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "3233a575ecf254e73fe18c3d55679716d276f96c", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 84, "deletions": 18, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/562581c2db7ae9294e16f84deeef1dcdaae18152/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562581c2db7ae9294e16f84deeef1dcdaae18152/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=562581c2db7ae9294e16f84deeef1dcdaae18152", "patch": "@@ -442,6 +442,24 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         // SAFETY: we have exclusive access to the entire node.\n         unsafe { &mut *ptr }\n     }\n+\n+    /// Returns a dormant copy of this node with its lifetime erased which can\n+    /// be reawakened later.\n+    pub fn dormant(&self) -> NodeRef<marker::DormantMut, K, V, Type> {\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n+    }\n+}\n+\n+impl<K, V, Type> NodeRef<marker::DormantMut, K, V, Type> {\n+    /// Revert to the unique borrow initially captured.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The reborrow must have ended, i.e., the reference returned by `new` and\n+    /// all pointers and references derived from it, must not be used anymore.\n+    pub unsafe fn awaken<'a>(self) -> NodeRef<marker::Mut<'a>, K, V, Type> {\n+        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n+    }\n }\n \n impl<K, V, Type> NodeRef<marker::Dying, K, V, Type> {\n@@ -798,6 +816,25 @@ impl<'a, K, V, NodeType, HandleType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeT\n         // We can't use Handle::new_kv or Handle::new_edge because we don't know our type\n         Handle { node: unsafe { self.node.reborrow_mut() }, idx: self.idx, _marker: PhantomData }\n     }\n+\n+    /// Returns a dormant copy of this handle which can be reawakened later.\n+    ///\n+    /// See `DormantMutRef` for more details.\n+    pub fn dormant(&self) -> Handle<NodeRef<marker::DormantMut, K, V, NodeType>, HandleType> {\n+        Handle { node: self.node.dormant(), idx: self.idx, _marker: PhantomData }\n+    }\n+}\n+\n+impl<K, V, NodeType, HandleType> Handle<NodeRef<marker::DormantMut, K, V, NodeType>, HandleType> {\n+    /// Revert to the unique borrow initially captured.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The reborrow must have ended, i.e., the reference returned by `new` and\n+    /// all pointers and references derived from it, must not be used anymore.\n+    pub unsafe fn awaken<'a>(self) -> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, HandleType> {\n+        Handle { node: unsafe { self.node.awaken() }, idx: self.idx, _marker: PhantomData }\n+    }\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {\n@@ -851,9 +888,11 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     /// Inserts a new key-value pair between the key-value pairs to the right and left of\n     /// this edge. This method assumes that there is enough space in the node for the new\n     /// pair to fit.\n-    ///\n-    /// The returned pointer points to the inserted value.\n-    fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n+    unsafe fn insert_fit(\n+        mut self,\n+        key: K,\n+        val: V,\n+    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n         debug_assert!(self.node.len() < CAPACITY);\n         let new_len = self.node.len() + 1;\n \n@@ -862,7 +901,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n             slice_insert(self.node.val_area_mut(..new_len), self.idx, val);\n             *self.node.len_mut() = new_len as u16;\n \n-            self.node.val_area_mut(self.idx).assume_init_mut()\n+            Handle::new_kv(self.node, self.idx)\n         }\n     }\n }\n@@ -871,30 +910,37 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     /// Inserts a new key-value pair between the key-value pairs to the right and left of\n     /// this edge. This method splits the node if there isn't enough room.\n     ///\n-    /// The returned pointer points to the inserted value.\n+    /// Returns a dormant handle to the inserted node which can be reawakened\n+    /// once splitting is complete.\n     fn insert<A: Allocator + Clone>(\n-        mut self,\n+        self,\n         key: K,\n         val: V,\n         alloc: A,\n-    ) -> (Option<SplitResult<'a, K, V, marker::Leaf>>, *mut V) {\n+    ) -> (\n+        Option<SplitResult<'a, K, V, marker::Leaf>>,\n+        Handle<NodeRef<marker::DormantMut, K, V, marker::Leaf>, marker::KV>,\n+    ) {\n         if self.node.len() < CAPACITY {\n-            let val_ptr = self.insert_fit(key, val);\n-            (None, val_ptr)\n+            // SAFETY: There is enough space in the node for insertion.\n+            let handle = unsafe { self.insert_fit(key, val) };\n+            (None, handle.dormant())\n         } else {\n             let (middle_kv_idx, insertion) = splitpoint(self.idx);\n             let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n             let mut result = middle.split(alloc);\n-            let mut insertion_edge = match insertion {\n+            let insertion_edge = match insertion {\n                 LeftOrRight::Left(insert_idx) => unsafe {\n                     Handle::new_edge(result.left.reborrow_mut(), insert_idx)\n                 },\n                 LeftOrRight::Right(insert_idx) => unsafe {\n                     Handle::new_edge(result.right.borrow_mut(), insert_idx)\n                 },\n             };\n-            let val_ptr = insertion_edge.insert_fit(key, val);\n-            (Some(result), val_ptr)\n+            // SAFETY: We just split the node, so there is enough space for\n+            // insertion.\n+            let handle = unsafe { insertion_edge.insert_fit(key, val).dormant() };\n+            (Some(result), handle)\n         }\n     }\n }\n@@ -976,21 +1022,31 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n         key: K,\n         value: V,\n         alloc: A,\n-    ) -> (Option<SplitResult<'a, K, V, marker::LeafOrInternal>>, *mut V) {\n-        let (mut split, val_ptr) = match self.insert(key, value, alloc.clone()) {\n-            (None, val_ptr) => return (None, val_ptr),\n-            (Some(split), val_ptr) => (split.forget_node_type(), val_ptr),\n+        split_root: impl FnOnce(SplitResult<'a, K, V, marker::LeafOrInternal>),\n+    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n+        let (mut split, handle) = match self.insert(key, value, alloc.clone()) {\n+            // SAFETY: we have finished splitting and can now re-awaken the\n+            // handle to the inserted element.\n+            (None, handle) => return unsafe { handle.awaken() },\n+            (Some(split), handle) => (split.forget_node_type(), handle),\n         };\n \n         loop {\n             split = match split.left.ascend() {\n                 Ok(parent) => {\n                     match parent.insert(split.kv.0, split.kv.1, split.right, alloc.clone()) {\n-                        None => return (None, val_ptr),\n+                        // SAFETY: we have finished splitting and can now re-awaken the\n+                        // handle to the inserted element.\n+                        None => return unsafe { handle.awaken() },\n                         Some(split) => split.forget_node_type(),\n                     }\n                 }\n-                Err(root) => return (Some(SplitResult { left: root, ..split }), val_ptr),\n+                Err(root) => {\n+                    split_root(SplitResult { left: root, ..split });\n+                    // SAFETY: we have finished splitting and can now re-awaken the\n+                    // handle to the inserted element.\n+                    return unsafe { handle.awaken() };\n+                }\n             };\n         }\n     }\n@@ -1043,6 +1099,14 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n         let leaf = self.node.into_leaf_mut();\n         unsafe { leaf.vals.get_unchecked_mut(self.idx).assume_init_mut() }\n     }\n+\n+    pub fn into_kv_valmut(self) -> (&'a K, &'a mut V) {\n+        debug_assert!(self.idx < self.node.len());\n+        let leaf = self.node.into_leaf_mut();\n+        let k = unsafe { leaf.keys.get_unchecked(self.idx).assume_init_ref() };\n+        let v = unsafe { leaf.vals.get_unchecked_mut(self.idx).assume_init_mut() };\n+        (k, v)\n+    }\n }\n \n impl<'a, K, V, NodeType> Handle<NodeRef<marker::ValMut<'a>, K, V, NodeType>, marker::KV> {\n@@ -1667,6 +1731,7 @@ pub mod marker {\n \n     pub enum Owned {}\n     pub enum Dying {}\n+    pub enum DormantMut {}\n     pub struct Immut<'a>(PhantomData<&'a ()>);\n     pub struct Mut<'a>(PhantomData<&'a mut ()>);\n     pub struct ValMut<'a>(PhantomData<&'a mut ()>);\n@@ -1688,6 +1753,7 @@ pub mod marker {\n     impl<'a> BorrowType for Immut<'a> {}\n     impl<'a> BorrowType for Mut<'a> {}\n     impl<'a> BorrowType for ValMut<'a> {}\n+    impl BorrowType for DormantMut {}\n \n     pub enum KV {}\n     pub enum Edge {}"}]}