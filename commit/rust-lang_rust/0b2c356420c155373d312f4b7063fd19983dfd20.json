{"sha": "0b2c356420c155373d312f4b7063fd19983dfd20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMmMzNTY0MjBjMTU1MzczZDMxMmY0YjcwNjNmZDE5OTgzZGZkMjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-11T20:29:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-11T20:29:02Z"}, "message": "Auto merge of #37090 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 9 pull requests\n\n- Successful merges: #36679, #36699, #36997, #37040, #37060, #37065, #37072, #37073, #37081\n- Failed merges:", "tree": {"sha": "9d9a14ac0b50f2f722feeda144f71ac341cb104b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d9a14ac0b50f2f722feeda144f71ac341cb104b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b2c356420c155373d312f4b7063fd19983dfd20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b2c356420c155373d312f4b7063fd19983dfd20", "html_url": "https://github.com/rust-lang/rust/commit/0b2c356420c155373d312f4b7063fd19983dfd20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b2c356420c155373d312f4b7063fd19983dfd20/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "304d0c8d8544ed0afcb57b32572b948fb5072f59", "url": "https://api.github.com/repos/rust-lang/rust/commits/304d0c8d8544ed0afcb57b32572b948fb5072f59", "html_url": "https://github.com/rust-lang/rust/commit/304d0c8d8544ed0afcb57b32572b948fb5072f59"}, {"sha": "30164c21fa0451e00b19bab22d15b9866edd97f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/30164c21fa0451e00b19bab22d15b9866edd97f1", "html_url": "https://github.com/rust-lang/rust/commit/30164c21fa0451e00b19bab22d15b9866edd97f1"}], "stats": {"total": 1080, "additions": 839, "deletions": 241}, "files": [{"sha": "e865609f217f0cb094fe4c5884feb66970992f60", "filename": "src/doc/book/lifetimes.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Fdoc%2Fbook%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Fdoc%2Fbook%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flifetimes.md?ref=0b2c356420c155373d312f4b7063fd19983dfd20", "patch": "@@ -56,8 +56,12 @@ To fix this, we have to make sure that step four never happens after step\n three. The ownership system in Rust does this through a concept called\n lifetimes, which describe the scope that a reference is valid for.\n \n-When we have a function that takes an argument by reference, we can be\n-implicit or explicit about the lifetime of the reference:\n+**Note** It's important to understand that lifetime annotations are\n+_descriptive_, not _prescriptive_. This means that how long a reference is valid\n+is determined by the code, not by the annotations. The annotations, however,\n+give information about lifetimes to the compiler that uses them to check the\n+validity of references. The compiler can do so without annotations in simple\n+cases, but needs the programmers support in complex scenarios.\n \n ```rust\n // implicit"}, {"sha": "883417e9f4ec76c90bcc9f3e4dbc7dc32dafe1cb", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=0b2c356420c155373d312f4b7063fd19983dfd20", "patch": "@@ -327,7 +327,7 @@\n //! format := '{' [ argument ] [ ':' format_spec ] '}'\n //! argument := integer | identifier\n //!\n-//! format_spec := [[fill]align][sign]['#'][0][width]['.' precision][type]\n+//! format_spec := [[fill]align][sign]['#']['0'][width]['.' precision][type]\n //! fill := character\n //! align := '<' | '^' | '>'\n //! sign := '+' | '-'"}, {"sha": "48a74bdecbbefa60db93ba3a74c94dcc1d0e79a3", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=0b2c356420c155373d312f4b7063fd19983dfd20", "patch": "@@ -1789,4 +1789,24 @@ impl str {\n             String::from_utf8_unchecked(slice.into_vec())\n         }\n     }\n+\n+    /// Create a [`String`] by repeating a string `n` times.\n+    ///\n+    /// [`String`]: string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(repeat_str)]\n+    ///\n+    /// assert_eq!(\"abc\".repeat(4), String::from(\"abcabcabcabc\"));\n+    /// ```\n+    #[unstable(feature = \"repeat_str\", issue = \"37079\")]\n+    pub fn repeat(&self, n: usize) -> String {\n+        let mut s = String::with_capacity(self.len() * n);\n+        s.extend((0..n).map(|_| self));\n+        s\n+    }\n }"}, {"sha": "7a61451b900c0322c946430e63fd7bed934b4314", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=0b2c356420c155373d312f4b7063fd19983dfd20", "patch": "@@ -14,12 +14,11 @@\n //! [`ToString`]s, and several error types that may result from working with\n //! [`String`]s.\n //!\n-//! [`String`]: struct.String.html\n //! [`ToString`]: trait.ToString.html\n //!\n //! # Examples\n //!\n-//! There are multiple ways to create a new `String` from a string literal:\n+//! There are multiple ways to create a new [`String`] from a string literal:\n //!\n //! ```\n //! let s = \"Hello\".to_string();\n@@ -28,9 +27,11 @@\n //! let s: String = \"also this\".into();\n //! ```\n //!\n-//! You can create a new `String` from an existing one by concatenating with\n+//! You can create a new [`String`] from an existing one by concatenating with\n //! `+`:\n //!\n+//! [`String`]: struct.String.html\n+//!\n //! ```\n //! let s = \"Hello\".to_string();\n //!"}, {"sha": "c2b34647c32791afe93ce5328866481a9839ce59", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=0b2c356420c155373d312f4b7063fd19983dfd20", "patch": "@@ -19,6 +19,7 @@\n #![feature(enumset)]\n #![feature(pattern)]\n #![feature(rand)]\n+#![feature(repeat_str)]\n #![feature(step_by)]\n #![feature(str_escape)]\n #![feature(str_replacen)]"}, {"sha": "cc56bbf4890aa46de435ab3048d1952aeaaa7e18", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=0b2c356420c155373d312f4b7063fd19983dfd20", "patch": "@@ -1286,6 +1286,13 @@ fn test_cow_from() {\n     }\n }\n \n+#[test]\n+fn test_repeat() {\n+    assert_eq!(\"\".repeat(3), \"\");\n+    assert_eq!(\"abc\".repeat(0), \"\");\n+    assert_eq!(\"\u03b1\".repeat(3), \"\u03b1\u03b1\u03b1\");\n+}\n+\n mod pattern {\n     use std::str::pattern::Pattern;\n     use std::str::pattern::{Searcher, ReverseSearcher};"}, {"sha": "9281d8aa44a56b6d05c758a91e440ab06346a98c", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=0b2c356420c155373d312f4b7063fd19983dfd20", "patch": "@@ -1238,8 +1238,10 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n         match pat.node {\n             PatKind::Binding(.., ref subpat) => {\n                 if !self.bindings_allowed {\n-                    span_err!(self.cx.tcx.sess, pat.span, E0303,\n-                              \"pattern bindings are not allowed after an `@`\");\n+                    struct_span_err!(self.cx.tcx.sess, pat.span, E0303,\n+                                     \"pattern bindings are not allowed after an `@`\")\n+                        .span_label(pat.span,  &format!(\"not allowed after `@`\"))\n+                        .emit();\n                 }\n \n                 if subpat.is_some() {"}, {"sha": "625acce27bd64bd8bc38ea3798546cb445267e34", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 318, "deletions": 100, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=0b2c356420c155373d312f4b7063fd19983dfd20", "patch": "@@ -42,7 +42,7 @@ pub struct UnsafetySpace(pub hir::Unsafety);\n #[derive(Copy, Clone)]\n pub struct ConstnessSpace(pub hir::Constness);\n /// Wrapper struct for properly emitting a method declaration.\n-pub struct Method<'a>(pub &'a clean::FnDecl);\n+pub struct Method<'a>(pub &'a clean::FnDecl, pub &'a str);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct MutableSpace(pub clean::Mutability);\n@@ -84,7 +84,7 @@ impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, item) in self.0.iter().enumerate() {\n             if i != 0 { write!(f, \", \")?; }\n-            write!(f, \"{}\", item)?;\n+            fmt::Display::fmt(item, f)?;\n         }\n         Ok(())\n     }\n@@ -97,7 +97,7 @@ impl<'a> fmt::Display for TyParamBounds<'a> {\n             if i > 0 {\n                 f.write_str(\" + \")?;\n             }\n-            write!(f, \"{}\", *bound)?;\n+            fmt::Display::fmt(bound, f)?;\n         }\n         Ok(())\n     }\n@@ -106,35 +106,51 @@ impl<'a> fmt::Display for TyParamBounds<'a> {\n impl fmt::Display for clean::Generics {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.is_empty() && self.type_params.is_empty() { return Ok(()) }\n-        f.write_str(\"&lt;\")?;\n+        if f.alternate() {\n+            f.write_str(\"<\")?;\n+        } else {\n+            f.write_str(\"&lt;\")?;\n+        }\n \n         for (i, life) in self.lifetimes.iter().enumerate() {\n             if i > 0 {\n-                f.write_str(\",&nbsp;\")?;\n+                f.write_str(\", \")?;\n             }\n             write!(f, \"{}\", *life)?;\n         }\n \n         if !self.type_params.is_empty() {\n             if !self.lifetimes.is_empty() {\n-                f.write_str(\",&nbsp;\")?;\n+                f.write_str(\", \")?;\n             }\n             for (i, tp) in self.type_params.iter().enumerate() {\n                 if i > 0 {\n-                    f.write_str(\",&nbsp;\")?\n+                    f.write_str(\", \")?\n                 }\n                 f.write_str(&tp.name)?;\n \n                 if !tp.bounds.is_empty() {\n-                    write!(f, \":&nbsp;{}\", TyParamBounds(&tp.bounds))?;\n+                    if f.alternate() {\n+                        write!(f, \": {:#}\", TyParamBounds(&tp.bounds))?;\n+                    } else {\n+                        write!(f, \":&nbsp;{}\", TyParamBounds(&tp.bounds))?;\n+                    }\n                 }\n \n                 if let Some(ref ty) = tp.default {\n-                    write!(f, \"&nbsp;=&nbsp;{}\", ty)?;\n+                    if f.alternate() {\n+                        write!(f, \" = {:#}\", ty)?;\n+                    } else {\n+                        write!(f, \"&nbsp;=&nbsp;{}\", ty)?;\n+                    }\n                 };\n             }\n         }\n-        f.write_str(\"&gt;\")?;\n+        if f.alternate() {\n+            f.write_str(\">\")?;\n+        } else {\n+            f.write_str(\"&gt;\")?;\n+        }\n         Ok(())\n     }\n }\n@@ -145,15 +161,23 @@ impl<'a> fmt::Display for WhereClause<'a> {\n         if gens.where_predicates.is_empty() {\n             return Ok(());\n         }\n-        f.write_str(\" <span class='where'>where \")?;\n+        if f.alternate() {\n+            f.write_str(\" \")?;\n+        } else {\n+            f.write_str(\" <span class='where'>where \")?;\n+        }\n         for (i, pred) in gens.where_predicates.iter().enumerate() {\n             if i > 0 {\n                 f.write_str(\", \")?;\n             }\n             match pred {\n                 &clean::WherePredicate::BoundPredicate { ref ty, ref bounds } => {\n                     let bounds = bounds;\n-                    write!(f, \"{}: {}\", ty, TyParamBounds(bounds))?;\n+                    if f.alternate() {\n+                        write!(f, \"{:#}: {:#}\", ty, TyParamBounds(bounds))?;\n+                    } else {\n+                        write!(f, \"{}: {}\", ty, TyParamBounds(bounds))?;\n+                    }\n                 }\n                 &clean::WherePredicate::RegionPredicate { ref lifetime,\n                                                           ref bounds } => {\n@@ -167,11 +191,17 @@ impl<'a> fmt::Display for WhereClause<'a> {\n                     }\n                 }\n                 &clean::WherePredicate::EqPredicate { ref lhs, ref rhs } => {\n-                    write!(f, \"{} == {}\", lhs, rhs)?;\n+                    if f.alternate() {\n+                        write!(f, \"{:#} == {:#}\", lhs, rhs)?;\n+                    } else {\n+                        write!(f, \"{} == {}\", lhs, rhs)?;\n+                    }\n                 }\n             }\n         }\n-        f.write_str(\"</span>\")?;\n+        if !f.alternate() {\n+            f.write_str(\"</span>\")?;\n+        }\n         Ok(())\n     }\n }\n@@ -186,16 +216,28 @@ impl fmt::Display for clean::Lifetime {\n impl fmt::Display for clean::PolyTrait {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if !self.lifetimes.is_empty() {\n-            f.write_str(\"for&lt;\")?;\n+            if f.alternate() {\n+                f.write_str(\"for<\")?;\n+            } else {\n+                f.write_str(\"for&lt;\")?;\n+            }\n             for (i, lt) in self.lifetimes.iter().enumerate() {\n                 if i > 0 {\n                     f.write_str(\", \")?;\n                 }\n                 write!(f, \"{}\", lt)?;\n             }\n-            f.write_str(\"&gt; \")?;\n+            if f.alternate() {\n+                f.write_str(\"> \")?;\n+            } else {\n+                f.write_str(\"&gt; \")?;\n+            }\n+        }\n+        if f.alternate() {\n+            write!(f, \"{:#}\", self.trait_)\n+        } else {\n+            write!(f, \"{}\", self.trait_)\n         }\n-        write!(f, \"{}\", self.trait_)\n     }\n }\n \n@@ -210,7 +252,11 @@ impl fmt::Display for clean::TyParamBound {\n                     hir::TraitBoundModifier::None => \"\",\n                     hir::TraitBoundModifier::Maybe => \"?\",\n                 };\n-                write!(f, \"{}{}\", modifier_str, *ty)\n+                if f.alternate() {\n+                    write!(f, \"{}{:#}\", modifier_str, *ty)\n+                } else {\n+                    write!(f, \"{}{}\", modifier_str, *ty)\n+                }\n             }\n         }\n     }\n@@ -223,30 +269,46 @@ impl fmt::Display for clean::PathParameters {\n                 ref lifetimes, ref types, ref bindings\n             } => {\n                 if !lifetimes.is_empty() || !types.is_empty() || !bindings.is_empty() {\n-                    f.write_str(\"&lt;\")?;\n+                    if f.alternate() {\n+                        f.write_str(\"<\")?;\n+                    } else {\n+                        f.write_str(\"&lt;\")?;\n+                    }\n                     let mut comma = false;\n                     for lifetime in lifetimes {\n                         if comma {\n-                            f.write_str(\",&nbsp;\")?;\n+                            f.write_str(\", \")?;\n                         }\n                         comma = true;\n                         write!(f, \"{}\", *lifetime)?;\n                     }\n                     for ty in types {\n                         if comma {\n-                            f.write_str(\",&nbsp;\")?;\n+                            f.write_str(\", \")?;\n                         }\n                         comma = true;\n-                        write!(f, \"{}\", *ty)?;\n+                        if f.alternate() {\n+                            write!(f, \"{:#}\", *ty)?;\n+                        } else {\n+                            write!(f, \"{}\", *ty)?;\n+                        }\n                     }\n                     for binding in bindings {\n                         if comma {\n-                            f.write_str(\",&nbsp;\")?;\n+                            f.write_str(\", \")?;\n                         }\n                         comma = true;\n-                        write!(f, \"{}\", *binding)?;\n+                        if f.alternate() {\n+                            write!(f, \"{:#}\", *binding)?;\n+                        } else {\n+                            write!(f, \"{}\", *binding)?;\n+                        }\n+                    }\n+                    if f.alternate() {\n+                        f.write_str(\">\")?;\n+                    } else {\n+                        f.write_str(\"&gt;\")?;\n                     }\n-                    f.write_str(\"&gt;\")?;\n                 }\n             }\n             clean::PathParameters::Parenthesized { ref inputs, ref output } => {\n@@ -257,12 +319,19 @@ impl fmt::Display for clean::PathParameters {\n                         f.write_str(\", \")?;\n                     }\n                     comma = true;\n-                    write!(f, \"{}\", *ty)?;\n+                    if f.alternate() {\n+                        write!(f, \"{:#}\", *ty)?;\n+                    } else {\n+                        write!(f, \"{}\", *ty)?;\n+                    }\n                 }\n                 f.write_str(\")\")?;\n                 if let Some(ref ty) = *output {\n-                    f.write_str(\" -&gt; \")?;\n-                    write!(f, \"{}\", ty)?;\n+                    if f.alternate() {\n+                        write!(f, \" -> {:#}\", ty)?;\n+                    } else {\n+                        write!(f, \" -&gt; {}\", ty)?;\n+                    }\n                 }\n             }\n         }\n@@ -273,7 +342,11 @@ impl fmt::Display for clean::PathParameters {\n impl fmt::Display for clean::PathSegment {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(&self.name)?;\n-        write!(f, \"{}\", self.params)\n+        if f.alternate() {\n+            write!(f, \"{:#}\", self.params)\n+        } else {\n+            write!(f, \"{}\", self.params)\n+        }\n     }\n }\n \n@@ -287,7 +360,11 @@ impl fmt::Display for clean::Path {\n             if i > 0 {\n                 f.write_str(\"::\")?\n             }\n-            write!(f, \"{}\", seg)?;\n+            if f.alternate() {\n+                write!(f, \"{:#}\", seg)?;\n+            } else {\n+                write!(f, \"{}\", seg)?;\n+            }\n         }\n         Ok(())\n     }\n@@ -349,7 +426,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n         match rel_root {\n             Some(mut root) => {\n                 for seg in &path.segments[..amt] {\n-                    if \"super\" == seg.name || \"self\" == seg.name {\n+                    if \"super\" == seg.name || \"self\" == seg.name || w.alternate() {\n                         write!(w, \"{}::\", seg.name)?;\n                     } else {\n                         root.push_str(&seg.name);\n@@ -368,7 +445,11 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n             }\n         }\n     }\n-    write!(w, \"{}{}\", HRef::new(did, &last.name), last.params)?;\n+    if w.alternate() {\n+        write!(w, \"{:#}{:#}\", HRef::new(did, &last.name), last.params)?;\n+    } else {\n+        write!(w, \"{}{}\", HRef::new(did, &last.name), last.params)?;\n+    }\n     Ok(())\n }\n \n@@ -377,33 +458,35 @@ fn primitive_link(f: &mut fmt::Formatter,\n                   name: &str) -> fmt::Result {\n     let m = cache();\n     let mut needs_termination = false;\n-    match m.primitive_locations.get(&prim) {\n-        Some(&LOCAL_CRATE) => {\n-            let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n-            let len = if len == 0 {0} else {len - 1};\n-            write!(f, \"<a class='primitive' href='{}primitive.{}.html'>\",\n-                   repeat(\"../\").take(len).collect::<String>(),\n-                   prim.to_url_str())?;\n-            needs_termination = true;\n-        }\n-        Some(&cnum) => {\n-            let loc = match m.extern_locations[&cnum] {\n-                (ref cname, render::Remote(ref s)) => Some((cname, s.to_string())),\n-                (ref cname, render::Local) => {\n-                    let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n-                    Some((cname, repeat(\"../\").take(len).collect::<String>()))\n-                }\n-                (_, render::Unknown) => None,\n-            };\n-            if let Some((cname, root)) = loc {\n-                write!(f, \"<a class='primitive' href='{}{}/primitive.{}.html'>\",\n-                       root,\n-                       cname,\n+    if !f.alternate() {\n+        match m.primitive_locations.get(&prim) {\n+            Some(&LOCAL_CRATE) => {\n+                let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n+                let len = if len == 0 {0} else {len - 1};\n+                write!(f, \"<a class='primitive' href='{}primitive.{}.html'>\",\n+                       repeat(\"../\").take(len).collect::<String>(),\n                        prim.to_url_str())?;\n                 needs_termination = true;\n             }\n+            Some(&cnum) => {\n+                let loc = match m.extern_locations[&cnum] {\n+                    (ref cname, render::Remote(ref s)) => Some((cname, s.to_string())),\n+                    (ref cname, render::Local) => {\n+                        let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n+                        Some((cname, repeat(\"../\").take(len).collect::<String>()))\n+                    }\n+                    (_, render::Unknown) => None,\n+                };\n+                if let Some((cname, root)) = loc {\n+                    write!(f, \"<a class='primitive' href='{}{}/primitive.{}.html'>\",\n+                           root,\n+                           cname,\n+                           prim.to_url_str())?;\n+                    needs_termination = true;\n+                }\n+            }\n+            None => {}\n         }\n-        None => {}\n     }\n     write!(f, \"{}\", name)?;\n     if needs_termination {\n@@ -419,7 +502,7 @@ fn tybounds(w: &mut fmt::Formatter,\n         Some(ref params) => {\n             for param in params {\n                 write!(w, \" + \")?;\n-                write!(w, \"{}\", *param)?;\n+                fmt::Display::fmt(param, w)?;\n             }\n             Ok(())\n         }\n@@ -436,10 +519,12 @@ impl<'a> HRef<'a> {\n impl<'a> fmt::Display for HRef<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match href(self.did) {\n-            Some((url, shortty, fqp)) => {\n+            Some((url, shortty, fqp)) => if !f.alternate() {\n                 write!(f, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n                        shortty, url, fqp.join(\"::\"), self.text)\n-            }\n+            } else {\n+                write!(f, \"{}\", self.text)\n+            },\n             _ => write!(f, \"{}\", self.text),\n         }\n     }\n@@ -459,49 +544,68 @@ impl fmt::Display for clean::Type {\n             clean::Infer => write!(f, \"_\"),\n             clean::Primitive(prim) => primitive_link(f, prim, prim.as_str()),\n             clean::BareFunction(ref decl) => {\n-                write!(f, \"{}{}fn{}{}\",\n-                       UnsafetySpace(decl.unsafety),\n-                       AbiSpace(decl.abi),\n-                       decl.generics,\n-                       decl.decl)\n+                if f.alternate() {\n+                    write!(f, \"{}{}fn{:#}{:#}\",\n+                           UnsafetySpace(decl.unsafety),\n+                           AbiSpace(decl.abi),\n+                           decl.generics,\n+                           decl.decl)\n+                } else {\n+                    write!(f, \"{}{}fn{}{}\",\n+                           UnsafetySpace(decl.unsafety),\n+                           AbiSpace(decl.abi),\n+                           decl.generics,\n+                           decl.decl)\n+                }\n             }\n             clean::Tuple(ref typs) => {\n                 match &typs[..] {\n                     &[] => primitive_link(f, PrimitiveType::Tuple, \"()\"),\n                     &[ref one] => {\n                         primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                        write!(f, \"{},\", one)?;\n-                        primitive_link(f, PrimitiveType::Tuple, \")\")\n+                        //carry f.alternate() into this display w/o branching manually\n+                        fmt::Display::fmt(one, f)?;\n+                        primitive_link(f, PrimitiveType::Tuple, \",)\")\n                     }\n                     many => {\n                         primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                        write!(f, \"{}\", CommaSep(&many))?;\n+                        fmt::Display::fmt(&CommaSep(&many), f)?;\n                         primitive_link(f, PrimitiveType::Tuple, \")\")\n                     }\n                 }\n             }\n             clean::Vector(ref t) => {\n                 primitive_link(f, PrimitiveType::Slice, &format!(\"[\"))?;\n-                write!(f, \"{}\", t)?;\n+                fmt::Display::fmt(t, f)?;\n                 primitive_link(f, PrimitiveType::Slice, &format!(\"]\"))\n             }\n             clean::FixedVector(ref t, ref s) => {\n                 primitive_link(f, PrimitiveType::Array, \"[\")?;\n-                write!(f, \"{}\", t)?;\n-                primitive_link(f, PrimitiveType::Array,\n-                               &format!(\"; {}]\", Escape(s)))\n+                fmt::Display::fmt(t, f)?;\n+                if f.alternate() {\n+                    primitive_link(f, PrimitiveType::Array,\n+                                   &format!(\"; {}]\", s))\n+                } else {\n+                    primitive_link(f, PrimitiveType::Array,\n+                                   &format!(\"; {}]\", Escape(s)))\n+                }\n             }\n             clean::Never => f.write_str(\"!\"),\n             clean::RawPointer(m, ref t) => {\n                 match **t {\n                     clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n-                        primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                       &format!(\"*{}{}\", RawMutableSpace(m), t))\n+                        if f.alternate() {\n+                            primitive_link(f, clean::PrimitiveType::RawPointer,\n+                                           &format!(\"*{}{:#}\", RawMutableSpace(m), t))\n+                        } else {\n+                            primitive_link(f, clean::PrimitiveType::RawPointer,\n+                                           &format!(\"*{}{}\", RawMutableSpace(m), t))\n+                        }\n                     }\n                     _ => {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n                                        &format!(\"*{}\", RawMutableSpace(m)))?;\n-                        write!(f, \"{}\", t)\n+                        fmt::Display::fmt(t, f)\n                     }\n                 }\n             }\n@@ -515,18 +619,33 @@ impl fmt::Display for clean::Type {\n                     clean::Vector(ref bt) => { // BorrowedRef{ ... Vector(T) } is &[T]\n                         match **bt {\n                             clean::Generic(_) =>\n-                                primitive_link(f, PrimitiveType::Slice,\n-                                    &format!(\"&amp;{}{}[{}]\", lt, m, **bt)),\n+                                if f.alternate() {\n+                                    primitive_link(f, PrimitiveType::Slice,\n+                                        &format!(\"&{}{}[{:#}]\", lt, m, **bt))\n+                                } else {\n+                                    primitive_link(f, PrimitiveType::Slice,\n+                                        &format!(\"&amp;{}{}[{}]\", lt, m, **bt))\n+                                },\n                             _ => {\n-                                primitive_link(f, PrimitiveType::Slice,\n-                                               &format!(\"&amp;{}{}[\", lt, m))?;\n-                                write!(f, \"{}\", **bt)?;\n+                                if f.alternate() {\n+                                    primitive_link(f, PrimitiveType::Slice,\n+                                                   &format!(\"&{}{}[\", lt, m))?;\n+                                    write!(f, \"{:#}\", **bt)?;\n+                                } else {\n+                                    primitive_link(f, PrimitiveType::Slice,\n+                                                   &format!(\"&amp;{}{}[\", lt, m))?;\n+                                    write!(f, \"{}\", **bt)?;\n+                                }\n                                 primitive_link(f, PrimitiveType::Slice, \"]\")\n                             }\n                         }\n                     }\n                     _ => {\n-                        write!(f, \"&amp;{}{}{}\", lt, m, **ty)\n+                        if f.alternate() {\n+                            write!(f, \"&{}{}{:#}\", lt, m, **ty)\n+                        } else {\n+                            write!(f, \"&amp;{}{}{}\", lt, m, **ty)\n+                        }\n                     }\n                 }\n             }\n@@ -535,7 +654,11 @@ impl fmt::Display for clean::Type {\n                     if i != 0 {\n                         write!(f, \" + \")?;\n                     }\n-                    write!(f, \"{}\", *bound)?;\n+                    if f.alternate() {\n+                        write!(f, \"{:#}\", *bound)?;\n+                    } else {\n+                        write!(f, \"{}\", *bound)?;\n+                    }\n                 }\n                 Ok(())\n             }\n@@ -545,7 +668,11 @@ impl fmt::Display for clean::Type {\n                     if i != 0 {\n                         write!(f, \" + \")?;\n                     }\n-                    write!(f, \"{}\", *bound)?;\n+                    if f.alternate() {\n+                        write!(f, \"{:#}\", *bound)?;\n+                    } else {\n+                        write!(f, \"{}\", *bound)?;\n+                    }\n                 }\n                 Ok(())\n             }\n@@ -564,7 +691,11 @@ impl fmt::Display for clean::Type {\n                 ref self_type,\n                 trait_: box clean::ResolvedPath { did, ref typarams, .. },\n             } => {\n-                write!(f, \"{}::\", self_type)?;\n+                if f.alternate() {\n+                    write!(f, \"{:#}::\", self_type)?;\n+                } else {\n+                    write!(f, \"{}::\", self_type)?;\n+                }\n                 let path = clean::Path::singleton(name.clone());\n                 resolved_path(f, did, &path, false)?;\n \n@@ -573,7 +704,11 @@ impl fmt::Display for clean::Type {\n                 Ok(())\n             }\n             clean::QPath { ref name, ref self_type, ref trait_ } => {\n-                write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n+                if f.alternate() {\n+                    write!(f, \"<{:#} as {:#}>::{}\", self_type, trait_, name)\n+                } else {\n+                    write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n+                }\n             }\n             clean::Unique(..) => {\n                 panic!(\"should have been cleaned\")\n@@ -583,24 +718,30 @@ impl fmt::Display for clean::Type {\n }\n \n fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::Result {\n-    write!(f, \"impl{} \", i.generics)?;\n+    if f.alternate() {\n+        write!(f, \"impl{:#} \", i.generics)?;\n+    } else {\n+        write!(f, \"impl{} \", i.generics)?;\n+    }\n     if let Some(ref ty) = i.trait_ {\n         write!(f, \"{}\",\n                if i.polarity == Some(clean::ImplPolarity::Negative) { \"!\" } else { \"\" })?;\n         if link_trait {\n-            write!(f, \"{}\", *ty)?;\n+            fmt::Display::fmt(ty, f)?;\n         } else {\n             match *ty {\n                 clean::ResolvedPath{ typarams: None, ref path, is_generic: false, .. } => {\n                     let last = path.segments.last().unwrap();\n-                    write!(f, \"{}{}\", last.name, last.params)?;\n+                    fmt::Display::fmt(&last.name, f)?;\n+                    fmt::Display::fmt(&last.params, f)?;\n                 }\n                 _ => unreachable!(),\n             }\n         }\n         write!(f, \" for \")?;\n     }\n-    write!(f, \"{}{}\", i.for_, WhereClause(&i.generics))?;\n+    fmt::Display::fmt(&i.for_, f)?;\n+    fmt::Display::fmt(&WhereClause(&i.generics), f)?;\n     Ok(())\n }\n \n@@ -618,11 +759,15 @@ pub fn fmt_impl_for_trait_page(i: &clean::Impl, f: &mut fmt::Formatter) -> fmt::\n impl fmt::Display for clean::Arguments {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, input) in self.values.iter().enumerate() {\n-            if i > 0 { write!(f, \", \")?; }\n             if !input.name.is_empty() {\n                 write!(f, \"{}: \", input.name)?;\n             }\n-            write!(f, \"{}\", input.type_)?;\n+            if f.alternate() {\n+                write!(f, \"{:#}\", input.type_)?;\n+            } else {\n+                write!(f, \"{}\", input.type_)?;\n+            }\n+            if i + 1 < self.values.len() { write!(f, \", \")?; }\n         }\n         Ok(())\n     }\n@@ -632,6 +777,7 @@ impl fmt::Display for clean::FunctionRetTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::Return(clean::Tuple(ref tys)) if tys.is_empty() => Ok(()),\n+            clean::Return(ref ty) if f.alternate() => write!(f, \" -> {:#}\", ty),\n             clean::Return(ref ty) => write!(f, \" -&gt; {}\", ty),\n             clean::DefaultReturn => Ok(()),\n         }\n@@ -641,40 +787,107 @@ impl fmt::Display for clean::FunctionRetTy {\n impl fmt::Display for clean::FnDecl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.variadic {\n-            write!(f, \"({args}, ...){arrow}\", args = self.inputs, arrow = self.output)\n+            if f.alternate() {\n+                write!(f, \"({args:#}, ...){arrow:#}\", args = self.inputs, arrow = self.output)\n+            } else {\n+                write!(f, \"({args}, ...){arrow}\", args = self.inputs, arrow = self.output)\n+            }\n         } else {\n-            write!(f, \"({args}){arrow}\", args = self.inputs, arrow = self.output)\n+            if f.alternate() {\n+                write!(f, \"({args:#}){arrow:#}\", args = self.inputs, arrow = self.output)\n+            } else {\n+                write!(f, \"({args}){arrow}\", args = self.inputs, arrow = self.output)\n+            }\n         }\n     }\n }\n \n impl<'a> fmt::Display for Method<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let decl = self.0;\n+        let indent = self.1;\n+        let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n         let mut args = String::new();\n+        let mut args_plain = String::new();\n         for (i, input) in decl.inputs.values.iter().enumerate() {\n-            if i > 0 || !args.is_empty() { args.push_str(\", \"); }\n             if let Some(selfty) = input.to_self() {\n                 match selfty {\n-                    clean::SelfValue => args.push_str(\"self\"),\n+                    clean::SelfValue => {\n+                        args.push_str(\"self\");\n+                        args_plain.push_str(\"self\");\n+                    }\n                     clean::SelfBorrowed(Some(ref lt), mtbl) => {\n-                        args.push_str(&format!(\"&amp;{} {}self\", *lt, MutableSpace(mtbl)));\n+                        args.push_str(&format!(\"{}{} {}self\", amp, *lt, MutableSpace(mtbl)));\n+                        args_plain.push_str(&format!(\"&{} {}self\", *lt, MutableSpace(mtbl)));\n                     }\n                     clean::SelfBorrowed(None, mtbl) => {\n-                        args.push_str(&format!(\"&amp;{}self\", MutableSpace(mtbl)));\n+                        args.push_str(&format!(\"{}{}self\", amp, MutableSpace(mtbl)));\n+                        args_plain.push_str(&format!(\"&{}self\", MutableSpace(mtbl)));\n                     }\n                     clean::SelfExplicit(ref typ) => {\n-                        args.push_str(&format!(\"self: {}\", *typ));\n+                        if f.alternate() {\n+                            args.push_str(&format!(\"self: {:#}\", *typ));\n+                        } else {\n+                            args.push_str(&format!(\"self: {}\", *typ));\n+                        }\n+                        args_plain.push_str(&format!(\"self: {:#}\", *typ));\n                     }\n                 }\n             } else {\n+                if i > 0 {\n+                    args.push_str(\"<br> \");\n+                    args_plain.push_str(\" \");\n+                }\n                 if !input.name.is_empty() {\n                     args.push_str(&format!(\"{}: \", input.name));\n+                    args_plain.push_str(&format!(\"{}: \", input.name));\n                 }\n-                args.push_str(&format!(\"{}\", input.type_));\n+\n+                if f.alternate() {\n+                    args.push_str(&format!(\"{:#}\", input.type_));\n+                } else {\n+                    args.push_str(&format!(\"{}\", input.type_));\n+                }\n+                args_plain.push_str(&format!(\"{:#}\", input.type_));\n+            }\n+            if i + 1 < decl.inputs.values.len() {\n+                args.push_str(\",\");\n+                args_plain.push_str(\",\");\n             }\n         }\n-        write!(f, \"({args}){arrow}\", args = args, arrow = decl.output)\n+\n+        if decl.variadic {\n+            args.push_str(\",<br> ...\");\n+            args_plain.push_str(\", ...\");\n+        }\n+\n+        let arrow_plain = format!(\"{:#}\", decl.output);\n+        let arrow = if f.alternate() {\n+            format!(\"{:#}\", decl.output)\n+        } else {\n+            format!(\"{}\", decl.output)\n+        };\n+\n+        let mut output: String;\n+        let plain: String;\n+        if arrow.is_empty() {\n+            output = format!(\"({})\", args);\n+            plain = format!(\"{}({})\", indent.replace(\"&nbsp;\", \" \"), args_plain);\n+        } else {\n+            output = format!(\"({args})<br>{arrow}\", args = args, arrow = arrow);\n+            plain = format!(\"{indent}({args}){arrow}\",\n+                            indent = indent.replace(\"&nbsp;\", \" \"),\n+                            args = args_plain,\n+                            arrow = arrow_plain);\n+        }\n+\n+        if plain.len() > 80 {\n+            let pad = format!(\"<br>{}\", indent);\n+            output = output.replace(\"<br>\", &pad);\n+        } else {\n+            output = output.replace(\"<br>\", \"\");\n+        }\n+        write!(f, \"{}\", output)\n     }\n }\n \n@@ -768,7 +981,11 @@ impl fmt::Display for clean::ViewListIdent {\n \n impl fmt::Display for clean::TypeBinding {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}={}\", self.name, self.ty)\n+        if f.alternate() {\n+            write!(f, \"{}={:#}\", self.name, self.ty)\n+        } else {\n+            write!(f, \"{}={}\", self.name, self.ty)\n+        }\n     }\n }\n \n@@ -792,10 +1009,11 @@ impl fmt::Display for RawMutableSpace {\n \n impl fmt::Display for AbiSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let quot = if f.alternate() { \"\\\"\" } else { \"&quot;\" };\n         match self.0 {\n             Abi::Rust => Ok(()),\n             Abi::C => write!(f, \"extern \"),\n-            abi => write!(f, \"extern &quot;{}&quot; \", abi.name()),\n+            abi => write!(f, \"extern {0}{1}{0} \", quot, abi.name()),\n         }\n     }\n }"}, {"sha": "d8dba00e7d5789f485bcff5c802264c0bbe353fc", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0b2c356420c155373d312f4b7063fd19983dfd20", "patch": "@@ -1967,6 +1967,14 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         UnstableFeatures::Allow => f.constness,\n         _ => hir::Constness::NotConst\n     };\n+    let prefix = format!(\"{}{}{}{:#}fn {}{:#}\",\n+                         VisSpace(&it.visibility),\n+                         ConstnessSpace(vis_constness),\n+                         UnsafetySpace(f.unsafety),\n+                         AbiSpace(f.abi),\n+                         it.name.as_ref().unwrap(),\n+                         f.generics);\n+    let indent = repeat(\"&nbsp;\").take(prefix.len()).collect::<String>();\n     write!(w, \"<pre class='rust fn'>{vis}{constness}{unsafety}{abi}fn \\\n                {name}{generics}{decl}{where_clause}</pre>\",\n            vis = VisSpace(&it.visibility),\n@@ -1976,7 +1984,7 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n            name = it.name.as_ref().unwrap(),\n            generics = f.generics,\n            where_clause = WhereClause(&f.generics),\n-           decl = f.decl)?;\n+           decl = Method(&f.decl, &indent))?;\n     document(w, cx, it)\n }\n \n@@ -2246,6 +2254,13 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n             UnstableFeatures::Allow => constness,\n             _ => hir::Constness::NotConst\n         };\n+        let prefix = format!(\"{}{}{:#}fn {}{:#}\",\n+                             ConstnessSpace(vis_constness),\n+                             UnsafetySpace(unsafety),\n+                             AbiSpace(abi),\n+                             name,\n+                             *g);\n+        let indent = repeat(\"&nbsp;\").take(prefix.len()).collect::<String>();\n         write!(w, \"{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n                ConstnessSpace(vis_constness),\n@@ -2254,7 +2269,7 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                href = href,\n                name = name,\n                generics = *g,\n-               decl = Method(d),\n+               decl = Method(d, &indent),\n                where_clause = WhereClause(g))\n     }\n     match item.inner {"}, {"sha": "792239e7219326d6b233efae7e08dea801491b38", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 31, "deletions": 38, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=0b2c356420c155373d312f4b7063fd19983dfd20", "patch": "@@ -125,9 +125,8 @@ impl fmt::Display for Token {\n     }\n }\n \n-fn buf_str(toks: &[Token], szs: &[isize], left: usize, right: usize, lim: usize) -> String {\n-    let n = toks.len();\n-    assert_eq!(n, szs.len());\n+fn buf_str(buf: &[BufEntry], left: usize, right: usize, lim: usize) -> String {\n+    let n = buf.len();\n     let mut i = left;\n     let mut l = lim;\n     let mut s = String::from(\"[\");\n@@ -136,7 +135,7 @@ fn buf_str(toks: &[Token], szs: &[isize], left: usize, right: usize, lim: usize)\n         if i != left {\n             s.push_str(\", \");\n         }\n-        s.push_str(&format!(\"{}={}\", szs[i], &toks[i]));\n+        s.push_str(&format!(\"{}={}\", buf[i].size, &buf[i].token));\n         i += 1;\n         i %= n;\n     }\n@@ -159,25 +158,20 @@ pub struct PrintStackElem {\n const SIZE_INFINITY: isize = 0xffff;\n \n pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n-    // Yes 55, it makes the ring buffers big enough to never\n-    // fall behind.\n+    // Yes 55, it makes the ring buffers big enough to never fall behind.\n     let n: usize = 55 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n-    let token = vec![Token::Eof; n];\n-    let size = vec![0; n];\n-    let scan_stack = VecDeque::with_capacity(n);\n     Printer {\n         out: out,\n         buf_len: n,\n         margin: linewidth as isize,\n         space: linewidth as isize,\n         left: 0,\n         right: 0,\n-        token: token,\n-        size: size,\n+        buf: vec![BufEntry { token: Token::Eof, size: 0 }; n],\n         left_total: 0,\n         right_total: 0,\n-        scan_stack: scan_stack,\n+        scan_stack: VecDeque::new(),\n         print_stack: Vec::new(),\n         pending_indentation: 0\n     }\n@@ -269,10 +263,8 @@ pub struct Printer<'a> {\n     left: usize,\n     /// Index of right side of input stream\n     right: usize,\n-    /// Ring-buffer stream goes through\n-    token: Vec<Token> ,\n-    /// Ring-buffer of calculated sizes\n-    size: Vec<isize> ,\n+    /// Ring-buffer of tokens and calculated sizes\n+    buf: Vec<BufEntry>,\n     /// Running size of stream \"...left\"\n     left_total: isize,\n     /// Running size of stream \"...right\"\n@@ -283,20 +275,26 @@ pub struct Printer<'a> {\n     /// Begin (if there is any) on top of it. Stuff is flushed off the\n     /// bottom as it becomes irrelevant due to the primary ring-buffer\n     /// advancing.\n-    scan_stack: VecDeque<usize> ,\n+    scan_stack: VecDeque<usize>,\n     /// Stack of blocks-in-progress being flushed by print\n     print_stack: Vec<PrintStackElem> ,\n     /// Buffered indentation to avoid writing trailing whitespace\n     pending_indentation: isize,\n }\n \n+#[derive(Clone)]\n+struct BufEntry {\n+    token: Token,\n+    size: isize,\n+}\n+\n impl<'a> Printer<'a> {\n     pub fn last_token(&mut self) -> Token {\n-        self.token[self.right].clone()\n+        self.buf[self.right].token.clone()\n     }\n     // be very careful with this!\n     pub fn replace_last_token(&mut self, t: Token) {\n-        self.token[self.right] = t;\n+        self.buf[self.right].token = t;\n     }\n     pub fn pretty_print(&mut self, token: Token) -> io::Result<()> {\n         debug!(\"pp Vec<{},{}>\", self.left, self.right);\n@@ -318,8 +316,7 @@ impl<'a> Printer<'a> {\n             } else { self.advance_right(); }\n             debug!(\"pp Begin({})/buffer Vec<{},{}>\",\n                    b.offset, self.left, self.right);\n-            self.token[self.right] = token;\n-            self.size[self.right] = -self.right_total;\n+            self.buf[self.right] = BufEntry { token: token, size: -self.right_total };\n             let right = self.right;\n             self.scan_push(right);\n             Ok(())\n@@ -331,8 +328,7 @@ impl<'a> Printer<'a> {\n             } else {\n                 debug!(\"pp End/buffer Vec<{},{}>\", self.left, self.right);\n                 self.advance_right();\n-                self.token[self.right] = token;\n-                self.size[self.right] = -1;\n+                self.buf[self.right] = BufEntry { token: token, size: -1 };\n                 let right = self.right;\n                 self.scan_push(right);\n                 Ok(())\n@@ -350,8 +346,7 @@ impl<'a> Printer<'a> {\n             self.check_stack(0);\n             let right = self.right;\n             self.scan_push(right);\n-            self.token[self.right] = token;\n-            self.size[self.right] = -self.right_total;\n+            self.buf[self.right] = BufEntry { token: token, size: -self.right_total };\n             self.right_total += b.blank_space;\n             Ok(())\n           }\n@@ -364,8 +359,7 @@ impl<'a> Printer<'a> {\n                 debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n                        s, self.left, self.right);\n                 self.advance_right();\n-                self.token[self.right] = Token::String(s, len);\n-                self.size[self.right] = len;\n+                self.buf[self.right] = BufEntry { token: Token::String(s, len), size: len };\n                 self.right_total += len;\n                 self.check_stream()\n             }\n@@ -381,7 +375,7 @@ impl<'a> Printer<'a> {\n             if Some(&self.left) == self.scan_stack.back() {\n                 debug!(\"setting {} to infinity and popping\", self.left);\n                 let scanned = self.scan_pop_bottom();\n-                self.size[scanned] = SIZE_INFINITY;\n+                self.buf[scanned].size = SIZE_INFINITY;\n             }\n             self.advance_left()?;\n             if self.left != self.right {\n@@ -410,12 +404,12 @@ impl<'a> Printer<'a> {\n     }\n     pub fn advance_left(&mut self) -> io::Result<()> {\n         debug!(\"advance_left Vec<{},{}>, sizeof({})={}\", self.left, self.right,\n-               self.left, self.size[self.left]);\n+               self.left, self.buf[self.left].size);\n \n-        let mut left_size = self.size[self.left];\n+        let mut left_size = self.buf[self.left].size;\n \n         while left_size >= 0 {\n-            let left = self.token[self.left].clone();\n+            let left = self.buf[self.left].token.clone();\n \n             let len = match left {\n                 Token::Break(b) => b.blank_space,\n@@ -437,31 +431,31 @@ impl<'a> Printer<'a> {\n             self.left += 1;\n             self.left %= self.buf_len;\n \n-            left_size = self.size[self.left];\n+            left_size = self.buf[self.left].size;\n         }\n \n         Ok(())\n     }\n     pub fn check_stack(&mut self, k: isize) {\n         if !self.scan_stack.is_empty() {\n             let x = self.scan_top();\n-            match self.token[x] {\n+            match self.buf[x].token {\n                 Token::Begin(_) => {\n                     if k > 0 {\n                         let popped = self.scan_pop();\n-                        self.size[popped] = self.size[x] + self.right_total;\n+                        self.buf[popped].size = self.buf[x].size + self.right_total;\n                         self.check_stack(k - 1);\n                     }\n                 }\n                 Token::End => {\n                     // paper says + not =, but that makes no sense.\n                     let popped = self.scan_pop();\n-                    self.size[popped] = 1;\n+                    self.buf[popped].size = 1;\n                     self.check_stack(k + 1);\n                 }\n                 _ => {\n                     let popped = self.scan_pop();\n-                    self.size[popped] = self.size[x] + self.right_total;\n+                    self.buf[popped].size = self.buf[x].size + self.right_total;\n                     if k > 0 {\n                         self.check_stack(k);\n                     }\n@@ -499,8 +493,7 @@ impl<'a> Printer<'a> {\n     pub fn print(&mut self, token: Token, l: isize) -> io::Result<()> {\n         debug!(\"print {} {} (remaining line space={})\", token, l,\n                self.space);\n-        debug!(\"{}\", buf_str(&self.token,\n-                             &self.size,\n+        debug!(\"{}\", buf_str(&self.buf,\n                              self.left,\n                              self.right,\n                              6));"}, {"sha": "b72b5e3b2808bb5998b4d3db121c0abf7e76bbdb", "filename": "src/test/compile-fail/E0007.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Ftest%2Fcompile-fail%2FE0007.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Ftest%2Fcompile-fail%2FE0007.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0007.rs?ref=0b2c356420c155373d312f4b7063fd19983dfd20", "patch": "@@ -15,6 +15,7 @@ fn main() {\n         //~^ ERROR E0007\n         //~| NOTE binds an already bound by-move value by moving it\n         //~| ERROR E0303\n+        //~| NOTE not allowed after `@`\n         None => {},\n     }\n }"}, {"sha": "e631fe2a8a7ccf834f66560db9ec310bbed647ed", "filename": "src/test/compile-fail/E0303.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Ftest%2Fcompile-fail%2FE0303.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Ftest%2Fcompile-fail%2FE0303.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0303.rs?ref=0b2c356420c155373d312f4b7063fd19983dfd20", "patch": "@@ -10,8 +10,12 @@\n \n fn main() {\n     match Some(\"hi\".to_string()) {\n-        ref op_string_ref @ Some(s) => {}, //~ ERROR E0303\n-                                           //~^ ERROR E0009\n+        ref op_string_ref @ Some(s) => {},\n+        //~^ ERROR pattern bindings are not allowed after an `@` [E0303]\n+        //~| NOTE not allowed after `@`\n+        //~| ERROR E0009\n+        //~| NOTE by-move pattern here\n+        //~| NOTE both by-ref and by-move used\n         None => {},\n     }\n }"}, {"sha": "10c02d84b385e7105723652a177694a4c6700e13", "filename": "src/test/incremental/hashes/consts.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fconsts.rs?ref=0b2c356420c155373d312f4b7063fd19983dfd20", "patch": "@@ -0,0 +1,132 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for consts.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Change const visibility ---------------------------------------------------\n+#[cfg(cfail1)]\n+const CONST_VISIBILITY: u8 = 0;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub const CONST_VISIBILITY: u8 = 0;\n+\n+\n+// Change type from i32 to u32 ------------------------------------------------\n+#[cfg(cfail1)]\n+const CONST_CHANGE_TYPE_1: i32 = 0;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+const CONST_CHANGE_TYPE_1: u32 = 0;\n+\n+\n+// Change type from Option<u32> to Option<u64> --------------------------------\n+#[cfg(cfail1)]\n+const CONST_CHANGE_TYPE_2: Option<u32> = None;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+const CONST_CHANGE_TYPE_2: Option<u64> = None;\n+\n+\n+// Change value between simple literals ---------------------------------------\n+#[cfg(cfail1)]\n+const CONST_CHANGE_VALUE_1: i16 = 1;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+const CONST_CHANGE_VALUE_1: i16 = 2;\n+\n+\n+// Change value between expressions -------------------------------------------\n+#[cfg(cfail1)]\n+const CONST_CHANGE_VALUE_2: i16 = 1 + 1;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+const CONST_CHANGE_VALUE_2: i16 = 1 + 2;\n+\n+\n+#[cfg(cfail1)]\n+const CONST_CHANGE_VALUE_3: i16 = 2 + 3;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+const CONST_CHANGE_VALUE_3: i16 = 2 * 3;\n+\n+\n+#[cfg(cfail1)]\n+const CONST_CHANGE_VALUE_4: i16 = 1 + 2 * 3;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+const CONST_CHANGE_VALUE_4: i16 = 1 + 2 * 4;\n+\n+\n+// Change type indirectly -----------------------------------------------------\n+struct ReferencedType1;\n+struct ReferencedType2;\n+\n+mod const_change_type_indirectly {\n+    #[cfg(cfail1)]\n+    use super::ReferencedType1 as Type;\n+\n+    #[cfg(not(cfail1))]\n+    use super::ReferencedType2 as Type;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    const CONST_CHANGE_TYPE_INDIRECTLY_1: Type = Type;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    const CONST_CHANGE_TYPE_INDIRECTLY_2: Option<Type> = None;\n+}"}, {"sha": "ac67e4349013a8cad20e453dceaaee3ea1673572", "filename": "src/test/incremental/hashes/statics.rs", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstatics.rs?ref=0b2c356420c155373d312f4b7063fd19983dfd20", "patch": "@@ -0,0 +1,185 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for statics.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![feature(linkage)]\n+#![feature(thread_local)]\n+#![crate_type=\"rlib\"]\n+\n+\n+// Change static visibility ---------------------------------------------------\n+#[cfg(cfail1)]\n+static STATIC_VISIBILITY: u8 = 0;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub static STATIC_VISIBILITY: u8 = 0;\n+\n+\n+// Change static mutability ---------------------------------------------------\n+#[cfg(cfail1)]\n+static STATIC_MUTABILITY: u8 = 0;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+static mut STATIC_MUTABILITY: u8 = 0;\n+\n+\n+// Add linkage attribute ------------------------------------------------------\n+#[cfg(cfail1)]\n+static STATIC_LINKAGE: u8 = 0;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[linkage=\"weak_odr\"]\n+static STATIC_LINKAGE: u8 = 0;\n+\n+\n+// Add no_mangle attribute ----------------------------------------------------\n+#[cfg(cfail1)]\n+static STATIC_NO_MANGLE: u8 = 0;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[no_mangle]\n+static STATIC_NO_MANGLE: u8 = 0;\n+\n+\n+// Add thread_local attribute -------------------------------------------------\n+#[cfg(cfail1)]\n+static STATIC_THREAD_LOCAL: u8 = 0;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[thread_local]\n+static STATIC_THREAD_LOCAL: u8 = 0;\n+\n+\n+// Change type from i16 to u64 ------------------------------------------------\n+#[cfg(cfail1)]\n+static STATIC_CHANGE_TYPE_1: i16 = 0;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+static STATIC_CHANGE_TYPE_1: u64 = 0;\n+\n+\n+// Change type from Option<i8> to Option<u16> ---------------------------------\n+#[cfg(cfail1)]\n+static STATIC_CHANGE_TYPE_2: Option<i8> = None;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+static STATIC_CHANGE_TYPE_2: Option<u16> = None;\n+\n+\n+// Change value between simple literals ---------------------------------------\n+#[cfg(cfail1)]\n+static STATIC_CHANGE_VALUE_1: i16 = 1;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+static STATIC_CHANGE_VALUE_1: i16 = 2;\n+\n+\n+// Change value between expressions -------------------------------------------\n+#[cfg(cfail1)]\n+static STATIC_CHANGE_VALUE_2: i16 = 1 + 1;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+static STATIC_CHANGE_VALUE_2: i16 = 1 + 2;\n+\n+\n+#[cfg(cfail1)]\n+static STATIC_CHANGE_VALUE_3: i16 = 2 + 3;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+static STATIC_CHANGE_VALUE_3: i16 = 2 * 3;\n+\n+\n+#[cfg(cfail1)]\n+static STATIC_CHANGE_VALUE_4: i16 = 1 + 2 * 3;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+static STATIC_CHANGE_VALUE_4: i16 = 1 + 2 * 4;\n+\n+\n+// Change type indirectly -----------------------------------------------------\n+struct ReferencedType1;\n+struct ReferencedType2;\n+\n+mod static_change_type_indirectly {\n+    #[cfg(cfail1)]\n+    use super::ReferencedType1 as Type;\n+\n+    #[cfg(not(cfail1))]\n+    use super::ReferencedType2 as Type;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    static STATIC_CHANGE_TYPE_INDIRECTLY_1: Type = Type;\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    static STATIC_CHANGE_TYPE_INDIRECTLY_2: Option<Type> = None;\n+}"}, {"sha": "937f053e320f6a7c56d1965b2e68b98a44aac7a3", "filename": "src/test/incremental/hashes/trait_defs.rs", "status": "modified", "additions": 85, "deletions": 91, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs?ref=0b2c356420c155373d312f4b7063fd19983dfd20", "patch": "@@ -46,16 +46,15 @@ pub trait TraitVisibility { }\n \n \n // Change trait unsafety ----------------------------------------------------------\n-// FIXME: this should work but doesn't yet.\n-// #[cfg(cfail1)]\n-// trait TraitUnsafety { }\n+#[cfg(cfail1)]\n+trait TraitUnsafety { }\n \n-// #[cfg(not(cfail1))]\n-// #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-// #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-// #[rustc_metadata_dirty(cfg=\"cfail2\")]\n-// #[rustc_metadata_clean(cfg=\"cfail3\")]\n-// unsafe trait TraitUnsafety { }\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+unsafe trait TraitUnsafety { }\n \n \n \n@@ -178,20 +177,19 @@ trait TraitChangeMethodParameterType {\n \n \n // Change type of method parameter (&i32 => &mut i32) -----------------------------\n-// FIXME: this should work but doesn't yet.\n-// #[cfg(cfail1)]\n-// trait TraitChangeMethodParameterTypeRef {\n-//     fn method(a: &i32);\n-// }\n+#[cfg(cfail1)]\n+trait TraitChangeMethodParameterTypeRef {\n+    fn method(a: &i32);\n+}\n \n-// #[cfg(not(cfail1))]\n-// #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-// #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-// #[rustc_metadata_dirty(cfg=\"cfail2\")]\n-// #[rustc_metadata_clean(cfg=\"cfail3\")]\n-// trait TraitChangeMethodParameterTypeRef {\n-//     fn method(a: &mut i32);\n-// }\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+trait TraitChangeMethodParameterTypeRef {\n+    fn method(a: &mut i32);\n+}\n \n \n \n@@ -249,35 +247,35 @@ trait TraitChangeOrderOfMethods {\n \n \n // Change mode of self parameter --------------------------------------------------\n-// FIXME: this should work but doesn't yet.\n-// #[cfg(cfail1)]\n-// trait TraitChangeModeSelfRefToMut {\n-//     fn method(&self);\n-// }\n-\n-// #[cfg(not(cfail1))]\n-// #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-// #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-// #[rustc_metadata_dirty(cfg=\"cfail2\")]\n-// #[rustc_metadata_clean(cfg=\"cfail3\")]\n-// trait TraitChangeModeSelfRefToMut {\n-//     fn method(&mut self);\n-// }\n-\n-// FIXME: this should work but doesn't yet.\n-// #[cfg(cfail1)]\n-// trait TraitChangeModeSelfOwnToMut {\n-//     fn method(self);\n-// }\n-\n-// #[cfg(not(cfail1))]\n-// #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-// #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-// #[rustc_metadata_dirty(cfg=\"cfail2\")]\n-// #[rustc_metadata_clean(cfg=\"cfail3\")]\n-// trait TraitChangeModeSelfOwnToMut {\n-//     fn method(mut self);\n-// }\n+#[cfg(cfail1)]\n+trait TraitChangeModeSelfRefToMut {\n+    fn method(&self);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+trait TraitChangeModeSelfRefToMut {\n+    fn method(&mut self);\n+}\n+\n+\n+\n+#[cfg(cfail1)]\n+trait TraitChangeModeSelfOwnToMut {\n+    fn method(self);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+trait TraitChangeModeSelfOwnToMut {\n+    fn method(mut self);\n+}\n \n \n \n@@ -298,56 +296,53 @@ trait TraitChangeModeSelfOwnToRef {\n \n \n // Add unsafe modifier to method --------------------------------------------------\n-// FIXME: this should work but doesn't yet.\n-// #[cfg(cfail1)]\n-// trait TraitAddUnsafeModifier {\n-//     fn method();\n-// }\n+#[cfg(cfail1)]\n+trait TraitAddUnsafeModifier {\n+    fn method();\n+}\n \n-// #[cfg(not(cfail1))]\n-// #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-// #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-// #[rustc_metadata_dirty(cfg=\"cfail2\")]\n-// #[rustc_metadata_clean(cfg=\"cfail3\")]\n-// trait TraitAddUnsafeModifier {\n-//     unsafe fn method();\n-// }\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+trait TraitAddUnsafeModifier {\n+    unsafe fn method();\n+}\n \n \n \n // Add extern modifier to method --------------------------------------------------\n-// FIXME: this should work but doesn't yet.\n-// #[cfg(cfail1)]\n-// trait TraitAddExternModifier {\n-//     fn method();\n-// }\n+#[cfg(cfail1)]\n+trait TraitAddExternModifier {\n+    fn method();\n+}\n \n-// #[cfg(not(cfail1))]\n-// #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-// #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-// #[rustc_metadata_dirty(cfg=\"cfail2\")]\n-// #[rustc_metadata_clean(cfg=\"cfail3\")]\n-// trait TraitAddExternModifier {\n-//     extern fn method();\n-// }\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+trait TraitAddExternModifier {\n+    extern fn method();\n+}\n \n \n \n // Change extern \"C\" to extern \"rust-intrinsic\" -----------------------------------\n-// FIXME: this should work but doesn't yet.\n-// #[cfg(cfail1)]\n-// trait TraitChangeExternCToRustIntrinsic {\n-//     extern \"C\" fn method();\n-// }\n+#[cfg(cfail1)]\n+trait TraitChangeExternCToRustIntrinsic {\n+    extern \"C\" fn method();\n+}\n \n-// #[cfg(not(cfail1))]\n-// #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-// #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-// #[rustc_metadata_dirty(cfg=\"cfail2\")]\n-// #[rustc_metadata_clean(cfg=\"cfail3\")]\n-// trait TraitChangeExternCToRustIntrinsic {\n-//     extern \"rust-intrinsic\" fn method();\n-// }\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+trait TraitChangeExternCToRustIntrinsic {\n+    extern \"rust-intrinsic\" fn method();\n+}\n \n \n \n@@ -1118,4 +1113,3 @@ mod change_method_type_parameter_bound_indirectly_where {\n         fn method(a: T);\n     }\n }\n-"}, {"sha": "cc608a2447574ee74d71ec3aede6b9af15c9a14e", "filename": "src/test/rustdoc/line-breaks.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Ftest%2Frustdoc%2Fline-breaks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2c356420c155373d312f4b7063fd19983dfd20/src%2Ftest%2Frustdoc%2Fline-breaks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fline-breaks.rs?ref=0b2c356420c155373d312f4b7063fd19983dfd20", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+//@count foo/fn.function_with_a_really_long_name.html //pre/br 2\n+pub fn function_with_a_really_long_name(parameter_one: i32,\n+                                        parameter_two: i32)\n+                                        -> Option<i32> {\n+    Some(parameter_one + parameter_two)\n+}\n+\n+//@count foo/fn.short_name.html //pre/br 0\n+pub fn short_name(param: i32) -> i32 { param + 1 }"}]}