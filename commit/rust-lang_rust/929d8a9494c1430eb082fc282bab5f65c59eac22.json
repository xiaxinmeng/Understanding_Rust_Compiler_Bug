{"sha": "929d8a9494c1430eb082fc282bab5f65c59eac22", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyOWQ4YTk0OTRjMTQzMGViMDgyZmMyODJiYWI1ZjY1YzU5ZWFjMjI=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2019-03-24T22:25:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-24T22:25:28Z"}, "message": "Merge pull request #3459 from scampi/issue-3442\n\nfix line numbering in missed spans and handle file_lines in edge cases", "tree": {"sha": "31e40cdbd2988499fd2de54263339d35cff7ebbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31e40cdbd2988499fd2de54263339d35cff7ebbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/929d8a9494c1430eb082fc282bab5f65c59eac22", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcmAPYCRBK7hj4Ov3rIwAAdHIIAIoh7dy27Dlzr+TglNQZr4xr\nMIVj5GVhHomSSV/x2LTGUNwB9bxVLNO/azfMjq7uKAEkUxKhD2bPJxxhvQEl8nVM\nEO4CpPjFKd1MyYqXWxoX9N7G1lIZG9sOqSgqXENgnOR0o2qHWma6YuN1SaQSV2V/\nv8jouLz5gNFP2aPd6nPyMhYRF3Rl35qoTci9QvT3P/Pnlw7lTCfbvnuN8ORVFJSQ\nmauiN3FFRrTDyU1RFy8or1XhNQNiBmgHccPNB1IJAo5INnaJPkYi6uEHLc5ewgQB\n+scjIhmBA+0adtaG00JRk5E1ynlrH/dtDbi8/3Ql5idcPooJqU6Gx8uuMgCzXoU=\n=izZr\n-----END PGP SIGNATURE-----\n", "payload": "tree 31e40cdbd2988499fd2de54263339d35cff7ebbe\nparent a5cc780c98d3f93f65f2f0299fe327c4e1eef62f\nparent cdd08da27bfb76d24dc44848e4b086df7d25d4f6\nauthor Seiichi Uchida <seuchida@gmail.com> 1553466328 +0900\ncommitter GitHub <noreply@github.com> 1553466328 +0900\n\nMerge pull request #3459 from scampi/issue-3442\n\nfix line numbering in missed spans and handle file_lines in edge cases"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/929d8a9494c1430eb082fc282bab5f65c59eac22", "html_url": "https://github.com/rust-lang/rust/commit/929d8a9494c1430eb082fc282bab5f65c59eac22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/929d8a9494c1430eb082fc282bab5f65c59eac22/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5cc780c98d3f93f65f2f0299fe327c4e1eef62f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5cc780c98d3f93f65f2f0299fe327c4e1eef62f", "html_url": "https://github.com/rust-lang/rust/commit/a5cc780c98d3f93f65f2f0299fe327c4e1eef62f"}, {"sha": "cdd08da27bfb76d24dc44848e4b086df7d25d4f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdd08da27bfb76d24dc44848e4b086df7d25d4f6", "html_url": "https://github.com/rust-lang/rust/commit/cdd08da27bfb76d24dc44848e4b086df7d25d4f6"}], "stats": {"total": 127, "additions": 91, "deletions": 36}, "files": [{"sha": "70ca898f2af0600654b59798dc491a9d9b8d5a6d", "filename": "src/missed_spans.rs", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/929d8a9494c1430eb082fc282bab5f65c59eac22/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/929d8a9494c1430eb082fc282bab5f65c59eac22/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=929d8a9494c1430eb082fc282bab5f65c59eac22", "patch": "@@ -3,6 +3,7 @@ use std::borrow::Cow;\n use syntax::source_map::{BytePos, Pos, Span};\n \n use crate::comment::{rewrite_comment, CodeCharKind, CommentCodeSlices};\n+use crate::config::file_lines::FileLines;\n use crate::config::{EmitMode, FileName};\n use crate::shape::{Indent, Shape};\n use crate::source_map::LineRangeUtils;\n@@ -156,7 +157,7 @@ impl<'a> FmtVisitor<'a> {\n     fn write_snippet_inner<F>(\n         &mut self,\n         big_snippet: &str,\n-        big_diff: usize,\n+        mut big_diff: usize,\n         old_snippet: &str,\n         span: Span,\n         process_last_snippet: F,\n@@ -175,16 +176,36 @@ impl<'a> FmtVisitor<'a> {\n             _ => Cow::from(old_snippet),\n         };\n \n-        for (kind, offset, subslice) in CommentCodeSlices::new(snippet) {\n-            debug!(\"{:?}: {:?}\", kind, subslice);\n+        // if the snippet starts with a new line, then information about the lines needs to be\n+        // adjusted since it is off by 1.\n+        let snippet = if snippet.starts_with('\\n') {\n+            // this takes into account the blank_lines_* options\n+            self.push_vertical_spaces(1);\n+            // include the newline character into the big_diff\n+            big_diff += 1;\n+            status.cur_line += 1;\n+            &snippet[1..]\n+        } else {\n+            snippet\n+        };\n \n-            let newline_count = count_newlines(subslice);\n-            let within_file_lines_range = self.config.file_lines().contains_range(\n+        let slice_within_file_lines_range = |file_lines: FileLines, cur_line, s| -> (usize, bool) {\n+            let newline_count = count_newlines(s);\n+            let within_file_lines_range = file_lines.contains_range(\n                 file_name,\n-                status.cur_line,\n-                status.cur_line + newline_count,\n+                cur_line,\n+                // if a newline character is at the end of the slice, then the number of newlines\n+                // needs to be decreased by 1 so that the range checked against the file_lines is\n+                // the visual range one would expect.\n+                cur_line + newline_count - if s.ends_with('\\n') { 1 } else { 0 },\n             );\n+            (newline_count, within_file_lines_range)\n+        };\n+        for (kind, offset, subslice) in CommentCodeSlices::new(snippet) {\n+            debug!(\"{:?}: {:?}\", kind, subslice);\n \n+            let (newline_count, within_file_lines_range) =\n+                slice_within_file_lines_range(self.config.file_lines(), status.cur_line, subslice);\n             if CodeCharKind::Comment == kind && within_file_lines_range {\n                 // 1: comment.\n                 self.process_comment(\n@@ -205,7 +226,15 @@ impl<'a> FmtVisitor<'a> {\n             }\n         }\n \n-        process_last_snippet(self, &snippet[status.line_start..], snippet);\n+        let last_snippet = &snippet[status.line_start..];\n+        let (_, within_file_lines_range) =\n+            slice_within_file_lines_range(self.config.file_lines(), status.cur_line, last_snippet);\n+        if within_file_lines_range {\n+            process_last_snippet(self, last_snippet, snippet);\n+        } else {\n+            // just append what's left\n+            self.push_str(last_snippet);\n+        }\n     }\n \n     fn process_comment("}, {"sha": "096a7ce57131ae14226fb7885fb11b5c839536c8", "filename": "src/source_map.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/929d8a9494c1430eb082fc282bab5f65c59eac22/src%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/929d8a9494c1430eb082fc282bab5f65c59eac22/src%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsource_map.rs?ref=929d8a9494c1430eb082fc282bab5f65c59eac22", "patch": "@@ -71,6 +71,7 @@ impl<'a> SpanUtils for SnippetProvider<'a> {\n \n impl LineRangeUtils for SourceMap {\n     fn lookup_line_range(&self, span: Span) -> LineRange {\n+        let snippet = self.span_to_snippet(span).unwrap_or(String::new());\n         let lo = self.lookup_line(span.lo()).unwrap();\n         let hi = self.lookup_line(span.hi()).unwrap();\n \n@@ -80,11 +81,14 @@ impl LineRangeUtils for SourceMap {\n             lo, hi\n         );\n \n+        // in case the span starts with a newline, the line range is off by 1 without the\n+        // adjustment below\n+        let offset = 1 + if snippet.starts_with('\\n') { 1 } else { 0 };\n         // Line numbers start at 1\n         LineRange {\n             file: lo.sf.clone(),\n-            lo: lo.line + 1,\n-            hi: hi.line + 1,\n+            lo: lo.line + offset,\n+            hi: hi.line + offset,\n         }\n     }\n }"}, {"sha": "c29409c2fdf7ec3af0f7f392640ed9c81feb3419", "filename": "src/visitor.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/929d8a9494c1430eb082fc282bab5f65c59eac22/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/929d8a9494c1430eb082fc282bab5f65c59eac22/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=929d8a9494c1430eb082fc282bab5f65c59eac22", "patch": "@@ -6,6 +6,7 @@ use syntax::{ast, visit};\n \n use crate::attr::*;\n use crate::comment::{CodeCharKind, CommentCodeSlices, FindUncommented};\n+use crate::config::file_lines::FileName;\n use crate::config::{BraceStyle, Config, Version};\n use crate::expr::{format_expr, ExprType};\n use crate::items::{\n@@ -171,7 +172,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n         if skip_rewrite {\n             self.push_rewrite(b.span, None);\n-            self.close_block(false);\n+            self.close_block(false, b.span);\n             self.last_pos = source!(self, b.span).hi();\n             return;\n         }\n@@ -188,21 +189,25 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n         let mut remove_len = BytePos(0);\n         if let Some(stmt) = b.stmts.last() {\n-            let snippet = self.snippet(mk_sp(\n+            let span_after_last_stmt = mk_sp(\n                 stmt.span.hi(),\n                 source!(self, b.span).hi() - brace_compensation,\n-            ));\n-            let len = CommentCodeSlices::new(snippet)\n-                .last()\n-                .and_then(|(kind, _, s)| {\n-                    if kind == CodeCharKind::Normal && s.trim().is_empty() {\n-                        Some(s.len())\n-                    } else {\n-                        None\n-                    }\n-                });\n-            if let Some(len) = len {\n-                remove_len = BytePos::from_usize(len);\n+            );\n+            // if the span is outside of a file_lines range, then do not try to remove anything\n+            if !out_of_file_lines_range!(self, span_after_last_stmt) {\n+                let snippet = self.snippet(span_after_last_stmt);\n+                let len = CommentCodeSlices::new(snippet)\n+                    .last()\n+                    .and_then(|(kind, _, s)| {\n+                        if kind == CodeCharKind::Normal && s.trim().is_empty() {\n+                            Some(s.len())\n+                        } else {\n+                            None\n+                        }\n+                    });\n+                if let Some(len) = len {\n+                    remove_len = BytePos::from_usize(len);\n+                }\n             }\n         }\n \n@@ -221,24 +226,31 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         if unindent_comment {\n             self.block_indent = self.block_indent.block_indent(self.config);\n         }\n-        self.close_block(unindent_comment);\n+        self.close_block(unindent_comment, b.span);\n         self.last_pos = source!(self, b.span).hi();\n     }\n \n     // FIXME: this is a terrible hack to indent the comments between the last\n     // item in the block and the closing brace to the block's level.\n     // The closing brace itself, however, should be indented at a shallower\n     // level.\n-    fn close_block(&mut self, unindent_comment: bool) {\n-        let total_len = self.buffer.len();\n-        let chars_too_many = if unindent_comment {\n-            0\n-        } else if self.config.hard_tabs() {\n-            1\n-        } else {\n-            self.config.tab_spaces()\n-        };\n-        self.buffer.truncate(total_len - chars_too_many);\n+    fn close_block(&mut self, unindent_comment: bool, span: Span) {\n+        let file_name: FileName = self.source_map.span_to_filename(span).into();\n+        let skip_this_line = !self\n+            .config\n+            .file_lines()\n+            .contains_line(&file_name, self.line_number);\n+        if !skip_this_line {\n+            let total_len = self.buffer.len();\n+            let chars_too_many = if unindent_comment {\n+                0\n+            } else if self.config.hard_tabs() {\n+                1\n+            } else {\n+                self.config.tab_spaces()\n+            };\n+            self.buffer.truncate(total_len - chars_too_many);\n+        }\n         self.push_str(\"}\");\n         self.block_indent = self.block_indent.block_unindent(self.config);\n     }\n@@ -789,7 +801,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 self.visit_attrs(attrs, ast::AttrStyle::Inner);\n                 self.walk_mod_items(m);\n                 self.format_missing_with_indent(source!(self, m.inner).hi() - BytePos(1));\n-                self.close_block(false);\n+                self.close_block(false, m.inner);\n             }\n             self.last_pos = source!(self, m.inner).hi();\n         } else {"}, {"sha": "3664c50ee7a8b90c9cd3c7154e5d14f34237a8b0", "filename": "tests/target/issue-3442.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/929d8a9494c1430eb082fc282bab5f65c59eac22/tests%2Ftarget%2Fissue-3442.rs", "raw_url": "https://github.com/rust-lang/rust/raw/929d8a9494c1430eb082fc282bab5f65c59eac22/tests%2Ftarget%2Fissue-3442.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3442.rs?ref=929d8a9494c1430eb082fc282bab5f65c59eac22", "patch": "@@ -0,0 +1,10 @@\n+// rustfmt-file_lines: [{\"file\":\"tests/target/issue-3442.rs\",\"range\":[5,5]},{\"file\":\"tests/target/issue-3442.rs\",\"range\":[8,8]}]\n+\n+extern crate alpha; // comment 1\n+extern crate beta; // comment 2\n+#[allow(aaa)] // comment 3\n+#[macro_use]\n+extern crate gamma;\n+#[allow(bbb)] // comment 4\n+#[macro_use]\n+extern crate lazy_static;"}]}