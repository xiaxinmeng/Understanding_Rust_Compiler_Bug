{"sha": "a856bccdc647330624fa36a25190aa63e1274379", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NTZiY2NkYzY0NzMzMDYyNGZhMzZhMjUxOTBhYTYzZTEyNzQzNzk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-07T03:45:06Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-07T03:45:06Z"}, "message": "Revert \"rustc: Switch to the new resolution pass\"\n\nThis reverts commit c4af6e92fbae171c56a4e68666025725555fc9d8.\n\nBranch was burning...many, many unresolved imports.", "tree": {"sha": "35ba72c2a0dfacea35cb32753f73a1457d94d596", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35ba72c2a0dfacea35cb32753f73a1457d94d596"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a856bccdc647330624fa36a25190aa63e1274379", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a856bccdc647330624fa36a25190aa63e1274379", "html_url": "https://github.com/rust-lang/rust/commit/a856bccdc647330624fa36a25190aa63e1274379", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a856bccdc647330624fa36a25190aa63e1274379/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9cb04f6fa6c23e98322d2aef5e704bfdbcacb7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9cb04f6fa6c23e98322d2aef5e704bfdbcacb7b", "html_url": "https://github.com/rust-lang/rust/commit/f9cb04f6fa6c23e98322d2aef5e704bfdbcacb7b"}], "stats": {"total": 758, "additions": 328, "deletions": 430}, "files": [{"sha": "f41e24c623f70bfe505f7135770f53fe952b9fe1", "filename": "src/libcore/task.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -63,12 +63,6 @@ export local_data_get;\n export local_data_set;\n export local_data_modify;\n \n-export single_threaded;\n-export thread_per_core;\n-export thread_per_task;\n-export manual_threads;\n-export osmain;\n-\n /* Data types */\n \n /// A handle to a task"}, {"sha": "2353a983dc2bd054c5c296e479a70e80d3c526d6", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -25,7 +25,6 @@ export ip_addr, parse_addr_err;\n export format_addr;\n export v4, v6;\n export get_addr;\n-export ipv4, ipv6;\n \n /// An IP address\n enum ip_addr {\n@@ -390,4 +389,4 @@ mod test {\n         let ga_result = get_addr(localhost_name, iotask);\n         assert result::is_err(ga_result);\n     }\n-}\n+}\n\\ No newline at end of file"}, {"sha": "b2d06311e673a27ba544f67b7fe067d3b9efa254", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -16,8 +16,10 @@ export parse_from_source_str;\n // unresolved import errors. Maybe resolve3 will fix it.\n import common::*;\n import parser::parser;\n-import attr::parser_attr;\n-import common::parser_common;\n+//import attr::parser_attr;\n+import attr::*; //resolve bug?\n+//import common::parser_common;\n+import common::*; //resolve bug?\n import ast::node_id;\n import util::interner;\n // FIXME (#1935): resolve badness"}, {"sha": "e188331dd2490e3704bbc0690860e27be488f8f9", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -9,7 +9,6 @@ export lit;\n export cmnt_style;\n export gather_comments_and_literals;\n export is_doc_comment, doc_comment_style, strip_doc_comment_decoration;\n-export isolated, trailing, mixed, blank_line;\n \n enum cmnt_style {\n     isolated, // No code on either side of each line of the comment"}, {"sha": "c94e2acbb2b44afc90150d60c06e8cfc3855be4e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -12,47 +12,7 @@ import common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed,\n                 seq_sep_none, token_to_str};\n import dvec::{dvec, extensions};\n import vec::{push};\n-import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n-             bitand, bitor, bitxor, blk, blk_check_mode, bound_const,\n-             bound_copy, bound_send, bound_trait, box, by_copy, by_move,\n-             by_mutbl_ref, by_ref, by_val, capture_clause, capture_item,\n-             carg_base, carg_ident, cdir_dir_mod, cdir_src_mod,\n-             cdir_view_item, checked_expr, claimed_expr, class_immutable,\n-             class_member, class_method, class_mutable, constr, constr_arg,\n-             constr_general, crate, crate_cfg, crate_directive, decl,\n-             decl_item, decl_local, default_blk, deref, div, expl, expr,\n-             expr_, expr_addr_of, expr_alt, expr_assert, expr_assign,\n-             expr_assign_op, expr_binary, expr_block, expr_break, expr_call,\n-             expr_cast, expr_check, expr_cont, expr_copy, expr_do_body,\n-             expr_fail, expr_field, expr_fn, expr_fn_block, expr_if,\n-             expr_if_check, expr_index, expr_lit, expr_log, expr_loop,\n-             expr_loop_body, expr_mac, expr_move, expr_new, expr_path,\n-             expr_rec, expr_ret, expr_swap, expr_tup, expr_unary, expr_vec,\n-             expr_vstore, expr_while, extern_fn, field, fn_decl, foreign_item,\n-             foreign_item_fn, foreign_mod, ident, impure_fn, infer,\n-             init_assign, init_move, initializer, instance_var, item, item_,\n-             item_class, item_const, item_enum, item_fn, item_foreign_mod,\n-             item_impl, item_mod, item_trait, item_ty, lit, lit_, lit_bool,\n-             lit_float, lit_int, lit_int_unsuffixed, lit_nil, lit_str,\n-             lit_uint, local, m_const, m_imm, m_mutbl, mac_, mac_aq,\n-             mac_ellipsis, mac_embed_block, mac_embed_type, mac_invoc,\n-             mac_invoc_tt, mac_var, matcher, method, mode, mt, mtc_bb,\n-             mtc_rep, mtc_tok, mul, mutability, neg, noreturn, not, pat,\n-             pat_box, pat_enum, pat_ident, pat_lit, pat_range, pat_rec,\n-             pat_tup, pat_uniq, pat_wild, path, private, proto, proto_any,\n-             proto_bare, proto_block, proto_box, proto_uniq, public, pure_fn,\n-             purity, re_anon, re_named, region, region_param, rem, ret_style,\n-             return_val, rp_none, rp_self, shl, shr, stmt, stmt_decl,\n-             stmt_expr, stmt_semi, subtract, token_tree, trait_ref, tt_delim,\n-             tt_dotdotdot, tt_flat, tt_interpolate, ty, ty_, ty_bot, ty_box,\n-             ty_constr, ty_constr_, ty_constr_arg, ty_field, ty_fn, ty_infer,\n-             ty_mac, ty_method, ty_nil, ty_param, ty_path, ty_ptr, ty_rec,\n-             ty_rptr, ty_tup, ty_u32, ty_uniq, ty_vec, ty_vstore,\n-             unchecked_blk, uniq, unsafe_blk, unsafe_fn, variant, view_item,\n-             view_item_, view_item_export, view_item_import, view_item_use,\n-             view_path, view_path_glob, view_path_list, view_path_simple,\n-             visibility, vstore, vstore_box, vstore_fixed, vstore_slice,\n-             vstore_uniq};\n+import ast::*;\n \n export file_type;\n export parser;"}, {"sha": "799f34377ede4955bb503fd7982f8f6a5f97ba74", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -168,9 +168,26 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n                              session::sess_os_to_meta_os(sess.targ_cfg.os),\n                              sess.opts.static));\n \n-    let { def_map: def_map, exp_map: exp_map, impl_map: impl_map } =\n-        time(time_passes, \"fast resolution\", ||\n-             middle::resolve3::resolve_crate(sess, ast_map, crate));\n+    let mut def_map;\n+    let mut impl_map;\n+    let mut exp_map;\n+    if sess.fast_resolve() {\n+        let { def_map: fast_dm, exp_map: fast_em, impl_map: fast_im } =\n+            time(time_passes, \"fast resolution\", ||\n+                 middle::resolve3::resolve_crate(sess, ast_map, crate));\n+\n+        def_map = fast_dm;\n+        impl_map = fast_im;\n+        exp_map = fast_em;\n+    } else {\n+        let { def_map: normal_dm, exp_map: normal_em, impl_map: normal_im } =\n+            time(time_passes, \"resolution\", ||\n+                 resolve::resolve_crate(sess, ast_map, crate));\n+\n+        def_map = normal_dm;\n+        impl_map = normal_im;\n+        exp_map = normal_em;\n+    }\n \n     let freevars = time(time_passes, \"freevar finding\", ||\n         freevars::annotate_freevars(def_map, crate));"}, {"sha": "63f3658a4e93ec872f8cac0a756550f68463ba92", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -9,7 +9,6 @@ import filesearch::filesearch;\n import io::writer_util;\n \n export os;\n-export os_macos, os_win32, os_linux, os_freebsd;\n export ctxt;\n export load_library_crate;\n export list_file_metadata;"}, {"sha": "6ca613d528103a9ac22d3da3df52c3ec38b15909", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 113, "deletions": 337, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -2,7 +2,6 @@ import driver::session::session;\n import metadata::csearch::{each_path, get_impls_for_mod, lookup_defs};\n import metadata::cstore::find_use_stmt_cnum;\n import metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n-import middle::lint::{error, ignore, level, unused_imports, warn};\n import syntax::ast::{_mod, arm, blk, bound_const, bound_copy, bound_trait};\n import syntax::ast::{bound_send, capture_clause, class_ctor, class_dtor};\n import syntax::ast::{class_member, class_method, crate, crate_num, decl_item};\n@@ -144,10 +143,7 @@ enum TypeParameters/& {\n                       // The index at the method site will be 1, because the\n                       // outer T had index 0.\n \n-                      uint,\n-\n-                      // The kind of the rib used for type parameters.\n-                      RibKind)\n+                      uint)\n }\n \n // The rib kind controls the translation of argument or local definitions\n@@ -156,13 +152,9 @@ enum TypeParameters/& {\n enum RibKind {\n     // No translation needs to be applied.\n     NormalRibKind,\n-\n     // We passed through a function scope at the given node ID. Translate\n     // upvars as appropriate.\n-    FunctionRibKind(node_id),\n-\n-    // We passed through a function *item* scope. Disallow upvars.\n-    OpaqueFunctionRibKind\n+    FunctionRibKind(node_id)\n }\n \n // The X-ray flag indicates that a context has the X-ray privilege, which\n@@ -177,17 +169,6 @@ enum XrayFlag {\n     Xray        //< Private items can be accessed.\n }\n \n-enum AllowCapturingSelfFlag {\n-    AllowCapturingSelf,         //< The \"self\" definition can be captured.\n-    DontAllowCapturingSelf,     //< The \"self\" definition cannot be captured.\n-}\n-\n-enum EnumVariantOrConstResolution {\n-    FoundEnumVariant(def),\n-    FoundConst,\n-    EnumVariantOrConstNotFound\n-}\n-\n // FIXME (issue #2550): Should be a class but then it becomes not implicitly\n // copyable due to a kind bug.\n \n@@ -277,15 +258,10 @@ class Rib {\n class ImportDirective {\n     let module_path: @dvec<Atom>;\n     let subclass: @ImportDirectiveSubclass;\n-    let span: span;\n-\n-    new(module_path: @dvec<Atom>,\n-        subclass: @ImportDirectiveSubclass,\n-        span: span) {\n \n+    new(module_path: @dvec<Atom>, subclass: @ImportDirectiveSubclass) {\n         self.module_path = module_path;\n         self.subclass = subclass;\n-        self.span = span;\n     }\n }\n \n@@ -301,8 +277,6 @@ class Target {\n }\n \n class ImportResolution {\n-    let span: span;\n-\n     // The number of outstanding references to this name. When this reaches\n     // zero, outside modules can count on the targets being correct. Before\n     // then, all bets are off; future imports could override this name.\n@@ -314,19 +288,13 @@ class ImportResolution {\n     let mut type_target: option<Target>;\n     let mut impl_target: @dvec<@Target>;\n \n-    let mut used: bool;\n-\n-    new(span: span) {\n-        self.span = span;\n-\n+    new() {\n         self.outstanding_references = 0u;\n \n         self.module_target = none;\n         self.value_target = none;\n         self.type_target = none;\n         self.impl_target = @dvec();\n-\n-        self.used = false;\n     }\n \n     fn target_for_namespace(namespace: Namespace) -> option<Target> {\n@@ -430,18 +398,10 @@ pure fn is_none<T>(x: option<T>) -> bool {\n     }\n }\n \n-fn unused_import_lint_level(session: session) -> level {\n-    for session.opts.lint_opts.each |lint_option_pair| {\n-        let (lint_type, lint_level) = lint_option_pair;\n-        if lint_type == unused_imports {\n-            ret lint_level;\n-        }\n-    }\n-    ret ignore;\n-}\n-\n-// Records the definitions (at most one for each namespace) that a name is\n-// bound to.\n+/**\n+ * Records the definitions (at most one for each namespace) that a name is\n+ * bound to.\n+ */\n class NameBindings {\n     let mut module_def: ModuleDef;      //< Meaning in the module namespace.\n     let mut type_def: option<def>;      //< Meaning in the type namespace.\n@@ -589,8 +549,6 @@ class Resolver {\n \n     let graph_root: @NameBindings;\n \n-    let unused_import_lint_level: level;\n-\n     // The number of imports that are currently unresolved.\n     let mut unresolved_imports: uint;\n \n@@ -636,8 +594,6 @@ class Resolver {\n         (*self.graph_root).define_module(NoParentLink,\n                                          some({ crate: 0, node: 0 }));\n \n-        self.unused_import_lint_level = unused_import_lint_level(session);\n-\n         self.unresolved_imports = 0u;\n \n         self.current_module = (*self.graph_root).get_module();\n@@ -658,21 +614,10 @@ class Resolver {\n     /// The main name resolution procedure.\n     fn resolve(this: @Resolver) {\n         self.build_reduced_graph(this);\n-        self.session.abort_if_errors();\n-\n         self.resolve_imports();\n-        self.session.abort_if_errors();\n-\n         self.record_exports();\n-        self.session.abort_if_errors();\n-\n         self.build_impl_scopes();\n-        self.session.abort_if_errors();\n-\n         self.resolve_crate();\n-        self.session.abort_if_errors();\n-\n-        self.check_for_unused_imports_if_necessary();\n     }\n \n     //\n@@ -1000,8 +945,7 @@ class Resolver {\n                                                          source_atom);\n                             self.build_import_directive(module,\n                                                         module_path,\n-                                                        subclass,\n-                                                        view_path.span);\n+                                                        subclass);\n                         }\n                         view_path_list(_, source_idents, _) {\n                             for source_idents.each |source_ident| {\n@@ -1010,15 +954,13 @@ class Resolver {\n                                 let subclass = @SingleImport(atom, atom);\n                                 self.build_import_directive(module,\n                                                             module_path,\n-                                                            subclass,\n-                                                            view_path.span);\n+                                                            subclass);\n                             }\n                         }\n                         view_path_glob(_, _) {\n                             self.build_import_directive(module,\n                                                         module_path,\n-                                                        @GlobImport,\n-                                                        view_path.span);\n+                                                        @GlobImport);\n                         }\n                     }\n                 }\n@@ -1124,8 +1066,7 @@ class Resolver {\n                 do self.with_type_parameter_rib\n                         (HasTypeParameters(&type_parameters,\n                                            foreign_item.id,\n-                                           0u,\n-                                           NormalRibKind)) || {\n+                                           0u)) || {\n \n                     visit_foreign_item(foreign_item, new_parent, visitor);\n                 }\n@@ -1351,10 +1292,9 @@ class Resolver {\n     /// Creates and adds an import directive to the given module.\n     fn build_import_directive(module: @Module,\n                               module_path: @dvec<Atom>,\n-                              subclass: @ImportDirectiveSubclass,\n-                              span: span) {\n+                              subclass: @ImportDirectiveSubclass) {\n \n-        let directive = @ImportDirective(module_path, subclass, span);\n+        let directive = @ImportDirective(module_path, subclass);\n         module.imports.push(directive);\n \n         // Bump the reference count on the name. Or, if this is a glob, set\n@@ -1367,7 +1307,7 @@ class Resolver {\n                         resolution.outstanding_references += 1u;\n                     }\n                     none {\n-                        let resolution = @ImportResolution(span);\n+                        let resolution = @ImportResolution();\n                         resolution.outstanding_references = 1u;\n                         module.import_resolutions.insert(target, resolution);\n                     }\n@@ -1463,8 +1403,9 @@ class Resolver {\n             alt self.resolve_import_for_module(module, import_directive) {\n                 Failed {\n                     // We presumably emitted an error. Continue.\n-                    self.session.span_err(import_directive.span,\n-                                          \"failed to resolve import\");\n+                    // XXX: span_err\n+                    self.session.err(#fmt(\"failed to resolve import in: %s\",\n+                                          self.module_to_str(module)));\n                 }\n                 Indeterminate {\n                     // Bail out. We'll come around next time.\n@@ -1509,8 +1450,7 @@ class Resolver {\n             // First, resolve the module path for the directive, if necessary.\n             alt self.resolve_module_path_for_import(module,\n                                                     module_path,\n-                                                    NoXray,\n-                                                    import_directive.span) {\n+                                                    NoXray) {\n \n                 Failed {\n                     resolution_result = Failed;\n@@ -1531,11 +1471,9 @@ class Resolver {\n                                                            source);\n                         }\n                         GlobImport {\n-                            let span = import_directive.span;\n                             resolution_result =\n                                 self.resolve_glob_import(module,\n-                                                         containing_module,\n-                                                         span);\n+                                                         containing_module);\n                         }\n                     }\n                 }\n@@ -1672,7 +1610,6 @@ class Resolver {\n                     some(import_resolution)\n                             if import_resolution.outstanding_references\n                                 == 0u {\n-\n                         fn get_binding(import_resolution: @ImportResolution,\n                                        namespace: Namespace)\n                                     -> NamespaceResult {\n@@ -1683,7 +1620,6 @@ class Resolver {\n                                     ret UnboundResult;\n                                 }\n                                 some(target) {\n-                                    import_resolution.used = true;\n                                     ret BoundResult(target.target_module,\n                                                     target.bindings);\n                                 }\n@@ -1794,9 +1730,7 @@ class Resolver {\n      * succeeds or bails out (as importing * from an empty module or a module\n      * that exports nothing is valid).\n      */\n-    fn resolve_glob_import(module: @Module,\n-                           containing_module: @Module,\n-                           span: span)\n+    fn resolve_glob_import(module: @Module, containing_module: @Module)\n                         -> ResolveResult<()> {\n \n         // This function works in a highly imperative manner; it eagerly adds\n@@ -1833,8 +1767,7 @@ class Resolver {\n             alt module.import_resolutions.find(atom) {\n                 none {\n                     // Simple: just copy the old import resolution.\n-                    let new_import_resolution =\n-                        @ImportResolution(target_import_resolution.span);\n+                    let new_import_resolution = @ImportResolution();\n                     new_import_resolution.module_target =\n                         copy target_import_resolution.module_target;\n                     new_import_resolution.value_target =\n@@ -1895,17 +1828,12 @@ class Resolver {\n \n         // Add all children from the containing module.\n         for containing_module.children.each |atom, name_bindings| {\n-            if !self.name_is_exported(containing_module, atom) {\n-                #debug(\"(resolving glob import) name '%s' is unexported\",\n-                       *(*self.atom_table).atom_to_str(atom));\n-                cont;\n-            }\n \n             let mut dest_import_resolution;\n             alt module.import_resolutions.find(atom) {\n                 none {\n                     // Create a new import resolution from this child.\n-                    dest_import_resolution = @ImportResolution(span);\n+                    dest_import_resolution = @ImportResolution();\n                     module.import_resolutions.insert\n                         (atom, dest_import_resolution);\n                 }\n@@ -1951,8 +1879,7 @@ class Resolver {\n     fn resolve_module_path_from_root(module: @Module,\n                                      module_path: @dvec<Atom>,\n                                      index: uint,\n-                                     xray: XrayFlag,\n-                                     span: span)\n+                                     xray: XrayFlag)\n                                   -> ResolveResult<@Module> {\n \n         let mut search_module = module;\n@@ -1969,7 +1896,10 @@ class Resolver {\n                                             xray) {\n \n                 Failed {\n-                    self.session.span_err(span, \"unresolved name\");\n+                    // XXX: span_err\n+                    self.session.err(#fmt(\"module resolution failed: %s\",\n+                                          *(*self.atom_table)\n+                                                .atom_to_str(name)));\n                     ret Failed;\n                 }\n                 Indeterminate {\n@@ -1982,10 +1912,10 @@ class Resolver {\n                     alt target.bindings.module_def {\n                         NoModuleDef {\n                             // Not a module.\n-                            self.session.span_err(span,\n-                                                  #fmt(\"not a module: %s\",\n-                                                       *(*self.atom_table).\n-                                                         atom_to_str(name)));\n+                            // XXX: span_err\n+                            self.session.err(#fmt(\"not a module: %s\",\n+                                                  *(*self.atom_table).\n+                                                    atom_to_str(name)));\n                             ret Failed;\n                         }\n                         ModuleDef(module) {\n@@ -2007,8 +1937,7 @@ class Resolver {\n      */\n     fn resolve_module_path_for_import(module: @Module,\n                                       module_path: @dvec<Atom>,\n-                                      xray: XrayFlag,\n-                                      span: span)\n+                                      xray: XrayFlag)\n                                    -> ResolveResult<@Module> {\n \n         let module_path_len = (*module_path).len();\n@@ -2026,7 +1955,10 @@ class Resolver {\n         let mut search_module;\n         alt self.resolve_module_in_lexical_scope(module, first_element) {\n             Failed {\n-                self.session.span_err(span, \"unresolved name\");\n+                // XXX: span_err\n+                self.session.err(#fmt(\"unresolved name: %s\",\n+                                       *(*self.atom_table).\n+                                            atom_to_str(first_element)));\n                 ret Failed;\n             }\n             Indeterminate {\n@@ -2042,8 +1974,7 @@ class Resolver {\n         ret self.resolve_module_path_from_root(search_module,\n                                                module_path,\n                                                1u,\n-                                               xray,\n-                                               span);\n+                                               xray);\n     }\n \n     fn resolve_item_in_lexical_scope(module: @Module,\n@@ -2087,7 +2018,6 @@ class Resolver {\n                                namespace);\n                     }\n                     some(target) {\n-                        import_resolution.used = true;\n                         ret Success(copy target);\n                     }\n                 }\n@@ -2227,7 +2157,6 @@ class Resolver {\n                     some(target) {\n                         #debug(\"(resolving name in module) resolved to \\\n                                 import\");\n-                        import_resolution.used = true;\n                         ret Success(copy target);\n                     }\n                 }\n@@ -2387,7 +2316,8 @@ class Resolver {\n         if is_none(module_result) && is_none(value_result) &&\n                 is_none(type_result) && is_none(impl_result) {\n \n-            self.session.span_err(import_directive.span, \"unresolved import\");\n+            // XXX: span_err, better error\n+            self.session.err(\"couldn't find anything with that name\");\n             ret Failed;\n         }\n \n@@ -2431,8 +2361,13 @@ class Resolver {\n         let index = module.resolved_import_count;\n         let import_count = module.imports.len();\n         if index != import_count {\n-            self.session.span_err(module.imports.get_elt(index).span,\n-                                  \"unresolved import\");\n+            let module_path = module.imports.get_elt(index).module_path;\n+\n+            // XXX: span_err\n+            self.session.err(#fmt(\"unresolved import in %s: %s\",\n+                                  self.module_to_str(module),\n+                                  *(*self.atom_table)\n+                                       .atoms_to_str((*module_path).get())));\n         }\n \n         // Descend into children and anonymous children.\n@@ -2517,8 +2452,7 @@ class Resolver {\n \n                 alt self.resolve_definition_of_name_in_module(module,\n                                                               name,\n-                                                              namespace,\n-                                                              Xray) {\n+                                                              namespace) {\n                     NoNameDefinition {\n                         // Nothing to do.\n                     }\n@@ -2577,7 +2511,7 @@ class Resolver {\n         for module.children.each |_atom, child_name_bindings| {\n             alt (*child_name_bindings).get_module_if_available() {\n                 none {\n-                    // Nothing to do.\n+                    /* Nothing to do. */\n                 }\n                 some(child_module) {\n                     self.build_impl_scopes_for_module_subtree(child_module);\n@@ -2643,7 +2577,10 @@ class Resolver {\n \n     // AST resolution\n     //\n-    // We maintain a list of value ribs and type ribs.\n+    // We maintain a list of value ribs and type ribs. Since ribs are\n+    // somewhat expensive to allocate, we try to avoid creating ribs unless\n+    // we know we need to. For instance, we don't allocate a type rib for\n+    // a function with no type parameters.\n     //\n     // Simultaneously, we keep track of the current position in the module\n     // graph in the `current_module` pointer. When we go to resolve a name in\n@@ -2697,30 +2634,18 @@ class Resolver {\n     // Wraps the given definition in the appropriate number of `def_upvar`\n     // wrappers.\n \n-    fn upvarify(ribs: @dvec<@Rib>, rib_index: uint, def_like: def_like,\n-                span: span, allow_capturing_self: AllowCapturingSelfFlag)\n-             -> option<def_like> {\n+    fn upvarify(ribs: @dvec<@Rib>, rib_index: uint, def_like: def_like)\n+             -> def_like {\n \n         let mut def;\n-        let mut is_ty_param;\n-\n         alt def_like {\n             dl_def(d @ def_local(*)) | dl_def(d @ def_upvar(*)) |\n-            dl_def(d @ def_arg(*)) | dl_def(d @ def_binding(*)) {\n-                def = d;\n-                is_ty_param = false;\n-            }\n-            dl_def(d @ def_ty_param(*)) {\n+            dl_def(d @ def_arg(*)) | dl_def(d @ def_self(*)) |\n+            dl_def(d @ def_binding(*)) {\n                 def = d;\n-                is_ty_param = true;\n-            }\n-            dl_def(d @ def_self(*))\n-                    if allow_capturing_self == DontAllowCapturingSelf {\n-                def = d;\n-                is_ty_param = false;\n             }\n             _ {\n-                ret some(def_like);\n+                ret def_like;\n             }\n         }\n \n@@ -2732,43 +2657,19 @@ class Resolver {\n                     // Nothing to do. Continue.\n                 }\n                 FunctionRibKind(function_id) {\n-                    if !is_ty_param {\n-                        def = def_upvar(def_id_of_def(def).node,\n-                                        @def,\n-                                        function_id);\n-                    }\n-                }\n-                OpaqueFunctionRibKind {\n-                    if !is_ty_param {\n-                        // This was an attempt to access an upvar inside a\n-                        // named function item. This is not allowed, so we\n-                        // report an error.\n-\n-                        self.session.span_err(span,\n-                                              \"attempted dynamic environment-\\\n-                                               capture\");\n-                    } else {\n-                        // This was an attempt to use a type parameter outside\n-                        // its scope.\n-\n-                        self.session.span_err(span,\n-                                              \"attempt to use a type \\\n-                                               argument out of scope\");\n-                    }\n-\n-                    ret none;\n+                    def = def_upvar(def_id_of_def(def).node,\n+                                    @def,\n+                                    function_id);\n                 }\n             }\n \n             rib_index += 1u;\n         }\n \n-        ret some(dl_def(def));\n+        ret dl_def(def);\n     }\n \n-    fn search_ribs(ribs: @dvec<@Rib>, name: Atom, span: span,\n-                   allow_capturing_self: AllowCapturingSelfFlag)\n-                -> option<def_like> {\n+    fn search_ribs(ribs: @dvec<@Rib>, name: Atom) -> option<def_like> {\n \n         // XXX: This should not use a while loop.\n         // XXX: Try caching?\n@@ -2779,8 +2680,7 @@ class Resolver {\n             let rib = (*ribs).get_elt(i);\n             alt rib.bindings.find(name) {\n                 some(def_like) {\n-                    ret self.upvarify(ribs, i, def_like, span,\n-                                      allow_capturing_self);\n+                    ret some(self.upvarify(ribs, i, def_like));\n                 }\n                 none {\n                     // Continue.\n@@ -2833,8 +2733,7 @@ class Resolver {\n             item_enum(_, type_parameters, _) |\n             item_ty(_, type_parameters, _) {\n                 do self.with_type_parameter_rib\n-                        (HasTypeParameters(&type_parameters, item.id, 0u,\n-                                           NormalRibKind))\n+                        (HasTypeParameters(&type_parameters, item.id, 0u))\n                         || {\n \n                     visit_item(item, (), visitor);\n@@ -2861,8 +2760,7 @@ class Resolver {\n \n                 // Create a new rib for the interface-wide type parameters.\n                 do self.with_type_parameter_rib\n-                        (HasTypeParameters(&type_parameters, item.id, 0u,\n-                                           NormalRibKind))\n+                        (HasTypeParameters(&type_parameters, item.id, 0u))\n                         || {\n \n                     for methods.each |method| {\n@@ -2874,8 +2772,7 @@ class Resolver {\n                         do self.with_type_parameter_rib\n                                 (HasTypeParameters(&method.tps,\n                                                    item.id,\n-                                                   type_parameters.len(),\n-                                                   NormalRibKind))\n+                                                   type_parameters.len()))\n                                 || {\n \n                             // Resolve the method-specific type parameters.\n@@ -2922,9 +2819,7 @@ class Resolver {\n                                 do self.with_type_parameter_rib\n                                     (HasTypeParameters(&type_parameters,\n                                                        foreign_item.id,\n-                                                       0u,\n-                                                       OpaqueFunctionRibKind))\n-                                        || {\n+                                                       0u)) || {\n \n                                     visit_foreign_item(foreign_item, (),\n                                                        visitor);\n@@ -2949,13 +2844,11 @@ class Resolver {\n                     self.session.main_fn = some((item.id, item.span));\n                 }\n \n-                self.resolve_function(OpaqueFunctionRibKind,\n+                self.resolve_function(NormalRibKind,\n                                       some(@fn_decl),\n-                                      HasTypeParameters\n-                                        (&ty_params,\n-                                         item.id,\n-                                         0u,\n-                                         OpaqueFunctionRibKind),\n+                                      HasTypeParameters(&ty_params,\n+                                                        item.id,\n+                                                        0u),\n                                       block,\n                                       NoSelfBinding,\n                                       NoCaptureClause,\n@@ -2976,10 +2869,10 @@ class Resolver {\n \n     fn with_type_parameter_rib(type_parameters: TypeParameters, f: fn()) {\n         alt type_parameters {\n-            HasTypeParameters(type_parameters, node_id, initial_index,\n-                              rib_kind) {\n+            HasTypeParameters(type_parameters, node_id, initial_index)\n+                    if (*type_parameters).len() >= 1u {\n \n-                let function_type_rib = @Rib(rib_kind);\n+                let function_type_rib = @Rib(NormalRibKind);\n                 (*self.type_ribs).push(function_type_rib);\n \n                 for (*type_parameters).eachi |index, type_parameter| {\n@@ -2992,19 +2885,21 @@ class Resolver {\n                 }\n             }\n \n-            NoTypeParameters {\n+            HasTypeParameters(*) | NoTypeParameters {\n                 // Nothing to do.\n             }\n         }\n \n         f();\n \n         alt type_parameters {\n-            HasTypeParameters(type_parameters, _, _, _) {\n+            HasTypeParameters(type_parameters, _, _)\n+                    if (*type_parameters).len() >= 1u {\n+\n                 (*self.type_ribs).pop();\n             }\n \n-            NoTypeParameters {\n+            HasTypeParameters(*) | NoTypeParameters {\n                 // Nothing to do.\n             }\n         }\n@@ -3028,11 +2923,11 @@ class Resolver {\n                 for (*capture_clause).each |capture_item| {\n                     alt self.resolve_identifier(capture_item.name,\n                                                 ValueNS,\n-                                                true,\n-                                                capture_item.span) {\n+                                                true) {\n                         none {\n                             self.session.span_err(capture_item.span,\n-                                                  \"unresolved name in \\\n+                                                  \"use of undeclared \\\n+                                                   identifier in \\\n                                                    capture clause\");\n                         }\n                         some(def) {\n@@ -3054,7 +2949,7 @@ class Resolver {\n                 NoTypeParameters {\n                     // Continue.\n                 }\n-                HasTypeParameters(type_parameters, _, _, _) {\n+                HasTypeParameters(type_parameters, _, _) {\n                     self.resolve_type_parameters(*type_parameters, visitor);\n                 }\n             }\n@@ -3097,8 +2992,8 @@ class Resolver {\n                                               false, visitor) {\n                             none {\n                                 self.session.span_err(constraint.span,\n-                                    #fmt(\"unresolved name: %s\",\n-                                    *constraint.node.path.idents.last()));\n+                                                      \"use of undeclared \\\n+                                                       constraint\");\n                             }\n                             some(def) {\n                                 self.record_def(constraint.node.id, def);\n@@ -3149,8 +3044,7 @@ class Resolver {\n         let outer_type_parameter_count = (*type_parameters).len();\n         let borrowed_type_parameters: &~[ty_param] = &*type_parameters;\n         do self.with_type_parameter_rib(HasTypeParameters\n-                                        (borrowed_type_parameters, id, 0u,\n-                                         NormalRibKind))\n+                                        (borrowed_type_parameters, id, 0u))\n                 || {\n \n             // Resolve the type parameters.\n@@ -3161,8 +3055,8 @@ class Resolver {\n                 alt self.resolve_path(interface.path, TypeNS, true, visitor) {\n                     none {\n                         self.session.span_err(interface.path.span,\n-                                              \"attempt to implement a \\\n-                                               nonexistent interface\");\n+                                              \"attempt to implement an \\\n+                                               unknown interface\");\n                     }\n                     some(def) {\n                         // Write a mapping from the interface ID to the\n@@ -3189,8 +3083,7 @@ class Resolver {\n                         let type_parameters =\n                             HasTypeParameters(borrowed_method_type_parameters,\n                                               method.id,\n-                                              outer_type_parameter_count,\n-                                              NormalRibKind);\n+                                              outer_type_parameter_count);\n                         self.resolve_function(NormalRibKind,\n                                               some(@method.decl),\n                                               type_parameters,\n@@ -3246,8 +3139,7 @@ class Resolver {\n         let outer_type_parameter_count = type_parameters.len();\n         let borrowed_type_parameters: &~[ty_param] = &type_parameters;\n         do self.with_type_parameter_rib(HasTypeParameters\n-                                        (borrowed_type_parameters, id, 0u,\n-                                         NormalRibKind))\n+                                        (borrowed_type_parameters, id, 0u))\n                 || {\n \n             // Resolve the type parameters.\n@@ -3286,8 +3178,7 @@ class Resolver {\n                                       HasTypeParameters\n                                         (borrowed_type_parameters,\n                                          method.id,\n-                                         outer_type_parameter_count,\n-                                         NormalRibKind),\n+                                         outer_type_parameter_count),\n                                       method.body,\n                                       HasSelfBinding(method.self_id),\n                                       NoCaptureClause,\n@@ -3482,32 +3373,19 @@ class Resolver {\n                     // such a variant is simply disallowed (since it's rarely\n                     // what you want).\n \n+                    // XXX: This restriction is not yet implemented.\n+\n                     let atom = (*self.atom_table).intern(path.idents[0]);\n \n-                    alt self.resolve_enum_variant_or_const(atom) {\n-                        FoundEnumVariant(def) if mode == RefutableMode {\n+                    alt self.resolve_enum_variant(atom) {\n+                        some(def) {\n                             #debug(\"(resolving pattern) resolving '%s' to \\\n                                     enum variant\",\n                                    *path.idents[0]);\n \n                             self.record_def(pattern.id, def);\n                         }\n-                        FoundEnumVariant(_) {\n-                            self.session.span_err(pattern.span,\n-                                                  #fmt(\"declaration of `%s` \\\n-                                                        shadows an enum \\\n-                                                        that's in scope\",\n-                                                       *(*self.atom_table).\n-                                                            atom_to_str\n-                                                            (atom)));\n-                        }\n-                        FoundConst {\n-                            self.session.span_err(pattern.span,\n-                                                  \"pattern variable \\\n-                                                   conflicts with a constant \\\n-                                                   in scope\");\n-                        }\n-                        EnumVariantOrConstNotFound {\n+                        none {\n                             #debug(\"(resolving pattern) binding '%s'\",\n                                    *path.idents[0]);\n \n@@ -3579,7 +3457,7 @@ class Resolver {\n                         }\n                         none {\n                             self.session.span_err(path.span,\n-                                                  \"unresolved enum variant\");\n+                                                  \"undeclared enum variant\");\n                         }\n                     }\n \n@@ -3596,9 +3474,7 @@ class Resolver {\n         }\n     }\n \n-    fn resolve_enum_variant_or_const(name: Atom)\n-                                  -> EnumVariantOrConstResolution {\n-\n+    fn resolve_enum_variant(name: Atom) -> option<def> {\n         alt self.resolve_item_in_lexical_scope(self.current_module,\n                                                name,\n                                                ValueNS) {\n@@ -3610,13 +3486,10 @@ class Resolver {\n                               of name bindings with no def?!\";\n                     }\n                     some(def @ def_variant(*)) {\n-                        ret FoundEnumVariant(def);\n-                    }\n-                    some(def_const(*)) {\n-                        ret FoundConst;\n+                        ret some(def);\n                     }\n                     some(_) {\n-                        ret EnumVariantOrConstNotFound;\n+                        ret none;\n                     }\n                 }\n             }\n@@ -3626,7 +3499,7 @@ class Resolver {\n             }\n \n             Failed {\n-                ret EnumVariantOrConstNotFound;\n+                ret none;\n             }\n         }\n     }\n@@ -3658,20 +3531,16 @@ class Resolver {\n \n         ret self.resolve_identifier(path.idents.last(),\n                                     namespace,\n-                                    check_ribs,\n-                                    path.span);\n+                                    check_ribs);\n     }\n \n     fn resolve_identifier(identifier: ident,\n                           namespace: Namespace,\n-                          check_ribs: bool,\n-                          span: span)\n+                          check_ribs: bool)\n                        -> option<def> {\n \n         if check_ribs {\n-            alt self.resolve_identifier_in_local_ribs(identifier,\n-                                                      namespace,\n-                                                      span) {\n+            alt self.resolve_identifier_in_local_ribs(identifier, namespace) {\n                 some(def) {\n                     ret some(def);\n                 }\n@@ -3688,17 +3557,9 @@ class Resolver {\n     // XXX: Merge me with resolve_name_in_module?\n     fn resolve_definition_of_name_in_module(containing_module: @Module,\n                                             name: Atom,\n-                                            namespace: Namespace,\n-                                            xray: XrayFlag)\n+                                            namespace: Namespace)\n                                          -> NameDefinition {\n \n-        if xray == NoXray && !self.name_is_exported(containing_module, name) {\n-            #debug(\"(resolving definition of name in module) name '%s' is \\\n-                    unexported\",\n-                   *(*self.atom_table).atom_to_str(name));\n-            ret NoNameDefinition;\n-        }\n-\n         // First, search children.\n         alt containing_module.children.find(name) {\n             some(child_name_bindings) {\n@@ -3725,7 +3586,6 @@ class Resolver {\n                         alt (*target.bindings).def_for_namespace(namespace) {\n                             some(def) {\n                                 // Found it.\n-                                import_resolution.used = true;\n                                 ret ImportNameDefinition(def);\n                             }\n                             none {\n@@ -3769,8 +3629,7 @@ class Resolver {\n         let mut containing_module;\n         alt self.resolve_module_path_for_import(self.current_module,\n                                                 module_path_atoms,\n-                                                xray,\n-                                                path.span) {\n+                                                xray) {\n \n             Failed {\n                 self.session.span_err(path.span,\n@@ -3792,8 +3651,7 @@ class Resolver {\n         let name = (*self.atom_table).intern(path.idents.last());\n         alt self.resolve_definition_of_name_in_module(containing_module,\n                                                       name,\n-                                                      namespace,\n-                                                      xray) {\n+                                                      namespace) {\n             NoNameDefinition {\n                 // We failed to resolve the name. Report an error.\n                 self.session.span_err(path.span,\n@@ -3823,8 +3681,7 @@ class Resolver {\n         alt self.resolve_module_path_from_root(root_module,\n                                                module_path_atoms,\n                                                0u,\n-                                               xray,\n-                                               path.span) {\n+                                               xray) {\n \n             Failed {\n                 self.session.span_err(path.span,\n@@ -3846,8 +3703,7 @@ class Resolver {\n         let name = (*self.atom_table).intern(path.idents.last());\n         alt self.resolve_definition_of_name_in_module(containing_module,\n                                                       name,\n-                                                      namespace,\n-                                                      xray) {\n+                                                      namespace) {\n             NoNameDefinition {\n                 // We failed to resolve the name. Report an error.\n                 self.session.span_err(path.span,\n@@ -3865,8 +3721,7 @@ class Resolver {\n     }\n \n     fn resolve_identifier_in_local_ribs(identifier: ident,\n-                                        namespace: Namespace,\n-                                        span: span)\n+                                        namespace: Namespace)\n                                      -> option<def> {\n \n         let name = (*self.atom_table).intern(identifier);\n@@ -3875,12 +3730,10 @@ class Resolver {\n         let mut search_result;\n         alt namespace {\n             ValueNS {\n-                search_result = self.search_ribs(self.value_ribs, name, span,\n-                                                 DontAllowCapturingSelf);\n+                search_result = self.search_ribs(self.value_ribs, name);\n             }\n             TypeNS {\n-                search_result = self.search_ribs(self.type_ribs, name, span,\n-                                                 AllowCapturingSelf);\n+                search_result = self.search_ribs(self.type_ribs, name);\n             }\n             ModuleNS | ImplNS {\n                 fail \"module or impl namespaces do not have local ribs\";\n@@ -4007,83 +3860,6 @@ class Resolver {\n         self.def_map.insert(node_id, def);\n     }\n \n-    //\n-    // Unused import checking\n-    //\n-    // Although this is a lint pass, it lives in here because it depends on\n-    // resolve data structures.\n-    //\n-\n-    fn check_for_unused_imports_if_necessary() {\n-        if self.unused_import_lint_level == ignore {\n-            ret;\n-        }\n-\n-        let root_module = (*self.graph_root).get_module();\n-        self.check_for_unused_imports_in_module_subtree(root_module);\n-    }\n-\n-    fn check_for_unused_imports_in_module_subtree(module: @Module) {\n-        // If this isn't a local crate, then bail out. We don't need to check\n-        // for unused imports in external crates.\n-\n-        alt module.def_id {\n-            some(def_id) if def_id.crate == local_crate {\n-                // OK. Continue.\n-            }\n-            none {\n-                // Check for unused imports in the root module.\n-            }\n-            some(_) {\n-                // Bail out.\n-                #debug(\"(checking for unused imports in module subtree) not \\\n-                        checking for unused imports for '%s'\",\n-                       self.module_to_str(module));\n-                ret;\n-            }\n-        }\n-\n-        self.check_for_unused_imports_in_module(module);\n-\n-        for module.children.each |_atom, child_name_bindings| {\n-            alt (*child_name_bindings).get_module_if_available() {\n-                none {\n-                    // Nothing to do.\n-                }\n-                some(child_module) {\n-                    self.check_for_unused_imports_in_module_subtree\n-                        (child_module);\n-                }\n-            }\n-        }\n-\n-        for module.anonymous_children.each |_node_id, child_module| {\n-            self.check_for_unused_imports_in_module_subtree(child_module);\n-        }\n-    }\n-\n-    fn check_for_unused_imports_in_module(module: @Module) {\n-        for module.import_resolutions.each |_impl_name, import_resolution| {\n-            if !import_resolution.used {\n-                alt self.unused_import_lint_level {\n-                    warn {\n-                        self.session.span_warn(import_resolution.span,\n-                                               \"unused import\");\n-                    }\n-                    error {\n-                        self.session.span_err(import_resolution.span,\n-                                              \"unused import\");\n-                    }\n-                    ignore {\n-                        self.session.span_bug(import_resolution.span,\n-                                              \"shouldn't be here if lint \\\n-                                               pass is ignored\");\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     //\n     // Diagnostics\n     //"}, {"sha": "fba8d54cfba01736810f4ce3c398d25690838ec5", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -166,13 +166,6 @@ export ty_sort_str;\n export normalize_ty;\n export to_str;\n export borrow, serialize_borrow, deserialize_borrow;\n-export bound_const;\n-export terr_no_integral_type, terr_ty_param_size, terr_self_substs;\n-export terr_in_field, terr_record_fields, terr_vstores_differ, terr_arg_count;\n-export terr_sorts, terr_vec, terr_str, terr_record_size, terr_tuple_size;\n-export terr_regions_differ, terr_mutability, terr_purity_mismatch;\n-export terr_constr_mismatch, terr_constr_len, terr_proto_mismatch;\n-export terr_ret_style_mismatch;\n \n // Data types\n "}, {"sha": "aaad7841d4c0c79027035f102c00eef55c74b9c0", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -75,8 +75,6 @@ export deserialize_method_map_entry;\n export vtable_map;\n export vtable_res;\n export vtable_origin;\n-export method_static, method_param, method_trait;\n-export vtable_static, vtable_param, vtable_trait;\n \n #[auto_serialize]\n enum method_origin {"}, {"sha": "94d232778679b51352847df1e164eb2075fda978", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -7,8 +7,6 @@ export config;\n export default_config;\n export parse_config;\n export usage;\n-export markdown, pandoc_html;\n-export doc_per_crate, doc_per_mod;\n \n /// The type of document to output\n enum output_format {"}, {"sha": "7cb79ff789e12be8239acb8f3936762cff2c9510", "filename": "src/test/compile-fail/ambig_impl_2_exe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fambig_impl_2_exe.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -2,6 +2,6 @@\n // aux-build:ambig_impl_2_lib.rs\n use ambig_impl_2_lib;\n import ambig_impl_2_lib::methods1;\n-impl methods2 for uint { fn me() -> uint { self } } //~ NOTE is `methods2::me`\n+impl methods2 for uint { fn me() -> uint { self } } //~ NOTE candidate #2 is `methods2::me`\n fn main() { 1u.me(); } //~ ERROR multiple applicable methods in scope\n-//~^ NOTE is `ambig_impl_2_lib::methods1::me`\n+//~^ NOTE candidate #1 is `ambig_impl_2_lib::methods1::me`"}, {"sha": "09018c2167f9acca614a71c3bb9bff756b142f18", "filename": "src/test/compile-fail/bad-tag-export-2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-2.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -0,0 +1,11 @@\n+// error-pattern:b does not refer to an enumeration\n+import bad::*;\n+\n+mod bad {\n+  export b::{};\n+\n+  fn b() { fail; }\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "e6934688e21b90e1290ac52fe9374decfedb1af1", "filename": "src/test/compile-fail/bad-tag-export-3.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-3.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -0,0 +1,13 @@\n+// error-pattern:b does not refer to an enumeration\n+import bad::*;\n+\n+mod bad {\n+  export b::{f, z};\n+\n+  fn b() { fail; }\n+  fn f() { fail; }\n+  fn z() { fail; }\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "fadf0c353a36a5e0da0491aa78a904175e915374", "filename": "src/test/compile-fail/bad-tag-export-4.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-tag-export-4.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -0,0 +1,12 @@\n+// error-pattern:f is not a variant\n+import bad::*;\n+\n+mod bad {\n+  export b::{f, z};\n+\n+  enum b { z, k }\n+  fn f() { fail; }\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "fb9d9b8682c6c5283a9125532593057ba7d3deea", "filename": "src/test/compile-fail/bad-tag-export.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fbad-tag-export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fbad-tag-export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-tag-export.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -0,0 +1,14 @@\n+// error-pattern:variant e doesn't belong to enum floop\n+import bad::*;\n+\n+mod bad {\n+\n+  export floop::{a, e};\n+\n+  enum floop {a, b, c}\n+  enum bloop {d, e, f}\n+\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "97655cb3bd760ed19fd09a84b44f3fc285db84df", "filename": "src/test/compile-fail/cap-clause-unresolved-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-copy.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:unresolved name\n+// error-pattern:unresolved name: z\n fn main() {\n     let x = 5;\n     let y = fn~(copy z, copy x) {"}, {"sha": "292b0f430541ad86a112a3817b7b3c86fd7586b7", "filename": "src/test/compile-fail/cap-clause-unresolved-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcap-clause-unresolved-move.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:unresolved name\n+// error-pattern:unresolved name: z\n fn main() {\n     let x = 5;\n     let y = fn~(move z, move x) {"}, {"sha": "4e95b986a9ab8421cd8499bbf6c67832d2998233", "filename": "src/test/compile-fail/class-implements-bad-iface.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fclass-implements-bad-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fclass-implements-bad-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-implements-bad-iface.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -1,9 +1,9 @@\n-// error-pattern:nonexistent\n+// error-pattern:unresolved typename: nonexistent\n class cat : nonexistent {\n   let meows: uint;\n   new(in_x : uint) { self.meows = in_x; }\n }\n \n fn main() {\n   let nyan = cat(0u);\n-}\n+}\n\\ No newline at end of file"}, {"sha": "469fee7863b97a2bea535b1f715908cc20a1d0d8", "filename": "src/test/compile-fail/class-implements-int.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-implements-int.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -1,8 +1,8 @@\n-class cat : int { //~ ERROR interface\n+class cat : int { //~ ERROR can only implement interface types\n   let meows: uint;\n   new(in_x : uint) { self.meows = in_x; }\n }\n \n fn main() {\n   let nyan = cat(0u);\n-}\n+}\n\\ No newline at end of file"}, {"sha": "c9694739b493cdbfeb47cd7dde5503a4c9f9fcd0", "filename": "src/test/compile-fail/cross-crate-glob-collision.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -0,0 +1,13 @@\n+// error-pattern: is glob-imported from multiple different modules\n+// issue #482\n+\n+use std;\n+// expecting swap to be defined in vec\n+import vec::*;\n+import alternate_supplier::*;\n+\n+mod alternate_supplier {\n+    fn contains() { }\n+}\n+\n+fn main() { contains() }"}, {"sha": "f5ed4c4f3a78818330701ceb941ba036003a1341", "filename": "src/test/compile-fail/export-import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fexport-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fexport-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport-import.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: import\n+// error-pattern: unresolved import\n \n import m::unexported;\n "}, {"sha": "1d45832d6df1c44a42ba6a5bb60e9fa7db1ed186", "filename": "src/test/compile-fail/iface-test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fiface-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fiface-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fiface-test.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -1,9 +1,9 @@\n iface foo { fn foo(); }\n \n-impl of foo for uint {}\n+impl of foo for uint {} //~ ERROR missing method `foo`\n \n-impl of foo for uint { fn foo() -> int {} }\n+impl of foo for uint { fn foo() -> int {} } //~ ERROR incompatible type\n \n-impl of int for uint { fn foo() {} } //~ ERROR interface\n+impl of int for uint { fn foo() {} } //~ ERROR can only implement interface\n \n fn main() {}"}, {"sha": "73e14bfc753f65c500307f16a909347c70ac7360", "filename": "src/test/compile-fail/import-from-dup.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport-from-dup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport-from-dup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-from-dup.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -0,0 +1,14 @@\n+// error-pattern:duplicate definition of f\n+\n+import m1::{f};\n+import m2::{f};\n+\n+mod m1 {\n+    fn f() { }\n+}\n+\n+mod m2 {\n+    fn f() { }\n+}\n+\n+fn main() { }"}, {"sha": "87434a6c5f362e294dedce6cb98bfc2668efe36e", "filename": "src/test/compile-fail/import-from-missing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport-from-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport-from-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-from-missing.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:unresolved\n+// error-pattern:unresolved import\n import spam::{ham, eggs};\n \n mod spam {"}, {"sha": "588b0d5848ee559d92108c14c939e4cf6f3932d4", "filename": "src/test/compile-fail/import-glob-circular.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -1,5 +1,5 @@\n-// error-pattern: unresolved\n \n+// error-pattern: unresolved name\n mod circ1 {\n     import circ1::*;\n     export f1;"}, {"sha": "83672579130fe6bd3b349e7ba541aa31e21f99c6", "filename": "src/test/compile-fail/import-glob-multiple.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport-glob-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport-glob-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-multiple.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -0,0 +1,20 @@\n+// error-pattern:common2\n+\n+import mod1::*;\n+import mod2::*;\n+\n+mod mod1 {\n+    fn f1() { #debug(\"f1\"); }\n+    fn common1() { #debug(\"common\") }\n+    fn common2() { #debug(\"common\") }\n+}\n+\n+mod mod2 {\n+    fn f2() { #debug(\"f1\"); }\n+    fn common1() { #debug(\"common\") }\n+    fn common2() { #debug(\"common\") }\n+}\n+\n+\n+\n+fn main() { common2(); }"}, {"sha": "4040f8333f98e14eb694e8057e921cc1378dd03e", "filename": "src/test/compile-fail/import-loop-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport-loop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport-loop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-loop-2.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:import\n+// error-pattern:cyclic import\n \n mod a {\n     import b::x;"}, {"sha": "6aa88db603d7ef1cb04008859d4d139571bde30d", "filename": "src/test/compile-fail/import-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-loop.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:import\n+// error-pattern: cyclic import\n \n import y::x;\n "}, {"sha": "eb47db0725afd334e89457ae533ba85344f249b8", "filename": "src/test/compile-fail/import.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -1,5 +1,4 @@\n-// xfail-test\n-// error-pattern: unresolved\n+// error-pattern: unresolved import\n import zed::bar;\n import zed::baz;\n mod zed {"}, {"sha": "6d503a62a4722108f4a2639f68fefa40d8a4d6e5", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: unresolved\n+// error-pattern: unresolved modulename\n import baz::zed::bar;\n mod baz { }\n mod zed {"}, {"sha": "939c38fed6a4a1328dc6bde557b01fc1505c8327", "filename": "src/test/compile-fail/import3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport3.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: unresolved\n+// error-pattern: unresolved modulename\n import main::bar;\n \n fn main(args: ~[str]) { #debug(\"foo\"); }"}, {"sha": "d4688a4fafdb6ea4ca1e6681f5cfebc68dc09c46", "filename": "src/test/compile-fail/import4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport4.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: import\n+// error-pattern: cyclic import\n \n mod a { import foo = b::foo; export foo; }\n mod b { import foo = a::foo; export foo; }"}, {"sha": "85a77411e682862926ae99fa788c82b020740d6b", "filename": "src/test/compile-fail/import5.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fimport5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport5.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -0,0 +1,15 @@\n+// error-pattern:unresolved import\n+\n+mod m1 {\n+    fn foo() { #debug(\"foo\"); }\n+}\n+\n+mod m2 {\n+    import m1::foo;\n+}\n+\n+mod m3 {\n+    import m2::foo;\n+}\n+\n+fn main() { }"}, {"sha": "63b316813ff98aa055304d243053441d43a3451d", "filename": "src/test/compile-fail/issue-1697.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1697.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -1,8 +1,7 @@\n-// xfail-test\n // Testing that we don't fail abnormally after hitting the errors\n \n import unresolved::*; //~ ERROR unresolved modulename\n //~^ ERROR unresolved does not name a module\n \n fn main() {\n-}\n+}\n\\ No newline at end of file"}, {"sha": "0766a8d1feed44b16fe461fb8a30e9c4b40ec225", "filename": "src/test/compile-fail/not-a-pred.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -1,5 +1,5 @@\n // -*- rust -*-\n-// error-pattern: lt\n+// error-pattern: lt is not declared pure\n \n fn f(a: int, b: int) : lt(a, b) { }\n "}, {"sha": "9472783848846e7e20b9d642e098143d4f9a7c71", "filename": "src/test/compile-fail/tag-exports-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Ftag-exports-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Ftag-exports-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-exports-2.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -0,0 +1,18 @@\n+// error-pattern:unresolved name: lovejoy\n+import alder::*;\n+\n+mod alder {\n+  export burnside;\n+  export everett::{flanders};\n+  export irving::{johnson, kearney};\n+  export marshall::{};\n+\n+  enum burnside { couch, davis }\n+  enum everett { flanders, glisan, hoyt }\n+  enum irving { johnson, kearney, lovejoy }\n+  enum marshall { northrup, overton }\n+}\n+\n+fn main() {\n+  let raleigh: irving = lovejoy;\n+}"}, {"sha": "e51a0aca115c85876057bc2232987161fca608d8", "filename": "src/test/compile-fail/tag-exports-3.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Ftag-exports-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Ftag-exports-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-exports-3.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -0,0 +1,18 @@\n+// error-pattern:unresolved name: northrup\n+import alder::*;\n+\n+mod alder {\n+  export burnside;\n+  export everett::{flanders};\n+  export irving::{johnson, kearney};\n+  export marshall::{};\n+\n+  enum burnside { couch, davis }\n+  enum everett { flanders, glisan, hoyt }\n+  enum irving { johnson, kearney, lovejoy }\n+  enum marshall { northrup, overton }\n+}\n+\n+fn main() {\n+  let savier: marshall = northrup;\n+}"}, {"sha": "18965c91842042ade0957288ca376606bcacf218", "filename": "src/test/compile-fail/tag-exports.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Ftag-exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Fcompile-fail%2Ftag-exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-exports.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -0,0 +1,18 @@\n+// error-pattern:unresolved name: glisan\n+import alder::*;\n+\n+mod alder {\n+  export burnside;\n+  export everett::{flanders};\n+  export irving::{johnson, kearney};\n+  export marshall::{};\n+\n+  enum burnside { couch, davis }\n+  enum everett { flanders, glisan, hoyt }\n+  enum irving { johnson, kearney, lovejoy }\n+  enum marshall { northrup, overton }\n+}\n+\n+fn main() {\n+  let quimby: everett = glisan;\n+}"}, {"sha": "34e51843070d567bbc465703bd0c8085110649a6", "filename": "src/test/run-pass/issue2170exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Frun-pass%2Fissue2170exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Frun-pass%2Fissue2170exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue2170exe.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -3,5 +3,5 @@\n use issue2170lib;\n \n fn main() {\n-   // let _ = issue2170lib::rsrc(2i32);\n+    let _ = issue2170lib::rsrc(2i32);\n }"}, {"sha": "6e5d07299c6d22b9cfe44003e383f9abdfac2862", "filename": "src/test/run-pass/tag-exports.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Frun-pass%2Ftag-exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a856bccdc647330624fa36a25190aa63e1274379/src%2Ftest%2Frun-pass%2Ftag-exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-exports.rs?ref=a856bccdc647330624fa36a25190aa63e1274379", "patch": "@@ -2,7 +2,6 @@ import alder::*;\n \n mod alder {\n   export burnside;\n-  export couch;\n   export everett;\n   export flanders;\n   export irving;"}]}