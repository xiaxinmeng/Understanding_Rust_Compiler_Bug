{"sha": "ecbdfb49882fa6db7e45d9fd676f54a6454d79fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYmRmYjQ5ODgyZmE2ZGI3ZTQ1ZDlmZDY3NmY1NGE2NDU0ZDc5ZmU=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-25T14:48:42Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-27T20:46:13Z"}, "message": "Convert EntryKind to a struct, Entry", "tree": {"sha": "70a612236d0d9e9a2f974b55cb0a0e57209d8f90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70a612236d0d9e9a2f974b55cb0a0e57209d8f90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecbdfb49882fa6db7e45d9fd676f54a6454d79fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecbdfb49882fa6db7e45d9fd676f54a6454d79fe", "html_url": "https://github.com/rust-lang/rust/commit/ecbdfb49882fa6db7e45d9fd676f54a6454d79fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecbdfb49882fa6db7e45d9fd676f54a6454d79fe/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11665ca45a4eb7745026040e840aef3207d5c7ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/11665ca45a4eb7745026040e840aef3207d5c7ce", "html_url": "https://github.com/rust-lang/rust/commit/11665ca45a4eb7745026040e840aef3207d5c7ce"}], "stats": {"total": 361, "additions": 118, "deletions": 243}, "files": [{"sha": "e0075039da9b917ffaaae35834cd8fc30f1b349c", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 19, "deletions": 36, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ecbdfb49882fa6db7e45d9fd676f54a6454d79fe/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecbdfb49882fa6db7e45d9fd676f54a6454d79fe/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=ecbdfb49882fa6db7e45d9fd676f54a6454d79fe", "patch": "@@ -29,7 +29,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     /// The crate\n     krate: &'hir Crate,\n     /// The node map\n-    map: Vec<EntryKind<'hir>>,\n+    map: Vec<Option<Entry<'hir>>>,\n     /// The parent of this node\n     parent_node: NodeId,\n \n@@ -114,7 +114,11 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             hcx,\n             hir_body_nodes,\n         };\n-        collector.insert_entry(CRATE_NODE_ID, EntryKind::RootCrate(root_mod_sig_dep_index));\n+        collector.insert_entry(CRATE_NODE_ID, Entry {\n+            parent: ast::DUMMY_NODE_ID,\n+            dep_node: root_mod_sig_dep_index,\n+            node: NodeKind::Crate,\n+        });\n \n         collector\n     }\n@@ -124,9 +128,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                                                   cstore: &dyn CrateStore,\n                                                   source_map: &SourceMap,\n                                                   commandline_args_hash: u64)\n-                                                  -> (Vec<EntryKind<'hir>>, Svh) {\n-        self\n-            .hir_body_nodes\n+                                                  -> (Vec<Option<Entry<'hir>>>, Svh) {\n+        self.hir_body_nodes\n             .sort_unstable_by(|&(ref d1, _), &(ref d2, _)| d1.cmp(d2));\n \n         let node_hashes = self\n@@ -178,44 +181,24 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         (self.map, svh)\n     }\n \n-    fn insert_entry(&mut self, id: NodeId, entry: EntryKind<'hir>) {\n+    fn insert_entry(&mut self, id: NodeId, entry: Entry<'hir>) {\n         debug!(\"hir_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n         if id.as_usize() >= len {\n-            self.map.extend(repeat(EntryKind::NotPresent).take(id.as_usize() - len + 1));\n+            self.map.extend(repeat(None).take(id.as_usize() - len + 1));\n         }\n-        self.map[id.as_usize()] = entry;\n+        self.map[id.as_usize()] = Some(entry);\n     }\n \n     fn insert(&mut self, id: NodeId, node: NodeKind<'hir>) {\n-        let parent = self.parent_node;\n-        let dep_node_index = if self.currently_in_body {\n-            self.current_full_dep_index\n-        } else {\n-            self.current_signature_dep_index\n-        };\n-\n-        let entry = match node {\n-            NodeKind::Item(n) => EntryKind::Item(parent, dep_node_index, n),\n-            NodeKind::ForeignItem(n) => EntryKind::ForeignItem(parent, dep_node_index, n),\n-            NodeKind::TraitItem(n) => EntryKind::TraitItem(parent, dep_node_index, n),\n-            NodeKind::ImplItem(n) => EntryKind::ImplItem(parent, dep_node_index, n),\n-            NodeKind::Variant(n) => EntryKind::Variant(parent, dep_node_index, n),\n-            NodeKind::Field(n) => EntryKind::Field(parent, dep_node_index, n),\n-            NodeKind::AnonConst(n) => EntryKind::AnonConst(parent, dep_node_index, n),\n-            NodeKind::Expr(n) => EntryKind::Expr(parent, dep_node_index, n),\n-            NodeKind::Stmt(n) => EntryKind::Stmt(parent, dep_node_index, n),\n-            NodeKind::Ty(n) => EntryKind::Ty(parent, dep_node_index, n),\n-            NodeKind::TraitRef(n) => EntryKind::TraitRef(parent, dep_node_index, n),\n-            NodeKind::Binding(n) => EntryKind::Binding(parent, dep_node_index, n),\n-            NodeKind::Pat(n) => EntryKind::Pat(parent, dep_node_index, n),\n-            NodeKind::Block(n) => EntryKind::Block(parent, dep_node_index, n),\n-            NodeKind::StructCtor(n) => EntryKind::StructCtor(parent, dep_node_index, n),\n-            NodeKind::Lifetime(n) => EntryKind::Lifetime(parent, dep_node_index, n),\n-            NodeKind::GenericParam(n) => EntryKind::GenericParam(parent, dep_node_index, n),\n-            NodeKind::Visibility(n) => EntryKind::Visibility(parent, dep_node_index, n),\n-            NodeKind::Local(n) => EntryKind::Local(parent, dep_node_index, n),\n-            NodeKind::MacroDef(n) => EntryKind::MacroDef(dep_node_index, n),\n+        let entry = Entry {\n+            parent: self.parent_node,\n+            dep_node: if self.currently_in_body {\n+                self.current_full_dep_index\n+            } else {\n+                self.current_signature_dep_index\n+            },\n+            node,\n         };\n \n         // Make sure that the DepNode of some node coincides with the HirId"}, {"sha": "742626250fc823832f6648e1b032d98ae33c0ba2", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 99, "deletions": 207, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/ecbdfb49882fa6db7e45d9fd676f54a6454d79fe/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecbdfb49882fa6db7e45d9fd676f54a6454d79fe/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=ecbdfb49882fa6db7e45d9fd676f54a6454d79fe", "patch": "@@ -69,142 +69,72 @@ pub enum NodeKind<'hir> {\n     Lifetime(&'hir Lifetime),\n     GenericParam(&'hir GenericParam),\n     Visibility(&'hir Visibility),\n-}\n \n-/// Represents an entry and its parent NodeID.\n-/// The odd layout is to bring down the total size.\n-#[derive(Copy, Debug)]\n-pub enum EntryKind<'hir> {\n-    /// Placeholder for holes in the map.\n-    NotPresent,\n-\n-    /// All the node types, with a parent ID.\n-    Item(NodeId, DepNodeIndex, &'hir Item),\n-    ForeignItem(NodeId, DepNodeIndex, &'hir ForeignItem),\n-    TraitItem(NodeId, DepNodeIndex, &'hir TraitItem),\n-    ImplItem(NodeId, DepNodeIndex, &'hir ImplItem),\n-    Variant(NodeId, DepNodeIndex, &'hir Variant),\n-    Field(NodeId, DepNodeIndex, &'hir StructField),\n-    AnonConst(NodeId, DepNodeIndex, &'hir AnonConst),\n-    Expr(NodeId, DepNodeIndex, &'hir Expr),\n-    Stmt(NodeId, DepNodeIndex, &'hir Stmt),\n-    Ty(NodeId, DepNodeIndex, &'hir Ty),\n-    TraitRef(NodeId, DepNodeIndex, &'hir TraitRef),\n-    Binding(NodeId, DepNodeIndex, &'hir Pat),\n-    Pat(NodeId, DepNodeIndex, &'hir Pat),\n-    Block(NodeId, DepNodeIndex, &'hir Block),\n-    StructCtor(NodeId, DepNodeIndex, &'hir VariantData),\n-    Lifetime(NodeId, DepNodeIndex, &'hir Lifetime),\n-    GenericParam(NodeId, DepNodeIndex, &'hir GenericParam),\n-    Visibility(NodeId, DepNodeIndex, &'hir Visibility),\n-    Local(NodeId, DepNodeIndex, &'hir Local),\n-    MacroDef(DepNodeIndex, &'hir MacroDef),\n-\n-    /// Roots for node trees. The DepNodeIndex is the dependency node of the\n-    /// crate's root module.\n-    RootCrate(DepNodeIndex),\n+    /// Roots for node trees. Its DepNodeIndex when in `Entry`\n+    /// is the dependency node of the crate's root module.\n+    Crate,\n }\n \n-impl<'hir> Clone for EntryKind<'hir> {\n-    fn clone(&self) -> EntryKind<'hir> {\n-        *self\n-    }\n+/// Represents an entry and its parent NodeId.\n+#[derive(Copy, Clone, Debug)]\n+pub struct Entry<'hir> {\n+    parent: NodeId,\n+    dep_node: DepNodeIndex,\n+    node: NodeKind<'hir>,\n }\n \n-impl<'hir> EntryKind<'hir> {\n+impl<'hir> Entry<'hir> {\n     fn parent_node(self) -> Option<NodeId> {\n-        Some(match self {\n-            EntryKind::Item(id, _, _) => id,\n-            EntryKind::ForeignItem(id, _, _) => id,\n-            EntryKind::TraitItem(id, _, _) => id,\n-            EntryKind::ImplItem(id, _, _) => id,\n-            EntryKind::Variant(id, _, _) => id,\n-            EntryKind::Field(id, _, _) => id,\n-            EntryKind::AnonConst(id, _, _) => id,\n-            EntryKind::Expr(id, _, _) => id,\n-            EntryKind::Stmt(id, _, _) => id,\n-            EntryKind::Ty(id, _, _) => id,\n-            EntryKind::TraitRef(id, _, _) => id,\n-            EntryKind::Binding(id, _, _) => id,\n-            EntryKind::Pat(id, _, _) => id,\n-            EntryKind::Block(id, _, _) => id,\n-            EntryKind::StructCtor(id, _, _) => id,\n-            EntryKind::Lifetime(id, _, _) => id,\n-            EntryKind::GenericParam(id, _, _) => id,\n-            EntryKind::Visibility(id, _, _) => id,\n-            EntryKind::Local(id, _, _) => id,\n-\n-            EntryKind::NotPresent |\n-            EntryKind::MacroDef(..) |\n-            EntryKind::RootCrate(_) => return None,\n-        })\n+        match self.node {\n+            NodeKind::Crate | NodeKind::MacroDef(_) => None,\n+            _ => Some(self.parent),\n+        }\n     }\n \n     fn to_node(self) -> Option<NodeKind<'hir>> {\n-        Some(match self {\n-            EntryKind::Item(_, _, n) => NodeKind::Item(n),\n-            EntryKind::ForeignItem(_, _, n) => NodeKind::ForeignItem(n),\n-            EntryKind::TraitItem(_, _, n) => NodeKind::TraitItem(n),\n-            EntryKind::ImplItem(_, _, n) => NodeKind::ImplItem(n),\n-            EntryKind::Variant(_, _, n) => NodeKind::Variant(n),\n-            EntryKind::Field(_, _, n) => NodeKind::Field(n),\n-            EntryKind::AnonConst(_, _, n) => NodeKind::AnonConst(n),\n-            EntryKind::Expr(_, _, n) => NodeKind::Expr(n),\n-            EntryKind::Stmt(_, _, n) => NodeKind::Stmt(n),\n-            EntryKind::Ty(_, _, n) => NodeKind::Ty(n),\n-            EntryKind::TraitRef(_, _, n) => NodeKind::TraitRef(n),\n-            EntryKind::Binding(_, _, n) => NodeKind::Binding(n),\n-            EntryKind::Pat(_, _, n) => NodeKind::Pat(n),\n-            EntryKind::Block(_, _, n) => NodeKind::Block(n),\n-            EntryKind::StructCtor(_, _, n) => NodeKind::StructCtor(n),\n-            EntryKind::Lifetime(_, _, n) => NodeKind::Lifetime(n),\n-            EntryKind::GenericParam(_, _, n) => NodeKind::GenericParam(n),\n-            EntryKind::Visibility(_, _, n) => NodeKind::Visibility(n),\n-            EntryKind::Local(_, _, n) => NodeKind::Local(n),\n-            EntryKind::MacroDef(_, n) => NodeKind::MacroDef(n),\n-\n-            EntryKind::NotPresent |\n-            EntryKind::RootCrate(_) => return None\n-        })\n+        match self.node {\n+            NodeKind::Crate => None,\n+            _ => Some(self.node),\n+        }\n     }\n \n     fn fn_decl(&self) -> Option<&FnDecl> {\n-        match self {\n-            EntryKind::Item(_, _, ref item) => {\n+        match self.node {\n+            NodeKind::Item(ref item) => {\n                 match item.node {\n                     ItemKind::Fn(ref fn_decl, _, _, _) => Some(&fn_decl),\n                     _ => None,\n                 }\n             }\n \n-            EntryKind::TraitItem(_, _, ref item) => {\n+            NodeKind::TraitItem(ref item) => {\n                 match item.node {\n                     TraitItemKind::Method(ref method_sig, _) => Some(&method_sig.decl),\n                     _ => None\n                 }\n             }\n \n-            EntryKind::ImplItem(_, _, ref item) => {\n+            NodeKind::ImplItem(ref item) => {\n                 match item.node {\n                     ImplItemKind::Method(ref method_sig, _) => Some(&method_sig.decl),\n                     _ => None,\n                 }\n             }\n \n-            EntryKind::Expr(_, _, ref expr) => {\n+            NodeKind::Expr(ref expr) => {\n                 match expr.node {\n                     ExprKind::Closure(_, ref fn_decl, ..) => Some(&fn_decl),\n                     _ => None,\n                 }\n             }\n \n-            _ => None\n+            _ => None,\n         }\n     }\n \n     fn associated_body(self) -> Option<BodyId> {\n-        match self {\n-            EntryKind::Item(_, _, item) => {\n+        match self.node {\n+            NodeKind::Item(item) => {\n                 match item.node {\n                     ItemKind::Const(_, body) |\n                     ItemKind::Static(.., body) |\n@@ -213,25 +143,25 @@ impl<'hir> EntryKind<'hir> {\n                 }\n             }\n \n-            EntryKind::TraitItem(_, _, item) => {\n+            NodeKind::TraitItem(item) => {\n                 match item.node {\n                     TraitItemKind::Const(_, Some(body)) |\n                     TraitItemKind::Method(_, TraitMethod::Provided(body)) => Some(body),\n                     _ => None\n                 }\n             }\n \n-            EntryKind::ImplItem(_, _, item) => {\n+            NodeKind::ImplItem(item) => {\n                 match item.node {\n                     ImplItemKind::Const(_, body) |\n                     ImplItemKind::Method(_, body) => Some(body),\n                     _ => None,\n                 }\n             }\n \n-            EntryKind::AnonConst(_, _, constant) => Some(constant.body),\n+            NodeKind::AnonConst(constant) => Some(constant.body),\n \n-            EntryKind::Expr(_, _, expr) => {\n+            NodeKind::Expr(expr) => {\n                 match expr.node {\n                     ExprKind::Closure(.., body, _, _) => Some(body),\n                     _ => None,\n@@ -284,16 +214,16 @@ pub struct Map<'hir> {\n     /// The SVH of the local crate.\n     pub crate_hash: Svh,\n \n-    /// NodeIds are sequential integers from 0, so we can be\n+    /// `NodeId`s are sequential integers from 0, so we can be\n     /// super-compact by storing them in a vector. Not everything with\n-    /// a NodeId is in the map, but empirically the occupancy is about\n+    /// a `NodeId` is in the map, but empirically the occupancy is about\n     /// 75-80%, so there's not too much overhead (certainly less than\n     /// a hashmap, since they (at the time of writing) have a maximum\n     /// of 75% occupancy).\n     ///\n     /// Also, indexing is pretty quick when you've got a vector and\n     /// plain old integers.\n-    map: Vec<EntryKind<'hir>>,\n+    map: Vec<Option<Entry<'hir>>>,\n \n     definitions: &'hir Definitions,\n \n@@ -310,34 +240,10 @@ impl<'hir> Map<'hir> {\n     /// read recorded). If the function just returns a DefId or\n     /// NodeId, no actual content was returned, so no read is needed.\n     pub fn read(&self, id: NodeId) {\n-        let entry = self.map[id.as_usize()];\n-        match entry {\n-            EntryKind::Item(_, dep_node_index, _) |\n-            EntryKind::TraitItem(_, dep_node_index, _) |\n-            EntryKind::ImplItem(_, dep_node_index, _) |\n-            EntryKind::Variant(_, dep_node_index, _) |\n-            EntryKind::ForeignItem(_, dep_node_index, _) |\n-            EntryKind::Field(_, dep_node_index, _) |\n-            EntryKind::Stmt(_, dep_node_index, _) |\n-            EntryKind::Ty(_, dep_node_index, _) |\n-            EntryKind::TraitRef(_, dep_node_index, _) |\n-            EntryKind::Binding(_, dep_node_index, _) |\n-            EntryKind::Pat(_, dep_node_index, _) |\n-            EntryKind::Block(_, dep_node_index, _) |\n-            EntryKind::StructCtor(_, dep_node_index, _) |\n-            EntryKind::Lifetime(_, dep_node_index, _) |\n-            EntryKind::GenericParam(_, dep_node_index, _) |\n-            EntryKind::Visibility(_, dep_node_index, _) |\n-            EntryKind::AnonConst(_, dep_node_index, _) |\n-            EntryKind::Expr(_, dep_node_index, _) |\n-            EntryKind::Local(_, dep_node_index, _) |\n-            EntryKind::MacroDef(dep_node_index, _) |\n-            EntryKind::RootCrate(dep_node_index) => {\n-                self.dep_graph.read_index(dep_node_index);\n-            }\n-            EntryKind::NotPresent => {\n-                bug!(\"called HirMap::read() with invalid NodeId\")\n-            }\n+        if let Some(entry) = self.map[id.as_usize()] {\n+            self.dep_graph.read_index(entry.dep_node);\n+        } else {\n+            bug!(\"called `HirMap::read()` with invalid `NodeId`\")\n         }\n     }\n \n@@ -485,7 +391,8 @@ impl<'hir> Map<'hir> {\n             NodeKind::StructCtor(_) |\n             NodeKind::Lifetime(_) |\n             NodeKind::Visibility(_) |\n-            NodeKind::Block(_) => None,\n+            NodeKind::Block(_) |\n+            NodeKind::Crate => None,\n             NodeKind::Local(local) => {\n                 Some(Def::Local(local.id))\n             }\n@@ -506,8 +413,8 @@ impl<'hir> Map<'hir> {\n         self.map.len()\n     }\n \n-    fn find_entry(&self, id: NodeId) -> Option<EntryKind<'hir>> {\n-        self.map.get(id.as_usize()).cloned()\n+    fn find_entry(&self, id: NodeId) -> Option<Entry<'hir>> {\n+        self.map.get(id.as_usize()).cloned().unwrap_or(None)\n     }\n \n     pub fn krate(&self) -> &'hir Crate {\n@@ -551,7 +458,7 @@ impl<'hir> Map<'hir> {\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n     pub fn body_owner(&self, BodyId { node_id }: BodyId) -> NodeId {\n         let parent = self.get_parent_node(node_id);\n-        assert!(self.map[parent.as_usize()].is_body_owner(node_id));\n+        assert!(self.map[parent.as_usize()].map_or(false, |e| e.is_body_owner(node_id)));\n         parent\n     }\n \n@@ -763,24 +670,21 @@ impl<'hir> Map<'hir> {\n                 return Err(id);\n             }\n \n-            let node = self.find_entry(parent_node);\n-            if node.is_none() {\n-                return Err(id);\n-            }\n-            let node = node.unwrap().to_node();\n-            match node {\n-                Some(ref node) => {\n-                    if found(node) {\n-                        return Ok(parent_node);\n-                    } else if bail_early(node) {\n-                        return Err(parent_node);\n+            if let Some(node) = self.find_entry(parent_node) {\n+                match node.to_node() {\n+                    Some(ref node) => {\n+                        if found(node) {\n+                            return Ok(parent_node);\n+                        } else if bail_early(node) {\n+                            return Err(parent_node);\n+                        }\n                     }\n+                    None => return Err(parent_node),\n                 }\n-                None => {\n-                    return Err(parent_node);\n-                }\n+                id = parent_node;\n+            } else {\n+                return Err(id);\n             }\n-            id = parent_node;\n         }\n     }\n \n@@ -888,23 +792,17 @@ impl<'hir> Map<'hir> {\n \n     pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n         let parent = self.get_parent(id);\n-        let abi = match self.find_entry(parent) {\n-            Some(EntryKind::Item(_, _, i)) => {\n-                match i.node {\n-                    ItemKind::ForeignMod(ref nm) => Some(nm.abi),\n-                    _ => None\n+        if let Some(entry) = self.find_entry(parent) {\n+            match entry {\n+                Entry { node: NodeKind::Item(Item { node: ItemKind::ForeignMod(ref nm), .. }), .. }\n+                    => {\n+                    self.read(id); // reveals some of the content of a node\n+                    return nm.abi;\n                 }\n+                _ => {}\n             }\n-            _ => None\n-        };\n-        match abi {\n-            Some(abi) => {\n-                self.read(id); // reveals some of the content of a node\n-                abi\n-            }\n-            None => bug!(\"expected foreign mod or inlined parent, found {}\",\n-                          self.node_to_string(parent))\n         }\n+        bug!(\"expected foreign mod or inlined parent, found {}\", self.node_to_string(parent))\n     }\n \n     pub fn expect_item(&self, id: NodeId) -> &'hir Item {\n@@ -1030,35 +928,33 @@ impl<'hir> Map<'hir> {\n \n     pub fn span(&self, id: NodeId) -> Span {\n         self.read(id); // reveals span from node\n-        match self.find_entry(id) {\n-            Some(EntryKind::Item(_, _, item)) => item.span,\n-            Some(EntryKind::ForeignItem(_, _, foreign_item)) => foreign_item.span,\n-            Some(EntryKind::TraitItem(_, _, trait_method)) => trait_method.span,\n-            Some(EntryKind::ImplItem(_, _, impl_item)) => impl_item.span,\n-            Some(EntryKind::Variant(_, _, variant)) => variant.span,\n-            Some(EntryKind::Field(_, _, field)) => field.span,\n-            Some(EntryKind::AnonConst(_, _, constant)) => self.body(constant.body).value.span,\n-            Some(EntryKind::Expr(_, _, expr)) => expr.span,\n-            Some(EntryKind::Stmt(_, _, stmt)) => stmt.span,\n-            Some(EntryKind::Ty(_, _, ty)) => ty.span,\n-            Some(EntryKind::TraitRef(_, _, tr)) => tr.path.span,\n-            Some(EntryKind::Binding(_, _, pat)) => pat.span,\n-            Some(EntryKind::Pat(_, _, pat)) => pat.span,\n-            Some(EntryKind::Block(_, _, block)) => block.span,\n-            Some(EntryKind::StructCtor(_, _, _)) => self.expect_item(self.get_parent(id)).span,\n-            Some(EntryKind::Lifetime(_, _, lifetime)) => lifetime.span,\n-            Some(EntryKind::GenericParam(_, _, param)) => param.span,\n-            Some(EntryKind::Visibility(_, _, &Spanned {\n+        match self.find_entry(id).map(|entry| entry.node) {\n+            Some(NodeKind::Item(item)) => item.span,\n+            Some(NodeKind::ForeignItem(foreign_item)) => foreign_item.span,\n+            Some(NodeKind::TraitItem(trait_method)) => trait_method.span,\n+            Some(NodeKind::ImplItem(impl_item)) => impl_item.span,\n+            Some(NodeKind::Variant(variant)) => variant.span,\n+            Some(NodeKind::Field(field)) => field.span,\n+            Some(NodeKind::AnonConst(constant)) => self.body(constant.body).value.span,\n+            Some(NodeKind::Expr(expr)) => expr.span,\n+            Some(NodeKind::Stmt(stmt)) => stmt.span,\n+            Some(NodeKind::Ty(ty)) => ty.span,\n+            Some(NodeKind::TraitRef(tr)) => tr.path.span,\n+            Some(NodeKind::Binding(pat)) => pat.span,\n+            Some(NodeKind::Pat(pat)) => pat.span,\n+            Some(NodeKind::Block(block)) => block.span,\n+            Some(NodeKind::StructCtor(_)) => self.expect_item(self.get_parent(id)).span,\n+            Some(NodeKind::Lifetime(lifetime)) => lifetime.span,\n+            Some(NodeKind::GenericParam(param)) => param.span,\n+            Some(NodeKind::Visibility(&Spanned {\n                 node: VisibilityKind::Restricted { ref path, .. }, ..\n             })) => path.span,\n-            Some(EntryKind::Visibility(_, _, v)) => bug!(\"unexpected Visibility {:?}\", v),\n-            Some(EntryKind::Local(_, _, local)) => local.span,\n-            Some(EntryKind::MacroDef(_, macro_def)) => macro_def.span,\n+            Some(NodeKind::Visibility(v)) => bug!(\"unexpected Visibility {:?}\", v),\n+            Some(NodeKind::Local(local)) => local.span,\n+            Some(NodeKind::MacroDef(macro_def)) => macro_def.span,\n \n-            Some(EntryKind::RootCrate(_)) => self.forest.krate.span,\n-            Some(EntryKind::NotPresent) | None => {\n-                bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n-            }\n+            Some(NodeKind::Crate) => self.forest.krate.span,\n+            None => bug!(\"hir::map::Map::span: id not in map: {:?}\", id),\n         }\n     }\n \n@@ -1151,13 +1047,13 @@ impl<'a, 'hir> Iterator for NodesMatchingSuffix<'a, 'hir> {\n                 return None;\n             }\n             self.idx = NodeId::from_u32(self.idx.as_u32() + 1);\n-            let name = match self.map.find_entry(idx) {\n-                Some(EntryKind::Item(_, _, n))       => n.name(),\n-                Some(EntryKind::ForeignItem(_, _, n))=> n.name(),\n-                Some(EntryKind::TraitItem(_, _, n))  => n.name(),\n-                Some(EntryKind::ImplItem(_, _, n))   => n.name(),\n-                Some(EntryKind::Variant(_, _, n))    => n.name(),\n-                Some(EntryKind::Field(_, _, n))      => n.name(),\n+            let name = match self.map.find_entry(idx).map(|entry| entry.node) {\n+                Some(NodeKind::Item(n)) => n.name(),\n+                Some(NodeKind::ForeignItem(n)) => n.name(),\n+                Some(NodeKind::TraitItem(n)) => n.name(),\n+                Some(NodeKind::ImplItem(n)) => n.name(),\n+                Some(NodeKind::Variant(n)) => n.name(),\n+                Some(NodeKind::Field(n)) => n.name(),\n                 _ => continue,\n             };\n             if self.matches_names(self.map.get_parent(idx), name) {\n@@ -1206,12 +1102,8 @@ pub fn map_crate<'hir>(sess: &::session::Session,\n     if log_enabled!(::log::Level::Debug) {\n         // This only makes sense for ordered stores; note the\n         // enumerate to count the number of entries.\n-        let (entries_less_1, _) = map.iter().filter(|&x| {\n-            match *x {\n-                EntryKind::NotPresent => false,\n-                _ => true\n-            }\n-        }).enumerate().last().expect(\"AST map was empty after folding?\");\n+        let (entries_less_1, _) = map.iter().filter_map(|x| *x).enumerate().last()\n+            .expect(\"AST map was empty after folding?\");\n \n         let entries = entries_less_1 + 1;\n         let vector_length = map.len();\n@@ -1264,7 +1156,7 @@ impl<'a> print::State<'a> {\n             NodeKind::Stmt(a)         => self.print_stmt(&a),\n             NodeKind::Ty(a)           => self.print_type(&a),\n             NodeKind::TraitRef(a)     => self.print_trait_ref(&a),\n-            NodeKind::Binding(a)       |\n+            NodeKind::Binding(a)      |\n             NodeKind::Pat(a)          => self.print_pat(&a),\n             NodeKind::Block(a)        => {\n                 use syntax::print::pprust::PrintState;\n@@ -1285,6 +1177,7 @@ impl<'a> print::State<'a> {\n             NodeKind::StructCtor(_)   => bug!(\"cannot print isolated StructCtor\"),\n             NodeKind::Local(a)        => self.print_local_decl(&a),\n             NodeKind::MacroDef(_)     => bug!(\"cannot print MacroDef\"),\n+            NodeKind::Crate     => bug!(\"cannot print Crate\"),\n         }\n     }\n }\n@@ -1411,9 +1304,8 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeKind::MacroDef(_)) => {\n             format!(\"macro {}{}\",  path_str(), id_str)\n         }\n-        None => {\n-            format!(\"unknown node{}\", id_str)\n-        }\n+        Some(NodeKind::Crate) => format!(\"root_crate\"),\n+        None => format!(\"unknown node{}\", id_str),\n     }\n }\n "}]}