{"sha": "497d67d708e5e54344efc10f9c16ea83b215da9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5N2Q2N2Q3MDhlNWU1NDM0NGVmYzEwZjljMTZlYTgzYjIxNWRhOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-01T22:25:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-01T22:25:58Z"}, "message": "Auto merge of #35761 - nikomatsakis:faster-trans-fulfill-obligation, r=eddyb\n\nCache projections in trans\n\nThis introduces a cache for the results of projection and normalization in trans. This is in addition to the existing cache that is per-inference-context. Trans is an easy place to put the cache because we are guaranteed not to have type parameters and also we don't expect any failures or inference variables, so there is no need to cache or follow-up on obligations that come along with.  (As evidenced by the fact that this particular code would panic if any error occurred.)\n\nThat said, I am not sure this is 100% the best place for it; I sort of wanted a cache like we have in the fulfillment context for global names; but that cache only triggers when all subsequent obligations are satisfied, and since projections don't have an entry in the obligation jungle there is no easy place to put it. I considered caching both the result and obligations globally, but haven't really tried implementing it. It might be a good next step.\n\nRegardless, this cache seems to have no real effect on bootstrap time (maybe a slight improvement), but on [the futures.rs test case I was looking at](https://github.com/rust-lang-nursery/rustc-benchmarks/pull/6), it improves performance quite a bit:\n\n| phase | before | after |\n| ----- | ------ | ----- |\n| collection | 0.79s | 0.46s |\n| translation | 6.8s | 3.2s |\n| total | 11.92s | 7.15s |\n\nr? @arielb1", "tree": {"sha": "600432645e75fd84e29383059ee10a329e41215f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/600432645e75fd84e29383059ee10a329e41215f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/497d67d708e5e54344efc10f9c16ea83b215da9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/497d67d708e5e54344efc10f9c16ea83b215da9e", "html_url": "https://github.com/rust-lang/rust/commit/497d67d708e5e54344efc10f9c16ea83b215da9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/497d67d708e5e54344efc10f9c16ea83b215da9e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "933f4717104aba3af71ced7e5a513f8c0bd6077a", "url": "https://api.github.com/repos/rust-lang/rust/commits/933f4717104aba3af71ced7e5a513f8c0bd6077a", "html_url": "https://github.com/rust-lang/rust/commit/933f4717104aba3af71ced7e5a513f8c0bd6077a"}, {"sha": "00d208eea87c1cbeefb8a0a83237a71c9eea2d6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/00d208eea87c1cbeefb8a0a83237a71c9eea2d6c", "html_url": "https://github.com/rust-lang/rust/commit/00d208eea87c1cbeefb8a0a83237a71c9eea2d6c"}], "stats": {"total": 341, "additions": 197, "deletions": 144}, "files": [{"sha": "18179027c25de9a6ef68d5746e73d6b8dace658a", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -132,7 +132,7 @@ pub enum DepNode<D: Clone + Debug> {\n     // which would yield an overly conservative dep-graph.\n     TraitItems(D),\n     ReprHints(D),\n-    TraitSelect(D, Vec<D>),\n+    TraitSelect(Vec<D>),\n }\n \n impl<D: Clone + Debug> DepNode<D> {\n@@ -237,10 +237,9 @@ impl<D: Clone + Debug> DepNode<D> {\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),\n-            TraitSelect(ref d, ref type_ds) => {\n-                let d = try_opt!(op(d));\n+            TraitSelect(ref type_ds) => {\n                 let type_ds = try_opt!(type_ds.iter().map(|d| op(d)).collect());\n-                Some(TraitSelect(d, type_ds))\n+                Some(TraitSelect(type_ds))\n             }\n         }\n     }"}, {"sha": "b6114f293ad3a7e060d0d5766d9027a7447d071c", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 24, "deletions": 68, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -136,13 +136,6 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // avoid reporting the same error twice.\n     pub reported_trait_errors: RefCell<FnvHashSet<traits::TraitErrorKey<'tcx>>>,\n \n-    // This is a temporary field used for toggling on normalization in the inference context,\n-    // as we move towards the approach described here:\n-    // https://internals.rust-lang.org/t/flattening-the-contexts-for-fun-and-profit/2293\n-    // At a point sometime in the future normalization will be done by the typing context\n-    // directly.\n-    normalize: bool,\n-\n     // Sadly, the behavior of projection varies a bit depending on the\n     // stage of compilation. The specifics are given in the\n     // documentation for `Reveal`.\n@@ -458,7 +451,6 @@ pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tables: Option<RefCell<ty::Tables<'tcx>>>,\n     param_env: Option<ty::ParameterEnvironment<'gcx>>,\n     projection_mode: Reveal,\n-    normalize: bool\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n@@ -473,19 +465,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             tables: tables.map(RefCell::new),\n             param_env: param_env,\n             projection_mode: projection_mode,\n-            normalize: false\n-        }\n-    }\n-\n-    pub fn normalizing_infer_ctxt(self, projection_mode: Reveal)\n-                                  -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n-        InferCtxtBuilder {\n-            global_tcx: self,\n-            arenas: ty::CtxtArenas::new(),\n-            tables: None,\n-            param_env: None,\n-            projection_mode: projection_mode,\n-            normalize: false\n         }\n     }\n \n@@ -506,7 +485,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             evaluation_cache: traits::EvaluationCache::new(),\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n             reported_trait_errors: RefCell::new(FnvHashSet()),\n-            normalize: false,\n             projection_mode: Reveal::NotSpecializable,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: self.sess.err_count(),\n@@ -525,7 +503,6 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             ref tables,\n             ref mut param_env,\n             projection_mode,\n-            normalize\n         } = *self;\n         let tables = if let Some(ref tables) = *tables {\n             InferTables::Local(tables)\n@@ -547,7 +524,6 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             reported_trait_errors: RefCell::new(FnvHashSet()),\n-            normalize: normalize,\n             projection_mode: projection_mode,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: tcx.sess.err_count(),\n@@ -683,6 +659,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n     }\n \n+    /// Finishes processes any obligations that remain in the\n+    /// fulfillment context, and then returns the result with all type\n+    /// variables removed and regions erased. Because this is intended\n+    /// for use after type-check has completed, if any errors occur,\n+    /// it will panic. It is used during normalization and other cases\n+    /// where processing the obligations in `fulfill_cx` may cause\n+    /// type inference variables that appear in `result` to be\n+    /// unified, and hence we need to process those obligations to get\n+    /// the complete picture of the type.\n     pub fn drain_fulfillment_cx_or_panic<T>(&self,\n                                             span: Span,\n                                             fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n@@ -692,47 +677,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         debug!(\"drain_fulfillment_cx_or_panic()\");\n \n-        let when = \"resolving bounds after type-checking\";\n-        let v = match self.drain_fulfillment_cx(fulfill_cx, result) {\n-            Ok(v) => v,\n+        // In principle, we only need to do this so long as `result`\n+        // contains unbound type parameters. It could be a slight\n+        // optimization to stop iterating early.\n+        match fulfill_cx.select_all_or_error(self) {\n+            Ok(()) => { }\n             Err(errors) => {\n-                span_bug!(span, \"Encountered errors `{:?}` {}\", errors, when);\n+                span_bug!(span, \"Encountered errors `{:?}` resolving bounds after type-checking\",\n+                          errors);\n             }\n-        };\n+        }\n+\n+        let result = self.resolve_type_vars_if_possible(result);\n+        let result = self.tcx.erase_regions(&result);\n \n-        match self.tcx.lift_to_global(&v) {\n-            Some(v) => v,\n+        match self.tcx.lift_to_global(&result) {\n+            Some(result) => result,\n             None => {\n-                span_bug!(span, \"Uninferred types/regions in `{:?}` {}\", v, when);\n+                span_bug!(span, \"Uninferred types/regions in `{:?}`\", result);\n             }\n         }\n     }\n \n-    /// Finishes processes any obligations that remain in the fulfillment\n-    /// context, and then \"freshens\" and returns `result`. This is\n-    /// primarily used during normalization and other cases where\n-    /// processing the obligations in `fulfill_cx` may cause type\n-    /// inference variables that appear in `result` to be unified, and\n-    /// hence we need to process those obligations to get the complete\n-    /// picture of the type.\n-    pub fn drain_fulfillment_cx<T>(&self,\n-                                   fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                                   result: &T)\n-                                   -> Result<T,Vec<traits::FulfillmentError<'tcx>>>\n-        where T : TypeFoldable<'tcx>\n-    {\n-        debug!(\"drain_fulfillment_cx(result={:?})\",\n-               result);\n-\n-        // In principle, we only need to do this so long as `result`\n-        // contains unbound type parameters. It could be a slight\n-        // optimization to stop iterating early.\n-        fulfill_cx.select_all_or_error(self)?;\n-\n-        let result = self.resolve_type_vars_if_possible(result);\n-        Ok(self.tcx.erase_regions(&result))\n-    }\n-\n     pub fn projection_mode(&self) -> Reveal {\n         self.projection_mode\n     }\n@@ -1702,17 +1668,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let closure_ty = self.tcx.closure_type(def_id, substs);\n-        if self.normalize {\n-            let closure_ty = self.tcx.erase_regions(&closure_ty);\n-\n-            if !closure_ty.has_projection_types() {\n-                return closure_ty;\n-            }\n-\n-            self.normalize_projections_in(&closure_ty)\n-        } else {\n-            closure_ty\n-        }\n+        closure_ty\n     }\n }\n "}, {"sha": "f3ba4d16eb0b2f2f72914a06ca1b5484d041dd90", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -147,7 +147,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              .unwrap()\n                              .subst(tcx, &penv.free_substs);\n \n-    let result = tcx.normalizing_infer_ctxt(Reveal::ExactMatch).enter(|mut infcx| {\n+    let result = tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|mut infcx| {\n         // Normalize the trait reference, adding any obligations\n         // that arise into the impl1 assumptions.\n         let Normalized { value: impl1_trait_ref, obligations: normalization_obligations } = {\n@@ -207,24 +207,27 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     for oblig in obligations.into_iter() {\n         fulfill_cx.register_predicate_obligation(&infcx, oblig);\n     }\n+    match fulfill_cx.select_all_or_error(infcx) {\n+        Err(errors) => {\n+            // no dice!\n+            debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n+                    {:?}\",\n+                   source_trait_ref,\n+                   target_trait_ref,\n+                   errors,\n+                   infcx.parameter_environment.caller_bounds);\n+            Err(())\n+        }\n \n-    if let Err(errors) = infcx.drain_fulfillment_cx(&mut fulfill_cx, &()) {\n-        // no dice!\n-        debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n-                {:?}\",\n-               source_trait_ref,\n-               target_trait_ref,\n-               errors,\n-               infcx.parameter_environment.caller_bounds);\n-        Err(())\n-    } else {\n-        debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\",\n-               source_trait_ref,\n-               target_trait_ref);\n+        Ok(()) => {\n+            debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\",\n+                   source_trait_ref,\n+                   target_trait_ref);\n \n-        // Now resolve the *substitution* we built for the target earlier, replacing\n-        // the inference variables inside with whatever we got from fulfillment.\n-        Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n+            // Now resolve the *substitution* we built for the target earlier, replacing\n+            // the inference variables inside with whatever we got from fulfillment.\n+            Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n+        }\n     }\n }\n "}, {"sha": "e9c01f5bad66ecab0273b09683dd971033d360c4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -953,8 +953,9 @@ impl<'tcx> TraitPredicate<'tcx> {\n                     _ =>\n                         None\n                 })\n+                .chain(iter::once(self.def_id()))\n                 .collect();\n-        DepNode::TraitSelect(self.def_id(), def_ids)\n+        DepNode::TraitSelect(def_ids)\n     }\n \n     pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {"}, {"sha": "40e78c007ccfd652ed9d53eae876f05b10767fc4", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -691,7 +691,7 @@ impl LateLintPass for VariantSizeDifferences {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n             if gens.ty_params.is_empty() {  // sizes only make sense for non-generic types\n                 let t = cx.tcx.node_id_to_type(it.id);\n-                let layout = cx.tcx.normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n+                let layout = cx.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n                     let ty = cx.tcx.erase_regions(&t);\n                     ty.layout(&infcx).unwrap_or_else(|e| {\n                         bug!(\"failed to get layout for `{}`: {}\", t, e)"}, {"sha": "99126095ede3e699d85612b00ef81031b44d67ec", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -1128,7 +1128,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n \n     let fn_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n     let fn_ty = ccx.tcx().erase_regions(&fn_ty);\n-    let fn_ty = monomorphize::apply_param_substs(ccx.tcx(), instance.substs, &fn_ty);\n+    let fn_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &fn_ty);\n \n     let sig = ccx.tcx().erase_late_bound_regions(fn_ty.fn_sig());\n     let sig = ccx.tcx().normalize_associated_type(&sig);\n@@ -1151,7 +1151,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     attributes::set_frame_pointer_elimination(ccx, llfndecl);\n \n     let ctor_ty = ccx.tcx().lookup_item_type(def_id).ty;\n-    let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), substs, &ctor_ty);\n+    let ctor_ty = monomorphize::apply_param_substs(ccx.shared(), substs, &ctor_ty);\n \n     let sig = ccx.tcx().erase_late_bound_regions(&ctor_ty.fn_sig());\n     let sig = ccx.tcx().normalize_associated_type(&sig);\n@@ -1894,7 +1894,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n     };\n \n     let codegen_units = time(time_passes, \"codegen unit partitioning\", || {\n-        partitioning::partition(scx.tcx(),\n+        partitioning::partition(scx,\n                                 items.iter().cloned(),\n                                 strategy,\n                                 &inlining_map,"}, {"sha": "33cacbe194bb0ee1c66bcdcf59d4252076546aa3", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -28,7 +28,7 @@ use base;\n use base::*;\n use build::*;\n use closure;\n-use common::{self, Block, Result, CrateContext, FunctionContext};\n+use common::{self, Block, Result, CrateContext, FunctionContext, SharedCrateContext};\n use consts;\n use debuginfo::DebugLoc;\n use declare;\n@@ -37,7 +37,7 @@ use monomorphize::{self, Instance};\n use trans_item::TransItem;\n use type_of;\n use Disr;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::hir;\n \n use syntax_pos::DUMMY_SP;\n@@ -97,7 +97,7 @@ impl<'tcx> Callee<'tcx> {\n             return Callee::trait_method(ccx, trait_id, def_id, substs);\n         }\n \n-        let fn_ty = def_ty(tcx, def_id, substs);\n+        let fn_ty = def_ty(ccx.shared(), def_id, substs);\n         if let ty::TyFnDef(_, _, f) = fn_ty.sty {\n             if f.abi == Abi::RustIntrinsic || f.abi == Abi::PlatformIntrinsic {\n                 return Callee {\n@@ -155,20 +155,20 @@ impl<'tcx> Callee<'tcx> {\n                                                          vtable_closure.substs,\n                                                          trait_closure_kind);\n \n-                let method_ty = def_ty(tcx, def_id, substs);\n+                let method_ty = def_ty(ccx.shared(), def_id, substs);\n                 Callee::ptr(llfn, method_ty)\n             }\n             traits::VtableFnPointer(vtable_fn_pointer) => {\n                 let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n                 let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, vtable_fn_pointer.fn_ty);\n \n-                let method_ty = def_ty(tcx, def_id, substs);\n+                let method_ty = def_ty(ccx.shared(), def_id, substs);\n                 Callee::ptr(llfn, method_ty)\n             }\n             traits::VtableObject(ref data) => {\n                 Callee {\n                     data: Virtual(tcx.get_vtable_index_of_object_method(data, def_id)),\n-                    ty: def_ty(tcx, def_id, substs)\n+                    ty: def_ty(ccx.shared(), def_id, substs)\n                 }\n             }\n             vtable => {\n@@ -244,12 +244,12 @@ impl<'tcx> Callee<'tcx> {\n }\n \n /// Given a DefId and some Substs, produces the monomorphic item type.\n-fn def_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n                     def_id: DefId,\n                     substs: &'tcx Substs<'tcx>)\n                     -> Ty<'tcx> {\n-    let ty = tcx.lookup_item_type(def_id).ty;\n-    monomorphize::apply_param_substs(tcx, substs, &ty)\n+    let ty = shared.tcx().lookup_item_type(def_id).ty;\n+    monomorphize::apply_param_substs(shared, substs, &ty)\n }\n \n /// Translates an adapter that implements the `Fn` trait for a fn\n@@ -407,7 +407,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let substs = tcx.normalize_associated_type(&substs);\n     let instance = Instance::new(def_id, substs);\n     let item_ty = ccx.tcx().lookup_item_type(def_id).ty;\n-    let fn_ty = monomorphize::apply_param_substs(ccx.tcx(), substs, &item_ty);\n+    let fn_ty = monomorphize::apply_param_substs(ccx.shared(), substs, &item_ty);\n \n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n         return (llfn, fn_ty);"}, {"sha": "c82bfa5c91ba1cbdd74ccd9703336cadc826c194", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -459,7 +459,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     format!(\"Could not find MIR for closure: {:?}\", def_id)\n                 });\n \n-                let concrete_substs = monomorphize::apply_param_substs(self.scx.tcx(),\n+                let concrete_substs = monomorphize::apply_param_substs(self.scx,\n                                                                        self.param_substs,\n                                                                        &substs.func_substs);\n                 let concrete_substs = self.scx.tcx().erase_regions(&concrete_substs);\n@@ -477,11 +477,11 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             // have to instantiate all methods of the trait being cast to, so we\n             // can build the appropriate vtable.\n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, target_ty) => {\n-                let target_ty = monomorphize::apply_param_substs(self.scx.tcx(),\n+                let target_ty = monomorphize::apply_param_substs(self.scx,\n                                                                  self.param_substs,\n                                                                  &target_ty);\n                 let source_ty = operand.ty(self.mir, self.scx.tcx());\n-                let source_ty = monomorphize::apply_param_substs(self.scx.tcx(),\n+                let source_ty = monomorphize::apply_param_substs(self.scx,\n                                                                  self.param_substs,\n                                                                  &source_ty);\n                 let (source_ty, target_ty) = find_vtable_types_for_unsizing(self.scx,\n@@ -508,7 +508,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 assert!(can_have_local_instance(self.scx.tcx(), exchange_malloc_fn_def_id));\n                 let empty_substs = self.scx.empty_substs_for_def_id(exchange_malloc_fn_def_id);\n                 let exchange_malloc_fn_trans_item =\n-                    create_fn_trans_item(self.scx.tcx(),\n+                    create_fn_trans_item(self.scx,\n                                          exchange_malloc_fn_def_id,\n                                          empty_substs,\n                                          self.param_substs);\n@@ -531,7 +531,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             let ty = lvalue.ty(self.mir, self.scx.tcx())\n                            .to_ty(self.scx.tcx());\n \n-            let ty = monomorphize::apply_param_substs(self.scx.tcx(),\n+            let ty = monomorphize::apply_param_substs(self.scx,\n                                                       self.param_substs,\n                                                       &ty);\n             assert!(ty.is_normalized_for_trans());\n@@ -555,7 +555,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     // references to `const` items\n                     if let mir::Literal::Item { def_id, substs } = constant.literal {\n                         let tcx = self.scx.tcx();\n-                        let substs = monomorphize::apply_param_substs(tcx,\n+                        let substs = monomorphize::apply_param_substs(self.scx,\n                                                                       self.param_substs,\n                                                                       &substs);\n \n@@ -613,7 +613,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 // result in a translation item ...\n                 if can_result_in_trans_item(self.scx.tcx(), callee_def_id) {\n                     // ... and create one if it does.\n-                    let trans_item = create_fn_trans_item(self.scx.tcx(),\n+                    let trans_item = create_fn_trans_item(self.scx,\n                                                           callee_def_id,\n                                                           callee_substs,\n                                                           self.param_substs);\n@@ -670,7 +670,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                         if is_drop_in_place_intrinsic(tcx, def_id, bare_fn_ty) => {\n                         let operand_ty = args[0].ty(self.mir, tcx);\n                         if let ty::TyRawPtr(mt) = operand_ty.sty {\n-                            let operand_ty = monomorphize::apply_param_substs(tcx,\n+                            let operand_ty = monomorphize::apply_param_substs(self.scx,\n                                                                               self.param_substs,\n                                                                               &mt.ty);\n                             let ty = glue::get_drop_glue_type(tcx, operand_ty);\n@@ -732,7 +732,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         assert!(can_have_local_instance(scx.tcx(), exchange_free_fn_def_id));\n         let fn_substs = scx.empty_substs_for_def_id(exchange_free_fn_def_id);\n         let exchange_free_fn_trans_item =\n-            create_fn_trans_item(scx.tcx(),\n+            create_fn_trans_item(scx,\n                                  exchange_free_fn_def_id,\n                                  fn_substs,\n                                  Substs::empty(scx.tcx()));\n@@ -769,7 +769,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         };\n \n         if can_have_local_instance(scx.tcx(), destructor_did) {\n-            let trans_item = create_fn_trans_item(scx.tcx(),\n+            let trans_item = create_fn_trans_item(scx,\n                                                   destructor_did,\n                                                   substs,\n                                                   Substs::empty(scx.tcx()));\n@@ -800,7 +800,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         ty::TyStruct(ref adt_def, substs) |\n         ty::TyEnum(ref adt_def, substs) => {\n             for field in adt_def.all_fields() {\n-                let field_type = monomorphize::apply_param_substs(scx.tcx(),\n+                let field_type = monomorphize::apply_param_substs(scx,\n                                                                   substs,\n                                                                   &field.unsubst_ty());\n                 let field_type = glue::get_drop_glue_type(scx.tcx(), field_type);\n@@ -894,8 +894,7 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n            callee_substs,\n            param_substs);\n \n-\n-    let rcvr_substs = monomorphize::apply_param_substs(tcx,\n+    let rcvr_substs = monomorphize::apply_param_substs(scx,\n                                                        param_substs,\n                                                        &callee_substs);\n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n@@ -1016,11 +1015,13 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     }\n }\n \n-fn create_fn_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn create_fn_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                   def_id: DefId,\n                                   fn_substs: &'tcx Substs<'tcx>,\n                                   param_substs: &'tcx Substs<'tcx>)\n                                   -> TransItem<'tcx> {\n+    let tcx = scx.tcx();\n+\n     debug!(\"create_fn_trans_item(def_id={}, fn_substs={:?}, param_substs={:?})\",\n             def_id_to_string(tcx, def_id),\n             fn_substs,\n@@ -1029,7 +1030,7 @@ fn create_fn_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // We only get here, if fn_def_id either designates a local item or\n     // an inlineable external item. Non-inlineable external items are\n     // ignored because we don't want to generate any code for them.\n-    let concrete_substs = monomorphize::apply_param_substs(tcx,\n+    let concrete_substs = monomorphize::apply_param_substs(scx,\n                                                            param_substs,\n                                                            &fn_substs);\n     assert!(concrete_substs.is_normalized_for_trans());\n@@ -1063,7 +1064,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n                         // create translation items\n                         .filter_map(|impl_method| {\n                             if can_have_local_instance(scx.tcx(), impl_method.method.def_id) {\n-                                Some(create_fn_trans_item(scx.tcx(),\n+                                Some(create_fn_trans_item(scx,\n                                     impl_method.method.def_id,\n                                     impl_method.substs,\n                                     Substs::empty(scx.tcx())))\n@@ -1114,7 +1115,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n \n             hir::ItemImpl(..) => {\n                 if self.mode == TransItemCollectionMode::Eager {\n-                    create_trans_items_for_default_impls(self.scx.tcx(),\n+                    create_trans_items_for_default_impls(self.scx,\n                                                          item,\n                                                          self.output);\n                 }\n@@ -1202,9 +1203,10 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n     }\n }\n \n-fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                   item: &'tcx hir::Item,\n                                                   output: &mut Vec<TransItem<'tcx>>) {\n+    let tcx = scx.tcx();\n     match item.node {\n         hir::ItemImpl(_,\n                       _,\n@@ -1255,7 +1257,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                     if can_have_local_instance(tcx, method.def_id) {\n                         let empty_substs = tcx.erase_regions(&mth.substs);\n-                        let item = create_fn_trans_item(tcx,\n+                        let item = create_fn_trans_item(scx,\n                                                         method.def_id,\n                                                         callee_substs,\n                                                         empty_substs);"}, {"sha": "f4682de7dff6af3aceec52ab6699a8bc6dd04fb3", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -350,7 +350,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n-        monomorphize::apply_param_substs(self.ccx.tcx(),\n+        monomorphize::apply_param_substs(self.ccx.shared(),\n                                          self.param_substs,\n                                          value)\n     }\n@@ -519,7 +519,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n-        monomorphize::apply_param_substs(self.tcx(),\n+        monomorphize::apply_param_substs(self.fcx.ccx.shared(),\n                                          self.fcx.param_substs,\n                                          value)\n     }\n@@ -955,7 +955,7 @@ pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n         // Do the initial selection for the obligation. This yields the\n         // shallow result we are looking for -- that is, what specific impl.\n-        tcx.normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n+        tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n             let mut selcx = SelectionContext::new(&infcx);\n \n             let obligation_cause = traits::ObligationCause::misc(span,\n@@ -1014,7 +1014,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"normalize_and_test_predicates(predicates={:?})\",\n            predicates);\n \n-    tcx.normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n+    tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n         let mut selcx = SelectionContext::new(&infcx);\n         let mut fulfill_cx = traits::FulfillmentContext::new();\n         let cause = traits::ObligationCause::dummy();\n@@ -1028,7 +1028,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             fulfill_cx.register_predicate_obligation(&infcx, obligation);\n         }\n \n-        infcx.drain_fulfillment_cx(&mut fulfill_cx, &()).is_ok()\n+        fulfill_cx.select_all_or_error(&infcx).is_ok()\n     })\n }\n "}, {"sha": "2422b9f30069b16a38bbc0fa1817bf4c0b86ce85", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -84,6 +84,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n \n     translation_items: RefCell<FnvHashSet<TransItem<'tcx>>>,\n     trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n+    project_cache: RefCell<DepTrackingMap<ProjectionCache<'tcx>>>,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n@@ -195,6 +196,46 @@ impl<'tcx> DepTrackingMapConfig for MirCache<'tcx> {\n     }\n }\n \n+// # Global Cache\n+\n+pub struct ProjectionCache<'gcx> {\n+    data: PhantomData<&'gcx ()>\n+}\n+\n+impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n+    type Key = Ty<'gcx>;\n+    type Value = Ty<'gcx>;\n+    fn to_dep_node(key: &Self::Key) -> DepNode<DefId> {\n+        // Ideally, we'd just put `key` into the dep-node, but we\n+        // can't put full types in there. So just collect up all the\n+        // def-ids of structs/enums as well as any traits that we\n+        // project out of. It doesn't matter so much what we do here,\n+        // except that if we are too coarse, we'll create overly\n+        // coarse edges between impls and the trans. For example, if\n+        // we just used the def-id of things we are projecting out of,\n+        // then the key for `<Foo as SomeTrait>::T` and `<Bar as\n+        // SomeTrait>::T` would both share a dep-node\n+        // (`TraitSelect(SomeTrait)`), and hence the impls for both\n+        // `Foo` and `Bar` would be considered inputs. So a change to\n+        // `Bar` would affect things that just normalized `Foo`.\n+        // Anyway, this heuristic is not ideal, but better than\n+        // nothing.\n+        let def_ids: Vec<DefId> =\n+            key.walk()\n+               .filter_map(|t| match t.sty {\n+                   ty::TyStruct(adt_def, _) |\n+                   ty::TyEnum(adt_def, _) =>\n+                       Some(adt_def.did),\n+                   ty::TyProjection(ref proj) =>\n+                       Some(proj.trait_ref.def_id),\n+                   _ =>\n+                       None\n+               })\n+               .collect();\n+        DepNode::TraitSelect(def_ids)\n+    }\n+}\n+\n /// This list owns a number of LocalCrateContexts and binds them to their common\n /// SharedCrateContext. This type just exists as a convenience, something to\n /// pass around all LocalCrateContexts with and get an iterator over them.\n@@ -496,6 +537,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             use_dll_storage_attrs: use_dll_storage_attrs,\n             translation_items: RefCell::new(FnvHashSet()),\n             trait_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n+            project_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n         }\n     }\n \n@@ -519,6 +561,10 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.trait_cache\n     }\n \n+    pub fn project_cache(&self) -> &RefCell<DepTrackingMap<ProjectionCache<'tcx>>> {\n+        &self.project_cache\n+    }\n+\n     pub fn link_meta<'a>(&'a self) -> &'a LinkMeta {\n         &self.link_meta\n     }\n@@ -950,7 +996,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn layout_of(&self, ty: Ty<'tcx>) -> &'tcx ty::layout::Layout {\n-        self.tcx().normalizing_infer_ctxt(traits::Reveal::All).enter(|infcx| {\n+        self.tcx().infer_ctxt(None, None, traits::Reveal::All).enter(|infcx| {\n             ty.layout(&infcx).unwrap_or_else(|e| {\n                 bug!(\"failed to get layout for `{}`: {}\", ty, e);\n             })"}, {"sha": "a3a7a79fb58be4d5ce42f4f0c601b8cc539ec203", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -414,7 +414,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             if cx.tcx().trait_id_of_impl(impl_def_id).is_none() {\n                 let impl_self_ty = cx.tcx().lookup_item_type(impl_def_id).ty;\n                 let impl_self_ty = cx.tcx().erase_regions(&impl_self_ty);\n-                let impl_self_ty = monomorphize::apply_param_substs(cx.tcx(),\n+                let impl_self_ty = monomorphize::apply_param_substs(cx.shared(),\n                                                                     instance.substs,\n                                                                     &impl_self_ty);\n "}, {"sha": "9e1e415f62a67b528f56e1ef70652627d0100175", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -113,7 +113,7 @@ pub fn get_drop_glue_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match t.sty {\n         ty::TyBox(typ) if !type_needs_drop(tcx, typ)\n                          && type_is_sized(tcx, typ) => {\n-            tcx.normalizing_infer_ctxt(traits::Reveal::All).enter(|infcx| {\n+            tcx.infer_ctxt(None, None, traits::Reveal::All).enter(|infcx| {\n                 let layout = t.layout(&infcx).unwrap();\n                 if layout.size(&tcx.data_layout).bytes() == 0 {\n                     // `Box<ZeroSizeType>` does not allocate."}, {"sha": "e958795570eee1ed7fe72cd99bc7a411251666fb", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -314,7 +314,7 @@ pub fn get_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n         Some(node_item) => {\n-            let substs = tcx.normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n+            let substs = tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_substs);\n                 let substs = traits::translate_substs(&infcx, impl_def_id,\n                                                       substs, node_item.node);"}, {"sha": "ade266a580e7873ddb02b1b6d9110a26b39c49da", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -258,7 +258,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     fn monomorphize<T>(&self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n-        monomorphize::apply_param_substs(self.ccx.tcx(),\n+        monomorphize::apply_param_substs(self.ccx.shared(),\n                                          self.substs,\n                                          value)\n     }"}, {"sha": "ab2a39864336fe2703b8cf9b55bb99a71d3617e9", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -8,13 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use common::*;\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n+use rustc::ty::fold::{TypeFolder, TypeFoldable};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n-use common::*;\n use rustc::util::ppaux;\n-\n+use rustc::util::common::MemoizationMap;\n use std::fmt;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -42,14 +43,17 @@ impl<'tcx> Instance<'tcx> {\n \n /// Monomorphizes a type from the AST by first applying the in-scope\n /// substitutions and then normalizing any associated types.\n-pub fn apply_param_substs<'a, 'tcx, T>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn apply_param_substs<'a, 'tcx, T>(scx: &SharedCrateContext<'a, 'tcx>,\n                                        param_substs: &Substs<'tcx>,\n                                        value: &T)\n                                        -> T\n     where T: TransNormalize<'tcx>\n {\n+    let tcx = scx.tcx();\n+    debug!(\"apply_param_substs(param_substs={:?}, value={:?})\", param_substs, value);\n     let substituted = value.subst(tcx, param_substs);\n-    tcx.normalize_associated_type(&substituted)\n+    let substituted = scx.tcx().erase_regions(&substituted);\n+    AssociatedTypeNormalizer::new(scx).fold(&substituted)\n }\n \n \n@@ -61,3 +65,40 @@ pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     tcx.normalize_associated_type(&f.ty(tcx, param_substs))\n }\n+\n+struct AssociatedTypeNormalizer<'a, 'b: 'a, 'gcx: 'b> {\n+    shared: &'a SharedCrateContext<'b, 'gcx>,\n+}\n+\n+impl<'a, 'b, 'gcx> AssociatedTypeNormalizer<'a, 'b, 'gcx> {\n+    fn new(shared: &'a SharedCrateContext<'b, 'gcx>) -> Self {\n+        AssociatedTypeNormalizer {\n+            shared: shared,\n+        }\n+    }\n+\n+    fn fold<T:TypeFoldable<'gcx>>(&mut self, value: &T) -> T {\n+        if !value.has_projection_types() {\n+            value.clone()\n+        } else {\n+            value.fold_with(self)\n+        }\n+    }\n+}\n+\n+impl<'a, 'b, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'b, 'gcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'gcx> {\n+        self.shared.tcx()\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'gcx>) -> Ty<'gcx> {\n+        if !ty.has_projection_types() {\n+            ty\n+        } else {\n+            self.shared.project_cache().memoize(ty, || {\n+                debug!(\"AssociatedTypeNormalizer: ty={:?}\", ty);\n+                self.shared.tcx().normalize_associated_type(&ty)\n+            })\n+        }\n+    }\n+}"}, {"sha": "a161bd199b1f6768ecf982d86b13b345bd499696", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -117,6 +117,7 @@\n //! inlining, even when they are not marked #[inline].\n \n use collector::InliningMap;\n+use context::SharedCrateContext;\n use llvm;\n use monomorphize;\n use rustc::dep_graph::{DepNode, WorkProductId};\n@@ -250,14 +251,16 @@ impl<'tcx> CodegenUnit<'tcx> {\n // Anything we can't find a proper codegen unit for goes into this.\n const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n \n-pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                               trans_items: I,\n                               strategy: PartitioningStrategy,\n                               inlining_map: &InliningMap<'tcx>,\n                               reachable: &NodeSet)\n                               -> Vec<CodegenUnit<'tcx>>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n+    let tcx = scx.tcx();\n+\n     if let PartitioningStrategy::FixedUnitCount(1) = strategy {\n         // If there is only a single codegen-unit, we can use a very simple\n         // scheme and don't have to bother with doing much analysis.\n@@ -267,7 +270,7 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // In the first step, we place all regular translation items into their\n     // respective 'home' codegen unit. Regular translation items are all\n     // functions and statics defined in the local crate.\n-    let mut initial_partitioning = place_root_translation_items(tcx,\n+    let mut initial_partitioning = place_root_translation_items(scx,\n                                                                 trans_items,\n                                                                 reachable);\n \n@@ -306,20 +309,21 @@ struct PreInliningPartitioning<'tcx> {\n \n struct PostInliningPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n \n-fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                                              trans_items: I,\n                                              _reachable: &NodeSet)\n                                              -> PreInliningPartitioning<'tcx>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n+    let tcx = scx.tcx();\n     let mut roots = FnvHashSet();\n     let mut codegen_units = FnvHashMap();\n \n     for trans_item in trans_items {\n         let is_root = !trans_item.is_instantiated_only_on_demand();\n \n         if is_root {\n-            let characteristic_def_id = characteristic_def_id_of_trans_item(tcx, trans_item);\n+            let characteristic_def_id = characteristic_def_id_of_trans_item(scx, trans_item);\n             let is_volatile = trans_item.is_generic_fn();\n \n             let codegen_unit_name = match characteristic_def_id {\n@@ -477,9 +481,10 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n     }\n }\n \n-fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                  trans_item: TransItem<'tcx>)\n                                                  -> Option<DefId> {\n+    let tcx = scx.tcx();\n     match trans_item {\n         TransItem::Fn(instance) => {\n             // If this is a method, we want to put it into the same module as\n@@ -497,7 +502,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 // self-type is:\n                 let impl_self_ty = tcx.lookup_item_type(impl_def_id).ty;\n                 let impl_self_ty = tcx.erase_regions(&impl_self_ty);\n-                let impl_self_ty = monomorphize::apply_param_substs(tcx,\n+                let impl_self_ty = monomorphize::apply_param_substs(scx,\n                                                                     instance.substs,\n                                                                     &impl_self_ty);\n "}, {"sha": "8a0f37230c8dfa21730fda3bd4e725c7cf7a7169", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/497d67d708e5e54344efc10f9c16ea83b215da9e/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=497d67d708e5e54344efc10f9c16ea83b215da9e", "patch": "@@ -176,7 +176,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n         let item_ty = ccx.tcx().lookup_item_type(instance.def).ty;\n         let item_ty = ccx.tcx().erase_regions(&item_ty);\n-        let mono_ty = monomorphize::apply_param_substs(ccx.tcx(), instance.substs, &item_ty);\n+        let mono_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &item_ty);\n \n         let attrs = ccx.tcx().get_attrs(instance.def);\n         let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);"}]}