{"sha": "1b80990fe01646868f85245f608203e23f64184a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiODA5OTBmZTAxNjQ2ODY4Zjg1MjQ1ZjYwODIwM2UyM2Y2NDE4NGE=", "commit": {"author": {"name": "unknown", "email": "abramlujan@gmail.com", "date": "2020-11-29T17:23:59Z"}, "committer": {"name": "unknown", "email": "abramlujan@gmail.com", "date": "2020-12-03T23:54:28Z"}, "message": "Make the unsafe_sizeof_count_copies lint work with more functions\nSpecifically:\n - find std::ptr::write_bytes\n - find std::ptr::swap_nonoverlapping\n - find std::ptr::slice_from_raw_parts\n - find std::ptr::slice_from_raw_parts_mut\n - pointer_primitive::write_bytes", "tree": {"sha": "177f26982d6e36000bbfb7fce63863fb7d420e75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/177f26982d6e36000bbfb7fce63863fb7d420e75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b80990fe01646868f85245f608203e23f64184a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b80990fe01646868f85245f608203e23f64184a", "html_url": "https://github.com/rust-lang/rust/commit/1b80990fe01646868f85245f608203e23f64184a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b80990fe01646868f85245f608203e23f64184a/comments", "author": {"login": "nico-abram", "id": 24706838, "node_id": "MDQ6VXNlcjI0NzA2ODM4", "avatar_url": "https://avatars.githubusercontent.com/u/24706838?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nico-abram", "html_url": "https://github.com/nico-abram", "followers_url": "https://api.github.com/users/nico-abram/followers", "following_url": "https://api.github.com/users/nico-abram/following{/other_user}", "gists_url": "https://api.github.com/users/nico-abram/gists{/gist_id}", "starred_url": "https://api.github.com/users/nico-abram/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nico-abram/subscriptions", "organizations_url": "https://api.github.com/users/nico-abram/orgs", "repos_url": "https://api.github.com/users/nico-abram/repos", "events_url": "https://api.github.com/users/nico-abram/events{/privacy}", "received_events_url": "https://api.github.com/users/nico-abram/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nico-abram", "id": 24706838, "node_id": "MDQ6VXNlcjI0NzA2ODM4", "avatar_url": "https://avatars.githubusercontent.com/u/24706838?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nico-abram", "html_url": "https://github.com/nico-abram", "followers_url": "https://api.github.com/users/nico-abram/followers", "following_url": "https://api.github.com/users/nico-abram/following{/other_user}", "gists_url": "https://api.github.com/users/nico-abram/gists{/gist_id}", "starred_url": "https://api.github.com/users/nico-abram/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nico-abram/subscriptions", "organizations_url": "https://api.github.com/users/nico-abram/orgs", "repos_url": "https://api.github.com/users/nico-abram/repos", "events_url": "https://api.github.com/users/nico-abram/events{/privacy}", "received_events_url": "https://api.github.com/users/nico-abram/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f954babef41b16e26b900d3858ceac4005a4506", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f954babef41b16e26b900d3858ceac4005a4506", "html_url": "https://github.com/rust-lang/rust/commit/0f954babef41b16e26b900d3858ceac4005a4506"}], "stats": {"total": 180, "additions": 126, "deletions": 54}, "files": [{"sha": "8a4538091e7658c9b07fe785e6fe8b9c7b567150", "filename": "clippy_lints/src/unsafe_sizeof_count_copies.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1b80990fe01646868f85245f608203e23f64184a/clippy_lints%2Fsrc%2Funsafe_sizeof_count_copies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80990fe01646868f85245f608203e23f64184a/clippy_lints%2Fsrc%2Funsafe_sizeof_count_copies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_sizeof_count_copies.rs?ref=1b80990fe01646868f85245f608203e23f64184a", "patch": "@@ -41,8 +41,8 @@ declare_clippy_lint! {\n declare_lint_pass!(UnsafeSizeofCountCopies => [UNSAFE_SIZEOF_COUNT_COPIES]);\n \n fn get_size_of_ty(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<Ty<'tcx>> {\n-    match &expr.kind {\n-        ExprKind::Call(ref count_func, _func_args) => {\n+    match expr.kind {\n+        ExprKind::Call(count_func, _func_args) => {\n             if_chain! {\n                 if let ExprKind::Path(ref count_func_qpath) = count_func.kind;\n                 if let Some(def_id) = cx.qpath_res(count_func_qpath, count_func.hir_id).opt_def_id();\n@@ -56,21 +56,24 @@ fn get_size_of_ty(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<Ty<'tc\n             }\n         },\n         ExprKind::Binary(op, left, right) if BinOpKind::Mul == op.node || BinOpKind::Div == op.node => {\n-            get_size_of_ty(cx, &*left).or_else(|| get_size_of_ty(cx, &*right))\n+            get_size_of_ty(cx, left).or_else(|| get_size_of_ty(cx, right))\n         },\n         _ => None,\n     }\n }\n \n fn get_pointee_ty_and_count_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<(Ty<'tcx>, &'tcx Expr<'tcx>)> {\n     if_chain! {\n-        // Find calls to ptr::copy and copy_nonoverlapping\n-        if let ExprKind::Call(ref func, ref args) = expr.kind;\n-        if let [_src, _dest, count] = &**args;\n+        // Find calls to ptr::{copy, copy_nonoverlapping}\n+        // and ptr::{swap_nonoverlapping, write_bytes},\n+        if let ExprKind::Call(func, args) = expr.kind;\n+        if let [_, _, count] = args;\n         if let ExprKind::Path(ref func_qpath) = func.kind;\n         if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n         if match_def_path(cx, def_id, &paths::COPY_NONOVERLAPPING)\n-            || match_def_path(cx, def_id, &paths::COPY);\n+            || match_def_path(cx, def_id, &paths::COPY)\n+            || match_def_path(cx, def_id, &paths::WRITE_BYTES)\n+            || match_def_path(cx, def_id, &paths::PTR_SWAP_NONOVERLAPPING);\n \n         // Get the pointee type\n         if let Some(pointee_ty) = cx.typeck_results().node_substs(func.hir_id).types().next();\n@@ -79,11 +82,11 @@ fn get_pointee_ty_and_count_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -\n         }\n     };\n     if_chain! {\n-        // Find calls to copy_{from,to}{,_nonoverlapping}\n-        if let ExprKind::MethodCall(ref method_path, _, ref args, _) = expr.kind;\n-        if let [ptr_self, _, count] = &**args;\n+        // Find calls to copy_{from,to}{,_nonoverlapping} and write_bytes methods\n+        if let ExprKind::MethodCall(method_path, _, args, _) = expr.kind;\n+        if let [ptr_self, _, count] = args;\n         let method_ident = method_path.ident.as_str();\n-        if method_ident== \"copy_to\" || method_ident == \"copy_from\"\n+        if method_ident == \"write_bytes\" || method_ident == \"copy_to\" || method_ident == \"copy_from\"\n             || method_ident == \"copy_to_nonoverlapping\" || method_ident == \"copy_from_nonoverlapping\";\n \n         // Get the pointee type\n@@ -93,6 +96,21 @@ fn get_pointee_ty_and_count_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -\n             return Some((pointee_ty, count));\n         }\n     };\n+    if_chain! {\n+        // Find calls to ptr::copy and copy_nonoverlapping\n+        if let ExprKind::Call(func, args) = expr.kind;\n+        if let [_data, count] = args;\n+        if let ExprKind::Path(ref func_qpath) = func.kind;\n+        if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n+        if match_def_path(cx, def_id, &paths::PTR_SLICE_FROM_RAW_PARTS)\n+            || match_def_path(cx, def_id, &paths::PTR_SLICE_FROM_RAW_PARTS_MUT);\n+\n+        // Get the pointee type\n+        if let Some(pointee_ty) = cx.typeck_results().node_substs(func.hir_id).types().next();\n+        then {\n+            return Some((pointee_ty, count));\n+        }\n+    };\n     None\n }\n \n@@ -102,7 +120,7 @@ impl<'tcx> LateLintPass<'tcx> for UnsafeSizeofCountCopies {\n             for the count parameter, it already gets multiplied by the size of the pointed to type\";\n \n         const LINT_MSG: &str = \"unsafe memory copying using a byte count \\\n-            (Multiplied by size_of::<T>) instead of a count of T\";\n+            (multiplied by size_of/size_of_val::<T>) instead of a count of T\";\n \n         if_chain! {\n             // Find calls to unsafe copy functions and get"}, {"sha": "87c020a99dbdcd70e9b46af594aa7c3182aaab64", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b80990fe01646868f85245f608203e23f64184a/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80990fe01646868f85245f608203e23f64184a/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=1b80990fe01646868f85245f608203e23f64184a", "patch": "@@ -104,6 +104,9 @@ pub const POLL_READY: [&str; 5] = [\"core\", \"task\", \"poll\", \"Poll\", \"Ready\"];\n pub const PTR_EQ: [&str; 3] = [\"core\", \"ptr\", \"eq\"];\n pub const PTR_NULL: [&str; 3] = [\"core\", \"ptr\", \"null\"];\n pub const PTR_NULL_MUT: [&str; 3] = [\"core\", \"ptr\", \"null_mut\"];\n+pub const PTR_SLICE_FROM_RAW_PARTS: [&str; 3] = [\"core\", \"ptr\", \"slice_from_raw_parts\"];\n+pub const PTR_SLICE_FROM_RAW_PARTS_MUT: [&str; 3] = [\"core\", \"ptr\", \"slice_from_raw_parts_mut\"];\n+pub const PTR_SWAP_NONOVERLAPPING: [&str; 3] = [\"core\", \"ptr\", \"swap_nonoverlapping\"];\n pub const PUSH_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"push_str\"];\n pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n@@ -158,3 +161,4 @@ pub const VEC_NEW: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"new\"];\n pub const VEC_RESIZE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"resize\"];\n pub const WEAK_ARC: [&str; 3] = [\"alloc\", \"sync\", \"Weak\"];\n pub const WEAK_RC: [&str; 3] = [\"alloc\", \"rc\", \"Weak\"];\n+pub const WRITE_BYTES: [&str; 3] = [\"core\", \"intrinsics\", \"write_bytes\"];"}, {"sha": "6aed8c31f7eee8b4ededcc02d7d45718220e1d59", "filename": "tests/ui/unsafe_sizeof_count_copies.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b80990fe01646868f85245f608203e23f64184a/tests%2Fui%2Funsafe_sizeof_count_copies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b80990fe01646868f85245f608203e23f64184a/tests%2Fui%2Funsafe_sizeof_count_copies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funsafe_sizeof_count_copies.rs?ref=1b80990fe01646868f85245f608203e23f64184a", "patch": "@@ -1,7 +1,9 @@\n #![warn(clippy::unsafe_sizeof_count_copies)]\n \n use std::mem::{size_of, size_of_val};\n-use std::ptr::{copy, copy_nonoverlapping};\n+use std::ptr::{\n+    copy, copy_nonoverlapping, slice_from_raw_parts, slice_from_raw_parts_mut, swap_nonoverlapping, write_bytes,\n+};\n \n fn main() {\n     const SIZE: usize = 128;\n@@ -22,6 +24,14 @@ fn main() {\n     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>()) };\n     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0])) };\n \n+    unsafe { y.as_mut_ptr().write_bytes(0u8, size_of::<u8>() * SIZE) };\n+    unsafe { write_bytes(y.as_mut_ptr(), 0u8, size_of::<u8>() * SIZE) };\n+\n+    unsafe { swap_nonoverlapping(y.as_mut_ptr(), x.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+\n+    unsafe { slice_from_raw_parts_mut(y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+    unsafe { slice_from_raw_parts(y.as_ptr(), size_of::<u8>() * SIZE) };\n+\n     // Count expression involving multiplication of size_of (Should trigger the lint)\n     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0]) * SIZE) };"}, {"sha": "6f491bc4e4abffdc8a8cbfc3eca41f279d46e407", "filename": "tests/ui/unsafe_sizeof_count_copies.stderr", "status": "modified", "additions": 81, "deletions": 41, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/1b80990fe01646868f85245f608203e23f64184a/tests%2Fui%2Funsafe_sizeof_count_copies.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b80990fe01646868f85245f608203e23f64184a/tests%2Fui%2Funsafe_sizeof_count_copies.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funsafe_sizeof_count_copies.stderr?ref=1b80990fe01646868f85245f608203e23f64184a", "patch": "@@ -1,163 +1,203 @@\n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:14:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:16:14\n    |\n LL |     unsafe { copy_nonoverlapping::<u8>(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>()) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::unsafe-sizeof-count-copies` implied by `-D warnings`\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:15:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:17:14\n    |\n LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0])) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:17:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:19:14\n    |\n LL |     unsafe { x.as_ptr().copy_to(y.as_mut_ptr(), size_of::<u8>()) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:18:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:20:14\n    |\n LL |     unsafe { x.as_ptr().copy_to_nonoverlapping(y.as_mut_ptr(), size_of::<u8>()) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:19:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:21:14\n    |\n LL |     unsafe { y.as_mut_ptr().copy_from(x.as_ptr(), size_of::<u8>()) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:20:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:22:14\n    |\n LL |     unsafe { y.as_mut_ptr().copy_from_nonoverlapping(x.as_ptr(), size_of::<u8>()) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:22:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:24:14\n    |\n LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>()) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:23:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:25:14\n    |\n LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0])) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:26:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:27:14\n+   |\n+LL |     unsafe { y.as_mut_ptr().write_bytes(0u8, size_of::<u8>() * SIZE) };\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n+\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:28:14\n+   |\n+LL |     unsafe { write_bytes(y.as_mut_ptr(), 0u8, size_of::<u8>() * SIZE) };\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n+\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:30:14\n+   |\n+LL |     unsafe { swap_nonoverlapping(y.as_mut_ptr(), x.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n+\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:32:14\n+   |\n+LL |     unsafe { slice_from_raw_parts_mut(y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n+\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:33:14\n+   |\n+LL |     unsafe { slice_from_raw_parts(y.as_ptr(), size_of::<u8>() * SIZE) };\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n+\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:36:14\n    |\n LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:27:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:37:14\n    |\n LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0]) * SIZE) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:29:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:39:14\n    |\n LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:30:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:40:14\n    |\n LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0]) * SIZE) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:33:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:43:14\n    |\n LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * HALF_SIZE * 2) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:34:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:44:14\n    |\n LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), HALF_SIZE * size_of_val(&x[0]) * 2) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:36:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:46:14\n    |\n LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * SIZE * HALF_SIZE) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:37:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:47:14\n    |\n LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0]) * HALF_SIZE * 2) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:40:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:50:14\n    |\n LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), size_of::<u8>() * DOUBLE_SIZE / 2) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:41:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:51:14\n    |\n LL |     unsafe { copy_nonoverlapping(x.as_ptr(), y.as_mut_ptr(), DOUBLE_SIZE / 2 * size_of_val(&x[0])) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:43:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:53:14\n    |\n LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), DOUBLE_SIZE * size_of::<u8>() / 2) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: unsafe memory copying using a byte count (Multiplied by size_of::<T>) instead of a count of T\n-  --> $DIR/unsafe_sizeof_count_copies.rs:44:14\n+error: unsafe memory copying using a byte count (multiplied by size_of/size_of_val::<T>) instead of a count of T\n+  --> $DIR/unsafe_sizeof_count_copies.rs:54:14\n    |\n LL |     unsafe { copy(x.as_ptr(), y.as_mut_ptr(), size_of_val(&x[0]) * DOUBLE_SIZE / 2) };\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use a count of elements instead of a count of bytes for the count parameter, it already gets multiplied by the size of the pointed to type\n \n-error: aborting due to 20 previous errors\n+error: aborting due to 25 previous errors\n "}]}