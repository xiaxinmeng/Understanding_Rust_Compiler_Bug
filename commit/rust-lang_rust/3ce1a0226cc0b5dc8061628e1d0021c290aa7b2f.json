{"sha": "3ce1a0226cc0b5dc8061628e1d0021c290aa7b2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjZTFhMDIyNmNjMGI1ZGM4MDYxNjI4ZTFkMDAyMWMyOTBhYTdiMmY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-28T18:16:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-28T18:16:00Z"}, "message": "Merge #9422\n\n9422: fix: Handle `::{self}` imports r=jonas-schievink a=jonas-schievink\n\nThese import the preceding segment, but only in type namespace. Previously we've imported the name in all namespaces.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "78c950af40c0d6f966b6c5c5c3bcfb80a17bfcd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78c950af40c0d6f966b6c5c5c3bcfb80a17bfcd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ce1a0226cc0b5dc8061628e1d0021c290aa7b2f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg2hHgCRBK7hj4Ov3rIwAAUn0IAKEXqDMFYrMoBx+gnDViev26\nuKi4YR4zEFW0wguAZ60oPgHj7fl76+grw4Jk82pTQy9+vndO7BhzgqUAOGHY5EOw\nP17kii0+qEtjAO+Vb4ODYG691TDkWMveh4/sz0eigXCGm2MzU4MOJ7YniAryIzSK\nzt6qAtZmLGHlCZHQUhJaSW4cAG+8NzEz/BB8ebD0U2+d7IFSL063TeOyiM9M/ADr\n3DnRaUeLPdPoBVl6bOWhcf0eIiKTEWaMHgDFf7RJ1TqpLfAWkC32mVLCclMUkGIw\ntn1R4x6MXLGFRKFO7r72nSH1rv+AkfPXPIVyIKpgYnKohWw6DwKtFanE/08ULWI=\n=SsnJ\n-----END PGP SIGNATURE-----\n", "payload": "tree 78c950af40c0d6f966b6c5c5c3bcfb80a17bfcd9\nparent fa7bb38450732b0129ed5c3bccab50b033120380\nparent 3ebceb71e3151fb714705d21943b6b27dd5ac8d2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1624904160 +0000\ncommitter GitHub <noreply@github.com> 1624904160 +0000\n\nMerge #9422\n\n9422: fix: Handle `::{self}` imports r=jonas-schievink a=jonas-schievink\n\nThese import the preceding segment, but only in type namespace. Previously we've imported the name in all namespaces.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ce1a0226cc0b5dc8061628e1d0021c290aa7b2f", "html_url": "https://github.com/rust-lang/rust/commit/3ce1a0226cc0b5dc8061628e1d0021c290aa7b2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ce1a0226cc0b5dc8061628e1d0021c290aa7b2f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa7bb38450732b0129ed5c3bccab50b033120380", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa7bb38450732b0129ed5c3bccab50b033120380", "html_url": "https://github.com/rust-lang/rust/commit/fa7bb38450732b0129ed5c3bccab50b033120380"}, {"sha": "3ebceb71e3151fb714705d21943b6b27dd5ac8d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ebceb71e3151fb714705d21943b6b27dd5ac8d2", "html_url": "https://github.com/rust-lang/rust/commit/3ebceb71e3151fb714705d21943b6b27dd5ac8d2"}], "stats": {"total": 307, "additions": 175, "deletions": 132}, "files": [{"sha": "90129a790a1c873508f9e518d5c84412b70089e9", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3ce1a0226cc0b5dc8061628e1d0021c290aa7b2f/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce1a0226cc0b5dc8061628e1d0021c290aa7b2f/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=3ce1a0226cc0b5dc8061628e1d0021c290aa7b2f", "patch": "@@ -747,38 +747,46 @@ impl Import {\n     }\n }\n \n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+pub enum ImportKind {\n+    /// The `ModPath` is imported normally.\n+    Plain,\n+    /// This is a glob-import of all names in the `ModPath`.\n+    Glob,\n+    /// This is a `some::path::self` import, which imports `some::path` only in type namespace.\n+    TypeOnly,\n+}\n+\n impl UseTree {\n     /// Expands the `UseTree` into individually imported `ModPath`s.\n     pub fn expand(\n         &self,\n-        mut cb: impl FnMut(Idx<ast::UseTree>, ModPath, /* is_glob */ bool, Option<ImportAlias>),\n+        mut cb: impl FnMut(Idx<ast::UseTree>, ModPath, ImportKind, Option<ImportAlias>),\n     ) {\n         self.expand_impl(None, &mut cb)\n     }\n \n     fn expand_impl(\n         &self,\n         prefix: Option<ModPath>,\n-        cb: &mut dyn FnMut(\n-            Idx<ast::UseTree>,\n-            ModPath,\n-            /* is_glob */ bool,\n-            Option<ImportAlias>,\n-        ),\n+        cb: &mut dyn FnMut(Idx<ast::UseTree>, ModPath, ImportKind, Option<ImportAlias>),\n     ) {\n-        fn concat_mod_paths(prefix: Option<ModPath>, path: &ModPath) -> Option<ModPath> {\n+        fn concat_mod_paths(\n+            prefix: Option<ModPath>,\n+            path: &ModPath,\n+        ) -> Option<(ModPath, ImportKind)> {\n             match (prefix, &path.kind) {\n-                (None, _) => Some(path.clone()),\n+                (None, _) => Some((path.clone(), ImportKind::Plain)),\n                 (Some(mut prefix), PathKind::Plain) => {\n                     for segment in path.segments() {\n                         prefix.push_segment(segment.clone());\n                     }\n-                    Some(prefix)\n+                    Some((prefix, ImportKind::Plain))\n                 }\n                 (Some(prefix), PathKind::Super(0)) => {\n                     // `some::path::self` == `some::path`\n                     if path.segments().is_empty() {\n-                        Some(prefix)\n+                        Some((prefix, ImportKind::TypeOnly))\n                     } else {\n                         None\n                     }\n@@ -789,25 +797,25 @@ impl UseTree {\n \n         match &self.kind {\n             UseTreeKind::Single { path, alias } => {\n-                if let Some(path) = concat_mod_paths(prefix, path) {\n-                    cb(self.index, path, false, alias.clone());\n+                if let Some((path, kind)) = concat_mod_paths(prefix, path) {\n+                    cb(self.index, path, kind, alias.clone());\n                 }\n             }\n             UseTreeKind::Glob { path: Some(path) } => {\n-                if let Some(path) = concat_mod_paths(prefix, path) {\n-                    cb(self.index, path, true, None);\n+                if let Some((path, _)) = concat_mod_paths(prefix, path) {\n+                    cb(self.index, path, ImportKind::Glob, None);\n                 }\n             }\n             UseTreeKind::Glob { path: None } => {\n                 if let Some(prefix) = prefix {\n-                    cb(self.index, prefix, true, None);\n+                    cb(self.index, prefix, ImportKind::Glob, None);\n                 }\n             }\n             UseTreeKind::Prefixed { prefix: additional_prefix, list } => {\n                 let prefix = match additional_prefix {\n                     Some(path) => match concat_mod_paths(prefix, path) {\n-                        Some(path) => Some(path),\n-                        None => return,\n+                        Some((path, ImportKind::Plain)) => Some(path),\n+                        _ => return,\n                     },\n                     None => prefix,\n                 };"}, {"sha": "f4f481f4dc04bf378f3b0b2e1905429003442813", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 125, "deletions": 113, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/3ce1a0226cc0b5dc8061628e1d0021c290aa7b2f/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce1a0226cc0b5dc8061628e1d0021c290aa7b2f/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=3ce1a0226cc0b5dc8061628e1d0021c290aa7b2f", "patch": "@@ -30,8 +30,8 @@ use crate::{\n     intern::Interned,\n     item_scope::{ImportType, PerNsGlobImports},\n     item_tree::{\n-        self, Fields, FileItemTreeId, ItemTree, ItemTreeId, MacroCall, MacroDef, MacroRules, Mod,\n-        ModItem, ModKind,\n+        self, Fields, FileItemTreeId, ImportKind, ItemTree, ItemTreeId, MacroCall, MacroDef,\n+        MacroRules, Mod, ModItem, ModKind,\n     },\n     macro_call_as_call_id,\n     nameres::{\n@@ -146,7 +146,7 @@ struct Import {\n     path: Interned<ModPath>,\n     alias: Option<ImportAlias>,\n     visibility: RawVisibility,\n-    is_glob: bool,\n+    kind: ImportKind,\n     is_prelude: bool,\n     is_extern_crate: bool,\n     is_macro_use: bool,\n@@ -166,12 +166,12 @@ impl Import {\n         let is_prelude = attrs.by_key(\"prelude_import\").exists();\n \n         let mut res = Vec::new();\n-        it.use_tree.expand(|idx, path, is_glob, alias| {\n+        it.use_tree.expand(|idx, path, kind, alias| {\n             res.push(Self {\n                 path: Interned::new(path), // FIXME this makes little sense\n                 alias,\n                 visibility: visibility.clone(),\n-                is_glob,\n+                kind,\n                 is_prelude,\n                 is_extern_crate: false,\n                 is_macro_use: false,\n@@ -197,7 +197,7 @@ impl Import {\n             )),\n             alias: it.alias.clone(),\n             visibility: visibility.clone(),\n-            is_glob: false,\n+            kind: ImportKind::Plain,\n             is_prelude: false,\n             is_extern_crate: true,\n             is_macro_use: attrs.by_key(\"macro_use\").exists(),\n@@ -767,127 +767,139 @@ impl DefCollector<'_> {\n     fn record_resolved_import(&mut self, directive: &ImportDirective) {\n         let module_id = directive.module_id;\n         let import = &directive.import;\n-        let def = directive.status.namespaces();\n+        let mut def = directive.status.namespaces();\n         let vis = self\n             .def_map\n             .resolve_visibility(self.db, module_id, &directive.import.visibility)\n             .unwrap_or(Visibility::Public);\n \n-        if import.is_glob {\n-            log::debug!(\"glob import: {:?}\", import);\n-            match def.take_types() {\n-                Some(ModuleDefId::ModuleId(m)) => {\n-                    if import.is_prelude {\n-                        // Note: This dodgily overrides the injected prelude. The rustc\n-                        // implementation seems to work the same though.\n-                        cov_mark::hit!(std_prelude);\n-                        self.def_map.prelude = Some(m);\n-                    } else if m.krate != self.def_map.krate {\n-                        cov_mark::hit!(glob_across_crates);\n-                        // glob import from other crate => we can just import everything once\n-                        let item_map = m.def_map(self.db);\n-                        let scope = &item_map[m.local_id].scope;\n-\n-                        // Module scoped macros is included\n-                        let items = scope\n-                            .resolutions()\n-                            // only keep visible names...\n-                            .map(|(n, res)| {\n-                                (n, res.filter_visibility(|v| v.is_visible_from_other_crate()))\n-                            })\n-                            .filter(|(_, res)| !res.is_none())\n-                            .collect::<Vec<_>>();\n+        match import.kind {\n+            ImportKind::Plain | ImportKind::TypeOnly => {\n+                let name = match &import.alias {\n+                    Some(ImportAlias::Alias(name)) => Some(name.clone()),\n+                    Some(ImportAlias::Underscore) => None,\n+                    None => match import.path.segments().last() {\n+                        Some(last_segment) => Some(last_segment.clone()),\n+                        None => {\n+                            cov_mark::hit!(bogus_paths);\n+                            return;\n+                        }\n+                    },\n+                };\n \n-                        self.update(module_id, &items, vis, ImportType::Glob);\n-                    } else {\n-                        // glob import from same crate => we do an initial\n-                        // import, and then need to propagate any further\n-                        // additions\n-                        let def_map;\n-                        let scope = if m.block == self.def_map.block_id() {\n-                            &self.def_map[m.local_id].scope\n-                        } else {\n-                            def_map = m.def_map(self.db);\n-                            &def_map[m.local_id].scope\n-                        };\n-\n-                        // Module scoped macros is included\n-                        let items = scope\n-                            .resolutions()\n-                            // only keep visible names...\n-                            .map(|(n, res)| {\n-                                (\n-                                    n,\n-                                    res.filter_visibility(|v| {\n-                                        v.is_visible_from_def_map(self.db, &self.def_map, module_id)\n-                                    }),\n-                                )\n-                            })\n-                            .filter(|(_, res)| !res.is_none())\n-                            .collect::<Vec<_>>();\n+                if import.kind == ImportKind::TypeOnly {\n+                    def.values = None;\n+                    def.macros = None;\n+                }\n \n-                        self.update(module_id, &items, vis, ImportType::Glob);\n-                        // record the glob import in case we add further items\n-                        let glob = self.glob_imports.entry(m.local_id).or_default();\n-                        if !glob.iter().any(|(mid, _)| *mid == module_id) {\n-                            glob.push((module_id, vis));\n-                        }\n+                log::debug!(\"resolved import {:?} ({:?}) to {:?}\", name, import, def);\n+\n+                // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n+                if import.is_extern_crate && module_id == self.def_map.root {\n+                    if let (Some(def), Some(name)) = (def.take_types(), name.as_ref()) {\n+                        self.def_map.extern_prelude.insert(name.clone(), def);\n                     }\n                 }\n-                Some(ModuleDefId::AdtId(AdtId::EnumId(e))) => {\n-                    cov_mark::hit!(glob_enum);\n-                    // glob import from enum => just import all the variants\n-\n-                    // XXX: urgh, so this works by accident! Here, we look at\n-                    // the enum data, and, in theory, this might require us to\n-                    // look back at the crate_def_map, creating a cycle. For\n-                    // example, `enum E { crate::some_macro!(); }`. Luckily, the\n-                    // only kind of macro that is allowed inside enum is a\n-                    // `cfg_macro`, and we don't need to run name resolution for\n-                    // it, but this is sheer luck!\n-                    let enum_data = self.db.enum_data(e);\n-                    let resolutions = enum_data\n-                        .variants\n-                        .iter()\n-                        .map(|(local_id, variant_data)| {\n-                            let name = variant_data.name.clone();\n-                            let variant = EnumVariantId { parent: e, local_id };\n-                            let res = PerNs::both(variant.into(), variant.into(), vis);\n-                            (Some(name), res)\n-                        })\n-                        .collect::<Vec<_>>();\n-                    self.update(module_id, &resolutions, vis, ImportType::Glob);\n-                }\n-                Some(d) => {\n-                    log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n-                }\n-                None => {\n-                    log::debug!(\"glob import {:?} didn't resolve as type\", import);\n-                }\n+\n+                self.update(module_id, &[(name, def)], vis, ImportType::Named);\n             }\n-        } else {\n-            let name = match &import.alias {\n-                Some(ImportAlias::Alias(name)) => Some(name.clone()),\n-                Some(ImportAlias::Underscore) => None,\n-                None => match import.path.segments().last() {\n-                    Some(last_segment) => Some(last_segment.clone()),\n+            ImportKind::Glob => {\n+                log::debug!(\"glob import: {:?}\", import);\n+                match def.take_types() {\n+                    Some(ModuleDefId::ModuleId(m)) => {\n+                        if import.is_prelude {\n+                            // Note: This dodgily overrides the injected prelude. The rustc\n+                            // implementation seems to work the same though.\n+                            cov_mark::hit!(std_prelude);\n+                            self.def_map.prelude = Some(m);\n+                        } else if m.krate != self.def_map.krate {\n+                            cov_mark::hit!(glob_across_crates);\n+                            // glob import from other crate => we can just import everything once\n+                            let item_map = m.def_map(self.db);\n+                            let scope = &item_map[m.local_id].scope;\n+\n+                            // Module scoped macros is included\n+                            let items = scope\n+                                .resolutions()\n+                                // only keep visible names...\n+                                .map(|(n, res)| {\n+                                    (n, res.filter_visibility(|v| v.is_visible_from_other_crate()))\n+                                })\n+                                .filter(|(_, res)| !res.is_none())\n+                                .collect::<Vec<_>>();\n+\n+                            self.update(module_id, &items, vis, ImportType::Glob);\n+                        } else {\n+                            // glob import from same crate => we do an initial\n+                            // import, and then need to propagate any further\n+                            // additions\n+                            let def_map;\n+                            let scope = if m.block == self.def_map.block_id() {\n+                                &self.def_map[m.local_id].scope\n+                            } else {\n+                                def_map = m.def_map(self.db);\n+                                &def_map[m.local_id].scope\n+                            };\n+\n+                            // Module scoped macros is included\n+                            let items = scope\n+                                .resolutions()\n+                                // only keep visible names...\n+                                .map(|(n, res)| {\n+                                    (\n+                                        n,\n+                                        res.filter_visibility(|v| {\n+                                            v.is_visible_from_def_map(\n+                                                self.db,\n+                                                &self.def_map,\n+                                                module_id,\n+                                            )\n+                                        }),\n+                                    )\n+                                })\n+                                .filter(|(_, res)| !res.is_none())\n+                                .collect::<Vec<_>>();\n+\n+                            self.update(module_id, &items, vis, ImportType::Glob);\n+                            // record the glob import in case we add further items\n+                            let glob = self.glob_imports.entry(m.local_id).or_default();\n+                            if !glob.iter().any(|(mid, _)| *mid == module_id) {\n+                                glob.push((module_id, vis));\n+                            }\n+                        }\n+                    }\n+                    Some(ModuleDefId::AdtId(AdtId::EnumId(e))) => {\n+                        cov_mark::hit!(glob_enum);\n+                        // glob import from enum => just import all the variants\n+\n+                        // XXX: urgh, so this works by accident! Here, we look at\n+                        // the enum data, and, in theory, this might require us to\n+                        // look back at the crate_def_map, creating a cycle. For\n+                        // example, `enum E { crate::some_macro!(); }`. Luckily, the\n+                        // only kind of macro that is allowed inside enum is a\n+                        // `cfg_macro`, and we don't need to run name resolution for\n+                        // it, but this is sheer luck!\n+                        let enum_data = self.db.enum_data(e);\n+                        let resolutions = enum_data\n+                            .variants\n+                            .iter()\n+                            .map(|(local_id, variant_data)| {\n+                                let name = variant_data.name.clone();\n+                                let variant = EnumVariantId { parent: e, local_id };\n+                                let res = PerNs::both(variant.into(), variant.into(), vis);\n+                                (Some(name), res)\n+                            })\n+                            .collect::<Vec<_>>();\n+                        self.update(module_id, &resolutions, vis, ImportType::Glob);\n+                    }\n+                    Some(d) => {\n+                        log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n+                    }\n                     None => {\n-                        cov_mark::hit!(bogus_paths);\n-                        return;\n+                        log::debug!(\"glob import {:?} didn't resolve as type\", import);\n                     }\n-                },\n-            };\n-\n-            log::debug!(\"resolved import {:?} ({:?}) to {:?}\", name, import, def);\n-\n-            // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n-            if import.is_extern_crate && module_id == self.def_map.root {\n-                if let (Some(def), Some(name)) = (def.take_types(), name.as_ref()) {\n-                    self.def_map.extern_prelude.insert(name.clone(), def);\n                 }\n             }\n-\n-            self.update(module_id, &[(name, def)], vis, ImportType::Named);\n         }\n     }\n "}, {"sha": "09f121c7ec2f7bfe134915e7f095f51bc605cae3", "filename": "crates/hir_def/src/nameres/tests.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ce1a0226cc0b5dc8061628e1d0021c290aa7b2f/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ce1a0226cc0b5dc8061628e1d0021c290aa7b2f/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=3ce1a0226cc0b5dc8061628e1d0021c290aa7b2f", "patch": "@@ -329,7 +329,7 @@ pub struct Baz;\n \"#,\n         expect![[r#\"\n             crate\n-            Baz: t v\n+            Baz: t\n             foo: t\n \n             crate::foo\n@@ -816,3 +816,26 @@ fn bar() {}\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn self_imports_only_types() {\n+    check(\n+        r#\"\n+//- /main.rs\n+mod m {\n+    pub macro S() {}\n+    pub struct S;\n+}\n+\n+use self::m::S::{self};\n+    \"#,\n+        expect![[r#\"\n+            crate\n+            S: t\n+            m: t\n+\n+            crate::m\n+            S: t v m\n+        \"#]],\n+    );\n+}"}]}