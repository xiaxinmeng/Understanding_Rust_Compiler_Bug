{"sha": "53498eca50e25d8a11f9dc5859770715fa906fa7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNDk4ZWNhNTBlMjVkOGExMWY5ZGM1ODU5NzcwNzE1ZmE5MDZmYTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-01T06:31:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-01T06:31:58Z"}, "message": "Auto merge of #32635 - gereeter:hashmap-iter-variance, r=alexcrichton\n\nMake HashMap, HashSet, and their iterators properly covariant\n\nSee #30642. `Drain` is the only type left invariant.", "tree": {"sha": "53d281bae20e5c72a57a8a07a38b7976d29d517d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53d281bae20e5c72a57a8a07a38b7976d29d517d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53498eca50e25d8a11f9dc5859770715fa906fa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53498eca50e25d8a11f9dc5859770715fa906fa7", "html_url": "https://github.com/rust-lang/rust/commit/53498eca50e25d8a11f9dc5859770715fa906fa7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53498eca50e25d8a11f9dc5859770715fa906fa7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b342fae8e8a0704e2acbd8ecc3e7ad06ce5eec6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b342fae8e8a0704e2acbd8ecc3e7ad06ce5eec6", "html_url": "https://github.com/rust-lang/rust/commit/3b342fae8e8a0704e2acbd8ecc3e7ad06ce5eec6"}, {"sha": "589108baf644ea44a10a7258d67da254e1e09fae", "url": "https://api.github.com/repos/rust-lang/rust/commits/589108baf644ea44a10a7258d67da254e1e09fae", "html_url": "https://github.com/rust-lang/rust/commit/589108baf644ea44a10a7258d67da254e1e09fae"}], "stats": {"total": 116, "additions": 72, "deletions": 44}, "files": [{"sha": "80b5448800e348b53957e8f4bc450b891765457c", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/53498eca50e25d8a11f9dc5859770715fa906fa7/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53498eca50e25d8a11f9dc5859770715fa906fa7/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=53498eca50e25d8a11f9dc5859770715fa906fa7", "patch": "@@ -15,7 +15,7 @@ use borrow::Borrow;\n use cmp::max;\n use fmt::{self, Debug};\n use hash::{Hash, SipHasher, BuildHasher};\n-use iter::{self, Map, FromIterator};\n+use iter::FromIterator;\n use mem::{self, replace};\n use ops::{Deref, Index};\n use rand::{self, Rng};\n@@ -836,8 +836,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n-        Keys { inner: self.iter().map(first) }\n+        Keys { inner: self.iter() }\n     }\n \n     /// An iterator visiting all values in arbitrary order.\n@@ -859,8 +858,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n-        fn second<A, B>((_, b): (A, B)) -> B { b }\n-        Values { inner: self.iter().map(second) }\n+        Values { inner: self.iter() }\n     }\n \n     /// An iterator visiting all key-value pairs in arbitrary order.\n@@ -992,9 +990,8 @@ impl<K, V, S> HashMap<K, V, S>\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain(&mut self) -> Drain<K, V> {\n-        fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n         Drain {\n-            inner: self.table.drain().map(last_two),\n+            inner: self.table.drain(),\n         }\n     }\n \n@@ -1224,13 +1221,13 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n /// HashMap move iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n-    inner: iter::Map<table::IntoIter<K, V>, fn((SafeHash, K, V)) -> (K, V)>\n+    inner: table::IntoIter<K, V>\n }\n \n /// HashMap keys iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n-    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+    inner: Iter<'a, K, V>\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -1246,7 +1243,7 @@ impl<'a, K, V> Clone for Keys<'a, K, V> {\n /// HashMap values iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n-    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+    inner: Iter<'a, K, V>\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -1262,7 +1259,7 @@ impl<'a, K, V> Clone for Values<'a, K, V> {\n /// HashMap drain iterator.\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<'a, K: 'a, V: 'a> {\n-    inner: iter::Map<table::Drain<'a, K, V>, fn((SafeHash, K, V)) -> (K, V)>\n+    inner: table::Drain<'a, K, V>\n }\n \n enum InternalEntry<K, V, M> {\n@@ -1397,9 +1394,8 @@ impl<K, V, S> IntoIterator for HashMap<K, V, S>\n     /// let vec: Vec<(&str, isize)> = map.into_iter().collect();\n     /// ```\n     fn into_iter(self) -> IntoIter<K, V> {\n-        fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n         IntoIter {\n-            inner: self.table.into_iter().map(last_two)\n+            inner: self.table.into_iter()\n         }\n     }\n }\n@@ -1432,7 +1428,7 @@ impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n-    #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n+    #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next().map(|(_, k, v)| (k, v)) }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1444,7 +1440,7 @@ impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n-    #[inline] fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n+    #[inline] fn next(&mut self) -> Option<(&'a K)> { self.inner.next().map(|(k, _)| k) }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1456,7 +1452,7 @@ impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n-    #[inline] fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n+    #[inline] fn next(&mut self) -> Option<(&'a V)> { self.inner.next().map(|(_, v)| v) }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1468,7 +1464,7 @@ impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n impl<'a, K, V> Iterator for Drain<'a, K, V> {\n     type Item = (K, V);\n \n-    #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n+    #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next().map(|(_, k, v)| (k, v)) }\n     #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1674,6 +1670,20 @@ impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n     }\n }\n \n+#[allow(dead_code)]\n+fn assert_covariance() {\n+    fn map_key<'new>(v: HashMap<&'static str, u8>) -> HashMap<&'new str, u8> { v }\n+    fn map_val<'new>(v: HashMap<u8, &'static str>) -> HashMap<u8, &'new str> { v }\n+    fn iter_key<'a, 'new>(v: Iter<'a, &'static str, u8>) -> Iter<'a, &'new str, u8> { v }\n+    fn iter_val<'a, 'new>(v: Iter<'a, u8, &'static str>) -> Iter<'a, u8, &'new str> { v }\n+    fn into_iter_key<'new>(v: IntoIter<&'static str, u8>) -> IntoIter<&'new str, u8> { v }\n+    fn into_iter_val<'new>(v: IntoIter<u8, &'static str>) -> IntoIter<u8, &'new str> { v }\n+    fn keys_key<'a, 'new>(v: Keys<'a, &'static str, u8>) -> Keys<'a, &'new str, u8> { v }\n+    fn keys_val<'a, 'new>(v: Keys<'a, u8, &'static str>) -> Keys<'a, u8, &'new str> { v }\n+    fn values_key<'a, 'new>(v: Values<'a, &'static str, u8>) -> Values<'a, &'new str, u8> { v }\n+    fn values_val<'a, 'new>(v: Values<'a, u8, &'static str>) -> Values<'a, u8, &'new str> { v }\n+}\n+\n #[cfg(test)]\n mod test_map {\n     use prelude::v1::*;"}, {"sha": "954adf313be0db086de984ac1f8797ff1e2ff90f", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/53498eca50e25d8a11f9dc5859770715fa906fa7/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53498eca50e25d8a11f9dc5859770715fa906fa7/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=53498eca50e25d8a11f9dc5859770715fa906fa7", "patch": "@@ -11,7 +11,7 @@\n use borrow::Borrow;\n use fmt;\n use hash::{Hash, BuildHasher};\n-use iter::{Map, Chain, FromIterator};\n+use iter::{Chain, FromIterator};\n use ops::{BitOr, BitAnd, BitXor, Sub};\n \n use super::Recover;\n@@ -414,8 +414,7 @@ impl<T, S> HashSet<T, S>\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain(&mut self) -> Drain<T> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n-        Drain { iter: self.map.drain().map(first) }\n+        Drain { iter: self.map.drain() }\n     }\n \n     /// Clears the set, removing all values.\n@@ -809,13 +808,13 @@ pub struct Iter<'a, K: 'a> {\n /// HashSet move iterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K> {\n-    iter: Map<map::IntoIter<K, ()>, fn((K, ())) -> K>\n+    iter: map::IntoIter<K, ()>\n }\n \n /// HashSet drain iterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Drain<'a, K: 'a> {\n-    iter: Map<map::Drain<'a, K, ()>, fn((K, ())) -> K>,\n+    iter: map::Drain<'a, K, ()>,\n }\n \n /// Intersection iterator\n@@ -889,8 +888,7 @@ impl<T, S> IntoIterator for HashSet<T, S>\n     /// }\n     /// ```\n     fn into_iter(self) -> IntoIter<T> {\n-        fn first<A, B>((a, _): (A, B)) -> A { a }\n-        IntoIter { iter: self.map.into_iter().map(first) }\n+        IntoIter { iter: self.map.into_iter() }\n     }\n }\n \n@@ -914,7 +912,7 @@ impl<'a, K> ExactSizeIterator for Iter<'a, K> {\n impl<K> Iterator for IntoIter<K> {\n     type Item = K;\n \n-    fn next(&mut self) -> Option<K> { self.iter.next() }\n+    fn next(&mut self) -> Option<K> { self.iter.next().map(|(k, _)| k) }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -926,7 +924,7 @@ impl<K> ExactSizeIterator for IntoIter<K> {\n impl<'a, K> Iterator for Drain<'a, K> {\n     type Item = K;\n \n-    fn next(&mut self) -> Option<K> { self.iter.next() }\n+    fn next(&mut self) -> Option<K> { self.iter.next().map(|(k, _)| k) }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1026,6 +1024,21 @@ impl<'a, T, S> Iterator for Union<'a, T, S>\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n+#[allow(dead_code)]\n+fn assert_covariance() {\n+    fn set<'new>(v: HashSet<&'static str>) -> HashSet<&'new str> { v }\n+    fn iter<'a, 'new>(v: Iter<'a, &'static str>) -> Iter<'a, &'new str> { v }\n+    fn into_iter<'new>(v: IntoIter<&'static str>) -> IntoIter<&'new str> { v }\n+    fn difference<'a, 'new>(v: Difference<'a, &'static str, RandomState>)\n+        -> Difference<'a, &'new str, RandomState> { v }\n+    fn symmetric_difference<'a, 'new>(v: SymmetricDifference<'a, &'static str, RandomState>)\n+        -> SymmetricDifference<'a, &'new str, RandomState> { v }\n+    fn intersection<'a, 'new>(v: Intersection<'a, &'static str, RandomState>)\n+        -> Intersection<'a, &'new str, RandomState> { v }\n+    fn union<'a, 'new>(v: Union<'a, &'static str, RandomState>)\n+        -> Union<'a, &'new str, RandomState> { v }\n+}\n+\n #[cfg(test)]\n mod test_set {\n     use prelude::v1::*;"}, {"sha": "cf64e5d333639c5f11d88b854bcfa418cc81029b", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/53498eca50e25d8a11f9dc5859770715fa906fa7/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53498eca50e25d8a11f9dc5859770715fa906fa7/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=53498eca50e25d8a11f9dc5859770715fa906fa7", "patch": "@@ -75,8 +75,10 @@ unsafe impl<K: Sync, V: Sync> Sync for RawTable<K, V> {}\n \n struct RawBucket<K, V> {\n     hash: *mut u64,\n-    key:  *mut K,\n-    val:  *mut V,\n+\n+    // We use *const to ensure covariance with respect to K and V\n+    key:  *const K,\n+    val:  *const V,\n     _marker: marker::PhantomData<(K,V)>,\n }\n \n@@ -354,8 +356,8 @@ impl<K, V, M> EmptyBucket<K, V, M> where M: Put<K, V> {\n                -> FullBucket<K, V, M> {\n         unsafe {\n             *self.raw.hash = hash.inspect();\n-            ptr::write(self.raw.key, key);\n-            ptr::write(self.raw.val, value);\n+            ptr::write(self.raw.key as *mut K, key);\n+            ptr::write(self.raw.val as *mut V, value);\n \n             self.table.borrow_table_mut().size += 1;\n         }\n@@ -453,8 +455,8 @@ impl<K, V, M> FullBucket<K, V, M> where M: Put<K, V> {\n     pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) {\n         unsafe {\n             let old_hash = ptr::replace(self.raw.hash as *mut SafeHash, h);\n-            let old_key  = ptr::replace(self.raw.key,  k);\n-            let old_val  = ptr::replace(self.raw.val,  v);\n+            let old_key  = ptr::replace(self.raw.key as *mut K,  k);\n+            let old_val  = ptr::replace(self.raw.val as *mut V,  v);\n \n             (old_hash, old_key, old_val)\n         }\n@@ -465,8 +467,8 @@ impl<K, V, M> FullBucket<K, V, M> where M: Deref<Target=RawTable<K, V>> + DerefM\n     /// Gets mutable references to the key and value at a given index.\n     pub fn read_mut(&mut self) -> (&mut K, &mut V) {\n         unsafe {\n-            (&mut *self.raw.key,\n-             &mut *self.raw.val)\n+            (&mut *(self.raw.key as *mut K),\n+             &mut *(self.raw.val as *mut V))\n         }\n     }\n }\n@@ -490,8 +492,8 @@ impl<'t, K, V, M> FullBucket<K, V, M> where M: Deref<Target=RawTable<K, V>> + De\n     /// for mutable references into the table.\n     pub fn into_mut_refs(self) -> (&'t mut K, &'t mut V) {\n         unsafe {\n-            (&mut *self.raw.key,\n-             &mut *self.raw.val)\n+            (&mut *(self.raw.key as *mut K),\n+             &mut *(self.raw.val as *mut V))\n         }\n     }\n }\n@@ -505,8 +507,8 @@ impl<K, V, M> GapThenFull<K, V, M> where M: Deref<Target=RawTable<K, V>> {\n     pub fn shift(mut self) -> Option<GapThenFull<K, V, M>> {\n         unsafe {\n             *self.gap.raw.hash = mem::replace(&mut *self.full.raw.hash, EMPTY_BUCKET);\n-            ptr::copy_nonoverlapping(self.full.raw.key, self.gap.raw.key, 1);\n-            ptr::copy_nonoverlapping(self.full.raw.val, self.gap.raw.val, 1);\n+            ptr::copy_nonoverlapping(self.full.raw.key, self.gap.raw.key as *mut K, 1);\n+            ptr::copy_nonoverlapping(self.full.raw.val, self.gap.raw.val as *mut V, 1);\n         }\n \n         let FullBucket { raw: prev_raw, idx: prev_idx, .. } = self.full;\n@@ -649,7 +651,7 @@ impl<K, V> RawTable<K, V> {\n         let hashes_size = self.capacity * size_of::<u64>();\n         let keys_size = self.capacity * size_of::<K>();\n \n-        let buffer = *self.hashes as *mut u8;\n+        let buffer = *self.hashes as *const u8;\n         let (keys_offset, vals_offset, oflo) =\n             calculate_offsets(hashes_size,\n                               keys_size, align_of::<K>(),\n@@ -658,8 +660,8 @@ impl<K, V> RawTable<K, V> {\n         unsafe {\n             RawBucket {\n                 hash: *self.hashes,\n-                key:  buffer.offset(keys_offset as isize) as *mut K,\n-                val:  buffer.offset(vals_offset as isize) as *mut V,\n+                key:  buffer.offset(keys_offset as isize) as *const K,\n+                val:  buffer.offset(vals_offset as isize) as *const V,\n                 _marker: marker::PhantomData,\n             }\n         }\n@@ -707,6 +709,7 @@ impl<K, V> RawTable<K, V> {\n         IterMut {\n             iter: self.raw_buckets(),\n             elems_left: self.size(),\n+            _marker: marker::PhantomData,\n         }\n     }\n \n@@ -858,6 +861,8 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'a, K, V>,\n     elems_left: usize,\n+    // To ensure invariance with respect to V\n+    _marker: marker::PhantomData<&'a mut V>,\n }\n \n unsafe impl<'a, K: Sync, V: Sync> Sync for IterMut<'a, K, V> {}\n@@ -912,7 +917,7 @@ impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n             self.elems_left -= 1;\n             unsafe {\n                 (&*bucket.key,\n-                 &mut *bucket.val)\n+                 &mut *(bucket.val as *mut V))\n             }\n         })\n     }\n@@ -1003,8 +1008,8 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n                                 (full.hash(), k.clone(), v.clone())\n                             };\n                             *new_buckets.raw.hash = h.inspect();\n-                            ptr::write(new_buckets.raw.key, k);\n-                            ptr::write(new_buckets.raw.val, v);\n+                            ptr::write(new_buckets.raw.key as *mut K, k);\n+                            ptr::write(new_buckets.raw.val as *mut V, v);\n                         }\n                         Empty(..) => {\n                             *new_buckets.raw.hash = EMPTY_BUCKET;"}]}