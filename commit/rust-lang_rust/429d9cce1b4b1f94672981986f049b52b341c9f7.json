{"sha": "429d9cce1b4b1f94672981986f049b52b341c9f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyOWQ5Y2NlMWI0YjFmOTQ2NzI5ODE5ODZmMDQ5YjUyYjM0MWM5Zjc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-02T08:57:50Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-03T12:00:51Z"}, "message": "Be more tolerant of errors in EUV so we can run it during typeck.", "tree": {"sha": "5b0f2db05cc51c1c6b24aed925c3d3b88074309a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b0f2db05cc51c1c6b24aed925c3d3b88074309a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/429d9cce1b4b1f94672981986f049b52b341c9f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/429d9cce1b4b1f94672981986f049b52b341c9f7", "html_url": "https://github.com/rust-lang/rust/commit/429d9cce1b4b1f94672981986f049b52b341c9f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/429d9cce1b4b1f94672981986f049b52b341c9f7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c54d862b858399c2990f9eaba963fb19bfa9c6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c54d862b858399c2990f9eaba963fb19bfa9c6a", "html_url": "https://github.com/rust-lang/rust/commit/9c54d862b858399c2990f9eaba963fb19bfa9c6a"}], "stats": {"total": 58, "additions": 41, "deletions": 17}, "files": [{"sha": "7dbf797e7392ce7a3c414a7248aa286d238f412d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/429d9cce1b4b1f94672981986f049b52b341c9f7/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/429d9cce1b4b1f94672981986f049b52b341c9f7/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=429d9cce1b4b1f94672981986f049b52b341c9f7", "patch": "@@ -673,6 +673,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     }\n                 }\n             }\n+            ty::ty_err => { }\n             _ => {\n                 let overloaded_call_type =\n                     match self.typer.node_method_origin(MethodCall::expr(call.id)) {\n@@ -792,9 +793,17 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 ty::struct_fields(self.tcx(), did, substs)\n             }\n             _ => {\n-                self.tcx().sess.span_bug(\n-                    with_expr.span,\n-                    \"with expression doesn't evaluate to a struct\");\n+                // the base expression should always evaluate to a\n+                // struct; however, when EUV is run during typeck, it\n+                // may not. This will generate an error earlier in typeck,\n+                // so we can just ignore it.\n+                if !self.tcx().sess.has_errors() {\n+                    self.tcx().sess.span_bug(\n+                        with_expr.span,\n+                        \"with expression doesn't evaluate to a struct\");\n+                }\n+                assert!(self.tcx().sess.has_errors());\n+                vec!()\n             }\n         };\n \n@@ -1004,8 +1013,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         debug!(\"determine_pat_move_mode cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n                pat.repr(self.tcx()));\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n-            let tcx = self.typer.tcx();\n-            let def_map = &self.typer.tcx().def_map;\n+            let tcx = self.tcx();\n+            let def_map = &self.tcx().def_map;\n             if pat_util::pat_is_binding(def_map, pat) {\n                 match pat.node {\n                     ast::PatIdent(ast::BindByRef(_), _, _) =>\n@@ -1041,7 +1050,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n         let mc = &self.mc;\n         let typer = self.typer;\n-        let def_map = &self.typer.tcx().def_map;\n+        let def_map = &self.tcx().def_map;\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n             if pat_util::pat_is_binding(def_map, pat) {\n@@ -1058,8 +1067,12 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n                 let def = def_map.borrow()[pat.id].clone();\n-                let binding_cmt = mc.cat_def(pat.id, pat.span, pat_ty, def);\n-                delegate.mutate(pat.id, pat.span, binding_cmt, Init);\n+                match mc.cat_def(pat.id, pat.span, pat_ty, def) {\n+                    Ok(binding_cmt) => {\n+                        delegate.mutate(pat.id, pat.span, binding_cmt, Init);\n+                    }\n+                    Err(_) => { }\n+                }\n \n                 // It is also a borrow or copy/move of the value being matched.\n                 match pat.node {\n@@ -1080,7 +1093,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         delegate.consume_pat(pat, cmt_pat, mode);\n                     }\n                     _ => {\n-                        typer.tcx().sess.span_bug(\n+                        tcx.sess.span_bug(\n                             pat.span,\n                             \"binding pattern not an identifier\");\n                     }\n@@ -1181,17 +1194,29 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                             // An enum's type -- should never be in a\n                             // pattern.\n \n-                            let msg = format!(\"Pattern has unexpected type: {}\", def);\n-                            tcx.sess.span_bug(pat.span, msg[])\n+                            if !tcx.sess.has_errors() {\n+                                let msg = format!(\"Pattern has unexpected type: {} and type {}\",\n+                                                  def,\n+                                                  cmt_pat.ty.repr(tcx));\n+                                tcx.sess.span_bug(pat.span, msg[])\n+                            }\n                         }\n \n                         Some(def) => {\n                             // Remaining cases are e.g. DefFn, to\n                             // which identifiers within patterns\n-                            // should not resolve.\n-\n-                            let msg = format!(\"Pattern has unexpected def: {}\", def);\n-                            tcx.sess.span_bug(pat.span, msg[])\n+                            // should not resolve. However, we do\n+                            // encouter this when using the\n+                            // expr-use-visitor during typeck. So just\n+                            // ignore it, an error should have been\n+                            // reported.\n+\n+                            if !tcx.sess.has_errors() {\n+                                let msg = format!(\"Pattern has unexpected def: {} and type {}\",\n+                                                  def,\n+                                                  cmt_pat.ty.repr(tcx));\n+                                tcx.sess.span_bug(pat.span, msg[])\n+                            }\n                         }\n                     }\n                 }\n@@ -1217,8 +1242,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_captures(&mut self, closure_expr: &ast::Expr) {\n         debug!(\"walk_captures({})\", closure_expr.repr(self.tcx()));\n \n-        let tcx = self.typer.tcx();\n-        ty::with_freevars(tcx, closure_expr.id, |freevars| {\n+        ty::with_freevars(self.tcx(), closure_expr.id, |freevars| {\n             match self.tcx().capture_mode(closure_expr.id) {\n                 ast::CaptureByRef => {\n                     self.walk_by_ref_captures(closure_expr, freevars);"}]}