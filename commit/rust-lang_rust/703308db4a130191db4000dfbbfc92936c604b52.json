{"sha": "703308db4a130191db4000dfbbfc92936c604b52", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMzMwOGRiNGExMzAxOTFkYjQwMDBkZmJiZmM5MjkzNmM2MDRiNTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-26T19:53:00Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-26T21:52:38Z"}, "message": "Refactor how binders are handled in trait selection", "tree": {"sha": "df56badc6f7e96a9922b6e6d61b13b10d8236cd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df56badc6f7e96a9922b6e6d61b13b10d8236cd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/703308db4a130191db4000dfbbfc92936c604b52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/703308db4a130191db4000dfbbfc92936c604b52", "html_url": "https://github.com/rust-lang/rust/commit/703308db4a130191db4000dfbbfc92936c604b52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/703308db4a130191db4000dfbbfc92936c604b52/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c59fe8bde2be55c46f627277e2cc37515fb7165e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c59fe8bde2be55c46f627277e2cc37515fb7165e", "html_url": "https://github.com/rust-lang/rust/commit/c59fe8bde2be55c46f627277e2cc37515fb7165e"}], "stats": {"total": 341, "additions": 213, "deletions": 128}, "files": [{"sha": "2bf5897296736a7d62b6111c5ccb1e6a065a52d6", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/703308db4a130191db4000dfbbfc92936c604b52/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/703308db4a130191db4000dfbbfc92936c604b52/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=703308db4a130191db4000dfbbfc92936c604b52", "patch": "@@ -164,6 +164,8 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         // debug output much nicer to read and so on.\n         let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n \n+        assert!(!obligation.has_escaping_regions());\n+\n         if !self.duplicate_set.insert(obligation.predicate.clone()) {\n             debug!(\"register_predicate({}) -- already seen, skip\", obligation.repr(infcx.tcx));\n             return;"}, {"sha": "6121a4419923957067426921ee2149083298c9fa", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 160, "deletions": 122, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/703308db4a130191db4000dfbbfc92936c604b52/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/703308db4a130191db4000dfbbfc92936c604b52/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=703308db4a130191db4000dfbbfc92936c604b52", "patch": "@@ -172,7 +172,7 @@ struct SelectionCandidateSet<'tcx> {\n }\n \n enum BuiltinBoundConditions<'tcx> {\n-    If(Vec<Ty<'tcx>>),\n+    If(ty::Binder<Vec<Ty<'tcx>>>),\n     ParameterBuiltin,\n     AmbiguousBuiltin\n }\n@@ -293,7 +293,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // because if it is a closure type, it must be a closure type from\n         // within this current fn, and hence none of the higher-ranked\n         // lifetimes can appear inside the self-type.\n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n             ty::ty_closure(id, ref substs) => (id, substs.clone()),\n             _ => { return; }\n@@ -1051,7 +1051,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None => { return Ok(()); }\n         };\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        // ok to skip binder because the substs on closure types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n             ty::ty_closure(id, ref substs) => (id, substs.clone()),\n             ty::ty_infer(ty::TyVar(_)) => {\n@@ -1094,7 +1097,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Ok(());\n         }\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        // ok to skip binder because what we are inspecting doesn't involve bound regions\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         match self_ty.sty {\n             ty::ty_infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n@@ -1126,8 +1130,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       candidates: &mut SelectionCandidateSet<'tcx>)\n                                       -> Result<(), SelectionError<'tcx>>\n     {\n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n-        debug!(\"assemble_candidates_from_impls(self_ty={})\", self_ty.repr(self.tcx()));\n+        debug!(\"assemble_candidates_from_impls(obligation={})\", obligation.repr(self.tcx()));\n \n         let def_id = obligation.predicate.def_id();\n         let all_impls = self.all_impls(def_id);\n@@ -1153,8 +1156,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                               candidates: &mut SelectionCandidateSet<'tcx>)\n                                               -> Result<(), SelectionError<'tcx>>\n     {\n-\n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        // OK to skip binder here because the tests we do below do not involve bound regions\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         debug!(\"assemble_candidates_from_default_impls(self_ty={})\", self_ty.repr(self.tcx()));\n \n         let def_id = obligation.predicate.def_id();\n@@ -1224,10 +1227,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                           obligation: &TraitObligation<'tcx>,\n                                           candidates: &mut SelectionCandidateSet<'tcx>)\n     {\n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n-\n         debug!(\"assemble_candidates_from_object_ty(self_ty={})\",\n-               self_ty.repr(self.tcx()));\n+               self.infcx.shallow_resolve(*obligation.self_ty().skip_binder()).repr(self.tcx()));\n \n         // Object-safety candidates are only applicable to object-safe\n         // traits. Including this check is useful because it helps\n@@ -1240,43 +1241,51 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return;\n         }\n \n-        let poly_trait_ref = match self_ty.sty {\n-            ty::ty_trait(ref data) => {\n-                match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n-                    Some(bound @ ty::BoundSend) | Some(bound @ ty::BoundSync) => {\n-                        if data.bounds.builtin_bounds.contains(&bound) {\n-                            debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n-                            pushing candidate\");\n-                            candidates.vec.push(BuiltinObjectCandidate);\n-                            return;\n+        self.infcx.try(|snapshot| {\n+            let bound_self_ty =\n+                self.infcx.resolve_type_vars_if_possible(&obligation.self_ty());\n+            let (self_ty, _) =\n+                self.infcx().skolemize_late_bound_regions(&bound_self_ty, snapshot);\n+            let poly_trait_ref = match self_ty.sty {\n+                ty::ty_trait(ref data) => {\n+                    match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n+                        Some(bound @ ty::BoundSend) | Some(bound @ ty::BoundSync) => {\n+                            if data.bounds.builtin_bounds.contains(&bound) {\n+                                debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n+                                        pushing candidate\");\n+                                candidates.vec.push(BuiltinObjectCandidate);\n+                                return Ok(());\n+                            }\n                         }\n+                        _ => {}\n                     }\n-                    _ => {}\n+\n+                    data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n+                }\n+                ty::ty_infer(ty::TyVar(_)) => {\n+                    debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n+                    candidates.ambiguous = true; // could wind up being an object type\n+                    return Ok(());\n                 }\n+                _ => {\n+                    return Ok(());\n+                }\n+            };\n \n-                data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n-            }\n-            ty::ty_infer(ty::TyVar(_)) => {\n-                debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n-                candidates.ambiguous = true; // could wind up being an object type\n-                return;\n-            }\n-            _ => {\n-                return;\n-            }\n-        };\n+            debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={}\",\n+                   poly_trait_ref.repr(self.tcx()));\n \n-        debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={}\",\n-               poly_trait_ref.repr(self.tcx()));\n+            // see whether the object trait can be upcast to the trait we are looking for\n+            let upcast_trait_refs = self.upcast(poly_trait_ref, obligation);\n+            if upcast_trait_refs.len() > 1 {\n+                // can be upcast in many ways; need more type information\n+                candidates.ambiguous = true;\n+            } else if upcast_trait_refs.len() == 1 {\n+                candidates.vec.push(ObjectCandidate);\n+            }\n \n-        // see whether the object trait can be upcast to the trait we are looking for\n-        let upcast_trait_refs = self.upcast(poly_trait_ref, obligation);\n-        if upcast_trait_refs.len() > 1 {\n-            // can be upcast in many ways; need more type information\n-            candidates.ambiguous = true;\n-        } else if upcast_trait_refs.len() == 1 {\n-            candidates.vec.push(ObjectCandidate);\n-        }\n+            Ok::<(),()>(())\n+        }).unwrap();\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -1411,23 +1420,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n         return match self_ty.sty {\n-            ty::ty_infer(ty::IntVar(_))\n-            | ty::ty_infer(ty::FloatVar(_))\n-            | ty::ty_uint(_)\n-            | ty::ty_int(_)\n-            | ty::ty_bool\n-            | ty::ty_float(_)\n-            | ty::ty_bare_fn(..)\n-            | ty::ty_char => {\n+            ty::ty_infer(ty::IntVar(_)) |\n+            ty::ty_infer(ty::FloatVar(_)) |\n+            ty::ty_uint(_) |\n+            ty::ty_int(_) |\n+            ty::ty_bool |\n+            ty::ty_float(_) |\n+            ty::ty_bare_fn(..) |\n+            ty::ty_char => {\n                 // safe for everything\n-                Ok(If(Vec::new()))\n+                ok_if(Vec::new())\n             }\n \n             ty::ty_uniq(_) => {  // Box<T>\n                 match bound {\n                     ty::BoundCopy => Err(Unimplemented),\n \n-                    ty::BoundSized => Ok(If(Vec::new())),\n+                    ty::BoundSized => ok_if(Vec::new()),\n \n                     ty::BoundSync | ty::BoundSend => {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1437,7 +1446,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::ty_ptr(..) => {     // *const T, *mut T\n                 match bound {\n-                    ty::BoundCopy | ty::BoundSized => Ok(If(Vec::new())),\n+                    ty::BoundCopy | ty::BoundSized => ok_if(Vec::new()),\n \n                     ty::BoundSync | ty::BoundSend => {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1450,7 +1459,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundSized => Err(Unimplemented),\n                     ty::BoundCopy => {\n                         if data.bounds.builtin_bounds.contains(&bound) {\n-                            Ok(If(Vec::new()))\n+                            ok_if(Vec::new())\n                         } else {\n                             // Recursively check all supertraits to find out if any further\n                             // bounds are required and thus we must fulfill.\n@@ -1460,7 +1469,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             let desired_def_id = obligation.predicate.def_id();\n                             for tr in util::supertraits(self.tcx(), principal) {\n                                 if tr.def_id() == desired_def_id {\n-                                    return Ok(If(Vec::new()))\n+                                    return ok_if(Vec::new())\n                                 }\n                             }\n \n@@ -1482,11 +1491,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             ast::MutMutable => Err(Unimplemented),\n \n                             // &T is always copyable\n-                            ast::MutImmutable => Ok(If(Vec::new())),\n+                            ast::MutImmutable => ok_if(Vec::new()),\n                         }\n                     }\n \n-                    ty::BoundSized => Ok(If(Vec::new())),\n+                    ty::BoundSized => ok_if(Vec::new()),\n \n                     ty::BoundSync | ty::BoundSend => {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1500,7 +1509,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundCopy => {\n                         match *len {\n                             // [T, ..n] is copy iff T is copy\n-                            Some(_) => Ok(If(vec![element_ty])),\n+                            Some(_) => ok_if(vec![element_ty]),\n \n                             // [T] is unsized and hence affine\n                             None => Err(Unimplemented),\n@@ -1509,7 +1518,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                     ty::BoundSized => {\n                         if len.is_some() {\n-                            Ok(If(Vec::new()))\n+                            ok_if(Vec::new())\n                         } else {\n                             Err(Unimplemented)\n                         }\n@@ -1533,7 +1542,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-            ty::ty_tup(ref tys) => Ok(If(tys.clone())),\n+            ty::ty_tup(ref tys) => ok_if(tys.clone()),\n \n             ty::ty_closure(def_id, substs) => {\n                 // FIXME -- This case is tricky. In the case of by-ref\n@@ -1558,11 +1567,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // unsized, so the closure struct as a whole must be\n                 // Sized.\n                 if bound == ty::BoundSized {\n-                    return Ok(If(Vec::new()));\n+                    return ok_if(Vec::new());\n                 }\n \n                 match self.closure_typer.closure_upvars(def_id, substs) {\n-                    Some(upvars) => Ok(If(upvars.iter().map(|c| c.ty).collect())),\n+                    Some(upvars) => ok_if(upvars.iter().map(|c| c.ty).collect()),\n                     None => {\n                         debug!(\"assemble_builtin_bound_candidates: no upvar types available yet\");\n                         Ok(AmbiguousBuiltin)\n@@ -1604,7 +1613,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(AmbiguousBuiltin)\n             }\n \n-            ty::ty_err => Ok(If(Vec::new())),\n+            ty::ty_err => ok_if(Vec::new()),\n \n             ty::ty_infer(ty::FreshTy(_))\n             | ty::ty_infer(ty::FreshIntTy(_)) => {\n@@ -1615,6 +1624,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n+        fn ok_if<'tcx>(v: Vec<Ty<'tcx>>)\n+                       -> Result<BuiltinBoundConditions<'tcx>, SelectionError<'tcx>> {\n+            Ok(If(ty::Binder(v)))\n+        }\n+\n         fn nominal<'cx, 'tcx>(bound: ty::BuiltinBound,\n                               types: Vec<Ty<'tcx>>)\n                               -> Result<BuiltinBoundConditions<'tcx>, SelectionError<'tcx>>\n@@ -1625,7 +1639,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::BoundCopy => Ok(ParameterBuiltin),\n \n                 // Sized if all the component types are sized.\n-                ty::BoundSized => Ok(If(types)),\n+                ty::BoundSized => ok_if(types),\n \n                 // Shouldn't be coming through here.\n                 ty::BoundSend | ty::BoundSync => unreachable!(),\n@@ -1728,8 +1742,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn collect_predicates_for_types(&mut self,\n                                     obligation: &TraitObligation<'tcx>,\n                                     trait_def_id: ast::DefId,\n-                                    types: Vec<Ty<'tcx>>) -> Vec<PredicateObligation<'tcx>> {\n-\n+                                    types: ty::Binder<Vec<Ty<'tcx>>>)\n+                                    -> Vec<PredicateObligation<'tcx>>\n+    {\n         let derived_cause = match self.tcx().lang_items.to_builtin_kind(trait_def_id) {\n             Some(_) => {\n                 self.derived_cause(obligation, BuiltinDerivedObligation)\n@@ -1739,43 +1754,52 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n-        let normalized = project::normalize_with_depth(self, obligation.cause.clone(),\n-                                                       obligation.recursion_depth + 1,\n-                                                       &types);\n-\n-        let obligations = normalized.value.iter().map(|&nested_ty| {\n-            // the obligation might be higher-ranked, e.g. for<'a> &'a\n-            // int : Copy. In that case, we will wind up with\n-            // late-bound regions in the `nested` vector. So for each\n-            // one we instantiate to a skolemized region, do our work\n-            // to produce something like `&'0 int : Copy`, and then\n-            // re-bind it. This is a bit of busy-work but preserves\n-            // the invariant that we only manipulate free regions, not\n-            // bound ones.\n+        // Because the types were potentially derived from\n+        // higher-ranked obligations they may reference late-bound\n+        // regions. For example, `for<'a> Foo<&'a int> : Copy` would\n+        // yield a type like `for<'a> &'a int`. In general, we\n+        // maintain the invariant that we never manipulate bound\n+        // regions, so we have to process these bound regions somehow.\n+        //\n+        // The strategy is to:\n+        //\n+        // 1. Instantiate those regions to skolemized regions (e.g.,\n+        //    `for<'a> &'a int` becomes `&0 int`.\n+        // 2. Produce something like `&'0 int : Copy`\n+        // 3. Re-bind the regions back to `for<'a> &'a int : Copy`\n+\n+        // Move the binder into the individual types\n+        let bound_types: Vec<ty::Binder<Ty<'tcx>>> =\n+            types.skip_binder()\n+                 .iter()\n+                 .map(|&nested_ty| ty::Binder(nested_ty))\n+                 .collect();\n+\n+        // For each type, produce a vector of resulting obligations\n+        let obligations: Result<Vec<Vec<_>>, _> = bound_types.iter().map(|nested_ty| {\n             self.infcx.try(|snapshot| {\n                 let (skol_ty, skol_map) =\n-                    self.infcx().skolemize_late_bound_regions(&ty::Binder(nested_ty), snapshot);\n-                let skol_predicate =\n-                    util::predicate_for_trait_def(\n-                        self.tcx(),\n-                        derived_cause.clone(),\n-                        trait_def_id,\n-                        obligation.recursion_depth + 1,\n-                        skol_ty);\n-                match skol_predicate {\n-                    Ok(skol_predicate) => Ok(self.infcx().plug_leaks(skol_map, snapshot,\n-                                                                     &skol_predicate)),\n-                    Err(ErrorReported) => Err(ErrorReported)\n-                }\n+                    self.infcx().skolemize_late_bound_regions(nested_ty, snapshot);\n+                let Normalized { value: normalized_ty, mut obligations } =\n+                    project::normalize_with_depth(self,\n+                                                  obligation.cause.clone(),\n+                                                  obligation.recursion_depth + 1,\n+                                                  &skol_ty);\n+                let skol_obligation =\n+                    try!(util::predicate_for_trait_def(self.tcx(),\n+                                                       derived_cause.clone(),\n+                                                       trait_def_id,\n+                                                       obligation.recursion_depth + 1,\n+                                                       normalized_ty));\n+                obligations.push(skol_obligation);\n+                Ok(self.infcx().plug_leaks(skol_map, snapshot, &obligations))\n             })\n-        }).collect::<Result<Vec<PredicateObligation<'tcx>>, _>>();\n+        }).collect();\n \n+        // Flatten those vectors (couldn't do it above due `collect`)\n         match obligations {\n-            Ok(mut obls) => {\n-                obls.push_all(&normalized.obligations);\n-                obls\n-            },\n-            Err(ErrorReported) => Vec::new()\n+            Ok(obligations) => obligations.into_iter().flat_map(|o| o.into_iter()).collect(),\n+            Err(ErrorReported) => Vec::new(),\n         }\n     }\n \n@@ -1919,7 +1943,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn vtable_builtin_data(&mut self,\n                            obligation: &TraitObligation<'tcx>,\n                            bound: ty::BuiltinBound,\n-                           nested: Vec<Ty<'tcx>>)\n+                           nested: ty::Binder<Vec<Ty<'tcx>>>)\n                            -> VtableBuiltinData<PredicateObligation<'tcx>>\n     {\n         let trait_def = match self.tcx().lang_items.from_builtin_kind(bound) {\n@@ -1953,9 +1977,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                obligation.repr(self.tcx()),\n                trait_def_id.repr(self.tcx()));\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n+        // binder is moved below\n+        let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n         match self.constituent_types_for_ty(self_ty) {\n-            Some(types) => self.vtable_default_impl(obligation, trait_def_id, types),\n+            Some(types) => self.vtable_default_impl(obligation, trait_def_id, ty::Binder(types)),\n             None => {\n                 self.tcx().sess.bug(\n                     &format!(\n@@ -1976,17 +2001,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         assert!(ty::has_attr(self.tcx(), trait_def_id, \"rustc_reflect_like\"));\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n+        // OK to skip binder, it is reintroduced below\n+        let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n         match self_ty.sty {\n             ty::ty_trait(ref data) => {\n-                // OK to skip the binder, since vtable_default_impl reintroduces it\n+                // OK to skip the binder, it is reintroduced below\n                 let input_types = data.principal.skip_binder().substs.types.get_slice(TypeSpace);\n                 let assoc_types = data.bounds.projection_bounds\n                                              .iter()\n                                              .map(|pb| pb.skip_binder().ty);\n                 let all_types: Vec<_> = input_types.iter().cloned()\n                                                           .chain(assoc_types)\n                                                           .collect();\n+\n+                // reintroduce the two binding levels we skipped, then flatten into one\n+                let all_types = ty::Binder(ty::Binder(all_types));\n+                let all_types = ty::flatten_late_bound_regions(self.tcx(), &all_types);\n+\n                 self.vtable_default_impl(obligation, trait_def_id, all_types)\n             }\n             _ => {\n@@ -2002,29 +2033,29 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn vtable_default_impl(&mut self,\n                            obligation: &TraitObligation<'tcx>,\n                            trait_def_id: ast::DefId,\n-                           nested: Vec<Ty<'tcx>>)\n+                           nested: ty::Binder<Vec<Ty<'tcx>>>)\n                            -> VtableDefaultImplData<PredicateObligation<'tcx>>\n     {\n+        debug!(\"vtable_default_impl_data: nested={}\", nested.repr(self.tcx()));\n \n         let mut obligations = self.collect_predicates_for_types(obligation,\n                                                                 trait_def_id,\n                                                                 nested);\n \n-        let _: Result<(),()> = self.infcx.try(|snapshot| {\n-            let (_, skol_map) =\n-                self.infcx().skolemize_late_bound_regions(&obligation.predicate, snapshot);\n-\n-            let substs = obligation.predicate.to_poly_trait_ref().substs();\n-            let trait_obligations = self.impl_or_trait_obligations(obligation.cause.clone(),\n-                                                                   obligation.recursion_depth + 1,\n-                                                                   trait_def_id,\n-                                                                   substs,\n-                                                                   skol_map,\n-                                                                   snapshot);\n-            obligations.push_all(trait_obligations.as_slice());\n-            Ok(())\n+        let trait_obligations: Result<VecPerParamSpace<_>,()> = self.infcx.try(|snapshot| {\n+            let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n+            let (trait_ref, skol_map) =\n+                self.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n+            Ok(self.impl_or_trait_obligations(obligation.cause.clone(),\n+                                              obligation.recursion_depth + 1,\n+                                              trait_def_id,\n+                                              &trait_ref.substs,\n+                                              skol_map,\n+                                              snapshot))\n         });\n \n+        obligations.extend(trait_obligations.unwrap().into_iter()); // no Errors in that code above\n+\n         debug!(\"vtable_default_impl_data: obligations={}\", obligations.repr(self.tcx()));\n \n         VtableDefaultImplData {\n@@ -2098,7 +2129,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"confirm_object_candidate({})\",\n                obligation.repr(self.tcx()));\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        // FIXME skipping binder here seems wrong -- we should\n+        // probably flatten the binder from the obligation and the\n+        // binder from the object. Have to try to make a broken test\n+        // case that results. -nmatsakis\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n             ty::ty_trait(ref data) => {\n                 data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n@@ -2136,15 +2171,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"confirm_fn_pointer_candidate({})\",\n                obligation.repr(self.tcx()));\n \n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        // ok to skip binder; it is reintroduced below\n+        let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let sig = ty::ty_fn_sig(self_ty);\n-        let ty::Binder((trait_ref, _)) =\n+        let trait_ref =\n             util::closure_trait_ref_and_return_type(self.tcx(),\n                                                     obligation.predicate.def_id(),\n                                                     self_ty,\n                                                     sig,\n-                                                    util::TupleArgumentsFlag::Yes);\n-        let trait_ref = ty::Binder(trait_ref);\n+                                                    util::TupleArgumentsFlag::Yes)\n+            .map_bound(|(trait_ref, _)| trait_ref);\n \n         try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                           obligation.predicate.to_poly_trait_ref(),\n@@ -2499,6 +2535,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                  snapshot: &infer::CombinedSnapshot)\n                                  -> VecPerParamSpace<PredicateObligation<'tcx>>\n     {\n+        debug!(\"impl_or_trait_obligations(def_id={})\", def_id.repr(self.tcx()));\n+\n         let predicates = ty::lookup_predicates(self.tcx(), def_id);\n         let predicates = predicates.instantiate(self.tcx(), substs);\n         let predicates = normalize_with_depth(self, cause.clone(), recursion_depth, &predicates);"}, {"sha": "3572ca89acc9f3fd1082f42c3bac8bffc2c12397", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 51, "deletions": 6, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/703308db4a130191db4000dfbbfc92936c604b52/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/703308db4a130191db4000dfbbfc92936c604b52/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=703308db4a130191db4000dfbbfc92936c604b52", "patch": "@@ -1108,16 +1108,16 @@ pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n \n impl<'tcx> PolyFnSig<'tcx> {\n     pub fn inputs(&self) -> ty::Binder<Vec<Ty<'tcx>>> {\n-        ty::Binder(self.0.inputs.clone())\n+        self.map_bound_ref(|fn_sig| fn_sig.inputs.clone())\n     }\n     pub fn input(&self, index: uint) -> ty::Binder<Ty<'tcx>> {\n-        ty::Binder(self.0.inputs[index])\n+        self.map_bound_ref(|fn_sig| fn_sig.inputs[index])\n     }\n     pub fn output(&self) -> ty::Binder<FnOutput<'tcx>> {\n-        ty::Binder(self.0.output.clone())\n+        self.map_bound_ref(|fn_sig| fn_sig.output.clone())\n     }\n     pub fn variadic(&self) -> bool {\n-        self.0.variadic\n+        self.skip_binder().variadic\n     }\n }\n \n@@ -1519,6 +1519,22 @@ impl<T> Binder<T> {\n     pub fn skip_binder(&self) -> &T {\n         &self.0\n     }\n+\n+    pub fn as_ref(&self) -> Binder<&T> {\n+        ty::Binder(&self.0)\n+    }\n+\n+    pub fn map_bound_ref<F,U>(&self, f: F) -> Binder<U>\n+        where F: FnOnce(&T) -> U\n+    {\n+        self.as_ref().map_bound(f)\n+    }\n+\n+    pub fn map_bound<F,U>(self, f: F) -> Binder<U>\n+        where F: FnOnce(T) -> U\n+    {\n+        ty::Binder(f(self.0))\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq)]\n@@ -2062,8 +2078,7 @@ impl<'tcx> ToPolyTraitRef<'tcx> for Rc<TraitRef<'tcx>> {\n \n impl<'tcx> ToPolyTraitRef<'tcx> for PolyTraitPredicate<'tcx> {\n     fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx> {\n-        // We are just preserving the binder levels here\n-        ty::Binder(self.0.trait_ref.clone())\n+        self.map_bound_ref(|trait_pred| trait_pred.trait_ref.clone())\n     }\n }\n \n@@ -6755,6 +6770,30 @@ pub fn binds_late_bound_regions<'tcx, T>(\n     count_late_bound_regions(tcx, value) > 0\n }\n \n+/// Flattens two binding levels into one. So `for<'a> for<'b> Foo`\n+/// becomes `for<'a,'b> Foo`.\n+pub fn flatten_late_bound_regions<'tcx, T>(\n+    tcx: &ty::ctxt<'tcx>,\n+    bound2_value: &Binder<Binder<T>>)\n+    -> Binder<T>\n+    where T: TypeFoldable<'tcx> + Repr<'tcx>\n+{\n+    let bound0_value = bound2_value.skip_binder().skip_binder();\n+    let value = ty_fold::fold_regions(tcx, bound0_value, |region, current_depth| {\n+        match region {\n+            ty::ReLateBound(debruijn, br) if debruijn.depth >= current_depth => {\n+                // should be true if no escaping regions from bound2_value\n+                assert!(debruijn.depth - current_depth <= 1);\n+                ty::ReLateBound(DebruijnIndex::new(current_depth), br)\n+            }\n+            _ => {\n+                region\n+            }\n+        }\n+    });\n+    Binder(value)\n+}\n+\n pub fn no_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n@@ -7093,6 +7132,12 @@ impl<'tcx> RegionEscape for Predicate<'tcx> {\n     }\n }\n \n+impl<'tcx,P:RegionEscape> RegionEscape for traits::Obligation<'tcx,P> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.predicate.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n impl<'tcx> RegionEscape for TraitRef<'tcx> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.substs.types.iter().any(|t| t.has_regions_escaping_depth(depth)) ||"}]}