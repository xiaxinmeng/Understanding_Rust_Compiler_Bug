{"sha": "a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NDQ3NmIwYWE5ZjdjYTAwZThmOGMxMmZjMzI3Y2Y3OTgxNTA1NGE=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-07T21:10:39Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-07T21:10:39Z"}, "message": "Merge remote-tracking branch 'remotes/origin/master' into remove-str-trailing-nulls", "tree": {"sha": "24fe9bd9f457a4d4111c2c3b49ebab91394e7606", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24fe9bd9f457a4d4111c2c3b49ebab91394e7606"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "html_url": "https://github.com/rust-lang/rust/commit/a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aababbba8e5d5b56aa4a0cedb9b2008ba6cdc422", "url": "https://api.github.com/repos/rust-lang/rust/commits/aababbba8e5d5b56aa4a0cedb9b2008ba6cdc422", "html_url": "https://github.com/rust-lang/rust/commit/aababbba8e5d5b56aa4a0cedb9b2008ba6cdc422"}, {"sha": "cdba212e7299f6bda752abbb9f887c51d96f7586", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdba212e7299f6bda752abbb9f887c51d96f7586", "html_url": "https://github.com/rust-lang/rust/commit/cdba212e7299f6bda752abbb9f887c51d96f7586"}], "stats": {"total": 1758, "additions": 897, "deletions": 861}, "files": [{"sha": "a9a41a073d03366291a404187213a417cd608de6", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -297,7 +297,7 @@ COMPILER_INPUTS := $(wildcard $(addprefix $(S)src/librustc/,      \\\n \n LIBSYNTAX_CRATE := $(S)src/libsyntax/syntax.rs\n LIBSYNTAX_INPUTS := $(wildcard $(addprefix $(S)src/libsyntax/, \\\n-                           *.rs */*.rs */*/*.rs))\n+                           *.rs */*.rs */*/*.rs */*/*/*.rs))\n \n DRIVER_CRATE := $(S)src/driver/driver.rs\n "}, {"sha": "b5677a261c45bffd12d1d80907e3df7ed035f45f", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -544,7 +544,7 @@ an intermediate generation has already exited:\n ~~~\n # use std::task;\n # fn sleep_forever() { loop { task::yield() } }\n-# fn wait_for_a_while() { do 1000.times { task::yield() } }\n+# fn wait_for_a_while() { for _ in range(0, 1000u) { task::yield() } }\n # do task::try::<int> {\n do task::spawn_supervised {\n     do task::spawn_supervised {\n@@ -563,7 +563,7 @@ other at all, using `task::spawn_unlinked` for _isolated failure_.\n ~~~\n # use std::task;\n # fn random() -> uint { 100 }\n-# fn sleep_for(i: uint) { do i.times { task::yield() } }\n+# fn sleep_for(i: uint) { for _ in range(0, i) { task::yield() } }\n # do task::try::<()> {\n let (time1, time2) = (random(), random());\n do task::spawn_unlinked {"}, {"sha": "6e6b804aa9d3408123dffe40f2a70c5f2a85a702", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -1894,7 +1894,7 @@ struct TimeBomb {\n \n impl Drop for TimeBomb {\n     fn drop(&self) {\n-        do self.explosivity.times {\n+        for _ in range(0, self.explosivity) {\n             println(\"blam!\");\n         }\n     }"}, {"sha": "b4431004bd74cff0dd38693c5093d4b590c479be", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 70, "deletions": 114, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n //! Base64 binary-to-text encoding\n+use std::str;\n \n /// Available encoding character sets\n pub enum CharacterSet {\n@@ -40,21 +41,13 @@ pub static URL_SAFE: Config =\n pub static MIME: Config =\n     Config {char_set: Standard, pad: true, line_length: Some(76)};\n \n-static STANDARD_CHARS: [char, ..64] = [\n-    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n-    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n-    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n-    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n-    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n-];\n-\n-static URLSAFE_CHARS: [char, ..64] = [\n-    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n-    'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n-    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n-    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n-    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n-];\n+static STANDARD_CHARS: &'static[u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n+                                             \"abcdefghijklmnopqrstuvwxyz\",\n+                                             \"0123456789+/\");\n+\n+static URLSAFE_CHARS: &'static[u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n+                                            \"abcdefghijklmnopqrstuvwxyz\",\n+                                            \"0123456789-_\");\n \n /// A trait for converting a value to base64 encoding.\n pub trait ToBase64 {\n@@ -80,20 +73,21 @@ impl<'self> ToBase64 for &'self [u8] {\n      * ~~~\n      */\n     fn to_base64(&self, config: Config) -> ~str {\n-        let chars = match config.char_set {\n+        let bytes = match config.char_set {\n             Standard => STANDARD_CHARS,\n             UrlSafe => URLSAFE_CHARS\n         };\n \n-        let mut s = ~\"\";\n+        let mut v: ~[u8] = ~[];\n         let mut i = 0;\n         let mut cur_length = 0;\n         let len = self.len();\n         while i < len - (len % 3) {\n             match config.line_length {\n                 Some(line_length) =>\n                     if cur_length >= line_length {\n-                        s.push_str(\"\\r\\n\");\n+                        v.push('\\r' as u8);\n+                        v.push('\\n' as u8);\n                         cur_length = 0;\n                     },\n                 None => ()\n@@ -104,10 +98,10 @@ impl<'self> ToBase64 for &'self [u8] {\n                     (self[i + 2] as u32);\n \n             // This 24-bit number gets separated into four 6-bit numbers.\n-            s.push_char(chars[(n >> 18) & 63]);\n-            s.push_char(chars[(n >> 12) & 63]);\n-            s.push_char(chars[(n >> 6 ) & 63]);\n-            s.push_char(chars[n & 63]);\n+            v.push(bytes[(n >> 18) & 63]);\n+            v.push(bytes[(n >> 12) & 63]);\n+            v.push(bytes[(n >> 6 ) & 63]);\n+            v.push(bytes[n & 63]);\n \n             cur_length += 4;\n             i += 3;\n@@ -117,7 +111,8 @@ impl<'self> ToBase64 for &'self [u8] {\n             match config.line_length {\n                 Some(line_length) =>\n                     if cur_length >= line_length {\n-                        s.push_str(\"\\r\\n\");\n+                        v.push('\\r' as u8);\n+                        v.push('\\n' as u8);\n                     },\n                 None => ()\n             }\n@@ -129,48 +124,29 @@ impl<'self> ToBase64 for &'self [u8] {\n             0 => (),\n             1 => {\n                 let n = (self[i] as u32) << 16;\n-                s.push_char(chars[(n >> 18) & 63]);\n-                s.push_char(chars[(n >> 12) & 63]);\n+                v.push(bytes[(n >> 18) & 63]);\n+                v.push(bytes[(n >> 12) & 63]);\n                 if config.pad {\n-                    s.push_str(\"==\");\n+                    v.push('=' as u8);\n+                    v.push('=' as u8);\n                 }\n             }\n             2 => {\n                 let n = (self[i] as u32) << 16 |\n                     (self[i + 1u] as u32) << 8;\n-                s.push_char(chars[(n >> 18) & 63]);\n-                s.push_char(chars[(n >> 12) & 63]);\n-                s.push_char(chars[(n >> 6 ) & 63]);\n+                v.push(bytes[(n >> 18) & 63]);\n+                v.push(bytes[(n >> 12) & 63]);\n+                v.push(bytes[(n >> 6 ) & 63]);\n                 if config.pad {\n-                    s.push_char('=');\n+                    v.push('=' as u8);\n                 }\n             }\n             _ => fail!(\"Algebra is broken, please alert the math police\")\n         }\n-        s\n-    }\n-}\n \n-impl<'self> ToBase64 for &'self str {\n-    /**\n-     * Convert any string (literal, `@`, `&`, or `~`) to base64 encoding.\n-     *\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     * extern mod extra;\n-     * use extra::base64::{ToBase64, standard};\n-     *\n-     * fn main () {\n-     *     let str = \"Hello, World\".to_base64(standard);\n-     *     printfln!(\"%s\", str);\n-     * }\n-     * ~~~\n-     *\n-     */\n-    fn to_base64(&self, config: Config) -> ~str {\n-        self.as_bytes().to_base64(config)\n+        unsafe {\n+            str::raw::from_bytes_owned(v)\n+        }\n     }\n }\n \n@@ -181,22 +157,31 @@ pub trait FromBase64 {\n     fn from_base64(&self) -> Result<~[u8], ~str>;\n }\n \n-impl<'self> FromBase64 for &'self [u8] {\n+impl<'self> FromBase64 for &'self str {\n     /**\n-     * Convert base64 `u8` vector into u8 byte values.\n-     * Every 4 encoded characters is converted into 3 octets, modulo padding.\n+     * Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n+     * to the byte values it encodes.\n+     *\n+     * You can use the `from_bytes` function in `std::str`\n+     * to turn a `[u8]` into a string with characters corresponding to those\n+     * values.\n      *\n      * # Example\n      *\n+     * This converts a string literal to base64 and back.\n+     *\n      * ~~~ {.rust}\n      * extern mod extra;\n      * use extra::base64::{ToBase64, FromBase64, standard};\n+     * use std::str;\n      *\n      * fn main () {\n-     *     let str = [52,32].to_base64(standard);\n-     *     printfln!(\"%s\", str);\n-     *     let bytes = str.from_base64();\n+     *     let hello_str = \"Hello, World\".to_base64(standard);\n+     *     printfln!(\"%s\", hello_str);\n+     *     let bytes = hello_str.from_base64();\n      *     printfln!(\"%?\", bytes);\n+     *     let result_str = str::from_bytes(bytes);\n+     *     printfln!(\"%s\", result_str);\n      * }\n      * ~~~\n      */\n@@ -205,20 +190,20 @@ impl<'self> FromBase64 for &'self [u8] {\n         let mut buf: u32 = 0;\n         let mut modulus = 0;\n \n-        let mut it = self.iter();\n-        for &byte in it {\n-            let ch = byte as char;\n+        let mut it = self.byte_iter().enumerate();\n+        for (idx, byte) in it {\n             let val = byte as u32;\n \n-            match ch {\n+            match byte as char {\n                 'A'..'Z' => buf |= val - 0x41,\n                 'a'..'z' => buf |= val - 0x47,\n                 '0'..'9' => buf |= val + 0x04,\n                 '+'|'-' => buf |= 0x3E,\n                 '/'|'_' => buf |= 0x3F,\n                 '\\r'|'\\n' => loop,\n                 '=' => break,\n-                _ => return Err(~\"Invalid Base64 character\")\n+                _ => return Err(fmt!(\"Invalid character '%c' at position %u\",\n+                                     self.char_at(idx), idx))\n             }\n \n             buf <<= 6;\n@@ -231,8 +216,11 @@ impl<'self> FromBase64 for &'self [u8] {\n             }\n         }\n \n-        if !it.all(|&byte| {byte as char == '='}) {\n-            return Err(~\"Invalid Base64 character\");\n+        for (idx, byte) in it {\n+            if (byte as char) != '=' {\n+                return Err(fmt!(\"Invalid character '%c' at position %u\",\n+                                self.char_at(idx), idx));\n+            }\n         }\n \n         match modulus {\n@@ -251,67 +239,35 @@ impl<'self> FromBase64 for &'self [u8] {\n     }\n }\n \n-impl<'self> FromBase64 for &'self str {\n-    /**\n-     * Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n-     * to the byte values it encodes.\n-     *\n-     * You can use the `from_bytes` function in `std::str`\n-     * to turn a `[u8]` into a string with characters corresponding to those\n-     * values.\n-     *\n-     * # Example\n-     *\n-     * This converts a string literal to base64 and back.\n-     *\n-     * ~~~ {.rust}\n-     * extern mod extra;\n-     * use extra::base64::{ToBase64, FromBase64, standard};\n-     * use std::str;\n-     *\n-     * fn main () {\n-     *     let hello_str = \"Hello, World\".to_base64(standard);\n-     *     printfln!(\"%s\", hello_str);\n-     *     let bytes = hello_str.from_base64();\n-     *     printfln!(\"%?\", bytes);\n-     *     let result_str = str::from_bytes(bytes);\n-     *     printfln!(\"%s\", result_str);\n-     * }\n-     * ~~~\n-     */\n-    fn from_base64(&self) -> Result<~[u8], ~str> {\n-        self.as_bytes().from_base64()\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n     use test::BenchHarness;\n     use base64::*;\n \n     #[test]\n     fn test_to_base64_basic() {\n-        assert_eq!(\"\".to_base64(STANDARD), ~\"\");\n-        assert_eq!(\"f\".to_base64(STANDARD), ~\"Zg==\");\n-        assert_eq!(\"fo\".to_base64(STANDARD), ~\"Zm8=\");\n-        assert_eq!(\"foo\".to_base64(STANDARD), ~\"Zm9v\");\n-        assert_eq!(\"foob\".to_base64(STANDARD), ~\"Zm9vYg==\");\n-        assert_eq!(\"fooba\".to_base64(STANDARD), ~\"Zm9vYmE=\");\n-        assert_eq!(\"foobar\".to_base64(STANDARD), ~\"Zm9vYmFy\");\n+        assert_eq!(\"\".as_bytes().to_base64(STANDARD), ~\"\");\n+        assert_eq!(\"f\".as_bytes().to_base64(STANDARD), ~\"Zg==\");\n+        assert_eq!(\"fo\".as_bytes().to_base64(STANDARD), ~\"Zm8=\");\n+        assert_eq!(\"foo\".as_bytes().to_base64(STANDARD), ~\"Zm9v\");\n+        assert_eq!(\"foob\".as_bytes().to_base64(STANDARD), ~\"Zm9vYg==\");\n+        assert_eq!(\"fooba\".as_bytes().to_base64(STANDARD), ~\"Zm9vYmE=\");\n+        assert_eq!(\"foobar\".as_bytes().to_base64(STANDARD), ~\"Zm9vYmFy\");\n     }\n \n     #[test]\n     fn test_to_base64_line_break() {\n         assert!(![0u8, 1000].to_base64(Config {line_length: None, ..STANDARD})\n                 .contains(\"\\r\\n\"));\n-        assert_eq!(\"foobar\".to_base64(Config {line_length: Some(4), ..STANDARD}),\n+        assert_eq!(\"foobar\".as_bytes().to_base64(Config {line_length: Some(4),\n+                                                         ..STANDARD}),\n                    ~\"Zm9v\\r\\nYmFy\");\n     }\n \n     #[test]\n     fn test_to_base64_padding() {\n-        assert_eq!(\"f\".to_base64(Config {pad: false, ..STANDARD}), ~\"Zg\");\n-        assert_eq!(\"fo\".to_base64(Config {pad: false, ..STANDARD}), ~\"Zm8\");\n+        assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), ~\"Zg\");\n+        assert_eq!(\"fo\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), ~\"Zm8\");\n     }\n \n     #[test]\n@@ -345,7 +301,7 @@ mod test {\n     #[test]\n     fn test_from_base64_invalid_char() {\n         assert!(\"Zm$=\".from_base64().is_err())\n-            assert!(\"Zg==$\".from_base64().is_err());\n+        assert!(\"Zg==$\".from_base64().is_err());\n     }\n \n     #[test]\n@@ -369,20 +325,20 @@ mod test {\n     }\n \n     #[bench]\n-    pub fn to_base64(bh: & mut BenchHarness) {\n+    pub fn bench_to_base64(bh: & mut BenchHarness) {\n         let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         do bh.iter {\n-            s.to_base64(STANDARD);\n+            s.as_bytes().to_base64(STANDARD);\n         }\n         bh.bytes = s.len() as u64;\n     }\n \n     #[bench]\n-    pub fn from_base64(bh: & mut BenchHarness) {\n+    pub fn bench_from_base64(bh: & mut BenchHarness) {\n         let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-        let b = s.to_base64(STANDARD);\n+        let b = s.as_bytes().to_base64(STANDARD);\n         do bh.iter {\n             b.from_base64();\n         }"}, {"sha": "44781a1fd19b632f0794802ae3d9ee8cbae167ce", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -102,6 +102,7 @@ pub mod stats;\n pub mod semver;\n pub mod fileinput;\n pub mod flate;\n+pub mod hex;\n \n #[cfg(unicode)]\n mod unicode;"}, {"sha": "d5345cb956b8f2004eb6d7571b27af9d7f7465b3", "filename": "src/libextra/hex.rs", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -0,0 +1,193 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Hex binary-to-text encoding\n+use std::str;\n+use std::vec;\n+\n+/// A trait for converting a value to hexadecimal encoding\n+pub trait ToHex {\n+    /// Converts the value of `self` to a hex value, returning the owned\n+    /// string.\n+    fn to_hex(&self) -> ~str;\n+}\n+\n+static CHARS: &'static[u8] = bytes!(\"0123456789abcdef\");\n+\n+impl<'self> ToHex for &'self [u8] {\n+    /**\n+     * Turn a vector of `u8` bytes into a hexadecimal string.\n+     *\n+     * # Example\n+     *\n+     * ~~~ {.rust}\n+     * extern mod extra;\n+     * use extra::hex::ToHex;\n+     *\n+     * fn main () {\n+     *     let str = [52,32].to_hex();\n+     *     printfln!(\"%s\", str);\n+     * }\n+     * ~~~\n+     */\n+    fn to_hex(&self) -> ~str {\n+        let mut v = vec::with_capacity(self.len() * 2);\n+        for &byte in self.iter() {\n+            v.push(CHARS[byte >> 4]);\n+            v.push(CHARS[byte & 0xf]);\n+        }\n+\n+        unsafe {\n+            str::raw::from_bytes_owned(v)\n+        }\n+    }\n+}\n+\n+/// A trait for converting hexadecimal encoded values\n+pub trait FromHex {\n+    /// Converts the value of `self`, interpreted as hexadecimal encoded data,\n+    /// into an owned vector of bytes, returning the vector.\n+    fn from_hex(&self) -> Result<~[u8], ~str>;\n+}\n+\n+impl<'self> FromHex for &'self str {\n+    /**\n+     * Convert any hexadecimal encoded string (literal, `@`, `&`, or `~`)\n+     * to the byte values it encodes.\n+     *\n+     * You can use the `from_bytes` function in `std::str`\n+     * to turn a `[u8]` into a string with characters corresponding to those\n+     * values.\n+     *\n+     * # Example\n+     *\n+     * This converts a string literal to hexadecimal and back.\n+     *\n+     * ~~~ {.rust}\n+     * extern mod extra;\n+     * use extra::hex::{FromHex, ToHex};\n+     * use std::str;\n+     *\n+     * fn main () {\n+     *     let hello_str = \"Hello, World\".to_hex();\n+     *     printfln!(\"%s\", hello_str);\n+     *     let bytes = hello_str.from_hex().unwrap();\n+     *     printfln!(\"%?\", bytes);\n+     *     let result_str = str::from_bytes(bytes);\n+     *     printfln!(\"%s\", result_str);\n+     * }\n+     * ~~~\n+     */\n+    fn from_hex(&self) -> Result<~[u8], ~str> {\n+        // This may be an overestimate if there is any whitespace\n+        let mut b = vec::with_capacity(self.len() / 2);\n+        let mut modulus = 0;\n+        let mut buf = 0u8;\n+\n+        for (idx, byte) in self.byte_iter().enumerate() {\n+            buf <<= 4;\n+\n+            match byte as char {\n+                'A'..'F' => buf |= byte - ('A' as u8) + 10,\n+                'a'..'f' => buf |= byte - ('a' as u8) + 10,\n+                '0'..'9' => buf |= byte - ('0' as u8),\n+                ' '|'\\r'|'\\n'|'\\t' => {\n+                    buf >>= 4;\n+                    loop\n+                }\n+                _ => return Err(fmt!(\"Invalid character '%c' at position %u\",\n+                                     self.char_at(idx), idx))\n+            }\n+\n+            modulus += 1;\n+            if modulus == 2 {\n+                modulus = 0;\n+                b.push(buf);\n+            }\n+        }\n+\n+        match modulus {\n+            0 => Ok(b),\n+            _ => Err(~\"Invalid input length\")\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test::BenchHarness;\n+    use hex::*;\n+\n+    #[test]\n+    pub fn test_to_hex() {\n+        assert_eq!(\"foobar\".as_bytes().to_hex(), ~\"666f6f626172\");\n+    }\n+\n+    #[test]\n+    pub fn test_from_hex_okay() {\n+        assert_eq!(\"666f6f626172\".from_hex().unwrap(),\n+                   \"foobar\".as_bytes().to_owned());\n+        assert_eq!(\"666F6F626172\".from_hex().unwrap(),\n+                   \"foobar\".as_bytes().to_owned());\n+    }\n+\n+    #[test]\n+    pub fn test_from_hex_odd_len() {\n+        assert!(\"666\".from_hex().is_err());\n+        assert!(\"66 6\".from_hex().is_err());\n+    }\n+\n+    #[test]\n+    pub fn test_from_hex_invalid_char() {\n+        assert!(\"66y6\".from_hex().is_err());\n+    }\n+\n+    #[test]\n+    pub fn test_from_hex_ignores_whitespace() {\n+        assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().unwrap(),\n+                   \"foobar\".as_bytes().to_owned());\n+    }\n+\n+    #[test]\n+    pub fn test_to_hex_all_bytes() {\n+        for i in range(0, 256) {\n+            assert_eq!([i as u8].to_hex(), fmt!(\"%02x\", i as uint));\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_from_hex_all_bytes() {\n+        for i in range(0, 256) {\n+            assert_eq!(fmt!(\"%02x\", i as uint).from_hex().unwrap(), ~[i as u8]);\n+            assert_eq!(fmt!(\"%02X\", i as uint).from_hex().unwrap(), ~[i as u8]);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_to_hex(bh: & mut BenchHarness) {\n+        let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n+                 \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n+        do bh.iter {\n+            s.as_bytes().to_hex();\n+        }\n+        bh.bytes = s.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn bench_from_hex(bh: & mut BenchHarness) {\n+        let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n+                 \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n+        let b = s.as_bytes().to_hex();\n+        do bh.iter {\n+            b.from_hex();\n+        }\n+        bh.bytes = b.len() as u64;\n+    }\n+}"}, {"sha": "7fd47fdbd3999a7f336e837e0c67e008381b15d4", "filename": "src/libextra/iter.rs", "status": "removed", "additions": 0, "deletions": 331, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/aababbba8e5d5b56aa4a0cedb9b2008ba6cdc422/src%2Flibextra%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aababbba8e5d5b56aa4a0cedb9b2008ba6cdc422/src%2Flibextra%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fiter.rs?ref=aababbba8e5d5b56aa4a0cedb9b2008ba6cdc422", "patch": "@@ -1,331 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*! Composable internal iterators\n-\n-Internal iterators are functions implementing the protocol used by the `for` loop.\n-\n-An internal iterator takes `fn(...) -> bool` as a parameter, with returning `false` used to signal\n-breaking out of iteration. The adaptors in the module work with any such iterator, not just ones\n-tied to specific traits. For example:\n-\n-~~~ {.rust}\n-println(iter::to_vec(|f| uint::range(0, 20, f)).to_str());\n-~~~\n-\n-An external iterator object implementing the interface in the `iterator` module can be used as an\n-internal iterator by calling the `advance` method. For example:\n-\n-~~~ {.rust}\n-let xs = [0u, 1, 2, 3, 4, 5];\n-let ys = [30, 40, 50, 60];\n-let mut it = xs.iter().chain(ys.iter());\n-for &x: &uint in it {\n-    println(x.to_str());\n-}\n-~~~\n-\n-Internal iterators provide a subset of the functionality of an external iterator. It's not possible\n-to interleave them to implement algorithms like `zip`, `union` and `merge`. However, they're often\n-much easier to implement.\n-\n-*/\n-\n-use std::vec;\n-use std::cmp::Ord;\n-use std::option::{Option, Some, None};\n-use std::num::{One, Zero};\n-use std::ops::{Add, Mul};\n-\n-#[allow(missing_doc)]\n-pub trait FromIter<T> {\n-    /// Build a container with elements from an internal iterator.\n-    ///\n-    /// # Example:\n-    ///\n-    /// ~~~ {.rust}\n-    /// let xs = ~[1, 2, 3];\n-    /// let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n-    /// assert_eq!(xs, ys);\n-    /// ~~~\n-    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> Self;\n-}\n-\n-/**\n- * Return true if `predicate` is true for any values yielded by an internal iterator.\n- *\n- * Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[1u, 2, 3, 4, 5];\n- * assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n- * assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n- * ~~~\n- */\n-#[inline]\n-pub fn any<T>(predicate: &fn(T) -> bool,\n-              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n-    do iter |x| {\n-        predicate(x)\n-    }\n-}\n-\n-/**\n- * Return true if `predicate` is true for all values yielded by an internal iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * assert!(all(|&x: &uint| x < 6, |f| uint::range(1, 6, f)));\n- * assert!(!all(|&x: &uint| x < 5, |f| uint::range(1, 6, f)));\n- * ~~~\n- */\n-#[inline]\n-pub fn all<T>(predicate: &fn(T) -> bool,\n-              iter: &fn(f: &fn(T) -> bool) -> bool) -> bool {\n-    // If we ever break, iter will return false, so this will only return true\n-    // if predicate returns true for everything.\n-    iter(|x| predicate(x))\n-}\n-\n-/**\n- * Return the first element where `predicate` returns `true`. Return `None` if no element is found.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[1u, 2, 3, 4, 5, 6];\n- * assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n- * ~~~\n- */\n-#[inline]\n-pub fn find<T>(predicate: &fn(&T) -> bool,\n-               iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    let mut ret = None;\n-    do iter |x| {\n-        if predicate(&x) {\n-            ret = Some(x);\n-            false\n-        } else { true }\n-    };\n-    ret\n-}\n-\n-/**\n- * Return the largest item yielded by an iterator. Return `None` if the iterator is empty.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n- * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n- * ~~~\n- */\n-#[inline]\n-pub fn max<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    let mut result = None;\n-    do iter |x| {\n-        match result {\n-            Some(ref mut y) => {\n-                if x > *y {\n-                    *y = x;\n-                }\n-            }\n-            None => result = Some(x)\n-        }\n-        true\n-    };\n-    result\n-}\n-\n-/**\n- * Return the smallest item yielded by an iterator. Return `None` if the iterator is empty.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n- * assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &-5);\n- * ~~~\n- */\n-#[inline]\n-pub fn min<T: Ord>(iter: &fn(f: &fn(T) -> bool) -> bool) -> Option<T> {\n-    let mut result = None;\n-    do iter |x| {\n-        match result {\n-            Some(ref mut y) => {\n-                if x < *y {\n-                    *y = x;\n-                }\n-            }\n-            None => result = Some(x)\n-        }\n-        true\n-    };\n-    result\n-}\n-\n-/**\n- * Reduce an iterator to an accumulated value.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n- * ~~~\n- */\n-#[inline]\n-pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T, U)) -> T {\n-    let mut result = start;\n-    do iter |x| {\n-        f(&mut result, x);\n-        true\n-    };\n-    result\n-}\n-\n-/**\n- * Reduce an iterator to an accumulated value.\n- *\n- * `fold_ref` is usable in some generic functions where `fold` is too lenient to type-check, but it\n- * forces the iterator to yield borrowed pointers.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n- *     fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n- * }\n- * ~~~\n- */\n-#[inline]\n-pub fn fold_ref<T, U>(start: T, iter: &fn(f: &fn(&U) -> bool) -> bool, f: &fn(&mut T, &U)) -> T {\n-    let mut result = start;\n-    do iter |x| {\n-        f(&mut result, x);\n-        true\n-    };\n-    result\n-}\n-\n-/**\n- * Return the sum of the items yielding by an iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs: ~[int] = ~[1, 2, 3, 4];\n- * assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n- * ~~~\n- */\n-#[inline]\n-pub fn sum<T: Zero + Add<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n-    fold_ref(Zero::zero::<T>(), iter, |a, x| *a = a.add(x))\n-}\n-\n-/**\n- * Return the product of the items yielded by an iterator.\n- *\n- * # Example:\n- *\n- * ~~~ {.rust}\n- * let xs: ~[int] = ~[1, 2, 3, 4];\n- * assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n- * ~~~\n- */\n-#[inline]\n-pub fn product<T: One + Mul<T, T>>(iter: &fn(f: &fn(&T) -> bool) -> bool) -> T {\n-    fold_ref(One::one::<T>(), iter, |a, x| *a = a.mul(x))\n-}\n-\n-impl<T> FromIter<T> for ~[T]{\n-    #[inline]\n-    pub fn from_iter(iter: &fn(f: &fn(T) -> bool) -> bool) -> ~[T] {\n-        let mut v = ~[];\n-        do iter |x| { v.push(x); true };\n-        v\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use prelude::*;\n-\n-    use int;\n-    use uint;\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = ~[1, 2, 3];\n-        let ys: ~[int] = do FromIter::from_iter |f| { xs.iter().advance(|x| f(*x)) };\n-        assert_eq!(xs, ys);\n-    }\n-\n-    #[test]\n-    fn test_any() {\n-        let xs = ~[1u, 2, 3, 4, 5];\n-        assert!(any(|&x: &uint| x > 2, |f| xs.iter().advance(f)));\n-        assert!(!any(|&x: &uint| x > 5, |f| xs.iter().advance(f)));\n-    }\n-\n-    #[test]\n-    fn test_all() {\n-        assert!(all(|x: uint| x < 6, |f| uint::range(1, 6, f)));\n-        assert!(!all(|x: uint| x < 5, |f| uint::range(1, 6, f)));\n-    }\n-\n-    #[test]\n-    fn test_find() {\n-        let xs = ~[1u, 2, 3, 4, 5, 6];\n-        assert_eq!(*find(|& &x: & &uint| x > 3, |f| xs.iter().advance(f)).unwrap(), 4);\n-    }\n-\n-    #[test]\n-    fn test_max() {\n-        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n-        assert_eq!(max(|f| xs.iter().advance(f)).unwrap(), &15);\n-    }\n-\n-    #[test]\n-    fn test_min() {\n-        let xs = ~[8, 2, 3, 1, -5, 9, 11, 15];\n-        assert_eq!(min(|f| xs.iter().advance(f)).unwrap(), &-5);\n-    }\n-\n-    #[test]\n-    fn test_fold() {\n-        assert_eq!(fold(0i, |f| int::range(1, 5, f), |a, x| *a += x), 10);\n-    }\n-\n-    #[test]\n-    fn test_sum() {\n-        let xs: ~[int] = ~[1, 2, 3, 4];\n-        assert_eq!(do sum |f| { xs.iter().advance(f) }, 10);\n-    }\n-\n-    #[test]\n-    fn test_empty_sum() {\n-        let xs: ~[int] = ~[];\n-        assert_eq!(do sum |f| { xs.iter().advance(f) }, 0);\n-    }\n-\n-    #[test]\n-    fn test_product() {\n-        let xs: ~[int] = ~[1, 2, 3, 4];\n-        assert_eq!(do product |f| { xs.iter().advance(f) }, 24);\n-    }\n-\n-    #[test]\n-    fn test_empty_product() {\n-        let xs: ~[int] = ~[];\n-        assert_eq!(do product |f| { xs.iter().advance(f) }, 1);\n-    }\n-}"}, {"sha": "da8089250b34587a24cd3191031c87c286b40f1d", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -696,7 +696,7 @@ mod tests {\n         let u: ~[int] = deq.iter().transform(|&x| x).collect();\n         assert_eq!(u, v);\n \n-        let mut seq = iterator::Counter::new(0u, 2).take_(256);\n+        let mut seq = iterator::count(0u, 2).take_(256);\n         let deq: RingBuf<uint> = seq.collect();\n         for (i, &x) in deq.iter().enumerate() {\n             assert_eq!(2*i, x);"}, {"sha": "b1e600b9d7376f5466d53ba06a500a948fe8e90d", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -888,6 +888,11 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let offset = get_param(decl, first_real_arg + 1);\n             Ret(bcx, GEP(bcx, ptr, [offset]));\n         }\n+        \"offset_inbounds\" => {\n+            let ptr = get_param(decl, first_real_arg);\n+            let offset = get_param(decl, first_real_arg + 1);\n+            Ret(bcx, InBoundsGEP(bcx, ptr, [offset]));\n+        }\n         \"memcpy32\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i32\", substs.tys[0], 32),\n         \"memcpy64\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i64\", substs.tys[0], 64),\n         \"memmove32\" => memcpy_intrinsic(bcx, \"llvm.memmove.p0i8.p0i8.i32\", substs.tys[0], 32),"}, {"sha": "ad83286c8c1d75a60353ab2a36c2f248f0665f26", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -148,7 +148,8 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n                     \"visit_tydesc\"  | \"forget\" | \"frame_address\" |\n                     \"morestack_addr\" => 0,\n \n-                    \"offset\" | \"memcpy32\" | \"memcpy64\" | \"memmove32\" | \"memmove64\" |\n+                    \"offset\" | \"offset_inbounds\" |\n+                    \"memcpy32\" | \"memcpy64\" | \"memmove32\" | \"memmove64\" |\n                     \"memset32\" | \"memset64\" => use_repr,\n \n                     \"sqrtf32\" | \"sqrtf64\" | \"powif32\" | \"powif64\" |"}, {"sha": "8623ee546d6603a0c6cb2ff52b7e31afb299a16e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -3481,6 +3481,20 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                    mutbl: ast::m_imm\n                }))\n             }\n+            \"offset_inbounds\" => {\n+              (1,\n+               ~[\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_imm\n+                  }),\n+                  ty::mk_int()\n+               ],\n+               ty::mk_ptr(tcx, ty::mt {\n+                   ty: param(ccx, 0),\n+                   mutbl: ast::m_imm\n+               }))\n+            }\n             \"memcpy32\" => {\n               (1,\n                ~["}, {"sha": "f05c59083f40f49f5288e1348b6a2a126c4a366e", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -637,7 +637,7 @@ mod test {\n         let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n         write_markdown(doc, writer_factory);\n         // We expect two pages to have been written\n-        do 2.times {\n+        for _ in range(0, 2u) {\n             po.recv();\n         }\n     }\n@@ -649,7 +649,7 @@ mod test {\n             ~\"#[link(name = \\\"core\\\")]; mod a { }\");\n         let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n         write_markdown(doc, writer_factory);\n-        do 2.times {\n+        for _ in range(0, 2u) {\n             let (page, markdown) = po.recv();\n             match page {\n                 doc::CratePage(_) => {"}, {"sha": "5d5518997f68f0252ab8e9c3acd276c0dec417f7", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -565,7 +565,10 @@ mod tests {\n         }\n     }\n \n-    #[cfg(not(target_word_size = \"32\"))]\n+    // FIXME: #7220 rusti on 32bit mac doesn't work.\n+    // FIXME: #7641 rusti on 32bit linux cross compile doesn't work\n+    // FIXME: #7115 re-enable once LLVM has been upgraded\n+    #[cfg(thiswillneverbeacfgflag)]\n     fn run_program(prog: &str) {\n         let mut r = repl();\n         for cmd in prog.split_iter('\\n') {\n@@ -574,9 +577,6 @@ mod tests {\n                     \"the command '%s' failed\", cmd);\n         }\n     }\n-    // FIXME: #7220 rusti on 32bit mac doesn't work\n-    // FIXME: #7641 rusti on 32bit linux cross compile doesn't work\n-    #[cfg(target_word_size = \"32\")]\n     fn run_program(_: &str) {}\n \n     #[test]\n@@ -594,12 +594,13 @@ mod tests {\n         run_program(\"let a = 3;\");\n     }\n \n-    #[test]\n+    #[test] #[ignore]\n     fn new_tasks() {\n+        // XXX: can't spawn new tasks because the JIT code is cleaned up\n+        //      after the main function is done.\n         run_program(\"\n-            use std::task::try;\n-            try( || println(\\\"Please don't segfault\\\") );\n-            do try { println(\\\"Please?\\\"); }\n+            spawn( || println(\\\"Please don't segfault\\\") );\n+            do spawn { println(\\\"Please?\\\"); }\n         \");\n     }\n "}, {"sha": "6c3d4c5f1fbeab4d82dec81c1543d7e4eeb74939", "filename": "src/libstd/borrow.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fborrow.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -58,3 +58,15 @@ impl<'self, T: Ord> Ord for &'self T {\n         *(*self) > *(*other)\n     }\n }\n+\n+#[cfg(not(test))]\n+impl<'self, T: TotalOrd> TotalOrd for &'self T {\n+    #[inline]\n+    fn cmp(&self, other: & &'self T) -> Ordering { (**self).cmp(*other) }\n+}\n+\n+#[cfg(not(test))]\n+impl<'self, T: TotalEq> TotalEq for &'self T {\n+    #[inline]\n+    fn equals(&self, other: & &'self T) -> bool { (**self).equals(*other) }\n+}"}, {"sha": "b66f89e83415e1b22ad0a575f950f1855057460f", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -153,7 +153,6 @@ pub fn cmp2<A:TotalOrd,B:TotalOrd>(\n Return `o1` if it is not `Equal`, otherwise `o2`. Simulates the\n lexical ordering on a type `(int, int)`.\n */\n-// used in deriving code in libsyntax\n #[inline]\n pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n     match o1 {"}, {"sha": "1be398966bbeba7281775a4929559dec9fba2ba7", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 26, "deletions": 44, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -18,7 +18,7 @@ implementing the `Iterator` trait.\n */\n \n use cmp;\n-use num::{Zero, One};\n+use num::{Zero, One, Saturating};\n use option::{Option, Some, None};\n use ops::{Add, Mul};\n use cmp::Ord;\n@@ -313,7 +313,7 @@ pub trait IteratorUtil<A> {\n     /// ~~~ {.rust}\n     /// let xs = [2u, 3];\n     /// let ys = [0u, 1, 0, 1, 2];\n-    /// let mut it = xs.iter().flat_map_(|&x| Counter::new(0u, 1).take_(x));\n+    /// let mut it = xs.iter().flat_map_(|&x| count(0u, 1).take_(x));\n     /// // Check that `it` has the same elements as `ys`\n     /// let mut i = 0;\n     /// for x: uint in it {\n@@ -351,7 +351,7 @@ pub trait IteratorUtil<A> {\n     /// ~~~ {.rust}\n     /// use std::iterator::Counter;\n     ///\n-    /// for i in Counter::new(0, 10) {\n+    /// for i in count(0, 10) {\n     ///     printfln!(\"%d\", i);\n     /// }\n     /// ~~~\n@@ -723,7 +723,7 @@ pub trait MultiplicativeIterator<A> {\n     /// use std::iterator::Counter;\n     ///\n     /// fn factorial(n: uint) -> uint {\n-    ///     Counter::new(1u, 1).take_while(|&i| i <= n).product()\n+    ///     count(1u, 1).take_while(|&i| i <= n).product()\n     /// }\n     /// assert!(factorial(0) == 1);\n     /// assert!(factorial(1) == 1);\n@@ -790,7 +790,7 @@ pub trait ClonableIterator {\n     /// # Example\n     ///\n     /// ~~~ {.rust}\n-    /// let a = Counter::new(1,1).take_(1);\n+    /// let a = count(1,1).take_(1);\n     /// let mut cy = a.cycle();\n     /// assert_eq!(cy.next(), Some(1));\n     /// assert_eq!(cy.next(), Some(1));\n@@ -884,15 +884,10 @@ impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for Chain<T, U> {\n         let (a_lower, a_upper) = self.a.size_hint();\n         let (b_lower, b_upper) = self.b.size_hint();\n \n-        let lower = if uint::max_value - a_lower < b_lower {\n-            uint::max_value\n-        } else {\n-            a_lower + b_lower\n-        };\n+        let lower = a_lower.saturating_add(b_lower);\n \n         let upper = match (a_upper, b_upper) {\n-            (Some(x), Some(y)) if uint::max_value - x < y => Some(uint::max_value),\n-            (Some(x), Some(y)) => Some(x + y),\n+            (Some(x), Some(y)) => Some(x.saturating_add(y)),\n             _ => None\n         };\n \n@@ -916,12 +911,7 @@ for Chain<T, U> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         let (a, b) = (self.a.indexable(), self.b.indexable());\n-        let total = a + b;\n-        if total < a || total < b {\n-            uint::max_value\n-        } else {\n-            total\n-        }\n+        a.saturating_add(b)\n     }\n \n     #[inline]\n@@ -1273,11 +1263,10 @@ impl<A, T: Iterator<A>> Iterator<A> for Skip<T> {\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         let (lower, upper) = self.iter.size_hint();\n \n-        let lower = if lower >= self.n { lower - self.n } else { 0 };\n+        let lower = lower.saturating_sub(self.n);\n \n         let upper = match upper {\n-            Some(x) if x >= self.n => Some(x - self.n),\n-            Some(_) => Some(0),\n+            Some(x) => Some(x.saturating_sub(self.n)),\n             None => None\n         };\n \n@@ -1288,12 +1277,7 @@ impl<A, T: Iterator<A>> Iterator<A> for Skip<T> {\n impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Skip<T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n-        let N = self.iter.indexable();\n-        if N < self.n {\n-            0\n-        } else {\n-            N - self.n\n-        }\n+        self.iter.indexable().saturating_sub(self.n)\n     }\n \n     #[inline]\n@@ -1316,10 +1300,9 @@ pub struct Take<T> {\n impl<A, T: Iterator<A>> Iterator<A> for Take<T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        let next = self.iter.next();\n         if self.n != 0 {\n             self.n -= 1;\n-            next\n+            self.iter.next()\n         } else {\n             None\n         }\n@@ -1410,9 +1393,10 @@ impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         let (flo, fhi) = self.frontiter.map_default((0, Some(0)), |it| it.size_hint());\n         let (blo, bhi) = self.backiter.map_default((0, Some(0)), |it| it.size_hint());\n+        let lo = flo.saturating_add(blo);\n         match (self.iter.size_hint(), fhi, bhi) {\n-            ((0, Some(0)), Some(a), Some(b)) => (flo + blo, Some(a + b)),\n-            _ => (flo + blo, None)\n+            ((0, Some(0)), Some(a), Some(b)) => (lo, Some(a.saturating_add(b))),\n+            _ => (lo, None)\n         }\n     }\n }\n@@ -1527,12 +1511,10 @@ pub struct Counter<A> {\n     step: A\n }\n \n-impl<A> Counter<A> {\n-    /// Creates a new counter with the specified start/step\n-    #[inline]\n-    pub fn new(start: A, step: A) -> Counter<A> {\n-        Counter{state: start, step: step}\n-    }\n+/// Creates a new counter with the specified start/step\n+#[inline]\n+pub fn count<A>(start: A, step: A) -> Counter<A> {\n+    Counter{state: start, step: step}\n }\n \n /// A range of numbers from [0, N)\n@@ -1619,7 +1601,7 @@ mod tests {\n \n     #[test]\n     fn test_counter_from_iter() {\n-        let mut it = Counter::new(0, 5).take_(10);\n+        let mut it = count(0, 5).take_(10);\n         let xs: ~[int] = FromIterator::from_iterator(&mut it);\n         assert_eq!(xs, ~[0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n     }\n@@ -1637,7 +1619,7 @@ mod tests {\n         }\n         assert_eq!(i, expected.len());\n \n-        let ys = Counter::new(30u, 10).take_(4);\n+        let ys = count(30u, 10).take_(4);\n         let mut it = xs.iter().transform(|&x| x).chain_(ys);\n         let mut i = 0;\n         for x in it {\n@@ -1649,7 +1631,7 @@ mod tests {\n \n     #[test]\n     fn test_filter_map() {\n-        let mut it = Counter::new(0u, 1u).take_(10)\n+        let mut it = count(0u, 1u).take_(10)\n             .filter_map(|x| if x.is_even() { Some(x*x) } else { None });\n         assert_eq!(it.collect::<~[uint]>(), ~[0*0, 2*2, 4*4, 6*6, 8*8]);\n     }\n@@ -1738,7 +1720,7 @@ mod tests {\n     fn test_iterator_flat_map() {\n         let xs = [0u, 3, 6];\n         let ys = [0u, 1, 2, 3, 4, 5, 6, 7, 8];\n-        let mut it = xs.iter().flat_map_(|&x| Counter::new(x, 1).take_(3));\n+        let mut it = xs.iter().flat_map_(|&x| count(x, 1).take_(3));\n         let mut i = 0;\n         for x in it {\n             assert_eq!(x, ys[i]);\n@@ -1785,13 +1767,13 @@ mod tests {\n     #[test]\n     fn test_cycle() {\n         let cycle_len = 3;\n-        let it = Counter::new(0u, 1).take_(cycle_len).cycle();\n+        let it = count(0u, 1).take_(cycle_len).cycle();\n         assert_eq!(it.size_hint(), (uint::max_value, None));\n         for (i, x) in it.take_(100).enumerate() {\n             assert_eq!(i % cycle_len, x);\n         }\n \n-        let mut it = Counter::new(0u, 1).take_(0).cycle();\n+        let mut it = count(0u, 1).take_(0).cycle();\n         assert_eq!(it.size_hint(), (0, Some(0)));\n         assert_eq!(it.next(), None);\n     }\n@@ -1853,7 +1835,7 @@ mod tests {\n \n     #[test]\n     fn test_iterator_size_hint() {\n-        let c = Counter::new(0, 1);\n+        let c = count(0, 1);\n         let v = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n         let v2 = &[10, 11, 12];\n         let vi = v.iter();"}, {"sha": "57230b2fd247d4e86d9a844dc6bc39c798056378", "filename": "src/libstd/managed.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmanaged.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -12,7 +12,7 @@\n \n use ptr::to_unsafe_ptr;\n \n-#[cfg(not(test))] use cmp::{Eq, Ord};\n+#[cfg(not(test))] use cmp::*;\n \n pub static RC_MANAGED_UNIQUE : uint = (-2) as uint;\n pub static RC_IMMORTAL : uint = 0x77777777;\n@@ -71,6 +71,29 @@ impl<T:Ord> Ord for @mut T {\n     fn gt(&self, other: &@mut T) -> bool { *(*self) > *(*other) }\n }\n \n+#[cfg(not(test))]\n+impl<T: TotalOrd> TotalOrd for @T {\n+    #[inline]\n+    fn cmp(&self, other: &@T) -> Ordering { (**self).cmp(*other) }\n+}\n+\n+#[cfg(not(test))]\n+impl<T: TotalOrd> TotalOrd for @mut T {\n+    #[inline]\n+    fn cmp(&self, other: &@mut T) -> Ordering { (**self).cmp(*other) }\n+}\n+\n+#[cfg(not(test))]\n+impl<T: TotalEq> TotalEq for @T {\n+    #[inline]\n+    fn equals(&self, other: &@T) -> bool { (**self).equals(*other) }\n+}\n+\n+#[cfg(not(test))]\n+impl<T: TotalEq> TotalEq for @mut T {\n+    #[inline]\n+    fn equals(&self, other: &@mut T) -> bool { (**self).equals(*other) }\n+}\n #[test]\n fn test() {\n     let x = @3;"}, {"sha": "bbadf1caca2413c4570460ac9040d28cc1940554", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 157, "deletions": 60, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -466,6 +466,56 @@ impl<T: Zero> Zero for ~T {\n     fn is_zero(&self) -> bool { (**self).is_zero() }\n }\n \n+/// Saturating math operations\n+pub trait Saturating: Int {\n+    /// Saturating addition operator.\n+    /// Returns a+b, saturating at the numeric bounds instead of overflowing.\n+    #[inline]\n+    fn saturating_add(self, v: Self) -> Self {\n+        let x = self + v;\n+        if v >= Zero::zero() {\n+            if x < self {\n+                // overflow\n+                Bounded::max_value::<Self>()\n+            } else { x }\n+        } else {\n+            if x > self {\n+                // underflow\n+                Bounded::min_value::<Self>()\n+            } else { x }\n+        }\n+    }\n+\n+    /// Saturating subtraction operator.\n+    /// Returns a-b, saturating at the numeric bounds instead of overflowing.\n+    #[inline]\n+    fn saturating_sub(self, v: Self) -> Self {\n+        let x = self - v;\n+        if v >= Zero::zero() {\n+            if x > self {\n+                // underflow\n+                Bounded::min_value::<Self>()\n+            } else { x }\n+        } else {\n+            if x < self {\n+                // overflow\n+                Bounded::max_value::<Self>()\n+            } else { x }\n+        }\n+    }\n+}\n+\n+impl Saturating for int {}\n+impl Saturating for i8 {}\n+impl Saturating for i16 {}\n+impl Saturating for i32 {}\n+impl Saturating for i64 {}\n+impl Saturating for uint {}\n+impl Saturating for u8 {}\n+impl Saturating for u16 {}\n+impl Saturating for u32 {}\n+impl Saturating for u64 {}\n+\n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T:Num + NumCast>(ten: T, two: T) {\n@@ -482,64 +532,111 @@ pub fn test_num<T:Num + NumCast>(ten: T, two: T) {\n     assert_eq!(ten.rem(&two),  ten % two);\n }\n \n-macro_rules! test_cast_20(\n-    ($_20:expr) => ({\n-        let _20 = $_20;\n-\n-        assert_eq!(20u,   _20.to_uint());\n-        assert_eq!(20u8,  _20.to_u8());\n-        assert_eq!(20u16, _20.to_u16());\n-        assert_eq!(20u32, _20.to_u32());\n-        assert_eq!(20u64, _20.to_u64());\n-        assert_eq!(20i,   _20.to_int());\n-        assert_eq!(20i8,  _20.to_i8());\n-        assert_eq!(20i16, _20.to_i16());\n-        assert_eq!(20i32, _20.to_i32());\n-        assert_eq!(20i64, _20.to_i64());\n-        assert_eq!(20f,   _20.to_float());\n-        assert_eq!(20f32, _20.to_f32());\n-        assert_eq!(20f64, _20.to_f64());\n-\n-        assert_eq!(_20, NumCast::from(20u));\n-        assert_eq!(_20, NumCast::from(20u8));\n-        assert_eq!(_20, NumCast::from(20u16));\n-        assert_eq!(_20, NumCast::from(20u32));\n-        assert_eq!(_20, NumCast::from(20u64));\n-        assert_eq!(_20, NumCast::from(20i));\n-        assert_eq!(_20, NumCast::from(20i8));\n-        assert_eq!(_20, NumCast::from(20i16));\n-        assert_eq!(_20, NumCast::from(20i32));\n-        assert_eq!(_20, NumCast::from(20i64));\n-        assert_eq!(_20, NumCast::from(20f));\n-        assert_eq!(_20, NumCast::from(20f32));\n-        assert_eq!(_20, NumCast::from(20f64));\n-\n-        assert_eq!(_20, cast(20u));\n-        assert_eq!(_20, cast(20u8));\n-        assert_eq!(_20, cast(20u16));\n-        assert_eq!(_20, cast(20u32));\n-        assert_eq!(_20, cast(20u64));\n-        assert_eq!(_20, cast(20i));\n-        assert_eq!(_20, cast(20i8));\n-        assert_eq!(_20, cast(20i16));\n-        assert_eq!(_20, cast(20i32));\n-        assert_eq!(_20, cast(20i64));\n-        assert_eq!(_20, cast(20f));\n-        assert_eq!(_20, cast(20f32));\n-        assert_eq!(_20, cast(20f64));\n-    })\n-)\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    macro_rules! test_cast_20(\n+        ($_20:expr) => ({\n+            let _20 = $_20;\n+\n+            assert_eq!(20u,   _20.to_uint());\n+            assert_eq!(20u8,  _20.to_u8());\n+            assert_eq!(20u16, _20.to_u16());\n+            assert_eq!(20u32, _20.to_u32());\n+            assert_eq!(20u64, _20.to_u64());\n+            assert_eq!(20i,   _20.to_int());\n+            assert_eq!(20i8,  _20.to_i8());\n+            assert_eq!(20i16, _20.to_i16());\n+            assert_eq!(20i32, _20.to_i32());\n+            assert_eq!(20i64, _20.to_i64());\n+            assert_eq!(20f,   _20.to_float());\n+            assert_eq!(20f32, _20.to_f32());\n+            assert_eq!(20f64, _20.to_f64());\n+\n+            assert_eq!(_20, NumCast::from(20u));\n+            assert_eq!(_20, NumCast::from(20u8));\n+            assert_eq!(_20, NumCast::from(20u16));\n+            assert_eq!(_20, NumCast::from(20u32));\n+            assert_eq!(_20, NumCast::from(20u64));\n+            assert_eq!(_20, NumCast::from(20i));\n+            assert_eq!(_20, NumCast::from(20i8));\n+            assert_eq!(_20, NumCast::from(20i16));\n+            assert_eq!(_20, NumCast::from(20i32));\n+            assert_eq!(_20, NumCast::from(20i64));\n+            assert_eq!(_20, NumCast::from(20f));\n+            assert_eq!(_20, NumCast::from(20f32));\n+            assert_eq!(_20, NumCast::from(20f64));\n+\n+            assert_eq!(_20, cast(20u));\n+            assert_eq!(_20, cast(20u8));\n+            assert_eq!(_20, cast(20u16));\n+            assert_eq!(_20, cast(20u32));\n+            assert_eq!(_20, cast(20u64));\n+            assert_eq!(_20, cast(20i));\n+            assert_eq!(_20, cast(20i8));\n+            assert_eq!(_20, cast(20i16));\n+            assert_eq!(_20, cast(20i32));\n+            assert_eq!(_20, cast(20i64));\n+            assert_eq!(_20, cast(20f));\n+            assert_eq!(_20, cast(20f32));\n+            assert_eq!(_20, cast(20f64));\n+        })\n+    )\n+\n+    #[test] fn test_u8_cast()    { test_cast_20!(20u8)  }\n+    #[test] fn test_u16_cast()   { test_cast_20!(20u16) }\n+    #[test] fn test_u32_cast()   { test_cast_20!(20u32) }\n+    #[test] fn test_u64_cast()   { test_cast_20!(20u64) }\n+    #[test] fn test_uint_cast()  { test_cast_20!(20u)   }\n+    #[test] fn test_i8_cast()    { test_cast_20!(20i8)  }\n+    #[test] fn test_i16_cast()   { test_cast_20!(20i16) }\n+    #[test] fn test_i32_cast()   { test_cast_20!(20i32) }\n+    #[test] fn test_i64_cast()   { test_cast_20!(20i64) }\n+    #[test] fn test_int_cast()   { test_cast_20!(20i)   }\n+    #[test] fn test_f32_cast()   { test_cast_20!(20f32) }\n+    #[test] fn test_f64_cast()   { test_cast_20!(20f64) }\n+    #[test] fn test_float_cast() { test_cast_20!(20f)   }\n+\n+    #[test]\n+    fn test_saturating_add_uint() {\n+        use uint::max_value;\n+        assert_eq!(3u.saturating_add(5u), 8u);\n+        assert_eq!(3u.saturating_add(max_value-1), max_value);\n+        assert_eq!(max_value.saturating_add(max_value), max_value);\n+        assert_eq!((max_value-2).saturating_add(1), max_value-1);\n+    }\n+\n+    #[test]\n+    fn test_saturating_sub_uint() {\n+        use uint::max_value;\n+        assert_eq!(5u.saturating_sub(3u), 2u);\n+        assert_eq!(3u.saturating_sub(5u), 0u);\n+        assert_eq!(0u.saturating_sub(1u), 0u);\n+        assert_eq!((max_value-1).saturating_sub(max_value), 0);\n+    }\n \n-#[test] fn test_u8_cast()    { test_cast_20!(20u8)  }\n-#[test] fn test_u16_cast()   { test_cast_20!(20u16) }\n-#[test] fn test_u32_cast()   { test_cast_20!(20u32) }\n-#[test] fn test_u64_cast()   { test_cast_20!(20u64) }\n-#[test] fn test_uint_cast()  { test_cast_20!(20u)   }\n-#[test] fn test_i8_cast()    { test_cast_20!(20i8)  }\n-#[test] fn test_i16_cast()   { test_cast_20!(20i16) }\n-#[test] fn test_i32_cast()   { test_cast_20!(20i32) }\n-#[test] fn test_i64_cast()   { test_cast_20!(20i64) }\n-#[test] fn test_int_cast()   { test_cast_20!(20i)   }\n-#[test] fn test_f32_cast()   { test_cast_20!(20f32) }\n-#[test] fn test_f64_cast()   { test_cast_20!(20f64) }\n-#[test] fn test_float_cast() { test_cast_20!(20f)   }\n+    #[test]\n+    fn test_saturating_add_int() {\n+        use int::{min_value,max_value};\n+        assert_eq!(3i.saturating_add(5i), 8i);\n+        assert_eq!(3i.saturating_add(max_value-1), max_value);\n+        assert_eq!(max_value.saturating_add(max_value), max_value);\n+        assert_eq!((max_value-2).saturating_add(1), max_value-1);\n+        assert_eq!(3i.saturating_add(-5i), -2i);\n+        assert_eq!(min_value.saturating_add(-1i), min_value);\n+        assert_eq!((-2i).saturating_add(-max_value), min_value);\n+    }\n+\n+    #[test]\n+    fn test_saturating_sub_int() {\n+        use int::{min_value,max_value};\n+        assert_eq!(3i.saturating_sub(5i), -2i);\n+        assert_eq!(min_value.saturating_sub(1i), min_value);\n+        assert_eq!((-2i).saturating_sub(max_value), min_value);\n+        assert_eq!(3i.saturating_sub(-5i), 8i);\n+        assert_eq!(3i.saturating_sub(-(max_value-1)), max_value);\n+        assert_eq!(max_value.saturating_sub(-max_value), max_value);\n+        assert_eq!((max_value-2).saturating_sub(-1), max_value-1);\n+    }\n+}"}, {"sha": "424c4fd6b2f44d0e4f4102e04e1827a62f667670", "filename": "src/libstd/owned.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fowned.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations on unique pointer types\n \n-#[cfg(not(test))] use cmp::{Eq, Ord};\n+#[cfg(not(test))] use cmp::*;\n \n #[cfg(not(test))]\n impl<T:Eq> Eq for ~T {\n@@ -31,3 +31,15 @@ impl<T:Ord> Ord for ~T {\n     #[inline]\n     fn gt(&self, other: &~T) -> bool { *(*self) > *(*other) }\n }\n+\n+#[cfg(not(test))]\n+impl<T: TotalOrd> TotalOrd for ~T {\n+    #[inline]\n+    fn cmp(&self, other: &~T) -> Ordering { (**self).cmp(*other) }\n+}\n+\n+#[cfg(not(test))]\n+impl<T: TotalEq> TotalEq for ~T {\n+    #[inline]\n+    fn equals(&self, other: &~T) -> bool { (**self).equals(*other) }\n+}"}, {"sha": "f035e61fa1e08a6db8c480f727bcee5dba082086", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -50,6 +50,7 @@ pub use char::Char;\n pub use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n pub use hash::Hash;\n pub use iter::Times;\n+pub use iterator::Extendable;\n pub use iterator::{Iterator, IteratorUtil, DoubleEndedIterator, DoubleEndedIteratorUtil};\n pub use iterator::{ClonableIterator, OrdIterator};\n pub use num::{Num, NumCast};\n@@ -65,7 +66,7 @@ pub use path::WindowsPath;\n pub use ptr::RawPtr;\n pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr, ToBytesConsume};\n pub use str::{Str, StrVector, StrSlice, OwnedStr};\n-pub use from_str::{FromStr};\n+pub use from_str::FromStr;\n pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, ToStrConsume};\n pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};"}, {"sha": "26653a51d66182dedf95b01b2d4345fec6652d82", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -272,6 +272,7 @@ pub trait RawPtr<T> {\n     fn is_not_null(&self) -> bool;\n     unsafe fn to_option(&self) -> Option<&T>;\n     fn offset(&self, count: int) -> Self;\n+    unsafe fn offset_inbounds(self, count: int) -> Self;\n }\n \n /// Extension methods for immutable pointers\n@@ -304,6 +305,22 @@ impl<T> RawPtr<T> for *T {\n     /// Calculates the offset from a pointer.\n     #[inline]\n     fn offset(&self, count: int) -> *T { offset(*self, count) }\n+\n+    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n+    /// the object, or one-byte-past-the-end.\n+    #[inline]\n+    #[cfg(stage0)]\n+    unsafe fn offset_inbounds(self, count: int) -> *T {\n+        intrinsics::offset(self, count)\n+    }\n+\n+    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n+    /// the object, or one-byte-past-the-end.\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    unsafe fn offset_inbounds(self, count: int) -> *T {\n+        intrinsics::offset_inbounds(self, count)\n+    }\n }\n \n /// Extension methods for mutable pointers\n@@ -336,6 +353,30 @@ impl<T> RawPtr<T> for *mut T {\n     /// Calculates the offset from a mutable pointer.\n     #[inline]\n     fn offset(&self, count: int) -> *mut T { mut_offset(*self, count) }\n+\n+    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n+    /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n+    /// undefined behaviour.\n+    ///\n+    /// This method should be preferred over `offset` when the guarantee can be\n+    /// satisfied, to enable better optimization.\n+    #[inline]\n+    #[cfg(stage0)]\n+    unsafe fn offset_inbounds(self, count: int) -> *mut T {\n+        intrinsics::offset(self as *T, count) as *mut T\n+    }\n+\n+    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n+    /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n+    /// undefined behaviour.\n+    ///\n+    /// This method should be preferred over `offset` when the guarantee can be\n+    /// satisfied, to enable better optimization.\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    unsafe fn offset_inbounds(self, count: int) -> *mut T {\n+        intrinsics::offset_inbounds(self as *T, count) as *mut T\n+    }\n }\n \n // Equality for pointers"}, {"sha": "d08879c68ccf94ff806285f40190c2196fa93ae1", "filename": "src/libstd/str.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -3483,19 +3483,22 @@ mod tests {\n     fn test_add() {\n         #[allow(unnecessary_allocation)];\n         macro_rules! t (\n-            ($s1:expr, $s2:expr, $e:expr) => {\n-                assert_eq!($s1 + $s2, $e);\n-                assert_eq!($s1.to_owned() + $s2, $e);\n-                assert_eq!($s1.to_managed() + $s2, $e);\n-            }\n+            ($s1:expr, $s2:expr, $e:expr) => { {\n+                let s1 = $s1;\n+                let s2 = $s2;\n+                let e = $e;\n+                assert_eq!(s1 + s2, e.to_owned());\n+                assert_eq!(s1.to_owned() + s2, e.to_owned());\n+                assert_eq!(s1.to_managed() + s2, e.to_owned());\n+            } }\n         );\n \n-        t!(\"foo\",  \"bar\", ~\"foobar\");\n-        t!(\"foo\", @\"bar\", ~\"foobar\");\n-        t!(\"foo\", ~\"bar\", ~\"foobar\");\n-        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\",  \"\u534eVi\u1ec7t Nam\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\", @\"\u534eVi\u1ec7t Nam\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"\u534eVi\u1ec7t Nam\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        t!(\"foo\",  \"bar\", \"foobar\");\n+        t!(\"foo\", @\"bar\", \"foobar\");\n+        t!(\"foo\", ~\"bar\", \"foobar\");\n+        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\",  \"\u534eVi\u1ec7t Nam\", \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\", @\"\u534eVi\u1ec7t Nam\", \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"\u534eVi\u1ec7t Nam\", \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n     }\n \n     #[test]"}, {"sha": "b4d3e4b0ad1421fe66209be870c3f2b96b567de6", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 169, "deletions": 11, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -13,7 +13,10 @@\n use to_str::{ToStr,ToStrConsume};\n use str;\n use str::StrSlice;\n+use str::OwnedStr;\n+use container::Container;\n use cast;\n+use ptr;\n use iterator::{Iterator, IteratorUtil};\n use vec::{CopyableVector, ImmutableVector};\n #[cfg(stage0)]\n@@ -41,27 +44,19 @@ impl Ascii {\n     /// Convert to lowercase.\n     #[inline]\n     pub fn to_lower(self) -> Ascii {\n-        if self.chr >= 65 && self.chr <= 90 {\n-            Ascii{chr: self.chr | 0x20 }\n-        } else {\n-            self\n-        }\n+        Ascii{chr: ASCII_LOWER_MAP[self.chr]}\n     }\n \n     /// Convert to uppercase.\n     #[inline]\n     pub fn to_upper(self) -> Ascii {\n-        if self.chr >= 97 && self.chr <= 122 {\n-            Ascii{chr: self.chr & !0x20 }\n-        } else {\n-            self\n-        }\n+        Ascii{chr: ASCII_UPPER_MAP[self.chr]}\n     }\n \n     /// Compares two ascii characters of equality, ignoring case.\n     #[inline]\n     pub fn eq_ignore_case(self, other: Ascii) -> bool {\n-        self.to_lower().chr == other.to_lower().chr\n+        ASCII_LOWER_MAP[self.chr] == ASCII_LOWER_MAP[other.chr]\n     }\n }\n \n@@ -292,10 +287,124 @@ impl ToBytesConsume for ~[Ascii] {\n     }\n }\n \n+\n+/// Convert the string to ASCII upper case:\n+/// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+/// but non-ASCII letters are unchanged.\n+#[inline]\n+pub fn to_ascii_upper(string: &str) -> ~str {\n+    map_bytes(string, ASCII_UPPER_MAP)\n+}\n+\n+/// Convert the string to ASCII lower case:\n+/// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+/// but non-ASCII letters are unchanged.\n+#[inline]\n+pub fn to_ascii_lower(string: &str) -> ~str {\n+    map_bytes(string, ASCII_LOWER_MAP)\n+}\n+\n+#[inline]\n+priv fn map_bytes(string: &str, map: &'static [u8]) -> ~str {\n+    let len = string.len();\n+    let mut result = str::with_capacity(len);\n+    unsafe {\n+        do result.as_mut_buf |mut buf, _| {\n+            for c in string.as_bytes().iter() {\n+                *buf = map[*c];\n+                buf = ptr::mut_offset(buf, 1)\n+            }\n+        }\n+        str::raw::set_len(&mut result, len);\n+    }\n+    result\n+}\n+\n+/// Check that two strings are an ASCII case-insensitive match.\n+/// Same as `to_ascii_lower(a) == to_ascii_lower(b)`,\n+/// but without allocating and copying temporary strings.\n+#[inline]\n+pub fn eq_ignore_ascii_case(a: &str, b: &str) -> bool {\n+    a.len() == b.len() && a.as_bytes().iter().zip(b.as_bytes().iter()).all(\n+        |(byte_a, byte_b)| ASCII_LOWER_MAP[*byte_a] == ASCII_LOWER_MAP[*byte_b])\n+}\n+\n+priv static ASCII_LOWER_MAP: &'static [u8] = &[\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n+    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n+    0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n+    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n+    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n+    0x78, 0x79, 0x7a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n+    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n+    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,\n+    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n+    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n+    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n+    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n+    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n+    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n+    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n+    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n+    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n+    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n+    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n+    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n+    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n+    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n+    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n+    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n+    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n+];\n+\n+priv static ASCII_UPPER_MAP: &'static [u8] = &[\n+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n+    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n+    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,\n+    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n+    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n+    0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,\n+    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n+    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n+    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n+    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n+    0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,\n+    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,\n+    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,\n+    0x58, 0x59, 0x5a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,\n+    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,\n+    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n+    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n+    0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,\n+    0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n+    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,\n+    0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,\n+    0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n+    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,\n+    0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,\n+    0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,\n+    0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,\n+    0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,\n+    0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n+    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n+    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n+];\n+\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n     use to_bytes::ToBytes;\n+    use str::from_char;\n \n     macro_rules! v2ascii (\n         ( [$($e:expr),*]) => ( [$(Ascii{chr:$e}),*]);\n@@ -378,4 +487,53 @@ mod tests {\n \n     #[test] #[should_fail]\n     fn test_ascii_fail_char_slice() { '\u03bb'.to_ascii(); }\n+\n+    #[test]\n+    fn test_to_ascii_upper() {\n+        assert_eq!(to_ascii_upper(\"url()URL()uRl()\u00fcrl\"), ~\"URL()URL()URL()\u00fcRL\");\n+        assert_eq!(to_ascii_upper(\"h\u0131\u212a\u00df\"), ~\"H\u0131\u212a\u00df\");\n+\n+        let mut i = 0;\n+        while i <= 500 {\n+            let c = i as char;\n+            let upper = if 'a' <= c && c <= 'z' { c + 'A' - 'a' } else { c };\n+            assert_eq!(to_ascii_upper(from_char(i as char)), from_char(upper))\n+            i += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_to_ascii_lower() {\n+        assert_eq!(to_ascii_lower(\"url()URL()uRl()\u00dcrl\"), ~\"url()url()url()\u00dcrl\");\n+        // Dotted capital I, Kelvin sign, Sharp S.\n+        assert_eq!(to_ascii_lower(\"H\u0130\u212a\u00df\"), ~\"h\u0130\u212a\u00df\");\n+\n+        let mut i = 0;\n+        while i <= 500 {\n+            let c = i as char;\n+            let lower = if 'A' <= c && c <= 'Z' { c + 'a' - 'A' } else { c };\n+            assert_eq!(to_ascii_lower(from_char(i as char)), from_char(lower))\n+            i += 1;\n+        }\n+    }\n+\n+\n+    #[test]\n+    fn test_eq_ignore_ascii_case() {\n+        assert!(eq_ignore_ascii_case(\"url()URL()uRl()\u00dcrl\", \"url()url()url()\u00dcrl\"));\n+        assert!(!eq_ignore_ascii_case(\"\u00dcrl\", \"\u00fcrl\"));\n+        // Dotted capital I, Kelvin sign, Sharp S.\n+        assert!(eq_ignore_ascii_case(\"H\u0130\u212a\u00df\", \"h\u0130\u212a\u00df\"));\n+        assert!(!eq_ignore_ascii_case(\"\u0130\", \"i\"));\n+        assert!(!eq_ignore_ascii_case(\"\u212a\", \"k\"));\n+        assert!(!eq_ignore_ascii_case(\"\u00df\", \"s\"));\n+\n+        let mut i = 0;\n+        while i <= 500 {\n+            let c = i as char;\n+            let lower = if 'A' <= c && c <= 'Z' { c + 'a' - 'A' } else { c };\n+            assert!(eq_ignore_ascii_case(from_char(i as char), from_char(lower)));\n+            i += 1;\n+        }\n+    }\n }"}, {"sha": "c60edad3dbd5683e6ec69cae281376a950089a6c", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -317,12 +317,21 @@ extern \"rust-intrinsic\" {\n     /// Get the address of the `__morestack` stack growth function.\n     pub fn morestack_addr() -> *();\n \n-    /// Adjust a pointer by an offset.\n+    /// Calculates the offset from a pointer.\n     ///\n     /// This is implemented as an intrinsic to avoid converting to and from an\n     /// integer, since the conversion would throw away aliasing information.\n     pub fn offset<T>(dst: *T, offset: int) -> *T;\n \n+    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n+    /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n+    /// undefined behaviour.\n+    ///\n+    /// This intrinsic should be preferred over `offset` when the guarantee can\n+    /// be satisfied, to enable better optimization.\n+    #[cfg(not(stage0))]\n+    pub fn offset_inbounds<T>(dst: *T, offset: int) -> *T;\n+\n     /// Equivalent to the `llvm.memcpy.p0i8.0i8.i32` intrinsic, with a size of\n     /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n     pub fn memcpy32<T>(dst: *mut T, src: *T, count: u32);"}, {"sha": "36201dc5e82665ab4a6c2abc2b03306cb594147a", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -849,10 +849,15 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn iter(self) -> VecIterator<'self, T> {\n         unsafe {\n             let p = vec::raw::to_ptr(self);\n-            VecIterator{ptr: p,\n-                        end: (p as uint + self.len() *\n-                              sys::nonzero_size_of::<T>()) as *T,\n-                        lifetime: cast::transmute(p)}\n+            if sys::size_of::<T>() == 0 {\n+                VecIterator{ptr: p,\n+                            end: (p as uint + self.len()) as *T,\n+                            lifetime: cast::transmute(p)}\n+            } else {\n+                VecIterator{ptr: p,\n+                            end: p.offset_inbounds(self.len() as int),\n+                            lifetime: cast::transmute(p)}\n+            }\n         }\n     }\n \n@@ -1826,10 +1831,15 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     fn mut_iter(self) -> VecMutIterator<'self, T> {\n         unsafe {\n             let p = vec::raw::to_mut_ptr(self);\n-            VecMutIterator{ptr: p,\n-                           end: (p as uint + self.len() *\n-                                 sys::nonzero_size_of::<T>()) as *mut T,\n-                           lifetime: cast::transmute(p)}\n+            if sys::size_of::<T>() == 0 {\n+                VecMutIterator{ptr: p,\n+                               end: (p as uint + self.len()) as *mut T,\n+                               lifetime: cast::transmute(p)}\n+            } else {\n+                VecMutIterator{ptr: p,\n+                               end: p.offset_inbounds(self.len() as int),\n+                               lifetime: cast::transmute(p)}\n+            }\n         }\n     }\n \n@@ -2183,7 +2193,7 @@ macro_rules! iterator {\n                             // same pointer.\n                             cast::transmute(self.ptr as uint + 1)\n                         } else {\n-                            self.ptr.offset(1)\n+                            self.ptr.offset_inbounds(1)\n                         };\n \n                         Some(cast::transmute(old))\n@@ -2215,7 +2225,7 @@ macro_rules! double_ended_iterator {\n                             // See above for why 'ptr.offset' isn't used\n                             cast::transmute(self.end as uint - 1)\n                         } else {\n-                            self.end.offset(-1)\n+                            self.end.offset_inbounds(-1)\n                         };\n                         Some(cast::transmute(self.end))\n                     }"}, {"sha": "001e92355282f9d5f095dfab787c3afa9dd779d4", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 47, "deletions": 16, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use ast;\n use ast::{MetaItem, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n@@ -40,40 +41,70 @@ pub fn expand_deriving_totalord(cx: @ExtCtxt,\n }\n \n \n-pub fn ordering_const(cx: @ExtCtxt, span: span, cnst: Ordering) -> @expr {\n+pub fn ordering_const(cx: @ExtCtxt, span: span, cnst: Ordering) -> ast::Path {\n     let cnst = match cnst {\n         Less => \"Less\",\n         Equal => \"Equal\",\n         Greater => \"Greater\"\n     };\n-    cx.expr_path(\n-        cx.path_global(span,\n-                       ~[cx.ident_of(\"std\"),\n-                         cx.ident_of(\"cmp\"),\n-                         cx.ident_of(cnst)]))\n+    cx.path_global(span,\n+                   ~[cx.ident_of(\"std\"),\n+                     cx.ident_of(\"cmp\"),\n+                     cx.ident_of(cnst)])\n }\n \n pub fn cs_cmp(cx: @ExtCtxt, span: span,\n               substr: &Substructure) -> @expr {\n+    let test_id = cx.ident_of(\"__test\");\n+    let equals_path = ordering_const(cx, span, Equal);\n \n+    /*\n+    Builds:\n+\n+    let __test = self_field1.cmp(&other_field2);\n+    if other == ::std::cmp::Equal {\n+        let __test = self_field2.cmp(&other_field2);\n+        if __test == ::std::cmp::Equal {\n+            ...\n+        } else {\n+            __test\n+        }\n+    } else {\n+        __test\n+    }\n+\n+    FIXME #6449: These `if`s could/should be `match`es.\n+    */\n     cs_same_method_fold(\n-        // foldr (possibly) nests the matches in lexical_ordering better\n+        // foldr nests the if-elses correctly, leaving the first field\n+        // as the outermost one, and the last as the innermost.\n         false,\n         |cx, span, old, new| {\n-            cx.expr_call_global(span,\n-                                ~[cx.ident_of(\"std\"),\n-                                  cx.ident_of(\"cmp\"),\n-                                  cx.ident_of(\"lexical_ordering\")],\n-                                ~[old, new])\n+            // let __test = new;\n+            // if __test == ::std::cmp::Equal {\n+            //    old\n+            // } else {\n+            //    __test\n+            // }\n+\n+            let assign = cx.stmt_let(span, false, test_id, new);\n+\n+            let cond = cx.expr_binary(span, ast::eq,\n+                                      cx.expr_ident(span, test_id),\n+                                      cx.expr_path(equals_path.clone()));\n+            let if_ = cx.expr_if(span,\n+                                 cond,\n+                                 old, Some(cx.expr_ident(span, test_id)));\n+            cx.expr_block(cx.block(span, ~[assign], Some(if_)))\n         },\n-        ordering_const(cx, span, Equal),\n+        cx.expr_path(equals_path.clone()),\n         |cx, span, list, _| {\n             match list {\n                 // an earlier nonmatching variant is Less than a\n-                // later one\n+                // later one.\n                 [(self_var, _, _),\n-                 (other_var, _, _)] => ordering_const(cx, span,\n-                                                      self_var.cmp(&other_var)),\n+                 (other_var, _, _)] => cx.expr_path(ordering_const(cx, span,\n+                                                                   self_var.cmp(&other_var))),\n                 _ => cx.span_bug(span, \"Not exactly 2 arguments in `deriving(TotalOrd)`\")\n             }\n         },"}, {"sha": "70fe6f706f79a763683fdc6556f09c765e2a86f0", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -59,7 +59,7 @@ impl Results {\n         {\n             let mut set = f();\n             do timed(&mut self.random_ints) {\n-                do num_keys.times {\n+                for _ in range(0, num_keys) {\n                     set.insert((rng.next() as uint) % rand_cap);\n                 }\n             }\n@@ -103,7 +103,7 @@ impl Results {\n         {\n             let mut set = f();\n             do timed(&mut self.random_strings) {\n-                do num_keys.times {\n+                for _ in range(0, num_keys) {\n                     let s = uint::to_str(rng.next() as uint);\n                     set.insert(s);\n                 }"}, {"sha": "8503b188b2f25a27dd7d21bc6d01e5d991373abd", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -105,7 +105,7 @@ fn main() {\n     let symbols = [\" \", \"\u2591\", \"\u2592\", \"\u2593\", \"\u2588\", \"\u2588\"];\n     let mut pixels = [0f32, ..256*256];\n     let n2d = ~Noise2DContext::new();\n-    do 100.times {\n+    for _ in range(0, 100u) {\n         for y in range(0, 256) {\n             for x in range(0, 256) {\n                 let v = n2d.get("}, {"sha": "2b177ccb98fcc194a0dbf743619ac82764b6a447", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -169,7 +169,7 @@ fn rendezvous(nn: uint, set: ~[color]) {\n     let mut creatures_met = 0;\n \n     // set up meetings...\n-    do nn.times {\n+    for _ in range(0, nn) {\n         let fst_creature: CreatureInfo = from_creatures.recv();\n         let snd_creature: CreatureInfo = from_creatures.recv();\n "}, {"sha": "44b1a28c12b30f6134729c413ad587797beb7ce0", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -164,7 +164,7 @@ impl RandomFasta {\n             let chars_left = n % LINE_LEN;\n             let mut buf = [0, ..LINE_LEN + 1];\n \n-            do lines.times {\n+            for _ in range(0, lines) {\n                 for i in range(0u, LINE_LEN) {\n                     buf[i] = self.nextc();\n                 }"}, {"sha": "2b5b4ded94774690913cd7136db00954f26a387d", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -54,7 +54,7 @@ impl Code {\n     fn unpack(&self, frame: i32) -> ~str {\n         let mut key = **self;\n         let mut result = ~[];\n-        do (frame as uint).times {\n+        for _ in range(0, frame) {\n             result.push(unpack_symbol((key as u8) & 3));\n             key >>= 2;\n         }\n@@ -251,7 +251,7 @@ fn generate_frequencies(frequencies: &mut Table,\n     let mut code = Code(0);\n \n     // Pull first frame.\n-    do (frame as uint).times {\n+    for _ in range(0, frame) {\n         code = code.push_char(input[0]);\n         input = next_char(input);\n     }"}, {"sha": "6a9c5ea89e4fc6a196fff097ae1ac76eef0edc84", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -79,7 +79,7 @@ struct Planet {\n \n fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: i32) {\n     let mut d = [ 0.0, ..3 ];\n-    do (steps as uint).times {\n+    for _ in range(0, steps) {\n         for i in range(0u, N_BODIES) {\n             for j in range(i + 1, N_BODIES) {\n                 d[0] = bodies[i].x[0] - bodies[j].x[0];"}, {"sha": "ecf54bf16473e8833ad074be023b8f3fc80c3d2f", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -56,7 +56,7 @@ fn main() {\n     let mut u = vec::from_elem(n, 1f64);\n     let mut v = u.clone();\n     let mut tmp = u.clone();\n-    do 8.times {\n+    for _ in range(0, 8u) {\n         mult_AtAv(u, v, tmp);\n         mult_AtAv(v, u, tmp);\n     }"}, {"sha": "114c7e997a24f67cd22b4195ae6d4221c126d776", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -32,7 +32,7 @@ fn main() {\n }\n \n fn run(repeat: int, depth: int) {\n-    do (repeat as uint).times {\n+    for _ in range(0, repeat) {\n         info!(\"starting %.4f\", precise_time_s());\n         do task::try {\n             recurse_or_fail(depth, None)"}, {"sha": "15808427f4a8b55c08d2c442c48ab8e4acc50cfb", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -32,7 +32,7 @@ fn grandchild_group(num_tasks: uint) {\n     let (po, ch) = stream();\n     let ch = SharedChan::new(ch);\n \n-    do num_tasks.times {\n+    for _ in range(0, num_tasks) {\n         let ch = ch.clone();\n         do task::spawn { // linked\n             ch.send(());\n@@ -41,7 +41,7 @@ fn grandchild_group(num_tasks: uint) {\n         }\n     }\n     error!(\"Grandchild group getting started\");\n-    do num_tasks.times {\n+    for _ in range(0, num_tasks) {\n         // Make sure all above children are fully spawned; i.e., enlisted in\n         // their ancestor groups.\n         po.recv();"}, {"sha": "93e9eac1dd9dfb621bf1e76df52a5769d403ac30", "filename": "src/test/run-pass/class-impl-parameterized-trait.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/aababbba8e5d5b56aa4a0cedb9b2008ba6cdc422/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aababbba8e5d5b56aa4a0cedb9b2008ba6cdc422/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs?ref=aababbba8e5d5b56aa4a0cedb9b2008ba6cdc422", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-test FIXME #7307\n-// xfail-fast\n-\n-extern mod extra;\n-use extra::oldmap::*;\n-\n-class cat : map<int, bool> {\n-  priv {\n-    // Yes, you can have negative meows\n-    let mut meows : int;\n-    fn meow() {\n-      self.meows += 1;\n-      error!(\"Meow %d\", self.meows);\n-      if self.meows % 5 == 0 {\n-          self.how_hungry += 1;\n-      }\n-    }\n-  }\n-\n-  let mut how_hungry : int;\n-  let name : str;\n-\n-  new(in_x : int, in_y : int, in_name: str)\n-    { self.meows = in_x; self.how_hungry = in_y; self.name = in_name; }\n-\n-  fn speak() { self.meow(); }\n-\n-  fn eat() -> bool {\n-    if self.how_hungry > 0 {\n-        error!(\"OM NOM NOM\");\n-        self.how_hungry -= 2;\n-        return true;\n-    }\n-    else {\n-        error!(\"Not hungry!\");\n-        return false;\n-    }\n-  }\n-\n-  fn size() -> uint { self.meows as uint }\n-  fn insert(+k: int, +v: bool) -> bool {\n-    if v { self.meows += k; } else { self.meows -= k; };\n-    true\n-  }\n-  fn contains_key(&&k: int) -> bool { k <= self.meows }\n-  fn get(&&k:int) -> bool { k <= self.meows }\n-  fn [](&&k:int) -> bool { k <= self.meows }\n-  fn find(&&k:int) -> Option<bool> { Some(self.get(k)) }\n-  fn remove(&&k:int) -> Option<bool> { self.meows -= k; Some(true) }\n-  fn each(f: &fn(&&int, &&bool) -> bool) {\n-    let mut n = num::abs(self.meows);\n-    while n > 0 {\n-        if !f(n, true) { break; }\n-        n -= 1;\n-    }\n-  }\n-  fn each_key(&&f: &fn(&&int) -> bool) {\n-    for self.each |k, _v| { if !f(k) { break; } again;};\n-  }\n-  fn each_value(&&f: &fn(&&bool) -> bool) {\n-    for self.each |_k, v| { if !f(v) { break; } again;};\n-  }\n-  fn clear() { }\n-}\n-\n-pub fn main() {\n-  let nyan : cat = cat(0, 2, \"nyan\");\n-  for _ in range(1u, 5u) { nyan.speak(); }\n-  // cat returns true if uint input is greater than\n-  // the number of meows so far\n-  assert!((nyan.get(1)));\n-  assert!((!nyan.get(10)));\n-}"}, {"sha": "4fccc45a75335cea0e23c96e9959cef68ecdf634", "filename": "src/test/run-pass/class-implements-multiple-traits.rs", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/aababbba8e5d5b56aa4a0cedb9b2008ba6cdc422/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aababbba8e5d5b56aa4a0cedb9b2008ba6cdc422/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-traits.rs?ref=aababbba8e5d5b56aa4a0cedb9b2008ba6cdc422", "patch": "@@ -1,129 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-test FIXME #7305\n-\n-extern mod extra;\n-use extra::oldmap::*;\n-use vec::*;\n-use dvec::{dvec, extensions};\n-\n-enum furniture { chair, couch, bed }\n-enum body_part { finger, toe, nose, ear }\n-\n-trait noisy {\n-  fn speak() -> int;\n-}\n-\n-trait scratchy {\n-  fn scratch() -> Option<furniture>;\n-}\n-\n-trait bitey {\n-  fn bite() -> body_part;\n-}\n-\n-fn vec_includes<T>(xs: ~[T], x: T) -> bool {\n-  for each(xs) |y| { if y == x { return true; }}\n-  return false;\n-}\n-\n-// vtables other than the 1st one don't seem to work\n-class cat : noisy, scratchy, bitey {\n-  priv {\n-    let meows : @mut uint;\n-    let scratched : dvec<furniture>;\n-    let bite_counts : hashmap<body_part, uint>;\n-\n-    fn meow() -> uint {\n-      info!(\"Meow: %u\", *self.meows);\n-      *self.meows += 1u;\n-      if *self.meows % 5u == 0u {\n-          *self.how_hungry += 1;\n-      }\n-      *self.meows\n-    }\n-  }\n-\n-  let how_hungry : @mut int;\n-  let name : str;\n-\n-  new(in_x : uint, in_y : int, in_name: str)\n-    { self.meows = @mut in_x; self.how_hungry = @mut in_y;\n-      self.name = in_name; self.scratched = dvec();\n-      let hsher: hashfn<body_part> = |p| int::hash(p as int);\n-      let eqer : eqfn<body_part> = |p, q| p == q;\n-      let t : hashmap<body_part, uint> =\n-        hashmap::<body_part, uint>(hsher, eqer);\n-      self.bite_counts = t;\n-     do iter(~[finger, toe, nose, ear]) |p| {\n-          self.bite_counts.insert(p, 0u);\n-      };\n-    }\n-\n-  fn speak() -> int { self.meow() as int }\n-  fn meow_count() -> uint { *self.meows }\n-  fn scratch() -> Option<furniture> {\n-    let all = ~[chair, couch, bed];\n-    log(error, self.scratched);\n-    let mut rslt = None;\n-    for each(all) |thing| { if !self.scratched.contains(thing) {\n-          self.scratched.push(thing);\n-          return Some(thing); }}\n-    rslt\n-  }\n-  fn bite() -> body_part {\n-    error!(\"In bite()\");\n-    let all = ~[toe, nose, ear];\n-    let mut min = finger;\n-    do iter(all) |next| {\n-      info!(\"min = %?\", min);\n-        if self.bite_counts.get(next) < self.bite_counts.get(min) {\n-            min = next;\n-          }};\n-    self.bite_counts.insert(min, self.bite_counts.get(min) + 1u);\n-    info!(\"Bit %?\", min);\n-    min\n-  }\n-}\n-\n-fn annoy_neighbors<T:noisy>(critter: T) {\n-  for i in range(0u, 10u) {\n-      let what = critter.speak();\n-      info!(\"%u %d\", i, what);\n-  }\n-}\n-\n-fn bite_everything<T:bitey>(critter: T) -> bool {\n-  let mut left : ~[body_part] = ~[finger, toe, nose, ear];\n-  while left.len() > 0u {\n-    let part = critter.bite();\n-    info!(\"%? %?\", left, part);\n-    if vec_includes(left, part) {\n-        left = vec::filter(left, |p| p != part );\n-    }\n-    else {\n-      return false;\n-    }\n-  }\n-  true\n-}\n-\n-fn scratched_something<T:scratchy>(critter: T) -> bool {\n-  option::is_some(critter.scratch())\n-}\n-\n-pub fn main() {\n-  let nyan : cat  = cat(0u, 2, \"nyan\");\n-  annoy_neighbors(nyan as noisy);\n-  assert_eq!(nyan.meow_count(), 10u);\n-  assert!((bite_everything(nyan as bitey)));\n-  assert!((scratched_something(nyan as scratchy)));\n-}"}, {"sha": "b31f0eab2e2239494bef52c7d1464ecfd0a982ad", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-arg.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -12,10 +12,4 @@ fn sum_imm(y: &[int]) -> int {\n     sum(y)\n }\n \n-/* FIXME #7304\n-fn sum_const(y: &const [int]) -> int {\n-    sum(y)\n-}\n-*/\n-\n pub fn main() {}"}, {"sha": "8a271a4d65f3c06f5ac728c3c24464bf00cef97b", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-rcvr.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -1,9 +1,3 @@\n-/* FIXME #7302\n-fn foo(v: &const [uint]) -> ~[uint] {\n-    v.to_owned()\n-}\n-*/\n-\n fn bar(v: &mut [uint]) -> ~[uint] {\n     v.to_owned()\n }\n@@ -14,7 +8,6 @@ fn bip(v: &[uint]) -> ~[uint] {\n \n pub fn main() {\n     let mut the_vec = ~[1u, 2, 3, 100];\n-//    assert_eq!(the_vec.clone(), foo(the_vec));\n     assert_eq!(the_vec.clone(), bar(the_vec));\n     assert_eq!(the_vec.clone(), bip(the_vec));\n }"}, {"sha": "7f5c78cf602ad400a5c11d7ea8c2e59030623cb7", "filename": "src/test/run-pass/deriving-cmp-shortcircuit.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Frun-pass%2Fderiving-cmp-shortcircuit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Frun-pass%2Fderiving-cmp-shortcircuit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-shortcircuit.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that the derived impls for the comparison traits shortcircuit\n+// where possible, by having a type that fails when compared as the\n+// second element, so this passes iff the instances shortcircuit.\n+\n+pub struct FailCmp;\n+impl Eq for FailCmp {\n+    fn eq(&self, _: &FailCmp) -> bool { fail!(\"eq\") }\n+}\n+\n+impl Ord for FailCmp {\n+    fn lt(&self, _: &FailCmp) -> bool { fail!(\"lt\") }\n+}\n+\n+impl TotalEq for FailCmp {\n+    fn equals(&self, _: &FailCmp) -> bool { fail!(\"equals\") }\n+}\n+\n+impl TotalOrd for FailCmp {\n+    fn cmp(&self, _: &FailCmp) -> Ordering { fail!(\"cmp\") }\n+}\n+\n+#[deriving(Eq,Ord,TotalEq,TotalOrd)]\n+struct ShortCircuit {\n+    x: int,\n+    y: FailCmp\n+}\n+\n+fn main() {\n+    let a = ShortCircuit { x: 1, y: FailCmp };\n+    let b = ShortCircuit { x: 2, y: FailCmp };\n+\n+    assert!(a != b);\n+    assert!(a < b);\n+    assert!(!a.equals(&b));\n+    assert_eq!(a.cmp(&b), ::std::cmp::Less);\n+}"}, {"sha": "46819027dad649719e9ab9da908260a5800ab863", "filename": "src/test/run-pass/rcvr-borrowed-to-region.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a54476b0aa9f7ca00e8f8c12fc327cf79815054a/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs?ref=a54476b0aa9f7ca00e8f8c12fc327cf79815054a", "patch": "@@ -12,7 +12,9 @@ trait get {\n     fn get(self) -> int;\n }\n \n-// FIXME #7302: Note: impl on a slice\n+// Note: impl on a slice; we're checking that the pointers below\n+// correctly get borrowed to `&`. (similar to impling for `int`, with\n+// `&self` instead of `self`.)\n impl<'self> get for &'self int {\n     fn get(self) -> int {\n         return *self;\n@@ -34,11 +36,6 @@ pub fn main() {\n     info!(\"y=%d\", y);\n     assert_eq!(y, 6);\n \n-    let x = ~6;\n-    let y = x.get();\n-    info!(\"y=%d\", y);\n-    assert_eq!(y, 6);\n-\n     let x = &6;\n     let y = x.get();\n     info!(\"y=%d\", y);"}]}