{"sha": "12103b16de2012988cc4ebcb025f7149a7ee6336", "node_id": "C_kwDOAAsO6NoAKDEyMTAzYjE2ZGUyMDEyOTg4Y2M0ZWJjYjAyNWY3MTQ5YTdlZTYzMzY", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-02T10:02:06Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-02T10:02:06Z"}, "message": "internal: untangle usages of ReferenceCategory somewhat\n\nNot everything that can be read or write is a reference, let's try to\nuse more precise types.", "tree": {"sha": "a9bbb90c45046f2b6c86a0590e0830066c4ffe59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9bbb90c45046f2b6c86a0590e0830066c4ffe59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12103b16de2012988cc4ebcb025f7149a7ee6336", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12103b16de2012988cc4ebcb025f7149a7ee6336", "html_url": "https://github.com/rust-lang/rust/commit/12103b16de2012988cc4ebcb025f7149a7ee6336", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12103b16de2012988cc4ebcb025f7149a7ee6336/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46eb03d99aa68ec7cbe03bce8a82780b21971907", "url": "https://api.github.com/repos/rust-lang/rust/commits/46eb03d99aa68ec7cbe03bce8a82780b21971907", "html_url": "https://github.com/rust-lang/rust/commit/46eb03d99aa68ec7cbe03bce8a82780b21971907"}], "stats": {"total": 78, "additions": 41, "deletions": 37}, "files": [{"sha": "f910edebf11080c13f53c7061131fb43dc150093", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/12103b16de2012988cc4ebcb025f7149a7ee6336/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12103b16de2012988cc4ebcb025f7149a7ee6336/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=12103b16de2012988cc4ebcb025f7149a7ee6336", "patch": "@@ -19,7 +19,10 @@ use crate::{display::TryToNav, references, NavigationTarget};\n #[derive(PartialEq, Eq, Hash)]\n pub struct HighlightedRange {\n     pub range: TextRange,\n-    pub access: Option<ReferenceCategory>,\n+    // FIXME: This needs to be more precise. Reference category makes sense only\n+    // for references, but we also have defs. And things like exit points are\n+    // neither.\n+    pub category: Option<ReferenceCategory>,\n }\n \n #[derive(Default, Clone)]\n@@ -87,7 +90,10 @@ fn highlight_references(\n                 .remove(&file_id)\n         })\n         .flatten()\n-        .map(|FileReference { category: access, range, .. }| HighlightedRange { range, access });\n+        .map(|FileReference { category: access, range, .. }| HighlightedRange {\n+            range,\n+            category: access,\n+        });\n \n     let declarations = defs.iter().flat_map(|def| {\n         match def {\n@@ -99,8 +105,12 @@ fn highlight_references(\n         .filter(|decl| decl.file_id == file_id)\n         .and_then(|decl| {\n             let range = decl.focus_range?;\n-            let access = references::decl_access(&def, syntax, range);\n-            Some(HighlightedRange { range, access })\n+            let category = if references::decl_mutability(&def, syntax, range) {\n+                Some(ReferenceCategory::Write)\n+            } else {\n+                None\n+            };\n+            Some(HighlightedRange { range, category })\n         })\n     });\n \n@@ -125,18 +135,20 @@ fn highlight_exit_points(\n         walk_expr(&body, &mut |expr| match expr {\n             ast::Expr::ReturnExpr(expr) => {\n                 if let Some(token) = expr.return_token() {\n-                    highlights.push(HighlightedRange { access: None, range: token.text_range() });\n+                    highlights.push(HighlightedRange { category: None, range: token.text_range() });\n                 }\n             }\n             ast::Expr::TryExpr(try_) => {\n                 if let Some(token) = try_.question_mark_token() {\n-                    highlights.push(HighlightedRange { access: None, range: token.text_range() });\n+                    highlights.push(HighlightedRange { category: None, range: token.text_range() });\n                 }\n             }\n             ast::Expr::MethodCallExpr(_) | ast::Expr::CallExpr(_) | ast::Expr::MacroCall(_) => {\n                 if sema.type_of_expr(&expr).map_or(false, |ty| ty.original.is_never()) {\n-                    highlights\n-                        .push(HighlightedRange { access: None, range: expr.syntax().text_range() });\n+                    highlights.push(HighlightedRange {\n+                        category: None,\n+                        range: expr.syntax().text_range(),\n+                    });\n                 }\n             }\n             _ => (),\n@@ -154,7 +166,7 @@ fn highlight_exit_points(\n                         .map_or_else(|| tail.syntax().text_range(), |tok| tok.text_range()),\n                     _ => tail.syntax().text_range(),\n                 };\n-                highlights.push(HighlightedRange { access: None, range })\n+                highlights.push(HighlightedRange { category: None, range })\n             });\n         }\n         Some(highlights)\n@@ -187,13 +199,13 @@ fn highlight_break_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n             token.map(|tok| tok.text_range()),\n             label.as_ref().map(|it| it.syntax().text_range()),\n         );\n-        highlights.extend(range.map(|range| HighlightedRange { access: None, range }));\n+        highlights.extend(range.map(|range| HighlightedRange { category: None, range }));\n         for_each_break_expr(label, body, &mut |break_| {\n             let range = cover_range(\n                 break_.break_token().map(|it| it.text_range()),\n                 break_.lifetime().map(|it| it.syntax().text_range()),\n             );\n-            highlights.extend(range.map(|range| HighlightedRange { access: None, range }));\n+            highlights.extend(range.map(|range| HighlightedRange { category: None, range }));\n         });\n         Some(highlights)\n     }\n@@ -241,13 +253,13 @@ fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<HighlightedRange>> {\n         body: Option<ast::Expr>,\n     ) -> Option<Vec<HighlightedRange>> {\n         let mut highlights =\n-            vec![HighlightedRange { access: None, range: async_token?.text_range() }];\n+            vec![HighlightedRange { category: None, range: async_token?.text_range() }];\n         if let Some(body) = body {\n             walk_expr(&body, &mut |expr| {\n                 if let ast::Expr::AwaitExpr(expr) = expr {\n                     if let Some(token) = expr.await_token() {\n                         highlights\n-                            .push(HighlightedRange { access: None, range: token.text_range() });\n+                            .push(HighlightedRange { category: None, range: token.text_range() });\n                     }\n                 }\n             });\n@@ -353,7 +365,7 @@ mod tests {\n             .map(|hl| {\n                 (\n                     hl.range,\n-                    hl.access.map(|it| {\n+                    hl.category.map(|it| {\n                         match it {\n                             ReferenceCategory::Read => \"read\",\n                             ReferenceCategory::Write => \"write\","}, {"sha": "fd36cfc44def9b178e6ab313294293bfe2f852f3", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/12103b16de2012988cc4ebcb025f7149a7ee6336/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12103b16de2012988cc4ebcb025f7149a7ee6336/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=12103b16de2012988cc4ebcb025f7149a7ee6336", "patch": "@@ -37,7 +37,7 @@ pub struct ReferenceSearchResult {\n #[derive(Debug, Clone)]\n pub struct Declaration {\n     pub nav: NavigationTarget,\n-    pub access: Option<ReferenceCategory>,\n+    pub is_mut: bool,\n }\n \n // Feature: Find All References\n@@ -88,7 +88,7 @@ pub(crate) fn find_all_refs(\n                 .map(|nav| {\n                     let decl_range = nav.focus_or_full_range();\n                     Declaration {\n-                        access: decl_access(&def, sema.parse(nav.file_id).syntax(), decl_range),\n+                        is_mut: decl_mutability(&def, sema.parse(nav.file_id).syntax(), decl_range),\n                         nav,\n                     }\n                 });\n@@ -145,27 +145,19 @@ pub(crate) fn find_defs<'a>(\n     })\n }\n \n-pub(crate) fn decl_access(\n-    def: &Definition,\n-    syntax: &SyntaxNode,\n-    range: TextRange,\n-) -> Option<ReferenceCategory> {\n+pub(crate) fn decl_mutability(def: &Definition, syntax: &SyntaxNode, range: TextRange) -> bool {\n     match def {\n         Definition::Local(_) | Definition::Field(_) => {}\n-        _ => return None,\n+        _ => return false,\n     };\n \n-    let stmt = find_node_at_offset::<ast::LetStmt>(syntax, range.start())?;\n-    if stmt.initializer().is_some() {\n-        let pat = stmt.pat()?;\n-        if let ast::Pat::IdentPat(it) = pat {\n-            if it.mut_token().is_some() {\n-                return Some(ReferenceCategory::Write);\n-            }\n-        }\n+    match find_node_at_offset::<ast::LetStmt>(syntax, range.start()) {\n+        Some(stmt) if stmt.initializer().is_some() => match stmt.pat() {\n+            Some(ast::Pat::IdentPat(it)) => it.mut_token().is_some(),\n+            _ => false,\n+        },\n+        _ => false,\n     }\n-\n-    None\n }\n \n /// Filter out all non-literal usages for adt-defs\n@@ -283,7 +275,7 @@ fn is_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n-    use ide_db::base_db::FileId;\n+    use ide_db::{base_db::FileId, search::ReferenceCategory};\n     use stdx::format_to;\n \n     use crate::{fixture, SearchScope};\n@@ -1095,8 +1087,8 @@ impl Foo {\n \n             if let Some(decl) = refs.declaration {\n                 format_to!(actual, \"{}\", decl.nav.debug_render());\n-                if let Some(access) = decl.access {\n-                    format_to!(actual, \" {:?}\", access)\n+                if decl.is_mut {\n+                    format_to!(actual, \" {:?}\", ReferenceCategory::Write)\n                 }\n                 actual += \"\\n\\n\";\n             }"}, {"sha": "e62bb9499fa36aad936cfb65fdf42b2dde27a21e", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12103b16de2012988cc4ebcb025f7149a7ee6336/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12103b16de2012988cc4ebcb025f7149a7ee6336/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=12103b16de2012988cc4ebcb025f7149a7ee6336", "patch": "@@ -1182,9 +1182,9 @@ pub(crate) fn handle_document_highlight(\n     };\n     let res = refs\n         .into_iter()\n-        .map(|ide::HighlightedRange { range, access }| lsp_types::DocumentHighlight {\n+        .map(|ide::HighlightedRange { range, category }| lsp_types::DocumentHighlight {\n             range: to_proto::range(&line_index, range),\n-            kind: access.map(to_proto::document_highlight_kind),\n+            kind: category.map(to_proto::document_highlight_kind),\n         })\n         .collect();\n     Ok(Some(res))"}]}