{"sha": "a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NWNlZDVkMTYxZDMxZTdlNWIwOTdiMzZiZmYwZjUxZWMwODQzYmM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-19T09:46:34Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-01T05:59:47Z"}, "message": "rustc: avoid using MethodCallee's signature where possible.", "tree": {"sha": "fb17e25a985507172f83a6ed3aa84783a4d08fad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb17e25a985507172f83a6ed3aa84783a4d08fad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "html_url": "https://github.com/rust-lang/rust/commit/a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3", "html_url": "https://github.com/rust-lang/rust/commit/22510f32666d0c9c230c9d09e5bcd9eb3a6200b3"}], "stats": {"total": 310, "additions": 147, "deletions": 163}, "files": [{"sha": "affc84382a526b59c9cf56e8443aadd48bb860bb", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "patch": "@@ -412,15 +412,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             pred: CFGIndex,\n             func_or_rcvr: &hir::Expr,\n             args: I) -> CFGIndex {\n-        let fn_ty = match self.tables.method_map.get(&call_expr.id) {\n-            Some(method) => method.ty,\n-            None => self.tables.expr_ty_adjusted(func_or_rcvr),\n-        };\n-\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n         // FIXME(canndrew): This is_never should probably be an is_uninhabited.\n-        if fn_ty.fn_ret().0.is_never() {\n+        if self.tables.expr_ty(call_expr).is_never() {\n             self.add_unreachable_node()\n         } else {\n             ret"}, {"sha": "c9593e54a867db8b4e9e27d10e41bc6f079ec572", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "patch": "@@ -173,10 +173,11 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n-                let method_sig = self.tables.method_map[&expr.id].sig;\n+                let method = self.tables.method_map[&expr.id];\n+                let base_type = self.tcx.type_of(method.def_id);\n                 debug!(\"effect: method call case, base type is {:?}\",\n-                        method_sig);\n-                if method_sig.unsafety == hir::Unsafety::Unsafe {\n+                        base_type);\n+                if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span,\n                                         \"invocation of unsafe method\")\n                 }"}, {"sha": "45afc17f33967f7c698098720ae786c4119aeec5", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "patch": "@@ -761,8 +761,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 let bk = ty::BorrowKind::from_mutbl(m);\n                 self.delegate.borrow(expr.id, expr.span, cmt.clone(),\n                                      r, bk, AutoRef);\n+                cmt = self.mc.cat_overloaded_autoderef(expr, method)?;\n+            } else {\n+                cmt = self.mc.cat_deref(expr, cmt, false)?;\n             }\n-            cmt = self.mc.cat_deref(expr, cmt, overloaded)?;\n         }\n         Ok(cmt)\n     }"}, {"sha": "6a74af6eb8aaddc7c9c767d2120a82e10c1e862d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "patch": "@@ -1072,9 +1072,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprCall(ref f, ref args) => {\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n-            let diverges = !self.tables.is_method_call(expr.id) &&\n-                self.tables.expr_ty_adjusted(&f).fn_sig().output().0.is_never();\n-            let succ = if diverges {\n+            let succ = if self.tables.expr_ty(expr).is_never() {\n                 self.s.exit_ln\n             } else {\n                 succ\n@@ -1084,9 +1082,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           hir::ExprMethodCall(.., ref args) => {\n-            let ret_ty = self.tables.method_map[&expr.id].sig.output();\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n-            let succ = if ret_ty.is_never() {\n+            let succ = if self.tables.expr_ty(expr).is_never() {\n                 self.s.exit_ln\n             } else {\n                 succ"}, {"sha": "cc65777bfce87b3a4b399c0f167de354c760b735", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 89, "deletions": 116, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "patch": "@@ -63,7 +63,6 @@\n pub use self::PointerKind::*;\n pub use self::InteriorKind::*;\n pub use self::FieldName::*;\n-pub use self::ElementKind::*;\n pub use self::MutabilityCategory::*;\n pub use self::AliasableReason::*;\n pub use self::Note::*;\n@@ -129,7 +128,7 @@ pub enum PointerKind<'tcx> {\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n-    InteriorElement(InteriorOffsetKind, ElementKind),\n+    InteriorElement(InteriorOffsetKind),\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n@@ -144,12 +143,6 @@ pub enum InteriorOffsetKind {\n     Pattern,          // e.g. `fn foo([_, a, _, _]: [A; 4]) { ... }`\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub enum ElementKind {\n-    VecElement,\n-    OtherElement,\n-}\n-\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n@@ -492,7 +485,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                         debug!(\"cat_expr: autoderefs={:?}, cmt={:?}\",\n                                autoderefs, cmt);\n                         for &overloaded in autoderefs {\n-                            cmt = self.cat_deref(expr, cmt, overloaded)?;\n+                            if let Some(method) = overloaded {\n+                                cmt = self.cat_overloaded_autoderef(expr, method)?;\n+                            } else {\n+                                cmt = self.cat_deref(expr, cmt, false)?;\n+                            }\n                         }\n                         return Ok(cmt);\n                     }\n@@ -518,10 +515,12 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let expr_ty = self.expr_ty(expr)?;\n         match expr.node {\n           hir::ExprUnary(hir::UnDeref, ref e_base) => {\n-            let base_cmt = self.cat_expr(&e_base)?;\n-            let method = self.infcx.tables.borrow().method_map\n-                .get(&expr.id).cloned();\n-            self.cat_deref(expr, base_cmt, method)\n+            if self.infcx.tables.borrow().is_method_call(expr.id) {\n+                self.cat_overloaded_lvalue(expr, e_base, false)\n+            } else {\n+                let base_cmt = self.cat_expr(&e_base)?;\n+                self.cat_deref(expr, base_cmt, false)\n+            }\n           }\n \n           hir::ExprField(ref base, f_name) => {\n@@ -539,33 +538,16 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           hir::ExprIndex(ref base, _) => {\n-            let method = self.infcx.tables.borrow().method_map.get(&expr.id()).cloned();\n-            match method {\n-                Some(method) => {\n-                    // If this is an index implemented by a method call, then it\n-                    // will include an implicit deref of the result.\n-                    let ret_ty = self.overloaded_method_return_ty(method);\n-\n-                    // The index method always returns an `&T`, so\n-                    // dereference it to find the result type.\n-                    let elem_ty = match ret_ty.sty {\n-                        ty::TyRef(_, mt) => mt.ty,\n-                        _ => {\n-                            debug!(\"cat_expr_unadjusted: return type of overloaded index is {:?}?\",\n-                                   ret_ty);\n-                            return Err(());\n-                        }\n-                    };\n-\n-                    // The call to index() returns a `&T` value, which\n-                    // is an rvalue. That is what we will be\n-                    // dereferencing.\n-                    let base_cmt = self.cat_rvalue_node(expr.id(), expr.span(), ret_ty);\n-                    Ok(self.cat_deref_common(expr, base_cmt, elem_ty, true))\n-                }\n-                None => {\n-                    self.cat_index(expr, self.cat_expr(&base)?, InteriorOffsetKind::Index)\n-                }\n+            if self.infcx.tables.borrow().is_method_call(expr.id()) {\n+                // If this is an index implemented by a method call, then it\n+                // will include an implicit deref of the result.\n+                // The call to index() returns a `&T` value, which\n+                // is an rvalue. That is what we will be\n+                // dereferencing.\n+                self.cat_overloaded_lvalue(expr, base, true)\n+            } else {\n+                let base_cmt = self.cat_expr(&base)?;\n+                self.cat_index(expr, base_cmt, expr_ty, InteriorOffsetKind::Index)\n             }\n           }\n \n@@ -924,50 +906,71 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         ret\n     }\n \n+    fn cat_overloaded_lvalue(&self,\n+                             expr: &hir::Expr,\n+                             base: &hir::Expr,\n+                             implicit: bool)\n+                             -> McResult<cmt<'tcx>> {\n+        debug!(\"cat_overloaded_lvalue: implicit={}\", implicit);\n+\n+        // Reconstruct the output assuming it's a reference with the\n+        // same region and mutability as the receiver. This holds for\n+        // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n+        let lvalue_ty = self.expr_ty(expr)?;\n+        let base_ty = self.expr_ty_adjusted(base)?;\n+\n+        let (region, mutbl) = match base_ty.sty {\n+            ty::TyRef(region, mt) => (region, mt.mutbl),\n+            _ => {\n+                span_bug!(expr.span, \"cat_overloaded_lvalue: base is not a reference\")\n+            }\n+        };\n+        let ref_ty = self.tcx().mk_ref(region, ty::TypeAndMut {\n+            ty: lvalue_ty,\n+            mutbl,\n+        });\n+\n+        let base_cmt = self.cat_rvalue_node(expr.id, expr.span, ref_ty);\n+        self.cat_deref(expr, base_cmt, implicit)\n+    }\n+\n+    pub fn cat_overloaded_autoderef(&self,\n+                                    expr: &hir::Expr,\n+                                    method: ty::MethodCallee<'tcx>)\n+                                    -> McResult<cmt<'tcx>> {\n+        debug!(\"cat_overloaded_autoderef: method={:?}\", method);\n+\n+        let ref_ty = method.sig.output();\n+        let ref_ty = self.infcx.resolve_type_vars_if_possible(&ref_ty);\n+        let base_cmt = self.cat_rvalue_node(expr.id, expr.span, ref_ty);\n+        self.cat_deref(expr, base_cmt, false)\n+    }\n+\n     pub fn cat_deref<N:ast_node>(&self,\n                                  node: &N,\n                                  base_cmt: cmt<'tcx>,\n-                                 overloaded: Option<ty::MethodCallee<'tcx>>)\n+                                 implicit: bool)\n                                  -> McResult<cmt<'tcx>> {\n-        debug!(\"cat_deref: overloaded={:?}\", overloaded);\n+        debug!(\"cat_deref: base_cmt={:?}\", base_cmt);\n \n-        let base_cmt = match overloaded {\n-            Some(method) => {\n-                let ref_ty = self.overloaded_method_return_ty(method);\n-                self.cat_rvalue_node(node.id(), node.span(), ref_ty)\n-            }\n-            None => base_cmt\n-        };\n         let base_cmt_ty = base_cmt.ty;\n-        match base_cmt_ty.builtin_deref(true, ty::NoPreference) {\n-            Some(mt) => {\n-                let ret = self.cat_deref_common(node, base_cmt, mt.ty, false);\n-                debug!(\"cat_deref ret {:?}\", ret);\n-                Ok(ret)\n-            }\n+        let deref_ty = match base_cmt_ty.builtin_deref(true, ty::NoPreference) {\n+            Some(mt) => mt.ty,\n             None => {\n                 debug!(\"Explicit deref of non-derefable type: {:?}\",\n                        base_cmt_ty);\n                 return Err(());\n             }\n-        }\n-    }\n+        };\n \n-    fn cat_deref_common<N:ast_node>(&self,\n-                                    node: &N,\n-                                    base_cmt: cmt<'tcx>,\n-                                    deref_ty: Ty<'tcx>,\n-                                    implicit: bool)\n-                                    -> cmt<'tcx>\n-    {\n         let ptr = match base_cmt.ty.sty {\n             ty::TyAdt(def, ..) if def.is_box() => Unique,\n             ty::TyRawPtr(ref mt) => UnsafePtr(mt.mutbl),\n             ty::TyRef(r, mt) => {\n                 let bk = ty::BorrowKind::from_mutbl(mt.mutbl);\n                 if implicit { Implicit(bk, r) } else { BorrowedPtr(bk, r) }\n             }\n-            ref ty => bug!(\"unexpected type in cat_deref_common: {:?}\", ty)\n+            ref ty => bug!(\"unexpected type in cat_deref: {:?}\", ty)\n         };\n         let ret = Rc::new(cmt_ {\n             id: node.id(),\n@@ -978,15 +981,16 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             ty: deref_ty,\n             note: NoteNone\n         });\n-        debug!(\"cat_deref_common ret {:?}\", ret);\n-        ret\n+        debug!(\"cat_deref ret {:?}\", ret);\n+        Ok(ret)\n     }\n \n-    pub fn cat_index<N:ast_node>(&self,\n-                                 elt: &N,\n-                                 mut base_cmt: cmt<'tcx>,\n-                                 context: InteriorOffsetKind)\n-                                 -> McResult<cmt<'tcx>> {\n+    fn cat_index<N:ast_node>(&self,\n+                             elt: &N,\n+                             base_cmt: cmt<'tcx>,\n+                             element_ty: Ty<'tcx>,\n+                             context: InteriorOffsetKind)\n+                             -> McResult<cmt<'tcx>> {\n         //! Creates a cmt for an indexing operation (`[]`).\n         //!\n         //! One subtle aspect of indexing that may not be\n@@ -1004,29 +1008,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         //! - `elt`: the AST node being indexed\n         //! - `base_cmt`: the cmt of `elt`\n \n-        let method = self.infcx.tables.borrow().method_map.get(&elt.id()).cloned();\n-        let (element_ty, element_kind) = match method {\n-            Some(method) => {\n-                let ref_ty = self.overloaded_method_return_ty(method);\n-                base_cmt = self.cat_rvalue_node(elt.id(), elt.span(), ref_ty);\n-\n-                (ref_ty.builtin_deref(false, ty::NoPreference).unwrap().ty,\n-                 ElementKind::OtherElement)\n-            }\n-            None => {\n-                match base_cmt.ty.builtin_index() {\n-                    Some(ty) => (ty, ElementKind::VecElement),\n-                    None => {\n-                        debug!(\"Explicit index of non-indexable type {:?}\", base_cmt);\n-                        return Err(());\n-                    }\n-                }\n-            }\n-        };\n-\n-        let interior_elem = InteriorElement(context, element_kind);\n+        let interior_elem = InteriorElement(context);\n         let ret =\n-            self.cat_imm_interior(elt, base_cmt.clone(), element_ty, interior_elem);\n+            self.cat_imm_interior(elt, base_cmt, element_ty, interior_elem);\n         debug!(\"cat_index ret {:?}\", ret);\n         return Ok(ret);\n     }\n@@ -1216,15 +1200,20 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n             // PatKind::Ref since that information is already contained\n             // in the type.\n-            let method = self.infcx.tables.borrow().method_map\n-                .get(&pat.id).cloned();\n-            let subcmt = self.cat_deref(pat, cmt, method)?;\n+            let subcmt = self.cat_deref(pat, cmt, false)?;\n             self.cat_pattern_(subcmt, &subpat, op)?;\n           }\n \n           PatKind::Slice(ref before, ref slice, ref after) => {\n+            let element_ty = match cmt.ty.builtin_index() {\n+                Some(ty) => ty,\n+                None => {\n+                    debug!(\"Explicit index of non-indexable type {:?}\", cmt);\n+                    return Err(());\n+                }\n+            };\n             let context = InteriorOffsetKind::Pattern;\n-            let elt_cmt = self.cat_index(pat, cmt, context)?;\n+            let elt_cmt = self.cat_index(pat, cmt, element_ty, context)?;\n             for before_pat in before {\n                 self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n             }\n@@ -1244,16 +1233,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         Ok(())\n     }\n-\n-    fn overloaded_method_return_ty(&self,\n-                                   method: ty::MethodCallee<'tcx>)\n-                                   -> Ty<'tcx>\n-    {\n-        // When we process an overloaded `*` or `[]` etc, we often\n-        // need to extract the return type of the method.\n-        let ret_ty = method.sig.output();\n-        self.infcx.resolve_type_vars_if_possible(&ret_ty)\n-    }\n }\n \n #[derive(Clone, Debug)]\n@@ -1401,16 +1380,10 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::Interior(_, InteriorField(PositionalField(_))) => {\n                 \"anonymous field\".to_string()\n             }\n-            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Index,\n-                                                        VecElement)) |\n-            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Index,\n-                                                        OtherElement)) => {\n+            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Index)) => {\n                 \"indexed content\".to_string()\n             }\n-            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Pattern,\n-                                                        VecElement)) |\n-            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Pattern,\n-                                                        OtherElement)) => {\n+            Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Pattern)) => {\n                 \"pattern-bound indexed content\".to_string()\n             }\n             Categorization::Upvar(ref var) => {"}, {"sha": "0fe8865f4a268a6c4f5d682d2892a389afc639de", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "patch": "@@ -805,7 +805,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 self.check_if_assigned_path_is_moved(id, span,\n                                                      use_kind, lp_base);\n             }\n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorElement(..))) |\n+            LpExtend(ref lp_base, _, LpInterior(_, InteriorElement)) |\n             LpExtend(ref lp_base, _, LpDeref(_)) => {\n                 // assigning to `P[i]` requires `P` is initialized\n                 // assigning to `(*P)` requires `P` is initialized"}, {"sha": "3d98c2a23dc674317b619c96c502830c16a9b624", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "patch": "@@ -237,7 +237,7 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n         Categorization::Downcast(ref b, _) |\n         Categorization::Interior(ref b, mc::InteriorField(_)) |\n-        Categorization::Interior(ref b, mc::InteriorElement(Kind::Pattern, _)) => {\n+        Categorization::Interior(ref b, mc::InteriorElement(Kind::Pattern)) => {\n             match b.ty.sty {\n                 ty::TyAdt(def, _) => {\n                     if def.has_dtor(bccx.tcx) {\n@@ -253,7 +253,7 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             }\n         }\n \n-        Categorization::Interior(_, mc::InteriorElement(Kind::Index, _)) => {\n+        Categorization::Interior(_, mc::InteriorElement(Kind::Index)) => {\n             // Forbid move of arr[i] for arr: [T; 3]; see RFC 533.\n             Some(cmt.clone())\n         }"}, {"sha": "cceb4a7b3cc2180a1d41e9354d4298ac78c85445", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "patch": "@@ -152,7 +152,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             err\n         }\n \n-        Categorization::Interior(ref b, mc::InteriorElement(ik, _)) => {\n+        Categorization::Interior(ref b, mc::InteriorElement(ik)) => {\n             match (&b.ty.sty, ik) {\n                 (&ty::TySlice(..), _) |\n                 (_, Kind::Index) => {"}, {"sha": "2b5bbe0e8a5dff88768b95601794620625f48ee6", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "patch": "@@ -284,15 +284,15 @@ const DOWNCAST_PRINTED_OPERATOR: &'static str = \" as \";\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InteriorKind {\n     InteriorField(mc::FieldName),\n-    InteriorElement(mc::ElementKind),\n+    InteriorElement,\n }\n \n trait ToInteriorKind { fn cleaned(self) -> InteriorKind; }\n impl ToInteriorKind for mc::InteriorKind {\n     fn cleaned(self) -> InteriorKind {\n         match self {\n             mc::InteriorField(name) => InteriorField(name),\n-            mc::InteriorElement(_, elem_kind) => InteriorElement(elem_kind),\n+            mc::InteriorElement(_) => InteriorElement,\n         }\n     }\n }\n@@ -1232,7 +1232,7 @@ before rustc 1.16, this temporary lived longer - see issue #39283 \\\n                 }\n             }\n \n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorElement(..))) => {\n+            LpExtend(ref lp_base, _, LpInterior(_, InteriorElement)) => {\n                 self.append_autoderefd_loan_path_to_string(&lp_base, out);\n                 out.push_str(\"[..]\");\n             }\n@@ -1318,7 +1318,7 @@ impl<'tcx> fmt::Debug for InteriorKind {\n         match *self {\n             InteriorField(mc::NamedField(fld)) => write!(f, \"{}\", fld),\n             InteriorField(mc::PositionalField(i)) => write!(f, \"#{}\", i),\n-            InteriorElement(..) => write!(f, \"[]\"),\n+            InteriorElement => write!(f, \"[]\"),\n         }\n     }\n }"}, {"sha": "0a31905c7928af79c050177a1653ee84d1bb135b", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "patch": "@@ -191,7 +191,7 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n         LpVar(_) | LpUpvar(_) => {\n             true\n         }\n-        LpExtend(.., LpInterior(_, InteriorKind::InteriorElement(..))) => {\n+        LpExtend(.., LpInterior(_, InteriorKind::InteriorElement)) => {\n             // Paths involving element accesses a[i] do not refer to a unique\n             // location, as there is no accurate tracking of the indices.\n             //"}, {"sha": "eee1f1a9712d2b335830f41cd2e0f8fd263a2e18", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "patch": "@@ -94,8 +94,8 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                         debug!(\"make_mirror: overloaded autoderef (method={:?})\", method);\n \n                         ref_ty = method.sig.output();\n-                        let (region, mutbl) = match ref_ty.sty {\n-                            ty::TyRef(region, mt) => (region, mt.mutbl),\n+                        let (region, mt) = match ref_ty.sty {\n+                            ty::TyRef(region, mt) => (region, mt),\n                             _ => span_bug!(expr.span, \"autoderef returned bad type\"),\n                         };\n \n@@ -105,18 +105,19 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                             ty: cx.tcx.mk_ref(region,\n                                               ty::TypeAndMut {\n                                                   ty: expr.ty,\n-                                                  mutbl: mutbl,\n+                                                  mutbl: mt.mutbl,\n                                               }),\n                             span: expr.span,\n                             kind: ExprKind::Borrow {\n                                 region: region,\n-                                borrow_kind: to_borrow_kind(mutbl),\n+                                borrow_kind: to_borrow_kind(mt.mutbl),\n                                 arg: expr.to_ref(),\n                             },\n                         };\n \n                         overloaded_lvalue(cx,\n                                           self,\n+                                          mt.ty,\n                                           method,\n                                           PassArgs::ByRef,\n                                           expr.to_ref(),\n@@ -264,13 +265,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n                 // rewrite f(u, v) into FnOnce::call_once(f, (u, v))\n \n-                let sig = method.sig;\n                 let method = method_callee(cx, expr, method);\n \n-                assert_eq!(sig.inputs().len(), 2);\n-\n+                let arg_tys = args.iter().map(|e| cx.tables().expr_ty_adjusted(e));\n                 let tupled_args = Expr {\n-                    ty: sig.inputs()[1],\n+                    ty: cx.tcx.mk_tup(arg_tys, false),\n                     temp_lifetime: temp_lifetime,\n                     temp_lifetime_was_shrunk: was_shrunk,\n                     span: expr.span,\n@@ -435,6 +434,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             if let Some(&method) = cx.tables().method_map.get(&expr.id) {\n                 overloaded_lvalue(cx,\n                                   expr,\n+                                  expr_ty,\n                                   method,\n                                   PassArgs::ByValue,\n                                   lhs.to_ref(),\n@@ -451,6 +451,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             if let Some(&method) = cx.tables().method_map.get(&expr.id) {\n                 overloaded_lvalue(cx,\n                                   expr,\n+                                  expr_ty,\n                                   method,\n                                   PassArgs::ByValue,\n                                   arg.to_ref(),\n@@ -996,6 +997,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n+                                     lvalue_ty: Ty<'tcx>,\n                                      method: ty::MethodCallee<'tcx>,\n                                      pass_args: PassArgs,\n                                      receiver: ExprRef<'tcx>,\n@@ -1005,8 +1007,22 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     // call returns an &T and we must add the deref so that the types\n     // line up (this is because `*x` and `x[y]` represent lvalues):\n \n-    // to find the type &T of the content returned by the method;\n-    let ref_ty = method.sig.output();\n+    let recv_ty = match receiver {\n+        ExprRef::Hair(e) => cx.tables().expr_ty_adjusted(e),\n+        ExprRef::Mirror(ref e) => e.ty\n+    };\n+\n+    // Reconstruct the output assuming it's a reference with the\n+    // same region and mutability as the receiver. This holds for\n+    // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n+    let (region, mutbl) = match recv_ty.sty {\n+        ty::TyRef(region, mt) => (region, mt.mutbl),\n+        _ => span_bug!(expr.span, \"overloaded_lvalue: receiver is not a reference\"),\n+    };\n+    let ref_ty = cx.tcx.mk_ref(region, ty::TypeAndMut {\n+        ty: lvalue_ty,\n+        mutbl,\n+    });\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type"}, {"sha": "5cda50b428b7cac7178990abaa7757694bfe066e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65ced5d161d31e7e5b097b36bff0f51ec0843bc/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=a65ced5d161d31e7e5b097b36bff0f51ec0843bc", "patch": "@@ -538,10 +538,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             self.substs_wf_in_scope(origin, &callee.substs, expr.span, expr_region);\n-            for &ty in callee.sig.inputs() {\n-                self.type_must_outlive(infer::ExprTypeIsNotInScope(ty, expr.span),\n-                                       ty, expr_region);\n-            }\n+            // Arguments (sub-expressions) are checked via `constrain_call`, below.\n         }\n \n         // Check any autoderefs or autorefs that appear.\n@@ -690,14 +687,13 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n \n             hir::ExprUnary(hir::UnDeref, ref base) => {\n                 // For *a, the lifetime of a must enclose the deref\n-                let base_ty = match self.tables.borrow().method_map.get(&expr.id) {\n-                    Some(method) => {\n-                        self.constrain_call(expr, Some(&base),\n-                                            None::<hir::Expr>.iter(), true);\n-                        method.sig.output()\n-                    }\n-                    None => self.resolve_node_type(base.id)\n-                };\n+                if self.tables.borrow().is_method_call(expr.id) {\n+                    self.constrain_call(expr, Some(base),\n+                                        None::<hir::Expr>.iter(), true);\n+                }\n+                // For overloaded derefs, base_ty is the input to `Deref::deref`,\n+                // but it's a reference type uing the same region as the output.\n+                let base_ty = self.resolve_expr_type_adjusted(base);\n                 if let ty::TyRef(r_ptr, _) = base_ty.sty {\n                     self.mk_subregion_due_to_dereference(expr.span, expr_region, r_ptr);\n                 }\n@@ -960,7 +956,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n             {\n                 let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-                cmt = mc.cat_deref(deref_expr, cmt, overloaded)?;\n+                if let Some(method) = overloaded {\n+                    cmt = mc.cat_overloaded_autoderef(deref_expr, method)?;\n+                } else {\n+                    cmt = mc.cat_deref(deref_expr, cmt, false)?;\n+                }\n             }\n \n             if let Categorization::Deref(_, mc::BorrowedPtr(_, r_ptr)) = cmt.cat {"}]}