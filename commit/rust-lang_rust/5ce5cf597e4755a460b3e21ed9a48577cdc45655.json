{"sha": "5ce5cf597e4755a460b3e21ed9a48577cdc45655", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjZTVjZjU5N2U0NzU1YTQ2MGIzZTIxZWQ5YTQ4NTc3Y2RjNDU2NTU=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-05-13T20:51:28Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-05-13T20:51:28Z"}, "message": "Rollup merge of #25363 - nham:E0106_E0107_fix, r=alexcrichton\n\ncc #25328", "tree": {"sha": "323bef15627442fb5b1dfc0396a06cdb6614ed8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/323bef15627442fb5b1dfc0396a06cdb6614ed8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ce5cf597e4755a460b3e21ed9a48577cdc45655", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ce5cf597e4755a460b3e21ed9a48577cdc45655", "html_url": "https://github.com/rust-lang/rust/commit/5ce5cf597e4755a460b3e21ed9a48577cdc45655", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ce5cf597e4755a460b3e21ed9a48577cdc45655/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12c93aa278ebbe8527b42d17065d3d5605c26bac", "url": "https://api.github.com/repos/rust-lang/rust/commits/12c93aa278ebbe8527b42d17065d3d5605c26bac", "html_url": "https://github.com/rust-lang/rust/commit/12c93aa278ebbe8527b42d17065d3d5605c26bac"}, {"sha": "5ac262f86c750c6c46901f2f8b9996d6662d80c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ac262f86c750c6c46901f2f8b9996d6662d80c9", "html_url": "https://github.com/rust-lang/rust/commit/5ac262f86c750c6c46901f2f8b9996d6662d80c9"}], "stats": {"total": 175, "additions": 167, "deletions": 8}, "files": [{"sha": "a11a4edbd316b71f5221bb7b1898b241ba85a52a", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 167, "deletions": 8, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/5ce5cf597e4755a460b3e21ed9a48577cdc45655/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ce5cf597e4755a460b3e21ed9a48577cdc45655/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=5ce5cf597e4755a460b3e21ed9a48577cdc45655", "patch": "@@ -19,6 +19,51 @@ methods that do not have default implementations), as well as any required\n trait items like associated types or constants.\n \"##,\n \n+E0049: r##\"\n+This error indicates that an attempted implementation of a trait method\n+has the wrong number of type parameters.\n+\n+For example, the trait below has a method `foo` with a type parameter `T`,\n+but the implementation of `foo` for the type `Bar` is missing this parameter:\n+\n+```\n+trait Foo {\n+    fn foo<T: Default>(x: T) -> Self;\n+}\n+\n+struct Bar;\n+\n+// error: method `foo` has 0 type parameters but its trait declaration has 1\n+// type parameter\n+impl Foo for Bar {\n+    fn foo(x: bool) -> Self { Bar }\n+}\n+```\n+\"##,\n+\n+E0050: r##\"\n+This error indicates that an attempted implementation of a trait method\n+has the wrong number of function parameters.\n+\n+For example, the trait below has a method `foo` with two function parameters\n+(`&self` and `u8`), but the implementation of `foo` for the type `Bar` omits\n+the `u8` parameter:\n+\n+```\n+trait Foo {\n+    fn foo(&self, x: u8) -> bool;\n+}\n+\n+struct Bar;\n+\n+// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`\n+// has 2\n+impl Foo for Bar {\n+    fn foo(&self) -> bool { true }\n+}\n+```\n+\"##,\n+\n E0054: r##\"\n It is not allowed to cast to a bool. If you are trying to cast a numeric type\n to a bool, you can compare it with zero instead:\n@@ -138,6 +183,88 @@ enum Empty {}\n ```\n \"##,\n \n+E0106: r##\"\n+This error indicates that a lifetime is missing from a type. If it is an error\n+inside a function signature, the problem may be with failing to adhere to the\n+lifetime elision rules (see below).\n+\n+Here are some simple examples of where you'll run into this error:\n+\n+```\n+struct Foo { x: &bool }        // error\n+struct Foo<'a> { x: &'a bool } // correct\n+\n+enum Bar { A(u8), B(&bool), }        // error\n+enum Bar<'a> { A(u8), B(&'a bool), } // correct\n+\n+type MyStr = &str;        // error\n+type MyStr<'a> = &'a str; //correct\n+\n+```\n+\n+Lifetime elision is a special, limited kind of inference for lifetimes in\n+function signatures which allows you to leave out lifetimes in certain cases.\n+For more background on lifetime elision see [the book][book-le].\n+\n+The lifetime elision rules require that any function signature with an elided\n+output lifetime must either have\n+\n+ - exactly one input lifetime\n+ - or, multiple input lifetimes, but the function must also be a method with a\n+   `&self` or `&mut self` receiver\n+\n+In the first case, the output lifetime is inferred to be the same as the unique\n+input lifetime. In the second case, the lifetime is instead inferred to be the\n+same as the lifetime on `&self` or `&mut self`.\n+\n+Here are some examples of elision errors:\n+\n+```\n+// error, no input lifetimes\n+fn foo() -> &str { ... }\n+\n+// error, `x` and `y` have distinct lifetimes inferred\n+fn bar(x: &str, y: &str) -> &str { ... }\n+\n+// error, `y`'s lifetime is inferred to be distinct from `x`'s\n+fn baz<'a>(x: &'a str, y: &str) -> &str { ... }\n+```\n+\n+[book-le]: http://doc.rust-lang.org/nightly/book/lifetimes.html#lifetime-elision\n+\"##,\n+\n+E0107: r##\"\n+This error means that an incorrect number of lifetime parameters were provided\n+for a type (like a struct or enum) or trait.\n+\n+Some basic examples include:\n+\n+```\n+struct Foo<'a>(&'a str);\n+enum Bar { A, B, C }\n+\n+struct Baz<'a> {\n+    foo: Foo,     // error: expected 1, found 0\n+    bar: Bar<'a>, // error: expected 0, found 1\n+}\n+```\n+\n+Here's an example that is currently an error, but may work in a future version\n+of Rust:\n+\n+```\n+struct Foo<'a>(&'a str);\n+\n+trait Quux { }\n+impl Quux for Foo { } // error: expected 1, found 0\n+```\n+\n+Lifetime elision in implementation headers was part of the lifetime elision\n+RFC. It is, however, [currently unimplemented][iss15872].\n+\n+[iss15872]: https://github.com/rust-lang/rust/issues/15872\n+\"##,\n+\n E0131: r##\"\n It is not possible to define `main` with type parameters, or even with function\n parameters. When `main` is present, it must take no arguments and return `()`.\n@@ -152,6 +279,20 @@ fn(isize, *const *const u8) -> isize\n ```\n \"##,\n \n+E0166: r##\"\n+This error means that the compiler found a return expression in a function\n+marked as diverging. A function diverges if it has `!` in the place of the\n+return type in its signature. For example:\n+\n+```\n+fn foo() -> ! { return; } // error\n+```\n+\n+For a function that diverges, every control path in the function must never\n+return, for example with a `loop` that never breaks or a call to another\n+diverging function (such as `panic!()`).\n+\"##,\n+\n E0184: r##\"\n Explicitly implementing both Drop and Copy for a type is currently disallowed.\n This feature can make some sense in theory, but the current implementation is\n@@ -161,6 +302,24 @@ it has been disabled for now.\n [iss20126]: https://github.com/rust-lang/rust/issues/20126\n \"##,\n \n+E0201: r##\"\n+It is an error to define a method--a trait method or an inherent method--more\n+than once.\n+\n+For example,\n+\n+```\n+struct Foo(u8);\n+\n+impl Foo {\n+    fn bar() {}\n+\n+    // error: duplicate method\n+    fn bar(&self) -> bool { self.0 > 5 }\n+}\n+```\n+\"##,\n+\n E0204: r##\"\n An attempt to implement the `Copy` trait for a struct failed because one of the\n fields does not implement `Copy`. To fix this, you must implement `Copy` for the\n@@ -292,6 +451,13 @@ const B: [u32; foo()] = [];\n use std::{f64, u8};\n const C: [u32; u8::MAX + f64::EPSILON] = [];\n ```\n+\"##,\n+\n+E0322: r##\"\n+The `Sized` trait is a special trait built-in to the compiler for types with a\n+constant size known at compile-time. This trait is automatically implemented\n+for types as needed by the compiler, and it is currently disallowed to\n+explicitly implement it for a type.\n \"##\n \n }\n@@ -312,8 +478,6 @@ register_diagnostics! {\n     E0040, // explicit use of destructor method\n     E0044, // foreign items may not have type parameters\n     E0045, // variadic function must have C calling convention\n-    E0049,\n-    E0050,\n     E0053,\n     E0055, // method has an incompatible type for trait\n     E0057, // method has an incompatible type for trait\n@@ -345,8 +509,6 @@ register_diagnostics! {\n     E0102,\n     E0103,\n     E0104,\n-    E0106,\n-    E0107,\n     E0116,\n     E0117,\n     E0118,\n@@ -364,7 +526,6 @@ register_diagnostics! {\n     E0159,\n     E0163,\n     E0164,\n-    E0166,\n     E0167,\n     E0168,\n     E0172,\n@@ -390,7 +551,6 @@ register_diagnostics! {\n     E0198, // negative implementations are not unsafe\n     E0199, // implementing trait is not unsafe\n     E0200, // trait requires an `unsafe impl` declaration\n-    E0201, // duplicate method in trait impl\n     E0202, // associated items are not allowed in inherent impls\n     E0203, // type parameter has more than one relaxed default bound,\n            // and only one is supported\n@@ -421,7 +581,7 @@ register_diagnostics! {\n     E0231, // only named substitution parameters are allowed\n     E0232, // this attribute must have a value\n     E0233,\n-    E0234, // `for` loop expression has type which does not implement the `Iterator` trait\n+    E0234,\n     E0235, // structure constructor specifies a structure of type but\n     E0236, // no lang item for range syntax\n     E0237, // no lang item for range syntax\n@@ -438,7 +598,6 @@ register_diagnostics! {\n     E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck\n     E0321, // extended coherence rules for defaulted traits violated\n-    E0322, // cannot implement Sized explicitly\n     E0323, // implemented an associated const when another trait item expected\n     E0324, // implemented a method when another trait item expected\n     E0325, // implemented an associated type when another trait item expected"}]}