{"sha": "9ee462625bae26c0dd93f996d8297b8d39450ab8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllZTQ2MjYyNWJhZTI2YzBkZDkzZjk5NmQ4Mjk3YjhkMzk0NTBhYjg=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-02-12T11:18:15Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-02-12T11:18:15Z"}, "message": "Merge pull request #637 from mcarton/debug\n\nLint usage of `Debug`-based formatting", "tree": {"sha": "c213d7f7b588ae14779f7df9a269bf515a52ab52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c213d7f7b588ae14779f7df9a269bf515a52ab52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ee462625bae26c0dd93f996d8297b8d39450ab8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ee462625bae26c0dd93f996d8297b8d39450ab8", "html_url": "https://github.com/rust-lang/rust/commit/9ee462625bae26c0dd93f996d8297b8d39450ab8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ee462625bae26c0dd93f996d8297b8d39450ab8/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1edd6ff1e1ea08595b87eb4a4555044e35fa24d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1edd6ff1e1ea08595b87eb4a4555044e35fa24d", "html_url": "https://github.com/rust-lang/rust/commit/c1edd6ff1e1ea08595b87eb4a4555044e35fa24d"}, {"sha": "2db6965c81ee9f01b12874c115ec2a593b5f2c5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2db6965c81ee9f01b12874c115ec2a593b5f2c5f", "html_url": "https://github.com/rust-lang/rust/commit/2db6965c81ee9f01b12874c115ec2a593b5f2c5f"}], "stats": {"total": 263, "additions": 147, "deletions": 116}, "files": [{"sha": "39e2cf15a37881a6946ee49ce45d3bcb06656581", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9ee462625bae26c0dd93f996d8297b8d39450ab8/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/9ee462625bae26c0dd93f996d8297b8d39450ab8/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=9ee462625bae26c0dd93f996d8297b8d39450ab8", "patch": "@@ -119,6 +119,7 @@ name\n [unstable_as_slice](https://github.com/Manishearth/rust-clippy/wiki#unstable_as_slice)                         | warn    | as_slice is not stable and can be replaced by & v[..]see https://github.com/rust-lang/rust/issues/27729\n [unused_collect](https://github.com/Manishearth/rust-clippy/wiki#unused_collect)                               | warn    | `collect()`ing an iterator without using the result; this is usually better written as a for loop\n [unused_lifetimes](https://github.com/Manishearth/rust-clippy/wiki#unused_lifetimes)                           | warn    | unused lifetimes in function definitions\n+[use_debug](https://github.com/Manishearth/rust-clippy/wiki#use_debug)                                         | allow   | use `Debug`-based formatting\n [used_underscore_binding](https://github.com/Manishearth/rust-clippy/wiki#used_underscore_binding)             | warn    | using a binding which is prefixed with an underscore\n [useless_transmute](https://github.com/Manishearth/rust-clippy/wiki#useless_transmute)                         | warn    | transmutes that have the same to and from types\n [useless_vec](https://github.com/Manishearth/rust-clippy/wiki#useless_vec)                                     | warn    | useless `vec!`"}, {"sha": "ddc8560c9b37f518ad1e1fcaad28fd9201e86319", "filename": "src/consts.rs", "status": "modified", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/9ee462625bae26c0dd93f996d8297b8d39450ab8/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ee462625bae26c0dd93f996d8297b8d39450ab8/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=9ee462625bae26c0dd93f996d8297b8d39450ab8", "patch": "@@ -6,12 +6,10 @@ use rustc::middle::def::PathResolution;\n use rustc::middle::def::Def;\n use rustc_front::hir::*;\n use syntax::ptr::P;\n-use std::char;\n use std::cmp::PartialOrd;\n use std::cmp::Ordering::{self, Greater, Less, Equal};\n use std::rc::Rc;\n use std::ops::Deref;\n-use std::fmt;\n \n use syntax::ast::Lit_;\n use syntax::ast::LitIntType;\n@@ -173,90 +171,6 @@ impl PartialOrd for Constant {\n     }\n }\n \n-fn format_byte(fmt: &mut fmt::Formatter, b: u8) -> fmt::Result {\n-    if b == b'\\\\' {\n-        write!(fmt, \"\\\\\\\\\")\n-    } else if 0x20 <= b && b <= 0x7e {\n-        write!(fmt, \"{}\", char::from_u32(b as u32).expect(\"all u8 are valid char\"))\n-    } else if b == 0x0a {\n-        write!(fmt, \"\\\\n\")\n-    } else if b == 0x0d {\n-        write!(fmt, \"\\\\r\")\n-    } else {\n-        write!(fmt, \"\\\\x{:02x}\", b)\n-    }\n-}\n-\n-impl fmt::Display for Constant {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Constant::Str(ref s, _) => write!(fmt, \"{:?}\", s),\n-            Constant::Byte(ref b) => {\n-                write!(fmt, \"b'\")\n-                    .and_then(|_| format_byte(fmt, *b))\n-                    .and_then(|_| write!(fmt, \"'\"))\n-            }\n-            Constant::Binary(ref bs) => {\n-                try!(write!(fmt, \"b\\\"\"));\n-                for b in bs.iter() {\n-                    try!(format_byte(fmt, *b));\n-                }\n-                write!(fmt, \"\\\"\")\n-            }\n-            Constant::Char(ref c) => write!(fmt, \"'{}'\", c),\n-            Constant::Int(ref i, ref ity) => {\n-                let (sign, suffix) = match *ity {\n-                    LitIntType::SignedIntLit(ref sity, ref sign) => {\n-                        (if let Sign::Minus = *sign {\n-                            \"-\"\n-                        } else {\n-                            \"\"\n-                        },\n-                         sity.ty_to_string())\n-                    }\n-                    LitIntType::UnsignedIntLit(ref uity) => (\"\", uity.ty_to_string()),\n-                    LitIntType::UnsuffixedIntLit(ref sign) => {\n-                        (if let Sign::Minus = *sign {\n-                            \"-\"\n-                        } else {\n-                            \"\"\n-                        },\n-                         \"\".into())\n-                    }\n-                };\n-                write!(fmt, \"{}{}{}\", sign, i, suffix)\n-            }\n-            Constant::Float(ref s, ref fw) => {\n-                let suffix = match *fw {\n-                    FloatWidth::Fw32 => \"f32\",\n-                    FloatWidth::Fw64 => \"f64\",\n-                    FloatWidth::FwAny => \"\",\n-                };\n-                write!(fmt, \"{}{}\", s, suffix)\n-            }\n-            Constant::Bool(ref b) => write!(fmt, \"{}\", b),\n-            Constant::Repeat(ref c, ref n) => write!(fmt, \"[{}; {}]\", c, n),\n-            Constant::Vec(ref v) => {\n-                write!(fmt,\n-                       \"[{}]\",\n-                       v.iter()\n-                        .map(|i| format!(\"{}\", i))\n-                        .collect::<Vec<_>>()\n-                        .join(\", \"))\n-            }\n-            Constant::Tuple(ref t) => {\n-                write!(fmt,\n-                       \"({})\",\n-                       t.iter()\n-                        .map(|i| format!(\"{}\", i))\n-                        .collect::<Vec<_>>()\n-                        .join(\", \"))\n-            }\n-        }\n-    }\n-}\n-\n-\n fn lit_to_constant(lit: &Lit_) -> Constant {\n     match *lit {\n         Lit_::LitStr(ref is, style) => Constant::Str(is.to_string(), style),"}, {"sha": "775b983075042c1f14e606fb4d6832f4ca2a1730", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9ee462625bae26c0dd93f996d8297b8d39450ab8/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ee462625bae26c0dd93f996d8297b8d39450ab8/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=9ee462625bae26c0dd93f996d8297b8d39450ab8", "patch": "@@ -170,6 +170,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         mut_mut::MUT_MUT,\n         mutex_atomic::MUTEX_INTEGER,\n         print::PRINT_STDOUT,\n+        print::USE_DEBUG,\n         shadow::SHADOW_REUSE,\n         shadow::SHADOW_SAME,\n         shadow::SHADOW_UNRELATED,"}, {"sha": "cecf47daf55639e62bc1a1011406007758c38afc", "filename": "src/loops.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9ee462625bae26c0dd93f996d8297b8d39450ab8/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ee462625bae26c0dd93f996d8297b8d39450ab8/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=9ee462625bae26c0dd93f996d8297b8d39450ab8", "patch": "@@ -1,11 +1,12 @@\n+use reexport::*;\n+use rustc::front::map::Node::NodeBlock;\n use rustc::lint::*;\n+use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n+use rustc::middle::const_eval::{ConstVal, eval_const_expr_partial};\n+use rustc::middle::def::Def;\n+use rustc::middle::ty;\n use rustc_front::hir::*;\n-use reexport::*;\n use rustc_front::intravisit::{Visitor, walk_expr, walk_block, walk_decl};\n-use rustc::middle::ty;\n-use rustc::middle::def::Def;\n-use consts::{constant_simple, Constant};\n-use rustc::front::map::Node::NodeBlock;\n use std::borrow::Cow;\n use std::collections::{HashSet, HashMap};\n \n@@ -421,22 +422,36 @@ fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n     // if this for loop is iterating over a two-sided range...\n     if let ExprRange(Some(ref start_expr), Some(ref stop_expr)) = arg.node {\n         // ...and both sides are compile-time constant integers...\n-        if let Some(start_idx @ Constant::Int(..)) = constant_simple(start_expr) {\n-            if let Some(stop_idx @ Constant::Int(..)) = constant_simple(stop_expr) {\n+        if let Ok(start_idx) = eval_const_expr_partial(&cx.tcx, start_expr, ExprTypeChecked, None) {\n+            if let Ok(stop_idx) = eval_const_expr_partial(&cx.tcx, stop_expr, ExprTypeChecked, None) {\n                 // ...and the start index is greater than the stop index,\n                 // this loop will never run. This is often confusing for developers\n                 // who think that this will iterate from the larger value to the\n                 // smaller value.\n-                if start_idx > stop_idx {\n-                    span_help_and_lint(cx,\n+                let (sup, eq) = match (start_idx, stop_idx) {\n+                    (ConstVal::Int(start_idx), ConstVal::Int(stop_idx)) => (start_idx > stop_idx, start_idx == stop_idx),\n+                    (ConstVal::Uint(start_idx), ConstVal::Uint(stop_idx)) => (start_idx > stop_idx, start_idx == stop_idx),\n+                    _ => (false, false),\n+                };\n+\n+                if sup {\n+                    let start_snippet = snippet(cx, start_expr.span, \"_\");\n+                    let stop_snippet = snippet(cx, stop_expr.span, \"_\");\n+\n+                    span_lint_and_then(cx,\n                                        REVERSE_RANGE_LOOP,\n                                        expr.span,\n                                        \"this range is empty so this for loop will never run\",\n-                                       &format!(\"Consider using `({}..{}).rev()` if you are attempting to iterate \\\n-                                                 over this range in reverse\",\n-                                                stop_idx,\n-                                                start_idx));\n-                } else if start_idx == stop_idx {\n+                                       |db| {\n+                                           db.span_suggestion(expr.span,\n+                                                              \"consider using the following if \\\n+                                                               you are attempting to iterate \\\n+                                                               over this range in reverse\",\n+                                                               format!(\"({}..{}).rev()` \",\n+                                                                       stop_snippet,\n+                                                                       start_snippet));\n+                                       });\n+                } else if eq {\n                     // if they are equal, it's also problematic - this loop\n                     // will never run.\n                     span_lint(cx,"}, {"sha": "f570c18b7429013070398fe7ff7df7855111cd40", "filename": "src/misc.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9ee462625bae26c0dd93f996d8297b8d39450ab8/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ee462625bae26c0dd93f996d8297b8d39450ab8/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=9ee462625bae26c0dd93f996d8297b8d39450ab8", "patch": "@@ -11,7 +11,7 @@ use rustc::middle::const_eval::eval_const_expr_partial;\n use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n \n use utils::{get_item_name, match_path, snippet, get_parent_expr, span_lint};\n-use utils::{span_help_and_lint, walk_ptrs_ty, is_integer_literal, implements_trait};\n+use utils::{span_lint_and_then, walk_ptrs_ty, is_integer_literal, implements_trait};\n \n /// **What it does:** This lint checks for function arguments and let bindings denoted as `ref`.\n ///\n@@ -62,16 +62,22 @@ impl LateLintPass for TopLevelRefPass {\n             let Some(ref init) = l.init\n             ], {\n                 let tyopt = if let Some(ref ty) = l.ty {\n-                    format!(\": {:?} \", ty)\n+                    format!(\": {}\", snippet(cx, ty.span, \"_\"))\n                 } else {\n                     \"\".to_owned()\n                 };\n-                span_help_and_lint(cx,\n+                span_lint_and_then(cx,\n                     TOPLEVEL_REF_ARG,\n                     l.pat.span,\n                     \"`ref` on an entire `let` pattern is discouraged, take a reference with & instead\",\n-                    &format!(\"try `let {} {}= &{};`\", snippet(cx, i.span, \"_\"),\n-                             tyopt, snippet(cx, init.span, \"_\"))\n+                    |db| {\n+                        db.span_suggestion(s.span,\n+                                           \"try\",\n+                                           format!(\"let {}{} = &{};\",\n+                                                   snippet(cx, i.span, \"_\"),\n+                                                   tyopt,\n+                                                   snippet(cx, init.span, \"_\")));\n+                    }\n                 );\n             }\n         };"}, {"sha": "3c10b4bed13f7d1a011a9a70ea3b593a96d8a2b6", "filename": "src/print.rs", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9ee462625bae26c0dd93f996d8297b8d39450ab8/src%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ee462625bae26c0dd93f996d8297b8d39450ab8/src%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprint.rs?ref=9ee462625bae26c0dd93f996d8297b8d39450ab8", "patch": "@@ -1,6 +1,8 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n-use utils::{IO_PRINT_PATH, is_expn_of, match_path, span_lint};\n+use rustc::front::map::Node::{NodeItem, NodeImplItem};\n+use utils::{FMT_ARGUMENTV1_NEW_PATH, DEBUG_FMT_METHOD_PATH, IO_PRINT_PATH};\n+use utils::{is_expn_of, match_path, span_lint};\n \n /// **What it does:** This lint warns whenever you print on *stdout*. The purpose of this lint is to catch debugging remnants.\n ///\n@@ -16,21 +18,36 @@ declare_lint! {\n     \"printing on stdout\"\n }\n \n+/// **What it does:** This lint warns whenever you use `Debug` formatting. The purpose of this lint is to catch debugging remnants.\n+///\n+/// **Why is this bad?** The purpose of the `Debug` trait is to facilitate debugging Rust code. It\n+/// should not be used in in user-facing output.\n+///\n+/// **Example:** `println!(\"{:?}\", foo);`\n+declare_lint! {\n+    pub USE_DEBUG,\n+    Allow,\n+    \"use `Debug`-based formatting\"\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub struct PrintLint;\n \n impl LintPass for PrintLint {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(PRINT_STDOUT)\n+        lint_array!(PRINT_STDOUT, USE_DEBUG)\n     }\n }\n \n impl LateLintPass for PrintLint {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprCall(ref fun, _) = expr.node {\n+        if let ExprCall(ref fun, ref args) = expr.node {\n             if let ExprPath(_, ref path) = fun.node {\n+                // Search for `std::io::_print(..)` which is unique in a\n+                // `print!` expansion.\n                 if match_path(path, &IO_PRINT_PATH) {\n                     if let Some(span) = is_expn_of(cx, expr.span, \"print\") {\n+                        // `println!` uses `print!`.\n                         let (span, name) = match is_expn_of(cx, span, \"println\") {\n                             Some(span) => (span, \"println\"),\n                             None => (span, \"print\"),\n@@ -39,7 +56,32 @@ impl LateLintPass for PrintLint {\n                         span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n                     }\n                 }\n+                // Search for something like\n+                // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n+                else if args.len() == 2 && match_path(path, &FMT_ARGUMENTV1_NEW_PATH) {\n+                    if let ExprPath(None, ref path) = args[1].node {\n+                        if match_path(path, &DEBUG_FMT_METHOD_PATH) &&\n+                            !is_in_debug_impl(cx, expr) &&\n+                            is_expn_of(cx, expr.span, \"panic\").is_none() {\n+                            span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n+                        }\n+                    }\n+                }\n             }\n         }\n     }\n }\n+\n+fn is_in_debug_impl(cx: &LateContext, expr: &Expr) -> bool {\n+    let map = &cx.tcx.map;\n+\n+    if let Some(NodeImplItem(item)) = map.find(map.get_parent(expr.id)) { // `fmt` method\n+        if let Some(NodeItem(item)) = map.find(map.get_parent(item.id)) { // `Debug` impl\n+            if let ItemImpl(_, _, _, Some(ref tr), _, _) = item.node {\n+                return match_path(&tr.path, &[\"Debug\"]);\n+            }\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "4c89b7f113d1e084d3e2e8061d698e0e223a35bd", "filename": "src/utils.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ee462625bae26c0dd93f996d8297b8d39450ab8/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ee462625bae26c0dd93f996d8297b8d39450ab8/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=9ee462625bae26c0dd93f996d8297b8d39450ab8", "patch": "@@ -26,8 +26,10 @@ pub const BTREEMAP_PATH: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"BT\n pub const CLONE_PATH: [&'static str; 3] = [\"clone\", \"Clone\", \"clone\"];\n pub const CLONE_TRAIT_PATH: [&'static str; 2] = [\"clone\", \"Clone\"];\n pub const COW_PATH: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n+pub const DEBUG_FMT_METHOD_PATH: [&'static str; 4] = [\"std\", \"fmt\", \"Debug\", \"fmt\"];\n pub const DEFAULT_TRAIT_PATH: [&'static str; 3] = [\"core\", \"default\", \"Default\"];\n pub const DROP_PATH: [&'static str; 3] = [\"core\", \"mem\", \"drop\"];\n+pub const FMT_ARGUMENTV1_NEW_PATH: [&'static str; 4] = [\"std\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const HASHMAP_ENTRY_PATH: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n pub const HASHMAP_PATH: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n pub const HASH_PATH: [&'static str; 2] = [\"hash\", \"Hash\"];"}, {"sha": "4609c840836cad68d6950793d9cc8d2b15742689", "filename": "tests/compile-fail/for_loop.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9ee462625bae26c0dd93f996d8297b8d39450ab8/tests%2Fcompile-fail%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ee462625bae26c0dd93f996d8297b8d39450ab8/tests%2Fcompile-fail%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffor_loop.rs?ref=9ee462625bae26c0dd93f996d8297b8d39450ab8", "patch": "@@ -65,7 +65,7 @@ fn for_loop_over_option_and_result() {\n         break;\n     }\n \n-    // while let false positive for Option\n+    // while let false positive for Result\n     while let Ok(x) = result {\n         println!(\"{}\", x);\n         break;\n@@ -85,8 +85,10 @@ impl Unrelated {\n \n #[deny(needless_range_loop, explicit_iter_loop, iter_next_loop, reverse_range_loop, explicit_counter_loop)]\n #[deny(unused_collect)]\n-#[allow(linkedlist,shadow_unrelated,unnecessary_mut_passed, cyclomatic_complexity)]\n+#[allow(linkedlist, shadow_unrelated, unnecessary_mut_passed, cyclomatic_complexity)]\n fn main() {\n+    const MAX_LEN: usize = 42;\n+\n     let mut vec = vec![1, 2, 3, 4];\n     let vec2 = vec![1, 2, 3, 4];\n     for i in 0..vec.len() {\n@@ -111,6 +113,11 @@ fn main() {\n         println!(\"{}\", vec[i]);\n     }\n \n+    for i in 0..MAX_LEN {\n+        //~^ ERROR `i` is only used to index `vec`. Consider using `for item in vec.iter().take(MAX_LEN)`\n+        println!(\"{}\", vec[i]);\n+    }\n+\n     for i in 5..10 {\n         //~^ ERROR `i` is only used to index `vec`. Consider using `for item in vec.iter().take(10).skip(5)`\n         println!(\"{}\", vec[i]);\n@@ -126,7 +133,16 @@ fn main() {\n         println!(\"{} {}\", vec[i], i);\n     }\n \n-    for i in 10..0 { //~ERROR this range is empty so this for loop will never run\n+    for i in 10..0 {\n+        //~^ERROR this range is empty so this for loop will never run\n+        //~|HELP consider\n+        //~|SUGGESTION (0..10).rev()\n+        println!(\"{}\", i);\n+    }\n+\n+    for i in MAX_LEN..0 { //~ERROR this range is empty so this for loop will never run\n+        //~|HELP consider\n+        //~|SUGGESTION (0..MAX_LEN).rev()\n         println!(\"{}\", i);\n     }\n "}, {"sha": "34c38dca2861e0b8b117f7faa51bbb477493bd48", "filename": "tests/compile-fail/print.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9ee462625bae26c0dd93f996d8297b8d39450ab8/tests%2Fcompile-fail%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ee462625bae26c0dd93f996d8297b8d39450ab8/tests%2Fcompile-fail%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fprint.rs?ref=9ee462625bae26c0dd93f996d8297b8d39450ab8", "patch": "@@ -1,11 +1,41 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n+#![deny(print_stdout, use_debug)]\n \n-#[deny(print_stdout)]\n+use std::fmt::{Debug, Display, Formatter, Result};\n+\n+#[allow(dead_code)]\n+struct Foo;\n+\n+impl Display for Foo {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        write!(f, \"{:?}\", 43.1415)\n+        //~^ ERROR use of `Debug`-based formatting\n+    }\n+}\n+\n+impl Debug for Foo {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        // ok, we can use `Debug` formatting in `Debug` implementations\n+        write!(f, \"{:?}\", 42.718)\n+    }\n+}\n \n fn main() {\n     println!(\"Hello\"); //~ERROR use of `println!`\n     print!(\"Hello\"); //~ERROR use of `print!`\n \n+    print!(\"Hello {}\", \"World\"); //~ERROR use of `print!`\n+\n+    print!(\"Hello {:?}\", \"World\");\n+    //~^ ERROR use of `print!`\n+    //~| ERROR use of `Debug`-based formatting\n+\n+    print!(\"Hello {:#?}\", \"#orld\");\n+    //~^ ERROR use of `print!`\n+    //~| ERROR use of `Debug`-based formatting\n+\n+    assert_eq!(42, 1337);\n+\n     vec![1, 2];\n }"}, {"sha": "de1556ed0e399fca9b9805adfff9fca6792aa41f", "filename": "tests/compile-fail/toplevel_ref_arg.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9ee462625bae26c0dd93f996d8297b8d39450ab8/tests%2Fcompile-fail%2Ftoplevel_ref_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ee462625bae26c0dd93f996d8297b8d39450ab8/tests%2Fcompile-fail%2Ftoplevel_ref_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ftoplevel_ref_arg.rs?ref=9ee462625bae26c0dd93f996d8297b8d39450ab8", "patch": "@@ -15,11 +15,15 @@ fn main() {\n   let y = |ref x| { println!(\"{:?}\", x) };\n   y(1u8);\n \n-  let ref x = 1; //~ ERROR `ref` on an entire `let` pattern is discouraged\n-                 //~^ HELP try `let x = &1;`\n+  let ref x = 1;\n+  //~^ ERROR `ref` on an entire `let` pattern is discouraged\n+  //~| HELP try\n+  //~| SUGGESTION let x = &1;\n \n-  let ref y = (&1, 2); //~ ERROR `ref` on an entire `let` pattern is discouraged\n-                 //~^ HELP try `let y = &(&1, 2);`\n+  let ref y : (&_, u8) = (&1, 2);\n+  //~^ ERROR `ref` on an entire `let` pattern is discouraged\n+  //~| HELP try\n+  //~| SUGGESTION let y: (&_, u8) = &(&1, 2);\n \n   let (ref x, _) = (1,2); // okay, not top level\n   println!(\"The answer is {}.\", x);"}]}