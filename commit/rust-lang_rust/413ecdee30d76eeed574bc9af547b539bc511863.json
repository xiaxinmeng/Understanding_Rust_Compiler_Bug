{"sha": "413ecdee30d76eeed574bc9af547b539bc511863", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxM2VjZGVlMzBkNzZlZWVkNTc0YmM5YWY1NDdiNTM5YmM1MTE4NjM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-28T10:34:44Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-28T10:34:50Z"}, "message": "Rollup merge of #35728 - petrochenkov:empderive, r=manishearth\n\nFix #[derive] for empty tuple structs/variants\n\nThis was missing from https://github.com/rust-lang/rust/pull/35138", "tree": {"sha": "a1931941954b1e2702eeb5f9a0ed70526c22fdf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1931941954b1e2702eeb5f9a0ed70526c22fdf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/413ecdee30d76eeed574bc9af547b539bc511863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/413ecdee30d76eeed574bc9af547b539bc511863", "html_url": "https://github.com/rust-lang/rust/commit/413ecdee30d76eeed574bc9af547b539bc511863", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/413ecdee30d76eeed574bc9af547b539bc511863/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd38e890ee5c9e35bbc8874edf8547515bf57b37", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd38e890ee5c9e35bbc8874edf8547515bf57b37", "html_url": "https://github.com/rust-lang/rust/commit/bd38e890ee5c9e35bbc8874edf8547515bf57b37"}, {"sha": "f6e06a8a365b118937079e3f9c4dfa8f221e7db5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e06a8a365b118937079e3f9c4dfa8f221e7db5", "html_url": "https://github.com/rust-lang/rust/commit/f6e06a8a365b118937079e3f9c4dfa8f221e7db5"}], "stats": {"total": 130, "additions": 79, "deletions": 51}, "files": [{"sha": "026442ba7ac48ccdfdabe58556e68c603c98f8bd", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/413ecdee30d76eeed574bc9af547b539bc511863/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413ecdee30d76eeed574bc9af547b539bc511863/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=413ecdee30d76eeed574bc9af547b539bc511863", "patch": "@@ -171,9 +171,11 @@ pub trait AstBuilder {\n                               span: Span,\n                               ident: ast::Ident,\n                               bm: ast::BindingMode) -> P<ast::Pat>;\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<P<ast::Pat>> ) -> P<ast::Pat>;\n-    fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: Vec<Spanned<ast::FieldPat>> ) -> P<ast::Pat>;\n+    fn pat_path(&self, span: Span, path: ast::Path) -> P<ast::Pat>;\n+    fn pat_tuple_struct(&self, span: Span, path: ast::Path,\n+                        subpats: Vec<P<ast::Pat>>) -> P<ast::Pat>;\n+    fn pat_struct(&self, span: Span, path: ast::Path,\n+                  field_pats: Vec<Spanned<ast::FieldPat>>) -> P<ast::Pat>;\n     fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat>;\n \n     fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat>;\n@@ -802,10 +804,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let binding_expr = self.expr_ident(sp, binding_variable);\n \n         // Ok(__try_var) pattern\n-        let ok_pat = self.pat_enum(sp, ok_path, vec!(binding_pat.clone()));\n+        let ok_pat = self.pat_tuple_struct(sp, ok_path, vec![binding_pat.clone()]);\n \n         // Err(__try_var)  (pattern and expression resp.)\n-        let err_pat = self.pat_enum(sp, err_path.clone(), vec!(binding_pat));\n+        let err_pat = self.pat_tuple_struct(sp, err_path.clone(), vec![binding_pat]);\n         let err_inner_expr = self.expr_call(sp, self.expr_path(err_path),\n                                             vec!(binding_expr.clone()));\n         // return Err(__try_var)\n@@ -842,18 +844,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let pat = PatKind::Ident(bm, Spanned{span: span, node: ident}, None);\n         self.pat(span, pat)\n     }\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n-        let pat = if subpats.is_empty() {\n-            PatKind::Path(None, path)\n-        } else {\n-            PatKind::TupleStruct(path, subpats, None)\n-        };\n-        self.pat(span, pat)\n+    fn pat_path(&self, span: Span, path: ast::Path) -> P<ast::Pat> {\n+        self.pat(span, PatKind::Path(None, path))\n     }\n-    fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: Vec<Spanned<ast::FieldPat>>) -> P<ast::Pat> {\n-        let pat = PatKind::Struct(path, field_pats, false);\n-        self.pat(span, pat)\n+    fn pat_tuple_struct(&self, span: Span, path: ast::Path,\n+                        subpats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n+        self.pat(span, PatKind::TupleStruct(path, subpats, None))\n+    }\n+    fn pat_struct(&self, span: Span, path: ast::Path,\n+                  field_pats: Vec<Spanned<ast::FieldPat>>) -> P<ast::Pat> {\n+        self.pat(span, PatKind::Struct(path, field_pats, false))\n     }\n     fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n         self.pat(span, PatKind::Tuple(pats, None))\n@@ -862,25 +862,25 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = self.std_path(&[\"option\", \"Option\", \"Some\"]);\n         let path = self.path_global(span, some);\n-        self.pat_enum(span, path, vec!(pat))\n+        self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n     fn pat_none(&self, span: Span) -> P<ast::Pat> {\n         let some = self.std_path(&[\"option\", \"Option\", \"None\"]);\n         let path = self.path_global(span, some);\n-        self.pat_enum(span, path, vec!())\n+        self.pat_path(span, path)\n     }\n \n     fn pat_ok(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = self.std_path(&[\"result\", \"Result\", \"Ok\"]);\n         let path = self.path_global(span, some);\n-        self.pat_enum(span, path, vec!(pat))\n+        self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n     fn pat_err(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = self.std_path(&[\"result\", \"Result\", \"Err\"]);\n         let path = self.path_global(span, some);\n-        self.pat_enum(span, path, vec!(pat))\n+        self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n     fn arm(&self, _span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm {"}, {"sha": "31194b04fa6e46c402c9a139ebdd2c6e637510a8", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/413ecdee30d76eeed574bc9af547b539bc511863/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413ecdee30d76eeed574bc9af547b539bc511863/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=413ecdee30d76eeed574bc9af547b539bc511863", "patch": "@@ -104,7 +104,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n         };\n \n         let eq_arm = cx.arm(span,\n-                            vec![cx.pat_enum(span, equals_path.clone(), vec![])],\n+                            vec![cx.pat_path(span, equals_path.clone())],\n                             old);\n         let neq_arm = cx.arm(span,\n                              vec![cx.pat_ident(span, test_id)],"}, {"sha": "9e9b2f020622ff560e294c76b5bc1584394f1804", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/413ecdee30d76eeed574bc9af547b539bc511863/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413ecdee30d76eeed574bc9af547b539bc511863/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=413ecdee30d76eeed574bc9af547b539bc511863", "patch": "@@ -165,7 +165,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<\n         };\n \n         let eq_arm = cx.arm(span,\n-                            vec![cx.pat_some(span, cx.pat_enum(span, ordering.clone(), vec![]))],\n+                            vec![cx.pat_some(span, cx.pat_path(span, ordering.clone()))],\n                             old);\n         let neq_arm = cx.arm(span,\n                              vec![cx.pat_ident(span, test_id)],"}, {"sha": "f395f7bd0c4c4e9b6ce1a2c75250204a591a1b0c", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/413ecdee30d76eeed574bc9af547b539bc511863/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413ecdee30d76eeed574bc9af547b539bc511863/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=413ecdee30d76eeed574bc9af547b539bc511863", "patch": "@@ -110,7 +110,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {\n             let nfields = match *summary {\n-                Unnamed(ref fields) => fields.len(),\n+                Unnamed(ref fields, _) => fields.len(),\n                 Named(ref fields) => fields.len(),\n             };\n             let read_struct_field = cx.ident_of(\"read_struct_field\");\n@@ -193,9 +193,9 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n     where F: FnMut(&mut ExtCtxt, Span, InternedString, usize) -> P<Expr>\n {\n     match *fields {\n-        Unnamed(ref fields) => {\n+        Unnamed(ref fields, is_tuple) => {\n             let path_expr = cx.expr_path(outer_pat_path);\n-            if fields.is_empty() {\n+            if !is_tuple {\n                 path_expr\n             } else {\n                 let fields = fields.iter()"}, {"sha": "449c1ff066b3b9d9b4574c110c232cb5d3237757", "filename": "src/libsyntax_ext/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/413ecdee30d76eeed574bc9af547b539bc511863/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413ecdee30d76eeed574bc9af547b539bc511863/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs?ref=413ecdee30d76eeed574bc9af547b539bc511863", "patch": "@@ -57,8 +57,8 @@ fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructur\n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {\n             match *summary {\n-                Unnamed(ref fields) => {\n-                    if fields.is_empty() {\n+                Unnamed(ref fields, is_tuple) => {\n+                    if !is_tuple {\n                         cx.expr_ident(trait_span, substr.type_ident)\n                     } else {\n                         let exprs = fields.iter().map(|sp| default_call(*sp)).collect();"}, {"sha": "03282653d362067fbd60724b11a5bd643f044de9", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/413ecdee30d76eeed574bc9af547b539bc511863/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413ecdee30d76eeed574bc9af547b539bc511863/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=413ecdee30d76eeed574bc9af547b539bc511863", "patch": "@@ -294,8 +294,8 @@ pub struct FieldInfo<'a> {\n \n /// Fields for a static method\n pub enum StaticFields {\n-    /// Tuple structs/enum variants like this.\n-    Unnamed(Vec<Span>),\n+    /// Tuple and unit structs/enum variants like this.\n+    Unnamed(Vec<Span>, bool /*is tuple*/),\n     /// Normal structs/struct variants.\n     Named(Vec<(Ident, Span)>),\n }\n@@ -1472,7 +1472,7 @@ impl<'a> TraitDef<'a> {\n             (_, false) => Named(named_idents),\n             // empty structs\n             _ if struct_def.is_struct() => Named(named_idents),\n-            _ => Unnamed(just_spans),\n+            _ => Unnamed(just_spans, struct_def.is_tuple()),\n         }\n     }\n \n@@ -1512,26 +1512,32 @@ impl<'a> TraitDef<'a> {\n         }\n \n         let subpats = self.create_subpatterns(cx, paths, mutbl);\n-        let pattern = if struct_def.is_struct() {\n-            let field_pats = subpats.into_iter()\n-                .zip(&ident_exprs)\n-                .map(|(pat, &(sp, ident, _, _))| {\n-                    if ident.is_none() {\n-                        cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n-                    }\n-                    codemap::Spanned {\n-                        span: pat.span,\n-                        node: ast::FieldPat {\n-                            ident: ident.unwrap(),\n-                            pat: pat,\n-                            is_shorthand: false,\n-                        },\n-                    }\n-                })\n-                .collect();\n-            cx.pat_struct(self.span, struct_path, field_pats)\n-        } else {\n-            cx.pat_enum(self.span, struct_path, subpats)\n+        let pattern = match *struct_def {\n+            VariantData::Struct(..) => {\n+                let field_pats = subpats.into_iter()\n+                    .zip(&ident_exprs)\n+                    .map(|(pat, &(sp, ident, _, _))| {\n+                        if ident.is_none() {\n+                            cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n+                        }\n+                        codemap::Spanned {\n+                            span: pat.span,\n+                            node: ast::FieldPat {\n+                                ident: ident.unwrap(),\n+                                pat: pat,\n+                                is_shorthand: false,\n+                            },\n+                        }\n+                    })\n+                    .collect();\n+                cx.pat_struct(self.span, struct_path, field_pats)\n+            }\n+            VariantData::Tuple(..) => {\n+                cx.pat_tuple_struct(self.span, struct_path, subpats)\n+            }\n+            VariantData::Unit(..) => {\n+                cx.pat_path(self.span, struct_path)\n+            }\n         };\n \n         (pattern, ident_exprs)"}, {"sha": "66ffff94333e9fe19ed869c3739e105f6852c96f", "filename": "src/test/run-pass-fulldeps/empty-struct-braces-derive.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/413ecdee30d76eeed574bc9af547b539bc511863/src%2Ftest%2Frun-pass-fulldeps%2Fempty-struct-braces-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413ecdee30d76eeed574bc9af547b539bc511863/src%2Ftest%2Frun-pass-fulldeps%2Fempty-struct-braces-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fempty-struct-braces-derive.rs?ref=413ecdee30d76eeed574bc9af547b539bc511863", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// `#[derive(Trait)]` works for empty structs/variants with braces\n+// `#[derive(Trait)]` works for empty structs/variants with braces or parens.\n \n+#![feature(relaxed_adts)]\n #![feature(rustc_private)]\n \n extern crate serialize as rustc_serialize;\n@@ -18,11 +19,16 @@ extern crate serialize as rustc_serialize;\n          Default, Debug, RustcEncodable, RustcDecodable)]\n struct S {}\n \n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash,\n+         Default, Debug, RustcEncodable, RustcDecodable)]\n+struct Z();\n+\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash,\n          Debug, RustcEncodable, RustcDecodable)]\n enum E {\n     V {},\n     U,\n+    W(),\n }\n \n fn main() {\n@@ -34,11 +40,27 @@ fn main() {\n     assert!(!(s < s1));\n     assert_eq!(format!(\"{:?}\", s), \"S\");\n \n+    let z = Z();\n+    let z1 = z;\n+    let z2 = z.clone();\n+    assert_eq!(z, z1);\n+    assert_eq!(z, z2);\n+    assert!(!(z < z1));\n+    assert_eq!(format!(\"{:?}\", z), \"Z\");\n+\n     let e = E::V {};\n     let e1 = e;\n     let e2 = e.clone();\n     assert_eq!(e, e1);\n     assert_eq!(e, e2);\n     assert!(!(e < e1));\n     assert_eq!(format!(\"{:?}\", e), \"V\");\n+\n+    let e = E::W();\n+    let e1 = e;\n+    let e2 = e.clone();\n+    assert_eq!(e, e1);\n+    assert_eq!(e, e2);\n+    assert!(!(e < e1));\n+    assert_eq!(format!(\"{:?}\", e), \"W\");\n }"}]}