{"sha": "059566b01960f3f630316cc50989e8c57e5e696e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1OTU2NmIwMTk2MGYzZjYzMDMxNmNjNTA5ODllOGM1N2U1ZTY5NmU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:36:32Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:36:32Z"}, "message": "rollup merge of #20434: steveklabnik/five_eye\n\nThis takes advantage of integer fallback to stop recomending `i` so much.", "tree": {"sha": "c473c2fe0ab9c9f1fc177278f4c69026fc38d638", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c473c2fe0ab9c9f1fc177278f4c69026fc38d638"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/059566b01960f3f630316cc50989e8c57e5e696e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/059566b01960f3f630316cc50989e8c57e5e696e", "html_url": "https://github.com/rust-lang/rust/commit/059566b01960f3f630316cc50989e8c57e5e696e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/059566b01960f3f630316cc50989e8c57e5e696e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d9923d0d5b1c3e9ad9756751cb54ec22492cff1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d9923d0d5b1c3e9ad9756751cb54ec22492cff1", "html_url": "https://github.com/rust-lang/rust/commit/3d9923d0d5b1c3e9ad9756751cb54ec22492cff1"}, {"sha": "f031671c6ea79391eeb3e1ad8f06fe0e436103fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f031671c6ea79391eeb3e1ad8f06fe0e436103fb", "html_url": "https://github.com/rust-lang/rust/commit/f031671c6ea79391eeb3e1ad8f06fe0e436103fb"}], "stats": {"total": 2686, "additions": 1392, "deletions": 1294}, "files": [{"sha": "080d34dbda5731e913ab0b768be0ad23823ab781", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -35,7 +35,7 @@\n //! use std::sync::Arc;\n //! use std::thread::Thread;\n //!\n-//! let five = Arc::new(5i);\n+//! let five = Arc::new(5);\n //!\n //! for i in range(0u, 10) {\n //!     let five = five.clone();\n@@ -52,7 +52,7 @@\n //! use std::sync::{Arc, Mutex};\n //! use std::thread::Thread;\n //!\n-//! let five = Arc::new(Mutex::new(5i));\n+//! let five = Arc::new(Mutex::new(5));\n //!\n //! for _ in range(0u, 10) {\n //!     let five = five.clone();\n@@ -154,7 +154,7 @@ impl<T> Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     /// ```\n     #[inline]\n     #[stable]\n@@ -176,7 +176,7 @@ impl<T> Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n@@ -220,7 +220,7 @@ impl<T> Clone for Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n     /// five.clone();\n     /// ```\n@@ -267,7 +267,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let mut five = Arc::new(5i);\n+    /// let mut five = Arc::new(5);\n     ///\n     /// let mut_five = five.make_unique();\n     /// ```\n@@ -303,14 +303,14 @@ impl<T: Sync + Send> Drop for Arc<T> {\n     /// use std::sync::Arc;\n     ///\n     /// {\n-    ///     let five = Arc::new(5i);\n+    ///     let five = Arc::new(5);\n     ///\n     ///     // stuff\n     ///\n     ///     drop(five); // explict drop\n     /// }\n     /// {\n-    ///     let five = Arc::new(5i);\n+    ///     let five = Arc::new(5);\n     ///\n     ///     // stuff\n     ///\n@@ -369,7 +369,7 @@ impl<T: Sync + Send> Weak<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n     /// let weak_five = five.downgrade();\n     ///\n@@ -405,7 +405,7 @@ impl<T: Sync + Send> Clone for Weak<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let weak_five = Arc::new(5i).downgrade();\n+    /// let weak_five = Arc::new(5).downgrade();\n     ///\n     /// weak_five.clone();\n     /// ```\n@@ -430,15 +430,15 @@ impl<T: Sync + Send> Drop for Weak<T> {\n     /// use std::sync::Arc;\n     ///\n     /// {\n-    ///     let five = Arc::new(5i);\n+    ///     let five = Arc::new(5);\n     ///     let weak_five = five.downgrade();\n     ///\n     ///     // stuff\n     ///\n     ///     drop(weak_five); // explict drop\n     /// }\n     /// {\n-    ///     let five = Arc::new(5i);\n+    ///     let five = Arc::new(5);\n     ///     let weak_five = five.downgrade();\n     ///\n     ///     // stuff\n@@ -472,9 +472,9 @@ impl<T: PartialEq> PartialEq for Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n-    /// five == Arc::new(5i);\n+    /// five == Arc::new(5);\n     /// ```\n     fn eq(&self, other: &Arc<T>) -> bool { *(*self) == *(*other) }\n \n@@ -487,9 +487,9 @@ impl<T: PartialEq> PartialEq for Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n-    /// five != Arc::new(5i);\n+    /// five != Arc::new(5);\n     /// ```\n     fn ne(&self, other: &Arc<T>) -> bool { *(*self) != *(*other) }\n }\n@@ -504,9 +504,9 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n-    /// five.partial_cmp(&Arc::new(5i));\n+    /// five.partial_cmp(&Arc::new(5));\n     /// ```\n     fn partial_cmp(&self, other: &Arc<T>) -> Option<Ordering> {\n         (**self).partial_cmp(&**other)\n@@ -521,9 +521,9 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n-    /// five < Arc::new(5i);\n+    /// five < Arc::new(5);\n     /// ```\n     fn lt(&self, other: &Arc<T>) -> bool { *(*self) < *(*other) }\n \n@@ -536,9 +536,9 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n-    /// five <= Arc::new(5i);\n+    /// five <= Arc::new(5);\n     /// ```\n     fn le(&self, other: &Arc<T>) -> bool { *(*self) <= *(*other) }\n \n@@ -551,9 +551,9 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n-    /// five > Arc::new(5i);\n+    /// five > Arc::new(5);\n     /// ```\n     fn gt(&self, other: &Arc<T>) -> bool { *(*self) > *(*other) }\n \n@@ -566,9 +566,9 @@ impl<T: PartialOrd> PartialOrd for Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let five = Arc::new(5i);\n+    /// let five = Arc::new(5);\n     ///\n-    /// five >= Arc::new(5i);\n+    /// five >= Arc::new(5);\n     /// ```\n     fn ge(&self, other: &Arc<T>) -> bool { *(*self) >= *(*other) }\n }"}, {"sha": "d9239e93a0740aa6ee6bc089a65f444c7c57098e", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -187,7 +187,7 @@ impl<T> Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     /// ```\n     #[stable]\n     pub fn new(value: T) -> Rc<T> {\n@@ -214,7 +214,7 @@ impl<T> Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n@@ -247,7 +247,7 @@ pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n /// use std::rc;\n /// use std::rc::Rc;\n ///\n-/// let five = Rc::new(5i);\n+/// let five = Rc::new(5);\n ///\n /// rc::is_unique(&five);\n /// ```\n@@ -329,7 +329,7 @@ impl<T: Clone> Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let mut five = Rc::new(5i);\n+    /// let mut five = Rc::new(5);\n     ///\n     /// let mut_five = five.make_unique();\n     /// ```\n@@ -378,14 +378,14 @@ impl<T> Drop for Rc<T> {\n     /// use std::rc::Rc;\n     ///\n     /// {\n-    ///     let five = Rc::new(5i);\n+    ///     let five = Rc::new(5);\n     ///\n     ///     // stuff\n     ///\n     ///     drop(five); // explict drop\n     /// }\n     /// {\n-    ///     let five = Rc::new(5i);\n+    ///     let five = Rc::new(5);\n     ///\n     ///     // stuff\n     ///\n@@ -424,7 +424,7 @@ impl<T> Clone for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n     /// five.clone();\n     /// ```\n@@ -465,9 +465,9 @@ impl<T: PartialEq> PartialEq for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n-    /// five == Rc::new(5i);\n+    /// five == Rc::new(5);\n     /// ```\n     #[inline(always)]\n     fn eq(&self, other: &Rc<T>) -> bool { **self == **other }\n@@ -481,9 +481,9 @@ impl<T: PartialEq> PartialEq for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n-    /// five != Rc::new(5i);\n+    /// five != Rc::new(5);\n     /// ```\n     #[inline(always)]\n     fn ne(&self, other: &Rc<T>) -> bool { **self != **other }\n@@ -503,9 +503,9 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n-    /// five.partial_cmp(&Rc::new(5i));\n+    /// five.partial_cmp(&Rc::new(5));\n     /// ```\n     #[inline(always)]\n     fn partial_cmp(&self, other: &Rc<T>) -> Option<Ordering> {\n@@ -521,9 +521,9 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n-    /// five < Rc::new(5i);\n+    /// five < Rc::new(5);\n     /// ```\n     #[inline(always)]\n     fn lt(&self, other: &Rc<T>) -> bool { **self < **other }\n@@ -537,9 +537,9 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n-    /// five <= Rc::new(5i);\n+    /// five <= Rc::new(5);\n     /// ```\n     #[inline(always)]\n     fn le(&self, other: &Rc<T>) -> bool { **self <= **other }\n@@ -553,9 +553,9 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n-    /// five > Rc::new(5i);\n+    /// five > Rc::new(5);\n     /// ```\n     #[inline(always)]\n     fn gt(&self, other: &Rc<T>) -> bool { **self > **other }\n@@ -569,9 +569,9 @@ impl<T: PartialOrd> PartialOrd for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n-    /// five >= Rc::new(5i);\n+    /// five >= Rc::new(5);\n     /// ```\n     #[inline(always)]\n     fn ge(&self, other: &Rc<T>) -> bool { **self >= **other }\n@@ -588,9 +588,9 @@ impl<T: Ord> Ord for Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n-    /// five.partial_cmp(&Rc::new(5i));\n+    /// five.partial_cmp(&Rc::new(5));\n     /// ```\n     #[inline]\n     fn cmp(&self, other: &Rc<T>) -> Ordering { (**self).cmp(&**other) }\n@@ -639,7 +639,7 @@ impl<T> Weak<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let five = Rc::new(5i);\n+    /// let five = Rc::new(5);\n     ///\n     /// let weak_five = five.downgrade();\n     ///\n@@ -668,15 +668,15 @@ impl<T> Drop for Weak<T> {\n     /// use std::rc::Rc;\n     ///\n     /// {\n-    ///     let five = Rc::new(5i);\n+    ///     let five = Rc::new(5);\n     ///     let weak_five = five.downgrade();\n     ///\n     ///     // stuff\n     ///\n     ///     drop(weak_five); // explict drop\n     /// }\n     /// {\n-    ///     let five = Rc::new(5i);\n+    ///     let five = Rc::new(5);\n     ///     let weak_five = five.downgrade();\n     ///\n     ///     // stuff\n@@ -710,7 +710,7 @@ impl<T> Clone for Weak<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let weak_five = Rc::new(5i).downgrade();\n+    /// let weak_five = Rc::new(5).downgrade();\n     ///\n     /// weak_five.clone();\n     /// ```"}, {"sha": "82002f16133ec9bf9742623a01c99c3a172b4965", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -211,7 +211,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from_vec(vec![9i, 1, 2, 7, 3, 2]);\n+    /// let heap = BinaryHeap::from_vec(vec![9, 1, 2, 7, 3, 2]);\n     /// ```\n     pub fn from_vec(vec: Vec<T>) -> BinaryHeap<T> {\n         let mut heap = BinaryHeap { data: vec };\n@@ -230,7 +230,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from_vec(vec![1i, 2, 3, 4]);\n+    /// let heap = BinaryHeap::from_vec(vec![1, 2, 3, 4]);\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order\n     /// for x in heap.iter() {\n@@ -250,7 +250,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from_vec(vec![1i, 2, 3, 4]);\n+    /// let heap = BinaryHeap::from_vec(vec![1, 2, 3, 4]);\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order\n     /// for x in heap.into_iter() {\n@@ -272,7 +272,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// let mut heap = BinaryHeap::new();\n     /// assert_eq!(heap.peek(), None);\n     ///\n-    /// heap.push(1i);\n+    /// heap.push(1);\n     /// heap.push(5);\n     /// heap.push(2);\n     /// assert_eq!(heap.peek(), Some(&5));\n@@ -355,7 +355,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::from_vec(vec![1i, 3]);\n+    /// let mut heap = BinaryHeap::from_vec(vec![1, 3]);\n     ///\n     /// assert_eq!(heap.pop(), Some(3));\n     /// assert_eq!(heap.pop(), Some(1));\n@@ -379,7 +379,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n-    /// heap.push(3i);\n+    /// heap.push(3);\n     /// heap.push(5);\n     /// heap.push(1);\n     ///\n@@ -401,7 +401,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n-    /// heap.push(1i);\n+    /// heap.push(1);\n     /// heap.push(5);\n     ///\n     /// assert_eq!(heap.push_pop(3), 5);\n@@ -433,7 +433,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n     ///\n-    /// assert_eq!(heap.replace(1i), None);\n+    /// assert_eq!(heap.replace(1), None);\n     /// assert_eq!(heap.replace(3), Some(1));\n     /// assert_eq!(heap.len(), 1);\n     /// assert_eq!(heap.peek(), Some(&3));\n@@ -456,7 +456,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from_vec(vec![1i, 2, 3, 4, 5, 6, 7]);\n+    /// let heap = BinaryHeap::from_vec(vec![1, 2, 3, 4, 5, 6, 7]);\n     /// let vec = heap.into_vec();\n     ///\n     /// // Will print in some order\n@@ -474,12 +474,12 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     /// use std::collections::BinaryHeap;\n     ///\n-    /// let mut heap = BinaryHeap::from_vec(vec![1i, 2, 4, 5, 7]);\n+    /// let mut heap = BinaryHeap::from_vec(vec![1, 2, 4, 5, 7]);\n     /// heap.push(6);\n     /// heap.push(3);\n     ///\n     /// let vec = heap.into_sorted_vec();\n-    /// assert_eq!(vec, vec![1i, 2, 3, 4, 5, 6, 7]);\n+    /// assert_eq!(vec, vec![1, 2, 3, 4, 5, 6, 7]);\n     /// ```\n     pub fn into_sorted_vec(mut self) -> Vec<T> {\n         let mut end = self.len();"}, {"sha": "80d01c07547d192b1691849e762854a04d4456ae", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -245,7 +245,7 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// let mut v = BTreeSet::new();\n     /// assert_eq!(v.len(), 0);\n-    /// v.insert(1i);\n+    /// v.insert(1);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable]\n@@ -260,7 +260,7 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// let mut v = BTreeSet::new();\n     /// assert!(v.is_empty());\n-    /// v.insert(1i);\n+    /// v.insert(1);\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable]\n@@ -274,7 +274,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// use std::collections::BTreeSet;\n     ///\n     /// let mut v = BTreeSet::new();\n-    /// v.insert(1i);\n+    /// v.insert(1);\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n@@ -294,7 +294,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let set: BTreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let set: BTreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n     /// assert_eq!(set.contains(&1), true);\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n@@ -311,7 +311,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let a: BTreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let a: BTreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n     /// let mut b: BTreeSet<int> = BTreeSet::new();\n     ///\n     /// assert_eq!(a.is_disjoint(&b), true);\n@@ -332,7 +332,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let sup: BTreeSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let sup: BTreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n     /// let mut set: BTreeSet<int> = BTreeSet::new();\n     ///\n     /// assert_eq!(set.is_subset(&sup), true);\n@@ -374,7 +374,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     /// use std::collections::BTreeSet;\n     ///\n-    /// let sub: BTreeSet<int> = [1i, 2].iter().map(|&x| x).collect();\n+    /// let sub: BTreeSet<int> = [1, 2].iter().map(|&x| x).collect();\n     /// let mut set: BTreeSet<int> = BTreeSet::new();\n     ///\n     /// assert_eq!(set.is_superset(&sub), false);\n@@ -401,8 +401,8 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// let mut set = BTreeSet::new();\n     ///\n-    /// assert_eq!(set.insert(2i), true);\n-    /// assert_eq!(set.insert(2i), false);\n+    /// assert_eq!(set.insert(2), true);\n+    /// assert_eq!(set.insert(2), false);\n     /// assert_eq!(set.len(), 1);\n     /// ```\n     #[stable]\n@@ -424,7 +424,7 @@ impl<T: Ord> BTreeSet<T> {\n     ///\n     /// let mut set = BTreeSet::new();\n     ///\n-    /// set.insert(2i);\n+    /// set.insert(2);\n     /// assert_eq!(set.remove(&2), true);\n     /// assert_eq!(set.remove(&2), false);\n     /// ```"}, {"sha": "5aec9973c811224338b236d7b41fb86d48c4ea63", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -230,9 +230,9 @@ impl<T> DList<T> {\n     ///\n     /// let mut a = DList::new();\n     /// let mut b = DList::new();\n-    /// a.push_back(1i);\n+    /// a.push_back(1);\n     /// a.push_back(2);\n-    /// b.push_back(3i);\n+    /// b.push_back(3);\n     /// b.push_back(4);\n     ///\n     /// a.append(b);\n@@ -375,7 +375,7 @@ impl<T> DList<T> {\n     /// use std::collections::DList;\n     ///\n     /// let mut d = DList::new();\n-    /// d.push_back(1i);\n+    /// d.push_back(1);\n     /// d.push_back(3);\n     /// assert_eq!(3, *d.back().unwrap());\n     /// ```\n@@ -394,7 +394,7 @@ impl<T> DList<T> {\n     ///\n     /// let mut d = DList::new();\n     /// assert_eq!(d.pop_back(), None);\n-    /// d.push_back(1i);\n+    /// d.push_back(1);\n     /// d.push_back(3);\n     /// assert_eq!(d.pop_back(), Some(3));\n     /// ```\n@@ -551,7 +551,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// }\n     /// {\n     ///     let vec: Vec<int> = list.into_iter().collect();\n-    ///     assert_eq!(vec, vec![1i, 2, 3, 4]);\n+    ///     assert_eq!(vec, vec![1, 2, 3, 4]);\n     /// }\n     /// ```\n     #[inline]"}, {"sha": "8a83bf25e9b098404644bd38aa9ec6af3df20caf", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -184,7 +184,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(3i);\n+    /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n     /// assert_eq!(buf.get(1).unwrap(), &4);\n@@ -207,7 +207,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(3i);\n+    /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n     /// match buf.get_mut(1) {\n@@ -241,7 +241,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(3i);\n+    /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// buf.push_back(5);\n     /// buf.swap(0, 2);\n@@ -493,7 +493,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(5i);\n+    /// buf.push_back(5);\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// let b: &[_] = &[&5, &3, &4];\n@@ -516,7 +516,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(5i);\n+    /// buf.push_back(5);\n     /// buf.push_back(3);\n     /// buf.push_back(4);\n     /// for num in buf.iter_mut() {\n@@ -595,7 +595,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// let mut v = RingBuf::new();\n     /// assert_eq!(v.len(), 0);\n-    /// v.push_back(1i);\n+    /// v.push_back(1);\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable]\n@@ -610,7 +610,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// let mut v = RingBuf::new();\n     /// assert!(v.is_empty());\n-    /// v.push_front(1i);\n+    /// v.push_front(1);\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable]\n@@ -625,7 +625,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut v = RingBuf::new();\n-    /// v.push_back(1i);\n+    /// v.push_back(1);\n     /// assert_eq!(v.drain().next(), Some(1));\n     /// assert!(v.is_empty());\n     /// ```\n@@ -645,7 +645,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut v = RingBuf::new();\n-    /// v.push_back(1i);\n+    /// v.push_back(1);\n     /// v.clear();\n     /// assert!(v.is_empty());\n     /// ```\n@@ -666,9 +666,9 @@ impl<T> RingBuf<T> {\n     /// let mut d = RingBuf::new();\n     /// assert_eq!(d.front(), None);\n     ///\n-    /// d.push_back(1i);\n-    /// d.push_back(2i);\n-    /// assert_eq!(d.front(), Some(&1i));\n+    /// d.push_back(1);\n+    /// d.push_back(2);\n+    /// assert_eq!(d.front(), Some(&1));\n     /// ```\n     #[stable]\n     pub fn front(&self) -> Option<&T> {\n@@ -686,13 +686,13 @@ impl<T> RingBuf<T> {\n     /// let mut d = RingBuf::new();\n     /// assert_eq!(d.front_mut(), None);\n     ///\n-    /// d.push_back(1i);\n-    /// d.push_back(2i);\n+    /// d.push_back(1);\n+    /// d.push_back(2);\n     /// match d.front_mut() {\n-    ///     Some(x) => *x = 9i,\n+    ///     Some(x) => *x = 9,\n     ///     None => (),\n     /// }\n-    /// assert_eq!(d.front(), Some(&9i));\n+    /// assert_eq!(d.front(), Some(&9));\n     /// ```\n     #[stable]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n@@ -710,9 +710,9 @@ impl<T> RingBuf<T> {\n     /// let mut d = RingBuf::new();\n     /// assert_eq!(d.back(), None);\n     ///\n-    /// d.push_back(1i);\n-    /// d.push_back(2i);\n-    /// assert_eq!(d.back(), Some(&2i));\n+    /// d.push_back(1);\n+    /// d.push_back(2);\n+    /// assert_eq!(d.back(), Some(&2));\n     /// ```\n     #[stable]\n     pub fn back(&self) -> Option<&T> {\n@@ -730,13 +730,13 @@ impl<T> RingBuf<T> {\n     /// let mut d = RingBuf::new();\n     /// assert_eq!(d.back(), None);\n     ///\n-    /// d.push_back(1i);\n-    /// d.push_back(2i);\n+    /// d.push_back(1);\n+    /// d.push_back(2);\n     /// match d.back_mut() {\n-    ///     Some(x) => *x = 9i,\n+    ///     Some(x) => *x = 9,\n     ///     None => (),\n     /// }\n-    /// assert_eq!(d.back(), Some(&9i));\n+    /// assert_eq!(d.back(), Some(&9));\n     /// ```\n     #[stable]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n@@ -753,11 +753,11 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut d = RingBuf::new();\n-    /// d.push_back(1i);\n-    /// d.push_back(2i);\n+    /// d.push_back(1);\n+    /// d.push_back(2);\n     ///\n-    /// assert_eq!(d.pop_front(), Some(1i));\n-    /// assert_eq!(d.pop_front(), Some(2i));\n+    /// assert_eq!(d.pop_front(), Some(1));\n+    /// assert_eq!(d.pop_front(), Some(2));\n     /// assert_eq!(d.pop_front(), None);\n     /// ```\n     #[stable]\n@@ -779,9 +779,9 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut d = RingBuf::new();\n-    /// d.push_front(1i);\n-    /// d.push_front(2i);\n-    /// assert_eq!(d.front(), Some(&2i));\n+    /// d.push_front(1);\n+    /// d.push_front(2);\n+    /// assert_eq!(d.front(), Some(&2));\n     /// ```\n     #[stable]\n     pub fn push_front(&mut self, t: T) {\n@@ -803,7 +803,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(1i);\n+    /// buf.push_back(1);\n     /// buf.push_back(3);\n     /// assert_eq!(3, *buf.back().unwrap());\n     /// ```\n@@ -829,7 +829,7 @@ impl<T> RingBuf<T> {\n     ///\n     /// let mut buf = RingBuf::new();\n     /// assert_eq!(buf.pop_back(), None);\n-    /// buf.push_back(1i);\n+    /// buf.push_back(1);\n     /// buf.push_back(3);\n     /// assert_eq!(buf.pop_back(), Some(3));\n     /// ```\n@@ -926,7 +926,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(10i);\n+    /// buf.push_back(10);\n     /// buf.push_back(12);\n     /// buf.insert(1,11);\n     /// assert_eq!(Some(&11), buf.get(1));\n@@ -1128,9 +1128,9 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n-    /// buf.push_back(5i);\n-    /// buf.push_back(10i);\n-    /// buf.push_back(12i);\n+    /// buf.push_back(5);\n+    /// buf.push_back(10);\n+    /// buf.push_back(12);\n     /// buf.push_back(15);\n     /// buf.remove(2);\n     /// assert_eq!(Some(&15), buf.get(2));"}, {"sha": "8050c44f54281b763a8b065d5816e288108653fc", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 464, "deletions": 336, "changes": 800, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -15,7 +15,7 @@\n //!\n //! ```rust\n //! // slicing a Vec\n-//! let vec = vec!(1i, 2, 3);\n+//! let vec = vec!(1, 2, 3);\n //! let int_slice = vec.as_slice();\n //! // coercing an array to a slice\n //! let str_slice: &[&str] = &[\"one\", \"two\", \"three\"];\n@@ -26,7 +26,7 @@\n //! block of memory that a mutable slice points to:\n //!\n //! ```rust\n-//! let x: &mut[int] = &mut [1i, 2, 3];\n+//! let x: &mut[int] = &mut [1, 2, 3];\n //! x[1] = 7;\n //! assert_eq!(x[0], 1);\n //! assert_eq!(x[1], 7);\n@@ -54,9 +54,9 @@\n //! ```rust\n //! #![feature(slicing_syntax)]\n //! fn main() {\n-//!     let numbers = [0i, 1i, 2i];\n+//!     let numbers = [0, 1, 2];\n //!     let last_numbers = numbers[1..3];\n-//!     // last_numbers is now &[1i, 2i]\n+//!     // last_numbers is now &[1, 2]\n //! }\n //! ```\n //!\n@@ -76,7 +76,7 @@\n //! type of the slice is `int`, the element type of the iterator is `&int`.\n //!\n //! ```rust\n-//! let numbers = [0i, 1i, 2i];\n+//! let numbers = [0, 1, 2];\n //! for &x in numbers.iter() {\n //!     println!(\"{} is a number!\", x);\n //! }\n@@ -89,40 +89,40 @@\n \n use alloc::boxed::Box;\n use core::borrow::{BorrowFrom, BorrowFromMut, ToOwned};\n-use core::clone::Clone;\n-use core::cmp::Ordering::{self, Greater, Less};\n-use core::cmp::{self, Ord, PartialEq};\n-use core::iter::{Iterator, IteratorExt};\n-use core::iter::{range, range_step, MultiplicativeIterator};\n+use core::cmp;\n+use core::iter::{range_step, MultiplicativeIterator};\n use core::kinds::Sized;\n use core::mem::size_of;\n use core::mem;\n-use core::ops::{FnMut, SliceMut};\n-use core::option::Option::{self, Some, None};\n-use core::ptr::PtrExt;\n+use core::ops::{FnMut,SliceMut};\n+use core::prelude::{Clone, Greater, Iterator, IteratorExt, Less, None, Option};\n+use core::prelude::{Ord, Ordering, PtrExt, Some, range, IteratorCloneExt, Result};\n use core::ptr;\n-use core::result::Result;\n use core::slice as core_slice;\n use self::Direction::*;\n \n use vec::Vec;\n \n pub use core::slice::{Chunks, AsSlice, Windows};\n-pub use core::slice::{Iter, IterMut};\n+pub use core::slice::{Iter, IterMut, PartialEqSliceExt};\n pub use core::slice::{IntSliceExt, SplitMut, ChunksMut, Split};\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n pub use core::slice::{from_raw_buf, from_raw_mut_buf};\n \n+#[deprecated = \"use Iter instead\"]\n+pub type Items<'a, T:'a> = Iter<'a, T>;\n+\n+#[deprecated = \"use IterMut instead\"]\n+pub type MutItems<'a, T:'a> = IterMut<'a, T>;\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Allocating extension methods for slices.\n #[unstable = \"needs associated types, may merge with other traits\"]\n-pub trait SliceExt for Sized? {\n-    type Item;\n-\n+pub trait SliceExt<T> for Sized? {\n     /// Sorts the slice, in place, using `compare` to compare\n     /// elements.\n     ///\n@@ -132,7 +132,7 @@ pub trait SliceExt for Sized? {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// let mut v = [5i, 4, 1, 3, 2];\n+    /// let mut v = [5, 4, 1, 3, 2];\n     /// v.sort_by(|a, b| a.cmp(b));\n     /// assert!(v == [1, 2, 3, 4, 5]);\n     ///\n@@ -141,7 +141,7 @@ pub trait SliceExt for Sized? {\n     /// assert!(v == [5, 4, 3, 2, 1]);\n     /// ```\n     #[stable]\n-    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&Self::Item, &Self::Item) -> Ordering;\n+    fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering;\n \n     /// Consumes `src` and moves as many elements as it can into `self`\n     /// from the range [start,end).\n@@ -158,14 +158,14 @@ pub trait SliceExt for Sized? {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// let mut a = [1i, 2, 3, 4, 5];\n-    /// let b = vec![6i, 7, 8];\n+    /// let mut a = [1, 2, 3, 4, 5];\n+    /// let b = vec![6, 7, 8];\n     /// let num_moved = a.move_from(b, 0, 3);\n     /// assert_eq!(num_moved, 3);\n-    /// assert!(a == [6i, 7, 8, 4, 5]);\n+    /// assert!(a == [6, 7, 8, 4, 5]);\n     /// ```\n     #[experimental = \"uncertain about this API approach\"]\n-    fn move_from(&mut self, src: Vec<Self::Item>, start: uint, end: uint) -> uint;\n+    fn move_from(&mut self, src: Vec<T>, start: uint, end: uint) -> uint;\n \n     /// Returns a subslice spanning the interval [`start`, `end`).\n     ///\n@@ -174,23 +174,23 @@ pub trait SliceExt for Sized? {\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice(&self, start: uint, end: uint) -> &[Self::Item];\n+    fn slice(&self, start: uint, end: uint) -> &[T];\n \n     /// Returns a subslice from `start` to the end of the slice.\n     ///\n     /// Panics when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_from(&self, start: uint) -> &[Self::Item];\n+    fn slice_from(&self, start: uint) -> &[T];\n \n     /// Returns a subslice from the start of the slice to `end`.\n     ///\n     /// Panics when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_to(&self, end: uint) -> &[Self::Item];\n+    fn slice_to(&self, end: uint) -> &[T];\n \n     /// Divides one slice into two at an index.\n     ///\n@@ -200,32 +200,32 @@ pub trait SliceExt for Sized? {\n     ///\n     /// Panics if `mid > len`.\n     #[stable]\n-    fn split_at(&self, mid: uint) -> (&[Self::Item], &[Self::Item]);\n+    fn split_at(&self, mid: uint) -> (&[T], &[T]);\n \n     /// Returns an iterator over the slice\n     #[stable]\n-    fn iter(&self) -> Iter<Self::Item>;\n+    fn iter(&self) -> Iter<T>;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`.  The matched element is not contained in the subslices.\n     #[stable]\n-    fn split<F>(&self, pred: F) -> Split<Self::Item, F>\n-                where F: FnMut(&Self::Item) -> bool;\n+    fn split<F>(&self, pred: F) -> Split<T, F>\n+                where F: FnMut(&T) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n     #[stable]\n-    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<Self::Item, F>\n-                 where F: FnMut(&Self::Item) -> bool;\n+    fn splitn<F>(&self, n: uint, pred: F) -> SplitN<T, F>\n+                 where F: FnMut(&T) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     #[stable]\n-    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<Self::Item, F>\n-                  where F: FnMut(&Self::Item) -> bool;\n+    fn rsplitn<F>(&self, n: uint, pred: F) -> RSplitN<T, F>\n+                  where F: FnMut(&T) -> bool;\n \n     /// Returns an iterator over all contiguous windows of length\n     /// `size`. The windows overlap. If the slice is shorter than\n@@ -241,13 +241,13 @@ pub trait SliceExt for Sized? {\n     /// `[3,4]`):\n     ///\n     /// ```rust\n-    /// let v = &[1i, 2, 3, 4];\n+    /// let v = &[1, 2, 3, 4];\n     /// for win in v.windows(2) {\n     ///     println!(\"{}\", win);\n     /// }\n     /// ```\n     #[stable]\n-    fn windows(&self, size: uint) -> Windows<Self::Item>;\n+    fn windows(&self, size: uint) -> Windows<T>;\n \n     /// Returns an iterator over `size` elements of the slice at a\n     /// time. The chunks do not overlap. If `size` does not divide the\n@@ -264,39 +264,49 @@ pub trait SliceExt for Sized? {\n     /// `[3,4]`, `[5]`):\n     ///\n     /// ```rust\n-    /// let v = &[1i, 2, 3, 4, 5];\n+    /// let v = &[1, 2, 3, 4, 5];\n     /// for win in v.chunks(2) {\n     ///     println!(\"{}\", win);\n     /// }\n     /// ```\n     #[stable]\n-    fn chunks(&self, size: uint) -> Chunks<Self::Item>;\n+    fn chunks(&self, size: uint) -> Chunks<T>;\n \n     /// Returns the element of a slice at the given index, or `None` if the\n     /// index is out of bounds.\n     #[stable]\n-    fn get(&self, index: uint) -> Option<&Self::Item>;\n+    fn get(&self, index: uint) -> Option<&T>;\n \n     /// Returns the first element of a slice, or `None` if it is empty.\n     #[stable]\n-    fn first(&self) -> Option<&Self::Item>;\n+    fn first(&self) -> Option<&T>;\n+\n+    /// Deprecated: renamed to `first`.\n+    #[deprecated = \"renamed to `first`\"]\n+    fn head(&self) -> Option<&T> { self.first() }\n \n     /// Returns all but the first element of a slice.\n     #[experimental = \"likely to be renamed\"]\n-    fn tail(&self) -> &[Self::Item];\n+    fn tail(&self) -> &[T];\n \n     /// Returns all but the last element of a slice.\n     #[experimental = \"likely to be renamed\"]\n-    fn init(&self) -> &[Self::Item];\n+    fn init(&self) -> &[T];\n \n     /// Returns the last element of a slice, or `None` if it is empty.\n     #[stable]\n-    fn last(&self) -> Option<&Self::Item>;\n+    fn last(&self) -> Option<&T>;\n \n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n     #[stable]\n-    unsafe fn get_unchecked(&self, index: uint) -> &Self::Item;\n+    unsafe fn get_unchecked(&self, index: uint) -> &T;\n+\n+    /// Deprecated: renamed to `get_unchecked`.\n+    #[deprecated = \"renamed to get_unchecked\"]\n+    unsafe fn unsafe_get(&self, index: uint) -> &T {\n+        self.get_unchecked(index)\n+    }\n \n     /// Returns an unsafe pointer to the slice's buffer\n     ///\n@@ -306,7 +316,7 @@ pub trait SliceExt for Sized? {\n     /// Modifying the slice may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n     #[stable]\n-    fn as_ptr(&self) -> *const Self::Item;\n+    fn as_ptr(&self) -> *const T;\n \n     /// Binary search a sorted slice with a comparator function.\n     ///\n@@ -327,7 +337,7 @@ pub trait SliceExt for Sized? {\n     /// found; the fourth could match any position in `[1,4]`.\n     ///\n     /// ```rust\n-    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n     /// let s = s.as_slice();\n     ///\n     /// let seek = 13;\n@@ -342,14 +352,14 @@ pub trait SliceExt for Sized? {\n     /// ```\n     #[stable]\n     fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n-        F: FnMut(&Self::Item) -> Ordering;\n+        F: FnMut(&T) -> Ordering;\n \n     /// Return the number of elements in the slice\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// let a = [1i, 2, 3];\n+    /// let a = [1, 2, 3];\n     /// assert_eq!(a.len(), 3);\n     /// ```\n     #[stable]\n@@ -360,7 +370,7 @@ pub trait SliceExt for Sized? {\n     /// # Example\n     ///\n     /// ```\n-    /// let a = [1i, 2, 3];\n+    /// let a = [1, 2, 3];\n     /// assert!(!a.is_empty());\n     /// ```\n     #[inline]\n@@ -369,12 +379,12 @@ pub trait SliceExt for Sized? {\n     /// Returns a mutable reference to the element at the given index,\n     /// or `None` if the index is out of bounds\n     #[stable]\n-    fn get_mut(&mut self, index: uint) -> Option<&mut Self::Item>;\n+    fn get_mut(&mut self, index: uint) -> Option<&mut T>;\n \n     /// Work with `self` as a mut slice.\n     /// Primarily intended for getting a &mut [T] from a [T; N].\n     #[stable]\n-    fn as_mut_slice(&mut self) -> &mut [Self::Item];\n+    fn as_mut_slice(&mut self) -> &mut [T];\n \n     /// Returns a mutable subslice spanning the interval [`start`, `end`).\n     ///\n@@ -383,64 +393,70 @@ pub trait SliceExt for Sized? {\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [Self::Item];\n+    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T];\n \n     /// Returns a mutable subslice from `start` to the end of the slice.\n     ///\n     /// Panics when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_from_mut(&mut self, start: uint) -> &mut [Self::Item];\n+    fn slice_from_mut(&mut self, start: uint) -> &mut [T];\n \n     /// Returns a mutable subslice from the start of the slice to `end`.\n     ///\n     /// Panics when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n     #[experimental = \"will be replaced by slice syntax\"]\n-    fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];\n+    fn slice_to_mut(&mut self, end: uint) -> &mut [T];\n \n     /// Returns an iterator that allows modifying each value\n     #[stable]\n-    fn iter_mut(&mut self) -> IterMut<Self::Item>;\n+    fn iter_mut(&mut self) -> IterMut<T>;\n \n     /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n     #[stable]\n-    fn first_mut(&mut self) -> Option<&mut Self::Item>;\n+    fn first_mut(&mut self) -> Option<&mut T>;\n+\n+    /// Depreated: renamed to `first_mut`.\n+    #[deprecated = \"renamed to first_mut\"]\n+    fn head_mut(&mut self) -> Option<&mut T> {\n+        self.first_mut()\n+    }\n \n     /// Returns all but the first element of a mutable slice\n     #[experimental = \"likely to be renamed or removed\"]\n-    fn tail_mut(&mut self) -> &mut [Self::Item];\n+    fn tail_mut(&mut self) -> &mut [T];\n \n     /// Returns all but the last element of a mutable slice\n     #[experimental = \"likely to be renamed or removed\"]\n-    fn init_mut(&mut self) -> &mut [Self::Item];\n+    fn init_mut(&mut self) -> &mut [T];\n \n     /// Returns a mutable pointer to the last item in the slice.\n     #[stable]\n-    fn last_mut(&mut self) -> Option<&mut Self::Item>;\n+    fn last_mut(&mut self) -> Option<&mut T>;\n \n     /// Returns an iterator over mutable subslices separated by elements that\n     /// match `pred`.  The matched element is not contained in the subslices.\n     #[stable]\n-    fn split_mut<F>(&mut self, pred: F) -> SplitMut<Self::Item, F>\n-                    where F: FnMut(&Self::Item) -> bool;\n+    fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n+                    where F: FnMut(&T) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, limited to splitting at most `n` times.  The matched element is\n     /// not contained in the subslices.\n     #[stable]\n-    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<Self::Item, F>\n-                     where F: FnMut(&Self::Item) -> bool;\n+    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitNMut<T, F>\n+                     where F: FnMut(&T) -> bool;\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to splitting at most `n` times. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     #[stable]\n-    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<Self::Item, F>\n-                      where F: FnMut(&Self::Item) -> bool;\n+    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> RSplitNMut<T, F>\n+                      where F: FnMut(&T) -> bool;\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n     /// The chunks are mutable and do not overlap. If `chunk_size` does\n@@ -451,7 +467,7 @@ pub trait SliceExt for Sized? {\n     ///\n     /// Panics if `chunk_size` is 0.\n     #[stable]\n-    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<Self::Item>;\n+    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<T>;\n \n     /// Swaps two elements in a slice.\n     ///\n@@ -487,45 +503,51 @@ pub trait SliceExt for Sized? {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = [1i, 2, 3, 4, 5, 6];\n+    /// let mut v = [1, 2, 3, 4, 5, 6];\n     ///\n     /// // scoped to restrict the lifetime of the borrows\n     /// {\n     ///    let (left, right) = v.split_at_mut(0);\n     ///    assert!(left == []);\n-    ///    assert!(right == [1i, 2, 3, 4, 5, 6]);\n+    ///    assert!(right == [1, 2, 3, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n     ///     let (left, right) = v.split_at_mut(2);\n-    ///     assert!(left == [1i, 2]);\n-    ///     assert!(right == [3i, 4, 5, 6]);\n+    ///     assert!(left == [1, 2]);\n+    ///     assert!(right == [3, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n     ///     let (left, right) = v.split_at_mut(6);\n-    ///     assert!(left == [1i, 2, 3, 4, 5, 6]);\n+    ///     assert!(left == [1, 2, 3, 4, 5, 6]);\n     ///     assert!(right == []);\n     /// }\n     /// ```\n     #[stable]\n-    fn split_at_mut(&mut self, mid: uint) -> (&mut [Self::Item], &mut [Self::Item]);\n+    fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]);\n \n     /// Reverse the order of elements in a slice, in place.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = [1i, 2, 3];\n+    /// let mut v = [1, 2, 3];\n     /// v.reverse();\n-    /// assert!(v == [3i, 2, 1]);\n+    /// assert!(v == [3, 2, 1]);\n     /// ```\n     #[stable]\n     fn reverse(&mut self);\n \n     /// Returns an unsafe mutable pointer to the element in index\n     #[stable]\n-    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut Self::Item;\n+    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut T;\n+\n+    /// Deprecated: renamed to `get_unchecked_mut`.\n+    #[deprecated = \"renamed to get_unchecked_mut\"]\n+    unsafe fn unchecked_mut(&mut self, index: uint) -> &mut T {\n+        self.get_unchecked_mut(index)\n+    }\n \n     /// Return an unsafe mutable pointer to the slice's buffer.\n     ///\n@@ -536,173 +558,11 @@ pub trait SliceExt for Sized? {\n     /// would also make any pointers to it invalid.\n     #[inline]\n     #[stable]\n-    fn as_mut_ptr(&mut self) -> *mut Self::Item;\n-\n-    /// Copies `self` into a new `Vec`.\n-    #[stable]\n-    fn to_vec(&self) -> Vec<Self::Item> where Self::Item: Clone;\n-\n-    /// Creates an iterator that yields every possible permutation of the\n-    /// vector in succession.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let v = [1i, 2, 3];\n-    /// let mut perms = v.permutations();\n-    ///\n-    /// for p in perms {\n-    ///   println!(\"{}\", p);\n-    /// }\n-    /// ```\n-    ///\n-    /// Iterating through permutations one by one.\n-    ///\n-    /// ```rust\n-    /// let v = [1i, 2, 3];\n-    /// let mut perms = v.permutations();\n-    ///\n-    /// assert_eq!(Some(vec![1i, 2, 3]), perms.next());\n-    /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n-    /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n-    /// ```\n-    #[unstable]\n-    fn permutations(&self) -> Permutations<Self::Item> where Self::Item: Clone;\n-\n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut dst = [0i, 0, 0];\n-    /// let src = [1i, 2];\n-    ///\n-    /// assert!(dst.clone_from_slice(&src) == 2);\n-    /// assert!(dst == [1, 2, 0]);\n-    ///\n-    /// let src2 = [3i, 4, 5, 6];\n-    /// assert!(dst.clone_from_slice(&src2) == 3);\n-    /// assert!(dst == [3i, 4, 5]);\n-    /// ```\n-    #[experimental]\n-    fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n-\n-    /// Sorts the slice, in place.\n-    ///\n-    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let mut v = [-5i, 4, 1, -3, 2];\n-    ///\n-    /// v.sort();\n-    /// assert!(v == [-5i, -3, 1, 2, 4]);\n-    /// ```\n-    #[stable]\n-    fn sort(&mut self) where Self::Item: Ord;\n-\n-    /// Binary search a sorted slice for a given element.\n-    ///\n-    /// If the value is found then `Ok` is returned, containing the\n-    /// index of the matching element; if the value is not found then\n-    /// `Err` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n-    ///\n-    /// # Example\n-    ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n-    ///\n-    /// ```rust\n-    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    /// let s = s.as_slice();\n-    ///\n-    /// assert_eq!(s.binary_search(&13),  Ok(9));\n-    /// assert_eq!(s.binary_search(&4),   Err(7));\n-    /// assert_eq!(s.binary_search(&100), Err(13));\n-    /// let r = s.binary_search(&1);\n-    /// assert!(match r { Ok(1...4) => true, _ => false, });\n-    /// ```\n-    #[stable]\n-    fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;\n-\n-    /// Deprecated: use `binary_search` instead.\n-    #[deprecated = \"use binary_search instead\"]\n-    fn binary_search_elem(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord {\n-        self.binary_search(x)\n-    }\n-\n-    /// Mutates the slice to the next lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// last-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [0i, 1, 2];\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [1i, 0, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[unstable = \"uncertain if this merits inclusion in std\"]\n-    fn next_permutation(&mut self) -> bool where Self::Item: Ord;\n-\n-    /// Mutates the slice to the previous lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// first-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [1i, 0, 2];\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 1, 2];\n-    /// assert!(v == b);\n-    /// ```\n-    #[unstable = \"uncertain if this merits inclusion in std\"]\n-    fn prev_permutation(&mut self) -> bool where Self::Item: Ord;\n-\n-    /// Find the first index containing a matching value.\n-    #[experimental]\n-    fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n-\n-    /// Find the last index containing a matching value.\n-    #[experimental]\n-    fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n-\n-    /// Return true if the slice contains an element with the given value.\n-    #[stable]\n-    fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n-\n-    /// Returns true if `needle` is a prefix of the slice.\n-    #[stable]\n-    fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n-\n-    /// Returns true if `needle` is a suffix of the slice.\n-    #[stable]\n-    fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n-\n-    /// Convert `self` into a vector without clones or allocation.\n-    #[experimental]\n-    fn into_vec(self: Box<Self>) -> Vec<Self::Item>;\n+    fn as_mut_ptr(&mut self) -> *mut T;\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<T> SliceExt for [T] {\n-    type Item = T;\n-\n+impl<T> SliceExt<T> for [T] {\n     #[inline]\n     fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n         merge_sort(self, compare)\n@@ -917,87 +777,250 @@ impl<T> SliceExt for [T] {\n     fn as_mut_ptr(&mut self) -> *mut T {\n         core_slice::SliceExt::as_mut_ptr(self)\n     }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Extension traits for slices over specifc kinds of data\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Extension methods for boxed slices.\n+#[experimental = \"likely to merge into SliceExt if it survives\"]\n+pub trait BoxedSliceExt<T> {\n+    /// Convert `self` into a vector without clones or allocation.\n+    #[experimental]\n+    fn into_vec(self) -> Vec<T>;\n+}\n+\n+#[experimental = \"trait is experimental\"]\n+impl<T> BoxedSliceExt<T> for Box<[T]> {\n+    fn into_vec(mut self) -> Vec<T> {\n+        unsafe {\n+            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n+            mem::forget(self);\n+            xs\n+        }\n+    }\n+}\n+\n+/// Allocating extension methods for slices containing `Clone` elements.\n+#[unstable = \"likely to be merged into SliceExt\"]\n+pub trait CloneSliceExt<T> for Sized? {\n+    /// Copies `self` into a new `Vec`.\n+    #[stable]\n+    fn to_vec(&self) -> Vec<T>;\n+\n+    /// Deprecated: use `iter().cloned().partition(f)` instead.\n+    #[deprecated = \"use iter().cloned().partition(f) instead\"]\n+    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool;\n \n+    /// Creates an iterator that yields every possible permutation of the\n+    /// vector in succession.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let v = [1, 2, 3];\n+    /// let mut perms = v.permutations();\n+    ///\n+    /// for p in perms {\n+    ///   println!(\"{}\", p);\n+    /// }\n+    /// ```\n+    ///\n+    /// Iterating through permutations one by one.\n+    ///\n+    /// ```rust\n+    /// let v = [1, 2, 3];\n+    /// let mut perms = v.permutations();\n+    ///\n+    /// assert_eq!(Some(vec![1, 2, 3]), perms.next());\n+    /// assert_eq!(Some(vec![1, 3, 2]), perms.next());\n+    /// assert_eq!(Some(vec![3, 1, 2]), perms.next());\n+    /// ```\n+    #[unstable]\n+    fn permutations(&self) -> Permutations<T>;\n+\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut dst = [0, 0, 0];\n+    /// let src = [1, 2];\n+    ///\n+    /// assert!(dst.clone_from_slice(&src) == 2);\n+    /// assert!(dst == [1, 2, 0]);\n+    ///\n+    /// let src2 = [3, 4, 5, 6];\n+    /// assert!(dst.clone_from_slice(&src2) == 3);\n+    /// assert!(dst == [3, 4, 5]);\n+    /// ```\n+    #[experimental]\n+    fn clone_from_slice(&mut self, &[T]) -> uint;\n+}\n+\n+\n+#[unstable = \"trait is unstable\"]\n+impl<T: Clone> CloneSliceExt<T> for [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n-    fn to_vec(&self) -> Vec<T> where T: Clone {\n+    fn to_vec(&self) -> Vec<T> {\n         let mut vector = Vec::with_capacity(self.len());\n         vector.push_all(self);\n         vector\n     }\n \n+\n+    #[inline]\n+    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n+        self.iter().cloned().partition(f)\n+    }\n+\n     /// Returns an iterator over all permutations of a vector.\n-    fn permutations(&self) -> Permutations<T> where T: Clone {\n+    fn permutations(&self) -> Permutations<T> {\n         Permutations{\n             swaps: ElementSwaps::new(self.len()),\n             v: self.to_vec(),\n         }\n     }\n \n-    fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone {\n-        core_slice::SliceExt::clone_from_slice(self, src)\n-    }\n-\n-    #[inline]\n-    fn sort(&mut self) where T: Ord {\n-        self.sort_by(|a, b| a.cmp(b))\n+    fn clone_from_slice(&mut self, src: &[T]) -> uint {\n+        core_slice::CloneSliceExt::clone_from_slice(self, src)\n     }\n+}\n \n-    fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord {\n-        core_slice::SliceExt::binary_search(self, x)\n-    }\n+/// Allocating extension methods for slices on Ord values.\n+#[unstable = \"likely to merge with SliceExt\"]\n+pub trait OrdSliceExt<T> for Sized? {\n+    /// Sorts the slice, in place.\n+    ///\n+    /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let mut v = [-5, 4, 1, -3, 2];\n+    ///\n+    /// v.sort();\n+    /// assert!(v == [-5, -3, 1, 2, 4]);\n+    /// ```\n+    #[stable]\n+    fn sort(&mut self);\n \n-    fn next_permutation(&mut self) -> bool where T: Ord {\n-        core_slice::SliceExt::next_permutation(self)\n-    }\n+    /// Binary search a sorted slice for a given element.\n+    ///\n+    /// If the value is found then `Ok` is returned, containing the\n+    /// index of the matching element; if the value is not found then\n+    /// `Err` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Example\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n+    ///\n+    /// ```rust\n+    /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = s.as_slice();\n+    ///\n+    /// assert_eq!(s.binary_search(&13),  Ok(9));\n+    /// assert_eq!(s.binary_search(&4),   Err(7));\n+    /// assert_eq!(s.binary_search(&100), Err(13));\n+    /// let r = s.binary_search(&1);\n+    /// assert!(match r { Ok(1...4) => true, _ => false, });\n+    /// ```\n+    #[stable]\n+    fn binary_search(&self, x: &T) -> Result<uint, uint>;\n \n-    fn prev_permutation(&mut self) -> bool where T: Ord {\n-        core_slice::SliceExt::prev_permutation(self)\n+    /// Deprecated: use `binary_search` instead.\n+    #[deprecated = \"use binary_search instead\"]\n+    fn binary_search_elem(&self, x: &T) -> Result<uint, uint> {\n+        self.binary_search(x)\n     }\n \n-    fn position_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n-        core_slice::SliceExt::position_elem(self, t)\n-    }\n+    /// Mutates the slice to the next lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// last-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [0, 1, 2];\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [0, 2, 1];\n+    /// assert!(v == b);\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [1, 0, 2];\n+    /// assert!(v == b);\n+    /// ```\n+    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    fn next_permutation(&mut self) -> bool;\n \n-    fn rposition_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n-        core_slice::SliceExt::rposition_elem(self, t)\n-    }\n+    /// Mutates the slice to the previous lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// first-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [1, 0, 2];\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0, 2, 1];\n+    /// assert!(v == b);\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0, 1, 2];\n+    /// assert!(v == b);\n+    /// ```\n+    #[unstable = \"uncertain if this merits inclusion in std\"]\n+    fn prev_permutation(&mut self) -> bool;\n+}\n \n-    fn contains(&self, x: &T) -> bool where T: PartialEq {\n-        core_slice::SliceExt::contains(self, x)\n+#[unstable = \"trait is unstable\"]\n+impl<T: Ord> OrdSliceExt<T> for [T] {\n+    #[inline]\n+    fn sort(&mut self) {\n+        self.sort_by(|a, b| a.cmp(b))\n     }\n \n-    fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n-        core_slice::SliceExt::starts_with(self, needle)\n+    fn binary_search(&self, x: &T) -> Result<uint, uint> {\n+        core_slice::OrdSliceExt::binary_search(self, x)\n     }\n \n-    fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n-        core_slice::SliceExt::ends_with(self, needle)\n+    fn next_permutation(&mut self) -> bool {\n+        core_slice::OrdSliceExt::next_permutation(self)\n     }\n \n-    fn into_vec(mut self: Box<Self>) -> Vec<T> {\n-        unsafe {\n-            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n-            mem::forget(self);\n-            xs\n-        }\n+    fn prev_permutation(&mut self) -> bool {\n+        core_slice::OrdSliceExt::prev_permutation(self)\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Extension traits for slices over specifc kinds of data\n-////////////////////////////////////////////////////////////////////////////////\n #[unstable = \"U should be an associated type\"]\n /// An extension trait for concatenating slices\n pub trait SliceConcatExt<Sized? T, U> for Sized? {\n     /// Flattens a slice of `T` into a single value `U`.\n     #[stable]\n     fn concat(&self) -> U;\n \n+    #[deprecated = \"renamed to concat\"]\n+    fn concat_vec(&self) -> U {\n+        self.concat()\n+    }\n+\n     /// Flattens a slice of `T` into a single value `U`, placing a\n     /// given seperator between each.\n     #[stable]\n     fn connect(&self, sep: &T) -> U;\n+\n+    #[deprecated = \"renamed to connect\"]\n+    fn connect_vec(&self, sep: &T) -> U {\n+        self.connect(sep)\n+    }\n }\n \n impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n@@ -1033,7 +1056,7 @@ impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n /// The last generated swap is always (0, 1), and it returns the\n /// sequence to its initial order.\n #[experimental]\n-#[derive(Clone)]\n+#[deriving(Clone)]\n pub struct ElementSwaps {\n     sdir: Vec<SizeDirection>,\n     /// If `true`, emit the last swap that returns the sequence to initial\n@@ -1080,19 +1103,17 @@ impl<T: Clone> ToOwned<Vec<T>> for [T] {\n // Iterators\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[derive(Copy, Clone)]\n+#[deriving(Copy, Clone)]\n enum Direction { Pos, Neg }\n \n /// An `Index` and `Direction` together.\n-#[derive(Copy, Clone)]\n+#[deriving(Copy, Clone)]\n struct SizeDirection {\n     size: uint,\n     dir: Direction,\n }\n \n-impl Iterator for ElementSwaps {\n-    type Item = (uint, uint);\n-\n+impl Iterator<(uint, uint)> for ElementSwaps {\n     #[inline]\n     fn next(&mut self) -> Option<(uint, uint)> {\n         fn new_pos(i: uint, s: Direction) -> uint {\n@@ -1159,9 +1180,7 @@ pub struct Permutations<T> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<T: Clone> Iterator for Permutations<T> {\n-    type Item = Vec<T>;\n-\n+impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n     #[inline]\n     fn next(&mut self) -> Option<Vec<T>> {\n         match self.swaps.next() {\n@@ -1388,12 +1407,21 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n     }\n }\n \n+/// Deprecated, unsafe operations\n+#[deprecated]\n+pub mod raw {\n+    pub use core::slice::raw::{buf_as_slice, mut_buf_as_slice};\n+    pub use core::slice::raw::{shift_ptr, pop_ptr};\n+}\n+\n #[cfg(test)]\n mod tests {\n+    use std::boxed::Box;\n     use prelude::{Some, None, range, Vec, ToString, Clone, Greater, Less, Equal};\n-    use prelude::{SliceExt, Iterator, IteratorExt};\n-    use prelude::AsSlice;\n+    use prelude::{SliceExt, Iterator, IteratorExt, DoubleEndedIteratorExt};\n+    use prelude::{OrdSliceExt, CloneSliceExt, PartialEqSliceExt, AsSlice};\n     use prelude::{RandomAccessIterator, Ord, SliceConcatExt};\n+    use core::cell::Cell;\n     use core::default::Default;\n     use core::mem;\n     use std::rand::{Rng, thread_rng};\n@@ -1407,7 +1435,7 @@ mod tests {\n     #[test]\n     fn test_from_fn() {\n         // Test on-stack from_fn.\n-        let mut v = range(0, 3).map(square).collect::<Vec<_>>();\n+        let mut v = Vec::from_fn(3u, square);\n         {\n             let v = v.as_slice();\n             assert_eq!(v.len(), 3u);\n@@ -1417,7 +1445,7 @@ mod tests {\n         }\n \n         // Test on-heap from_fn.\n-        v = range(0, 5).map(square).collect::<Vec<_>>();\n+        v = Vec::from_fn(5u, square);\n         {\n             let v = v.as_slice();\n             assert_eq!(v.len(), 5u);\n@@ -1432,7 +1460,7 @@ mod tests {\n     #[test]\n     fn test_from_elem() {\n         // Test on-stack from_elem.\n-        let mut v = vec![10u, 10u];\n+        let mut v = Vec::from_elem(2u, 10u);\n         {\n             let v = v.as_slice();\n             assert_eq!(v.len(), 2u);\n@@ -1441,7 +1469,7 @@ mod tests {\n         }\n \n         // Test on-heap from_elem.\n-        v = vec![20u, 20u, 20u, 20u, 20u, 20u];\n+        v = Vec::from_elem(6u, 20u);\n         {\n             let v = v.as_slice();\n             assert_eq!(v[0], 20u);\n@@ -1483,23 +1511,23 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_first() {\n+    fn test_head() {\n         let mut a = vec![];\n-        assert_eq!(a.as_slice().first(), None);\n+        assert_eq!(a.as_slice().head(), None);\n         a = vec![11i];\n-        assert_eq!(a.as_slice().first().unwrap(), &11);\n+        assert_eq!(a.as_slice().head().unwrap(), &11);\n         a = vec![11i, 12];\n-        assert_eq!(a.as_slice().first().unwrap(), &11);\n+        assert_eq!(a.as_slice().head().unwrap(), &11);\n     }\n \n     #[test]\n-    fn test_first_mut() {\n+    fn test_head_mut() {\n         let mut a = vec![];\n-        assert_eq!(a.first_mut(), None);\n+        assert_eq!(a.head_mut(), None);\n         a = vec![11i];\n-        assert_eq!(*a.first_mut().unwrap(), 11);\n+        assert_eq!(*a.head_mut().unwrap(), 11);\n         a = vec![11i, 12];\n-        assert_eq!(*a.first_mut().unwrap(), 11);\n+        assert_eq!(*a.head_mut().unwrap(), 11);\n     }\n \n     #[test]\n@@ -1703,6 +1731,42 @@ mod tests {\n         assert_eq!(v.as_slice()[1], 2);\n     }\n \n+    #[test]\n+    fn test_grow() {\n+        // Test on-stack grow().\n+        let mut v = vec![];\n+        v.grow(2u, 1i);\n+        {\n+            let v = v.as_slice();\n+            assert_eq!(v.len(), 2u);\n+            assert_eq!(v[0], 1);\n+            assert_eq!(v[1], 1);\n+        }\n+\n+        // Test on-heap grow().\n+        v.grow(3u, 2i);\n+        {\n+            let v = v.as_slice();\n+            assert_eq!(v.len(), 5u);\n+            assert_eq!(v[0], 1);\n+            assert_eq!(v[1], 1);\n+            assert_eq!(v[2], 2);\n+            assert_eq!(v[3], 2);\n+            assert_eq!(v[4], 2);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_grow_fn() {\n+        let mut v = vec![];\n+        v.grow_fn(3u, square);\n+        let v = v.as_slice();\n+        assert_eq!(v.len(), 3u);\n+        assert_eq!(v[0], 0u);\n+        assert_eq!(v[1], 1u);\n+        assert_eq!(v[2], 4u);\n+    }\n+\n     #[test]\n     fn test_truncate() {\n         let mut v = vec![box 6i,box 5,box 4];\n@@ -2035,6 +2099,22 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_partition() {\n+        assert_eq!((vec![]).partition(|x: &int| *x < 3), (vec![], vec![]));\n+        assert_eq!((vec![1i, 2, 3]).partition(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n+        assert_eq!((vec![1i, 2, 3]).partition(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n+        assert_eq!((vec![1i, 2, 3]).partition(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n+    }\n+\n+    #[test]\n+    fn test_partitioned() {\n+        assert_eq!(([]).partitioned(|x: &int| *x < 3), (vec![], vec![]));\n+        assert_eq!(([1i, 2, 3]).partitioned(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n+        assert_eq!(([1i, 2, 3]).partitioned(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n+        assert_eq!(([1i, 2, 3]).partitioned(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n+    }\n+\n     #[test]\n     fn test_concat() {\n         let v: [Vec<int>; 0] = [];\n@@ -2052,14 +2132,14 @@ mod tests {\n     #[test]\n     fn test_connect() {\n         let v: [Vec<int>; 0] = [];\n-        assert_eq!(v.connect(&0), vec![]);\n-        assert_eq!([vec![1i], vec![2i, 3]].connect(&0), vec![1, 0, 2, 3]);\n-        assert_eq!([vec![1i], vec![2i], vec![3i]].connect(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!(v.connect_vec(&0), vec![]);\n+        assert_eq!([vec![1i], vec![2i, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n+        assert_eq!([vec![1i], vec![2i], vec![3i]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n \n         let v: [&[int]; 2] = [&[1], &[2, 3]];\n-        assert_eq!(v.connect(&0), vec![1, 0, 2, 3]);\n+        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 3]);\n         let v: [&[int]; 3] = [&[1], &[2], &[3]];\n-        assert_eq!(v.connect(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n@@ -2132,6 +2212,55 @@ mod tests {\n         assert_eq!(v[1], 3);\n     }\n \n+\n+    #[test]\n+    #[should_fail]\n+    fn test_from_fn_fail() {\n+        Vec::from_fn(100, |v| {\n+            if v == 50 { panic!() }\n+            box 0i\n+        });\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_from_elem_fail() {\n+\n+        struct S {\n+            f: Cell<int>,\n+            boxes: (Box<int>, Rc<int>)\n+        }\n+\n+        impl Clone for S {\n+            fn clone(&self) -> S {\n+                self.f.set(self.f.get() + 1);\n+                if self.f.get() == 10 { panic!() }\n+                S {\n+                    f: self.f.clone(),\n+                    boxes: self.boxes.clone(),\n+                }\n+            }\n+        }\n+\n+        let s = S {\n+            f: Cell::new(0),\n+            boxes: (box 0, Rc::new(0)),\n+        };\n+        let _ = Vec::from_elem(100, s);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_grow_fn_fail() {\n+        let mut v = vec![];\n+        v.grow_fn(100, |i| {\n+            if i == 50 {\n+                panic!()\n+            }\n+            (box 0i, Rc::new(0i))\n+        })\n+    }\n+\n     #[test]\n     #[should_fail]\n     fn test_permute_fail() {\n@@ -2549,7 +2678,7 @@ mod tests {\n         assert!(values == [2, 3, 5, 6, 7]);\n     }\n \n-    #[derive(Clone, PartialEq)]\n+    #[deriving(Clone, PartialEq)]\n     struct Foo;\n \n     #[test]\n@@ -2720,15 +2849,14 @@ mod bench {\n     use prelude::*;\n     use core::mem;\n     use core::ptr;\n-    use core::iter::repeat;\n     use std::rand::{weak_rng, Rng};\n     use test::{Bencher, black_box};\n \n     #[bench]\n     fn iterator(b: &mut Bencher) {\n         // peculiar numbers to stop LLVM from optimising the summation\n         // out.\n-        let v = range(0u, 100).map(|i| i ^ (i << 1) ^ (i >> 1)).collect::<Vec<_>>();\n+        let v = Vec::from_fn(100, |i| i ^ (i << 1) ^ (i >> 1));\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -2742,7 +2870,7 @@ mod bench {\n \n     #[bench]\n     fn mut_iterator(b: &mut Bencher) {\n-        let mut v = repeat(0i).take(100).collect::<Vec<_>>();\n+        let mut v = Vec::from_elem(100, 0i);\n \n         b.iter(|| {\n             let mut i = 0i;\n@@ -2756,7 +2884,7 @@ mod bench {\n     #[bench]\n     fn concat(b: &mut Bencher) {\n         let xss: Vec<Vec<uint>> =\n-            range(0, 100u).map(|i| range(0, i).collect()).collect();\n+            Vec::from_fn(100, |i| range(0u, i).collect());\n         b.iter(|| {\n             xss.as_slice().concat();\n         });\n@@ -2765,9 +2893,9 @@ mod bench {\n     #[bench]\n     fn connect(b: &mut Bencher) {\n         let xss: Vec<Vec<uint>> =\n-            range(0, 100u).map(|i| range(0, i).collect()).collect();\n+            Vec::from_fn(100, |i| range(0u, i).collect());\n         b.iter(|| {\n-            xss.as_slice().connect(&0)\n+            xss.as_slice().connect_vec(&0)\n         });\n     }\n \n@@ -2782,7 +2910,7 @@ mod bench {\n \n     #[bench]\n     fn starts_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<uint> = range(0, 100).collect();\n+        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n         b.iter(|| {\n             vec.as_slice().starts_with(vec.as_slice())\n         })\n@@ -2798,8 +2926,8 @@ mod bench {\n \n     #[bench]\n     fn starts_with_diff_one_element_at_end(b: &mut Bencher) {\n-        let vec: Vec<uint> = range(0, 100).collect();\n-        let mut match_vec: Vec<uint> = range(0, 99).collect();\n+        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n+        let mut match_vec: Vec<uint> = Vec::from_fn(99, |i| i);\n         match_vec.push(0);\n         b.iter(|| {\n             vec.as_slice().starts_with(match_vec.as_slice())\n@@ -2808,7 +2936,7 @@ mod bench {\n \n     #[bench]\n     fn ends_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<uint> = range(0, 100).collect();\n+        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n         b.iter(|| {\n             vec.as_slice().ends_with(vec.as_slice())\n         })\n@@ -2824,8 +2952,8 @@ mod bench {\n \n     #[bench]\n     fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) {\n-        let vec: Vec<uint> = range(0, 100).collect();\n-        let mut match_vec: Vec<uint> = range(0, 100).collect();\n+        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n+        let mut match_vec: Vec<uint> = Vec::from_fn(100, |i| i);\n         match_vec.as_mut_slice()[0] = 200;\n         b.iter(|| {\n             vec.as_slice().starts_with(match_vec.as_slice())\n@@ -2834,7 +2962,7 @@ mod bench {\n \n     #[bench]\n     fn contains_last_element(b: &mut Bencher) {\n-        let vec: Vec<uint> = range(0, 100).collect();\n+        let vec: Vec<uint> = Vec::from_fn(100, |i| i);\n         b.iter(|| {\n             vec.contains(&99u)\n         })\n@@ -2843,7 +2971,7 @@ mod bench {\n     #[bench]\n     fn zero_1kb_from_elem(b: &mut Bencher) {\n         b.iter(|| {\n-            repeat(0u8).take(1024).collect::<Vec<_>>()\n+            Vec::from_elem(1024, 0u8)\n         });\n     }\n \n@@ -2891,24 +3019,24 @@ mod bench {\n     fn random_inserts(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = repeat((0u, 0u)).take(30).collect::<Vec<_>>();\n-            for _ in range(0u, 100) {\n-                let l = v.len();\n-                v.insert(rng.gen::<uint>() % (l + 1),\n-                         (1, 1));\n-            }\n-        })\n+                let mut v = Vec::from_elem(30, (0u, 0u));\n+                for _ in range(0u, 100) {\n+                    let l = v.len();\n+                    v.insert(rng.gen::<uint>() % (l + 1),\n+                             (1, 1));\n+                }\n+            })\n     }\n     #[bench]\n     fn random_removes(b: &mut Bencher) {\n         let mut rng = weak_rng();\n         b.iter(|| {\n-            let mut v = repeat((0u, 0u)).take(130).collect::<Vec<_>>();\n-            for _ in range(0u, 100) {\n-                let l = v.len();\n-                v.remove(rng.gen::<uint>() % l);\n-            }\n-        })\n+                let mut v = Vec::from_elem(130, (0u, 0u));\n+                for _ in range(0u, 100) {\n+                    let l = v.len();\n+                    v.remove(rng.gen::<uint>() % l);\n+                }\n+            })\n     }\n \n     #[bench]\n@@ -2943,7 +3071,7 @@ mod bench {\n \n     #[bench]\n     fn sort_sorted(b: &mut Bencher) {\n-        let mut v = range(0u, 10000).collect::<Vec<_>>();\n+        let mut v = Vec::from_fn(10000, |i| i);\n         b.iter(|| {\n             v.sort();\n         });\n@@ -2987,7 +3115,7 @@ mod bench {\n \n     #[bench]\n     fn sort_big_sorted(b: &mut Bencher) {\n-        let mut v = range(0, 10000u).map(|i| (i, i, i, i)).collect::<Vec<_>>();\n+        let mut v = Vec::from_fn(10000u, |i| (i, i, i, i));\n         b.iter(|| {\n             v.sort();\n         });"}, {"sha": "e0ed8e27e991c168464e4baac23c680ce9bfb816", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -25,21 +25,21 @@\n //! ```\n //! let ys: Vec<i32> = vec![];\n //!\n-//! let zs = vec![1i32, 2, 3, 4, 5];\n+//! let zs = vec![1, 2, 3, 4, 5];\n //! ```\n //!\n //! Push:\n //!\n //! ```\n-//! let mut xs = vec![1i32, 2];\n+//! let mut xs = vec![1, 2];\n //!\n //! xs.push(3);\n //! ```\n //!\n //! And pop:\n //!\n //! ```\n-//! let mut xs = vec![1i32, 2];\n+//! let mut xs = vec![1, 2];\n //!\n //! let two = xs.pop();\n //! ```\n@@ -71,30 +71,30 @@ use core::uint;\n ///\n /// ```\n /// let mut vec = Vec::new();\n-/// vec.push(1i);\n-/// vec.push(2i);\n+/// vec.push(1);\n+/// vec.push(2);\n ///\n /// assert_eq!(vec.len(), 2);\n /// assert_eq!(vec[0], 1);\n ///\n /// assert_eq!(vec.pop(), Some(2));\n /// assert_eq!(vec.len(), 1);\n ///\n-/// vec[0] = 7i;\n+/// vec[0] = 7;\n /// assert_eq!(vec[0], 7);\n ///\n /// vec.push_all(&[1, 2, 3]);\n ///\n /// for x in vec.iter() {\n ///     println!(\"{}\", x);\n /// }\n-/// assert_eq!(vec, vec![7i, 1, 2, 3]);\n+/// assert_eq!(vec, vec![7, 1, 2, 3]);\n /// ```\n ///\n /// The `vec!` macro is provided to make initialization more convenient:\n ///\n /// ```\n-/// let mut vec = vec![1i, 2i, 3i];\n+/// let mut vec = vec![1, 2, 3];\n /// vec.push(4);\n /// assert_eq!(vec, vec![1, 2, 3, 4]);\n /// ```\n@@ -104,9 +104,9 @@ use core::uint;\n /// ```\n /// let mut stack = Vec::new();\n ///\n-/// stack.push(1i);\n-/// stack.push(2i);\n-/// stack.push(3i);\n+/// stack.push(1);\n+/// stack.push(2);\n+/// stack.push(3);\n ///\n /// loop {\n ///     let top = match stack.pop() {\n@@ -218,7 +218,7 @@ impl<T> Vec<T> {\n     /// use std::mem;\n     ///\n     /// fn main() {\n-    ///     let mut v = vec![1i, 2, 3];\n+    ///     let mut v = vec![1, 2, 3];\n     ///\n     ///     // Pull out the various important pieces of information about `v`\n     ///     let p = v.as_mut_ptr();\n@@ -237,7 +237,7 @@ impl<T> Vec<T> {\n     ///\n     ///         // Put everything back together into a Vec\n     ///         let rebuilt = Vec::from_raw_parts(p, len, cap);\n-    ///         assert_eq!(rebuilt, vec![4i, 5i, 6i]);\n+    ///         assert_eq!(rebuilt, vec![4, 5, 6]);\n     ///     }\n     /// }\n     /// ```\n@@ -392,7 +392,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4];\n+    /// let mut vec = vec![1, 2, 3, 4];\n     /// vec.truncate(2);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n@@ -416,7 +416,7 @@ impl<T> Vec<T> {\n     /// ```\n     /// fn foo(slice: &mut [int]) {}\n     ///\n-    /// let mut vec = vec![1i, 2];\n+    /// let mut vec = vec![1, 2];\n     /// foo(vec.as_mut_slice());\n     /// ```\n     #[inline]\n@@ -519,7 +519,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![1i, 2, 3];\n+    /// let mut vec = vec![1, 2, 3];\n     /// vec.insert(1, 4);\n     /// assert_eq!(vec, vec![1, 4, 2, 3]);\n     /// vec.insert(4, 5);\n@@ -557,7 +557,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = vec![1i, 2, 3];\n+    /// let mut v = vec![1, 2, 3];\n     /// assert_eq!(v.remove(1), 2);\n     /// assert_eq!(v, vec![1, 3]);\n     /// ```\n@@ -591,7 +591,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![1i, 2, 3, 4];\n+    /// let mut vec = vec![1, 2, 3, 4];\n     /// vec.retain(|&x| x%2 == 0);\n     /// assert_eq!(vec, vec![2, 4]);\n     /// ```\n@@ -624,7 +624,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// let mut vec = vec!(1i, 2);\n+    /// let mut vec = vec!(1, 2);\n     /// vec.push(3);\n     /// assert_eq!(vec, vec!(1, 2, 3));\n     /// ```\n@@ -662,7 +662,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// let mut vec = vec![1i, 2, 3];\n+    /// let mut vec = vec![1, 2, 3];\n     /// assert_eq!(vec.pop(), Some(3));\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n@@ -716,7 +716,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut v = vec![1i, 2, 3];\n+    /// let mut v = vec![1, 2, 3];\n     ///\n     /// v.clear();\n     ///\n@@ -733,7 +733,7 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let a = vec![1i, 2, 3];\n+    /// let a = vec![1, 2, 3];\n     /// assert_eq!(a.len(), 3);\n     /// ```\n     #[inline]\n@@ -748,7 +748,7 @@ impl<T> Vec<T> {\n     /// let mut v = Vec::new();\n     /// assert!(v.is_empty());\n     ///\n-    /// v.push(1i);\n+    /// v.push(1);\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable]\n@@ -965,7 +965,7 @@ impl<T: Clone> Vec<T> {\n     /// vec.resize(3, \"world\");\n     /// assert_eq!(vec, vec![\"hello\", \"world\", \"world\"]);\n     ///\n-    /// let mut vec = vec![1i, 2, 3, 4];\n+    /// let mut vec = vec![1, 2, 3, 4];\n     /// vec.resize(2, 0);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n@@ -988,8 +988,8 @@ impl<T: Clone> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![1i];\n-    /// vec.push_all(&[2i, 3, 4]);\n+    /// let mut vec = vec![1];\n+    /// vec.push_all(&[2, 3, 4]);\n     /// assert_eq!(vec, vec![1, 2, 3, 4]);\n     /// ```\n     #[inline]\n@@ -1021,11 +1021,11 @@ impl<T: PartialEq> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut vec = vec![1i, 2, 2, 3, 2];\n+    /// let mut vec = vec![1, 2, 2, 3, 2];\n     ///\n     /// vec.dedup();\n     ///\n-    /// assert_eq!(vec, vec![1i, 2, 3, 2]);\n+    /// assert_eq!(vec, vec![1, 2, 3, 2]);\n     /// ```\n     #[stable]\n     pub fn dedup(&mut self) {\n@@ -1378,7 +1378,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     /// ```\n     /// fn foo(slice: &[int]) {}\n     ///\n-    /// let vec = vec![1i, 2];\n+    /// let vec = vec![1, 2];\n     /// foo(vec.as_slice());\n     /// ```\n     #[inline]"}, {"sha": "ebc01ae14fc81a06044634a0ed712d9d55c637ba", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -793,7 +793,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     /// use std::sync::atomic::AtomicPtr;\n     ///\n-    /// let ptr = &mut 5i;\n+    /// let ptr = &mut 5;\n     /// let atomic_ptr  = AtomicPtr::new(ptr);\n     /// ```\n     #[inline]\n@@ -815,7 +815,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     /// use std::sync::atomic::{AtomicPtr, Ordering};\n     ///\n-    /// let ptr = &mut 5i;\n+    /// let ptr = &mut 5;\n     /// let some_ptr  = AtomicPtr::new(ptr);\n     ///\n     /// let value = some_ptr.load(Ordering::Relaxed);\n@@ -837,10 +837,10 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     /// use std::sync::atomic::{AtomicPtr, Ordering};\n     ///\n-    /// let ptr = &mut 5i;\n+    /// let ptr = &mut 5;\n     /// let some_ptr  = AtomicPtr::new(ptr);\n     ///\n-    /// let other_ptr = &mut 10i;\n+    /// let other_ptr = &mut 10;\n     ///\n     /// some_ptr.store(other_ptr, Ordering::Relaxed);\n     /// ```\n@@ -863,10 +863,10 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     /// use std::sync::atomic::{AtomicPtr, Ordering};\n     ///\n-    /// let ptr = &mut 5i;\n+    /// let ptr = &mut 5;\n     /// let some_ptr  = AtomicPtr::new(ptr);\n     ///\n-    /// let other_ptr = &mut 10i;\n+    /// let other_ptr = &mut 10;\n     ///\n     /// let value = some_ptr.swap(other_ptr, Ordering::Relaxed);\n     /// ```\n@@ -888,11 +888,11 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     /// use std::sync::atomic::{AtomicPtr, Ordering};\n     ///\n-    /// let ptr = &mut 5i;\n+    /// let ptr = &mut 5;\n     /// let some_ptr  = AtomicPtr::new(ptr);\n     ///\n-    /// let other_ptr   = &mut 10i;\n-    /// let another_ptr = &mut 10i;\n+    /// let other_ptr   = &mut 10;\n+    /// let another_ptr = &mut 10;\n     ///\n     /// let value = some_ptr.compare_and_swap(other_ptr, another_ptr, Ordering::Relaxed);\n     /// ```"}, {"sha": "c9646bb3d3506b33e4faf10a1a17138e57c47a2c", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -145,7 +145,7 @@ pub struct RadixFmt<T, R>(T, R);\n ///\n /// ```\n /// use std::fmt::radix;\n-/// assert_eq!(format!(\"{}\", radix(55i, 36)), \"1j\".to_string());\n+/// assert_eq!(format!(\"{}\", radix(55, 36)), \"1j\".to_string());\n /// ```\n #[unstable = \"may be renamed or move to a different module\"]\n pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {"}, {"sha": "e7e32cec177ec48567f778618a92b1774bfddd77", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -33,7 +33,7 @@\n //! translated to the `loop` below.\n //!\n //! ```rust\n-//! let values = vec![1i, 2, 3];\n+//! let values = vec![1, 2, 3];\n //!\n //! // \"Syntactical sugar\" taking advantage of an iterator\n //! for &x in values.iter() {\n@@ -118,8 +118,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [0i];\n-    /// let b = [1i];\n+    /// let a = [0];\n+    /// let b = [1];\n     /// let mut it = a.iter().chain(b.iter());\n     /// assert_eq!(it.next().unwrap(), &0);\n     /// assert_eq!(it.next().unwrap(), &1);\n@@ -141,10 +141,10 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [0i];\n-    /// let b = [1i];\n+    /// let a = [0];\n+    /// let b = [1];\n     /// let mut it = a.iter().zip(b.iter());\n-    /// let (x0, x1) = (0i, 1i);\n+    /// let (x0, x1) = (0, 1);\n     /// assert_eq!(it.next().unwrap(), (&x0, &x1));\n     /// assert!(it.next().is_none());\n     /// ```\n@@ -162,7 +162,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2];\n+    /// let a = [1, 2];\n     /// let mut it = a.iter().map(|&x| 2 * x);\n     /// assert_eq!(it.next().unwrap(), 2);\n     /// assert_eq!(it.next().unwrap(), 4);\n@@ -183,7 +183,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2];\n+    /// let a = [1, 2];\n     /// let mut it = a.iter().filter(|&x| *x > 1);\n     /// assert_eq!(it.next().unwrap(), &2);\n     /// assert!(it.next().is_none());\n@@ -203,7 +203,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2];\n+    /// let a = [1, 2];\n     /// let mut it = a.iter().filter_map(|&x| if x > 1 {Some(2 * x)} else {None});\n     /// assert_eq!(it.next().unwrap(), 4);\n     /// assert!(it.next().is_none());\n@@ -222,9 +222,9 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [100i, 200];\n+    /// let a = [100, 200];\n     /// let mut it = a.iter().enumerate();\n-    /// let (x100, x200) = (100i, 200i);\n+    /// let (x100, x200) = (100, 200);\n     /// assert_eq!(it.next().unwrap(), (0, &x100));\n     /// assert_eq!(it.next().unwrap(), (1, &x200));\n     /// assert!(it.next().is_none());\n@@ -241,7 +241,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let xs = [100i, 200, 300];\n+    /// let xs = [100, 200, 300];\n     /// let mut it = xs.iter().map(|x| *x).peekable();\n     /// assert_eq!(*it.peek().unwrap(), 100);\n     /// assert_eq!(it.next().unwrap(), 100);\n@@ -265,7 +265,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2, 3, 2, 1];\n+    /// let a = [1, 2, 3, 2, 1];\n     /// let mut it = a.iter().skip_while(|&a| *a < 3);\n     /// assert_eq!(it.next().unwrap(), &3);\n     /// assert_eq!(it.next().unwrap(), &2);\n@@ -287,7 +287,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2, 3, 2, 1];\n+    /// let a = [1, 2, 3, 2, 1];\n     /// let mut it = a.iter().take_while(|&a| *a < 3);\n     /// assert_eq!(it.next().unwrap(), &1);\n     /// assert_eq!(it.next().unwrap(), &2);\n@@ -307,7 +307,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().skip(3);\n     /// assert_eq!(it.next().unwrap(), &4);\n     /// assert_eq!(it.next().unwrap(), &5);\n@@ -325,7 +325,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().take(3);\n     /// assert_eq!(it.next().unwrap(), &1);\n     /// assert_eq!(it.next().unwrap(), &2);\n@@ -346,7 +346,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().scan(1, |fac, &x| {\n     ///   *fac = *fac * x;\n     ///   Some(*fac)\n@@ -419,9 +419,9 @@ pub trait IteratorExt: Iterator + Sized {\n     ///     }\n     ///     sum\n     /// }\n-    /// let x = vec![1i,2,3,7,8,9];\n+    /// let x = vec![1,2,3,7,8,9];\n     /// assert_eq!(process(x.into_iter()), 6);\n-    /// let x = vec![1i,2,3];\n+    /// let x = vec![1,2,3];\n     /// assert_eq!(process(x.into_iter()), 1006);\n     /// ```\n     #[inline]\n@@ -482,7 +482,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let b: Vec<int> = a.iter().map(|&x| x).collect();\n     /// assert!(a.as_slice() == b.as_slice());\n     /// ```\n@@ -498,7 +498,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// do not.\n     ///\n     /// ```\n-    /// let vec = vec![1i, 2i, 3i, 4i];\n+    /// let vec = vec![1, 2, 3, 4];\n     /// let (even, odd): (Vec<int>, Vec<int>) = vec.into_iter().partition(|&n| n % 2 == 0);\n     /// assert_eq!(even, vec![2, 4]);\n     /// assert_eq!(odd, vec![1, 3]);\n@@ -528,7 +528,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.nth(2).unwrap() == &3);\n     /// assert!(it.nth(2) == None);\n@@ -549,7 +549,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().last().unwrap() == &5);\n     /// ```\n     #[inline]\n@@ -566,7 +566,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n     /// ```\n     #[inline]\n@@ -586,7 +586,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.count() == 5);\n     /// ```\n@@ -601,7 +601,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().all(|x| *x > 0));\n     /// assert!(!a.iter().all(|x| *x > 2));\n     /// ```\n@@ -618,7 +618,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.any(|x| *x == 3));\n     /// assert!(!it.any(|x| *x == 3));\n@@ -668,7 +668,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```rust\n     /// use core::num::SignedInt;\n     ///\n-    /// let xs = [-3i, 0, 1, 5, -10];\n+    /// let xs = [-3, 0, 1, 5, -10];\n     /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n@@ -697,7 +697,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```rust\n     /// use core::num::SignedInt;\n     ///\n-    /// let xs = [-3i, 0, 1, 5, -10];\n+    /// let xs = [-3, 0, 1, 5, -10];\n     /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n@@ -950,7 +950,7 @@ pub trait AdditiveIterator<A> {\n     /// ```rust\n     /// use std::iter::AdditiveIterator;\n     ///\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// let a: [i32] = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().map(|&x| x);\n     /// assert!(it.sum() == 15);\n     /// ```\n@@ -1033,7 +1033,7 @@ pub trait IteratorOrdExt<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().max().unwrap() == &5);\n     /// ```\n     fn max(self) -> Option<A>;\n@@ -1043,7 +1043,7 @@ pub trait IteratorOrdExt<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n+    /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().min().unwrap() == &1);\n     /// ```\n     fn min(self) -> Option<A>;\n@@ -1069,16 +1069,16 @@ pub trait IteratorOrdExt<A> {\n     /// let v: [int; 0] = [];\n     /// assert_eq!(v.iter().min_max(), NoElements);\n     ///\n-    /// let v = [1i];\n+    /// let v = [1];\n     /// assert!(v.iter().min_max() == OneElement(&1));\n     ///\n-    /// let v = [1i, 2, 3, 4, 5];\n+    /// let v = [1, 2, 3, 4, 5];\n     /// assert!(v.iter().min_max() == MinMax(&1, &5));\n     ///\n-    /// let v = [1i, 2, 3, 4, 5, 6];\n+    /// let v = [1, 2, 3, 4, 5, 6];\n     /// assert!(v.iter().min_max() == MinMax(&1, &6));\n     ///\n-    /// let v = [1i, 1, 1, 1];\n+    /// let v = [1, 1, 1, 1];\n     /// assert!(v.iter().min_max() == MinMax(&1, &1));\n     /// ```\n     fn min_max(self) -> MinMaxResult<A>;\n@@ -1179,10 +1179,10 @@ impl<T: Clone> MinMaxResult<T> {\n     /// let r: MinMaxResult<int> = NoElements;\n     /// assert_eq!(r.into_option(), None);\n     ///\n-    /// let r = OneElement(1i);\n+    /// let r = OneElement(1);\n     /// assert_eq!(r.into_option(), Some((1,1)));\n     ///\n-    /// let r = MinMax(1i,2i);\n+    /// let r = MinMax(1, 2);\n     /// assert_eq!(r.into_option(), Some((1,2)));\n     /// ```\n     pub fn into_option(self) -> Option<(T,T)> {\n@@ -1261,7 +1261,7 @@ pub trait CloneIteratorExt {\n     /// ```rust\n     /// use std::iter::{CloneIteratorExt, count};\n     ///\n-    /// let a = count(1i,1i).take(1);\n+    /// let a = count(1, 1).take(1);\n     /// let mut cy = a.cycle();\n     /// assert_eq!(cy.next(), Some(1));\n     /// assert_eq!(cy.next(), Some(1));"}, {"sha": "9cf3433e1ab896690b89614585f88477830f6ed1", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -187,13 +187,13 @@ pub unsafe fn uninitialized<T>() -> T {\n /// ```\n /// use std::mem;\n ///\n-/// let x = &mut 5i;\n-/// let y = &mut 42i;\n+/// let x = &mut 5;\n+/// let y = &mut 42;\n ///\n /// mem::swap(x, y);\n ///\n-/// assert_eq!(42i, *x);\n-/// assert_eq!(5i, *y);\n+/// assert_eq!(42, *x);\n+/// assert_eq!(5, *y);\n /// ```\n #[inline]\n #[stable]"}, {"sha": "485d320cf5cc8906153b461222e0bb9bac7a52cc", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -336,7 +336,7 @@ pub trait Int\n     /// ```rust\n     /// use std::num::Int;\n     ///\n-    /// assert_eq!(2i.pow(4), 16);\n+    /// assert_eq!(2.pow(4), 16);\n     /// ```\n     #[inline]\n     fn pow(self, mut exp: uint) -> Self {"}, {"sha": "9e55a3aa8c404f641c8c97cff3b8480aefe7f3f9", "filename": "src/libcore/option.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -470,10 +470,10 @@ impl<T> Option<T> {\n     ///\n     /// ```\n     /// let x = Some(\"foo\");\n-    /// assert_eq!(x.ok_or(0i), Ok(\"foo\"));\n+    /// assert_eq!(x.ok_or(0), Ok(\"foo\"));\n     ///\n     /// let x: Option<&str> = None;\n-    /// assert_eq!(x.ok_or(0i), Err(0i));\n+    /// assert_eq!(x.ok_or(0), Err(0));\n     /// ```\n     #[inline]\n     #[experimental]\n@@ -491,10 +491,10 @@ impl<T> Option<T> {\n     ///\n     /// ```\n     /// let x = Some(\"foo\");\n-    /// assert_eq!(x.ok_or_else(|| 0i), Ok(\"foo\"));\n+    /// assert_eq!(x.ok_or_else(|| 0), Ok(\"foo\"));\n     ///\n     /// let x: Option<&str> = None;\n-    /// assert_eq!(x.ok_or_else(|| 0i), Err(0i));\n+    /// assert_eq!(x.ok_or_else(|| 0), Err(0));\n     /// ```\n     #[inline]\n     #[experimental]\n@@ -728,8 +728,8 @@ impl<T: Default> Option<T> {\n     /// let good_year = good_year_from_input.parse().unwrap_or_default();\n     /// let bad_year = bad_year_from_input.parse().unwrap_or_default();\n     ///\n-    /// assert_eq!(1909i, good_year);\n-    /// assert_eq!(0i, bad_year);\n+    /// assert_eq!(1909, good_year);\n+    /// assert_eq!(0, bad_year);\n     /// ```\n     #[inline]\n     #[stable]"}, {"sha": "f41a4a8b901a8f329e11fe9802572ccb4b88788b", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -125,7 +125,7 @@ macro_rules! warn {\n /// #[phase(plugin, link)] extern crate log;\n ///\n /// fn main() {\n-///     let ret = 3i;\n+///     let ret = 3;\n ///     info!(\"this function is about to return: {}\", ret);\n /// }\n /// ```\n@@ -152,7 +152,7 @@ macro_rules! info {\n /// #[phase(plugin, link)] extern crate log;\n ///\n /// fn main() {\n-///     debug!(\"x = {x}, y = {y}\", x=10i, y=20i);\n+///     debug!(\"x = {x}, y = {y}\", x=10, y=20);\n /// }\n /// ```\n ///"}, {"sha": "1d37b061c97121ce6821952b0fe304b271e3410b", "filename": "src/librand/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -269,7 +269,7 @@ pub trait Rng : Sized {\n     /// ```\n     /// use std::rand::{thread_rng, Rng};\n     ///\n-    /// let choices = [1i, 2, 4, 8, 16, 32];\n+    /// let choices = [1, 2, 4, 8, 16, 32];\n     /// let mut rng = thread_rng();\n     /// println!(\"{}\", rng.choose(&choices));\n     /// # // replace with slicing syntax when it's stable!\n@@ -291,7 +291,7 @@ pub trait Rng : Sized {\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n-    /// let mut y = [1i, 2, 3];\n+    /// let mut y = [1, 2, 3];\n     /// rng.shuffle(&mut y);\n     /// println!(\"{}\", y.as_slice());\n     /// rng.shuffle(&mut y);"}, {"sha": "7877e783ed699f622a3b206c55f9a49c2f1165ca", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -164,7 +164,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///\n     /// let h = SipHasher::new();\n     /// let mut set = HashSet::with_capacity_and_hasher(10u, h);\n-    /// set.insert(1i);\n+    /// set.insert(1);\n     /// ```\n     #[inline]\n     #[unstable = \"hasher stuff is unclear\"]\n@@ -283,21 +283,21 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n     /// // Can be seen as `a - b`.\n     /// for x in a.difference(&b) {\n     ///     println!(\"{}\", x); // Print 1\n     /// }\n     ///\n     /// let diff: HashSet<int> = a.difference(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [1i].iter().map(|&x| x).collect());\n+    /// assert_eq!(diff, [1].iter().map(|&x| x).collect());\n     ///\n     /// // Note that difference is not symmetric,\n     /// // and `b - a` means something else:\n     /// let diff: HashSet<int> = b.difference(&a).map(|&x| x).collect();\n-    /// assert_eq!(diff, [4i].iter().map(|&x| x).collect());\n+    /// assert_eq!(diff, [4].iter().map(|&x| x).collect());\n     /// ```\n     #[stable]\n     pub fn difference<'a>(&'a self, other: &'a HashSet<T, H>) -> Difference<'a, T, H> {\n@@ -313,8 +313,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n     /// // Print 1, 4 in arbitrary order.\n     /// for x in a.symmetric_difference(&b) {\n@@ -325,7 +325,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// let diff2: HashSet<int> = b.symmetric_difference(&a).map(|&x| x).collect();\n     ///\n     /// assert_eq!(diff1, diff2);\n-    /// assert_eq!(diff1, [1i, 4].iter().map(|&x| x).collect());\n+    /// assert_eq!(diff1, [1, 4].iter().map(|&x| x).collect());\n     /// ```\n     #[stable]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, H>)\n@@ -339,16 +339,16 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n     /// // Print 2, 3 in arbitrary order.\n     /// for x in a.intersection(&b) {\n     ///     println!(\"{}\", x);\n     /// }\n     ///\n     /// let diff: HashSet<int> = a.intersection(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [2i, 3].iter().map(|&x| x).collect());\n+    /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n     /// ```\n     #[stable]\n     pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>) -> Intersection<'a, T, H> {\n@@ -364,16 +364,16 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n+    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n     ///\n     /// // Print 1, 2, 3, 4 in arbitrary order.\n     /// for x in a.union(&b) {\n     ///     println!(\"{}\", x);\n     /// }\n     ///\n     /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n-    /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n+    /// assert_eq!(diff, [1, 2, 3, 4].iter().map(|&x| x).collect());\n     /// ```\n     #[stable]\n     pub fn union<'a>(&'a self, other: &'a HashSet<T, H>) -> Union<'a, T, H> {"}, {"sha": "fb2d23b01b4644c990baaa0d4fa6e481bc198586", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -33,7 +33,7 @@\n /// # #![allow(unreachable_code)]\n /// panic!();\n /// panic!(\"this is a terrible mistake!\");\n-/// panic!(4i); // panic with the value of 4 to be collected elsewhere\n+/// panic!(4); // panic with the value of 4 to be collected elsewhere\n /// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n /// ```\n #[macro_export]\n@@ -74,7 +74,7 @@ macro_rules! panic {\n /// // assert with a custom message\n /// # let x = true;\n /// assert!(x, \"x wasn't true!\");\n-/// # let a = 3i; let b = 27i;\n+/// # let a = 3; let b = 27;\n /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n@@ -99,8 +99,8 @@ macro_rules! assert {\n /// # Example\n ///\n /// ```\n-/// let a = 3i;\n-/// let b = 1i + 2i;\n+/// let a = 3;\n+/// let b = 1 + 2;\n /// assert_eq!(a, b);\n /// ```\n #[macro_export]\n@@ -141,7 +141,7 @@ macro_rules! assert_eq {\n /// // assert with a custom message\n /// # let x = true;\n /// debug_assert!(x, \"x wasn't true!\");\n-/// # let a = 3i; let b = 27i;\n+/// # let a = 3; let b = 27;\n /// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n@@ -162,8 +162,8 @@ macro_rules! debug_assert {\n /// # Example\n ///\n /// ```\n-/// let a = 3i;\n-/// let b = 1i + 2i;\n+/// let a = 3;\n+/// let b = 1 + 2;\n /// debug_assert_eq!(a, b);\n /// ```\n #[macro_export]\n@@ -238,7 +238,7 @@ macro_rules! unimplemented {\n /// ```\n /// format!(\"test\");\n /// format!(\"hello {}\", \"world!\");\n-/// format!(\"x = {}, y = {y}\", 10i, y = 30i);\n+/// format!(\"x = {}, y = {y}\", 10, y = 30);\n /// ```\n #[macro_export]\n #[stable]\n@@ -338,7 +338,7 @@ macro_rules! vec {\n /// let (tx1, rx1) = channel();\n /// let (tx2, rx2) = channel();\n /// # fn long_running_task() {}\n-/// # fn calculate_the_answer() -> int { 42i }\n+/// # fn calculate_the_answer() -> int { 42 }\n ///\n /// Thread::spawn(move|| { long_running_task(); tx1.send(()) }).detach();\n /// Thread::spawn(move|| { tx2.send(calculate_the_answer()) }).detach();\n@@ -507,7 +507,7 @@ pub mod builtin {\n     /// # Example\n     ///\n     /// ```\n-    /// let s = concat!(\"test\", 10i, 'b', true);\n+    /// let s = concat!(\"test\", 10, 'b', true);\n     /// assert_eq!(s, \"test10btrue\");\n     /// ```\n     #[macro_export]"}, {"sha": "338cadafff724e2de23b7832cf8d69535d1e7f5b", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 695, "deletions": 725, "changes": 1420, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -8,7 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Multi-producer, single-consumer communication primitives threads\n+//! Communication primitives for concurrent tasks\n+//!\n+//! Rust makes it very difficult to share data among tasks to prevent race\n+//! conditions and to improve parallelism, but there is often a need for\n+//! communication between concurrent tasks. The primitives defined in this\n+//! module are the building blocks for synchronization in rust.\n //!\n //! This module provides message-based communication over channels, concretely\n //! defined among three types:\n@@ -18,10 +23,12 @@\n //! * `Receiver`\n //!\n //! A `Sender` or `SyncSender` is used to send data to a `Receiver`. Both\n-//! senders are clone-able (multi-producer) such that many threads can send\n-//! simultaneously to one receiver (single-consumer).\n+//! senders are clone-able such that many tasks can send simultaneously to one\n+//! receiver.  These channels are *task blocking*, not *thread blocking*. This\n+//! means that if one task is blocked on a channel, other tasks can continue to\n+//! make progress.\n //!\n-//! These channels come in two flavors:\n+//! Rust channels come in one of two flavors:\n //!\n //! 1. An asynchronous, infinitely buffered channel. The `channel()` function\n //!    will return a `(Sender, Receiver)` tuple where all sends will be\n@@ -36,39 +43,36 @@\n //!    \"rendezvous\" channel where each sender atomically hands off a message to\n //!    a receiver.\n //!\n-//! ## Disconnection\n+//! ## Panic Propagation\n //!\n-//! The send and receive operations on channels will all return a `Result`\n-//! indicating whether the operation succeeded or not. An unsuccessful operation\n-//! is normally indicative of the other half of a channel having \"hung up\" by\n-//! being dropped in its corresponding thread.\n+//! In addition to being a core primitive for communicating in rust, channels\n+//! are the points at which panics are propagated among tasks.  Whenever the one\n+//! half of channel is closed, the other half will have its next operation\n+//! `panic!`. The purpose of this is to allow propagation of panics among tasks\n+//! that are linked to one another via channels.\n //!\n-//! Once half of a channel has been deallocated, most operations can no longer\n-//! continue to make progress, so `Err` will be returned. Many applications will\n-//! continue to `unwrap()` the results returned from this module, instigating a\n-//! propagation of failure among threads if one unexpectedly dies.\n+//! There are methods on both of senders and receivers to perform their\n+//! respective operations without panicking, however.\n //!\n-//! # Examples\n+//! # Example\n //!\n //! Simple usage:\n //!\n //! ```\n //! use std::thread::Thread;\n-//! use std::sync::mpsc::channel;\n //!\n //! // Create a simple streaming channel\n //! let (tx, rx) = channel();\n //! Thread::spawn(move|| {\n-//!     tx.send(10i).unwrap();\n+//!     tx.send(10);\n //! }).detach();\n-//! assert_eq!(rx.recv().unwrap(), 10i);\n+//! assert_eq!(rx.recv(), 10);\n //! ```\n //!\n //! Shared usage:\n //!\n //! ```\n //! use std::thread::Thread;\n-//! use std::sync::mpsc::channel;\n //!\n //! // Create a shared channel that can be sent along from many threads\n //! // where tx is the sending half (tx for transmission), and rx is the receiving\n@@ -77,40 +81,37 @@\n //! for i in range(0i, 10i) {\n //!     let tx = tx.clone();\n //!     Thread::spawn(move|| {\n-//!         tx.send(i).unwrap();\n+//!         tx.send(i);\n //!     }).detach()\n //! }\n //!\n //! for _ in range(0i, 10i) {\n-//!     let j = rx.recv().unwrap();\n+//!     let j = rx.recv();\n //!     assert!(0 <= j && j < 10);\n //! }\n //! ```\n //!\n //! Propagating panics:\n //!\n-//! ```\n-//! use std::sync::mpsc::channel;\n-//!\n-//! // The call to recv() will return an error because the channel has already\n-//! // hung up (or been deallocated)\n+//! ```should_fail\n+//! // The call to recv() will panic!() because the channel has already hung\n+//! // up (or been deallocated)\n //! let (tx, rx) = channel::<int>();\n //! drop(tx);\n-//! assert!(rx.recv().is_err());\n+//! rx.recv();\n //! ```\n //!\n //! Synchronous channels:\n //!\n //! ```\n //! use std::thread::Thread;\n-//! use std::sync::mpsc::sync_channel;\n //!\n //! let (tx, rx) = sync_channel::<int>(0);\n //! Thread::spawn(move|| {\n //!     // This will wait for the parent task to start receiving\n-//!     tx.send(53).unwrap();\n+//!     tx.send(53);\n //! }).detach();\n-//! rx.recv().unwrap();\n+//! rx.recv();\n //! ```\n //!\n //! Reading from a channel with a timeout requires to use a Timer together\n@@ -119,7 +120,6 @@\n //! after 10 seconds no matter what:\n //!\n //! ```no_run\n-//! use std::sync::mpsc::channel;\n //! use std::io::timer::Timer;\n //! use std::time::Duration;\n //!\n@@ -129,8 +129,8 @@\n //!\n //! loop {\n //!     select! {\n-//!         val = rx.recv() => println!(\"Received {}\", val.unwrap()),\n-//!         _ = timeout.recv() => {\n+//!         val = rx.recv() => println!(\"Received {}\", val),\n+//!         () = timeout.recv() => {\n //!             println!(\"timed out, total time was more than 10 seconds\");\n //!             break;\n //!         }\n@@ -143,7 +143,6 @@\n //! has been inactive for 5 seconds:\n //!\n //! ```no_run\n-//! use std::sync::mpsc::channel;\n //! use std::io::timer::Timer;\n //! use std::time::Duration;\n //!\n@@ -154,8 +153,8 @@\n //!     let timeout = timer.oneshot(Duration::seconds(5));\n //!\n //!     select! {\n-//!         val = rx.recv() => println!(\"Received {}\", val.unwrap()),\n-//!         _ = timeout.recv() => {\n+//!         val = rx.recv() => println!(\"Received {}\", val),\n+//!         () = timeout.recv() => {\n //!             println!(\"timed out, no message received in 5 seconds\");\n //!             break;\n //!         }\n@@ -313,19 +312,38 @@\n // And now that you've seen all the races that I found and attempted to fix,\n // here's the code for you to find some more!\n \n-use prelude::v1::*;\n+use core::prelude::*;\n \n-use sync::Arc;\n-use fmt;\n-use kinds::marker;\n-use mem;\n-use cell::UnsafeCell;\n+pub use self::TryRecvError::*;\n+pub use self::TrySendError::*;\n+\n+use alloc::arc::Arc;\n+use core::kinds;\n+use core::kinds::marker;\n+use core::mem;\n+use core::cell::UnsafeCell;\n \n pub use self::select::{Select, Handle};\n use self::select::StartResult;\n use self::select::StartResult::*;\n use self::blocking::SignalToken;\n \n+macro_rules! test {\n+    { fn $name:ident() $b:block $(#[$a:meta])*} => (\n+        mod $name {\n+            #![allow(unused_imports)]\n+\n+            use super::*;\n+            use comm::*;\n+            use thread::Thread;\n+            use prelude::{Ok, Err, spawn, range, drop, Box, Some, None, Option};\n+            use prelude::{Vec, Buffer, from_str, Clone};\n+\n+            $(#[$a])* #[test] fn f() { $b }\n+        }\n+    )\n+}\n+\n mod blocking;\n mod oneshot;\n mod select;\n@@ -337,7 +355,7 @@ mod spsc_queue;\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n /// one task\n-#[stable]\n+#[unstable]\n pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n }\n@@ -349,14 +367,14 @@ unsafe impl<T:Send> Send for Receiver<T> { }\n /// An iterator over messages on a receiver, this iterator will block\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n-#[stable]\n-pub struct Iter<'a, T:'a> {\n+#[unstable]\n+pub struct Messages<'a, T:'a> {\n     rx: &'a Receiver<T>\n }\n \n /// The sending-half of Rust's asynchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n-#[stable]\n+#[unstable]\n pub struct Sender<T> {\n     inner: UnsafeCell<Flavor<T>>,\n }\n@@ -367,64 +385,41 @@ unsafe impl<T:Send> Send for Sender<T> { }\n \n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n-#[stable]\n+#[unstable = \"this type may be renamed, but it will always exist\"]\n pub struct SyncSender<T> {\n     inner: Arc<RacyCell<sync::Packet<T>>>,\n     // can't share in an arc\n     _marker: marker::NoSync,\n }\n \n-/// An error returned from the `send` function on channels.\n-///\n-/// A `send` operation can only fail if the receiving end of a channel is\n-/// disconnected, implying that the data could never be received. The error\n-/// contains the data being sent as a payload so it can be recovered.\n-#[derive(PartialEq, Eq)]\n-#[stable]\n-pub struct SendError<T>(pub T);\n-\n-/// An error returned from the `recv` function on a `Receiver`.\n-///\n-/// The `recv` operation can only fail if the sending half of a channel is\n-/// disconnected, implying that no further messages will ever be received.\n-#[derive(PartialEq, Eq, Clone, Copy)]\n-#[stable]\n-pub struct RecvError;\n-\n /// This enumeration is the list of the possible reasons that try_recv could not\n /// return data when called.\n-#[derive(PartialEq, Clone, Copy)]\n-#[stable]\n+#[deriving(PartialEq, Clone, Copy, Show)]\n+#[experimental = \"this is likely to be removed in changing try_recv()\"]\n pub enum TryRecvError {\n     /// This channel is currently empty, but the sender(s) have not yet\n     /// disconnected, so data may yet become available.\n-    #[stable]\n     Empty,\n-\n     /// This channel's sending half has become disconnected, and there will\n     /// never be any more data received on this channel\n-    #[stable]\n     Disconnected,\n }\n \n /// This enumeration is the list of the possible error outcomes for the\n /// `SyncSender::try_send` method.\n-#[derive(PartialEq, Clone)]\n-#[stable]\n+#[deriving(PartialEq, Clone, Show)]\n+#[experimental = \"this is likely to be removed in changing try_send()\"]\n pub enum TrySendError<T> {\n     /// The data could not be sent on the channel because it would require that\n     /// the callee block to send the data.\n     ///\n     /// If this is a buffered channel, then the buffer is full at this time. If\n     /// this is not a buffered channel, then there is no receiver available to\n     /// acquire the data.\n-    #[stable]\n     Full(T),\n-\n     /// This channel's receiving half has disconnected, so the data could not be\n     /// sent. The data is returned back to the callee in this case.\n-    #[stable]\n-    Disconnected(T),\n+    RecvDisconnected(T),\n }\n \n enum Flavor<T> {\n@@ -463,7 +458,6 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// # Example\n ///\n /// ```\n-/// use std::sync::mpsc::channel;\n /// use std::thread::Thread;\n ///\n /// // tx is is the sending half (tx for transmission), and rx is the receiving\n@@ -473,15 +467,15 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// // Spawn off an expensive computation\n /// Thread::spawn(move|| {\n /// #   fn expensive_computation() {}\n-///     tx.send(expensive_computation()).unwrap();\n+///     tx.send(expensive_computation());\n /// }).detach();\n ///\n /// // Do some useful work for awhile\n ///\n /// // Let's see what that answer was\n-/// println!(\"{}\", rx.recv().unwrap());\n+/// println!(\"{}\", rx.recv());\n /// ```\n-#[stable]\n+#[unstable]\n pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n     let a = Arc::new(RacyCell::new(oneshot::Packet::new()));\n     (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))\n@@ -505,23 +499,23 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// # Example\n ///\n /// ```\n-/// use std::sync::mpsc::sync_channel;\n /// use std::thread::Thread;\n ///\n /// let (tx, rx) = sync_channel(1);\n ///\n /// // this returns immediately\n-/// tx.send(1i).unwrap();\n+/// tx.send(1);\n ///\n /// Thread::spawn(move|| {\n ///     // this will block until the previous message has been received\n-///     tx.send(2i).unwrap();\n+///     tx.send(2);\n /// }).detach();\n ///\n-/// assert_eq!(rx.recv().unwrap(), 1i);\n-/// assert_eq!(rx.recv().unwrap(), 2i);\n+/// assert_eq!(rx.recv(), 1);\n+/// assert_eq!(rx.recv(), 2);\n /// ```\n-#[stable]\n+#[unstable = \"this function may be renamed to more accurately reflect the type \\\n+              of channel that is is creating\"]\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n     let a = Arc::new(RacyCell::new(sync::Packet::new(bound)));\n     (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n@@ -538,6 +532,33 @@ impl<T: Send> Sender<T> {\n         }\n     }\n \n+    /// Sends a value along this channel to be received by the corresponding\n+    /// receiver.\n+    ///\n+    /// Rust channels are infinitely buffered so this method will never block.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the other end of the channel has hung up.\n+    /// This means that if the corresponding receiver has fallen out of scope,\n+    /// this function will trigger a panic message saying that a message is\n+    /// being sent on a closed channel.\n+    ///\n+    /// Note that if this function does *not* panic, it does not mean that the\n+    /// data will be successfully received. All sends are placed into a queue,\n+    /// so it is possible for a send to succeed (the other end is alive), but\n+    /// then the other end could immediately disconnect.\n+    ///\n+    /// The purpose of this functionality is to propagate panics among tasks.\n+    /// If a panic is not desired, then consider using the `send_opt` method\n+    #[experimental = \"this function is being considered candidate for removal \\\n+                      to adhere to the general guidelines of rust\"]\n+    pub fn send(&self, t: T) {\n+        if self.send_opt(t).is_err() {\n+            panic!(\"sending on a closed channel\");\n+        }\n+    }\n+\n     /// Attempts to send a value on this channel, returning it back if it could\n     /// not be sent.\n     ///\n@@ -549,34 +570,37 @@ impl<T: Send> Sender<T> {\n     /// will be received.  It is possible for the corresponding receiver to\n     /// hang up immediately after this function returns `Ok`.\n     ///\n-    /// This method will never block the current thread.\n+    /// Like `send`, this method will never block.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method will never panic, it will return the message back to the\n+    /// caller if the other end is disconnected\n     ///\n     /// # Example\n     ///\n     /// ```\n-    /// use std::sync::mpsc::channel;\n-    ///\n     /// let (tx, rx) = channel();\n     ///\n     /// // This send is always successful\n-    /// tx.send(1i).unwrap();\n+    /// assert_eq!(tx.send_opt(1), Ok(()));\n     ///\n     /// // This send will fail because the receiver is gone\n     /// drop(rx);\n-    /// assert_eq!(tx.send(1i).err().unwrap().0, 1);\n+    /// assert_eq!(tx.send_opt(1), Err(1));\n     /// ```\n-    pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n+    #[unstable = \"this function may be renamed to send() in the future\"]\n+    pub fn send_opt(&self, t: T) -> Result<(), T> {\n         let (new_inner, ret) = match *unsafe { self.inner() } {\n             Flavor::Oneshot(ref p) => {\n                 unsafe {\n                     let p = p.get();\n                     if !(*p).sent() {\n-                        return (*p).send(t).map_err(SendError);\n+                        return (*p).send(t);\n                     } else {\n                         let a =\n                             Arc::new(RacyCell::new(stream::Packet::new()));\n-                        let rx = Receiver::new(Flavor::Stream(a.clone()));\n-                        match (*p).upgrade(rx) {\n+                        match (*p).upgrade(Receiver::new(Flavor::Stream(a.clone()))) {\n                             oneshot::UpSuccess => {\n                                 let ret = (*a.get()).send(t);\n                                 (a, ret)\n@@ -594,20 +618,16 @@ impl<T: Send> Sender<T> {\n                     }\n                 }\n             }\n-            Flavor::Stream(ref p) => return unsafe {\n-                (*p.get()).send(t).map_err(SendError)\n-            },\n-            Flavor::Shared(ref p) => return unsafe {\n-                (*p.get()).send(t).map_err(SendError)\n-            },\n+            Flavor::Stream(ref p) => return unsafe { (*p.get()).send(t) },\n+            Flavor::Shared(ref p) => return unsafe { (*p.get()).send(t) },\n             Flavor::Sync(..) => unreachable!(),\n         };\n \n         unsafe {\n             let tmp = Sender::new(Flavor::Stream(new_inner));\n             mem::swap(self.inner_mut(), tmp.inner_mut());\n         }\n-        ret.map_err(SendError)\n+        return ret;\n     }\n }\n \n@@ -619,8 +639,7 @@ impl<T: Send> Clone for Sender<T> {\n                 let a = Arc::new(RacyCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n-                    let rx = Receiver::new(Flavor::Shared(a.clone()));\n-                    match (*p.get()).upgrade(rx) {\n+                    match (*p.get()).upgrade(Receiver::new(Flavor::Shared(a.clone()))) {\n                         oneshot::UpSuccess |\n                         oneshot::UpDisconnected => (a, None, guard),\n                         oneshot::UpWoke(task) => (a, Some(task), guard)\n@@ -631,8 +650,7 @@ impl<T: Send> Clone for Sender<T> {\n                 let a = Arc::new(RacyCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n-                    let rx = Receiver::new(Flavor::Shared(a.clone()));\n-                    match (*p.get()).upgrade(rx) {\n+                    match (*p.get()).upgrade(Receiver::new(Flavor::Shared(a.clone()))) {\n                         stream::UpSuccess |\n                         stream::UpDisconnected => (a, None, guard),\n                         stream::UpWoke(task) => (a, Some(task), guard),\n@@ -683,29 +701,59 @@ impl<T: Send> SyncSender<T> {\n     /// available or a receiver is available to hand off the message to.\n     ///\n     /// Note that a successful send does *not* guarantee that the receiver will\n-    /// ever see the data if there is a buffer on this channel. Items may be\n+    /// ever see the data if there is a buffer on this channel. Messages may be\n     /// enqueued in the internal buffer for the receiver to receive at a later\n     /// time. If the buffer size is 0, however, it can be guaranteed that the\n     /// receiver has indeed received the data if this function returns success.\n     ///\n-    /// This function will never panic, but it may return `Err` if the\n-    /// `Receiver` has disconnected and is no longer able to receive\n-    /// information.\n-    #[stable]\n-    pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n-        unsafe { (*self.inner.get()).send(t).map_err(SendError) }\n+    /// # Panics\n+    ///\n+    /// Similarly to `Sender::send`, this function will panic if the\n+    /// corresponding `Receiver` for this channel has disconnected. This\n+    /// behavior is used to propagate panics among tasks.\n+    ///\n+    /// If a panic is not desired, you can achieve the same semantics with the\n+    /// `SyncSender::send_opt` method which will not panic if the receiver\n+    /// disconnects.\n+    #[experimental = \"this function is being considered candidate for removal \\\n+                      to adhere to the general guidelines of rust\"]\n+    pub fn send(&self, t: T) {\n+        if self.send_opt(t).is_err() {\n+            panic!(\"sending on a closed channel\");\n+        }\n+    }\n+\n+    /// Send a value on a channel, returning it back if the receiver\n+    /// disconnected\n+    ///\n+    /// This method will *block* to send the value `t` on the channel, but if\n+    /// the value could not be sent due to the receiver disconnecting, the value\n+    /// is returned back to the callee. This function is similar to `try_send`,\n+    /// except that it will block if the channel is currently full.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function cannot panic.\n+    #[unstable = \"this function may be renamed to send() in the future\"]\n+    pub fn send_opt(&self, t: T) -> Result<(), T> {\n+        unsafe { (*self.inner.get()).send(t) }\n     }\n \n     /// Attempts to send a value on this channel without blocking.\n     ///\n-    /// This method differs from `send` by returning immediately if the\n+    /// This method differs from `send_opt` by returning immediately if the\n     /// channel's buffer is full or no receiver is waiting to acquire some\n-    /// data. Compared with `send`, this function has two failure cases\n+    /// data. Compared with `send_opt`, this function has two failure cases\n     /// instead of one (one for disconnection, one for a full buffer).\n     ///\n     /// See `SyncSender::send` for notes about guarantees of whether the\n     /// receiver has received the data or not if this function is successful.\n-    #[stable]\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function cannot panic\n+    #[unstable = \"the return type of this function is candidate for \\\n+                  modification\"]\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n         unsafe { (*self.inner.get()).try_send(t) }\n     }\n@@ -735,6 +783,34 @@ impl<T: Send> Receiver<T> {\n         Receiver { inner: UnsafeCell::new(inner) }\n     }\n \n+    /// Blocks waiting for a value on this receiver\n+    ///\n+    /// This function will block if necessary to wait for a corresponding send\n+    /// on the channel from its paired `Sender` structure. This receiver will\n+    /// be woken up when data is ready, and the data will be returned.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Similar to channels, this method will trigger a task panic if the\n+    /// other end of the channel has hung up (been deallocated). The purpose of\n+    /// this is to propagate panics among tasks.\n+    ///\n+    /// If a panic is not desired, then there are two options:\n+    ///\n+    /// * If blocking is still desired, the `recv_opt` method will return `None`\n+    ///   when the other end hangs up\n+    ///\n+    /// * If blocking is not desired, then the `try_recv` method will attempt to\n+    ///   peek at a value on this receiver.\n+    #[experimental = \"this function is being considered candidate for removal \\\n+                      to adhere to the general guidelines of rust\"]\n+    pub fn recv(&self) -> T {\n+        match self.recv_opt() {\n+            Ok(t) => t,\n+            Err(()) => panic!(\"receiving on a closed channel\"),\n+        }\n+    }\n+\n     /// Attempts to return a pending value on this receiver without blocking\n     ///\n     /// This method will never block the caller in order to wait for data to\n@@ -743,46 +819,42 @@ impl<T: Send> Receiver<T> {\n     ///\n     /// This is useful for a flavor of \"optimistic check\" before deciding to\n     /// block on a receiver.\n-    #[stable]\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function cannot panic.\n+    #[unstable = \"the return type of this function may be altered\"]\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n                 Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n-                        Err(oneshot::Empty) => return Err(TryRecvError::Empty),\n-                        Err(oneshot::Disconnected) => {\n-                            return Err(TryRecvError::Disconnected)\n-                        }\n+                        Err(oneshot::Empty) => return Err(Empty),\n+                        Err(oneshot::Disconnected) => return Err(Disconnected),\n                         Err(oneshot::Upgraded(rx)) => rx,\n                     }\n                 }\n                 Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n-                        Err(stream::Empty) => return Err(TryRecvError::Empty),\n-                        Err(stream::Disconnected) => {\n-                            return Err(TryRecvError::Disconnected)\n-                        }\n+                        Err(stream::Empty) => return Err(Empty),\n+                        Err(stream::Disconnected) => return Err(Disconnected),\n                         Err(stream::Upgraded(rx)) => rx,\n                     }\n                 }\n                 Flavor::Shared(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n-                        Err(shared::Empty) => return Err(TryRecvError::Empty),\n-                        Err(shared::Disconnected) => {\n-                            return Err(TryRecvError::Disconnected)\n-                        }\n+                        Err(shared::Empty) => return Err(Empty),\n+                        Err(shared::Disconnected) => return Err(Disconnected),\n                     }\n                 }\n                 Flavor::Sync(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Ok(t),\n-                        Err(sync::Empty) => return Err(TryRecvError::Empty),\n-                        Err(sync::Disconnected) => {\n-                            return Err(TryRecvError::Disconnected)\n-                        }\n+                        Err(sync::Empty) => return Err(Empty),\n+                        Err(sync::Disconnected) => return Err(Disconnected),\n                     }\n                 }\n             };\n@@ -793,47 +865,46 @@ impl<T: Send> Receiver<T> {\n         }\n     }\n \n-    /// Attempt to wait for a value on this receiver, returning an error if the\n+    /// Attempt to wait for a value on this receiver, but does not panic if the\n     /// corresponding channel has hung up.\n     ///\n-    /// This function will always block the current thread if there is no data\n-    /// available and it's possible for more data to be sent. Once a message is\n-    /// sent to the corresponding `Sender`, then this receiver will wake up and\n-    /// return that message.\n+    /// This implementation of iterators for ports will always block if there is\n+    /// not data available on the receiver, but it will not panic in the case\n+    /// that the channel has been deallocated.\n     ///\n-    /// If the corresponding `Sender` has disconnected, or it disconnects while\n-    /// this call is blocking, this call will wake up and return `Err` to\n-    /// indicate that no more messages can ever be received on this channel.\n-    #[stable]\n-    pub fn recv(&self) -> Result<T, RecvError> {\n+    /// In other words, this function has the same semantics as the `recv`\n+    /// method except for the panic aspect.\n+    ///\n+    /// If the channel has hung up, then `Err` is returned. Otherwise `Ok` of\n+    /// the value found on the receiver is returned.\n+    #[unstable = \"this function may be renamed to recv()\"]\n+    pub fn recv_opt(&self) -> Result<T, ()> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n                 Flavor::Oneshot(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(oneshot::Empty) => return unreachable!(),\n-                        Err(oneshot::Disconnected) => return Err(RecvError),\n+                        Err(oneshot::Disconnected) => return Err(()),\n                         Err(oneshot::Upgraded(rx)) => rx,\n                     }\n                 }\n                 Flavor::Stream(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(stream::Empty) => return unreachable!(),\n-                        Err(stream::Disconnected) => return Err(RecvError),\n+                        Err(stream::Disconnected) => return Err(()),\n                         Err(stream::Upgraded(rx)) => rx,\n                     }\n                 }\n                 Flavor::Shared(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Ok(t),\n                         Err(shared::Empty) => return unreachable!(),\n-                        Err(shared::Disconnected) => return Err(RecvError),\n+                        Err(shared::Disconnected) => return Err(()),\n                     }\n                 }\n-                Flavor::Sync(ref p) => return unsafe {\n-                    (*p.get()).recv().map_err(|()| RecvError)\n-                }\n+                Flavor::Sync(ref p) => return unsafe { (*p.get()).recv() }\n             };\n             unsafe {\n                 mem::swap(self.inner_mut(), new_port.inner_mut());\n@@ -843,9 +914,9 @@ impl<T: Send> Receiver<T> {\n \n     /// Returns an iterator that will block waiting for messages, but never\n     /// `panic!`. It will return `None` when the channel has hung up.\n-    #[stable]\n-    pub fn iter(&self) -> Iter<T> {\n-        Iter { rx: self }\n+    #[unstable]\n+    pub fn iter<'a>(&'a self) -> Messages<'a, T> {\n+        Messages { rx: self }\n     }\n }\n \n@@ -936,10 +1007,8 @@ impl<T: Send> select::Packet for Receiver<T> {\n }\n \n #[unstable]\n-impl<'a, T: Send> Iterator for Iter<'a, T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n+impl<'a, T: Send> Iterator<T> for Messages<'a, T> {\n+    fn next(&mut self) -> Option<T> { self.rx.recv_opt().ok() }\n }\n \n #[unsafe_destructor]\n@@ -972,425 +1041,368 @@ impl<T> RacyCell<T> {\n \n unsafe impl<T:Send> Send for RacyCell<T> { }\n \n-unsafe impl<T> Sync for RacyCell<T> { } // Oh dear\n-\n-impl<T> fmt::Show for SendError<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        \"sending on a closed channel\".fmt(f)\n-    }\n-}\n-\n-impl<T> fmt::Show for TrySendError<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            TrySendError::Full(..) => {\n-                \"sending on a full channel\".fmt(f)\n-            }\n-            TrySendError::Disconnected(..) => {\n-                \"sending on a closed channel\".fmt(f)\n-            }\n-        }\n-    }\n-}\n-\n-impl fmt::Show for RecvError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        \"receiving on a closed channel\".fmt(f)\n-    }\n-}\n+unsafe impl<T> kinds::Sync for RacyCell<T> { } // Oh dear\n \n-impl fmt::Show for TryRecvError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            TryRecvError::Empty => {\n-                \"receiving on an empty channel\".fmt(f)\n-            }\n-            TryRecvError::Disconnected => {\n-                \"receiving on a closed channel\".fmt(f)\n-            }\n-        }\n-    }\n-}\n \n #[cfg(test)]\n mod test {\n-    use prelude::v1::*;\n-\n-    use os;\n     use super::*;\n-    use thread::Thread;\n+    use prelude::{spawn, range, Some, None, from_str, Clone, Str};\n+    use os;\n \n     pub fn stress_factor() -> uint {\n         match os::getenv(\"RUST_TEST_STRESS\") {\n-            Some(val) => val.parse().unwrap(),\n+            Some(val) => from_str::<uint>(val.as_slice()).unwrap(),\n             None => 1,\n         }\n     }\n \n-    #[test]\n-    fn smoke() {\n+    test! { fn smoke() {\n         let (tx, rx) = channel::<int>();\n-        tx.send(1).unwrap();\n-        assert_eq!(rx.recv().unwrap(), 1);\n-    }\n+        tx.send(1);\n+        assert_eq!(rx.recv(), 1);\n+    } }\n \n-    #[test]\n-    fn drop_full() {\n+    test! { fn drop_full() {\n         let (tx, _rx) = channel();\n-        tx.send(box 1i).unwrap();\n-    }\n+        tx.send(box 1i);\n+    } }\n \n-    #[test]\n-    fn drop_full_shared() {\n+    test! { fn drop_full_shared() {\n         let (tx, _rx) = channel();\n         drop(tx.clone());\n         drop(tx.clone());\n-        tx.send(box 1i).unwrap();\n-    }\n+        tx.send(box 1i);\n+    } }\n \n-    #[test]\n-    fn smoke_shared() {\n+    test! { fn smoke_shared() {\n         let (tx, rx) = channel::<int>();\n-        tx.send(1).unwrap();\n-        assert_eq!(rx.recv().unwrap(), 1);\n+        tx.send(1);\n+        assert_eq!(rx.recv(), 1);\n         let tx = tx.clone();\n-        tx.send(1).unwrap();\n-        assert_eq!(rx.recv().unwrap(), 1);\n-    }\n+        tx.send(1);\n+        assert_eq!(rx.recv(), 1);\n+    } }\n \n-    #[test]\n-    fn smoke_threads() {\n+    test! { fn smoke_threads() {\n         let (tx, rx) = channel::<int>();\n-        let _t = Thread::spawn(move|| {\n-            tx.send(1).unwrap();\n+        spawn(move|| {\n+            tx.send(1);\n         });\n-        assert_eq!(rx.recv().unwrap(), 1);\n-    }\n+        assert_eq!(rx.recv(), 1);\n+    } }\n \n-    #[test]\n-    fn smoke_port_gone() {\n+    test! { fn smoke_port_gone() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n-        assert!(tx.send(1).is_err());\n-    }\n+        tx.send(1);\n+    } #[should_fail] }\n \n-    #[test]\n-    fn smoke_shared_port_gone() {\n+    test! { fn smoke_shared_port_gone() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n-        assert!(tx.send(1).is_err())\n-    }\n+        tx.send(1);\n+    } #[should_fail] }\n \n-    #[test]\n-    fn smoke_shared_port_gone2() {\n+    test! { fn smoke_shared_port_gone2() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n         let tx2 = tx.clone();\n         drop(tx);\n-        assert!(tx2.send(1).is_err());\n-    }\n+        tx2.send(1);\n+    } #[should_fail] }\n \n-    #[test]\n-    fn port_gone_concurrent() {\n+    test! { fn port_gone_concurrent() {\n         let (tx, rx) = channel::<int>();\n-        let _t = Thread::spawn(move|| {\n-            rx.recv().unwrap();\n+        spawn(move|| {\n+            rx.recv();\n         });\n-        while tx.send(1).is_ok() {}\n-    }\n+        loop { tx.send(1) }\n+    } #[should_fail] }\n \n-    #[test]\n-    fn port_gone_concurrent_shared() {\n+    test! { fn port_gone_concurrent_shared() {\n         let (tx, rx) = channel::<int>();\n         let tx2 = tx.clone();\n-        let _t = Thread::spawn(move|| {\n-            rx.recv().unwrap();\n+        spawn(move|| {\n+            rx.recv();\n         });\n-        while tx.send(1).is_ok() && tx2.send(1).is_ok() {}\n-    }\n+        loop {\n+            tx.send(1);\n+            tx2.send(1);\n+        }\n+    } #[should_fail] }\n \n-    #[test]\n-    fn smoke_chan_gone() {\n+    test! { fn smoke_chan_gone() {\n         let (tx, rx) = channel::<int>();\n         drop(tx);\n-        assert!(rx.recv().is_err());\n-    }\n+        rx.recv();\n+    } #[should_fail] }\n \n-    #[test]\n-    fn smoke_chan_gone_shared() {\n+    test! { fn smoke_chan_gone_shared() {\n         let (tx, rx) = channel::<()>();\n         let tx2 = tx.clone();\n         drop(tx);\n         drop(tx2);\n-        assert!(rx.recv().is_err());\n-    }\n+        rx.recv();\n+    } #[should_fail] }\n \n-    #[test]\n-    fn chan_gone_concurrent() {\n+    test! { fn chan_gone_concurrent() {\n         let (tx, rx) = channel::<int>();\n-        let _t = Thread::spawn(move|| {\n-            tx.send(1).unwrap();\n-            tx.send(1).unwrap();\n+        spawn(move|| {\n+            tx.send(1);\n+            tx.send(1);\n         });\n-        while rx.recv().is_ok() {}\n-    }\n+        loop { rx.recv(); }\n+    } #[should_fail] }\n \n-    #[test]\n-    fn stress() {\n+    test! { fn stress() {\n         let (tx, rx) = channel::<int>();\n-        let t = Thread::spawn(move|| {\n-            for _ in range(0u, 10000) { tx.send(1i).unwrap(); }\n+        spawn(move|| {\n+            for _ in range(0u, 10000) { tx.send(1i); }\n         });\n         for _ in range(0u, 10000) {\n-            assert_eq!(rx.recv().unwrap(), 1);\n+            assert_eq!(rx.recv(), 1);\n         }\n-        t.join().ok().unwrap();\n-    }\n+    } }\n \n-    #[test]\n-    fn stress_shared() {\n+    test! { fn stress_shared() {\n         static AMT: uint = 10000;\n         static NTHREADS: uint = 8;\n         let (tx, rx) = channel::<int>();\n+        let (dtx, drx) = channel::<()>();\n \n-        let t = Thread::spawn(move|| {\n+        spawn(move|| {\n             for _ in range(0, AMT * NTHREADS) {\n-                assert_eq!(rx.recv().unwrap(), 1);\n+                assert_eq!(rx.recv(), 1);\n             }\n             match rx.try_recv() {\n                 Ok(..) => panic!(),\n                 _ => {}\n             }\n+            dtx.send(());\n         });\n \n         for _ in range(0, NTHREADS) {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n-                for _ in range(0, AMT) { tx.send(1).unwrap(); }\n-            }).detach();\n+            spawn(move|| {\n+                for _ in range(0, AMT) { tx.send(1); }\n+            });\n         }\n         drop(tx);\n-        t.join().ok().unwrap();\n-    }\n+        drx.recv();\n+    } }\n \n     #[test]\n     fn send_from_outside_runtime() {\n         let (tx1, rx1) = channel::<()>();\n         let (tx2, rx2) = channel::<int>();\n-        let t1 = Thread::spawn(move|| {\n-            tx1.send(()).unwrap();\n+        let (tx3, rx3) = channel::<()>();\n+        let tx4 = tx3.clone();\n+        spawn(move|| {\n+            tx1.send(());\n             for _ in range(0i, 40) {\n-                assert_eq!(rx2.recv().unwrap(), 1);\n+                assert_eq!(rx2.recv(), 1);\n             }\n+            tx3.send(());\n         });\n-        rx1.recv().unwrap();\n-        let t2 = Thread::spawn(move|| {\n+        rx1.recv();\n+        spawn(move|| {\n             for _ in range(0i, 40) {\n-                tx2.send(1).unwrap();\n+                tx2.send(1);\n             }\n+            tx4.send(());\n         });\n-        t1.join().ok().unwrap();\n-        t2.join().ok().unwrap();\n+        rx3.recv();\n+        rx3.recv();\n     }\n \n     #[test]\n     fn recv_from_outside_runtime() {\n         let (tx, rx) = channel::<int>();\n-        let t = Thread::spawn(move|| {\n+        let (dtx, drx) = channel();\n+        spawn(move|| {\n             for _ in range(0i, 40) {\n-                assert_eq!(rx.recv().unwrap(), 1);\n+                assert_eq!(rx.recv(), 1);\n             }\n+            dtx.send(());\n         });\n         for _ in range(0u, 40) {\n-            tx.send(1).unwrap();\n+            tx.send(1);\n         }\n-        t.join().ok().unwrap();\n+        drx.recv();\n     }\n \n     #[test]\n     fn no_runtime() {\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<int>();\n-        let t1 = Thread::spawn(move|| {\n-            assert_eq!(rx1.recv().unwrap(), 1);\n-            tx2.send(2).unwrap();\n+        let (tx3, rx3) = channel::<()>();\n+        let tx4 = tx3.clone();\n+        spawn(move|| {\n+            assert_eq!(rx1.recv(), 1);\n+            tx2.send(2);\n+            tx4.send(());\n         });\n-        let t2 = Thread::spawn(move|| {\n-            tx1.send(1).unwrap();\n-            assert_eq!(rx2.recv().unwrap(), 2);\n+        spawn(move|| {\n+            tx1.send(1);\n+            assert_eq!(rx2.recv(), 2);\n+            tx3.send(());\n         });\n-        t1.join().ok().unwrap();\n-        t2.join().ok().unwrap();\n+        rx3.recv();\n+        rx3.recv();\n     }\n \n-    #[test]\n-    fn oneshot_single_thread_close_port_first() {\n+    test! { fn oneshot_single_thread_close_port_first() {\n         // Simple test of closing without sending\n         let (_tx, rx) = channel::<int>();\n         drop(rx);\n-    }\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_close_chan_first() {\n+    test! { fn oneshot_single_thread_close_chan_first() {\n         // Simple test of closing without sending\n         let (tx, _rx) = channel::<int>();\n         drop(tx);\n-    }\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_send_port_close() {\n+    test! { fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n         let (tx, rx) = channel::<Box<int>>();\n         drop(rx);\n-        assert!(tx.send(box 0).is_err());\n-    }\n+        tx.send(box 0);\n+    } #[should_fail] }\n \n-    #[test]\n-    fn oneshot_single_thread_recv_chan_close() {\n+    test! { fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n         let res = Thread::spawn(move|| {\n             let (tx, rx) = channel::<int>();\n             drop(tx);\n-            rx.recv().unwrap();\n+            rx.recv();\n         }).join();\n         // What is our res?\n         assert!(res.is_err());\n-    }\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_send_then_recv() {\n+    test! { fn oneshot_single_thread_send_then_recv() {\n         let (tx, rx) = channel::<Box<int>>();\n-        tx.send(box 10).unwrap();\n-        assert!(rx.recv().unwrap() == box 10);\n-    }\n+        tx.send(box 10);\n+        assert!(rx.recv() == box 10);\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_try_send_open() {\n+    test! { fn oneshot_single_thread_try_send_open() {\n         let (tx, rx) = channel::<int>();\n-        assert!(tx.send(10).is_ok());\n-        assert!(rx.recv().unwrap() == 10);\n-    }\n+        assert!(tx.send_opt(10).is_ok());\n+        assert!(rx.recv() == 10);\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_try_send_closed() {\n+    test! { fn oneshot_single_thread_try_send_closed() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n-        assert!(tx.send(10).is_err());\n-    }\n+        assert!(tx.send_opt(10).is_err());\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_try_recv_open() {\n+    test! { fn oneshot_single_thread_try_recv_open() {\n         let (tx, rx) = channel::<int>();\n-        tx.send(10).unwrap();\n-        assert!(rx.recv() == Ok(10));\n-    }\n+        tx.send(10);\n+        assert!(rx.recv_opt() == Ok(10));\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_try_recv_closed() {\n+    test! { fn oneshot_single_thread_try_recv_closed() {\n         let (tx, rx) = channel::<int>();\n         drop(tx);\n-        assert!(rx.recv().is_err());\n-    }\n+        assert!(rx.recv_opt() == Err(()));\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_peek_data() {\n+    test! { fn oneshot_single_thread_peek_data() {\n         let (tx, rx) = channel::<int>();\n-        assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n-        tx.send(10).unwrap();\n+        assert_eq!(rx.try_recv(), Err(Empty));\n+        tx.send(10);\n         assert_eq!(rx.try_recv(), Ok(10));\n-    }\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_peek_close() {\n+    test! { fn oneshot_single_thread_peek_close() {\n         let (tx, rx) = channel::<int>();\n         drop(tx);\n-        assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n-        assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n-    }\n+        assert_eq!(rx.try_recv(), Err(Disconnected));\n+        assert_eq!(rx.try_recv(), Err(Disconnected));\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_peek_open() {\n+    test! { fn oneshot_single_thread_peek_open() {\n         let (_tx, rx) = channel::<int>();\n-        assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n-    }\n+        assert_eq!(rx.try_recv(), Err(Empty));\n+    } }\n \n-    #[test]\n-    fn oneshot_multi_task_recv_then_send() {\n+    test! { fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = channel::<Box<int>>();\n-        let _t = Thread::spawn(move|| {\n-            assert!(rx.recv().unwrap() == box 10);\n+        spawn(move|| {\n+            assert!(rx.recv() == box 10);\n         });\n \n-        tx.send(box 10).unwrap();\n-    }\n+        tx.send(box 10);\n+    } }\n \n-    #[test]\n-    fn oneshot_multi_task_recv_then_close() {\n+    test! { fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = channel::<Box<int>>();\n-        let _t = Thread::spawn(move|| {\n+        spawn(move|| {\n             drop(tx);\n         });\n         let res = Thread::spawn(move|| {\n-            assert!(rx.recv().unwrap() == box 10);\n+            assert!(rx.recv() == box 10);\n         }).join();\n         assert!(res.is_err());\n-    }\n+    } }\n \n-    #[test]\n-    fn oneshot_multi_thread_close_stress() {\n+    test! { fn oneshot_multi_thread_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel::<int>();\n-            let _t = Thread::spawn(move|| {\n+            spawn(move|| {\n                 drop(rx);\n             });\n             drop(tx);\n         }\n-    }\n+    } }\n \n-    #[test]\n-    fn oneshot_multi_thread_send_close_stress() {\n+    test! { fn oneshot_multi_thread_send_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel::<int>();\n-            let _t = Thread::spawn(move|| {\n+            spawn(move|| {\n                 drop(rx);\n             });\n             let _ = Thread::spawn(move|| {\n-                tx.send(1).unwrap();\n+                tx.send(1);\n             }).join();\n         }\n-    }\n+    } }\n \n-    #[test]\n-    fn oneshot_multi_thread_recv_close_stress() {\n+    test! { fn oneshot_multi_thread_recv_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel::<int>();\n-            Thread::spawn(move|| {\n+            spawn(move|| {\n                 let res = Thread::spawn(move|| {\n-                    rx.recv().unwrap();\n+                    rx.recv();\n                 }).join();\n                 assert!(res.is_err());\n-            }).detach();\n-            let _t = Thread::spawn(move|| {\n-                Thread::spawn(move|| {\n+            });\n+            spawn(move|| {\n+                spawn(move|| {\n                     drop(tx);\n-                }).detach();\n+                });\n             });\n         }\n-    }\n+    } }\n \n-    #[test]\n-    fn oneshot_multi_thread_send_recv_stress() {\n+    test! { fn oneshot_multi_thread_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel();\n-            let _t = Thread::spawn(move|| {\n-                tx.send(box 10i).unwrap();\n+            spawn(move|| {\n+                tx.send(box 10i);\n+            });\n+            spawn(move|| {\n+                assert!(rx.recv() == box 10i);\n             });\n-            assert!(rx.recv().unwrap() == box 10i);\n         }\n-    }\n+    } }\n \n-    #[test]\n-    fn stream_send_recv_stress() {\n+    test! { fn stream_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel();\n \n@@ -1400,73 +1412,69 @@ mod test {\n             fn send(tx: Sender<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                Thread::spawn(move|| {\n-                    tx.send(box i).unwrap();\n+                spawn(move|| {\n+                    tx.send(box i);\n                     send(tx, i + 1);\n-                }).detach();\n+                });\n             }\n \n             fn recv(rx: Receiver<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                Thread::spawn(move|| {\n-                    assert!(rx.recv().unwrap() == box i);\n+                spawn(move|| {\n+                    assert!(rx.recv() == box i);\n                     recv(rx, i + 1);\n-                }).detach();\n+                });\n             }\n         }\n-    }\n+    } }\n \n-    #[test]\n-    fn recv_a_lot() {\n+    test! { fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = channel();\n-        for _ in range(0i, 10000) { tx.send(()).unwrap(); }\n-        for _ in range(0i, 10000) { rx.recv().unwrap(); }\n-    }\n+        for _ in range(0i, 10000) { tx.send(()); }\n+        for _ in range(0i, 10000) { rx.recv(); }\n+    } }\n \n-    #[test]\n-    fn shared_chan_stress() {\n+    test! { fn shared_chan_stress() {\n         let (tx, rx) = channel();\n         let total = stress_factor() + 100;\n         for _ in range(0, total) {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n-                tx.send(()).unwrap();\n-            }).detach();\n+            spawn(move|| {\n+                tx.send(());\n+            });\n         }\n \n         for _ in range(0, total) {\n-            rx.recv().unwrap();\n+            rx.recv();\n         }\n-    }\n+    } }\n \n-    #[test]\n-    fn test_nested_recv_iter() {\n+    test! { fn test_nested_recv_iter() {\n         let (tx, rx) = channel::<int>();\n         let (total_tx, total_rx) = channel::<int>();\n \n-        let _t = Thread::spawn(move|| {\n+        spawn(move|| {\n             let mut acc = 0;\n             for x in rx.iter() {\n                 acc += x;\n             }\n-            total_tx.send(acc).unwrap();\n+            total_tx.send(acc);\n         });\n \n-        tx.send(3).unwrap();\n-        tx.send(1).unwrap();\n-        tx.send(2).unwrap();\n+        tx.send(3);\n+        tx.send(1);\n+        tx.send(2);\n         drop(tx);\n-        assert_eq!(total_rx.recv().unwrap(), 6);\n-    }\n+        assert_eq!(total_rx.recv(), 6);\n+    } }\n \n-    #[test]\n-    fn test_recv_iter_break() {\n+    test! { fn test_recv_iter_break() {\n         let (tx, rx) = channel::<int>();\n         let (count_tx, count_rx) = channel();\n \n-        let _t = Thread::spawn(move|| {\n+        spawn(move|| {\n             let mut count = 0;\n             for x in rx.iter() {\n                 if count >= 3 {\n@@ -1475,386 +1483,353 @@ mod test {\n                     count += x;\n                 }\n             }\n-            count_tx.send(count).unwrap();\n+            count_tx.send(count);\n         });\n \n-        tx.send(2).unwrap();\n-        tx.send(2).unwrap();\n-        tx.send(2).unwrap();\n-        let _ = tx.send(2);\n+        tx.send(2);\n+        tx.send(2);\n+        tx.send(2);\n+        let _ = tx.send_opt(2);\n         drop(tx);\n-        assert_eq!(count_rx.recv().unwrap(), 4);\n-    }\n+        assert_eq!(count_rx.recv(), 4);\n+    } }\n \n-    #[test]\n-    fn try_recv_states() {\n+    test! { fn try_recv_states() {\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n-        let _t = Thread::spawn(move|| {\n-            rx2.recv().unwrap();\n-            tx1.send(1).unwrap();\n-            tx3.send(()).unwrap();\n-            rx2.recv().unwrap();\n+        spawn(move|| {\n+            rx2.recv();\n+            tx1.send(1);\n+            tx3.send(());\n+            rx2.recv();\n             drop(tx1);\n-            tx3.send(()).unwrap();\n+            tx3.send(());\n         });\n \n-        assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n-        tx2.send(()).unwrap();\n-        rx3.recv().unwrap();\n+        assert_eq!(rx1.try_recv(), Err(Empty));\n+        tx2.send(());\n+        rx3.recv();\n         assert_eq!(rx1.try_recv(), Ok(1));\n-        assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n-        tx2.send(()).unwrap();\n-        rx3.recv().unwrap();\n-        assert_eq!(rx1.try_recv(), Err(TryRecvError::Disconnected));\n-    }\n+        assert_eq!(rx1.try_recv(), Err(Empty));\n+        tx2.send(());\n+        rx3.recv();\n+        assert_eq!(rx1.try_recv(), Err(Disconnected));\n+    } }\n \n     // This bug used to end up in a livelock inside of the Receiver destructor\n     // because the internal state of the Shared packet was corrupted\n-    #[test]\n-    fn destroy_upgraded_shared_port_when_sender_still_active() {\n+    test! { fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n-            rx.recv().unwrap(); // wait on a oneshot\n+        spawn(move|| {\n+            rx.recv(); // wait on a oneshot\n             drop(rx);  // destroy a shared\n-            tx2.send(()).unwrap();\n+            tx2.send(());\n         });\n         // make sure the other task has gone to sleep\n         for _ in range(0u, 5000) { Thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n         drop(tx);\n-        t.send(()).unwrap();\n+        t.send(());\n \n         // wait for the child task to exit before we exit\n-        rx2.recv().unwrap();\n-    }\n+        rx2.recv();\n+    }}\n }\n \n #[cfg(test)]\n mod sync_tests {\n-    use prelude::v1::*;\n-\n+    use prelude::*;\n     use os;\n-    use thread::Thread;\n-    use super::*;\n \n     pub fn stress_factor() -> uint {\n         match os::getenv(\"RUST_TEST_STRESS\") {\n-            Some(val) => val.parse().unwrap(),\n+            Some(val) => from_str::<uint>(val.as_slice()).unwrap(),\n             None => 1,\n         }\n     }\n \n-    #[test]\n-    fn smoke() {\n+    test! { fn smoke() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        tx.send(1).unwrap();\n-        assert_eq!(rx.recv().unwrap(), 1);\n-    }\n+        tx.send(1);\n+        assert_eq!(rx.recv(), 1);\n+    } }\n \n-    #[test]\n-    fn drop_full() {\n+    test! { fn drop_full() {\n         let (tx, _rx) = sync_channel(1);\n-        tx.send(box 1i).unwrap();\n-    }\n+        tx.send(box 1i);\n+    } }\n \n-    #[test]\n-    fn smoke_shared() {\n+    test! { fn smoke_shared() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        tx.send(1).unwrap();\n-        assert_eq!(rx.recv().unwrap(), 1);\n+        tx.send(1);\n+        assert_eq!(rx.recv(), 1);\n         let tx = tx.clone();\n-        tx.send(1).unwrap();\n-        assert_eq!(rx.recv().unwrap(), 1);\n-    }\n+        tx.send(1);\n+        assert_eq!(rx.recv(), 1);\n+    } }\n \n-    #[test]\n-    fn smoke_threads() {\n+    test! { fn smoke_threads() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        let _t = Thread::spawn(move|| {\n-            tx.send(1).unwrap();\n+        spawn(move|| {\n+            tx.send(1);\n         });\n-        assert_eq!(rx.recv().unwrap(), 1);\n-    }\n+        assert_eq!(rx.recv(), 1);\n+    } }\n \n-    #[test]\n-    fn smoke_port_gone() {\n+    test! { fn smoke_port_gone() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n-        assert!(tx.send(1).is_err());\n-    }\n+        tx.send(1);\n+    } #[should_fail] }\n \n-    #[test]\n-    fn smoke_shared_port_gone2() {\n+    test! { fn smoke_shared_port_gone2() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n         let tx2 = tx.clone();\n         drop(tx);\n-        assert!(tx2.send(1).is_err());\n-    }\n+        tx2.send(1);\n+    } #[should_fail] }\n \n-    #[test]\n-    fn port_gone_concurrent() {\n+    test! { fn port_gone_concurrent() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        let _t = Thread::spawn(move|| {\n-            rx.recv().unwrap();\n+        spawn(move|| {\n+            rx.recv();\n         });\n-        while tx.send(1).is_ok() {}\n-    }\n+        loop { tx.send(1) }\n+    } #[should_fail] }\n \n-    #[test]\n-    fn port_gone_concurrent_shared() {\n+    test! { fn port_gone_concurrent_shared() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let tx2 = tx.clone();\n-        let _t = Thread::spawn(move|| {\n-            rx.recv().unwrap();\n+        spawn(move|| {\n+            rx.recv();\n         });\n-        while tx.send(1).is_ok() && tx2.send(1).is_ok() {}\n-    }\n+        loop {\n+            tx.send(1);\n+            tx2.send(1);\n+        }\n+    } #[should_fail] }\n \n-    #[test]\n-    fn smoke_chan_gone() {\n+    test! { fn smoke_chan_gone() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(tx);\n-        assert!(rx.recv().is_err());\n-    }\n+        rx.recv();\n+    } #[should_fail] }\n \n-    #[test]\n-    fn smoke_chan_gone_shared() {\n+    test! { fn smoke_chan_gone_shared() {\n         let (tx, rx) = sync_channel::<()>(0);\n         let tx2 = tx.clone();\n         drop(tx);\n         drop(tx2);\n-        assert!(rx.recv().is_err());\n-    }\n+        rx.recv();\n+    } #[should_fail] }\n \n-    #[test]\n-    fn chan_gone_concurrent() {\n+    test! { fn chan_gone_concurrent() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        Thread::spawn(move|| {\n-            tx.send(1).unwrap();\n-            tx.send(1).unwrap();\n-        }).detach();\n-        while rx.recv().is_ok() {}\n-    }\n+        spawn(move|| {\n+            tx.send(1);\n+            tx.send(1);\n+        });\n+        loop { rx.recv(); }\n+    } #[should_fail] }\n \n-    #[test]\n-    fn stress() {\n+    test! { fn stress() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        Thread::spawn(move|| {\n-            for _ in range(0u, 10000) { tx.send(1).unwrap(); }\n-        }).detach();\n+        spawn(move|| {\n+            for _ in range(0u, 10000) { tx.send(1); }\n+        });\n         for _ in range(0u, 10000) {\n-            assert_eq!(rx.recv().unwrap(), 1);\n+            assert_eq!(rx.recv(), 1);\n         }\n-    }\n+    } }\n \n-    #[test]\n-    fn stress_shared() {\n+    test! { fn stress_shared() {\n         static AMT: uint = 1000;\n         static NTHREADS: uint = 8;\n         let (tx, rx) = sync_channel::<int>(0);\n         let (dtx, drx) = sync_channel::<()>(0);\n \n-        Thread::spawn(move|| {\n+        spawn(move|| {\n             for _ in range(0, AMT * NTHREADS) {\n-                assert_eq!(rx.recv().unwrap(), 1);\n+                assert_eq!(rx.recv(), 1);\n             }\n             match rx.try_recv() {\n                 Ok(..) => panic!(),\n                 _ => {}\n             }\n-            dtx.send(()).unwrap();\n-        }).detach();\n+            dtx.send(());\n+        });\n \n         for _ in range(0, NTHREADS) {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n-                for _ in range(0, AMT) { tx.send(1).unwrap(); }\n-            }).detach();\n+            spawn(move|| {\n+                for _ in range(0, AMT) { tx.send(1); }\n+            });\n         }\n         drop(tx);\n-        drx.recv().unwrap();\n-    }\n+        drx.recv();\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_close_port_first() {\n+    test! { fn oneshot_single_thread_close_port_first() {\n         // Simple test of closing without sending\n         let (_tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n-    }\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_close_chan_first() {\n+    test! { fn oneshot_single_thread_close_chan_first() {\n         // Simple test of closing without sending\n         let (tx, _rx) = sync_channel::<int>(0);\n         drop(tx);\n-    }\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_send_port_close() {\n+    test! { fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n         drop(rx);\n-        assert!(tx.send(box 0).is_err());\n-    }\n+        tx.send(box 0);\n+    } #[should_fail] }\n \n-    #[test]\n-    fn oneshot_single_thread_recv_chan_close() {\n+    test! { fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n         let res = Thread::spawn(move|| {\n             let (tx, rx) = sync_channel::<int>(0);\n             drop(tx);\n-            rx.recv().unwrap();\n+            rx.recv();\n         }).join();\n         // What is our res?\n         assert!(res.is_err());\n-    }\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_send_then_recv() {\n+    test! { fn oneshot_single_thread_send_then_recv() {\n         let (tx, rx) = sync_channel::<Box<int>>(1);\n-        tx.send(box 10).unwrap();\n-        assert!(rx.recv().unwrap() == box 10);\n-    }\n+        tx.send(box 10);\n+        assert!(rx.recv() == box 10);\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_try_send_open() {\n+    test! { fn oneshot_single_thread_try_send_open() {\n         let (tx, rx) = sync_channel::<int>(1);\n         assert_eq!(tx.try_send(10), Ok(()));\n-        assert!(rx.recv().unwrap() == 10);\n-    }\n+        assert!(rx.recv() == 10);\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_try_send_closed() {\n+    test! { fn oneshot_single_thread_try_send_closed() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n-        assert_eq!(tx.try_send(10), Err(TrySendError::Disconnected(10)));\n-    }\n+        assert_eq!(tx.try_send(10), Err(RecvDisconnected(10)));\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_try_send_closed2() {\n+    test! { fn oneshot_single_thread_try_send_closed2() {\n         let (tx, _rx) = sync_channel::<int>(0);\n-        assert_eq!(tx.try_send(10), Err(TrySendError::Full(10)));\n-    }\n+        assert_eq!(tx.try_send(10), Err(Full(10)));\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_try_recv_open() {\n+    test! { fn oneshot_single_thread_try_recv_open() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        tx.send(10).unwrap();\n-        assert!(rx.recv() == Ok(10));\n-    }\n+        tx.send(10);\n+        assert!(rx.recv_opt() == Ok(10));\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_try_recv_closed() {\n+    test! { fn oneshot_single_thread_try_recv_closed() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(tx);\n-        assert!(rx.recv().is_err());\n-    }\n+        assert!(rx.recv_opt() == Err(()));\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_peek_data() {\n+    test! { fn oneshot_single_thread_peek_data() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n-        tx.send(10).unwrap();\n+        assert_eq!(rx.try_recv(), Err(Empty));\n+        tx.send(10);\n         assert_eq!(rx.try_recv(), Ok(10));\n-    }\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_peek_close() {\n+    test! { fn oneshot_single_thread_peek_close() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(tx);\n-        assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n-        assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n-    }\n+        assert_eq!(rx.try_recv(), Err(Disconnected));\n+        assert_eq!(rx.try_recv(), Err(Disconnected));\n+    } }\n \n-    #[test]\n-    fn oneshot_single_thread_peek_open() {\n+    test! { fn oneshot_single_thread_peek_open() {\n         let (_tx, rx) = sync_channel::<int>(0);\n-        assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n-    }\n+        assert_eq!(rx.try_recv(), Err(Empty));\n+    } }\n \n-    #[test]\n-    fn oneshot_multi_task_recv_then_send() {\n+    test! { fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n-        let _t = Thread::spawn(move|| {\n-            assert!(rx.recv().unwrap() == box 10);\n+        spawn(move|| {\n+            assert!(rx.recv() == box 10);\n         });\n \n-        tx.send(box 10).unwrap();\n-    }\n+        tx.send(box 10);\n+    } }\n \n-    #[test]\n-    fn oneshot_multi_task_recv_then_close() {\n+    test! { fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n-        let _t = Thread::spawn(move|| {\n+        spawn(move|| {\n             drop(tx);\n         });\n         let res = Thread::spawn(move|| {\n-            assert!(rx.recv().unwrap() == box 10);\n+            assert!(rx.recv() == box 10);\n         }).join();\n         assert!(res.is_err());\n-    }\n+    } }\n \n-    #[test]\n-    fn oneshot_multi_thread_close_stress() {\n+    test! { fn oneshot_multi_thread_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<int>(0);\n-            let _t = Thread::spawn(move|| {\n+            spawn(move|| {\n                 drop(rx);\n             });\n             drop(tx);\n         }\n-    }\n+    } }\n \n-    #[test]\n-    fn oneshot_multi_thread_send_close_stress() {\n+    test! { fn oneshot_multi_thread_send_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<int>(0);\n-            let _t = Thread::spawn(move|| {\n+            spawn(move|| {\n                 drop(rx);\n             });\n             let _ = Thread::spawn(move || {\n-                tx.send(1).unwrap();\n+                tx.send(1);\n             }).join();\n         }\n-    }\n+    } }\n \n-    #[test]\n-    fn oneshot_multi_thread_recv_close_stress() {\n+    test! { fn oneshot_multi_thread_recv_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<int>(0);\n-            let _t = Thread::spawn(move|| {\n+            spawn(move|| {\n                 let res = Thread::spawn(move|| {\n-                    rx.recv().unwrap();\n+                    rx.recv();\n                 }).join();\n                 assert!(res.is_err());\n             });\n-            let _t = Thread::spawn(move|| {\n-                Thread::spawn(move|| {\n+            spawn(move|| {\n+                spawn(move|| {\n                     drop(tx);\n-                }).detach();\n+                });\n             });\n         }\n-    }\n+    } }\n \n-    #[test]\n-    fn oneshot_multi_thread_send_recv_stress() {\n+    test! { fn oneshot_multi_thread_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<Box<int>>(0);\n-            let _t = Thread::spawn(move|| {\n-                tx.send(box 10i).unwrap();\n+            spawn(move|| {\n+                tx.send(box 10i);\n+            });\n+            spawn(move|| {\n+                assert!(rx.recv() == box 10i);\n             });\n-            assert!(rx.recv().unwrap() == box 10i);\n         }\n-    }\n+    } }\n \n-    #[test]\n-    fn stream_send_recv_stress() {\n+    test! { fn stream_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<Box<int>>(0);\n \n@@ -1864,73 +1839,69 @@ mod sync_tests {\n             fn send(tx: SyncSender<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                Thread::spawn(move|| {\n-                    tx.send(box i).unwrap();\n+                spawn(move|| {\n+                    tx.send(box i);\n                     send(tx, i + 1);\n-                }).detach();\n+                });\n             }\n \n             fn recv(rx: Receiver<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                Thread::spawn(move|| {\n-                    assert!(rx.recv().unwrap() == box i);\n+                spawn(move|| {\n+                    assert!(rx.recv() == box i);\n                     recv(rx, i + 1);\n-                }).detach();\n+                });\n             }\n         }\n-    }\n+    } }\n \n-    #[test]\n-    fn recv_a_lot() {\n+    test! { fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = sync_channel(10000);\n-        for _ in range(0u, 10000) { tx.send(()).unwrap(); }\n-        for _ in range(0u, 10000) { rx.recv().unwrap(); }\n-    }\n+        for _ in range(0u, 10000) { tx.send(()); }\n+        for _ in range(0u, 10000) { rx.recv(); }\n+    } }\n \n-    #[test]\n-    fn shared_chan_stress() {\n+    test! { fn shared_chan_stress() {\n         let (tx, rx) = sync_channel(0);\n         let total = stress_factor() + 100;\n         for _ in range(0, total) {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n-                tx.send(()).unwrap();\n-            }).detach();\n+            spawn(move|| {\n+                tx.send(());\n+            });\n         }\n \n         for _ in range(0, total) {\n-            rx.recv().unwrap();\n+            rx.recv();\n         }\n-    }\n+    } }\n \n-    #[test]\n-    fn test_nested_recv_iter() {\n+    test! { fn test_nested_recv_iter() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let (total_tx, total_rx) = sync_channel::<int>(0);\n \n-        let _t = Thread::spawn(move|| {\n+        spawn(move|| {\n             let mut acc = 0;\n             for x in rx.iter() {\n                 acc += x;\n             }\n-            total_tx.send(acc).unwrap();\n+            total_tx.send(acc);\n         });\n \n-        tx.send(3).unwrap();\n-        tx.send(1).unwrap();\n-        tx.send(2).unwrap();\n+        tx.send(3);\n+        tx.send(1);\n+        tx.send(2);\n         drop(tx);\n-        assert_eq!(total_rx.recv().unwrap(), 6);\n-    }\n+        assert_eq!(total_rx.recv(), 6);\n+    } }\n \n-    #[test]\n-    fn test_recv_iter_break() {\n+    test! { fn test_recv_iter_break() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let (count_tx, count_rx) = sync_channel(0);\n \n-        let _t = Thread::spawn(move|| {\n+        spawn(move|| {\n             let mut count = 0;\n             for x in rx.iter() {\n                 if count >= 3 {\n@@ -1939,143 +1910,142 @@ mod sync_tests {\n                     count += x;\n                 }\n             }\n-            count_tx.send(count).unwrap();\n+            count_tx.send(count);\n         });\n \n-        tx.send(2).unwrap();\n-        tx.send(2).unwrap();\n-        tx.send(2).unwrap();\n+        tx.send(2);\n+        tx.send(2);\n+        tx.send(2);\n         let _ = tx.try_send(2);\n         drop(tx);\n-        assert_eq!(count_rx.recv().unwrap(), 4);\n-    }\n+        assert_eq!(count_rx.recv(), 4);\n+    } }\n \n-    #[test]\n-    fn try_recv_states() {\n+    test! { fn try_recv_states() {\n         let (tx1, rx1) = sync_channel::<int>(1);\n         let (tx2, rx2) = sync_channel::<()>(1);\n         let (tx3, rx3) = sync_channel::<()>(1);\n-        let _t = Thread::spawn(move|| {\n-            rx2.recv().unwrap();\n-            tx1.send(1).unwrap();\n-            tx3.send(()).unwrap();\n-            rx2.recv().unwrap();\n+        spawn(move|| {\n+            rx2.recv();\n+            tx1.send(1);\n+            tx3.send(());\n+            rx2.recv();\n             drop(tx1);\n-            tx3.send(()).unwrap();\n+            tx3.send(());\n         });\n \n-        assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n-        tx2.send(()).unwrap();\n-        rx3.recv().unwrap();\n+        assert_eq!(rx1.try_recv(), Err(Empty));\n+        tx2.send(());\n+        rx3.recv();\n         assert_eq!(rx1.try_recv(), Ok(1));\n-        assert_eq!(rx1.try_recv(), Err(TryRecvError::Empty));\n-        tx2.send(()).unwrap();\n-        rx3.recv().unwrap();\n-        assert_eq!(rx1.try_recv(), Err(TryRecvError::Disconnected));\n-    }\n+        assert_eq!(rx1.try_recv(), Err(Empty));\n+        tx2.send(());\n+        rx3.recv();\n+        assert_eq!(rx1.try_recv(), Err(Disconnected));\n+    } }\n \n     // This bug used to end up in a livelock inside of the Receiver destructor\n     // because the internal state of the Shared packet was corrupted\n-    #[test]\n-    fn destroy_upgraded_shared_port_when_sender_still_active() {\n+    test! { fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = sync_channel::<()>(0);\n         let (tx2, rx2) = sync_channel::<()>(0);\n-        let _t = Thread::spawn(move|| {\n-            rx.recv().unwrap(); // wait on a oneshot\n+        spawn(move|| {\n+            rx.recv(); // wait on a oneshot\n             drop(rx);  // destroy a shared\n-            tx2.send(()).unwrap();\n+            tx2.send(());\n         });\n         // make sure the other task has gone to sleep\n         for _ in range(0u, 5000) { Thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n         drop(tx);\n-        t.send(()).unwrap();\n+        t.send(());\n \n         // wait for the child task to exit before we exit\n-        rx2.recv().unwrap();\n-    }\n+        rx2.recv();\n+    } }\n \n-    #[test]\n-    fn send1() {\n+    test! { fn send_opt1() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        let _t = Thread::spawn(move|| { rx.recv().unwrap(); });\n-        assert_eq!(tx.send(1), Ok(()));\n-    }\n+        spawn(move|| { rx.recv(); });\n+        assert_eq!(tx.send_opt(1), Ok(()));\n+    } }\n \n-    #[test]\n-    fn send2() {\n+    test! { fn send_opt2() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        let _t = Thread::spawn(move|| { drop(rx); });\n-        assert!(tx.send(1).is_err());\n-    }\n+        spawn(move|| { drop(rx); });\n+        assert_eq!(tx.send_opt(1), Err(1));\n+    } }\n \n-    #[test]\n-    fn send3() {\n+    test! { fn send_opt3() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        assert_eq!(tx.send(1), Ok(()));\n-        let _t =Thread::spawn(move|| { drop(rx); });\n-        assert!(tx.send(1).is_err());\n-    }\n+        assert_eq!(tx.send_opt(1), Ok(()));\n+        spawn(move|| { drop(rx); });\n+        assert_eq!(tx.send_opt(1), Err(1));\n+    } }\n \n-    #[test]\n-    fn send4() {\n+    test! { fn send_opt4() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let tx2 = tx.clone();\n         let (done, donerx) = channel();\n         let done2 = done.clone();\n-        let _t = Thread::spawn(move|| {\n-            assert!(tx.send(1).is_err());\n-            done.send(()).unwrap();\n+        spawn(move|| {\n+            assert_eq!(tx.send_opt(1), Err(1));\n+            done.send(());\n         });\n-        let _t = Thread::spawn(move|| {\n-            assert!(tx2.send(2).is_err());\n-            done2.send(()).unwrap();\n+        spawn(move|| {\n+            assert_eq!(tx2.send_opt(2), Err(2));\n+            done2.send(());\n         });\n         drop(rx);\n-        donerx.recv().unwrap();\n-        donerx.recv().unwrap();\n-    }\n+        donerx.recv();\n+        donerx.recv();\n+    } }\n \n-    #[test]\n-    fn try_send1() {\n+    test! { fn try_send1() {\n         let (tx, _rx) = sync_channel::<int>(0);\n-        assert_eq!(tx.try_send(1), Err(TrySendError::Full(1)));\n-    }\n+        assert_eq!(tx.try_send(1), Err(Full(1)));\n+    } }\n \n-    #[test]\n-    fn try_send2() {\n+    test! { fn try_send2() {\n         let (tx, _rx) = sync_channel::<int>(1);\n         assert_eq!(tx.try_send(1), Ok(()));\n-        assert_eq!(tx.try_send(1), Err(TrySendError::Full(1)));\n-    }\n+        assert_eq!(tx.try_send(1), Err(Full(1)));\n+    } }\n \n-    #[test]\n-    fn try_send3() {\n+    test! { fn try_send3() {\n         let (tx, rx) = sync_channel::<int>(1);\n         assert_eq!(tx.try_send(1), Ok(()));\n         drop(rx);\n-        assert_eq!(tx.try_send(1), Err(TrySendError::Disconnected(1)));\n-    }\n+        assert_eq!(tx.try_send(1), Err(RecvDisconnected(1)));\n+    } }\n \n-    #[test]\n-    fn issue_15761() {\n+    test! { fn try_send4() {\n+        let (tx, rx) = sync_channel::<int>(0);\n+        spawn(move|| {\n+            for _ in range(0u, 1000) { Thread::yield_now(); }\n+            assert_eq!(tx.try_send(1), Ok(()));\n+        });\n+        assert_eq!(rx.recv(), 1);\n+    } #[ignore(reason = \"flaky on libnative\")] }\n+\n+    test! { fn issue_15761() {\n         fn repro() {\n             let (tx1, rx1) = sync_channel::<()>(3);\n             let (tx2, rx2) = sync_channel::<()>(3);\n \n-            let _t = Thread::spawn(move|| {\n-                rx1.recv().unwrap();\n+            spawn(move|| {\n+                rx1.recv();\n                 tx2.try_send(()).unwrap();\n             });\n \n             tx1.try_send(()).unwrap();\n-            rx2.recv().unwrap();\n+            rx2.recv();\n         }\n \n         for _ in range(0u, 100) {\n             repro()\n         }\n-    }\n+    } }\n }"}, {"sha": "bd98b09d77985fcc8974d1af6859d5e99778325c", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059566b01960f3f630316cc50989e8c57e5e696e/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=059566b01960f3f630316cc50989e8c57e5e696e", "patch": "@@ -41,7 +41,7 @@ use sys_common::rwlock as sys;\n /// ```\n /// use std::sync::RWLock;\n ///\n-/// let lock = RWLock::new(5i);\n+/// let lock = RWLock::new(5);\n ///\n /// // many reader locks can be held at once\n /// {"}]}