{"sha": "f2acbb9d1eb5cb59199f16a608a291b4c884e967", "node_id": "C_kwDOAAsO6NoAKGYyYWNiYjlkMWViNWNiNTkxOTlmMTZhNjA4YTI5MWI0Yzg4NGU5Njc", "commit": {"author": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-10-16T14:15:39Z"}, "committer": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2023-02-01T20:49:45Z"}, "message": "Forbid #[suggestion_*(...)] on Vecs\n\nIt is ambiguous whether this should produce several `.span_suggestions()`\ncalls or one `.multipart_suggestions()` call.", "tree": {"sha": "af8c01be73f8c5380e1c02ad23cfc2b9ad90517e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af8c01be73f8c5380e1c02ad23cfc2b9ad90517e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2acbb9d1eb5cb59199f16a608a291b4c884e967", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2acbb9d1eb5cb59199f16a608a291b4c884e967", "html_url": "https://github.com/rust-lang/rust/commit/f2acbb9d1eb5cb59199f16a608a291b4c884e967", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2acbb9d1eb5cb59199f16a608a291b4c884e967/comments", "author": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11d96b59307b1702fffe871bfc2d0145d070881e", "url": "https://api.github.com/repos/rust-lang/rust/commits/11d96b59307b1702fffe871bfc2d0145d070881e", "html_url": "https://github.com/rust-lang/rust/commit/11d96b59307b1702fffe871bfc2d0145d070881e"}], "stats": {"total": 162, "additions": 117, "deletions": 45}, "files": [{"sha": "12bcd939bd61b78e74b974b75eece249ca5d8680", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f2acbb9d1eb5cb59199f16a608a291b4c884e967/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2acbb9d1eb5cb59199f16a608a291b4c884e967/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=f2acbb9d1eb5cb59199f16a608a291b4c884e967", "patch": "@@ -322,11 +322,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 let generated_code = self\n                     .generate_inner_field_code(\n                         attr,\n-                        FieldInfo {\n-                            binding: binding_info,\n-                            ty: inner_ty.inner_type().unwrap_or(&field.ty),\n-                            span: &field.span(),\n-                        },\n+                        FieldInfo { binding: binding_info, ty: inner_ty, span: &field.span() },\n                         binding,\n                     )\n                     .unwrap_or_else(|v| v.to_compile_error());\n@@ -418,9 +414,9 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 Ok(self.add_spanned_subdiagnostic(binding, &fn_ident, slug))\n             }\n             SubdiagnosticKind::Note | SubdiagnosticKind::Help | SubdiagnosticKind::Warn => {\n-                if type_matches_path(info.ty, &[\"rustc_span\", \"Span\"]) {\n+                if type_matches_path(info.ty.inner_type(), &[\"rustc_span\", \"Span\"]) {\n                     Ok(self.add_spanned_subdiagnostic(binding, &fn_ident, slug))\n-                } else if type_is_unit(info.ty) {\n+                } else if type_is_unit(info.ty.inner_type()) {\n                     Ok(self.add_subdiagnostic(&fn_ident, slug))\n                 } else {\n                     report_type_error(attr, \"`Span` or `()`\")?\n@@ -432,6 +428,15 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 code_field,\n                 code_init,\n             } => {\n+                if let FieldInnerTy::Vec(_) = info.ty {\n+                    throw_invalid_attr!(attr, &meta, |diag| {\n+                        diag\n+                        .note(\"`#[suggestion(...)]` applied to `Vec` field is ambiguous\")\n+                        .help(\"to show a suggestion consisting of multiple parts, use a `Subdiagnostic` annotated with `#[multipart_suggestion(...)]`\")\n+                        .help(\"to show a variable set of suggestions, use a `Vec` of `Subdiagnostic`s annotated with `#[suggestion(...)]`\")\n+                    });\n+                }\n+\n                 let (span_field, mut applicability) = self.span_and_applicability_of_ty(info)?;\n \n                 if let Some((static_applicability, span)) = static_applicability {\n@@ -489,7 +494,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         &self,\n         info: FieldInfo<'_>,\n     ) -> Result<(TokenStream, SpannedOption<TokenStream>), DiagnosticDeriveError> {\n-        match &info.ty {\n+        match &info.ty.inner_type() {\n             // If `ty` is `Span` w/out applicability, then use `Applicability::Unspecified`.\n             ty @ Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n                 let binding = &info.binding.binding;"}, {"sha": "906e4c0b0e16c293faa07d0e4558d482a1627579", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f2acbb9d1eb5cb59199f16a608a291b4c884e967/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2acbb9d1eb5cb59199f16a608a291b4c884e967/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=f2acbb9d1eb5cb59199f16a608a291b4c884e967", "patch": "@@ -247,11 +247,7 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     return quote! {};\n                 }\n \n-                let info = FieldInfo {\n-                    binding,\n-                    ty: inner_ty.inner_type().unwrap_or(&ast.ty),\n-                    span: &ast.span(),\n-                };\n+                let info = FieldInfo { binding, ty: inner_ty, span: &ast.span() };\n \n                 let generated = self\n                     .generate_field_code_inner(kind_stats, attr, info, inner_ty.will_iterate())\n@@ -312,6 +308,21 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     let binding = info.binding.binding.clone();\n                     // FIXME(#100717): support `Option<Span>` on `primary_span` like in the\n                     // diagnostic derive\n+                    if !matches!(info.ty, FieldInnerTy::Plain(_)) {\n+                        throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n+                            let diag = diag.note(\"there must be exactly one primary span\");\n+\n+                            if kind_stats.has_normal_suggestion {\n+                                diag.help(\n+                                    \"to create a suggestion with multiple spans, \\\n+                                     use `#[multipart_suggestion]` instead\",\n+                                )\n+                            } else {\n+                                diag\n+                            }\n+                        });\n+                    }\n+\n                     self.span_field.set_once(binding, span);\n                 }\n "}, {"sha": "27b8f676f3fbb8cec626e05a44e97b1ade90da4c", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f2acbb9d1eb5cb59199f16a608a291b4c884e967/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2acbb9d1eb5cb59199f16a608a291b4c884e967/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=f2acbb9d1eb5cb59199f16a608a291b4c884e967", "patch": "@@ -80,7 +80,7 @@ fn report_error_if_not_applied_to_ty(\n     path: &[&str],\n     ty_name: &str,\n ) -> Result<(), DiagnosticDeriveError> {\n-    if !type_matches_path(info.ty, path) {\n+    if !type_matches_path(info.ty.inner_type(), path) {\n         report_type_error(attr, ty_name)?;\n     }\n \n@@ -105,8 +105,8 @@ pub(crate) fn report_error_if_not_applied_to_span(\n     attr: &Attribute,\n     info: &FieldInfo<'_>,\n ) -> Result<(), DiagnosticDeriveError> {\n-    if !type_matches_path(info.ty, &[\"rustc_span\", \"Span\"])\n-        && !type_matches_path(info.ty, &[\"rustc_errors\", \"MultiSpan\"])\n+    if !type_matches_path(info.ty.inner_type(), &[\"rustc_span\", \"Span\"])\n+        && !type_matches_path(info.ty.inner_type(), &[\"rustc_errors\", \"MultiSpan\"])\n     {\n         report_type_error(attr, \"`Span` or `MultiSpan`\")?;\n     }\n@@ -115,60 +115,67 @@ pub(crate) fn report_error_if_not_applied_to_span(\n }\n \n /// Inner type of a field and type of wrapper.\n+#[derive(Copy, Clone)]\n pub(crate) enum FieldInnerTy<'ty> {\n     /// Field is wrapped in a `Option<$inner>`.\n     Option(&'ty Type),\n     /// Field is wrapped in a `Vec<$inner>`.\n     Vec(&'ty Type),\n     /// Field isn't wrapped in an outer type.\n-    None,\n+    Plain(&'ty Type),\n }\n \n impl<'ty> FieldInnerTy<'ty> {\n     /// Returns inner type for a field, if there is one.\n     ///\n-    /// - If `ty` is an `Option`, returns `FieldInnerTy::Option { inner: (inner type) }`.\n-    /// - If `ty` is a `Vec`, returns `FieldInnerTy::Vec { inner: (inner type) }`.\n-    /// - Otherwise returns `None`.\n+    /// - If `ty` is an `Option<Inner>`, returns `FieldInnerTy::Option(Inner)`.\n+    /// - If `ty` is a `Vec<Inner>`, returns `FieldInnerTy::Vec(Inner)`.\n+    /// - Otherwise returns `FieldInnerTy::Plain(ty)`.\n     pub(crate) fn from_type(ty: &'ty Type) -> Self {\n-        let variant: &dyn Fn(&'ty Type) -> FieldInnerTy<'ty> =\n-            if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n-                &FieldInnerTy::Option\n-            } else if type_matches_path(ty, &[\"std\", \"vec\", \"Vec\"]) {\n-                &FieldInnerTy::Vec\n-            } else {\n-                return FieldInnerTy::None;\n+        fn single_generic_type(ty: &Type) -> &Type {\n+            let Type::Path(ty_path) = ty else {\n+                panic!(\"expected path type\");\n             };\n \n-        if let Type::Path(ty_path) = ty {\n             let path = &ty_path.path;\n             let ty = path.segments.iter().last().unwrap();\n-            if let syn::PathArguments::AngleBracketed(bracketed) = &ty.arguments {\n-                if bracketed.args.len() == 1 {\n-                    if let syn::GenericArgument::Type(ty) = &bracketed.args[0] {\n-                        return variant(ty);\n-                    }\n-                }\n-            }\n+            let syn::PathArguments::AngleBracketed(bracketed) = &ty.arguments else {\n+                panic!(\"expected bracketed generic arguments\");\n+            };\n+\n+            assert_eq!(bracketed.args.len(), 1);\n+\n+            let syn::GenericArgument::Type(ty) = &bracketed.args[0] else {\n+                panic!(\"expected generic parameter to be a type generic\");\n+            };\n+\n+            ty\n         }\n \n-        unreachable!();\n+        if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n+            FieldInnerTy::Option(single_generic_type(ty))\n+        } else if type_matches_path(ty, &[\"std\", \"vec\", \"Vec\"]) {\n+            FieldInnerTy::Vec(single_generic_type(ty))\n+        } else {\n+            FieldInnerTy::Plain(ty)\n+        }\n     }\n \n     /// Returns `true` if `FieldInnerTy::with` will result in iteration for this inner type (i.e.\n     /// that cloning might be required for values moved in the loop body).\n     pub(crate) fn will_iterate(&self) -> bool {\n         match self {\n             FieldInnerTy::Vec(..) => true,\n-            FieldInnerTy::Option(..) | FieldInnerTy::None => false,\n+            FieldInnerTy::Option(..) | FieldInnerTy::Plain(_) => false,\n         }\n     }\n \n-    /// Returns `Option` containing inner type if there is one.\n-    pub(crate) fn inner_type(&self) -> Option<&'ty Type> {\n+    /// Returns the inner type.\n+    pub(crate) fn inner_type(&self) -> &'ty Type {\n         match self {\n-            FieldInnerTy::Option(inner) | FieldInnerTy::Vec(inner) => Some(inner),\n-            FieldInnerTy::None => None,\n+            FieldInnerTy::Option(inner) | FieldInnerTy::Vec(inner) | FieldInnerTy::Plain(inner) => {\n+                inner\n+            }\n         }\n     }\n \n@@ -185,7 +192,7 @@ impl<'ty> FieldInnerTy<'ty> {\n                     #inner\n                 }\n             },\n-            FieldInnerTy::None => quote! { #inner },\n+            FieldInnerTy::Plain(..) => quote! { #inner },\n         }\n     }\n }\n@@ -194,7 +201,7 @@ impl<'ty> FieldInnerTy<'ty> {\n /// `generate_*` methods from walking the attributes themselves.\n pub(crate) struct FieldInfo<'a> {\n     pub(crate) binding: &'a BindingInfo<'a>,\n-    pub(crate) ty: &'a Type,\n+    pub(crate) ty: FieldInnerTy<'a>,\n     pub(crate) span: &'a proc_macro2::Span,\n }\n "}, {"sha": "07f95d13937b47d246017b1a0aa7f5f8f555b24d", "filename": "tests/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2acbb9d1eb5cb59199f16a608a291b4c884e967/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2acbb9d1eb5cb59199f16a608a291b4c884e967/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=f2acbb9d1eb5cb59199f16a608a291b4c884e967", "patch": "@@ -799,3 +799,11 @@ struct SuggestionStyleGood {\n     #[suggestion(code = \"\", style = \"hidden\")]\n     sub: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest_example)]\n+struct SuggestionOnVec {\n+    #[suggestion(suggestion, code = \"\")]\n+    //~^ ERROR `#[suggestion(...)]` is not a valid attribute\n+    sub: Vec<Span>,\n+}"}, {"sha": "61806c80efc0b8195c10a59153bb33fa439f8b37", "filename": "tests/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2acbb9d1eb5cb59199f16a608a291b4c884e967/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2acbb9d1eb5cb59199f16a608a291b4c884e967/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=f2acbb9d1eb5cb59199f16a608a291b4c884e967", "patch": "@@ -589,6 +589,16 @@ error: `code = \"...\"`/`code(...)` must contain only string literals\n LL |     #[suggestion(code = 3)]\n    |                  ^^^^^^^^\n \n+error: `#[suggestion(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:806:5\n+   |\n+LL |     #[suggestion(suggestion, code = \"\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[suggestion(...)]` applied to `Vec` field is ambiguous\n+   = help: to show a suggestion consisting of multiple parts, use a `Subdiagnostic` annotated with `#[multipart_suggestion(...)]`\n+   = help: to show a variable set of suggestions, use a `Vec` of `Subdiagnostic`s annotated with `#[suggestion(...)]`\n+\n error: cannot find attribute `nonsense` in this scope\n   --> $DIR/diagnostic-derive.rs:55:3\n    |\n@@ -660,7 +670,7 @@ note: required by a bound in `DiagnosticBuilder::<'a, G>::set_arg`\n   --> $COMPILER_DIR/rustc_errors/src/diagnostic_builder.rs:LL:CC\n    = note: this error originates in the derive macro `Diagnostic` which comes from the expansion of the macro `forward` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 83 previous errors\n+error: aborting due to 84 previous errors\n \n Some errors have detailed explanations: E0277, E0425.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "09ad69649098342dc26b2da15f462e77c09f8347", "filename": "tests/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2acbb9d1eb5cb59199f16a608a291b4c884e967/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2acbb9d1eb5cb59199f16a608a291b4c884e967/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=f2acbb9d1eb5cb59199f16a608a291b4c884e967", "patch": "@@ -798,3 +798,13 @@ struct SuggestionStyleInvalid4 {\n     #[primary_span]\n     sub: Span,\n }\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(parse_add_paren, code = \"\")]\n+//~^ ERROR suggestion without `#[primary_span]` field\n+struct PrimarySpanOnVec {\n+    #[primary_span]\n+    //~^ ERROR `#[primary_span]` is not a valid attribute\n+    //~| NOTE there must be exactly one primary span\n+    sub: Vec<Span>,\n+}"}, {"sha": "f9d1a63031d7cceb84c5093304e523d8a9b6fcc1", "filename": "tests/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f2acbb9d1eb5cb59199f16a608a291b4c884e967/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2acbb9d1eb5cb59199f16a608a291b4c884e967/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=f2acbb9d1eb5cb59199f16a608a291b4c884e967", "patch": "@@ -501,6 +501,27 @@ error: `#[suggestion(style(...))]` is not a valid attribute\n LL | #[suggestion(parse_add_paren, code = \"\", style(\"foo\"))]\n    |                                          ^^^^^^^^^^^^\n \n+error: `#[primary_span]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:806:5\n+   |\n+LL |     #[primary_span]\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+   = note: there must be exactly one primary span\n+   = help: to create a suggestion with multiple spans, use `#[multipart_suggestion]` instead\n+\n+error: suggestion without `#[primary_span]` field\n+  --> $DIR/subdiagnostic-derive.rs:803:1\n+   |\n+LL | / #[suggestion(parse_add_paren, code = \"\")]\n+LL | |\n+LL | | struct PrimarySpanOnVec {\n+LL | |     #[primary_span]\n+...  |\n+LL | |     sub: Vec<Span>,\n+LL | | }\n+   | |_^\n+\n error: cannot find attribute `foo` in this scope\n   --> $DIR/subdiagnostic-derive.rs:63:3\n    |\n@@ -561,6 +582,6 @@ error[E0425]: cannot find value `slug` in module `rustc_errors::fluent`\n LL | #[label(slug)]\n    |         ^^^^ not found in `rustc_errors::fluent`\n \n-error: aborting due to 79 previous errors\n+error: aborting due to 81 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}]}