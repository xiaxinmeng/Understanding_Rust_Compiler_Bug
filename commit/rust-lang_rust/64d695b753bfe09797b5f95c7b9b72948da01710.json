{"sha": "64d695b753bfe09797b5f95c7b9b72948da01710", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZDY5NWI3NTNiZmUwOTc5N2I1Zjk1YzdiOWI3Mjk0OGRhMDE3MTA=", "commit": {"author": {"name": "Philippe Laflamme", "email": "philippe.laflamme@gmail.com", "date": "2020-10-23T03:52:07Z"}, "committer": {"name": "Philippe Laflamme", "email": "philippe.laflamme@gmail.com", "date": "2021-01-14T04:14:00Z"}, "message": "Adds tests to ensure some base op traits exist.\n\nThese tests invoke the various op traits using all accepted types they\nare implemented for as well as for references to those types.\n\nThis fixes #49660 and ensures the following implementations exist:\n\n* `Add`, `Sub`, `Mul`, `Div`, `Rem`\n  * `T op T`, `T op &T`, `&T op T` and `&T op &T`\n  * for all integer and floating point types\n* `AddAssign`, `SubAssign`, `MulAssign`, `DivAssign`, `RemAssign`\n  * `&mut T op T` and `&mut T op &T`\n  * for all integer and floating point types\n* `Neg`\n  * `op T` and `op &T`\n  * for all signed integer and floating point types\n* `Not`\n  * `op T` and `op &T`\n  * for `bool`\n* `BitAnd`, `BitOr`, `BitXor`\n  * `T op T`, `T op &T`, `&T op T` and `&T op &T`\n  * for all integer types and bool\n* `BitAndAssign`, `BitOrAssign`, `BitXorAssign`\n  * `&mut T op T` and `&mut T op &T`\n  * for all integer types and bool\n* `Shl`, `Shr`\n  * `L op R`, `L op &R`, `&L op R` and `&L op &R`\n  * for all pairs of integer types\n* `ShlAssign`, `ShrAssign`\n  * `&mut L op R`, `&mut L op &R`\n  * for all pairs of integer types", "tree": {"sha": "a01f3827be640131dc03a287e00af5dd94ca925c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a01f3827be640131dc03a287e00af5dd94ca925c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64d695b753bfe09797b5f95c7b9b72948da01710", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJQBAABCgA6FiEE+HocooijKK2PufZZCLxEPNEOTcQFAl//xQgcHHBoaWxpcHBl\nLmxhZmxhbW1lQGdtYWlsLmNvbQAKCRAIvEQ80Q5NxDIbEACVtyVDm3OA770KqXZ8\nJ/XVHBbYXSkqPUnVFIZKV+24w2J0v53EQ8za+yfzEFdUO/MF8J973GIICJxMU7/z\nKoi27QNgZywbdESqgONuOxDMiT0JpXokDpEx/NqvmRtqNbnVWa+l4mt+deeN0rE7\nsfYPcylzTpNngBsJkWfmsLfR5EajXS8nelqVnYuW8/X5MKI89PPnty3tXyU6Q+wb\nIF17D+ZVcPCEzif2qEUf/HdHEQr52csnXNnV1PYw0cL+dNN2DiPUbkd9zzKPN2sh\nv4J9I1Pe1Vbph/LvrFBrGsUoZAigqssYM55dlF00QyYw1ZiZxXds5/jhSAKnEjD5\nVSoeD1fnRnDGwcZHkI7uQaCC6hK3JGAuIXhg8AezsAt+ezjtUtDBmxpkTZ/SCV+Z\n12I7cfXEcsYlERtfbw6RTZbxx8BpSzxuDVCaldrI49OfBBXUMZGO9nAJhj/0nt10\n5bL0QAiFJfuemI+od/evj7FieJgDaLauHA0/intqeCmtnW9Zc0uuuPa0shvbSXiU\nA9MSzUwsiEheI432FZF3L1krkwdkchA99a5A8FJQh98KUyZGSlDjJbxUamioPQln\nVq83w1ijMl19wbsvKiA7iQD5JwxETSmoPeTIhpful3Ge6ccQPw2G5UCGno10OEOk\nnuhijgLtq1gLRhs+Cyyld654MQ==\n=NP6e\n-----END PGP SIGNATURE-----", "payload": "tree a01f3827be640131dc03a287e00af5dd94ca925c\nparent 8ddad18283e304753e09ef651209b4a6b54148b0\nauthor Philippe Laflamme <philippe.laflamme@gmail.com> 1603425127 -0400\ncommitter Philippe Laflamme <philippe.laflamme@gmail.com> 1610597640 -0500\n\nAdds tests to ensure some base op traits exist.\n\nThese tests invoke the various op traits using all accepted types they\nare implemented for as well as for references to those types.\n\nThis fixes #49660 and ensures the following implementations exist:\n\n* `Add`, `Sub`, `Mul`, `Div`, `Rem`\n  * `T op T`, `T op &T`, `&T op T` and `&T op &T`\n  * for all integer and floating point types\n* `AddAssign`, `SubAssign`, `MulAssign`, `DivAssign`, `RemAssign`\n  * `&mut T op T` and `&mut T op &T`\n  * for all integer and floating point types\n* `Neg`\n  * `op T` and `op &T`\n  * for all signed integer and floating point types\n* `Not`\n  * `op T` and `op &T`\n  * for `bool`\n* `BitAnd`, `BitOr`, `BitXor`\n  * `T op T`, `T op &T`, `&T op T` and `&T op &T`\n  * for all integer types and bool\n* `BitAndAssign`, `BitOrAssign`, `BitXorAssign`\n  * `&mut T op T` and `&mut T op &T`\n  * for all integer types and bool\n* `Shl`, `Shr`\n  * `L op R`, `L op &R`, `&L op R` and `&L op &R`\n  * for all pairs of integer types\n* `ShlAssign`, `ShrAssign`\n  * `&mut L op R`, `&mut L op &R`\n  * for all pairs of integer types\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64d695b753bfe09797b5f95c7b9b72948da01710", "html_url": "https://github.com/rust-lang/rust/commit/64d695b753bfe09797b5f95c7b9b72948da01710", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64d695b753bfe09797b5f95c7b9b72948da01710/comments", "author": {"login": "plaflamme", "id": 484152, "node_id": "MDQ6VXNlcjQ4NDE1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/484152?v=4", "gravatar_id": "", "url": "https://api.github.com/users/plaflamme", "html_url": "https://github.com/plaflamme", "followers_url": "https://api.github.com/users/plaflamme/followers", "following_url": "https://api.github.com/users/plaflamme/following{/other_user}", "gists_url": "https://api.github.com/users/plaflamme/gists{/gist_id}", "starred_url": "https://api.github.com/users/plaflamme/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/plaflamme/subscriptions", "organizations_url": "https://api.github.com/users/plaflamme/orgs", "repos_url": "https://api.github.com/users/plaflamme/repos", "events_url": "https://api.github.com/users/plaflamme/events{/privacy}", "received_events_url": "https://api.github.com/users/plaflamme/received_events", "type": "User", "site_admin": false}, "committer": {"login": "plaflamme", "id": 484152, "node_id": "MDQ6VXNlcjQ4NDE1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/484152?v=4", "gravatar_id": "", "url": "https://api.github.com/users/plaflamme", "html_url": "https://github.com/plaflamme", "followers_url": "https://api.github.com/users/plaflamme/followers", "following_url": "https://api.github.com/users/plaflamme/following{/other_user}", "gists_url": "https://api.github.com/users/plaflamme/gists{/gist_id}", "starred_url": "https://api.github.com/users/plaflamme/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/plaflamme/subscriptions", "organizations_url": "https://api.github.com/users/plaflamme/orgs", "repos_url": "https://api.github.com/users/plaflamme/repos", "events_url": "https://api.github.com/users/plaflamme/events{/privacy}", "received_events_url": "https://api.github.com/users/plaflamme/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ddad18283e304753e09ef651209b4a6b54148b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ddad18283e304753e09ef651209b4a6b54148b0", "html_url": "https://github.com/rust-lang/rust/commit/8ddad18283e304753e09ef651209b4a6b54148b0"}], "stats": {"total": 245, "additions": 245, "deletions": 0}, "files": [{"sha": "e66a73ac1289b22201cbc7ee0ef1a4906f15c571", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/64d695b753bfe09797b5f95c7b9b72948da01710/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64d695b753bfe09797b5f95c7b9b72948da01710/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=64d695b753bfe09797b5f95c7b9b72948da01710", "patch": "@@ -29,6 +29,7 @@ mod u8;\n mod bignum;\n mod dec2flt;\n mod flt2dec;\n+mod ops;\n mod wrapping;\n \n mod nan;"}, {"sha": "9979cc8fde4341d3579cdc600a3412c6ac3b7246", "filename": "library/core/tests/num/ops.rs", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/64d695b753bfe09797b5f95c7b9b72948da01710/library%2Fcore%2Ftests%2Fnum%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64d695b753bfe09797b5f95c7b9b72948da01710/library%2Fcore%2Ftests%2Fnum%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fops.rs?ref=64d695b753bfe09797b5f95c7b9b72948da01710", "patch": "@@ -0,0 +1,244 @@\n+use core::ops::*;\n+\n+// For types L and R, checks that a trait implementation exists for\n+//   * binary ops: L op R, L op &R, &L op R and &L op &R\n+//   * assign ops: &mut L op R, &mut L op &R\n+macro_rules! impl_defined {\n+    ($op:ident, $method:ident($lhs:literal, $rhs:literal), $result:literal, $lt:ty, $rt:ty) => {\n+        let lhs = $lhs as $lt;\n+        let rhs = $rhs as $rt;\n+        assert_eq!($result as $lt, $op::$method(lhs, rhs));\n+        assert_eq!($result as $lt, $op::$method(lhs, &rhs));\n+        assert_eq!($result as $lt, $op::$method(&lhs, rhs));\n+        assert_eq!($result as $lt, $op::$method(&lhs, &rhs));\n+    };\n+    ($op:ident, $method:ident(&mut $lhs:literal, $rhs:literal), $result:literal, $lt:ty, $rt:ty) => {\n+        let rhs = $rhs as $rt;\n+        let mut lhs = $lhs as $lt;\n+        $op::$method(&mut lhs, rhs);\n+        assert_eq!($result as $lt, lhs);\n+\n+        let mut lhs = $lhs as $lt;\n+        $op::$method(&mut lhs, &rhs);\n+        assert_eq!($result as $lt, lhs);\n+    };\n+}\n+\n+// For all specified types T, checks that a trait implementation exists for\n+//   * binary ops: T op T, T op &T, &T op T and &T op &T\n+//   * assign ops: &mut T op T, &mut T op &T\n+//   * unary ops: op T and op &T\n+macro_rules! impls_defined {\n+    ($op:ident, $method:ident($lhs:literal, $rhs:literal), $result:literal, $($t:ty),+) => {$(\n+        impl_defined!($op, $method($lhs, $rhs), $result, $t, $t);\n+    )+};\n+    ($op:ident, $method:ident(&mut $lhs:literal, $rhs:literal), $result:literal, $($t:ty),+) => {$(\n+        impl_defined!($op, $method(&mut $lhs, $rhs), $result, $t, $t);\n+    )+};\n+    ($op:ident, $method:ident($operand:literal), $result:literal, $($t:ty),+) => {$(\n+        let operand = $operand as $t;\n+        assert_eq!($result as $t, $op::$method(operand));\n+        assert_eq!($result as $t, $op::$method(&operand));\n+    )+};\n+}\n+\n+macro_rules! test_op {\n+    ($fn_name:ident, $op:ident::$method:ident($lhs:literal, $rhs:literal), $result:literal, $($t:ty),+) => {\n+        #[test]\n+        fn $fn_name() {\n+            impls_defined!($op, $method($lhs, $rhs), $result, $($t),+);\n+        }\n+    };\n+    ($fn_name:ident, $op:ident::$method:ident(&mut $lhs:literal, $rhs:literal), $result:literal, $($t:ty),+) => {\n+        #[test]\n+        fn $fn_name() {\n+            impls_defined!($op, $method(&mut $lhs, $rhs), $result, $($t),+);\n+        }\n+    };\n+    ($fn_name:ident, $op:ident::$method:ident($lhs:literal), $result:literal, $($t:ty),+) => {\n+        #[test]\n+        fn $fn_name() {\n+            impls_defined!($op, $method($lhs), $result, $($t),+);\n+        }\n+    };\n+}\n+\n+test_op!(test_neg_defined, Neg::neg(0), 0, i8, i16, i32, i64, f32, f64);\n+#[cfg(not(target_os = \"emscripten\"))]\n+test_op!(test_neg_defined_128, Neg::neg(0), 0, i128);\n+\n+test_op!(test_not_defined_bool, Not::not(true), false, bool);\n+\n+macro_rules! test_arith_op {\n+    ($fn_name:ident, $op:ident::$method:ident($lhs:literal, $rhs:literal)) => {\n+        #[test]\n+        fn $fn_name() {\n+            impls_defined!(\n+                $op,\n+                $method($lhs, $rhs),\n+                0,\n+                i8,\n+                i16,\n+                i32,\n+                i64,\n+                isize,\n+                u8,\n+                u16,\n+                u32,\n+                u64,\n+                usize,\n+                f32,\n+                f64\n+            );\n+            #[cfg(not(target_os = \"emscripten\"))]\n+            impls_defined!($op, $method($lhs, $rhs), 0, i128, u128);\n+        }\n+    };\n+    ($fn_name:ident, $op:ident::$method:ident(&mut $lhs:literal, $rhs:literal)) => {\n+        #[test]\n+        fn $fn_name() {\n+            impls_defined!(\n+                $op,\n+                $method(&mut $lhs, $rhs),\n+                0,\n+                i8,\n+                i16,\n+                i32,\n+                i64,\n+                isize,\n+                u8,\n+                u16,\n+                u32,\n+                u64,\n+                usize,\n+                f32,\n+                f64\n+            );\n+            #[cfg(not(target_os = \"emscripten\"))]\n+            impls_defined!($op, $method(&mut $lhs, $rhs), 0, i128, u128);\n+        }\n+    };\n+}\n+\n+test_arith_op!(test_add_defined, Add::add(0, 0));\n+test_arith_op!(test_add_assign_defined, AddAssign::add_assign(&mut 0, 0));\n+test_arith_op!(test_sub_defined, Sub::sub(0, 0));\n+test_arith_op!(test_sub_assign_defined, SubAssign::sub_assign(&mut 0, 0));\n+test_arith_op!(test_mul_defined, Mul::mul(0, 0));\n+test_arith_op!(test_mul_assign_defined, MulAssign::mul_assign(&mut 0, 0));\n+test_arith_op!(test_div_defined, Div::div(0, 1));\n+test_arith_op!(test_div_assign_defined, DivAssign::div_assign(&mut 0, 1));\n+test_arith_op!(test_rem_defined, Rem::rem(0, 1));\n+test_arith_op!(test_rem_assign_defined, RemAssign::rem_assign(&mut 0, 1));\n+\n+macro_rules! test_bitop {\n+    ($test_name:ident, $op:ident::$method:ident) => {\n+        #[test]\n+        fn $test_name() {\n+            impls_defined!(\n+                $op,\n+                $method(0, 0),\n+                0,\n+                i8,\n+                i16,\n+                i32,\n+                i64,\n+                isize,\n+                u8,\n+                u16,\n+                u32,\n+                u64,\n+                usize\n+            );\n+            #[cfg(not(target_os = \"emscripten\"))]\n+            impls_defined!($op, $method(0, 0), 0, i128, u128);\n+            impls_defined!($op, $method(false, false), false, bool);\n+        }\n+    };\n+}\n+macro_rules! test_bitop_assign {\n+    ($test_name:ident, $op:ident::$method:ident) => {\n+        #[test]\n+        fn $test_name() {\n+            impls_defined!(\n+                $op,\n+                $method(&mut 0, 0),\n+                0,\n+                i8,\n+                i16,\n+                i32,\n+                i64,\n+                isize,\n+                u8,\n+                u16,\n+                u32,\n+                u64,\n+                usize\n+            );\n+            #[cfg(not(target_os = \"emscripten\"))]\n+            impls_defined!($op, $method(&mut 0, 0), 0, i128, u128);\n+            impls_defined!($op, $method(&mut false, false), false, bool);\n+        }\n+    };\n+}\n+\n+test_bitop!(test_bitand_defined, BitAnd::bitand);\n+test_bitop_assign!(test_bitand_assign_defined, BitAndAssign::bitand_assign);\n+test_bitop!(test_bitor_defined, BitOr::bitor);\n+test_bitop_assign!(test_bitor_assign_defined, BitOrAssign::bitor_assign);\n+test_bitop!(test_bitxor_defined, BitXor::bitxor);\n+test_bitop_assign!(test_bitxor_assign_defined, BitXorAssign::bitxor_assign);\n+\n+macro_rules! test_shift_inner {\n+    ($op:ident::$method:ident, $lt:ty, $($rt:ty),+) => {\n+        $(impl_defined!($op, $method(0,0), 0, $lt, $rt);)+\n+    };\n+    ($op:ident::$method:ident, $lt:ty) => {\n+        test_shift_inner!($op::$method, $lt, i8, i16, i32, i64, isize, u8, u16, u32, u64, usize);\n+        #[cfg(not(target_os = \"emscripten\"))]\n+        test_shift_inner!($op::$method, $lt, i128, u128);\n+    };\n+}\n+\n+macro_rules! test_shift {\n+    ($op:ident::$method:ident, $($lt:ty),+) => {\n+        $(test_shift_inner!($op::$method, $lt);)+\n+    };\n+    ($test_name:ident, $op:ident::$method:ident) => {\n+        #[test]\n+        fn $test_name() {\n+            test_shift!($op::$method, i8, i16, i32, i64, isize, u8, u16, u32, u64, usize);\n+            #[cfg(not(target_os = \"emscripten\"))]\n+            test_shift!($op::$method, i128, u128);\n+        }\n+    };\n+}\n+\n+macro_rules! test_shift_assign_inner {\n+    ($op:ident::$method:ident, $lt:ty, $($rt:ty),+) => {\n+        $(impl_defined!($op, $method(&mut 0,0), 0, $lt, $rt);)+\n+    };\n+    ($op:ident::$method:ident, $lt:ty) => {\n+        test_shift_assign_inner!($op::$method, $lt, i8, i16, i32, i64, isize, u8, u16, u32, u64, usize);\n+        #[cfg(not(target_os = \"emscripten\"))]\n+        test_shift_assign_inner!($op::$method, $lt, i128, u128);\n+    };\n+}\n+\n+macro_rules! test_shift_assign {\n+    ($op:ident::$method:ident, $($lt:ty),+) => {\n+        $(test_shift_assign_inner!($op::$method, $lt);)+\n+    };\n+    ($test_name:ident, $op:ident::$method:ident) => {\n+        #[test]\n+        fn $test_name() {\n+            test_shift_assign!($op::$method, i8, i16, i32, i64, isize, u8, u16, u32, u64, usize);\n+            #[cfg(not(target_os = \"emscripten\"))]\n+            test_shift_assign!($op::$method, i128, u128);\n+        }\n+    };\n+}\n+test_shift!(test_shl_defined, Shl::shl);\n+test_shift_assign!(test_shl_assign_defined, ShlAssign::shl_assign);\n+test_shift!(test_shr_defined, Shr::shr);\n+test_shift_assign!(test_shr_assign_defined, ShrAssign::shr_assign);"}]}