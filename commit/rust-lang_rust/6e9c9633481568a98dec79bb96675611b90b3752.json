{"sha": "6e9c9633481568a98dec79bb96675611b90b3752", "node_id": "C_kwDOAAsO6NoAKDZlOWM5NjMzNDgxNTY4YTk4ZGVjNzliYjk2Njc1NjExYjkwYjM3NTI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-20T15:41:04Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-20T15:41:04Z"}, "message": "internal: Lift out IdentContext from CompletionContext", "tree": {"sha": "a50490d3ebb425f5b09b8e8e1bf5f548c382f0eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a50490d3ebb425f5b09b8e8e1bf5f548c382f0eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e9c9633481568a98dec79bb96675611b90b3752", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e9c9633481568a98dec79bb96675611b90b3752", "html_url": "https://github.com/rust-lang/rust/commit/6e9c9633481568a98dec79bb96675611b90b3752", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e9c9633481568a98dec79bb96675611b90b3752/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcf10cde137bb0b0c4e2be8564c31c2e0e392406", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcf10cde137bb0b0c4e2be8564c31c2e0e392406", "html_url": "https://github.com/rust-lang/rust/commit/bcf10cde137bb0b0c4e2be8564c31c2e0e392406"}], "stats": {"total": 797, "additions": 451, "deletions": 346}, "files": [{"sha": "a0725198f73e5638044c263579d47bcd32f4e3b6", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 56, "deletions": 13, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -23,13 +23,13 @@ pub(crate) mod vis;\n use std::iter;\n \n use hir::{known, ScopeDef};\n-use ide_db::SymbolKind;\n+use ide_db::{imports::import_assets::LocatedImport, SymbolKind};\n use syntax::ast;\n \n use crate::{\n     context::{\n-        ItemListKind, NameContext, NameKind, NameRefContext, NameRefKind, PathKind, PatternContext,\n-        TypeLocation, Visible,\n+        DotAccess, ItemListKind, NameContext, NameKind, NameRefContext, NameRefKind,\n+        PathCompletionCtx, PathKind, PatternContext, TypeLocation, Visible,\n     },\n     item::Builder,\n     render::{\n@@ -38,7 +38,7 @@ use crate::{\n         literal::{render_struct_literal, render_variant_lit},\n         macro_::render_macro,\n         pattern::{render_struct_pat, render_variant_pat},\n-        render_field, render_resolution, render_resolution_simple, render_tuple_field,\n+        render_field, render_path_resolution, render_resolution_simple, render_tuple_field,\n         type_alias::{render_type_alias, render_type_alias_with_eq},\n         union_literal::render_union_literal,\n         RenderContext,\n@@ -137,23 +137,27 @@ impl Completions {\n     pub(crate) fn add_crate_roots(&mut self, ctx: &CompletionContext) {\n         ctx.process_all_names(&mut |name, res| match res {\n             ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) if m.is_crate_root(ctx.db) => {\n-                self.add_resolution(ctx, name, res);\n+                self.add_module(ctx, m, name);\n             }\n             _ => (),\n         });\n     }\n \n-    pub(crate) fn add_resolution(\n+    pub(crate) fn add_path_resolution(\n         &mut self,\n         ctx: &CompletionContext,\n+        path_ctx: &PathCompletionCtx,\n         local_name: hir::Name,\n         resolution: hir::ScopeDef,\n     ) {\n         if ctx.is_scope_def_hidden(resolution) {\n             cov_mark::hit!(qualified_path_doc_hidden);\n             return;\n         }\n-        self.add(render_resolution(RenderContext::new(ctx), local_name, resolution).build());\n+        self.add(\n+            render_path_resolution(RenderContext::new(ctx), path_ctx, local_name, resolution)\n+                .build(),\n+        );\n     }\n \n     pub(crate) fn add_resolution_simple(\n@@ -174,12 +178,13 @@ impl Completions {\n         module: hir::Module,\n         local_name: hir::Name,\n     ) {\n-        self.add_resolution(ctx, local_name, hir::ScopeDef::ModuleDef(module.into()));\n+        self.add_resolution_simple(ctx, local_name, hir::ScopeDef::ModuleDef(module.into()));\n     }\n \n     pub(crate) fn add_macro(\n         &mut self,\n         ctx: &CompletionContext,\n+        path_ctx: &PathCompletionCtx,\n         mac: hir::Macro,\n         local_name: hir::Name,\n     ) {\n@@ -191,6 +196,7 @@ impl Completions {\n         self.add(\n             render_macro(\n                 RenderContext::new(ctx).private_editable(is_private_editable),\n+                path_ctx,\n                 local_name,\n                 mac,\n             )\n@@ -201,6 +207,7 @@ impl Completions {\n     pub(crate) fn add_function(\n         &mut self,\n         ctx: &CompletionContext,\n+        path_ctx: &PathCompletionCtx,\n         func: hir::Function,\n         local_name: Option<hir::Name>,\n     ) {\n@@ -212,6 +219,7 @@ impl Completions {\n         self.add(\n             render_fn(\n                 RenderContext::new(ctx).private_editable(is_private_editable),\n+                path_ctx,\n                 local_name,\n                 func,\n             )\n@@ -222,6 +230,7 @@ impl Completions {\n     pub(crate) fn add_method(\n         &mut self,\n         ctx: &CompletionContext,\n+        dot_access: &DotAccess,\n         func: hir::Function,\n         receiver: Option<hir::Name>,\n         local_name: Option<hir::Name>,\n@@ -234,6 +243,7 @@ impl Completions {\n         self.add(\n             render_method(\n                 RenderContext::new(ctx).private_editable(is_private_editable),\n+                dot_access,\n                 receiver,\n                 local_name,\n                 func,\n@@ -242,6 +252,32 @@ impl Completions {\n         );\n     }\n \n+    pub(crate) fn add_method_with_import(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        dot_access: &DotAccess,\n+        func: hir::Function,\n+        import: LocatedImport,\n+    ) {\n+        let is_private_editable = match ctx.is_visible(&func) {\n+            Visible::Yes => false,\n+            Visible::Editable => true,\n+            Visible::No => return,\n+        };\n+        self.add(\n+            render_method(\n+                RenderContext::new(ctx)\n+                    .private_editable(is_private_editable)\n+                    .import_to_add(Some(import)),\n+                dot_access,\n+                None,\n+                None,\n+                func,\n+            )\n+            .build(),\n+        );\n+    }\n+\n     pub(crate) fn add_const(&mut self, ctx: &CompletionContext, konst: hir::Const) {\n         let is_private_editable = match ctx.is_visible(&konst) {\n             Visible::Yes => false,\n@@ -277,11 +313,12 @@ impl Completions {\n     pub(crate) fn add_qualified_enum_variant(\n         &mut self,\n         ctx: &CompletionContext,\n+        path_ctx: &PathCompletionCtx,\n         variant: hir::Variant,\n         path: hir::ModPath,\n     ) {\n         if let Some(builder) =\n-            render_variant_lit(RenderContext::new(ctx), None, variant, Some(path))\n+            render_variant_lit(RenderContext::new(ctx), path_ctx, None, variant, Some(path))\n         {\n             self.add(builder.build());\n         }\n@@ -290,11 +327,12 @@ impl Completions {\n     pub(crate) fn add_enum_variant(\n         &mut self,\n         ctx: &CompletionContext,\n+        path_ctx: &PathCompletionCtx,\n         variant: hir::Variant,\n         local_name: Option<hir::Name>,\n     ) {\n         if let Some(builder) =\n-            render_variant_lit(RenderContext::new(ctx), local_name, variant, None)\n+            render_variant_lit(RenderContext::new(ctx), path_ctx, local_name, variant, None)\n         {\n             self.add(builder.build());\n         }\n@@ -324,12 +362,13 @@ impl Completions {\n     pub(crate) fn add_struct_literal(\n         &mut self,\n         ctx: &CompletionContext,\n+        path_ctx: &PathCompletionCtx,\n         strukt: hir::Struct,\n         path: Option<hir::ModPath>,\n         local_name: Option<hir::Name>,\n     ) {\n         if let Some(builder) =\n-            render_struct_literal(RenderContext::new(ctx), strukt, path, local_name)\n+            render_struct_literal(RenderContext::new(ctx), path_ctx, strukt, path, local_name)\n         {\n             self.add(builder.build());\n         }\n@@ -369,11 +408,13 @@ impl Completions {\n     pub(crate) fn add_variant_pat(\n         &mut self,\n         ctx: &CompletionContext,\n+        pattern_ctx: &PatternContext,\n         variant: hir::Variant,\n         local_name: Option<hir::Name>,\n     ) {\n         self.add_opt(render_variant_pat(\n             RenderContext::new(ctx),\n+            pattern_ctx,\n             variant,\n             local_name.clone(),\n             None,\n@@ -383,20 +424,22 @@ impl Completions {\n     pub(crate) fn add_qualified_variant_pat(\n         &mut self,\n         ctx: &CompletionContext,\n+        pattern_ctx: &PatternContext,\n         variant: hir::Variant,\n         path: hir::ModPath,\n     ) {\n         let path = Some(&path);\n-        self.add_opt(render_variant_pat(RenderContext::new(ctx), variant, None, path));\n+        self.add_opt(render_variant_pat(RenderContext::new(ctx), pattern_ctx, variant, None, path));\n     }\n \n     pub(crate) fn add_struct_pat(\n         &mut self,\n         ctx: &CompletionContext,\n+        pattern_ctx: &PatternContext,\n         strukt: hir::Struct,\n         local_name: Option<hir::Name>,\n     ) {\n-        self.add_opt(render_struct_pat(RenderContext::new(ctx), strukt, local_name));\n+        self.add_opt(render_struct_pat(RenderContext::new(ctx), pattern_ctx, strukt, local_name));\n     }\n }\n "}, {"sha": "1c4f9a3113d17091b36c892d2d4641a6a8780a5a", "filename": "crates/ide-completion/src/completions/attribute.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -74,7 +74,7 @@ pub(crate) fn complete_known_attribute_input(\n pub(crate) fn complete_attribute_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n+    path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n     &AttrCtx { kind, annotated_item_kind }: &AttrCtx,\n ) {\n     let is_inner = kind == AttrKind::Inner;\n@@ -92,7 +92,7 @@ pub(crate) fn complete_attribute_path(\n             for (name, def) in module.scope(ctx.db, Some(ctx.module)) {\n                 match def {\n                     hir::ScopeDef::ModuleDef(hir::ModuleDef::Macro(m)) if m.is_attr(ctx.db) => {\n-                        acc.add_macro(ctx, m, name)\n+                        acc.add_macro(ctx, path_ctx, m, name)\n                     }\n                     hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n                         acc.add_module(ctx, m, name)\n@@ -108,7 +108,7 @@ pub(crate) fn complete_attribute_path(\n         Qualified::No => {\n             ctx.process_all_names(&mut |name, def| match def {\n                 hir::ScopeDef::ModuleDef(hir::ModuleDef::Macro(m)) if m.is_attr(ctx.db) => {\n-                    acc.add_macro(ctx, m, name)\n+                    acc.add_macro(ctx, path_ctx, m, name)\n                 }\n                 hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => acc.add_module(ctx, m, name),\n                 _ => (),"}, {"sha": "21298b6ca5ddd2c61b689b8242f015423643566e", "filename": "crates/ide-completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -13,7 +13,7 @@ use crate::{\n pub(crate) fn complete_derive_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n+    path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n     existing_derives: &ExistingDerives,\n ) {\n     let core = ctx.famous_defs().core();\n@@ -33,7 +33,7 @@ pub(crate) fn complete_derive_path(\n                     ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac))\n                         if !existing_derives.contains(&mac) && mac.is_derive(ctx.db) =>\n                     {\n-                        acc.add_macro(ctx, mac, name)\n+                        acc.add_macro(ctx, path_ctx, mac, name)\n                     }\n                     ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => acc.add_module(ctx, m, name),\n                     _ => (),\n@@ -59,7 +59,7 @@ pub(crate) fn complete_derive_path(\n                 match (core, mac.module(ctx.db).krate()) {\n                     // show derive dependencies for `core`/`std` derives\n                     (Some(core), mac_krate) if core == mac_krate => {}\n-                    _ => return acc.add_macro(ctx, mac, name),\n+                    _ => return acc.add_macro(ctx, path_ctx, mac, name),\n                 };\n \n                 let name_ = name.to_smol_str();\n@@ -92,7 +92,7 @@ pub(crate) fn complete_derive_path(\n                         item.lookup_by(lookup);\n                         item.add_to(acc);\n                     }\n-                    None => acc.add_macro(ctx, mac, name),\n+                    None => acc.add_macro(ctx, path_ctx, mac, name),\n                 }\n             });\n             acc.add_nameref_keywords_with_colon(ctx);"}, {"sha": "b58a9f39f2ef97a11da6c45141c725b11e7778ca", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -33,7 +33,7 @@ pub(crate) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext, dot_a\n             |acc, field, ty| acc.add_tuple_field(ctx, None, field, &ty),\n         );\n     }\n-    complete_methods(ctx, &receiver_ty, |func| acc.add_method(ctx, func, None, None));\n+    complete_methods(ctx, &receiver_ty, |func| acc.add_method(ctx, dot_access, func, None, None));\n }\n \n pub(crate) fn complete_undotted_self(\n@@ -68,7 +68,17 @@ pub(crate) fn complete_undotted_self(\n         |acc, field, ty| acc.add_tuple_field(ctx, Some(hir::known::SELF_PARAM), field, &ty),\n     );\n     complete_methods(ctx, &ty, |func| {\n-        acc.add_method(ctx, func, Some(hir::known::SELF_PARAM), None)\n+        acc.add_method(\n+            ctx,\n+            &DotAccess {\n+                receiver: None,\n+                receiver_ty: None,\n+                kind: DotAccessKind::Method { has_parens: false },\n+            },\n+            func,\n+            Some(hir::known::SELF_PARAM),\n+            None,\n+        )\n     });\n }\n "}, {"sha": "9c003be6af4656fdb1f1ee7fa77d0f63cb6dd4aa", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -11,7 +11,7 @@ use crate::{\n pub(crate) fn complete_expr_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n+    path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n     &ExprCtx {\n         in_block_expr,\n         in_loop_body,\n@@ -34,11 +34,12 @@ pub(crate) fn complete_expr_path(\n         ref_expr_parent.as_ref().map(|it| it.mut_token().is_none()).unwrap_or(false);\n \n     let scope_def_applicable = |def| {\n-        use hir::{GenericParam::*, ModuleDef::*};\n         match def {\n-            ScopeDef::GenericParam(LifetimeParam(_)) | ScopeDef::Label(_) => false,\n+            ScopeDef::GenericParam(hir::GenericParam::LifetimeParam(_)) | ScopeDef::Label(_) => {\n+                false\n+            }\n             // Don't suggest attribute macros and derives.\n-            ScopeDef::ModuleDef(Macro(mac)) => mac.is_fn_like(ctx.db),\n+            ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => mac.is_fn_like(ctx.db),\n             _ => true,\n         }\n     };\n@@ -49,7 +50,7 @@ pub(crate) fn complete_expr_path(\n             .0\n             .into_iter()\n             .flat_map(|it| hir::Trait::from(it).items(ctx.sema.db))\n-            .for_each(|item| add_assoc_item(acc, ctx, item)),\n+            .for_each(|item| add_assoc_item(acc, ctx, path_ctx, item)),\n         Qualified::With { resolution: None, .. } => {}\n         Qualified::With { resolution: Some(resolution), .. } => {\n             // Add associated types on type parameters and `Self`.\n@@ -62,7 +63,7 @@ pub(crate) fn complete_expr_path(\n                     let module_scope = module.scope(ctx.db, Some(ctx.module));\n                     for (name, def) in module_scope {\n                         if scope_def_applicable(def) {\n-                            acc.add_resolution(ctx, name, def);\n+                            acc.add_path_resolution(ctx, path_ctx, name, def);\n                         }\n                     }\n                 }\n@@ -73,15 +74,15 @@ pub(crate) fn complete_expr_path(\n                     | hir::ModuleDef::BuiltinType(_)),\n                 ) => {\n                     if let &hir::ModuleDef::Adt(hir::Adt::Enum(e)) = def {\n-                        add_enum_variants(acc, ctx, e);\n+                        add_enum_variants(acc, ctx, path_ctx, e);\n                     }\n                     let ty = match def {\n                         hir::ModuleDef::Adt(adt) => adt.ty(ctx.db),\n                         hir::ModuleDef::TypeAlias(a) => {\n                             let ty = a.ty(ctx.db);\n                             if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n                                 cov_mark::hit!(completes_variant_through_alias);\n-                                add_enum_variants(acc, ctx, e);\n+                                add_enum_variants(acc, ctx, path_ctx, e);\n                             }\n                             ty\n                         }\n@@ -102,7 +103,7 @@ pub(crate) fn complete_expr_path(\n                         Some(ctx.module),\n                         None,\n                         |item| {\n-                            add_assoc_item(acc, ctx, item);\n+                            add_assoc_item(acc, ctx, path_ctx, item);\n                             None::<()>\n                         },\n                     );\n@@ -118,7 +119,7 @@ pub(crate) fn complete_expr_path(\n                 hir::PathResolution::Def(hir::ModuleDef::Trait(t)) => {\n                     // Handles `Trait::assoc` as well as `<Ty as Trait>::assoc`.\n                     for item in t.items(ctx.db) {\n-                        add_assoc_item(acc, ctx, item);\n+                        add_assoc_item(acc, ctx, path_ctx, item);\n                     }\n                 }\n                 hir::PathResolution::TypeParam(_) | hir::PathResolution::SelfType(_) => {\n@@ -129,7 +130,7 @@ pub(crate) fn complete_expr_path(\n                     };\n \n                     if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n-                        add_enum_variants(acc, ctx, e);\n+                        add_enum_variants(acc, ctx, path_ctx, e);\n                     }\n                     let mut seen = FxHashSet::default();\n                     ty.iterate_path_candidates(\n@@ -142,7 +143,7 @@ pub(crate) fn complete_expr_path(\n                             // We might iterate candidates of a trait multiple times here, so deduplicate\n                             // them.\n                             if seen.insert(item) {\n-                                add_assoc_item(acc, ctx, item);\n+                                add_assoc_item(acc, ctx, path_ctx, item);\n                             }\n                             None::<()>\n                         },\n@@ -167,10 +168,16 @@ pub(crate) fn complete_expr_path(\n                             .find_use_path(ctx.db, hir::ModuleDef::from(strukt))\n                             .filter(|it| it.len() > 1);\n \n-                        acc.add_struct_literal(ctx, strukt, path, None);\n+                        acc.add_struct_literal(ctx, path_ctx, strukt, path, None);\n \n                         if complete_self {\n-                            acc.add_struct_literal(ctx, strukt, None, Some(hir::known::SELF_TYPE));\n+                            acc.add_struct_literal(\n+                                ctx,\n+                                path_ctx,\n+                                strukt,\n+                                None,\n+                                Some(hir::known::SELF_TYPE),\n+                            );\n                         }\n                     }\n                     hir::Adt::Union(un) => {\n@@ -191,15 +198,15 @@ pub(crate) fn complete_expr_path(\n                             e,\n                             impl_,\n                             |acc, ctx, variant, path| {\n-                                acc.add_qualified_enum_variant(ctx, variant, path)\n+                                acc.add_qualified_enum_variant(ctx, path_ctx, variant, path)\n                             },\n                         );\n                     }\n                 }\n             }\n             ctx.process_all_names(&mut |name, def| {\n                 if scope_def_applicable(def) {\n-                    acc.add_resolution(ctx, name, def);\n+                    acc.add_path_resolution(ctx, path_ctx, name, def);\n                 }\n             });\n \n@@ -259,14 +266,26 @@ pub(crate) fn complete_expr_path(\n     }\n }\n \n-fn add_assoc_item(acc: &mut Completions, ctx: &CompletionContext, item: hir::AssocItem) {\n+fn add_assoc_item(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    path_ctx: &PathCompletionCtx,\n+    item: hir::AssocItem,\n+) {\n     match item {\n-        hir::AssocItem::Function(func) => acc.add_function(ctx, func, None),\n+        hir::AssocItem::Function(func) => acc.add_function(ctx, path_ctx, func, None),\n         hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n         hir::AssocItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n     }\n }\n \n-fn add_enum_variants(acc: &mut Completions, ctx: &CompletionContext, e: hir::Enum) {\n-    e.variants(ctx.db).into_iter().for_each(|variant| acc.add_enum_variant(ctx, variant, None));\n+fn add_enum_variants(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    path_ctx: &PathCompletionCtx,\n+    e: hir::Enum,\n+) {\n+    e.variants(ctx.db)\n+        .into_iter()\n+        .for_each(|variant| acc.add_enum_variant(ctx, path_ctx, variant, None));\n }"}, {"sha": "129910465c22cd124ff10ac52474320b52e4a511", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 75, "deletions": 35, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -116,17 +116,17 @@ pub(crate) fn import_on_the_fly_path(\n     if !ctx.config.enable_imports_on_the_fly {\n         return None;\n     }\n-    let (kind, qualified) = match path_ctx {\n+    let qualified = match path_ctx {\n         PathCompletionCtx {\n             kind:\n-                kind @ (PathKind::Expr { .. }\n+                PathKind::Expr { .. }\n                 | PathKind::Type { .. }\n                 | PathKind::Attr { .. }\n                 | PathKind::Derive { .. }\n-                | PathKind::Pat { .. }),\n+                | PathKind::Pat { .. },\n             qualified,\n             ..\n-        } => (Some(kind), qualified),\n+        } => qualified,\n         _ => return None,\n     };\n     let potential_import_name = import_name(ctx);\n@@ -139,71 +139,78 @@ pub(crate) fn import_on_the_fly_path(\n     import_on_the_fly(\n         acc,\n         ctx,\n-        kind,\n+        path_ctx,\n         import_assets,\n         qualifier.map(|it| it.syntax().clone()).or_else(|| ctx.original_token.parent())?,\n         potential_import_name,\n     )\n }\n \n-pub(crate) fn import_on_the_fly_dot(\n+pub(crate) fn import_on_the_fly_pat(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    dot_access: &DotAccess,\n+    pat_ctx: &PatternContext,\n ) -> Option<()> {\n     if !ctx.config.enable_imports_on_the_fly {\n         return None;\n     }\n-    let receiver = dot_access.receiver.as_ref()?;\n-    let ty = dot_access.receiver_ty.as_ref()?;\n+    if let PatternContext { record_pat: Some(_), .. } = pat_ctx {\n+        return None;\n+    }\n+\n     let potential_import_name = import_name(ctx);\n-    let import_assets = ImportAssets::for_fuzzy_method_call(\n-        ctx.module,\n-        ty.original.clone(),\n-        potential_import_name.clone(),\n-        receiver.syntax().clone(),\n-    )?;\n+    let import_assets = import_assets_for_path(ctx, &potential_import_name, None)?;\n \n     import_on_the_fly(\n         acc,\n         ctx,\n-        None,\n+        &PathCompletionCtx {\n+            has_call_parens: false,\n+            has_macro_bang: false,\n+            qualified: Qualified::No,\n+            parent: None,\n+            kind: crate::context::PathKind::Pat { pat_ctx: pat_ctx.clone() },\n+            has_type_args: false,\n+            use_tree_parent: false,\n+        },\n         import_assets,\n-        receiver.syntax().clone(),\n+        ctx.original_token.parent()?,\n         potential_import_name,\n     )\n }\n \n-pub(crate) fn import_on_the_fly_pat(\n+pub(crate) fn import_on_the_fly_dot(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    pat_ctx: &PatternContext,\n+    dot_access: &DotAccess,\n ) -> Option<()> {\n     if !ctx.config.enable_imports_on_the_fly {\n         return None;\n     }\n-    let kind = match pat_ctx {\n-        PatternContext { record_pat: None, .. } => PathKind::Pat { pat_ctx: pat_ctx.clone() },\n-        _ => return None,\n-    };\n-\n+    let receiver = dot_access.receiver.as_ref()?;\n+    let ty = dot_access.receiver_ty.as_ref()?;\n     let potential_import_name = import_name(ctx);\n-    let import_assets = import_assets_for_path(ctx, &potential_import_name, None)?;\n+    let import_assets = ImportAssets::for_fuzzy_method_call(\n+        ctx.module,\n+        ty.original.clone(),\n+        potential_import_name.clone(),\n+        receiver.syntax().clone(),\n+    )?;\n \n-    import_on_the_fly(\n+    import_on_the_fly_method(\n         acc,\n         ctx,\n-        Some(&kind),\n+        dot_access,\n         import_assets,\n-        ctx.original_token.parent()?,\n+        receiver.syntax().clone(),\n         potential_import_name,\n     )\n }\n \n fn import_on_the_fly(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    path_kind: Option<&PathKind>,\n+    path_ctx @ PathCompletionCtx { kind, .. }: &PathCompletionCtx,\n     import_assets: ImportAssets,\n     position: SyntaxNode,\n     potential_import_name: String,\n@@ -215,11 +222,7 @@ fn import_on_the_fly(\n     }\n \n     let ns_filter = |import: &LocatedImport| {\n-        let path_kind = match path_kind {\n-            Some(it) => it,\n-            None => return true,\n-        };\n-        match (path_kind, import.original_item) {\n+        match (kind, import.original_item) {\n             // Aren't handled in flyimport\n             (PathKind::Vis { .. } | PathKind::Use, _) => false,\n             // modules are always fair game\n@@ -276,12 +279,49 @@ fn import_on_the_fly(\n                     &user_input_lowercased,\n                 )\n             })\n-            .filter_map(|import| render_resolution_with_import(RenderContext::new(ctx), import))\n+            .filter_map(|import| {\n+                render_resolution_with_import(RenderContext::new(ctx), path_ctx, import)\n+            })\n             .map(|builder| builder.build()),\n     );\n     Some(())\n }\n \n+fn import_on_the_fly_method(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    dot_access: &DotAccess,\n+    import_assets: ImportAssets,\n+    position: SyntaxNode,\n+    potential_import_name: String,\n+) -> Option<()> {\n+    let _p = profile::span(\"import_on_the_fly\").detail(|| potential_import_name.clone());\n+\n+    if ImportScope::find_insert_use_container(&position, &ctx.sema).is_none() {\n+        return None;\n+    }\n+\n+    let user_input_lowercased = potential_import_name.to_lowercase();\n+\n+    import_assets\n+        .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n+        .into_iter()\n+        .filter(|import| {\n+            !ctx.is_item_hidden(&import.item_to_import)\n+                && !ctx.is_item_hidden(&import.original_item)\n+        })\n+        .sorted_by_key(|located_import| {\n+            compute_fuzzy_completion_order_key(&located_import.import_path, &user_input_lowercased)\n+        })\n+        .for_each(|import| match import.original_item {\n+            ItemInNs::Values(hir::ModuleDef::Function(f)) => {\n+                acc.add_method_with_import(ctx, dot_access, f, import);\n+            }\n+            _ => (),\n+        });\n+    Some(())\n+}\n+\n fn import_name(ctx: &CompletionContext) -> String {\n     let token_kind = ctx.token.kind();\n     if matches!(token_kind, T![.] | T![::]) {"}, {"sha": "329d08a9e764c79550357350f4ed922b23244e01", "filename": "crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -42,7 +42,7 @@ pub(crate) fn complete_item_list(\n             for (name, def) in module.scope(ctx.db, Some(ctx.module)) {\n                 match def {\n                     hir::ScopeDef::ModuleDef(hir::ModuleDef::Macro(m)) if m.is_fn_like(ctx.db) => {\n-                        acc.add_macro(ctx, m, name)\n+                        acc.add_macro(ctx, path_ctx, m, name)\n                     }\n                     hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n                         acc.add_module(ctx, m, name)\n@@ -59,7 +59,7 @@ pub(crate) fn complete_item_list(\n         Qualified::No if ctx.qualifier_ctx.none() => {\n             ctx.process_all_names(&mut |name, def| match def {\n                 hir::ScopeDef::ModuleDef(hir::ModuleDef::Macro(m)) if m.is_fn_like(ctx.db) => {\n-                    acc.add_macro(ctx, m, name)\n+                    acc.add_macro(ctx, path_ctx, m, name)\n                 }\n                 hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => acc.add_module(ctx, m, name),\n                 _ => (),"}, {"sha": "91d535654105635195d26e8c019bab3e26abe92a", "filename": "crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -13,9 +13,9 @@ use crate::{\n pub(crate) fn complete_pattern(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    patctx: &PatternContext,\n+    pattern_ctx: &PatternContext,\n ) {\n-    match patctx.parent_pat.as_ref() {\n+    match pattern_ctx.parent_pat.as_ref() {\n         Some(Pat::RangePat(_) | Pat::BoxPat(_)) => (),\n         Some(Pat::RefPat(r)) => {\n             if r.mut_token().is_none() {\n@@ -24,7 +24,7 @@ pub(crate) fn complete_pattern(\n         }\n         _ => {\n             let tok = ctx.token.text_range().start();\n-            match (patctx.ref_token.as_ref(), patctx.mut_token.as_ref()) {\n+            match (pattern_ctx.ref_token.as_ref(), pattern_ctx.mut_token.as_ref()) {\n                 (None, None) => {\n                     acc.add_keyword(ctx, \"ref\");\n                     acc.add_keyword(ctx, \"mut\");\n@@ -40,11 +40,11 @@ pub(crate) fn complete_pattern(\n         }\n     }\n \n-    if patctx.record_pat.is_some() {\n+    if pattern_ctx.record_pat.is_some() {\n         return;\n     }\n \n-    let refutable = patctx.refutability == PatternRefutability::Refutable;\n+    let refutable = pattern_ctx.refutability == PatternRefutability::Refutable;\n     let single_variant_enum = |enum_: hir::Enum| ctx.db.enum_data(enum_.into()).variants.len() == 1;\n \n     if let Some(hir::Adt::Enum(e)) =\n@@ -55,9 +55,9 @@ pub(crate) fn complete_pattern(\n                 acc,\n                 ctx,\n                 e,\n-                &patctx.impl_,\n+                &pattern_ctx.impl_,\n                 |acc, ctx, variant, path| {\n-                    acc.add_qualified_variant_pat(ctx, variant, path);\n+                    acc.add_qualified_variant_pat(ctx, pattern_ctx, variant, path);\n                 },\n             );\n         }\n@@ -69,26 +69,39 @@ pub(crate) fn complete_pattern(\n         let add_simple_path = match res {\n             hir::ScopeDef::ModuleDef(def) => match def {\n                 hir::ModuleDef::Adt(hir::Adt::Struct(strukt)) => {\n-                    acc.add_struct_pat(ctx, strukt, Some(name.clone()));\n+                    acc.add_struct_pat(ctx, pattern_ctx, strukt, Some(name.clone()));\n                     true\n                 }\n                 hir::ModuleDef::Variant(variant)\n                     if refutable || single_variant_enum(variant.parent_enum(ctx.db)) =>\n                 {\n-                    acc.add_variant_pat(ctx, variant, Some(name.clone()));\n+                    acc.add_variant_pat(ctx, pattern_ctx, variant, Some(name.clone()));\n                     true\n                 }\n                 hir::ModuleDef::Adt(hir::Adt::Enum(e)) => refutable || single_variant_enum(e),\n                 hir::ModuleDef::Const(..) => refutable,\n                 hir::ModuleDef::Module(..) => true,\n                 hir::ModuleDef::Macro(mac) if mac.is_fn_like(ctx.db) => {\n-                    return acc.add_macro(ctx, mac, name)\n+                    return acc.add_macro(\n+                        ctx,\n+                        &PathCompletionCtx {\n+                            has_call_parens: false,\n+                            has_macro_bang: false,\n+                            qualified: Qualified::No,\n+                            parent: None,\n+                            kind: crate::context::PathKind::Pat { pat_ctx: pattern_ctx.clone() },\n+                            has_type_args: false,\n+                            use_tree_parent: false,\n+                        },\n+                        mac,\n+                        name,\n+                    )\n                 }\n                 _ => false,\n             },\n             hir::ScopeDef::ImplSelfType(impl_) => match impl_.self_ty(ctx.db).as_adt() {\n                 Some(hir::Adt::Struct(strukt)) => {\n-                    acc.add_struct_pat(ctx, strukt, Some(name.clone()));\n+                    acc.add_struct_pat(ctx, pattern_ctx, strukt, Some(name.clone()));\n                     true\n                 }\n                 Some(hir::Adt::Enum(e)) => refutable || single_variant_enum(e),\n@@ -111,7 +124,7 @@ pub(crate) fn complete_pattern(\n pub(crate) fn complete_pattern_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n+    path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n ) {\n     match qualified {\n         Qualified::With { resolution: Some(resolution), is_super_chain, .. } => {\n@@ -132,7 +145,7 @@ pub(crate) fn complete_pattern_path(\n                         };\n \n                         if add_resolution {\n-                            acc.add_resolution(ctx, name, def);\n+                            acc.add_path_resolution(ctx, path_ctx, name, def);\n                         }\n                     }\n                 }\n@@ -150,9 +163,9 @@ pub(crate) fn complete_pattern_path(\n                         }\n                         hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Enum(e))) => {\n                             cov_mark::hit!(enum_plain_qualified_use_tree);\n-                            e.variants(ctx.db)\n-                                .into_iter()\n-                                .for_each(|variant| acc.add_enum_variant(ctx, variant, None));\n+                            e.variants(ctx.db).into_iter().for_each(|variant| {\n+                                acc.add_enum_variant(ctx, path_ctx, variant, None)\n+                            });\n                             e.ty(ctx.db)\n                         }\n                         hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Union(u))) => {\n@@ -197,7 +210,7 @@ pub(crate) fn complete_pattern_path(\n             ctx.process_all_names(&mut |name, res| {\n                 // FIXME: properly filter here\n                 if let ScopeDef::ModuleDef(_) = res {\n-                    acc.add_resolution(ctx, name, res);\n+                    acc.add_path_resolution(ctx, path_ctx, name, res);\n                 }\n             });\n "}, {"sha": "dea0c701b84e1dc6daa43ace3a5f4419da9d7a1d", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -13,7 +13,7 @@ use crate::{\n pub(crate) fn complete_type_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n+    path_ctx @ PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n     location: &TypeLocation,\n ) {\n     let _p = profile::span(\"complete_type_path\");\n@@ -69,7 +69,7 @@ pub(crate) fn complete_type_path(\n                     let module_scope = module.scope(ctx.db, Some(ctx.module));\n                     for (name, def) in module_scope {\n                         if scope_def_applicable(def) {\n-                            acc.add_resolution(ctx, name, def);\n+                            acc.add_path_resolution(ctx, path_ctx, name, def);\n                         }\n                     }\n                 }\n@@ -154,7 +154,7 @@ pub(crate) fn complete_type_path(\n                         _ => false,\n                     };\n                     if add_resolution {\n-                        acc.add_resolution(ctx, name, res);\n+                        acc.add_path_resolution(ctx, path_ctx, name, res);\n                     }\n                 });\n                 return;\n@@ -178,7 +178,7 @@ pub(crate) fn complete_type_path(\n             }\n             ctx.process_all_names(&mut |name, def| {\n                 if scope_def_applicable(def) {\n-                    acc.add_resolution(ctx, name, def);\n+                    acc.add_path_resolution(ctx, path_ctx, name, def);\n                 }\n             });\n         }"}, {"sha": "2c039d50189cdf9913851bc8cae6bb9e832af2cd", "filename": "crates/ide-completion/src/completions/use_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -13,7 +13,7 @@ use crate::{\n pub(crate) fn complete_use_path(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    PathCompletionCtx { qualified, use_tree_parent, .. }: &PathCompletionCtx,\n+    path_ctx @ PathCompletionCtx { qualified, use_tree_parent, .. }: &PathCompletionCtx,\n     name_ref: &Option<ast::NameRef>,\n ) {\n     match qualified {\n@@ -68,7 +68,7 @@ pub(crate) fn complete_use_path(\n                         };\n \n                         if add_resolution {\n-                            let mut builder = Builder::from_resolution(ctx, name, def);\n+                            let mut builder = Builder::from_resolution(ctx, path_ctx, name, def);\n                             builder.set_relevance(CompletionRelevance {\n                                 is_name_already_imported,\n                                 ..Default::default()\n@@ -81,7 +81,7 @@ pub(crate) fn complete_use_path(\n                     cov_mark::hit!(enum_plain_qualified_use_tree);\n                     e.variants(ctx.db)\n                         .into_iter()\n-                        .for_each(|variant| acc.add_enum_variant(ctx, variant, None));\n+                        .for_each(|variant| acc.add_enum_variant(ctx, path_ctx, variant, None));\n                 }\n                 _ => {}\n             }"}, {"sha": "441f7ad70bf2b7dd492c76caf4940919b7436d94", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -269,7 +269,7 @@ pub(super) enum NameRefKind {\n \n /// The identifier we are currently completing.\n #[derive(Debug)]\n-pub(super) enum IdentContext {\n+pub(super) enum CompletionAnalysis {\n     Name(NameContext),\n     NameRef(NameRefContext),\n     Lifetime(LifetimeContext),\n@@ -338,8 +338,6 @@ pub(crate) struct CompletionContext<'a> {\n     /// The expected type of what we are completing.\n     pub(super) expected_type: Option<Type>,\n \n-    // We might wanna split these out of CompletionContext\n-    pub(super) ident_ctx: IdentContext,\n     pub(super) qualifier_ctx: QualifierCtx,\n \n     pub(super) locals: FxHashMap<Name, Local>,\n@@ -461,7 +459,7 @@ impl<'a> CompletionContext<'a> {\n         db: &'a RootDatabase,\n         position @ FilePosition { file_id, offset }: FilePosition,\n         config: &'a CompletionConfig,\n-    ) -> Option<CompletionContext<'a>> {\n+    ) -> Option<(CompletionContext<'a>, CompletionAnalysis)> {\n         let _p = profile::span(\"CompletionContext::new\");\n         let sema = Semantics::new(db);\n \n@@ -503,21 +501,16 @@ impl<'a> CompletionContext<'a> {\n             module,\n             expected_name: None,\n             expected_type: None,\n-            // dummy value, will be overwritten\n-            ident_ctx: IdentContext::UnexpandedAttrTT {\n-                fake_attribute_under_caret: None,\n-                colon_prefix: false,\n-            },\n             qualifier_ctx: Default::default(),\n             locals,\n         };\n-        ctx.expand_and_fill(\n+        let ident_ctx = ctx.expand_and_analyze(\n             original_file.syntax().clone(),\n             file_with_fake_ident.syntax().clone(),\n             offset,\n             fake_ident_token,\n         )?;\n-        Some(ctx)\n+        Some((ctx, ident_ctx))\n     }\n }\n "}, {"sha": "7e6c842b1e05aba24f62a73d68cfbca905ad6c84", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -11,23 +11,23 @@ use syntax::{\n };\n \n use crate::context::{\n-    AttrCtx, CompletionContext, DotAccess, DotAccessKind, ExprCtx, IdentContext, ItemListKind,\n-    LifetimeContext, LifetimeKind, NameContext, NameKind, NameRefContext, NameRefKind, ParamKind,\n-    PathCompletionCtx, PathKind, PatternContext, PatternRefutability, Qualified, QualifierCtx,\n-    TypeAscriptionTarget, TypeLocation, COMPLETION_MARKER,\n+    AttrCtx, CompletionAnalysis, CompletionContext, DotAccess, DotAccessKind, ExprCtx,\n+    ItemListKind, LifetimeContext, LifetimeKind, NameContext, NameKind, NameRefContext,\n+    NameRefKind, ParamKind, PathCompletionCtx, PathKind, PatternContext, PatternRefutability,\n+    Qualified, QualifierCtx, TypeAscriptionTarget, TypeLocation, COMPLETION_MARKER,\n };\n \n impl<'a> CompletionContext<'a> {\n     /// Expand attributes and macro calls at the current cursor position for both the original file\n     /// and fake file repeatedly. As soon as one of the two expansions fail we stop so the original\n     /// and speculative states stay in sync.\n-    pub(super) fn expand_and_fill(\n+    pub(super) fn expand_and_analyze(\n         &mut self,\n         mut original_file: SyntaxNode,\n         mut speculative_file: SyntaxNode,\n         mut offset: TextSize,\n         mut fake_ident_token: SyntaxToken,\n-    ) -> Option<()> {\n+    ) -> Option<CompletionAnalysis> {\n         let _p = profile::span(\"CompletionContext::expand_and_fill\");\n         let mut derive_ctx = None;\n \n@@ -157,7 +157,7 @@ impl<'a> CompletionContext<'a> {\n             break 'expansion;\n         }\n \n-        self.fill(&original_file, speculative_file, offset, derive_ctx)\n+        self.analyze(&original_file, speculative_file, offset, derive_ctx)\n     }\n \n     /// Calculate the expected type and name of the cursor position.\n@@ -311,13 +311,13 @@ impl<'a> CompletionContext<'a> {\n \n     /// Fill the completion context, this is what does semantic reasoning about the surrounding context\n     /// of the completion location.\n-    fn fill(\n+    fn analyze(\n         &mut self,\n         original_file: &SyntaxNode,\n         file_with_fake_ident: SyntaxNode,\n         offset: TextSize,\n         derive_ctx: Option<(SyntaxNode, SyntaxNode, TextSize, ast::Attr)>,\n-    ) -> Option<()> {\n+    ) -> Option<CompletionAnalysis> {\n         let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased()?;\n         let syntax_element = NodeOrToken::Token(fake_ident_token);\n         if is_in_token_of_for_loop(syntax_element.clone()) {\n@@ -350,67 +350,62 @@ impl<'a> CompletionContext<'a> {\n                             .collect(),\n                     };\n                 }\n-                self.ident_ctx = IdentContext::NameRef(nameref_ctx);\n-                return Some(());\n+                return Some(CompletionAnalysis::NameRef(nameref_ctx));\n             }\n             return None;\n         }\n \n         let name_like = match find_node_at_offset(&file_with_fake_ident, offset) {\n             Some(it) => it,\n             None => {\n-                if let Some(original) = ast::String::cast(self.original_token.clone()) {\n-                    self.ident_ctx = IdentContext::String {\n-                        original,\n-                        expanded: ast::String::cast(self.token.clone()),\n-                    };\n-                } else {\n-                    // Fix up trailing whitespace problem\n-                    // #[attr(foo = $0\n-                    let token =\n-                        syntax::algo::skip_trivia_token(self.token.clone(), Direction::Prev)?;\n-                    let p = token.parent()?;\n-                    if p.kind() == SyntaxKind::TOKEN_TREE\n-                        && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n-                    {\n-                        let colon_prefix = previous_non_trivia_token(self.token.clone())\n-                            .map_or(false, |it| T![:] == it.kind());\n-                        self.ident_ctx = IdentContext::UnexpandedAttrTT {\n-                            fake_attribute_under_caret: syntax_element\n-                                .ancestors()\n-                                .find_map(ast::Attr::cast),\n-                            colon_prefix,\n-                        };\n+                let analysis =\n+                    if let Some(original) = ast::String::cast(self.original_token.clone()) {\n+                        CompletionAnalysis::String {\n+                            original,\n+                            expanded: ast::String::cast(self.token.clone()),\n+                        }\n                     } else {\n-                        return None;\n-                    }\n-                }\n-                return Some(());\n+                        // Fix up trailing whitespace problem\n+                        // #[attr(foo = $0\n+                        let token =\n+                            syntax::algo::skip_trivia_token(self.token.clone(), Direction::Prev)?;\n+                        let p = token.parent()?;\n+                        if p.kind() == SyntaxKind::TOKEN_TREE\n+                            && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n+                        {\n+                            let colon_prefix = previous_non_trivia_token(self.token.clone())\n+                                .map_or(false, |it| T![:] == it.kind());\n+                            CompletionAnalysis::UnexpandedAttrTT {\n+                                fake_attribute_under_caret: syntax_element\n+                                    .ancestors()\n+                                    .find_map(ast::Attr::cast),\n+                                colon_prefix,\n+                            }\n+                        } else {\n+                            return None;\n+                        }\n+                    };\n+                return Some(analysis);\n             }\n         };\n-\n-        match name_like {\n-            ast::NameLike::Lifetime(lifetime) => {\n-                self.ident_ctx = IdentContext::Lifetime(Self::classify_lifetime(\n-                    &self.sema,\n-                    original_file,\n-                    lifetime,\n-                )?);\n-            }\n+        let analysis = match name_like {\n+            ast::NameLike::Lifetime(lifetime) => CompletionAnalysis::Lifetime(\n+                Self::classify_lifetime(&self.sema, original_file, lifetime)?,\n+            ),\n             ast::NameLike::NameRef(name_ref) => {\n                 let parent = name_ref.syntax().parent()?;\n                 let (nameref_ctx, qualifier_ctx) =\n                     Self::classify_name_ref(&self.sema, &original_file, name_ref, parent.clone())?;\n \n                 self.qualifier_ctx = qualifier_ctx;\n-                self.ident_ctx = IdentContext::NameRef(nameref_ctx);\n+                CompletionAnalysis::NameRef(nameref_ctx)\n             }\n             ast::NameLike::Name(name) => {\n                 let name_ctx = Self::classify_name(&self.sema, original_file, name)?;\n-                self.ident_ctx = IdentContext::Name(name_ctx);\n+                CompletionAnalysis::Name(name_ctx)\n             }\n-        }\n-        Some(())\n+        };\n+        Some(analysis)\n     }\n \n     fn classify_lifetime("}, {"sha": "c5557bdafb339e1abc1e08a2705d2d6ec2f4b17b", "filename": "crates/ide-completion/src/context/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -9,7 +9,7 @@ use crate::{\n fn check_expected_type_and_name(ra_fixture: &str, expect: Expect) {\n     let (db, pos) = position(ra_fixture);\n     let config = TEST_CONFIG;\n-    let completion_context = CompletionContext::new(&db, pos, &config).unwrap();\n+    let (completion_context, _analysis) = CompletionContext::new(&db, pos, &config).unwrap();\n \n     let ty = completion_context\n         .expected_type"}, {"sha": "4774fe9db73765aaf6c8b2e51ebf89eb5a972201", "filename": "crates/ide-completion/src/item.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fitem.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -10,8 +10,8 @@ use syntax::{SmolStr, TextRange};\n use text_edit::TextEdit;\n \n use crate::{\n-    context::CompletionContext,\n-    render::{render_resolution, RenderContext},\n+    context::{CompletionContext, PathCompletionCtx},\n+    render::{render_path_resolution, RenderContext},\n };\n \n /// `CompletionItem` describes a single completion variant in the editor pop-up.\n@@ -434,10 +434,11 @@ pub(crate) struct Builder {\n impl Builder {\n     pub(crate) fn from_resolution(\n         ctx: &CompletionContext,\n+        path_ctx: &PathCompletionCtx,\n         local_name: hir::Name,\n         resolution: hir::ScopeDef,\n     ) -> Self {\n-        render_resolution(RenderContext::new(ctx), local_name, resolution)\n+        render_path_resolution(RenderContext::new(ctx), path_ctx, local_name, resolution)\n     }\n \n     pub(crate) fn build(self) -> CompletionItem {"}, {"sha": "fe02f05fd13d7c036139862803acdea82f1a149e", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -25,7 +25,8 @@ use text_edit::TextEdit;\n use crate::{\n     completions::Completions,\n     context::{\n-        CompletionContext, IdentContext, NameRefContext, NameRefKind, PathCompletionCtx, PathKind,\n+        CompletionAnalysis, CompletionContext, NameRefContext, NameRefKind, PathCompletionCtx,\n+        PathKind,\n     },\n };\n \n@@ -148,12 +149,12 @@ pub fn completions(\n     position: FilePosition,\n     trigger_character: Option<char>,\n ) -> Option<Completions> {\n-    let ctx = &CompletionContext::new(db, position, config)?;\n+    let (ctx, analysis) = &CompletionContext::new(db, position, config)?;\n     let mut completions = Completions::default();\n \n     // prevent `(` from triggering unwanted completion noise\n     if trigger_character == Some('(') {\n-        if let IdentContext::NameRef(NameRefContext { kind, .. }) = &ctx.ident_ctx {\n+        if let CompletionAnalysis::NameRef(NameRefContext { kind, .. }) = &analysis {\n             if let NameRefKind::Path(\n                 path_ctx @ PathCompletionCtx { kind: PathKind::Vis { has_in_token }, .. },\n             ) = kind\n@@ -168,20 +169,20 @@ pub fn completions(\n     {\n         let acc = &mut completions;\n \n-        match &ctx.ident_ctx {\n-            IdentContext::Name(name_ctx) => completions::complete_name(acc, ctx, name_ctx),\n-            IdentContext::NameRef(name_ref_ctx) => {\n+        match &analysis {\n+            CompletionAnalysis::Name(name_ctx) => completions::complete_name(acc, ctx, name_ctx),\n+            CompletionAnalysis::NameRef(name_ref_ctx) => {\n                 completions::complete_name_ref(acc, ctx, name_ref_ctx)\n             }\n-            IdentContext::Lifetime(lifetime_ctx) => {\n+            CompletionAnalysis::Lifetime(lifetime_ctx) => {\n                 completions::lifetime::complete_label(acc, ctx, lifetime_ctx);\n                 completions::lifetime::complete_lifetime(acc, ctx, lifetime_ctx);\n             }\n-            IdentContext::String { original, expanded: Some(expanded) } => {\n+            CompletionAnalysis::String { original, expanded: Some(expanded) } => {\n                 completions::extern_abi::complete_extern_abi(acc, ctx, expanded);\n                 completions::format_string::format_string(acc, ctx, original, expanded);\n             }\n-            IdentContext::UnexpandedAttrTT {\n+            CompletionAnalysis::UnexpandedAttrTT {\n                 colon_prefix,\n                 fake_attribute_under_caret: Some(attr),\n             } => {\n@@ -192,7 +193,7 @@ pub fn completions(\n                     attr,\n                 );\n             }\n-            IdentContext::UnexpandedAttrTT { .. } | IdentContext::String { .. } => (),\n+            CompletionAnalysis::UnexpandedAttrTT { .. } | CompletionAnalysis::String { .. } => (),\n         }\n     }\n \n@@ -204,22 +205,26 @@ pub fn completions(\n pub fn resolve_completion_edits(\n     db: &RootDatabase,\n     config: &CompletionConfig,\n-    position: FilePosition,\n+    FilePosition { file_id, offset }: FilePosition,\n     imports: impl IntoIterator<Item = (String, String)>,\n ) -> Option<Vec<TextEdit>> {\n     let _p = profile::span(\"resolve_completion_edits\");\n-    let ctx = CompletionContext::new(db, position, config)?;\n-    let position_for_import = &ctx.original_token.parent()?;\n-    let scope = ImportScope::find_insert_use_container(position_for_import, &ctx.sema)?;\n+    let sema = hir::Semantics::new(db);\n+\n+    let original_file = sema.parse(file_id);\n+    let original_token =\n+        syntax::AstNode::syntax(&original_file).token_at_offset(offset).left_biased()?;\n+    let position_for_import = &original_token.parent()?;\n+    let scope = ImportScope::find_insert_use_container(position_for_import, &sema)?;\n \n-    let current_module = ctx.sema.scope(position_for_import)?.module();\n+    let current_module = sema.scope(position_for_import)?.module();\n     let current_crate = current_module.krate();\n     let new_ast = scope.clone_for_update();\n     let mut import_insert = TextEdit::builder();\n \n     imports.into_iter().for_each(|(full_import_path, imported_name)| {\n         let items_with_name = items_locator::items_with_name(\n-            &ctx.sema,\n+            &sema,\n             current_crate,\n             NameToImport::exact_case_sensitive(imported_name),\n             items_locator::AssocItemSearch::Include,"}, {"sha": "9c339a13e7b3dfced2af98b742f1b8972eb5c9b7", "filename": "crates/ide-completion/src/render.rs", "status": "modified", "additions": 51, "deletions": 46, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -17,7 +17,7 @@ use ide_db::{\n use syntax::{SmolStr, SyntaxKind, TextRange};\n \n use crate::{\n-    context::{IdentContext, NameRefContext, NameRefKind, PathCompletionCtx, PathKind},\n+    context::{PathCompletionCtx, PathKind},\n     item::{Builder, CompletionRelevanceTypeMatch},\n     render::{function::render_fn, literal::render_variant_lit, macro_::render_macro},\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance,\n@@ -74,16 +74,6 @@ impl<'a> RenderContext<'a> {\n                 .map_or(false, |it| it.kind() == SyntaxKind::MACRO_CALL)\n     }\n \n-    pub(crate) fn path_is_call(&self) -> bool {\n-        matches!(\n-            self.completion.ident_ctx,\n-            IdentContext::NameRef(NameRefContext {\n-                kind: NameRefKind::Path(PathCompletionCtx { has_call_parens: true, .. }),\n-                ..\n-            })\n-        )\n-    }\n-\n     fn is_deprecated(&self, def: impl HasAttrs) -> bool {\n         let attrs = def.attrs(self.db());\n         attrs.by_key(\"deprecated\").exists()\n@@ -163,12 +153,13 @@ pub(crate) fn render_tuple_field(\n     item.build()\n }\n \n-pub(crate) fn render_resolution(\n+pub(crate) fn render_path_resolution(\n     ctx: RenderContext<'_>,\n+    path_ctx: &PathCompletionCtx,\n     local_name: hir::Name,\n     resolution: ScopeDef,\n ) -> Builder {\n-    render_resolution_(ctx, local_name, None, resolution)\n+    render_resolution_(ctx, path_ctx, local_name, None, resolution)\n }\n \n pub(crate) fn render_resolution_simple(\n@@ -181,6 +172,7 @@ pub(crate) fn render_resolution_simple(\n \n pub(crate) fn render_resolution_with_import(\n     ctx: RenderContext<'_>,\n+    path_ctx: &PathCompletionCtx,\n     import_edit: LocatedImport,\n ) -> Option<Builder> {\n     let resolution = ScopeDef::from(import_edit.original_item);\n@@ -190,7 +182,7 @@ pub(crate) fn render_resolution_with_import(\n         ScopeDef::ModuleDef(hir::ModuleDef::TypeAlias(t)) => t.name(ctx.completion.db),\n         _ => item_name(ctx.db(), import_edit.original_item)?,\n     };\n-    Some(render_resolution_(ctx, local_name, Some(import_edit), resolution))\n+    Some(render_resolution_(ctx, path_ctx, local_name, Some(import_edit), resolution))\n }\n \n pub(crate) fn render_type_inference(ty_string: String, ctx: &CompletionContext) -> CompletionItem {\n@@ -202,6 +194,7 @@ pub(crate) fn render_type_inference(ty_string: String, ctx: &CompletionContext)\n \n fn render_resolution_(\n     ctx: RenderContext<'_>,\n+    path_ctx: &PathCompletionCtx,\n     local_name: hir::Name,\n     import_to_add: Option<LocatedImport>,\n     resolution: ScopeDef,\n@@ -212,21 +205,61 @@ fn render_resolution_(\n     match resolution {\n         ScopeDef::ModuleDef(Macro(mac)) => {\n             let ctx = ctx.import_to_add(import_to_add);\n-            return render_macro(ctx, local_name, mac);\n+            return render_macro(ctx, path_ctx, local_name, mac);\n         }\n         ScopeDef::ModuleDef(Function(func)) => {\n             let ctx = ctx.import_to_add(import_to_add);\n-            return render_fn(ctx, Some(local_name), func);\n+            return render_fn(ctx, path_ctx, Some(local_name), func);\n         }\n         ScopeDef::ModuleDef(Variant(var)) => {\n             let ctx = ctx.clone().import_to_add(import_to_add.clone());\n-            if let Some(item) = render_variant_lit(ctx, Some(local_name.clone()), var, None) {\n+            if let Some(item) =\n+                render_variant_lit(ctx, path_ctx, Some(local_name.clone()), var, None)\n+            {\n                 return item;\n             }\n         }\n         _ => (),\n     }\n-    render_resolution_simple_(ctx, local_name, import_to_add, resolution)\n+    render_resolution_simple_type(ctx, path_ctx, local_name, import_to_add, resolution)\n+}\n+\n+fn render_resolution_simple_type(\n+    ctx: RenderContext<'_>,\n+    path_ctx: &PathCompletionCtx,\n+    local_name: hir::Name,\n+    import_to_add: Option<LocatedImport>,\n+    resolution: ScopeDef,\n+) -> Builder {\n+    let cap = ctx.snippet_cap();\n+    let db = ctx.completion.db;\n+    let config = ctx.completion.config;\n+    let name = local_name.to_smol_str();\n+    let mut item = render_resolution_simple_(ctx, local_name, import_to_add, resolution);\n+    // Add `<>` for generic types\n+    let type_path_no_ty_args = matches!(\n+        path_ctx,\n+        PathCompletionCtx { kind: PathKind::Type { .. }, has_type_args: false, .. }\n+    ) && config.callable.is_some();\n+    if type_path_no_ty_args {\n+        if let Some(cap) = cap {\n+            let has_non_default_type_params = match resolution {\n+                ScopeDef::ModuleDef(hir::ModuleDef::Adt(it)) => it.has_non_default_type_params(db),\n+                ScopeDef::ModuleDef(hir::ModuleDef::TypeAlias(it)) => {\n+                    it.has_non_default_type_params(db)\n+                }\n+                _ => false,\n+            };\n+            if has_non_default_type_params {\n+                cov_mark::hit!(inserts_angle_brackets_for_generics);\n+                item.lookup_by(name.clone())\n+                    .label(SmolStr::from_iter([&name, \"<\u2026>\"]))\n+                    .trigger_call_info()\n+                    .insert_snippet(cap, format!(\"{}<$0>\", name));\n+            }\n+        }\n+    }\n+    item\n }\n \n fn render_resolution_simple_(\n@@ -289,34 +322,6 @@ fn render_resolution_simple_(\n         }\n     };\n \n-    // Add `<>` for generic types\n-    let type_path_no_ty_args = matches!(\n-        ctx.completion.ident_ctx,\n-        IdentContext::NameRef(NameRefContext {\n-            kind: NameRefKind::Path(PathCompletionCtx {\n-                kind: PathKind::Type { .. },\n-                has_type_args: false,\n-                ..\n-            }),\n-            ..\n-        })\n-    ) && ctx.completion.config.callable.is_some();\n-    if type_path_no_ty_args {\n-        if let Some(cap) = ctx.snippet_cap() {\n-            let has_non_default_type_params = match resolution {\n-                ScopeDef::ModuleDef(Adt(it)) => it.has_non_default_type_params(db),\n-                ScopeDef::ModuleDef(TypeAlias(it)) => it.has_non_default_type_params(db),\n-                _ => false,\n-            };\n-            if has_non_default_type_params {\n-                cov_mark::hit!(inserts_angle_brackets_for_generics);\n-                item.lookup_by(local_name.clone())\n-                    .label(SmolStr::from_iter([&local_name, \"<\u2026>\"]))\n-                    .trigger_call_info()\n-                    .insert_snippet(cap, format!(\"{}<$0>\", local_name));\n-            }\n-        }\n-    }\n     item.set_documentation(scope_def_docs(db, resolution))\n         .set_deprecated(scope_def_is_deprecated(&ctx, resolution));\n "}, {"sha": "3666ee40e2f8754071da376badea61cd77f943d4", "filename": "crates/ide-completion/src/render/function.rs", "status": "modified", "additions": 42, "deletions": 45, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -8,8 +8,7 @@ use syntax::SmolStr;\n \n use crate::{\n     context::{\n-        CompletionContext, DotAccess, DotAccessKind, IdentContext, NameRefContext, NameRefKind,\n-        PathCompletionCtx, PathKind, Qualified,\n+        CompletionContext, DotAccess, DotAccessKind, PathCompletionCtx, PathKind, Qualified,\n     },\n     item::{Builder, CompletionItem, CompletionItemKind, CompletionRelevance},\n     render::{compute_exact_name_match, compute_ref_match, compute_type_match, RenderContext},\n@@ -23,28 +22,63 @@ enum FuncKind {\n \n pub(crate) fn render_fn(\n     ctx: RenderContext<'_>,\n+    path_ctx: &PathCompletionCtx,\n     local_name: Option<hir::Name>,\n     func: hir::Function,\n ) -> Builder {\n     let _p = profile::span(\"render_fn\");\n-    render(ctx, local_name, func, FuncKind::Function)\n+    let func_kind = FuncKind::Function;\n+    let params = match ctx.completion.config.snippet_cap {\n+        Some(_) => {\n+            if !matches!(\n+                path_ctx,\n+                PathCompletionCtx { kind: PathKind::Expr { .. }, has_call_parens: true, .. }\n+                    | PathCompletionCtx { kind: PathKind::Use | PathKind::Type { .. }, .. }\n+            ) {\n+                params(ctx.completion, func, &func_kind, false)\n+            } else {\n+                None\n+            }\n+        }\n+        _ => None,\n+    };\n+    render(\n+        ctx,\n+        local_name,\n+        func,\n+        func_kind,\n+        params,\n+        matches!(path_ctx.qualified, Qualified::With { .. }),\n+    )\n }\n \n pub(crate) fn render_method(\n     ctx: RenderContext<'_>,\n+    dot_access: &DotAccess,\n     receiver: Option<hir::Name>,\n     local_name: Option<hir::Name>,\n     func: hir::Function,\n ) -> Builder {\n     let _p = profile::span(\"render_method\");\n-    render(ctx, local_name, func, FuncKind::Method(receiver))\n+    let func_kind = FuncKind::Method(receiver);\n+    let params = match ctx.completion.config.snippet_cap {\n+        Some(_) => match dot_access {\n+            DotAccess { kind: DotAccessKind::Method { has_parens: true }, .. } => None,\n+            _ => params(ctx.completion, func, &func_kind, true),\n+        },\n+        _ => None,\n+    };\n+\n+    render(ctx, local_name, func, func_kind, params, false)\n }\n \n fn render(\n     ctx @ RenderContext { completion, .. }: RenderContext<'_>,\n     local_name: Option<hir::Name>,\n     func: hir::Function,\n     func_kind: FuncKind,\n+    params: Option<(Option<hir::SelfParam>, Vec<hir::Param>)>,\n+    qualified_path: bool,\n ) -> Builder {\n     let db = completion.db;\n \n@@ -80,16 +114,6 @@ fn render(\n         // FIXME For now we don't properly calculate the edits for ref match\n         // completions on methods or qualified paths, so we've disabled them.\n         // See #8058.\n-        let qualified_path = matches!(\n-            ctx.completion.ident_ctx,\n-            IdentContext::NameRef(NameRefContext {\n-                kind: NameRefKind::Path(PathCompletionCtx {\n-                    qualified: Qualified::With { .. },\n-                    ..\n-                }),\n-                ..\n-            })\n-        );\n         if matches!(func_kind, FuncKind::Function) && !qualified_path {\n             item.ref_match(ref_match);\n         }\n@@ -100,11 +124,9 @@ fn render(\n         .detail(detail(db, func))\n         .lookup_by(name.to_smol_str());\n \n-    match completion.config.snippet_cap {\n-        Some(cap) => {\n-            if let Some((self_param, params)) = params(completion, func, &func_kind) {\n-                add_call_parens(&mut item, completion, cap, call, self_param, params);\n-            }\n+    match completion.config.snippet_cap.zip(params) {\n+        Some((cap, (self_param, params))) => {\n+            add_call_parens(&mut item, completion, cap, call, self_param, params);\n         }\n         _ => (),\n     }\n@@ -254,37 +276,12 @@ fn params(\n     ctx: &CompletionContext<'_>,\n     func: hir::Function,\n     func_kind: &FuncKind,\n+    has_dot_receiver: bool,\n ) -> Option<(Option<hir::SelfParam>, Vec<hir::Param>)> {\n     if ctx.config.callable.is_none() {\n         return None;\n     }\n \n-    let has_dot_receiver = match ctx.ident_ctx {\n-        IdentContext::NameRef(NameRefContext {\n-            kind:\n-                NameRefKind::DotAccess(DotAccess {\n-                    kind: DotAccessKind::Method { has_parens: true },\n-                    ..\n-                }),\n-            ..\n-        }) => return None,\n-        IdentContext::NameRef(NameRefContext {\n-            kind: NameRefKind::DotAccess(DotAccess { .. }),\n-            ..\n-        }) => true,\n-        IdentContext::NameRef(NameRefContext {\n-            kind:\n-                NameRefKind::Path(\n-                    PathCompletionCtx {\n-                        kind: PathKind::Expr { .. }, has_call_parens: true, ..\n-                    }\n-                    | PathCompletionCtx { kind: PathKind::Use | PathKind::Type { .. }, .. },\n-                ),\n-            ..\n-        }) => return None,\n-        _ => false,\n-    };\n-\n     // Don't add parentheses if the expected type is some function reference.\n     if let Some(ty) = &ctx.expected_type {\n         // FIXME: check signature matches?"}, {"sha": "b89030990e44465df9e26c48ae64bdd6ffa344fd", "filename": "crates/ide-completion/src/render/literal.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -4,9 +4,7 @@ use hir::{db::HirDatabase, Documentation, HasAttrs, StructKind};\n use ide_db::SymbolKind;\n \n use crate::{\n-    context::{\n-        CompletionContext, IdentContext, NameRefContext, NameRefKind, PathCompletionCtx, PathKind,\n-    },\n+    context::{CompletionContext, PathCompletionCtx, PathKind},\n     item::{Builder, CompletionItem},\n     render::{\n         compute_ref_match, compute_type_match,\n@@ -21,6 +19,7 @@ use crate::{\n \n pub(crate) fn render_variant_lit(\n     ctx: RenderContext<'_>,\n+    path_ctx: &PathCompletionCtx,\n     local_name: Option<hir::Name>,\n     variant: hir::Variant,\n     path: Option<hir::ModPath>,\n@@ -29,11 +28,12 @@ pub(crate) fn render_variant_lit(\n     let db = ctx.db();\n \n     let name = local_name.unwrap_or_else(|| variant.name(db));\n-    render(ctx, Variant::EnumVariant(variant), name, path)\n+    render(ctx, path_ctx, Variant::EnumVariant(variant), name, path)\n }\n \n pub(crate) fn render_struct_literal(\n     ctx: RenderContext<'_>,\n+    path_ctx: &PathCompletionCtx,\n     strukt: hir::Struct,\n     path: Option<hir::ModPath>,\n     local_name: Option<hir::Name>,\n@@ -42,29 +42,21 @@ pub(crate) fn render_struct_literal(\n     let db = ctx.db();\n \n     let name = local_name.unwrap_or_else(|| strukt.name(db));\n-    render(ctx, Variant::Struct(strukt), name, path)\n+    render(ctx, path_ctx, Variant::Struct(strukt), name, path)\n }\n \n fn render(\n     ctx @ RenderContext { completion, .. }: RenderContext<'_>,\n+    path_ctx: &PathCompletionCtx,\n     thing: Variant,\n     name: hir::Name,\n     path: Option<hir::ModPath>,\n ) -> Option<Builder> {\n     let db = completion.db;\n     let mut kind = thing.kind(db);\n-    let should_add_parens = match &completion.ident_ctx {\n-        IdentContext::NameRef(NameRefContext {\n-            kind: NameRefKind::Path(PathCompletionCtx { has_call_parens: true, .. }),\n-            ..\n-        }) => false,\n-        IdentContext::NameRef(NameRefContext {\n-            kind:\n-                NameRefKind::Path(PathCompletionCtx {\n-                    kind: PathKind::Use | PathKind::Type { .. }, ..\n-                }),\n-            ..\n-        }) => false,\n+    let should_add_parens = match &path_ctx {\n+        PathCompletionCtx { has_call_parens: true, .. } => false,\n+        PathCompletionCtx { kind: PathKind::Use | PathKind::Type { .. }, .. } => false,\n         _ => true,\n     };\n "}, {"sha": "6da7bb3193baa5ef5ee1885fe1ab71e7b500ba2c", "filename": "crates/ide-completion/src/render/macro_.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -5,18 +5,24 @@ use ide_db::SymbolKind;\n use syntax::SmolStr;\n \n use crate::{\n-    context::{IdentContext, NameRefContext, NameRefKind, PathCompletionCtx, PathKind},\n+    context::{PathCompletionCtx, PathKind},\n     item::{Builder, CompletionItem},\n     render::RenderContext,\n };\n \n-pub(crate) fn render_macro(ctx: RenderContext<'_>, name: hir::Name, macro_: hir::Macro) -> Builder {\n+pub(crate) fn render_macro(\n+    ctx: RenderContext<'_>,\n+    path_ctx: &PathCompletionCtx,\n+    name: hir::Name,\n+    macro_: hir::Macro,\n+) -> Builder {\n     let _p = profile::span(\"render_macro\");\n-    render(ctx, name, macro_)\n+    render(ctx, path_ctx, name, macro_)\n }\n \n fn render(\n     ctx @ RenderContext { completion, .. }: RenderContext<'_>,\n+    PathCompletionCtx { kind, has_macro_bang, has_call_parens, .. }: &PathCompletionCtx,\n     name: hir::Name,\n     macro_: hir::Macro,\n ) -> Builder {\n@@ -33,13 +39,7 @@ fn render(\n     let is_fn_like = macro_.is_fn_like(completion.db);\n     let (bra, ket) = if is_fn_like { guess_macro_braces(&name, docs_str) } else { (\"\", \"\") };\n \n-    let needs_bang = match &completion.ident_ctx {\n-        IdentContext::NameRef(NameRefContext {\n-            kind: NameRefKind::Path(PathCompletionCtx { kind, has_macro_bang, .. }),\n-            ..\n-        }) => is_fn_like && *kind != PathKind::Use && !has_macro_bang,\n-        _ => is_fn_like,\n-    };\n+    let needs_bang = is_fn_like && *kind != PathKind::Use && !has_macro_bang;\n \n     let mut item = CompletionItem::new(\n         SymbolKind::from(macro_.kind(completion.db)),\n@@ -53,7 +53,7 @@ fn render(\n \n     let name = &*name;\n     match ctx.snippet_cap() {\n-        Some(cap) if needs_bang && !ctx.path_is_call() => {\n+        Some(cap) if needs_bang && !has_call_parens => {\n             let snippet = format!(\"{}!{}$0{}\", name, bra, ket);\n             let lookup = banged_name(name);\n             item.insert_snippet(cap, snippet).lookup_by(lookup);"}, {"sha": "463d29295500c08a1f89d07717b4ab1944b0763b", "filename": "crates/ide-completion/src/render/pattern.rs", "status": "modified", "additions": 30, "deletions": 38, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -6,16 +6,14 @@ use itertools::Itertools;\n use syntax::SmolStr;\n \n use crate::{\n-    context::{\n-        IdentContext, NameContext, NameKind, NameRefContext, NameRefKind, ParamKind,\n-        PathCompletionCtx, PathKind, PatternContext,\n-    },\n+    context::{ParamKind, PatternContext},\n     render::{variant::visible_fields, RenderContext},\n     CompletionItem, CompletionItemKind,\n };\n \n pub(crate) fn render_struct_pat(\n     ctx: RenderContext<'_>,\n+    pattern_ctx: &PatternContext,\n     strukt: hir::Struct,\n     local_name: Option<Name>,\n ) -> Option<CompletionItem> {\n@@ -30,13 +28,21 @@ pub(crate) fn render_struct_pat(\n     }\n \n     let name = local_name.unwrap_or_else(|| strukt.name(ctx.db())).to_smol_str();\n-    let pat = render_pat(&ctx, &name, strukt.kind(ctx.db()), &visible_fields, fields_omitted)?;\n+    let pat = render_pat(\n+        &ctx,\n+        pattern_ctx,\n+        &name,\n+        strukt.kind(ctx.db()),\n+        &visible_fields,\n+        fields_omitted,\n+    )?;\n \n     Some(build_completion(ctx, name, pat, strukt))\n }\n \n pub(crate) fn render_variant_pat(\n     ctx: RenderContext<'_>,\n+    pattern_ctx: &PatternContext,\n     variant: hir::Variant,\n     local_name: Option<Name>,\n     path: Option<&hir::ModPath>,\n@@ -50,7 +56,14 @@ pub(crate) fn render_variant_pat(\n         Some(path) => path.to_string().into(),\n         None => local_name.unwrap_or_else(|| variant.name(ctx.db())).to_smol_str(),\n     };\n-    let pat = render_pat(&ctx, &name, variant.kind(ctx.db()), &visible_fields, fields_omitted)?;\n+    let pat = render_pat(\n+        &ctx,\n+        pattern_ctx,\n+        &name,\n+        variant.kind(ctx.db()),\n+        &visible_fields,\n+        fields_omitted,\n+    )?;\n \n     Some(build_completion(ctx, name, pat, variant))\n }\n@@ -75,49 +88,28 @@ fn build_completion(\n \n fn render_pat(\n     ctx: &RenderContext<'_>,\n+    pattern_ctx: &PatternContext,\n     name: &str,\n     kind: StructKind,\n     fields: &[hir::Field],\n     fields_omitted: bool,\n ) -> Option<String> {\n-    let has_call_parens = matches!(\n-        ctx.completion.ident_ctx,\n-        IdentContext::NameRef(NameRefContext {\n-            kind: NameRefKind::Path(PathCompletionCtx { has_call_parens: true, .. }),\n-            ..\n-        })\n-    );\n     let mut pat = match kind {\n-        StructKind::Tuple if !has_call_parens => {\n-            render_tuple_as_pat(ctx.snippet_cap(), fields, name, fields_omitted)\n-        }\n-        StructKind::Record if !has_call_parens => {\n+        StructKind::Tuple => render_tuple_as_pat(ctx.snippet_cap(), fields, name, fields_omitted),\n+        StructKind::Record => {\n             render_record_as_pat(ctx.db(), ctx.snippet_cap(), fields, name, fields_omitted)\n         }\n         StructKind::Unit => return None,\n-        _ => name.to_owned(),\n     };\n \n-    let needs_ascription = !has_call_parens\n-        && matches!(\n-            &ctx.completion.ident_ctx,\n-            IdentContext::NameRef(NameRefContext {\n-                kind: NameRefKind::Path(PathCompletionCtx {\n-                    kind: PathKind::Pat {\n-                        pat_ctx\n-                    },\n-                    ..\n-                }),\n-                ..\n-            }) | IdentContext::Name(NameContext {\n-                kind: NameKind::IdentPat(pat_ctx), ..}\n-            )\n-            if matches!(pat_ctx, PatternContext {\n-                param_ctx: Some((.., ParamKind::Function(_))),\n-                has_type_ascription: false,\n-                ..\n-            })\n-        );\n+    let needs_ascription = matches!(\n+        pattern_ctx,\n+        PatternContext {\n+            param_ctx: Some((.., ParamKind::Function(_))),\n+            has_type_ascription: false,\n+            ..\n+        }\n+    );\n     if needs_ascription {\n         pat.push(':');\n         pat.push(' ');"}, {"sha": "c393e16e7a5e608306fa706cd5437cfd7bba579b", "filename": "crates/ide-completion/src/tests/flyimport.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e9c9633481568a98dec79bb96675611b90b3752/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fflyimport.rs?ref=6e9c9633481568a98dec79bb96675611b90b3752", "patch": "@@ -1,22 +1,22 @@\n use expect_test::{expect, Expect};\n \n use crate::{\n-    context::{IdentContext, NameContext, NameKind, NameRefKind},\n+    context::{CompletionAnalysis, NameContext, NameKind, NameRefKind},\n     tests::{check_edit, check_edit_with_config, TEST_CONFIG},\n };\n \n fn check(ra_fixture: &str, expect: Expect) {\n     let config = TEST_CONFIG;\n     let (db, position) = crate::tests::position(ra_fixture);\n-    let ctx = crate::context::CompletionContext::new(&db, position, &config).unwrap();\n+    let (ctx, analysis) = crate::context::CompletionContext::new(&db, position, &config).unwrap();\n \n     let mut acc = crate::completions::Completions::default();\n-    if let IdentContext::Name(NameContext { kind: NameKind::IdentPat(pat_ctx), .. }) =\n-        &ctx.ident_ctx\n+    if let CompletionAnalysis::Name(NameContext { kind: NameKind::IdentPat(pat_ctx), .. }) =\n+        &analysis\n     {\n         crate::completions::flyimport::import_on_the_fly_pat(&mut acc, &ctx, pat_ctx);\n     }\n-    if let IdentContext::NameRef(name_ref_ctx) = &ctx.ident_ctx {\n+    if let CompletionAnalysis::NameRef(name_ref_ctx) = &analysis {\n         match &name_ref_ctx.kind {\n             NameRefKind::Path(path) => {\n                 crate::completions::flyimport::import_on_the_fly_path(&mut acc, &ctx, path);"}]}