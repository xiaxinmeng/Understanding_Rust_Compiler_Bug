{"sha": "35e5123f5168102eed3b3c8e1d7ab36e6f90d53b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZTUxMjNmNTE2ODEwMmVlZDNiM2M4ZTFkN2FiMzZlNmY5MGQ1M2I=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-14T17:56:46Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: support overriding type printing in ty::print::Printer.", "tree": {"sha": "a66c7371fd9315f138182d462e58d5581f485a89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a66c7371fd9315f138182d462e58d5581f485a89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35e5123f5168102eed3b3c8e1d7ab36e6f90d53b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35e5123f5168102eed3b3c8e1d7ab36e6f90d53b", "html_url": "https://github.com/rust-lang/rust/commit/35e5123f5168102eed3b3c8e1d7ab36e6f90d53b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35e5123f5168102eed3b3c8e1d7ab36e6f90d53b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88d96b269c77a0de2c143c797aeb61e928f32e03", "url": "https://api.github.com/repos/rust-lang/rust/commits/88d96b269c77a0de2c143c797aeb61e928f32e03", "html_url": "https://github.com/rust-lang/rust/commit/88d96b269c77a0de2c143c797aeb61e928f32e03"}], "stats": {"total": 535, "additions": 295, "deletions": 240}, "files": [{"sha": "863e10846f4f4936bf68865a9a4baa27270396f2", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35e5123f5168102eed3b3c8e1d7ab36e6f90d53b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e5123f5168102eed3b3c8e1d7ab36e6f90d53b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=35e5123f5168102eed3b3c8e1d7ab36e6f90d53b", "patch": "@@ -458,6 +458,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n             type Path = Vec<String>;\n             type Region = !;\n+            type Type = !;\n \n             fn print_region(\n                 self: PrintCx<'_, '_, '_, Self>,\n@@ -466,6 +467,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 Err(NonTrivialPath)\n             }\n \n+            fn print_type<'tcx>(\n+                self: PrintCx<'_, '_, 'tcx, Self>,\n+                _ty: Ty<'tcx>,\n+            ) -> Result<Self::Type, Self::Error> {\n+                Err(NonTrivialPath)\n+            }\n+\n             fn path_crate(\n                 self: PrintCx<'_, '_, '_, Self>,\n                 cnum: CrateNum,"}, {"sha": "f2f6f2e30fc26f0680d3da0b202b427af46e1646", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/35e5123f5168102eed3b3c8e1d7ab36e6f90d53b/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e5123f5168102eed3b3c8e1d7ab36e6f90d53b/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=35e5123f5168102eed3b3c8e1d7ab36e6f90d53b", "patch": "@@ -252,6 +252,7 @@ pub trait Printer: Sized {\n \n     type Path;\n     type Region;\n+    type Type;\n \n     fn print_def_path(\n         self: PrintCx<'_, '_, 'tcx, Self>,\n@@ -278,6 +279,11 @@ pub trait Printer: Sized {\n         region: ty::Region<'_>,\n     ) -> Result<Self::Region, Self::Error>;\n \n+    fn print_type(\n+        self: PrintCx<'_, '_, 'tcx, Self>,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error>;\n+\n     fn path_crate(\n         self: PrintCx<'_, '_, '_, Self>,\n         cnum: CrateNum,\n@@ -317,7 +323,15 @@ pub trait Printer: Sized {\n }\n \n /// Trait for printers that pretty-print using `fmt::Write` to the printer.\n-pub trait PrettyPrinter: Printer<Error = fmt::Error, Path = Self, Region = Self> + fmt::Write {\n+pub trait PrettyPrinter:\n+    Printer<\n+        Error = fmt::Error,\n+        Path = Self,\n+        Region = Self,\n+        Type = Self,\n+    > +\n+    fmt::Write\n+{\n     /// Enter a nested print context, for pretty-printing\n     /// nested components in some larger context.\n     fn nest<'a, 'gcx, 'tcx, E>(\n@@ -870,8 +884,8 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                     nest!(self, |cx| ty.print_display(cx));\n                 }\n                 UnpackedKind::Const(ct) => {\n-                    start_or_continue(self, start, \", \")?;\n-                    ct.print_display(self)?;\n+                    start_or_continue(&mut self, start, \", \")?;\n+                    nest!(self, |cx| ct.print_display(cx));\n                 }\n             }\n         }\n@@ -901,6 +915,7 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n \n     type Path = Self;\n     type Region = Self;\n+    type Type = Self;\n \n     fn print_def_path(\n         mut self: PrintCx<'_, '_, 'tcx, Self>,\n@@ -1031,6 +1046,13 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         Ok(self.printer)\n     }\n \n+    fn print_type(\n+        self: PrintCx<'_, '_, 'tcx, Self>,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error> {\n+        self.pretty_print_type(ty)\n+    }\n+\n     fn path_crate(\n         mut self: PrintCx<'_, '_, '_, Self>,\n         cnum: CrateNum,"}, {"sha": "f42865f55ec8425c75bd14492d5cf32aebea6284", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 246, "deletions": 237, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/35e5123f5168102eed3b3c8e1d7ab36e6f90d53b/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e5123f5168102eed3b3c8e1d7ab36e6f90d53b/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=35e5123f5168102eed3b3c8e1d7ab36e6f90d53b", "patch": "@@ -1,11 +1,6 @@\n use crate::hir::def::Namespace;\n use crate::hir::def_id::DefId;\n use crate::ty::subst::{Kind, Subst, SubstsRef, UnpackedKind};\n-use crate::ty::{Bool, Char, Adt};\n-use crate::ty::{Error, Str, Array, Slice, Float, FnDef, FnPtr};\n-use crate::ty::{Param, Bound, RawPtr, Ref, Never, Tuple};\n-use crate::ty::{Closure, Generator, GeneratorWitness, Foreign, Projection, Opaque};\n-use crate::ty::{Placeholder, UnnormalizedProjection, Dynamic, Int, Uint, Infer};\n use crate::ty::{self, ParamConst, Ty, TypeFoldable};\n use crate::ty::print::{FmtPrinter, PrettyPrinter, PrintCx, Print, Printer};\n use crate::mir::interpret::ConstValue;\n@@ -689,269 +684,283 @@ define_print! {\n     }\n }\n \n-define_print! {\n-    ('tcx) ty::Ty<'tcx>, (self, cx) {\n-        display {\n-            match self.sty {\n-                Bool => p!(write(\"bool\")),\n-                Char => p!(write(\"char\")),\n-                Int(t) => p!(write(\"{}\", t.ty_to_string())),\n-                Uint(t) => p!(write(\"{}\", t.ty_to_string())),\n-                Float(t) => p!(write(\"{}\", t.ty_to_string())),\n-                RawPtr(ref tm) => {\n-                    p!(write(\"*{} \", match tm.mutbl {\n-                        hir::MutMutable => \"mut\",\n-                        hir::MutImmutable => \"const\",\n-                    }));\n-                    p!(print(tm.ty))\n+// FIXME(eddyb) move this to `ty::print`.\n+impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n+    pub fn pretty_print_type(\n+        mut self,\n+        ty: Ty<'tcx>,\n+    ) -> Result<P::Type, P::Error> {\n+        define_scoped_cx!(self);\n+\n+        match ty.sty {\n+            ty::Bool => p!(write(\"bool\")),\n+            ty::Char => p!(write(\"char\")),\n+            ty::Int(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::Uint(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::Float(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::RawPtr(ref tm) => {\n+                p!(write(\"*{} \", match tm.mutbl {\n+                    hir::MutMutable => \"mut\",\n+                    hir::MutImmutable => \"const\",\n+                }));\n+                p!(print(tm.ty))\n+            }\n+            ty::Ref(r, ty, mutbl) => {\n+                p!(write(\"&\"));\n+                if self.print_region_outputs_anything(r) {\n+                    p!(print_display(r), write(\" \"));\n                 }\n-                Ref(r, ty, mutbl) => {\n-                    p!(write(\"&\"));\n-                    if cx.print_region_outputs_anything(r) {\n-                        p!(print_display(r), write(\" \"));\n+                p!(print(ty::TypeAndMut { ty, mutbl }))\n+            }\n+            ty::Never => p!(write(\"!\")),\n+            ty::Tuple(ref tys) => {\n+                p!(write(\"(\"));\n+                let mut tys = tys.iter();\n+                if let Some(&ty) = tys.next() {\n+                    p!(print(ty), write(\",\"));\n+                    if let Some(&ty) = tys.next() {\n+                        p!(write(\" \"), print(ty));\n+                        for &ty in tys {\n+                            p!(write(\", \"), print(ty));\n+                        }\n                     }\n-                    p!(print(ty::TypeAndMut { ty, mutbl }))\n                 }\n-                Never => p!(write(\"!\")),\n-                Tuple(ref tys) => {\n-                    p!(write(\"(\"));\n-                    let mut tys = tys.iter();\n-                    if let Some(&ty) = tys.next() {\n-                        p!(print(ty), write(\",\"));\n-                        if let Some(&ty) = tys.next() {\n-                            p!(write(\" \"), print(ty));\n-                            for &ty in tys {\n-                                p!(write(\", \"), print(ty));\n-                            }\n+                p!(write(\")\"))\n+            }\n+            ty::FnDef(def_id, substs) => {\n+                let sig = self.tcx.fn_sig(def_id).subst(self.tcx, substs);\n+                p!(print(sig), write(\" {{\"));\n+                nest!(|cx| cx.print_def_path(\n+                    def_id,\n+                    Some(substs),\n+                    Namespace::ValueNS,\n+                    iter::empty(),\n+                ));\n+                p!(write(\"}}\"))\n+            }\n+            ty::FnPtr(ref bare_fn) => {\n+                p!(print(bare_fn))\n+            }\n+            ty::Infer(infer_ty) => p!(write(\"{}\", infer_ty)),\n+            ty::Error => p!(write(\"[type error]\")),\n+            ty::Param(ref param_ty) => p!(write(\"{}\", param_ty)),\n+            ty::Bound(debruijn, bound_ty) => {\n+                match bound_ty.kind {\n+                    ty::BoundTyKind::Anon => {\n+                        if debruijn == ty::INNERMOST {\n+                            p!(write(\"^{}\", bound_ty.var.index()))\n+                        } else {\n+                            p!(write(\"^{}_{}\", debruijn.index(), bound_ty.var.index()))\n                         }\n                     }\n-                    p!(write(\")\"))\n+\n+                    ty::BoundTyKind::Param(p) => p!(write(\"{}\", p)),\n                 }\n-                FnDef(def_id, substs) => {\n-                    let sig = cx.tcx.fn_sig(def_id).subst(cx.tcx, substs);\n-                    p!(print(sig), write(\" {{\"));\n-                    nest!(|cx| cx.print_def_path(\n-                        def_id,\n-                        Some(substs),\n-                        Namespace::ValueNS,\n-                        iter::empty(),\n-                    ));\n-                    p!(write(\"}}\"))\n+            }\n+            ty::Adt(def, substs) => {\n+                nest!(|cx| cx.print_def_path(\n+                    def.did,\n+                    Some(substs),\n+                    Namespace::TypeNS,\n+                    iter::empty(),\n+                ));\n+            }\n+            ty::Dynamic(data, r) => {\n+                let print_r = self.print_region_outputs_anything(r);\n+                if print_r {\n+                    p!(write(\"(\"));\n                 }\n-                FnPtr(ref bare_fn) => {\n-                    p!(print(bare_fn))\n+                p!(write(\"dyn \"), print(data));\n+                if print_r {\n+                    p!(write(\" + \"), print_display(r), write(\")\"));\n+                }\n+            }\n+            ty::Foreign(def_id) => {\n+                nest!(|cx| cx.print_def_path(\n+                    def_id,\n+                    None,\n+                    Namespace::TypeNS,\n+                    iter::empty(),\n+                ));\n+            }\n+            ty::Projection(ref data) => p!(print(data)),\n+            ty::UnnormalizedProjection(ref data) => {\n+                p!(write(\"Unnormalized(\"), print(data), write(\")\"))\n+            }\n+            ty::Placeholder(placeholder) => {\n+                p!(write(\"Placeholder({:?})\", placeholder))\n+            }\n+            ty::Opaque(def_id, substs) => {\n+                if self.config.is_verbose {\n+                    p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n+                    return Ok(self.printer);\n                 }\n-                Infer(infer_ty) => p!(write(\"{}\", infer_ty)),\n-                Error => p!(write(\"[type error]\")),\n-                Param(ref param_ty) => p!(write(\"{}\", param_ty)),\n-                Bound(debruijn, bound_ty) => {\n-                    match bound_ty.kind {\n-                        ty::BoundTyKind::Anon => {\n-                            if debruijn == ty::INNERMOST {\n-                                p!(write(\"^{}\", bound_ty.var.index()))\n-                            } else {\n-                                p!(write(\"^{}_{}\", debruijn.index(), bound_ty.var.index()))\n-                            }\n-                        }\n \n-                        ty::BoundTyKind::Param(p) => p!(write(\"{}\", p)),\n+                let def_key = self.tcx.def_key(def_id);\n+                if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n+                    p!(write(\"{}\", name));\n+                    let mut substs = substs.iter();\n+                    // FIXME(eddyb) print this with `print_def_path`.\n+                    if let Some(first) = substs.next() {\n+                        p!(write(\"::<\"));\n+                        p!(print_display(first));\n+                        for subst in substs {\n+                            p!(write(\", \"), print_display(subst));\n+                        }\n+                        p!(write(\">\"));\n                     }\n+                    return Ok(self.printer);\n                 }\n-                Adt(def, substs) => {\n-                    nest!(|cx| cx.print_def_path(\n-                        def.did,\n-                        Some(substs),\n-                        Namespace::TypeNS,\n-                        iter::empty(),\n-                    ));\n-                }\n-                Dynamic(data, r) => {\n-                    let print_r = cx.print_region_outputs_anything(r);\n-                    if print_r {\n-                        p!(write(\"(\"));\n-                    }\n-                    p!(write(\"dyn \"), print(data));\n-                    if print_r {\n-                        p!(write(\" + \"), print_display(r), write(\")\"));\n+                // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+                // by looking up the projections associated with the def_id.\n+                let bounds = self.tcx.predicates_of(def_id).instantiate(self.tcx, substs);\n+\n+                let mut first = true;\n+                let mut is_sized = false;\n+                p!(write(\"impl\"));\n+                for predicate in bounds.predicates {\n+                    if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n+                        // Don't print +Sized, but rather +?Sized if absent.\n+                        if Some(trait_ref.def_id()) == self.tcx.lang_items().sized_trait() {\n+                            is_sized = true;\n+                            continue;\n+                        }\n+\n+                        p!(\n+                                write(\"{}\", if first { \" \" } else { \"+\" }),\n+                                print(trait_ref));\n+                        first = false;\n                     }\n                 }\n-                Foreign(def_id) => {\n-                    nest!(|cx| cx.print_def_path(\n-                        def_id,\n-                        None,\n-                        Namespace::TypeNS,\n-                        iter::empty(),\n-                    ));\n-                }\n-                Projection(ref data) => p!(print(data)),\n-                UnnormalizedProjection(ref data) => {\n-                    p!(write(\"Unnormalized(\"), print(data), write(\")\"))\n+                if !is_sized {\n+                    p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n+                } else if first {\n+                    p!(write(\" Sized\"));\n                 }\n-                Placeholder(placeholder) => {\n-                    p!(write(\"Placeholder({:?})\", placeholder))\n+            }\n+            ty::Str => p!(write(\"str\")),\n+            ty::Generator(did, substs, movability) => {\n+                let upvar_tys = substs.upvar_tys(did, self.tcx);\n+                let witness = substs.witness(did, self.tcx);\n+                if movability == hir::GeneratorMovability::Movable {\n+                    p!(write(\"[generator\"));\n+                } else {\n+                    p!(write(\"[static generator\"));\n                 }\n-                Opaque(def_id, substs) => {\n-                    if cx.config.is_verbose {\n-                        p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n-                        return Ok(cx.printer);\n-                    }\n \n-                    let def_key = cx.tcx.def_key(def_id);\n-                    if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n-                        p!(write(\"{}\", name));\n-                        let mut substs = substs.iter();\n-                        // FIXME(eddyb) print this with `print_def_path`.\n-                        if let Some(first) = substs.next() {\n-                            p!(write(\"::<\"));\n-                            p!(print_display(first));\n-                            for subst in substs {\n-                                p!(write(\", \"), print_display(subst));\n-                            }\n-                            p!(write(\">\"));\n-                        }\n-                        return Ok(cx.printer);\n-                    }\n-                    // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n-                    // by looking up the projections associated with the def_id.\n-                    let bounds = cx.tcx.predicates_of(def_id).instantiate(cx.tcx, substs);\n-\n-                    let mut first = true;\n-                    let mut is_sized = false;\n-                    p!(write(\"impl\"));\n-                    for predicate in bounds.predicates {\n-                        if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n-                            // Don't print +Sized, but rather +?Sized if absent.\n-                            if Some(trait_ref.def_id()) == cx.tcx.lang_items().sized_trait() {\n-                                is_sized = true;\n-                                continue;\n-                            }\n-\n-                            p!(\n-                                    write(\"{}\", if first { \" \" } else { \"+\" }),\n-                                    print(trait_ref));\n-                            first = false;\n-                        }\n+                // FIXME(eddyb) should use `def_span`.\n+                if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n+                    p!(write(\"@{:?}\", self.tcx.hir().span_by_hir_id(hir_id)));\n+                    let mut sep = \" \";\n+                    for (freevar, upvar_ty) in self.tcx.freevars(did)\n+                        .as_ref()\n+                        .map_or(&[][..], |fv| &fv[..])\n+                        .iter()\n+                        .zip(upvar_tys)\n+                    {\n+                        p!(\n+                            write(\"{}{}:\",\n+                                    sep,\n+                                    self.tcx.hir().name(freevar.var_id())),\n+                            print(upvar_ty));\n+                        sep = \", \";\n                     }\n-                    if !is_sized {\n-                        p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n-                    } else if first {\n-                        p!(write(\" Sized\"));\n+                } else {\n+                    // cross-crate closure types should only be\n+                    // visible in codegen bug reports, I imagine.\n+                    p!(write(\"@{:?}\", did));\n+                    let mut sep = \" \";\n+                    for (index, upvar_ty) in upvar_tys.enumerate() {\n+                        p!(\n+                                write(\"{}{}:\", sep, index),\n+                                print(upvar_ty));\n+                        sep = \", \";\n                     }\n                 }\n-                Str => p!(write(\"str\")),\n-                Generator(did, substs, movability) => {\n-                    let upvar_tys = substs.upvar_tys(did, cx.tcx);\n-                    let witness = substs.witness(did, cx.tcx);\n-                    if movability == hir::GeneratorMovability::Movable {\n-                        p!(write(\"[generator\"));\n+\n+                p!(write(\" \"), print(witness), write(\"]\"))\n+            },\n+            ty::GeneratorWitness(types) => {\n+                nest!(|cx| cx.in_binder(&types))\n+            }\n+            ty::Closure(did, substs) => {\n+                let upvar_tys = substs.upvar_tys(did, self.tcx);\n+                p!(write(\"[closure\"));\n+\n+                // FIXME(eddyb) should use `def_span`.\n+                if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n+                    if self.tcx.sess.opts.debugging_opts.span_free_formats {\n+                        p!(write(\"@{:?}\", hir_id));\n                     } else {\n-                        p!(write(\"[static generator\"));\n+                        p!(write(\"@{:?}\", self.tcx.hir().span_by_hir_id(hir_id)));\n                     }\n-\n-                    // FIXME(eddyb) should use `def_span`.\n-                    if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(did) {\n-                        p!(write(\"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id)));\n-                        let mut sep = \" \";\n-                        for (freevar, upvar_ty) in cx.tcx.freevars(did)\n-                            .as_ref()\n-                            .map_or(&[][..], |fv| &fv[..])\n-                            .iter()\n-                            .zip(upvar_tys)\n-                        {\n-                            p!(\n-                                write(\"{}{}:\",\n-                                        sep,\n-                                        cx.tcx.hir().name(freevar.var_id())),\n+                    let mut sep = \" \";\n+                    for (freevar, upvar_ty) in self.tcx.freevars(did)\n+                        .as_ref()\n+                        .map_or(&[][..], |fv| &fv[..])\n+                        .iter()\n+                        .zip(upvar_tys)\n+                    {\n+                        p!(\n+                            write(\"{}{}:\",\n+                                    sep,\n+                                    self.tcx.hir().name(freevar.var_id())),\n+                            print(upvar_ty));\n+                        sep = \", \";\n+                    }\n+                } else {\n+                    // cross-crate closure types should only be\n+                    // visible in codegen bug reports, I imagine.\n+                    p!(write(\"@{:?}\", did));\n+                    let mut sep = \" \";\n+                    for (index, upvar_ty) in upvar_tys.enumerate() {\n+                        p!(\n+                                write(\"{}{}:\", sep, index),\n                                 print(upvar_ty));\n-                            sep = \", \";\n-                        }\n-                    } else {\n-                        // cross-crate closure types should only be\n-                        // visible in codegen bug reports, I imagine.\n-                        p!(write(\"@{:?}\", did));\n-                        let mut sep = \" \";\n-                        for (index, upvar_ty) in upvar_tys.enumerate() {\n-                            p!(\n-                                   write(\"{}{}:\", sep, index),\n-                                   print(upvar_ty));\n-                            sep = \", \";\n-                        }\n+                        sep = \", \";\n                     }\n+                }\n \n-                    p!(write(\" \"), print(witness), write(\"]\"))\n-                },\n-                GeneratorWitness(types) => {\n-                    nest!(|cx| cx.in_binder(&types))\n+                if self.config.is_verbose {\n+                    p!(write(\n+                        \" closure_kind_ty={:?} closure_sig_ty={:?}\",\n+                        substs.closure_kind_ty(did, self.tcx),\n+                        substs.closure_sig_ty(did, self.tcx)\n+                    ));\n                 }\n-                Closure(did, substs) => {\n-                    let upvar_tys = substs.upvar_tys(did, cx.tcx);\n-                    p!(write(\"[closure\"));\n-\n-                    // FIXME(eddyb) should use `def_span`.\n-                    if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(did) {\n-                        if cx.tcx.sess.opts.debugging_opts.span_free_formats {\n-                            p!(write(\"@{:?}\", hir_id));\n-                        } else {\n-                            p!(write(\"@{:?}\", cx.tcx.hir().span_by_hir_id(hir_id)));\n-                        }\n-                        let mut sep = \" \";\n-                        for (freevar, upvar_ty) in cx.tcx.freevars(did)\n-                            .as_ref()\n-                            .map_or(&[][..], |fv| &fv[..])\n-                            .iter()\n-                            .zip(upvar_tys)\n-                        {\n-                            p!(\n-                                write(\"{}{}:\",\n-                                        sep,\n-                                        cx.tcx.hir().name(freevar.var_id())),\n-                                print(upvar_ty));\n-                            sep = \", \";\n-                        }\n-                    } else {\n-                        // cross-crate closure types should only be\n-                        // visible in codegen bug reports, I imagine.\n-                        p!(write(\"@{:?}\", did));\n-                        let mut sep = \" \";\n-                        for (index, upvar_ty) in upvar_tys.enumerate() {\n-                            p!(\n-                                   write(\"{}{}:\", sep, index),\n-                                   print(upvar_ty));\n-                            sep = \", \";\n-                        }\n-                    }\n \n-                    if cx.config.is_verbose {\n-                        p!(write(\n-                            \" closure_kind_ty={:?} closure_sig_ty={:?}\",\n-                            substs.closure_kind_ty(did, cx.tcx),\n-                            substs.closure_sig_ty(did, cx.tcx)\n-                        ));\n+                p!(write(\"]\"))\n+            },\n+            ty::Array(ty, sz) => {\n+                p!(write(\"[\"), print(ty), write(\"; \"));\n+                match sz {\n+                    ty::LazyConst::Unevaluated(_def_id, _substs) => {\n+                        p!(write(\"_\"));\n                     }\n-\n-                    p!(write(\"]\"))\n-                },\n-                Array(ty, sz) => {\n-                    p!(write(\"[\"), print(ty), write(\"; \"));\n-                    match sz {\n-                        ty::LazyConst::Unevaluated(_def_id, _substs) => {\n-                            p!(write(\"_\"));\n-                        }\n-                        ty::LazyConst::Evaluated(c) => {\n-                            match c.val {\n-                                ConstValue::Infer(..) => p!(write(\"_\")),\n-                                ConstValue::Param(ParamConst { name, .. }) =>\n-                                    p!(write(\"{}\", name)),\n-                                _ => p!(write(\"{}\", c.unwrap_usize(cx.tcx))),\n-                            }\n+                    ty::LazyConst::Evaluated(c) => {\n+                        match c.val {\n+                            ConstValue::Infer(..) => p!(write(\"_\")),\n+                            ConstValue::Param(ParamConst { name, .. }) =>\n+                                p!(write(\"{}\", name)),\n+                            _ => p!(write(\"{}\", c.unwrap_usize(self.tcx))),\n                         }\n                     }\n-                    p!(write(\"]\"))\n-                }\n-                Slice(ty) => {\n-                    p!(write(\"[\"), print(ty), write(\"]\"))\n                 }\n+                p!(write(\"]\"))\n             }\n+            ty::Slice(ty) => {\n+                p!(write(\"[\"), print(ty), write(\"]\"))\n+            }\n+        }\n+\n+        Ok(self.printer)\n+    }\n+}\n+\n+define_print! {\n+    ('tcx) Ty<'tcx>, (self, cx) {\n+        display {\n+            return cx.print_type(self);\n         }\n         debug {\n             p!(print_display(self))"}, {"sha": "f3af2425820841f009586806f3a72c5336190100", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35e5123f5168102eed3b3c8e1d7ab36e6f90d53b/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e5123f5168102eed3b3c8e1d7ab36e6f90d53b/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=35e5123f5168102eed3b3c8e1d7ab36e6f90d53b", "patch": "@@ -410,6 +410,7 @@ impl Printer for SymbolPath {\n \n     type Path = Self;\n     type Region = Self;\n+    type Type = Self;\n \n     fn print_region(\n         self: PrintCx<'_, '_, '_, Self>,\n@@ -418,6 +419,13 @@ impl Printer for SymbolPath {\n         Ok(self.printer)\n     }\n \n+    fn print_type(\n+        self: PrintCx<'_, '_, 'tcx, Self>,\n+        ty: Ty<'tcx>,\n+    ) -> Result<Self::Type, Self::Error> {\n+        self.pretty_print_type(ty)\n+    }\n+\n     fn path_crate(\n         mut self: PrintCx<'_, '_, '_, Self>,\n         cnum: CrateNum,"}, {"sha": "13db78cc803aa278202360a2b2772c9ae3febbbd", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35e5123f5168102eed3b3c8e1d7ab36e6f90d53b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e5123f5168102eed3b3c8e1d7ab36e6f90d53b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=35e5123f5168102eed3b3c8e1d7ab36e6f90d53b", "patch": "@@ -4234,6 +4234,7 @@ where F: Fn(DefId) -> Def {\n \n         type Path = Vec<String>;\n         type Region = ();\n+        type Type = ();\n \n         fn print_region(\n             self: PrintCx<'_, '_, '_, Self>,\n@@ -4242,6 +4243,13 @@ where F: Fn(DefId) -> Def {\n             Ok(())\n         }\n \n+        fn print_type(\n+            self: PrintCx<'_, '_, 'tcx, Self>,\n+            _ty: Ty<'tcx>,\n+        ) -> Result<Self::Type, Self::Error> {\n+            Ok(())\n+        }\n+\n         fn path_crate(\n             self: PrintCx<'_, '_, '_, Self>,\n             cnum: CrateNum,"}]}