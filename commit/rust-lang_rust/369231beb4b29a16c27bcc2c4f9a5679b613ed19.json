{"sha": "369231beb4b29a16c27bcc2c4f9a5679b613ed19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2OTIzMWJlYjRiMjlhMTZjMjdiY2MyYzRmOWE1Njc5YjYxM2VkMTk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-10T03:27:42Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-13T19:13:56Z"}, "message": "core: Rename SharedMutableState to UnsafeAtomicRcBox", "tree": {"sha": "485a1a22a95e003d1379e685d958217b5676e546", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/485a1a22a95e003d1379e685d958217b5676e546"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/369231beb4b29a16c27bcc2c4f9a5679b613ed19", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/369231beb4b29a16c27bcc2c4f9a5679b613ed19", "html_url": "https://github.com/rust-lang/rust/commit/369231beb4b29a16c27bcc2c4f9a5679b613ed19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/369231beb4b29a16c27bcc2c4f9a5679b613ed19/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa1d0477edab6fa800eabd951d88f6bd12fbcfff", "html_url": "https://github.com/rust-lang/rust/commit/fa1d0477edab6fa800eabd951d88f6bd12fbcfff"}], "stats": {"total": 262, "additions": 131, "deletions": 131}, "files": [{"sha": "2d6698fb96adec1f95e5f8b1c90bb146d2c1afb2", "filename": "src/libcore/unstable/global.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/369231beb4b29a16c27bcc2c4f9a5679b613ed19/src%2Flibcore%2Funstable%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/369231beb4b29a16c27bcc2c4f9a5679b613ed19/src%2Flibcore%2Funstable%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fglobal.rs?ref=369231beb4b29a16c27bcc2c4f9a5679b613ed19", "patch": "@@ -37,8 +37,7 @@ use unstable::intrinsics::atomic_cxchg;\n use hashmap::HashMap;\n use sys::Closure;\n \n-#[cfg(test)] use unstable::sync::{SharedMutableState, shared_mutable_state};\n-#[cfg(test)] use unstable::sync::get_shared_immutable_state;\n+#[cfg(test)] use unstable::sync::{UnsafeAtomicRcBox};\n #[cfg(test)] use task::spawn;\n #[cfg(test)] use uint;\n \n@@ -234,35 +233,31 @@ extern {\n \n #[test]\n fn test_clone_rc() {\n-    type MyType = SharedMutableState<int>;\n-\n-    fn key(_v: SharedMutableState<int>) { }\n+    fn key(_v: UnsafeAtomicRcBox<int>) { }\n \n     for uint::range(0, 100) |_| {\n         do spawn {\n             unsafe {\n                 let val = do global_data_clone_create(key) {\n-                    ~shared_mutable_state(10)\n+                    ~UnsafeAtomicRcBox::new(10)\n                 };\n \n-                assert!(get_shared_immutable_state(&val) == &10);\n+                assert!(val.get() == &10);\n             }\n         }\n     }\n }\n \n #[test]\n fn test_modify() {\n-    type MyType = SharedMutableState<int>;\n-\n-    fn key(_v: SharedMutableState<int>) { }\n+    fn key(_v: UnsafeAtomicRcBox<int>) { }\n \n     unsafe {\n         do global_data_modify(key) |v| {\n             match v {\n                 None => {\n                     unsafe {\n-                        Some(~shared_mutable_state(10))\n+                        Some(~UnsafeAtomicRcBox::new(10))\n                     }\n                 }\n                 _ => fail!()\n@@ -272,7 +267,7 @@ fn test_modify() {\n         do global_data_modify(key) |v| {\n             match v {\n                 Some(sms) => {\n-                    let v = get_shared_immutable_state(sms);\n+                    let v = sms.get();\n                     assert!(*v == 10);\n                     None\n                 },\n@@ -284,7 +279,7 @@ fn test_modify() {\n             match v {\n                 None => {\n                     unsafe {\n-                        Some(~shared_mutable_state(10))\n+                        Some(~UnsafeAtomicRcBox::new(10))\n                     }\n                 }\n                 _ => fail!()"}, {"sha": "e22046f04f95b6419a5867218462a9828899635e", "filename": "src/libcore/unstable/sync.rs", "status": "modified", "additions": 80, "deletions": 77, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/369231beb4b29a16c27bcc2c4f9a5679b613ed19/src%2Flibcore%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/369231beb4b29a16c27bcc2c4f9a5679b613ed19/src%2Flibcore%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fsync.rs?ref=369231beb4b29a16c27bcc2c4f9a5679b613ed19", "patch": "@@ -19,98 +19,103 @@ use ops::Drop;\n use clone::Clone;\n use kinds::Owned;\n \n-/****************************************************************************\n- * Shared state & exclusive ARC\n- ****************************************************************************/\n-\n-struct ArcData<T> {\n-    count:     libc::intptr_t,\n-    // FIXME(#3224) should be able to make this non-option to save memory\n-    data:      Option<T>,\n+/// An atomically reference counted pointer.\n+///\n+/// Enforces no shared-memory safety.\n+pub struct UnsafeAtomicRcBox<T> {\n+    data: *mut libc::c_void,\n }\n \n-struct ArcDestruct<T> {\n-    data: *libc::c_void,\n+struct AtomicRcBoxData<T> {\n+    count: int,\n+    data: Option<T>,\n }\n \n-#[unsafe_destructor]\n-impl<T> Drop for ArcDestruct<T>{\n-    fn finalize(&self) {\n+impl<T: Owned> UnsafeAtomicRcBox<T> {\n+    pub fn new(data: T) -> UnsafeAtomicRcBox<T> {\n         unsafe {\n-            do task::unkillable {\n-                let mut data: ~ArcData<T> = cast::transmute(self.data);\n-                let new_count =\n-                    intrinsics::atomic_xsub(&mut data.count, 1) - 1;\n-                assert!(new_count >= 0);\n-                if new_count == 0 {\n-                    // drop glue takes over.\n-                } else {\n-                    cast::forget(data);\n-                }\n-            }\n+            let data = ~AtomicRcBoxData { count: 1, data: Some(data) };\n+            let ptr = cast::transmute(data);\n+            return UnsafeAtomicRcBox { data: ptr };\n         }\n     }\n-}\n \n-fn ArcDestruct<T>(data: *libc::c_void) -> ArcDestruct<T> {\n-    ArcDestruct {\n-        data: data\n+    #[inline(always)]\n+    #[cfg(stage0)]\n+    pub unsafe fn get(&self) -> *mut T\n+    {\n+        let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+        assert!(data.count > 0);\n+        let r: *mut T = cast::transmute(data.data.get_mut_ref());\n+        cast::forget(data);\n+        return r;\n     }\n-}\n \n-/**\n- * COMPLETELY UNSAFE. Used as a primitive for the safe versions in std::arc.\n- *\n- * Data races between tasks can result in crashes and, with sufficient\n- * cleverness, arbitrary type coercion.\n- */\n-pub type SharedMutableState<T> = ArcDestruct<T>;\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    pub unsafe fn get(&self) -> *mut T\n+    {\n+        let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+        assert!(data.count > 0);\n+        let r: *mut T = data.data.get_mut_ref();\n+        cast::forget(data);\n+        return r;\n+    }\n \n-pub unsafe fn shared_mutable_state<T:Owned>(data: T) ->\n-        SharedMutableState<T> {\n-    let data = ~ArcData { count: 1, data: Some(data) };\n-    let ptr = cast::transmute(data);\n-    ArcDestruct(ptr)\n-}\n+    #[inline(always)]\n+    #[cfg(stage0)]\n+    pub unsafe fn get_immut(&self) -> *T\n+    {\n+        let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+        assert!(data.count > 0);\n+        let r: *T = cast::transmute(data.data.get_mut_ref());\n+        cast::forget(data);\n+        return r;\n+    }\n \n-#[inline(always)]\n-pub unsafe fn get_shared_mutable_state<T:Owned>(\n-    rc: *SharedMutableState<T>) -> *mut T\n-{\n-    let ptr: ~ArcData<T> = cast::transmute((*rc).data);\n-    assert!(ptr.count > 0);\n-    let r = cast::transmute(ptr.data.get_ref());\n-    cast::forget(ptr);\n-    return r;\n-}\n-#[inline(always)]\n-pub unsafe fn get_shared_immutable_state<'a,T:Owned>(\n-        rc: &'a SharedMutableState<T>) -> &'a T {\n-    let ptr: ~ArcData<T> = cast::transmute((*rc).data);\n-    assert!(ptr.count > 0);\n-    // Cast us back into the correct region\n-    let r = cast::transmute_region(ptr.data.get_ref());\n-    cast::forget(ptr);\n-    return r;\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    pub unsafe fn get_immut(&self) -> *T\n+    {\n+        let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+        assert!(data.count > 0);\n+        let r: *T = cast::transmute_immut(data.data.get_mut_ref());\n+        cast::forget(data);\n+        return r;\n+    }\n }\n \n-pub unsafe fn clone_shared_mutable_state<T:Owned>(rc: &SharedMutableState<T>)\n-        -> SharedMutableState<T> {\n-    let mut ptr: ~ArcData<T> = cast::transmute((*rc).data);\n-    let new_count = intrinsics::atomic_xadd(&mut ptr.count, 1) + 1;\n-    assert!(new_count >= 2);\n-    cast::forget(ptr);\n-    ArcDestruct((*rc).data)\n+impl<T: Owned> Clone for UnsafeAtomicRcBox<T> {\n+    fn clone(&self) -> UnsafeAtomicRcBox<T> {\n+        unsafe {\n+            let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+            let new_count = intrinsics::atomic_xadd(&mut data.count, 1) + 1;\n+            assert!(new_count >= 2);\n+            cast::forget(data);\n+            return UnsafeAtomicRcBox { data: self.data };\n+        }\n+    }\n }\n \n-impl<T:Owned> Clone for SharedMutableState<T> {\n-    fn clone(&self) -> SharedMutableState<T> {\n+#[unsafe_destructor]\n+impl<T> Drop for UnsafeAtomicRcBox<T>{\n+    fn finalize(&self) {\n         unsafe {\n-            clone_shared_mutable_state(self)\n+            do task::unkillable {\n+                let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+                let new_count = intrinsics::atomic_xsub(&mut data.count, 1) - 1;\n+                assert!(new_count >= 0);\n+                if new_count == 0 {\n+                    // drop glue takes over.\n+                } else {\n+                    cast::forget(data);\n+                }\n+            }\n         }\n     }\n }\n \n+\n /****************************************************************************/\n \n #[allow(non_camel_case_types)] // runtime type\n@@ -160,7 +165,7 @@ struct ExData<T> {\n  * An arc over mutable data that is protected by a lock. For library use only.\n  */\n pub struct Exclusive<T> {\n-    x: SharedMutableState<ExData<T>>\n+    x: UnsafeAtomicRcBox<ExData<T>>\n }\n \n pub fn exclusive<T:Owned>(user_data: T) -> Exclusive<T> {\n@@ -170,16 +175,14 @@ pub fn exclusive<T:Owned>(user_data: T) -> Exclusive<T> {\n         data: user_data\n     };\n     Exclusive {\n-        x: unsafe {\n-            shared_mutable_state(data)\n-        }\n+        x: UnsafeAtomicRcBox::new(data)\n     }\n }\n \n impl<T:Owned> Clone for Exclusive<T> {\n     // Duplicate an exclusive ARC, as std::arc::clone.\n     fn clone(&self) -> Exclusive<T> {\n-        Exclusive { x: unsafe { clone_shared_mutable_state(&self.x) } }\n+        Exclusive { x: self.x.clone() }\n     }\n }\n \n@@ -192,7 +195,7 @@ pub impl<T:Owned> Exclusive<T> {\n     // the exclusive. Supporting that is a work in progress.\n     #[inline(always)]\n     unsafe fn with<U>(&self, f: &fn(x: &mut T) -> U) -> U {\n-        let rec = get_shared_mutable_state(&self.x);\n+        let rec = self.x.get();\n         do (*rec).lock.lock {\n             if (*rec).failed {\n                 fail!("}, {"sha": "d3f774a1cd51fd17ad8d768537705b7ea9d5e7ba", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 43, "deletions": 41, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/369231beb4b29a16c27bcc2c4f9a5679b613ed19/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/369231beb4b29a16c27bcc2c4f9a5679b613ed19/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=369231beb4b29a16c27bcc2c4f9a5679b613ed19", "patch": "@@ -17,9 +17,7 @@ use sync;\n use sync::{Mutex, mutex_with_condvars, RWlock, rwlock_with_condvars};\n \n use core::cast;\n-use core::unstable::sync::{SharedMutableState, shared_mutable_state};\n-use core::unstable::sync::{clone_shared_mutable_state};\n-use core::unstable::sync::{get_shared_mutable_state, get_shared_immutable_state};\n+use core::unstable::sync::UnsafeAtomicRcBox;\n use core::ptr;\n use core::task;\n \n@@ -83,19 +81,19 @@ pub impl<'self> Condvar<'self> {\n  ****************************************************************************/\n \n /// An atomically reference counted wrapper for shared immutable state.\n-struct ARC<T> { x: SharedMutableState<T> }\n+struct ARC<T> { x: UnsafeAtomicRcBox<T> }\n \n /// Create an atomically reference counted wrapper.\n pub fn ARC<T:Const + Owned>(data: T) -> ARC<T> {\n-    ARC { x: unsafe { shared_mutable_state(data) } }\n+    ARC { x: UnsafeAtomicRcBox::new(data) }\n }\n \n /**\n  * Access the underlying data in an atomically reference counted\n  * wrapper.\n  */\n pub fn get<'a, T:Const + Owned>(rc: &'a ARC<T>) -> &'a T {\n-    unsafe { get_shared_immutable_state(&rc.x) }\n+    unsafe { &*rc.x.get_immut() }\n }\n \n /**\n@@ -106,7 +104,7 @@ pub fn get<'a, T:Const + Owned>(rc: &'a ARC<T>) -> &'a T {\n  * allowing them to share the underlying data.\n  */\n pub fn clone<T:Const + Owned>(rc: &ARC<T>) -> ARC<T> {\n-    ARC { x: unsafe { clone_shared_mutable_state(&rc.x) } }\n+    ARC { x: rc.x.clone() }\n }\n \n impl<T:Const + Owned> Clone for ARC<T> {\n@@ -122,7 +120,7 @@ impl<T:Const + Owned> Clone for ARC<T> {\n #[doc(hidden)]\n struct MutexARCInner<T> { lock: Mutex, failed: bool, data: T }\n /// An ARC with mutable data protected by a blocking mutex.\n-struct MutexARC<T> { x: SharedMutableState<MutexARCInner<T>> }\n+struct MutexARC<T> { x: UnsafeAtomicRcBox<MutexARCInner<T>> }\n \n /// Create a mutex-protected ARC with the supplied data.\n pub fn MutexARC<T:Owned>(user_data: T) -> MutexARC<T> {\n@@ -137,15 +135,15 @@ pub fn mutex_arc_with_condvars<T:Owned>(user_data: T,\n     let data =\n         MutexARCInner { lock: mutex_with_condvars(num_condvars),\n                           failed: false, data: user_data };\n-    MutexARC { x: unsafe { shared_mutable_state(data) } }\n+    MutexARC { x: UnsafeAtomicRcBox::new(data) }\n }\n \n impl<T:Owned> Clone for MutexARC<T> {\n     /// Duplicate a mutex-protected ARC, as arc::clone.\n     fn clone(&self) -> MutexARC<T> {\n         // NB: Cloning the underlying mutex is not necessary. Its reference\n         // count would be exactly the same as the shared state's.\n-        MutexARC { x: unsafe { clone_shared_mutable_state(&self.x) } }\n+        MutexARC { x: self.x.clone() }\n     }\n }\n \n@@ -176,7 +174,7 @@ pub impl<T:Owned> MutexARC<T> {\n      */\n     #[inline(always)]\n     unsafe fn access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n-        let state = get_shared_mutable_state(&self.x);\n+        let state = self.x.get();\n         // Borrowck would complain about this if the function were\n         // not already unsafe. See borrow_rwlock, far below.\n         do (&(*state).lock).lock {\n@@ -192,7 +190,7 @@ pub impl<T:Owned> MutexARC<T> {\n         &self,\n         blk: &fn(x: &'x mut T, c: &'c Condvar) -> U) -> U\n     {\n-        let state = get_shared_mutable_state(&self.x);\n+        let state = self.x.get();\n         do (&(*state).lock).lock_cond |cond| {\n             check_poison(true, (*state).failed);\n             let _z = PoisonOnFail(&mut (*state).failed);\n@@ -254,7 +252,7 @@ struct RWARCInner<T> { lock: RWlock, failed: bool, data: T }\n  */\n #[mutable]\n struct RWARC<T> {\n-    x: SharedMutableState<RWARCInner<T>>,\n+    x: UnsafeAtomicRcBox<RWARCInner<T>>,\n     cant_nest: ()\n }\n \n@@ -273,13 +271,13 @@ pub fn rw_arc_with_condvars<T:Const + Owned>(\n     let data =\n         RWARCInner { lock: rwlock_with_condvars(num_condvars),\n                      failed: false, data: user_data };\n-    RWARC { x: unsafe { shared_mutable_state(data) }, cant_nest: () }\n+    RWARC { x: UnsafeAtomicRcBox::new(data), cant_nest: () }\n }\n \n pub impl<T:Const + Owned> RWARC<T> {\n     /// Duplicate a rwlock-protected ARC, as arc::clone.\n     fn clone(&self) -> RWARC<T> {\n-        RWARC { x: unsafe { clone_shared_mutable_state(&self.x) },\n+        RWARC { x: self.x.clone(),\n                 cant_nest: () }\n     }\n \n@@ -299,7 +297,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n     #[inline(always)]\n     fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n         unsafe {\n-            let state = get_shared_mutable_state(&self.x);\n+            let state = self.x.get();\n             do (*borrow_rwlock(state)).write {\n                 check_poison(false, (*state).failed);\n                 let _z = PoisonOnFail(&mut (*state).failed);\n@@ -313,7 +311,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n                              blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n                           -> U {\n         unsafe {\n-            let state = get_shared_mutable_state(&self.x);\n+            let state = self.x.get();\n             do (*borrow_rwlock(state)).write_cond |cond| {\n                 check_poison(false, (*state).failed);\n                 let _z = PoisonOnFail(&mut (*state).failed);\n@@ -334,10 +332,12 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * access modes, this will not poison the ARC.\n      */\n     fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n-        let state = unsafe { get_shared_immutable_state(&self.x) };\n-        do (&state.lock).read {\n-            check_poison(false, state.failed);\n-            blk(&state.data)\n+        let state = self.x.get();\n+        unsafe {\n+            do (*state).lock.read {\n+                check_poison(false, (*state).failed);\n+                blk(&(*state).data)\n+            }\n         }\n     }\n \n@@ -360,7 +360,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n      */\n     fn write_downgrade<U>(&self, blk: &fn(v: RWWriteMode<T>) -> U) -> U {\n         unsafe {\n-            let state = get_shared_mutable_state(&self.x);\n+            let state = self.x.get();\n             do (*borrow_rwlock(state)).write_downgrade |write_mode| {\n                 check_poison(false, (*state).failed);\n                 blk(RWWriteMode {\n@@ -374,25 +374,27 @@ pub impl<T:Const + Owned> RWARC<T> {\n \n     /// To be called inside of the write_downgrade block.\n     fn downgrade<'a>(&self, token: RWWriteMode<'a, T>) -> RWReadMode<'a, T> {\n-        // The rwlock should assert that the token belongs to us for us.\n-        let state = unsafe { get_shared_immutable_state(&self.x) };\n-        let RWWriteMode {\n-            data: data,\n-            token: t,\n-            poison: _poison\n-        } = token;\n-        // Let readers in\n-        let new_token = (&state.lock).downgrade(t);\n-        // Whatever region the input reference had, it will be safe to use\n-        // the same region for the output reference. (The only 'unsafe' part\n-        // of this cast is removing the mutability.)\n-        let new_data = unsafe { cast::transmute_immut(data) };\n-        // Downgrade ensured the token belonged to us. Just a sanity check.\n-        assert!(ptr::ref_eq(&state.data, new_data));\n-        // Produce new token\n-        RWReadMode {\n-            data: new_data,\n-            token: new_token,\n+        unsafe {\n+            // The rwlock should assert that the token belongs to us for us.\n+            let state = self.x.get();\n+            let RWWriteMode {\n+                data: data,\n+                token: t,\n+                poison: _poison\n+            } = token;\n+            // Let readers in\n+            let new_token = (*state).lock.downgrade(t);\n+            // Whatever region the input reference had, it will be safe to use\n+            // the same region for the output reference. (The only 'unsafe' part\n+            // of this cast is removing the mutability.)\n+            let new_data = cast::transmute_immut(data);\n+            // Downgrade ensured the token belonged to us. Just a sanity check.\n+            assert!(ptr::ref_eq(&(*state).data, new_data));\n+            // Produce new token\n+            RWReadMode {\n+                data: new_data,\n+                token: new_token,\n+            }\n         }\n     }\n }"}]}