{"sha": "357c6a7e2739da8c8d0a68a5e9e0867983af7cbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1N2M2YTdlMjczOWRhOGM4ZDBhNjhhNWU5ZTA4Njc5ODNhZjdjYmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-04T10:03:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-04T10:03:45Z"}, "message": "Auto merge of #6646 - nahuakang:for_loops_over_options_or_results, r=flip1995\n\nNew Lint: Manual Flatten\n\nThis is a draft PR for [Issue 6564](https://github.com/rust-lang/rust-clippy/issues/6564).\n\nr? `@camsteffen`\n\n- \\[x] Followed [lint naming conventions][lint_naming]\n- \\[x] Added passing UI tests (including committed `.stderr` file)\n- \\[x] `cargo test` passes locally\n- \\[x] Executed `cargo dev update_lints`\n- \\[x] Added lint documentation\n- \\[x] Run `cargo dev fmt`\n\n---\n\n*Please write a short comment explaining your change (or \"none\" for internal only changes)*\nchangelog: Add new lint [`manual_flatten`] to check for loops over a single `if let` expression with `Result` or `Option`.", "tree": {"sha": "efa75677c5d3c952b060a2cb62f124b34a05762f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efa75677c5d3c952b060a2cb62f124b34a05762f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe", "html_url": "https://github.com/rust-lang/rust/commit/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "876ffa4674c5d304983ff4d9bfeaffadee2cbb37", "url": "https://api.github.com/repos/rust-lang/rust/commits/876ffa4674c5d304983ff4d9bfeaffadee2cbb37", "html_url": "https://github.com/rust-lang/rust/commit/876ffa4674c5d304983ff4d9bfeaffadee2cbb37"}, {"sha": "2f8a8d3468050f724473900bcfcc75a110314059", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f8a8d3468050f724473900bcfcc75a110314059", "html_url": "https://github.com/rust-lang/rust/commit/2f8a8d3468050f724473900bcfcc75a110314059"}], "stats": {"total": 392, "additions": 343, "deletions": 49}, "files": [{"sha": "45321751ba7e8e48677ed4e2da05e3487696175a", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=357c6a7e2739da8c8d0a68a5e9e0867983af7cbe", "patch": "@@ -2039,6 +2039,7 @@ Released 2018-09-13\n [`manual_async_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_async_fn\n [`manual_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_filter_map\n [`manual_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find_map\n+[`manual_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_flatten\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n [`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n [`manual_ok_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_ok_or"}, {"sha": "7f5c4f56f9e05884680b6c6b0ceb9f046fbb8f3b", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=357c6a7e2739da8c8d0a68a5e9e0867983af7cbe", "patch": "@@ -687,6 +687,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &loops::FOR_KV_MAP,\n         &loops::FOR_LOOPS_OVER_FALLIBLES,\n         &loops::ITER_NEXT_LOOP,\n+        &loops::MANUAL_FLATTEN,\n         &loops::MANUAL_MEMCPY,\n         &loops::MUT_RANGE_BOUND,\n         &loops::NEEDLESS_COLLECT,\n@@ -1491,6 +1492,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::FOR_KV_MAP),\n         LintId::of(&loops::FOR_LOOPS_OVER_FALLIBLES),\n         LintId::of(&loops::ITER_NEXT_LOOP),\n+        LintId::of(&loops::MANUAL_FLATTEN),\n         LintId::of(&loops::MANUAL_MEMCPY),\n         LintId::of(&loops::MUT_RANGE_BOUND),\n         LintId::of(&loops::NEEDLESS_COLLECT),\n@@ -1822,6 +1824,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&lifetimes::EXTRA_UNUSED_LIFETIMES),\n         LintId::of(&lifetimes::NEEDLESS_LIFETIMES),\n         LintId::of(&loops::EXPLICIT_COUNTER_LOOP),\n+        LintId::of(&loops::MANUAL_FLATTEN),\n         LintId::of(&loops::MUT_RANGE_BOUND),\n         LintId::of(&loops::SINGLE_ELEMENT_LOOP),\n         LintId::of(&loops::WHILE_LET_LOOP),"}, {"sha": "663c2df23e22bd77ea0cfe1b3cdfbe0b3f3756ae", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 113, "deletions": 6, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=357c6a7e2739da8c8d0a68a5e9e0867983af7cbe", "patch": "@@ -5,10 +5,10 @@ use crate::utils::usage::{is_unused, mutated_variables};\n use crate::utils::visitors::LocalUsedVisitor;\n use crate::utils::{\n     contains_name, get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n-    indent_of, is_in_panic_handler, is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item,\n-    last_path_segment, match_trait_method, match_type, match_var, multispan_sugg, single_segment_path, snippet,\n-    snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg,\n-    span_lint_and_then, sugg, SpanlessEq,\n+    indent_of, is_in_panic_handler, is_integer_const, is_no_std_crate, is_ok_ctor, is_refutable, is_some_ctor,\n+    is_type_diagnostic_item, last_path_segment, match_trait_method, match_type, match_var, multispan_sugg,\n+    single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n+    span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast;\n@@ -494,8 +494,40 @@ declare_clippy_lint! {\n     \"there is no reason to have a single element loop\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Check for unnecessary `if let` usage in a for loop\n+    /// where only the `Some` or `Ok` variant of the iterator element is used.\n+    ///\n+    /// **Why is this bad?** It is verbose and can be simplified\n+    /// by first calling the `flatten` method on the `Iterator`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x = vec![Some(1), Some(2), Some(3)];\n+    /// for n in x {\n+    ///     if let Some(n) = n {\n+    ///         println!(\"{}\", n);\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = vec![Some(1), Some(2), Some(3)];\n+    /// for n in x.into_iter().flatten() {\n+    ///     println!(\"{}\", n);\n+    /// }\n+    /// ```\n+    pub MANUAL_FLATTEN,\n+    complexity,\n+    \"for loops over `Option`s or `Result`s with a single expression can be simplified\"\n+}\n+\n declare_lint_pass!(Loops => [\n     MANUAL_MEMCPY,\n+    MANUAL_FLATTEN,\n     NEEDLESS_RANGE_LOOP,\n     EXPLICIT_ITER_LOOP,\n     EXPLICIT_INTO_ITER_LOOP,\n@@ -517,14 +549,14 @@ declare_lint_pass!(Loops => [\n impl<'tcx> LateLintPass<'tcx> for Loops {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some((pat, arg, body)) = higher::for_loop(expr) {\n+        if let Some((pat, arg, body, span)) = higher::for_loop(expr) {\n             // we don't want to check expanded macros\n             // this check is not at the top of the function\n             // since higher::for_loop expressions are marked as expansions\n             if body.span.from_expansion() {\n                 return;\n             }\n-            check_for_loop(cx, pat, arg, body, expr);\n+            check_for_loop(cx, pat, arg, body, expr, span);\n         }\n \n         // we don't want to check expanded macros\n@@ -819,6 +851,7 @@ fn check_for_loop<'tcx>(\n     arg: &'tcx Expr<'_>,\n     body: &'tcx Expr<'_>,\n     expr: &'tcx Expr<'_>,\n+    span: Span,\n ) {\n     let is_manual_memcpy_triggered = detect_manual_memcpy(cx, pat, arg, body, expr);\n     if !is_manual_memcpy_triggered {\n@@ -830,6 +863,7 @@ fn check_for_loop<'tcx>(\n     check_for_mut_range_bound(cx, arg, body);\n     check_for_single_element_loop(cx, pat, arg, body, expr);\n     detect_same_item_push(cx, pat, arg, body, expr);\n+    check_manual_flatten(cx, pat, arg, body, span);\n }\n \n // this function assumes the given expression is a `for` loop.\n@@ -1953,6 +1987,79 @@ fn check_for_single_element_loop<'tcx>(\n     }\n }\n \n+/// Check for unnecessary `if let` usage in a for loop where only the `Some` or `Ok` variant of the\n+/// iterator element is used.\n+fn check_manual_flatten<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    span: Span,\n+) {\n+    if let ExprKind::Block(ref block, _) = body.kind {\n+        // Ensure the `if let` statement is the only expression or statement in the for-loop\n+        let inner_expr = if block.stmts.len() == 1 && block.expr.is_none() {\n+            let match_stmt = &block.stmts[0];\n+            if let StmtKind::Semi(inner_expr) = match_stmt.kind {\n+                Some(inner_expr)\n+            } else {\n+                None\n+            }\n+        } else if block.stmts.is_empty() {\n+            block.expr\n+        } else {\n+            None\n+        };\n+\n+        if_chain! {\n+            if let Some(inner_expr) = inner_expr;\n+            if let ExprKind::Match(\n+                ref match_expr, ref match_arms, MatchSource::IfLetDesugar{ contains_else_clause: false }\n+            ) = inner_expr.kind;\n+            // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n+            if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n+            if let ExprKind::Path(QPath::Resolved(None, match_expr_path)) = match_expr.kind;\n+            if let Res::Local(match_expr_path_id) = match_expr_path.res;\n+            if pat_hir_id == match_expr_path_id;\n+            // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n+            if let PatKind::TupleStruct(QPath::Resolved(None, path), _, _) = match_arms[0].pat.kind;\n+            let some_ctor = is_some_ctor(cx, path.res);\n+            let ok_ctor = is_ok_ctor(cx, path.res);\n+            if some_ctor || ok_ctor;\n+            let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n+\n+            then {\n+                // Prepare the error message\n+                let msg = format!(\"unnecessary `if let` since only the `{}` variant of the iterator element is used\", if_let_type);\n+\n+                // Prepare the help message\n+                let mut applicability = Applicability::MaybeIncorrect;\n+                let arg_snippet = make_iterator_snippet(cx, arg, &mut applicability);\n+\n+                span_lint_and_then(\n+                    cx,\n+                    MANUAL_FLATTEN,\n+                    span,\n+                    &msg,\n+                    |diag| {\n+                        let sugg = format!(\"{}.flatten()\", arg_snippet);\n+                        diag.span_suggestion(\n+                            arg.span,\n+                            \"try\",\n+                            sugg,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        diag.span_help(\n+                            inner_expr.span,\n+                            \"...and remove the `if let` statement in the for loop\",\n+                        );\n+                    }\n+                );\n+            }\n+        }\n+    }\n+}\n+\n struct MutatePairDelegate<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     hir_id_low: Option<HirId>,"}, {"sha": "d7239b328bbcd0a7f245ba19b827ffbf67f1b856", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=357c6a7e2739da8c8d0a68a5e9e0867983af7cbe", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n             return;\n         }\n \n-        if let Some((_, arg, body)) = higher::for_loop(expr) {\n+        if let Some((_, arg, body, _)) = higher::for_loop(expr) {\n             // A `for` loop lowers to:\n             // ```rust\n             // match ::std::iter::Iterator::next(&mut iter) {"}, {"sha": "fe8d4d07abc15ae8a062e313c766a93c6c065bea", "filename": "clippy_lints/src/needless_question_mark.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=357c6a7e2739da8c8d0a68a5e9e0867983af7cbe", "patch": "@@ -1,8 +1,6 @@\n use rustc_errors::Applicability;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::{Body, Expr, ExprKind, LangItem, MatchSource, QPath};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::ty::DefIdTree;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::sym;\n@@ -160,7 +158,7 @@ fn is_some_or_ok_call<'a>(\n         // Check outer expression matches CALL_IDENT(ARGUMENT) format\n         if let ExprKind::Call(path, args) = &expr.kind;\n         if let ExprKind::Path(QPath::Resolved(None, path)) = &path.kind;\n-        if is_some_ctor(cx, path.res) || is_ok_ctor(cx, path.res);\n+        if utils::is_some_ctor(cx, path.res) || utils::is_ok_ctor(cx, path.res);\n \n         // Extract inner expression from ARGUMENT\n         if let ExprKind::Match(inner_expr_with_q, _, MatchSource::TryDesugar) = &args[0].kind;\n@@ -208,25 +206,3 @@ fn is_some_or_ok_call<'a>(\n fn has_implicit_error_from(cx: &LateContext<'_>, entire_expr: &Expr<'_>, inner_result_expr: &Expr<'_>) -> bool {\n     return cx.typeck_results().expr_ty(entire_expr) != cx.typeck_results().expr_ty(inner_result_expr);\n }\n-\n-fn is_ok_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n-    if let Some(ok_id) = cx.tcx.lang_items().result_ok_variant() {\n-        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n-            if let Some(variant_id) = cx.tcx.parent(id) {\n-                return variant_id == ok_id;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n-fn is_some_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n-    if let Some(some_id) = cx.tcx.lang_items().option_some_variant() {\n-        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n-            if let Some(variant_id) = cx.tcx.parent(id) {\n-                return variant_id == some_id;\n-            }\n-        }\n-    }\n-    false\n-}"}, {"sha": "59503817c0fccfc97719e2d355defa325e8fb0fe", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=357c6a7e2739da8c8d0a68a5e9e0867983af7cbe", "patch": "@@ -442,7 +442,7 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         let mut cur_expr = expr;\n         while let Some(parent_expr) = get_parent_expr(cx, cur_expr) {\n             match higher::for_loop(parent_expr) {\n-                Some((_, args, _)) if args.hir_id == expr.hir_id => return true,\n+                Some((_, args, _, _)) if args.hir_id == expr.hir_id => return true,\n                 _ => cur_expr = parent_expr,\n             }\n         }"}, {"sha": "df7f0f957821877a9ed52c0db5f711d60f1dabd0", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=357c6a7e2739da8c8d0a68a5e9e0867983af7cbe", "patch": "@@ -9,6 +9,7 @@ use rustc_ast::ast;\n use rustc_hir as hir;\n use rustc_hir::{BorrowKind, Expr, ExprKind, StmtKind, UnOp};\n use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n \n /// Converts a hir binary operator to the corresponding `ast` type.\n #[must_use]\n@@ -133,11 +134,11 @@ pub fn is_from_for_desugar(local: &hir::Local<'_>) -> bool {\n     false\n }\n \n-/// Recover the essential nodes of a desugared for loop:\n-/// `for pat in arg { body }` becomes `(pat, arg, body)`.\n+/// Recover the essential nodes of a desugared for loop as well as the entire span:\n+/// `for pat in arg { body }` becomes `(pat, arg, body)`. Return `(pat, arg, body, span)`.\n pub fn for_loop<'tcx>(\n     expr: &'tcx hir::Expr<'tcx>,\n-) -> Option<(&hir::Pat<'_>, &'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>)> {\n+) -> Option<(&hir::Pat<'_>, &'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>, Span)> {\n     if_chain! {\n         if let hir::ExprKind::Match(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n         if let hir::ExprKind::Call(_, ref iterargs) = iterexpr.kind;\n@@ -148,7 +149,7 @@ pub fn for_loop<'tcx>(\n         if let hir::StmtKind::Local(ref local) = let_stmt.kind;\n         if let hir::StmtKind::Expr(ref expr) = body.kind;\n         then {\n-            return Some((&*local.pat, &iterargs[0], expr));\n+            return Some((&*local.pat, &iterargs[0], expr, arms[0].span));\n         }\n     }\n     None"}, {"sha": "f5c3109560d2042a6b037f35c0b4f786ef387868", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=357c6a7e2739da8c8d0a68a5e9e0867983af7cbe", "patch": "@@ -841,15 +841,13 @@ pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n     // implementations of native types. Check lang items.\n     let path_syms: Vec<_> = path.iter().map(|p| Symbol::intern(p)).collect();\n     let lang_items = cx.tcx.lang_items();\n-    for lang_item in lang_items.items() {\n-        if let Some(def_id) = lang_item {\n-            let lang_item_path = cx.get_def_path(*def_id);\n-            if path_syms.starts_with(&lang_item_path) {\n-                if let [item] = &path_syms[lang_item_path.len()..] {\n-                    for child in cx.tcx.item_children(*def_id) {\n-                        if child.ident.name == *item {\n-                            return true;\n-                        }\n+    for item_def_id in lang_items.items().iter().flatten() {\n+        let lang_item_path = cx.get_def_path(*item_def_id);\n+        if path_syms.starts_with(&lang_item_path) {\n+            if let [item] = &path_syms[lang_item_path.len()..] {\n+                for child in cx.tcx.item_children(*item_def_id) {\n+                    if child.ident.name == *item {\n+                        return true;\n                     }\n                 }\n             }"}, {"sha": "cf93ee0a7a5c61375503fc65438a372e60a270b4", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=357c6a7e2739da8c8d0a68a5e9e0867983af7cbe", "patch": "@@ -37,7 +37,7 @@ use rustc_ast::ast::{self, Attribute, LitKind};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::Node;\n@@ -50,7 +50,7 @@ use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, layout::IntegerExt, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, layout::IntegerExt, DefIdTree, Ty, TyCtxt, TypeFoldable};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n@@ -1703,6 +1703,30 @@ pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n     }\n }\n \n+/// Check if the resolution of a given path is an `Ok` variant of `Result`.\n+pub fn is_ok_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n+    if let Some(ok_id) = cx.tcx.lang_items().result_ok_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n+            if let Some(variant_id) = cx.tcx.parent(id) {\n+                return variant_id == ok_id;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+/// Check if the resolution of a given path is a `Some` variant of `Option`.\n+pub fn is_some_ctor(cx: &LateContext<'_>, res: Res) -> bool {\n+    if let Some(some_id) = cx.tcx.lang_items().option_some_variant() {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n+            if let Some(variant_id) = cx.tcx.parent(id) {\n+                return variant_id == some_id;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::{reindent_multiline, without_block_comments};"}, {"sha": "c132e4de4f67ba450b877bf49fe09066bf5b32a8", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=357c6a7e2739da8c8d0a68a5e9e0867983af7cbe", "patch": "@@ -55,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n \n         // search for `for _ in vec![\u2026]`\n         if_chain! {\n-            if let Some((_, arg, _)) = higher::for_loop(expr);\n+            if let Some((_, arg, _, _)) = higher::for_loop(expr);\n             if let Some(vec_args) = higher::vec_macro(cx, arg);\n             if is_copy(cx, vec_type(cx.typeck_results().expr_ty_adjusted(arg)));\n             then {"}, {"sha": "cff68eca933743338acd6b184c3b25c0883aa9c1", "filename": "tests/ui/manual_flatten.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/tests%2Fui%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/tests%2Fui%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_flatten.rs?ref=357c6a7e2739da8c8d0a68a5e9e0867983af7cbe", "patch": "@@ -0,0 +1,76 @@\n+#![warn(clippy::manual_flatten)]\n+\n+fn main() {\n+    // Test for loop over implicitly adjusted `Iterator` with `if let` expression\n+    let x = vec![Some(1), Some(2), Some(3)];\n+    for n in x {\n+        if let Some(y) = n {\n+            println!(\"{}\", y);\n+        }\n+    }\n+\n+    // Test for loop over implicitly implicitly adjusted `Iterator` with `if let` statement\n+    let y: Vec<Result<i32, i32>> = vec![];\n+    for n in y.clone() {\n+        if let Ok(n) = n {\n+            println!(\"{}\", n);\n+        };\n+    }\n+\n+    // Test for loop over by reference\n+    for n in &y {\n+        if let Ok(n) = n {\n+            println!(\"{}\", n);\n+        }\n+    }\n+\n+    // Test for loop over an implicit reference\n+    // Note: if `clippy::manual_flatten` is made autofixable, this case will\n+    // lead to a follow-up lint `clippy::into_iter_on_ref`\n+    let z = &y;\n+    for n in z {\n+        if let Ok(n) = n {\n+            println!(\"{}\", n);\n+        }\n+    }\n+\n+    // Test for loop over `Iterator` with `if let` expression\n+    let z = vec![Some(1), Some(2), Some(3)];\n+    let z = z.iter();\n+    for n in z {\n+        if let Some(m) = n {\n+            println!(\"{}\", m);\n+        }\n+    }\n+\n+    // Using the `None` variant should not trigger the lint\n+    // Note: for an autofixable suggestion, the binding in the for loop has to take the\n+    // name of the binding in the `if let`\n+    let z = vec![Some(1), Some(2), Some(3)];\n+    for n in z {\n+        if n.is_none() {\n+            println!(\"Nada.\");\n+        }\n+    }\n+\n+    // Using the `Err` variant should not trigger the lint\n+    for n in y.clone() {\n+        if let Err(e) = n {\n+            println!(\"Oops: {}!\", e);\n+        }\n+    }\n+\n+    // Having an else clause should not trigger the lint\n+    for n in y.clone() {\n+        if let Ok(n) = n {\n+            println!(\"{}\", n);\n+        } else {\n+            println!(\"Oops!\");\n+        }\n+    }\n+\n+    // Using manual flatten should not trigger the lint\n+    for n in vec![Some(1), Some(2), Some(3)].iter().flatten() {\n+        println!(\"{}\", n);\n+    }\n+}"}, {"sha": "855dd9130e2fbbdc8e9c77047a4d69d1c5ebae9e", "filename": "tests/ui/manual_flatten.stderr", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/tests%2Fui%2Fmanual_flatten.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/357c6a7e2739da8c8d0a68a5e9e0867983af7cbe/tests%2Fui%2Fmanual_flatten.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_flatten.stderr?ref=357c6a7e2739da8c8d0a68a5e9e0867983af7cbe", "patch": "@@ -0,0 +1,108 @@\n+error: unnecessary `if let` since only the `Some` variant of the iterator element is used\n+  --> $DIR/manual_flatten.rs:6:5\n+   |\n+LL |       for n in x {\n+   |       ^        - help: try: `x.into_iter().flatten()`\n+   |  _____|\n+   | |\n+LL | |         if let Some(y) = n {\n+LL | |             println!(\"{}\", y);\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::manual-flatten` implied by `-D warnings`\n+help: ...and remove the `if let` statement in the for loop\n+  --> $DIR/manual_flatten.rs:7:9\n+   |\n+LL | /         if let Some(y) = n {\n+LL | |             println!(\"{}\", y);\n+LL | |         }\n+   | |_________^\n+\n+error: unnecessary `if let` since only the `Ok` variant of the iterator element is used\n+  --> $DIR/manual_flatten.rs:14:5\n+   |\n+LL |       for n in y.clone() {\n+   |       ^        --------- help: try: `y.clone().into_iter().flatten()`\n+   |  _____|\n+   | |\n+LL | |         if let Ok(n) = n {\n+LL | |             println!(\"{}\", n);\n+LL | |         };\n+LL | |     }\n+   | |_____^\n+   |\n+help: ...and remove the `if let` statement in the for loop\n+  --> $DIR/manual_flatten.rs:15:9\n+   |\n+LL | /         if let Ok(n) = n {\n+LL | |             println!(\"{}\", n);\n+LL | |         };\n+   | |_________^\n+\n+error: unnecessary `if let` since only the `Ok` variant of the iterator element is used\n+  --> $DIR/manual_flatten.rs:21:5\n+   |\n+LL |       for n in &y {\n+   |       ^        -- help: try: `y.iter().flatten()`\n+   |  _____|\n+   | |\n+LL | |         if let Ok(n) = n {\n+LL | |             println!(\"{}\", n);\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: ...and remove the `if let` statement in the for loop\n+  --> $DIR/manual_flatten.rs:22:9\n+   |\n+LL | /         if let Ok(n) = n {\n+LL | |             println!(\"{}\", n);\n+LL | |         }\n+   | |_________^\n+\n+error: unnecessary `if let` since only the `Ok` variant of the iterator element is used\n+  --> $DIR/manual_flatten.rs:31:5\n+   |\n+LL |       for n in z {\n+   |       ^        - help: try: `z.into_iter().flatten()`\n+   |  _____|\n+   | |\n+LL | |         if let Ok(n) = n {\n+LL | |             println!(\"{}\", n);\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: ...and remove the `if let` statement in the for loop\n+  --> $DIR/manual_flatten.rs:32:9\n+   |\n+LL | /         if let Ok(n) = n {\n+LL | |             println!(\"{}\", n);\n+LL | |         }\n+   | |_________^\n+\n+error: unnecessary `if let` since only the `Some` variant of the iterator element is used\n+  --> $DIR/manual_flatten.rs:40:5\n+   |\n+LL |       for n in z {\n+   |       ^        - help: try: `z.flatten()`\n+   |  _____|\n+   | |\n+LL | |         if let Some(m) = n {\n+LL | |             println!(\"{}\", m);\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+help: ...and remove the `if let` statement in the for loop\n+  --> $DIR/manual_flatten.rs:41:9\n+   |\n+LL | /         if let Some(m) = n {\n+LL | |             println!(\"{}\", m);\n+LL | |         }\n+   | |_________^\n+\n+error: aborting due to 5 previous errors\n+"}]}