{"sha": "a24df5b3cdeb49334d6cde1c4d983b2354616824", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNGRmNWIzY2RlYjQ5MzM0ZDZjZGUxYzRkOTgzYjIzNTQ2MTY4MjQ=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2020-03-03T16:25:03Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2020-05-07T21:35:58Z"}, "message": "Reintegrate chalk using chalk-solve", "tree": {"sha": "0cd6fe7af3d9c5b05f69643659ce27651e27df6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cd6fe7af3d9c5b05f69643659ce27651e27df6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a24df5b3cdeb49334d6cde1c4d983b2354616824", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a24df5b3cdeb49334d6cde1c4d983b2354616824", "html_url": "https://github.com/rust-lang/rust/commit/a24df5b3cdeb49334d6cde1c4d983b2354616824", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a24df5b3cdeb49334d6cde1c4d983b2354616824/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a08c47310c7d49cbdc5d7afb38408ba519967ecd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a08c47310c7d49cbdc5d7afb38408ba519967ecd", "html_url": "https://github.com/rust-lang/rust/commit/a08c47310c7d49cbdc5d7afb38408ba519967ecd"}], "stats": {"total": 2911, "additions": 2890, "deletions": 21}, "files": [{"sha": "6b28f1513d2ac86417663ca3bf054c956decffb8", "filename": "Cargo.lock", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -429,6 +429,77 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"chalk-derive\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8d4620afad4d4d9e63f915cfa10c930b7a3c9c3ca5cd88dd771ff8e5bf04ea10\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n+ \"synstructure 0.12.1\",\n+]\n+\n+[[package]]\n+name = \"chalk-engine\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6ca6e5cef10197789da0b4ec310eda58da4c55530613b2323432642a97372735\"\n+dependencies = [\n+ \"chalk-macros\",\n+ \"rustc-hash\",\n+]\n+\n+[[package]]\n+name = \"chalk-ir\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d45df5fb6328527f976e8a32c9e1c9970084d937ebe93d0d34f5bbf4231cb956\"\n+dependencies = [\n+ \"chalk-derive\",\n+ \"chalk-engine\",\n+ \"chalk-macros\",\n+]\n+\n+[[package]]\n+name = \"chalk-macros\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9e4782d108e420a1fcf94d8a919cf248db33c5071678e87d9c2d4f20ed1feb32\"\n+dependencies = [\n+ \"lazy_static 1.4.0\",\n+]\n+\n+[[package]]\n+name = \"chalk-rust-ir\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a0ec96dbe0ab5fdbadfca4179ec2e1d35f0439c3b53a74988b1aec239c63eb08\"\n+dependencies = [\n+ \"chalk-derive\",\n+ \"chalk-engine\",\n+ \"chalk-ir\",\n+ \"chalk-macros\",\n+]\n+\n+[[package]]\n+name = \"chalk-solve\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dfb99fa9530f0e101475fb60adc931f51bdea05b4642a48928b814d7f0141a6b\"\n+dependencies = [\n+ \"chalk-derive\",\n+ \"chalk-engine\",\n+ \"chalk-ir\",\n+ \"chalk-macros\",\n+ \"chalk-rust-ir\",\n+ \"ena\",\n+ \"itertools 0.9.0\",\n+ \"petgraph\",\n+ \"rustc-hash\",\n+]\n+\n [[package]]\n name = \"chrono\"\n version = \"0.4.6\"\n@@ -1102,6 +1173,12 @@ dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n+[[package]]\n+name = \"fixedbitset\"\n+version = \"0.1.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n+\n [[package]]\n name = \"flate2\"\n version = \"1.0.12\"\n@@ -2328,6 +2405,12 @@ dependencies = [\n  \"vcpkg\",\n ]\n \n+[[package]]\n+name = \"ordermap\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a86ed3f5f244b372d6b1a00b72ef7f8876d0bc6a78a4c9985c53614041512063\"\n+\n [[package]]\n name = \"ordslice\"\n version = \"0.3.0\"\n@@ -2496,6 +2579,16 @@ dependencies = [\n  \"sha-1\",\n ]\n \n+[[package]]\n+name = \"petgraph\"\n+version = \"0.4.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9c3659d1ee90221741f65dd128d9998311b0e40c5d3c23a62445938214abce4f\"\n+dependencies = [\n+ \"fixedbitset\",\n+ \"ordermap\",\n+]\n+\n [[package]]\n name = \"phf\"\n version = \"0.7.24\"\n@@ -4002,6 +4095,7 @@ dependencies = [\n  \"arena\",\n  \"bitflags\",\n  \"byteorder\",\n+ \"chalk-ir\",\n  \"log\",\n  \"measureme\",\n  \"polonius-engine\",\n@@ -4301,10 +4395,14 @@ dependencies = [\n name = \"rustc_traits\"\n version = \"0.0.0\"\n dependencies = [\n+ \"chalk-ir\",\n+ \"chalk-rust-ir\",\n+ \"chalk-solve\",\n  \"log\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n+ \"rustc_index\",\n  \"rustc_infer\",\n  \"rustc_middle\",\n  \"rustc_span\","}, {"sha": "20af9b22a9795ebe53b54381d59f491ad78a956c", "filename": "src/librustc_infer/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -353,8 +353,10 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     // `TyVar(vid)` is unresolved, track its universe index in the canonicalized\n                     // result.\n                     Err(mut ui) => {\n-                        // FIXME: perf problem described in #55921.\n-                        ui = ty::UniverseIndex::ROOT;\n+                        if !self.infcx.unwrap().tcx.sess.opts.debugging_opts.chalk {\n+                            // FIXME: perf problem described in #55921.\n+                            ui = ty::UniverseIndex::ROOT;\n+                        }\n                         self.canonicalize_ty_var(\n                             CanonicalVarInfo {\n                                 kind: CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n@@ -439,8 +441,10 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     // `ConstVar(vid)` is unresolved, track its universe index in the\n                     // canonicalized result\n                     Err(mut ui) => {\n-                        // FIXME: perf problem described in #55921.\n-                        ui = ty::UniverseIndex::ROOT;\n+                        if !self.infcx.unwrap().tcx.sess.opts.debugging_opts.chalk {\n+                            // FIXME: perf problem described in #55921.\n+                            ui = ty::UniverseIndex::ROOT;\n+                        }\n                         return self.canonicalize_const_var(\n                             CanonicalVarInfo { kind: CanonicalVarKind::Const(ui) },\n                             ct,"}, {"sha": "69237b81a823edbbe9da3b47214f33db86bb4b80", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -525,6 +525,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(always_encode_mir, true);\n     tracked!(asm_comments, true);\n     tracked!(binary_dep_depinfo, true);\n+    tracked!(chalk, true);\n     tracked!(codegen_backend, Some(\"abc\".to_string()));\n     tracked!(crate_attr, vec![\"abc\".to_string()]);\n     tracked!(debug_macros, true);"}, {"sha": "8a1317ba2893f2ffda394c98eda9ff453c4b1989", "filename": "src/librustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2FCargo.toml?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -31,6 +31,7 @@ rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n byteorder = { version = \"1.3\" }\n+chalk-ir = \"0.10.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"0.7.1\"\n rustc_session = { path = \"../librustc_session\" }"}, {"sha": "330379008801057ffd765b411d3219ceb080ed0a", "filename": "src/librustc_middle/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -51,6 +51,7 @@\n \n use crate::mir;\n use crate::mir::interpret::{GlobalId, LitToConstInput};\n+use crate::traits;\n use crate::traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n     CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,"}, {"sha": "760fded55d69caed8e580e3260765b7fbd10a462", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -1,6 +1,7 @@\n use crate::dep_graph::SerializedDepNodeIndex;\n use crate::mir;\n use crate::mir::interpret::{GlobalId, LitToConstInput};\n+use crate::traits;\n use crate::traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n     CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n@@ -1154,6 +1155,15 @@ rustc_queries! {\n             desc { \"evaluating trait selection obligation `{}`\", goal.value.value }\n         }\n \n+        query evaluate_goal(\n+            goal: traits::ChalkCanonicalGoal<'tcx>\n+        ) -> Result<\n+            &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n+            NoSolution\n+        > {\n+            desc { \"evaluating trait selection obligation `{}`\", goal.value }\n+        }\n+\n         /// Do not call this query directly: part of the `Eq` type-op\n         query type_op_ascribe_user_type(\n             goal: CanonicalTypeOpAscribeUserTypeGoal<'tcx>"}, {"sha": "b963af96f5027cd5b96207353c02e1f8f386908e", "filename": "src/librustc_middle/traits/chalk.rs", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_middle%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_middle%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fchalk.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,366 @@\n+//! Types required for Chalk-related queries\n+//!\n+//! The primary purpose of this file is defining an implementation for the\n+//! `chalk_ir::interner::Interner` trait. The primary purpose of this trait, as\n+//! its name suggest, is to provide an abstraction boundary for creating\n+//! interned Chalk types.\n+\n+use chalk_ir::{GoalData, Parameter};\n+\n+use rustc_middle::mir::Mutability;\n+use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+\n+use rustc_hir::def_id::DefId;\n+\n+use smallvec::SmallVec;\n+\n+use std::cmp::Ordering;\n+use std::fmt;\n+use std::hash::{Hash, Hasher};\n+\n+/// Since Chalk doesn't have full support for all Rust builtin types yet, we\n+/// need to use an enum here, rather than just `DefId`.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub enum RustDefId {\n+    Adt(DefId),\n+    Str,\n+    Never,\n+    Slice,\n+    Array,\n+    Ref(Mutability),\n+    RawPtr,\n+\n+    Trait(DefId),\n+\n+    Impl(DefId),\n+\n+    FnDef(DefId),\n+\n+    AssocTy(DefId),\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct RustInterner<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+}\n+\n+/// We don't ever actually need this. It's only required for derives.\n+impl<'tcx> Hash for RustInterner<'tcx> {\n+    fn hash<H: Hasher>(&self, _state: &mut H) {}\n+}\n+\n+/// We don't ever actually need this. It's only required for derives.\n+impl<'tcx> Ord for RustInterner<'tcx> {\n+    fn cmp(&self, _other: &Self) -> Ordering {\n+        Ordering::Equal\n+    }\n+}\n+\n+/// We don't ever actually need this. It's only required for derives.\n+impl<'tcx> PartialOrd for RustInterner<'tcx> {\n+    fn partial_cmp(&self, _other: &Self) -> Option<Ordering> {\n+        None\n+    }\n+}\n+\n+/// We don't ever actually need this. It's only required for derives.\n+impl<'tcx> PartialEq for RustInterner<'tcx> {\n+    fn eq(&self, _other: &Self) -> bool {\n+        false\n+    }\n+}\n+\n+/// We don't ever actually need this. It's only required for derives.\n+impl<'tcx> Eq for RustInterner<'tcx> {}\n+\n+impl fmt::Debug for RustInterner<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"RustInterner\")\n+    }\n+}\n+\n+// Right now, there is no interning at all. I was running into problems with\n+// adding interning in `ty/context.rs` for Chalk types with\n+// `parallel-compiler = true`. -jackh726\n+impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n+    type InternedType = Box<chalk_ir::TyData<Self>>;\n+    type InternedLifetime = Box<chalk_ir::LifetimeData<Self>>;\n+    type InternedParameter = Box<chalk_ir::ParameterData<Self>>;\n+    type InternedGoal = Box<chalk_ir::GoalData<Self>>;\n+    type InternedGoals = Vec<chalk_ir::Goal<Self>>;\n+    type InternedSubstitution = Vec<chalk_ir::Parameter<Self>>;\n+    type InternedProgramClause = Box<chalk_ir::ProgramClauseData<Self>>;\n+    type InternedProgramClauses = Vec<chalk_ir::ProgramClause<Self>>;\n+    type InternedQuantifiedWhereClauses = Vec<chalk_ir::QuantifiedWhereClause<Self>>;\n+    type InternedParameterKinds = Vec<chalk_ir::ParameterKind<()>>;\n+    type InternedCanonicalVarKinds = Vec<chalk_ir::ParameterKind<chalk_ir::UniverseIndex>>;\n+    type DefId = RustDefId;\n+    type Identifier = ();\n+\n+    fn debug_program_clause_implication(\n+        pci: &chalk_ir::ProgramClauseImplication<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        let mut write = || {\n+            write!(fmt, \"{:?}\", pci.consequence)?;\n+\n+            let conditions = pci.conditions.interned();\n+\n+            let conds = conditions.len();\n+            if conds == 0 {\n+                return Ok(());\n+            }\n+\n+            write!(fmt, \" :- \")?;\n+            for cond in &conditions[..conds - 1] {\n+                write!(fmt, \"{:?}, \", cond)?;\n+            }\n+            write!(fmt, \"{:?}\", conditions[conds - 1])?;\n+            Ok(())\n+        };\n+        Some(write())\n+    }\n+\n+    fn debug_application_ty(\n+        application_ty: &chalk_ir::ApplicationTy<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        let chalk_ir::ApplicationTy { name, substitution } = application_ty;\n+        Some(write!(fmt, \"{:?}{:?}\", name, chalk_ir::debug::Angle(substitution.interned())))\n+    }\n+\n+    fn debug_substitution(\n+        substitution: &chalk_ir::Substitution<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        Some(write!(fmt, \"{:?}\", substitution.interned()))\n+    }\n+\n+    fn debug_separator_trait_ref(\n+        separator_trait_ref: &chalk_ir::SeparatorTraitRef<'_, Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        let substitution = &separator_trait_ref.trait_ref.substitution;\n+        let parameters = substitution.interned();\n+        Some(write!(\n+            fmt,\n+            \"{:?}{}{:?}{:?}\",\n+            parameters[0],\n+            separator_trait_ref.separator,\n+            separator_trait_ref.trait_ref.trait_id,\n+            chalk_ir::debug::Angle(&parameters[1..])\n+        ))\n+    }\n+\n+    fn debug_quantified_where_clauses(\n+        clauses: &chalk_ir::QuantifiedWhereClauses<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        Some(write!(fmt, \"{:?}\", clauses.interned()))\n+    }\n+\n+    fn debug_alias(\n+        alias_ty: &chalk_ir::AliasTy<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        match alias_ty {\n+            chalk_ir::AliasTy::Projection(projection_ty) => {\n+                Self::debug_projection_ty(projection_ty, fmt)\n+            }\n+            chalk_ir::AliasTy::Opaque(opaque_ty) => Self::debug_opaque_ty(opaque_ty, fmt),\n+        }\n+    }\n+\n+    fn debug_projection_ty(\n+        projection_ty: &chalk_ir::ProjectionTy<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        Some(write!(\n+            fmt,\n+            \"projection: {:?} {:?}\",\n+            projection_ty.associated_ty_id, projection_ty.substitution,\n+        ))\n+    }\n+\n+    fn debug_opaque_ty(\n+        opaque_ty: &chalk_ir::OpaqueTy<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        Some(write!(fmt, \"{:?}\", opaque_ty.opaque_ty_id))\n+    }\n+\n+    fn intern_ty(&self, ty: chalk_ir::TyData<Self>) -> Self::InternedType {\n+        Box::new(ty)\n+    }\n+\n+    fn ty_data<'a>(&self, ty: &'a Self::InternedType) -> &'a chalk_ir::TyData<Self> {\n+        ty\n+    }\n+\n+    fn intern_lifetime(&self, lifetime: chalk_ir::LifetimeData<Self>) -> Self::InternedLifetime {\n+        Box::new(lifetime)\n+    }\n+\n+    fn lifetime_data<'a>(\n+        &self,\n+        lifetime: &'a Self::InternedLifetime,\n+    ) -> &'a chalk_ir::LifetimeData<Self> {\n+        &lifetime\n+    }\n+\n+    fn intern_parameter(\n+        &self,\n+        parameter: chalk_ir::ParameterData<Self>,\n+    ) -> Self::InternedParameter {\n+        Box::new(parameter)\n+    }\n+\n+    fn parameter_data<'a>(\n+        &self,\n+        parameter: &'a Self::InternedParameter,\n+    ) -> &'a chalk_ir::ParameterData<Self> {\n+        &parameter\n+    }\n+\n+    fn intern_goal(&self, goal: GoalData<Self>) -> Self::InternedGoal {\n+        Box::new(goal)\n+    }\n+\n+    fn goal_data<'a>(&self, goal: &'a Self::InternedGoal) -> &'a GoalData<Self> {\n+        &goal\n+    }\n+\n+    fn intern_goals<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::Goal<Self>, E>>,\n+    ) -> Result<Self::InternedGoals, E> {\n+        data.into_iter().collect::<Result<Vec<_>, _>>()\n+    }\n+\n+    fn goals_data<'a>(&self, goals: &'a Self::InternedGoals) -> &'a [chalk_ir::Goal<Self>] {\n+        goals\n+    }\n+\n+    fn intern_substitution<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::Parameter<Self>, E>>,\n+    ) -> Result<Self::InternedSubstitution, E> {\n+        data.into_iter().collect::<Result<Vec<_>, _>>()\n+    }\n+\n+    fn substitution_data<'a>(\n+        &self,\n+        substitution: &'a Self::InternedSubstitution,\n+    ) -> &'a [Parameter<Self>] {\n+        substitution\n+    }\n+\n+    fn intern_program_clause(\n+        &self,\n+        data: chalk_ir::ProgramClauseData<Self>,\n+    ) -> Self::InternedProgramClause {\n+        Box::new(data)\n+    }\n+\n+    fn program_clause_data<'a>(\n+        &self,\n+        clause: &'a Self::InternedProgramClause,\n+    ) -> &'a chalk_ir::ProgramClauseData<Self> {\n+        &clause\n+    }\n+\n+    fn intern_program_clauses<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::ProgramClause<Self>, E>>,\n+    ) -> Result<Self::InternedProgramClauses, E> {\n+        data.into_iter().collect::<Result<Vec<_>, _>>()\n+    }\n+\n+    fn program_clauses_data<'a>(\n+        &self,\n+        clauses: &'a Self::InternedProgramClauses,\n+    ) -> &'a [chalk_ir::ProgramClause<Self>] {\n+        clauses\n+    }\n+\n+    fn intern_quantified_where_clauses<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::QuantifiedWhereClause<Self>, E>>,\n+    ) -> Result<Self::InternedQuantifiedWhereClauses, E> {\n+        data.into_iter().collect::<Result<Vec<_>, _>>()\n+    }\n+\n+    fn quantified_where_clauses_data<'a>(\n+        &self,\n+        clauses: &'a Self::InternedQuantifiedWhereClauses,\n+    ) -> &'a [chalk_ir::QuantifiedWhereClause<Self>] {\n+        clauses\n+    }\n+\n+    fn intern_parameter_kinds<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::ParameterKind<()>, E>>,\n+    ) -> Result<Self::InternedParameterKinds, E> {\n+        data.into_iter().collect::<Result<Vec<_>, _>>()\n+    }\n+\n+    fn parameter_kinds_data<'a>(\n+        &self,\n+        parameter_kinds: &'a Self::InternedParameterKinds,\n+    ) -> &'a [chalk_ir::ParameterKind<()>] {\n+        parameter_kinds\n+    }\n+\n+    fn intern_canonical_var_kinds<E>(\n+        &self,\n+        data: impl IntoIterator<Item = Result<chalk_ir::ParameterKind<chalk_ir::UniverseIndex>, E>>,\n+    ) -> Result<Self::InternedCanonicalVarKinds, E> {\n+        data.into_iter().collect::<Result<Vec<_>, _>>()\n+    }\n+\n+    fn canonical_var_kinds_data<'a>(\n+        &self,\n+        canonical_var_kinds: &'a Self::InternedCanonicalVarKinds,\n+    ) -> &'a [chalk_ir::ParameterKind<chalk_ir::UniverseIndex>] {\n+        canonical_var_kinds\n+    }\n+}\n+\n+impl<'tcx> chalk_ir::interner::HasInterner for RustInterner<'tcx> {\n+    type Interner = Self;\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub enum ChalkEnvironmentClause<'tcx> {\n+    /// A normal rust `ty::Predicate` in the environment.\n+    Predicate(ty::Predicate<'tcx>),\n+    /// A special clause in the environment that gets lowered to\n+    /// `chalk_ir::FromEnv::Ty`.\n+    TypeFromEnv(Ty<'tcx>),\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ChalkEnvironmentClause<'tcx>> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n+        folder.tcx().intern_chalk_environment_clause_list(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+/// We have to elaborate the environment of a chalk goal *before*\n+/// canonicalization. This type wraps the predicate and the elaborated\n+/// environment.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub struct ChalkEnvironmentAndGoal<'tcx> {\n+    pub environment: &'tcx ty::List<ChalkEnvironmentClause<'tcx>>,\n+    pub goal: ty::Predicate<'tcx>,\n+}\n+\n+impl<'tcx> fmt::Display for ChalkEnvironmentAndGoal<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"environment: {:?}, goal: {}\", self.environment, self.goal)\n+    }\n+}"}, {"sha": "43a347fec2acec3e4c07fb00bccba1c0925d73d9", "filename": "src/librustc_middle/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fmod.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -2,11 +2,13 @@\n //!\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/resolution.html\n \n+mod chalk;\n pub mod query;\n pub mod select;\n pub mod specialization_graph;\n mod structural_impls;\n \n+use crate::infer::canonical::Canonical;\n use crate::mir::interpret::ErrorHandled;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtKind, Ty, TyCtxt};\n@@ -23,10 +25,17 @@ use std::rc::Rc;\n \n pub use self::select::{EvaluationCache, EvaluationResult, OverflowError, SelectionCache};\n \n+pub type ChalkCanonicalGoal<'tcx> = Canonical<'tcx, ChalkEnvironmentAndGoal<'tcx>>;\n+\n pub use self::ObligationCauseCode::*;\n pub use self::SelectionError::*;\n pub use self::Vtable::*;\n \n+pub use self::chalk::{\n+    ChalkEnvironmentAndGoal, ChalkEnvironmentClause, RustDefId as ChalkRustDefId,\n+    RustInterner as ChalkRustInterner,\n+};\n+\n /// Depending on the stage of compilation, we want projection to be\n /// more or less conservative.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, HashStable)]"}, {"sha": "fc68a347dfde55304b5df92917e131df97ca222f", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -93,6 +93,8 @@ pub struct CtxtInterners<'tcx> {\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n     const_: InternedSet<'tcx, Const<'tcx>>,\n+\n+    chalk_environment_clause_list: InternedSet<'tcx, List<traits::ChalkEnvironmentClause<'tcx>>>,\n }\n \n impl<'tcx> CtxtInterners<'tcx> {\n@@ -109,6 +111,8 @@ impl<'tcx> CtxtInterners<'tcx> {\n             projs: Default::default(),\n             place_elems: Default::default(),\n             const_: Default::default(),\n+\n+            chalk_environment_clause_list: Default::default(),\n         }\n     }\n \n@@ -1997,6 +2001,14 @@ impl<'tcx> Borrow<Const<'tcx>> for Interned<'tcx, Const<'tcx>> {\n     }\n }\n \n+impl<'tcx> Borrow<[traits::ChalkEnvironmentClause<'tcx>]>\n+    for Interned<'tcx, List<traits::ChalkEnvironmentClause<'tcx>>>\n+{\n+    fn borrow<'a>(&'a self) -> &'a [traits::ChalkEnvironmentClause<'tcx>] {\n+        &self.0[..]\n+    }\n+}\n+\n macro_rules! direct_interners {\n     ($($name:ident: $method:ident($ty:ty)),+) => {\n         $(impl<'tcx> PartialEq for Interned<'tcx, $ty> {\n@@ -2044,7 +2056,9 @@ slice_interners!(\n     existential_predicates: _intern_existential_predicates(ExistentialPredicate<'tcx>),\n     predicates: _intern_predicates(Predicate<'tcx>),\n     projs: _intern_projs(ProjectionKind),\n-    place_elems: _intern_place_elems(PlaceElem<'tcx>)\n+    place_elems: _intern_place_elems(PlaceElem<'tcx>),\n+    chalk_environment_clause_list:\n+        _intern_chalk_environment_clause_list(traits::ChalkEnvironmentClause<'tcx>)\n );\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -2430,6 +2444,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         if ts.is_empty() { List::empty() } else { self._intern_canonical_var_infos(ts) }\n     }\n \n+    pub fn intern_chalk_environment_clause_list(\n+        self,\n+        ts: &[traits::ChalkEnvironmentClause<'tcx>],\n+    ) -> &'tcx List<traits::ChalkEnvironmentClause<'tcx>> {\n+        if ts.is_empty() { List::empty() } else { self._intern_chalk_environment_clause_list(ts) }\n+    }\n+\n     pub fn mk_fn_sig<I>(\n         self,\n         inputs: I,\n@@ -2487,6 +2508,18 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_substs(iter::once(self_ty.into()).chain(rest.iter().cloned()))\n     }\n \n+    pub fn mk_chalk_environment_clause_list<\n+        I: InternAs<\n+            [traits::ChalkEnvironmentClause<'tcx>],\n+            &'tcx List<traits::ChalkEnvironmentClause<'tcx>>,\n+        >,\n+    >(\n+        self,\n+        iter: I,\n+    ) -> I::Output {\n+        iter.intern_with(|xs| self.intern_chalk_environment_clause_list(xs))\n+    }\n+\n     /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n     /// It stops at `bound` and just returns it if reached.\n     pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {"}, {"sha": "689fbf3b95a862a7d07e77be5360ad911a9103a4", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -768,6 +768,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"select which borrowck is used (`mir` or `migrate`) (default: `migrate`)\"),\n     borrowck_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather borrowck statistics (default: no)\"),\n+    chalk: bool = (false, parse_bool, [TRACKED],\n+        \"enable the experimental Chalk-based trait solving engine\"),\n     codegen_backend: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"the backend to use\"),\n     control_flow_guard: CFGuard = (CFGuard::Disabled, parse_cfguard, [UNTRACKED],"}, {"sha": "115e4a0e629695e13e241beb6ba0570043f93b15", "filename": "src/librustc_trait_selection/traits/chalk_fulfill.rs", "status": "added", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,262 @@\n+//! Defines a Chalk-based `TraitEngine`\n+\n+use crate::infer::canonical::OriginalQueryValues;\n+use crate::infer::InferCtxt;\n+use crate::traits::query::NoSolution;\n+use crate::traits::{\n+    ChalkEnvironmentAndGoal, ChalkEnvironmentClause, FulfillmentError, FulfillmentErrorCode,\n+    ObligationCause, PredicateObligation, SelectionError, TraitEngine,\n+};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+\n+pub struct FulfillmentContext<'tcx> {\n+    obligations: FxHashSet<PredicateObligation<'tcx>>,\n+}\n+\n+impl FulfillmentContext<'tcx> {\n+    crate fn new() -> Self {\n+        FulfillmentContext { obligations: FxHashSet::default() }\n+    }\n+}\n+\n+fn environment<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+) -> &'tcx ty::List<ChalkEnvironmentClause<'tcx>> {\n+    use rustc_hir::{ForeignItemKind, ImplItemKind, ItemKind, Node, TraitItemKind};\n+    use rustc_middle::ty::subst::GenericArgKind;\n+\n+    debug!(\"environment(def_id = {:?})\", def_id);\n+\n+    // The environment of an impl Trait type is its defining function's environment.\n+    if let Some(parent) = ty::is_impl_trait_defn(tcx, def_id) {\n+        return environment(tcx, parent);\n+    }\n+\n+    // Compute the bounds on `Self` and the type parameters.\n+    let ty::InstantiatedPredicates { predicates, .. } =\n+        tcx.predicates_of(def_id).instantiate_identity(tcx);\n+\n+    let clauses = predicates.into_iter().map(|pred| ChalkEnvironmentClause::Predicate(pred));\n+\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let node = tcx.hir().get(hir_id);\n+\n+    enum NodeKind {\n+        TraitImpl,\n+        InherentImpl,\n+        Fn,\n+        Other,\n+    };\n+\n+    let node_kind = match node {\n+        Node::TraitItem(item) => match item.kind {\n+            TraitItemKind::Fn(..) => NodeKind::Fn,\n+            _ => NodeKind::Other,\n+        },\n+\n+        Node::ImplItem(item) => match item.kind {\n+            ImplItemKind::Fn(..) => NodeKind::Fn,\n+            _ => NodeKind::Other,\n+        },\n+\n+        Node::Item(item) => match item.kind {\n+            ItemKind::Impl { of_trait: Some(_), .. } => NodeKind::TraitImpl,\n+            ItemKind::Impl { of_trait: None, .. } => NodeKind::InherentImpl,\n+            ItemKind::Fn(..) => NodeKind::Fn,\n+            _ => NodeKind::Other,\n+        },\n+\n+        Node::ForeignItem(item) => match item.kind {\n+            ForeignItemKind::Fn(..) => NodeKind::Fn,\n+            _ => NodeKind::Other,\n+        },\n+\n+        // FIXME: closures?\n+        _ => NodeKind::Other,\n+    };\n+\n+    // FIXME(eddyb) isn't the unordered nature of this a hazard?\n+    let mut inputs = FxHashSet::default();\n+\n+    match node_kind {\n+        // In a trait impl, we assume that the header trait ref and all its\n+        // constituents are well-formed.\n+        NodeKind::TraitImpl => {\n+            let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n+\n+            inputs.extend(trait_ref.substs.iter().flat_map(|&arg| arg.walk()));\n+        }\n+\n+        // In an inherent impl, we assume that the receiver type and all its\n+        // constituents are well-formed.\n+        NodeKind::InherentImpl => {\n+            let self_ty = tcx.type_of(def_id);\n+            inputs.extend(self_ty.walk());\n+        }\n+\n+        // In an fn, we assume that the arguments and all their constituents are\n+        // well-formed.\n+        NodeKind::Fn => {\n+            let fn_sig = tcx.fn_sig(def_id);\n+            let fn_sig = tcx.liberate_late_bound_regions(def_id, &fn_sig);\n+\n+            inputs.extend(fn_sig.inputs().iter().flat_map(|ty| ty.walk()));\n+        }\n+\n+        NodeKind::Other => (),\n+    }\n+    let input_clauses = inputs.into_iter().filter_map(|arg| {\n+        match arg.unpack() {\n+            GenericArgKind::Type(ty) => Some(ChalkEnvironmentClause::TypeFromEnv(ty)),\n+\n+            // FIXME(eddyb) no WF conditions from lifetimes?\n+            GenericArgKind::Lifetime(_) => None,\n+\n+            // FIXME(eddyb) support const generics in Chalk\n+            GenericArgKind::Const(_) => None,\n+        }\n+    });\n+\n+    tcx.mk_chalk_environment_clause_list(clauses.chain(input_clauses))\n+}\n+\n+/// We need to wrap a `ty::Predicate` in an elaborated environment *before* we\n+/// canonicalize. This is due to the fact that we insert extra clauses into the\n+/// environment for all input types (`FromEnv`).\n+fn in_environment(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    obligation: &PredicateObligation<'tcx>,\n+) -> ChalkEnvironmentAndGoal<'tcx> {\n+    assert!(!infcx.is_in_snapshot());\n+    let obligation = infcx.resolve_vars_if_possible(obligation);\n+\n+    let environment = match obligation.param_env.def_id {\n+        Some(def_id) => environment(infcx.tcx, def_id),\n+        None if obligation.param_env.caller_bounds.is_empty() => ty::List::empty(),\n+        _ => bug!(\"non-empty `ParamEnv` with no def-id\"),\n+    };\n+\n+    ChalkEnvironmentAndGoal { environment, goal: obligation.predicate }\n+}\n+\n+impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n+    fn normalize_projection_type(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        _param_env: ty::ParamEnv<'tcx>,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        _cause: ObligationCause<'tcx>,\n+    ) -> Ty<'tcx> {\n+        infcx.tcx.mk_ty(ty::Projection(projection_ty))\n+    }\n+\n+    fn register_predicate_obligation(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        obligation: PredicateObligation<'tcx>,\n+    ) {\n+        assert!(!infcx.is_in_snapshot());\n+        let obligation = infcx.resolve_vars_if_possible(&obligation);\n+\n+        self.obligations.insert(obligation);\n+    }\n+\n+    fn select_all_or_error(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n+        self.select_where_possible(infcx)?;\n+\n+        if self.obligations.is_empty() {\n+            Ok(())\n+        } else {\n+            let errors = self\n+                .obligations\n+                .iter()\n+                .map(|obligation| FulfillmentError {\n+                    obligation: obligation.clone(),\n+                    code: FulfillmentErrorCode::CodeAmbiguity,\n+                    points_at_arg_span: false,\n+                })\n+                .collect();\n+            Err(errors)\n+        }\n+    }\n+\n+    fn select_where_possible(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n+        let mut errors = Vec::new();\n+        let mut next_round = FxHashSet::default();\n+        let mut making_progress;\n+\n+        loop {\n+            making_progress = false;\n+\n+            // We iterate over all obligations, and record if we are able\n+            // to unambiguously prove at least one obligation.\n+            for obligation in self.obligations.drain() {\n+                let goal_in_environment = in_environment(infcx, &obligation);\n+                let mut orig_values = OriginalQueryValues::default();\n+                let canonical_goal =\n+                    infcx.canonicalize_query(&goal_in_environment, &mut orig_values);\n+\n+                match infcx.tcx.evaluate_goal(canonical_goal) {\n+                    Ok(response) => {\n+                        if response.is_proven() {\n+                            making_progress = true;\n+\n+                            match infcx.instantiate_query_response_and_region_obligations(\n+                                &obligation.cause,\n+                                obligation.param_env,\n+                                &orig_values,\n+                                &response,\n+                            ) {\n+                                Ok(infer_ok) => next_round.extend(\n+                                    infer_ok.obligations.into_iter().map(|obligation| {\n+                                        assert!(!infcx.is_in_snapshot());\n+                                        infcx.resolve_vars_if_possible(&obligation)\n+                                    }),\n+                                ),\n+\n+                                Err(_err) => errors.push(FulfillmentError {\n+                                    obligation: obligation,\n+                                    code: FulfillmentErrorCode::CodeSelectionError(\n+                                        SelectionError::Unimplemented,\n+                                    ),\n+                                    points_at_arg_span: false,\n+                                }),\n+                            }\n+                        } else {\n+                            // Ambiguous: retry at next round.\n+                            next_round.insert(obligation);\n+                        }\n+                    }\n+\n+                    Err(NoSolution) => errors.push(FulfillmentError {\n+                        obligation: obligation,\n+                        code: FulfillmentErrorCode::CodeSelectionError(\n+                            SelectionError::Unimplemented,\n+                        ),\n+                        points_at_arg_span: false,\n+                    }),\n+                }\n+            }\n+            next_round = std::mem::replace(&mut self.obligations, next_round);\n+\n+            if !making_progress {\n+                break;\n+            }\n+        }\n+\n+        if errors.is_empty() { Ok(()) } else { Err(errors) }\n+    }\n+\n+    fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n+        self.obligations.iter().map(|obligation| obligation.clone()).collect()\n+    }\n+}"}, {"sha": "4d4778869794b9bab6bd09157c4316a24d1bc0b7", "filename": "src/librustc_trait_selection/traits/engine.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_trait_selection%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_trait_selection%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fengine.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -1,14 +1,18 @@\n use rustc_middle::ty::TyCtxt;\n \n-use super::FulfillmentContext;\n use super::TraitEngine;\n+use super::{ChalkFulfillmentContext, FulfillmentContext};\n \n pub trait TraitEngineExt<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> Box<Self>;\n }\n \n impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n-    fn new(_tcx: TyCtxt<'tcx>) -> Box<Self> {\n-        Box::new(FulfillmentContext::new())\n+    fn new(tcx: TyCtxt<'tcx>) -> Box<Self> {\n+        if tcx.sess.opts.debugging_opts.chalk {\n+            Box::new(ChalkFulfillmentContext::new())\n+        } else {\n+            Box::new(FulfillmentContext::new())\n+        }\n     }\n }"}, {"sha": "cf333b4dfe994dc4cc7422518ab54d437305a671", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -570,12 +570,21 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     }\n \n                     ty::Predicate::WellFormed(ty) => {\n-                        // WF predicates cannot themselves make\n-                        // errors. They can only block due to\n-                        // ambiguity; otherwise, they always\n-                        // degenerate into other obligations\n-                        // (which may fail).\n-                        span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                        if !self.tcx.sess.opts.debugging_opts.chalk {\n+                            // WF predicates cannot themselves make\n+                            // errors. They can only block due to\n+                            // ambiguity; otherwise, they always\n+                            // degenerate into other obligations\n+                            // (which may fail).\n+                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                        } else {\n+                            // FIXME: we'll need a better message which takes into account\n+                            // which bounds actually failed to hold.\n+                            self.tcx.sess.struct_span_err(\n+                                span,\n+                                &format!(\"the type `{}` is not well-formed (chalk)\", ty),\n+                            )\n+                        }\n                     }\n \n                     ty::Predicate::ConstEvaluatable(..) => {"}, {"sha": "778430fc2ca9cba87be0366571e2cffb583a261a", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -4,6 +4,7 @@\n \n #[allow(dead_code)]\n pub mod auto_trait;\n+mod chalk_fulfill;\n pub mod codegen;\n mod coherence;\n mod engine;\n@@ -69,6 +70,8 @@ pub use self::util::{\n     supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,\n };\n \n+pub use self::chalk_fulfill::FulfillmentContext as ChalkFulfillmentContext;\n+\n pub use rustc_infer::traits::*;\n \n /// Whether to skip the leak check, as part of a future compatibility warning step."}, {"sha": "b595f77e4d6f2404cd13b88b788f61df19c097cc", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -2877,11 +2877,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             trait_ref,\n         )?);\n \n-        obligations.push(Obligation::new(\n-            obligation.cause.clone(),\n-            obligation.param_env,\n-            ty::Predicate::ClosureKind(closure_def_id, substs, kind),\n-        ));\n+        // FIXME: Chalk\n+\n+        if !self.tcx().sess.opts.debugging_opts.chalk {\n+            obligations.push(Obligation::new(\n+                obligation.cause.clone(),\n+                obligation.param_env,\n+                ty::Predicate::ClosureKind(closure_def_id, substs, kind),\n+            ));\n+        }\n \n         Ok(VtableClosureData { closure_def_id, substs, nested: obligations })\n     }"}, {"sha": "e485bc2929bdb9feee7287acb626c05703cf048c", "filename": "src/librustc_traits/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -13,8 +13,12 @@ log = { version = \"0.4\" }\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_index = { path = \"../librustc_index\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n+chalk-ir = \"0.10.0\"\n+chalk-rust-ir = \"0.10.0\"\n+chalk-solve = \"0.10.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_infer = { path = \"../librustc_infer\" }\n rustc_trait_selection = { path = \"../librustc_trait_selection\" }"}, {"sha": "0cec583bb566e0e79e4a33316e0d59682a58335d", "filename": "src/librustc_traits/chalk/db.rs", "status": "added", "additions": 521, "deletions": 0, "changes": 521, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_traits%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_traits%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Fdb.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,521 @@\n+//! Provides the `RustIrDatabase` implementation for `chalk-solve`\n+//!\n+//! The purpose of the `chalk_solve::RustIrDatabase` is to get data about\n+//! specific types, such as bounds, where clauses, or fields. This file contains\n+//! the minimal logic to assemble the types for `chalk-solve` by calling out to\n+//! either the `TyCtxt` (for information about types) or\n+//! `crate::chalk::lowering` (to lower rustc types into Chalk types).\n+\n+use rustc_middle::traits::{ChalkRustDefId as RustDefId, ChalkRustInterner as RustInterner};\n+use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n+use rustc_middle::ty::{self, AssocItemContainer, AssocKind, TyCtxt};\n+\n+use rustc_hir::def_id::DefId;\n+\n+use rustc_span::symbol::sym;\n+\n+use std::fmt;\n+use std::sync::Arc;\n+\n+use crate::chalk::lowering::LowerInto;\n+\n+pub struct RustIrDatabase<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+    pub interner: RustInterner<'tcx>,\n+}\n+\n+impl fmt::Debug for RustIrDatabase<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"RustIrDatabase\")\n+    }\n+}\n+\n+impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'tcx> {\n+    fn interner(&self) -> &RustInterner<'tcx> {\n+        &self.interner\n+    }\n+\n+    fn associated_ty_data(\n+        &self,\n+        assoc_type_id: chalk_ir::AssocTypeId<RustInterner<'tcx>>,\n+    ) -> Arc<chalk_rust_ir::AssociatedTyDatum<RustInterner<'tcx>>> {\n+        let def_id = match assoc_type_id.0 {\n+            RustDefId::AssocTy(def_id) => def_id,\n+            _ => bug!(\"Did not use `AssocTy` variant when expecting associated type.\"),\n+        };\n+        let assoc_item = self.tcx.associated_item(def_id);\n+        let trait_def_id = match assoc_item.container {\n+            AssocItemContainer::TraitContainer(def_id) => def_id,\n+            _ => unimplemented!(\"Not possible??\"),\n+        };\n+        match assoc_item.kind {\n+            AssocKind::Type => {}\n+            _ => unimplemented!(\"Not possible??\"),\n+        }\n+        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let binders = binders_for(&self.interner, bound_vars);\n+        // FIXME(chalk): this really isn't right I don't think. The functions\n+        // for GATs are a bit hard to figure out. Are these supposed to be where\n+        // clauses or bounds?\n+        let predicates = self.tcx.predicates_defined_on(def_id).predicates;\n+        let where_clauses: Vec<_> = predicates\n+            .into_iter()\n+            .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n+            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+\n+        Arc::new(chalk_rust_ir::AssociatedTyDatum {\n+            trait_id: chalk_ir::TraitId(RustDefId::Trait(trait_def_id)),\n+            id: assoc_type_id,\n+            name: (),\n+            binders: chalk_ir::Binders::new(\n+                binders,\n+                chalk_rust_ir::AssociatedTyDatumBound { bounds: vec![], where_clauses },\n+            ),\n+        })\n+    }\n+\n+    fn trait_datum(\n+        &self,\n+        trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n+    ) -> Arc<chalk_rust_ir::TraitDatum<RustInterner<'tcx>>> {\n+        let def_id = match trait_id.0 {\n+            RustDefId::Trait(def_id) => def_id,\n+            _ => bug!(\"Did not use `Trait` variant when expecting trait.\"),\n+        };\n+        let trait_def = self.tcx.trait_def(def_id);\n+\n+        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let binders = binders_for(&self.interner, bound_vars);\n+        let predicates = self.tcx.predicates_defined_on(def_id).predicates;\n+        let where_clauses: Vec<_> = predicates\n+            .into_iter()\n+            .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n+            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+\n+        let well_known =\n+            if self.tcx.lang_items().sized_trait().map(|t| def_id == t).unwrap_or(false) {\n+                Some(chalk_rust_ir::WellKnownTrait::SizedTrait)\n+            } else if self.tcx.lang_items().copy_trait().map(|t| def_id == t).unwrap_or(false) {\n+                Some(chalk_rust_ir::WellKnownTrait::CopyTrait)\n+            } else if self.tcx.lang_items().clone_trait().map(|t| def_id == t).unwrap_or(false) {\n+                Some(chalk_rust_ir::WellKnownTrait::CloneTrait)\n+            } else {\n+                None\n+            };\n+        Arc::new(chalk_rust_ir::TraitDatum {\n+            id: trait_id,\n+            binders: chalk_ir::Binders::new(\n+                binders,\n+                chalk_rust_ir::TraitDatumBound { where_clauses },\n+            ),\n+            flags: chalk_rust_ir::TraitFlags {\n+                auto: trait_def.has_auto_impl,\n+                marker: trait_def.is_marker,\n+                upstream: !def_id.is_local(),\n+                fundamental: self.tcx.has_attr(def_id, sym::fundamental),\n+                non_enumerable: true,\n+                coinductive: false,\n+            },\n+            associated_ty_ids: vec![],\n+            well_known,\n+        })\n+    }\n+\n+    fn struct_datum(\n+        &self,\n+        struct_id: chalk_ir::StructId<RustInterner<'tcx>>,\n+    ) -> Arc<chalk_rust_ir::StructDatum<RustInterner<'tcx>>> {\n+        match struct_id.0 {\n+            RustDefId::Adt(adt_def_id) => {\n+                let adt_def = self.tcx.adt_def(adt_def_id);\n+\n+                let bound_vars = bound_vars_for_item(self.tcx, adt_def_id);\n+                let binders = binders_for(&self.interner, bound_vars);\n+\n+                let predicates = self.tcx.predicates_of(adt_def_id).predicates;\n+                let where_clauses: Vec<_> = predicates\n+                    .into_iter()\n+                    .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n+                    .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner))\n+                    .collect();\n+                let fields = match adt_def.adt_kind() {\n+                    ty::AdtKind::Struct | ty::AdtKind::Union => {\n+                        let variant = adt_def.non_enum_variant();\n+                        variant\n+                            .fields\n+                            .iter()\n+                            .map(|field| {\n+                                self.tcx\n+                                    .type_of(field.did)\n+                                    .subst(self.tcx, bound_vars)\n+                                    .lower_into(&self.interner)\n+                            })\n+                            .collect()\n+                    }\n+                    // FIXME(chalk): handle enums; force_impl_for requires this\n+                    ty::AdtKind::Enum => vec![],\n+                };\n+                let struct_datum = Arc::new(chalk_rust_ir::StructDatum {\n+                    id: struct_id,\n+                    binders: chalk_ir::Binders::new(\n+                        binders,\n+                        chalk_rust_ir::StructDatumBound { fields, where_clauses },\n+                    ),\n+                    flags: chalk_rust_ir::StructFlags {\n+                        upstream: !adt_def_id.is_local(),\n+                        fundamental: adt_def.is_fundamental(),\n+                    },\n+                });\n+                return struct_datum;\n+            }\n+            RustDefId::Ref(_) => {\n+                return Arc::new(chalk_rust_ir::StructDatum {\n+                    id: struct_id,\n+                    binders: chalk_ir::Binders::new(\n+                        chalk_ir::ParameterKinds::from(\n+                            &self.interner,\n+                            vec![\n+                                chalk_ir::ParameterKind::Lifetime(()),\n+                                chalk_ir::ParameterKind::Ty(()),\n+                            ],\n+                        ),\n+                        chalk_rust_ir::StructDatumBound { fields: vec![], where_clauses: vec![] },\n+                    ),\n+                    flags: chalk_rust_ir::StructFlags { upstream: false, fundamental: false },\n+                });\n+            }\n+            RustDefId::Array | RustDefId::Slice => {\n+                return Arc::new(chalk_rust_ir::StructDatum {\n+                    id: struct_id,\n+                    binders: chalk_ir::Binders::new(\n+                        chalk_ir::ParameterKinds::from(\n+                            &self.interner,\n+                            Some(chalk_ir::ParameterKind::Ty(())),\n+                        ),\n+                        chalk_rust_ir::StructDatumBound { fields: vec![], where_clauses: vec![] },\n+                    ),\n+                    flags: chalk_rust_ir::StructFlags { upstream: false, fundamental: false },\n+                });\n+            }\n+            RustDefId::Str | RustDefId::Never | RustDefId::FnDef(_) => {\n+                return Arc::new(chalk_rust_ir::StructDatum {\n+                    id: struct_id,\n+                    binders: chalk_ir::Binders::new(\n+                        chalk_ir::ParameterKinds::new(&self.interner),\n+                        chalk_rust_ir::StructDatumBound { fields: vec![], where_clauses: vec![] },\n+                    ),\n+                    flags: chalk_rust_ir::StructFlags { upstream: false, fundamental: false },\n+                });\n+            }\n+\n+            _ => bug!(\"Used not struct variant when expecting struct variant.\"),\n+        }\n+    }\n+\n+    fn impl_datum(\n+        &self,\n+        impl_id: chalk_ir::ImplId<RustInterner<'tcx>>,\n+    ) -> Arc<chalk_rust_ir::ImplDatum<RustInterner<'tcx>>> {\n+        let def_id = match impl_id.0 {\n+            RustDefId::Impl(def_id) => def_id,\n+            _ => bug!(\"Did not use `Impl` variant when expecting impl.\"),\n+        };\n+        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let binders = binders_for(&self.interner, bound_vars);\n+\n+        let trait_ref = self.tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n+        let trait_ref = trait_ref.subst(self.tcx, bound_vars);\n+\n+        let predicates = self.tcx.predicates_of(def_id).predicates;\n+        let where_clauses: Vec<_> = predicates\n+            .into_iter()\n+            .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n+            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+\n+        let value = chalk_rust_ir::ImplDatumBound {\n+            trait_ref: trait_ref.lower_into(&self.interner),\n+            where_clauses,\n+        };\n+\n+        Arc::new(chalk_rust_ir::ImplDatum {\n+            polarity: chalk_rust_ir::Polarity::Positive,\n+            binders: chalk_ir::Binders::new(binders, value),\n+            impl_type: chalk_rust_ir::ImplType::Local,\n+            associated_ty_value_ids: vec![],\n+        })\n+    }\n+\n+    fn impls_for_trait(\n+        &self,\n+        trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n+        parameters: &[chalk_ir::Parameter<RustInterner<'tcx>>],\n+    ) -> Vec<chalk_ir::ImplId<RustInterner<'tcx>>> {\n+        let def_id: DefId = match trait_id.0 {\n+            RustDefId::Trait(def_id) => def_id,\n+            _ => bug!(\"Did not use `Trait` variant when expecting trait.\"),\n+        };\n+\n+        // FIXME(chalk): use TraitDef::for_each_relevant_impl, but that will\n+        // require us to be able to interconvert `Ty<'tcx>`, and we're\n+        // not there yet.\n+\n+        let all_impls = self.tcx.all_impls(def_id);\n+        let matched_impls = all_impls.into_iter().filter(|impl_def_id| {\n+            use chalk_ir::could_match::CouldMatch;\n+            let trait_ref = self.tcx.impl_trait_ref(*impl_def_id).unwrap();\n+            let bound_vars = bound_vars_for_item(self.tcx, *impl_def_id);\n+\n+            let self_ty = trait_ref.self_ty();\n+            let self_ty = self_ty.subst(self.tcx, bound_vars);\n+            let lowered_ty = self_ty.lower_into(&self.interner);\n+\n+            parameters[0].assert_ty_ref(&self.interner).could_match(&self.interner, &lowered_ty)\n+        });\n+\n+        let impls = matched_impls\n+            .map(|matched_impl| chalk_ir::ImplId(RustDefId::Impl(matched_impl)))\n+            .collect();\n+        impls\n+    }\n+\n+    fn impl_provided_for(\n+        &self,\n+        auto_trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n+        struct_id: chalk_ir::StructId<RustInterner<'tcx>>,\n+    ) -> bool {\n+        let trait_def_id: DefId = match auto_trait_id.0 {\n+            RustDefId::Trait(def_id) => def_id,\n+            _ => bug!(\"Did not use `Trait` variant when expecting trait.\"),\n+        };\n+        let adt_def_id: DefId = match struct_id.0 {\n+            RustDefId::Adt(def_id) => def_id,\n+            _ => bug!(\"Did not use `Adt` variant when expecting adt.\"),\n+        };\n+        let all_impls = self.tcx.all_impls(trait_def_id);\n+        for impl_def_id in all_impls {\n+            let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n+            let self_ty = trait_ref.self_ty();\n+            match self_ty.kind {\n+                ty::Adt(adt_def, _) => {\n+                    if adt_def.did == adt_def_id {\n+                        return true;\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        return false;\n+    }\n+\n+    fn associated_ty_value(\n+        &self,\n+        associated_ty_id: chalk_rust_ir::AssociatedTyValueId<RustInterner<'tcx>>,\n+    ) -> Arc<chalk_rust_ir::AssociatedTyValue<RustInterner<'tcx>>> {\n+        let def_id = match associated_ty_id.0 {\n+            RustDefId::AssocTy(def_id) => def_id,\n+            _ => bug!(\"Did not use `AssocTy` variant when expecting associated type.\"),\n+        };\n+        let assoc_item = self.tcx.associated_item(def_id);\n+        let impl_id = match assoc_item.container {\n+            AssocItemContainer::TraitContainer(def_id) => def_id,\n+            _ => unimplemented!(\"Not possible??\"),\n+        };\n+        match assoc_item.kind {\n+            AssocKind::Type => {}\n+            _ => unimplemented!(\"Not possible??\"),\n+        }\n+        let bound_vars = bound_vars_for_item(self.tcx, def_id);\n+        let binders = binders_for(&self.interner, bound_vars);\n+        let ty = self.tcx.type_of(def_id);\n+\n+        Arc::new(chalk_rust_ir::AssociatedTyValue {\n+            impl_id: chalk_ir::ImplId(RustDefId::Impl(impl_id)),\n+            associated_ty_id: chalk_ir::AssocTypeId(RustDefId::AssocTy(def_id)),\n+            value: chalk_ir::Binders::new(\n+                binders,\n+                chalk_rust_ir::AssociatedTyValueBound { ty: ty.lower_into(&self.interner) },\n+            ),\n+        })\n+    }\n+\n+    fn custom_clauses(&self) -> Vec<chalk_ir::ProgramClause<RustInterner<'tcx>>> {\n+        vec![]\n+    }\n+\n+    fn local_impls_to_coherence_check(\n+        &self,\n+        _trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n+    ) -> Vec<chalk_ir::ImplId<RustInterner<'tcx>>> {\n+        unimplemented!()\n+    }\n+\n+    fn opaque_ty_data(\n+        &self,\n+        _id: chalk_ir::OpaqueTyId<RustInterner<'tcx>>,\n+    ) -> Arc<chalk_rust_ir::OpaqueTyDatum<RustInterner<'tcx>>> {\n+        unimplemented!()\n+    }\n+\n+    /// Since Chalk can't handle all Rust types currently, we have to handle\n+    /// some specially for now. Over time, these `Some` returns will change to\n+    /// `None` and eventually this function will be removed.\n+    fn force_impl_for(\n+        &self,\n+        well_known: chalk_rust_ir::WellKnownTrait,\n+        ty: &chalk_ir::TyData<RustInterner<'tcx>>,\n+    ) -> Option<bool> {\n+        use chalk_ir::TyData::*;\n+        match well_known {\n+            chalk_rust_ir::WellKnownTrait::SizedTrait => match ty {\n+                Apply(apply) => match apply.name {\n+                    chalk_ir::TypeName::Struct(chalk_ir::StructId(rust_def_id)) => {\n+                        use rustc_middle::traits::ChalkRustDefId::*;\n+                        match rust_def_id {\n+                            Never | Array | RawPtr | FnDef(_) | Ref(_) => Some(true),\n+\n+                            Adt(adt_def_id) => {\n+                                let adt_def = self.tcx.adt_def(adt_def_id);\n+                                match adt_def.adt_kind() {\n+                                    ty::AdtKind::Struct | ty::AdtKind::Union => None,\n+                                    ty::AdtKind::Enum => {\n+                                        let constraint = self.tcx.adt_sized_constraint(adt_def_id);\n+                                        if constraint.0.len() > 0 {\n+                                            unimplemented!()\n+                                        } else {\n+                                            Some(true)\n+                                        }\n+                                    }\n+                                }\n+                            }\n+\n+                            Str | Slice => Some(false),\n+\n+                            Trait(_) | Impl(_) | AssocTy(_) => panic!(),\n+                        }\n+                    }\n+                    _ => None,\n+                },\n+                Dyn(_) | Alias(_) | Placeholder(_) | Function(_) | InferenceVar(_)\n+                | BoundVar(_) => None,\n+            },\n+            chalk_rust_ir::WellKnownTrait::CopyTrait\n+            | chalk_rust_ir::WellKnownTrait::CloneTrait => match ty {\n+                Apply(apply) => match apply.name {\n+                    chalk_ir::TypeName::Struct(chalk_ir::StructId(rust_def_id)) => {\n+                        use rustc_middle::traits::ChalkRustDefId::*;\n+                        match rust_def_id {\n+                            Never | RawPtr | Ref(_) | Str | Slice => Some(false),\n+                            FnDef(_) | Array => Some(true),\n+                            Adt(adt_def_id) => {\n+                                let adt_def = self.tcx.adt_def(adt_def_id);\n+                                match adt_def.adt_kind() {\n+                                    ty::AdtKind::Struct | ty::AdtKind::Union => None,\n+                                    ty::AdtKind::Enum => {\n+                                        let constraint = self.tcx.adt_sized_constraint(adt_def_id);\n+                                        if constraint.0.len() > 0 {\n+                                            unimplemented!()\n+                                        } else {\n+                                            Some(true)\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                            Trait(_) | Impl(_) | AssocTy(_) => panic!(),\n+                        }\n+                    }\n+                    _ => None,\n+                },\n+                Dyn(_) | Alias(_) | Placeholder(_) | Function(_) | InferenceVar(_)\n+                | BoundVar(_) => None,\n+            },\n+            chalk_rust_ir::WellKnownTrait::DropTrait => None,\n+        }\n+    }\n+\n+    fn program_clauses_for_env(\n+        &self,\n+        environment: &chalk_ir::Environment<RustInterner<'tcx>>,\n+    ) -> chalk_ir::ProgramClauses<RustInterner<'tcx>> {\n+        chalk_solve::program_clauses_for_env(self, environment)\n+    }\n+\n+    fn well_known_trait_id(\n+        &self,\n+        well_known_trait: chalk_rust_ir::WellKnownTrait,\n+    ) -> Option<chalk_ir::TraitId<RustInterner<'tcx>>> {\n+        use chalk_rust_ir::WellKnownTrait::*;\n+        let t = match well_known_trait {\n+            SizedTrait => self\n+                .tcx\n+                .lang_items()\n+                .sized_trait()\n+                .map(|t| chalk_ir::TraitId(RustDefId::Trait(t)))\n+                .unwrap(),\n+            CopyTrait => self\n+                .tcx\n+                .lang_items()\n+                .copy_trait()\n+                .map(|t| chalk_ir::TraitId(RustDefId::Trait(t)))\n+                .unwrap(),\n+            CloneTrait => self\n+                .tcx\n+                .lang_items()\n+                .clone_trait()\n+                .map(|t| chalk_ir::TraitId(RustDefId::Trait(t)))\n+                .unwrap(),\n+            DropTrait => self\n+                .tcx\n+                .lang_items()\n+                .drop_trait()\n+                .map(|t| chalk_ir::TraitId(RustDefId::Trait(t)))\n+                .unwrap(),\n+        };\n+        Some(t)\n+    }\n+}\n+\n+/// Creates a `InternalSubsts` that maps each generic parameter to a higher-ranked\n+/// var bound at index `0`. For types, we use a `BoundVar` index equal to\n+/// the type parameter index. For regions, we use the `BoundRegion::BrNamed`\n+/// variant (which has a `DefId`).\n+fn bound_vars_for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n+    InternalSubsts::for_item(tcx, def_id, |param, substs| match param.kind {\n+        ty::GenericParamDefKind::Type { .. } => tcx\n+            .mk_ty(ty::Bound(\n+                ty::INNERMOST,\n+                ty::BoundTy {\n+                    var: ty::BoundVar::from(param.index),\n+                    kind: ty::BoundTyKind::Param(param.name),\n+                },\n+            ))\n+            .into(),\n+\n+        ty::GenericParamDefKind::Lifetime => tcx\n+            .mk_region(ty::RegionKind::ReLateBound(\n+                ty::INNERMOST,\n+                ty::BoundRegion::BrAnon(substs.len() as u32),\n+            ))\n+            .into(),\n+\n+        ty::GenericParamDefKind::Const => tcx\n+            .mk_const(ty::Const {\n+                val: ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from(param.index)),\n+                ty: tcx.type_of(param.def_id),\n+            })\n+            .into(),\n+    })\n+}\n+\n+fn binders_for<'tcx>(\n+    interner: &RustInterner<'tcx>,\n+    bound_vars: SubstsRef<'tcx>,\n+) -> chalk_ir::ParameterKinds<RustInterner<'tcx>> {\n+    chalk_ir::ParameterKinds::from(\n+        interner,\n+        bound_vars.iter().map(|arg| match arg.unpack() {\n+            ty::subst::GenericArgKind::Lifetime(_re) => chalk_ir::ParameterKind::Lifetime(()),\n+            ty::subst::GenericArgKind::Type(_ty) => chalk_ir::ParameterKind::Ty(()),\n+            ty::subst::GenericArgKind::Const(_const) => chalk_ir::ParameterKind::Ty(()),\n+        }),\n+    )\n+}"}, {"sha": "70aba31a2d30012d421f091907b1a4b10faa6b46", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "added", "additions": 722, "deletions": 0, "changes": 722, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,722 @@\n+//! Contains the logic to lower rustc types into Chalk types\n+//!\n+//! In many there is a 1:1 relationship between a rustc type and a Chalk type.\n+//! For example, a `SubstsRef` maps almost directly to a `Substitution`. In some\n+//! other cases, such as `Param`s, there is no Chalk type, so we have to handle\n+//! accordingly.\n+//!\n+//! ## `Ty` lowering\n+//! Much of the `Ty` lowering is 1:1 with Chalk. (Or will be eventually). A\n+//! helpful table for what types lower to what can be found in the\n+//! [Chalk book](http://rust-lang.github.io/chalk/book/types/rust_types.html).\n+//! The most notable difference lies with `Param`s. To convert from rustc to\n+//! Chalk, we eagerly and deeply convert `Param`s to placeholders (in goals) or\n+//! bound variables (for clause generation through functions in `db`).\n+//!\n+//! ## `Region` lowering\n+//! Regions are handled in rustc and Chalk is quite differently. In rustc, there\n+//! is a difference between \"early bound\" and \"late bound\" regions, where only\n+//! the late bound regions have a `DebruijnIndex`. Moreover, in Chalk all\n+//! regions (Lifetimes) have an associated index. In rustc, only `BrAnon`s have\n+//! an index, whereas `BrNamed` don't. In order to lower regions to Chalk, we\n+//! convert all regions into `BrAnon` late-bound regions.\n+//!\n+//! ## `Const` lowering\n+//! Chalk doesn't handle consts currently, so consts are currently lowered to\n+//! an empty tuple.\n+//!\n+//! ## Bound variable collection\n+//! Another difference between rustc and Chalk lies in the handling of binders.\n+//! Chalk requires that we store the bound parameter kinds, whereas rustc does\n+//! not. To lower anything wrapped in a `Binder`, we first deeply find any bound\n+//! variables from the current `Binder`.\n+\n+use rustc_middle::traits::{\n+    ChalkEnvironmentAndGoal, ChalkEnvironmentClause, ChalkRustDefId as RustDefId,\n+    ChalkRustInterner as RustInterner,\n+};\n+use rustc_middle::ty::fold::TypeFolder;\n+use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n+use rustc_middle::ty::{\n+    self, Binder, BoundRegion, Predicate, Region, RegionKind, Ty, TyCtxt, TyKind, TypeFoldable,\n+    TypeVisitor,\n+};\n+use rustc_span::def_id::DefId;\n+\n+use std::collections::btree_map::{BTreeMap, Entry};\n+\n+/// Essentially an `Into` with a `&RustInterner` parameter\n+crate trait LowerInto<'tcx, T> {\n+    /// Lower a rustc construct (e.g., `ty::TraitPredicate`) to a chalk type, consuming `self`.\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> T;\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::Substitution<RustInterner<'tcx>>> for SubstsRef<'tcx> {\n+    fn lower_into(\n+        self,\n+        interner: &RustInterner<'tcx>,\n+    ) -> chalk_ir::Substitution<RustInterner<'tcx>> {\n+        chalk_ir::Substitution::from(interner, self.iter().map(|s| s.lower_into(interner)))\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::AliasTy<RustInterner<'tcx>>> for ty::ProjectionTy<'tcx> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::AliasTy<RustInterner<'tcx>> {\n+        chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n+            associated_ty_id: chalk_ir::AssocTypeId(RustDefId::AssocTy(self.item_def_id)),\n+            substitution: self.substs.lower_into(interner),\n+        })\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'tcx>>>>\n+    for ChalkEnvironmentAndGoal<'tcx>\n+{\n+    fn lower_into(\n+        self,\n+        interner: &RustInterner<'tcx>,\n+    ) -> chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'tcx>>> {\n+        let clauses = self.environment.into_iter().filter_map(|clause| match clause {\n+            ChalkEnvironmentClause::Predicate(predicate) => {\n+                match predicate {\n+                    ty::Predicate::Trait(predicate, _) => {\n+                        let (predicate, binders, _named_regions) =\n+                            collect_bound_vars(interner, interner.tcx, predicate);\n+\n+                        Some(\n+                            chalk_ir::ProgramClauseData::ForAll(chalk_ir::Binders::new(\n+                                binders,\n+                                chalk_ir::ProgramClauseImplication {\n+                                    consequence: chalk_ir::DomainGoal::FromEnv(\n+                                        chalk_ir::FromEnv::Trait(\n+                                            predicate.trait_ref.lower_into(interner),\n+                                        ),\n+                                    ),\n+                                    conditions: chalk_ir::Goals::new(interner),\n+                                    priority: chalk_ir::ClausePriority::High,\n+                                },\n+                            ))\n+                            .intern(interner),\n+                        )\n+                    }\n+                    // FIXME(chalk): need to add RegionOutlives/TypeOutlives\n+                    ty::Predicate::RegionOutlives(_) => None,\n+                    ty::Predicate::TypeOutlives(_) => None,\n+                    ty::Predicate::Projection(predicate) => {\n+                        let (predicate, binders, _named_regions) =\n+                            collect_bound_vars(interner, interner.tcx, predicate);\n+\n+                        Some(\n+                            chalk_ir::ProgramClauseData::ForAll(chalk_ir::Binders::new(\n+                                binders,\n+                                chalk_ir::ProgramClauseImplication {\n+                                    consequence: chalk_ir::DomainGoal::Holds(\n+                                        chalk_ir::WhereClause::AliasEq(\n+                                            predicate.lower_into(interner),\n+                                        ),\n+                                    ),\n+                                    conditions: chalk_ir::Goals::new(interner),\n+                                    priority: chalk_ir::ClausePriority::High,\n+                                },\n+                            ))\n+                            .intern(interner),\n+                        )\n+                    }\n+                    ty::Predicate::WellFormed(..)\n+                    | ty::Predicate::ObjectSafe(..)\n+                    | ty::Predicate::ClosureKind(..)\n+                    | ty::Predicate::Subtype(..)\n+                    | ty::Predicate::ConstEvaluatable(..) => {\n+                        bug!(\"unexpected predicate {}\", predicate)\n+                    }\n+                }\n+            }\n+            ChalkEnvironmentClause::TypeFromEnv(ty) => Some(\n+                chalk_ir::ProgramClauseData::Implies(chalk_ir::ProgramClauseImplication {\n+                    consequence: chalk_ir::DomainGoal::FromEnv(chalk_ir::FromEnv::Ty(\n+                        ty.lower_into(interner),\n+                    )),\n+                    conditions: chalk_ir::Goals::new(interner),\n+                    priority: chalk_ir::ClausePriority::High,\n+                })\n+                .intern(interner),\n+            ),\n+        });\n+\n+        let goal: chalk_ir::GoalData<RustInterner<'tcx>> = self.goal.lower_into(&interner);\n+        chalk_ir::InEnvironment {\n+            environment: chalk_ir::Environment {\n+                clauses: chalk_ir::ProgramClauses::from(&interner, clauses),\n+            },\n+            goal: goal.intern(&interner),\n+        }\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predicate<'tcx> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n+        match self {\n+            Predicate::Trait(predicate, _) => predicate.lower_into(interner),\n+            // FIXME(chalk): we need to register constraints.\n+            Predicate::RegionOutlives(_predicate) => {\n+                chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+            }\n+            Predicate::TypeOutlives(_predicate) => {\n+                chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+            }\n+            Predicate::Projection(predicate) => predicate.lower_into(interner),\n+            Predicate::WellFormed(ty) => match ty.kind {\n+                // These types are always WF.\n+                ty::Str | ty::Placeholder(..) | ty::Error | ty::Never => {\n+                    chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+                }\n+\n+                // FIXME(chalk): Well-formed only if ref lifetime outlives type\n+                ty::Ref(..) => chalk_ir::GoalData::All(chalk_ir::Goals::new(interner)),\n+\n+                ty::Param(..) => panic!(\"No Params expected.\"),\n+\n+                // FIXME(chalk) -- ultimately I think this is what we\n+                // want to do, and we just have rules for how to prove\n+                // `WellFormed` for everything above, instead of\n+                // inlining a bit the rules of the proof here.\n+                _ => chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::WellFormed(\n+                    chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n+                )),\n+            },\n+\n+            // FIXME(chalk): other predicates\n+            //\n+            // We can defer this, but ultimately we'll want to express\n+            // some of these in terms of chalk operations.\n+            Predicate::ObjectSafe(..)\n+            | Predicate::ClosureKind(..)\n+            | Predicate::Subtype(..)\n+            | Predicate::ConstEvaluatable(..) => {\n+                chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::TraitRef<RustInterner<'tcx>>>\n+    for rustc_middle::ty::TraitRef<'tcx>\n+{\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::TraitRef<RustInterner<'tcx>> {\n+        chalk_ir::TraitRef {\n+            trait_id: chalk_ir::TraitId(RustDefId::Trait(self.def_id)),\n+            substitution: self.substs.lower_into(interner),\n+        }\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>>\n+    for ty::PolyTraitPredicate<'tcx>\n+{\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n+        let (ty, binders, _named_regions) = collect_bound_vars(interner, interner.tcx, &self);\n+\n+        chalk_ir::GoalData::Quantified(\n+            chalk_ir::QuantifierKind::ForAll,\n+            chalk_ir::Binders::new(\n+                binders,\n+                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n+                    chalk_ir::WhereClause::Implemented(ty.trait_ref.lower_into(interner)),\n+                ))\n+                .intern(interner),\n+            ),\n+        )\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::AliasEq<RustInterner<'tcx>>>\n+    for rustc_middle::ty::ProjectionPredicate<'tcx>\n+{\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::AliasEq<RustInterner<'tcx>> {\n+        chalk_ir::AliasEq {\n+            ty: self.ty.lower_into(interner),\n+            alias: self.projection_ty.lower_into(interner),\n+        }\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>>\n+    for ty::PolyProjectionPredicate<'tcx>\n+{\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n+        let (ty, binders, _named_regions) = collect_bound_vars(interner, interner.tcx, &self);\n+\n+        chalk_ir::GoalData::Quantified(\n+            chalk_ir::QuantifierKind::ForAll,\n+            chalk_ir::Binders::new(\n+                binders,\n+                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n+                    chalk_ir::WhereClause::AliasEq(ty.lower_into(interner)),\n+                ))\n+                .intern(interner),\n+            ),\n+        )\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Ty<RustInterner<'tcx>> {\n+        use chalk_ir::TyData;\n+        use rustc_ast::ast;\n+        use TyKind::*;\n+\n+        let empty = || chalk_ir::Substitution::empty(interner);\n+        let struct_ty = |def_id| chalk_ir::TypeName::Struct(chalk_ir::StructId(def_id));\n+        let apply = |name, substitution| {\n+            TyData::Apply(chalk_ir::ApplicationTy { name, substitution }).intern(interner)\n+        };\n+        let int = |i| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Int(i)), empty());\n+        let uint = |i| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Uint(i)), empty());\n+        let float = |f| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Float(f)), empty());\n+\n+        return match self.kind {\n+            Bool => apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Bool), empty()),\n+            Char => apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Char), empty()),\n+            Int(ty) => match ty {\n+                ast::IntTy::Isize => int(chalk_ir::IntTy::Isize),\n+                ast::IntTy::I8 => int(chalk_ir::IntTy::I8),\n+                ast::IntTy::I16 => int(chalk_ir::IntTy::I16),\n+                ast::IntTy::I32 => int(chalk_ir::IntTy::I32),\n+                ast::IntTy::I64 => int(chalk_ir::IntTy::I64),\n+                ast::IntTy::I128 => int(chalk_ir::IntTy::I128),\n+            },\n+            Uint(ty) => match ty {\n+                ast::UintTy::Usize => uint(chalk_ir::UintTy::Usize),\n+                ast::UintTy::U8 => uint(chalk_ir::UintTy::U8),\n+                ast::UintTy::U16 => uint(chalk_ir::UintTy::U16),\n+                ast::UintTy::U32 => uint(chalk_ir::UintTy::U32),\n+                ast::UintTy::U64 => uint(chalk_ir::UintTy::U64),\n+                ast::UintTy::U128 => uint(chalk_ir::UintTy::U128),\n+            },\n+            Float(ty) => match ty {\n+                ast::FloatTy::F32 => float(chalk_ir::FloatTy::F32),\n+                ast::FloatTy::F64 => float(chalk_ir::FloatTy::F64),\n+            },\n+            Adt(def, substs) => {\n+                apply(struct_ty(RustDefId::Adt(def.did)), substs.lower_into(interner))\n+            }\n+            Foreign(_def_id) => unimplemented!(),\n+            Str => apply(struct_ty(RustDefId::Str), empty()),\n+            Array(ty, _) => apply(\n+                struct_ty(RustDefId::Array),\n+                chalk_ir::Substitution::from1(\n+                    interner,\n+                    chalk_ir::ParameterKind::Ty(ty.lower_into(interner)).intern(interner),\n+                ),\n+            ),\n+            Slice(ty) => apply(\n+                struct_ty(RustDefId::Slice),\n+                chalk_ir::Substitution::from1(\n+                    interner,\n+                    chalk_ir::ParameterKind::Ty(ty.lower_into(interner)).intern(interner),\n+                ),\n+            ),\n+            RawPtr(_) => apply(struct_ty(RustDefId::RawPtr), empty()),\n+            Ref(region, ty, mutability) => apply(\n+                struct_ty(RustDefId::Ref(mutability)),\n+                chalk_ir::Substitution::from(\n+                    interner,\n+                    [\n+                        chalk_ir::ParameterKind::Lifetime(region.lower_into(interner))\n+                            .intern(interner),\n+                        chalk_ir::ParameterKind::Ty(ty.lower_into(interner)).intern(interner),\n+                    ]\n+                    .iter(),\n+                ),\n+            ),\n+            FnDef(def_id, _) => apply(struct_ty(RustDefId::FnDef(def_id)), empty()),\n+            FnPtr(sig) => {\n+                let (inputs_and_outputs, binders, _named_regions) =\n+                    collect_bound_vars(interner, interner.tcx, &sig.inputs_and_output());\n+                TyData::Function(chalk_ir::Fn {\n+                    num_binders: binders.len(interner),\n+                    substitution: chalk_ir::Substitution::from(\n+                        interner,\n+                        inputs_and_outputs.iter().map(|ty| {\n+                            chalk_ir::ParameterKind::Ty(ty.lower_into(interner)).intern(interner)\n+                        }),\n+                    ),\n+                })\n+                .intern(interner)\n+            }\n+            Dynamic(_, _) => unimplemented!(),\n+            Closure(_def_id, _) => unimplemented!(),\n+            Generator(_def_id, _substs, _) => unimplemented!(),\n+            GeneratorWitness(_) => unimplemented!(),\n+            Never => apply(struct_ty(RustDefId::Never), empty()),\n+            Tuple(substs) => {\n+                apply(chalk_ir::TypeName::Tuple(substs.len()), substs.lower_into(interner))\n+            }\n+            Projection(proj) => TyData::Alias(proj.lower_into(interner)).intern(interner),\n+            UnnormalizedProjection(_proj) => unimplemented!(),\n+            Opaque(_def_id, _substs) => unimplemented!(),\n+            // This should have been done eagerly prior to this, and all Params\n+            // should have been substituted to placeholders\n+            Param(_) => panic!(\"Lowering Param when not expected.\"),\n+            Bound(db, bound) => TyData::BoundVar(chalk_ir::BoundVar::new(\n+                chalk_ir::DebruijnIndex::new(db.as_u32()),\n+                bound.var.index(),\n+            ))\n+            .intern(interner),\n+            Placeholder(_placeholder) => TyData::Placeholder(chalk_ir::PlaceholderIndex {\n+                ui: chalk_ir::UniverseIndex { counter: _placeholder.universe.as_usize() },\n+                idx: _placeholder.name.as_usize(),\n+            })\n+            .intern(interner),\n+            Infer(_infer) => unimplemented!(),\n+            Error => unimplemented!(),\n+        };\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'tcx> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Lifetime<RustInterner<'tcx>> {\n+        use rustc_middle::ty::RegionKind::*;\n+\n+        match self {\n+            ReEarlyBound(_) => {\n+                panic!(\"Should have already been substituted.\");\n+            }\n+            ReLateBound(db, br) => match br {\n+                ty::BoundRegion::BrAnon(var) => {\n+                    chalk_ir::LifetimeData::BoundVar(chalk_ir::BoundVar::new(\n+                        chalk_ir::DebruijnIndex::new(db.as_u32()),\n+                        *var as usize,\n+                    ))\n+                    .intern(interner)\n+                }\n+                ty::BoundRegion::BrNamed(_def_id, _name) => unimplemented!(),\n+                ty::BrEnv => unimplemented!(),\n+            },\n+            ReFree(_) => unimplemented!(),\n+            ReScope(_) => unimplemented!(),\n+            ReStatic => unimplemented!(),\n+            ReVar(_) => unimplemented!(),\n+            RePlaceholder(placeholder_region) => {\n+                chalk_ir::LifetimeData::Placeholder(chalk_ir::PlaceholderIndex {\n+                    ui: chalk_ir::UniverseIndex { counter: placeholder_region.universe.index() },\n+                    idx: 0,\n+                })\n+                .intern(interner)\n+            }\n+            ReEmpty(_) => unimplemented!(),\n+            ReErased => unimplemented!(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::Parameter<RustInterner<'tcx>>> for GenericArg<'tcx> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Parameter<RustInterner<'tcx>> {\n+        match self.unpack() {\n+            ty::subst::GenericArgKind::Type(ty) => {\n+                chalk_ir::ParameterKind::Ty(ty.lower_into(interner))\n+            }\n+            ty::subst::GenericArgKind::Lifetime(lifetime) => {\n+                chalk_ir::ParameterKind::Lifetime(lifetime.lower_into(interner))\n+            }\n+            ty::subst::GenericArgKind::Const(_) => chalk_ir::ParameterKind::Ty(\n+                chalk_ir::TyData::Apply(chalk_ir::ApplicationTy {\n+                    name: chalk_ir::TypeName::Tuple(0),\n+                    substitution: chalk_ir::Substitution::empty(interner),\n+                })\n+                .intern(interner),\n+            ),\n+        }\n+        .intern(interner)\n+    }\n+}\n+\n+// We lower into an Option here since there are some predicates which Chalk\n+// doesn't have a representation for yet (as a `WhereClause`), but are so common\n+// that we just are accepting the unsoundness for now. The `Option` will\n+// eventually be removed.\n+impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>\n+    for ty::Predicate<'tcx>\n+{\n+    fn lower_into(\n+        self,\n+        interner: &RustInterner<'tcx>,\n+    ) -> Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n+        match &self {\n+            Predicate::Trait(predicate, _) => {\n+                let (predicate, binders, _named_regions) =\n+                    collect_bound_vars(interner, interner.tcx, predicate);\n+\n+                Some(chalk_ir::Binders::new(\n+                    binders,\n+                    chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)),\n+                ))\n+            }\n+            Predicate::RegionOutlives(_predicate) => None,\n+            Predicate::TypeOutlives(_predicate) => None,\n+            Predicate::Projection(_predicate) => None,\n+            Predicate::WellFormed(_ty) => None,\n+\n+            Predicate::ObjectSafe(..)\n+            | Predicate::ClosureKind(..)\n+            | Predicate::Subtype(..)\n+            | Predicate::ConstEvaluatable(..) => bug!(\"unexpected predicate {}\", &self),\n+        }\n+    }\n+}\n+\n+/// To collect bound vars, we have to do two passes. In the first pass, we\n+/// collect all `BoundRegion`s and `ty::Bound`s. In the second pass, we then\n+/// replace `BrNamed` into `BrAnon`. The two separate passes are important,\n+/// since we can only replace `BrNamed` with `BrAnon`s with indices *after* all\n+/// \"real\" `BrAnon`s.\n+///\n+/// It's important to note that because of prior substitution, we may have\n+/// late-bound regions, even outside of fn contexts, since this is the best way\n+/// to prep types for chalk lowering.\n+crate fn collect_bound_vars<'a, 'tcx, T: TypeFoldable<'tcx>>(\n+    interner: &RustInterner<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    ty: &'a Binder<T>,\n+) -> (T, chalk_ir::ParameterKinds<RustInterner<'tcx>>, BTreeMap<DefId, u32>) {\n+    let mut bound_vars_collector = BoundVarsCollector::new();\n+    ty.skip_binder().visit_with(&mut bound_vars_collector);\n+    let mut parameters = bound_vars_collector.parameters;\n+    let named_parameters: BTreeMap<DefId, u32> = bound_vars_collector\n+        .named_parameters\n+        .into_iter()\n+        .enumerate()\n+        .map(|(i, def_id)| (def_id, (i + parameters.len()) as u32))\n+        .collect();\n+\n+    let mut bound_var_substitutor = NamedBoundVarSubstitutor::new(tcx, &named_parameters);\n+    let new_ty = ty.skip_binder().fold_with(&mut bound_var_substitutor);\n+\n+    for var in named_parameters.values() {\n+        parameters.insert(*var, chalk_ir::ParameterKind::Lifetime(()));\n+    }\n+\n+    (0..parameters.len()).for_each(|i| {\n+        parameters.get(&(i as u32)).expect(\"Skipped bound var index.\");\n+    });\n+\n+    let binders = chalk_ir::ParameterKinds::from(interner, parameters.into_iter().map(|(_, v)| v));\n+\n+    (new_ty, binders, named_parameters)\n+}\n+\n+crate struct BoundVarsCollector {\n+    binder_index: ty::DebruijnIndex,\n+    crate parameters: BTreeMap<u32, chalk_ir::ParameterKind<()>>,\n+    crate named_parameters: Vec<DefId>,\n+}\n+\n+impl BoundVarsCollector {\n+    crate fn new() -> Self {\n+        BoundVarsCollector {\n+            binder_index: ty::INNERMOST,\n+            parameters: BTreeMap::new(),\n+            named_parameters: vec![],\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_visit_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        match t.kind {\n+            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n+                match self.parameters.entry(bound_ty.var.as_u32()) {\n+                    Entry::Vacant(entry) => {\n+                        entry.insert(chalk_ir::ParameterKind::Ty(()));\n+                    }\n+                    Entry::Occupied(entry) => {\n+                        entry.get().assert_ty_ref();\n+                    }\n+                }\n+            }\n+\n+            _ => (),\n+        };\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: Region<'tcx>) -> bool {\n+        match r {\n+            ty::ReLateBound(index, br) if *index == self.binder_index => match br {\n+                ty::BoundRegion::BrNamed(def_id, _name) => {\n+                    if self.named_parameters.iter().find(|d| *d == def_id).is_none() {\n+                        self.named_parameters.push(*def_id);\n+                    }\n+                }\n+\n+                ty::BoundRegion::BrAnon(var) => match self.parameters.entry(*var) {\n+                    Entry::Vacant(entry) => {\n+                        entry.insert(chalk_ir::ParameterKind::Lifetime(()));\n+                    }\n+                    Entry::Occupied(entry) => {\n+                        entry.get().assert_lifetime_ref();\n+                    }\n+                },\n+\n+                ty::BrEnv => unimplemented!(),\n+            },\n+\n+            ty::ReEarlyBound(_re) => {\n+                // FIXME(chalk): jackh726 - I think we should always have already\n+                // substituted away `ReEarlyBound`s for `ReLateBound`s, but need to confirm.\n+                unimplemented!();\n+            }\n+\n+            _ => (),\n+        };\n+\n+        r.super_visit_with(self)\n+    }\n+}\n+\n+/// This is used to replace `BoundRegion::BrNamed` with `BoundRegion::BrAnon`.\n+/// Note: we assume that we will always have room for more bound vars. (i.e. we\n+/// won't ever hit the `u32` limit in `BrAnon`s).\n+struct NamedBoundVarSubstitutor<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    binder_index: ty::DebruijnIndex,\n+    named_parameters: &'a BTreeMap<DefId, u32>,\n+}\n+\n+impl<'a, 'tcx> NamedBoundVarSubstitutor<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, named_parameters: &'a BTreeMap<DefId, u32>) -> Self {\n+        NamedBoundVarSubstitutor { tcx, binder_index: ty::INNERMOST, named_parameters }\n+    }\n+}\n+\n+impl<'a, 'tcx> TypeFolder<'tcx> for NamedBoundVarSubstitutor<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> Binder<T> {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_fold_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        t.super_fold_with(self)\n+    }\n+\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n+        match r {\n+            ty::ReLateBound(index, br) if *index == self.binder_index => match br {\n+                ty::BoundRegion::BrNamed(def_id, _name) => {\n+                    match self.named_parameters.get(def_id) {\n+                        Some(idx) => {\n+                            return self.tcx.mk_region(RegionKind::ReLateBound(\n+                                *index,\n+                                BoundRegion::BrAnon(*idx),\n+                            ));\n+                        }\n+                        None => panic!(\"Missing `BrNamed`.\"),\n+                    }\n+                }\n+                ty::BrEnv => unimplemented!(),\n+                ty::BoundRegion::BrAnon(_) => {}\n+            },\n+            _ => (),\n+        };\n+\n+        r.super_fold_with(self)\n+    }\n+}\n+\n+/// Used to substitute `Param`s with placeholders. We do this since Chalk\n+/// have a notion of `Param`s.\n+crate struct ParamsSubstitutor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    binder_index: ty::DebruijnIndex,\n+    list: Vec<rustc_middle::ty::ParamTy>,\n+    crate params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n+    crate named_regions: BTreeMap<DefId, u32>,\n+}\n+\n+impl<'tcx> ParamsSubstitutor<'tcx> {\n+    crate fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        ParamsSubstitutor {\n+            tcx,\n+            binder_index: ty::INNERMOST,\n+            list: vec![],\n+            params: rustc_data_structures::fx::FxHashMap::default(),\n+            named_regions: BTreeMap::default(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> Binder<T> {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_fold_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.kind {\n+            // FIXME(chalk): currently we convert params to placeholders starting at\n+            // index `0`. To support placeholders, we'll actually need to do a\n+            // first pass to collect placeholders. Then we can insert params after.\n+            ty::Placeholder(_) => unimplemented!(),\n+            ty::Param(param) => match self.list.iter().position(|r| r == &param) {\n+                Some(_idx) => self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n+                    universe: ty::UniverseIndex::from_usize(0),\n+                    name: ty::BoundVar::from_usize(_idx),\n+                })),\n+                None => {\n+                    self.list.push(param);\n+                    let idx = self.list.len() - 1;\n+                    self.params.insert(idx, param);\n+                    self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n+                        universe: ty::UniverseIndex::from_usize(0),\n+                        name: ty::BoundVar::from_usize(idx),\n+                    }))\n+                }\n+            },\n+\n+            _ => t.super_fold_with(self),\n+        }\n+    }\n+\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n+        match r {\n+            // FIXME(chalk) - jackh726 - this currently isn't hit in any tests.\n+            // This covers any region variables in a goal, right?\n+            ty::ReEarlyBound(_re) => match self.named_regions.get(&_re.def_id) {\n+                Some(idx) => self.tcx.mk_region(RegionKind::ReLateBound(\n+                    self.binder_index,\n+                    BoundRegion::BrAnon(*idx),\n+                )),\n+                None => {\n+                    let idx = self.named_regions.len() as u32;\n+                    self.named_regions.insert(_re.def_id, idx);\n+                    self.tcx.mk_region(RegionKind::ReLateBound(\n+                        self.binder_index,\n+                        BoundRegion::BrAnon(idx),\n+                    ))\n+                }\n+            },\n+\n+            _ => r.super_fold_with(self),\n+        }\n+    }\n+}"}, {"sha": "4e635b9db0901b49d9c772bbea39f8045f3a5fe3", "filename": "src/librustc_traits/chalk/mod.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_traits%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_traits%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Fmod.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,227 @@\n+//! Calls `chalk-solve` to solve a `ty::Predicate`\n+//!\n+//! In order to call `chalk-solve`, this file must convert a\n+//! `ChalkCanonicalGoal` into a Chalk ucanonical goal. It then calls Chalk, and\n+//! converts the answer back into rustc solution.\n+\n+crate mod db;\n+crate mod lowering;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+\n+use rustc_index::vec::IndexVec;\n+\n+use rustc_middle::infer::canonical::{CanonicalTyVarKind, CanonicalVarKind};\n+use rustc_middle::traits::ChalkRustInterner;\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::subst::GenericArg;\n+use rustc_middle::ty::{\n+    self, Bound, BoundVar, ParamTy, Region, RegionKind, Ty, TyCtxt, TypeFoldable,\n+};\n+\n+use rustc_infer::infer::canonical::{\n+    Canonical, CanonicalVarValues, Certainty, QueryRegionConstraints, QueryResponse,\n+};\n+use rustc_infer::traits::{self, ChalkCanonicalGoal, ChalkRustDefId as RustDefId};\n+\n+use crate::chalk::db::RustIrDatabase as ChalkRustIrDatabase;\n+use crate::chalk::lowering::{LowerInto, ParamsSubstitutor};\n+\n+use chalk_solve::Solution;\n+\n+crate fn provide(p: &mut Providers<'_>) {\n+    *p = Providers { evaluate_goal, ..*p };\n+}\n+\n+crate fn evaluate_goal<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    obligation: ChalkCanonicalGoal<'tcx>,\n+) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, traits::query::NoSolution> {\n+    let interner = ChalkRustInterner { tcx };\n+\n+    // Chalk doesn't have a notion of `Params`, so instead we use placeholders.\n+    let mut params_substitutor = ParamsSubstitutor::new(tcx);\n+    let obligation = obligation.fold_with(&mut params_substitutor);\n+    let _params: FxHashMap<usize, ParamTy> = params_substitutor.params;\n+    let max_universe = obligation.max_universe.index();\n+\n+    let _lowered_goal: chalk_ir::UCanonical<\n+        chalk_ir::InEnvironment<chalk_ir::Goal<ChalkRustInterner<'tcx>>>,\n+    > = chalk_ir::UCanonical {\n+        canonical: chalk_ir::Canonical {\n+            binders: chalk_ir::CanonicalVarKinds::from(\n+                &interner,\n+                obligation.variables.iter().map(|v| match v.kind {\n+                    CanonicalVarKind::PlaceholderTy(_ty) => unimplemented!(),\n+                    CanonicalVarKind::PlaceholderRegion(_ui) => unimplemented!(),\n+                    CanonicalVarKind::Ty(ty) => match ty {\n+                        CanonicalTyVarKind::General(ui) => {\n+                            chalk_ir::ParameterKind::Ty(chalk_ir::UniverseIndex {\n+                                counter: ui.index(),\n+                            })\n+                        }\n+                        CanonicalTyVarKind::Int | CanonicalTyVarKind::Float => {\n+                            // FIXME(chalk) - this is actually really important\n+                            // These variable kinds put some limits on the\n+                            // types that can be substituted (floats or ints).\n+                            // While it's unclear exactly the design here, we\n+                            // probably want some way to \"register\" these.\n+                            chalk_ir::ParameterKind::Ty(chalk_ir::UniverseIndex::root())\n+                        }\n+                    },\n+                    CanonicalVarKind::Region(ui) => {\n+                        chalk_ir::ParameterKind::Lifetime(chalk_ir::UniverseIndex {\n+                            counter: ui.index(),\n+                        })\n+                    }\n+                    CanonicalVarKind::Const(_ui) => unimplemented!(),\n+                    CanonicalVarKind::PlaceholderConst(_pc) => unimplemented!(),\n+                }),\n+            ),\n+            value: obligation.value.lower_into(&interner),\n+        },\n+        universes: max_universe + 1,\n+    };\n+\n+    let solver_choice = chalk_solve::SolverChoice::SLG { max_size: 32, expected_answers: None };\n+    let mut solver = solver_choice.into_solver::<ChalkRustInterner<'tcx>>();\n+\n+    let db = ChalkRustIrDatabase { tcx, interner };\n+    let solution = solver.solve(&db, &_lowered_goal);\n+\n+    // Ideally, the code to convert *back* to rustc types would live close to\n+    // the code to convert *from* rustc types. Right now though, we don't\n+    // really need this and so it's really minimal.\n+    // Right now, we also treat a `Unique` solution the same as\n+    // `Ambig(Definite)`. This really isn't right.\n+    let make_solution = |_subst: chalk_ir::Substitution<_>| {\n+        let mut var_values: IndexVec<BoundVar, GenericArg<'tcx>> = IndexVec::new();\n+        _subst.parameters(&interner).iter().for_each(|p| {\n+            // FIXME(chalk): we should move this elsewhere, since this is\n+            // essentially inverse of lowering a `GenericArg`.\n+            let _data = p.data(&interner);\n+            match _data {\n+                chalk_ir::ParameterKind::Ty(_t) => {\n+                    use chalk_ir::TyData;\n+                    use rustc_ast::ast;\n+\n+                    let _data = _t.data(&interner);\n+                    let kind = match _data {\n+                        TyData::Apply(_application_ty) => match _application_ty.name {\n+                            chalk_ir::TypeName::Struct(_struct_id) => match _struct_id.0 {\n+                                RustDefId::Array => unimplemented!(),\n+                                RustDefId::Slice => unimplemented!(),\n+                                _ => unimplemented!(),\n+                            },\n+                            chalk_ir::TypeName::Scalar(scalar) => match scalar {\n+                                chalk_ir::Scalar::Bool => ty::Bool,\n+                                chalk_ir::Scalar::Char => ty::Char,\n+                                chalk_ir::Scalar::Int(int_ty) => match int_ty {\n+                                    chalk_ir::IntTy::Isize => ty::Int(ast::IntTy::Isize),\n+                                    chalk_ir::IntTy::I8 => ty::Int(ast::IntTy::I8),\n+                                    chalk_ir::IntTy::I16 => ty::Int(ast::IntTy::I16),\n+                                    chalk_ir::IntTy::I32 => ty::Int(ast::IntTy::I32),\n+                                    chalk_ir::IntTy::I64 => ty::Int(ast::IntTy::I64),\n+                                    chalk_ir::IntTy::I128 => ty::Int(ast::IntTy::I128),\n+                                },\n+                                chalk_ir::Scalar::Uint(int_ty) => match int_ty {\n+                                    chalk_ir::UintTy::Usize => ty::Uint(ast::UintTy::Usize),\n+                                    chalk_ir::UintTy::U8 => ty::Uint(ast::UintTy::U8),\n+                                    chalk_ir::UintTy::U16 => ty::Uint(ast::UintTy::U16),\n+                                    chalk_ir::UintTy::U32 => ty::Uint(ast::UintTy::U32),\n+                                    chalk_ir::UintTy::U64 => ty::Uint(ast::UintTy::U64),\n+                                    chalk_ir::UintTy::U128 => ty::Uint(ast::UintTy::U128),\n+                                },\n+                                chalk_ir::Scalar::Float(float_ty) => match float_ty {\n+                                    chalk_ir::FloatTy::F32 => ty::Float(ast::FloatTy::F32),\n+                                    chalk_ir::FloatTy::F64 => ty::Float(ast::FloatTy::F64),\n+                                },\n+                            },\n+                            chalk_ir::TypeName::Tuple(_size) => unimplemented!(),\n+                            chalk_ir::TypeName::OpaqueType(_ty) => unimplemented!(),\n+                            chalk_ir::TypeName::AssociatedType(_assoc_ty) => unimplemented!(),\n+                            chalk_ir::TypeName::Error => unimplemented!(),\n+                        },\n+                        TyData::Placeholder(_placeholder) => {\n+                            unimplemented!();\n+                        }\n+                        TyData::Alias(_alias_ty) => unimplemented!(),\n+                        TyData::Function(_quantified_ty) => unimplemented!(),\n+                        TyData::BoundVar(_bound) => Bound(\n+                            ty::DebruijnIndex::from_usize(_bound.debruijn.depth() as usize),\n+                            ty::BoundTy {\n+                                var: ty::BoundVar::from_usize(_bound.index),\n+                                kind: ty::BoundTyKind::Anon,\n+                            },\n+                        ),\n+                        TyData::InferenceVar(_) => unimplemented!(),\n+                        TyData::Dyn(_) => unimplemented!(),\n+                    };\n+                    let _ty: Ty<'_> = tcx.mk_ty(kind);\n+                    let _arg: GenericArg<'_> = _ty.into();\n+                    var_values.push(_arg);\n+                }\n+                chalk_ir::ParameterKind::Lifetime(_l) => {\n+                    let _data = _l.data(&interner);\n+                    let _lifetime: Region<'_> = match _data {\n+                        chalk_ir::LifetimeData::BoundVar(_var) => {\n+                            tcx.mk_region(RegionKind::ReLateBound(\n+                                rustc_middle::ty::DebruijnIndex::from_usize(\n+                                    _var.debruijn.depth() as usize\n+                                ),\n+                                rustc_middle::ty::BoundRegion::BrAnon(_var.index as u32),\n+                            ))\n+                        }\n+                        chalk_ir::LifetimeData::InferenceVar(_var) => unimplemented!(),\n+                        chalk_ir::LifetimeData::Placeholder(_index) => unimplemented!(),\n+                        chalk_ir::LifetimeData::Phantom(_, _) => unimplemented!(),\n+                    };\n+                    let _arg: GenericArg<'_> = _lifetime.into();\n+                    var_values.push(_arg);\n+                }\n+            }\n+        });\n+        let sol = Canonical {\n+            max_universe: ty::UniverseIndex::from_usize(0),\n+            variables: obligation.variables.clone(),\n+            value: QueryResponse {\n+                var_values: CanonicalVarValues { var_values },\n+                region_constraints: QueryRegionConstraints::default(),\n+                certainty: Certainty::Proven,\n+                value: (),\n+            },\n+        };\n+        &*tcx.arena.alloc(sol)\n+    };\n+    solution\n+        .map(|s| match s {\n+            Solution::Unique(_subst) => {\n+                // FIXME(chalk): handle constraints\n+                assert!(_subst.value.constraints.is_empty());\n+                make_solution(_subst.value.subst)\n+            }\n+            Solution::Ambig(_guidance) => {\n+                match _guidance {\n+                    chalk_solve::Guidance::Definite(_subst) => make_solution(_subst.value),\n+                    chalk_solve::Guidance::Suggested(_) => unimplemented!(),\n+                    chalk_solve::Guidance::Unknown => {\n+                        // chalk_fulfill doesn't use the var_values here, so\n+                        // let's just ignore that\n+                        let sol = Canonical {\n+                            max_universe: ty::UniverseIndex::from_usize(0),\n+                            variables: obligation.variables.clone(),\n+                            value: QueryResponse {\n+                                var_values: CanonicalVarValues { var_values: IndexVec::new() }\n+                                    .make_identity(tcx),\n+                                region_constraints: QueryRegionConstraints::default(),\n+                                certainty: Certainty::Ambiguous,\n+                                value: (),\n+                            },\n+                        };\n+                        &*tcx.arena.alloc(sol)\n+                    }\n+                }\n+            }\n+        })\n+        .ok_or(traits::query::NoSolution)\n+}"}, {"sha": "f3dfdffda41910aa227b6b39a692103133e01c29", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -12,6 +12,7 @@ extern crate log;\n #[macro_use]\n extern crate rustc_middle;\n \n+mod chalk;\n mod dropck_outlives;\n mod evaluate_obligation;\n mod implied_outlives_bounds;\n@@ -25,6 +26,7 @@ pub fn provide(p: &mut Providers<'_>) {\n     dropck_outlives::provide(p);\n     evaluate_obligation::provide(p);\n     implied_outlives_bounds::provide(p);\n+    chalk::provide(p);\n     normalize_projection_ty::provide(p);\n     normalize_erasing_regions::provide(p);\n     type_op::provide(p);"}, {"sha": "6add099e75bd6ea47e9f1088bf4ea1e6d1e0a92c", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -262,8 +262,11 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     // are any errors at that point, so after type checking you can be\n     // sure that this will succeed without errors anyway.\n \n-    let unnormalized_env =\n-        ty::ParamEnv::new(tcx.intern_predicates(&predicates), traits::Reveal::UserFacing, None);\n+    let unnormalized_env = ty::ParamEnv::new(\n+        tcx.intern_predicates(&predicates),\n+        traits::Reveal::UserFacing,\n+        tcx.sess.opts.debugging_opts.chalk.then_some(def_id),\n+    );\n \n     let body_id = def_id\n         .as_local()"}, {"sha": "dbd60fc8bb1ff1d9bb5b7d146c57f8f445d102c0", "filename": "src/test/ui/chalkify/basic.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fbasic.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo {}\n+\n+struct Bar {}\n+\n+impl Foo for Bar {}\n+\n+fn main() -> () {\n+    let _ = Bar {};\n+}"}, {"sha": "d403514b553b079d4ac6c1cb782c6e6742a9dadc", "filename": "src/test/ui/chalkify/builtin-copy-clone.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fbuiltin-copy-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fbuiltin-copy-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fbuiltin-copy-clone.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,44 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+// Test that `Clone` is correctly implemented for builtin types.\n+\n+#[derive(Copy, Clone)]\n+struct S(i32);\n+\n+fn test_clone<T: Clone>(arg: T) {\n+    let _ = arg.clone();\n+}\n+\n+fn test_copy<T: Copy>(arg: T) {\n+    let _ = arg;\n+    let _ = arg;\n+}\n+\n+fn test_copy_clone<T: Copy + Clone>(arg: T) {\n+    test_copy(arg);\n+    test_clone(arg);\n+}\n+\n+fn foo() { }\n+\n+fn main() {\n+    test_copy_clone(foo);\n+    let f: fn() = foo;\n+    test_copy_clone(f);\n+    // FIXME: add closures when they're considered WF\n+    test_copy_clone([1; 56]);\n+    test_copy_clone((1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1));\n+    test_copy_clone((1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, true, 'a', 1.1));\n+    test_copy_clone(());\n+    test_copy_clone(((1, 1), (1, 1, 1), (1.1, 1, 1, 'a'), ()));\n+\n+    let a = (\n+        (S(1), S(0)),\n+        (\n+            (S(0), S(0), S(1)),\n+            S(0)\n+        )\n+    );\n+    test_copy_clone(a);\n+}"}, {"sha": "df25bad622b3d09e83d3d6090f176f5cf914e887", "filename": "src/test/ui/chalkify/chalk_initial_program.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fchalk_initial_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fchalk_initial_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fchalk_initial_program.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,16 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+impl Foo for i32 { }\n+\n+impl Foo for u32 { }\n+\n+fn gimme<F: Foo>() { }\n+\n+// Note: this also tests that `std::process::Termination` is implemented for `()`.\n+fn main() {\n+    gimme::<i32>();\n+    gimme::<u32>();\n+    gimme::<f32>(); //~ERROR the trait bound `f32: Foo` is not satisfied\n+}"}, {"sha": "f2e13a6a46904316a29b8fd44b4bdfa8a4a1882f", "filename": "src/test/ui/chalkify/chalk_initial_program.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fchalk_initial_program.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fchalk_initial_program.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fchalk_initial_program.stderr?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `f32: Foo` is not satisfied\n+  --> $DIR/chalk_initial_program.rs:15:13\n+   |\n+LL | fn gimme<F: Foo>() { }\n+   |             --- required by this bound in `gimme`\n+...\n+LL |     gimme::<f32>();\n+   |             ^^^ the trait `Foo` is not implemented for `f32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "d70c6f8055ddf92adfd332a3d1963888ed08ce93", "filename": "src/test/ui/chalkify/generic_impls.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fgeneric_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fgeneric_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fgeneric_impls.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,18 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+impl<T> Foo for (T, u32) { }\n+\n+fn gimme<F: Foo>() { }\n+\n+fn foo<T>() {\n+    gimme::<(T, u32)>();\n+    gimme::<(Option<T>, u32)>();\n+    gimme::<(Option<T>, f32)>(); //~ ERROR\n+}\n+\n+fn main() {\n+    gimme::<(i32, u32)>();\n+    gimme::<(i32, f32)>(); //~ ERROR\n+}"}, {"sha": "4ac57a2f13fd15920ca92d8987a2d4b72bdf948a", "filename": "src/test/ui/chalkify/generic_impls.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fgeneric_impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fgeneric_impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fgeneric_impls.stderr?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,27 @@\n+error[E0277]: the trait bound `(std::option::Option<T>, f32): Foo` is not satisfied\n+  --> $DIR/generic_impls.rs:12:13\n+   |\n+LL | fn gimme<F: Foo>() { }\n+   |             --- required by this bound in `gimme`\n+...\n+LL |     gimme::<(Option<T>, f32)>();\n+   |             ^^^^^^^^^^^^^^^^ the trait `Foo` is not implemented for `(std::option::Option<T>, f32)`\n+   |\n+   = help: the following implementations were found:\n+             <(T, u32) as Foo>\n+\n+error[E0277]: the trait bound `(i32, f32): Foo` is not satisfied\n+  --> $DIR/generic_impls.rs:17:13\n+   |\n+LL | fn gimme<F: Foo>() { }\n+   |             --- required by this bound in `gimme`\n+...\n+LL |     gimme::<(i32, f32)>();\n+   |             ^^^^^^^^^^ the trait `Foo` is not implemented for `(i32, f32)`\n+   |\n+   = help: the following implementations were found:\n+             <(T, u32) as Foo>\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "8aa876422924d3e96ff0a38ec2d0e7633c0ac45d", "filename": "src/test/ui/chalkify/impl_wf.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,47 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo: Sized { }\n+\n+trait Bar {\n+    type Item: Foo;\n+}\n+\n+impl Foo for i32 { }\n+\n+// FIXME(chalk): blocked on better handling of builtin traits for non-struct\n+// application types (or a workaround)\n+/*\n+impl Foo for str { }\n+//^ ERROR the size for values of type `str` cannot be known at compilation time\n+*/\n+\n+// Implicit `T: Sized` bound.\n+impl<T> Foo for Option<T> { }\n+\n+impl Bar for () {\n+    type Item = i32;\n+}\n+\n+impl<T> Bar for Option<T> {\n+    type Item = Option<T>;\n+}\n+\n+// FIXME(chalk): the ordering of these two errors differs between CI and local\n+// We need to figure out why its non-deterministic\n+/*\n+impl Bar for f32 {\n+//^ ERROR the trait bound `f32: Foo` is not satisfied\n+    type Item = f32;\n+    //^ ERROR the trait bound `f32: Foo` is not satisfied\n+}\n+*/\n+\n+trait Baz<U: ?Sized> where U: Foo { }\n+\n+impl Baz<i32> for i32 { }\n+\n+impl Baz<f32> for f32 { }\n+//~^ ERROR the trait bound `f32: Foo` is not satisfied\n+\n+fn main() {\n+}"}, {"sha": "befd688741c80ca4e77fe8ed684e1ad7da408c4e", "filename": "src/test/ui/chalkify/impl_wf.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `f32: Foo` is not satisfied\n+  --> $DIR/impl_wf.rs:43:6\n+   |\n+LL | trait Baz<U: ?Sized> where U: Foo { }\n+   |                               --- required by this bound in `Baz`\n+...\n+LL | impl Baz<f32> for f32 { }\n+   |      ^^^^^^^^ the trait `Foo` is not implemented for `f32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "44e120c1eebbaabfd4bd162118ff3943199b5303", "filename": "src/test/ui/chalkify/inherent_impl.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,42 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+impl Foo for i32 { }\n+\n+struct S<T: Foo> {\n+    x: T,\n+}\n+\n+fn only_foo<T: Foo>(_x: &T) { }\n+\n+impl<T> S<T> {\n+    // Test that we have the correct environment inside an inherent method.\n+    fn dummy_foo(&self) {\n+        only_foo(&self.x)\n+    }\n+}\n+\n+trait Bar { }\n+impl Bar for u32 { }\n+\n+fn only_bar<T: Bar>() { }\n+\n+impl<T> S<T> {\n+    // Test that the environment of `dummy_bar` adds up with the environment\n+    // of the inherent impl.\n+    fn dummy_bar<U: Bar>(&self) {\n+        only_foo(&self.x);\n+        only_bar::<U>();\n+    }\n+}\n+\n+fn main() {\n+    let s = S {\n+        x: 5,\n+    };\n+\n+    s.dummy_foo();\n+    s.dummy_bar::<u32>();\n+}"}, {"sha": "774c46e401ca30260f86e73dc4f27f26f9f573a9", "filename": "src/test/ui/chalkify/inherent_impl_min.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl_min.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl_min.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Finherent_impl_min.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,27 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+impl Foo for i32 { }\n+\n+struct S<T: Foo> {\n+    x: T,\n+}\n+\n+fn only_foo<T: Foo>(_x: &T) { }\n+\n+impl<T> S<T> {\n+    // Test that we have the correct environment inside an inherent method.\n+    fn dummy_foo(&self) {\n+        only_foo(&self.x)\n+    }\n+}\n+\n+fn main() {\n+    let s = S {\n+        x: 5,\n+    };\n+\n+    s.dummy_foo();\n+}"}, {"sha": "e3c7569592149d236215c06570469ddf1e120f6e", "filename": "src/test/ui/chalkify/lower_env1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+#![allow(dead_code)]\n+\n+trait Foo { }\n+\n+trait Bar where Self: Foo { }\n+\n+fn bar<T: Bar + ?Sized>() {\n+}\n+\n+fn main() {\n+}"}, {"sha": "b5432ce0e307bb9e2bf5c024a4dda0f0906aff28", "filename": "src/test/ui/chalkify/lower_env2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+#![allow(dead_code)]\n+\n+trait Foo { }\n+\n+struct S<'a, T: ?Sized> where T: Foo {\n+    data: &'a T,\n+}\n+\n+fn bar<T: Foo>(_x: S<'_, T>) { // note that we have an implicit `T: Sized` bound\n+}\n+\n+fn main() {\n+}"}, {"sha": "673f08d78abd0ee08102294a9ed6634b04ac4e46", "filename": "src/test/ui/chalkify/lower_env3.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+#![allow(dead_code)]\n+\n+trait Foo {\n+    fn foo(&self);\n+}\n+\n+impl<T> Foo for T where T: Clone {\n+    fn foo(&self) {\n+    }\n+}\n+\n+fn main() {\n+}"}, {"sha": "f586cf083915debc7986e0d2e59d5a69f4149cac", "filename": "src/test/ui/chalkify/lower_impl.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+impl<T: 'static> Foo for T where T: Iterator<Item = i32> { }\n+\n+trait Bar {\n+    type Assoc;\n+}\n+\n+impl<T> Bar for T where T: Iterator<Item = i32> {\n+    type Assoc = Vec<T>;\n+}\n+\n+fn main() {\n+}"}, {"sha": "94a0716d383546c2f307cac7232cd2f3a1543fd1", "filename": "src/test/ui/chalkify/lower_struct.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,8 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+struct Foo<'a, T> where Box<T>: Clone {\n+    _x: std::marker::PhantomData<&'a T>,\n+}\n+\n+fn main() { }"}, {"sha": "d8f6180ceb315ab07a41346ca0d9904f9a131478", "filename": "src/test/ui/chalkify/lower_trait.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+trait Bar { }\n+\n+trait Foo<S, T: ?Sized> {\n+    type Assoc: Bar + ?Sized;\n+}\n+\n+fn main() {\n+}"}, {"sha": "a48979491a10de7144a331e911d39a55923ff2d0", "filename": "src/test/ui/chalkify/lower_trait_higher_rank.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo<F: ?Sized> where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8\n+{\n+}\n+\n+fn main() {\n+}"}, {"sha": "19cff8db7cb4ad59c792a43f2ed000a8986d5bda", "filename": "src/test/ui/chalkify/lower_trait_where_clause.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+use std::borrow::Borrow;\n+\n+trait Foo<'a, 'b, T, U>\n+where\n+    T: Borrow<U> + ?Sized,\n+    U: ?Sized + 'b,\n+    'a: 'b,\n+    Box<T>:, // NOTE(#53696) this checks an empty list of bounds.\n+{\n+}\n+\n+fn main() {\n+}"}, {"sha": "cf36aef8afaf3d0c9963229d64099c941e820af4", "filename": "src/test/ui/chalkify/println.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fprintln.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fprintln.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fprintln.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,7 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+fn main() {\n+    // FIXME(chalk): Require `RegionOutlives`/`TypeOutlives`/`Subtype` support\n+    //println!(\"hello\");\n+}"}, {"sha": "d6a8dd7a4a20317ddadfd00f2659683b1cd8bbae", "filename": "src/test/ui/chalkify/projection.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fprojection.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,25 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+trait Bar {\n+    type Item: Foo;\n+}\n+\n+impl Foo for i32 { }\n+impl Bar for i32 {\n+    type Item = i32;\n+}\n+\n+fn only_foo<T: Foo>() { }\n+\n+fn only_bar<T: Bar>() {\n+    // `T` implements `Bar` hence `<T as Bar>::Item` must also implement `Bar`\n+    only_foo::<T::Item>()\n+}\n+\n+fn main() {\n+    only_bar::<i32>();\n+    only_foo::<<i32 as Bar>::Item>();\n+}"}, {"sha": "6ee13f5e7a104da2aab05de447f6074fd4584ab5", "filename": "src/test/ui/chalkify/recursive_where_clause_on_type.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,35 @@\n+// FIXME(chalk): should fail, see comments\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+#![feature(trivial_bounds)]\n+\n+trait Bar {\n+    fn foo();\n+}\n+trait Foo: Bar { }\n+\n+struct S where S: Foo;\n+//~^ WARN Trait bound S: Foo does not depend on any type or lifetime parameters\n+\n+impl Foo for S {\n+}\n+\n+fn bar<T: Bar>() {\n+    T::foo();\n+}\n+\n+fn foo<T: Foo>() {\n+    bar::<T>()\n+}\n+\n+fn main() {\n+    // For some reason, the error is duplicated...\n+\n+    // FIXME(chalk): this order of this duplicate error seems non-determistic\n+    // and causes test to fail\n+    /*\n+    foo::<S>() // ERROR the type `S` is not well-formed (chalk)\n+    //^ ERROR the type `S` is not well-formed (chalk)\n+    */\n+}"}, {"sha": "a5b7ef7fdb2e37b920130c2a875577f2d6a6375c", "filename": "src/test/ui/chalkify/recursive_where_clause_on_type.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Frecursive_where_clause_on_type.stderr?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,10 @@\n+warning: Trait bound S: Foo does not depend on any type or lifetime parameters\n+  --> $DIR/recursive_where_clause_on_type.rs:12:19\n+   |\n+LL | struct S where S: Foo;\n+   |                   ^^^\n+   |\n+   = note: `#[warn(trivial_bounds)]` on by default\n+\n+warning: 1 warning emitted\n+"}, {"sha": "eeff9fd9b80a36098d7f90944fab6d08f56ab092", "filename": "src/test/ui/chalkify/super_trait.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fsuper_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Fsuper_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fsuper_trait.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,19 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+trait Bar: Foo { }\n+\n+impl Foo for i32 { }\n+impl Bar for i32 { }\n+\n+fn only_foo<T: Foo>() { }\n+\n+fn only_bar<T: Bar>() {\n+    // `T` implements `Bar` hence `T` must also implement `Foo`\n+    only_foo::<T>()\n+}\n+\n+fn main() {\n+    only_bar::<i32>()\n+}"}, {"sha": "8a2e1cf599008acd80bcb98765711110013d3642", "filename": "src/test/ui/chalkify/trait_implied_bound.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Ftrait_implied_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Ftrait_implied_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftrait_implied_bound.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,18 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+trait Bar<U> where U: Foo { }\n+\n+impl Foo for i32 { }\n+impl Bar<i32> for i32 { }\n+\n+fn only_foo<T: Foo>() { }\n+\n+fn only_bar<U, T: Bar<U>>() {\n+    only_foo::<U>()\n+}\n+\n+fn main() {\n+    only_bar::<i32, i32>()\n+}"}, {"sha": "8673f5319bdf05c55bf580eb1fb33967590b1ed6", "filename": "src/test/ui/chalkify/type_implied_bound.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Ftype_implied_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Ftype_implied_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_implied_bound.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,29 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+trait Eq { }\n+trait Hash: Eq { }\n+\n+impl Eq for i32 { }\n+impl Hash for i32 { }\n+\n+struct Set<T: Hash> {\n+    _x: T,\n+}\n+\n+fn only_eq<T: Eq>() { }\n+\n+fn take_a_set<T>(_: &Set<T>) {\n+    // `Set<T>` is an input type of `take_a_set`, hence we know that\n+    // `T` must implement `Hash`, and we know in turn that `T` must\n+    // implement `Eq`.\n+    only_eq::<T>()\n+}\n+\n+fn main() {\n+    let set = Set {\n+        _x: 5,\n+    };\n+\n+    take_a_set(&set);\n+}"}, {"sha": "5175c5d062a6e37ffb5e4a0f790da6d5fefd997c", "filename": "src/test/ui/chalkify/type_inference.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,28 @@\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+impl Foo for i32 { }\n+\n+trait Bar { }\n+impl Bar for i32 { }\n+impl Bar for u32 { }\n+\n+fn only_foo<T: Foo>(_x: T) { }\n+\n+fn only_bar<T: Bar>(_x: T) { }\n+\n+fn main() {\n+    let x = 5.0;\n+\n+    // The only type which implements `Foo` is `i32`, so the chalk trait solver\n+    // is expecting a variable of type `i32`. This behavior differs from the\n+    // old-style trait solver. I guess this will change, that's why I'm\n+    // adding that test.\n+    // FIXME(chalk): partially blocked on float/int special casing\n+    only_foo(x); //~ ERROR the trait bound `f64: Foo` is not satisfied\n+\n+    // Here we have two solutions so we get back the behavior of the old-style\n+    // trait solver.\n+    // FIXME(chalk): blocked on float/int special casing\n+    //only_bar(x); // ERROR the trait bound `{float}: Bar` is not satisfied\n+}"}, {"sha": "ee9e67c6c78849d43095e8efa28ceffeae4ef7d2", "filename": "src/test/ui/chalkify/type_inference.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `f64: Foo` is not satisfied\n+  --> $DIR/type_inference.rs:22:5\n+   |\n+LL | fn only_foo<T: Foo>(_x: T) { }\n+   |                --- required by this bound in `only_foo`\n+...\n+LL |     only_foo(x);\n+   |     ^^^^^^^^ the trait `Foo` is not implemented for `f64`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "396baf814a0b040c5379657fc9671890bf69e4fe", "filename": "src/test/ui/chalkify/type_wf.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -0,0 +1,32 @@\n+// FIXME(chalk): should have an error, see below\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+trait Foo { }\n+\n+struct S<T: Foo> {\n+    x: T,\n+}\n+\n+impl Foo for i32 { }\n+impl<T> Foo for Option<T> { }\n+\n+fn main() {\n+    let s = S {\n+       x: 5,\n+    };\n+\n+    // FIXME(chalk): blocked on float/int special handling. Needs to know that {float}: !i32\n+    /*\n+    let s = S { // ERROR the trait bound `{float}: Foo` is not satisfied\n+        x: 5.0,\n+    };\n+    */\n+\n+    // FIXME(chalk): blocked on float/int special handling. Needs to know that {float}: Sized\n+    /*\n+    let s = S {\n+        x: Some(5.0),\n+    };\n+    */\n+}"}, {"sha": "d3c7b7a068bc321b6a8dc667d7582b052a165989", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a24df5b3cdeb49334d6cde1c4d983b2354616824/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=a24df5b3cdeb49334d6cde1c4d983b2354616824", "patch": "@@ -80,6 +80,10 @@ const WHITELIST: &[&str] = &[\n     \"c2-chacha\",\n     \"cc\",\n     \"cfg-if\",\n+    \"chalk-derive\",\n+    \"chalk-engine\",\n+    \"chalk-ir\",\n+    \"chalk-macros\",\n     \"cloudabi\",\n     \"cmake\",\n     \"compiler_builtins\","}]}