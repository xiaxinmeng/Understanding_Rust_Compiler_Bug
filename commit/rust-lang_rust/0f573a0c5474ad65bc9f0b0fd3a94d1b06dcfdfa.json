{"sha": "0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "node_id": "C_kwDOAAsO6NoAKDBmNTczYTBjNTQ3NGFkNjViYzlmMGIwZmQzYTk0ZDFiMDZkY2ZkZmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-07T18:14:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-07T18:14:44Z"}, "message": "Auto merge of #95573 - cjgillot:lower-query, r=michaelwoerister\n\nMake lowering a query\n\nSplit from https://github.com/rust-lang/rust/pull/88186.\n\nThis PR refactors the relationship between lowering and the resolver outputs in order to make lowering itself a query.\nIn a first part, lowering is changed to avoid modifying resolver outputs, by maintaining its own data structures for creating new `NodeId`s and so.\n\nThen, the `TyCtxt` is modified to allow creating new `LocalDefId`s from inside it. This is done by:\n- enclosing `Definitions` in a lock, so as to allow modification;\n- creating a query `register_def` whose purpose is to declare a `LocalDefId` to the query system.\n\nSee `TyCtxt::create_def` and `TyCtxt::iter_local_def_id` for more detailed explanations of the design.", "tree": {"sha": "76e166db0204687bf633bfc00b5af062e732d286", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76e166db0204687bf633bfc00b5af062e732d286"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "html_url": "https://github.com/rust-lang/rust/commit/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29", "html_url": "https://github.com/rust-lang/rust/commit/3e51277fe638dc0c8ceb6d1d3acc5aa247277c29"}, {"sha": "32a30cad0375e61eeac483f811413a9a26102ebf", "url": "https://api.github.com/repos/rust-lang/rust/commits/32a30cad0375e61eeac483f811413a9a26102ebf", "html_url": "https://github.com/rust-lang/rust/commit/32a30cad0375e61eeac483f811413a9a26102ebf"}], "stats": {"total": 859, "additions": 465, "deletions": 394}, "files": [{"sha": "86936b25d8ad9c61f012c97a77a227aa43f50321", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -3869,6 +3869,7 @@ name = \"rustc_hir\"\n version = \"0.0.0\"\n dependencies = [\n  \"odht\",\n+ \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_error_messages\","}, {"sha": "0e395d703358610447ae658266608d0f063e1273", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -24,10 +24,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> &'hir hir::InlineAsm<'hir> {\n         // Rustdoc needs to support asm! from foreign architectures: don't try\n         // lowering the register constraints in this case.\n-        let asm_arch = if self.sess.opts.actually_rustdoc { None } else { self.sess.asm_arch };\n-        if asm_arch.is_none() && !self.sess.opts.actually_rustdoc {\n-            struct_span_err!(self.sess, sp, E0472, \"inline assembly is unsupported on this target\")\n-                .emit();\n+        let asm_arch =\n+            if self.tcx.sess.opts.actually_rustdoc { None } else { self.tcx.sess.asm_arch };\n+        if asm_arch.is_none() && !self.tcx.sess.opts.actually_rustdoc {\n+            struct_span_err!(\n+                self.tcx.sess,\n+                sp,\n+                E0472,\n+                \"inline assembly is unsupported on this target\"\n+            )\n+            .emit();\n         }\n         if let Some(asm_arch) = asm_arch {\n             // Inline assembly is currently only stable for these architectures.\n@@ -40,9 +46,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     | asm::InlineAsmArch::RiscV32\n                     | asm::InlineAsmArch::RiscV64\n             );\n-            if !is_stable && !self.sess.features_untracked().asm_experimental_arch {\n+            if !is_stable && !self.tcx.features().asm_experimental_arch {\n                 feature_err(\n-                    &self.sess.parse_sess,\n+                    &self.tcx.sess.parse_sess,\n                     sym::asm_experimental_arch,\n                     sp,\n                     \"inline assembly is not stable yet on this architecture\",\n@@ -52,17 +58,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n         if asm.options.contains(InlineAsmOptions::ATT_SYNTAX)\n             && !matches!(asm_arch, Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64))\n-            && !self.sess.opts.actually_rustdoc\n+            && !self.tcx.sess.opts.actually_rustdoc\n         {\n-            self.sess\n+            self.tcx\n+                .sess\n                 .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n                 .emit();\n         }\n-        if asm.options.contains(InlineAsmOptions::MAY_UNWIND)\n-            && !self.sess.features_untracked().asm_unwind\n-        {\n+        if asm.options.contains(InlineAsmOptions::MAY_UNWIND) && !self.tcx.features().asm_unwind {\n             feature_err(\n-                &self.sess.parse_sess,\n+                &self.tcx.sess.parse_sess,\n                 sym::asm_unwind,\n                 sp,\n                 \"the `may_unwind` option is unstable\",\n@@ -73,20 +78,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut clobber_abis = FxHashMap::default();\n         if let Some(asm_arch) = asm_arch {\n             for (abi_name, abi_span) in &asm.clobber_abis {\n-                match asm::InlineAsmClobberAbi::parse(asm_arch, &self.sess.target, *abi_name) {\n+                match asm::InlineAsmClobberAbi::parse(asm_arch, &self.tcx.sess.target, *abi_name) {\n                     Ok(abi) => {\n                         // If the abi was already in the list, emit an error\n                         match clobber_abis.get(&abi) {\n                             Some((prev_name, prev_sp)) => {\n-                                let mut err = self.sess.struct_span_err(\n+                                let mut err = self.tcx.sess.struct_span_err(\n                                     *abi_span,\n                                     &format!(\"`{}` ABI specified multiple times\", prev_name),\n                                 );\n                                 err.span_label(*prev_sp, \"previously specified here\");\n \n                                 // Multiple different abi names may actually be the same ABI\n                                 // If the specified ABIs are not the same name, alert the user that they resolve to the same ABI\n-                                let source_map = self.sess.source_map();\n+                                let source_map = self.tcx.sess.source_map();\n                                 if source_map.span_to_snippet(*prev_sp)\n                                     != source_map.span_to_snippet(*abi_span)\n                                 {\n@@ -101,16 +106,19 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                     }\n                     Err(&[]) => {\n-                        self.sess\n+                        self.tcx\n+                            .sess\n                             .struct_span_err(\n                                 *abi_span,\n                                 \"`clobber_abi` is not supported on this target\",\n                             )\n                             .emit();\n                     }\n                     Err(supported_abis) => {\n-                        let mut err =\n-                            self.sess.struct_span_err(*abi_span, \"invalid ABI for `clobber_abi`\");\n+                        let mut err = self\n+                            .tcx\n+                            .sess\n+                            .struct_span_err(*abi_span, \"invalid ABI for `clobber_abi`\");\n                         let mut abis = format!(\"`{}`\", supported_abis[0]);\n                         for m in &supported_abis[1..] {\n                             let _ = write!(abis, \", `{}`\", m);\n@@ -128,7 +136,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Lower operands to HIR. We use dummy register classes if an error\n         // occurs during lowering because we still need to be able to produce a\n         // valid HIR.\n-        let sess = self.sess;\n+        let sess = self.tcx.sess;\n         let mut operands: Vec<_> = asm\n             .operands\n             .iter()\n@@ -184,9 +192,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                     }\n                     InlineAsmOperand::Const { ref anon_const } => {\n-                        if !self.sess.features_untracked().asm_const {\n+                        if !self.tcx.features().asm_const {\n                             feature_err(\n-                                &self.sess.parse_sess,\n+                                &sess.parse_sess,\n                                 sym::asm_const,\n                                 *op_sp,\n                                 \"const operands for inline assembly are unstable\",\n@@ -198,9 +206,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                     }\n                     InlineAsmOperand::Sym { ref sym } => {\n-                        if !self.sess.features_untracked().asm_sym {\n+                        if !self.tcx.features().asm_sym {\n                             feature_err(\n-                                &self.sess.parse_sess,\n+                                &sess.parse_sess,\n                                 sym::asm_sym,\n                                 *op_sp,\n                                 \"sym operands for inline assembly are unstable\","}, {"sha": "9444fffc331c79adbbc8863ca5d8d834c30cdafe", "filename": "compiler/rustc_ast_lowering/src/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -159,9 +159,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             span,\n             kind: hir::ExprKind::If(let_expr, then_expr, Some(else_expr)),\n         });\n-        if !self.sess.features_untracked().let_else {\n+        if !self.tcx.features().let_else {\n             feature_err(\n-                &self.sess.parse_sess,\n+                &self.tcx.sess.parse_sess,\n                 sym::let_else,\n                 local.span,\n                 \"`let...else` statements are unstable\","}, {"sha": "9e02e7ed3b9cf0048e66d07435aa03b0c747e437", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -46,7 +46,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             let hir_id = self.lower_node_id(e.id);\n                             return hir::Expr { hir_id, kind, span: self.lower_span(e.span) };\n                         } else {\n-                            self.sess\n+                            self.tcx.sess\n                                 .struct_span_err(\n                                     e.span,\n                                     \"#[rustc_box] requires precisely one argument \\\n@@ -207,8 +207,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), lims)\n                 }\n                 ExprKind::Underscore => {\n-                    self.sess\n-                        .struct_span_err(\n+                    self.tcx\n+                        .sess.struct_span_err(\n                             e.span,\n                             \"in expressions, `_` can only be used on the left-hand side of an assignment\",\n                         )\n@@ -245,7 +245,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n                         StructRest::Rest(sp) => {\n-                            self.sess\n+                            self.tcx\n+                                .sess\n                                 .struct_span_err(*sp, \"base expression required after `..`\")\n                                 .span_label(*sp, \"add a base expression here\")\n                                 .emit();\n@@ -474,7 +475,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             } else {\n                 let try_span = this.mark_span_with_reason(\n                     DesugaringKind::TryBlock,\n-                    this.sess.source_map().end_point(body.span),\n+                    this.tcx.sess.source_map().end_point(body.span),\n                     this.allow_try_trait.clone(),\n                 );\n \n@@ -653,7 +654,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             Some(hir::GeneratorKind::Async(_)) => {}\n             Some(hir::GeneratorKind::Gen) | None => {\n                 let mut err = struct_span_err!(\n-                    self.sess,\n+                    self.tcx.sess,\n                     dot_await_span,\n                     E0728,\n                     \"`await` is only allowed inside `async` functions and blocks\"\n@@ -878,7 +879,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             Some(hir::GeneratorKind::Gen) => {\n                 if decl.inputs.len() > 1 {\n                     struct_span_err!(\n-                        self.sess,\n+                        self.tcx.sess,\n                         fn_decl_span,\n                         E0628,\n                         \"too many parameters for a generator (expected 0 or 1 parameters)\"\n@@ -892,8 +893,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             None => {\n                 if movability == Movability::Static {\n-                    struct_span_err!(self.sess, fn_decl_span, E0697, \"closures cannot be static\")\n-                        .emit();\n+                    struct_span_err!(\n+                        self.tcx.sess,\n+                        fn_decl_span,\n+                        E0697,\n+                        \"closures cannot be static\"\n+                    )\n+                    .emit();\n                 }\n                 None\n             }\n@@ -916,7 +922,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n             if capture_clause == CaptureBy::Ref && !decl.inputs.is_empty() {\n                 struct_span_err!(\n-                    this.sess,\n+                    this.tcx.sess,\n                     fn_decl_span,\n                     E0708,\n                     \"`async` non-`move` closures with parameters are not currently supported\",\n@@ -1163,7 +1169,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 let fields_omitted = match &se.rest {\n                     StructRest::Base(e) => {\n-                        self.sess\n+                        self.tcx\n+                            .sess\n                             .struct_span_err(\n                                 e.span,\n                                 \"functional record updates are not allowed in destructuring \\\n@@ -1371,7 +1378,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             Some(hir::GeneratorKind::Gen) => {}\n             Some(hir::GeneratorKind::Async(_)) => {\n                 struct_span_err!(\n-                    self.sess,\n+                    self.tcx.sess,\n                     span,\n                     E0727,\n                     \"`async` generators are not yet supported\"\n@@ -1516,7 +1523,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             span,\n             self.allow_try_trait.clone(),\n         );\n-        let try_span = self.sess.source_map().end_point(span);\n+        let try_span = self.tcx.sess.source_map().end_point(span);\n         let try_span = self.mark_span_with_reason(\n             DesugaringKind::QuestionMark,\n             try_span,"}, {"sha": "7da49143b461e2a785038bf64cab2ff490581b83", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -1,7 +1,6 @@\n use super::ResolverAstLoweringExt;\n use super::{AstOwner, ImplTraitContext, ImplTraitPosition};\n-use super::{LoweringContext, ParamMode};\n-use crate::{Arena, FnDeclKind};\n+use super::{FnDeclKind, LoweringContext, ParamMode};\n \n use rustc_ast::ptr::P;\n use rustc_ast::visit::AssocCtxt;\n@@ -12,12 +11,9 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n-use rustc_hir::definitions::Definitions;\n use rustc_hir::PredicateOrigin;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::ty::{ResolverAstLowering, ResolverOutputs};\n-use rustc_session::cstore::CrateStoreDyn;\n-use rustc_session::Session;\n+use rustc_middle::ty::{DefIdTree, ResolverAstLowering, TyCtxt};\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n@@ -27,12 +23,8 @@ use smallvec::{smallvec, SmallVec};\n use std::iter;\n \n pub(super) struct ItemLowerer<'a, 'hir> {\n-    pub(super) sess: &'a Session,\n-    pub(super) definitions: &'a mut Definitions,\n-    pub(super) cstore: &'a CrateStoreDyn,\n-    pub(super) resolutions: &'a ResolverOutputs,\n+    pub(super) tcx: TyCtxt<'hir>,\n     pub(super) resolver: &'a mut ResolverAstLowering,\n-    pub(super) arena: &'hir Arena<'hir>,\n     pub(super) ast_index: &'a IndexVec<LocalDefId, AstOwner<'a>>,\n     pub(super) owners: &'a mut IndexVec<LocalDefId, hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>>>,\n }\n@@ -65,12 +57,9 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n     ) {\n         let mut lctx = LoweringContext {\n             // Pseudo-globals.\n-            sess: &self.sess,\n-            definitions: self.definitions,\n-            cstore: self.cstore,\n-            resolutions: self.resolutions,\n+            tcx: self.tcx,\n             resolver: self.resolver,\n-            arena: self.arena,\n+            arena: self.tcx.hir_arena,\n \n             // HirId handling.\n             bodies: Vec::new(),\n@@ -144,12 +133,7 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n     fn lower_assoc_item(&mut self, item: &AssocItem, ctxt: AssocCtxt) {\n         let def_id = self.resolver.node_id_to_def_id[&item.id];\n \n-        let parent_id = {\n-            let parent = self.definitions.def_key(def_id).parent;\n-            let local_def_index = parent.unwrap();\n-            LocalDefId { local_def_index }\n-        };\n-\n+        let parent_id = self.tcx.local_parent(def_id);\n         let parent_hir = self.lower_node(parent_id).unwrap();\n         self.with_lctx(item.id, |lctx| {\n             // Evaluate with the lifetimes in `params` in-scope.\n@@ -1278,7 +1262,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn error_on_invalid_abi(&self, abi: StrLit) {\n-        struct_span_err!(self.sess, abi.span, E0703, \"invalid ABI: found `{}`\", abi.symbol)\n+        struct_span_err!(self.tcx.sess, abi.span, E0703, \"invalid ABI: found `{}`\", abi.symbol)\n             .span_label(abi.span, \"invalid ABI\")\n             .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n             .emit();"}, {"sha": "2dcbd0782ef72d9adcf6121e76f76916d138aae0", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 88, "deletions": 103, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -49,18 +49,15 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{struct_span_err, Applicability};\n+use rustc_errors::{struct_span_err, Applicability, Handler};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, LifetimeRes, Namespace, PartialRes, PerNS, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n-use rustc_hir::definitions::{DefPathData, Definitions};\n+use rustc_hir::definitions::DefPathData;\n use rustc_hir::{ConstArg, GenericArg, ItemLocalId, ParamName, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::ty::{ResolverAstLowering, ResolverOutputs};\n-use rustc_query_system::ich::StableHashingContext;\n-use rustc_session::cstore::CrateStoreDyn;\n+use rustc_middle::ty::{ResolverAstLowering, TyCtxt};\n use rustc_session::parse::feature_err;\n-use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -83,19 +80,12 @@ mod item;\n mod pat;\n mod path;\n \n-rustc_hir::arena_types!(rustc_arena::declare_arena);\n-\n-struct LoweringContext<'a, 'hir: 'a> {\n-    /// Used to assign IDs to HIR nodes that do not directly correspond to AST nodes.\n-    sess: &'a Session,\n-\n-    definitions: &'a mut Definitions,\n-    cstore: &'a CrateStoreDyn,\n-    resolutions: &'a ResolverOutputs,\n+struct LoweringContext<'a, 'hir> {\n+    tcx: TyCtxt<'hir>,\n     resolver: &'a mut ResolverAstLowering,\n \n     /// Used to allocate HIR nodes.\n-    arena: &'hir Arena<'hir>,\n+    arena: &'hir hir::Arena<'hir>,\n \n     /// Bodies inside the owner being lowered.\n     bodies: Vec<(hir::ItemLocalId, &'hir hir::Body<'hir>)>,\n@@ -391,61 +381,58 @@ fn index_crate<'a>(\n /// Compute the hash for the HIR of the full crate.\n /// This hash will then be part of the crate_hash which is stored in the metadata.\n fn compute_hir_hash(\n-    sess: &Session,\n-    definitions: &Definitions,\n-    cstore: &CrateStoreDyn,\n-    resolver: &ResolverOutputs,\n+    tcx: TyCtxt<'_>,\n     owners: &IndexVec<LocalDefId, hir::MaybeOwner<&hir::OwnerInfo<'_>>>,\n ) -> Fingerprint {\n     let mut hir_body_nodes: Vec<_> = owners\n         .iter_enumerated()\n         .filter_map(|(def_id, info)| {\n             let info = info.as_owner()?;\n-            let def_path_hash = definitions.def_path_hash(def_id);\n+            let def_path_hash = tcx.hir().def_path_hash(def_id);\n             Some((def_path_hash, info))\n         })\n         .collect();\n     hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\n \n-    let mut stable_hasher = StableHasher::new();\n-    let mut hcx = StableHashingContext::new(sess, definitions, cstore, &resolver.source_span);\n-    hir_body_nodes.hash_stable(&mut hcx, &mut stable_hasher);\n-    stable_hasher.finish()\n+    tcx.with_stable_hashing_context(|mut hcx| {\n+        let mut stable_hasher = StableHasher::new();\n+        hir_body_nodes.hash_stable(&mut hcx, &mut stable_hasher);\n+        stable_hasher.finish()\n+    })\n }\n \n-pub fn lower_crate<'hir>(\n-    sess: &Session,\n-    krate: &Crate,\n-    definitions: &mut Definitions,\n-    cstore: &CrateStoreDyn,\n-    resolutions: &ResolverOutputs,\n-    mut resolver: ResolverAstLowering,\n-    arena: &'hir Arena<'hir>,\n-) -> &'hir hir::Crate<'hir> {\n-    let _prof_timer = sess.prof.verbose_generic_activity(\"hir_lowering\");\n+pub fn lower_to_hir<'hir>(tcx: TyCtxt<'hir>, (): ()) -> hir::Crate<'hir> {\n+    let sess = tcx.sess;\n+    let krate = tcx.untracked_crate.steal();\n+    let mut resolver = tcx.resolver_for_lowering(()).steal();\n \n-    let ast_index = index_crate(&resolver.node_id_to_def_id, krate);\n-\n-    let mut owners =\n-        IndexVec::from_fn_n(|_| hir::MaybeOwner::Phantom, definitions.def_index_count());\n+    let ast_index = index_crate(&resolver.node_id_to_def_id, &krate);\n+    let mut owners = IndexVec::from_fn_n(\n+        |_| hir::MaybeOwner::Phantom,\n+        tcx.definitions_untracked().def_index_count(),\n+    );\n \n     for def_id in ast_index.indices() {\n         item::ItemLowerer {\n-            sess,\n-            definitions,\n-            cstore,\n-            resolutions,\n+            tcx,\n             resolver: &mut resolver,\n-            arena,\n             ast_index: &ast_index,\n             owners: &mut owners,\n         }\n         .lower_node(def_id);\n     }\n \n-    let hir_hash = compute_hir_hash(sess, definitions, cstore, resolutions, &owners);\n-    let krate = hir::Crate { owners, hir_hash };\n-    arena.alloc(krate)\n+    // Drop AST to free memory\n+    std::mem::drop(ast_index);\n+    sess.time(\"drop_ast\", || std::mem::drop(krate));\n+\n+    // Discard hygiene data, which isn't required after lowering to HIR.\n+    if !sess.opts.debugging_opts.keep_hygiene_data {\n+        rustc_span::hygiene::clear_syntax_context_map();\n+    }\n+\n+    let hir_hash = compute_hir_hash(tcx, &owners);\n+    hir::Crate { owners, hir_hash }\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -464,38 +451,25 @@ enum ParenthesizedGenericArgs {\n }\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n-    fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n-        StableHashingContext::new(\n-            self.sess,\n-            self.definitions,\n-            self.cstore,\n-            &self.resolutions.source_span,\n-        )\n-    }\n-\n     fn create_def(\n         &mut self,\n         parent: LocalDefId,\n         node_id: ast::NodeId,\n         data: DefPathData,\n     ) -> LocalDefId {\n+        debug_assert_ne!(node_id, ast::DUMMY_NODE_ID);\n         assert!(\n             self.opt_local_def_id(node_id).is_none(),\n             \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n             node_id,\n             data,\n-            self.definitions.def_key(self.local_def_id(node_id)),\n+            self.tcx.hir().def_key(self.local_def_id(node_id)),\n         );\n \n-        let def_id = self.definitions.create_def(parent, data);\n+        let def_id = self.tcx.create_def(parent, data);\n \n-        // Some things for which we allocate `LocalDefId`s don't correspond to\n-        // anything in the AST, so they don't have a `NodeId`. For these cases\n-        // we don't need a mapping from `NodeId` to `LocalDefId`.\n-        if node_id != ast::DUMMY_NODE_ID {\n-            debug!(\"create_def: def_id_to_node_id[{:?}] <-> {:?}\", def_id, node_id);\n-            self.resolver.node_id_to_def_id.insert(node_id, def_id);\n-        }\n+        debug!(\"create_def: def_id_to_node_id[{:?}] <-> {:?}\", def_id, node_id);\n+        self.resolver.node_id_to_def_id.insert(node_id, def_id);\n \n         def_id\n     }\n@@ -515,6 +489,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n     }\n \n+    /// Freshen the `LoweringContext` and ready it to lower a nested item.\n+    /// The lowered item is registered into `self.children`.\n+    ///\n+    /// This function sets up `HirId` lowering infrastructure,\n+    /// and stashes the shared mutable state to avoid pollution by the closure.\n     #[instrument(level = \"debug\", skip(self, f))]\n     fn with_hir_id_owner(\n         &mut self,\n@@ -533,8 +512,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             std::mem::replace(&mut self.item_local_id_counter, hir::ItemLocalId::new(1));\n         let current_impl_trait_defs = std::mem::take(&mut self.impl_trait_defs);\n         let current_impl_trait_bounds = std::mem::take(&mut self.impl_trait_bounds);\n-        // Do not reset `next_node_id` and `node_id_to_def_id` as we want to refer to the\n-        // subdefinitions' nodes.\n+\n+        // Do not reset `next_node_id` and `node_id_to_def_id`:\n+        // we want `f` to be able to refer to the `LocalDefId`s that the caller created.\n+        // and the caller to refer to some of the subdefinitions' nodes' `LocalDefId`s.\n \n         // Always allocate the first `HirId` for the owner itself.\n         let _old = self.node_id_to_local_id.insert(owner, hir::ItemLocalId::new(0));\n@@ -578,7 +559,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         bodies.sort_by_key(|(k, _)| *k);\n         let bodies = SortedMap::from_presorted_elements(bodies);\n         let (hash_including_bodies, hash_without_bodies) = self.hash_owner(node, &bodies);\n-        let (nodes, parenting) = index::index_hir(self.sess, self.definitions, node, &bodies);\n+        let (nodes, parenting) =\n+            index::index_hir(self.tcx.sess, &*self.tcx.definitions_untracked(), node, &bodies);\n         let nodes = hir::OwnerNodes {\n             hash_including_bodies,\n             hash_without_bodies,\n@@ -587,10 +569,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             local_id_to_def_id,\n         };\n         let attrs = {\n-            let mut hcx = self.create_stable_hashing_context();\n-            let mut stable_hasher = StableHasher::new();\n-            attrs.hash_stable(&mut hcx, &mut stable_hasher);\n-            let hash = stable_hasher.finish();\n+            let hash = self.tcx.with_stable_hashing_context(|mut hcx| {\n+                let mut stable_hasher = StableHasher::new();\n+                attrs.hash_stable(&mut hcx, &mut stable_hasher);\n+                stable_hasher.finish()\n+            });\n             hir::AttributeMap { map: attrs, hash }\n         };\n \n@@ -604,18 +587,19 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         node: hir::OwnerNode<'hir>,\n         bodies: &SortedMap<hir::ItemLocalId, &'hir hir::Body<'hir>>,\n     ) -> (Fingerprint, Fingerprint) {\n-        let mut hcx = self.create_stable_hashing_context();\n-        let mut stable_hasher = StableHasher::new();\n-        hcx.with_hir_bodies(true, node.def_id(), bodies, |hcx| {\n-            node.hash_stable(hcx, &mut stable_hasher)\n-        });\n-        let hash_including_bodies = stable_hasher.finish();\n-        let mut stable_hasher = StableHasher::new();\n-        hcx.with_hir_bodies(false, node.def_id(), bodies, |hcx| {\n-            node.hash_stable(hcx, &mut stable_hasher)\n-        });\n-        let hash_without_bodies = stable_hasher.finish();\n-        (hash_including_bodies, hash_without_bodies)\n+        self.tcx.with_stable_hashing_context(|mut hcx| {\n+            let mut stable_hasher = StableHasher::new();\n+            hcx.with_hir_bodies(true, node.def_id(), bodies, |hcx| {\n+                node.hash_stable(hcx, &mut stable_hasher)\n+            });\n+            let hash_including_bodies = stable_hasher.finish();\n+            let mut stable_hasher = StableHasher::new();\n+            hcx.with_hir_bodies(false, node.def_id(), bodies, |hcx| {\n+                node.hash_stable(hcx, &mut stable_hasher)\n+            });\n+            let hash_without_bodies = stable_hasher.finish();\n+            (hash_including_bodies, hash_without_bodies)\n+        })\n     }\n \n     /// This method allocates a new `HirId` for the given `NodeId` and stores it in\n@@ -656,9 +640,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n+    /// Generate a new `HirId` without a backing `NodeId`.\n     fn next_id(&mut self) -> hir::HirId {\n-        let node_id = self.next_node_id();\n-        self.lower_node_id(node_id)\n+        let owner = self.current_hir_id_owner;\n+        let local_id = self.item_local_id_counter;\n+        assert_ne!(local_id, hir::ItemLocalId::new(0));\n+        self.item_local_id_counter.increment_by(1);\n+        hir::HirId { owner, local_id }\n     }\n \n     #[instrument(level = \"trace\", skip(self))]\n@@ -691,8 +679,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.resolver.get_import_res(id).present_items()\n     }\n \n-    fn diagnostic(&self) -> &rustc_errors::Handler {\n-        self.sess.diagnostic()\n+    fn diagnostic(&self) -> &Handler {\n+        self.tcx.sess.diagnostic()\n     }\n \n     /// Reuses the span but adds information like the kind of the desugaring and features that are\n@@ -703,18 +691,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         span: Span,\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     ) -> Span {\n-        span.mark_with_reason(\n-            allow_internal_unstable,\n-            reason,\n-            self.sess.edition(),\n-            self.create_stable_hashing_context(),\n-        )\n+        self.tcx.with_stable_hashing_context(|hcx| {\n+            span.mark_with_reason(allow_internal_unstable, reason, self.tcx.sess.edition(), hcx)\n+        })\n     }\n \n     /// Intercept all spans entering HIR.\n     /// Mark a span as relative to the current owning item.\n     fn lower_span(&self, span: Span) -> Span {\n-        if self.sess.opts.debugging_opts.incremental_relative_spans {\n+        if self.tcx.sess.opts.debugging_opts.incremental_relative_spans {\n             span.with_parent(Some(self.current_hir_id_owner))\n         } else {\n             // Do not make spans relative when not using incremental compilation.\n@@ -1061,7 +1046,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn emit_bad_parenthesized_trait_in_assoc_ty(&self, data: &ParenthesizedArgs) {\n-        let mut err = self.sess.struct_span_err(\n+        let mut err = self.tcx.sess.struct_span_err(\n             data.span,\n             \"parenthesized generic arguments cannot be used in associated type constraints\",\n         );\n@@ -1106,7 +1091,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n             ast::GenericArg::Type(ty) => {\n                 match ty.kind {\n-                    TyKind::Infer if self.sess.features_untracked().generic_arg_infer => {\n+                    TyKind::Infer if self.tcx.features().generic_arg_infer => {\n                         return GenericArg::Infer(hir::InferArg {\n                             hir_id: self.lower_node_id(ty.id),\n                             span: self.lower_span(ty.span),\n@@ -1203,7 +1188,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     } else {\n                         self.next_node_id()\n                     };\n-                    let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n+                    let span = self.tcx.sess.source_map().next_point(t.span.shrink_to_lo());\n                     Lifetime { ident: Ident::new(kw::UnderscoreLifetime, span), id }\n                 });\n                 let lifetime = self.lower_lifetime(&region);\n@@ -1307,7 +1292,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }\n                     ImplTraitContext::Disallowed(position) => {\n                         let mut err = struct_span_err!(\n-                            self.sess,\n+                            self.tcx.sess,\n                             t.span,\n                             E0562,\n                             \"`impl Trait` only allowed in function and inherent method return types, not in {}\",\n@@ -1320,7 +1305,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             TyKind::MacCall(_) => panic!(\"`TyKind::MacCall` should have been expanded by now\"),\n             TyKind::CVarArgs => {\n-                self.sess.delay_span_bug(\n+                self.tcx.sess.delay_span_bug(\n                     t.span,\n                     \"`TyKind::CVarArgs` should have been handled elsewhere\",\n                 );\n@@ -1925,7 +1910,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hir_id,\n             name,\n             span: self.lower_span(param.span()),\n-            pure_wrt_drop: self.sess.contains_name(&param.attrs, sym::may_dangle),\n+            pure_wrt_drop: self.tcx.sess.contains_name(&param.attrs, sym::may_dangle),\n             kind,\n             colon_span: param.colon_span.map(|s| self.lower_span(s)),\n         }\n@@ -2067,11 +2052,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_array_length(&mut self, c: &AnonConst) -> hir::ArrayLen {\n         match c.value.kind {\n             ExprKind::Underscore => {\n-                if self.sess.features_untracked().generic_arg_infer {\n+                if self.tcx.features().generic_arg_infer {\n                     hir::ArrayLen::Infer(self.lower_node_id(c.id), c.value.span)\n                 } else {\n                     feature_err(\n-                        &self.sess.parse_sess,\n+                        &self.tcx.sess.parse_sess,\n                         sym::generic_arg_infer,\n                         c.value.span,\n                         \"using `_` for array lengths is unstable\","}, {"sha": "393be3b454c3787c7630750abb2c1d79369dc1f4", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         // We should've returned in the for loop above.\n \n-        self.sess.diagnostic().span_bug(\n+        self.diagnostic().span_bug(\n             p.span,\n             &format!(\n                 \"lower_qpath: no final extension segment in {}..{}\",\n@@ -193,7 +193,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n                     ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n                     ParenthesizedGenericArgs::Err => {\n-                        let mut err = struct_span_err!(self.sess, data.span, E0214, \"{}\", msg);\n+                        let mut err = struct_span_err!(self.tcx.sess, data.span, E0214, \"{}\", msg);\n                         err.span_label(data.span, \"only `Fn` traits may use parentheses\");\n                         // Suggest replacing parentheses with angle brackets `Trait(params...)` to `Trait<params...>`\n                         if !data.inputs.is_empty() {"}, {"sha": "8fc8118849baef066ba68165e7ddb6dd92229822", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/type_map.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -93,8 +93,9 @@ impl<'tcx> UniqueTypeId<'tcx> {\n     /// Right now this takes the form of a hex-encoded opaque hash value.\n     pub fn generate_unique_id_string(self, tcx: TyCtxt<'tcx>) -> String {\n         let mut hasher = StableHasher::new();\n-        let mut hcx = tcx.create_stable_hashing_context();\n-        hcx.while_hashing_spans(false, |hcx| self.hash_stable(hcx, &mut hasher));\n+        tcx.with_stable_hashing_context(|mut hcx| {\n+            hcx.while_hashing_spans(false, |hcx| self.hash_stable(hcx, &mut hasher))\n+        });\n         hasher.finish::<Fingerprint>().to_hex()\n     }\n "}, {"sha": "8cd5a0fc24759efd8178d138f8a30449539bac29", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -701,16 +701,20 @@ fn push_const_param<'tcx>(tcx: TyCtxt<'tcx>, ct: ty::Const<'tcx>, output: &mut S\n                 // If we cannot evaluate the constant to a known type, we fall back\n                 // to emitting a stable hash value of the constant. This isn't very pretty\n                 // but we get a deterministic, virtually unique value for the constant.\n-                let hcx = &mut tcx.create_stable_hashing_context();\n-                let mut hasher = StableHasher::new();\n-                let ct = ct.eval(tcx, ty::ParamEnv::reveal_all());\n-                hcx.while_hashing_spans(false, |hcx| ct.to_valtree().hash_stable(hcx, &mut hasher));\n+                //\n                 // Let's only emit 64 bits of the hash value. That should be plenty for\n                 // avoiding collisions and will make the emitted type names shorter.\n-                // Note: Don't use `StableHashResult` impl of `u64` here directly, since that\n-                // would lead to endianness problems.\n-                let hash: u128 = hasher.finish();\n-                let hash_short = (hash.to_le() as u64).to_le();\n+                let hash_short = tcx.with_stable_hashing_context(|mut hcx| {\n+                    let mut hasher = StableHasher::new();\n+                    let ct = ct.eval(tcx, ty::ParamEnv::reveal_all());\n+                    hcx.while_hashing_spans(false, |hcx| {\n+                        ct.to_valtree().hash_stable(hcx, &mut hasher)\n+                    });\n+                    // Note: Don't use `StableHashResult` impl of `u64` here directly, since that\n+                    // would lead to endianness problems.\n+                    let hash: u128 = hasher.finish();\n+                    (hash.to_le() as u64).to_le()\n+                });\n \n                 if cpp_like_debuginfo(tcx) {\n                     write!(output, \"CONST${:x}\", hash_short)"}, {"sha": "0a2d2b40709041873c0739f6a51bafe03bba9254", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -10,6 +10,7 @@\n #![feature(array_windows)]\n #![feature(associated_type_bounds)]\n #![feature(auto_traits)]\n+#![feature(cell_leak)]\n #![feature(control_flow_enum)]\n #![feature(extend_one)]\n #![feature(let_else)]"}, {"sha": "cf0940df9e487c66a18b2a3c1b5ee31502824e02", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -539,6 +539,33 @@ impl<T> RwLock<T> {\n     pub fn borrow_mut(&self) -> WriteGuard<'_, T> {\n         self.write()\n     }\n+\n+    #[cfg(not(parallel_compiler))]\n+    #[inline(always)]\n+    pub fn clone_guard<'a>(rg: &ReadGuard<'a, T>) -> ReadGuard<'a, T> {\n+        ReadGuard::clone(rg)\n+    }\n+\n+    #[cfg(parallel_compiler)]\n+    #[inline(always)]\n+    pub fn clone_guard<'a>(rg: &ReadGuard<'a, T>) -> ReadGuard<'a, T> {\n+        ReadGuard::rwlock(&rg).read()\n+    }\n+\n+    #[cfg(not(parallel_compiler))]\n+    #[inline(always)]\n+    pub fn leak(&self) -> &T {\n+        ReadGuard::leak(self.read())\n+    }\n+\n+    #[cfg(parallel_compiler)]\n+    #[inline(always)]\n+    pub fn leak(&self) -> &T {\n+        let guard = self.read();\n+        let ret = unsafe { &*(&*guard as *const T) };\n+        std::mem::forget(guard);\n+        ret\n+    }\n }\n \n // FIXME: Probably a bad idea"}, {"sha": "69ad623b7ea864b3eda089500698fa72cd122236", "filename": "compiler/rustc_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2FCargo.toml?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -7,6 +7,7 @@ edition = \"2021\"\n doctest = false\n \n [dependencies]\n+rustc_arena = { path = \"../rustc_arena\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "a6d10f3adae9f510510e7c69f041f8b756ca242b", "filename": "compiler/rustc_hir/src/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Farena.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -9,7 +9,7 @@ macro_rules! arena_types {\n             // HIR types\n             [] hir_krate: rustc_hir::Crate<'tcx>,\n             [] arm: rustc_hir::Arm<'tcx>,\n-            [] asm_operand: (rustc_hir::InlineAsmOperand<'tcx>, Span),\n+            [] asm_operand: (rustc_hir::InlineAsmOperand<'tcx>, rustc_span::Span),\n             [] asm_template: rustc_ast::InlineAsmTemplatePiece,\n             [] attribute: rustc_ast::Attribute,\n             [] block: rustc_hir::Block<'tcx>,"}, {"sha": "0f9e6fa7b98951648a32d3b3c52515bad42e9218", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -18,6 +18,8 @@ extern crate rustc_macros;\n #[macro_use]\n extern crate rustc_data_structures;\n \n+extern crate self as rustc_hir;\n+\n mod arena;\n pub mod def;\n pub mod def_path_hash_map;\n@@ -41,3 +43,5 @@ pub use hir_id::*;\n pub use lang_items::{LangItem, LanguageItems};\n pub use stable_hash_impls::HashStableContext;\n pub use target::{MethodKind, Target};\n+\n+arena_types!(rustc_arena::declare_arena);"}, {"sha": "b7d1d6edfaa7b5dcf8be794b9ba7ed44ddfd54e4", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 6, "deletions": 47, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -14,7 +14,6 @@ use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan, PResult};\n use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n use rustc_hir::def_id::{StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n-use rustc_hir::Crate;\n use rustc_lint::{EarlyCheckNode, LintStore};\n use rustc_metadata::creader::CStore;\n use rustc_metadata::{encode_metadata, EncodedMetadata};\n@@ -482,37 +481,6 @@ pub fn configure_and_expand(\n     Ok(krate)\n }\n \n-fn lower_to_hir<'tcx>(\n-    sess: &Session,\n-    definitions: &mut Definitions,\n-    cstore: &CrateStoreDyn,\n-    resolutions: &ty::ResolverOutputs,\n-    resolver: ty::ResolverAstLowering,\n-    krate: Rc<ast::Crate>,\n-    arena: &'tcx rustc_ast_lowering::Arena<'tcx>,\n-) -> &'tcx Crate<'tcx> {\n-    // Lower AST to HIR.\n-    let hir_crate = rustc_ast_lowering::lower_crate(\n-        sess,\n-        &krate,\n-        definitions,\n-        cstore,\n-        resolutions,\n-        resolver,\n-        arena,\n-    );\n-\n-    // Drop AST to free memory\n-    sess.time(\"drop_ast\", || std::mem::drop(krate));\n-\n-    // Discard hygiene data, which isn't required after lowering to HIR.\n-    if !sess.opts.debugging_opts.keep_hygiene_data {\n-        rustc_span::hygiene::clear_syntax_context_map();\n-    }\n-\n-    hir_crate\n-}\n-\n // Returns all the paths that correspond to generated files.\n fn generated_output_paths(\n     sess: &Session,\n@@ -777,6 +745,7 @@ pub fn prepare_outputs(\n pub static DEFAULT_QUERY_PROVIDERS: LazyLock<Providers> = LazyLock::new(|| {\n     let providers = &mut Providers::default();\n     providers.analysis = analysis;\n+    providers.hir_crate = rustc_ast_lowering::lower_to_hir;\n     proc_macro_decls::provide(providers);\n     rustc_const_eval::provide(providers);\n     rustc_middle::hir::provide(providers);\n@@ -823,37 +792,25 @@ impl<'tcx> QueryContext<'tcx> {\n pub fn create_global_ctxt<'tcx>(\n     compiler: &'tcx Compiler,\n     lint_store: Lrc<LintStore>,\n-    krate: Rc<ast::Crate>,\n+    krate: Lrc<ast::Crate>,\n     dep_graph: DepGraph,\n     resolver: Rc<RefCell<BoxedResolver>>,\n     outputs: OutputFilenames,\n     crate_name: &str,\n     queries: &'tcx OnceCell<TcxQueries<'tcx>>,\n     global_ctxt: &'tcx OnceCell<GlobalCtxt<'tcx>>,\n     arena: &'tcx WorkerLocal<Arena<'tcx>>,\n-    hir_arena: &'tcx WorkerLocal<rustc_ast_lowering::Arena<'tcx>>,\n+    hir_arena: &'tcx WorkerLocal<rustc_hir::Arena<'tcx>>,\n ) -> QueryContext<'tcx> {\n     // We're constructing the HIR here; we don't care what we will\n     // read, since we haven't even constructed the *input* to\n     // incr. comp. yet.\n     dep_graph.assert_ignored();\n \n-    let (mut definitions, cstore, resolver_outputs, resolver_for_lowering) =\n+    let (definitions, cstore, resolver_outputs, resolver_for_lowering) =\n         BoxedResolver::to_resolver_outputs(resolver);\n \n     let sess = &compiler.session();\n-\n-    // Lower AST to HIR.\n-    let krate = lower_to_hir(\n-        sess,\n-        &mut definitions,\n-        &*cstore,\n-        &resolver_outputs,\n-        resolver_for_lowering,\n-        krate,\n-        hir_arena,\n-    );\n-\n     let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n \n     let codegen_backend = compiler.codegen_backend();\n@@ -877,9 +834,11 @@ pub fn create_global_ctxt<'tcx>(\n                 sess,\n                 lint_store,\n                 arena,\n+                hir_arena,\n                 definitions,\n                 cstore,\n                 resolver_outputs,\n+                resolver_for_lowering,\n                 krate,\n                 dep_graph,\n                 queries.on_disk_cache.as_ref().map(OnDiskCache::as_dyn),"}, {"sha": "8ffb1ad05399427d5f866b813d741965db17bacc", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -72,13 +72,13 @@ pub struct Queries<'tcx> {\n     queries: OnceCell<TcxQueries<'tcx>>,\n \n     arena: WorkerLocal<Arena<'tcx>>,\n-    hir_arena: WorkerLocal<rustc_ast_lowering::Arena<'tcx>>,\n+    hir_arena: WorkerLocal<rustc_hir::Arena<'tcx>>,\n \n     dep_graph_future: Query<Option<DepGraphFuture>>,\n     parse: Query<ast::Crate>,\n     crate_name: Query<String>,\n     register_plugins: Query<(ast::Crate, Lrc<LintStore>)>,\n-    expansion: Query<(Rc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>,\n+    expansion: Query<(Lrc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n     prepare_outputs: Query<OutputFilenames>,\n     global_ctxt: Query<QueryContext<'tcx>>,\n@@ -92,7 +92,7 @@ impl<'tcx> Queries<'tcx> {\n             gcx: OnceCell::new(),\n             queries: OnceCell::new(),\n             arena: WorkerLocal::new(|_| Arena::default()),\n-            hir_arena: WorkerLocal::new(|_| rustc_ast_lowering::Arena::default()),\n+            hir_arena: WorkerLocal::new(|_| rustc_hir::Arena::default()),\n             dep_graph_future: Default::default(),\n             parse: Default::default(),\n             crate_name: Default::default(),\n@@ -164,7 +164,7 @@ impl<'tcx> Queries<'tcx> {\n \n     pub fn expansion(\n         &self,\n-    ) -> Result<&Query<(Rc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>> {\n+    ) -> Result<&Query<(Lrc<ast::Crate>, Rc<RefCell<BoxedResolver>>, Lrc<LintStore>)>> {\n         tracing::trace!(\"expansion\");\n         self.expansion.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n@@ -180,7 +180,7 @@ impl<'tcx> Queries<'tcx> {\n             let krate = resolver.access(|resolver| {\n                 passes::configure_and_expand(sess, &lint_store, krate, &crate_name, resolver)\n             })?;\n-            Ok((Rc::new(krate), Rc::new(RefCell::new(resolver)), lint_store))\n+            Ok((Lrc::new(krate), Rc::new(RefCell::new(resolver)), lint_store))\n         })\n     }\n "}, {"sha": "27f67207209dd81cc275b3f1cb9a7e0bac5c5860", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -34,7 +34,7 @@ use tracing::debug;\n \n /// Extract the `LintStore` from the query context.\n /// This function exists because we've erased `LintStore` as `dyn Any` in the context.\n-pub(crate) fn unerased_lint_store(tcx: TyCtxt<'_>) -> &LintStore {\n+pub fn unerased_lint_store(tcx: TyCtxt<'_>) -> &LintStore {\n     let store: &dyn Any = &*tcx.lint_store;\n     store.downcast_ref().unwrap()\n }"}, {"sha": "aaee0caa070e72d83816116aa6aa590282617f4c", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -99,7 +99,7 @@ pub use builtin::SoftLints;\n pub use context::{CheckLintNameResult, FindLintError, LintStore};\n pub use context::{EarlyContext, LateContext, LintContext};\n pub use early::{check_ast_node, EarlyCheckNode};\n-pub use late::check_crate;\n+pub use late::{check_crate, unerased_lint_store};\n pub use passes::{EarlyLintPass, LateLintPass};\n pub use rustc_session::lint::Level::{self, *};\n pub use rustc_session::lint::{BufferedEarlyLint, FutureIncompatibleInfo, Lint, LintId};"}, {"sha": "7e07898ff52f1d5f58c227fdf5eb0aae303b78aa", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -423,7 +423,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_def_path_table(&mut self) {\n-        let table = self.tcx.definitions_untracked().def_path_table();\n+        let table = self.tcx.def_path_table();\n         if self.is_proc_macro {\n             for def_index in std::iter::once(CRATE_DEF_INDEX)\n                 .chain(self.tcx.resolutions(()).proc_macros.iter().map(|p| p.local_def_index))\n@@ -443,9 +443,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_def_path_hash_map(&mut self) -> LazyValue<DefPathHashMapRef<'static>> {\n-        self.lazy(DefPathHashMapRef::BorrowedFromTcx(\n-            self.tcx.definitions_untracked().def_path_hash_to_def_index_map(),\n-        ))\n+        self.lazy(DefPathHashMapRef::BorrowedFromTcx(self.tcx.def_path_hash_to_def_index_map()))\n     }\n \n     fn encode_source_map(&mut self) -> LazyArray<rustc_span::SourceFile> {\n@@ -614,7 +612,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let interpret_alloc_index_bytes = self.position() - i;\n \n         // Encode the proc macro data. This affects 'tables',\n-        // so we need to do this before we encode the tables\n+        // so we need to do this before we encode the tables.\n+        // This overwrites def_keys, so it must happen after encode_def_path_table.\n         i = self.position();\n         let proc_macro_data = self.encode_proc_macros();\n         let proc_macro_data_bytes = self.position() - i;\n@@ -992,8 +991,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             return;\n         }\n         let tcx = self.tcx;\n-        let hir = tcx.hir();\n-        for local_id in hir.iter_local_def_id() {\n+        for local_id in tcx.iter_local_def_id() {\n             let def_id = local_id.to_def_id();\n             let def_kind = tcx.opt_def_kind(local_id);\n             let Some(def_kind) = def_kind else { continue };\n@@ -1854,12 +1852,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         debug!(\"EncodeContext::encode_traits_and_impls()\");\n         empty_proc_macro!(self);\n         let tcx = self.tcx;\n-        let mut ctx = tcx.create_stable_hashing_context();\n         let mut all_impls: Vec<_> = tcx.crate_inherent_impls(()).incoherent_impls.iter().collect();\n-        all_impls.sort_by_cached_key(|&(&simp, _)| {\n-            let mut hasher = StableHasher::new();\n-            simp.hash_stable(&mut ctx, &mut hasher);\n-            hasher.finish::<Fingerprint>();\n+        tcx.with_stable_hashing_context(|mut ctx| {\n+            all_impls.sort_by_cached_key(|&(&simp, _)| {\n+                let mut hasher = StableHasher::new();\n+                simp.hash_stable(&mut ctx, &mut hasher);\n+                hasher.finish::<Fingerprint>()\n+            })\n         });\n         let all_impls: Vec<_> = all_impls\n             .into_iter()"}, {"sha": "2d095438fc4e9fcd5bf0c24500a4420eb7395599", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -183,6 +183,9 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     // We use this for most things when incr. comp. is turned off.\n     [] Null,\n \n+    // We use this to create a forever-red node.\n+    [] Red,\n+\n     [anon] TraitSelect,\n \n     // WARNING: if `Symbol` is changed, make sure you update `make_compile_codegen_unit` below."}, {"sha": "c8b3b52b0fb2bd7d6467f626f173dc494d76fbb7", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -23,6 +23,7 @@ pub type EdgeFilter = rustc_query_system::dep_graph::debug::EdgeFilter<DepKind>;\n \n impl rustc_query_system::dep_graph::DepKind for DepKind {\n     const NULL: Self = DepKind::Null;\n+    const RED: Self = DepKind::Red;\n \n     fn debug_node(node: &DepNode, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         write!(f, \"{:?}(\", node.kind)?;\n@@ -71,8 +72,8 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n     type DepKind = DepKind;\n \n     #[inline]\n-    fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n-        TyCtxt::create_stable_hashing_context(*self)\n+    fn with_stable_hashing_context<R>(&self, f: impl FnOnce(StableHashingContext<'_>) -> R) -> R {\n+        TyCtxt::with_stable_hashing_context(*self, f)\n     }\n \n     #[inline]"}, {"sha": "0624832019887b9e4e9863b2eb715866604b65b9", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -218,13 +218,6 @@ impl<'hir> Map<'hir> {\n         self.tcx.local_def_id_to_hir_id(def_id)\n     }\n \n-    pub fn iter_local_def_id(self) -> impl Iterator<Item = LocalDefId> + 'hir {\n-        // Create a dependency to the crate to be sure we re-execute this when the amount of\n-        // definitions change.\n-        self.tcx.ensure().hir_crate(());\n-        self.tcx.definitions_untracked().iter_local_def_id()\n-    }\n-\n     /// Do not call this function directly. The query should be called.\n     pub(super) fn opt_def_kind(self, local_def_id: LocalDefId) -> Option<DefKind> {\n         let hir_id = self.local_def_id_to_hir_id(local_def_id);\n@@ -1142,34 +1135,35 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n \n     source_file_names.sort_unstable();\n \n-    let mut hcx = tcx.create_stable_hashing_context();\n-    let mut stable_hasher = StableHasher::new();\n-    hir_body_hash.hash_stable(&mut hcx, &mut stable_hasher);\n-    upstream_crates.hash_stable(&mut hcx, &mut stable_hasher);\n-    source_file_names.hash_stable(&mut hcx, &mut stable_hasher);\n-    if tcx.sess.opts.debugging_opts.incremental_relative_spans {\n-        let definitions = &tcx.definitions_untracked();\n-        let mut owner_spans: Vec<_> = krate\n-            .owners\n-            .iter_enumerated()\n-            .filter_map(|(def_id, info)| {\n-                let _ = info.as_owner()?;\n-                let def_path_hash = definitions.def_path_hash(def_id);\n-                let span = resolutions.source_span[def_id];\n-                debug_assert_eq!(span.parent(), None);\n-                Some((def_path_hash, span))\n-            })\n-            .collect();\n-        owner_spans.sort_unstable_by_key(|bn| bn.0);\n-        owner_spans.hash_stable(&mut hcx, &mut stable_hasher);\n-    }\n-    tcx.sess.opts.dep_tracking_hash(true).hash_stable(&mut hcx, &mut stable_hasher);\n-    tcx.sess.local_stable_crate_id().hash_stable(&mut hcx, &mut stable_hasher);\n-    // Hash visibility information since it does not appear in HIR.\n-    resolutions.visibilities.hash_stable(&mut hcx, &mut stable_hasher);\n-    resolutions.has_pub_restricted.hash_stable(&mut hcx, &mut stable_hasher);\n+    let crate_hash: Fingerprint = tcx.with_stable_hashing_context(|mut hcx| {\n+        let mut stable_hasher = StableHasher::new();\n+        hir_body_hash.hash_stable(&mut hcx, &mut stable_hasher);\n+        upstream_crates.hash_stable(&mut hcx, &mut stable_hasher);\n+        source_file_names.hash_stable(&mut hcx, &mut stable_hasher);\n+        if tcx.sess.opts.debugging_opts.incremental_relative_spans {\n+            let definitions = tcx.definitions_untracked();\n+            let mut owner_spans: Vec<_> = krate\n+                .owners\n+                .iter_enumerated()\n+                .filter_map(|(def_id, info)| {\n+                    let _ = info.as_owner()?;\n+                    let def_path_hash = definitions.def_path_hash(def_id);\n+                    let span = resolutions.source_span[def_id];\n+                    debug_assert_eq!(span.parent(), None);\n+                    Some((def_path_hash, span))\n+                })\n+                .collect();\n+            owner_spans.sort_unstable_by_key(|bn| bn.0);\n+            owner_spans.hash_stable(&mut hcx, &mut stable_hasher);\n+        }\n+        tcx.sess.opts.dep_tracking_hash(true).hash_stable(&mut hcx, &mut stable_hasher);\n+        tcx.sess.local_stable_crate_id().hash_stable(&mut hcx, &mut stable_hasher);\n+        // Hash visibility information since it does not appear in HIR.\n+        resolutions.visibilities.hash_stable(&mut hcx, &mut stable_hasher);\n+        resolutions.has_pub_restricted.hash_stable(&mut hcx, &mut stable_hasher);\n+        stable_hasher.finish()\n+    });\n \n-    let crate_hash: Fingerprint = stable_hasher.finish();\n     Svh::new(crate_hash.to_smaller_hash())\n }\n "}, {"sha": "070a063c881e6128813cf69fa40b89bb0230a3fb", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -111,7 +111,6 @@ pub fn provide(providers: &mut Providers) {\n         let hir = tcx.hir();\n         hir.get_module_parent_node(hir.local_def_id_to_hir_id(id))\n     };\n-    providers.hir_crate = |tcx, ()| tcx.untracked_crate;\n     providers.hir_crate_items = map::hir_crate_items;\n     providers.crate_hash = map::crate_hash;\n     providers.hir_module_items = map::hir_module_items;"}, {"sha": "cbc45526e89fbc2d8b2f6229e1ffabb9954973e6", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -26,6 +26,12 @@ rustc_queries! {\n         desc { \"get the resolver outputs\" }\n     }\n \n+    query resolver_for_lowering(_: ()) -> &'tcx Steal<ty::ResolverAstLowering> {\n+        eval_always\n+        no_hash\n+        desc { \"get the resolver for lowering\" }\n+    }\n+\n     /// Return the span for a definition.\n     /// Contrary to `def_span` below, this query returns the full absolute span of the definition.\n     /// This span is meant for dep-tracking rather than diagnostics. It should not be used outside\n@@ -40,7 +46,8 @@ rustc_queries! {\n     /// This is because the `hir_crate` query gives you access to all other items.\n     /// To avoid this fate, do not call `tcx.hir().krate()`; instead,\n     /// prefer wrappers like `tcx.visit_all_items_in_krate()`.\n-    query hir_crate(key: ()) -> &'tcx Crate<'tcx> {\n+    query hir_crate(key: ()) -> Crate<'tcx> {\n+        storage(ArenaCacheSelector<'tcx>)\n         eval_always\n         desc { \"get the crate HIR\" }\n     }"}, {"sha": "a594dab2e20a30c00244f871c15504a6762a0a8d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 93, "deletions": 30, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -32,12 +32,13 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n-use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n+use rustc_data_structures::sync::{self, Lock, Lrc, ReadGuard, RwLock, WorkerLocal};\n use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{DecorateLint, ErrorGuaranteed, LintDiagnosticBuilder, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::definitions::Definitions;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{\n@@ -1045,6 +1046,7 @@ impl<'tcx> Deref for TyCtxt<'tcx> {\n \n pub struct GlobalCtxt<'tcx> {\n     pub arena: &'tcx WorkerLocal<Arena<'tcx>>,\n+    pub hir_arena: &'tcx WorkerLocal<hir::Arena<'tcx>>,\n \n     interners: CtxtInterners<'tcx>,\n \n@@ -1069,13 +1071,15 @@ pub struct GlobalCtxt<'tcx> {\n     /// Common consts, pre-interned for your convenience.\n     pub consts: CommonConsts<'tcx>,\n \n-    definitions: rustc_hir::definitions::Definitions,\n+    definitions: RwLock<Definitions>,\n     cstore: Box<CrateStoreDyn>,\n \n     /// Output of the resolver.\n     pub(crate) untracked_resolutions: ty::ResolverOutputs,\n-\n-    pub(crate) untracked_crate: &'tcx hir::Crate<'tcx>,\n+    untracked_resolver_for_lowering: Steal<ty::ResolverAstLowering>,\n+    /// The entire crate as AST. This field serves as the input for the hir_crate query,\n+    /// which lowers it from AST to HIR. It must not be read or used by anything else.\n+    pub untracked_crate: Steal<Lrc<ast::Crate>>,\n \n     /// This provides access to the incremental compilation on-disk cache for query results.\n     /// Do not access this directly. It is only meant to be used by\n@@ -1233,10 +1237,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         s: &'tcx Session,\n         lint_store: Lrc<dyn Any + sync::Send + sync::Sync>,\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n-        definitions: rustc_hir::definitions::Definitions,\n+        hir_arena: &'tcx WorkerLocal<hir::Arena<'tcx>>,\n+        definitions: Definitions,\n         cstore: Box<CrateStoreDyn>,\n         untracked_resolutions: ty::ResolverOutputs,\n-        krate: &'tcx hir::Crate<'tcx>,\n+        untracked_resolver_for_lowering: ty::ResolverAstLowering,\n+        krate: Lrc<ast::Crate>,\n         dep_graph: DepGraph,\n         on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n         queries: &'tcx dyn query::QueryEngine<'tcx>,\n@@ -1263,16 +1269,18 @@ impl<'tcx> TyCtxt<'tcx> {\n             sess: s,\n             lint_store,\n             arena,\n+            hir_arena,\n             interners,\n             dep_graph,\n-            definitions,\n+            definitions: RwLock::new(definitions),\n             cstore,\n-            untracked_resolutions,\n             prof: s.prof.clone(),\n             types: common_types,\n             lifetimes: common_lifetimes,\n             consts: common_consts,\n-            untracked_crate: krate,\n+            untracked_resolutions,\n+            untracked_resolver_for_lowering: Steal::new(untracked_resolver_for_lowering),\n+            untracked_crate: Steal::new(krate),\n             on_disk_cache,\n             queries,\n             query_caches: query::QueryCaches::default(),\n@@ -1368,7 +1376,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn def_key(self, id: DefId) -> rustc_hir::definitions::DefKey {\n         // Accessing the DefKey is ok, since it is part of DefPathHash.\n         if let Some(id) = id.as_local() {\n-            self.definitions.def_key(id)\n+            self.definitions_untracked().def_key(id)\n         } else {\n             self.cstore.def_key(id)\n         }\n@@ -1382,7 +1390,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn def_path(self, id: DefId) -> rustc_hir::definitions::DefPath {\n         // Accessing the DefPath is ok, since it is part of DefPathHash.\n         if let Some(id) = id.as_local() {\n-            self.definitions.def_path(id)\n+            self.definitions_untracked().def_path(id)\n         } else {\n             self.cstore.def_path(id)\n         }\n@@ -1392,7 +1400,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn def_path_hash(self, def_id: DefId) -> rustc_hir::definitions::DefPathHash {\n         // Accessing the DefPathHash is ok, it is incr. comp. stable.\n         if let Some(def_id) = def_id.as_local() {\n-            self.definitions.def_path_hash(def_id)\n+            self.definitions_untracked().def_path_hash(def_id)\n         } else {\n             self.cstore.def_path_hash(def_id)\n         }\n@@ -1429,7 +1437,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // If this is a DefPathHash from the local crate, we can look up the\n         // DefId in the tcx's `Definitions`.\n         if stable_crate_id == self.sess.local_stable_crate_id() {\n-            self.definitions.local_def_path_hash_to_def_id(hash, err).to_def_id()\n+            self.definitions.read().local_def_path_hash_to_def_id(hash, err).to_def_id()\n         } else {\n             // If this is a DefPathHash from an upstream crate, let the CrateStore map\n             // it to a DefId.\n@@ -1460,6 +1468,64 @@ impl<'tcx> TyCtxt<'tcx> {\n         )\n     }\n \n+    /// Create a new definition within the incr. comp. engine.\n+    pub fn create_def(self, parent: LocalDefId, data: hir::definitions::DefPathData) -> LocalDefId {\n+        // This function modifies `self.definitions` using a side-effect.\n+        // We need to ensure that these side effects are re-run by the incr. comp. engine.\n+        // Depending on the forever-red node will tell the graph that the calling query\n+        // needs to be re-evaluated.\n+        use rustc_query_system::dep_graph::DepNodeIndex;\n+        self.dep_graph.read_index(DepNodeIndex::FOREVER_RED_NODE);\n+\n+        // The following call has the side effect of modifying the tables inside `definitions`.\n+        // These very tables are relied on by the incr. comp. engine to decode DepNodes and to\n+        // decode the on-disk cache.\n+        //\n+        // Any LocalDefId which is used within queries, either as key or result, either:\n+        // - has been created before the construction of the TyCtxt;\n+        // - has been created by this call to `create_def`.\n+        // As a consequence, this LocalDefId is always re-created before it is needed by the incr.\n+        // comp. engine itself.\n+        //\n+        // This call also writes to the value of `source_span` and `expn_that_defined` queries.\n+        // This is fine because:\n+        // - those queries are `eval_always` so we won't miss their result changing;\n+        // - this write will have happened before these queries are called.\n+        self.definitions.write().create_def(parent, data)\n+    }\n+\n+    pub fn iter_local_def_id(self) -> impl Iterator<Item = LocalDefId> + 'tcx {\n+        // Create a dependency to the crate to be sure we re-execute this when the amount of\n+        // definitions change.\n+        self.ensure().hir_crate(());\n+        // Leak a read lock once we start iterating on definitions, to prevent adding new onces\n+        // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n+        let definitions = self.definitions.leak();\n+        definitions.iter_local_def_id()\n+    }\n+\n+    pub fn def_path_table(self) -> &'tcx rustc_hir::definitions::DefPathTable {\n+        // Create a dependency to the crate to be sure we reexcute this when the amount of\n+        // definitions change.\n+        self.ensure().hir_crate(());\n+        // Leak a read lock once we start iterating on definitions, to prevent adding new onces\n+        // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n+        let definitions = self.definitions.leak();\n+        definitions.def_path_table()\n+    }\n+\n+    pub fn def_path_hash_to_def_index_map(\n+        self,\n+    ) -> &'tcx rustc_hir::def_path_hash_map::DefPathHashMap {\n+        // Create a dependency to the crate to be sure we reexcute this when the amount of\n+        // definitions change.\n+        self.ensure().hir_crate(());\n+        // Leak a read lock once we start iterating on definitions, to prevent adding new onces\n+        // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n+        let definitions = self.definitions.leak();\n+        definitions.def_path_hash_to_def_index_map()\n+    }\n+\n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n     pub fn cstore_untracked(self) -> &'tcx CrateStoreDyn {\n@@ -1468,8 +1534,9 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n-    pub fn definitions_untracked(self) -> &'tcx hir::definitions::Definitions {\n-        &self.definitions\n+    #[inline]\n+    pub fn definitions_untracked(self) -> ReadGuard<'tcx, Definitions> {\n+        self.definitions.read()\n     }\n \n     /// Note that this is *untracked* and should only be used within the query\n@@ -1480,23 +1547,18 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline(always)]\n-    pub fn create_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n-        StableHashingContext::new(\n-            self.sess,\n-            &self.definitions,\n-            &*self.cstore,\n-            &self.untracked_resolutions.source_span,\n-        )\n-    }\n-\n-    #[inline(always)]\n-    pub fn create_no_span_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n-        StableHashingContext::ignore_spans(\n+    pub fn with_stable_hashing_context<R>(\n+        self,\n+        f: impl FnOnce(StableHashingContext<'_>) -> R,\n+    ) -> R {\n+        let definitions = self.definitions_untracked();\n+        let hcx = StableHashingContext::new(\n             self.sess,\n-            &self.definitions,\n+            &*definitions,\n             &*self.cstore,\n             &self.untracked_resolutions.source_span,\n-        )\n+        );\n+        f(hcx)\n     }\n \n     pub fn serialize_query_result_cache(self, encoder: FileEncoder) -> FileEncodeResult {\n@@ -2304,7 +2366,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.interners.intern_ty(\n             st,\n             self.sess,\n-            &self.definitions,\n+            &self.definitions.read(),\n             &*self.cstore,\n             // This is only used to create a stable hashing context.\n             &self.untracked_resolutions.source_span,\n@@ -2922,6 +2984,7 @@ fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {\n \n pub fn provide(providers: &mut ty::query::Providers) {\n     providers.resolutions = |tcx, ()| &tcx.untracked_resolutions;\n+    providers.resolver_for_lowering = |tcx, ()| &tcx.untracked_resolver_for_lowering;\n     providers.module_reexports =\n         |tcx, id| tcx.resolutions(()).reexport_map.get(&id).map(|v| &v[..]);\n     providers.crate_name = |tcx, id| {"}, {"sha": "0e581d7f1f7edf3caf17e38cb2adae313e532900", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -142,16 +142,16 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Creates a hash of the type `Ty` which will be the same no matter what crate\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n     pub fn type_id_hash(self, ty: Ty<'tcx>) -> u64 {\n-        let mut hasher = StableHasher::new();\n-        let mut hcx = self.create_stable_hashing_context();\n-\n         // We want the type_id be independent of the types free regions, so we\n         // erase them. The erase_regions() call will also anonymize bound\n         // regions, which is desirable too.\n         let ty = self.erase_regions(ty);\n \n-        hcx.while_hashing_spans(false, |hcx| ty.hash_stable(hcx, &mut hasher));\n-        hasher.finish()\n+        self.with_stable_hashing_context(|mut hcx| {\n+            let mut hasher = StableHasher::new();\n+            hcx.while_hashing_spans(false, |hcx| ty.hash_stable(hcx, &mut hasher));\n+            hasher.finish()\n+        })\n     }\n \n     pub fn res_generics_def_id(self, res: Res) -> Option<DefId> {"}, {"sha": "88ad5b7ef148227bf151995bc6faf5c5f1a6e644", "filename": "compiler/rustc_mir_transform/src/coverage/mod.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -15,7 +15,6 @@ use spans::{CoverageSpan, CoverageSpans};\n use crate::MirPass;\n \n use rustc_data_structures::graph::WithNumNodes;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_index::vec::IndexVec;\n use rustc_middle::hir;\n@@ -576,12 +575,6 @@ fn get_body_span<'tcx>(\n \n fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, hir_body: &'tcx rustc_hir::Body<'tcx>) -> u64 {\n     // FIXME(cjgillot) Stop hashing HIR manually here.\n-    let mut hcx = tcx.create_no_span_stable_hashing_context();\n-    let mut stable_hasher = StableHasher::new();\n     let owner = hir_body.id().hir_id.owner;\n-    let bodies = &tcx.hir_owner_nodes(owner).unwrap().bodies;\n-    hcx.with_hir_bodies(false, owner, bodies, |hcx| {\n-        hir_body.value.hash_stable(hcx, &mut stable_hasher)\n-    });\n-    stable_hasher.finish()\n+    tcx.hir_owner_nodes(owner).unwrap().hash_including_bodies.to_smaller_hash()\n }"}, {"sha": "8f049a182eeaf593ec4af7a09343f3d0ec2cfec9", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -588,7 +588,7 @@ impl<'tcx> Inliner<'tcx> {\n                 );\n                 expn_data.def_site = callee_body.span;\n                 let expn_data =\n-                    LocalExpnId::fresh(expn_data, self.tcx.create_stable_hashing_context());\n+                    self.tcx.with_stable_hashing_context(|hcx| LocalExpnId::fresh(expn_data, hcx));\n                 let mut integrator = Integrator {\n                     args: &args,\n                     new_locals: Local::new(caller_body.local_decls.len())..,"}, {"sha": "4c25075327f0149af69fab7e6183b0ceae85a552", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -653,12 +653,11 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for ExpnId {\n             #[cfg(debug_assertions)]\n             {\n                 use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-                let mut hcx = decoder.tcx.create_stable_hashing_context();\n-                let mut hasher = StableHasher::new();\n-                hcx.while_hashing_spans(true, |hcx| {\n-                    expn_id.expn_data().hash_stable(hcx, &mut hasher)\n+                let local_hash: u64 = decoder.tcx.with_stable_hashing_context(|mut hcx| {\n+                    let mut hasher = StableHasher::new();\n+                    expn_id.expn_data().hash_stable(&mut hcx, &mut hasher);\n+                    hasher.finish()\n                 });\n-                let local_hash: u64 = hasher.finish();\n                 debug_assert_eq!(hash.local_hash(), local_hash);\n             }\n "}, {"sha": "333dc5aa668b02639020b5694bdd56476cfc6118", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -291,11 +291,12 @@ macro_rules! define_queries {\n                         .and_then(|def_id| tcx.opt_def_kind(def_id))\n                 };\n                 let hash = || {\n-                    let mut hcx = tcx.create_stable_hashing_context();\n-                    let mut hasher = StableHasher::new();\n-                    std::mem::discriminant(&kind).hash_stable(&mut hcx, &mut hasher);\n-                    key.hash_stable(&mut hcx, &mut hasher);\n-                    hasher.finish::<u64>()\n+                    tcx.with_stable_hashing_context(|mut hcx|{\n+                        let mut hasher = StableHasher::new();\n+                        std::mem::discriminant(&kind).hash_stable(&mut hcx, &mut hasher);\n+                        key.hash_stable(&mut hcx, &mut hasher);\n+                        hasher.finish::<u64>()\n+                    })\n                 };\n \n                 QueryStackFrame::new(name, description, span, def_kind, hash)\n@@ -376,6 +377,17 @@ macro_rules! define_queries {\n                 }\n             }\n \n+            // We use this for the forever-red node.\n+            pub fn Red() -> DepKindStruct {\n+                DepKindStruct {\n+                    is_anon: false,\n+                    is_eval_always: false,\n+                    fingerprint_style: FingerprintStyle::Unit,\n+                    force_from_dep_node: Some(|_, dep_node| bug!(\"force_from_dep_node: encountered {:?}\", dep_node)),\n+                    try_load_from_on_disk_cache: None,\n+                }\n+            }\n+\n             pub fn TraitSelect() -> DepKindStruct {\n                 DepKindStruct {\n                     is_anon: true,"}, {"sha": "c6210095b60fc0153ce9c79a8eb5b9c48b81cdfd", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -131,12 +131,11 @@ where\n \n     #[inline(always)]\n     default fn to_fingerprint(&self, tcx: Ctxt) -> Fingerprint {\n-        let mut hcx = tcx.create_stable_hashing_context();\n-        let mut hasher = StableHasher::new();\n-\n-        self.hash_stable(&mut hcx, &mut hasher);\n-\n-        hasher.finish()\n+        tcx.with_stable_hashing_context(|mut hcx| {\n+            let mut hasher = StableHasher::new();\n+            self.hash_stable(&mut hcx, &mut hasher);\n+            hasher.finish()\n+        })\n     }\n \n     #[inline(always)]"}, {"sha": "0da42fddd4c1e15e1a44f0f2d3451927d113238d", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -43,6 +43,7 @@ rustc_index::newtype_index! {\n impl DepNodeIndex {\n     pub const INVALID: DepNodeIndex = DepNodeIndex::MAX;\n     pub const SINGLETON_DEPENDENCYLESS_ANON_NODE: DepNodeIndex = DepNodeIndex::from_u32(0);\n+    pub const FOREVER_RED_NODE: DepNodeIndex = DepNodeIndex::from_u32(1);\n }\n \n impl std::convert::From<DepNodeIndex> for QueryInvocationId {\n@@ -124,14 +125,28 @@ impl<K: DepKind> DepGraph<K> {\n             record_stats,\n         );\n \n+        let colors = DepNodeColorMap::new(prev_graph_node_count);\n+\n         // Instantiate a dependy-less node only once for anonymous queries.\n         let _green_node_index = current.intern_new_node(\n             profiler,\n             DepNode { kind: DepKind::NULL, hash: current.anon_id_seed.into() },\n             smallvec![],\n             Fingerprint::ZERO,\n         );\n-        debug_assert_eq!(_green_node_index, DepNodeIndex::SINGLETON_DEPENDENCYLESS_ANON_NODE);\n+        assert_eq!(_green_node_index, DepNodeIndex::SINGLETON_DEPENDENCYLESS_ANON_NODE);\n+\n+        // Instantiate a dependy-less red node only once for anonymous queries.\n+        let (_red_node_index, _prev_and_index) = current.intern_node(\n+            profiler,\n+            &prev_graph,\n+            DepNode { kind: DepKind::RED, hash: Fingerprint::ZERO.into() },\n+            smallvec![],\n+            None,\n+            false,\n+        );\n+        assert_eq!(_red_node_index, DepNodeIndex::FOREVER_RED_NODE);\n+        assert!(matches!(_prev_and_index, None | Some((_, DepNodeColor::Red))));\n \n         DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n@@ -140,7 +155,7 @@ impl<K: DepKind> DepGraph<K> {\n                 current,\n                 processed_side_effects: Default::default(),\n                 previous: prev_graph,\n-                colors: DepNodeColorMap::new(prev_graph_node_count),\n+                colors,\n                 debug_loaded_from_disk: Default::default(),\n             })),\n             virtual_dep_node_index: Lrc::new(AtomicU32::new(0)),\n@@ -328,10 +343,8 @@ impl<K: DepKind> DepGraph<K> {\n \n         let dcx = cx.dep_context();\n         let hashing_timer = dcx.profiler().incr_result_hashing();\n-        let current_fingerprint = hash_result.map(|f| {\n-            let mut hcx = dcx.create_stable_hashing_context();\n-            f(&mut hcx, &result)\n-        });\n+        let current_fingerprint =\n+            hash_result.map(|f| dcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, &result)));\n \n         let print_status = cfg!(debug_assertions) && dcx.sess().opts.debugging_opts.dep_tasks;\n \n@@ -971,6 +984,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         let nanos = duration.as_secs() * 1_000_000_000 + duration.subsec_nanos() as u64;\n         let mut stable_hasher = StableHasher::new();\n         nanos.hash(&mut stable_hasher);\n+        let anon_id_seed = stable_hasher.finish();\n \n         #[cfg(debug_assertions)]\n         let forbidden_edge = match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n@@ -1006,7 +1020,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                 )\n             }),\n             prev_index_to_index: Lock::new(IndexVec::from_elem_n(None, prev_graph_node_count)),\n-            anon_id_seed: stable_hasher.finish(),\n+            anon_id_seed,\n             #[cfg(debug_assertions)]\n             forbidden_edge,\n             total_read_count: AtomicU64::new(0),"}, {"sha": "342d95ca490ea276a5ecd2dfb3b2bc6aa3b44f1f", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -23,7 +23,7 @@ pub trait DepContext: Copy {\n     type DepKind: self::DepKind;\n \n     /// Create a hashing context for hashing new results.\n-    fn create_stable_hashing_context(&self) -> StableHashingContext<'_>;\n+    fn with_stable_hashing_context<R>(&self, f: impl FnOnce(StableHashingContext<'_>) -> R) -> R;\n \n     /// Access the DepGraph.\n     fn dep_graph(&self) -> &DepGraph<Self::DepKind>;\n@@ -85,8 +85,12 @@ impl FingerprintStyle {\n \n /// Describe the different families of dependency nodes.\n pub trait DepKind: Copy + fmt::Debug + Eq + Hash + Send + Encodable<FileEncoder> + 'static {\n+    /// DepKind to use when incr. comp. is turned off.\n     const NULL: Self;\n \n+    /// DepKind to use to create the initial forever-red node.\n+    const RED: Self;\n+\n     /// Implementation of `std::fmt::Debug` for `DepNode`.\n     fn debug_node(node: &DepNode<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result;\n "}, {"sha": "843f6f9d703674e3eabe10e8f7c695675f99161d", "filename": "compiler/rustc_query_system/src/ich/hcx.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -1,4 +1,5 @@\n use crate::ich;\n+\n use rustc_ast as ast;\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::stable_hasher::{HashStable, HashingControls, StableHasher};\n@@ -118,13 +119,13 @@ impl<'a> StableHashingContext<'a> {\n         &mut self,\n         hash_bodies: bool,\n         owner: LocalDefId,\n-        bodies: &'a SortedMap<hir::ItemLocalId, &'a hir::Body<'a>>,\n-        f: impl FnOnce(&mut Self),\n+        bodies: &SortedMap<hir::ItemLocalId, &hir::Body<'_>>,\n+        f: impl FnOnce(&mut StableHashingContext<'_>),\n     ) {\n-        let prev = self.body_resolver;\n-        self.body_resolver = BodyResolver::Traverse { hash_bodies, owner, bodies };\n-        f(self);\n-        self.body_resolver = prev;\n+        f(&mut StableHashingContext {\n+            body_resolver: BodyResolver::Traverse { hash_bodies, owner, bodies },\n+            ..self.clone()\n+        });\n     }\n \n     #[inline]"}, {"sha": "bbcd00be943a274bd180e869852f7605ec137be4", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -542,8 +542,7 @@ fn incremental_verify_ich<CTX, K, V: Debug>(\n \n     debug!(\"BEGIN verify_ich({:?})\", dep_node);\n     let new_hash = query.hash_result.map_or(Fingerprint::ZERO, |f| {\n-        let mut hcx = tcx.create_stable_hashing_context();\n-        f(&mut hcx, result)\n+        tcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n     });\n     let old_hash = tcx.dep_graph().prev_fingerprint_of(dep_node);\n     debug!(\"END verify_ich({:?})\", dep_node);"}, {"sha": "e3045c9321d1c74474ec44616c63408beb2d113c", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -96,47 +96,48 @@ fn get_symbol_hash<'tcx>(\n     let substs = instance.substs;\n     debug!(\"get_symbol_hash(def_id={:?}, parameters={:?})\", def_id, substs);\n \n-    let mut hasher = StableHasher::new();\n-    let mut hcx = tcx.create_stable_hashing_context();\n-\n-    record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n-        // the main symbol name is not necessarily unique; hash in the\n-        // compiler's internal def-path, guaranteeing each symbol has a\n-        // truly unique path\n-        tcx.def_path_hash(def_id).hash_stable(&mut hcx, &mut hasher);\n-\n-        // Include the main item-type. Note that, in this case, the\n-        // assertions about `needs_subst` may not hold, but this item-type\n-        // ought to be the same for every reference anyway.\n-        assert!(!item_type.has_erasable_regions());\n-        hcx.while_hashing_spans(false, |hcx| {\n-            item_type.hash_stable(hcx, &mut hasher);\n-\n-            // If this is a function, we hash the signature as well.\n-            // This is not *strictly* needed, but it may help in some\n-            // situations, see the `run-make/a-b-a-linker-guard` test.\n-            if let ty::FnDef(..) = item_type.kind() {\n-                item_type.fn_sig(tcx).hash_stable(hcx, &mut hasher);\n-            }\n+    tcx.with_stable_hashing_context(|mut hcx| {\n+        let mut hasher = StableHasher::new();\n+\n+        record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n+            // the main symbol name is not necessarily unique; hash in the\n+            // compiler's internal def-path, guaranteeing each symbol has a\n+            // truly unique path\n+            tcx.def_path_hash(def_id).hash_stable(&mut hcx, &mut hasher);\n+\n+            // Include the main item-type. Note that, in this case, the\n+            // assertions about `needs_subst` may not hold, but this item-type\n+            // ought to be the same for every reference anyway.\n+            assert!(!item_type.has_erasable_regions());\n+            hcx.while_hashing_spans(false, |hcx| {\n+                item_type.hash_stable(hcx, &mut hasher);\n+\n+                // If this is a function, we hash the signature as well.\n+                // This is not *strictly* needed, but it may help in some\n+                // situations, see the `run-make/a-b-a-linker-guard` test.\n+                if let ty::FnDef(..) = item_type.kind() {\n+                    item_type.fn_sig(tcx).hash_stable(hcx, &mut hasher);\n+                }\n \n-            // also include any type parameters (for generic items)\n-            substs.hash_stable(hcx, &mut hasher);\n+                // also include any type parameters (for generic items)\n+                substs.hash_stable(hcx, &mut hasher);\n \n-            if let Some(instantiating_crate) = instantiating_crate {\n-                tcx.def_path_hash(instantiating_crate.as_def_id())\n-                    .stable_crate_id()\n-                    .hash_stable(hcx, &mut hasher);\n-            }\n+                if let Some(instantiating_crate) = instantiating_crate {\n+                    tcx.def_path_hash(instantiating_crate.as_def_id())\n+                        .stable_crate_id()\n+                        .hash_stable(hcx, &mut hasher);\n+                }\n \n-            // We want to avoid accidental collision between different types of instances.\n-            // Especially, `VtableShim`s and `ReifyShim`s may overlap with their original\n-            // instances without this.\n-            discriminant(&instance.def).hash_stable(hcx, &mut hasher);\n+                // We want to avoid accidental collision between different types of instances.\n+                // Especially, `VtableShim`s and `ReifyShim`s may overlap with their original\n+                // instances without this.\n+                discriminant(&instance.def).hash_stable(hcx, &mut hasher);\n+            });\n         });\n-    });\n \n-    // 64 bits should be enough to avoid collisions.\n-    hasher.finish::<u64>()\n+        // 64 bits should be enough to avoid collisions.\n+        hasher.finish::<u64>()\n+    })\n }\n \n // Follow C++ namespace-mangling style, see"}, {"sha": "0172ef5700b62f480354682cac21b9df3353871d", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=0f573a0c5474ad65bc9f0b0fd3a94d1b06dcfdfa", "patch": "@@ -53,7 +53,8 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n             None,\n             None,\n         );\n-        let expn_id = LocalExpnId::fresh(expn_data, self.cx.tcx.create_stable_hashing_context());\n+        let expn_id =\n+            self.cx.tcx.with_stable_hashing_context(|hcx| LocalExpnId::fresh(expn_data, hcx));\n         let span = DUMMY_SP.fresh_expansion(expn_id);\n \n         let is_empty = rustc_driver::catch_fatal_errors(|| {"}]}