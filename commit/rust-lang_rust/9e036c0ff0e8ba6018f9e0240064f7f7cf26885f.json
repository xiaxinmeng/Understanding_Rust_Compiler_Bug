{"sha": "9e036c0ff0e8ba6018f9e0240064f7f7cf26885f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllMDM2YzBmZjBlOGJhNjAxOGY5ZTAyNDAwNjRmN2Y3Y2YyNjg4NWY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-06T10:38:46Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:52Z"}, "message": "trans: Provide the FnType for a direct call via Callee::direct_fn_type.", "tree": {"sha": "ee3726ffd2f486fed3a0dc760e0ef5c5eea24537", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee3726ffd2f486fed3a0dc760e0ef5c5eea24537"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e036c0ff0e8ba6018f9e0240064f7f7cf26885f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e036c0ff0e8ba6018f9e0240064f7f7cf26885f", "html_url": "https://github.com/rust-lang/rust/commit/9e036c0ff0e8ba6018f9e0240064f7f7cf26885f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e036c0ff0e8ba6018f9e0240064f7f7cf26885f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80d939fd22361cc8652cd4d7006fd1964d9ab699", "url": "https://api.github.com/repos/rust-lang/rust/commits/80d939fd22361cc8652cd4d7006fd1964d9ab699", "html_url": "https://github.com/rust-lang/rust/commit/80d939fd22361cc8652cd4d7006fd1964d9ab699"}], "stats": {"total": 87, "additions": 55, "deletions": 32}, "files": [{"sha": "6345395d441690d3ac01aca93e5f4c6794c6b1f0", "filename": "src/librustc_trans/trans/abi.rs", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/9e036c0ff0e8ba6018f9e0240064f7f7cf26885f/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e036c0ff0e8ba6018f9e0240064f7f7cf26885f/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fabi.rs?ref=9e036c0ff0e8ba6018f9e0240064f7f7cf26885f", "patch": "@@ -150,17 +150,18 @@ impl FnType {\n                          abi: Abi,\n                          sig: &ty::FnSig<'tcx>,\n                          extra_args: &[Ty<'tcx>]) -> FnType {\n+        let mut fn_ty = FnType::unadjusted(ccx, abi, sig, extra_args);\n+        fn_ty.adjust_for_abi(ccx, abi, sig);\n+        fn_ty\n+    }\n+\n+    pub fn unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                abi: Abi,\n+                                sig: &ty::FnSig<'tcx>,\n+                                extra_args: &[Ty<'tcx>]) -> FnType {\n         use self::Abi::*;\n         let cconv = match ccx.sess().target.target.adjust_abi(abi) {\n-            RustIntrinsic => {\n-                // Intrinsics are emitted at the call site\n-                ccx.sess().bug(\"asked to compute FnType of intrinsic\");\n-            }\n-            PlatformIntrinsic => {\n-                // Intrinsics are emitted at the call site\n-                ccx.sess().bug(\"asked to compute FnType of platform intrinsic\");\n-            }\n-\n+            RustIntrinsic | PlatformIntrinsic |\n             Rust | RustCall => llvm::CCallConv,\n \n             // It's the ABI's job to select this, not us.\n@@ -309,14 +310,20 @@ impl FnType {\n             }\n         }\n \n-        let mut fty = FnType {\n+        FnType {\n             args: args,\n             ret: ret,\n             variadic: sig.variadic,\n             cconv: cconv\n-        };\n+        }\n+    }\n \n-        if abi == Rust || abi == RustCall {\n+    pub fn adjust_for_abi<'a, 'tcx>(&mut self,\n+                                    ccx: &CrateContext<'a, 'tcx>,\n+                                    abi: Abi,\n+                                    sig: &ty::FnSig<'tcx>) {\n+        if abi == Abi::Rust || abi == Abi::RustCall ||\n+           abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n             let fixup = |arg: &mut ArgType| {\n                 if !arg.ty.is_aggregate() {\n                     // Scalars and vectors, always immediate.\n@@ -332,49 +339,48 @@ impl FnType {\n                     arg.cast = Some(Type::ix(ccx, size * 8));\n                 }\n             };\n-            if fty.ret.ty != Type::void(ccx) {\n-                // Fat pointers are returned by-value.\n+            // Fat pointers are returned by-value.\n+            if !self.ret.is_ignore() {\n                 if !type_is_fat_ptr(ccx.tcx(), sig.output.unwrap()) {\n-                    fixup(&mut fty.ret);\n+                    fixup(&mut self.ret);\n                 }\n             }\n-            for arg in &mut fty.args {\n+            for arg in &mut self.args {\n+                if arg.is_ignore() { continue; }\n                 fixup(arg);\n             }\n-            if fty.ret.is_indirect() {\n-                fty.ret.attrs.set(llvm::Attribute::StructRet);\n+            if self.ret.is_indirect() {\n+                self.ret.attrs.set(llvm::Attribute::StructRet);\n             }\n-            return fty;\n+            return;\n         }\n \n         match &ccx.sess().target.target.arch[..] {\n-            \"x86\" => cabi_x86::compute_abi_info(ccx, &mut fty),\n+            \"x86\" => cabi_x86::compute_abi_info(ccx, self),\n             \"x86_64\" => if ccx.sess().target.target.options.is_like_windows {\n-                cabi_x86_win64::compute_abi_info(ccx, &mut fty);\n+                cabi_x86_win64::compute_abi_info(ccx, self);\n             } else {\n-                cabi_x86_64::compute_abi_info(ccx, &mut fty);\n+                cabi_x86_64::compute_abi_info(ccx, self);\n             },\n-            \"aarch64\" => cabi_aarch64::compute_abi_info(ccx, &mut fty),\n+            \"aarch64\" => cabi_aarch64::compute_abi_info(ccx, self),\n             \"arm\" => {\n                 let flavor = if ccx.sess().target.target.target_os == \"ios\" {\n                     cabi_arm::Flavor::Ios\n                 } else {\n                     cabi_arm::Flavor::General\n                 };\n-                cabi_arm::compute_abi_info(ccx, &mut fty, flavor);\n+                cabi_arm::compute_abi_info(ccx, self, flavor);\n             },\n-            \"mips\" => cabi_mips::compute_abi_info(ccx, &mut fty),\n-            \"powerpc\" => cabi_powerpc::compute_abi_info(ccx, &mut fty),\n-            \"powerpc64\" => cabi_powerpc64::compute_abi_info(ccx, &mut fty),\n-            \"asmjs\" => cabi_asmjs::compute_abi_info(ccx, &mut fty),\n+            \"mips\" => cabi_mips::compute_abi_info(ccx, self),\n+            \"powerpc\" => cabi_powerpc::compute_abi_info(ccx, self),\n+            \"powerpc64\" => cabi_powerpc64::compute_abi_info(ccx, self),\n+            \"asmjs\" => cabi_asmjs::compute_abi_info(ccx, self),\n             a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n         }\n \n-        if fty.ret.is_indirect() {\n-            fty.ret.attrs.set(llvm::Attribute::StructRet);\n+        if self.ret.is_indirect() {\n+            self.ret.attrs.set(llvm::Attribute::StructRet);\n         }\n-\n-        fty\n     }\n \n     pub fn llvm_type(&self, ccx: &CrateContext) -> Type {"}, {"sha": "1d302b65f9ca9b7eda3da4dec6ae27bcdd6ab2aa", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9e036c0ff0e8ba6018f9e0240064f7f7cf26885f/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e036c0ff0e8ba6018f9e0240064f7f7cf26885f/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=9e036c0ff0e8ba6018f9e0240064f7f7cf26885f", "patch": "@@ -210,6 +210,23 @@ impl<'tcx> Callee<'tcx> {\n         }\n     }\n \n+    /// Get the abi::FnType for a direct call. Mainly deals with the fact\n+    /// that a Virtual call doesn't take the vtable, like its shim does.\n+    /// The extra argument types are for variadic (extern \"C\") functions.\n+    pub fn direct_fn_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n+                              extra_args: &[Ty<'tcx>]) -> FnType {\n+        let abi = self.ty.fn_abi();\n+        let sig = ccx.tcx().erase_late_bound_regions(self.ty.fn_sig());\n+        let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n+        let mut fn_ty = FnType::unadjusted(ccx, abi, &sig, extra_args);\n+        if let Virtual(_) = self.data {\n+            // Don't pass the vtable, it's not an argument of the virtual fn.\n+            fn_ty.args[1].ignore();\n+        }\n+        fn_ty.adjust_for_abi(ccx, abi, &sig);\n+        fn_ty\n+    }\n+\n     /// This behemoth of a function translates function calls. Unfortunately, in\n     /// order to generate more efficient LLVM output at -O0, it has quite a complex\n     /// signature (refactoring this into two functions seems like a good idea)."}]}