{"sha": "50e8c41a817b3c9139055eb13bec5108215e0e3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZThjNDFhODE3YjNjOTEzOTA1NWViMTNiZWM1MTA4MjE1ZTBlM2Y=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-25T04:18:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-25T04:18:06Z"}, "message": "Rollup merge of #65414 - davidtwco:issue-65157-non-exhaustive-always-useful, r=varkor\n\nignore uninhabited non-exhaustive variant fields\n\nFixes #65157.\n\nThis PR modifies the uninhabitedness checking so that the fields of\na non-exhaustive variant (which is not local) are ignored if they are\nuninhabited. This is an improvement over the previous behaviour which\nconsidered all non-local non-exhaustive variants useful because\nunreachable patterns are now detected.\n\nr? @arielb1\ncc @varkor", "tree": {"sha": "ca873bc7666127d6aa87a3209bd787f96930c4f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca873bc7666127d6aa87a3209bd787f96930c4f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50e8c41a817b3c9139055eb13bec5108215e0e3f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdsnd+CRBK7hj4Ov3rIwAAdHIIAC1J6m78ldVi0/h3Uek6Pe0E\nnNR+uwBCNkOvHDC+CeyqNJHjE0qdnF2Freub18/Ma3U8vAsfCrVsvaUoVVeue1XE\nweph8jAbTmg3hccE7errhF9mCfPJcMdbosVhGGZ7ZWFykGGcVDlB30oGHA9dw/ks\nZ3S6QxYIeWkVuOrBUY4B6eQbL9U5lk/Rq+WmyYua5IKAr9I+A8wQVKrkgo9myogl\nVSVHH6M05HvuwFmqrePkS8BXgTWZ3iA3XtFgKEEj7aGsYB3ua9cO6Ic5CWYJmNgF\nw/I0mwg3wI4xtrOKWzzsVV/I9wMgTmGVeljLv4kVSzlr0steQK/dm9Gc6Zi8fRU=\n=FuuA\n-----END PGP SIGNATURE-----\n", "payload": "tree ca873bc7666127d6aa87a3209bd787f96930c4f4\nparent ee7f9de4c44dff2c83d2ea4cf5e1b2d5846dfb34\nparent 7ffbd62445b9706325d01ec8be8e70c41404fe0d\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1571977086 +0200\ncommitter GitHub <noreply@github.com> 1571977086 +0200\n\nRollup merge of #65414 - davidtwco:issue-65157-non-exhaustive-always-useful, r=varkor\n\nignore uninhabited non-exhaustive variant fields\n\nFixes #65157.\n\nThis PR modifies the uninhabitedness checking so that the fields of\na non-exhaustive variant (which is not local) are ignored if they are\nuninhabited. This is an improvement over the previous behaviour which\nconsidered all non-local non-exhaustive variants useful because\nunreachable patterns are now detected.\n\nr? @arielb1\ncc @varkor\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50e8c41a817b3c9139055eb13bec5108215e0e3f", "html_url": "https://github.com/rust-lang/rust/commit/50e8c41a817b3c9139055eb13bec5108215e0e3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50e8c41a817b3c9139055eb13bec5108215e0e3f/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee7f9de4c44dff2c83d2ea4cf5e1b2d5846dfb34", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee7f9de4c44dff2c83d2ea4cf5e1b2d5846dfb34", "html_url": "https://github.com/rust-lang/rust/commit/ee7f9de4c44dff2c83d2ea4cf5e1b2d5846dfb34"}, {"sha": "7ffbd62445b9706325d01ec8be8e70c41404fe0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ffbd62445b9706325d01ec8be8e70c41404fe0d", "html_url": "https://github.com/rust-lang/rust/commit/7ffbd62445b9706325d01ec8be8e70c41404fe0d"}], "stats": {"total": 124, "additions": 75, "deletions": 49}, "files": [{"sha": "907c84b6f8cf02ac23a4d4a33f1dade25a452a52", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 39, "deletions": 49, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/50e8c41a817b3c9139055eb13bec5108215e0e3f/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50e8c41a817b3c9139055eb13bec5108215e0e3f/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=50e8c41a817b3c9139055eb13bec5108215e0e3f", "patch": "@@ -394,16 +394,6 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn is_non_exhaustive_variant<'p>(&self, pattern: &'p Pat<'tcx>) -> bool {\n-        match *pattern.kind {\n-            PatKind::Variant { adt_def, variant_index, .. } => {\n-                let ref variant = adt_def.variants[variant_index];\n-                variant.is_field_list_non_exhaustive()\n-            }\n-            _ => false,\n-        }\n-    }\n-\n     fn is_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.kind {\n             ty::Adt(adt_def, ..) => adt_def.is_variant_list_non_exhaustive(),\n@@ -1252,19 +1242,12 @@ pub fn is_useful<'p, 'a, 'tcx>(\n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v[0]);\n \n     if let Some(constructors) = pat_constructors(cx, v[0], pcx) {\n-        let is_declared_nonexhaustive = cx.is_non_exhaustive_variant(v[0]) && !cx.is_local(pcx.ty);\n-        debug!(\"is_useful - expanding constructors: {:#?}, is_declared_nonexhaustive: {:?}\",\n-               constructors, is_declared_nonexhaustive);\n-\n-        if is_declared_nonexhaustive {\n-            Useful\n-        } else {\n-            split_grouped_constructors(\n-                cx.tcx, cx.param_env, constructors, matrix, pcx.ty, pcx.span, Some(hir_id),\n-            ).into_iter().map(|c|\n-                is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id)\n-            ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n-        }\n+        debug!(\"is_useful - expanding constructors: {:#?}\", constructors);\n+        split_grouped_constructors(\n+            cx.tcx, cx.param_env, constructors, matrix, pcx.ty, pcx.span, Some(hir_id),\n+        ).into_iter().map(|c|\n+            is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id)\n+        ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n \n@@ -1548,27 +1531,30 @@ fn constructor_sub_pattern_tys<'a, 'tcx>(\n                 // Use T as the sub pattern type of Box<T>.\n                 vec![substs.type_at(0)]\n             } else {\n-                adt.variants[ctor.variant_index_for_adt(cx, adt)].fields.iter().map(|field| {\n+                let variant = &adt.variants[ctor.variant_index_for_adt(cx, adt)];\n+                let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !cx.is_local(ty);\n+                variant.fields.iter().map(|field| {\n                     let is_visible = adt.is_enum()\n                         || field.vis.is_accessible_from(cx.module, cx.tcx);\n-                    if is_visible {\n-                        let ty = field.ty(cx.tcx, substs);\n-                        match ty.kind {\n-                            // If the field type returned is an array of an unknown\n-                            // size return an TyErr.\n-                            ty::Array(_, len)\n-                                if len.try_eval_usize(cx.tcx, cx.param_env).is_none() =>\n-                                cx.tcx.types.err,\n-                            _ => ty,\n-                        }\n-                    } else {\n-                        // Treat all non-visible fields as TyErr. They\n-                        // can't appear in any other pattern from\n-                        // this match (because they are private),\n-                        // so their type does not matter - but\n-                        // we don't want to know they are\n-                        // uninhabited.\n-                        cx.tcx.types.err\n+                    let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n+                    match (is_visible, is_non_exhaustive, is_uninhabited) {\n+                        // Treat all uninhabited types in non-exhaustive variants as `TyErr`.\n+                        (_, true, true) => cx.tcx.types.err,\n+                        // Treat all non-visible fields as `TyErr`. They can't appear in any\n+                        // other pattern from this match (because they are private), so their\n+                        // type does not matter - but we don't want to know they are uninhabited.\n+                        (false, ..) => cx.tcx.types.err,\n+                        (true, ..) => {\n+                            let ty = field.ty(cx.tcx, substs);\n+                            match ty.kind {\n+                                // If the field type returned is an array of an unknown\n+                                // size return an TyErr.\n+                                ty::Array(_, len)\n+                                    if len.try_eval_usize(cx.tcx, cx.param_env).is_none() =>\n+                                    cx.tcx.types.err,\n+                                _ => ty,\n+                            }\n+                        },\n                     }\n                 }).collect()\n             }\n@@ -1874,15 +1860,18 @@ fn constructor_covered_by_range<'tcx>(\n     }\n }\n \n-fn patterns_for_variant<'p, 'tcx>(\n+fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     subpatterns: &'p [FieldPat<'tcx>],\n-    wild_patterns: &[&'p Pat<'tcx>])\n-    -> SmallVec<[&'p Pat<'tcx>; 2]>\n-{\n+    wild_patterns: &[&'p Pat<'tcx>],\n+    is_non_exhaustive: bool,\n+) -> SmallVec<[&'p Pat<'tcx>; 2]> {\n     let mut result = SmallVec::from_slice(wild_patterns);\n \n     for subpat in subpatterns {\n-        result[subpat.field.index()] = &subpat.pattern;\n+        if !is_non_exhaustive || !cx.is_uninhabited(subpat.pattern.ty) {\n+            result[subpat.field.index()] = &subpat.pattern;\n+        }\n     }\n \n     debug!(\"patterns_for_variant({:#?}, {:#?}) = {:#?}\", subpatterns, wild_patterns, result);\n@@ -1916,13 +1905,14 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n \n         PatKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n+            let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !cx.is_local(pat.ty);\n             Some(Variant(variant.def_id))\n                 .filter(|variant_constructor| variant_constructor == constructor)\n-                .map(|_| patterns_for_variant(subpatterns, wild_patterns))\n+                .map(|_| patterns_for_variant(cx, subpatterns, wild_patterns, is_non_exhaustive))\n         }\n \n         PatKind::Leaf { ref subpatterns } => {\n-            Some(patterns_for_variant(subpatterns, wild_patterns))\n+            Some(patterns_for_variant(cx, subpatterns, wild_patterns, false))\n         }\n \n         PatKind::Deref { ref subpattern } => {"}, {"sha": "0096e2963007a442f05c70aea27779619cccba9e", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/issue-65157-repeated-match-arm.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/50e8c41a817b3c9139055eb13bec5108215e0e3f/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50e8c41a817b3c9139055eb13bec5108215e0e3f/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.rs?ref=50e8c41a817b3c9139055eb13bec5108215e0e3f", "patch": "@@ -0,0 +1,22 @@\n+// aux-build:uninhabited.rs\n+#![deny(unreachable_patterns)]\n+#![feature(never_type)]\n+#![feature(non_exhaustive)]\n+\n+extern crate uninhabited;\n+\n+use uninhabited::PartiallyInhabitedVariants;\n+\n+// This test checks a redundant/useless pattern of a non-exhaustive enum/variant is still\n+// warned against.\n+\n+pub fn foo(x: PartiallyInhabitedVariants) {\n+    match x {\n+        PartiallyInhabitedVariants::Struct { .. } => {},\n+        PartiallyInhabitedVariants::Struct { .. } => {},\n+        //~^ ERROR unreachable pattern\n+        _ => {},\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "d46b1fd4c420252f6d34b8f7bb2505889582833a", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/issue-65157-repeated-match-arm.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50e8c41a817b3c9139055eb13bec5108215e0e3f/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50e8c41a817b3c9139055eb13bec5108215e0e3f/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fissue-65157-repeated-match-arm.stderr?ref=50e8c41a817b3c9139055eb13bec5108215e0e3f", "patch": "@@ -0,0 +1,14 @@\n+error: unreachable pattern\n+  --> $DIR/issue-65157-repeated-match-arm.rs:16:9\n+   |\n+LL |         PartiallyInhabitedVariants::Struct { .. } => {},\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-65157-repeated-match-arm.rs:2:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}