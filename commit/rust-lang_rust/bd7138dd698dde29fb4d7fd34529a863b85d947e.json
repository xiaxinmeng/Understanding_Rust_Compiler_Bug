{"sha": "bd7138dd698dde29fb4d7fd34529a863b85d947e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNzEzOGRkNjk4ZGRlMjlmYjRkN2ZkMzQ1MjlhODYzYjg1ZDk0N2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-27T23:02:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-27T23:02:55Z"}, "message": "auto merge of #18368 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "b0d85f6266675501dce79b4802325e0d60b147e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0d85f6266675501dce79b4802325e0d60b147e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd7138dd698dde29fb4d7fd34529a863b85d947e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd7138dd698dde29fb4d7fd34529a863b85d947e", "html_url": "https://github.com/rust-lang/rust/commit/bd7138dd698dde29fb4d7fd34529a863b85d947e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd7138dd698dde29fb4d7fd34529a863b85d947e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e05c3b7799b45b78baf49f05763865be838f5b43", "url": "https://api.github.com/repos/rust-lang/rust/commits/e05c3b7799b45b78baf49f05763865be838f5b43", "html_url": "https://github.com/rust-lang/rust/commit/e05c3b7799b45b78baf49f05763865be838f5b43"}, {"sha": "4dc06dceb2bbb7ced9ea137b5280f7ce413b4d01", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dc06dceb2bbb7ced9ea137b5280f7ce413b4d01", "html_url": "https://github.com/rust-lang/rust/commit/4dc06dceb2bbb7ced9ea137b5280f7ce413b4d01"}], "stats": {"total": 2234, "additions": 1588, "deletions": 646}, "files": [{"sha": "f529fe1bb78c3e6b9643e2f4e6d318bbaf12a2b7", "filename": ".mailmap", "status": "modified", "additions": 98, "deletions": 2, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -5,8 +5,104 @@\n # email addresses.\n #\n \n-Elly Jones <elly@leptoquark.net>\n-ILyoan <ilyoan@gmail.com>\n+Aaron Todd <github@opprobrio.us>\n+Ahmed Charles <ahmedcharles@gmail.com> <acharles@outlook.com>\n+Alex Lyon <arcterus@mail.com> <Arcterus@mail.com>\n+Alex R\u00f8nne Petersen <alex@lycus.org>\n+Andreas Gal <gal@mozilla.com> <andreas.gal@gmail.com>\n+Andrew Poelstra <asp11@sfu.ca> <apoelstra@wpsoftware.net>\n+Anton L\u00f6fgren <anton.lofgren@gmail.com> <alofgren@op5.com>\n+Ariel Ben-Yehuda <arielb1@mail.tau.ac.il> <ariel.byd@gmail.com>\n+Austin Seipp <mad.one@gmail.com> <as@hacks.yi.org>\n+Ben Alpert <ben@benalpert.com> <spicyjalapeno@gmail.com>\n+Benjamin Jackman <ben@jackman.biz>\n+Bj\u00f6rn Steinbrink <bsteinbr@gmail.com> <B.Steinbrink@gmx.de>\n+blake2-ppc <ulrik.sverdrup@gmail.com> <blake2-ppc>\n+Boris Egorov <jightuse@gmail.com> <egorov@linux.com>\n+Brian Anderson <banderson@mozilla.com> <andersrb@gmail.com>\n+Brian Dawn <brian.t.dawn@gmail.com>\n+Carl-Anton Ingmarsson <mail@carlanton.se> <ca.ingmarsson@gmail.com>\n+Carol Willing <carolcode@willingconsulting.com>\n+Chris Pressey <cpressey@gmail.com>\n+Clark Gaebel <cg.wowus.cg@gmail.com> <cgaebel@mozilla.com>\n+David Klein <david.klein@baesystemsdetica.com>\n+David Manescu <david.manescu@gmail.com> <dman2626@uni.sydney.edu.au>\n+Damien Schoof <damien.schoof@gmail.com>\n+Derek Chiang <derekchiang93@gmail.com> Derek Chiang (Enchi Jiang) <derekchiang93@gmail.com>\n+Dylan Braithwaite <dylanbraithwaite1@gmail.com> <mail@dylanb.me>\n+Eduardo Bautista <me@eduardobautista.com> <mail@eduardobautista.com>\n+Eduardo Bautista <me@eduardobautista.com> <=>\n+Elliott Slaughter <elliottslaughter@gmail.com> <eslaughter@mozilla.com>\n+Elly Fong-Jones <elly@leptoquark.net>\n+Eric Holk <eric.holk@gmail.com> <eholk@mozilla.com>\n+Eric Holk <eric.holk@gmail.com> <eholk@cs.indiana.edu>\n+Eric Holmes <eric@ejholmes.net>\n+Eric Reed <ecreed@cs.washington.edu> <ereed@mozilla.com>\n+Erick Tryzelaar <erick.tryzelaar@gmail.com> <etryzelaar@iqt.org>\n+Evgeny Sologubov\n+Falco Hirschenberger <falco.hirschenberger@gmail.com> <hirschen@itwm.fhg.de>\n+Gareth Daniel Smith <garethdanielsmith@gmail.com>\n+Georges Dubus <georges.dubus@gmail.com> <georges.dubus@compiletoi.net>\n+Graham Fawcett <fawcett@uwindsor.ca> <graham.fawcett@gmail.com>\n+Graydon Hoare <graydon@mozilla.com> <graydon@pobox.com>\n+Heather <heather@cynede.net> <Heather@cynede.net>\n+Heather <heather@cynede.net> <Cynede@Gentoo.org>\n+Ilyong Cho <ilyoan@gmail.com>\n+J. J. Weber <jjweber@gmail.com>\n+Jakub Bukaj <jakub@jakub.cc>\n+Jakub Bukaj <jakub@jakub.cc> <jakubw@jakubw.net>\n+James Deng <cnjamesdeng@gmail.com> <cnJamesDeng@gmail.com>\n+James Miller <bladeon@gmail.com> <james@aatch.net>\n+Jason Orendorff <jorendorff@mozilla.com> <jason@mozmac-2.local>\n+Jason Orendorff <jorendorff@mozilla.com> <jason.orendorff@gmail.com>\n+Jeremy Letang <letang.jeremy@gmail.com>\n+Jihyun Yu <jihyun@nclab.kaist.ac.kr> jihyun <jihyun@nablecomm.com>\n+Jihyun Yu <jihyun@nclab.kaist.ac.kr> <yjh0502@gmail.com>\n+John Clements <clements@racket-lang.org> <clements@brinckerhoff.org>\n+Jorge Aparicio <japaric@linux.com> <japaricious@gmail.com>\n+Jonathan Bailey <jbailey@mozilla.com> <jbailey@jbailey-20809.local>\n Junyoung Cho <june0.cho@samsung.com>\n+Jyun-Yan You <jyyou.tw@gmail.com> <jyyou@cs.nctu.edu.tw>\n+Kang Seonghoon <kang.seonghoon@mearie.org> <public+git@mearie.org>\n+Keegan McAllister <kmcallister@mozilla.com> <mcallister.keegan@gmail.com>\n+Kyeongwoon Lee <kyeongwoon.lee@samsung.com>\n+Lee Wondong <wdlee91@gmail.com>\n+Lennart Kudling <github@kudling.de>\n+Lindsey Kuper <lindsey@composition.al> <lindsey@rockstargirl.org>\n+Lindsey Kuper <lindsey@composition.al> <lkuper@mozilla.com>\n+Luqman Aden <me@luqman.ca> <laden@mozilla.com>\n+Luqman Aden <me@luqman.ca> <laden@csclub.uwaterloo.ca>\n+Luke Metz <luke.metz@students.olin.edu>\n+Makoto Nakashima <makoto.nksm+github@gmail.com> <makoto.nksm@gmail.com>\n+Makoto Nakashima <makoto.nksm+github@gmail.com> gifnksm <makoto.nksm+github@gmail.com>\n+Margaret Meyerhofer <mmeyerho@andrew.cmu.edu> <mmeyerho@andrew>\n+Mark Sinclair <mark.edward.x@gmail.com>\n+Mark Sinclair <mark.edward.x@gmail.com> =Mark Sinclair <=125axel125@gmail.com>\n+Matt Brubeck <mbrubeck@limpet.net> <mbrubeck@cs.hmc.edu>\n+Matthew Auld <matthew.auld@intel.com>\n+Matthew McPherrin <matthew@mcpherrin.ca> <matt@mcpherrin.ca>\n Matthijs Hofstra <thiezz@gmail.com>\n+Michael Williams <m.t.williams@live.com>\n+Michael Woerister <michaelwoerister@gmail> <michaelwoerister@gmail.com>\n+Michael Woerister <michaelwoerister@gmail> <michaelwoerister@posteo>\n+Neil Pankey <npankey@gmail.com> <neil@wire.im>\n+Philipp Br\u00fcschweiler <blei42@gmail.com> <blei42@gmail.com>\n+Philipp Br\u00fcschweiler <blei42@gmail.com> <bruphili@student.ethz.ch>\n+Pradeep Kumar <gohanpra@gmail.com>\n+Richard Diamond <wichard@vitalitystudios.com> <wichard@hahbee.co>\n Rob Arnold <robarnold@cs.cmu.edu>\n+Robert Gawdzik <rgawdzik@hotmail.com> Robert Gawdzik \u2622 <rgawdzik@hotmail.com>\n+Robert Millar <robert.millar@cantab.net>\n+Ryan Scheel <ryan.havvy@gmail.com>\n+Seonghyun Kim <sh8281.kim@samsung.com>\n+Simon Barber-Dueck <sbarberdueck@gmail.com> Simon BD <simon@server>\n+Simon Sapin <simon@exyr.org> <simon.sapin@exyr.org>\n+startling <tdixon51793@gmail.com>\n+Steven Fackler <sfackler@gmail.com> <sfackler@palantir.com>\n+Steven Stewart-Gallus <sstewartgallus00@langara.bc.ca> <sstewartgallus00@mylangara.bc.ca>\n+Tim Chevalier <chevalier@alum.wellesley.edu> <catamorphism@gmail.com>\n+Torsten Weber <TorstenWeber12@gmail.com> <torstenweber12@gmail.com>\n+William Ting <io@williamting.com> <william.h.ting@gmail.com>\n+Youngsoo Son <ysson83@gmail.com> <ysoo.son@samsung.com>\n+Zack Corr <zack@z0w0.me> <zackcorr95@gmail.com>\n+Zack Slayton <zack.slayton@gmail.com>"}, {"sha": "89b11daf93863831d9bd1aaf35e909ccd286aacb", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/configure", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -989,6 +989,7 @@ do\n     make_dir $h/test/doc-guide-container\n     make_dir $h/test/doc-guide-tasks\n     make_dir $h/test/doc-guide-plugin\n+    make_dir $h/test/doc-guide-crates\n     make_dir $h/test/doc-rust\n done\n "}, {"sha": "9dbcb2c9bbcd567f56ff905d890e7d8db61cbd9c", "filename": "mk/docs.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -27,7 +27,7 @@\n ######################################################################\n DOCS := index intro tutorial guide guide-ffi guide-macros guide-lifetimes \\\n \tguide-tasks guide-container guide-pointers guide-testing \\\n-\tguide-plugin complement-bugreport \\\n+\tguide-plugin guide-crates complement-bugreport \\\n \tcomplement-lang-faq complement-design-faq complement-project-faq rust \\\n     rustdoc guide-unsafe guide-strings reference\n "}, {"sha": "50d76371cc51e3ce760e83ba17ccf7815e8b6e80", "filename": "src/doc/guide-crates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fdoc%2Fguide-crates.md", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fdoc%2Fguide-crates.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-crates.md?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -452,7 +452,7 @@ fn main() {\n \n Rust will give us a compile-time error:\n \n-```{rust,ignore}\n+```{notrust,ignore}\n    Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n /home/you/projects/phrases/src/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this module\n /home/you/projects/phrases/src/main.rs:4 use phrases::japanese::greetings::hello;"}, {"sha": "1145235c5f899fdaf21eac5a22bede3695322625", "filename": "src/doc/guide-plugin.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fdoc%2Fguide-plugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fdoc%2Fguide-plugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-plugin.md?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -56,7 +56,7 @@ extern crate rustc;\n \n use syntax::codemap::Span;\n use syntax::parse::token::{IDENT, get_ident};\n-use syntax::ast::{TokenTree, TTTok};\n+use syntax::ast::{TokenTree, TtToken};\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacExpr};\n use syntax::ext::build::AstBuilder;  // trait for expr_uint\n use rustc::plugin::Registry;\n@@ -71,7 +71,7 @@ fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         (\"I\",    1)];\n \n     let text = match args {\n-        [TTTok(_, IDENT(s, _))] => get_ident(s).to_string(),\n+        [TtToken(_, IDENT(s, _))] => get_ident(s).to_string(),\n         _ => {\n             cx.span_err(sp, \"argument should be a single identifier\");\n             return DummyResult::any(sp);\n@@ -151,8 +151,7 @@ higher-level syntax elements like expressions:\n fn expand_foo(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         -> Box<MacResult+'static> {\n \n-    let mut parser =\n-        parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(), args.to_slice())\n+    let mut parser = cx.new_parser_from_tts(args);\n \n     let expr: P<Expr> = parser.parse_expr();\n ```"}, {"sha": "87eb91d3ec7ff730ed85e3ec5f7a53eba3d85eca", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -416,7 +416,7 @@ great detail, so if you want the full details, check that out.\n \n In general, prefer stack allocation over heap allocation. Using references to\n stack allocated information is preferred whenever possible. Therefore,\n-references are the default pointer type you should use, unless you have\n+references are the default pointer type you should use, unless you have a\n specific reason to use a different type. The other types of pointers cover when\n they're appropriate to use in their own best practices sections.\n "}, {"sha": "1c7cb1a3b4eb9e80890014cbbc8c8a357deef584", "filename": "src/doc/guide-strings.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fdoc%2Fguide-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fdoc%2Fguide-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-strings.md?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -14,8 +14,8 @@ Rust has two main types of strings: `&str` and `String`.\n \n # &str\n \n-The first kind is a `&str`. This is pronounced a 'string slice.' String literals\n-are of the type `&str`:\n+The first kind is a `&str`. This is pronounced a 'string slice'.\n+String literals are of the type `&str`:\n \n ```{rust}\n let string = \"Hello there.\";\n@@ -121,8 +121,8 @@ Both of these lines will print `12`.\n To compare a String to a constant string, prefer `as_slice()`...\n \n ```{rust}\n-fn compare(string: String) {\n-    if string.as_slice() == \"Hello\" {\n+fn compare(x: String) {\n+    if x.as_slice() == \"Hello\" {\n         println!(\"yes\");\n     }\n }\n@@ -131,8 +131,8 @@ fn compare(string: String) {\n ... over `to_string()`:\n \n ```{rust}\n-fn compare(string: String) {\n-    if string == \"Hello\".to_string() {\n+fn compare(x: String) {\n+    if x == \"Hello\".to_string() {\n         println!(\"yes\");\n     }\n }"}, {"sha": "842157bb51998fe661b4350b07562fb47925e618", "filename": "src/doc/guide.md", "status": "modified", "additions": 165, "deletions": 114, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -1130,12 +1130,12 @@ fn main() {\n     let y = Missing;\n \n     match x {\n-        Value(n) => println!(\"x is {:d}\", n),\n+        Value(n) => println!(\"x is {}\", n),\n         Missing  => println!(\"x is missing!\"),\n     }\n \n     match y {\n-        Value(n) => println!(\"y is {:d}\", n),\n+        Value(n) => println!(\"y is {}\", n),\n         Missing  => println!(\"y is missing!\"),\n     }\n }\n@@ -1301,7 +1301,7 @@ Instead, it looks like this:\n \n ```{rust}\n for x in range(0i, 10i) {\n-    println!(\"{:d}\", x);\n+    println!(\"{}\", x);\n }\n ```\n \n@@ -1408,7 +1408,7 @@ iteration: This will only print the odd numbers:\n for x in range(0i, 10i) {\n     if x % 2 == 0 { continue; }\n \n-    println!(\"{:d}\", x);\n+    println!(\"{}\", x);\n }\n ```\n \n@@ -1677,12 +1677,12 @@ fn main() {\n     let y = Missing;\n \n     match x {\n-        Value(n) => println!(\"x is {:d}\", n),\n+        Value(n) => println!(\"x is {}\", n),\n         Missing  => println!(\"x is missing!\"),\n     }\n \n     match y {\n-        Value(n) => println!(\"y is {:d}\", n),\n+        Value(n) => println!(\"y is {}\", n),\n         Missing  => println!(\"y is missing!\"),\n     }\n }\n@@ -1793,7 +1793,7 @@ Finally, Cargo generated a hello, world for us. Check out `src/main.rs`:\n \n ```{rust}\n fn main() {\n-    println!(\"Hello, world!\");\n+    println!(\"Hello, world!\")\n }\n ```\n \n@@ -2682,12 +2682,12 @@ like this:\n \n ```\n fn main() {\n-    println!(\"Hello, world!\");\n+    println!(\"Hello, world!\")\n }\n \n mod hello {\n     fn print_hello() {\n-        println!(\"Hello, world!\");\n+        println!(\"Hello, world!\")\n     }\n }\n ```\n@@ -2721,7 +2721,7 @@ fn main() {\n \n mod hello {\n     fn print_hello() {\n-        println!(\"Hello, world!\");\n+        println!(\"Hello, world!\")\n     }\n }\n ```\n@@ -2744,7 +2744,7 @@ fn main() {\n \n mod hello {\n     pub fn print_hello() {\n-        println!(\"Hello, world!\");\n+        println!(\"Hello, world!\")\n     }\n }\n ```\n@@ -2921,15 +2921,11 @@ it `false`, so this test should fail. Let's try it!\n ```{notrust,ignore}\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n-/home/you/projects/testing/src/main.rs:1:1: 3:2 warning: code is never used: `main`, #[warn(dead_code)] on by default\n+/home/you/projects/testing/src/main.rs:1:1: 3:2 warning: function is never used: `main`, #[warn(dead_code)] on by default\n /home/you/projects/testing/src/main.rs:1 fn main() {\n-/home/you/projects/testing/src/main.rs:2     println!(\"Hello, world\");\n+/home/you/projects/testing/src/main.rs:2     println!(\"Hello, world!\")\n /home/you/projects/testing/src/main.rs:3 }\n-\n-running 0 tests\n-\n-test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n-\n+     Running target/lib-654ce120f310a3a5\n \n running 1 test\n test foo ... FAILED\n@@ -2946,7 +2942,7 @@ failures:\n \n test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n \n-task '<main>' failed at 'Some tests failed', /home/you/src/rust/src/libtest/lib.rs:242\n+task '<main>' failed at 'Some tests failed', /home/you/src/rust/src/libtest/lib.rs:243\n ```\n \n Lots of output! Let's break this down:\n@@ -2960,9 +2956,9 @@ You can run all of your tests with `cargo test`. This runs both your tests in\n `tests`, as well as the tests you put inside of your crate.\n \n ```{notrust,ignore}\n-/home/you/projects/testing/src/main.rs:1:1: 3:2 warning: code is never used: `main`, #[warn(dead_code)] on by default\n+/home/you/projects/testing/src/main.rs:1:1: 3:2 warning: function is never used: `main`, #[warn(dead_code)] on by default\n /home/you/projects/testing/src/main.rs:1 fn main() {\n-/home/you/projects/testing/src/main.rs:2     println!(\"Hello, world\");\n+/home/you/projects/testing/src/main.rs:2     println!(\"Hello, world!\")\n /home/you/projects/testing/src/main.rs:3 }\n ```\n \n@@ -2974,18 +2970,8 @@ We'll turn this lint off for just this function soon. For now, just ignore this\n output.\n \n ```{notrust,ignore}\n-running 0 tests\n-\n-test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n-```\n+     Running target/lib-654ce120f310a3a5\n \n-Wait a minute, zero tests? Didn't we define one? Yup. This output is from\n-attempting to run the tests in our crate, of which we don't have any.\n-You'll note that Rust reports on several kinds of tests: passed, failed,\n-ignored, and measured. The 'measured' tests refer to benchmark tests, which\n-we'll cover soon enough!\n-\n-```{notrust,ignore}\n running 1 test\n test foo ... FAILED\n ```\n@@ -3008,7 +2994,7 @@ failures:\n \n test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n \n-task '<main>' failed at 'Some tests failed', /home/you/src/rust/src/libtest/lib.rs:242\n+task '<main>' failed at 'Some tests failed', /home/you/src/rust/src/libtest/lib.rs:243\n ```\n \n After all the tests run, Rust will show us any output from our failed tests.\n@@ -3029,29 +3015,30 @@ And then try to run our tests again:\n ```{notrust,ignore}\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n-/home/you/projects/testing/src/main.rs:1:1: 3:2 warning: code is never used: `main`, #[warn(dead_code)] on by default\n-/home/you/projects/testing/src/main.rs:1 fn main() {\n-/home/you/projects/testing/src/main.rs:2     println!(\"Hello, world\");\n-/home/you/projects/testing/src/main.rs:3 }\n-\n-running 0 tests\n-\n-test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n-\n+     Running target/lib-654ce120f310a3a5\n \n running 1 test\n test foo ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+\n+     Running target/testing-6d7518593c7c3ee5\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n ```\n \n-Nice! Our test passes, as we expected. Let's get rid of that warning for our `main`\n-function. Change your `src/main.rs` to look like this:\n+Nice! Our test passes, as we expected. Note how we didn't get the\n+`main` warning this time? This is because `src/main.rs` didn't\n+need recompiling, but we'll get that warning again if we\n+change (and recompile) that file. Let's get rid of that\n+warning; change your `src/main.rs` to look like this:\n \n ```{rust}\n #[cfg(not(test))]\n fn main() {\n-    println!(\"Hello, world\");\n+    println!(\"Hello, world!\")\n }\n ```\n \n@@ -3062,21 +3049,24 @@ our tests, it sets things up so that `cfg(test)` is true. But we want to only\n include `main` when it's _not_ true. So we use `not` to negate things:\n `cfg(not(test))` will only compile our code when the `cfg(test)` is false.\n \n-With this attribute, we won't get the warning:\n+With this attribute we won't get the warning (even\n+though `src/main.rs` gets recompiled this time):\n \n ```{notrust,ignore}\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n-\n-running 0 tests\n-\n-test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n-\n+     Running target/lib-654ce120f310a3a5\n \n running 1 test\n test foo ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+\n+     Running target/testing-6d7518593c7c3ee5\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n ```\n \n Nice. Okay, let's write a real test now. Change your `tests/lib.rs`\n@@ -3133,7 +3123,7 @@ extern crate testing;\n \n #[cfg(not(test))]\n fn main() {\n-    println!(\"Hello, world\");\n+    println!(\"Hello, world!\")\n }\n ```\n \n@@ -3156,21 +3146,30 @@ Let's give it a run:\n ```{ignore,notrust}\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n+     Running target/lib-654ce120f310a3a5\n+\n+running 1 test\n+test math_checks_out ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+\n+     Running target/testing-6d7518593c7c3ee5\n \n running 0 tests\n \n test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n \n+     Running target/testing-8a94b31f7fd2e8fe\n \n running 0 tests\n \n test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n \n+   Doc-tests testing\n \n-running 1 test\n-test math_checks_out ... ok\n+running 0 tests\n \n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n ```\n \n Great! One test passed. We've got an integration test showing that our public\n@@ -3196,21 +3195,30 @@ If you run `cargo test`, you should get the same output:\n ```{ignore,notrust}\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n+     Running target/lib-654ce120f310a3a5\n+\n+running 1 test\n+test math_checks_out ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+\n+     Running target/testing-6d7518593c7c3ee5\n \n running 0 tests\n \n test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n \n+     Running target/testing-8a94b31f7fd2e8fe\n \n running 0 tests\n \n test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n \n+   Doc-tests testing\n \n-running 1 test\n-test math_checks_out ... ok\n+running 0 tests\n \n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n ```\n \n If we tried to write a test for these two new functions, it wouldn't\n@@ -3283,23 +3291,32 @@ Let's give it a shot:\n ```{ignore,notrust}\n $ cargo test\n    Compiling testing v0.0.1 (file:///home/you/projects/testing)\n+     Running target/lib-654ce120f310a3a5\n+\n+running 1 test\n+test math_checks_out ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n+\n+     Running target/testing-6d7518593c7c3ee5\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n+\n+     Running target/testing-8a94b31f7fd2e8fe\n \n running 2 tests\n test test::test_times_four ... ok\n test test::test_add_three ... ok\n \n test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured\n \n+   Doc-tests testing\n \n running 0 tests\n \n test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n-\n-\n-running 1 test\n-test math_checks_out ... ok\n-\n-test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\n ```\n \n Cool! We now have two tests of our internal functions. You'll note that there\n@@ -3637,40 +3654,72 @@ pub fn as_maybe_owned(&self) -> MaybeOwned<'a> { ... }\n \n ## Boxes\n \n-All of our references so far have been to variables we've created on the stack.\n-In Rust, the simplest way to allocate heap variables is using a *box*.  To\n-create a box, use the `box` keyword:\n+Most of the types we've seen so far have a fixed size or number of components.\n+The compiler needs this fact to lay out values in memory. However, some data\n+structures, such as a linked list, do not have a fixed size. You might think to\n+implement a linked list with an enum that's either a `Node` or the end of the\n+list (`Nil`), like this:\n+\n+```{rust,ignore}\n+enum List {             // error: illegal recursive enum type\n+    Node(u32, List),\n+    Nil\n+}\n+```\n+\n+But the compiler complains that the type is recursive, that is, it could be\n+arbitrarily large. To remedy this, Rust provides a fixed-size container called\n+a **box** that can hold any type. You can box up any value with the `box`\n+keyword. Our boxed List gets the type `Box<List>` (more on the notation when we\n+get to generics):\n \n ```{rust}\n-let x = box 5i;\n+enum List {\n+    Node(u32, Box<List>),\n+    Nil\n+}\n+\n+fn main() {\n+    let list = Node(0, box Node(1, box Nil));\n+}\n ```\n \n-This allocates an integer `5` on the heap, and creates a binding `x` that\n-refers to it. The great thing about boxed pointers is that we don't have to\n-manually free this allocation! If we write\n+A box dynamically allocates memory to hold its contents. The great thing about\n+Rust is that that memory is *automatically*, *efficiently*, and *predictably*\n+deallocated when you're done with the box.\n+\n+A box is a pointer type, and you access what's inside using the `*` operator,\n+just like regular references. This (rather silly) example dynamically allocates\n+an integer `5` and makes `x` a pointer to it:\n \n ```{rust}\n {\n     let x = box 5i;\n-    // do stuff\n+    println!(\"{}\", *x);     // Prints 5\n }\n ```\n \n-then Rust will automatically free `x` at the end of the block. This isn't\n-because Rust has a garbage collector -- it doesn't. Instead, when `x` goes out\n-of scope, Rust `free`s `x`. This Rust code will do the same thing as the\n-following C code:\n+The great thing about boxes is that we don't have to manually free this\n+allocation! Instead, when `x` reaches the end of its lifetime -- in this case,\n+when it goes out of scope at the end of the block -- Rust `free`s `x`. This\n+isn't because Rust has a garbage collector (it doesn't). Instead, by tracking\n+the ownership and lifetime of a variable (with a little help from you, the\n+programmer), the compiler knows precisely when it is no longer used.\n+\n+The Rust code above will do the same thing as the following C code:\n \n ```{c,ignore}\n {\n     int *x = (int *)malloc(sizeof(int));\n-    // do stuff\n+    if (!x) abort();\n+    *x = 5;\n+    printf(\"%d\\n\", *x);\n     free(x);\n }\n ```\n \n-This means we get the benefits of manual memory management, but the compiler\n-ensures that we don't do something wrong. We can't forget to `free` our memory.\n+We get the benefits of manual memory management, while ensuring we don't\n+introduce any bugs. We can't forget to `free` our memory.\n \n Boxes are the sole owner of their contents, so you cannot take a mutable\n reference to them and then use the original box:\n@@ -3706,48 +3755,50 @@ let mut x = box 5i;\n *x;\n ```\n \n-## Rc and Arc\n-\n-Sometimes, you need to allocate something on the heap, but give out multiple\n-references to the memory. Rust's `Rc<T>` (pronounced 'arr cee tee') and\n-`Arc<T>` types (again, the `T` is for generics, we'll learn more later) provide\n-you with this ability.  **Rc** stands for 'reference counted,' and **Arc** for\n-'atomically reference counted.' This is how Rust keeps track of the multiple\n-owners: every time we make a new reference to the `Rc<T>`, we add one to its\n-internal 'reference count.' Every time a reference goes out of scope, we\n-subtract one from the count. When the count is zero, the `Rc<T>` can be safely\n-deallocated. `Arc<T>` is almost identical to `Rc<T>`, except for one thing: The\n-'atomically' in 'Arc' means that increasing and decreasing the count uses a\n-thread-safe mechanism to do so. Why two types? `Rc<T>` is faster, so if you're\n-not in a multi-threaded scenario, you can have that advantage. Since we haven't\n-talked about threading yet in Rust, we'll show you `Rc<T>` for the rest of this\n-section.\n+Boxes are simple and efficient pointers to dynamically allocated values with a\n+single owner. They are useful for tree-like structures where the lifetime of a\n+child depends solely on the lifetime of its (single) parent. If you need a\n+value that must persist as long as any of several referrers, read on.\n \n-To create an `Rc<T>`, use `Rc::new()`:\n+## Rc and Arc\n \n-```{rust}\n-use std::rc::Rc;\n+Sometimes, you need a variable that is referenced from multiple places\n+(immutably!), lasting as long as any of those places, and disappearing when it\n+is no longer referenced. For instance, in a graph-like data structure, a node\n+might be referenced from all of its neighbors. In this case, it is not possible\n+for the compiler to determine ahead of time when the value can be freed -- it\n+needs a little run-time support.\n \n-let x = Rc::new(5i);\n-```\n+Rust's **Rc** type provides shared ownership of a dynamically allocated value\n+that is automatically freed at the end of its last owner's lifetime. (`Rc`\n+stands for 'reference counted,' referring to the way these library types are\n+implemented.) This provides more flexibility than single-owner boxes, but has\n+some runtime overhead.\n \n-To create a second reference, use the `.clone()` method:\n+To create an `Rc` value, use `Rc::new()`. To create a second owner, use the\n+`.clone()` method:\n \n ```{rust}\n use std::rc::Rc;\n \n let x = Rc::new(5i);\n let y = x.clone();\n+\n+println!(\"{} {}\", *x, *y);      // Prints 5 5\n ```\n \n-The `Rc<T>` will live as long as any of its references are alive. After they\n-all go out of scope, the memory will be `free`d.\n+The `Rc` will live as long as any of its owners are alive. After that, the\n+memory will be `free`d.\n+\n+**Arc** is an 'atomically reference counted' value, identical to `Rc` except\n+that ownership can be safely shared among multiple threads. Why two types?\n+`Arc` has more overhead, so if you're not in a multi-threaded scenario, you\n+don't have to pay the price.\n \n-If you use `Rc<T>` or `Arc<T>`, you have to be careful about introducing\n-cycles. If you have two `Rc<T>`s that point to each other, the reference counts\n-will never drop to zero, and you'll have a memory leak. To learn more, check\n-out [the section on `Rc<T>` and `Arc<T>` in the pointers\n-guide](guide-pointers.html#rc-and-arc).\n+If you use `Rc` or `Arc`, you have to be careful about introducing cycles. If\n+you have two `Rc`s that point to each other, they will happily keep each other\n+alive forever, creating a memory leak. To learn more, check out [the section on\n+`Rc` and `Arc` in the pointers guide](guide-pointers.html#rc-and-arc).\n \n # Patterns\n \n@@ -4220,7 +4271,7 @@ Remember Rust's `for` loop? Here's an example:\n \n ```{rust}\n for x in range(0i, 10i) {\n-    println!(\"{:d}\", x);\n+    println!(\"{}\", x);\n }\n ```\n \n@@ -4353,7 +4404,7 @@ is one:\n \n ```{rust}\n let greater_than_forty_two = range(0i, 100i)\n-                             .find(|x| *x >= 42);\n+                             .find(|x| *x > 42);\n \n match greater_than_forty_two {\n     Some(_) => println!(\"We got some numbers!\"),\n@@ -4474,7 +4525,7 @@ range(1i, 100i).map(|x| x + 1i);\n \n `map` is called upon another iterator, and produces a new iterator where each\n element reference has the closure it's been given as an argument called on it.\n-So this would give us the numbers from `2-101`. Well, almost! If you\n+So this would give us the numbers from `2-100`. Well, almost! If you\n compile the example, you'll get a warning:\n \n ```{notrust,ignore}\n@@ -5288,9 +5339,9 @@ There are two circumstances where Rust's safety provisions don't work well.\n The first is when interfacing with C code, and the second is when building\n certain kinds of abstractions.\n \n-Rust has support for FFI (which you can read about in the [FFI\n-Guide](guide-ffi.html)), but can't guarantee that the C code will be safe.\n-Therefore, Rust marks such functions with the `unsafe`\n+Rust has support for [FFI](http://en.wikipedia.org/wiki/Foreign_function_interface)\n+(which you can read about in the [FFI Guide](guide-ffi.html)), but can't guarantee\n+that the C code will be safe. Therefore, Rust marks such functions with the `unsafe`\n keyword, which indicates that the function may not behave properly.\n \n Second, if you'd like to create some sort of shared-memory data structure, Rust"}, {"sha": "8d54550a9f988d7e62f1d307e84f72d71db515ba", "filename": "src/doc/index.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -57,6 +57,7 @@ a guide that can help you out:\n * [Strings](guide-strings.html)\n * [Pointers](guide-pointers.html)\n * [References and Lifetimes](guide-lifetimes.html)\n+* [Crates and modules](guide-crates.html)\n * [Tasks and Communication](guide-tasks.html)\n * [Foreign Function Interface](guide-ffi.html)\n * [Writing Unsafe and Low-Level Code](guide-unsafe.html)"}, {"sha": "25f1a5fd3e2e40582b2c8c6d5890c5c9caabeda7", "filename": "src/doc/po4a.conf", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fdoc%2Fpo4a.conf", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fdoc%2Fpo4a.conf", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo4a.conf?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -19,6 +19,7 @@\n [type: text] src/doc/guide-tasks.md $lang:doc/l10n/$lang/guide-tasks.md\n [type: text] src/doc/guide-testing.md $lang:doc/l10n/$lang/guide-testing.md\n [type: text] src/doc/guide-unsafe.md $lang:doc/l10n/$lang/guide-unsafe.md\n+[type: text] src/doc/guide-unsafe.md $lang:doc/l10n/$lang/guide-crates.md\n [type: text] src/doc/guide.md $lang:doc/l10n/$lang/guide.md\n [type: text] src/doc/index.md $lang:doc/l10n/$lang/index.md\n [type: text] src/doc/intro.md $lang:doc/l10n/$lang/intro.md"}, {"sha": "f255dbf15071b6dc3852bace3c21aa7d706ab759", "filename": "src/etc/emacs/rust-mode-tests.el", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fetc%2Femacs%2Frust-mode-tests.el", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fetc%2Femacs%2Frust-mode-tests.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode-tests.el?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -376,7 +376,7 @@ fn bar(   a:int,\n           -> int\n { }\n \n-fn baz(   a:int,  // shoudl work with a comment here\n+fn baz(   a:int,  // should work with a comment here\n           b:char)\n           -> int\n { }"}, {"sha": "0e62fbb01441dcc1eee788fbdcc51a7a07a0d431", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -15,6 +15,7 @@\n \n use core::atomic;\n use core::clone::Clone;\n+use core::fmt::{mod, Show};\n use core::kinds::{Sync, Send};\n use core::mem::{min_align_of, size_of, drop};\n use core::mem;\n@@ -147,6 +148,12 @@ impl<T: Send + Sync> Deref<T> for Arc<T> {\n     }\n }\n \n+impl<T: Send + Sync + Show> Show for Arc<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        (**self).fmt(f)\n+    }\n+}\n+\n impl<T: Send + Sync + Clone> Arc<T> {\n     /// Acquires a mutable pointer to the inner contents by guaranteeing that\n     /// the reference count is one (no sharing is possible).\n@@ -280,6 +287,7 @@ mod tests {\n     use std::mem::drop;\n     use std::ops::Drop;\n     use std::option::{Option, Some, None};\n+    use std::str::Str;\n     use std::sync::atomic;\n     use std::task;\n     use std::vec::Vec;\n@@ -426,4 +434,10 @@ mod tests {\n         assert!(canary.load(atomic::Acquire) == 1);\n         drop(arc_weak);\n     }\n+\n+    #[test]\n+    fn show_arc() {\n+        let a = Arc::new(5u32);\n+        assert!(format!(\"{}\", a).as_slice() == \"5\")\n+    }\n }"}, {"sha": "77fb6d4a1203b360fa4e624cb382168fed73f62f", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -41,10 +41,10 @@ use ringbuf::RingBuf;\n /// the BST strategy.\n ///\n /// A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing\n-/// this, we reduce the number of allocations by a factor of B, and improve cache effeciency in\n+/// this, we reduce the number of allocations by a factor of B, and improve cache efficiency in\n /// searches. However, this does mean that searches will have to do *more* comparisons on average.\n /// The precise number of comparisons depends on the node search strategy used. For optimal cache\n-/// effeciency, one could search the nodes linearly. For optimal comparisons, one could search\n+/// efficiency, one could search the nodes linearly. For optimal comparisons, one could search\n /// the node using binary search. As a compromise, one could also perform a linear search\n /// that initially only checks every i<sup>th</sup> element for some choice of i.\n ///"}, {"sha": "4da362952b67c8fadec70ee436f7897644944da8", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -53,7 +53,7 @@ pub struct Node<K, V> {\n     // hard. For now, we accept this cost in the name of correctness and simplicity.\n     //\n     // As a compromise, keys and vals could be merged into one Vec<(K, V)>, which would shave\n-    // off 3 words, but possibly hurt our cache effeciency during search, which only cares about\n+    // off 3 words, but possibly hurt our cache efficiency during search, which only cares about\n     // keys. This would also avoid the Zip we use in our iterator implementations. This is\n     // probably worth investigating.\n     //\n@@ -72,7 +72,7 @@ impl<K: Ord, V> Node<K, V> {\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n     pub fn search(&self, key: &K) -> SearchResult {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n-        // For the B configured as of this writing (B = 6), binary search was *singnificantly*\n+        // For the B configured as of this writing (B = 6), binary search was *significantly*\n         // worse for uints.\n         self.search_linear(key)\n     }\n@@ -375,7 +375,7 @@ impl<K, V> Node<K, V> {\n         }\n     }\n \n-    /// Steal! Stealing is roughly analagous to a binary tree rotation.\n+    /// Steal! Stealing is roughly analogous to a binary tree rotation.\n     /// In this case, we're \"rotating\" right.\n     unsafe fn steal_to_left(&mut self, underflowed_child_index: uint) {\n         // Take the biggest stuff off left\n@@ -387,7 +387,7 @@ impl<K, V> Node<K, V> {\n             }\n         };\n \n-        // Swap the parent's seperating key-value pair with left's\n+        // Swap the parent's separating key-value pair with left's\n         self.unsafe_swap(underflowed_child_index - 1, &mut key, &mut val);\n \n         // Put them at the start of right\n@@ -402,7 +402,7 @@ impl<K, V> Node<K, V> {\n         }\n     }\n \n-    /// Steal! Stealing is roughly analagous to a binary tree rotation.\n+    /// Steal! Stealing is roughly analogous to a binary tree rotation.\n     /// In this case, we're \"rotating\" left.\n     unsafe fn steal_to_right(&mut self, underflowed_child_index: uint) {\n         // Take the smallest stuff off right\n@@ -414,7 +414,7 @@ impl<K, V> Node<K, V> {\n             }\n         };\n \n-        // Swap the parent's seperating key-value pair with right's\n+        // Swap the parent's separating key-value pair with right's\n         self.unsafe_swap(underflowed_child_index, &mut key, &mut val);\n \n         // Put them at the end of left\n@@ -430,9 +430,9 @@ impl<K, V> Node<K, V> {\n     }\n \n     /// Merge! Left and right will be smooshed into one node, along with the key-value\n-    /// pair that seperated them in their parent.\n+    /// pair that separated them in their parent.\n     unsafe fn merge_children(&mut self, left_index: uint) {\n-        // Permanently remove right's index, and the key-value pair that seperates\n+        // Permanently remove right's index, and the key-value pair that separates\n         // left and right\n         let (key, val, right) = {\n             match (self.keys.remove(left_index),\n@@ -448,7 +448,7 @@ impl<K, V> Node<K, V> {\n         left.absorb(key, val, right);\n     }\n \n-    /// Take all the values from right, seperated by the given key and value\n+    /// Take all the values from right, separated by the given key and value\n     fn absorb(&mut self, key: K, val: V, right: Node<K, V>) {\n         // Just as a sanity check, make sure we can fit this guy in\n         debug_assert!(self.len() + right.len() <= self.capacity())"}, {"sha": "d4115df7da4787e13e9c43e219d90d4606ea1c02", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -292,7 +292,7 @@ impl<T> BoxedSlice<T> for Box<[T]> {\n     #[experimental]\n     fn into_vec(mut self) -> Vec<T> {\n         unsafe {\n-            let xs = Vec::from_raw_parts(self.len(), self.len(), self.as_mut_ptr());\n+            let xs = Vec::from_raw_parts(self.as_mut_ptr(), self.len(), self.len());\n             mem::forget(self);\n             xs\n         }"}, {"sha": "c44a03b05cd35d7f3f6664dc68f0d871e1757cb6", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -780,7 +780,7 @@ pub mod raw {\n     #[inline]\n     pub unsafe fn from_parts(buf: *mut u8, length: uint, capacity: uint) -> String {\n         String {\n-            vec: Vec::from_raw_parts(length, capacity, buf),\n+            vec: Vec::from_raw_parts(buf, length, capacity),\n         }\n     }\n "}, {"sha": "765c9827cb79f6ac1414e3c55144d74733e22e5d", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -103,9 +103,9 @@ use slice::{Items, MutItems};\n #[unsafe_no_drop_flag]\n #[stable]\n pub struct Vec<T> {\n+    ptr: *mut T,\n     len: uint,\n     cap: uint,\n-    ptr: *mut T\n }\n \n impl<T> Vec<T> {\n@@ -125,7 +125,7 @@ impl<T> Vec<T> {\n         // non-null value which is fine since we never call deallocate on the ptr\n         // if cap is 0. The reason for this is because the pointer of a slice\n         // being NULL would break the null pointer optimization for enums.\n-        Vec { len: 0, cap: 0, ptr: EMPTY as *mut T }\n+        Vec { ptr: EMPTY as *mut T, len: 0, cap: 0 }\n     }\n \n     /// Constructs a new, empty `Vec` with the specified capacity.\n@@ -159,14 +159,14 @@ impl<T> Vec<T> {\n     #[stable]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n-            Vec { len: 0, cap: uint::MAX, ptr: EMPTY as *mut T }\n+            Vec { ptr: EMPTY as *mut T, len: 0, cap: uint::MAX }\n         } else if capacity == 0 {\n             Vec::new()\n         } else {\n             let size = capacity.checked_mul(&mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             let ptr = unsafe { allocate(size, mem::min_align_of::<T>()) };\n-            Vec { len: 0, cap: capacity, ptr: ptr as *mut T }\n+            Vec { ptr: ptr as *mut T, len: 0, cap: capacity }\n         }\n     }\n \n@@ -231,15 +231,15 @@ impl<T> Vec<T> {\n     ///         }\n     ///\n     ///         // Put everything back together into a Vec\n-    ///         let rebuilt = Vec::from_raw_parts(len, cap, p);\n+    ///         let rebuilt = Vec::from_raw_parts(p, len, cap);\n     ///         assert_eq!(rebuilt, vec![4i, 5i, 6i]);\n     ///     }\n     /// }\n     /// ```\n     #[experimental]\n-    pub unsafe fn from_raw_parts(length: uint, capacity: uint,\n-                                 ptr: *mut T) -> Vec<T> {\n-        Vec { len: length, cap: capacity, ptr: ptr }\n+    pub unsafe fn from_raw_parts(ptr: *mut T, length: uint,\n+                                 capacity: uint) -> Vec<T> {\n+        Vec { ptr: ptr, len: length, cap: capacity }\n     }\n \n     /// Consumes the `Vec`, partitioning it based on a predicate.\n@@ -1680,7 +1680,7 @@ impl<'a, T> Drop for DerefVec<'a, T> {\n pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n     unsafe {\n         DerefVec {\n-            x: Vec::from_raw_parts(x.len(), x.len(), x.as_ptr() as *mut T),\n+            x: Vec::from_raw_parts(x.as_ptr() as *mut T, x.len(), x.len()),\n             l: ContravariantLifetime::<'a>\n         }\n     }\n@@ -1929,7 +1929,7 @@ impl<T> Vec<T> {\n                 let vec_cap = pv.vec.capacity();\n                 let vec_ptr = pv.vec.as_mut_ptr() as *mut U;\n                 mem::forget(pv);\n-                Vec::from_raw_parts(vec_len, vec_cap, vec_ptr)\n+                Vec::from_raw_parts(vec_ptr, vec_len, vec_cap)\n             }\n         } else {\n             // Put the `Vec` into the `PartialVecZeroSized` structure and"}, {"sha": "fe365b43ca6d1838e860f0254e2de10ce92b0c1b", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -21,18 +21,21 @@\n use mem;\n \n /// The representation of a Rust slice\n+#[repr(C)]\n pub struct Slice<T> {\n     pub data: *const T,\n     pub len: uint,\n }\n \n /// The representation of a Rust closure\n+#[repr(C)]\n pub struct Closure {\n     pub code: *mut (),\n     pub env: *mut (),\n }\n \n /// The representation of a Rust procedure (`proc()`)\n+#[repr(C)]\n pub struct Procedure {\n     pub code: *mut (),\n     pub env: *mut (),\n@@ -42,6 +45,7 @@ pub struct Procedure {\n ///\n /// This struct does not have a `Repr` implementation\n /// because there is no way to refer to all trait objects generically.\n+#[repr(C)]\n pub struct TraitObject {\n     pub data: *mut (),\n     pub vtable: *mut (),\n@@ -60,4 +64,3 @@ pub trait Repr<T> {\n \n impl<'a, T> Repr<Slice<T>> for &'a [T] {}\n impl<'a> Repr<Slice<u8>> for &'a str {}\n-"}, {"sha": "97e68bcbb2c6ca52d0c316b8e6cebc199152f7c6", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -173,7 +173,7 @@ impl<'a> SeedableRng<&'a [u32]> for ChaChaRng {\n     fn reseed(&mut self, seed: &'a [u32]) {\n         // reset state\n         self.init(&[0u32, ..KEY_WORDS]);\n-        // set key inplace\n+        // set key in place\n         let key = self.state.slice_mut(4, 4+KEY_WORDS);\n         for (k, s) in key.iter_mut().zip(seed.iter()) {\n             *k = *s;"}, {"sha": "474e8e45d94c265893097b637c6f5566e9ab9c0f", "filename": "src/librustc/back/write.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fwrite.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -714,7 +714,13 @@ pub fn run_passes(sess: &Session,\n            .stdout(::std::io::process::InheritFd(1))\n            .stderr(::std::io::process::InheritFd(2));\n         match cmd.status() {\n-            Ok(_) => {},\n+            Ok(status) => {\n+                if !status.success() {\n+                    sess.err(format!(\"linking of {} with `{}` failed\",\n+                                     output_path.display(), cmd).as_slice());\n+                    sess.abort_if_errors();\n+                }\n+            },\n             Err(e) => {\n                 sess.err(format!(\"could not exec the linker `{}`: {}\",\n                                  pname,"}, {"sha": "9db79074d1fd12b0b0a62fb6901a7ba6541dd344", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -36,6 +36,7 @@ register_diagnostics!(\n     E0015,\n     E0016,\n     E0017,\n+    E0018,\n     E0019,\n     E0020,\n     E0022,"}, {"sha": "de61f4f2b404c78a46b7defe3b9d719c2e572e9c", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -777,13 +777,28 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         // Otherwise, just a plain error.\n         match assignee_cmt.note {\n             mc::NoteClosureEnv(upvar_id) => {\n-                self.bccx.span_err(\n-                    assignment_span,\n-                    format!(\"cannot assign to {}\",\n-                            self.bccx.cmt_to_string(&*assignee_cmt)).as_slice());\n-                self.bccx.span_note(\n-                    self.tcx().map.span(upvar_id.closure_expr_id),\n-                    \"consider changing this closure to take self by mutable reference\");\n+                // If this is an `Fn` closure, it simply can't mutate upvars.\n+                // If it's an `FnMut` closure, the original variable was declared immutable.\n+                // We need to determine which is the case here.\n+                let kind = match assignee_cmt.upvar().unwrap().cat {\n+                    mc::cat_upvar(mc::Upvar { kind, .. }) => kind,\n+                    _ => unreachable!()\n+                };\n+                if kind == ty::FnUnboxedClosureKind {\n+                    self.bccx.span_err(\n+                        assignment_span,\n+                        format!(\"cannot assign to {}\",\n+                                self.bccx.cmt_to_string(&*assignee_cmt)).as_slice());\n+                    self.bccx.span_note(\n+                        self.tcx().map.span(upvar_id.closure_expr_id),\n+                        \"consider changing this closure to take self by mutable reference\");\n+                } else {\n+                    self.bccx.span_err(\n+                        assignment_span,\n+                        format!(\"cannot assign to {} {}\",\n+                                assignee_cmt.mutbl.to_user_str(),\n+                                self.bccx.cmt_to_string(&*assignee_cmt)).as_slice());\n+                }\n             }\n             _ => match opt_loan_path(&assignee_cmt) {\n                 Some(lp) => {\n@@ -825,12 +840,20 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     mc::cat_rvalue(..) |\n                     mc::cat_static_item |\n                     mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-                    mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n                     mc::cat_deref(_, _, mc::Implicit(..)) => {\n                         assert_eq!(cmt.mutbl, mc::McDeclared);\n                         return;\n                     }\n \n+                    mc::cat_deref(_, _, mc::BorrowedPtr(..)) => {\n+                        assert_eq!(cmt.mutbl, mc::McDeclared);\n+                        // We need to drill down to upvar if applicable\n+                        match cmt.upvar() {\n+                            Some(b) => cmt = b,\n+                            None => return\n+                        }\n+                    }\n+\n                     mc::cat_deref(b, _, mc::OwnedPtr) => {\n                         assert_eq!(cmt.mutbl, mc::McInherited);\n                         cmt = b;"}, {"sha": "b09e9105f3f6be4102905f05b1fd38fc56bc8329", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -625,7 +625,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         match err.code {\n             err_mutbl => {\n                 let descr = match err.cmt.note {\n-                    mc::NoteClosureEnv(_) => {\n+                    mc::NoteClosureEnv(_) | mc::NoteUpvarRef(_) => {\n                         self.cmt_to_string(&*err.cmt)\n                     }\n                     _ => match opt_loan_path(&err.cmt) {\n@@ -761,11 +761,20 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         match code {\n             err_mutbl(..) => {\n                 match err.cmt.note {\n-                    mc::NoteClosureEnv(upvar_id) => {\n-                        self.tcx.sess.span_note(\n-                            self.tcx.map.span(upvar_id.closure_expr_id),\n-                            \"consider changing this closure to take \\\n-                             self by mutable reference\");\n+                    mc::NoteClosureEnv(upvar_id) | mc::NoteUpvarRef(upvar_id) => {\n+                        // If this is an `Fn` closure, it simply can't mutate upvars.\n+                        // If it's an `FnMut` closure, the original variable was declared immutable.\n+                        // We need to determine which is the case here.\n+                        let kind = match err.cmt.upvar().unwrap().cat {\n+                            mc::cat_upvar(mc::Upvar { kind, .. }) => kind,\n+                            _ => unreachable!()\n+                        };\n+                        if kind == ty::FnUnboxedClosureKind {\n+                            self.tcx.sess.span_note(\n+                                self.tcx.map.span(upvar_id.closure_expr_id),\n+                                \"consider changing this closure to take \\\n+                                 self by mutable reference\");\n+                        }\n                     }\n                     _ => {}\n                 }"}, {"sha": "6cf1a93b40b7b85d52eeb276653c1d1ce019646a", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -119,12 +119,18 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n             }\n         }\n         ExprLit(_) => (),\n-        ExprCast(_, _) => {\n-            let ety = ty::expr_ty(v.tcx, e);\n-            if !ty::type_is_numeric(ety) && !ty::type_is_unsafe_ptr(ety) {\n+        ExprCast(ref from, _) => {\n+            let toty = ty::expr_ty(v.tcx, e);\n+            let fromty = ty::expr_ty(v.tcx, &**from);\n+            if !ty::type_is_numeric(toty) && !ty::type_is_unsafe_ptr(toty) {\n                 span_err!(v.tcx.sess, e.span, E0012,\n                           \"can not cast to `{}` in a constant expression\",\n-                          ppaux::ty_to_string(v.tcx, ety));\n+                          ppaux::ty_to_string(v.tcx, toty));\n+            }\n+            if ty::type_is_unsafe_ptr(fromty) && ty::type_is_numeric(toty) {\n+                span_err!(v.tcx.sess, e.span, E0018,\n+                          \"can not cast a pointer to an integer in a constant \\\n+                           expression\");\n             }\n         }\n         ExprPath(ref pth) => {"}, {"sha": "fe38669ea6c29a89c5c19036def93c242238af88", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -421,7 +421,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n                         node: FieldPat {\n                             ident: Ident::new(field.name),\n                             pat: pat,\n-                            is_shorthand: true,\n+                            is_shorthand: false,\n                         }\n                     }).collect();\n                 let has_more_fields = field_pats.len() < pats_len;"}, {"sha": "3d6b319ac0d62077de387023795afbba87750727", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -341,7 +341,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<Pat> {\n                 node: FieldPat {\n                     ident: field.ident.node,\n                     pat: const_expr_to_pat(tcx, &*field.expr),\n-                    is_shorthand: true,\n+                    is_shorthand: false,\n                 },\n             }).collect();\n             PatStruct(path.clone(), field_pats, false)"}, {"sha": "08e14e8034e9eff6d57ee30005978d76ce31b263", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 69, "deletions": 62, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -655,51 +655,54 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // FnOnce         | copied               | upvar -> &'up bk\n         // old stack      | N/A                  | upvar -> &'env mut -> &'up bk\n         // old proc/once  | copied               | N/A\n+        let var_ty = if_ok!(self.node_ty(var_id));\n+\n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n \n-        // Do we need to deref through an env reference?\n-        let has_env_deref = kind != ty::FnOnceUnboxedClosureKind;\n-\n         // Mutability of original variable itself\n         let var_mutbl = MutabilityCategory::from_local(self.tcx(), var_id);\n \n-        // Mutability of environment dereference\n-        let env_mutbl = match kind {\n-            ty::FnOnceUnboxedClosureKind => var_mutbl,\n-            ty::FnMutUnboxedClosureKind => McInherited,\n-            ty::FnUnboxedClosureKind => McImmutable\n+        // Construct information about env pointer dereference, if any\n+        let mutbl = match kind {\n+            ty::FnOnceUnboxedClosureKind => None, // None, env is by-value\n+            ty::FnMutUnboxedClosureKind => match mode { // Depends on capture type\n+                ast::CaptureByValue => Some(var_mutbl), // Mutable if the original var is\n+                ast::CaptureByRef => Some(McDeclared) // Mutable regardless\n+            },\n+            ty::FnUnboxedClosureKind => Some(McImmutable) // Never mutable\n         };\n+        let env_info = mutbl.map(|env_mutbl| {\n+            // Look up the node ID of the closure body so we can construct\n+            // a free region within it\n+            let fn_body_id = {\n+                let fn_expr = match self.tcx().map.find(fn_node_id) {\n+                    Some(ast_map::NodeExpr(e)) => e,\n+                    _ => unreachable!()\n+                };\n \n-        // Look up the node ID of the closure body so we can construct\n-        // a free region within it\n-        let fn_body_id = {\n-            let fn_expr = match self.tcx().map.find(fn_node_id) {\n-                Some(ast_map::NodeExpr(e)) => e,\n-                _ => unreachable!()\n+                match fn_expr.node {\n+                    ast::ExprFnBlock(_, _, ref body) |\n+                    ast::ExprProc(_, ref body) |\n+                    ast::ExprUnboxedFn(_, _, _, ref body) => body.id,\n+                    _ => unreachable!()\n+                }\n             };\n \n-            match fn_expr.node {\n-                ast::ExprFnBlock(_, _, ref body) |\n-                ast::ExprProc(_, ref body) |\n-                ast::ExprUnboxedFn(_, _, _, ref body) => body.id,\n-                _ => unreachable!()\n-            }\n-        };\n+            // Region of environment pointer\n+            let env_region = ty::ReFree(ty::FreeRegion {\n+                scope_id: fn_body_id,\n+                bound_region: ty::BrEnv\n+            });\n \n-        // Region of environment pointer\n-        let env_region = ty::ReFree(ty::FreeRegion {\n-            scope_id: fn_body_id,\n-            bound_region: ty::BrEnv\n-        });\n-\n-        let env_ptr = BorrowedPtr(if env_mutbl.is_mutable() {\n-            ty::MutBorrow\n-        } else {\n-            ty::ImmBorrow\n-        }, env_region);\n+            let env_ptr = BorrowedPtr(if env_mutbl.is_mutable() {\n+                ty::MutBorrow\n+            } else {\n+                ty::ImmBorrow\n+            }, env_region);\n \n-        let var_ty = if_ok!(self.node_ty(var_id));\n+            (env_mutbl, env_ptr)\n+        });\n \n         // First, switch by capture mode\n         Ok(match mode {\n@@ -717,25 +720,27 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     note: NoteNone\n                 };\n \n-                if has_env_deref {\n-                    // We need to add the env deref.  This means that\n-                    // the above is actually immutable and has a ref\n-                    // type.  However, nothing should actually look at\n-                    // the type, so we can get away with stuffing a\n-                    // `ty_err` in there instead of bothering to\n-                    // construct a proper one.\n-                    base.mutbl = McImmutable;\n-                    base.ty = ty::mk_err();\n-                    Rc::new(cmt_ {\n-                        id: id,\n-                        span: span,\n-                        cat: cat_deref(Rc::new(base), 0, env_ptr),\n-                        mutbl: env_mutbl,\n-                        ty: var_ty,\n-                        note: NoteClosureEnv(upvar_id)\n-                    })\n-                } else {\n-                    Rc::new(base)\n+                match env_info {\n+                    Some((env_mutbl, env_ptr)) => {\n+                        // We need to add the env deref.  This means\n+                        // that the above is actually immutable and\n+                        // has a ref type.  However, nothing should\n+                        // actually look at the type, so we can get\n+                        // away with stuffing a `ty_err` in there\n+                        // instead of bothering to construct a proper\n+                        // one.\n+                        base.mutbl = McImmutable;\n+                        base.ty = ty::mk_err();\n+                        Rc::new(cmt_ {\n+                            id: id,\n+                            span: span,\n+                            cat: cat_deref(Rc::new(base), 0, env_ptr),\n+                            mutbl: env_mutbl,\n+                            ty: var_ty,\n+                            note: NoteClosureEnv(upvar_id)\n+                        })\n+                    }\n+                    None => Rc::new(base)\n                 }\n             },\n             ast::CaptureByRef => {\n@@ -755,16 +760,18 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     note: NoteNone\n                 };\n \n-                // As in the by-value case, add env deref if needed\n-                if has_env_deref {\n-                    base = cmt_ {\n-                        id: id,\n-                        span: span,\n-                        cat: cat_deref(Rc::new(base), 0, env_ptr),\n-                        mutbl: env_mutbl,\n-                        ty: ty::mk_err(),\n-                        note: NoteClosureEnv(upvar_id)\n-                    };\n+                match env_info {\n+                    Some((env_mutbl, env_ptr)) => {\n+                        base = cmt_ {\n+                            id: id,\n+                            span: span,\n+                            cat: cat_deref(Rc::new(base), 0, env_ptr),\n+                            mutbl: env_mutbl,\n+                            ty: ty::mk_err(),\n+                            note: NoteClosureEnv(upvar_id)\n+                        };\n+                    }\n+                    None => {}\n                 }\n \n                 // Look up upvar borrow so we can get its region"}, {"sha": "c014bc0c164f206dce9b7c1180382c215b0d846f", "filename": "src/librustc/middle/traits/doc.rs", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -279,4 +279,132 @@ selection. This is because it must account for the transformed self\n type of the receiver and various other complications. The procedure is\n described in `select.rs` in the \"METHOD MATCHING\" section.\n \n+# Caching and subtle considerations therewith\n+\n+In general we attempt to cache the results of trait selection.  This\n+is a somewhat complex process. Part of the reason for this is that we\n+want to be able to cache results even when all the types in the trait\n+reference are not fully known. In that case, it may happen that the\n+trait selection process is also influencing type variables, so we have\n+to be able to not only cache the *result* of the selection process,\n+but *replay* its effects on the type variables.\n+\n+## An example\n+\n+The high-level idea of how the cache works is that we first replace\n+all unbound inference variables with skolemized versions. Therefore,\n+if we had a trait reference `uint : Foo<$1>`, where `$n` is an unbound\n+inference variable, we might replace it with `uint : Foo<%0>`, where\n+`%n` is a skolemized type. We would then look this up in the cache.\n+If we found a hit, the hit would tell us the immediate next step to\n+take in the selection process: i.e., apply impl #22, or apply where\n+clause `X : Foo<Y>`. Let's say in this case there is no hit.\n+Therefore, we search through impls and where clauses and so forth, and\n+we come to the conclusion that the only possible impl is this one,\n+with def-id 22:\n+\n+    impl Foo<int> for uint { ... } // Impl #22\n+\n+We would then record in the cache `uint : Foo<%0> ==>\n+ImplCandidate(22)`. Next we would confirm `ImplCandidate(22)`, which\n+would (as a side-effect) unify `$1` with `int`.\n+\n+Now, at some later time, we might come along and see a `uint :\n+Foo<$3>`.  When skolemized, this would yield `uint : Foo<%0>`, just as\n+before, and hence the cache lookup would succeed, yielding\n+`ImplCandidate(22)`. We would confirm `ImplCandidate(22)` which would\n+(as a side-effect) unify `$3` with `int`.\n+\n+## Where clauses and the local vs global cache\n+\n+One subtle interaction is that the results of trait lookup will vary\n+depending on what where clauses are in scope. Therefore, we actually\n+have *two* caches, a local and a global cache. The local cache is\n+attached to the `ParameterEnvironment` and the global cache attached\n+to the `tcx`. We use the local cache whenever the result might depend\n+on the where clauses that are in scope. The determination of which\n+cache to use is done by the method `pick_candidate_cache` in\n+`select.rs`.\n+\n+There are two cases where we currently use the local cache. The\n+current rules are probably more conservative than necessary.\n+\n+### Trait references that involve parameter types\n+\n+The most obvious case where you need the local environment is\n+when the trait reference includes parameter types. For example,\n+consider the following function:\n+\n+    impl<T> Vec<T> {\n+        fn foo(x: T)\n+            where T : Foo\n+        { ... }\n+\n+        fn bar(x: T)\n+        { ... }\n+    }\n+\n+If there is an obligation `T : Foo`, or `int : Bar<T>`, or whatever,\n+clearly the results from `foo` and `bar` are potentially different,\n+since the set of where clauses in scope are different.\n+\n+### Trait references with unbound variables when where clauses are in scope\n+\n+There is another less obvious interaction which involves unbound variables\n+where *only* where clauses are in scope (no impls). This manifested as\n+issue #18209 (`run-pass/trait-cache-issue-18209.rs`). Consider\n+this snippet:\n+\n+```\n+pub trait Foo {\n+    fn load_from() -> Box<Self>;\n+    fn load() -> Box<Self> {\n+        Foo::load_from()\n+    }\n+}\n+```\n+\n+The default method will incur an obligation `$0 : Foo` from the call\n+to `load_from`. If there are no impls, this can be eagerly resolved to\n+`VtableParam(Self : Foo)` and cached. Because the trait reference\n+doesn't involve any parameters types (only the resolution does), this\n+result was stored in the global cache, causing later calls to\n+`Foo::load_from()` to get nonsense.\n+\n+To fix this, we always use the local cache if there are unbound\n+variables and where clauses in scope. This is more conservative than\n+necessary as far as I can tell. However, it still seems to be a simple\n+rule and I observe ~99% hit rate on rustc, so it doesn't seem to hurt\n+us in particular.\n+\n+Here is an example of the kind of subtle case that I would be worried\n+about with a more complex rule (although this particular case works\n+out ok). Imagine the trait reference doesn't directly reference a\n+where clause, but the where clause plays a role in the winnowing\n+phase. Something like this:\n+\n+```\n+pub trait Foo<T> { ... }\n+pub trait Bar { ... }\n+impl<U,T:Bar> Foo<U> for T { ... } // Impl A\n+impl Foo<char> for uint { ... }    // Impl B\n+```\n+\n+Now, in some function, we have no where clauses in scope, and we have\n+an obligation `$1 : Foo<$0>`. We might then conclude that `$0=char`\n+and `$1=uint`: this is because for impl A to apply, `uint:Bar` would\n+have to hold, and we know it does not or else the coherence check\n+would have failed.  So we might enter into our global cache: `$1 :\n+Foo<$0> => Impl B`.  Then we come along in a different scope, where a\n+generic type `A` is around with the bound `A:Bar`. Now suddenly the\n+impl is viable.\n+\n+The flaw in this imaginary DOOMSDAY SCENARIO is that we would not\n+currently conclude that `$1 : Foo<$0>` implies that `$0 == uint` and\n+`$1 == char`, even though it is true that (absent type parameters)\n+there is no other type the user could enter. However, it is not\n+*completely* implausible that we *could* draw this conclusion in the\n+future; we wouldn't have to guess types, in particular, we could be\n+led by the impls.\n+\n */"}, {"sha": "8f1fcf77ee38a6f565793d0c1abb03bf35bef809", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -211,7 +211,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // can be applied to particular types. It skips the \"confirmation\"\n     // step and hence completely ignores output type parameters.\n     //\n-    // The result is \"true\" if the obliation *may* hold and \"false\" if\n+    // The result is \"true\" if the obligation *may* hold and \"false\" if\n     // we can be sure it does not.\n \n     pub fn evaluate_obligation_intercrate(&mut self,\n@@ -844,19 +844,36 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             cache_skol_trait_ref: &Rc<ty::TraitRef>)\n                             -> &SelectionCache\n     {\n+        // High-level idea: we have to decide whether to consult the\n+        // cache that is specific to this scope, or to consult the\n+        // global cache. We want the cache that is specific to this\n+        // scope whenever where clauses might affect the result.\n+\n         // If the trait refers to any parameters in scope, then use\n-        // the cache of the param-environment. This is because the\n-        // result will depend on the where clauses that are in\n-        // scope. Otherwise, use the generic tcx cache, since the\n-        // result holds across all environments.\n+        // the cache of the param-environment.\n         if\n             cache_skol_trait_ref.input_types().iter().any(\n                 |&t| ty::type_has_self(t) || ty::type_has_params(t))\n         {\n-            &self.param_env.selection_cache\n-        } else {\n-            &self.tcx().selection_cache\n+            return &self.param_env.selection_cache;\n         }\n+\n+        // If the trait refers to unbound type variables, and there\n+        // are where clauses in scope, then use the local environment.\n+        // If there are no where clauses in scope, which is a very\n+        // common case, then we can use the global environment.\n+        // See the discussion in doc.rs for more details.\n+        if\n+            !self.param_env.caller_obligations.is_empty()\n+            &&\n+            cache_skol_trait_ref.input_types().iter().any(\n+                |&t| ty::type_has_ty_infer(t))\n+        {\n+            return &self.param_env.selection_cache;\n+        }\n+\n+        // Otherwise, we can use the global cache.\n+        &self.tcx().selection_cache\n     }\n \n     fn check_candidate_cache(&mut self,\n@@ -1935,26 +1952,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         util::obligations_for_generics(self.tcx(), cause, recursion_depth,\n                                        &impl_generics, impl_substs)\n     }\n-\n-    fn contains_skolemized_types(&self,\n-                                 ty: ty::t)\n-                                 -> bool\n-    {\n-        /*!\n-         * True if the type contains skolemized variables.\n-         */\n-\n-        let mut found_skol = false;\n-\n-        ty::walk_ty(ty, |t| {\n-            match ty::get(t).sty {\n-                ty::ty_infer(ty::SkolemizedTy(_)) => { found_skol = true; }\n-                _ => { }\n-            }\n-        });\n-\n-        found_skol\n-    }\n }\n \n impl Repr for Candidate {"}, {"sha": "622da4840b047bee4eccf44f8602b8d809a208a8", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -940,6 +940,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             controlflow::trans_loop(bcx, expr.id, &**body)\n         }\n         ast::ExprAssign(ref dst, ref src) => {\n+            let src_datum = unpack_datum!(bcx, trans(bcx, &**src));\n             let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &**dst, \"assign\"));\n \n             if ty::type_needs_drop(bcx.tcx(), dst_datum.ty) {\n@@ -960,7 +961,6 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // We could avoid this intermediary with some analysis\n                 // to determine whether `dst` may possibly own `src`.\n                 debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n-                let src_datum = unpack_datum!(bcx, trans(bcx, &**src));\n                 let src_datum = unpack_datum!(\n                     bcx, src_datum.to_rvalue_datum(bcx, \"ExprAssign\"));\n                 bcx = glue::drop_ty(bcx,\n@@ -969,7 +969,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     Some(NodeInfo { id: expr.id, span: expr.span }));\n                 src_datum.store_to(bcx, dst_datum.val)\n             } else {\n-                trans_into(bcx, &**src, SaveIn(dst_datum.to_llref()))\n+                src_datum.store_to(bcx, dst_datum.val)\n             }\n         }\n         ast::ExprAssignOp(op, ref dst, ref src) => {\n@@ -2117,7 +2117,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 deref_owned_pointer(bcx, expr, datum, content_ty)\n             } else {\n                 // A fat pointer and an opened DST value have the same\n-                // represenation just different types. Since there is no\n+                // representation just different types. Since there is no\n                 // temporary for `*e` here (because it is unsized), we cannot\n                 // emulate the sized object code path for running drop glue and\n                 // free. Instead, we schedule cleanup for `e`, turning it into\n@@ -2142,7 +2142,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // owner (or, in the case of *T, by the user).\n                 DatumBlock::new(bcx, Datum::new(ptr, content_ty, LvalueExpr))\n             } else {\n-                // A fat pointer and an opened DST value have the same represenation\n+                // A fat pointer and an opened DST value have the same representation\n                 // just different types.\n                 DatumBlock::new(bcx, Datum::new(datum.val,\n                                                 ty::mk_open(bcx.tcx(), content_ty),"}, {"sha": "569c256a738b13966c8a7e6537c89401c160fbc6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 73, "deletions": 59, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -585,17 +585,22 @@ pub struct ctxt<'tcx> {\n     pub repr_hint_cache: RefCell<DefIdMap<Rc<Vec<attr::ReprAttr>>>>,\n }\n \n-pub enum tbox_flag {\n-    has_params = 1,\n-    has_self = 2,\n-    needs_infer = 4,\n-    has_regions = 8,\n-    has_ty_err = 16,\n-    has_ty_bot = 32,\n-\n-    // a meta-pub flag: subst may be required if the type has parameters, a self\n-    // type, or references bound regions\n-    needs_subst = 1 | 2 | 8\n+// Flags that we track on types. These flags are propagated upwards\n+// through the type during type construction, so that we can quickly\n+// check whether the type has various kinds of types in it without\n+// recursing over the type itself.\n+bitflags! {\n+    flags TypeFlags: u32 {\n+        const NO_TYPE_FLAGS = 0b0,\n+        const HAS_PARAMS    = 0b1,\n+        const HAS_SELF      = 0b10,\n+        const HAS_TY_INFER  = 0b100,\n+        const HAS_RE_INFER  = 0b1000,\n+        const HAS_REGIONS   = 0b10000,\n+        const HAS_TY_ERR    = 0b100000,\n+        const HAS_TY_BOT    = 0b1000000,\n+        const NEEDS_SUBST   = HAS_PARAMS.bits | HAS_SELF.bits | HAS_REGIONS.bits,\n+    }\n }\n \n pub type t_box = &'static t_box_;\n@@ -604,7 +609,13 @@ pub type t_box = &'static t_box_;\n pub struct t_box_ {\n     pub sty: sty,\n     pub id: uint,\n-    pub flags: uint,\n+    pub flags: TypeFlags,\n+}\n+\n+impl fmt::Show for TypeFlags {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.bits)\n+    }\n }\n \n // To reduce refcounting cost, we're representing types as unsafe pointers\n@@ -631,15 +642,16 @@ pub fn get(t: t) -> t_box {\n     }\n }\n \n-pub fn tbox_has_flag(tb: t_box, flag: tbox_flag) -> bool {\n-    (tb.flags & (flag as uint)) != 0u\n+fn tbox_has_flag(tb: t_box, flag: TypeFlags) -> bool {\n+    tb.flags.intersects(flag)\n }\n pub fn type_has_params(t: t) -> bool {\n-    tbox_has_flag(get(t), has_params)\n+    tbox_has_flag(get(t), HAS_PARAMS)\n }\n-pub fn type_has_self(t: t) -> bool { tbox_has_flag(get(t), has_self) }\n+pub fn type_has_self(t: t) -> bool { tbox_has_flag(get(t), HAS_SELF) }\n+pub fn type_has_ty_infer(t: t) -> bool { tbox_has_flag(get(t), HAS_TY_INFER) }\n pub fn type_needs_infer(t: t) -> bool {\n-    tbox_has_flag(get(t), needs_infer)\n+    tbox_has_flag(get(t), HAS_TY_INFER | HAS_RE_INFER)\n }\n pub fn type_id(t: t) -> uint { get(t).id }\n \n@@ -886,7 +898,7 @@ mod primitives {\n             pub static $name: t_box_ = t_box_ {\n                 sty: $sty,\n                 id: $id,\n-                flags: 0,\n+                flags: super::NO_TYPE_FLAGS,\n             };\n         )\n     )\n@@ -910,13 +922,13 @@ mod primitives {\n     pub static TY_BOT: t_box_ = t_box_ {\n         sty: super::ty_bot,\n         id: 16,\n-        flags: super::has_ty_bot as uint,\n+        flags: super::HAS_TY_BOT,\n     };\n \n     pub static TY_ERR: t_box_ = t_box_ {\n         sty: super::ty_err,\n         id: 17,\n-        flags: super::has_ty_err as uint,\n+        flags: super::HAS_TY_ERR,\n     };\n \n     pub const LAST_PRIMITIVE_ID: uint = 18;\n@@ -1577,91 +1589,91 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         _ => ()\n     }\n \n-    let mut flags = 0u;\n-    fn rflags(r: Region) -> uint {\n-        (has_regions as uint) | {\n+    let mut flags = NO_TYPE_FLAGS;\n+    fn rflags(r: Region) -> TypeFlags {\n+        HAS_REGIONS | {\n             match r {\n-              ty::ReInfer(_) => needs_infer as uint,\n-              _ => 0u\n+              ty::ReInfer(_) => HAS_RE_INFER,\n+              _ => NO_TYPE_FLAGS,\n             }\n         }\n     }\n-    fn sflags(substs: &Substs) -> uint {\n-        let mut f = 0u;\n+    fn sflags(substs: &Substs) -> TypeFlags {\n+        let mut f = NO_TYPE_FLAGS;\n         let mut i = substs.types.iter();\n         for tt in i {\n-            f |= get(*tt).flags;\n+            f = f | get(*tt).flags;\n         }\n         match substs.regions {\n             subst::ErasedRegions => {}\n             subst::NonerasedRegions(ref regions) => {\n                 for r in regions.iter() {\n-                    f |= rflags(*r)\n+                    f = f | rflags(*r)\n                 }\n             }\n         }\n         return f;\n     }\n-    fn flags_for_bounds(bounds: &ExistentialBounds) -> uint {\n+    fn flags_for_bounds(bounds: &ExistentialBounds) -> TypeFlags {\n         rflags(bounds.region_bound)\n     }\n     match &st {\n       &ty_nil | &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n       &ty_str => {}\n       // You might think that we could just return ty_err for\n       // any type containing ty_err as a component, and get\n-      // rid of the has_ty_err flag -- likewise for ty_bot (with\n+      // rid of the HAS_TY_ERR flag -- likewise for ty_bot (with\n       // the exception of function types that return bot).\n       // But doing so caused sporadic memory corruption, and\n       // neither I (tjc) nor nmatsakis could figure out why,\n       // so we're doing it this way.\n-      &ty_bot => flags |= has_ty_bot as uint,\n-      &ty_err => flags |= has_ty_err as uint,\n+      &ty_bot => flags = flags | HAS_TY_BOT,\n+      &ty_err => flags = flags | HAS_TY_ERR,\n       &ty_param(ref p) => {\n           if p.space == subst::SelfSpace {\n-              flags |= has_self as uint;\n+              flags = flags | HAS_SELF;\n           } else {\n-              flags |= has_params as uint;\n+              flags = flags | HAS_PARAMS;\n           }\n       }\n-      &ty_unboxed_closure(_, ref region) => flags |= rflags(*region),\n-      &ty_infer(_) => flags |= needs_infer as uint,\n+      &ty_unboxed_closure(_, ref region) => flags = flags | rflags(*region),\n+      &ty_infer(_) => flags = flags | HAS_TY_INFER,\n       &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n-          flags |= sflags(substs);\n+          flags = flags | sflags(substs);\n       }\n       &ty_trait(box TyTrait { ref substs, ref bounds, .. }) => {\n-          flags |= sflags(substs);\n-          flags |= flags_for_bounds(bounds);\n+          flags = flags | sflags(substs);\n+          flags = flags | flags_for_bounds(bounds);\n       }\n       &ty_uniq(tt) | &ty_vec(tt, _) | &ty_open(tt) => {\n-        flags |= get(tt).flags\n+        flags = flags | get(tt).flags\n       }\n       &ty_ptr(ref m) => {\n-        flags |= get(m.ty).flags;\n+        flags = flags | get(m.ty).flags;\n       }\n       &ty_rptr(r, ref m) => {\n-        flags |= rflags(r);\n-        flags |= get(m.ty).flags;\n+        flags = flags | rflags(r);\n+        flags = flags | get(m.ty).flags;\n       }\n-      &ty_tup(ref ts) => for tt in ts.iter() { flags |= get(*tt).flags; },\n+      &ty_tup(ref ts) => for tt in ts.iter() { flags = flags | get(*tt).flags; },\n       &ty_bare_fn(ref f) => {\n-        for a in f.sig.inputs.iter() { flags |= get(*a).flags; }\n-        flags |= get(f.sig.output).flags;\n+        for a in f.sig.inputs.iter() { flags = flags | get(*a).flags; }\n+        flags = flags | get(f.sig.output).flags;\n         // T -> _|_ is *not* _|_ !\n-        flags &= !(has_ty_bot as uint);\n+        flags = flags - HAS_TY_BOT;\n       }\n       &ty_closure(ref f) => {\n         match f.store {\n             RegionTraitStore(r, _) => {\n-                flags |= rflags(r);\n+                flags = flags | rflags(r);\n             }\n             _ => {}\n         }\n-        for a in f.sig.inputs.iter() { flags |= get(*a).flags; }\n-        flags |= get(f.sig.output).flags;\n+        for a in f.sig.inputs.iter() { flags = flags | get(*a).flags; }\n+        flags = flags | get(f.sig.output).flags;\n         // T -> _|_ is *not* _|_ !\n-        flags &= !(has_ty_bot as uint);\n-        flags |= flags_for_bounds(&f.bounds);\n+        flags = flags - HAS_TY_BOT;\n+        flags = flags | flags_for_bounds(&f.bounds);\n       }\n     }\n \n@@ -1976,18 +1988,20 @@ impl ItemSubsts {\n \n // Type utilities\n \n-pub fn type_is_nil(ty: t) -> bool { get(ty).sty == ty_nil }\n+pub fn type_is_nil(ty: t) -> bool {\n+    get(ty).sty == ty_nil\n+}\n \n pub fn type_is_bot(ty: t) -> bool {\n-    (get(ty).flags & (has_ty_bot as uint)) != 0\n+    get(ty).flags.intersects(HAS_TY_BOT)\n }\n \n pub fn type_is_error(ty: t) -> bool {\n-    (get(ty).flags & (has_ty_err as uint)) != 0\n+    get(ty).flags.intersects(HAS_TY_ERR)\n }\n \n pub fn type_needs_subst(ty: t) -> bool {\n-    tbox_has_flag(get(ty), needs_subst)\n+    tbox_has_flag(get(ty), NEEDS_SUBST)\n }\n \n pub fn trait_ref_contains_error(tref: &ty::TraitRef) -> bool {\n@@ -3605,7 +3619,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n \n                 // Special case: A unit like struct's constructor must be called without () at the\n                 // end (like `UnitStruct`) which means this is an ExprPath to a DefFn. But in case\n-                // of unit structs this is should not be interpretet as function pointer but as\n+                // of unit structs this is should not be interpreted as function pointer but as\n                 // call to the constructor.\n                 def::DefFn(_, _, true) => RvalueDpsExpr,\n \n@@ -5409,7 +5423,7 @@ impl BorrowKind {\n             MutBorrow => ast::MutMutable,\n             ImmBorrow => ast::MutImmutable,\n \n-            // We have no type correponding to a unique imm borrow, so\n+            // We have no type corresponding to a unique imm borrow, so\n             // use `&mut`. It gives all the capabilities of an `&uniq`\n             // and hence is a safe \"over approximation\".\n             UniqueImmBorrow => ast::MutMutable,"}, {"sha": "1dcd8c76f4b84b573d68b8f91404f9b93cd26303", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -74,7 +74,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n             let const_did = tcx.def_map.borrow().get_copy(&pat.id).def_id();\n             let const_pty = ty::lookup_item_type(tcx, const_did);\n             fcx.write_ty(pat.id, const_pty.ty);\n-            demand::eqtype(fcx, pat.span, expected, const_pty.ty);\n+            demand::suptype(fcx, pat.span, expected, const_pty.ty);\n         }\n         ast::PatIdent(bm, ref path, ref sub) if pat_is_binding(&tcx.def_map, pat) => {\n             let typ = fcx.local_ty(pat.span, pat.id);"}, {"sha": "66693224c87794241cb53d5a6198df18f85ffb93", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -88,7 +88,7 @@ use middle::ty;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::{FnCtxt, NoPreference, PreferMutLvalue};\n use middle::typeck::check::{impl_self_ty};\n-use middle::typeck::check::vtable2::select_fcx_obligations_where_possible;\n+use middle::typeck::check::vtable::select_fcx_obligations_where_possible;\n use middle::typeck::check;\n use middle::typeck::infer;\n use middle::typeck::{MethodCall, MethodCallee};\n@@ -223,17 +223,37 @@ pub fn report_error(fcx: &FnCtxt,\n {\n     match error {\n         NoMatch(static_sources) => {\n+            let cx = fcx.tcx();\n+            let method_ustring = method_name.user_string(cx);\n+\n+            // True if the type is a struct and contains a field with\n+            // the same name as the not-found method\n+            let is_field = match ty::get(rcvr_ty).sty {\n+                ty_struct(did, _) =>\n+                    ty::lookup_struct_fields(cx, did)\n+                        .iter()\n+                        .any(|f| f.name.user_string(cx) == method_ustring),\n+                _ => false\n+            };\n+\n             fcx.type_error_message(\n                 span,\n                 |actual| {\n                     format!(\"type `{}` does not implement any \\\n                              method in scope named `{}`\",\n                             actual,\n-                            method_name.user_string(fcx.tcx()))\n+                            method_ustring)\n                 },\n                 rcvr_ty,\n                 None);\n \n+            // If the method has the name of a field, give a help note\n+            if is_field {\n+                cx.sess.span_note(span,\n+                    format!(\"use `(s.{0})(...)` if you meant to call the \\\n+                            function stored in the `{0}` field\", method_ustring).as_slice());\n+            }\n+\n             if static_sources.len() > 0 {\n                 fcx.tcx().sess.fileline_note(\n                     span,"}, {"sha": "3d1385bac3bf52f369b315d9b036dec8c2b70a03", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -139,7 +139,7 @@ use syntax::visit::Visitor;\n use syntax;\n \n pub mod _match;\n-pub mod vtable2; // New trait code\n+pub mod vtable;\n pub mod writeback;\n pub mod regionmanip;\n pub mod regionck;\n@@ -409,7 +409,7 @@ fn check_bare_fn(ccx: &CrateCtxt,\n             let fcx = check_fn(ccx, fn_ty.fn_style, id, &fn_ty.sig,\n                                decl, id, body, &inh);\n \n-            vtable2::select_all_fcx_obligations_or_error(&fcx);\n+            vtable::select_all_fcx_obligations_or_error(&fcx);\n             regionck::regionck_fn(&fcx, id, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n         }\n@@ -1372,7 +1372,7 @@ fn check_cast(fcx: &FnCtxt,\n \n     if ty::type_is_trait(t_1) {\n         // This will be looked up later on.\n-        vtable2::check_object_cast(fcx, cast_expr, e, t_1);\n+        vtable::check_object_cast(fcx, cast_expr, e, t_1);\n         fcx.write_ty(id, t_1);\n         return\n     }\n@@ -1677,7 +1677,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::UnsizeVtable(ref ty_trait, self_ty) => {\n                 // If the type is `Foo+'a`, ensures that the type\n                 // being cast to `Foo+'a` implements `Foo`:\n-                vtable2::register_object_cast_obligations(self,\n+                vtable::register_object_cast_obligations(self,\n                                                           span,\n                                                           ty_trait,\n                                                           self_ty);\n@@ -2564,7 +2564,7 @@ fn check_argument_types<'a>(fcx: &FnCtxt,\n         // an \"opportunistic\" vtable resolution of any trait\n         // bounds on the call.\n         if check_blocks {\n-            vtable2::select_fcx_obligations_where_possible(fcx);\n+            vtable::select_fcx_obligations_where_possible(fcx);\n         }\n \n         // For variadic functions, we don't have a declared type for all of\n@@ -4036,7 +4036,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprForLoop(ref pat, ref head, ref block, _) => {\n         check_expr(fcx, &**head);\n         let typ = lookup_method_for_for_loop(fcx, &**head, expr.id);\n-        vtable2::select_fcx_obligations_where_possible(fcx);\n+        vtable::select_fcx_obligations_where_possible(fcx);\n \n         let pcx = pat_ctxt {\n             fcx: fcx,\n@@ -4743,7 +4743,7 @@ pub fn check_const_with_ty(fcx: &FnCtxt,\n \n     check_expr_with_hint(fcx, e, declty);\n     demand::coerce(fcx, e.span, declty, e);\n-    vtable2::select_all_fcx_obligations_or_error(fcx);\n+    vtable::select_all_fcx_obligations_or_error(fcx);\n     regionck::regionck_expr(fcx, e);\n     writeback::resolve_type_vars_in_expr(fcx, e);\n }"}, {"sha": "deeee67ac6eab5174a98df261e5b7537523dc737", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -126,7 +126,7 @@ use middle::ty;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::FnCtxt;\n use middle::typeck::check::regionmanip;\n-use middle::typeck::check::vtable2;\n+use middle::typeck::check::vtable;\n use middle::typeck::infer::resolve_and_force_all_but_regions;\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n@@ -172,7 +172,7 @@ pub fn regionck_fn(fcx: &FnCtxt, id: ast::NodeId, blk: &ast::Block) {\n \n     // Region checking a fn can introduce new trait obligations,\n     // particularly around closure bounds.\n-    vtable2::select_all_fcx_obligations_or_error(fcx);\n+    vtable::select_all_fcx_obligations_or_error(fcx);\n \n     fcx.infcx().resolve_regions_and_report_errors();\n }\n@@ -1674,7 +1674,7 @@ fn link_reborrowed_region(rcx: &Rcx,\n             //\n             // If mutability was inferred from an upvar, we may be\n             // forced to revisit this decision later if processing\n-            // another borrow or nested closure ends up coverting the\n+            // another borrow or nested closure ends up converting the\n             // upvar borrow kind to mutable/unique.  Record the\n             // information needed to perform the recursive link in the\n             // maybe link map."}, {"sha": "d557a2b713be7127a3169de9ba05facef2fe4ce4", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "previous_filename": "src/librustc/middle/typeck/check/vtable2.rs"}, {"sha": "3c594fbf2d3661ea4277cdfe79dd34d41092b48e", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -14,7 +14,7 @@ use middle::traits;\n use middle::ty;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use middle::typeck::astconv::AstConv;\n-use middle::typeck::check::{FnCtxt, Inherited, blank_fn_ctxt, vtable2, regionck};\n+use middle::typeck::check::{FnCtxt, Inherited, blank_fn_ctxt, vtable, regionck};\n use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::CrateCtxt;\n use util::ppaux::Repr;\n@@ -100,7 +100,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let inh = Inherited::new(ccx.tcx, param_env);\n         let fcx = blank_fn_ctxt(ccx, &inh, polytype.ty, item.id);\n         f(self, &fcx);\n-        vtable2::select_all_fcx_obligations_or_error(&fcx);\n+        vtable::select_all_fcx_obligations_or_error(&fcx);\n         regionck::regionck_item(&fcx, item);\n     }\n "}, {"sha": "0a040fff40d6a4b55b3ef618490f6b669c080be5", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -17,6 +17,7 @@ Core encoding and decoding interfaces.\n use std::path;\n use std::rc::Rc;\n use std::cell::{Cell, RefCell};\n+use std::sync::Arc;\n \n pub trait Encoder<E> {\n     // Primitive types:\n@@ -556,6 +557,18 @@ impl<E, D: Decoder<E>, T: Decodable<D, E>> Decodable<D, E> for RefCell<T> {\n     }\n }\n \n+impl<E, S:Encoder<E>, T:Encodable<S, E>+Send+Sync> Encodable<S, E> for Arc<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>,T:Decodable<D, E>+Send+Sync> Decodable<D, E> for Arc<T> {\n+    fn decode(d: &mut D) -> Result<Arc<T>, E> {\n+        Ok(Arc::new(try!(Decodable::decode(d))))\n+    }\n+}\n+\n // ___________________________________________________________________________\n // Helper routines\n "}, {"sha": "c2e88bfdbcfb9e6d502b30010b537e809baee63f", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -247,8 +247,7 @@ impl OwnedAsciiCast for String {\n \n     #[inline]\n     unsafe fn into_ascii_nocheck(self) -> Vec<Ascii> {\n-        let v: Vec<u8> = mem::transmute(self);\n-        v.into_ascii_nocheck()\n+        self.into_bytes().into_ascii_nocheck()\n     }\n }\n \n@@ -260,7 +259,14 @@ impl OwnedAsciiCast for Vec<u8> {\n \n     #[inline]\n     unsafe fn into_ascii_nocheck(self) -> Vec<Ascii> {\n-        mem::transmute(self)\n+        let v = Vec::from_raw_parts(self.as_ptr() as *mut Ascii,\n+                                    self.len(),\n+                                    self.capacity());\n+\n+        // We forget `self` to avoid freeing it at the end of the scope\n+        // Otherwise, the returned `Vec` would point to freed memory\n+        mem::forget(self);\n+        v\n     }\n }\n \n@@ -338,7 +344,16 @@ pub trait IntoBytes {\n \n impl IntoBytes for Vec<Ascii> {\n     fn into_bytes(self) -> Vec<u8> {\n-        unsafe { mem::transmute(self) }\n+        unsafe {\n+            let v = Vec::from_raw_parts(self.as_ptr() as *mut u8,\n+                                        self.len(),\n+                                        self.capacity());\n+\n+            // We forget `self` to avoid freeing it at the end of the scope\n+            // Otherwise, the returned `Vec` would point to freed memory\n+            mem::forget(self);\n+            v\n+        }\n     }\n }\n "}, {"sha": "ca954679c1c9d7db7851c03df088a8bf33524f32", "filename": "src/libstd/collections/hashmap/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -186,7 +186,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// # Example\n     ///\n     /// This is a slightly silly example where we define the number's\n-    /// parity as the equivilance class. It is important that the\n+    /// parity as the equivalance class. It is important that the\n     /// values hash the same, which is why we implement `Hash`.\n     ///\n     /// ```"}, {"sha": "dd4a3e0593594100dacb97bcf0f56ef26a1acf4f", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -22,7 +22,7 @@ use slice;\n use slice::AsSlice;\n use vec::Vec;\n \n-static BUF_CAPACITY: uint = 128;\n+const BUF_CAPACITY: uint = 128;\n \n fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n     // compute offset as signed and clamp to prevent overflow\n@@ -71,7 +71,12 @@ impl MemWriter {\n     /// the internal buffer.\n     #[inline]\n     pub fn with_capacity(n: uint) -> MemWriter {\n-        MemWriter { buf: Vec::with_capacity(n) }\n+        MemWriter::from_vec(Vec::with_capacity(n))\n+    }\n+    /// Create a new `MemWriter` that will append to an existing `Vec`.\n+    #[inline]\n+    pub fn from_vec(buf: Vec<u8>) -> MemWriter {\n+        MemWriter { buf: buf }\n     }\n \n     /// Acquires an immutable reference to the underlying buffer of this"}, {"sha": "eaa370d95a85c1321e15691922165648dae287be", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -24,6 +24,9 @@ use std::fmt::Show;\n use std::rc::Rc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n+#[cfg(stage0)]\n+pub use self::TtToken as TTTok;\n+\n // FIXME #6993: in librustc, uses of \"ident\" should be replaced\n // by just \"Name\".\n \n@@ -436,7 +439,7 @@ pub enum Stmt_ {\n     /// Expr with trailing semi-colon (may have any type):\n     StmtSemi(P<Expr>, NodeId),\n \n-    /// bool: is there a trailing sem-colon?\n+    /// bool: is there a trailing semi-colon?\n     StmtMac(Mac, bool),\n }\n \n@@ -592,6 +595,28 @@ pub enum CaptureClause {\n     CaptureByRef,\n }\n \n+/// A token that delimits a sequence of token trees\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct Delimiter {\n+    pub span: Span,\n+    pub token: ::parse::token::Token,\n+}\n+\n+impl Delimiter {\n+    /// Convert the delimiter to a `TtToken`\n+    pub fn to_tt(&self) -> TokenTree {\n+        TtToken(self.span, self.token.clone())\n+    }\n+}\n+\n+/// A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star)\n+/// for token sequences.\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub enum KleeneOp {\n+    ZeroOrMore,\n+    OneOrMore,\n+}\n+\n /// When the main rust parser encounters a syntax-extension invocation, it\n /// parses the arguments to the invocation as a token-tree. This is a very\n /// loose structure, such that all sorts of different AST-fragments can\n@@ -600,32 +625,39 @@ pub enum CaptureClause {\n /// If the syntax extension is an MBE macro, it will attempt to match its\n /// LHS \"matchers\" against the provided token tree, and if it finds a\n /// match, will transcribe the RHS token tree, splicing in any captured\n-/// macro_parser::matched_nonterminals into the TTNonterminals it finds.\n+/// `macro_parser::matched_nonterminals` into the `TtNonterminal`s it finds.\n ///\n-/// The RHS of an MBE macro is the only place a TTNonterminal or TTSeq\n+/// The RHS of an MBE macro is the only place a `TtNonterminal` or `TtSequence`\n /// makes any real sense. You could write them elsewhere but nothing\n /// else knows what to do with them, so you'll probably get a syntax\n /// error.\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum TokenTree {\n     /// A single token\n-    TTTok(Span, ::parse::token::Token),\n-    /// A delimited sequence (the delimiters appear as the first\n-    /// and last elements of the vector)\n-    // FIXME(eddyb) #6308 Use Rc<[TokenTree]> after DST.\n-    TTDelim(Rc<Vec<TokenTree>>),\n+    TtToken(Span, ::parse::token::Token),\n+    /// A delimited sequence of token trees\n+    TtDelimited(Span, Rc<(Delimiter, Vec<TokenTree>, Delimiter)>),\n \n     // These only make sense for right-hand-sides of MBE macros:\n \n-    /// A kleene-style repetition sequence with a span, a TTForest,\n-    /// an optional separator, and a boolean where true indicates\n-    /// zero or more (..), and false indicates one or more (+).\n+    /// A Kleene-style repetition sequence with an optional separator.\n     // FIXME(eddyb) #6308 Use Rc<[TokenTree]> after DST.\n-    TTSeq(Span, Rc<Vec<TokenTree>>, Option<::parse::token::Token>, bool),\n-\n+    TtSequence(Span, Rc<Vec<TokenTree>>, Option<::parse::token::Token>, KleeneOp),\n     /// A syntactic variable that will be filled in by macro expansion.\n-    TTNonterminal(Span, Ident)\n+    TtNonterminal(Span, Ident)\n+}\n+\n+impl TokenTree {\n+    /// Returns the `Span` corresponding to this token tree.\n+    pub fn get_span(&self) -> Span {\n+        match *self {\n+            TtToken(span, _)           => span,\n+            TtDelimited(span, _)       => span,\n+            TtSequence(span, _, _, _)  => span,\n+            TtNonterminal(span, _)     => span,\n+        }\n+    }\n }\n \n // Matchers are nodes defined-by and recognized-by the main rust parser and\n@@ -684,9 +716,9 @@ pub type Matcher = Spanned<Matcher_>;\n pub enum Matcher_ {\n     /// Match one token\n     MatchTok(::parse::token::Token),\n-    /// Match repetitions of a sequence: body, separator, zero ok?,\n+    /// Match repetitions of a sequence: body, separator, Kleene operator,\n     /// lo, hi position-in-match-array used:\n-    MatchSeq(Vec<Matcher> , Option<::parse::token::Token>, bool, uint, uint),\n+    MatchSeq(Vec<Matcher> , Option<::parse::token::Token>, KleeneOp, uint, uint),\n     /// Parse a Rust NT: name to bind, name of NT, position in match array:\n     MatchNonterminal(Ident, Ident, uint)\n }"}, {"sha": "72c62a173fc30b88bf18992e5f86448cc7bd397d", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -250,30 +250,18 @@ fn impl_item_in_cfg(cx: &mut Context, impl_item: &ast::ImplItem) -> bool {\n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n fn in_cfg(diagnostic: &SpanHandler, cfg: &[P<ast::MetaItem>], attrs: &[ast::Attribute]) -> bool {\n-    let mut in_cfg = false;\n-    let mut seen_cfg = false;\n-    for attr in attrs.iter() {\n+    attrs.iter().all(|attr| {\n         let mis = match attr.node.value.node {\n             ast::MetaList(_, ref mis) if attr.check_name(\"cfg\") => mis,\n-            _ => continue\n+            _ => return true\n         };\n \n         if mis.len() != 1 {\n             diagnostic.span_err(attr.span, \"expected 1 cfg-pattern\");\n-            return false;\n+            return true;\n         }\n \n-        if seen_cfg {\n-            diagnostic.span_err(attr.span, \"The semantics of multiple `#[cfg(..)]` attributes on \\\n-                                            same item are changing from the union of the cfgs to \\\n-                                            the intersection of the cfgs. Change `#[cfg(a)] \\\n-                                            #[cfg(b)]` to `#[cfg(any(a, b))]`.\");\n-            return false;\n-        }\n-\n-        seen_cfg = true;\n-        in_cfg |= attr::cfg_matches(diagnostic, cfg, &*mis[0]);\n-    }\n-    in_cfg | !seen_cfg\n+        attr::cfg_matches(diagnostic, cfg, &*mis[0])\n+    })\n }\n "}, {"sha": "b8795ad5be80fa12211ca1a34b99deb01afbd995", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -50,7 +50,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n                                    token_tree: &[TokenTree])\n                                    -> Box<MacResult+'cx> {\n     let code = match token_tree {\n-        [ast::TTTok(_, token::IDENT(code, _))] => code,\n+        [ast::TtToken(_, token::IDENT(code, _))] => code,\n         _ => unreachable!()\n     };\n     with_registered_diagnostics(|diagnostics| {\n@@ -82,12 +82,12 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n                                        token_tree: &[TokenTree])\n                                        -> Box<MacResult+'cx> {\n     let (code, description) = match token_tree {\n-        [ast::TTTok(_, token::IDENT(ref code, _))] => {\n+        [ast::TtToken(_, token::IDENT(ref code, _))] => {\n             (code, None)\n         },\n-        [ast::TTTok(_, token::IDENT(ref code, _)),\n-         ast::TTTok(_, token::COMMA),\n-         ast::TTTok(_, token::LIT_STR_RAW(description, _))] => {\n+        [ast::TtToken(_, token::IDENT(ref code, _)),\n+         ast::TtToken(_, token::COMMA),\n+         ast::TtToken(_, token::LIT_STR_RAW(description, _))] => {\n             (code, Some(description))\n         }\n         _ => unreachable!()\n@@ -110,7 +110,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n                                           token_tree: &[TokenTree])\n                                           -> Box<MacResult+'cx> {\n     let name = match token_tree {\n-        [ast::TTTok(_, token::IDENT(ref name, _))] => name,\n+        [ast::TtToken(_, token::IDENT(ref name, _))] => name,\n         _ => unreachable!()\n     };\n "}, {"sha": "64c8068607aa011259e14c0528419e248ef1a25f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -684,8 +684,8 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n         cx.span_err(sp, format!(\"{} takes 1 argument.\", name).as_slice());\n     } else {\n         match tts[0] {\n-            ast::TTTok(_, token::LIT_STR(ident)) => return Some(parse::str_lit(ident.as_str())),\n-            ast::TTTok(_, token::LIT_STR_RAW(ident, _)) => {\n+            ast::TtToken(_, token::LIT_STR(ident)) => return Some(parse::str_lit(ident.as_str())),\n+            ast::TtToken(_, token::LIT_STR_RAW(ident, _)) => {\n                 return Some(parse::raw_str_lit(ident.as_str()))\n             }\n             _ => {"}, {"sha": "e12f9ee133a328171a687b423d7b40b6ba3a576e", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -23,15 +23,15 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n     for (i, e) in tts.iter().enumerate() {\n         if i & 1 == 1 {\n             match *e {\n-                ast::TTTok(_, token::COMMA) => (),\n+                ast::TtToken(_, token::COMMA) => (),\n                 _ => {\n                     cx.span_err(sp, \"concat_idents! expecting comma.\");\n                     return DummyResult::expr(sp);\n                 }\n             }\n         } else {\n             match *e {\n-                ast::TTTok(_, token::IDENT(ident,_)) => {\n+                ast::TtToken(_, token::IDENT(ident,_)) => {\n                     res_str.push_str(token::get_ident(ident).get())\n                 }\n                 _ => {"}, {"sha": "7c32b84550893a5813916a555a97539d00409ab2", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -1250,7 +1250,7 @@ impl<'a> TraitDef<'a> {\n                 // id is guaranteed to be Some\n                 codemap::Spanned {\n                     span: pat.span,\n-                    node: ast::FieldPat { ident: id.unwrap(), pat: pat, is_shorthand: true },\n+                    node: ast::FieldPat { ident: id.unwrap(), pat: pat, is_shorthand: false },\n                 }\n             }).collect();\n             cx.pat_struct(self.span, matching_path, field_pats)"}, {"sha": "30301e3b8cc92414a940ebc6fb374d958a267479", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -13,16 +13,14 @@ use codemap;\n use ext::base;\n use print;\n \n-use std::rc::Rc;\n-\n pub fn expand_syntax_ext<'cx>(cx: &'cx mut base::ExtCtxt,\n                               sp: codemap::Span,\n-                              tt: &[ast::TokenTree])\n+                              tts: &[ast::TokenTree])\n                               -> Box<base::MacResult+'cx> {\n \n     cx.print_backtrace();\n-    println!(\"{}\", print::pprust::tt_to_string(&ast::TTDelim(\n-                Rc::new(tt.iter().map(|x| (*x).clone()).collect()))));\n+\n+    println!(\"{}\", print::pprust::tts_to_string(tts));\n \n     // any so that `log_syntax` can be invoked as an expression and item.\n     base::DummyResult::any(sp)"}, {"sha": "6f1fd90adfa4b6591a58d80f596d184fa1c51f5b", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -23,7 +23,7 @@ use ptr::P;\n *\n * This is registered as a set of expression syntax extension called quote!\n * that lifts its argument token-tree to an AST representing the\n-* construction of the same token tree, with ast::TTNonterminal nodes\n+* construction of the same token tree, with ast::TtNonterminal nodes\n * interpreted as antiquotes (splices).\n *\n */\n@@ -637,26 +637,29 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n }\n \n \n-fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n+fn mk_tt(cx: &ExtCtxt, _: Span, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n     match *tt {\n-        ast::TTTok(sp, ref tok) => {\n+        ast::TtToken(sp, ref tok) => {\n             let e_sp = cx.expr_ident(sp, id_ext(\"_sp\"));\n             let e_tok = cx.expr_call(sp,\n-                                     mk_ast_path(cx, sp, \"TTTok\"),\n+                                     mk_ast_path(cx, sp, \"TtToken\"),\n                                      vec!(e_sp, mk_token(cx, sp, tok)));\n             let e_push =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, id_ext(\"tt\")),\n                                     id_ext(\"push\"),\n                                     vec!(e_tok));\n             vec!(cx.stmt_expr(e_push))\n-        }\n-\n-        ast::TTDelim(ref tts) => mk_tts(cx, sp, tts.as_slice()),\n-        ast::TTSeq(..) => fail!(\"TTSeq in quote!\"),\n-\n-        ast::TTNonterminal(sp, ident) => {\n-\n+        },\n+        ast::TtDelimited(sp, ref delimed) => {\n+            let (ref open, ref tts, ref close) = **delimed;\n+            mk_tt(cx, sp, &open.to_tt()).into_iter()\n+                .chain(tts.iter().flat_map(|tt| mk_tt(cx, sp, tt).into_iter()))\n+                .chain(mk_tt(cx, sp, &close.to_tt()).into_iter())\n+                .collect()\n+        },\n+        ast::TtSequence(..) => fail!(\"TtSequence in quote!\"),\n+        ast::TtNonterminal(sp, ident) => {\n             // tt.extend($ident.to_tokens(ext_cx).into_iter())\n \n             let e_to_toks =\n@@ -674,7 +677,7 @@ fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n                                     vec!(e_to_toks));\n \n             vec!(cx.stmt_expr(e_push))\n-        }\n+        },\n     }\n }\n \n@@ -690,7 +693,7 @@ fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n               -> (P<ast::Expr>, P<ast::Expr>) {\n     // NB: It appears that the main parser loses its mind if we consider\n-    // $foo as a TTNonterminal during the main parse, so we have to re-parse\n+    // $foo as a TtNonterminal during the main parse, so we have to re-parse\n     // under quote_depth > 0. This is silly and should go away; the _guess_ is\n     // it has to do with transition away from supporting old-style macros, so\n     // try removing it when enough of them are gone."}, {"sha": "abf798ddacb3a12c36895d32f77b9c21033e347a", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -20,10 +20,10 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt,\n                            tt: &[ast::TokenTree])\n                            -> Box<base::MacResult+'static> {\n     match tt {\n-        [ast::TTTok(_, ref tok)] if is_keyword(keywords::True, tok) => {\n+        [ast::TtToken(_, ref tok)] if is_keyword(keywords::True, tok) => {\n             cx.set_trace_macros(true);\n         }\n-        [ast::TTTok(_, ref tok)] if is_keyword(keywords::False, tok) => {\n+        [ast::TtToken(_, ref tok)] if is_keyword(keywords::False, tok) => {\n             cx.set_trace_macros(false);\n         }\n         _ => cx.span_err(sp, \"trace_macros! accepts only `true` or `false`\"),"}, {"sha": "cea8cab52654d3e3a0af7fe6f73b15224cef6b90", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -323,9 +323,9 @@ pub fn parse(sess: &ParseSess,\n             } else {\n                 match ei.elts[idx].node.clone() {\n                   /* need to descend into sequence */\n-                  MatchSeq(ref matchers, ref sep, zero_ok,\n+                  MatchSeq(ref matchers, ref sep, kleene_op,\n                            match_idx_lo, match_idx_hi) => {\n-                    if zero_ok {\n+                    if kleene_op == ast::ZeroOrMore {\n                         let mut new_ei = ei.clone();\n                         new_ei.idx += 1u;\n                         //we specifically matched zero repeats."}, {"sha": "3b51fb380b816853611a75d0e4cb6762355a5827", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Ident, Matcher_, Matcher, MatchTok, MatchNonterminal, MatchSeq, TTDelim};\n+use ast::{Ident, Matcher_, Matcher, MatchTok, MatchNonterminal, MatchSeq, TtDelimited};\n use ast;\n use codemap::{Span, Spanned, DUMMY_SP};\n use ext::base::{ExtCtxt, MacResult, MacroDef};\n@@ -147,13 +147,9 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                           rhses: &[Rc<NamedMatch>])\n                           -> Box<MacResult+'cx> {\n     if cx.trace_macros() {\n-        println!(\"{}! {} {} {}\",\n+        println!(\"{}! {{ {} }}\",\n                  token::get_ident(name),\n-                 \"{\",\n-                 print::pprust::tt_to_string(&TTDelim(Rc::new(arg.iter()\n-                                                              .map(|x| (*x).clone())\n-                                                              .collect()))),\n-                 \"}\");\n+                 print::pprust::tts_to_string(arg));\n     }\n \n     // Which arm's failure should we report? (the one furthest along)\n@@ -175,15 +171,12 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                     // okay, what's your transcriber?\n                     MatchedNonterminal(NtTT(ref tt)) => {\n                         match **tt {\n-                            // cut off delimiters; don't parse 'em\n-                            TTDelim(ref tts) => {\n-                                (*tts).slice(1u,(*tts).len()-1u)\n-                                      .iter()\n-                                      .map(|x| (*x).clone())\n-                                      .collect()\n-                            }\n-                            _ => cx.span_fatal(\n-                                sp, \"macro rhs must be delimited\")\n+                            // ignore delimiters\n+                            TtDelimited(_, ref delimed) => {\n+                                let (_, ref tts, _) = **delimed;\n+                                tts.clone()\n+                            },\n+                            _ => cx.span_fatal(sp, \"macro rhs must be delimited\"),\n                         }\n                     },\n                     _ => cx.span_bug(sp, \"bad thing in rhs\")\n@@ -239,10 +232,11 @@ pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n         ms(MatchSeq(vec!(\n             ms(MatchNonterminal(lhs_nm, special_idents::matchers, 0u)),\n             ms(MatchTok(FAT_ARROW)),\n-            ms(MatchNonterminal(rhs_nm, special_idents::tt, 1u))), Some(SEMI), false, 0u, 2u)),\n+            ms(MatchNonterminal(rhs_nm, special_idents::tt, 1u))), Some(SEMI),\n+                                ast::OneOrMore, 0u, 2u)),\n         //to phase into semicolon-termination instead of\n         //semicolon-separation\n-        ms(MatchSeq(vec!(ms(MatchTok(SEMI))), None, true, 2u, 2u)));\n+        ms(MatchSeq(vec!(ms(MatchTok(SEMI))), None, ast::ZeroOrMore, 2u, 2u)));\n \n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):"}, {"sha": "1bb519f66cd55fca25fc26930f80c3a2f727787c", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 48, "deletions": 33, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use ast::{TokenTree, TTDelim, TTTok, TTSeq, TTNonterminal, Ident};\n+use ast::{TokenTree, TtDelimited, TtToken, TtSequence, TtNonterminal, Ident};\n use codemap::{Span, DUMMY_SP};\n use diagnostic::SpanHandler;\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n@@ -18,6 +18,7 @@ use parse::token;\n use parse::lexer::TokenAndSpan;\n \n use std::rc::Rc;\n+use std::ops::Add;\n use std::collections::HashMap;\n \n ///an unzipping of `TokenTree`s\n@@ -44,7 +45,7 @@ pub struct TtReader<'a> {\n }\n \n /// This can do Macro-By-Example transcription. On the other hand, if\n-/// `src` contains no `TTSeq`s and `TTNonterminal`s, `interp` can (and\n+/// `src` contains no `TtSequence`s and `TtNonterminal`s, `interp` can (and\n /// should) be none.\n pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n                          interp: Option<HashMap<Ident, Rc<NamedMatch>>>,\n@@ -104,37 +105,45 @@ enum LockstepIterSize {\n     LisContradiction(String),\n }\n \n-fn lis_merge(lhs: LockstepIterSize, rhs: LockstepIterSize) -> LockstepIterSize {\n-    match lhs {\n-        LisUnconstrained => rhs.clone(),\n-        LisContradiction(_) => lhs.clone(),\n-        LisConstraint(l_len, l_id) => match rhs {\n-            LisUnconstrained => lhs.clone(),\n-            LisContradiction(_) => rhs.clone(),\n-            LisConstraint(r_len, _) if l_len == r_len => lhs.clone(),\n-            LisConstraint(r_len, r_id) => {\n-                let l_n = token::get_ident(l_id);\n-                let r_n = token::get_ident(r_id);\n-                LisContradiction(format!(\"inconsistent lockstep iteration: \\\n-                                          '{}' has {} items, but '{}' has {}\",\n-                                          l_n, l_len, r_n, r_len).to_string())\n-            }\n+impl Add<LockstepIterSize, LockstepIterSize> for LockstepIterSize {\n+    fn add(&self, other: &LockstepIterSize) -> LockstepIterSize {\n+        match *self {\n+            LisUnconstrained => other.clone(),\n+            LisContradiction(_) => self.clone(),\n+            LisConstraint(l_len, l_id) => match *other {\n+                LisUnconstrained => self.clone(),\n+                LisContradiction(_) => other.clone(),\n+                LisConstraint(r_len, _) if l_len == r_len => self.clone(),\n+                LisConstraint(r_len, r_id) => {\n+                    let l_n = token::get_ident(l_id);\n+                    let r_n = token::get_ident(r_id);\n+                    LisContradiction(format!(\"inconsistent lockstep iteration: \\\n+                                              '{}' has {} items, but '{}' has {}\",\n+                                              l_n, l_len, r_n, r_len).to_string())\n+                }\n+            },\n         }\n     }\n }\n \n fn lockstep_iter_size(t: &TokenTree, r: &TtReader) -> LockstepIterSize {\n     match *t {\n-        TTDelim(ref tts) | TTSeq(_, ref tts, _, _) => {\n-            tts.iter().fold(LisUnconstrained, |lis, tt| {\n-                lis_merge(lis, lockstep_iter_size(tt, r))\n+        TtDelimited(_, ref delimed) => {\n+            let (_, ref tts, _) = **delimed;\n+            tts.iter().fold(LisUnconstrained, |size, tt| {\n+                size + lockstep_iter_size(tt, r)\n             })\n-        }\n-        TTTok(..) => LisUnconstrained,\n-        TTNonterminal(_, name) => match *lookup_cur_matched(r, name) {\n+        },\n+        TtSequence(_, ref tts, _, _) => {\n+            tts.iter().fold(LisUnconstrained, |size, tt| {\n+                size + lockstep_iter_size(tt, r)\n+            })\n+        },\n+        TtToken(..) => LisUnconstrained,\n+        TtNonterminal(_, name) => match *lookup_cur_matched(r, name) {\n             MatchedNonterminal(_) => LisUnconstrained,\n             MatchedSeq(ref ads, _) => LisConstraint(ads.len(), name)\n-        }\n+        },\n     }\n }\n \n@@ -189,32 +198,38 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n             }\n         }\n     }\n-    loop { /* because it's easiest, this handles `TTDelim` not starting\n-              with a `TTTok`, even though it won't happen */\n+    loop { /* because it's easiest, this handles `TtDelimited` not starting\n+              with a `TtToken`, even though it won't happen */\n         let t = {\n             let frame = r.stack.last().unwrap();\n             // FIXME(pcwalton): Bad copy.\n             (*frame.forest)[frame.idx].clone()\n         };\n         match t {\n-            TTDelim(tts) => {\n+            TtDelimited(_, ref delimed) => {\n+                let (ref open, ref tts, ref close) = **delimed;\n+                let mut forest = Vec::with_capacity(1 + tts.len() + 1);\n+                forest.push(open.to_tt());\n+                forest.extend(tts.iter().map(|x| (*x).clone()));\n+                forest.push(close.to_tt());\n+\n                 r.stack.push(TtFrame {\n-                    forest: tts,\n+                    forest: Rc::new(forest),\n                     idx: 0,\n                     dotdotdoted: false,\n                     sep: None\n                 });\n                 // if this could be 0-length, we'd need to potentially recur here\n             }\n-            TTTok(sp, tok) => {\n+            TtToken(sp, tok) => {\n                 r.cur_span = sp;\n                 r.cur_tok = tok;\n                 r.stack.last_mut().unwrap().idx += 1;\n                 return ret_val;\n             }\n-            TTSeq(sp, tts, sep, zerok) => {\n+            TtSequence(sp, tts, sep, kleene_op) => {\n                 // FIXME(pcwalton): Bad copy.\n-                match lockstep_iter_size(&TTSeq(sp, tts.clone(), sep.clone(), zerok), r) {\n+                match lockstep_iter_size(&TtSequence(sp, tts.clone(), sep.clone(), kleene_op), r) {\n                     LisUnconstrained => {\n                         r.sp_diag.span_fatal(\n                             sp.clone(), /* blame macro writer */\n@@ -228,7 +243,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                         }\n                     LisConstraint(len, _) => {\n                         if len == 0 {\n-                            if !zerok {\n+                            if kleene_op == ast::OneOrMore {\n                                 // FIXME #2887 blame invoker\n                                 r.sp_diag.span_fatal(sp.clone(),\n                                                      \"this must repeat at least once\");\n@@ -249,7 +264,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                 }\n             }\n             // FIXME #2887: think about span stuff here\n-            TTNonterminal(sp, ident) => {\n+            TtNonterminal(sp, ident) => {\n                 r.stack.last_mut().unwrap().idx += 1;\n                 match *lookup_cur_matched(r, ident) {\n                     /* sidestep the interpolation tricks for ident because"}, {"sha": "0f9ab5c6b261ece7ff24a099f92b4a8c4a4c8e9e", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -569,16 +569,29 @@ pub fn noop_fold_arg<T: Folder>(Arg {id, pat, ty}: Arg, fld: &mut T) -> Arg {\n \n pub fn noop_fold_tt<T: Folder>(tt: &TokenTree, fld: &mut T) -> TokenTree {\n     match *tt {\n-        TTTok(span, ref tok) =>\n-            TTTok(span, fld.fold_token(tok.clone())),\n-        TTDelim(ref tts) => TTDelim(Rc::new(fld.fold_tts(tts.as_slice()))),\n-        TTSeq(span, ref pattern, ref sep, is_optional) =>\n-            TTSeq(span,\n-                  Rc::new(fld.fold_tts(pattern.as_slice())),\n-                  sep.clone().map(|tok| fld.fold_token(tok)),\n-                  is_optional),\n-        TTNonterminal(sp,ref ident) =>\n-            TTNonterminal(sp,fld.fold_ident(*ident))\n+        TtToken(span, ref tok) =>\n+            TtToken(span, fld.fold_token(tok.clone())),\n+        TtDelimited(span, ref delimed) => {\n+            let (ref open, ref tts, ref close) = **delimed;\n+            TtDelimited(span, Rc::new((\n+                            Delimiter {\n+                                span: open.span,\n+                                token: fld.fold_token(open.token.clone())\n+                            },\n+                            fld.fold_tts(tts.as_slice()),\n+                            Delimiter {\n+                                span: close.span,\n+                                token: fld.fold_token(close.token.clone())\n+                            },\n+                        )))\n+        },\n+        TtSequence(span, ref pattern, ref sep, is_optional) =>\n+            TtSequence(span,\n+                       Rc::new(fld.fold_tts(pattern.as_slice())),\n+                       sep.clone().map(|tok| fld.fold_token(tok)),\n+                       is_optional),\n+        TtNonterminal(sp,ref ident) =>\n+            TtNonterminal(sp,fld.fold_ident(*ident))\n     }\n }\n "}, {"sha": "4f09b34557c74e93ab2938474406992381a77e14", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -74,7 +74,7 @@ impl<T> OwnedSlice<T> {\n     pub fn into_vec(self) -> Vec<T> {\n         // null is ok, because len == 0 in that case, as required by Vec.\n         unsafe {\n-            let ret = Vec::from_raw_parts(self.len, self.len, self.data);\n+            let ret = Vec::from_raw_parts(self.data, self.len, self.len);\n             // the vector owns the allocation now\n             mem::forget(self);\n             ret"}, {"sha": "2965094f23662f396aeb47ec7fcd3f6da47e740a", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 107, "deletions": 121, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -788,65 +788,57 @@ mod test {\n     }\n \n     // check the token-tree-ization of macros\n-    #[test] fn string_to_tts_macro () {\n+    #[test]\n+    fn string_to_tts_macro () {\n         let tts = string_to_tts(\"macro_rules! zip (($a)=>($a))\".to_string());\n         let tts: &[ast::TokenTree] = tts.as_slice();\n         match tts {\n-            [ast::TTTok(_,_),\n-             ast::TTTok(_,token::NOT),\n-             ast::TTTok(_,_),\n-             ast::TTDelim(ref delim_elts)] => {\n-                let delim_elts: &[ast::TokenTree] = delim_elts.as_slice();\n-                match delim_elts {\n-                    [ast::TTTok(_,token::LPAREN),\n-                     ast::TTDelim(ref first_set),\n-                     ast::TTTok(_,token::FAT_ARROW),\n-                     ast::TTDelim(ref second_set),\n-                     ast::TTTok(_,token::RPAREN)] => {\n-                        let first_set: &[ast::TokenTree] =\n-                            first_set.as_slice();\n-                        match first_set {\n-                            [ast::TTTok(_,token::LPAREN),\n-                             ast::TTTok(_,token::DOLLAR),\n-                             ast::TTTok(_,_),\n-                             ast::TTTok(_,token::RPAREN)] => {\n-                                let second_set: &[ast::TokenTree] =\n-                                    second_set.as_slice();\n-                                match second_set {\n-                                    [ast::TTTok(_,token::LPAREN),\n-                                     ast::TTTok(_,token::DOLLAR),\n-                                     ast::TTTok(_,_),\n-                                     ast::TTTok(_,token::RPAREN)] => {\n-                                        assert_eq!(\"correct\",\"correct\")\n-                                    }\n-                                    _ => assert_eq!(\"wrong 4\",\"correct\")\n-                                }\n-                            },\n-                            _ => {\n-                                error!(\"failing value 3: {}\",first_set);\n-                                assert_eq!(\"wrong 3\",\"correct\")\n-                            }\n+            [ast::TtToken(_, token::IDENT(name_macro_rules, false)),\n+             ast::TtToken(_, token::NOT),\n+             ast::TtToken(_, token::IDENT(name_zip, false)),\n+             ast::TtDelimited(_, ref macro_delimed)]\n+            if name_macro_rules.as_str() == \"macro_rules\"\n+            && name_zip.as_str() == \"zip\" => {\n+                let (ref macro_open, ref macro_tts, ref macro_close) = **macro_delimed;\n+                match (macro_open, macro_tts.as_slice(), macro_close) {\n+                    (&ast::Delimiter { token: token::LPAREN, .. },\n+                     [ast::TtDelimited(_, ref first_delimed),\n+                      ast::TtToken(_, token::FAT_ARROW),\n+                      ast::TtDelimited(_, ref second_delimed)],\n+                     &ast::Delimiter { token: token::RPAREN, .. }) => {\n+                        let (ref first_open, ref first_tts, ref first_close) = **first_delimed;\n+                        match (first_open, first_tts.as_slice(), first_close) {\n+                            (&ast::Delimiter { token: token::LPAREN, .. },\n+                             [ast::TtToken(_, token::DOLLAR),\n+                              ast::TtToken(_, token::IDENT(name, false))],\n+                             &ast::Delimiter { token: token::RPAREN, .. })\n+                            if name.as_str() == \"a\" => {},\n+                            _ => fail!(\"value 3: {}\", **first_delimed),\n+                        }\n+                        let (ref second_open, ref second_tts, ref second_close) = **second_delimed;\n+                        match (second_open, second_tts.as_slice(), second_close) {\n+                            (&ast::Delimiter { token: token::LPAREN, .. },\n+                             [ast::TtToken(_, token::DOLLAR),\n+                              ast::TtToken(_, token::IDENT(name, false))],\n+                             &ast::Delimiter { token: token::RPAREN, .. })\n+                            if name.as_str() == \"a\" => {},\n+                            _ => fail!(\"value 4: {}\", **second_delimed),\n                         }\n                     },\n-                    _ => {\n-                        error!(\"failing value 2: {}\",delim_elts);\n-                        assert_eq!(\"wrong\",\"correct\");\n-                    }\n+                    _ => fail!(\"value 2: {}\", **macro_delimed),\n                 }\n             },\n-            _ => {\n-                error!(\"failing value: {}\",tts);\n-                assert_eq!(\"wrong 1\",\"correct\");\n-            }\n+            _ => fail!(\"value: {}\",tts),\n         }\n     }\n \n-    #[test] fn string_to_tts_1 () {\n+    #[test]\n+    fn string_to_tts_1 () {\n         let tts = string_to_tts(\"fn a (b : int) { b; }\".to_string());\n         assert_eq!(json::encode(&tts),\n         \"[\\\n     {\\\n-        \\\"variant\\\":\\\"TTTok\\\",\\\n+        \\\"variant\\\":\\\"TtToken\\\",\\\n         \\\"fields\\\":[\\\n             null,\\\n             {\\\n@@ -859,7 +851,7 @@ mod test {\n         ]\\\n     },\\\n     {\\\n-        \\\"variant\\\":\\\"TTTok\\\",\\\n+        \\\"variant\\\":\\\"TtToken\\\",\\\n         \\\"fields\\\":[\\\n             null,\\\n             {\\\n@@ -872,96 +864,90 @@ mod test {\n         ]\\\n     },\\\n     {\\\n-        \\\"variant\\\":\\\"TTDelim\\\",\\\n+        \\\"variant\\\":\\\"TtDelimited\\\",\\\n         \\\"fields\\\":[\\\n+            null,\\\n             [\\\n                 {\\\n-                    \\\"variant\\\":\\\"TTTok\\\",\\\n-                    \\\"fields\\\":[\\\n-                        null,\\\n-                        \\\"LPAREN\\\"\\\n-                    ]\\\n-                },\\\n-                {\\\n-                    \\\"variant\\\":\\\"TTTok\\\",\\\n-                    \\\"fields\\\":[\\\n-                        null,\\\n-                        {\\\n-                            \\\"variant\\\":\\\"IDENT\\\",\\\n-                            \\\"fields\\\":[\\\n-                                \\\"b\\\",\\\n-                                false\\\n-                            ]\\\n-                        }\\\n-                    ]\\\n+                    \\\"span\\\":null,\\\n+                    \\\"token\\\":\\\"LPAREN\\\"\\\n                 },\\\n+                [\\\n+                    {\\\n+                        \\\"variant\\\":\\\"TtToken\\\",\\\n+                        \\\"fields\\\":[\\\n+                            null,\\\n+                            {\\\n+                                \\\"variant\\\":\\\"IDENT\\\",\\\n+                                \\\"fields\\\":[\\\n+                                    \\\"b\\\",\\\n+                                    false\\\n+                                ]\\\n+                            }\\\n+                        ]\\\n+                    },\\\n+                    {\\\n+                        \\\"variant\\\":\\\"TtToken\\\",\\\n+                        \\\"fields\\\":[\\\n+                            null,\\\n+                            \\\"COLON\\\"\\\n+                        ]\\\n+                    },\\\n+                    {\\\n+                        \\\"variant\\\":\\\"TtToken\\\",\\\n+                        \\\"fields\\\":[\\\n+                            null,\\\n+                            {\\\n+                                \\\"variant\\\":\\\"IDENT\\\",\\\n+                                \\\"fields\\\":[\\\n+                                    \\\"int\\\",\\\n+                                    false\\\n+                                ]\\\n+                            }\\\n+                        ]\\\n+                    }\\\n+                ],\\\n                 {\\\n-                    \\\"variant\\\":\\\"TTTok\\\",\\\n-                    \\\"fields\\\":[\\\n-                        null,\\\n-                        \\\"COLON\\\"\\\n-                    ]\\\n-                },\\\n-                {\\\n-                    \\\"variant\\\":\\\"TTTok\\\",\\\n-                    \\\"fields\\\":[\\\n-                        null,\\\n-                        {\\\n-                            \\\"variant\\\":\\\"IDENT\\\",\\\n-                            \\\"fields\\\":[\\\n-                                \\\"int\\\",\\\n-                                false\\\n-                            ]\\\n-                        }\\\n-                    ]\\\n-                },\\\n-                {\\\n-                    \\\"variant\\\":\\\"TTTok\\\",\\\n-                    \\\"fields\\\":[\\\n-                        null,\\\n-                        \\\"RPAREN\\\"\\\n-                    ]\\\n+                    \\\"span\\\":null,\\\n+                    \\\"token\\\":\\\"RPAREN\\\"\\\n                 }\\\n             ]\\\n         ]\\\n     },\\\n     {\\\n-        \\\"variant\\\":\\\"TTDelim\\\",\\\n+        \\\"variant\\\":\\\"TtDelimited\\\",\\\n         \\\"fields\\\":[\\\n+            null,\\\n             [\\\n                 {\\\n-                    \\\"variant\\\":\\\"TTTok\\\",\\\n-                    \\\"fields\\\":[\\\n-                        null,\\\n-                        \\\"LBRACE\\\"\\\n-                    ]\\\n-                },\\\n-                {\\\n-                    \\\"variant\\\":\\\"TTTok\\\",\\\n-                    \\\"fields\\\":[\\\n-                        null,\\\n-                        {\\\n-                            \\\"variant\\\":\\\"IDENT\\\",\\\n-                            \\\"fields\\\":[\\\n-                                \\\"b\\\",\\\n-                                false\\\n-                            ]\\\n-                        }\\\n-                    ]\\\n-                },\\\n-                {\\\n-                    \\\"variant\\\":\\\"TTTok\\\",\\\n-                    \\\"fields\\\":[\\\n-                        null,\\\n-                        \\\"SEMI\\\"\\\n-                    ]\\\n+                    \\\"span\\\":null,\\\n+                    \\\"token\\\":\\\"LBRACE\\\"\\\n                 },\\\n+                [\\\n+                    {\\\n+                        \\\"variant\\\":\\\"TtToken\\\",\\\n+                        \\\"fields\\\":[\\\n+                            null,\\\n+                            {\\\n+                                \\\"variant\\\":\\\"IDENT\\\",\\\n+                                \\\"fields\\\":[\\\n+                                    \\\"b\\\",\\\n+                                    false\\\n+                                ]\\\n+                            }\\\n+                        ]\\\n+                    },\\\n+                    {\\\n+                        \\\"variant\\\":\\\"TtToken\\\",\\\n+                        \\\"fields\\\":[\\\n+                            null,\\\n+                            \\\"SEMI\\\"\\\n+                        ]\\\n+                    }\\\n+                ],\\\n                 {\\\n-                    \\\"variant\\\":\\\"TTTok\\\",\\\n-                    \\\"fields\\\":[\\\n-                        null,\\\n-                        \\\"RBRACE\\\"\\\n-                    ]\\\n+                    \\\"span\\\":null,\\\n+                    \\\"token\\\":\\\"RBRACE\\\"\\\n                 }\\\n             ]\\\n         ]\\"}, {"sha": "7bf751c2d5ebf3b4a7a9c50767bdd4e4c20d618d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -48,8 +48,8 @@ use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n use ast::{StructVariantKind, BiSub};\n use ast::StrStyle;\n use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n-use ast::{TokenTree, TraitItem, TraitRef, TTDelim, TTSeq, TTTok};\n-use ast::{TTNonterminal, TupleVariantKind, Ty, Ty_, TyBot};\n+use ast::{Delimiter, TokenTree, TraitItem, TraitRef, TtDelimited, TtSequence, TtToken};\n+use ast::{TtNonterminal, TupleVariantKind, Ty, Ty_, TyBot};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n use ast::{TyNil, TyParam, TyParamBound, TyParen, TyPath, TyPtr, TyQPath};\n@@ -2497,27 +2497,30 @@ impl<'a> Parser<'a> {\n         return e;\n     }\n \n-    /// Parse an optional separator followed by a kleene-style\n+    /// Parse an optional separator followed by a Kleene-style\n     /// repetition token (+ or *).\n-    pub fn parse_sep_and_zerok(&mut self) -> (Option<token::Token>, bool) {\n-        fn parse_zerok(parser: &mut Parser) -> Option<bool> {\n+    pub fn parse_sep_and_kleene_op(&mut self) -> (Option<token::Token>, ast::KleeneOp) {\n+        fn parse_kleene_op(parser: &mut Parser) -> Option<ast::KleeneOp> {\n             match parser.token {\n-                token::BINOP(token::STAR) | token::BINOP(token::PLUS) => {\n-                    let zerok = parser.token == token::BINOP(token::STAR);\n+                token::BINOP(token::STAR) => {\n                     parser.bump();\n-                    Some(zerok)\n+                    Some(ast::ZeroOrMore)\n+                },\n+                token::BINOP(token::PLUS) => {\n+                    parser.bump();\n+                    Some(ast::OneOrMore)\n                 },\n                 _ => None\n             }\n         };\n \n-        match parse_zerok(self) {\n-            Some(zerok) => return (None, zerok),\n+        match parse_kleene_op(self) {\n+            Some(kleene_op) => return (None, kleene_op),\n             None => {}\n         }\n \n         let separator = self.bump_and_get();\n-        match parse_zerok(self) {\n+        match parse_kleene_op(self) {\n             Some(zerok) => (Some(separator), zerok),\n             None => self.fatal(\"expected `*` or `+`\")\n         }\n@@ -2526,8 +2529,8 @@ impl<'a> Parser<'a> {\n     /// parse a single token tree from the input.\n     pub fn parse_token_tree(&mut self) -> TokenTree {\n         // FIXME #6994: currently, this is too eager. It\n-        // parses token trees but also identifies TTSeq's\n-        // and TTNonterminal's; it's too early to know yet\n+        // parses token trees but also identifies TtSequence's\n+        // and TtNonterminal's; it's too early to know yet\n         // whether something will be a nonterminal or a seq\n         // yet.\n         maybe_whole!(deref self, NtTT);\n@@ -2564,26 +2567,21 @@ impl<'a> Parser<'a> {\n                         seq_sep_none(),\n                         |p| p.parse_token_tree()\n                     );\n-                    let (s, z) = p.parse_sep_and_zerok();\n+                    let (sep, repeat) = p.parse_sep_and_kleene_op();\n                     let seq = match seq {\n                         Spanned { node, .. } => node,\n                     };\n-                    TTSeq(mk_sp(sp.lo, p.span.hi), Rc::new(seq), s, z)\n+                    TtSequence(mk_sp(sp.lo, p.span.hi), Rc::new(seq), sep, repeat)\n                 } else {\n-                    TTNonterminal(sp, p.parse_ident())\n+                    TtNonterminal(sp, p.parse_ident())\n                 }\n               }\n               _ => {\n-                  parse_any_tt_tok(p)\n+                  TtToken(p.span, p.bump_and_get())\n               }\n             }\n         }\n \n-        // turn the next token into a TTTok:\n-        fn parse_any_tt_tok(p: &mut Parser) -> TokenTree {\n-            TTTok(p.span, p.bump_and_get())\n-        }\n-\n         match (&self.token, token::close_delimiter_for(&self.token)) {\n             (&token::EOF, _) => {\n                 let open_braces = self.open_braces.clone();\n@@ -2595,21 +2593,32 @@ impl<'a> Parser<'a> {\n                 self.fatal(\"this file contains an un-closed delimiter \");\n             }\n             (_, Some(close_delim)) => {\n+                // The span for beginning of the delimited section\n+                let pre_span = self.span;\n+\n                 // Parse the open delimiter.\n                 self.open_braces.push(self.span);\n-                let mut result = vec!(parse_any_tt_tok(self));\n+                let open = Delimiter {\n+                    span: self.span,\n+                    token: self.bump_and_get(),\n+                };\n \n-                let trees =\n-                    self.parse_seq_to_before_end(&close_delim,\n-                                                 seq_sep_none(),\n-                                                 |p| p.parse_token_tree());\n-                result.extend(trees.into_iter());\n+                // Parse the token trees within the delimeters\n+                let tts = self.parse_seq_to_before_end(\n+                    &close_delim, seq_sep_none(), |p| p.parse_token_tree()\n+                );\n \n                 // Parse the close delimiter.\n-                result.push(parse_any_tt_tok(self));\n+                let close = Delimiter {\n+                    span: self.span,\n+                    token: self.bump_and_get(),\n+                };\n                 self.open_braces.pop().unwrap();\n \n-                TTDelim(Rc::new(result))\n+                // Expand to cover the entire delimited token tree\n+                let span = Span { hi: self.span.hi, ..pre_span };\n+\n+                TtDelimited(span, Rc::new((open, tts, close)))\n             }\n             _ => parse_non_delim_tt_tok(self)\n         }\n@@ -2673,8 +2682,8 @@ impl<'a> Parser<'a> {\n                 if ms.len() == 0u {\n                     self.fatal(\"repetition body must be nonempty\");\n                 }\n-                let (sep, zerok) = self.parse_sep_and_zerok();\n-                MatchSeq(ms, sep, zerok, name_idx_lo, *name_idx)\n+                let (sep, kleene_op) = self.parse_sep_and_kleene_op();\n+                MatchSeq(ms, sep, kleene_op, name_idx_lo, *name_idx)\n             } else {\n                 let bound_to = self.parse_ident();\n                 self.expect(&token::COLON);"}, {"sha": "69e6d78d16a57e9f6f3fb020bf76bd17cc8e87a1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -224,6 +224,10 @@ pub fn item_to_string(i: &ast::Item) -> String {\n     $to_string(|s| s.print_item(i))\n }\n \n+pub fn view_item_to_string(i: &ast::ViewItem) -> String {\n+    $to_string(|s| s.print_view_item(i))\n+}\n+\n pub fn generics_to_string(generics: &ast::Generics) -> String {\n     $to_string(|s| s.print_generics(generics))\n }\n@@ -1020,8 +1024,15 @@ impl<'a> State<'a> {\n     /// expression arguments as expressions). It can be done! I think.\n     pub fn print_tt(&mut self, tt: &ast::TokenTree) -> IoResult<()> {\n         match *tt {\n-            ast::TTDelim(ref tts) => self.print_tts(tts.as_slice()),\n-            ast::TTTok(_, ref tk) => {\n+            ast::TtDelimited(_, ref delimed) => {\n+                let (ref open, ref tts, ref close) = **delimed;\n+                try!(word(&mut self.s, parse::token::to_string(&open.token).as_slice()));\n+                try!(space(&mut self.s));\n+                try!(self.print_tts(tts.as_slice()));\n+                try!(space(&mut self.s));\n+                word(&mut self.s, parse::token::to_string(&close.token).as_slice())\n+            },\n+            ast::TtToken(_, ref tk) => {\n                 try!(word(&mut self.s, parse::token::to_string(tk).as_slice()));\n                 match *tk {\n                     parse::token::DOC_COMMENT(..) => {\n@@ -1030,22 +1041,25 @@ impl<'a> State<'a> {\n                     _ => Ok(())\n                 }\n             }\n-            ast::TTSeq(_, ref tts, ref sep, zerok) => {\n+            ast::TtSequence(_, ref tts, ref separator, kleene_op) => {\n                 try!(word(&mut self.s, \"$(\"));\n                 for tt_elt in (*tts).iter() {\n                     try!(self.print_tt(tt_elt));\n                 }\n                 try!(word(&mut self.s, \")\"));\n-                match *sep {\n+                match *separator {\n                     Some(ref tk) => {\n                         try!(word(&mut self.s,\n                                   parse::token::to_string(tk).as_slice()));\n                     }\n                     None => ()\n                 }\n-                word(&mut self.s, if zerok { \"*\" } else { \"+\" })\n+                match kleene_op {\n+                    ast::ZeroOrMore => word(&mut self.s, \"*\"),\n+                    ast::OneOrMore => word(&mut self.s, \"+\"),\n+                }\n             }\n-            ast::TTNonterminal(_, name) => {\n+            ast::TtNonterminal(_, name) => {\n                 try!(word(&mut self.s, \"$\"));\n                 self.print_ident(name)\n             }\n@@ -1983,8 +1997,10 @@ impl<'a> State<'a> {\n                     Consistent, fields.as_slice(),\n                     |s, f| {\n                         try!(s.cbox(indent_unit));\n-                        try!(s.print_ident(f.node.ident));\n-                        try!(s.word_nbsp(\":\"));\n+                        if !f.node.is_shorthand {\n+                            try!(s.print_ident(f.node.ident));\n+                            try!(s.word_nbsp(\":\"));\n+                        }\n                         try!(s.print_pat(&*f.node.pat));\n                         s.end()\n                     },"}, {"sha": "d4f06403c1a6e6bd02c9ffec821197f94ddc4fe1", "filename": "src/libterm/win.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -71,7 +71,8 @@ fn color_to_bits(color: color::Color) -> u16 {\n }\n \n fn bits_to_color(bits: u16) -> color::Color {\n-    let color = match bits & 0x7 {\n+    let bits = bits & 0x7;\n+    let color = match bits {\n         0 => color::BLACK,\n         0x1 => color::BLUE,\n         0x2 => color::GREEN,"}, {"sha": "f6eea15d8cfcf1325106320aef9c723b1c66fc8e", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -1,3 +1,12 @@\n+S 2014-10-22 d44ea72\n+  freebsd-x86_64 8bf5ee7c1ca8ab880800cf3a535e16bb7ffbf9e8\n+  linux-i386 1fc8302b405406a3fc183b23c8397bef5a56c52a\n+  linux-x86_64 3e04d8197a96b0c858e4e2763b3893df35ae2fb3\n+  macos-i386 b9823771ae6237a3c1c19eb2e98a2372ce23439d\n+  macos-x86_64 3cf9fc1cd252a80430d8673e35a1256674e122ae\n+  winnt-i386 5a6d2ad82a31deffad5b6a17487a8cd5c21f7636\n+  winnt-x86_64 7468b87eb5be238993ccd41ad74bbd88dd176d31\n+\n S 2014-10-10 78a7676\n   freebsd-x86_64 511061af382e2e837a6d615823e1a952e8281483\n   linux-i386 0644637db852db8a6c603ded0531ccaa60291bd3"}, {"sha": "40ed3a35ddf134bb6b6f9b174bb704d800738314", "filename": "src/test/auxiliary/roman_numerals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fauxiliary%2Froman_numerals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fauxiliary%2Froman_numerals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Froman_numerals.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -18,7 +18,7 @@ extern crate rustc;\n \n use syntax::codemap::Span;\n use syntax::parse::token::{IDENT, get_ident};\n-use syntax::ast::{TokenTree, TTTok};\n+use syntax::ast::{TokenTree, TtToken};\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacExpr};\n use syntax::ext::build::AstBuilder;  // trait for expr_uint\n use rustc::plugin::Registry;\n@@ -39,7 +39,7 @@ fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         (\"I\",    1)];\n \n     let text = match args {\n-        [TTTok(_, IDENT(s, _))] => get_ident(s).to_string(),\n+        [TtToken(_, IDENT(s, _))] => get_ident(s).to_string(),\n         _ => {\n             cx.span_err(sp, \"argument should be a single identifier\");\n             return DummyResult::any(sp);"}, {"sha": "07676679ef18f1a50bc927f6bf51710b421b86db", "filename": "src/test/compile-fail/issue-12863.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-12863.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-12863.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12863.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod foo { pub fn bar() {} }\n+\n+fn main() {\n+    match () {\n+        foo::bar => {} //~ ERROR `bar` is not an enum variant, struct or const\n+    }\n+}"}, {"sha": "92add18f9413c1faae4be1c80c32f13e56262e48", "filename": "src/test/compile-fail/issue-14721.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-14721.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-14721.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14721.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let foo = \"str\";\n+    println!(\"{}\", foo.desc); //~ ERROR attempted access of field `desc` on type `&str`,\n+                              //        but no field with that name was found\n+}"}, {"sha": "d9dfaac572066b6ab70c08b4ede661b505203500", "filename": "src/test/compile-fail/issue-16683.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-16683.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-16683.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16683.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait T<'a> {\n+    fn a(&'a self) -> &'a bool;\n+    fn b(&self) {\n+        self.a(); //~ ERROR mismatched types: expected `&'a Self`, found `&Self` (lifetime mismatch)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b1fbe6f5549e4face3d68a591b0039f1c5dd655b", "filename": "src/test/compile-fail/issue-17458.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-17458.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-17458.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17458.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n static X: uint = 0 as *const uint as uint;\n+//~^ ERROR: can not cast a pointer to an integer in a constant expression\n \n fn main() {\n     assert_eq!(X, 0);", "previous_filename": "src/test/run-pass/issue-17458.rs"}, {"sha": "197319b6d4340f2ee5a95936ebad1fb26ee94249", "filename": "src/test/compile-fail/issue-17551.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-17551.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-17551.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17551.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+struct B<T>;\n+\n+fn main() {\n+    let foo = B; //~ ERROR unable to infer enough type information to locate the impl of the trait\n+    let closure = |:| foo;\n+}"}, {"sha": "4497c8088c31cba8a8f2c815b85d90251dfdd16d", "filename": "src/test/compile-fail/issue-18118.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-18118.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-18118.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18118.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    static z: &'static int = {\n+        let p = 3;\n+        &p\n+//~^ ERROR cannot borrow a local variable inside a static block, define a separate static instead\n+    };\n+}"}, {"sha": "c884f02892f167b61991d7c7f8f6d4c4da296f60", "filename": "src/test/compile-fail/issue-18252.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-18252.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-18252.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18252.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(struct_variant)]\n+\n+enum Foo {\n+    Variant { x: uint }\n+}\n+\n+fn main() {\n+    let f = Variant(42u); //~ ERROR expected function, found `Foo`\n+}"}, {"sha": "ca4cf526f07a49606828a730479f7df339f80045", "filename": "src/test/compile-fail/issue-18294.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-18294.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-18294.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18294.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    const X: u32 = 1;\n+    const Y: uint = &X as *const u32 as uint; //~ ERROR E0018\n+    println!(\"{}\", Y);\n+}"}, {"sha": "1608d2137fc3216ee92862d8f79619c584b9aa09", "filename": "src/test/compile-fail/issue-18343.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-18343.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-18343.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18343.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Obj<'a> {\n+    closure: ||: 'a -> u32\n+}\n+\n+fn main() {\n+    let o = Obj { closure: || 42 };\n+    o.closure(); //~ ERROR type `Obj<'_>` does not implement any method in scope named `closure`\n+    //~^ NOTE use `(s.closure)(...)` if you meant to call the function stored in the `closure` field\n+}"}, {"sha": "a5d23c70bd5e8a208c6bc05ff28db7025e5c3f86", "filename": "src/test/compile-fail/issue-6991.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-6991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-6991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6991.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static x: &'static uint = &1;\n+static y: uint = *x;\n+//~^ ERROR cannot refer to other statics by value,\n+//         use the address-of operator or a constant instead\n+fn main() {}"}, {"sha": "0ab551642a0c4b4638e2a8a33dfe0936710131ae", "filename": "src/test/compile-fail/issue-7867.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-7867.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Fissue-7867.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7867.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum A { B, C }\n+\n+mod foo { pub fn bar() {} }\n+\n+fn main() {\n+    match (true, false) {\n+        B => (), //~ ERROR expected `(bool,bool)`, found `A` (expected tuple, found enum A)\n+        _ => ()\n+    }\n+\n+    match &Some(42i) {\n+        Some(x) => (), //~ ERROR expected `&core::option::Option<int>`,\n+                       //        found `core::option::Option<<generic #4>>`\n+        None => ()     //~ ERROR expected `&core::option::Option<int>`,\n+                       //        found `core::option::Option<<generic #5>>`\n+    }\n+}"}, {"sha": "e28abaf2b1fd6a85078769b20af8569b9d58d2b3", "filename": "src/test/compile-fail/unboxed-closure-immutable-capture.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Funboxed-closure-immutable-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fcompile-fail%2Funboxed-closure-immutable-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-immutable-capture.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+// Test that even unboxed closures that are capable of mutating their\n+// environment cannot mutate captured variables that have not been\n+// declared mutable (#18335)\n+\n+fn set(x: &mut uint) { *x = 0; }\n+\n+fn main() {\n+    let x = 0u;\n+    move |&mut:| x = 1; //~ ERROR cannot assign\n+    move |&mut:| set(&mut x); //~ ERROR cannot borrow\n+    move |:| x = 1; //~ ERROR cannot assign\n+    move |:| set(&mut x); //~ ERROR cannot borrow\n+    |&mut:| x = 1; //~ ERROR cannot assign\n+    // FIXME: this should be `cannot borrow` (issue #18330)\n+    |&mut:| set(&mut x); //~ ERROR cannot assign\n+    |:| x = 1; //~ ERROR cannot assign\n+    // FIXME: this should be `cannot borrow` (issue #18330)\n+    |:| set(&mut x); //~ ERROR cannot assign\n+}"}, {"sha": "b0795bb08f361e1f6d0696ab2dafb9de586b5104", "filename": "src/test/pretty/struct-pattern.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fpretty%2Fstruct-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Fpretty%2Fstruct-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fstruct-pattern.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// pp-exact\n+// pretty-compare-only\n+// Testing that shorthand struct patterns are preserved\n+\n+fn main() { let Foo { a, ref b, mut c, x: y, z: z } = foo; }"}, {"sha": "9d98a7ac12f9ba1809d7845d3630ea3a3fde7ac9", "filename": "src/test/run-pass/closure-syntax.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -9,6 +9,9 @@\n // except according to those terms.\n \n #![allow(dead_code)]\n+#![feature(unboxed_closures, unboxed_closure_sugar)]\n+\n+// compile-flags:-g\n \n fn foo<T>() {}\n \n@@ -82,6 +85,9 @@ fn bar<'b>() {\n     // issue #13490\n     let _ = || -> ! loop {};\n     let _ = proc() -> ! loop {};\n+\n+    // issue #17021\n+    let c = box |&:| {};\n }\n \n struct B<T>;"}, {"sha": "dbad546ce1ae3fd1a427b91afa99d06deecaed6f", "filename": "src/test/run-pass/dst-coercions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fdst-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fdst-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-coercions.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -28,7 +28,7 @@ pub fn main() {\n \n     let x: *mut S = &mut S;\n \n-    // Test we can chnage the mutability from mut to const.\n+    // Test we can change the mutability from mut to const.\n     let x: &T = &mut S;\n     let x: *const T = &mut S;\n }"}, {"sha": "4d64103e502240cd991c39fa8ee983b4d0ecdc73", "filename": "src/test/run-pass/issue-12028.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fissue-12028.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fissue-12028.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12028.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Hash<H> {\n+    fn hash2(&self, hasher: &H) -> u64;\n+}\n+\n+trait Stream {\n+    fn input(&mut self, bytes: &[u8]);\n+    fn result(&self) -> u64;\n+}\n+\n+trait StreamHasher<S: Stream> {\n+    fn stream(&self) -> S;\n+}\n+\n+//////////////////////////////////////////////////////////////////////////////\n+\n+trait StreamHash<S: Stream, H: StreamHasher<S>>: Hash<H> {\n+    fn input_stream(&self, stream: &mut S);\n+}\n+\n+impl<S: Stream, H: StreamHasher<S>> Hash<H> for u8 {\n+    fn hash2(&self, hasher: &H) -> u64 {\n+        let mut stream = hasher.stream();\n+        self.input_stream(&mut stream);\n+        stream.result()\n+    }\n+}\n+\n+impl<S: Stream, H: StreamHasher<S>> StreamHash<S, H> for u8 {\n+    fn input_stream(&self, stream: &mut S) {\n+        stream.input([*self]);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f93347f4366c69e9939322c4594d4d7666988fb5", "filename": "src/test/run-pass/issue-14901.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fissue-14901.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fissue-14901.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14901.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::io::Reader;\n+\n+enum Wrapper<'a> {\n+    WrapReader(&'a Reader + 'a)\n+}\n+\n+trait Wrap<'a> {\n+    fn wrap(self) -> Wrapper<'a>;\n+}\n+\n+impl<'a, R: Reader> Wrap<'a> for &'a mut R {\n+    fn wrap(self) -> Wrapper<'a> {\n+        WrapReader(self as &'a mut Reader)\n+    }\n+}\n+\n+pub fn main() {}"}, {"sha": "77eba0245b1c34a294db639b01a1dedab1ba6e91", "filename": "src/test/run-pass/issue-16560.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fissue-16560.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fissue-16560.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16560.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+use std::mem;\n+\n+fn main() {\n+    let y = 0u8;\n+    let closure = move |&: x| y + x;\n+\n+    // Check that both closures are capturing by value\n+    assert_eq!(1, mem::size_of_val(&closure));\n+\n+    spawn(proc() {\n+        let ok = closure;\n+    })\n+}"}, {"sha": "b66fb4306d02993b01d7f413580592385cfbcea4", "filename": "src/test/run-pass/issue-16668.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fissue-16668.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fissue-16668.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16668.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty\n+\n+#![feature(unboxed_closures)]\n+\n+struct Parser<'a, I, O> {\n+    parse: Box<FnMut<(I,), Result<O, String>> + 'a>\n+}\n+\n+impl<'a, I, O: 'a> Parser<'a, I, O> {\n+    fn compose<K: 'a>(mut self, mut rhs: Parser<O, K>) -> Parser<'a, I, K> {\n+        Parser {\n+            parse: box move |&mut: x: I| {\n+                match self.parse.call_mut((x,)) {\n+                    Ok(r) => rhs.parse.call_mut((r,)),\n+                    Err(e) => Err(e)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "7878d698e52ae148190fd3ce9b69aaec3e2cc279", "filename": "src/test/run-pass/issue-18352.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fissue-18352.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fissue-18352.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18352.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const X: &'static str = \"12345\";\n+\n+fn test(s: String) -> bool {\n+    match s.as_slice() {\n+        X => true,\n+        _ => false\n+    }\n+}\n+\n+fn main() {\n+    assert!(test(\"12345\".to_string()));\n+}"}, {"sha": "2a44df7a1b5667770c167662348ff0524779b2db", "filename": "src/test/run-pass/out-pointer-aliasing.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fout-pointer-aliasing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fout-pointer-aliasing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-pointer-aliasing.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Foo {\n+    f1: int,\n+    _f2: int,\n+}\n+\n+#[inline(never)]\n+pub fn foo(f: &mut Foo) -> Foo {\n+    let ret = *f;\n+    f.f1 = 0;\n+    ret\n+}\n+\n+pub fn main() {\n+    let mut f = Foo {\n+        f1: 8,\n+        _f2: 9,\n+    };\n+    f = foo(&mut f);\n+    assert_eq!(f.f1, 8);\n+}"}, {"sha": "966e34dfe49c6902ae161768403ebf9dfd167608", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -30,7 +30,7 @@ unsafe fn test_triangle() -> bool {\n     let ascend = ascend.as_mut_slice();\n     static ALIGN : uint = 1;\n \n-    // Checks that `ascend` forms triangle of acending size formed\n+    // Checks that `ascend` forms triangle of ascending size formed\n     // from pairs of rows (where each pair of rows is equally sized),\n     // and the elements of the triangle match their row-pair index.\n     unsafe fn sanity_check(ascend: &[*mut u8]) {"}, {"sha": "a5efb32079de854d3514c79f327c479de99dd1e0", "filename": "src/test/run-pass/trait-cache-issue-18209.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Ftrait-cache-issue-18209.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Ftrait-cache-issue-18209.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-cache-issue-18209.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the cache results from the default method do not pollute\n+// the cache for the later call in `load()`.\n+//\n+// See issue #18209.\n+\n+pub trait Foo {\n+    fn load_from() -> Box<Self>;\n+    fn load() -> Box<Self> {\n+        Foo::load_from()\n+    }\n+}\n+\n+pub fn load<M: Foo>() -> Box<M> {\n+    Foo::load()\n+}\n+\n+fn main() { }"}, {"sha": "f7e1e46e54d65dad51322605a1bbec8a8557e9c0", "filename": "src/test/run-pass/unboxed-closures-move-mutable.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Funboxed-closures-move-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Funboxed-closures-move-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-move-mutable.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+#![deny(unused_mut)]\n+\n+// Test that mutating a mutable upvar in a capture-by-value unboxed\n+// closure does not ice (issue #18238) and marks the upvar as used\n+// mutably so we do not get a spurious warning about it not needing to\n+// be declared mutable (issue #18336).\n+\n+fn main() {\n+    {\n+        let mut x = 0u;\n+        move |&mut:| x += 1;\n+    }\n+    {\n+        let mut x = 0u;\n+        move |:| x += 1;\n+    }\n+}"}, {"sha": "11b58948e0535d1f928630cf16740ece3ce9efb2", "filename": "src/test/run-pass/vec-dst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fvec-dst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7138dd698dde29fb4d7fd34529a863b85d947e/src%2Ftest%2Frun-pass%2Fvec-dst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-dst.rs?ref=bd7138dd698dde29fb4d7fd34529a863b85d947e", "patch": "@@ -10,7 +10,7 @@\n \n fn sub_expr() {\n     // Test for a &[T] => &&[T] coercion in sub-expression position\n-    // (surpisingly, this can cause errors which are not caused by either of:\n+    // (surprisingly, this can cause errors which are not caused by either of:\n     //    `let x = vec.slice_mut(0, 2);`\n     //    `foo(vec.slice_mut(0, 2));` ).\n     let mut vec: Vec<int> = vec!(1, 2, 3, 4);"}]}