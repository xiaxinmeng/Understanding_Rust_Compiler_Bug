{"sha": "f6d1f368db9e726fde825dc2525cdec07673b416", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZDFmMzY4ZGI5ZTcyNmZkZTgyNWRjMjUyNWNkZWMwNzY3M2I0MTY=", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-04-08T15:50:13Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-04-08T15:50:13Z"}, "message": "Merge commit 'b40ea209e7f14c8193ddfc98143967b6a2f4f5c9' into clippyup", "tree": {"sha": "3528a2e5d9d2c22732db72815ce4e121b157bfb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3528a2e5d9d2c22732db72815ce4e121b157bfb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6d1f368db9e726fde825dc2525cdec07673b416", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6d1f368db9e726fde825dc2525cdec07673b416", "html_url": "https://github.com/rust-lang/rust/commit/f6d1f368db9e726fde825dc2525cdec07673b416", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6d1f368db9e726fde825dc2525cdec07673b416/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cde58f7174cd83752b3c0a00a970dcc07c511077", "url": "https://api.github.com/repos/rust-lang/rust/commits/cde58f7174cd83752b3c0a00a970dcc07c511077", "html_url": "https://github.com/rust-lang/rust/commit/cde58f7174cd83752b3c0a00a970dcc07c511077"}], "stats": {"total": 16207, "additions": 10307, "deletions": 5900}, "files": [{"sha": "73997192ae0d5537db33b9c7a1f52990cf0d3c21", "filename": "CHANGELOG.md", "status": "modified", "additions": 143, "deletions": 3, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -6,11 +6,146 @@ document.\n \n ## Unreleased / In Rust Nightly\n \n-[3e41797...master](https://github.com/rust-lang/rust-clippy/compare/3e41797...master)\n+[6ed6f1e...master](https://github.com/rust-lang/rust-clippy/compare/6ed6f1e...master)\n+\n+## Rust 1.52\n+\n+Current beta, release 2021-05-06\n+\n+[3e41797...6ed6f1e](https://github.com/rust-lang/rust-clippy/compare/3e41797...6ed6f1e)\n+\n+### New Lints\n+\n+* [`from_str_radix_10`]\n+  [#6717](https://github.com/rust-lang/rust-clippy/pull/6717)\n+* [`implicit_clone`]\n+  [#6730](https://github.com/rust-lang/rust-clippy/pull/6730)\n+* [`semicolon_if_nothing_returned`]\n+  [#6681](https://github.com/rust-lang/rust-clippy/pull/6681)\n+* [`manual_flatten`]\n+  [#6646](https://github.com/rust-lang/rust-clippy/pull/6646)\n+* [`inconsistent_struct_constructor`]\n+  [#6769](https://github.com/rust-lang/rust-clippy/pull/6769)\n+* [`iter_count`]\n+  [#6791](https://github.com/rust-lang/rust-clippy/pull/6791)\n+* [`default_numeric_fallback`]\n+  [#6662](https://github.com/rust-lang/rust-clippy/pull/6662)\n+* [`bytes_nth`]\n+  [#6695](https://github.com/rust-lang/rust-clippy/pull/6695)\n+* [`filter_map_identity`]\n+  [#6685](https://github.com/rust-lang/rust-clippy/pull/6685)\n+* [`manual_map`]\n+  [#6573](https://github.com/rust-lang/rust-clippy/pull/6573)\n+\n+### Moves and Deprecations\n+\n+* Moved [`upper_case_acronyms`] to `pedantic`\n+  [#6775](https://github.com/rust-lang/rust-clippy/pull/6775)\n+* Moved [`manual_map`] to `nursery`\n+  [#6796](https://github.com/rust-lang/rust-clippy/pull/6796)\n+* Moved [`unnecessary_wraps`] to `pedantic`\n+  [#6765](https://github.com/rust-lang/rust-clippy/pull/6765)\n+* Moved [`trivial_regex`] to `nursery`\n+  [#6696](https://github.com/rust-lang/rust-clippy/pull/6696)\n+* Moved [`naive_bytecount`] to `pedantic`\n+  [#6825](https://github.com/rust-lang/rust-clippy/pull/6825)\n+* Moved [`upper_case_acronyms`] to `style`\n+  [#6788](https://github.com/rust-lang/rust-clippy/pull/6788)\n+* Moved [`manual_map`] to `style`\n+  [#6801](https://github.com/rust-lang/rust-clippy/pull/6801)\n+\n+### Enhancements\n+\n+* [`disallowed_method`]: Now supports functions in addition to methods\n+  [#6674](https://github.com/rust-lang/rust-clippy/pull/6674)\n+* [`upper_case_acronyms`]: Added a new configuration `upper-case-acronyms-aggressive` to\n+  trigger the lint if there is more than one uppercase character next to each other\n+  [#6788](https://github.com/rust-lang/rust-clippy/pull/6788)\n+* [`collapsible_match`]: Now supports block comparison with different value names\n+  [#6754](https://github.com/rust-lang/rust-clippy/pull/6754)\n+* [`unnecessary_wraps`]: Will now suggest removing unnecessary wrapped return unit type, like `Option<()>`\n+  [#6665](https://github.com/rust-lang/rust-clippy/pull/6665)\n+* Improved value usage detection in closures\n+  [#6698](https://github.com/rust-lang/rust-clippy/pull/6698)\n+\n+### False Positive Fixes\n+\n+* [`use_self`]: No longer lints in macros\n+  [#6833](https://github.com/rust-lang/rust-clippy/pull/6833)\n+* [`use_self`]: Fixed multiple false positives for: generics, associated types and derive implementations\n+  [#6179](https://github.com/rust-lang/rust-clippy/pull/6179)\n+* [`missing_inline_in_public_items`]: No longer lints for procedural macros\n+  [#6814](https://github.com/rust-lang/rust-clippy/pull/6814)\n+* [`inherent_to_string`]: No longer lints on functions with function generics\n+  [#6771](https://github.com/rust-lang/rust-clippy/pull/6771)\n+* [`doc_markdown`]: Add `OpenDNS` to the default configuration as an allowed identifier\n+  [#6783](https://github.com/rust-lang/rust-clippy/pull/6783)\n+* [`missing_panics_doc`]: No longer lints on [`unreachable!`](https://doc.rust-lang.org/std/macro.unreachable.html)\n+  [#6700](https://github.com/rust-lang/rust-clippy/pull/6700)\n+* [`collapsible_if`]: No longer lints on if statements with attributes\n+  [#6701](https://github.com/rust-lang/rust-clippy/pull/6701)\n+* [`match_same_arms`]: Only considers empty blocks as equal if the tokens contained are the same\n+  [#6843](https://github.com/rust-lang/rust-clippy/pull/6843)\n+* [`redundant_closure`]: Now ignores macros\n+  [#6871](https://github.com/rust-lang/rust-clippy/pull/6871)\n+* [`manual_map`]: Fixed false positives when control flow statements like `return`, `break` etc. are used\n+  [#6801](https://github.com/rust-lang/rust-clippy/pull/6801)\n+* [`vec_init_then_push`]: Fixed false positives for loops and if statements\n+  [#6697](https://github.com/rust-lang/rust-clippy/pull/6697)\n+* [`len_without_is_empty`]: Will now consider multiple impl blocks and `#[allow]` on\n+  the `len` method as well as the type definition.\n+  [#6853](https://github.com/rust-lang/rust-clippy/pull/6853)\n+* [`let_underscore_drop`]: Only lints on types which implement `Drop`\n+  [#6682](https://github.com/rust-lang/rust-clippy/pull/6682)\n+* [`unit_arg`]: No longer lints on unit arguments when they come from a path expression.\n+  [#6601](https://github.com/rust-lang/rust-clippy/pull/6601)\n+* [`cargo_common_metadata`]: No longer lints if \n+  [`publish = false`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-publish-field)\n+  is defined in the manifest\n+  [#6650](https://github.com/rust-lang/rust-clippy/pull/6650)\n+\n+### Suggestion Fixes/Improvements\n+\n+* [`collapsible_match`]: Fixed lint message capitalization\n+  [#6766](https://github.com/rust-lang/rust-clippy/pull/6766)\n+* [`or_fun_call`]: Improved suggestions for `or_insert(vec![])`\n+  [#6790](https://github.com/rust-lang/rust-clippy/pull/6790)\n+* [`manual_map`]: No longer expands macros in the suggestions\n+  [#6801](https://github.com/rust-lang/rust-clippy/pull/6801)\n+* Aligned Clippy's lint messages with the rustc dev guide\n+  [#6787](https://github.com/rust-lang/rust-clippy/pull/6787)\n+\n+### ICE Fixes\n+\n+* [`zero_sized_map_values`]\n+  [#6866](https://github.com/rust-lang/rust-clippy/pull/6866)\n+\n+### Documentation Improvements\n+\n+* [`useless_format`]: Improved the documentation example\n+  [#6854](https://github.com/rust-lang/rust-clippy/pull/6854)\n+* Clippy's [`README.md`]: Includes a new subsection on running Clippy as a rustc wrapper \n+  [#6782](https://github.com/rust-lang/rust-clippy/pull/6782)\n+\n+### Others\n+* Running `cargo clippy` after `cargo check` now works as expected \n+  (`cargo clippy` and `cargo check` no longer shares the same build cache)\n+  [#6687](https://github.com/rust-lang/rust-clippy/pull/6687)\n+* Cargo now re-runs Clippy if arguments after `--` provided to `cargo clippy` are changed.\n+  [#6834](https://github.com/rust-lang/rust-clippy/pull/6834)\n+* Extracted Clippy's `utils` module into the new `clippy_utils` crate\n+  [#6756](https://github.com/rust-lang/rust-clippy/pull/6756)\n+* Clippy lintcheck tool improvements\n+  [#6800](https://github.com/rust-lang/rust-clippy/pull/6800)\n+  [#6735](https://github.com/rust-lang/rust-clippy/pull/6735)\n+  [#6764](https://github.com/rust-lang/rust-clippy/pull/6764)\n+  [#6708](https://github.com/rust-lang/rust-clippy/pull/6708)\n+  [#6780](https://github.com/rust-lang/rust-clippy/pull/6780)\n+  [#6686](https://github.com/rust-lang/rust-clippy/pull/6686)\n \n ## Rust 1.51\n \n-Current beta, release 2021-03-25\n+Current stable, released 2021-03-25\n \n [4911ab1...3e41797](https://github.com/rust-lang/rust-clippy/compare/4911ab1...3e41797)\n \n@@ -125,7 +260,7 @@ Current beta, release 2021-03-25\n \n ## Rust 1.50\n \n-Current stable, released 2021-02-11\n+Released 2021-02-11\n \n [b20d4c1...4bd77a1](https://github.com/rust-lang/rust-clippy/compare/b20d4c1...4bd77a1)\n \n@@ -1970,6 +2105,7 @@ Released 2018-09-13\n [configuration file]: ./rust-clippy#configuration\n [pull3665]: https://github.com/rust-lang/rust-clippy/pull/3665\n [adding_lints]: https://github.com/rust-lang/rust-clippy/blob/master/doc/adding_lints.md\n+[`README.md`]: https://github.com/rust-lang/rust-clippy/blob/master/README.md\n \n <!-- lint disable no-unused-definitions -->\n <!-- begin autogenerated links to lint list -->\n@@ -1993,6 +2129,7 @@ Released 2018-09-13\n [`borrowed_box`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrowed_box\n [`box_vec`]: https://rust-lang.github.io/rust-clippy/master/index.html#box_vec\n [`boxed_local`]: https://rust-lang.github.io/rust-clippy/master/index.html#boxed_local\n+[`branches_sharing_code`]: https://rust-lang.github.io/rust-clippy/master/index.html#branches_sharing_code\n [`builtin_type_shadow`]: https://rust-lang.github.io/rust-clippy/master/index.html#builtin_type_shadow\n [`bytes_nth`]: https://rust-lang.github.io/rust-clippy/master/index.html#bytes_nth\n [`cargo_common_metadata`]: https://rust-lang.github.io/rust-clippy/master/index.html#cargo_common_metadata\n@@ -2233,6 +2370,7 @@ Released 2018-09-13\n [`needless_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_collect\n [`needless_continue`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_continue\n [`needless_doctest_main`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_doctest_main\n+[`needless_for_each`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_for_each\n [`needless_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_lifetimes\n [`needless_pass_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_pass_by_value\n [`needless_question_mark`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_question_mark\n@@ -2246,13 +2384,15 @@ Released 2018-09-13\n [`new_without_default`]: https://rust-lang.github.io/rust-clippy/master/index.html#new_without_default\n [`no_effect`]: https://rust-lang.github.io/rust-clippy/master/index.html#no_effect\n [`non_ascii_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#non_ascii_literal\n+[`non_octal_unix_permissions`]: https://rust-lang.github.io/rust-clippy/master/index.html#non_octal_unix_permissions\n [`nonminimal_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#nonminimal_bool\n [`nonsensical_open_options`]: https://rust-lang.github.io/rust-clippy/master/index.html#nonsensical_open_options\n [`not_unsafe_ptr_arg_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#not_unsafe_ptr_arg_deref\n [`ok_expect`]: https://rust-lang.github.io/rust-clippy/master/index.html#ok_expect\n [`op_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#op_ref\n [`option_as_ref_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_as_ref_deref\n [`option_env_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_env_unwrap\n+[`option_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_filter_map\n [`option_if_let_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_if_let_else\n [`option_map_or_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_or_none\n [`option_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unit_fn"}, {"sha": "8c0c16c443dfcd4153f43318e9a2568214fb99e6", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -5,7 +5,7 @@\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are over 400 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are over 450 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n Lints are divided into categories, each with a default [lint level](https://doc.rust-lang.org/rustc/lints/levels.html).\n You can choose how much Clippy is supposed to ~~annoy~~ help you by changing the lint level by category."}, {"sha": "1517cdc9419626600ad03b60cbc28e1ef1cc7d42", "filename": "clippy_dev/src/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_dev%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_dev%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Ffmt.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -68,7 +68,7 @@ pub fn run(check: bool, verbose: bool) {\n                 continue;\n             }\n \n-            success &= rustfmt(context, &path)?;\n+            success &= rustfmt(context, path)?;\n         }\n \n         Ok(success)"}, {"sha": "1e5a140e9648f6fd39b73ee0ea37954f326cb2aa", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -101,7 +101,7 @@ impl Lint {\n #[must_use]\n pub fn gen_lint_group_list<'a>(lints: impl Iterator<Item = &'a Lint>) -> Vec<String> {\n     lints\n-        .map(|l| format!(\"        LintId::of(&{}::{}),\", l.module, l.name.to_uppercase()))\n+        .map(|l| format!(\"        LintId::of({}::{}),\", l.module, l.name.to_uppercase()))\n         .sorted()\n         .collect::<Vec<String>>()\n }\n@@ -154,17 +154,17 @@ pub fn gen_register_lint_list<'a>(\n     let header = \"    store.register_lints(&[\".to_string();\n     let footer = \"    ]);\".to_string();\n     let internal_lints = internal_lints\n-        .sorted_by_key(|l| format!(\"        &{}::{},\", l.module, l.name.to_uppercase()))\n+        .sorted_by_key(|l| format!(\"        {}::{},\", l.module, l.name.to_uppercase()))\n         .map(|l| {\n             format!(\n-                \"        #[cfg(feature = \\\"internal-lints\\\")]\\n        &{}::{},\",\n+                \"        #[cfg(feature = \\\"internal-lints\\\")]\\n        {}::{},\",\n                 l.module,\n                 l.name.to_uppercase()\n             )\n         });\n     let other_lints = usable_lints\n-        .sorted_by_key(|l| format!(\"        &{}::{},\", l.module, l.name.to_uppercase()))\n-        .map(|l| format!(\"        &{}::{},\", l.module, l.name.to_uppercase()))\n+        .sorted_by_key(|l| format!(\"        {}::{},\", l.module, l.name.to_uppercase()))\n+        .map(|l| format!(\"        {}::{},\", l.module, l.name.to_uppercase()))\n         .sorted();\n     let mut lint_list = vec![header];\n     lint_list.extend(internal_lints);\n@@ -550,9 +550,9 @@ fn test_gen_lint_group_list() {\n         Lint::new(\"internal\", \"internal_style\", \"abc\", None, \"module_name\"),\n     ];\n     let expected = vec![\n-        \"        LintId::of(&module_name::ABC),\".to_string(),\n-        \"        LintId::of(&module_name::INTERNAL),\".to_string(),\n-        \"        LintId::of(&module_name::SHOULD_ASSERT_EQ),\".to_string(),\n+        \"        LintId::of(module_name::ABC),\".to_string(),\n+        \"        LintId::of(module_name::INTERNAL),\".to_string(),\n+        \"        LintId::of(module_name::SHOULD_ASSERT_EQ),\".to_string(),\n     ];\n     assert_eq!(expected, gen_lint_group_list(lints.iter()));\n }"}, {"sha": "5fbf4bdbd187b642db39ba3852b0b82e28ec79ae", "filename": "clippy_lints/src/absurd_extreme_comparisons.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fabsurd_extreme_comparisons.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,173 @@\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::consts::{constant, Constant};\n+\n+use clippy_utils::comparisons::{normalize_comparison, Rel};\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::is_isize_or_usize;\n+use clippy_utils::{clip, int_bits, unsext};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for comparisons where one side of the relation is\n+    /// either the minimum or maximum value for its type and warns if it involves a\n+    /// case that is always true or always false. Only integer and boolean types are\n+    /// checked.\n+    ///\n+    /// **Why is this bad?** An expression like `min <= x` may misleadingly imply\n+    /// that it is possible for `x` to be less than the minimum. Expressions like\n+    /// `max < x` are probably mistakes.\n+    ///\n+    /// **Known problems:** For `usize` the size of the current compile target will\n+    /// be assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\n+    /// a comparison to detect target pointer width will trigger this lint. One can\n+    /// use `mem::sizeof` and compare its value or conditional compilation\n+    /// attributes\n+    /// like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let vec: Vec<isize> = Vec::new();\n+    /// if vec.len() <= 0 {}\n+    /// if 100 > i32::MAX {}\n+    /// ```\n+    pub ABSURD_EXTREME_COMPARISONS,\n+    correctness,\n+    \"a comparison with a maximum or minimum value that is always true or false\"\n+}\n+\n+declare_lint_pass!(AbsurdExtremeComparisons => [ABSURD_EXTREME_COMPARISONS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for AbsurdExtremeComparisons {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Binary(ref cmp, lhs, rhs) = expr.kind {\n+            if let Some((culprit, result)) = detect_absurd_comparison(cx, cmp.node, lhs, rhs) {\n+                if !expr.span.from_expansion() {\n+                    let msg = \"this comparison involving the minimum or maximum element for this \\\n+                               type contains a case that is always true or always false\";\n+\n+                    let conclusion = match result {\n+                        AbsurdComparisonResult::AlwaysFalse => \"this comparison is always false\".to_owned(),\n+                        AbsurdComparisonResult::AlwaysTrue => \"this comparison is always true\".to_owned(),\n+                        AbsurdComparisonResult::InequalityImpossible => format!(\n+                            \"the case where the two sides are not equal never occurs, consider using `{} == {}` \\\n+                             instead\",\n+                            snippet(cx, lhs.span, \"lhs\"),\n+                            snippet(cx, rhs.span, \"rhs\")\n+                        ),\n+                    };\n+\n+                    let help = format!(\n+                        \"because `{}` is the {} value for this type, {}\",\n+                        snippet(cx, culprit.expr.span, \"x\"),\n+                        match culprit.which {\n+                            ExtremeType::Minimum => \"minimum\",\n+                            ExtremeType::Maximum => \"maximum\",\n+                        },\n+                        conclusion\n+                    );\n+\n+                    span_lint_and_help(cx, ABSURD_EXTREME_COMPARISONS, expr.span, msg, None, &help);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+enum ExtremeType {\n+    Minimum,\n+    Maximum,\n+}\n+\n+struct ExtremeExpr<'a> {\n+    which: ExtremeType,\n+    expr: &'a Expr<'a>,\n+}\n+\n+enum AbsurdComparisonResult {\n+    AlwaysFalse,\n+    AlwaysTrue,\n+    InequalityImpossible,\n+}\n+\n+fn is_cast_between_fixed_and_target<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    if let ExprKind::Cast(cast_exp, _) = expr.kind {\n+        let precast_ty = cx.typeck_results().expr_ty(cast_exp);\n+        let cast_ty = cx.typeck_results().expr_ty(expr);\n+\n+        return is_isize_or_usize(precast_ty) != is_isize_or_usize(cast_ty);\n+    }\n+\n+    false\n+}\n+\n+fn detect_absurd_comparison<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    op: BinOpKind,\n+    lhs: &'tcx Expr<'_>,\n+    rhs: &'tcx Expr<'_>,\n+) -> Option<(ExtremeExpr<'tcx>, AbsurdComparisonResult)> {\n+    use AbsurdComparisonResult::{AlwaysFalse, AlwaysTrue, InequalityImpossible};\n+    use ExtremeType::{Maximum, Minimum};\n+    // absurd comparison only makes sense on primitive types\n+    // primitive types don't implement comparison operators with each other\n+    if cx.typeck_results().expr_ty(lhs) != cx.typeck_results().expr_ty(rhs) {\n+        return None;\n+    }\n+\n+    // comparisons between fix sized types and target sized types are considered unanalyzable\n+    if is_cast_between_fixed_and_target(cx, lhs) || is_cast_between_fixed_and_target(cx, rhs) {\n+        return None;\n+    }\n+\n+    let (rel, normalized_lhs, normalized_rhs) = normalize_comparison(op, lhs, rhs)?;\n+\n+    let lx = detect_extreme_expr(cx, normalized_lhs);\n+    let rx = detect_extreme_expr(cx, normalized_rhs);\n+\n+    Some(match rel {\n+        Rel::Lt => {\n+            match (lx, rx) {\n+                (Some(l @ ExtremeExpr { which: Maximum, .. }), _) => (l, AlwaysFalse), // max < x\n+                (_, Some(r @ ExtremeExpr { which: Minimum, .. })) => (r, AlwaysFalse), // x < min\n+                _ => return None,\n+            }\n+        },\n+        Rel::Le => {\n+            match (lx, rx) {\n+                (Some(l @ ExtremeExpr { which: Minimum, .. }), _) => (l, AlwaysTrue), // min <= x\n+                (Some(l @ ExtremeExpr { which: Maximum, .. }), _) => (l, InequalityImpossible), // max <= x\n+                (_, Some(r @ ExtremeExpr { which: Minimum, .. })) => (r, InequalityImpossible), // x <= min\n+                (_, Some(r @ ExtremeExpr { which: Maximum, .. })) => (r, AlwaysTrue), // x <= max\n+                _ => return None,\n+            }\n+        },\n+        Rel::Ne | Rel::Eq => return None,\n+    })\n+}\n+\n+fn detect_extreme_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<ExtremeExpr<'tcx>> {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+\n+    let cv = constant(cx, cx.typeck_results(), expr)?.0;\n+\n+    let which = match (ty.kind(), cv) {\n+        (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => ExtremeType::Minimum,\n+        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::MIN >> (128 - int_bits(cx.tcx, ity)), ity) => {\n+            ExtremeType::Minimum\n+        },\n+\n+        (&ty::Bool, Constant::Bool(true)) => ExtremeType::Maximum,\n+        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::MAX >> (128 - int_bits(cx.tcx, ity)), ity) => {\n+            ExtremeType::Maximum\n+        },\n+        (&ty::Uint(uty), Constant::Int(i)) if clip(cx.tcx, u128::MAX, uty) == i => ExtremeType::Maximum,\n+\n+        _ => return None,\n+    };\n+    Some(ExtremeExpr { which, expr })\n+}"}, {"sha": "a0993bb6913e7c62a3ac67be103e223d88b2ea76", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> LateLintPass<'tcx> for AssertionsOnConstants {\n                 return;\n             }\n             if_chain! {\n-                if let ExprKind::Unary(_, ref lit) = e.kind;\n+                if let ExprKind::Unary(_, lit) = e.kind;\n                 if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), lit);\n                 if is_true;\n                 then {\n@@ -82,7 +82,7 @@ impl<'tcx> LateLintPass<'tcx> for AssertionsOnConstants {\n             if assert_span.from_expansion() {\n                 return;\n             }\n-            if let Some(assert_match) = match_assert_with_message(&cx, e) {\n+            if let Some(assert_match) = match_assert_with_message(cx, e) {\n                 match assert_match {\n                     // matched assert but not message\n                     AssertKind::WithoutMessage(false) => lint_false_without_message(),\n@@ -113,17 +113,17 @@ enum AssertKind {\n /// where `message` is any expression and `c` is a constant bool.\n fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<AssertKind> {\n     if_chain! {\n-        if let ExprKind::If(ref cond, ref then, _) = expr.kind;\n-        if let ExprKind::Unary(UnOp::Not, ref expr) = cond.kind;\n+        if let ExprKind::If(cond, then, _) = expr.kind;\n+        if let ExprKind::Unary(UnOp::Not, expr) = cond.kind;\n         // bind the first argument of the `assert!` macro\n         if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), expr);\n         // block\n-        if let ExprKind::Block(ref block, _) = then.kind;\n+        if let ExprKind::Block(block, _) = then.kind;\n         if block.stmts.is_empty();\n         if let Some(block_expr) = &block.expr;\n         // inner block is optional. unwrap it if it exists, or use the expression as is otherwise.\n         if let Some(begin_panic_call) = match block_expr.kind {\n-            ExprKind::Block(ref inner_block, _) => &inner_block.expr,\n+            ExprKind::Block(inner_block, _) => &inner_block.expr,\n             _ => &block.expr,\n         };\n         // function call"}, {"sha": "7ceb01f5590fcf2e38fa9b7ba17455eaa1a5e611", "filename": "clippy_lints/src/atomic_ordering.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fatomic_ordering.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -85,7 +85,7 @@ fn match_ordering_def_path(cx: &LateContext<'_>, did: DefId, orderings: &[&str])\n \n fn check_atomic_load_store(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method_path, _, args, _) = &expr.kind;\n+        if let ExprKind::MethodCall(method_path, _, args, _) = &expr.kind;\n         let method = method_path.ident.name.as_str();\n         if type_is_atomic(cx, &args[0]);\n         if method == \"load\" || method == \"store\";\n@@ -120,7 +120,7 @@ fn check_atomic_load_store(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n fn check_memory_fence(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::Call(ref func, ref args) = expr.kind;\n+        if let ExprKind::Call(func, args) = expr.kind;\n         if let ExprKind::Path(ref func_qpath) = func.kind;\n         if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n         if [\"fence\", \"compiler_fence\"]\n@@ -152,7 +152,7 @@ fn opt_ordering_defid(cx: &LateContext<'_>, ord_arg: &Expr<'_>) -> Option<DefId>\n \n fn check_atomic_compare_exchange(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method_path, _, args, _) = &expr.kind;\n+        if let ExprKind::MethodCall(method_path, _, args, _) = &expr.kind;\n         let method = method_path.ident.name.as_str();\n         if type_is_atomic(cx, &args[0]);\n         if method == \"compare_exchange\" || method == \"compare_exchange_weak\" || method == \"fetch_update\";"}, {"sha": "c5b01461c1c00b077a97a914f262e4f9e49190b0", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 56, "deletions": 62, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -250,12 +250,8 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n     fn check_attribute(&mut self, cx: &LateContext<'tcx>, attr: &'tcx Attribute) {\n         if let Some(items) = &attr.meta_item_list() {\n             if let Some(ident) = attr.ident() {\n-                let ident = &*ident.as_str();\n-                match ident {\n-                    \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n-                        check_clippy_lint_names(cx, ident, items);\n-                    },\n-                    _ => {},\n+                if is_lint_level(ident.name) {\n+                    check_clippy_lint_names(cx, ident.name, items);\n                 }\n                 if items.is_empty() || !attr.has_name(sym::deprecated) {\n                     return;\n@@ -288,60 +284,54 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n                         return;\n                     }\n                     if let Some(lint_list) = &attr.meta_item_list() {\n-                        if let Some(ident) = attr.ident() {\n-                            match &*ident.as_str() {\n-                                \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n-                                    // permit `unused_imports`, `deprecated`, `unreachable_pub`,\n-                                    // `clippy::wildcard_imports`, and `clippy::enum_glob_use` for `use` items\n-                                    // and `unused_imports` for `extern crate` items with `macro_use`\n-                                    for lint in lint_list {\n-                                        match item.kind {\n-                                            ItemKind::Use(..) => {\n-                                                if is_word(lint, sym!(unused_imports))\n-                                                    || is_word(lint, sym::deprecated)\n-                                                    || is_word(lint, sym!(unreachable_pub))\n-                                                    || is_word(lint, sym!(unused))\n-                                                    || extract_clippy_lint(lint)\n-                                                        .map_or(false, |s| s == \"wildcard_imports\")\n-                                                    || extract_clippy_lint(lint).map_or(false, |s| s == \"enum_glob_use\")\n-                                                {\n-                                                    return;\n-                                                }\n-                                            },\n-                                            ItemKind::ExternCrate(..) => {\n-                                                if is_word(lint, sym!(unused_imports)) && skip_unused_imports {\n-                                                    return;\n-                                                }\n-                                                if is_word(lint, sym!(unused_extern_crates)) {\n-                                                    return;\n-                                                }\n-                                            },\n-                                            _ => {},\n+                        if attr.ident().map_or(false, |ident| is_lint_level(ident.name)) {\n+                            // permit `unused_imports`, `deprecated`, `unreachable_pub`,\n+                            // `clippy::wildcard_imports`, and `clippy::enum_glob_use` for `use` items\n+                            // and `unused_imports` for `extern crate` items with `macro_use`\n+                            for lint in lint_list {\n+                                match item.kind {\n+                                    ItemKind::Use(..) => {\n+                                        if is_word(lint, sym!(unused_imports))\n+                                            || is_word(lint, sym::deprecated)\n+                                            || is_word(lint, sym!(unreachable_pub))\n+                                            || is_word(lint, sym!(unused))\n+                                            || extract_clippy_lint(lint).map_or(false, |s| s == \"wildcard_imports\")\n+                                            || extract_clippy_lint(lint).map_or(false, |s| s == \"enum_glob_use\")\n+                                        {\n+                                            return;\n+                                        }\n+                                    },\n+                                    ItemKind::ExternCrate(..) => {\n+                                        if is_word(lint, sym!(unused_imports)) && skip_unused_imports {\n+                                            return;\n                                         }\n-                                    }\n-                                    let line_span = first_line_of_span(cx, attr.span);\n-\n-                                    if let Some(mut sugg) = snippet_opt(cx, line_span) {\n-                                        if sugg.contains(\"#[\") {\n-                                            span_lint_and_then(\n-                                                cx,\n-                                                USELESS_ATTRIBUTE,\n+                                        if is_word(lint, sym!(unused_extern_crates)) {\n+                                            return;\n+                                        }\n+                                    },\n+                                    _ => {},\n+                                }\n+                            }\n+                            let line_span = first_line_of_span(cx, attr.span);\n+\n+                            if let Some(mut sugg) = snippet_opt(cx, line_span) {\n+                                if sugg.contains(\"#[\") {\n+                                    span_lint_and_then(\n+                                        cx,\n+                                        USELESS_ATTRIBUTE,\n+                                        line_span,\n+                                        \"useless lint attribute\",\n+                                        |diag| {\n+                                            sugg = sugg.replacen(\"#[\", \"#![\", 1);\n+                                            diag.span_suggestion(\n                                                 line_span,\n-                                                \"useless lint attribute\",\n-                                                |diag| {\n-                                                    sugg = sugg.replacen(\"#[\", \"#![\", 1);\n-                                                    diag.span_suggestion(\n-                                                        line_span,\n-                                                        \"if you just forgot a `!`, use\",\n-                                                        sugg,\n-                                                        Applicability::MaybeIncorrect,\n-                                                    );\n-                                                },\n+                                                \"if you just forgot a `!`, use\",\n+                                                sugg,\n+                                                Applicability::MaybeIncorrect,\n                                             );\n-                                        }\n-                                    }\n-                                },\n-                                _ => {},\n+                                        },\n+                                    );\n+                                }\n                             }\n                         }\n                     }\n@@ -371,18 +361,18 @@ fn extract_clippy_lint(lint: &NestedMetaItem) -> Option<SymbolStr> {\n         if meta_item.path.segments.len() > 1;\n         if let tool_name = meta_item.path.segments[0].ident;\n         if tool_name.name == sym::clippy;\n-        let lint_name = meta_item.path.segments.last().unwrap().ident.name;\n         then {\n+            let lint_name = meta_item.path.segments.last().unwrap().ident.name;\n             return Some(lint_name.as_str());\n         }\n     }\n     None\n }\n \n-fn check_clippy_lint_names(cx: &LateContext<'_>, ident: &str, items: &[NestedMetaItem]) {\n+fn check_clippy_lint_names(cx: &LateContext<'_>, name: Symbol, items: &[NestedMetaItem]) {\n     for lint in items {\n         if let Some(lint_name) = extract_clippy_lint(lint) {\n-            if lint_name == \"restriction\" && ident != \"allow\" {\n+            if lint_name == \"restriction\" && name != sym::allow {\n                 span_lint_and_help(\n                     cx,\n                     BLANKET_CLIPPY_RESTRICTION_LINTS,\n@@ -602,7 +592,7 @@ fn check_mismatched_target_os(cx: &EarlyContext<'_>, attr: &Attribute) {\n             if let NestedMetaItem::MetaItem(meta) = item {\n                 match &meta.kind {\n                     MetaItemKind::List(list) => {\n-                        mismatched.extend(find_mismatched_target_os(&list));\n+                        mismatched.extend(find_mismatched_target_os(list));\n                     },\n                     MetaItemKind::Word => {\n                         if_chain! {\n@@ -629,7 +619,7 @@ fn check_mismatched_target_os(cx: &EarlyContext<'_>, attr: &Attribute) {\n         then {\n             let mess = \"operating system used in target family position\";\n \n-            span_lint_and_then(cx, MISMATCHED_TARGET_OS, attr.span, &mess, |diag| {\n+            span_lint_and_then(cx, MISMATCHED_TARGET_OS, attr.span, mess, |diag| {\n                 // Avoid showing the unix suggestion multiple times in case\n                 // we have more than one mismatch for unix-like systems\n                 let mut unix_suggested = false;\n@@ -647,3 +637,7 @@ fn check_mismatched_target_os(cx: &EarlyContext<'_>, attr: &Attribute) {\n         }\n     }\n }\n+\n+fn is_lint_level(symbol: Symbol) -> bool {\n+    matches!(symbol, sym::allow | sym::warn | sym::deny | sym::forbid)\n+}"}, {"sha": "1739a57a240b2807731ca31c40190fe6d3a49a7c", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -101,7 +101,7 @@ impl LateLintPass<'_> for AwaitHolding {\n             let typeck_results = cx.tcx.typeck_body(body_id);\n             check_interior_types(\n                 cx,\n-                &typeck_results.generator_interior_types.as_ref().skip_binder(),\n+                typeck_results.generator_interior_types.as_ref().skip_binder(),\n                 body.value.span,\n             );\n         }"}, {"sha": "877ae002d36e9de67bb360716112cf266929ae4d", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 43, "deletions": 47, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -38,59 +38,55 @@ declare_lint_pass!(ByteCount => [NAIVE_BYTECOUNT]);\n impl<'tcx> LateLintPass<'tcx> for ByteCount {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref count, _, ref count_args, _) = expr.kind;\n+            if let ExprKind::MethodCall(count, _, count_args, _) = expr.kind;\n             if count.ident.name == sym!(count);\n             if count_args.len() == 1;\n-            if let ExprKind::MethodCall(ref filter, _, ref filter_args, _) = count_args[0].kind;\n+            if let ExprKind::MethodCall(filter, _, filter_args, _) = count_args[0].kind;\n             if filter.ident.name == sym!(filter);\n             if filter_args.len() == 2;\n             if let ExprKind::Closure(_, _, body_id, _, _) = filter_args[1].kind;\n+            let body = cx.tcx.hir().body(body_id);\n+            if body.params.len() == 1;\n+            if let Some(argname) = get_pat_name(body.params[0].pat);\n+            if let ExprKind::Binary(ref op, l, r) = body.value.kind;\n+            if op.node == BinOpKind::Eq;\n+            if match_type(cx,\n+                       cx.typeck_results().expr_ty(&filter_args[0]).peel_refs(),\n+                       &paths::SLICE_ITER);\n             then {\n-                let body = cx.tcx.hir().body(body_id);\n-                if_chain! {\n-                    if body.params.len() == 1;\n-                    if let Some(argname) = get_pat_name(&body.params[0].pat);\n-                    if let ExprKind::Binary(ref op, ref l, ref r) = body.value.kind;\n-                    if op.node == BinOpKind::Eq;\n-                    if match_type(cx,\n-                               cx.typeck_results().expr_ty(&filter_args[0]).peel_refs(),\n-                               &paths::SLICE_ITER);\n-                    then {\n-                        let needle = match get_path_name(l) {\n-                            Some(name) if check_arg(name, argname, r) => r,\n-                            _ => match get_path_name(r) {\n-                                Some(name) if check_arg(name, argname, l) => l,\n-                                _ => { return; }\n-                            }\n-                        };\n-                        if ty::Uint(UintTy::U8) != *cx.typeck_results().expr_ty(needle).peel_refs().kind() {\n-                            return;\n-                        }\n-                        let haystack = if let ExprKind::MethodCall(ref path, _, ref args, _) =\n-                                filter_args[0].kind {\n-                            let p = path.ident.name;\n-                            if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n-                                &args[0]\n-                            } else {\n-                                &filter_args[0]\n-                            }\n-                        } else {\n-                            &filter_args[0]\n-                        };\n-                        let mut applicability = Applicability::MaybeIncorrect;\n-                        span_lint_and_sugg(\n-                            cx,\n-                            NAIVE_BYTECOUNT,\n-                            expr.span,\n-                            \"you appear to be counting bytes the naive way\",\n-                            \"consider using the bytecount crate\",\n-                            format!(\"bytecount::count({}, {})\",\n-                                    snippet_with_applicability(cx, haystack.span, \"..\", &mut applicability),\n-                                    snippet_with_applicability(cx, needle.span, \"..\", &mut applicability)),\n-                            applicability,\n-                        );\n+                let needle = match get_path_name(l) {\n+                    Some(name) if check_arg(name, argname, r) => r,\n+                    _ => match get_path_name(r) {\n+                        Some(name) if check_arg(name, argname, l) => l,\n+                        _ => { return; }\n                     }\n                 };\n+                if ty::Uint(UintTy::U8) != *cx.typeck_results().expr_ty(needle).peel_refs().kind() {\n+                    return;\n+                }\n+                let haystack = if let ExprKind::MethodCall(path, _, args, _) =\n+                        filter_args[0].kind {\n+                    let p = path.ident.name;\n+                    if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n+                        &args[0]\n+                    } else {\n+                        &filter_args[0]\n+                    }\n+                } else {\n+                    &filter_args[0]\n+                };\n+                let mut applicability = Applicability::MaybeIncorrect;\n+                span_lint_and_sugg(\n+                    cx,\n+                    NAIVE_BYTECOUNT,\n+                    expr.span,\n+                    \"you appear to be counting bytes the naive way\",\n+                    \"consider using the bytecount crate\",\n+                    format!(\"bytecount::count({}, {})\",\n+                            snippet_with_applicability(cx, haystack.span, \"..\", &mut applicability),\n+                            snippet_with_applicability(cx, needle.span, \"..\", &mut applicability)),\n+                    applicability,\n+                );\n             }\n         };\n     }\n@@ -102,10 +98,10 @@ fn check_arg(name: Symbol, arg: Symbol, needle: &Expr<'_>) -> bool {\n \n fn get_path_name(expr: &Expr<'_>) -> Option<Symbol> {\n     match expr.kind {\n-        ExprKind::Box(ref e) | ExprKind::AddrOf(BorrowKind::Ref, _, ref e) | ExprKind::Unary(UnOp::Deref, ref e) => {\n+        ExprKind::Box(e) | ExprKind::AddrOf(BorrowKind::Ref, _, e) | ExprKind::Unary(UnOp::Deref, e) => {\n             get_path_name(e)\n         },\n-        ExprKind::Block(ref b, _) => {\n+        ExprKind::Block(b, _) => {\n             if b.stmts.is_empty() {\n                 b.expr.as_ref().and_then(|p| get_path_name(p))\n             } else {"}, {"sha": "8097a1c832613b7c4a1a5b23a953bf8c55315318", "filename": "clippy_lints/src/cargo_common_metadata.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcargo_common_metadata.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -20,26 +20,24 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```toml\n-    /// # This `Cargo.toml` is missing an authors field:\n+    /// # This `Cargo.toml` is missing a description field:\n     /// [package]\n     /// name = \"clippy\"\n     /// version = \"0.0.212\"\n-    /// description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n     /// repository = \"https://github.com/rust-lang/rust-clippy\"\n     /// readme = \"README.md\"\n     /// license = \"MIT OR Apache-2.0\"\n     /// keywords = [\"clippy\", \"lint\", \"plugin\"]\n     /// categories = [\"development-tools\", \"development-tools::cargo-plugins\"]\n     /// ```\n     ///\n-    /// Should include an authors field like:\n+    /// Should include a description field like:\n     ///\n     /// ```toml\n     /// # This `Cargo.toml` includes all common metadata\n     /// [package]\n     /// name = \"clippy\"\n     /// version = \"0.0.212\"\n-    /// authors = [\"Someone <someone@rust-lang.org>\"]\n     /// description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n     /// repository = \"https://github.com/rust-lang/rust-clippy\"\n     /// readme = \"README.md\"\n@@ -97,10 +95,6 @@ impl LateLintPass<'_> for CargoCommonMetadata {\n             // only run the lint if publish is `None` (`publish = true` or skipped entirely)\n             // or if the vector isn't empty (`publish = [\"something\"]`)\n             if package.publish.as_ref().filter(|publish| publish.is_empty()).is_none() || self.ignore_publish {\n-                if is_empty_vec(&package.authors) {\n-                    missing_warning(cx, &package, \"package.authors\");\n-                }\n-\n                 if is_empty_str(&package.description) {\n                     missing_warning(cx, &package, \"package.description\");\n                 }"}, {"sha": "62a119d662bb251f1cb3a0af16dff3b8817bc41a", "filename": "clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -10,7 +10,7 @@ use rustc_target::abi::LayoutOf;\n use super::CAST_PTR_ALIGNMENT;\n \n pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let ExprKind::Cast(ref cast_expr, cast_to) = expr.kind {\n+    if let ExprKind::Cast(cast_expr, cast_to) = expr.kind {\n         if is_hir_ty_cfg_dependant(cx, cast_to) {\n             return;\n         }"}, {"sha": "040e0ca886458d3f63265acdc953822bc1409a9c", "filename": "clippy_lints/src/casts/cast_sign_loss.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -30,7 +30,7 @@ fn should_lint(cx: &LateContext<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast\n             }\n \n             // Don't lint for positive constants.\n-            let const_val = constant(cx, &cx.typeck_results(), cast_op);\n+            let const_val = constant(cx, cx.typeck_results(), cast_op);\n             if_chain! {\n                 if let Some((Constant::Int(n), _)) = const_val;\n                 if let ty::Int(ity) = *cast_from.kind();\n@@ -41,14 +41,14 @@ fn should_lint(cx: &LateContext<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast\n             }\n \n             // Don't lint for the result of methods that always return non-negative values.\n-            if let ExprKind::MethodCall(ref path, _, _, _) = cast_op.kind {\n+            if let ExprKind::MethodCall(path, _, _, _) = cast_op.kind {\n                 let mut method_name = path.ident.name.as_str();\n                 let allowed_methods = [\"abs\", \"checked_abs\", \"rem_euclid\", \"checked_rem_euclid\"];\n \n                 if_chain! {\n                     if method_name == \"unwrap\";\n                     if let Some(arglist) = method_chain_args(cast_op, &[\"unwrap\"]);\n-                    if let ExprKind::MethodCall(ref inner_path, _, _, _) = &arglist[0][0].kind;\n+                    if let ExprKind::MethodCall(inner_path, _, _, _) = &arglist[0][0].kind;\n                     then {\n                         method_name = inner_path.ident.name.as_str();\n                     }"}, {"sha": "ae4fdd12c41e8361f0999613c6bd5cd30671774b", "filename": "clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -372,7 +372,7 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n             return;\n         }\n \n-        if let ExprKind::Cast(ref cast_expr, cast_to) = expr.kind {\n+        if let ExprKind::Cast(cast_expr, cast_to) = expr.kind {\n             if is_hir_ty_cfg_dependant(cx, cast_to) {\n                 return;\n             }"}, {"sha": "d7136f84cc3af3d4d9471cb367c086e4cf994872", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for CheckedConversions {\n \n         let result = if_chain! {\n             if !in_external_macro(cx.sess(), item.span);\n-            if let ExprKind::Binary(op, ref left, ref right) = &item.kind;\n+            if let ExprKind::Binary(op, left, right) = &item.kind;\n \n             then {\n                 match op.node {\n@@ -200,7 +200,7 @@ impl ConversionType {\n /// Check for `expr <= (to_type::MAX as from_type)`\n fn check_upper_bound<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<Conversion<'tcx>> {\n     if_chain! {\n-         if let ExprKind::Binary(ref op, ref left, ref right) = &expr.kind;\n+         if let ExprKind::Binary(ref op, left, right) = &expr.kind;\n          if let Some((candidate, check)) = normalize_le_ge(op, left, right);\n          if let Some((from, to)) = get_types_from_cast(check, INTS, \"max_value\", \"MAX\");\n \n@@ -219,7 +219,7 @@ fn check_lower_bound<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<Conversion<'tcx>> {\n     }\n \n     // First of we need a binary containing the expression & the cast\n-    if let ExprKind::Binary(ref op, ref left, ref right) = &expr.kind {\n+    if let ExprKind::Binary(ref op, left, right) = &expr.kind {\n         normalize_le_ge(op, right, left).and_then(|(l, r)| check_function(l, r))\n     } else {\n         None\n@@ -260,7 +260,7 @@ fn get_types_from_cast<'a>(\n     // or `to_type::MAX as from_type`\n     let call_from_cast: Option<(&Expr<'_>, &str)> = if_chain! {\n         // to_type::max_value(), from_type\n-        if let ExprKind::Cast(ref limit, ref from_type) = &expr.kind;\n+        if let ExprKind::Cast(limit, from_type) = &expr.kind;\n         if let TyKind::Path(ref from_type_path) = &from_type.kind;\n         if let Some(from_sym) = int_ty_to_sym(from_type_path);\n \n@@ -275,7 +275,7 @@ fn get_types_from_cast<'a>(\n     let limit_from: Option<(&Expr<'_>, &str)> = call_from_cast.or_else(|| {\n         if_chain! {\n             // `from_type::from, to_type::max_value()`\n-            if let ExprKind::Call(ref from_func, ref args) = &expr.kind;\n+            if let ExprKind::Call(from_func, args) = &expr.kind;\n             // `to_type::max_value()`\n             if args.len() == 1;\n             if let limit = &args[0];\n@@ -317,13 +317,12 @@ fn get_types_from_cast<'a>(\n /// Gets the type which implements the called function\n fn get_implementing_type<'a>(path: &QPath<'_>, candidates: &'a [&str], function: &str) -> Option<&'a str> {\n     if_chain! {\n-        if let QPath::TypeRelative(ref ty, ref path) = &path;\n+        if let QPath::TypeRelative(ty, path) = &path;\n         if path.ident.name.as_str() == function;\n-        if let TyKind::Path(QPath::Resolved(None, ref tp)) = &ty.kind;\n+        if let TyKind::Path(QPath::Resolved(None, tp)) = &ty.kind;\n         if let [int] = &*tp.segments;\n-        let name = &int.ident.name.as_str();\n-\n         then {\n+            let name = &int.ident.name.as_str();\n             candidates.iter().find(|c| name == *c).cloned()\n         } else {\n             None\n@@ -334,11 +333,10 @@ fn get_implementing_type<'a>(path: &QPath<'_>, candidates: &'a [&str], function:\n /// Gets the type as a string, if it is a supported integer\n fn int_ty_to_sym<'tcx>(path: &QPath<'_>) -> Option<&'tcx str> {\n     if_chain! {\n-        if let QPath::Resolved(_, ref path) = *path;\n+        if let QPath::Resolved(_, path) = *path;\n         if let [ty] = &*path.segments;\n-        let name = &ty.ident.name.as_str();\n-\n         then {\n+            let name = &ty.ident.name.as_str();\n             INTS.iter().find(|c| name == *c).cloned()\n         } else {\n             None"}, {"sha": "f62c6a9c3251c9cc54562d5611eba8194d07b8d3", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -152,7 +152,7 @@ impl<'tcx> Visitor<'tcx> for CcHelper {\n             ExprKind::If(_, _, _) => {\n                 self.cc += 1;\n             },\n-            ExprKind::Match(_, ref arms, _) => {\n+            ExprKind::Match(_, arms, _) => {\n                 if arms.len() > 1 {\n                     self.cc += 1;\n                 }"}, {"sha": "04fff237bb4cbe4fa576aa2c0332284bdabeada2", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -62,8 +62,8 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleMatch {\n }\n \n fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext<'tcx>) {\n+    let expr = strip_singleton_blocks(arm.body);\n     if_chain! {\n-        let expr = strip_singleton_blocks(arm.body);\n         if let ExprKind::Match(expr_in, arms_inner, _) = expr.kind;\n         // the outer arm pattern and the inner match\n         if expr_in.span.ctxt() == arm.pat.span.ctxt();"}, {"sha": "31ae63b51849cb6e9a2b7ba32c48e45d3f530dcb", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -71,10 +71,8 @@ impl<'tcx> LateLintPass<'tcx> for ComparisonChain {\n         }\n \n         for cond in conds.windows(2) {\n-            if let (\n-                &ExprKind::Binary(ref kind1, ref lhs1, ref rhs1),\n-                &ExprKind::Binary(ref kind2, ref lhs2, ref rhs2),\n-            ) = (&cond[0].kind, &cond[1].kind)\n+            if let (&ExprKind::Binary(ref kind1, lhs1, rhs1), &ExprKind::Binary(ref kind2, lhs2, rhs2)) =\n+                (&cond[0].kind, &cond[1].kind)\n             {\n                 if !kind_is_cmp(kind1.node) || !kind_is_cmp(kind2.node) {\n                     return;"}, {"sha": "8b503c9a0306b383c415b3335562036d8423d03e", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 448, "deletions": 40, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,9 +1,19 @@\n-use clippy_utils::diagnostics::span_lint_and_note;\n-use clippy_utils::{eq_expr_value, in_macro, search_same, SpanlessEq, SpanlessHash};\n-use clippy_utils::{get_parent_expr, if_sequence};\n-use rustc_hir::{Block, Expr, ExprKind};\n+use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_then};\n+use clippy_utils::source::{first_line_of_span, indent_of, reindent_multiline, snippet, snippet_opt};\n+use clippy_utils::{\n+    both, count_eq, eq_expr_value, get_enclosing_block, get_parent_expr, if_sequence, in_macro, parent_node_is_if_expr,\n+    run_lints, search_same, ContainsName, SpanlessEq, SpanlessHash,\n+};\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::{Block, Expr, ExprKind, HirId};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{source_map::Span, symbol::Symbol, BytePos};\n+use std::borrow::Cow;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for consecutive `if`s with the same condition.\n@@ -104,47 +114,457 @@ declare_clippy_lint! {\n     \"`if` with the same `then` and `else` blocks\"\n }\n \n-declare_lint_pass!(CopyAndPaste => [IFS_SAME_COND, SAME_FUNCTIONS_IN_IF_CONDITION, IF_SAME_THEN_ELSE]);\n+declare_clippy_lint! {\n+    /// **What it does:** Checks if the `if` and `else` block contain shared code that can be\n+    /// moved out of the blocks.\n+    ///\n+    /// **Why is this bad?** Duplicate code is less maintainable.\n+    ///\n+    /// **Known problems:** Hopefully none.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// let foo = if \u2026 {\n+    ///     println!(\"Hello World\");\n+    ///     13\n+    /// } else {\n+    ///     println!(\"Hello World\");\n+    ///     42\n+    /// };\n+    /// ```\n+    ///\n+    /// Could be written as:\n+    /// ```ignore\n+    /// println!(\"Hello World\");\n+    /// let foo = if \u2026 {\n+    ///     13\n+    /// } else {\n+    ///     42\n+    /// };\n+    /// ```\n+    pub BRANCHES_SHARING_CODE,\n+    complexity,\n+    \"`if` statement with shared code in all blocks\"\n+}\n+\n+declare_lint_pass!(CopyAndPaste => [\n+    IFS_SAME_COND,\n+    SAME_FUNCTIONS_IN_IF_CONDITION,\n+    IF_SAME_THEN_ELSE,\n+    BRANCHES_SHARING_CODE\n+]);\n \n impl<'tcx> LateLintPass<'tcx> for CopyAndPaste {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if !expr.span.from_expansion() {\n-            // skip ifs directly in else, it will be checked in the parent if\n-            if let Some(&Expr {\n-                kind: ExprKind::If(_, _, Some(ref else_expr)),\n-                ..\n-            }) = get_parent_expr(cx, expr)\n-            {\n-                if else_expr.hir_id == expr.hir_id {\n-                    return;\n+            if let ExprKind::If(_, _, _) = expr.kind {\n+                // skip ifs directly in else, it will be checked in the parent if\n+                if let Some(&Expr {\n+                    kind: ExprKind::If(_, _, Some(else_expr)),\n+                    ..\n+                }) = get_parent_expr(cx, expr)\n+                {\n+                    if else_expr.hir_id == expr.hir_id {\n+                        return;\n+                    }\n                 }\n+\n+                let (conds, blocks) = if_sequence(expr);\n+                // Conditions\n+                lint_same_cond(cx, &conds);\n+                lint_same_fns_in_if_cond(cx, &conds);\n+                // Block duplication\n+                lint_same_then_else(cx, &blocks, conds.len() == blocks.len(), expr);\n             }\n+        }\n+    }\n+}\n \n-            let (conds, blocks) = if_sequence(expr);\n-            lint_same_then_else(cx, &blocks);\n-            lint_same_cond(cx, &conds);\n-            lint_same_fns_in_if_cond(cx, &conds);\n+/// Implementation of `BRANCHES_SHARING_CODE` and `IF_SAME_THEN_ELSE` if the blocks are equal.\n+fn lint_same_then_else<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    blocks: &[&Block<'tcx>],\n+    has_conditional_else: bool,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    // We only lint ifs with multiple blocks\n+    if blocks.len() < 2 || parent_node_is_if_expr(expr, cx) {\n+        return;\n+    }\n+\n+    // Check if each block has shared code\n+    let has_expr = blocks[0].expr.is_some();\n+    let (start_eq, mut end_eq, expr_eq) = scan_block_for_eq(cx, blocks);\n+\n+    // BRANCHES_SHARING_CODE prerequisites\n+    if has_conditional_else || (start_eq == 0 && end_eq == 0 && (has_expr && !expr_eq)) {\n+        return;\n+    }\n+\n+    // Only the start is the same\n+    if start_eq != 0 && end_eq == 0 && (!has_expr || !expr_eq) {\n+        let block = blocks[0];\n+        let start_stmts = block.stmts.split_at(start_eq).0;\n+\n+        let mut start_walker = UsedValueFinderVisitor::new(cx);\n+        for stmt in start_stmts {\n+            intravisit::walk_stmt(&mut start_walker, stmt);\n         }\n+\n+        emit_branches_sharing_code_lint(\n+            cx,\n+            start_eq,\n+            0,\n+            false,\n+            check_for_warn_of_moved_symbol(cx, &start_walker.def_symbols, expr),\n+            blocks,\n+            expr,\n+        );\n+    } else if end_eq != 0 || (has_expr && expr_eq) {\n+        let block = blocks[blocks.len() - 1];\n+        let (start_stmts, block_stmts) = block.stmts.split_at(start_eq);\n+        let (block_stmts, end_stmts) = block_stmts.split_at(block_stmts.len() - end_eq);\n+\n+        // Scan start\n+        let mut start_walker = UsedValueFinderVisitor::new(cx);\n+        for stmt in start_stmts {\n+            intravisit::walk_stmt(&mut start_walker, stmt);\n+        }\n+        let mut moved_syms = start_walker.def_symbols;\n+\n+        // Scan block\n+        let mut block_walker = UsedValueFinderVisitor::new(cx);\n+        for stmt in block_stmts {\n+            intravisit::walk_stmt(&mut block_walker, stmt);\n+        }\n+        let mut block_defs = block_walker.defs;\n+\n+        // Scan moved stmts\n+        let mut moved_start: Option<usize> = None;\n+        let mut end_walker = UsedValueFinderVisitor::new(cx);\n+        for (index, stmt) in end_stmts.iter().enumerate() {\n+            intravisit::walk_stmt(&mut end_walker, stmt);\n+\n+            for value in &end_walker.uses {\n+                // Well we can't move this and all prev statements. So reset\n+                if block_defs.contains(value) {\n+                    moved_start = Some(index + 1);\n+                    end_walker.defs.drain().for_each(|x| {\n+                        block_defs.insert(x);\n+                    });\n+\n+                    end_walker.def_symbols.clear();\n+                }\n+            }\n+\n+            end_walker.uses.clear();\n+        }\n+\n+        if let Some(moved_start) = moved_start {\n+            end_eq -= moved_start;\n+        }\n+\n+        let end_linable = block.expr.map_or_else(\n+            || end_eq != 0,\n+            |expr| {\n+                intravisit::walk_expr(&mut end_walker, expr);\n+                end_walker.uses.iter().any(|x| !block_defs.contains(x))\n+            },\n+        );\n+\n+        if end_linable {\n+            end_walker.def_symbols.drain().for_each(|x| {\n+                moved_syms.insert(x);\n+            });\n+        }\n+\n+        emit_branches_sharing_code_lint(\n+            cx,\n+            start_eq,\n+            end_eq,\n+            end_linable,\n+            check_for_warn_of_moved_symbol(cx, &moved_syms, expr),\n+            blocks,\n+            expr,\n+        );\n     }\n }\n \n-/// Implementation of `IF_SAME_THEN_ELSE`.\n-fn lint_same_then_else(cx: &LateContext<'_>, blocks: &[&Block<'_>]) {\n-    let eq: &dyn Fn(&&Block<'_>, &&Block<'_>) -> bool =\n-        &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).eq_block(lhs, rhs) };\n+fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> (usize, usize, bool) {\n+    let mut start_eq = usize::MAX;\n+    let mut end_eq = usize::MAX;\n+    let mut expr_eq = true;\n+    for win in blocks.windows(2) {\n+        let l_stmts = win[0].stmts;\n+        let r_stmts = win[1].stmts;\n \n-    if let Some((i, j)) = search_same_sequenced(blocks, eq) {\n-        span_lint_and_note(\n+        // `SpanlessEq` now keeps track of the locals and is therefore context sensitive clippy#6752.\n+        // The comparison therefore needs to be done in a way that builds the correct context.\n+        let mut evaluator = SpanlessEq::new(cx);\n+        let mut evaluator = evaluator.inter_expr();\n+\n+        let current_start_eq = count_eq(&mut l_stmts.iter(), &mut r_stmts.iter(), |l, r| evaluator.eq_stmt(l, r));\n+\n+        let current_end_eq = {\n+            // We skip the middle statements which can't be equal\n+            let end_comparison_count = l_stmts.len().min(r_stmts.len()) - current_start_eq;\n+            let it1 = l_stmts.iter().skip(l_stmts.len() - end_comparison_count);\n+            let it2 = r_stmts.iter().skip(r_stmts.len() - end_comparison_count);\n+            it1.zip(it2)\n+                .fold(0, |acc, (l, r)| if evaluator.eq_stmt(l, r) { acc + 1 } else { 0 })\n+        };\n+        let block_expr_eq = both(&win[0].expr, &win[1].expr, |l, r| evaluator.eq_expr(l, r));\n+\n+        // IF_SAME_THEN_ELSE\n+        if_chain! {\n+            if block_expr_eq;\n+            if l_stmts.len() == r_stmts.len();\n+            if l_stmts.len() == current_start_eq;\n+            if run_lints(cx, &[IF_SAME_THEN_ELSE], win[0].hir_id);\n+            if run_lints(cx, &[IF_SAME_THEN_ELSE], win[1].hir_id);\n+            then {\n+                span_lint_and_note(\n+                    cx,\n+                    IF_SAME_THEN_ELSE,\n+                    win[0].span,\n+                    \"this `if` has identical blocks\",\n+                    Some(win[1].span),\n+                    \"same as this\",\n+                );\n+\n+                return (0, 0, false);\n+            }\n+        }\n+\n+        start_eq = start_eq.min(current_start_eq);\n+        end_eq = end_eq.min(current_end_eq);\n+        expr_eq &= block_expr_eq;\n+    }\n+\n+    let has_expr = blocks[0].expr.is_some();\n+    if has_expr && !expr_eq {\n+        end_eq = 0;\n+    }\n+\n+    // Check if the regions are overlapping. Set `end_eq` to prevent the overlap\n+    let min_block_size = blocks.iter().map(|x| x.stmts.len()).min().unwrap();\n+    if (start_eq + end_eq) > min_block_size {\n+        end_eq = min_block_size - start_eq;\n+    }\n+\n+    (start_eq, end_eq, expr_eq)\n+}\n+\n+fn check_for_warn_of_moved_symbol(\n+    cx: &LateContext<'tcx>,\n+    symbols: &FxHashSet<Symbol>,\n+    if_expr: &'tcx Expr<'_>,\n+) -> bool {\n+    get_enclosing_block(cx, if_expr.hir_id).map_or(false, |block| {\n+        let ignore_span = block.span.shrink_to_lo().to(if_expr.span);\n+\n+        symbols\n+            .iter()\n+            .filter(|sym| !sym.as_str().starts_with('_'))\n+            .any(move |sym| {\n+                let mut walker = ContainsName {\n+                    name: *sym,\n+                    result: false,\n+                };\n+\n+                // Scan block\n+                block\n+                    .stmts\n+                    .iter()\n+                    .filter(|stmt| !ignore_span.overlaps(stmt.span))\n+                    .for_each(|stmt| intravisit::walk_stmt(&mut walker, stmt));\n+\n+                if let Some(expr) = block.expr {\n+                    intravisit::walk_expr(&mut walker, expr);\n+                }\n+\n+                walker.result\n+            })\n+    })\n+}\n+\n+fn emit_branches_sharing_code_lint(\n+    cx: &LateContext<'tcx>,\n+    start_stmts: usize,\n+    end_stmts: usize,\n+    lint_end: bool,\n+    warn_about_moved_symbol: bool,\n+    blocks: &[&Block<'tcx>],\n+    if_expr: &'tcx Expr<'_>,\n+) {\n+    if start_stmts == 0 && !lint_end {\n+        return;\n+    }\n+\n+    // (help, span, suggestion)\n+    let mut suggestions: Vec<(&str, Span, String)> = vec![];\n+    let mut add_expr_note = false;\n+\n+    // Construct suggestions\n+    if start_stmts > 0 {\n+        let block = blocks[0];\n+        let span_start = first_line_of_span(cx, if_expr.span).shrink_to_lo();\n+        let span_end = block.stmts[start_stmts - 1].span.source_callsite();\n+\n+        let cond_span = first_line_of_span(cx, if_expr.span).until(block.span);\n+        let cond_snippet = reindent_multiline(snippet(cx, cond_span, \"_\"), false, None);\n+        let cond_indent = indent_of(cx, cond_span);\n+        let moved_span = block.stmts[0].span.source_callsite().to(span_end);\n+        let moved_snippet = reindent_multiline(snippet(cx, moved_span, \"_\"), true, None);\n+        let suggestion = moved_snippet.to_string() + \"\\n\" + &cond_snippet + \"{\";\n+        let suggestion = reindent_multiline(Cow::Borrowed(&suggestion), true, cond_indent);\n+\n+        let span = span_start.to(span_end);\n+        suggestions.push((\"start\", span, suggestion.to_string()));\n+    }\n+\n+    if lint_end {\n+        let block = blocks[blocks.len() - 1];\n+        let span_end = block.span.shrink_to_hi();\n+\n+        let moved_start = if end_stmts == 0 && block.expr.is_some() {\n+            block.expr.unwrap().span\n+        } else {\n+            block.stmts[block.stmts.len() - end_stmts].span\n+        }\n+        .source_callsite();\n+        let moved_end = block\n+            .expr\n+            .map_or_else(|| block.stmts[block.stmts.len() - 1].span, |expr| expr.span)\n+            .source_callsite();\n+\n+        let moved_span = moved_start.to(moved_end);\n+        let moved_snipped = reindent_multiline(snippet(cx, moved_span, \"_\"), true, None);\n+        let indent = indent_of(cx, if_expr.span.shrink_to_hi());\n+        let suggestion = \"}\\n\".to_string() + &moved_snipped;\n+        let suggestion = reindent_multiline(Cow::Borrowed(&suggestion), true, indent);\n+\n+        let mut span = moved_start.to(span_end);\n+        // Improve formatting if the inner block has indention (i.e. normal Rust formatting)\n+        let test_span = Span::new(span.lo() - BytePos(4), span.lo(), span.ctxt());\n+        if snippet_opt(cx, test_span)\n+            .map(|snip| snip == \"    \")\n+            .unwrap_or_default()\n+        {\n+            span = span.with_lo(test_span.lo());\n+        }\n+\n+        suggestions.push((\"end\", span, suggestion.to_string()));\n+        add_expr_note = !cx.typeck_results().expr_ty(if_expr).is_unit()\n+    }\n+\n+    let add_optional_msgs = |diag: &mut DiagnosticBuilder<'_>| {\n+        if add_expr_note {\n+            diag.note(\"The end suggestion probably needs some adjustments to use the expression result correctly\");\n+        }\n+\n+        if warn_about_moved_symbol {\n+            diag.warn(\"Some moved values might need to be renamed to avoid wrong references\");\n+        }\n+    };\n+\n+    // Emit lint\n+    if suggestions.len() == 1 {\n+        let (place_str, span, sugg) = suggestions.pop().unwrap();\n+        let msg = format!(\"all if blocks contain the same code at the {}\", place_str);\n+        let help = format!(\"consider moving the {} statements out like this\", place_str);\n+        span_lint_and_then(cx, BRANCHES_SHARING_CODE, span, msg.as_str(), |diag| {\n+            diag.span_suggestion(span, help.as_str(), sugg, Applicability::Unspecified);\n+\n+            add_optional_msgs(diag);\n+        });\n+    } else if suggestions.len() == 2 {\n+        let (_, end_span, end_sugg) = suggestions.pop().unwrap();\n+        let (_, start_span, start_sugg) = suggestions.pop().unwrap();\n+        span_lint_and_then(\n             cx,\n-            IF_SAME_THEN_ELSE,\n-            j.span,\n-            \"this `if` has identical blocks\",\n-            Some(i.span),\n-            \"same as this\",\n+            BRANCHES_SHARING_CODE,\n+            start_span,\n+            \"all if blocks contain the same code at the start and the end. Here at the start\",\n+            move |diag| {\n+                diag.span_note(end_span, \"and here at the end\");\n+\n+                diag.span_suggestion(\n+                    start_span,\n+                    \"consider moving the start statements out like this\",\n+                    start_sugg,\n+                    Applicability::Unspecified,\n+                );\n+\n+                diag.span_suggestion(\n+                    end_span,\n+                    \"and consider moving the end statements out like this\",\n+                    end_sugg,\n+                    Applicability::Unspecified,\n+                );\n+\n+                add_optional_msgs(diag);\n+            },\n         );\n     }\n }\n \n+/// This visitor collects `HirId`s and Symbols of defined symbols and `HirId`s of used values.\n+struct UsedValueFinderVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+\n+    /// The `HirId`s of defined values in the scanned statements\n+    defs: FxHashSet<HirId>,\n+\n+    /// The Symbols of the defined symbols in the scanned statements\n+    def_symbols: FxHashSet<Symbol>,\n+\n+    /// The `HirId`s of the used values\n+    uses: FxHashSet<HirId>,\n+}\n+\n+impl<'a, 'tcx> UsedValueFinderVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> Self {\n+        UsedValueFinderVisitor {\n+            cx,\n+            defs: FxHashSet::default(),\n+            def_symbols: FxHashSet::default(),\n+            uses: FxHashSet::default(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for UsedValueFinderVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::All(self.cx.tcx.hir())\n+    }\n+\n+    fn visit_local(&mut self, l: &'tcx rustc_hir::Local<'tcx>) {\n+        let local_id = l.pat.hir_id;\n+        self.defs.insert(local_id);\n+\n+        if let Some(sym) = l.pat.simple_ident() {\n+            self.def_symbols.insert(sym.name);\n+        }\n+\n+        if let Some(expr) = l.init {\n+            intravisit::walk_expr(self, expr);\n+        }\n+    }\n+\n+    fn visit_qpath(&mut self, qpath: &'tcx rustc_hir::QPath<'tcx>, id: HirId, _span: rustc_span::Span) {\n+        if let rustc_hir::QPath::Resolved(_, path) = *qpath {\n+            if path.segments.len() == 1 {\n+                if let rustc_hir::def::Res::Local(var) = self.cx.qpath_res(qpath, id) {\n+                    self.uses.insert(var);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// Implementation of `IFS_SAME_COND`.\n fn lint_same_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n     let hash: &dyn Fn(&&Expr<'_>) -> u64 = &|expr| -> u64 {\n@@ -198,15 +618,3 @@ fn lint_same_fns_in_if_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n         );\n     }\n }\n-\n-fn search_same_sequenced<T, Eq>(exprs: &[T], eq: Eq) -> Option<(&T, &T)>\n-where\n-    Eq: Fn(&T, &T) -> bool,\n-{\n-    for win in exprs.windows(2) {\n-        if eq(&win[0], &win[1]) {\n-            return Some((&win[0], &win[1]));\n-        }\n-    }\n-    None\n-}"}, {"sha": "7b5cce6462a436bc738052fc222cf8aff9324acc", "filename": "clippy_lints/src/create_dir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcreate_dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fcreate_dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcreate_dir.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -33,7 +33,7 @@ declare_lint_pass!(CreateDir => [CREATE_DIR]);\n impl LateLintPass<'_> for CreateDir {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Call(ref func, ref args) = expr.kind;\n+            if let ExprKind::Call(func, args) = expr.kind;\n             if let ExprKind::Path(ref path) = func.kind;\n             if let Some(def_id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::STD_FS_CREATE_DIR);"}, {"sha": "710da8fe9e037ea6bc21eceeafc3afe205c07410", "filename": "clippy_lints/src/default.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -77,29 +77,28 @@ impl LateLintPass<'_> for Default {\n         if_chain! {\n             // Avoid cases already linted by `field_reassign_with_default`\n             if !self.reassigned_linted.contains(&expr.span);\n-            if let ExprKind::Call(ref path, ..) = expr.kind;\n+            if let ExprKind::Call(path, ..) = expr.kind;\n             if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n             if let ExprKind::Path(ref qpath) = path.kind;\n             if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n             // Detect and ignore <Foo as Default>::default() because these calls do explicitly name the type.\n             if let QPath::Resolved(None, _path) = qpath;\n+            let expr_ty = cx.typeck_results().expr_ty(expr);\n+            if let ty::Adt(def, ..) = expr_ty.kind();\n             then {\n-                let expr_ty = cx.typeck_results().expr_ty(expr);\n-                if let ty::Adt(def, ..) = expr_ty.kind() {\n-                    // TODO: Work out a way to put \"whatever the imported way of referencing\n-                    // this type in this file\" rather than a fully-qualified type.\n-                    let replacement = format!(\"{}::default()\", cx.tcx.def_path_str(def.did));\n-                    span_lint_and_sugg(\n-                        cx,\n-                        DEFAULT_TRAIT_ACCESS,\n-                        expr.span,\n-                        &format!(\"calling `{}` is more clear than this expression\", replacement),\n-                        \"try\",\n-                        replacement,\n-                        Applicability::Unspecified, // First resolve the TODO above\n-                    );\n-                }\n+                // TODO: Work out a way to put \"whatever the imported way of referencing\n+                // this type in this file\" rather than a fully-qualified type.\n+                let replacement = format!(\"{}::default()\", cx.tcx.def_path_str(def.did));\n+                span_lint_and_sugg(\n+                    cx,\n+                    DEFAULT_TRAIT_ACCESS,\n+                    expr.span,\n+                    &format!(\"calling `{}` is more clear than this expression\", replacement),\n+                    \"try\",\n+                    replacement,\n+                    Applicability::Unspecified, // First resolve the TODO above\n+                );\n             }\n         }\n     }\n@@ -202,14 +201,14 @@ impl LateLintPass<'_> for Default {\n                 let binding_type = if_chain! {\n                     if let ty::Adt(adt_def, substs) = binding_type.kind();\n                     if !substs.is_empty();\n-                    let adt_def_ty_name = cx.tcx.item_name(adt_def.did);\n-                    let generic_args = substs.iter().collect::<Vec<_>>();\n-                    let tys_str = generic_args\n-                        .iter()\n-                        .map(ToString::to_string)\n-                        .collect::<Vec<_>>()\n-                        .join(\", \");\n                     then {\n+                        let adt_def_ty_name = cx.tcx.item_name(adt_def.did);\n+                        let generic_args = substs.iter().collect::<Vec<_>>();\n+                        let tys_str = generic_args\n+                            .iter()\n+                            .map(ToString::to_string)\n+                            .collect::<Vec<_>>()\n+                            .join(\", \");\n                         format!(\"{}::<{}>\", adt_def_ty_name, &tys_str)\n                     } else {\n                         binding_type.to_string()\n@@ -247,7 +246,7 @@ impl LateLintPass<'_> for Default {\n /// Checks if the given expression is the `default` method belonging to the `Default` trait.\n fn is_expr_default<'tcx>(expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> bool {\n     if_chain! {\n-        if let ExprKind::Call(ref fn_expr, _) = &expr.kind;\n+        if let ExprKind::Call(fn_expr, _) = &expr.kind;\n         if let ExprKind::Path(qpath) = &fn_expr.kind;\n         if let Res::Def(_, def_id) = cx.qpath_res(qpath, fn_expr.hir_id);\n         then {\n@@ -263,11 +262,11 @@ fn is_expr_default<'tcx>(expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> bool\n fn field_reassigned_by_stmt<'tcx>(this: &Stmt<'tcx>, binding_name: Symbol) -> Option<(Ident, &'tcx Expr<'tcx>)> {\n     if_chain! {\n         // only take assignments\n-        if let StmtKind::Semi(ref later_expr) = this.kind;\n-        if let ExprKind::Assign(ref assign_lhs, ref assign_rhs, _) = later_expr.kind;\n+        if let StmtKind::Semi(later_expr) = this.kind;\n+        if let ExprKind::Assign(assign_lhs, assign_rhs, _) = later_expr.kind;\n         // only take assignments to fields where the left-hand side field is a field of\n         // the same binding as the previous statement\n-        if let ExprKind::Field(ref binding, field_ident) = assign_lhs.kind;\n+        if let ExprKind::Field(binding, field_ident) = assign_lhs.kind;\n         if let ExprKind::Path(QPath::Resolved(_, path)) = binding.kind;\n         if let Some(second_binding_name) = path.segments.last();\n         if second_binding_name.ident.name == binding_name;"}, {"sha": "6e88394268042b5e69be6bafc87e48ac11e97297", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -131,8 +131,8 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n             },\n \n             ExprKind::Struct(_, fields, base) => {\n+                let ty = self.cx.typeck_results().expr_ty(expr);\n                 if_chain! {\n-                    let ty = self.cx.typeck_results().expr_ty(expr);\n                     if let Some(adt_def) = ty.ty_adt_def();\n                     if adt_def.is_struct();\n                     if let Some(variant) = adt_def.variants.iter().next();"}, {"sha": "647af3bdc04d073124fbedfa84a93fb96fa9d1b6", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 48, "deletions": 43, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note, span_lint_and_then};\n use clippy_utils::paths;\n-use clippy_utils::ty::is_copy;\n+use clippy_utils::ty::{implements_trait, is_copy};\n use clippy_utils::{get_trait_def_id, is_allowed, is_automatically_derived, match_def_path};\n use if_chain::if_chain;\n use rustc_hir::def_id::DefId;\n@@ -12,7 +12,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n+use rustc_span::{def_id::LOCAL_CRATE, source_map::Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for deriving `Hash` but implementing `PartialEq`\n@@ -199,7 +199,7 @@ fn check_hash_peq<'tcx>(\n         then {\n             // Look for the PartialEq implementations for `ty`\n             cx.tcx.for_each_relevant_impl(peq_trait_def_id, ty, |impl_id| {\n-                let peq_is_automatically_derived = is_automatically_derived(&cx.tcx.get_attrs(impl_id));\n+                let peq_is_automatically_derived = is_automatically_derived(cx.tcx.get_attrs(impl_id));\n \n                 if peq_is_automatically_derived == hash_is_automatically_derived {\n                     return;\n@@ -253,7 +253,7 @@ fn check_ord_partial_ord<'tcx>(\n         then {\n             // Look for the PartialOrd implementations for `ty`\n             cx.tcx.for_each_relevant_impl(partial_ord_trait_def_id, ty, |impl_id| {\n-                let partial_ord_is_automatically_derived = is_automatically_derived(&cx.tcx.get_attrs(impl_id));\n+                let partial_ord_is_automatically_derived = is_automatically_derived(cx.tcx.get_attrs(impl_id));\n \n                 if partial_ord_is_automatically_derived == ord_is_automatically_derived {\n                     return;\n@@ -293,48 +293,53 @@ fn check_ord_partial_ord<'tcx>(\n \n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n fn check_copy_clone<'tcx>(cx: &LateContext<'tcx>, item: &Item<'_>, trait_ref: &TraitRef<'_>, ty: Ty<'tcx>) {\n-    if cx\n-        .tcx\n-        .lang_items()\n-        .clone_trait()\n-        .map_or(false, |id| Some(id) == trait_ref.trait_def_id())\n-    {\n-        if !is_copy(cx, ty) {\n+    let clone_id = match cx.tcx.lang_items().clone_trait() {\n+        Some(id) if trait_ref.trait_def_id() == Some(id) => id,\n+        _ => return,\n+    };\n+    let copy_id = match cx.tcx.lang_items().copy_trait() {\n+        Some(id) => id,\n+        None => return,\n+    };\n+    let (ty_adt, ty_subs) = match *ty.kind() {\n+        // Unions can't derive clone.\n+        ty::Adt(adt, subs) if !adt.is_union() => (adt, subs),\n+        _ => return,\n+    };\n+    // If the current self type doesn't implement Copy (due to generic constraints), search to see if\n+    // there's a Copy impl for any instance of the adt.\n+    if !is_copy(cx, ty) {\n+        if ty_subs.non_erasable_generics().next().is_some() {\n+            let has_copy_impl = cx\n+                .tcx\n+                .all_local_trait_impls(LOCAL_CRATE)\n+                .get(&copy_id)\n+                .map_or(false, |impls| {\n+                    impls\n+                        .iter()\n+                        .any(|&id| matches!(cx.tcx.type_of(id).kind(), ty::Adt(adt, _) if ty_adt.did == adt.did))\n+                });\n+            if !has_copy_impl {\n+                return;\n+            }\n+        } else {\n             return;\n         }\n-\n-        match *ty.kind() {\n-            ty::Adt(def, _) if def.is_union() => return,\n-\n-            // Some types are not Clone by default but could be cloned \u201cby hand\u201d if necessary\n-            ty::Adt(def, substs) => {\n-                for variant in &def.variants {\n-                    for field in &variant.fields {\n-                        if let ty::FnDef(..) = field.ty(cx.tcx, substs).kind() {\n-                            return;\n-                        }\n-                    }\n-                    for subst in substs {\n-                        if let ty::subst::GenericArgKind::Type(subst) = subst.unpack() {\n-                            if let ty::Param(_) = subst.kind() {\n-                                return;\n-                            }\n-                        }\n-                    }\n-                }\n-            },\n-            _ => (),\n-        }\n-\n-        span_lint_and_note(\n-            cx,\n-            EXPL_IMPL_CLONE_ON_COPY,\n-            item.span,\n-            \"you are implementing `Clone` explicitly on a `Copy` type\",\n-            Some(item.span),\n-            \"consider deriving `Clone` or removing `Copy`\",\n-        );\n     }\n+    // Derive constrains all generic types to requiring Clone. Check if any type is not constrained for\n+    // this impl.\n+    if ty_subs.types().any(|ty| !implements_trait(cx, ty, clone_id, &[])) {\n+        return;\n+    }\n+\n+    span_lint_and_note(\n+        cx,\n+        EXPL_IMPL_CLONE_ON_COPY,\n+        item.span,\n+        \"you are implementing `Clone` explicitly on a `Copy` type\",\n+        Some(item.span),\n+        \"consider deriving `Clone` or removing `Copy`\",\n+    );\n }\n \n /// Implementation of the `UNSAFE_DERIVE_DESERIALIZE` lint."}, {"sha": "fb53b55ebd6acdd41e0d2a9f94676248bccf4343", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -11,7 +11,7 @@ use rustc_errors::emitter::EmitterWriter;\n use rustc_errors::Handler;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_hir::{Expr, ExprKind, QPath};\n+use rustc_hir::{AnonConst, Expr, ExprKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n@@ -710,16 +710,22 @@ impl<'a, 'tcx> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n \n         // check for `begin_panic`\n         if_chain! {\n-            if let ExprKind::Call(ref func_expr, _) = expr.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path)) = func_expr.kind;\n+            if let ExprKind::Call(func_expr, _) = expr.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path)) = func_expr.kind;\n             if let Some(path_def_id) = path.res.opt_def_id();\n             if match_panic_def_id(self.cx, path_def_id);\n             if is_expn_of(expr.span, \"unreachable\").is_none();\n+            if !is_expn_of_debug_assertions(expr.span);\n             then {\n                 self.panic_span = Some(expr.span);\n             }\n         }\n \n+        // check for `assert_eq` or `assert_ne`\n+        if is_expn_of(expr.span, \"assert_eq\").is_some() || is_expn_of(expr.span, \"assert_ne\").is_some() {\n+            self.panic_span = Some(expr.span);\n+        }\n+\n         // check for `unwrap`\n         if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n             let reciever_ty = self.typeck_results.expr_ty(&arglists[0][0]).peel_refs();\n@@ -734,7 +740,15 @@ impl<'a, 'tcx> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n+    // Panics in const blocks will cause compilation to fail.\n+    fn visit_anon_const(&mut self, _: &'tcx AnonConst) {}\n+\n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n         NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n     }\n }\n+\n+fn is_expn_of_debug_assertions(span: Span) -> bool {\n+    const MACRO_NAMES: &[&str] = &[\"debug_assert\", \"debug_assert_eq\", \"debug_assert_ne\"];\n+    MACRO_NAMES.iter().any(|name| is_expn_of(span, name).is_some())\n+}"}, {"sha": "58543ae6e4e314a64a3244b8f9bb911c00d7b971", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> DoubleComparisons {\n             },\n             _ => return,\n         };\n-        if !(eq_expr_value(cx, &llhs, &rlhs) && eq_expr_value(cx, &lrhs, &rrhs)) {\n+        if !(eq_expr_value(cx, llhs, rlhs) && eq_expr_value(cx, lrhs, rrhs)) {\n             return;\n         }\n         macro_rules! lint_double_comparison {\n@@ -88,7 +88,7 @@ impl<'tcx> DoubleComparisons {\n \n impl<'tcx> LateLintPass<'tcx> for DoubleComparisons {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = expr.kind {\n+        if let ExprKind::Binary(ref kind, lhs, rhs) = expr.kind {\n             Self::check_binop(cx, kind.node, lhs, rhs, expr.span);\n         }\n     }"}, {"sha": "e4e4a93b011fd2e8f68c5dc0e93008e4b5278e2b", "filename": "clippy_lints/src/double_parens.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_parens.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -50,23 +50,23 @@ impl EarlyLintPass for DoubleParens {\n         match expr.kind {\n             ExprKind::Paren(ref in_paren) => match in_paren.kind {\n                 ExprKind::Paren(_) | ExprKind::Tup(_) => {\n-                    span_lint(cx, DOUBLE_PARENS, expr.span, &msg);\n+                    span_lint(cx, DOUBLE_PARENS, expr.span, msg);\n                 },\n                 _ => {},\n             },\n             ExprKind::Call(_, ref params) => {\n                 if params.len() == 1 {\n                     let param = &params[0];\n                     if let ExprKind::Paren(_) = param.kind {\n-                        span_lint(cx, DOUBLE_PARENS, param.span, &msg);\n+                        span_lint(cx, DOUBLE_PARENS, param.span, msg);\n                     }\n                 }\n             },\n             ExprKind::MethodCall(_, ref params, _) => {\n                 if params.len() == 2 {\n                     let param = &params[1];\n                     if let ExprKind::Paren(_) = param.kind {\n-                        span_lint(cx, DOUBLE_PARENS, param.span, &msg);\n+                        span_lint(cx, DOUBLE_PARENS, param.span, msg);\n                     }\n                 }\n             },"}, {"sha": "b5b29760636ba5ce61627b21f30559317b886324", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -113,7 +113,7 @@ declare_lint_pass!(DropForgetRef => [DROP_REF, FORGET_REF, DROP_COPY, FORGET_COP\n impl<'tcx> LateLintPass<'tcx> for DropForgetRef {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Call(ref path, ref args) = expr.kind;\n+            if let ExprKind::Call(path, args) = expr.kind;\n             if let ExprKind::Path(ref qpath) = path.kind;\n             if args.len() == 1;\n             if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();"}, {"sha": "529807770f3cd76cbf67adb4ab68ae6e8898bf63", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -43,8 +43,8 @@ declare_lint_pass!(DurationSubsec => [DURATION_SUBSEC]);\n impl<'tcx> LateLintPass<'tcx> for DurationSubsec {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, ref left, ref right) = expr.kind;\n-            if let ExprKind::MethodCall(ref method_path, _ , ref args, _) = left.kind;\n+            if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, left, right) = expr.kind;\n+            if let ExprKind::MethodCall(method_path, _ , args, _) = left.kind;\n             if match_type(cx, cx.typeck_results().expr_ty(&args[0]).peel_refs(), &paths::DURATION);\n             if let Some((Constant::Int(divisor), _)) = constant(cx, cx.typeck_results(), right);\n             then {"}, {"sha": "a815df1691a1c9f8d9334d1695d268c2978a3c9b", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -57,14 +57,14 @@ declare_lint_pass!(HashMapPass => [MAP_ENTRY]);\n \n impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::If(ref check, ref then_block, ref else_block) = expr.kind {\n-            if let ExprKind::Unary(UnOp::Not, ref check) = check.kind {\n+        if let ExprKind::If(check, then_block, ref else_block) = expr.kind {\n+            if let ExprKind::Unary(UnOp::Not, check) = check.kind {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n                     // in case of `if !m.contains_key(&k) { m.insert(k, v); }`\n                     // we can give a better error message\n                     let sole_expr = {\n                         else_block.is_none()\n-                            && if let ExprKind::Block(ref then_block, _) = then_block.kind {\n+                            && if let ExprKind::Block(then_block, _) = then_block.kind {\n                                 (then_block.expr.is_some() as usize) + then_block.stmts.len() == 1\n                             } else {\n                                 true\n@@ -81,9 +81,9 @@ impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n                         sole_expr,\n                     };\n \n-                    walk_expr(&mut visitor, &**then_block);\n+                    walk_expr(&mut visitor, then_block);\n                 }\n-            } else if let Some(ref else_block) = *else_block {\n+            } else if let Some(else_block) = *else_block {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n                     let mut visitor = InsertVisitor {\n                         cx,\n@@ -103,10 +103,10 @@ impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n \n fn check_cond<'a>(cx: &LateContext<'_>, check: &'a Expr<'a>) -> Option<(&'static str, &'a Expr<'a>, &'a Expr<'a>)> {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref path, _, ref params, _) = check.kind;\n+        if let ExprKind::MethodCall(path, _, params, _) = check.kind;\n         if params.len() >= 2;\n         if path.ident.name == sym!(contains_key);\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref key) = params[1].kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, key) = params[1].kind;\n         then {\n             let map = &params[0];\n             let obj_ty = cx.typeck_results().expr_ty(map).peel_refs();\n@@ -140,7 +140,7 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref path, _, ref params, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, params, _) = expr.kind;\n             if params.len() == 3;\n             if path.ident.name == sym!(insert);\n             if get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]);"}, {"sha": "90f391b5f5c89efa3613b7936c232d99e1e41137", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -65,12 +65,12 @@ const ASSERT_MACRO_NAMES: [&str; 4] = [\"assert_eq\", \"assert_ne\", \"debug_assert_e\n impl<'tcx> LateLintPass<'tcx> for EqOp {\n     #[allow(clippy::similar_names, clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::Block(ref block, _) = e.kind {\n+        if let ExprKind::Block(block, _) = e.kind {\n             for stmt in block.stmts {\n                 for amn in &ASSERT_MACRO_NAMES {\n                     if_chain! {\n                         if is_expn_of(stmt.span, amn).is_some();\n-                        if let StmtKind::Semi(ref matchexpr) = stmt.kind;\n+                        if let StmtKind::Semi(matchexpr) = stmt.kind;\n                         if let Some(macro_args) = higher::extract_assert_macro_args(matchexpr);\n                         if macro_args.len() == 2;\n                         let (lhs, rhs) = (macro_args[0], macro_args[1]);\n@@ -88,12 +88,12 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                 }\n             }\n         }\n-        if let ExprKind::Binary(op, ref left, ref right) = e.kind {\n+        if let ExprKind::Binary(op, left, right) = e.kind {\n             if e.span.from_expansion() {\n                 return;\n             }\n             let macro_with_not_op = |expr_kind: &ExprKind<'_>| {\n-                if let ExprKind::Unary(_, ref expr) = *expr_kind {\n+                if let ExprKind::Unary(_, expr) = *expr_kind {\n                     in_macro(expr.span)\n                 } else {\n                     false\n@@ -135,7 +135,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                     // do not suggest to dereference literals\n                     (&ExprKind::Lit(..), _) | (_, &ExprKind::Lit(..)) => {},\n                     // &foo == &bar\n-                    (&ExprKind::AddrOf(BorrowKind::Ref, _, ref l), &ExprKind::AddrOf(BorrowKind::Ref, _, ref r)) => {\n+                    (&ExprKind::AddrOf(BorrowKind::Ref, _, l), &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n                         let lty = cx.typeck_results().expr_ty(l);\n                         let rty = cx.typeck_results().expr_ty(r);\n                         let lcpy = is_copy(cx, lty);\n@@ -198,7 +198,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                         }\n                     },\n                     // &foo == bar\n-                    (&ExprKind::AddrOf(BorrowKind::Ref, _, ref l), _) => {\n+                    (&ExprKind::AddrOf(BorrowKind::Ref, _, l), _) => {\n                         let lty = cx.typeck_results().expr_ty(l);\n                         let lcpy = is_copy(cx, lty);\n                         if (requires_ref || lcpy)\n@@ -222,7 +222,7 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n                         }\n                     },\n                     // foo == &bar\n-                    (_, &ExprKind::AddrOf(BorrowKind::Ref, _, ref r)) => {\n+                    (_, &ExprKind::AddrOf(BorrowKind::Ref, _, r)) => {\n                         let rty = cx.typeck_results().expr_ty(r);\n                         let rcpy = is_copy(cx, rty);\n                         if (requires_ref || rcpy)"}, {"sha": "f95ca86a2d015ec3602369e0e00e65ea755aedbb", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -34,7 +34,7 @@ impl<'tcx> LateLintPass<'tcx> for ErasingOp {\n         if e.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::Binary(ref cmp, ref left, ref right) = e.kind {\n+        if let ExprKind::Binary(ref cmp, left, right) = e.kind {\n             match cmp.node {\n                 BinOpKind::Mul | BinOpKind::BitAnd => {\n                     check(cx, left, e.span);"}, {"sha": "2f1aa53236d3324dd219001ade629bb8a8f950fb", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -87,7 +87,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n }\n \n fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n-    if let ExprKind::Closure(_, ref decl, eid, _, _) = expr.kind {\n+    if let ExprKind::Closure(_, decl, eid, _, _) = expr.kind {\n         let body = cx.tcx.hir().body(eid);\n         let ex = &body.value;\n \n@@ -109,7 +109,7 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         }\n \n         if_chain!(\n-            if let ExprKind::Call(ref caller, ref args) = ex.kind;\n+            if let ExprKind::Call(caller, args) = ex.kind;\n \n             if let ExprKind::Path(_) = caller.kind;\n \n@@ -142,7 +142,7 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         );\n \n         if_chain!(\n-            if let ExprKind::MethodCall(ref path, _, ref args, _) = ex.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = ex.kind;\n \n             // Not the same number of arguments, there is no way the closure is the same as the function return;\n             if args.len() == decl.inputs.len();\n@@ -178,7 +178,7 @@ fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: def_id::DefId, self_a\n     let actual_type_of_self = &cx.typeck_results().node_type(self_arg.hir_id);\n \n     if let Some(trait_id) = cx.tcx.trait_of_item(method_def_id) {\n-        if match_borrow_depth(expected_type_of_self, &actual_type_of_self)\n+        if match_borrow_depth(expected_type_of_self, actual_type_of_self)\n             && implements_trait(cx, actual_type_of_self, trait_id, &[])\n         {\n             return Some(cx.tcx.def_path_str(trait_id));\n@@ -187,16 +187,16 @@ fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: def_id::DefId, self_a\n \n     cx.tcx.impl_of_method(method_def_id).and_then(|_| {\n         //a type may implicitly implement other type's methods (e.g. Deref)\n-        if match_types(expected_type_of_self, &actual_type_of_self) {\n-            return Some(get_type_name(cx, &actual_type_of_self));\n+        if match_types(expected_type_of_self, actual_type_of_self) {\n+            return Some(get_type_name(cx, actual_type_of_self));\n         }\n         None\n     })\n }\n \n fn match_borrow_depth(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n     match (&lhs.kind(), &rhs.kind()) {\n-        (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_borrow_depth(&t1, &t2),\n+        (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_borrow_depth(t1, t2),\n         (l, r) => !matches!((l, r), (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _))),\n     }\n }\n@@ -218,7 +218,7 @@ fn match_types(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n fn get_type_name(cx: &LateContext<'_>, ty: Ty<'_>) -> String {\n     match ty.kind() {\n         ty::Adt(t, _) => cx.tcx.def_path_str(t.did),\n-        ty::Ref(_, r, _) => get_type_name(cx, &r),\n+        ty::Ref(_, r, _) => get_type_name(cx, r),\n         _ => ty.to_string(),\n     }\n }\n@@ -230,7 +230,7 @@ fn compare_inputs(\n     for (closure_input, function_arg) in closure_inputs.zip(call_args) {\n         if let PatKind::Binding(_, _, ident, _) = closure_input.pat.kind {\n             // XXXManishearth Should I be checking the binding mode here?\n-            if let ExprKind::Path(QPath::Resolved(None, ref p)) = function_arg.kind {\n+            if let ExprKind::Path(QPath::Resolved(None, p)) = function_arg.kind {\n                 if p.segments.len() != 1 {\n                     // If it's a proper path, it can't be a local variable\n                     return false;"}, {"sha": "762f64fe37ad6862f19edf05576a747ec76e158e", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> LateLintPass<'tcx> for EvalOrderDependence {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // Find a write to a local variable.\n         match expr.kind {\n-            ExprKind::Assign(ref lhs, ..) | ExprKind::AssignOp(_, ref lhs, _) => {\n+            ExprKind::Assign(lhs, ..) | ExprKind::AssignOp(_, lhs, _) => {\n                 if let Some(var) = path_to_local(lhs) {\n                     let mut visitor = ReadVisitor {\n                         cx,\n@@ -87,12 +87,12 @@ impl<'tcx> LateLintPass<'tcx> for EvalOrderDependence {\n     }\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         match stmt.kind {\n-            StmtKind::Local(ref local) => {\n-                if let Local { init: Some(ref e), .. } = **local {\n+            StmtKind::Local(local) => {\n+                if let Local { init: Some(e), .. } = local {\n                     DivergenceVisitor { cx }.visit_expr(e);\n                 }\n             },\n-            StmtKind::Expr(ref e) | StmtKind::Semi(ref e) => DivergenceVisitor { cx }.maybe_walk_expr(e),\n+            StmtKind::Expr(e) | StmtKind::Semi(e) => DivergenceVisitor { cx }.maybe_walk_expr(e),\n             StmtKind::Item(..) => {},\n         }\n     }\n@@ -106,7 +106,7 @@ impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n     fn maybe_walk_expr(&mut self, e: &'tcx Expr<'_>) {\n         match e.kind {\n             ExprKind::Closure(..) => {},\n-            ExprKind::Match(ref e, arms, _) => {\n+            ExprKind::Match(e, arms, _) => {\n                 self.visit_expr(e);\n                 for arm in arms {\n                     if let Some(Guard::If(if_expr)) = arm.guard {\n@@ -130,7 +130,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n         match e.kind {\n             ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => self.report_diverging_sub_expr(e),\n-            ExprKind::Call(ref func, _) => {\n+            ExprKind::Call(func, _) => {\n                 let typ = self.cx.typeck_results().expr_ty(func);\n                 match typ.kind() {\n                     ty::FnDef(..) | ty::FnPtr(_) => {\n@@ -266,10 +266,10 @@ fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr<'_>) -\n \n fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt<'_>) -> StopEarly {\n     match stmt.kind {\n-        StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => check_expr(vis, expr),\n+        StmtKind::Expr(expr) | StmtKind::Semi(expr) => check_expr(vis, expr),\n         // If the declaration is of a local variable, check its initializer\n         // expression if it has one. Otherwise, keep going.\n-        StmtKind::Local(ref local) => local\n+        StmtKind::Local(local) => local\n             .init\n             .as_ref()\n             .map_or(StopEarly::KeepGoing, |expr| check_expr(vis, expr)),\n@@ -343,7 +343,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n /// Returns `true` if `expr` is the LHS of an assignment, like `expr = ...`.\n fn is_in_assignment_position(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n-        if let ExprKind::Assign(ref lhs, ..) = parent.kind {\n+        if let ExprKind::Assign(lhs, ..) = parent.kind {\n             return lhs.hir_id == expr.hir_id;\n         }\n     }"}, {"sha": "249ee27330bf92537e7686b922fd109ff649ccee", "filename": "clippy_lints/src/excessive_bools.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fexcessive_bools.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fexcessive_bools.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_bools.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,9 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::{attr_by_name, in_macro, match_path_ast};\n+use clippy_utils::{in_macro, match_path_ast};\n use rustc_ast::ast::{AssocItemKind, Extern, FnKind, FnSig, ImplKind, Item, ItemKind, TraitKind, Ty, TyKind};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n use std::convert::TryInto;\n \n@@ -138,7 +138,7 @@ impl EarlyLintPass for ExcessiveBools {\n         }\n         match &item.kind {\n             ItemKind::Struct(variant_data, _) => {\n-                if attr_by_name(&item.attrs, \"repr\").is_some() {\n+                if item.attrs.iter().any(|attr| attr.has_name(sym::repr)) {\n                     return;\n                 }\n "}, {"sha": "16246e548b6131e2e73790c9f15a65dfdd17783f", "filename": "clippy_lints/src/exit.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fexit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fexit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexit.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -28,20 +28,18 @@ declare_lint_pass!(Exit => [EXIT]);\n impl<'tcx> LateLintPass<'tcx> for Exit {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Call(ref path_expr, ref _args) = e.kind;\n+            if let ExprKind::Call(path_expr, _args) = e.kind;\n             if let ExprKind::Path(ref path) = path_expr.kind;\n             if let Some(def_id) = cx.qpath_res(path, path_expr.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::EXIT);\n+            let parent = cx.tcx.hir().get_parent_item(e.hir_id);\n+            if let Some(Node::Item(Item{kind: ItemKind::Fn(..), ..})) = cx.tcx.hir().find(parent);\n+            // If the next item up is a function we check if it is an entry point\n+            // and only then emit a linter warning\n+            let def_id = cx.tcx.hir().local_def_id(parent);\n+            if !is_entrypoint_fn(cx, def_id.to_def_id());\n             then {\n-                let parent = cx.tcx.hir().get_parent_item(e.hir_id);\n-                if let Some(Node::Item(Item{kind: ItemKind::Fn(..), ..})) = cx.tcx.hir().find(parent) {\n-                    // If the next item up is a function we check if it is an entry point\n-                    // and only then emit a linter warning\n-                    let def_id = cx.tcx.hir().local_def_id(parent);\n-                    if !is_entrypoint_fn(cx, def_id.to_def_id()) {\n-                        span_lint(cx, EXIT, e.span, \"usage of `process::exit`\");\n-                    }\n-                }\n+                span_lint(cx, EXIT, e.span, \"usage of `process::exit`\");\n             }\n         }\n     }"}, {"sha": "da4936ff25b6d22d19e38f502e8d32c106cce991", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -34,11 +34,11 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // match call to unwrap\n-            if let ExprKind::MethodCall(ref unwrap_fun, _, ref unwrap_args, _) = expr.kind;\n+            if let ExprKind::MethodCall(unwrap_fun, _, unwrap_args, _) = expr.kind;\n             if unwrap_fun.ident.name == sym::unwrap;\n             // match call to write_fmt\n             if !unwrap_args.is_empty();\n-            if let ExprKind::MethodCall(ref write_fun, _, write_args, _) =\n+            if let ExprKind::MethodCall(write_fun, _, write_args, _) =\n                 unwrap_args[0].kind;\n             if write_fun.ident.name == sym!(write_fmt);\n             // match calls to std::io::stdout() / std::io::stderr ()\n@@ -135,10 +135,10 @@ fn write_output_string(write_args: &[Expr<'_>]) -> Option<String> {\n     if_chain! {\n         // Obtain the string that should be printed\n         if write_args.len() > 1;\n-        if let ExprKind::Call(_, ref output_args) = write_args[1].kind;\n+        if let ExprKind::Call(_, output_args) = write_args[1].kind;\n         if !output_args.is_empty();\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref output_string_expr) = output_args[0].kind;\n-        if let ExprKind::Array(ref string_exprs) = output_string_expr.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, output_string_expr) = output_args[0].kind;\n+        if let ExprKind::Array(string_exprs) = output_string_expr.kind;\n         // we only want to provide an automatic suggestion for simple (non-format) strings\n         if string_exprs.len() == 1;\n         if let ExprKind::Lit(ref lit) = string_exprs[0].kind;"}, {"sha": "2937fcb9ca0f3d02bc93154dfe1cf087a9715ee4", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -81,8 +81,8 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n         fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n             // check for `begin_panic`\n             if_chain! {\n-                if let ExprKind::Call(ref func_expr, _) = expr.kind;\n-                if let ExprKind::Path(QPath::Resolved(_, ref path)) = func_expr.kind;\n+                if let ExprKind::Call(func_expr, _) = expr.kind;\n+                if let ExprKind::Path(QPath::Resolved(_, path)) = func_expr.kind;\n                 if let Some(path_def_id) = path.res.opt_def_id();\n                 if match_panic_def_id(self.lcx, path_def_id);\n                 if is_expn_of(expr.span, \"unreachable\").is_none();"}, {"sha": "b5ebe5f90ba25c6733ccafe8f054db109f08ed1f", "filename": "clippy_lints/src/float_equality_without_abs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> LateLintPass<'tcx> for FloatEqualityWithoutAbs {\n         let rhs;\n \n         // check if expr is a binary expression with a lt or gt operator\n-        if let ExprKind::Binary(op, ref left, ref right) = expr.kind {\n+        if let ExprKind::Binary(op, left, right) = expr.kind {\n             match op.node {\n                 BinOpKind::Lt => {\n                     lhs = left;\n@@ -88,8 +88,8 @@ impl<'tcx> LateLintPass<'tcx> for FloatEqualityWithoutAbs {\n             if let ty::Float(_) = t_val_r.kind();\n \n             then {\n-                let sug_l = sugg::Sugg::hir(cx, &val_l, \"..\");\n-                let sug_r = sugg::Sugg::hir(cx, &val_r, \"..\");\n+                let sug_l = sugg::Sugg::hir(cx, val_l, \"..\");\n+                let sug_r = sugg::Sugg::hir(cx, val_r, \"..\");\n                 // format the suggestion\n                 let suggestion = format!(\"{}.abs()\", sugg::make_assoc(AssocOp::Subtract, &sug_l, &sug_r).maybe_par());\n                 // spans the lint"}, {"sha": "7968e7b764df356c8d5cb1c1cbb6f18ac2b813f5", "filename": "clippy_lints/src/float_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloat_literal.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -61,8 +61,8 @@ declare_lint_pass!(FloatLiteral => [EXCESSIVE_PRECISION, LOSSY_FLOAT_LITERAL]);\n \n impl<'tcx> LateLintPass<'tcx> for FloatLiteral {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        let ty = cx.typeck_results().expr_ty(expr);\n         if_chain! {\n-            let ty = cx.typeck_results().expr_ty(expr);\n             if let ty::Float(fty) = *ty.kind();\n             if let hir::ExprKind::Lit(ref lit) = expr.kind;\n             if let LitKind::Float(sym, lit_float_ty) = lit.node;"}, {"sha": "e0b687b02052146415a089a4b379eb06e0fc4163", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -131,7 +131,7 @@ fn prepare_receiver_sugg<'a>(cx: &LateContext<'_>, mut expr: &'a Expr<'a>) -> Su\n     let mut suggestion = Sugg::hir(cx, expr, \"..\");\n \n     if let ExprKind::Unary(UnOp::Neg, inner_expr) = &expr.kind {\n-        expr = &inner_expr;\n+        expr = inner_expr;\n     }\n \n     if_chain! {\n@@ -313,8 +313,8 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n                     Spanned {\n                         node: BinOpKind::Add, ..\n                     },\n-                    ref lhs,\n-                    ref rhs,\n+                    lhs,\n+                    rhs,\n                 ) = parent.kind\n                 {\n                     let other_addend = if lhs.hir_id == expr.hir_id { rhs } else { lhs };\n@@ -329,7 +329,7 @@ fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n                             \"{}.mul_add({}, {})\",\n                             Sugg::hir(cx, &args[0], \"..\"),\n                             Sugg::hir(cx, &args[0], \"..\"),\n-                            Sugg::hir(cx, &other_addend, \"..\"),\n+                            Sugg::hir(cx, other_addend, \"..\"),\n                         ),\n                         Applicability::MachineApplicable,\n                     );\n@@ -356,18 +356,18 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n         Spanned {\n             node: BinOpKind::Add, ..\n         },\n-        ref add_lhs,\n-        ref add_rhs,\n+        add_lhs,\n+        add_rhs,\n     ) = args[0].kind\n     {\n         // check if expression of the form x * x + y * y\n         if_chain! {\n-            if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref lmul_lhs, ref lmul_rhs) = add_lhs.kind;\n-            if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref rmul_lhs, ref rmul_rhs) = add_rhs.kind;\n+            if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, lmul_lhs, lmul_rhs) = add_lhs.kind;\n+            if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, rmul_lhs, rmul_rhs) = add_rhs.kind;\n             if eq_expr_value(cx, lmul_lhs, lmul_rhs);\n             if eq_expr_value(cx, rmul_lhs, rmul_rhs);\n             then {\n-                return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, &lmul_lhs, \"..\"), Sugg::hir(cx, &rmul_lhs, \"..\")));\n+                return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, lmul_lhs, \"..\"), Sugg::hir(cx, rmul_lhs, \"..\")));\n             }\n         }\n \n@@ -376,13 +376,13 @@ fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n             if let ExprKind::MethodCall(\n                 PathSegment { ident: lmethod_name, .. },\n                 ref _lspan,\n-                ref largs,\n+                largs,\n                 _\n             ) = add_lhs.kind;\n             if let ExprKind::MethodCall(\n                 PathSegment { ident: rmethod_name, .. },\n                 ref _rspan,\n-                ref rargs,\n+                rargs,\n                 _\n             ) = add_rhs.kind;\n             if lmethod_name.as_str() == \"powi\" && rmethod_name.as_str() == \"powi\";\n@@ -416,11 +416,11 @@ fn check_hypot(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n // and suggest usage of `x.exp_m1() - (y - 1)` instead\n fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, ref lhs, ref rhs) = expr.kind;\n+        if let ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, lhs, rhs) = expr.kind;\n         if cx.typeck_results().expr_ty(lhs).is_floating_point();\n         if let Some((value, _)) = constant(cx, cx.typeck_results(), rhs);\n         if F32(1.0) == value || F64(1.0) == value;\n-        if let ExprKind::MethodCall(ref path, _, ref method_args, _) = lhs.kind;\n+        if let ExprKind::MethodCall(path, _, method_args, _) = lhs.kind;\n         if cx.typeck_results().expr_ty(&method_args[0]).is_floating_point();\n         if path.ident.name.as_str() == \"exp\";\n         then {\n@@ -442,7 +442,7 @@ fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n fn is_float_mul_expr<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(&'a Expr<'a>, &'a Expr<'a>)> {\n     if_chain! {\n-        if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref lhs, ref rhs) = &expr.kind;\n+        if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, lhs, rhs) = &expr.kind;\n         if cx.typeck_results().expr_ty(lhs).is_floating_point();\n         if cx.typeck_results().expr_ty(rhs).is_floating_point();\n         then {\n@@ -604,8 +604,8 @@ fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n fn are_same_base_logs(cx: &LateContext<'_>, expr_a: &Expr<'_>, expr_b: &Expr<'_>) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(PathSegment { ident: method_name_a, .. }, _, ref args_a, _) = expr_a.kind;\n-        if let ExprKind::MethodCall(PathSegment { ident: method_name_b, .. }, _, ref args_b, _) = expr_b.kind;\n+        if let ExprKind::MethodCall(PathSegment { ident: method_name_a, .. }, _, args_a, _) = expr_a.kind;\n+        if let ExprKind::MethodCall(PathSegment { ident: method_name_b, .. }, _, args_b, _) = expr_b.kind;\n         then {\n             return method_name_a.as_str() == method_name_b.as_str() &&\n                 args_a.len() == args_b.len() &&\n@@ -630,8 +630,8 @@ fn check_log_division(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             rhs,\n         ) = &expr.kind;\n         if are_same_base_logs(cx, lhs, rhs);\n-        if let ExprKind::MethodCall(_, _, ref largs, _) = lhs.kind;\n-        if let ExprKind::MethodCall(_, _, ref rargs, _) = rhs.kind;\n+        if let ExprKind::MethodCall(_, _, largs, _) = lhs.kind;\n+        if let ExprKind::MethodCall(_, _, rargs, _) = rhs.kind;\n         then {\n             span_lint_and_sugg(\n                 cx,\n@@ -675,7 +675,7 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                     expr.span,\n                     \"conversion to degrees can be done more accurately\",\n                     \"consider using\",\n-                    format!(\"{}.to_degrees()\", Sugg::hir(cx, &mul_lhs, \"..\")),\n+                    format!(\"{}.to_degrees()\", Sugg::hir(cx, mul_lhs, \"..\")),\n                     Applicability::MachineApplicable,\n                 );\n             } else if\n@@ -688,7 +688,7 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                     expr.span,\n                     \"conversion to radians can be done more accurately\",\n                     \"consider using\",\n-                    format!(\"{}.to_radians()\", Sugg::hir(cx, &mul_lhs, \"..\")),\n+                    format!(\"{}.to_radians()\", Sugg::hir(cx, mul_lhs, \"..\")),\n                     Applicability::MachineApplicable,\n                 );\n             }\n@@ -698,7 +698,7 @@ fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n impl<'tcx> LateLintPass<'tcx> for FloatingPointArithmetic {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::MethodCall(ref path, _, args, _) = &expr.kind {\n+        if let ExprKind::MethodCall(path, _, args, _) = &expr.kind {\n             let recv_ty = cx.typeck_results().expr_ty(&args[0]);\n \n             if recv_ty.is_floating_point() {"}, {"sha": "4729abbd8e3f7ff99ad2f2e29dfe653043243262", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -78,8 +78,8 @@ fn span_useless_format<T: LintContext>(cx: &T, span: Span, help: &str, mut sugg:\n \n fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) -> Option<String> {\n     if_chain! {\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref format_args) = expr.kind;\n-        if let ExprKind::Array(ref elems) = arms[0].body.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, format_args) = expr.kind;\n+        if let ExprKind::Array(elems) = arms[0].body.kind;\n         if elems.len() == 1;\n         if let Some(args) = match_function_call(cx, &elems[0], &paths::FMT_ARGUMENTV1_NEW);\n         // matches `core::fmt::Display::fmt`\n@@ -88,10 +88,10 @@ fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &\n         if let Some(did) = cx.qpath_res(qpath, args[1].hir_id).opt_def_id();\n         if match_def_path(cx, did, &paths::DISPLAY_FMT_METHOD);\n         // check `(arg0,)` in match block\n-        if let PatKind::Tuple(ref pats, None) = arms[0].pat.kind;\n+        if let PatKind::Tuple(pats, None) = arms[0].pat.kind;\n         if pats.len() == 1;\n         then {\n-            let ty = cx.typeck_results().pat_ty(&pats[0]).peel_refs();\n+            let ty = cx.typeck_results().pat_ty(pats[0]).peel_refs();\n             if *ty.kind() != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym::string_type) {\n                 return None;\n             }\n@@ -101,7 +101,7 @@ fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &\n                 }\n             } else {\n                 let snip = snippet(cx, format_args.span, \"<arg>\");\n-                if let ExprKind::MethodCall(ref path, _, _, _) = format_args.kind {\n+                if let ExprKind::MethodCall(path, _, _, _) = format_args.kind {\n                     if path.ident.name == sym!(to_string) {\n                         return Some(format!(\"{}\", snip));\n                     }\n@@ -120,16 +120,16 @@ fn on_new_v1<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<Strin\n         if let Some(args) = match_function_call(cx, expr, &paths::FMT_ARGUMENTS_NEW_V1);\n         if args.len() == 2;\n         // Argument 1 in `new_v1()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arr) = args[0].kind;\n-        if let ExprKind::Array(ref pieces) = arr.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, arr) = args[0].kind;\n+        if let ExprKind::Array(pieces) = arr.kind;\n         if pieces.len() == 1;\n         if let ExprKind::Lit(ref lit) = pieces[0].kind;\n         if let LitKind::Str(ref s, _) = lit.node;\n         // Argument 2 in `new_v1()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arg1) = args[1].kind;\n-        if let ExprKind::Match(ref matchee, ref arms, MatchSource::Normal) = arg1.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, arg1) = args[1].kind;\n+        if let ExprKind::Match(matchee, arms, MatchSource::Normal) = arg1.kind;\n         if arms.len() == 1;\n-        if let ExprKind::Tup(ref tup) = matchee.kind;\n+        if let ExprKind::Tup(tup) = matchee.kind;\n         then {\n             // `format!(\"foo\")` expansion contains `match () { () => [], }`\n             if tup.is_empty() {\n@@ -152,16 +152,16 @@ fn on_new_v1_fmt<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<S\n         if args.len() == 3;\n         if check_unformatted(&args[2]);\n         // Argument 1 in `new_v1_formatted()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arr) = args[0].kind;\n-        if let ExprKind::Array(ref pieces) = arr.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, arr) = args[0].kind;\n+        if let ExprKind::Array(pieces) = arr.kind;\n         if pieces.len() == 1;\n         if let ExprKind::Lit(ref lit) = pieces[0].kind;\n         if let LitKind::Str(..) = lit.node;\n         // Argument 2 in `new_v1_formatted()`\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arg1) = args[1].kind;\n-        if let ExprKind::Match(ref matchee, ref arms, MatchSource::Normal) = arg1.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, arg1) = args[1].kind;\n+        if let ExprKind::Match(matchee, arms, MatchSource::Normal) = arg1.kind;\n         if arms.len() == 1;\n-        if let ExprKind::Tup(ref tup) = matchee.kind;\n+        if let ExprKind::Tup(tup) = matchee.kind;\n         then {\n             return on_argumentv1_new(cx, &tup[0], arms);\n         }\n@@ -182,14 +182,14 @@ fn on_new_v1_fmt<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<S\n /// ```\n fn check_unformatted(expr: &Expr<'_>) -> bool {\n     if_chain! {\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref expr) = expr.kind;\n-        if let ExprKind::Array(ref exprs) = expr.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, expr) = expr.kind;\n+        if let ExprKind::Array(exprs) = expr.kind;\n         if exprs.len() == 1;\n         // struct `core::fmt::rt::v1::Argument`\n-        if let ExprKind::Struct(_, ref fields, _) = exprs[0].kind;\n+        if let ExprKind::Struct(_, fields, _) = exprs[0].kind;\n         if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym::format);\n         // struct `core::fmt::rt::v1::FormatSpec`\n-        if let ExprKind::Struct(_, ref fields, _) = format_field.expr.kind;\n+        if let ExprKind::Struct(_, fields, _) = format_field.expr.kind;\n         if let Some(precision_field) = fields.iter().find(|f| f.ident.name == sym::precision);\n         if let ExprKind::Path(ref precision_path) = precision_field.expr.kind;\n         if last_path_segment(precision_path).ident.name == sym::Implied;"}, {"sha": "48612befc68d905a5e10a42ad314b6f047dd3bf8", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -217,9 +217,8 @@ fn check_else(cx: &EarlyContext<'_>, expr: &Expr) {\n         if let Some(else_snippet) = snippet_opt(cx, else_span);\n         if let Some(else_pos) = else_snippet.find(\"else\");\n         if else_snippet[else_pos..].contains('\\n');\n-        let else_desc = if is_if(else_) { \"if\" } else { \"{..}\" };\n-\n         then {\n+            let else_desc = if is_if(else_) { \"if\" } else { \"{..}\" };\n             span_lint_and_note(\n                 cx,\n                 SUSPICIOUS_ELSE_FORMATTING,"}, {"sha": "5fe46065348fc88069aa3dc87143993588740362", "filename": "clippy_lints/src/functions.rs", "status": "removed", "additions": 0, "deletions": 738, "changes": 738, "blob_url": "https://github.com/rust-lang/rust/blob/cde58f7174cd83752b3c0a00a970dcc07c511077/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde58f7174cd83752b3c0a00a970dcc07c511077/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=cde58f7174cd83752b3c0a00a970dcc07c511077", "patch": "@@ -1,738 +0,0 @@\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_then};\n-use clippy_utils::source::{snippet, snippet_opt};\n-use clippy_utils::ty::{is_must_use_ty, is_type_diagnostic_item, type_is_unsafe_function};\n-use clippy_utils::{\n-    attr_by_name, attrs::is_proc_macro, is_trait_impl_item, iter_input_pats, match_def_path, must_use_attr,\n-    path_to_local, return_ty, trait_ref_of_method,\n-};\n-use if_chain::if_chain;\n-use rustc_ast::ast::Attribute;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::intravisit;\n-use rustc_hir::{def::Res, def_id::DefId, QPath};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::hir::map::Map;\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty};\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::Span;\n-use rustc_span::sym;\n-use rustc_target::spec::abi::Abi;\n-use rustc_typeck::hir_ty_to_ty;\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for functions with too many parameters.\n-    ///\n-    /// **Why is this bad?** Functions with lots of parameters are considered bad\n-    /// style and reduce readability (\u201cwhat does the 5th parameter mean?\u201d). Consider\n-    /// grouping some parameters into a new type.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # struct Color;\n-    /// fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) {\n-    ///     // ..\n-    /// }\n-    /// ```\n-    pub TOO_MANY_ARGUMENTS,\n-    complexity,\n-    \"functions with too many arguments\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for functions with a large amount of lines.\n-    ///\n-    /// **Why is this bad?** Functions with a lot of lines are harder to understand\n-    /// due to having to look at a larger amount of code to understand what the\n-    /// function is doing. Consider splitting the body of the function into\n-    /// multiple functions.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// fn im_too_long() {\n-    ///     println!(\"\");\n-    ///     // ... 100 more LoC\n-    ///     println!(\"\");\n-    /// }\n-    /// ```\n-    pub TOO_MANY_LINES,\n-    pedantic,\n-    \"functions with too many lines\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for public functions that dereference raw pointer\n-    /// arguments but are not marked unsafe.\n-    ///\n-    /// **Why is this bad?** The function should probably be marked `unsafe`, since\n-    /// for an arbitrary raw pointer, there is no way of telling for sure if it is\n-    /// valid.\n-    ///\n-    /// **Known problems:**\n-    ///\n-    /// * It does not check functions recursively so if the pointer is passed to a\n-    /// private non-`unsafe` function which does the dereferencing, the lint won't\n-    /// trigger.\n-    /// * It only checks for arguments whose type are raw pointers, not raw pointers\n-    /// got from an argument in some other way (`fn foo(bar: &[*const u8])` or\n-    /// `some_argument.get_raw_ptr()`).\n-    ///\n-    /// **Example:**\n-    /// ```rust,ignore\n-    /// // Bad\n-    /// pub fn foo(x: *const u8) {\n-    ///     println!(\"{}\", unsafe { *x });\n-    /// }\n-    ///\n-    /// // Good\n-    /// pub unsafe fn foo(x: *const u8) {\n-    ///     println!(\"{}\", unsafe { *x });\n-    /// }\n-    /// ```\n-    pub NOT_UNSAFE_PTR_ARG_DEREF,\n-    correctness,\n-    \"public functions dereferencing raw pointer arguments but not marked `unsafe`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for a [`#[must_use]`] attribute on\n-    /// unit-returning functions and methods.\n-    ///\n-    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n-    ///\n-    /// **Why is this bad?** Unit values are useless. The attribute is likely\n-    /// a remnant of a refactoring that removed the return type.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Examples:**\n-    /// ```rust\n-    /// #[must_use]\n-    /// fn useless() { }\n-    /// ```\n-    pub MUST_USE_UNIT,\n-    style,\n-    \"`#[must_use]` attribute on a unit-returning function / method\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for a [`#[must_use]`] attribute without\n-    /// further information on functions and methods that return a type already\n-    /// marked as `#[must_use]`.\n-    ///\n-    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n-    ///\n-    /// **Why is this bad?** The attribute isn't needed. Not using the result\n-    /// will already be reported. Alternatively, one can add some text to the\n-    /// attribute to improve the lint message.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Examples:**\n-    /// ```rust\n-    /// #[must_use]\n-    /// fn double_must_use() -> Result<(), ()> {\n-    ///     unimplemented!();\n-    /// }\n-    /// ```\n-    pub DOUBLE_MUST_USE,\n-    style,\n-    \"`#[must_use]` attribute on a `#[must_use]`-returning function / method\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for public functions that have no\n-    /// [`#[must_use]`] attribute, but return something not already marked\n-    /// must-use, have no mutable arg and mutate no statics.\n-    ///\n-    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n-    ///\n-    /// **Why is this bad?** Not bad at all, this lint just shows places where\n-    /// you could add the attribute.\n-    ///\n-    /// **Known problems:** The lint only checks the arguments for mutable\n-    /// types without looking if they are actually changed. On the other hand,\n-    /// it also ignores a broad range of potentially interesting side effects,\n-    /// because we cannot decide whether the programmer intends the function to\n-    /// be called for the side effect or the result. Expect many false\n-    /// positives. At least we don't lint if the result type is unit or already\n-    /// `#[must_use]`.\n-    ///\n-    /// **Examples:**\n-    /// ```rust\n-    /// // this could be annotated with `#[must_use]`.\n-    /// fn id<T>(t: T) -> T { t }\n-    /// ```\n-    pub MUST_USE_CANDIDATE,\n-    pedantic,\n-    \"function or method that could take a `#[must_use]` attribute\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for public functions that return a `Result`\n-    /// with an `Err` type of `()`. It suggests using a custom type that\n-    /// implements [`std::error::Error`].\n-    ///\n-    /// **Why is this bad?** Unit does not implement `Error` and carries no\n-    /// further information about what went wrong.\n-    ///\n-    /// **Known problems:** Of course, this lint assumes that `Result` is used\n-    /// for a fallible operation (which is after all the intended use). However\n-    /// code may opt to (mis)use it as a basic two-variant-enum. In that case,\n-    /// the suggestion is misguided, and the code should use a custom enum\n-    /// instead.\n-    ///\n-    /// **Examples:**\n-    /// ```rust\n-    /// pub fn read_u8() -> Result<u8, ()> { Err(()) }\n-    /// ```\n-    /// should become\n-    /// ```rust,should_panic\n-    /// use std::fmt;\n-    ///\n-    /// #[derive(Debug)]\n-    /// pub struct EndOfStream;\n-    ///\n-    /// impl fmt::Display for EndOfStream {\n-    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-    ///         write!(f, \"End of Stream\")\n-    ///     }\n-    /// }\n-    ///\n-    /// impl std::error::Error for EndOfStream { }\n-    ///\n-    /// pub fn read_u8() -> Result<u8, EndOfStream> { Err(EndOfStream) }\n-    ///# fn main() {\n-    ///#     read_u8().unwrap();\n-    ///# }\n-    /// ```\n-    ///\n-    /// Note that there are crates that simplify creating the error type, e.g.\n-    /// [`thiserror`](https://docs.rs/thiserror).\n-    pub RESULT_UNIT_ERR,\n-    style,\n-    \"public function returning `Result` with an `Err` type of `()`\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct Functions {\n-    threshold: u64,\n-    max_lines: u64,\n-}\n-\n-impl Functions {\n-    pub fn new(threshold: u64, max_lines: u64) -> Self {\n-        Self { threshold, max_lines }\n-    }\n-}\n-\n-impl_lint_pass!(Functions => [\n-    TOO_MANY_ARGUMENTS,\n-    TOO_MANY_LINES,\n-    NOT_UNSAFE_PTR_ARG_DEREF,\n-    MUST_USE_UNIT,\n-    DOUBLE_MUST_USE,\n-    MUST_USE_CANDIDATE,\n-    RESULT_UNIT_ERR,\n-]);\n-\n-impl<'tcx> LateLintPass<'tcx> for Functions {\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'tcx>,\n-        kind: intravisit::FnKind<'tcx>,\n-        decl: &'tcx hir::FnDecl<'_>,\n-        body: &'tcx hir::Body<'_>,\n-        span: Span,\n-        hir_id: hir::HirId,\n-    ) {\n-        let unsafety = match kind {\n-            intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }, _) => unsafety,\n-            intravisit::FnKind::Method(_, sig, _) => sig.header.unsafety,\n-            intravisit::FnKind::Closure => return,\n-        };\n-\n-        // don't warn for implementations, it's not their fault\n-        if !is_trait_impl_item(cx, hir_id) {\n-            // don't lint extern functions decls, it's not their fault either\n-            match kind {\n-                intravisit::FnKind::Method(\n-                    _,\n-                    &hir::FnSig {\n-                        header: hir::FnHeader { abi: Abi::Rust, .. },\n-                        ..\n-                    },\n-                    _,\n-                )\n-                | intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }, _) => {\n-                    self.check_arg_number(cx, decl, span.with_hi(decl.output.span().hi()))\n-                },\n-                _ => {},\n-            }\n-        }\n-\n-        Self::check_raw_ptr(cx, unsafety, decl, body, hir_id);\n-        self.check_line_number(cx, span, body);\n-    }\n-\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let attr = must_use_attr(attrs);\n-        if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n-            let is_public = cx.access_levels.is_exported(item.hir_id());\n-            let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n-            if is_public {\n-                check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n-            }\n-            if let Some(attr) = attr {\n-                check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-                return;\n-            }\n-            if is_public && !is_proc_macro(cx.sess(), attrs) && attr_by_name(attrs, \"no_mangle\").is_none() {\n-                check_must_use_candidate(\n-                    cx,\n-                    &sig.decl,\n-                    cx.tcx.hir().body(*body_id),\n-                    item.span,\n-                    item.hir_id(),\n-                    item.span.with_hi(sig.decl.output.span().hi()),\n-                    \"this function could have a `#[must_use]` attribute\",\n-                );\n-            }\n-        }\n-    }\n-\n-    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n-        if let hir::ImplItemKind::Fn(ref sig, ref body_id) = item.kind {\n-            let is_public = cx.access_levels.is_exported(item.hir_id());\n-            let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n-            if is_public && trait_ref_of_method(cx, item.hir_id()).is_none() {\n-                check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n-            }\n-            let attrs = cx.tcx.hir().attrs(item.hir_id());\n-            let attr = must_use_attr(attrs);\n-            if let Some(attr) = attr {\n-                check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-            } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.hir_id()).is_none()\n-            {\n-                check_must_use_candidate(\n-                    cx,\n-                    &sig.decl,\n-                    cx.tcx.hir().body(*body_id),\n-                    item.span,\n-                    item.hir_id(),\n-                    item.span.with_hi(sig.decl.output.span().hi()),\n-                    \"this method could have a `#[must_use]` attribute\",\n-                );\n-            }\n-        }\n-    }\n-\n-    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n-        if let hir::TraitItemKind::Fn(ref sig, ref eid) = item.kind {\n-            // don't lint extern functions decls, it's not their fault\n-            if sig.header.abi == Abi::Rust {\n-                self.check_arg_number(cx, &sig.decl, item.span.with_hi(sig.decl.output.span().hi()));\n-            }\n-            let is_public = cx.access_levels.is_exported(item.hir_id());\n-            let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n-            if is_public {\n-                check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n-            }\n-\n-            let attrs = cx.tcx.hir().attrs(item.hir_id());\n-            let attr = must_use_attr(attrs);\n-            if let Some(attr) = attr {\n-                check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-            }\n-            if let hir::TraitFn::Provided(eid) = *eid {\n-                let body = cx.tcx.hir().body(eid);\n-                Self::check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id());\n-\n-                if attr.is_none() && is_public && !is_proc_macro(cx.sess(), attrs) {\n-                    check_must_use_candidate(\n-                        cx,\n-                        &sig.decl,\n-                        body,\n-                        item.span,\n-                        item.hir_id(),\n-                        item.span.with_hi(sig.decl.output.span().hi()),\n-                        \"this method could have a `#[must_use]` attribute\",\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> Functions {\n-    fn check_arg_number(self, cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, fn_span: Span) {\n-        let args = decl.inputs.len() as u64;\n-        if args > self.threshold {\n-            span_lint(\n-                cx,\n-                TOO_MANY_ARGUMENTS,\n-                fn_span,\n-                &format!(\"this function has too many arguments ({}/{})\", args, self.threshold),\n-            );\n-        }\n-    }\n-\n-    fn check_line_number(self, cx: &LateContext<'_>, span: Span, body: &'tcx hir::Body<'_>) {\n-        if in_external_macro(cx.sess(), span) {\n-            return;\n-        }\n-\n-        let code_snippet = snippet(cx, body.value.span, \"..\");\n-        let mut line_count: u64 = 0;\n-        let mut in_comment = false;\n-        let mut code_in_line;\n-\n-        // Skip the surrounding function decl.\n-        let start_brace_idx = code_snippet.find('{').map_or(0, |i| i + 1);\n-        let end_brace_idx = code_snippet.rfind('}').unwrap_or_else(|| code_snippet.len());\n-        let function_lines = code_snippet[start_brace_idx..end_brace_idx].lines();\n-\n-        for mut line in function_lines {\n-            code_in_line = false;\n-            loop {\n-                line = line.trim_start();\n-                if line.is_empty() {\n-                    break;\n-                }\n-                if in_comment {\n-                    if let Some(i) = line.find(\"*/\") {\n-                        line = &line[i + 2..];\n-                        in_comment = false;\n-                        continue;\n-                    }\n-                } else {\n-                    let multi_idx = line.find(\"/*\").unwrap_or_else(|| line.len());\n-                    let single_idx = line.find(\"//\").unwrap_or_else(|| line.len());\n-                    code_in_line |= multi_idx > 0 && single_idx > 0;\n-                    // Implies multi_idx is below line.len()\n-                    if multi_idx < single_idx {\n-                        line = &line[multi_idx + 2..];\n-                        in_comment = true;\n-                        continue;\n-                    }\n-                }\n-                break;\n-            }\n-            if code_in_line {\n-                line_count += 1;\n-            }\n-        }\n-\n-        if line_count > self.max_lines {\n-            span_lint(\n-                cx,\n-                TOO_MANY_LINES,\n-                span,\n-                &format!(\"this function has too many lines ({}/{})\", line_count, self.max_lines),\n-            )\n-        }\n-    }\n-\n-    fn check_raw_ptr(\n-        cx: &LateContext<'tcx>,\n-        unsafety: hir::Unsafety,\n-        decl: &'tcx hir::FnDecl<'_>,\n-        body: &'tcx hir::Body<'_>,\n-        hir_id: hir::HirId,\n-    ) {\n-        let expr = &body.value;\n-        if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(hir_id) {\n-            let raw_ptrs = iter_input_pats(decl, body)\n-                .zip(decl.inputs.iter())\n-                .filter_map(|(arg, ty)| raw_ptr_arg(arg, ty))\n-                .collect::<FxHashSet<_>>();\n-\n-            if !raw_ptrs.is_empty() {\n-                let typeck_results = cx.tcx.typeck_body(body.id());\n-                let mut v = DerefVisitor {\n-                    cx,\n-                    ptrs: raw_ptrs,\n-                    typeck_results,\n-                };\n-\n-                intravisit::walk_expr(&mut v, expr);\n-            }\n-        }\n-    }\n-}\n-\n-fn check_result_unit_err(cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, item_span: Span, fn_header_span: Span) {\n-    if_chain! {\n-        if !in_external_macro(cx.sess(), item_span);\n-        if let hir::FnRetTy::Return(ref ty) = decl.output;\n-        let ty = hir_ty_to_ty(cx.tcx, ty);\n-        if is_type_diagnostic_item(cx, ty, sym::result_type);\n-        if let ty::Adt(_, substs) = ty.kind();\n-        let err_ty = substs.type_at(1);\n-        if err_ty.is_unit();\n-        then {\n-            span_lint_and_help(\n-                cx,\n-                RESULT_UNIT_ERR,\n-                fn_header_span,\n-                \"this returns a `Result<_, ()>\",\n-                None,\n-                \"use a custom Error type instead\",\n-            );\n-        }\n-    }\n-}\n-\n-fn check_needless_must_use(\n-    cx: &LateContext<'_>,\n-    decl: &hir::FnDecl<'_>,\n-    item_id: hir::HirId,\n-    item_span: Span,\n-    fn_header_span: Span,\n-    attr: &Attribute,\n-) {\n-    if in_external_macro(cx.sess(), item_span) {\n-        return;\n-    }\n-    if returns_unit(decl) {\n-        span_lint_and_then(\n-            cx,\n-            MUST_USE_UNIT,\n-            fn_header_span,\n-            \"this unit-returning function has a `#[must_use]` attribute\",\n-            |diag| {\n-                diag.span_suggestion(\n-                    attr.span,\n-                    \"remove the attribute\",\n-                    \"\".into(),\n-                    Applicability::MachineApplicable,\n-                );\n-            },\n-        );\n-    } else if !attr.value_str().is_some() && is_must_use_ty(cx, return_ty(cx, item_id)) {\n-        span_lint_and_help(\n-            cx,\n-            DOUBLE_MUST_USE,\n-            fn_header_span,\n-            \"this function has an empty `#[must_use]` attribute, but returns a type already marked as `#[must_use]`\",\n-            None,\n-            \"either add some descriptive text or remove the attribute\",\n-        );\n-    }\n-}\n-\n-fn check_must_use_candidate<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    decl: &'tcx hir::FnDecl<'_>,\n-    body: &'tcx hir::Body<'_>,\n-    item_span: Span,\n-    item_id: hir::HirId,\n-    fn_span: Span,\n-    msg: &str,\n-) {\n-    if has_mutable_arg(cx, body)\n-        || mutates_static(cx, body)\n-        || in_external_macro(cx.sess(), item_span)\n-        || returns_unit(decl)\n-        || !cx.access_levels.is_exported(item_id)\n-        || is_must_use_ty(cx, return_ty(cx, item_id))\n-    {\n-        return;\n-    }\n-    span_lint_and_then(cx, MUST_USE_CANDIDATE, fn_span, msg, |diag| {\n-        if let Some(snippet) = snippet_opt(cx, fn_span) {\n-            diag.span_suggestion(\n-                fn_span,\n-                \"add the attribute\",\n-                format!(\"#[must_use] {}\", snippet),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    });\n-}\n-\n-fn returns_unit(decl: &hir::FnDecl<'_>) -> bool {\n-    match decl.output {\n-        hir::FnRetTy::DefaultReturn(_) => true,\n-        hir::FnRetTy::Return(ref ty) => match ty.kind {\n-            hir::TyKind::Tup(ref tys) => tys.is_empty(),\n-            hir::TyKind::Never => true,\n-            _ => false,\n-        },\n-    }\n-}\n-\n-fn has_mutable_arg(cx: &LateContext<'_>, body: &hir::Body<'_>) -> bool {\n-    let mut tys = FxHashSet::default();\n-    body.params.iter().any(|param| is_mutable_pat(cx, &param.pat, &mut tys))\n-}\n-\n-fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut FxHashSet<DefId>) -> bool {\n-    if let hir::PatKind::Wild = pat.kind {\n-        return false; // ignore `_` patterns\n-    }\n-    if cx.tcx.has_typeck_results(pat.hir_id.owner.to_def_id()) {\n-        is_mutable_ty(cx, &cx.tcx.typeck(pat.hir_id.owner).pat_ty(pat), pat.span, tys)\n-    } else {\n-        false\n-    }\n-}\n-\n-static KNOWN_WRAPPER_TYS: &[&[&str]] = &[&[\"alloc\", \"rc\", \"Rc\"], &[\"std\", \"sync\", \"Arc\"]];\n-\n-fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &mut FxHashSet<DefId>) -> bool {\n-    match *ty.kind() {\n-        // primitive types are never mutable\n-        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n-        ty::Adt(ref adt, ref substs) => {\n-            tys.insert(adt.did) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n-                || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did, path))\n-                    && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n-        },\n-        ty::Tuple(ref substs) => substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n-        ty::Array(ty, _) | ty::Slice(ty) => is_mutable_ty(cx, ty, span, tys),\n-        ty::RawPtr(ty::TypeAndMut { ty, mutbl }) | ty::Ref(_, ty, mutbl) => {\n-            mutbl == hir::Mutability::Mut || is_mutable_ty(cx, ty, span, tys)\n-        },\n-        // calling something constitutes a side effect, so return true on all callables\n-        // also never calls need not be used, so return true for them, too\n-        _ => true,\n-    }\n-}\n-\n-fn raw_ptr_arg(arg: &hir::Param<'_>, ty: &hir::Ty<'_>) -> Option<hir::HirId> {\n-    if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.kind, &ty.kind) {\n-        Some(id)\n-    } else {\n-        None\n-    }\n-}\n-\n-struct DerefVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    ptrs: FxHashSet<hir::HirId>,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n-}\n-\n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        match expr.kind {\n-            hir::ExprKind::Call(ref f, args) => {\n-                let ty = self.typeck_results.expr_ty(f);\n-\n-                if type_is_unsafe_function(self.cx, ty) {\n-                    for arg in args {\n-                        self.check_arg(arg);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::MethodCall(_, _, args, _) => {\n-                let def_id = self.typeck_results.type_dependent_def_id(expr.hir_id).unwrap();\n-                let base_type = self.cx.tcx.type_of(def_id);\n-\n-                if type_is_unsafe_function(self.cx, base_type) {\n-                    for arg in args {\n-                        self.check_arg(arg);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::Unary(hir::UnOp::Deref, ref ptr) => self.check_arg(ptr),\n-            _ => (),\n-        }\n-\n-        intravisit::walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-        intravisit::NestedVisitorMap::None\n-    }\n-}\n-\n-impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n-    fn check_arg(&self, ptr: &hir::Expr<'_>) {\n-        if let Some(id) = path_to_local(ptr) {\n-            if self.ptrs.contains(&id) {\n-                span_lint(\n-                    self.cx,\n-                    NOT_UNSAFE_PTR_ARG_DEREF,\n-                    ptr.span,\n-                    \"this public function dereferences a raw pointer but is not marked `unsafe`\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-struct StaticMutVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    mutates_static: bool,\n-}\n-\n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        use hir::ExprKind::{AddrOf, Assign, AssignOp, Call, MethodCall};\n-\n-        if self.mutates_static {\n-            return;\n-        }\n-        match expr.kind {\n-            Call(_, args) | MethodCall(_, _, args, _) => {\n-                let mut tys = FxHashSet::default();\n-                for arg in args {\n-                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n-                        && is_mutable_ty(\n-                            self.cx,\n-                            self.cx.tcx.typeck(arg.hir_id.owner).expr_ty(arg),\n-                            arg.span,\n-                            &mut tys,\n-                        )\n-                        && is_mutated_static(arg)\n-                    {\n-                        self.mutates_static = true;\n-                        return;\n-                    }\n-                    tys.clear();\n-                }\n-            },\n-            Assign(ref target, ..) | AssignOp(_, ref target, _) | AddrOf(_, hir::Mutability::Mut, ref target) => {\n-                self.mutates_static |= is_mutated_static(target)\n-            },\n-            _ => {},\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-        intravisit::NestedVisitorMap::None\n-    }\n-}\n-\n-fn is_mutated_static(e: &hir::Expr<'_>) -> bool {\n-    use hir::ExprKind::{Field, Index, Path};\n-\n-    match e.kind {\n-        Path(QPath::Resolved(_, path)) => !matches!(path.res, Res::Local(_)),\n-        Path(_) => true,\n-        Field(ref inner, _) | Index(ref inner, _) => is_mutated_static(inner),\n-        _ => false,\n-    }\n-}\n-\n-fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n-    let mut v = StaticMutVisitor {\n-        cx,\n-        mutates_static: false,\n-    };\n-    intravisit::walk_expr(&mut v, &body.value);\n-    v.mutates_static\n-}"}, {"sha": "2beb9bc94bf06397f203a9e9a1a849335083d353", "filename": "clippy_lints/src/functions/mod.rs", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmod.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,267 @@\n+mod must_use;\n+mod not_unsafe_ptr_arg_deref;\n+mod result_unit_err;\n+mod too_many_arguments;\n+mod too_many_lines;\n+\n+use rustc_hir as hir;\n+use rustc_hir::intravisit;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions with too many parameters.\n+    ///\n+    /// **Why is this bad?** Functions with lots of parameters are considered bad\n+    /// style and reduce readability (\u201cwhat does the 5th parameter mean?\u201d). Consider\n+    /// grouping some parameters into a new type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # struct Color;\n+    /// fn foo(x: u32, y: u32, name: &str, c: Color, w: f32, h: f32, a: f32, b: f32) {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    pub TOO_MANY_ARGUMENTS,\n+    complexity,\n+    \"functions with too many arguments\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions with a large amount of lines.\n+    ///\n+    /// **Why is this bad?** Functions with a lot of lines are harder to understand\n+    /// due to having to look at a larger amount of code to understand what the\n+    /// function is doing. Consider splitting the body of the function into\n+    /// multiple functions.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn im_too_long() {\n+    ///     println!(\"\");\n+    ///     // ... 100 more LoC\n+    ///     println!(\"\");\n+    /// }\n+    /// ```\n+    pub TOO_MANY_LINES,\n+    pedantic,\n+    \"functions with too many lines\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for public functions that dereference raw pointer\n+    /// arguments but are not marked `unsafe`.\n+    ///\n+    /// **Why is this bad?** The function should probably be marked `unsafe`, since\n+    /// for an arbitrary raw pointer, there is no way of telling for sure if it is\n+    /// valid.\n+    ///\n+    /// **Known problems:**\n+    ///\n+    /// * It does not check functions recursively so if the pointer is passed to a\n+    /// private non-`unsafe` function which does the dereferencing, the lint won't\n+    /// trigger.\n+    /// * It only checks for arguments whose type are raw pointers, not raw pointers\n+    /// got from an argument in some other way (`fn foo(bar: &[*const u8])` or\n+    /// `some_argument.get_raw_ptr()`).\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// pub fn foo(x: *const u8) {\n+    ///     println!(\"{}\", unsafe { *x });\n+    /// }\n+    ///\n+    /// // Good\n+    /// pub unsafe fn foo(x: *const u8) {\n+    ///     println!(\"{}\", unsafe { *x });\n+    /// }\n+    /// ```\n+    pub NOT_UNSAFE_PTR_ARG_DEREF,\n+    correctness,\n+    \"public functions dereferencing raw pointer arguments but not marked `unsafe`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for a [`#[must_use]`] attribute on\n+    /// unit-returning functions and methods.\n+    ///\n+    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n+    ///\n+    /// **Why is this bad?** Unit values are useless. The attribute is likely\n+    /// a remnant of a refactoring that removed the return type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// #[must_use]\n+    /// fn useless() { }\n+    /// ```\n+    pub MUST_USE_UNIT,\n+    style,\n+    \"`#[must_use]` attribute on a unit-returning function / method\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for a [`#[must_use]`] attribute without\n+    /// further information on functions and methods that return a type already\n+    /// marked as `#[must_use]`.\n+    ///\n+    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n+    ///\n+    /// **Why is this bad?** The attribute isn't needed. Not using the result\n+    /// will already be reported. Alternatively, one can add some text to the\n+    /// attribute to improve the lint message.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// #[must_use]\n+    /// fn double_must_use() -> Result<(), ()> {\n+    ///     unimplemented!();\n+    /// }\n+    /// ```\n+    pub DOUBLE_MUST_USE,\n+    style,\n+    \"`#[must_use]` attribute on a `#[must_use]`-returning function / method\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for public functions that have no\n+    /// [`#[must_use]`] attribute, but return something not already marked\n+    /// must-use, have no mutable arg and mutate no statics.\n+    ///\n+    /// [`#[must_use]`]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n+    ///\n+    /// **Why is this bad?** Not bad at all, this lint just shows places where\n+    /// you could add the attribute.\n+    ///\n+    /// **Known problems:** The lint only checks the arguments for mutable\n+    /// types without looking if they are actually changed. On the other hand,\n+    /// it also ignores a broad range of potentially interesting side effects,\n+    /// because we cannot decide whether the programmer intends the function to\n+    /// be called for the side effect or the result. Expect many false\n+    /// positives. At least we don't lint if the result type is unit or already\n+    /// `#[must_use]`.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// // this could be annotated with `#[must_use]`.\n+    /// fn id<T>(t: T) -> T { t }\n+    /// ```\n+    pub MUST_USE_CANDIDATE,\n+    pedantic,\n+    \"function or method that could take a `#[must_use]` attribute\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for public functions that return a `Result`\n+    /// with an `Err` type of `()`. It suggests using a custom type that\n+    /// implements `std::error::Error`.\n+    ///\n+    /// **Why is this bad?** Unit does not implement `Error` and carries no\n+    /// further information about what went wrong.\n+    ///\n+    /// **Known problems:** Of course, this lint assumes that `Result` is used\n+    /// for a fallible operation (which is after all the intended use). However\n+    /// code may opt to (mis)use it as a basic two-variant-enum. In that case,\n+    /// the suggestion is misguided, and the code should use a custom enum\n+    /// instead.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// pub fn read_u8() -> Result<u8, ()> { Err(()) }\n+    /// ```\n+    /// should become\n+    /// ```rust,should_panic\n+    /// use std::fmt;\n+    ///\n+    /// #[derive(Debug)]\n+    /// pub struct EndOfStream;\n+    ///\n+    /// impl fmt::Display for EndOfStream {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         write!(f, \"End of Stream\")\n+    ///     }\n+    /// }\n+    ///\n+    /// impl std::error::Error for EndOfStream { }\n+    ///\n+    /// pub fn read_u8() -> Result<u8, EndOfStream> { Err(EndOfStream) }\n+    ///# fn main() {\n+    ///#     read_u8().unwrap();\n+    ///# }\n+    /// ```\n+    ///\n+    /// Note that there are crates that simplify creating the error type, e.g.\n+    /// [`thiserror`](https://docs.rs/thiserror).\n+    pub RESULT_UNIT_ERR,\n+    style,\n+    \"public function returning `Result` with an `Err` type of `()`\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct Functions {\n+    too_many_arguments_threshold: u64,\n+    too_many_lines_threshold: u64,\n+}\n+\n+impl Functions {\n+    pub fn new(too_many_arguments_threshold: u64, too_many_lines_threshold: u64) -> Self {\n+        Self {\n+            too_many_arguments_threshold,\n+            too_many_lines_threshold,\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(Functions => [\n+    TOO_MANY_ARGUMENTS,\n+    TOO_MANY_LINES,\n+    NOT_UNSAFE_PTR_ARG_DEREF,\n+    MUST_USE_UNIT,\n+    DOUBLE_MUST_USE,\n+    MUST_USE_CANDIDATE,\n+    RESULT_UNIT_ERR,\n+]);\n+\n+impl<'tcx> LateLintPass<'tcx> for Functions {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        kind: intravisit::FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl<'_>,\n+        body: &'tcx hir::Body<'_>,\n+        span: Span,\n+        hir_id: hir::HirId,\n+    ) {\n+        too_many_arguments::check_fn(cx, kind, decl, span, hir_id, self.too_many_arguments_threshold);\n+        too_many_lines::check_fn(cx, span, body, self.too_many_lines_threshold);\n+        not_unsafe_ptr_arg_deref::check_fn(cx, kind, decl, body, hir_id);\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n+        must_use::check_item(cx, item);\n+        result_unit_err::check_item(cx, item);\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n+        must_use::check_impl_item(cx, item);\n+        result_unit_err::check_impl_item(cx, item);\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+        too_many_arguments::check_trait_item(cx, item, self.too_many_arguments_threshold);\n+        not_unsafe_ptr_arg_deref::check_trait_item(cx, item);\n+        must_use::check_trait_item(cx, item);\n+        result_unit_err::check_trait_item(cx, item);\n+    }\n+}"}, {"sha": "20288427b4a74550d2594ff36e4e3d2b284bf821", "filename": "clippy_lints/src/functions/must_use.rs", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,272 @@\n+use rustc_ast::ast::Attribute;\n+use rustc_errors::Applicability;\n+use rustc_hir::def_id::DefIdSet;\n+use rustc_hir::{self as hir, def::Res, intravisit, QPath};\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::{\n+    hir::map::Map,\n+    lint::in_external_macro,\n+    ty::{self, Ty},\n+};\n+use rustc_span::{sym, Span};\n+\n+use clippy_utils::attrs::is_proc_macro;\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::is_must_use_ty;\n+use clippy_utils::{match_def_path, must_use_attr, return_ty, trait_ref_of_method};\n+\n+use super::{DOUBLE_MUST_USE, MUST_USE_CANDIDATE, MUST_USE_UNIT};\n+\n+pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n+    let attrs = cx.tcx.hir().attrs(item.hir_id());\n+    let attr = must_use_attr(attrs);\n+    if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n+        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+        if let Some(attr) = attr {\n+            check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n+            return;\n+        } else if is_public && !is_proc_macro(cx.sess(), attrs) && !attrs.iter().any(|a| a.has_name(sym::no_mangle)) {\n+            check_must_use_candidate(\n+                cx,\n+                sig.decl,\n+                cx.tcx.hir().body(*body_id),\n+                item.span,\n+                item.hir_id(),\n+                item.span.with_hi(sig.decl.output.span().hi()),\n+                \"this function could have a `#[must_use]` attribute\",\n+            );\n+        }\n+    }\n+}\n+\n+pub(super) fn check_impl_item(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n+    if let hir::ImplItemKind::Fn(ref sig, ref body_id) = item.kind {\n+        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+        let attrs = cx.tcx.hir().attrs(item.hir_id());\n+        let attr = must_use_attr(attrs);\n+        if let Some(attr) = attr {\n+            check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n+        } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.hir_id()).is_none() {\n+            check_must_use_candidate(\n+                cx,\n+                sig.decl,\n+                cx.tcx.hir().body(*body_id),\n+                item.span,\n+                item.hir_id(),\n+                item.span.with_hi(sig.decl.output.span().hi()),\n+                \"this method could have a `#[must_use]` attribute\",\n+            );\n+        }\n+    }\n+}\n+\n+pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+    if let hir::TraitItemKind::Fn(ref sig, ref eid) = item.kind {\n+        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+\n+        let attrs = cx.tcx.hir().attrs(item.hir_id());\n+        let attr = must_use_attr(attrs);\n+        if let Some(attr) = attr {\n+            check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n+        } else if let hir::TraitFn::Provided(eid) = *eid {\n+            let body = cx.tcx.hir().body(eid);\n+            if attr.is_none() && is_public && !is_proc_macro(cx.sess(), attrs) {\n+                check_must_use_candidate(\n+                    cx,\n+                    sig.decl,\n+                    body,\n+                    item.span,\n+                    item.hir_id(),\n+                    item.span.with_hi(sig.decl.output.span().hi()),\n+                    \"this method could have a `#[must_use]` attribute\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn check_needless_must_use(\n+    cx: &LateContext<'_>,\n+    decl: &hir::FnDecl<'_>,\n+    item_id: hir::HirId,\n+    item_span: Span,\n+    fn_header_span: Span,\n+    attr: &Attribute,\n+) {\n+    if in_external_macro(cx.sess(), item_span) {\n+        return;\n+    }\n+    if returns_unit(decl) {\n+        span_lint_and_then(\n+            cx,\n+            MUST_USE_UNIT,\n+            fn_header_span,\n+            \"this unit-returning function has a `#[must_use]` attribute\",\n+            |diag| {\n+                diag.span_suggestion(\n+                    attr.span,\n+                    \"remove the attribute\",\n+                    \"\".into(),\n+                    Applicability::MachineApplicable,\n+                );\n+            },\n+        );\n+    } else if attr.value_str().is_none() && is_must_use_ty(cx, return_ty(cx, item_id)) {\n+        span_lint_and_help(\n+            cx,\n+            DOUBLE_MUST_USE,\n+            fn_header_span,\n+            \"this function has an empty `#[must_use]` attribute, but returns a type already marked as `#[must_use]`\",\n+            None,\n+            \"either add some descriptive text or remove the attribute\",\n+        );\n+    }\n+}\n+\n+fn check_must_use_candidate<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    decl: &'tcx hir::FnDecl<'_>,\n+    body: &'tcx hir::Body<'_>,\n+    item_span: Span,\n+    item_id: hir::HirId,\n+    fn_span: Span,\n+    msg: &str,\n+) {\n+    if has_mutable_arg(cx, body)\n+        || mutates_static(cx, body)\n+        || in_external_macro(cx.sess(), item_span)\n+        || returns_unit(decl)\n+        || !cx.access_levels.is_exported(item_id)\n+        || is_must_use_ty(cx, return_ty(cx, item_id))\n+    {\n+        return;\n+    }\n+    span_lint_and_then(cx, MUST_USE_CANDIDATE, fn_span, msg, |diag| {\n+        if let Some(snippet) = snippet_opt(cx, fn_span) {\n+            diag.span_suggestion(\n+                fn_span,\n+                \"add the attribute\",\n+                format!(\"#[must_use] {}\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    });\n+}\n+\n+fn returns_unit(decl: &hir::FnDecl<'_>) -> bool {\n+    match decl.output {\n+        hir::FnRetTy::DefaultReturn(_) => true,\n+        hir::FnRetTy::Return(ty) => match ty.kind {\n+            hir::TyKind::Tup(tys) => tys.is_empty(),\n+            hir::TyKind::Never => true,\n+            _ => false,\n+        },\n+    }\n+}\n+\n+fn has_mutable_arg(cx: &LateContext<'_>, body: &hir::Body<'_>) -> bool {\n+    let mut tys = DefIdSet::default();\n+    body.params.iter().any(|param| is_mutable_pat(cx, param.pat, &mut tys))\n+}\n+\n+fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut DefIdSet) -> bool {\n+    if let hir::PatKind::Wild = pat.kind {\n+        return false; // ignore `_` patterns\n+    }\n+    if cx.tcx.has_typeck_results(pat.hir_id.owner.to_def_id()) {\n+        is_mutable_ty(cx, cx.tcx.typeck(pat.hir_id.owner).pat_ty(pat), pat.span, tys)\n+    } else {\n+        false\n+    }\n+}\n+\n+static KNOWN_WRAPPER_TYS: &[&[&str]] = &[&[\"alloc\", \"rc\", \"Rc\"], &[\"std\", \"sync\", \"Arc\"]];\n+\n+fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &mut DefIdSet) -> bool {\n+    match *ty.kind() {\n+        // primitive types are never mutable\n+        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n+        ty::Adt(adt, substs) => {\n+            tys.insert(adt.did) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+                || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did, path))\n+                    && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n+        },\n+        ty::Tuple(substs) => substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n+        ty::Array(ty, _) | ty::Slice(ty) => is_mutable_ty(cx, ty, span, tys),\n+        ty::RawPtr(ty::TypeAndMut { ty, mutbl }) | ty::Ref(_, ty, mutbl) => {\n+            mutbl == hir::Mutability::Mut || is_mutable_ty(cx, ty, span, tys)\n+        },\n+        // calling something constitutes a side effect, so return true on all callables\n+        // also never calls need not be used, so return true for them, too\n+        _ => true,\n+    }\n+}\n+\n+struct StaticMutVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    mutates_static: bool,\n+}\n+\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+        use hir::ExprKind::{AddrOf, Assign, AssignOp, Call, MethodCall};\n+\n+        if self.mutates_static {\n+            return;\n+        }\n+        match expr.kind {\n+            Call(_, args) | MethodCall(_, _, args, _) => {\n+                let mut tys = DefIdSet::default();\n+                for arg in args {\n+                    if self.cx.tcx.has_typeck_results(arg.hir_id.owner.to_def_id())\n+                        && is_mutable_ty(\n+                            self.cx,\n+                            self.cx.tcx.typeck(arg.hir_id.owner).expr_ty(arg),\n+                            arg.span,\n+                            &mut tys,\n+                        )\n+                        && is_mutated_static(arg)\n+                    {\n+                        self.mutates_static = true;\n+                        return;\n+                    }\n+                    tys.clear();\n+                }\n+            },\n+            Assign(target, ..) | AssignOp(_, target, _) | AddrOf(_, hir::Mutability::Mut, target) => {\n+                self.mutates_static |= is_mutated_static(target)\n+            },\n+            _ => {},\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::None\n+    }\n+}\n+\n+fn is_mutated_static(e: &hir::Expr<'_>) -> bool {\n+    use hir::ExprKind::{Field, Index, Path};\n+\n+    match e.kind {\n+        Path(QPath::Resolved(_, path)) => !matches!(path.res, Res::Local(_)),\n+        Path(_) => true,\n+        Field(inner, _) | Index(inner, _) => is_mutated_static(inner),\n+        _ => false,\n+    }\n+}\n+\n+fn mutates_static<'tcx>(cx: &LateContext<'tcx>, body: &'tcx hir::Body<'_>) -> bool {\n+    let mut v = StaticMutVisitor {\n+        cx,\n+        mutates_static: false,\n+    };\n+    intravisit::walk_expr(&mut v, &body.value);\n+    v.mutates_static\n+}"}, {"sha": "b8ea69908665655e1c4ad7eeee612cfd1d2d8d21", "filename": "clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,124 @@\n+use rustc_hir::{self as hir, intravisit, HirIdSet};\n+use rustc_lint::LateContext;\n+use rustc_middle::{hir::map::Map, ty};\n+\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::type_is_unsafe_function;\n+use clippy_utils::{iter_input_pats, path_to_local};\n+\n+use super::NOT_UNSAFE_PTR_ARG_DEREF;\n+\n+pub(super) fn check_fn(\n+    cx: &LateContext<'tcx>,\n+    kind: intravisit::FnKind<'tcx>,\n+    decl: &'tcx hir::FnDecl<'tcx>,\n+    body: &'tcx hir::Body<'tcx>,\n+    hir_id: hir::HirId,\n+) {\n+    let unsafety = match kind {\n+        intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }, _) => unsafety,\n+        intravisit::FnKind::Method(_, sig, _) => sig.header.unsafety,\n+        intravisit::FnKind::Closure => return,\n+    };\n+\n+    check_raw_ptr(cx, unsafety, decl, body, hir_id);\n+}\n+\n+pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+    if let hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(eid)) = item.kind {\n+        let body = cx.tcx.hir().body(eid);\n+        check_raw_ptr(cx, sig.header.unsafety, sig.decl, body, item.hir_id());\n+    }\n+}\n+\n+fn check_raw_ptr(\n+    cx: &LateContext<'tcx>,\n+    unsafety: hir::Unsafety,\n+    decl: &'tcx hir::FnDecl<'tcx>,\n+    body: &'tcx hir::Body<'tcx>,\n+    hir_id: hir::HirId,\n+) {\n+    let expr = &body.value;\n+    if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(hir_id) {\n+        let raw_ptrs = iter_input_pats(decl, body)\n+            .zip(decl.inputs.iter())\n+            .filter_map(|(arg, ty)| raw_ptr_arg(arg, ty))\n+            .collect::<HirIdSet>();\n+\n+        if !raw_ptrs.is_empty() {\n+            let typeck_results = cx.tcx.typeck_body(body.id());\n+            let mut v = DerefVisitor {\n+                cx,\n+                ptrs: raw_ptrs,\n+                typeck_results,\n+            };\n+\n+            intravisit::walk_expr(&mut v, expr);\n+        }\n+    }\n+}\n+\n+fn raw_ptr_arg(arg: &hir::Param<'_>, ty: &hir::Ty<'_>) -> Option<hir::HirId> {\n+    if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.kind, &ty.kind) {\n+        Some(id)\n+    } else {\n+        None\n+    }\n+}\n+\n+struct DerefVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    ptrs: HirIdSet,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+}\n+\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+        match expr.kind {\n+            hir::ExprKind::Call(f, args) => {\n+                let ty = self.typeck_results.expr_ty(f);\n+\n+                if type_is_unsafe_function(self.cx, ty) {\n+                    for arg in args {\n+                        self.check_arg(arg);\n+                    }\n+                }\n+            },\n+            hir::ExprKind::MethodCall(_, _, args, _) => {\n+                let def_id = self.typeck_results.type_dependent_def_id(expr.hir_id).unwrap();\n+                let base_type = self.cx.tcx.type_of(def_id);\n+\n+                if type_is_unsafe_function(self.cx, base_type) {\n+                    for arg in args {\n+                        self.check_arg(arg);\n+                    }\n+                }\n+            },\n+            hir::ExprKind::Unary(hir::UnOp::Deref, ptr) => self.check_arg(ptr),\n+            _ => (),\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::None\n+    }\n+}\n+\n+impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n+    fn check_arg(&self, ptr: &hir::Expr<'_>) {\n+        if let Some(id) = path_to_local(ptr) {\n+            if self.ptrs.contains(&id) {\n+                span_lint(\n+                    self.cx,\n+                    NOT_UNSAFE_PTR_ARG_DEREF,\n+                    ptr.span,\n+                    \"this public function dereferences a raw pointer but is not marked `unsafe`\",\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "c073f312d386f3fc0d0155e7f9693bd4912e441b", "filename": "clippy_lints/src/functions/result_unit_err.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,66 @@\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty;\n+use rustc_span::{sym, Span};\n+use rustc_typeck::hir_ty_to_ty;\n+\n+use if_chain::if_chain;\n+\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::trait_ref_of_method;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+\n+use super::RESULT_UNIT_ERR;\n+\n+pub(super) fn check_item(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n+    if let hir::ItemKind::Fn(ref sig, ref _generics, _) = item.kind {\n+        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+        if is_public {\n+            check_result_unit_err(cx, sig.decl, item.span, fn_header_span);\n+        }\n+    }\n+}\n+\n+pub(super) fn check_impl_item(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n+    if let hir::ImplItemKind::Fn(ref sig, _) = item.kind {\n+        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+        if is_public && trait_ref_of_method(cx, item.hir_id()).is_none() {\n+            check_result_unit_err(cx, sig.decl, item.span, fn_header_span);\n+        }\n+    }\n+}\n+\n+pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+    if let hir::TraitItemKind::Fn(ref sig, _) = item.kind {\n+        let is_public = cx.access_levels.is_exported(item.hir_id());\n+        let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+        if is_public {\n+            check_result_unit_err(cx, sig.decl, item.span, fn_header_span);\n+        }\n+    }\n+}\n+\n+fn check_result_unit_err(cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, item_span: Span, fn_header_span: Span) {\n+    if_chain! {\n+        if !in_external_macro(cx.sess(), item_span);\n+        if let hir::FnRetTy::Return(ty) = decl.output;\n+        let ty = hir_ty_to_ty(cx.tcx, ty);\n+        if is_type_diagnostic_item(cx, ty, sym::result_type);\n+        if let ty::Adt(_, substs) = ty.kind();\n+        let err_ty = substs.type_at(1);\n+        if err_ty.is_unit();\n+        then {\n+            span_lint_and_help(\n+                cx,\n+                RESULT_UNIT_ERR,\n+                fn_header_span,\n+                \"this returns a `Result<_, ()>`\",\n+                None,\n+                \"use a custom `Error` type instead\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "63a14d8d4cde897a04387e97e9649ea30ead2d63", "filename": "clippy_lints/src/functions/too_many_arguments.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_arguments.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,73 @@\n+use rustc_hir::{self as hir, intravisit};\n+use rustc_lint::LateContext;\n+use rustc_span::Span;\n+use rustc_target::spec::abi::Abi;\n+\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::is_trait_impl_item;\n+\n+use super::TOO_MANY_ARGUMENTS;\n+\n+pub(super) fn check_fn(\n+    cx: &LateContext<'tcx>,\n+    kind: intravisit::FnKind<'tcx>,\n+    decl: &'tcx hir::FnDecl<'_>,\n+    span: Span,\n+    hir_id: hir::HirId,\n+    too_many_arguments_threshold: u64,\n+) {\n+    // don't warn for implementations, it's not their fault\n+    if !is_trait_impl_item(cx, hir_id) {\n+        // don't lint extern functions decls, it's not their fault either\n+        match kind {\n+            intravisit::FnKind::Method(\n+                _,\n+                &hir::FnSig {\n+                    header: hir::FnHeader { abi: Abi::Rust, .. },\n+                    ..\n+                },\n+                _,\n+            )\n+            | intravisit::FnKind::ItemFn(_, _, hir::FnHeader { abi: Abi::Rust, .. }, _) => check_arg_number(\n+                cx,\n+                decl,\n+                span.with_hi(decl.output.span().hi()),\n+                too_many_arguments_threshold,\n+            ),\n+            _ => {},\n+        }\n+    }\n+}\n+\n+pub(super) fn check_trait_item(\n+    cx: &LateContext<'tcx>,\n+    item: &'tcx hir::TraitItem<'_>,\n+    too_many_arguments_threshold: u64,\n+) {\n+    if let hir::TraitItemKind::Fn(ref sig, _) = item.kind {\n+        // don't lint extern functions decls, it's not their fault\n+        if sig.header.abi == Abi::Rust {\n+            check_arg_number(\n+                cx,\n+                sig.decl,\n+                item.span.with_hi(sig.decl.output.span().hi()),\n+                too_many_arguments_threshold,\n+            );\n+        }\n+    }\n+}\n+\n+fn check_arg_number(cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, fn_span: Span, too_many_arguments_threshold: u64) {\n+    let args = decl.inputs.len() as u64;\n+    if args > too_many_arguments_threshold {\n+        span_lint(\n+            cx,\n+            TOO_MANY_ARGUMENTS,\n+            fn_span,\n+            &format!(\n+                \"this function has too many arguments ({}/{})\",\n+                args, too_many_arguments_threshold\n+            ),\n+        );\n+    }\n+}"}, {"sha": "aa5494d5a7d2c74b54f251f4325b2cd52df7aabd", "filename": "clippy_lints/src/functions/too_many_lines.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,68 @@\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_span::Span;\n+\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::source::snippet;\n+\n+use super::TOO_MANY_LINES;\n+\n+pub(super) fn check_fn(cx: &LateContext<'_>, span: Span, body: &'tcx hir::Body<'_>, too_many_lines_threshold: u64) {\n+    if in_external_macro(cx.sess(), span) {\n+        return;\n+    }\n+\n+    let code_snippet = snippet(cx, body.value.span, \"..\");\n+    let mut line_count: u64 = 0;\n+    let mut in_comment = false;\n+    let mut code_in_line;\n+\n+    // Skip the surrounding function decl.\n+    let start_brace_idx = code_snippet.find('{').map_or(0, |i| i + 1);\n+    let end_brace_idx = code_snippet.rfind('}').unwrap_or_else(|| code_snippet.len());\n+    let function_lines = code_snippet[start_brace_idx..end_brace_idx].lines();\n+\n+    for mut line in function_lines {\n+        code_in_line = false;\n+        loop {\n+            line = line.trim_start();\n+            if line.is_empty() {\n+                break;\n+            }\n+            if in_comment {\n+                if let Some(i) = line.find(\"*/\") {\n+                    line = &line[i + 2..];\n+                    in_comment = false;\n+                    continue;\n+                }\n+            } else {\n+                let multi_idx = line.find(\"/*\").unwrap_or_else(|| line.len());\n+                let single_idx = line.find(\"//\").unwrap_or_else(|| line.len());\n+                code_in_line |= multi_idx > 0 && single_idx > 0;\n+                // Implies multi_idx is below line.len()\n+                if multi_idx < single_idx {\n+                    line = &line[multi_idx + 2..];\n+                    in_comment = true;\n+                    continue;\n+                }\n+            }\n+            break;\n+        }\n+        if code_in_line {\n+            line_count += 1;\n+        }\n+    }\n+\n+    if line_count > too_many_lines_threshold {\n+        span_lint(\n+            cx,\n+            TOO_MANY_LINES,\n+            span,\n+            &format!(\n+                \"this function has too many lines ({}/{})\",\n+                line_count, too_many_lines_threshold\n+            ),\n+        )\n+    }\n+}"}, {"sha": "3707e792177d3317408cb59dcf6c9c51022011d5", "filename": "clippy_lints/src/get_last_with_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fget_last_with_len.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> LateLintPass<'tcx> for GetLastWithLen {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // Is a method call\n-            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n \n             // Method name is \"get\"\n             if path.ident.name == sym!(get);"}, {"sha": "366b3b46a8aecdc0f9939b68f7424c5dc3083924", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -35,7 +35,7 @@ impl<'tcx> LateLintPass<'tcx> for IdentityOp {\n         if e.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::Binary(cmp, ref left, ref right) = e.kind {\n+        if let ExprKind::Binary(cmp, left, right) = e.kind {\n             if is_allowed(cx, cmp, left, right) {\n                 return;\n             }"}, {"sha": "f661f7ede821a6d486a33448eab7c56fd8e106da", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -55,16 +55,16 @@ impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n             cx,\n         };\n         if let ExprKind::Match(\n-            ref op,\n-            ref arms,\n+            op,\n+            arms,\n             MatchSource::IfLetDesugar {\n                 contains_else_clause: true,\n             },\n         ) = ex.kind\n         {\n             op_visit.visit_expr(op);\n             if op_visit.mutex_lock_called {\n-                for arm in *arms {\n+                for arm in arms {\n                     arm_visit.visit_arm(arm);\n                 }\n \n@@ -94,13 +94,10 @@ impl<'tcx> Visitor<'tcx> for OppVisitor<'_, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let Some(mutex) = is_mutex_lock_call(self.cx, expr);\n-            then {\n-                self.found_mutex = Some(mutex);\n-                self.mutex_lock_called = true;\n-                return;\n-            }\n+        if let Some(mutex) = is_mutex_lock_call(self.cx, expr) {\n+            self.found_mutex = Some(mutex);\n+            self.mutex_lock_called = true;\n+            return;\n         }\n         visit::walk_expr(self, expr);\n     }\n@@ -121,13 +118,10 @@ impl<'tcx> Visitor<'tcx> for ArmVisitor<'_, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        if_chain! {\n-            if let Some(mutex) = is_mutex_lock_call(self.cx, expr);\n-            then {\n-                self.found_mutex = Some(mutex);\n-                self.mutex_lock_called = true;\n-                return;\n-            }\n+        if let Some(mutex) = is_mutex_lock_call(self.cx, expr) {\n+            self.found_mutex = Some(mutex);\n+            self.mutex_lock_called = true;\n+            return;\n         }\n         visit::walk_expr(self, expr);\n     }"}, {"sha": "611da3744eeeeba2b4fabbaa368d01a6d0475cb8", "filename": "clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -44,9 +44,9 @@ declare_lint_pass!(OkIfLet => [IF_LET_SOME_RESULT]);\n impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! { //begin checking variables\n-            if let ExprKind::Match(ref op, ref body, MatchSource::IfLetDesugar { .. }) = expr.kind; //test if expr is if let\n-            if let ExprKind::MethodCall(_, ok_span, ref result_types, _) = op.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n-            if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pat.kind; //get operation\n+            if let ExprKind::Match(op, body, MatchSource::IfLetDesugar { .. }) = expr.kind; //test if expr is if let\n+            if let ExprKind::MethodCall(_, ok_span, result_types, _) = op.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n+            if let PatKind::TupleStruct(QPath::Resolved(_, x), y, _)  = body[0].pat.kind; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&result_types[0]), sym::result_type);\n             if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";"}, {"sha": "ee16519692f9a8b83e64728b2270ec316569edf8", "filename": "clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -72,15 +72,15 @@ impl LateLintPass<'_> for IfThenSomeElseNone {\n         }\n \n         if_chain! {\n-            if let ExprKind::If(ref cond, ref then, Some(ref els)) = expr.kind;\n-            if let ExprKind::Block(ref then_block, _) = then.kind;\n-            if let Some(ref then_expr) = then_block.expr;\n-            if let ExprKind::Call(ref then_call, [then_arg]) = then_expr.kind;\n+            if let ExprKind::If(cond, then, Some(els)) = expr.kind;\n+            if let ExprKind::Block(then_block, _) = then.kind;\n+            if let Some(then_expr) = then_block.expr;\n+            if let ExprKind::Call(then_call, [then_arg]) = then_expr.kind;\n             if let ExprKind::Path(ref then_call_qpath) = then_call.kind;\n             if match_qpath(then_call_qpath, &clippy_utils::paths::OPTION_SOME);\n-            if let ExprKind::Block(ref els_block, _) = els.kind;\n+            if let ExprKind::Block(els_block, _) = els.kind;\n             if els_block.stmts.is_empty();\n-            if let Some(ref els_expr) = els_block.expr;\n+            if let Some(els_expr) = els_block.expr;\n             if let ExprKind::Path(ref els_call_qpath) = els_expr.kind;\n             if match_qpath(els_call_qpath, &clippy_utils::paths::OPTION_NONE);\n             then {"}, {"sha": "77a38544edc87151198181708d4d83f1d8261e19", "filename": "clippy_lints/src/implicit_hasher.rs", "status": "added", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,377 @@\n+#![allow(rustc::default_hash_types)]\n+\n+use std::borrow::Cow;\n+use std::collections::BTreeMap;\n+\n+use rustc_errors::DiagnosticBuilder;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, NestedVisitorMap, Visitor};\n+use rustc_hir::{Body, Expr, ExprKind, GenericArg, Item, ItemKind, QPath, TyKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::{Ty, TyS, TypeckResults};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::sym;\n+use rustc_typeck::hir_ty_to_ty;\n+\n+use if_chain::if_chain;\n+\n+use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n+use clippy_utils::paths;\n+use clippy_utils::source::{snippet, snippet_opt};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{differing_macro_contexts, match_path};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for public `impl` or `fn` missing generalization\n+    /// over different hashers and implicitly defaulting to the default hashing\n+    /// algorithm (`SipHash`).\n+    ///\n+    /// **Why is this bad?** `HashMap` or `HashSet` with custom hashers cannot be\n+    /// used with them.\n+    ///\n+    /// **Known problems:** Suggestions for replacing constructors can contain\n+    /// false-positives. Also applying suggestions can require modification of other\n+    /// pieces of code, possibly including external crates.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// # use std::hash::{Hash, BuildHasher};\n+    /// # trait Serialize {};\n+    /// impl<K: Hash + Eq, V> Serialize for HashMap<K, V> { }\n+    ///\n+    /// pub fn foo(map: &mut HashMap<i32, i32>) { }\n+    /// ```\n+    /// could be rewritten as\n+    /// ```rust\n+    /// # use std::collections::HashMap;\n+    /// # use std::hash::{Hash, BuildHasher};\n+    /// # trait Serialize {};\n+    /// impl<K: Hash + Eq, V, S: BuildHasher> Serialize for HashMap<K, V, S> { }\n+    ///\n+    /// pub fn foo<S: BuildHasher>(map: &mut HashMap<i32, i32, S>) { }\n+    /// ```\n+    pub IMPLICIT_HASHER,\n+    pedantic,\n+    \"missing generalization over different hashers\"\n+}\n+\n+declare_lint_pass!(ImplicitHasher => [IMPLICIT_HASHER]);\n+\n+impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n+    #[allow(clippy::cast_possible_truncation, clippy::too_many_lines)]\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        use rustc_span::BytePos;\n+\n+        fn suggestion<'tcx>(\n+            cx: &LateContext<'tcx>,\n+            diag: &mut DiagnosticBuilder<'_>,\n+            generics_span: Span,\n+            generics_suggestion_span: Span,\n+            target: &ImplicitHasherType<'_>,\n+            vis: ImplicitHasherConstructorVisitor<'_, '_, '_>,\n+        ) {\n+            let generics_snip = snippet(cx, generics_span, \"\");\n+            // trim `<` `>`\n+            let generics_snip = if generics_snip.is_empty() {\n+                \"\"\n+            } else {\n+                &generics_snip[1..generics_snip.len() - 1]\n+            };\n+\n+            multispan_sugg(\n+                diag,\n+                \"consider adding a type parameter\",\n+                vec![\n+                    (\n+                        generics_suggestion_span,\n+                        format!(\n+                            \"<{}{}S: ::std::hash::BuildHasher{}>\",\n+                            generics_snip,\n+                            if generics_snip.is_empty() { \"\" } else { \", \" },\n+                            if vis.suggestions.is_empty() {\n+                                \"\"\n+                            } else {\n+                                // request users to add `Default` bound so that generic constructors can be used\n+                                \" + Default\"\n+                            },\n+                        ),\n+                    ),\n+                    (\n+                        target.span(),\n+                        format!(\"{}<{}, S>\", target.type_name(), target.type_arguments(),),\n+                    ),\n+                ],\n+            );\n+\n+            if !vis.suggestions.is_empty() {\n+                multispan_sugg(diag, \"...and use generic constructor\", vis.suggestions);\n+            }\n+        }\n+\n+        if !cx.access_levels.is_exported(item.hir_id()) {\n+            return;\n+        }\n+\n+        match item.kind {\n+            ItemKind::Impl(ref impl_) => {\n+                let mut vis = ImplicitHasherTypeVisitor::new(cx);\n+                vis.visit_ty(impl_.self_ty);\n+\n+                for target in &vis.found {\n+                    if differing_macro_contexts(item.span, target.span()) {\n+                        return;\n+                    }\n+\n+                    let generics_suggestion_span = impl_.generics.span.substitute_dummy({\n+                        let pos = snippet_opt(cx, item.span.until(target.span()))\n+                            .and_then(|snip| Some(item.span.lo() + BytePos(snip.find(\"impl\")? as u32 + 4)));\n+                        if let Some(pos) = pos {\n+                            Span::new(pos, pos, item.span.data().ctxt)\n+                        } else {\n+                            return;\n+                        }\n+                    });\n+\n+                    let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n+                    for item in impl_.items.iter().map(|item| cx.tcx.hir().impl_item(item.id)) {\n+                        ctr_vis.visit_impl_item(item);\n+                    }\n+\n+                    span_lint_and_then(\n+                        cx,\n+                        IMPLICIT_HASHER,\n+                        target.span(),\n+                        &format!(\n+                            \"impl for `{}` should be generalized over different hashers\",\n+                            target.type_name()\n+                        ),\n+                        move |diag| {\n+                            suggestion(cx, diag, impl_.generics.span, generics_suggestion_span, target, ctr_vis);\n+                        },\n+                    );\n+                }\n+            },\n+            ItemKind::Fn(ref sig, ref generics, body_id) => {\n+                let body = cx.tcx.hir().body(body_id);\n+\n+                for ty in sig.decl.inputs {\n+                    let mut vis = ImplicitHasherTypeVisitor::new(cx);\n+                    vis.visit_ty(ty);\n+\n+                    for target in &vis.found {\n+                        if in_external_macro(cx.sess(), generics.span) {\n+                            continue;\n+                        }\n+                        let generics_suggestion_span = generics.span.substitute_dummy({\n+                            let pos = snippet_opt(cx, item.span.until(body.params[0].pat.span))\n+                                .and_then(|snip| {\n+                                    let i = snip.find(\"fn\")?;\n+                                    Some(item.span.lo() + BytePos((i + (&snip[i..]).find('(')?) as u32))\n+                                })\n+                                .expect(\"failed to create span for type parameters\");\n+                            Span::new(pos, pos, item.span.data().ctxt)\n+                        });\n+\n+                        let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n+                        ctr_vis.visit_body(body);\n+\n+                        span_lint_and_then(\n+                            cx,\n+                            IMPLICIT_HASHER,\n+                            target.span(),\n+                            &format!(\n+                                \"parameter of type `{}` should be generalized over different hashers\",\n+                                target.type_name()\n+                            ),\n+                            move |diag| {\n+                                suggestion(cx, diag, generics.span, generics_suggestion_span, target, ctr_vis);\n+                            },\n+                        );\n+                    }\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+enum ImplicitHasherType<'tcx> {\n+    HashMap(Span, Ty<'tcx>, Cow<'static, str>, Cow<'static, str>),\n+    HashSet(Span, Ty<'tcx>, Cow<'static, str>),\n+}\n+\n+impl<'tcx> ImplicitHasherType<'tcx> {\n+    /// Checks that `ty` is a target type without a `BuildHasher`.\n+    fn new(cx: &LateContext<'tcx>, hir_ty: &hir::Ty<'_>) -> Option<Self> {\n+        if let TyKind::Path(QPath::Resolved(None, path)) = hir_ty.kind {\n+            let params: Vec<_> = path\n+                .segments\n+                .last()\n+                .as_ref()?\n+                .args\n+                .as_ref()?\n+                .args\n+                .iter()\n+                .filter_map(|arg| match arg {\n+                    GenericArg::Type(ty) => Some(ty),\n+                    _ => None,\n+                })\n+                .collect();\n+            let params_len = params.len();\n+\n+            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+\n+            if is_type_diagnostic_item(cx, ty, sym::hashmap_type) && params_len == 2 {\n+                Some(ImplicitHasherType::HashMap(\n+                    hir_ty.span,\n+                    ty,\n+                    snippet(cx, params[0].span, \"K\"),\n+                    snippet(cx, params[1].span, \"V\"),\n+                ))\n+            } else if is_type_diagnostic_item(cx, ty, sym::hashset_type) && params_len == 1 {\n+                Some(ImplicitHasherType::HashSet(\n+                    hir_ty.span,\n+                    ty,\n+                    snippet(cx, params[0].span, \"T\"),\n+                ))\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn type_name(&self) -> &'static str {\n+        match *self {\n+            ImplicitHasherType::HashMap(..) => \"HashMap\",\n+            ImplicitHasherType::HashSet(..) => \"HashSet\",\n+        }\n+    }\n+\n+    fn type_arguments(&self) -> String {\n+        match *self {\n+            ImplicitHasherType::HashMap(.., ref k, ref v) => format!(\"{}, {}\", k, v),\n+            ImplicitHasherType::HashSet(.., ref t) => format!(\"{}\", t),\n+        }\n+    }\n+\n+    fn ty(&self) -> Ty<'tcx> {\n+        match *self {\n+            ImplicitHasherType::HashMap(_, ty, ..) | ImplicitHasherType::HashSet(_, ty, ..) => ty,\n+        }\n+    }\n+\n+    fn span(&self) -> Span {\n+        match *self {\n+            ImplicitHasherType::HashMap(span, ..) | ImplicitHasherType::HashSet(span, ..) => span,\n+        }\n+    }\n+}\n+\n+struct ImplicitHasherTypeVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    found: Vec<ImplicitHasherType<'tcx>>,\n+}\n+\n+impl<'a, 'tcx> ImplicitHasherTypeVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> Self {\n+        Self { cx, found: vec![] }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ImplicitHasherTypeVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty<'_>) {\n+        if let Some(target) = ImplicitHasherType::new(self.cx, t) {\n+            self.found.push(target);\n+        }\n+\n+        walk_ty(self, t);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Looks for default-hasher-dependent constructors like `HashMap::new`.\n+struct ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n+    target: &'b ImplicitHasherType<'tcx>,\n+    suggestions: BTreeMap<Span, String>,\n+}\n+\n+impl<'a, 'b, 'tcx> ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>, target: &'b ImplicitHasherType<'tcx>) -> Self {\n+        Self {\n+            cx,\n+            maybe_typeck_results: cx.maybe_typeck_results(),\n+            target,\n+            suggestions: BTreeMap::new(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_body(&mut self, body: &'tcx Body<'_>) {\n+        let old_maybe_typeck_results = self.maybe_typeck_results.replace(self.cx.tcx.typeck_body(body.id()));\n+        walk_body(self, body);\n+        self.maybe_typeck_results = old_maybe_typeck_results;\n+    }\n+\n+    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Call(fun, args) = e.kind;\n+            if let ExprKind::Path(QPath::TypeRelative(ty, method)) = fun.kind;\n+            if let TyKind::Path(QPath::Resolved(None, ty_path)) = ty.kind;\n+            then {\n+                if !TyS::same_type(self.target.ty(), self.maybe_typeck_results.unwrap().expr_ty(e)) {\n+                    return;\n+                }\n+\n+                if match_path(ty_path, &paths::HASHMAP) {\n+                    if method.ident.name == sym::new {\n+                        self.suggestions\n+                            .insert(e.span, \"HashMap::default()\".to_string());\n+                    } else if method.ident.name == sym!(with_capacity) {\n+                        self.suggestions.insert(\n+                            e.span,\n+                            format!(\n+                                \"HashMap::with_capacity_and_hasher({}, Default::default())\",\n+                                snippet(self.cx, args[0].span, \"capacity\"),\n+                            ),\n+                        );\n+                    }\n+                } else if match_path(ty_path, &paths::HASHSET) {\n+                    if method.ident.name == sym::new {\n+                        self.suggestions\n+                            .insert(e.span, \"HashSet::default()\".to_string());\n+                    } else if method.ident.name == sym!(with_capacity) {\n+                        self.suggestions.insert(\n+                            e.span,\n+                            format!(\n+                                \"HashSet::with_capacity_and_hasher({}, Default::default())\",\n+                                snippet(self.cx, args[0].span, \"capacity\"),\n+                            ),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        walk_expr(self, e);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+}"}, {"sha": "6b379b0d59b2bb0c807d23687de2c578524cb12a", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -100,10 +100,10 @@ fn expr_match(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n             if check_all_arms {\n                 for arm in arms {\n-                    expr_match(cx, &arm.body);\n+                    expr_match(cx, arm.body);\n                 }\n             } else {\n-                expr_match(cx, &arms.first().expect(\"`if let` doesn't have a single arm\").body);\n+                expr_match(cx, arms.first().expect(\"`if let` doesn't have a single arm\").body);\n             }\n         },\n         // skip if it already has a return statement"}, {"sha": "cba3183e86950aaf83e8e9cbfe6a0e759a572b42", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -46,21 +46,21 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n             if let ExprKind::If(cond, then, None) = &expr.kind;\n \n             // Check if the conditional expression is a binary operation\n-            if let ExprKind::Binary(ref cond_op, ref cond_left, ref cond_right) = cond.kind;\n+            if let ExprKind::Binary(ref cond_op, cond_left, cond_right) = cond.kind;\n \n             // Ensure that the binary operator is >, != and <\n             if BinOpKind::Ne == cond_op.node || BinOpKind::Gt == cond_op.node || BinOpKind::Lt == cond_op.node;\n \n             // Check if the true condition block has only one statement\n-            if let ExprKind::Block(ref block, _) = then.kind;\n+            if let ExprKind::Block(block, _) = then.kind;\n             if block.stmts.len() == 1 && block.expr.is_none();\n \n             // Check if assign operation is done\n-            if let StmtKind::Semi(ref e) = block.stmts[0].kind;\n+            if let StmtKind::Semi(e) = block.stmts[0].kind;\n             if let Some(target) = subtracts_one(cx, e);\n \n             // Extracting out the variable name\n-            if let ExprKind::Path(QPath::Resolved(_, ref ares_path)) = target.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, ares_path)) = target.kind;\n \n             then {\n                 // Handle symmetric conditions in the if statement\n@@ -104,7 +104,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                             print_lint_and_sugg(cx, &var_name, expr);\n                         };\n                     },\n-                    ExprKind::Call(ref func, _) => {\n+                    ExprKind::Call(func, _) => {\n                         if let ExprKind::Path(ref cond_num_path) = func.kind {\n                             if INT_TYPES.iter().any(|int_type| match_qpath(cond_num_path, &[int_type, \"min_value\"])) {\n                                 print_lint_and_sugg(cx, &var_name, expr);\n@@ -120,7 +120,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n \n fn subtracts_one<'a>(cx: &LateContext<'_>, expr: &Expr<'a>) -> Option<&'a Expr<'a>> {\n     match expr.kind {\n-        ExprKind::AssignOp(ref op1, ref target, ref value) => {\n+        ExprKind::AssignOp(ref op1, target, value) => {\n             if_chain! {\n                 if BinOpKind::Sub == op1.node;\n                 // Check if literal being subtracted is one\n@@ -133,9 +133,9 @@ fn subtracts_one<'a>(cx: &LateContext<'_>, expr: &Expr<'a>) -> Option<&'a Expr<'\n                 }\n             }\n         },\n-        ExprKind::Assign(ref target, ref value, _) => {\n+        ExprKind::Assign(target, value, _) => {\n             if_chain! {\n-                if let ExprKind::Binary(ref op1, ref left1, ref right1) = value.kind;\n+                if let ExprKind::Binary(ref op1, left1, right1) = value.kind;\n                 if BinOpKind::Sub == op1.node;\n \n                 if SpanlessEq::new(cx).eq_expr(left1, target);"}, {"sha": "1c54599abc40558fd6306d49023ee89c8de7c64e", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -88,7 +88,7 @@ declare_lint_pass!(IndexingSlicing => [INDEXING_SLICING, OUT_OF_BOUNDS_INDEXING]\n \n impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Index(ref array, ref index) = &expr.kind {\n+        if let ExprKind::Index(array, index) = &expr.kind {\n             let ty = cx.typeck_results().expr_ty(array).peel_refs();\n             if let Some(range) = higher::range(index) {\n                 // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]"}, {"sha": "bbb4ddc613af5ca60cdd773dba6b5a193d042b41", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -139,7 +139,7 @@ const HEURISTICS: [(&str, usize, Heuristic, Finiteness); 19] = [\n \n fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n-        ExprKind::MethodCall(ref method, _, ref args, _) => {\n+        ExprKind::MethodCall(method, _, args, _) => {\n             for &(name, len, heuristic, cap) in &HEURISTICS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n                     return (match heuristic {\n@@ -159,9 +159,9 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n             }\n             Finite\n         },\n-        ExprKind::Block(ref block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n-        ExprKind::Box(ref e) | ExprKind::AddrOf(BorrowKind::Ref, _, ref e) => is_infinite(cx, e),\n-        ExprKind::Call(ref path, _) => {\n+        ExprKind::Block(block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n+        ExprKind::Box(e) | ExprKind::AddrOf(BorrowKind::Ref, _, e) => is_infinite(cx, e),\n+        ExprKind::Call(path, _) => {\n             if let ExprKind::Path(ref qpath) = path.kind {\n                 match_qpath(qpath, &paths::REPEAT).into()\n             } else {\n@@ -215,7 +215,7 @@ const INFINITE_COLLECTORS: [&[&str]; 8] = [\n \n fn complete_infinite_iter(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n-        ExprKind::MethodCall(ref method, _, ref args, _) => {\n+        ExprKind::MethodCall(method, _, args, _) => {\n             for &(name, len) in &COMPLETING_METHODS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n                     return is_infinite(cx, &args[0]);\n@@ -240,7 +240,7 @@ fn complete_infinite_iter(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n                 }\n             }\n         },\n-        ExprKind::Binary(op, ref l, ref r) => {\n+        ExprKind::Binary(op, l, r) => {\n             if op.node.is_comparison() {\n                 return is_infinite(cx, l).and(is_infinite(cx, r)).and(MaybeInfinite);\n             }"}, {"sha": "c31013e49be59b54e4851ba81e5ae202d7f30ab6", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -2,7 +2,7 @@\n \n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::in_macro;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::DefIdMap;\n use rustc_hir::{def_id, Crate, Impl, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -43,7 +43,7 @@ declare_clippy_lint! {\n #[allow(clippy::module_name_repetitions)]\n #[derive(Default)]\n pub struct MultipleInherentImpl {\n-    impls: FxHashMap<def_id::DefId, Span>,\n+    impls: DefIdMap<Span>,\n }\n \n impl_lint_pass!(MultipleInherentImpl => [MULTIPLE_INHERENT_IMPL]);"}, {"sha": "c67c02eefa5f6b680eb704e3f9b7d0ac03bccc6b", "filename": "clippy_lints/src/invalid_upcast_comparisons.rs", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,221 @@\n+use std::cmp::Ordering;\n+\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, IntTy, UintTy};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+use rustc_target::abi::LayoutOf;\n+\n+use crate::consts::{constant, Constant};\n+\n+use clippy_utils::comparisons::Rel;\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::source::snippet;\n+use clippy_utils::{comparisons, sext};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for comparisons where the relation is always either\n+    /// true or false, but where one side has been upcast so that the comparison is\n+    /// necessary. Only integer types are checked.\n+    ///\n+    /// **Why is this bad?** An expression like `let x : u8 = ...; (x as u32) > 300`\n+    /// will mistakenly imply that it is possible for `x` to be outside the range of\n+    /// `u8`.\n+    ///\n+    /// **Known problems:**\n+    /// https://github.com/rust-lang/rust-clippy/issues/886\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: u8 = 1;\n+    /// (x as u32) > 300;\n+    /// ```\n+    pub INVALID_UPCAST_COMPARISONS,\n+    pedantic,\n+    \"a comparison involving an upcast which is always true or false\"\n+}\n+\n+declare_lint_pass!(InvalidUpcastComparisons => [INVALID_UPCAST_COMPARISONS]);\n+\n+#[derive(Copy, Clone, Debug, Eq)]\n+enum FullInt {\n+    S(i128),\n+    U(u128),\n+}\n+\n+impl FullInt {\n+    #[allow(clippy::cast_sign_loss)]\n+    #[must_use]\n+    fn cmp_s_u(s: i128, u: u128) -> Ordering {\n+        if s < 0 {\n+            Ordering::Less\n+        } else if u > (i128::MAX as u128) {\n+            Ordering::Greater\n+        } else {\n+            (s as u128).cmp(&u)\n+        }\n+    }\n+}\n+\n+impl PartialEq for FullInt {\n+    #[must_use]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.partial_cmp(other).expect(\"`partial_cmp` only returns `Some(_)`\") == Ordering::Equal\n+    }\n+}\n+\n+impl PartialOrd for FullInt {\n+    #[must_use]\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(match (self, other) {\n+            (&Self::S(s), &Self::S(o)) => s.cmp(&o),\n+            (&Self::U(s), &Self::U(o)) => s.cmp(&o),\n+            (&Self::S(s), &Self::U(o)) => Self::cmp_s_u(s, o),\n+            (&Self::U(s), &Self::S(o)) => Self::cmp_s_u(o, s).reverse(),\n+        })\n+    }\n+}\n+\n+impl Ord for FullInt {\n+    #[must_use]\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.partial_cmp(other)\n+            .expect(\"`partial_cmp` for FullInt can never return `None`\")\n+    }\n+}\n+\n+fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) -> Option<(FullInt, FullInt)> {\n+    if let ExprKind::Cast(cast_exp, _) = expr.kind {\n+        let pre_cast_ty = cx.typeck_results().expr_ty(cast_exp);\n+        let cast_ty = cx.typeck_results().expr_ty(expr);\n+        // if it's a cast from i32 to u32 wrapping will invalidate all these checks\n+        if cx.layout_of(pre_cast_ty).ok().map(|l| l.size) == cx.layout_of(cast_ty).ok().map(|l| l.size) {\n+            return None;\n+        }\n+        match pre_cast_ty.kind() {\n+            ty::Int(int_ty) => Some(match int_ty {\n+                IntTy::I8 => (FullInt::S(i128::from(i8::MIN)), FullInt::S(i128::from(i8::MAX))),\n+                IntTy::I16 => (FullInt::S(i128::from(i16::MIN)), FullInt::S(i128::from(i16::MAX))),\n+                IntTy::I32 => (FullInt::S(i128::from(i32::MIN)), FullInt::S(i128::from(i32::MAX))),\n+                IntTy::I64 => (FullInt::S(i128::from(i64::MIN)), FullInt::S(i128::from(i64::MAX))),\n+                IntTy::I128 => (FullInt::S(i128::MIN), FullInt::S(i128::MAX)),\n+                IntTy::Isize => (FullInt::S(isize::MIN as i128), FullInt::S(isize::MAX as i128)),\n+            }),\n+            ty::Uint(uint_ty) => Some(match uint_ty {\n+                UintTy::U8 => (FullInt::U(u128::from(u8::MIN)), FullInt::U(u128::from(u8::MAX))),\n+                UintTy::U16 => (FullInt::U(u128::from(u16::MIN)), FullInt::U(u128::from(u16::MAX))),\n+                UintTy::U32 => (FullInt::U(u128::from(u32::MIN)), FullInt::U(u128::from(u32::MAX))),\n+                UintTy::U64 => (FullInt::U(u128::from(u64::MIN)), FullInt::U(u128::from(u64::MAX))),\n+                UintTy::U128 => (FullInt::U(u128::MIN), FullInt::U(u128::MAX)),\n+                UintTy::Usize => (FullInt::U(usize::MIN as u128), FullInt::U(usize::MAX as u128)),\n+            }),\n+            _ => None,\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+fn node_as_const_fullint<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<FullInt> {\n+    let val = constant(cx, cx.typeck_results(), expr)?.0;\n+    if let Constant::Int(const_int) = val {\n+        match *cx.typeck_results().expr_ty(expr).kind() {\n+            ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n+            ty::Uint(_) => Some(FullInt::U(const_int)),\n+            _ => None,\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+fn err_upcast_comparison(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, always: bool) {\n+    if let ExprKind::Cast(cast_val, _) = expr.kind {\n+        span_lint(\n+            cx,\n+            INVALID_UPCAST_COMPARISONS,\n+            span,\n+            &format!(\n+                \"because of the numeric bounds on `{}` prior to casting, this expression is always {}\",\n+                snippet(cx, cast_val.span, \"the expression\"),\n+                if always { \"true\" } else { \"false\" },\n+            ),\n+        );\n+    }\n+}\n+\n+fn upcast_comparison_bounds_err<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    span: Span,\n+    rel: comparisons::Rel,\n+    lhs_bounds: Option<(FullInt, FullInt)>,\n+    lhs: &'tcx Expr<'_>,\n+    rhs: &'tcx Expr<'_>,\n+    invert: bool,\n+) {\n+    if let Some((lb, ub)) = lhs_bounds {\n+        if let Some(norm_rhs_val) = node_as_const_fullint(cx, rhs) {\n+            if rel == Rel::Eq || rel == Rel::Ne {\n+                if norm_rhs_val < lb || norm_rhs_val > ub {\n+                    err_upcast_comparison(cx, span, lhs, rel == Rel::Ne);\n+                }\n+            } else if match rel {\n+                Rel::Lt => {\n+                    if invert {\n+                        norm_rhs_val < lb\n+                    } else {\n+                        ub < norm_rhs_val\n+                    }\n+                },\n+                Rel::Le => {\n+                    if invert {\n+                        norm_rhs_val <= lb\n+                    } else {\n+                        ub <= norm_rhs_val\n+                    }\n+                },\n+                Rel::Eq | Rel::Ne => unreachable!(),\n+            } {\n+                err_upcast_comparison(cx, span, lhs, true)\n+            } else if match rel {\n+                Rel::Lt => {\n+                    if invert {\n+                        norm_rhs_val >= ub\n+                    } else {\n+                        lb >= norm_rhs_val\n+                    }\n+                },\n+                Rel::Le => {\n+                    if invert {\n+                        norm_rhs_val > ub\n+                    } else {\n+                        lb > norm_rhs_val\n+                    }\n+                },\n+                Rel::Eq | Rel::Ne => unreachable!(),\n+            } {\n+                err_upcast_comparison(cx, span, lhs, false)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for InvalidUpcastComparisons {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Binary(ref cmp, lhs, rhs) = expr.kind {\n+            let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n+            let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n+                val\n+            } else {\n+                return;\n+            };\n+\n+            let lhs_bounds = numeric_cast_precast_bounds(cx, normalized_lhs);\n+            let rhs_bounds = numeric_cast_precast_bounds(cx, normalized_rhs);\n+\n+            upcast_comparison_bounds_err(cx, expr.span, rel, lhs_bounds, normalized_lhs, normalized_rhs, false);\n+            upcast_comparison_bounds_err(cx, expr.span, rel, rhs_bounds, normalized_rhs, normalized_lhs, true);\n+        }\n+    }\n+}"}, {"sha": "f166748d86b81a021822759440e66456206309b5", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -113,7 +113,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n                             );\n                             if variant.fields.len() == 1 {\n                                 let span = match def.variants[i].data {\n-                                    VariantData::Struct(ref fields, ..) | VariantData::Tuple(ref fields, ..) => {\n+                                    VariantData::Struct(fields, ..) | VariantData::Tuple(fields, ..) => {\n                                         fields[0].ty.span\n                                     },\n                                     VariantData::Unit(..) => unreachable!(),"}, {"sha": "bb57adff7bea1eb1e004e3f9246d609f7ccec534", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 74, "deletions": 25, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -3,16 +3,19 @@ use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{get_item_name, get_parent_as_impl, is_allowed};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n+use rustc_hir::def_id::DefIdSet;\n use rustc_hir::{\n     def_id::DefId, AssocItemKind, BinOpKind, Expr, ExprKind, FnRetTy, ImplItem, ImplItemKind, ImplicitSelfKind, Item,\n     ItemKind, Mutability, Node, TraitItemRef, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, AssocKind, FnSig};\n+use rustc_middle::ty::{self, AssocKind, FnSig, Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::{Span, Spanned, Symbol};\n+use rustc_span::{\n+    source_map::{Span, Spanned, Symbol},\n+    symbol::sym,\n+};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for getting the length of something via `.len()`\n@@ -118,7 +121,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             return;\n         }\n \n-        if let ItemKind::Trait(_, _, _, _, ref trait_items) = item.kind {\n+        if let ItemKind::Trait(_, _, _, _, trait_items) = item.kind {\n             check_trait_items(cx, item, trait_items);\n         }\n     }\n@@ -137,6 +140,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             if let Some(local_id) = ty_id.as_local();\n             let ty_hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_id);\n             if !is_allowed(cx, LEN_WITHOUT_IS_EMPTY, ty_hir_id);\n+            if let Some(output) = parse_len_output(cx, cx.tcx.fn_sig(item.def_id).skip_binder());\n             then {\n                 let (name, kind) = match cx.tcx.hir().find(ty_hir_id) {\n                     Some(Node::ForeignItem(x)) => (x.ident.name, \"extern type\"),\n@@ -148,7 +152,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n                     }\n                     _ => return,\n                 };\n-                check_for_is_empty(cx, sig.span, sig.decl.implicit_self, ty_id, name, kind)\n+                check_for_is_empty(cx, sig.span, sig.decl.implicit_self, output, ty_id, name, kind)\n             }\n         }\n     }\n@@ -158,7 +162,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             return;\n         }\n \n-        if let ExprKind::Binary(Spanned { node: cmp, .. }, ref left, ref right) = expr.kind {\n+        if let ExprKind::Binary(Spanned { node: cmp, .. }, left, right) = expr.kind {\n             match cmp {\n                 BinOpKind::Eq => {\n                     check_cmp(cx, expr.span, left, right, \"\", 0); // len == 0\n@@ -195,7 +199,7 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n     }\n \n     // fill the set with current and super traits\n-    fn fill_trait_set(traitt: DefId, set: &mut FxHashSet<DefId>, cx: &LateContext<'_>) {\n+    fn fill_trait_set(traitt: DefId, set: &mut DefIdSet, cx: &LateContext<'_>) {\n         if set.insert(traitt) {\n             for supertrait in rustc_trait_selection::traits::supertrait_def_ids(cx.tcx, traitt) {\n                 fill_trait_set(supertrait, set, cx);\n@@ -204,7 +208,7 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n     }\n \n     if cx.access_levels.is_exported(visited_trait.hir_id()) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n-        let mut current_and_super_traits = FxHashSet::default();\n+        let mut current_and_super_traits = DefIdSet::default();\n         fill_trait_set(visited_trait.def_id.to_def_id(), &mut current_and_super_traits, cx);\n \n         let is_empty_method_found = current_and_super_traits\n@@ -231,10 +235,62 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n     }\n }\n \n+#[derive(Debug, Clone, Copy)]\n+enum LenOutput<'tcx> {\n+    Integral,\n+    Option(DefId),\n+    Result(DefId, Ty<'tcx>),\n+}\n+fn parse_len_output(cx: &LateContext<'_>, sig: FnSig<'tcx>) -> Option<LenOutput<'tcx>> {\n+    match *sig.output().kind() {\n+        ty::Int(_) | ty::Uint(_) => Some(LenOutput::Integral),\n+        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::option_type, adt.did) => {\n+            subs.type_at(0).is_integral().then(|| LenOutput::Option(adt.did))\n+        },\n+        ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::result_type, adt.did) => subs\n+            .type_at(0)\n+            .is_integral()\n+            .then(|| LenOutput::Result(adt.did, subs.type_at(1))),\n+        _ => None,\n+    }\n+}\n+\n+impl LenOutput<'_> {\n+    fn matches_is_empty_output(self, ty: Ty<'_>) -> bool {\n+        match (self, ty.kind()) {\n+            (_, &ty::Bool) => true,\n+            (Self::Option(id), &ty::Adt(adt, subs)) if id == adt.did => subs.type_at(0).is_bool(),\n+            (Self::Result(id, err_ty), &ty::Adt(adt, subs)) if id == adt.did => {\n+                subs.type_at(0).is_bool() && TyS::same_type(subs.type_at(1), err_ty)\n+            },\n+            _ => false,\n+        }\n+    }\n+\n+    fn expected_sig(self, self_kind: ImplicitSelfKind) -> String {\n+        let self_ref = match self_kind {\n+            ImplicitSelfKind::ImmRef => \"&\",\n+            ImplicitSelfKind::MutRef => \"&mut \",\n+            _ => \"\",\n+        };\n+        match self {\n+            Self::Integral => format!(\"expected signature: `({}self) -> bool`\", self_ref),\n+            Self::Option(_) => format!(\n+                \"expected signature: `({}self) -> bool` or `({}self) -> Option<bool>\",\n+                self_ref, self_ref\n+            ),\n+            Self::Result(..) => format!(\n+                \"expected signature: `({}self) -> bool` or `({}self) -> Result<bool>\",\n+                self_ref, self_ref\n+            ),\n+        }\n+    }\n+}\n+\n /// Checks if the given signature matches the expectations for `is_empty`\n-fn check_is_empty_sig(cx: &LateContext<'_>, sig: FnSig<'_>, self_kind: ImplicitSelfKind) -> bool {\n+fn check_is_empty_sig(sig: FnSig<'_>, self_kind: ImplicitSelfKind, len_output: LenOutput<'_>) -> bool {\n     match &**sig.inputs_and_output {\n-        [arg, res] if *res == cx.tcx.types.bool => {\n+        [arg, res] if len_output.matches_is_empty_output(res) => {\n             matches!(\n                 (arg.kind(), self_kind),\n                 (ty::Ref(_, _, Mutability::Not), ImplicitSelfKind::ImmRef)\n@@ -250,6 +306,7 @@ fn check_for_is_empty(\n     cx: &LateContext<'_>,\n     span: Span,\n     self_kind: ImplicitSelfKind,\n+    output: LenOutput<'_>,\n     impl_ty: DefId,\n     item_name: Symbol,\n     item_kind: &str,\n@@ -289,7 +346,7 @@ fn check_for_is_empty(\n         },\n         Some(is_empty)\n             if !(is_empty.fn_has_self_parameter\n-                && check_is_empty_sig(cx, cx.tcx.fn_sig(is_empty.def_id).skip_binder(), self_kind)) =>\n+                && check_is_empty_sig(cx.tcx.fn_sig(is_empty.def_id).skip_binder(), self_kind, output)) =>\n         {\n             (\n                 format!(\n@@ -309,21 +366,13 @@ fn check_for_is_empty(\n             db.span_note(span, \"`is_empty` defined here\");\n         }\n         if let Some(self_kind) = self_kind {\n-            db.note(&format!(\n-                \"expected signature: `({}self) -> bool`\",\n-                match self_kind {\n-                    ImplicitSelfKind::ImmRef => \"&\",\n-                    ImplicitSelfKind::MutRef => \"&mut \",\n-                    _ => \"\",\n-                }\n-            ));\n+            db.note(&output.expected_sig(self_kind));\n         }\n     });\n }\n \n fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {\n-    if let (&ExprKind::MethodCall(ref method_path, _, ref args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind)\n-    {\n+    if let (&ExprKind::MethodCall(method_path, _, args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n             if name.as_str() == \"is_empty\" {\n@@ -401,7 +450,7 @@ fn is_empty_string(expr: &Expr<'_>) -> bool {\n }\n \n fn is_empty_array(expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Array(ref arr) = expr.kind {\n+    if let ExprKind::Array(arr) = expr.kind {\n         return arr.is_empty();\n     }\n     false\n@@ -430,17 +479,17 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n             cx.tcx\n                 .associated_items(*imp)\n                 .in_definition_order()\n-                .any(|item| is_is_empty(cx, &item))\n+                .any(|item| is_is_empty(cx, item))\n         })\n     }\n \n     let ty = &cx.typeck_results().expr_ty(expr).peel_refs();\n     match ty.kind() {\n-        ty::Dynamic(ref tt, ..) => tt.principal().map_or(false, |principal| {\n+        ty::Dynamic(tt, ..) => tt.principal().map_or(false, |principal| {\n             cx.tcx\n                 .associated_items(principal.def_id())\n                 .in_definition_order()\n-                .any(|item| is_is_empty(cx, &item))\n+                .any(|item| is_is_empty(cx, item))\n         }),\n         ty::Projection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),\n         ty::Adt(id, _) => has_is_empty_impl(cx, id.did),"}, {"sha": "67eae4d87bbdb44524b36a17e673f52302e582e5", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -61,13 +61,13 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n         while let Some(stmt) = it.next() {\n             if_chain! {\n                 if let Some(expr) = it.peek();\n-                if let hir::StmtKind::Local(ref local) = stmt.kind;\n+                if let hir::StmtKind::Local(local) = stmt.kind;\n                 if let hir::PatKind::Binding(mode, canonical_id, ident, None) = local.pat.kind;\n-                if let hir::StmtKind::Expr(ref if_) = expr.kind;\n-                if let hir::ExprKind::If(ref cond, ref then, ref else_) = if_.kind;\n+                if let hir::StmtKind::Expr(if_) = expr.kind;\n+                if let hir::ExprKind::If(cond, then, ref else_) = if_.kind;\n                 let mut used_visitor = LocalUsedVisitor::new(cx, canonical_id);\n                 if !used_visitor.check_expr(cond);\n-                if let hir::ExprKind::Block(ref then, _) = then.kind;\n+                if let hir::ExprKind::Block(then, _) = then.kind;\n                 if let Some(value) = check_assign(cx, canonical_id, &*then);\n                 if !used_visitor.check_expr(value);\n                 then {\n@@ -79,20 +79,20 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                     );\n                     if has_interior_mutability { return; }\n \n-                    let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n-                        if let hir::ExprKind::Block(ref else_, _) = else_.kind {\n+                    let (default_multi_stmts, default) = if let Some(else_) = *else_ {\n+                        if let hir::ExprKind::Block(else_, _) = else_.kind {\n                             if let Some(default) = check_assign(cx, canonical_id, else_) {\n                                 (else_.stmts.len() > 1, default)\n-                            } else if let Some(ref default) = local.init {\n-                                (true, &**default)\n+                            } else if let Some(default) = local.init {\n+                                (true, default)\n                             } else {\n                                 continue;\n                             }\n                         } else {\n                             continue;\n                         }\n-                    } else if let Some(ref default) = local.init {\n-                        (false, &**default)\n+                    } else if let Some(default) = local.init {\n+                        (false, default)\n                     } else {\n                         continue;\n                     };\n@@ -144,8 +144,8 @@ fn check_assign<'tcx>(\n     if_chain! {\n         if block.expr.is_none();\n         if let Some(expr) = block.stmts.iter().last();\n-        if let hir::StmtKind::Semi(ref expr) = expr.kind;\n-        if let hir::ExprKind::Assign(ref var, ref value, _) = expr.kind;\n+        if let hir::StmtKind::Semi(expr) = expr.kind;\n+        if let hir::ExprKind::Assign(var, value, _) = expr.kind;\n         if path_to_local_id(var, decl);\n         then {\n             let mut v = LocalUsedVisitor::new(cx, decl);"}, {"sha": "17e23781db7d6a73c4653d7a29035f6fddb53a00", "filename": "clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_underscore.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -116,7 +116,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n \n         if_chain! {\n             if let PatKind::Wild = local.pat.kind;\n-            if let Some(ref init) = local.init;\n+            if let Some(init) = local.init;\n             then {\n                 let init_ty = cx.typeck_results().expr_ty(init);\n                 let contains_sync_guard = init_ty.walk().any(|inner| match inner.unpack() {"}, {"sha": "11fef30945d7884a0b655318369979a1bbc326bd", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1241, "deletions": 1221, "changes": 2462, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416"}, {"sha": "116ad072837928a7cf573aa1e790528059b4e942", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -81,7 +81,7 @@ declare_lint_pass!(Lifetimes => [NEEDLESS_LIFETIMES, EXTRA_UNUSED_LIFETIMES]);\n impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let ItemKind::Fn(ref sig, ref generics, id) = item.kind {\n-            check_fn_inner(cx, &sig.decl, Some(id), generics, item.span, true);\n+            check_fn_inner(cx, sig.decl, Some(id), generics, item.span, true);\n         }\n     }\n \n@@ -90,7 +90,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n             let report_extra_lifetimes = trait_ref_of_method(cx, item.hir_id()).is_none();\n             check_fn_inner(\n                 cx,\n-                &sig.decl,\n+                sig.decl,\n                 Some(id),\n                 &item.generics,\n                 item.span,\n@@ -105,7 +105,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n                 TraitFn::Required(_) => None,\n                 TraitFn::Provided(id) => Some(id),\n             };\n-            check_fn_inner(cx, &sig.decl, body, &item.generics, item.span, true);\n+            check_fn_inner(cx, sig.decl, body, &item.generics, item.span, true);\n         }\n     }\n }\n@@ -149,7 +149,7 @@ fn check_fn_inner<'tcx>(\n                     .last()\n                     .expect(\"a path must have at least one segment\")\n                     .args;\n-                if let Some(ref params) = *params {\n+                if let Some(params) = *params {\n                     let lifetimes = params.args.iter().filter_map(|arg| match arg {\n                         GenericArg::Lifetime(lt) => Some(lt),\n                         _ => None,\n@@ -163,7 +163,7 @@ fn check_fn_inner<'tcx>(\n             }\n         }\n     }\n-    if could_use_elision(cx, decl, body, &generics.params) {\n+    if could_use_elision(cx, decl, body, generics.params) {\n         span_lint(\n             cx,\n             NEEDLESS_LIFETIMES,\n@@ -201,7 +201,7 @@ fn could_use_elision<'tcx>(\n         input_visitor.visit_ty(arg);\n     }\n     // extract lifetimes in output type\n-    if let Return(ref ty) = func.output {\n+    if let Return(ty) = func.output {\n         output_visitor.visit_ty(ty);\n     }\n     for lt in named_generics {\n@@ -416,12 +416,12 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, where_clause: &'tcx WhereCl\n                 // a predicate like F: Trait or F: for<'a> Trait<'a>\n                 let mut visitor = RefVisitor::new(cx);\n                 // walk the type F, it may not contain LT refs\n-                walk_ty(&mut visitor, &pred.bounded_ty);\n+                walk_ty(&mut visitor, pred.bounded_ty);\n                 if !visitor.all_lts().is_empty() {\n                     return true;\n                 }\n                 // if the bounds define new lifetimes, they are fine to occur\n-                let allowed_lts = allowed_lts_from(&pred.bound_generic_params);\n+                let allowed_lts = allowed_lts_from(pred.bound_generic_params);\n                 // now walk the bounds\n                 for bound in pred.bounds.iter() {\n                     walk_param_bound(&mut visitor, bound);\n@@ -433,8 +433,8 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, where_clause: &'tcx WhereCl\n             },\n             WherePredicate::EqPredicate(ref pred) => {\n                 let mut visitor = RefVisitor::new(cx);\n-                walk_ty(&mut visitor, &pred.lhs_ty);\n-                walk_ty(&mut visitor, &pred.rhs_ty);\n+                walk_ty(&mut visitor, pred.lhs_ty);\n+                walk_ty(&mut visitor, pred.rhs_ty);\n                 if !visitor.lts.is_empty() {\n                     return true;\n                 }"}, {"sha": "e93b2e36b860ad234f0b57a5178f9ff48bf50702", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -249,7 +249,7 @@ impl LiteralDigitGrouping {\n     fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n         if_chain! {\n             if let Some(src) = snippet_opt(cx, lit.span);\n-            if let Some(mut num_lit) = NumericLiteral::from_lit(&src, &lit);\n+            if let Some(mut num_lit) = NumericLiteral::from_lit(&src, lit);\n             then {\n                 if !Self::check_for_mistyped_suffix(cx, lit.span, &mut num_lit) {\n                     return;\n@@ -439,7 +439,7 @@ impl DecimalLiteralRepresentation {\n         if_chain! {\n             if let LitKind::Int(val, _) = lit.kind;\n             if let Some(src) = snippet_opt(cx, lit.span);\n-            if let Some(num_lit) = NumericLiteral::from_lit(&src, &lit);\n+            if let Some(num_lit) = NumericLiteral::from_lit(&src, lit);\n             if num_lit.radix == Radix::Decimal;\n             if val >= u128::from(self.threshold);\n             then {"}, {"sha": "98e60f7ed85cf16c939e8917a97f66976515ab0b", "filename": "clippy_lints/src/loops/explicit_counter_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -26,7 +26,7 @@ pub(super) fn check<'tcx>(\n \n     // For each candidate, check the parent block to see if\n     // it's initialized to zero at the start of the loop.\n-    if let Some(block) = get_enclosing_block(&cx, expr.hir_id) {\n+    if let Some(block) = get_enclosing_block(cx, expr.hir_id) {\n         for id in increment_visitor.into_results() {\n             let mut initialize_visitor = InitializeVisitor::new(cx, expr, id);\n             walk_block(&mut initialize_visitor, block);"}, {"sha": "666b8c58728c27ffeb2158527a97aa871f53c0dd", "filename": "clippy_lints/src/loops/for_kv_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -19,7 +19,7 @@ pub(super) fn check<'tcx>(\n ) {\n     let pat_span = pat.span;\n \n-    if let PatKind::Tuple(ref pat, _) = pat.kind {\n+    if let PatKind::Tuple(pat, _) = pat.kind {\n         if pat.len() == 2 {\n             let arg_span = arg.span;\n             let (new_pat_span, kind, ty, mutbl) = match *cx.typeck_results().expr_ty(arg).kind() {\n@@ -35,7 +35,7 @@ pub(super) fn check<'tcx>(\n                 Mutability::Mut => \"_mut\",\n             };\n             let arg = match arg.kind {\n-                ExprKind::AddrOf(BorrowKind::Ref, _, ref expr) => &**expr,\n+                ExprKind::AddrOf(BorrowKind::Ref, _, expr) => expr,\n                 _ => arg,\n             };\n "}, {"sha": "94743cfcf4657705f708f7e5d94ff61592c900d5", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -18,7 +18,7 @@ pub(super) fn check<'tcx>(\n     body: &'tcx Expr<'_>,\n     span: Span,\n ) {\n-    if let ExprKind::Block(ref block, _) = body.kind {\n+    if let ExprKind::Block(block, _) = body.kind {\n         // Ensure the `if let` statement is the only expression or statement in the for-loop\n         let inner_expr = if block.stmts.len() == 1 && block.expr.is_none() {\n             let match_stmt = &block.stmts[0];\n@@ -36,7 +36,7 @@ pub(super) fn check<'tcx>(\n         if_chain! {\n             if let Some(inner_expr) = inner_expr;\n             if let ExprKind::Match(\n-                ref match_expr, ref match_arms, MatchSource::IfLetDesugar{ contains_else_clause: false }\n+                match_expr, match_arms, MatchSource::IfLetDesugar{ contains_else_clause: false }\n             ) = inner_expr.kind;\n             // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n             if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n@@ -46,9 +46,8 @@ pub(super) fn check<'tcx>(\n             let some_ctor = is_some_ctor(cx, path.res);\n             let ok_ctor = is_ok_ctor(cx, path.res);\n             if some_ctor || ok_ctor;\n-            let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n-\n             then {\n+                let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n                 // Prepare the error message\n                 let msg = format!(\"unnecessary `if let` since only the `{}` variant of the iterator element is used\", if_let_type);\n "}, {"sha": "c91fe88757ec719d1b59d3162c14e06a7818f511", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -61,10 +61,10 @@ pub(super) fn check<'tcx>(\n                         if_chain! {\n                             if let ExprKind::Index(base_left, idx_left) = lhs.kind;\n                             if let ExprKind::Index(base_right, idx_right) = rhs.kind;\n-                            if is_slice_like(cx, cx.typeck_results().expr_ty(base_left))\n-                                && is_slice_like(cx, cx.typeck_results().expr_ty(base_right));\n-                            if let Some((start_left, offset_left)) = get_details_from_idx(cx, &idx_left, &starts);\n-                            if let Some((start_right, offset_right)) = get_details_from_idx(cx, &idx_right, &starts);\n+                            if is_slice_like(cx, cx.typeck_results().expr_ty(base_left));\n+                            if is_slice_like(cx, cx.typeck_results().expr_ty(base_right));\n+                            if let Some((start_left, offset_left)) = get_details_from_idx(cx, idx_left, &starts);\n+                            if let Some((start_right, offset_right)) = get_details_from_idx(cx, idx_right, &starts);\n \n                             // Source and destination must be different\n                             if path_to_local(base_left) != path_to_local(base_right);\n@@ -168,8 +168,8 @@ fn build_manual_memcpy_suggestion<'tcx>(\n         },\n     };\n \n-    let (dst_offset, dst_limit) = print_offset_and_limit(&dst);\n-    let (src_offset, src_limit) = print_offset_and_limit(&src);\n+    let (dst_offset, dst_limit) = print_offset_and_limit(dst);\n+    let (src_offset, src_limit) = print_offset_and_limit(src);\n \n     let dst_base_str = snippet(cx, dst.base.span, \"???\");\n     let src_base_str = snippet(cx, src.base.span, \"???\");\n@@ -438,7 +438,7 @@ fn get_loop_counters<'a, 'tcx>(\n \n     // For each candidate, check the parent block to see if\n     // it's initialized to zero at the start of the loop.\n-    get_enclosing_block(&cx, expr.hir_id).and_then(|block| {\n+    get_enclosing_block(cx, expr.hir_id).and_then(|block| {\n         increment_visitor\n             .into_results()\n             .filter_map(move |var_id| {"}, {"sha": "28acefd51fef74554630f7bea55ae5469c18b2cb", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -562,15 +562,15 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n         // check for `loop { if let {} else break }` that could be `while let`\n         // (also matches an explicit \"match\" instead of \"if let\")\n         // (even if the \"match\" or \"if let\" is used for declaration)\n-        if let ExprKind::Loop(ref block, _, LoopSource::Loop, _) = expr.kind {\n+        if let ExprKind::Loop(block, _, LoopSource::Loop, _) = expr.kind {\n             // also check for empty `loop {}` statements, skipping those in #[panic_handler]\n             empty_loop::check(cx, expr, block);\n             while_let_loop::check(cx, expr, block);\n         }\n \n         while_let_on_iterator::check(cx, expr);\n \n-        if let Some((cond, body)) = higher::while_loop(&expr) {\n+        if let Some((cond, body)) = higher::while_loop(expr) {\n             while_immutable_condition::check(cx, cond, body);\n         }\n \n@@ -602,7 +602,7 @@ fn check_for_loop<'tcx>(\n fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr: &Expr<'_>) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n \n-    if let ExprKind::MethodCall(ref method, _, ref args, _) = arg.kind {\n+    if let ExprKind::MethodCall(method, _, args, _) = arg.kind {\n         // just the receiver, no arguments\n         if args.len() == 1 {\n             let method_name = &*method.ident.as_str();"}, {"sha": "4d73aef76e87e8604294791aac254627716f9f62", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 44, "deletions": 82, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -10,8 +10,8 @@ use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{Block, Expr, ExprKind, GenericArg, HirId, Local, Pat, PatKind, QPath, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n-use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, Ident};\n+use rustc_span::{MultiSpan, Span};\n \n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n \n@@ -21,88 +21,60 @@ pub(super) fn check<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n }\n fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n-        if let ExprKind::MethodCall(ref chain_method, _, _, _) = args[0].kind;\n+        if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n+        if let ExprKind::MethodCall(chain_method, method0_span, _, _) = args[0].kind;\n         if chain_method.ident.name == sym!(collect) && is_trait_method(cx, &args[0], sym::Iterator);\n-        if let Some(ref generic_args) = chain_method.args;\n+        if let Some(generic_args) = chain_method.args;\n         if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n-        then {\n-            let ty = cx.typeck_results().node_type(ty.hir_id);\n-            if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n-                is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n-                match_type(cx, ty, &paths::BTREEMAP) ||\n-                is_type_diagnostic_item(cx, ty, sym::hashmap_type) {\n-                if method.ident.name == sym!(len) {\n-                    let span = shorten_needless_collect_span(expr);\n-                    span_lint_and_sugg(\n-                        cx,\n-                        NEEDLESS_COLLECT,\n-                        span,\n-                        NEEDLESS_COLLECT_MSG,\n-                        \"replace with\",\n-                        \"count()\".to_string(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                if method.ident.name == sym!(is_empty) {\n-                    let span = shorten_needless_collect_span(expr);\n-                    span_lint_and_sugg(\n-                        cx,\n-                        NEEDLESS_COLLECT,\n-                        span,\n-                        NEEDLESS_COLLECT_MSG,\n-                        \"replace with\",\n-                        \"next().is_none()\".to_string(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                if method.ident.name == sym!(contains) {\n-                    let contains_arg = snippet(cx, args[1].span, \"??\");\n-                    let span = shorten_needless_collect_span(expr);\n-                    span_lint_and_then(\n-                        cx,\n-                        NEEDLESS_COLLECT,\n-                        span,\n-                        NEEDLESS_COLLECT_MSG,\n-                        |diag| {\n-                            let (arg, pred) = contains_arg\n-                                    .strip_prefix('&')\n-                                    .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n-                            diag.span_suggestion(\n-                                span,\n-                                \"replace with\",\n-                                format!(\n-                                    \"any(|{}| x == {})\",\n-                                    arg, pred\n-                                ),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    );\n-                }\n+        let ty = cx.typeck_results().node_type(ty.hir_id);\n+        if is_type_diagnostic_item(cx, ty, sym::vec_type)\n+            || is_type_diagnostic_item(cx, ty, sym::vecdeque_type)\n+            || match_type(cx, ty, &paths::BTREEMAP)\n+            || is_type_diagnostic_item(cx, ty, sym::hashmap_type);\n+        if let Some(sugg) = match &*method.ident.name.as_str() {\n+            \"len\" => Some(\"count()\".to_string()),\n+            \"is_empty\" => Some(\"next().is_none()\".to_string()),\n+            \"contains\" => {\n+                let contains_arg = snippet(cx, args[1].span, \"??\");\n+                let (arg, pred) = contains_arg\n+                    .strip_prefix('&')\n+                    .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n+                Some(format!(\"any(|{}| x == {})\", arg, pred))\n             }\n+            _ => None,\n+        };\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                NEEDLESS_COLLECT,\n+                method0_span.with_hi(expr.span.hi()),\n+                NEEDLESS_COLLECT_MSG,\n+                \"replace with\",\n+                sugg,\n+                Applicability::MachineApplicable,\n+            );\n         }\n     }\n }\n \n fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n-    if let ExprKind::Block(ref block, _) = expr.kind {\n-        for ref stmt in block.stmts {\n+    if let ExprKind::Block(block, _) = expr.kind {\n+        for stmt in block.stmts {\n             if_chain! {\n                 if let StmtKind::Local(\n                     Local { pat: Pat { hir_id: pat_id, kind: PatKind::Binding(_, _, ident, .. ), .. },\n-                    init: Some(ref init_expr), .. }\n+                    init: Some(init_expr), .. }\n                 ) = stmt.kind;\n-                if let ExprKind::MethodCall(ref method_name, _, &[ref iter_source], ..) = init_expr.kind;\n-                if method_name.ident.name == sym!(collect) && is_trait_method(cx, &init_expr, sym::Iterator);\n-                if let Some(ref generic_args) = method_name.args;\n+                if let ExprKind::MethodCall(method_name, collect_span, &[ref iter_source], ..) = init_expr.kind;\n+                if method_name.ident.name == sym!(collect) && is_trait_method(cx, init_expr, sym::Iterator);\n+                if let Some(generic_args) = method_name.args;\n                 if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n                 if let ty = cx.typeck_results().node_type(ty.hir_id);\n                 if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n                     is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n                     match_type(cx, ty, &paths::LINKED_LIST);\n                 if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n-                if iter_calls.len() == 1;\n+                if let [iter_call] = &*iter_calls;\n                 then {\n                     let mut used_count_visitor = UsedCountVisitor {\n                         cx,\n@@ -115,11 +87,12 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                     }\n \n                     // Suggest replacing iter_call with iter_replacement, and removing stmt\n-                    let iter_call = &iter_calls[0];\n+                    let mut span = MultiSpan::from_span(collect_span);\n+                    span.push_span_label(iter_call.span, \"the iterator could be used here instead\".into());\n                     span_lint_and_then(\n                         cx,\n                         super::NEEDLESS_COLLECT,\n-                        stmt.span.until(iter_call.span),\n+                        span,\n                         NEEDLESS_COLLECT_MSG,\n                         |diag| {\n                             let iter_replacement = format!(\"{}{}\", Sugg::hir(cx, iter_source, \"..\"), iter_call.get_iter_method(cx));\n@@ -130,7 +103,7 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                                     (iter_call.span, iter_replacement)\n                                 ],\n                                 Applicability::MachineApplicable,// MaybeIncorrect,\n-                            ).emit();\n+                            );\n                         },\n                     );\n                 }\n@@ -192,8 +165,8 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         // Check function calls on our collection\n         if_chain! {\n-            if let ExprKind::MethodCall(method_name, _, ref args, _) = &expr.kind;\n-            if let Some(Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. }) = args.get(0);\n+            if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n+            if let Some(Expr { kind: ExprKind::Path(QPath::Resolved(_, path)), .. }) = args.get(0);\n             if let &[name] = &path.segments;\n             if name.ident == self.target;\n             then {\n@@ -220,7 +193,7 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n         }\n         // Check if the collection is used for anything else\n         if_chain! {\n-            if let Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. } = expr;\n+            if let Expr { kind: ExprKind::Path(QPath::Resolved(_, path)), .. } = expr;\n             if let &[name] = &path.segments;\n             if name.ident == self.target;\n             then {\n@@ -270,14 +243,3 @@ fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, identifier: Ident)\n     visitor.visit_block(block);\n     if visitor.seen_other { None } else { Some(visitor.uses) }\n }\n-\n-fn shorten_needless_collect_span(expr: &Expr<'_>) -> Span {\n-    if_chain! {\n-        if let ExprKind::MethodCall(.., args, _) = &expr.kind;\n-        if let ExprKind::MethodCall(_, span, ..) = &args[0].kind;\n-        then {\n-            return expr.span.with_lo(span.lo());\n-        }\n-    }\n-    unreachable!();\n-}"}, {"sha": "3065bcc3e6c81e2b70baa3d3f69a92fa9c85524d", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -96,7 +96,7 @@ pub(super) fn check<'tcx>(\n                 let take = if let Some(end) = *end {\n                     let mut take_expr = end;\n \n-                    if let ExprKind::Binary(ref op, ref left, ref right) = end.kind {\n+                    if let ExprKind::Binary(ref op, left, right) = end.kind {\n                         if let BinOpKind::Add = op.node {\n                             let start_equal_left = SpanlessEq::new(cx).eq_expr(start, left);\n                             let start_equal_right = SpanlessEq::new(cx).eq_expr(start, right);\n@@ -190,10 +190,10 @@ pub(super) fn check<'tcx>(\n \n fn is_len_call(expr: &Expr<'_>, var: Symbol) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method, _, ref len_args, _) = expr.kind;\n+        if let ExprKind::MethodCall(method, _, len_args, _) = expr.kind;\n         if len_args.len() == 1;\n         if method.ident.name == sym!(len);\n-        if let ExprKind::Path(QPath::Resolved(_, ref path)) = len_args[0].kind;\n+        if let ExprKind::Path(QPath::Resolved(_, path)) = len_args[0].kind;\n         if path.segments.len() == 1;\n         if path.segments[0].ident.name == var;\n         then {\n@@ -254,51 +254,49 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n         if_chain! {\n             // the indexed container is referenced by a name\n             if let ExprKind::Path(ref seqpath) = seqexpr.kind;\n-            if let QPath::Resolved(None, ref seqvar) = *seqpath;\n+            if let QPath::Resolved(None, seqvar) = *seqpath;\n             if seqvar.segments.len() == 1;\n+            let index_used_directly = path_to_local_id(idx, self.var);\n+            let indexed_indirectly = {\n+                let mut used_visitor = LocalUsedVisitor::new(self.cx, self.var);\n+                walk_expr(&mut used_visitor, idx);\n+                used_visitor.used\n+            };\n+            if indexed_indirectly || index_used_directly;\n             then {\n-                let index_used_directly = path_to_local_id(idx, self.var);\n-                let indexed_indirectly = {\n-                    let mut used_visitor = LocalUsedVisitor::new(self.cx, self.var);\n-                    walk_expr(&mut used_visitor, idx);\n-                    used_visitor.used\n-                };\n-\n-                if indexed_indirectly || index_used_directly {\n-                    if self.prefer_mutable {\n-                        self.indexed_mut.insert(seqvar.segments[0].ident.name);\n+                if self.prefer_mutable {\n+                    self.indexed_mut.insert(seqvar.segments[0].ident.name);\n+                }\n+                let res = self.cx.qpath_res(seqpath, seqexpr.hir_id);\n+                match res {\n+                    Res::Local(hir_id) => {\n+                        let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n+                        let parent_def_id = self.cx.tcx.hir().local_def_id(parent_id);\n+                        let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n+                        if indexed_indirectly {\n+                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n+                        }\n+                        if index_used_directly {\n+                            self.indexed_directly.insert(\n+                                seqvar.segments[0].ident.name,\n+                                (Some(extent), self.cx.typeck_results().node_type(seqexpr.hir_id)),\n+                            );\n+                        }\n+                        return false;  // no need to walk further *on the variable*\n                     }\n-                    let res = self.cx.qpath_res(seqpath, seqexpr.hir_id);\n-                    match res {\n-                        Res::Local(hir_id) => {\n-                            let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n-                            let parent_def_id = self.cx.tcx.hir().local_def_id(parent_id);\n-                            let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n-                            if indexed_indirectly {\n-                                self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n-                            }\n-                            if index_used_directly {\n-                                self.indexed_directly.insert(\n-                                    seqvar.segments[0].ident.name,\n-                                    (Some(extent), self.cx.typeck_results().node_type(seqexpr.hir_id)),\n-                                );\n-                            }\n-                            return false;  // no need to walk further *on the variable*\n+                    Res::Def(DefKind::Static | DefKind::Const, ..) => {\n+                        if indexed_indirectly {\n+                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n                         }\n-                        Res::Def(DefKind::Static | DefKind::Const, ..) => {\n-                            if indexed_indirectly {\n-                                self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n-                            }\n-                            if index_used_directly {\n-                                self.indexed_directly.insert(\n-                                    seqvar.segments[0].ident.name,\n-                                    (None, self.cx.typeck_results().node_type(seqexpr.hir_id)),\n-                                );\n-                            }\n-                            return false;  // no need to walk further *on the variable*\n+                        if index_used_directly {\n+                            self.indexed_directly.insert(\n+                                seqvar.segments[0].ident.name,\n+                                (None, self.cx.typeck_results().node_type(seqexpr.hir_id)),\n+                            );\n                         }\n-                        _ => (),\n+                        return false;  // no need to walk further *on the variable*\n                     }\n+                    _ => (),\n                 }\n             }\n         }\n@@ -312,7 +310,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // a range index op\n-            if let ExprKind::MethodCall(ref meth, _, ref args, _) = expr.kind;\n+            if let ExprKind::MethodCall(meth, _, args, _) = expr.kind;\n             if (meth.ident.name == sym::index && match_trait_method(self.cx, expr, &paths::INDEX))\n                 || (meth.ident.name == sym::index_mut && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n             if !self.check(&args[1], &args[0], expr);\n@@ -321,7 +319,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n \n         if_chain! {\n             // an index op\n-            if let ExprKind::Index(ref seqexpr, ref idx) = expr.kind;\n+            if let ExprKind::Index(seqexpr, idx) = expr.kind;\n             if !self.check(idx, seqexpr, expr);\n             then { return }\n         }\n@@ -342,19 +340,19 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n \n         let old = self.prefer_mutable;\n         match expr.kind {\n-            ExprKind::AssignOp(_, ref lhs, ref rhs) | ExprKind::Assign(ref lhs, ref rhs, _) => {\n+            ExprKind::AssignOp(_, lhs, rhs) | ExprKind::Assign(lhs, rhs, _) => {\n                 self.prefer_mutable = true;\n                 self.visit_expr(lhs);\n                 self.prefer_mutable = false;\n                 self.visit_expr(rhs);\n             },\n-            ExprKind::AddrOf(BorrowKind::Ref, mutbl, ref expr) => {\n+            ExprKind::AddrOf(BorrowKind::Ref, mutbl, expr) => {\n                 if mutbl == Mutability::Mut {\n                     self.prefer_mutable = true;\n                 }\n                 self.visit_expr(expr);\n             },\n-            ExprKind::Call(ref f, args) => {\n+            ExprKind::Call(f, args) => {\n                 self.visit_expr(f);\n                 for expr in args {\n                     let ty = self.cx.typeck_results().expr_ty_adjusted(expr);"}, {"sha": "96720764e1658979b5563f811a19bfa09df7cb42", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -5,7 +5,7 @@ use rustc_lint::LateContext;\n use std::iter::{once, Iterator};\n \n pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let ExprKind::Loop(ref block, _, _, _) = expr.kind {\n+    if let ExprKind::Loop(block, _, _, _) = expr.kind {\n         match never_loop_block(block, expr.hir_id) {\n             NeverLoopResult::AlwaysBreak => span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n             NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n@@ -76,44 +76,44 @@ fn never_loop_expr_seq<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_lo\n \n fn stmt_to_expr<'tcx>(stmt: &Stmt<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     match stmt.kind {\n-        StmtKind::Semi(ref e, ..) | StmtKind::Expr(ref e, ..) => Some(e),\n-        StmtKind::Local(ref local) => local.init.as_deref(),\n+        StmtKind::Semi(e, ..) | StmtKind::Expr(e, ..) => Some(e),\n+        StmtKind::Local(local) => local.init.as_deref(),\n         StmtKind::Item(..) => None,\n     }\n }\n \n fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n     match expr.kind {\n-        ExprKind::Box(ref e)\n-        | ExprKind::Unary(_, ref e)\n-        | ExprKind::Cast(ref e, _)\n-        | ExprKind::Type(ref e, _)\n-        | ExprKind::Field(ref e, _)\n-        | ExprKind::AddrOf(_, _, ref e)\n-        | ExprKind::Struct(_, _, Some(ref e))\n-        | ExprKind::Repeat(ref e, _)\n-        | ExprKind::DropTemps(ref e) => never_loop_expr(e, main_loop_id),\n-        ExprKind::Array(ref es) | ExprKind::MethodCall(_, _, ref es, _) | ExprKind::Tup(ref es) => {\n+        ExprKind::Box(e)\n+        | ExprKind::Unary(_, e)\n+        | ExprKind::Cast(e, _)\n+        | ExprKind::Type(e, _)\n+        | ExprKind::Field(e, _)\n+        | ExprKind::AddrOf(_, _, e)\n+        | ExprKind::Struct(_, _, Some(e))\n+        | ExprKind::Repeat(e, _)\n+        | ExprKind::DropTemps(e) => never_loop_expr(e, main_loop_id),\n+        ExprKind::Array(es) | ExprKind::MethodCall(_, _, es, _) | ExprKind::Tup(es) => {\n             never_loop_expr_all(&mut es.iter(), main_loop_id)\n         },\n-        ExprKind::Call(ref e, ref es) => never_loop_expr_all(&mut once(&**e).chain(es.iter()), main_loop_id),\n-        ExprKind::Binary(_, ref e1, ref e2)\n-        | ExprKind::Assign(ref e1, ref e2, _)\n-        | ExprKind::AssignOp(_, ref e1, ref e2)\n-        | ExprKind::Index(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n-        ExprKind::Loop(ref b, _, _, _) => {\n+        ExprKind::Call(e, es) => never_loop_expr_all(&mut once(e).chain(es.iter()), main_loop_id),\n+        ExprKind::Binary(_, e1, e2)\n+        | ExprKind::Assign(e1, e2, _)\n+        | ExprKind::AssignOp(_, e1, e2)\n+        | ExprKind::Index(e1, e2) => never_loop_expr_all(&mut [e1, e2].iter().cloned(), main_loop_id),\n+        ExprKind::Loop(b, _, _, _) => {\n             // Break can come from the inner loop so remove them.\n             absorb_break(&never_loop_block(b, main_loop_id))\n         },\n-        ExprKind::If(ref e, ref e2, ref e3) => {\n+        ExprKind::If(e, e2, ref e3) => {\n             let e1 = never_loop_expr(e, main_loop_id);\n             let e2 = never_loop_expr(e2, main_loop_id);\n             let e3 = e3\n                 .as_ref()\n                 .map_or(NeverLoopResult::Otherwise, |e| never_loop_expr(e, main_loop_id));\n             combine_seq(e1, combine_branches(e2, e3))\n         },\n-        ExprKind::Match(ref e, ref arms, _) => {\n+        ExprKind::Match(e, arms, _) => {\n             let e = never_loop_expr(e, main_loop_id);\n             if arms.is_empty() {\n                 e\n@@ -122,7 +122,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n                 combine_seq(e, arms)\n             }\n         },\n-        ExprKind::Block(ref b, _) => never_loop_block(b, main_loop_id),\n+        ExprKind::Block(b, _) => never_loop_block(b, main_loop_id),\n         ExprKind::Continue(d) => {\n             let id = d\n                 .target_id\n@@ -136,7 +136,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         ExprKind::Break(_, ref e) | ExprKind::Ret(ref e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n             combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n         }),\n-        ExprKind::InlineAsm(ref asm) => asm\n+        ExprKind::InlineAsm(asm) => asm\n             .operands\n             .iter()\n             .map(|(o, _)| match o {"}, {"sha": "cb2c83e90294accb9185a56ad28f395f1c98cf06", "filename": "clippy_lints/src/loops/same_item_push.rs", "status": "modified", "additions": 85, "deletions": 54, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,11 +1,13 @@\n use super::SAME_ITEM_PUSH;\n use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::path_to_local;\n use clippy_utils::source::snippet_with_macro_callsite;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, Node, Pat, PatKind, Stmt, StmtKind};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, Node, Pat, PatKind, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_span::symbol::sym;\n@@ -41,70 +43,94 @@ pub(super) fn check<'tcx>(\n     }\n \n     // Determine whether it is safe to lint the body\n-    let mut same_item_push_visitor = SameItemPushVisitor {\n-        should_lint: true,\n-        vec_push: None,\n-        cx,\n-    };\n+    let mut same_item_push_visitor = SameItemPushVisitor::new(cx);\n     walk_expr(&mut same_item_push_visitor, body);\n-    if same_item_push_visitor.should_lint {\n-        if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push {\n-            let vec_ty = cx.typeck_results().expr_ty(vec);\n-            let ty = vec_ty.walk().nth(1).unwrap().expect_ty();\n-            if cx\n-                .tcx\n-                .lang_items()\n-                .clone_trait()\n-                .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n-            {\n-                // Make sure that the push does not involve possibly mutating values\n-                match pushed_item.kind {\n-                    ExprKind::Path(ref qpath) => {\n-                        match cx.qpath_res(qpath, pushed_item.hir_id) {\n-                            // immutable bindings that are initialized with literal or constant\n-                            Res::Local(hir_id) => {\n-                                if_chain! {\n-                                    let node = cx.tcx.hir().get(hir_id);\n-                                    if let Node::Binding(pat) = node;\n-                                    if let PatKind::Binding(bind_ann, ..) = pat.kind;\n-                                    if !matches!(bind_ann, BindingAnnotation::RefMut | BindingAnnotation::Mutable);\n-                                    let parent_node = cx.tcx.hir().get_parent_node(hir_id);\n-                                    if let Some(Node::Local(parent_let_expr)) = cx.tcx.hir().find(parent_node);\n-                                    if let Some(init) = parent_let_expr.init;\n-                                    then {\n-                                        match init.kind {\n-                                            // immutable bindings that are initialized with literal\n-                                            ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n-                                            // immutable bindings that are initialized with constant\n-                                            ExprKind::Path(ref path) => {\n-                                                if let Res::Def(DefKind::Const, ..) = cx.qpath_res(path, init.hir_id) {\n-                                                    emit_lint(cx, vec, pushed_item);\n-                                                }\n+    if_chain! {\n+        if same_item_push_visitor.should_lint();\n+        if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push;\n+        let vec_ty = cx.typeck_results().expr_ty(vec);\n+        let ty = vec_ty.walk().nth(1).unwrap().expect_ty();\n+        if cx\n+            .tcx\n+            .lang_items()\n+            .clone_trait()\n+            .map_or(false, |id| implements_trait(cx, ty, id, &[]));\n+        then {\n+            // Make sure that the push does not involve possibly mutating values\n+            match pushed_item.kind {\n+                ExprKind::Path(ref qpath) => {\n+                    match cx.qpath_res(qpath, pushed_item.hir_id) {\n+                        // immutable bindings that are initialized with literal or constant\n+                        Res::Local(hir_id) => {\n+                            let node = cx.tcx.hir().get(hir_id);\n+                            if_chain! {\n+                                if let Node::Binding(pat) = node;\n+                                if let PatKind::Binding(bind_ann, ..) = pat.kind;\n+                                if !matches!(bind_ann, BindingAnnotation::RefMut | BindingAnnotation::Mutable);\n+                                let parent_node = cx.tcx.hir().get_parent_node(hir_id);\n+                                if let Some(Node::Local(parent_let_expr)) = cx.tcx.hir().find(parent_node);\n+                                if let Some(init) = parent_let_expr.init;\n+                                then {\n+                                    match init.kind {\n+                                        // immutable bindings that are initialized with literal\n+                                        ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n+                                        // immutable bindings that are initialized with constant\n+                                        ExprKind::Path(ref path) => {\n+                                            if let Res::Def(DefKind::Const, ..) = cx.qpath_res(path, init.hir_id) {\n+                                                emit_lint(cx, vec, pushed_item);\n                                             }\n-                                            _ => {},\n                                         }\n+                                        _ => {},\n                                     }\n                                 }\n-                            },\n-                            // constant\n-                            Res::Def(DefKind::Const, ..) => emit_lint(cx, vec, pushed_item),\n-                            _ => {},\n-                        }\n-                    },\n-                    ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n-                    _ => {},\n-                }\n+                            }\n+                        },\n+                        // constant\n+                        Res::Def(DefKind::Const, ..) => emit_lint(cx, vec, pushed_item),\n+                        _ => {},\n+                    }\n+                },\n+                ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n+                _ => {},\n             }\n         }\n     }\n }\n \n // Scans the body of the for loop and determines whether lint should be given\n struct SameItemPushVisitor<'a, 'tcx> {\n-    should_lint: bool,\n+    non_deterministic_expr: bool,\n+    multiple_pushes: bool,\n     // this field holds the last vec push operation visited, which should be the only push seen\n     vec_push: Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>,\n     cx: &'a LateContext<'tcx>,\n+    used_locals: FxHashSet<HirId>,\n+}\n+\n+impl<'a, 'tcx> SameItemPushVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> Self {\n+        Self {\n+            non_deterministic_expr: false,\n+            multiple_pushes: false,\n+            vec_push: None,\n+            cx,\n+            used_locals: FxHashSet::default(),\n+        }\n+    }\n+\n+    fn should_lint(&self) -> bool {\n+        if_chain! {\n+            if !self.non_deterministic_expr;\n+            if !self.multiple_pushes;\n+            if let Some((vec, _)) = self.vec_push;\n+            if let Some(hir_id) = path_to_local(vec);\n+            then {\n+                !self.used_locals.contains(&hir_id)\n+            } else {\n+                false\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n@@ -113,9 +139,14 @@ impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         match &expr.kind {\n             // Non-determinism may occur ... don't give a lint\n-            ExprKind::Loop(..) | ExprKind::Match(..) => self.should_lint = false,\n+            ExprKind::Loop(..) | ExprKind::Match(..) | ExprKind::If(..) => self.non_deterministic_expr = true,\n             ExprKind::Block(block, _) => self.visit_block(block),\n-            _ => {},\n+            _ => {\n+                if let Some(hir_id) = path_to_local(expr) {\n+                    self.used_locals.insert(hir_id);\n+                }\n+                walk_expr(self, expr);\n+            },\n         }\n     }\n \n@@ -130,7 +161,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n         if vec_push_option.is_none() {\n             // Current statement is not a push so visit inside\n             match &s.kind {\n-                StmtKind::Expr(expr) | StmtKind::Semi(expr) => self.visit_expr(&expr),\n+                StmtKind::Expr(expr) | StmtKind::Semi(expr) => self.visit_expr(expr),\n                 _ => {},\n             }\n         } else {\n@@ -140,7 +171,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n                 self.vec_push = vec_push_option;\n             } else {\n                 // There are multiple pushes ... don't lint\n-                self.should_lint = false;\n+                self.multiple_pushes = true;\n             }\n         }\n     }"}, {"sha": "fc067e81bcafb7cd25b0817fc0f0e58106daae25", "filename": "clippy_lints/src/loops/single_element_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -15,12 +15,12 @@ pub(super) fn check<'tcx>(\n     expr: &'tcx Expr<'_>,\n ) {\n     if_chain! {\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arg_expr) = arg.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, arg_expr) = arg.kind;\n         if let PatKind::Binding(.., target, _) = pat.kind;\n         if let ExprKind::Array([arg_expression]) = arg_expr.kind;\n         if let ExprKind::Path(ref list_item) = arg_expression.kind;\n         if let Some(list_item_name) = single_segment_path(list_item).map(|ps| ps.ident.name);\n-        if let ExprKind::Block(ref block, _) = body.kind;\n+        if let ExprKind::Block(block, _) = body.kind;\n         if !block.stmts.is_empty();\n \n         then {"}, {"sha": "4db6644b9d705fb1a6f28f2e05549bc5c7f0cd0f", "filename": "clippy_lints/src/loops/utils.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Futils.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,9 +1,9 @@\n use clippy_utils::ty::{has_iter_method, implements_trait};\n use clippy_utils::{get_parent_expr, is_integer_const, path_to_local, path_to_local_id, sugg};\n use if_chain::if_chain;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n+use rustc_hir::HirIdMap;\n use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n@@ -20,17 +20,17 @@ enum IncrementVisitorVarState {\n \n /// Scan a for loop for variables that are incremented exactly once and not used after that.\n pub(super) struct IncrementVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,                          // context reference\n-    states: FxHashMap<HirId, IncrementVisitorVarState>, // incremented variables\n-    depth: u32,                                         // depth of conditional expressions\n+    cx: &'a LateContext<'tcx>,                  // context reference\n+    states: HirIdMap<IncrementVisitorVarState>, // incremented variables\n+    depth: u32,                                 // depth of conditional expressions\n     done: bool,\n }\n \n impl<'a, 'tcx> IncrementVisitor<'a, 'tcx> {\n     pub(super) fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n-            states: FxHashMap::default(),\n+            states: HirIdMap::default(),\n             depth: 0,\n             done: false,\n         }\n@@ -65,7 +65,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n                 }\n \n                 match parent.kind {\n-                    ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+                    ExprKind::AssignOp(op, lhs, rhs) => {\n                         if lhs.hir_id == expr.hir_id {\n                             *state = if op.node == BinOpKind::Add\n                                 && is_integer_const(self.cx, rhs, 1)\n@@ -79,7 +79,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n                             };\n                         }\n                     },\n-                    ExprKind::Assign(ref lhs, _, _) if lhs.hir_id == expr.hir_id => {\n+                    ExprKind::Assign(lhs, _, _) if lhs.hir_id == expr.hir_id => {\n                         *state = IncrementVisitorVarState::DontWarn\n                     },\n                     ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {\n@@ -153,7 +153,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n         // Look for declarations of the variable\n         if_chain! {\n-            if let StmtKind::Local(ref local) = stmt.kind;\n+            if let StmtKind::Local(local) = stmt.kind;\n             if local.pat.hir_id == self.var_id;\n             if let PatKind::Binding(.., ident, _) = local.pat.kind;\n             then {\n@@ -191,10 +191,10 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n \n             if let Some(parent) = get_parent_expr(self.cx, expr) {\n                 match parent.kind {\n-                    ExprKind::AssignOp(_, ref lhs, _) if lhs.hir_id == expr.hir_id => {\n+                    ExprKind::AssignOp(_, lhs, _) if lhs.hir_id == expr.hir_id => {\n                         self.state = InitializeVisitorState::DontWarn;\n                     },\n-                    ExprKind::Assign(ref lhs, ref rhs, _) if lhs.hir_id == expr.hir_id => {\n+                    ExprKind::Assign(lhs, rhs, _) if lhs.hir_id == expr.hir_id => {\n                         self.state = if_chain! {\n                             if self.depth == 0;\n                             if let InitializeVisitorState::Declared(name)\n@@ -273,7 +273,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n             return;\n         }\n         match expr.kind {\n-            ExprKind::Assign(ref path, _, _) | ExprKind::AssignOp(_, ref path, _) => {\n+            ExprKind::Assign(path, _, _) | ExprKind::AssignOp(_, path, _) => {\n                 if path_to_local_id(path, self.iterator) {\n                     self.nesting = RuledOut;\n                 }\n@@ -327,15 +327,15 @@ pub(super) fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic\n         // (&mut x).into_iter() ==> x.iter_mut()\n         match &arg.kind {\n             ExprKind::AddrOf(BorrowKind::Ref, mutability, arg_inner)\n-                if has_iter_method(cx, cx.typeck_results().expr_ty(&arg_inner)).is_some() =>\n+                if has_iter_method(cx, cx.typeck_results().expr_ty(arg_inner)).is_some() =>\n             {\n                 let meth_name = match mutability {\n                     Mutability::Mut => \"iter_mut\",\n                     Mutability::Not => \"iter\",\n                 };\n                 format!(\n                     \"{}.{}()\",\n-                    sugg::Sugg::hir_with_applicability(cx, &arg_inner, \"_\", applic_ref).maybe_par(),\n+                    sugg::Sugg::hir_with_applicability(cx, arg_inner, \"_\", applic_ref).maybe_par(),\n                     meth_name,\n                 )\n             }"}, {"sha": "de267cc77d2b406f0c369cd8f2e2101a3bb3502a", "filename": "clippy_lints/src/loops/while_immutable_condition.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -3,13 +3,13 @@ use crate::consts::constant;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::usage::mutated_variables;\n use if_chain::if_chain;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::DefIdMap;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{def_id, Expr, ExprKind, HirId, QPath};\n+use rustc_hir::HirIdSet;\n+use rustc_hir::{Expr, ExprKind, QPath};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n-use std::iter::Iterator;\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) {\n     if constant(cx, cx.typeck_results(), cond).is_some() {\n@@ -19,8 +19,8 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, expr: &'\n \n     let mut var_visitor = VarCollectorVisitor {\n         cx,\n-        ids: FxHashSet::default(),\n-        def_ids: FxHashMap::default(),\n+        ids: HirIdSet::default(),\n+        def_ids: DefIdMap::default(),\n         skip: false,\n     };\n     var_visitor.visit_expr(cond);\n@@ -93,8 +93,8 @@ impl<'tcx> Visitor<'tcx> for HasBreakOrReturnVisitor {\n /// All variables definition IDs are collected\n struct VarCollectorVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n-    ids: FxHashSet<HirId>,\n-    def_ids: FxHashMap<def_id::DefId, bool>,\n+    ids: HirIdSet,\n+    def_ids: DefIdMap<bool>,\n     skip: bool,\n }\n \n@@ -103,9 +103,8 @@ impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n         if_chain! {\n             if let ExprKind::Path(ref qpath) = ex.kind;\n             if let QPath::Resolved(None, _) = *qpath;\n-            let res = self.cx.qpath_res(qpath, ex.hir_id);\n             then {\n-                match res {\n+                match self.cx.qpath_res(qpath, ex.hir_id) {\n                     Res::Local(hir_id) => {\n                         self.ids.insert(hir_id);\n                     },"}, {"sha": "9c1720798529de1187bdddf8e47f7c02b0a09f23", "filename": "clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -11,14 +11,14 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'\n     let inner_stmt_expr = extract_expr_from_first_stmt(loop_block);\n     // or extract the first expression (if any) from the block\n     if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(loop_block)) {\n-        if let ExprKind::Match(ref matchexpr, ref arms, ref source) = inner.kind {\n+        if let ExprKind::Match(matchexpr, arms, ref source) = inner.kind {\n             // ensure \"if let\" compatible match structure\n             match *source {\n                 MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n                     if arms.len() == 2\n                         && arms[0].guard.is_none()\n                         && arms[1].guard.is_none()\n-                        && is_simple_break_expr(&arms[1].body)\n+                        && is_simple_break_expr(arms[1].body)\n                     {\n                         if in_external_macro(cx.sess(), expr.span) {\n                             return;\n@@ -57,7 +57,7 @@ fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<\n     if block.stmts.is_empty() {\n         return None;\n     }\n-    if let StmtKind::Local(ref local) = block.stmts[0].kind {\n+    if let StmtKind::Local(local) = block.stmts[0].kind {\n         local.init //.map(|expr| expr)\n     } else {\n         None\n@@ -67,9 +67,9 @@ fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<\n /// If a block begins with an expression (with or without semicolon), return it.\n fn extract_first_expr<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     match block.expr {\n-        Some(ref expr) if block.stmts.is_empty() => Some(expr),\n+        Some(expr) if block.stmts.is_empty() => Some(expr),\n         None if !block.stmts.is_empty() => match block.stmts[0].kind {\n-            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => Some(expr),\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => Some(expr),\n             StmtKind::Local(..) | StmtKind::Item(..) => None,\n         },\n         _ => None,\n@@ -82,7 +82,7 @@ fn extract_first_expr<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Break(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n-        ExprKind::Block(ref b, _) => extract_first_expr(b).map_or(false, |subexpr| is_simple_break_expr(subexpr)),\n+        ExprKind::Block(b, _) => extract_first_expr(b).map_or(false, |subexpr| is_simple_break_expr(subexpr)),\n         _ => false,\n     }\n }"}, {"sha": "82715d9bafacca72c8e6317b992e7134b8ba7024", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -16,12 +16,10 @@ use rustc_middle::hir::map::Map;\n use rustc_span::symbol::sym;\n \n pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let ExprKind::Match(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.kind {\n+    if let ExprKind::Match(match_expr, arms, MatchSource::WhileLetDesugar) = expr.kind {\n         let pat = &arms[0].pat.kind;\n-        if let (\n-            &PatKind::TupleStruct(ref qpath, ref pat_args, _),\n-            &ExprKind::MethodCall(ref method_path, _, ref method_args, _),\n-        ) = (pat, &match_expr.kind)\n+        if let (&PatKind::TupleStruct(ref qpath, pat_args, _), &ExprKind::MethodCall(method_path, _, method_args, _)) =\n+            (pat, &match_expr.kind)\n         {\n             let iter_expr = &method_args[0];\n \n@@ -40,8 +38,8 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n                 && is_trait_method(cx, match_expr, sym::Iterator)\n                 && lhs_constructor.ident.name == sym::Some\n                 && (pat_args.is_empty()\n-                    || !is_refutable(cx, &pat_args[0])\n-                        && !is_used_inside(cx, iter_expr, &arms[0].body)\n+                    || !is_refutable(cx, pat_args[0])\n+                        && !is_used_inside(cx, iter_expr, arms[0].body)\n                         && !is_iterator_used_after_while_let(cx, iter_expr)\n                         && !is_nested(cx, expr, &method_args[0]))\n             {"}, {"sha": "c506d52e7462a09f5417bff79058ee9372b1581c", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -9,7 +9,7 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{edition::Edition, Span};\n+use rustc_span::{edition::Edition, sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `#[macro_use] use...`.\n@@ -110,9 +110,7 @@ impl<'tcx> LateLintPass<'tcx> for MacroUseImports {\n             if cx.sess().opts.edition >= Edition::Edition2018;\n             if let hir::ItemKind::Use(path, _kind) = &item.kind;\n             let attrs = cx.tcx.hir().attrs(item.hir_id());\n-            if let Some(mac_attr) = attrs\n-                .iter()\n-                .find(|attr| attr.ident().map(|s| s.to_string()) == Some(\"macro_use\".to_string()));\n+            if let Some(mac_attr) = attrs.iter().find(|attr| attr.has_name(sym::macro_use));\n             if let Res::Def(DefKind::Mod, id) = path.res;\n             then {\n                 for kid in cx.tcx.item_children(id).iter() {"}, {"sha": "8c9e3af62f482568fc5382df4e9b6878410ee94f", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -2,7 +2,7 @@ use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{can_partially_move_ty, is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n-use clippy_utils::{is_allowed, is_else_clause_of_if_let_else, match_def_path, match_var, paths, peel_hir_expr_refs};\n+use clippy_utils::{in_constant, is_allowed, is_else_clause, match_def_path, match_var, paths, peel_hir_expr_refs};\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::{\n@@ -47,16 +47,16 @@ declare_lint_pass!(ManualMap => [MANUAL_MAP]);\n impl LateLintPass<'_> for ManualMap {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if in_external_macro(cx.sess(), expr.span) {\n-            return;\n-        }\n-\n         if let ExprKind::Match(\n             scrutinee,\n             [arm1 @ Arm { guard: None, .. }, arm2 @ Arm { guard: None, .. }],\n             match_kind,\n         ) = expr.kind\n         {\n+            if in_external_macro(cx.sess(), expr.span) || in_constant(cx, expr.hir_id) {\n+                return;\n+            }\n+\n             let (scrutinee_ty, ty_ref_count, ty_mutability) =\n                 peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n             if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n@@ -181,8 +181,7 @@ impl LateLintPass<'_> for ManualMap {\n                 expr.span,\n                 \"manual implementation of `Option::map`\",\n                 \"try this\",\n-                if matches!(match_kind, MatchSource::IfLetDesugar { .. }) && is_else_clause_of_if_let_else(cx.tcx, expr)\n-                {\n+                if matches!(match_kind, MatchSource::IfLetDesugar { .. }) && is_else_clause(cx.tcx, expr) {\n                     format!(\"{{ {}{}.map({}) }}\", scrutinee_str, as_ref_str, body_str)\n                 } else {\n                     format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str)"}, {"sha": "dc19805b50abdbec8ae3e04ca9b5f1426c6b4505", "filename": "clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,9 +1,9 @@\n+use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::meets_msrv;\n use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n-use rustc_ast::ast::{Attribute, FieldDef, Item, ItemKind, Variant, VariantData, VisibilityKind};\n-use rustc_attr as attr;\n+use rustc_ast::ast::{FieldDef, Item, ItemKind, Variant, VariantData, VisibilityKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_semver::RustcVersion;\n@@ -102,19 +102,11 @@ fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants\n     fn is_non_exhaustive_marker(variant: &Variant) -> bool {\n         matches!(variant.data, VariantData::Unit(_))\n             && variant.ident.as_str().starts_with('_')\n-            && variant.attrs.iter().any(|a| is_doc_hidden(a))\n-    }\n-\n-    fn is_doc_hidden(attr: &Attribute) -> bool {\n-        attr.has_name(sym::doc)\n-            && match attr.meta_item_list() {\n-                Some(l) => attr::list_contains_name(&l, sym::hidden),\n-                None => false,\n-            }\n+            && is_doc_hidden(&variant.attrs)\n     }\n \n+    let mut markers = variants.iter().filter(|v| is_non_exhaustive_marker(v));\n     if_chain! {\n-        let mut markers = variants.iter().filter(|v| is_non_exhaustive_marker(v));\n         if let Some(marker) = markers.next();\n         if markers.count() == 0 && variants.len() > 1;\n         then {"}, {"sha": "dfa464ddb81ac4e1043cb17907b998092af7a5d5", "filename": "clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_strip.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -91,7 +91,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n                 } else {\n                     return;\n                 };\n-                let target_res = cx.qpath_res(&target_path, target_arg.hir_id);\n+                let target_res = cx.qpath_res(target_path, target_arg.hir_id);\n                 if target_res == Res::Err {\n                     return;\n                 };\n@@ -174,7 +174,7 @@ fn eq_pattern_length<'tcx>(cx: &LateContext<'tcx>, pattern: &Expr<'_>, expr: &'t\n \n // Tests if `expr` is a `&str`.\n fn is_ref_str(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    match cx.typeck_results().expr_ty_adjusted(&expr).kind() {\n+    match cx.typeck_results().expr_ty_adjusted(expr).kind() {\n         ty::Ref(_, ty, _) => ty.is_str(),\n         _ => false,\n     }"}, {"sha": "99c35ae3bbf4c68393408490c906e8d5bb069a26", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -52,17 +52,17 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n         }\n \n         if_chain! {\n-            if let hir::ExprKind::MethodCall(ref method, _, ref args, _) = e.kind;\n+            if let hir::ExprKind::MethodCall(method, _, args, _) = e.kind;\n             if args.len() == 2;\n             if method.ident.name == sym::map;\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n             if is_type_diagnostic_item(cx, ty, sym::option_type) || is_trait_method(cx, e, sym::Iterator);\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].kind;\n-            let closure_body = cx.tcx.hir().body(body_id);\n-            let closure_expr = remove_blocks(&closure_body.value);\n             then {\n+                let closure_body = cx.tcx.hir().body(body_id);\n+                let closure_expr = remove_blocks(&closure_body.value);\n                 match closure_body.params[0].pat.kind {\n-                    hir::PatKind::Ref(ref inner, hir::Mutability::Not) => if let hir::PatKind::Binding(\n+                    hir::PatKind::Ref(inner, hir::Mutability::Not) => if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated, .., name, None\n                     ) = inner.kind {\n                         if ident_eq(name, closure_expr) {\n@@ -71,14 +71,14 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                     },\n                     hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, .., name, None) => {\n                         match closure_expr.kind {\n-                            hir::ExprKind::Unary(hir::UnOp::Deref, ref inner) => {\n+                            hir::ExprKind::Unary(hir::UnOp::Deref, inner) => {\n                                 if ident_eq(name, inner) {\n                                     if let ty::Ref(.., Mutability::Not) = cx.typeck_results().expr_ty(inner).kind() {\n                                         lint(cx, e.span, args[0].span, true);\n                                     }\n                                 }\n                             },\n-                            hir::ExprKind::MethodCall(ref method, _, [obj], _) => if_chain! {\n+                            hir::ExprKind::MethodCall(method, _, [obj], _) => if_chain! {\n                                 if ident_eq(name, obj) && method.ident.name == sym::clone;\n                                 if let Some(fn_id) = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id);\n                                 if let Some(trait_id) = cx.tcx.trait_of_item(fn_id);\n@@ -109,7 +109,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n }\n \n fn ident_eq(name: Ident, path: &hir::Expr<'_>) -> bool {\n-    if let hir::ExprKind::Path(hir::QPath::Resolved(None, ref path)) = path.kind {\n+    if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = path.kind {\n         path.segments.len() == 1 && path.segments[0].ident == name\n     } else {\n         false"}, {"sha": "425a9734e5feeeaa1bd951df116e965eb0e401bb", "filename": "clippy_lints/src/map_err_ignore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmap_err_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmap_err_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_err_ignore.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -112,7 +112,7 @@ impl<'tcx> LateLintPass<'tcx> for MapErrIgnore {\n         }\n \n         // check if this is a method call (e.g. x.foo())\n-        if let ExprKind::MethodCall(ref method, _t_span, ref args, _) = e.kind {\n+        if let ExprKind::MethodCall(method, _t_span, args, _) = e.kind {\n             // only work if the method name is `map_err` and there are only 2 arguments (e.g. x.map_err(|_|[1]\n             // Enum::Variant[2]))\n             if method.ident.as_str() == \"map_err\" && args.len() == 2 {"}, {"sha": "e7719e7663d643737787a9846f2eb0bfade3296b", "filename": "clippy_lints/src/map_identity.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_identity.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for MapIdentity {\n /// map(). Otherwise, returns None.\n fn get_map_argument<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a [Expr<'a>]> {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n+        if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n         if args.len() == 2 && method.ident.name == sym::map;\n         let caller_ty = cx.typeck_results().expr_ty(&args[0]);\n         if is_trait_method(cx, expr, sym::Iterator)\n@@ -80,7 +80,7 @@ fn get_map_argument<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a\n fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Closure(_, _, body_id, _, _) => is_body_identity_function(cx, cx.tcx.hir().body(body_id)),\n-        ExprKind::Path(QPath::Resolved(_, ref path)) => match_path(path, &paths::STD_CONVERT_IDENTITY),\n+        ExprKind::Path(QPath::Resolved(_, path)) => match_path(path, &paths::STD_CONVERT_IDENTITY),\n         _ => false,\n     }\n }\n@@ -99,12 +99,12 @@ fn is_body_identity_function(cx: &LateContext<'_>, func: &Body<'_>) -> bool {\n \n     match body.kind {\n         ExprKind::Path(QPath::Resolved(None, _)) => match_expr_param(cx, body, params[0].pat),\n-        ExprKind::Ret(Some(ref ret_val)) => match_expr_param(cx, ret_val, params[0].pat),\n-        ExprKind::Block(ref block, _) => {\n+        ExprKind::Ret(Some(ret_val)) => match_expr_param(cx, ret_val, params[0].pat),\n+        ExprKind::Block(block, _) => {\n             if_chain! {\n                 if block.stmts.len() == 1;\n-                if let StmtKind::Semi(ref expr) | StmtKind::Expr(ref expr) = block.stmts[0].kind;\n-                if let ExprKind::Ret(Some(ref ret_val)) = expr.kind;\n+                if let StmtKind::Semi(expr) | StmtKind::Expr(expr) = block.stmts[0].kind;\n+                if let ExprKind::Ret(Some(ret_val)) = expr.kind;\n                 then {\n                     match_expr_param(cx, ret_val, params[0].pat)\n                 } else {"}, {"sha": "57cd907e77e8da975a56773a5e357e0125de3394", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -133,7 +133,7 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_>, expr: &'a hir::Expr<'_>) ->\n             // Calls can't be reduced any more\n             Some(expr.span)\n         },\n-        hir::ExprKind::Block(ref block, _) => {\n+        hir::ExprKind::Block(block, _) => {\n             match (block.stmts, block.expr.as_ref()) {\n                 (&[], Some(inner_expr)) => {\n                     // If block only contains an expression,\n@@ -144,8 +144,8 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_>, expr: &'a hir::Expr<'_>) ->\n                     // If block only contains statements,\n                     // reduce `{ X; }` to `X` or `X;`\n                     match inner_stmt.kind {\n-                        hir::StmtKind::Local(ref local) => Some(local.span),\n-                        hir::StmtKind::Expr(ref e) => Some(e.span),\n+                        hir::StmtKind::Local(local) => Some(local.span),\n+                        hir::StmtKind::Expr(e) => Some(e.span),\n                         hir::StmtKind::Semi(..) => Some(inner_stmt.span),\n                         hir::StmtKind::Item(..) => None,\n                     }\n@@ -168,17 +168,15 @@ fn unit_closure<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &hir::Expr<'_>,\n ) -> Option<(&'tcx hir::Param<'tcx>, &'tcx hir::Expr<'tcx>)> {\n-    if let hir::ExprKind::Closure(_, ref decl, inner_expr_id, _, _) = expr.kind {\n+    if_chain! {\n+        if let hir::ExprKind::Closure(_, decl, inner_expr_id, _, _) = expr.kind;\n         let body = cx.tcx.hir().body(inner_expr_id);\n         let body_expr = &body.value;\n-\n-        if_chain! {\n-            if decl.inputs.len() == 1;\n-            if is_unit_expression(cx, body_expr);\n-            if let Some(binding) = iter_input_pats(&decl, body).next();\n-            then {\n-                return Some((binding, body_expr));\n-            }\n+        if decl.inputs.len() == 1;\n+        if is_unit_expression(cx, body_expr);\n+        if let Some(binding) = iter_input_pats(decl, body).next();\n+        then {\n+            return Some((binding, body_expr));\n         }\n     }\n     None\n@@ -269,7 +267,7 @@ impl<'tcx> LateLintPass<'tcx> for MapUnit {\n             return;\n         }\n \n-        if let hir::StmtKind::Semi(ref expr) = stmt.kind {\n+        if let hir::StmtKind::Semi(expr) = stmt.kind {\n             if let Some(arglists) = method_chain_args(expr, &[\"map\"]) {\n                 lint_map_unit_fn(cx, stmt, expr, arglists[0]);\n             }"}, {"sha": "ca6fb0831fe223879806e205b5b62226dde677be", "filename": "clippy_lints/src/match_on_vec_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchOnVecItems {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if_chain! {\n             if !in_external_macro(cx.sess(), expr.span);\n-            if let ExprKind::Match(ref match_expr, _, MatchSource::Normal) = expr.kind;\n+            if let ExprKind::Match(match_expr, _, MatchSource::Normal) = expr.kind;\n             if let Some(idx_expr) = is_vec_indexing(cx, match_expr);\n             if let ExprKind::Index(vec, idx) = idx_expr.kind;\n \n@@ -78,7 +78,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchOnVecItems {\n \n fn is_vec_indexing<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     if_chain! {\n-        if let ExprKind::Index(ref array, ref index) = expr.kind;\n+        if let ExprKind::Index(array, index) = expr.kind;\n         if is_vector(cx, array);\n         if !is_full_range(cx, index);\n "}, {"sha": "c8ee0abd3dfefa81cf6db517adbaba50ea815628", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 67, "deletions": 59, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -13,13 +13,13 @@ use clippy_utils::{\n use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::{\n     self as hir, Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, HirId, Local, MatchSource,\n     Mutability, Node, Pat, PatKind, PathSegment, QPath, RangeEnd, TyKind,\n };\n+use rustc_hir::{HirIdMap, HirIdSet};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty, TyS, VariantDef};\n@@ -590,7 +590,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n             lint_match_arms(cx, expr);\n         }\n \n-        if let ExprKind::Match(ref ex, ref arms, MatchSource::Normal) = expr.kind {\n+        if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n             check_single_match(cx, ex, arms, expr);\n             check_match_bool(cx, ex, arms, expr);\n             check_overlapping_arms(cx, ex, arms);\n@@ -605,7 +605,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                 check_match_single_binding(cx, ex, arms, expr);\n             }\n         }\n-        if let ExprKind::Match(ref ex, ref arms, _) = expr.kind {\n+        if let ExprKind::Match(ex, arms, _) = expr.kind {\n             check_match_ref_pats(cx, ex, arms, expr);\n         }\n     }\n@@ -614,14 +614,14 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         if_chain! {\n             if !in_external_macro(cx.sess(), local.span);\n             if !in_macro(local.span);\n-            if let Some(ref expr) = local.init;\n-            if let ExprKind::Match(ref target, ref arms, MatchSource::Normal) = expr.kind;\n+            if let Some(expr) = local.init;\n+            if let ExprKind::Match(target, arms, MatchSource::Normal) = expr.kind;\n             if arms.len() == 1 && arms[0].guard.is_none();\n             if let PatKind::TupleStruct(\n-                QPath::Resolved(None, ref variant_name), ref args, _) = arms[0].pat.kind;\n+                QPath::Resolved(None, variant_name), args, _) = arms[0].pat.kind;\n             if args.len() == 1;\n-            if let PatKind::Binding(_, arg, ..) = strip_pat_refs(&args[0]).kind;\n-            let body = remove_blocks(&arms[0].body);\n+            if let PatKind::Binding(_, arg, ..) = strip_pat_refs(args[0]).kind;\n+            let body = remove_blocks(arms[0].body);\n             if path_to_local_id(body, arg);\n \n             then {\n@@ -650,7 +650,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         if_chain! {\n             if !in_external_macro(cx.sess(), pat.span);\n             if !in_macro(pat.span);\n-            if let PatKind::Struct(QPath::Resolved(_, ref path), fields, true) = pat.kind;\n+            if let PatKind::Struct(QPath::Resolved(_, path), fields, true) = pat.kind;\n             if let Some(def_id) = path.res.opt_def_id();\n             let ty = cx.tcx.type_of(def_id);\n             if let ty::Adt(def, _) = ty.kind();\n@@ -733,8 +733,8 @@ fn report_single_match_single_pattern(\n         format!(\" else {}\", expr_block(cx, els, None, \"..\", Some(expr.span)))\n     });\n \n+    let (pat, pat_ref_count) = peel_hir_pat_refs(arms[0].pat);\n     let (msg, sugg) = if_chain! {\n-        let (pat, pat_ref_count) = peel_hir_pat_refs(arms[0].pat);\n         if let PatKind::Path(_) | PatKind::Lit(_) = pat.kind;\n         let (ty, ty_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(ex));\n         if let Some(trait_id) = cx.tcx.lang_items().structural_peq_trait();\n@@ -762,7 +762,7 @@ fn report_single_match_single_pattern(\n                 // PartialEq for different reference counts may not exist.\n                 \"&\".repeat(ref_count_diff),\n                 snippet(cx, arms[0].pat.span, \"..\"),\n-                expr_block(cx, &arms[0].body, None, \"..\", Some(expr.span)),\n+                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n                 els_str,\n             );\n             (msg, sugg)\n@@ -772,7 +772,7 @@ fn report_single_match_single_pattern(\n                 \"if let {} = {} {}{}\",\n                 snippet(cx, arms[0].pat.span, \"..\"),\n                 snippet(cx, ex.span, \"..\"),\n-                expr_block(cx, &arms[0].body, None, \"..\", Some(expr.span)),\n+                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n                 els_str,\n             );\n             (msg, sugg)\n@@ -810,7 +810,7 @@ fn check_single_match_opt_like(\n     ];\n \n     let path = match arms[1].pat.kind {\n-        PatKind::TupleStruct(ref path, ref inner, _) => {\n+        PatKind::TupleStruct(ref path, inner, _) => {\n             // Contains any non wildcard patterns (e.g., `Err(err)`)?\n             if !inner.iter().all(is_wild) {\n                 return;\n@@ -842,7 +842,7 @@ fn check_match_bool(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr:\n             move |diag| {\n                 if arms.len() == 2 {\n                     // no guards\n-                    let exprs = if let PatKind::Lit(ref arm_bool) = arms[0].pat.kind {\n+                    let exprs = if let PatKind::Lit(arm_bool) = arms[0].pat.kind {\n                         if let ExprKind::Lit(ref lit) = arm_bool.kind {\n                             match lit.node {\n                                 LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n@@ -918,14 +918,14 @@ fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm\n     let ex_ty = cx.typeck_results().expr_ty(ex).peel_refs();\n     if is_type_diagnostic_item(cx, ex_ty, sym::result_type) {\n         for arm in arms {\n-            if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pat.kind {\n+            if let PatKind::TupleStruct(ref path, inner, _) = arm.pat.kind {\n                 let path_str = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false));\n                 if path_str == \"Err\" {\n                     let mut matching_wild = inner.iter().any(is_wild);\n                     let mut ident_bind_name = String::from(\"_\");\n                     if !matching_wild {\n                         // Looking for unused bindings (i.e.: `_e`)\n-                        inner.iter().for_each(|pat| {\n+                        for pat in inner.iter() {\n                             if let PatKind::Binding(_, id, ident, None) = pat.kind {\n                                 if ident.as_str().starts_with('_')\n                                     && !LocalUsedVisitor::new(cx, id).check_expr(arm.body)\n@@ -934,11 +934,11 @@ fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm\n                                     matching_wild = true;\n                                 }\n                             }\n-                        });\n+                        }\n                     }\n                     if_chain! {\n                         if matching_wild;\n-                        if let ExprKind::Block(ref block, _) = arm.body.kind;\n+                        if let ExprKind::Block(block, _) = arm.body.kind;\n                         if is_panic_block(block);\n                         then {\n                             // `Err(_)` or `Err(_e)` arm with `panic!` found\n@@ -984,6 +984,11 @@ impl CommonPrefixSearcher<'a> {\n     }\n }\n \n+fn is_doc_hidden(cx: &LateContext<'_>, variant_def: &VariantDef) -> bool {\n+    let attrs = cx.tcx.get_attrs(variant_def.def_id);\n+    clippy_utils::attrs::is_doc_hidden(attrs)\n+}\n+\n #[allow(clippy::too_many_lines)]\n fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n     let ty = cx.typeck_results().expr_ty(ex).peel_refs();\n@@ -1042,16 +1047,18 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n                     path\n                 },\n                 PatKind::TupleStruct(path, patterns, ..) => {\n-                    if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p)) {\n-                        let id = cx.qpath_res(path, pat.hir_id).def_id();\n-                        missing_variants.retain(|e| e.ctor_def_id != Some(id));\n+                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n+                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p)) {\n+                            missing_variants.retain(|e| e.ctor_def_id != Some(id));\n+                        }\n                     }\n                     path\n                 },\n                 PatKind::Struct(path, patterns, ..) => {\n-                    if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p.pat)) {\n-                        let id = cx.qpath_res(path, pat.hir_id).def_id();\n-                        missing_variants.retain(|e| e.def_id != id);\n+                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n+                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p.pat)) {\n+                            missing_variants.retain(|e| e.def_id != id);\n+                        }\n                     }\n                     path\n                 },\n@@ -1103,7 +1110,7 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n \n     match missing_variants.as_slice() {\n         [] => (),\n-        [x] if !adt_def.is_variant_list_non_exhaustive() => span_lint_and_sugg(\n+        [x] if !adt_def.is_variant_list_non_exhaustive() && !is_doc_hidden(cx, x) => span_lint_and_sugg(\n             cx,\n             MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n             wildcard_span,\n@@ -1137,9 +1144,7 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n // If the block contains only a `panic!` macro (as expression or statement)\n fn is_panic_block(block: &Block<'_>) -> bool {\n     match (&block.expr, block.stmts.len(), block.stmts.first()) {\n-        (&Some(ref exp), 0, _) => {\n-            is_expn_of(exp.span, \"panic\").is_some() && is_expn_of(exp.span, \"unreachable\").is_none()\n-        },\n+        (&Some(exp), 0, _) => is_expn_of(exp.span, \"panic\").is_some() && is_expn_of(exp.span, \"unreachable\").is_none(),\n         (&None, 1, Some(stmt)) => {\n             is_expn_of(stmt.span, \"panic\").is_some() && is_expn_of(stmt.span, \"unreachable\").is_none()\n         },\n@@ -1150,7 +1155,7 @@ fn is_panic_block(block: &Block<'_>) -> bool {\n fn check_match_ref_pats(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if has_only_ref_pats(arms) {\n         let mut suggs = Vec::with_capacity(arms.len() + 1);\n-        let (title, msg) = if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, ref inner) = ex.kind {\n+        let (title, msg) = if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = ex.kind {\n             let span = ex.span.source_callsite();\n             suggs.push((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n             (\n@@ -1167,7 +1172,7 @@ fn check_match_ref_pats(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], e\n         };\n \n         suggs.extend(arms.iter().filter_map(|a| {\n-            if let PatKind::Ref(ref refp, _) = a.pat.kind {\n+            if let PatKind::Ref(refp, _) = a.pat.kind {\n                 Some((a.pat.span, snippet(cx, refp.span, \"..\").to_string()))\n             } else {\n                 None\n@@ -1236,7 +1241,7 @@ fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n \n fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n     for arm in arms {\n-        if let PatKind::Or(ref fields) = arm.pat.kind {\n+        if let PatKind::Or(fields) = arm.pat.kind {\n             // look for multiple fields in this arm that contains at least one Wild pattern\n             if fields.len() > 1 && fields.iter().any(is_wild) {\n                 span_lint_and_help(\n@@ -1302,7 +1307,7 @@ fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr\n             // strip potential borrows (#6503), but only if the type is a reference\n             let mut ex_new = ex;\n             if let ExprKind::AddrOf(BorrowKind::Ref, .., ex_inner) = ex.kind {\n-                if let ty::Ref(..) = cx.typeck_results().expr_ty(&ex_inner).kind() {\n+                if let ty::Ref(..) = cx.typeck_results().expr_ty(ex_inner).kind() {\n                     ex_new = ex_inner;\n                 }\n             };\n@@ -1379,7 +1384,7 @@ fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[A\n \n     let matched_vars = ex.span;\n     let bind_names = arms[0].pat.span;\n-    let match_body = remove_blocks(&arms[0].body);\n+    let match_body = remove_blocks(arms[0].body);\n     let mut snippet_body = if match_body.span.from_expansion() {\n         Sugg::hir_with_macro_callsite(cx, match_body, \"..\").to_string()\n     } else {\n@@ -1390,13 +1395,13 @@ fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[A\n     match match_body.kind {\n         ExprKind::Block(block, _) => {\n             // macro + expr_ty(body) == ()\n-            if block.span.from_expansion() && cx.typeck_results().expr_ty(&match_body).is_unit() {\n+            if block.span.from_expansion() && cx.typeck_results().expr_ty(match_body).is_unit() {\n                 snippet_body.push(';');\n             }\n         },\n         _ => {\n             // expr_ty(body) == ()\n-            if cx.typeck_results().expr_ty(&match_body).is_unit() {\n+            if cx.typeck_results().expr_ty(match_body).is_unit() {\n                 snippet_body.push(';');\n             }\n         },\n@@ -1481,8 +1486,8 @@ fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[A\n \n /// Returns true if the `ex` match expression is in a local (`let`) statement\n fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'a>> {\n+    let map = &cx.tcx.hir();\n     if_chain! {\n-        let map = &cx.tcx.hir();\n         if let Some(Node::Expr(parent_arm_expr)) = map.find(map.get_parent_node(ex.hir_id));\n         if let Some(Node::Local(parent_let_expr)) = map.find(map.get_parent_node(parent_arm_expr.hir_id));\n         then {\n@@ -1496,10 +1501,7 @@ fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'\n fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<Constant>> {\n     arms.iter()\n         .flat_map(|arm| {\n-            if let Arm {\n-                ref pat, guard: None, ..\n-            } = *arm\n-            {\n+            if let Arm { pat, guard: None, .. } = *arm {\n                 if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n                     let lhs = match lhs {\n                         Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n@@ -1519,7 +1521,7 @@ fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>)\n                     });\n                 }\n \n-                if let PatKind::Lit(ref value) = pat.kind {\n+                if let PatKind::Lit(value) = pat.kind {\n                     let value = constant(cx, cx.typeck_results(), value)?.0;\n                     return Some(SpannedRange {\n                         span: pat.span,\n@@ -1566,8 +1568,8 @@ fn type_ranges(ranges: &[SpannedRange<Constant>]) -> TypedRanges {\n \n fn is_unit_expr(expr: &Expr<'_>) -> bool {\n     match expr.kind {\n-        ExprKind::Tup(ref v) if v.is_empty() => true,\n-        ExprKind::Block(ref b, _) if b.stmts.is_empty() && b.expr.is_none() => true,\n+        ExprKind::Tup(v) if v.is_empty() => true,\n+        ExprKind::Block(b, _) if b.stmts.is_empty() && b.expr.is_none() => true,\n         _ => false,\n     }\n }\n@@ -1580,14 +1582,14 @@ fn is_none_arm(arm: &Arm<'_>) -> bool {\n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n fn is_ref_some_arm(arm: &Arm<'_>) -> Option<BindingAnnotation> {\n     if_chain! {\n-        if let PatKind::TupleStruct(ref path, ref pats, _) = arm.pat.kind;\n+        if let PatKind::TupleStruct(ref path, pats, _) = arm.pat.kind;\n         if pats.len() == 1 && match_qpath(path, &paths::OPTION_SOME);\n         if let PatKind::Binding(rb, .., ident, _) = pats[0].kind;\n         if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n-        if let ExprKind::Call(ref e, ref args) = remove_blocks(&arm.body).kind;\n+        if let ExprKind::Call(e, args) = remove_blocks(arm.body).kind;\n         if let ExprKind::Path(ref some_path) = e.kind;\n         if match_qpath(some_path, &paths::OPTION_SOME) && args.len() == 1;\n-        if let ExprKind::Path(QPath::Resolved(_, ref path2)) = args[0].kind;\n+        if let ExprKind::Path(QPath::Resolved(_, path2)) = args[0].kind;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {\n             return Some(rb)\n@@ -1669,7 +1671,7 @@ where\n \n     values.sort();\n \n-    for (a, b) in iter::zip(&values, &values[1..]) {\n+    for (a, b) in iter::zip(&values, values.iter().skip(1)) {\n         match (a, b) {\n             (&Kind::Start(_, ra), &Kind::End(_, rb)) => {\n                 if ra.node != rb.node {\n@@ -1679,7 +1681,7 @@ where\n             (&Kind::End(a, _), &Kind::Start(b, _)) if a != Bound::Included(b) => (),\n             _ => {\n                 // skip if the range `a` is completely included into the range `b`\n-                if let Ordering::Equal | Ordering::Less = a.cmp(&b) {\n+                if let Ordering::Equal | Ordering::Less = a.cmp(b) {\n                     let kind_a = Kind::End(a.range().node.1, a.range());\n                     let kind_b = Kind::End(b.range().node.1, b.range());\n                     if let Ordering::Equal | Ordering::Greater = kind_a.cmp(&kind_b) {\n@@ -1724,8 +1726,14 @@ mod redundant_pattern_match {\n         arms: &[Arm<'_>],\n         keyword: &'static str,\n     ) {\n-        let good_method = match arms[0].pat.kind {\n-            PatKind::TupleStruct(ref path, ref patterns, _) if patterns.len() == 1 => {\n+        // also look inside refs\n+        let mut kind = &arms[0].pat.kind;\n+        // if we have &None for example, peel it so we can detect \"if let None = x\"\n+        if let PatKind::Ref(inner, _mutability) = kind {\n+            kind = &inner.kind;\n+        }\n+        let good_method = match kind {\n+            PatKind::TupleStruct(ref path, patterns, _) if patterns.len() == 1 => {\n                 if let PatKind::Wild = patterns[0].kind {\n                     if match_qpath(path, &paths::RESULT_OK) {\n                         \"is_ok()\"\n@@ -1806,8 +1814,8 @@ mod redundant_pattern_match {\n \n             let found_good_method = match node_pair {\n                 (\n-                    PatKind::TupleStruct(ref path_left, ref patterns_left, _),\n-                    PatKind::TupleStruct(ref path_right, ref patterns_right, _),\n+                    PatKind::TupleStruct(ref path_left, patterns_left, _),\n+                    PatKind::TupleStruct(ref path_right, patterns_right, _),\n                 ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n                     if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n                         find_good_method_for_match(\n@@ -1834,8 +1842,8 @@ mod redundant_pattern_match {\n                         None\n                     }\n                 },\n-                (PatKind::TupleStruct(ref path_left, ref patterns, _), PatKind::Path(ref path_right))\n-                | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, ref patterns, _))\n+                (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Path(ref path_right))\n+                | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, patterns, _))\n                     if patterns.len() == 1 =>\n                 {\n                     if let PatKind::Wild = patterns[0].kind {\n@@ -1957,18 +1965,18 @@ fn test_overlapping() {\n \n /// Implementation of `MATCH_SAME_ARMS`.\n fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n-    if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.kind {\n+    if let ExprKind::Match(_, arms, MatchSource::Normal) = expr.kind {\n         let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n             let mut h = SpanlessHash::new(cx);\n-            h.hash_expr(&arm.body);\n+            h.hash_expr(arm.body);\n             h.finish()\n         };\n \n         let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n             let min_index = usize::min(lindex, rindex);\n             let max_index = usize::max(lindex, rindex);\n \n-            let mut local_map: FxHashMap<HirId, HirId> = FxHashMap::default();\n+            let mut local_map: HirIdMap<HirId> = HirIdMap::default();\n             let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n                 if_chain! {\n                     if let Some(a_id) = path_to_local(a);\n@@ -1996,7 +2004,7 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n             (min_index..=max_index).all(|index| arms[index].guard.is_none())\n                 && SpanlessEq::new(cx)\n                     .expr_fallback(eq_fallback)\n-                    .eq_expr(&lhs.body, &rhs.body)\n+                    .eq_expr(lhs.body, rhs.body)\n                 // these checks could be removed to allow unused bindings\n                 && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n                 && bindings_eq(rhs.pat, local_map.values().copied().collect())\n@@ -2052,7 +2060,7 @@ fn pat_contains_local(pat: &Pat<'_>, id: HirId) -> bool {\n }\n \n /// Returns true if all the bindings in the `Pat` are in `ids` and vice versa\n-fn bindings_eq(pat: &Pat<'_>, mut ids: FxHashSet<HirId>) -> bool {\n+fn bindings_eq(pat: &Pat<'_>, mut ids: HirIdSet) -> bool {\n     let mut result = true;\n     pat.each_binding_or_first(&mut |_, id, _, _| result &= ids.remove(&id));\n     result && ids.is_empty()"}, {"sha": "a735c616f6e416fdeb06e0b8d6232875252b7a80", "filename": "clippy_lints/src/mem_discriminant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -34,7 +34,7 @@ declare_lint_pass!(MemDiscriminant => [MEM_DISCRIMINANT_NON_ENUM]);\n impl<'tcx> LateLintPass<'tcx> for MemDiscriminant {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Call(ref func, ref func_args) = expr.kind;\n+            if let ExprKind::Call(func, func_args) = expr.kind;\n             // is `mem::discriminant`\n             if let ExprKind::Path(ref func_qpath) = func.kind;\n             if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n@@ -59,7 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for MemDiscriminant {\n                             let mut derefs_needed = ptr_depth;\n                             let mut cur_expr = param;\n                             while derefs_needed > 0  {\n-                                if let ExprKind::AddrOf(BorrowKind::Ref, _, ref inner_expr) = cur_expr.kind {\n+                                if let ExprKind::AddrOf(BorrowKind::Ref, _, inner_expr) = cur_expr.kind {\n                                     derefs_needed -= 1;\n                                     cur_expr = inner_expr;\n                                 } else {"}, {"sha": "a28cb5f32fe8abe016001d8674d0a6e016a89a80", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -28,7 +28,7 @@ declare_lint_pass!(MemForget => [MEM_FORGET]);\n \n impl<'tcx> LateLintPass<'tcx> for MemForget {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::Call(ref path_expr, ref args) = e.kind {\n+        if let ExprKind::Call(path_expr, args) = e.kind {\n             if let ExprKind::Path(ref qpath) = path_expr.kind {\n                 if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n                     if match_def_path(cx, def_id, &paths::MEM_FORGET) {"}, {"sha": "e1d351aee45479426fa299d54ec73f022e6a05ee", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -109,14 +109,14 @@ fn check_replace_option_with_none(cx: &LateContext<'_>, src: &Expr<'_>, dest: &E\n             // argument's type. All that's left is to get\n             // replacee's path.\n             let replaced_path = match dest.kind {\n-                ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, ref replaced) => {\n-                    if let ExprKind::Path(QPath::Resolved(None, ref replaced_path)) = replaced.kind {\n+                ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, replaced) => {\n+                    if let ExprKind::Path(QPath::Resolved(None, replaced_path)) = replaced.kind {\n                         replaced_path\n                     } else {\n                         return;\n                     }\n                 },\n-                ExprKind::Path(QPath::Resolved(None, ref replaced_path)) => replaced_path,\n+                ExprKind::Path(QPath::Resolved(None, replaced_path)) => replaced_path,\n                 _ => return,\n             };\n \n@@ -161,7 +161,7 @@ fn check_replace_with_uninit(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'\n     }\n \n     if_chain! {\n-        if let ExprKind::Call(ref repl_func, ref repl_args) = src.kind;\n+        if let ExprKind::Call(repl_func, repl_args) = src.kind;\n         if repl_args.is_empty();\n         if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n         if let Some(repl_def_id) = cx.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n@@ -214,7 +214,7 @@ fn is_default_equivalent_ctor(cx: &LateContext<'_>, def_id: DefId, path: &QPath<\n         .iter()\n         .any(|symbol| is_diagnostic_assoc_item(cx, def_id, *symbol))\n     {\n-        if let QPath::TypeRelative(_, ref method) = path {\n+        if let QPath::TypeRelative(_, method) = path {\n             if method.ident.name == sym::new {\n                 return true;\n             }\n@@ -225,34 +225,33 @@ fn is_default_equivalent_ctor(cx: &LateContext<'_>, def_id: DefId, path: &QPath<\n }\n \n fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n-    if let ExprKind::Call(ref repl_func, _) = src.kind {\n-        if_chain! {\n-            if !in_external_macro(cx.tcx.sess, expr_span);\n-            if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n-            if let Some(repl_def_id) = cx.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n-            if is_diagnostic_assoc_item(cx, repl_def_id, sym::Default)\n-                || is_default_equivalent_ctor(cx, repl_def_id, repl_func_qpath);\n+    if_chain! {\n+        if let ExprKind::Call(repl_func, _) = src.kind;\n+        if !in_external_macro(cx.tcx.sess, expr_span);\n+        if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n+        if let Some(repl_def_id) = cx.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n+        if is_diagnostic_assoc_item(cx, repl_def_id, sym::Default)\n+            || is_default_equivalent_ctor(cx, repl_def_id, repl_func_qpath);\n \n-            then {\n-                span_lint_and_then(\n-                    cx,\n-                    MEM_REPLACE_WITH_DEFAULT,\n-                    expr_span,\n-                    \"replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\",\n-                    |diag| {\n-                        if !in_macro(expr_span) {\n-                            let suggestion = format!(\"std::mem::take({})\", snippet(cx, dest.span, \"\"));\n+        then {\n+            span_lint_and_then(\n+                cx,\n+                MEM_REPLACE_WITH_DEFAULT,\n+                expr_span,\n+                \"replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\",\n+                |diag| {\n+                    if !in_macro(expr_span) {\n+                        let suggestion = format!(\"std::mem::take({})\", snippet(cx, dest.span, \"\"));\n \n-                            diag.span_suggestion(\n-                                expr_span,\n-                                \"consider using\",\n-                                suggestion,\n-                                Applicability::MachineApplicable\n-                            );\n-                        }\n+                        diag.span_suggestion(\n+                            expr_span,\n+                            \"consider using\",\n+                            suggestion,\n+                            Applicability::MachineApplicable\n+                        );\n                     }\n-                );\n-            }\n+                }\n+            );\n         }\n     }\n }\n@@ -274,11 +273,11 @@ impl<'tcx> LateLintPass<'tcx> for MemReplace {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // Check that `expr` is a call to `mem::replace()`\n-            if let ExprKind::Call(ref func, ref func_args) = expr.kind;\n+            if let ExprKind::Call(func, func_args) = expr.kind;\n             if let ExprKind::Path(ref func_qpath) = func.kind;\n             if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::MEM_REPLACE);\n-            if let [dest, src] = &**func_args;\n+            if let [dest, src] = func_args;\n             then {\n                 check_replace_option_with_none(cx, src, dest, expr.span);\n                 check_replace_with_uninit(cx, src, dest, expr.span);"}, {"sha": "287bff886bfbf020663880d11fccd2546ed34421", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 83, "deletions": 86, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,115 +1,96 @@\n use super::{contains_return, BIND_INSTEAD_OF_MAP};\n use clippy_utils::diagnostics::{multispan_sugg_with_applicability, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_with_macro_callsite};\n-use clippy_utils::ty::match_type;\n-use clippy_utils::{in_macro, match_qpath, method_calls, paths, remove_blocks, visitors::find_all_ret_expressions};\n+use clippy_utils::{in_macro, remove_blocks, visitors::find_all_ret_expressions};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::{LangItem, QPath};\n use rustc_lint::LateContext;\n+use rustc_middle::ty::DefIdTree;\n use rustc_span::Span;\n \n pub(crate) struct OptionAndThenSome;\n \n impl BindInsteadOfMap for OptionAndThenSome {\n-    const TYPE_NAME: &'static str = \"Option\";\n-    const TYPE_QPATH: &'static [&'static str] = &paths::OPTION;\n-\n+    const VARIANT_LANG_ITEM: LangItem = LangItem::OptionSome;\n     const BAD_METHOD_NAME: &'static str = \"and_then\";\n-    const BAD_VARIANT_NAME: &'static str = \"Some\";\n-    const BAD_VARIANT_QPATH: &'static [&'static str] = &paths::OPTION_SOME;\n-\n     const GOOD_METHOD_NAME: &'static str = \"map\";\n }\n \n pub(crate) struct ResultAndThenOk;\n \n impl BindInsteadOfMap for ResultAndThenOk {\n-    const TYPE_NAME: &'static str = \"Result\";\n-    const TYPE_QPATH: &'static [&'static str] = &paths::RESULT;\n-\n+    const VARIANT_LANG_ITEM: LangItem = LangItem::ResultOk;\n     const BAD_METHOD_NAME: &'static str = \"and_then\";\n-    const BAD_VARIANT_NAME: &'static str = \"Ok\";\n-    const BAD_VARIANT_QPATH: &'static [&'static str] = &paths::RESULT_OK;\n-\n     const GOOD_METHOD_NAME: &'static str = \"map\";\n }\n \n pub(crate) struct ResultOrElseErrInfo;\n \n impl BindInsteadOfMap for ResultOrElseErrInfo {\n-    const TYPE_NAME: &'static str = \"Result\";\n-    const TYPE_QPATH: &'static [&'static str] = &paths::RESULT;\n-\n+    const VARIANT_LANG_ITEM: LangItem = LangItem::ResultErr;\n     const BAD_METHOD_NAME: &'static str = \"or_else\";\n-    const BAD_VARIANT_NAME: &'static str = \"Err\";\n-    const BAD_VARIANT_QPATH: &'static [&'static str] = &paths::RESULT_ERR;\n-\n     const GOOD_METHOD_NAME: &'static str = \"map_err\";\n }\n \n pub(crate) trait BindInsteadOfMap {\n-    const TYPE_NAME: &'static str;\n-    const TYPE_QPATH: &'static [&'static str];\n-\n+    const VARIANT_LANG_ITEM: LangItem;\n     const BAD_METHOD_NAME: &'static str;\n-    const BAD_VARIANT_NAME: &'static str;\n-    const BAD_VARIANT_QPATH: &'static [&'static str];\n-\n     const GOOD_METHOD_NAME: &'static str;\n \n-    fn no_op_msg() -> String {\n-        format!(\n+    fn no_op_msg(cx: &LateContext<'_>) -> Option<String> {\n+        let variant_id = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM).ok()?;\n+        let item_id = cx.tcx.parent(variant_id)?;\n+        Some(format!(\n             \"using `{}.{}({})`, which is a no-op\",\n-            Self::TYPE_NAME,\n+            cx.tcx.item_name(item_id),\n             Self::BAD_METHOD_NAME,\n-            Self::BAD_VARIANT_NAME\n-        )\n+            cx.tcx.item_name(variant_id),\n+        ))\n     }\n \n-    fn lint_msg() -> String {\n-        format!(\n+    fn lint_msg(cx: &LateContext<'_>) -> Option<String> {\n+        let variant_id = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM).ok()?;\n+        let item_id = cx.tcx.parent(variant_id)?;\n+        Some(format!(\n             \"using `{}.{}(|x| {}(y))`, which is more succinctly expressed as `{}(|x| y)`\",\n-            Self::TYPE_NAME,\n+            cx.tcx.item_name(item_id),\n             Self::BAD_METHOD_NAME,\n-            Self::BAD_VARIANT_NAME,\n+            cx.tcx.item_name(variant_id),\n             Self::GOOD_METHOD_NAME\n-        )\n+        ))\n     }\n \n     fn lint_closure_autofixable(\n         cx: &LateContext<'_>,\n         expr: &hir::Expr<'_>,\n-        args: &[hir::Expr<'_>],\n+        recv: &hir::Expr<'_>,\n         closure_expr: &hir::Expr<'_>,\n         closure_args_span: Span,\n     ) -> bool {\n         if_chain! {\n-            if let hir::ExprKind::Call(ref some_expr, ref some_args) = closure_expr.kind;\n-            if let hir::ExprKind::Path(ref qpath) = some_expr.kind;\n-            if match_qpath(qpath, Self::BAD_VARIANT_QPATH);\n-            if some_args.len() == 1;\n+            if let hir::ExprKind::Call(some_expr, [inner_expr]) = closure_expr.kind;\n+            if let hir::ExprKind::Path(QPath::Resolved(_, path)) = some_expr.kind;\n+            if Self::is_variant(cx, path.res);\n+            if !contains_return(inner_expr);\n+            if let Some(msg) = Self::lint_msg(cx);\n             then {\n-                let inner_expr = &some_args[0];\n-\n-                if contains_return(inner_expr) {\n-                    return false;\n-                }\n-\n                 let some_inner_snip = if inner_expr.span.from_expansion() {\n                     snippet_with_macro_callsite(cx, inner_expr.span, \"_\")\n                 } else {\n                     snippet(cx, inner_expr.span, \"_\")\n                 };\n \n                 let closure_args_snip = snippet(cx, closure_args_span, \"..\");\n-                let option_snip = snippet(cx, args[0].span, \"..\");\n+                let option_snip = snippet(cx, recv.span, \"..\");\n                 let note = format!(\"{}.{}({} {})\", option_snip, Self::GOOD_METHOD_NAME, closure_args_snip, some_inner_snip);\n                 span_lint_and_sugg(\n                     cx,\n                     BIND_INSTEAD_OF_MAP,\n                     expr.span,\n-                    Self::lint_msg().as_ref(),\n+                    &msg,\n                     \"try this\",\n                     note,\n                     Applicability::MachineApplicable,\n@@ -126,68 +107,84 @@ pub(crate) trait BindInsteadOfMap {\n         let can_sugg: bool = find_all_ret_expressions(cx, closure_expr, |ret_expr| {\n             if_chain! {\n                 if !in_macro(ret_expr.span);\n-                if let hir::ExprKind::Call(ref func_path, ref args) = ret_expr.kind;\n-                if let hir::ExprKind::Path(ref qpath) = func_path.kind;\n-                if match_qpath(qpath, Self::BAD_VARIANT_QPATH);\n-                if args.len() == 1;\n-                if !contains_return(&args[0]);\n+                if let hir::ExprKind::Call(func_path, [arg]) = ret_expr.kind;\n+                if let hir::ExprKind::Path(QPath::Resolved(_, path)) = func_path.kind;\n+                if Self::is_variant(cx, path.res);\n+                if !contains_return(arg);\n                 then {\n-                    suggs.push((ret_expr.span, args[0].span.source_callsite()));\n+                    suggs.push((ret_expr.span, arg.span.source_callsite()));\n                     true\n                 } else {\n                     false\n                 }\n             }\n         });\n-\n-        if can_sugg {\n-            span_lint_and_then(cx, BIND_INSTEAD_OF_MAP, expr.span, Self::lint_msg().as_ref(), |diag| {\n-                multispan_sugg_with_applicability(\n-                    diag,\n-                    \"try this\",\n-                    Applicability::MachineApplicable,\n-                    std::iter::once((*method_calls(expr, 1).2.get(0).unwrap(), Self::GOOD_METHOD_NAME.into())).chain(\n-                        suggs\n-                            .into_iter()\n-                            .map(|(span1, span2)| (span1, snippet(cx, span2, \"_\").into())),\n-                    ),\n-                )\n-            });\n-        }\n-        can_sugg\n+        let (span, msg) = if_chain! {\n+            if can_sugg;\n+            if let hir::ExprKind::MethodCall(_, span, ..) = expr.kind;\n+            if let Some(msg) = Self::lint_msg(cx);\n+            then { (span, msg) } else { return false; }\n+        };\n+        span_lint_and_then(cx, BIND_INSTEAD_OF_MAP, expr.span, &msg, |diag| {\n+            multispan_sugg_with_applicability(\n+                diag,\n+                \"try this\",\n+                Applicability::MachineApplicable,\n+                std::iter::once((span, Self::GOOD_METHOD_NAME.into())).chain(\n+                    suggs\n+                        .into_iter()\n+                        .map(|(span1, span2)| (span1, snippet(cx, span2, \"_\").into())),\n+                ),\n+            )\n+        });\n+        true\n     }\n \n     /// Lint use of `_.and_then(|x| Some(y))` for `Option`s\n-    fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) -> bool {\n-        if !match_type(cx, cx.typeck_results().expr_ty(&args[0]), Self::TYPE_QPATH) {\n-            return false;\n+    fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, arg: &hir::Expr<'_>) -> bool {\n+        if_chain! {\n+            if let Some(adt) = cx.typeck_results().expr_ty(recv).ty_adt_def();\n+            if let Ok(vid) = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM);\n+            if Some(adt.did) == cx.tcx.parent(vid);\n+            then {} else { return false; }\n         }\n \n-        match args[1].kind {\n+        match arg.kind {\n             hir::ExprKind::Closure(_, _, body_id, closure_args_span, _) => {\n                 let closure_body = cx.tcx.hir().body(body_id);\n                 let closure_expr = remove_blocks(&closure_body.value);\n \n-                if Self::lint_closure_autofixable(cx, expr, args, closure_expr, closure_args_span) {\n+                if Self::lint_closure_autofixable(cx, expr, recv, closure_expr, closure_args_span) {\n                     true\n                 } else {\n                     Self::lint_closure(cx, expr, closure_expr)\n                 }\n             },\n             // `_.and_then(Some)` case, which is no-op.\n-            hir::ExprKind::Path(ref qpath) if match_qpath(qpath, Self::BAD_VARIANT_QPATH) => {\n-                span_lint_and_sugg(\n-                    cx,\n-                    BIND_INSTEAD_OF_MAP,\n-                    expr.span,\n-                    Self::no_op_msg().as_ref(),\n-                    \"use the expression directly\",\n-                    snippet(cx, args[0].span, \"..\").into(),\n-                    Applicability::MachineApplicable,\n-                );\n+            hir::ExprKind::Path(QPath::Resolved(_, path)) if Self::is_variant(cx, path.res) => {\n+                if let Some(msg) = Self::no_op_msg(cx) {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        BIND_INSTEAD_OF_MAP,\n+                        expr.span,\n+                        &msg,\n+                        \"use the expression directly\",\n+                        snippet(cx, recv.span, \"..\").into(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n                 true\n             },\n             _ => false,\n         }\n     }\n+\n+    fn is_variant(cx: &LateContext<'_>, res: Res) -> bool {\n+        if let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), id) = res {\n+            if let Ok(variant_id) = cx.tcx.lang_items().require(Self::VARIANT_LANG_ITEM) {\n+                return cx.tcx.parent(id) == Some(variant_id);\n+            }\n+        }\n+        false\n+    }\n }"}, {"sha": "2ad3e673c574fea36ec111d6897e5b6b27c7cd7e", "filename": "clippy_lints/src/methods/bytes_nth.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,41 +1,34 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n+use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_span::sym;\n \n use super::BYTES_NTH;\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, iter_args: &'tcx [Expr<'tcx>]) {\n-    if_chain! {\n-        if let ExprKind::MethodCall(_, _, ref args, _) = expr.kind;\n-        let ty = cx.typeck_results().expr_ty(&iter_args[0]).peel_refs();\n-        let caller_type = if is_type_diagnostic_item(cx, ty, sym::string_type) {\n-            Some(\"String\")\n-        } else if ty.is_str() {\n-            Some(\"str\")\n-        } else {\n-            None\n-        };\n-        if let Some(caller_type) = caller_type;\n-        then {\n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                BYTES_NTH,\n-                expr.span,\n-                &format!(\"called `.byte().nth()` on a `{}`\", caller_type),\n-                \"try\",\n-                format!(\n-                    \"{}.as_bytes().get({})\",\n-                    snippet_with_applicability(cx, iter_args[0].span, \"..\", &mut applicability),\n-                    snippet_with_applicability(cx, args[1].span, \"..\", &mut applicability)\n-                ),\n-                applicability,\n-            );\n-        }\n-    }\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, recv: &'tcx Expr<'tcx>, n_arg: &'tcx Expr<'tcx>) {\n+    let ty = cx.typeck_results().expr_ty(recv).peel_refs();\n+    let caller_type = if ty.is_str() {\n+        \"str\"\n+    } else if is_type_diagnostic_item(cx, ty, sym::string_type) {\n+        \"String\"\n+    } else {\n+        return;\n+    };\n+    let mut applicability = Applicability::MachineApplicable;\n+    span_lint_and_sugg(\n+        cx,\n+        BYTES_NTH,\n+        expr.span,\n+        &format!(\"called `.byte().nth()` on a `{}`\", caller_type),\n+        \"try\",\n+        format!(\n+            \"{}.as_bytes().get({})\",\n+            snippet_with_applicability(cx, recv.span, \"..\", &mut applicability),\n+            snippet_with_applicability(cx, n_arg.span, \"..\", &mut applicability)\n+        ),\n+        applicability,\n+    );\n }"}, {"sha": "514c411876551150478608f8f4756d0ecb5074ef", "filename": "clippy_lints/src/methods/chars_cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -19,7 +19,7 @@ pub(super) fn check(\n ) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprKind::Call(ref fun, ref arg_char) = info.other.kind;\n+        if let hir::ExprKind::Call(fun, arg_char) = info.other.kind;\n         if arg_char.len() == 1;\n         if let hir::ExprKind::Path(ref qpath) = fun.kind;\n         if let Some(segment) = single_segment_path(qpath);"}, {"sha": "ce2e8fa8b1074aaa8b9324a4554e6ff63b249658", "filename": "clippy_lints/src/methods/clone_on_copy.rs", "status": "modified", "additions": 67, "deletions": 51, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,23 +1,39 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::get_parent_node;\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::sugg;\n use clippy_utils::ty::is_copy;\n use rustc_errors::Applicability;\n-use rustc_hir as hir;\n+use rustc_hir::{BindingAnnotation, Expr, ExprKind, MatchSource, Node, PatKind};\n use rustc_lint::LateContext;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, adjustment::Adjust};\n use rustc_span::symbol::{sym, Symbol};\n use std::iter;\n \n use super::CLONE_DOUBLE_REF;\n use super::CLONE_ON_COPY;\n \n /// Checks for the `CLONE_ON_COPY` lint.\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_name: Symbol, args: &[hir::Expr<'_>]) {\n-    if !(args.len() == 1 && method_name == sym::clone) {\n+#[allow(clippy::too_many_lines)]\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol, args: &[Expr<'_>]) {\n+    let arg = match args {\n+        [arg] if method_name == sym::clone => arg,\n+        _ => return,\n+    };\n+    if cx\n+        .typeck_results()\n+        .type_dependent_def_id(expr.hir_id)\n+        .and_then(|id| cx.tcx.trait_of_item(id))\n+        .zip(cx.tcx.lang_items().clone_trait())\n+        .map_or(true, |(x, y)| x != y)\n+    {\n         return;\n     }\n-    let arg = &args[0];\n-    let arg_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+    let arg_adjustments = cx.typeck_results().expr_adjustments(arg);\n+    let arg_ty = arg_adjustments\n+        .last()\n+        .map_or_else(|| cx.typeck_results().expr_ty(arg), |a| a.target);\n+\n     let ty = cx.typeck_results().expr_ty(expr);\n     if let ty::Ref(_, inner, _) = arg_ty.kind() {\n         if let ty::Ref(_, innermost, _) = inner.kind() {\n@@ -61,57 +77,57 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_name: Sym\n     }\n \n     if is_copy(cx, ty) {\n-        let snip;\n-        if let Some(snippet) = sugg::Sugg::hir_opt(cx, arg) {\n-            let parent = cx.tcx.hir().get_parent_node(expr.hir_id);\n-            match &cx.tcx.hir().get(parent) {\n-                hir::Node::Expr(parent) => match parent.kind {\n-                    // &*x is a nop, &x.clone() is not\n-                    hir::ExprKind::AddrOf(..) => return,\n-                    // (*x).func() is useless, x.clone().func() can work in case func borrows mutably\n-                    hir::ExprKind::MethodCall(_, _, parent_args, _) if expr.hir_id == parent_args[0].hir_id => {\n-                        return;\n-                    },\n-\n-                    _ => {},\n-                },\n-                hir::Node::Stmt(stmt) => {\n-                    if let hir::StmtKind::Local(ref loc) = stmt.kind {\n-                        if let hir::PatKind::Ref(..) = loc.pat.kind {\n-                            // let ref y = *x borrows x, let ref y = x.clone() does not\n-                            return;\n-                        }\n-                    }\n-                },\n-                _ => {},\n+        let parent_is_suffix_expr = match get_parent_node(cx.tcx, expr.hir_id) {\n+            Some(Node::Expr(parent)) => match parent.kind {\n+                // &*x is a nop, &x.clone() is not\n+                ExprKind::AddrOf(..) => return,\n+                // (*x).func() is useless, x.clone().func() can work in case func borrows self\n+                ExprKind::MethodCall(_, _, [self_arg, ..], _)\n+                    if expr.hir_id == self_arg.hir_id && ty != cx.typeck_results().expr_ty_adjusted(expr) =>\n+                {\n+                    return;\n+                }\n+                ExprKind::MethodCall(_, _, [self_arg, ..], _) if expr.hir_id == self_arg.hir_id => true,\n+                ExprKind::Match(_, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar)\n+                | ExprKind::Field(..)\n+                | ExprKind::Index(..) => true,\n+                _ => false,\n+            },\n+            // local binding capturing a reference\n+            Some(Node::Local(l))\n+                if matches!(\n+                    l.pat.kind,\n+                    PatKind::Binding(BindingAnnotation::Ref | BindingAnnotation::RefMut, ..)\n+                ) =>\n+            {\n+                return;\n             }\n+            _ => false,\n+        };\n \n-            // x.clone() might have dereferenced x, possibly through Deref impls\n-            if cx.typeck_results().expr_ty(arg) == ty {\n-                snip = Some((\"try removing the `clone` call\", format!(\"{}\", snippet)));\n-            } else {\n-                let deref_count = cx\n-                    .typeck_results()\n-                    .expr_adjustments(arg)\n-                    .iter()\n-                    .filter(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(_)))\n-                    .count();\n-                let derefs: String = iter::repeat('*').take(deref_count).collect();\n-                snip = Some((\"try dereferencing it\", format!(\"{}{}\", derefs, snippet)));\n-            }\n+        let mut app = Applicability::MachineApplicable;\n+        let snip = snippet_with_context(cx, arg.span, expr.span.ctxt(), \"_\", &mut app).0;\n+\n+        let deref_count = arg_adjustments\n+            .iter()\n+            .take_while(|adj| matches!(adj.kind, Adjust::Deref(_)))\n+            .count();\n+        let (help, sugg) = if deref_count == 0 {\n+            (\"try removing the `clone` call\", snip.into())\n+        } else if parent_is_suffix_expr {\n+            (\"try dereferencing it\", format!(\"({}{})\", \"*\".repeat(deref_count), snip))\n         } else {\n-            snip = None;\n-        }\n-        span_lint_and_then(\n+            (\"try dereferencing it\", format!(\"{}{}\", \"*\".repeat(deref_count), snip))\n+        };\n+\n+        span_lint_and_sugg(\n             cx,\n             CLONE_ON_COPY,\n             expr.span,\n             &format!(\"using `clone` on type `{}` which implements the `Copy` trait\", ty),\n-            |diag| {\n-                if let Some((text, snip)) = snip {\n-                    diag.span_suggestion(expr.span, text, snip, Applicability::MachineApplicable);\n-                }\n-            },\n+            help,\n+            sugg,\n+            app,\n         );\n     }\n }"}, {"sha": "03cb41697d509dd46717ed6d1a1c43094749f605", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -100,9 +100,9 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Spa\n         applicability: &mut Applicability,\n     ) -> Vec<String> {\n         if_chain! {\n-            if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, ref format_arg) = a.kind;\n-            if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.kind;\n-            if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.kind;\n+            if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, format_arg) = a.kind;\n+            if let hir::ExprKind::Match(format_arg_expr, _, _) = format_arg.kind;\n+            if let hir::ExprKind::Tup(format_arg_expr_tup) = format_arg_expr.kind;\n \n             then {\n                 format_arg_expr_tup\n@@ -155,7 +155,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Spa\n         if block.stmts.len() == 1;\n         if let hir::StmtKind::Local(local) = &block.stmts[0].kind;\n         if let Some(arg_root) = &local.init;\n-        if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = arg_root.kind;\n+        if let hir::ExprKind::Call(inner_fun, inner_args) = arg_root.kind;\n         if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1;\n         if let hir::ExprKind::Call(_, format_args) = &inner_args[0].kind;\n         then {"}, {"sha": "63a834fdce0cb8e525e771bbf07a48c9d9c4b776", "filename": "clippy_lints/src/methods/expect_used.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -7,8 +7,8 @@ use rustc_span::sym;\n use super::EXPECT_USED;\n \n /// lint use of `expect()` for `Option`s and `Result`s\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n-    let obj_ty = cx.typeck_results().expr_ty(&expect_args[0]).peel_refs();\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n+    let obj_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym::option_type) {\n         Some((EXPECT_USED, \"an Option\", \"None\"))"}, {"sha": "7b2967feb0fe988e18bfeb683616b39e09023dff", "filename": "clippy_lints/src/methods/filetype_is_file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -8,8 +8,8 @@ use rustc_span::source_map::Span;\n \n use super::FILETYPE_IS_FILE;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    let ty = cx.typeck_results().expr_ty(&args[0]);\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n+    let ty = cx.typeck_results().expr_ty(recv);\n \n     if !match_type(cx, ty, &paths::FILE_TYPE) {\n         return;"}, {"sha": "35fae450eeb93177612141992e50a89ca5815bc1", "filename": "clippy_lints/src/methods/filter_map.rs", "status": "modified", "additions": 155, "deletions": 68, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,87 +1,174 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet;\n-use clippy_utils::{is_trait_method, path_to_local_id, SpanlessEq};\n+use clippy_utils::source::{indent_of, reindent_multiline, snippet};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{is_trait_method, path_to_local_id, remove_blocks, SpanlessEq};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::{Expr, ExprKind, PatKind, UnOp};\n+use rustc_hir::def::Res;\n+use rustc_hir::{Expr, ExprKind, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::ty::TyS;\n-use rustc_span::symbol::sym;\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::{sym, Symbol};\n+use std::borrow::Cow;\n \n use super::MANUAL_FILTER_MAP;\n use super::MANUAL_FIND_MAP;\n+use super::OPTION_FILTER_MAP;\n+\n+fn is_method<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Symbol) -> bool {\n+    match &expr.kind {\n+        hir::ExprKind::Path(QPath::TypeRelative(_, mname)) => mname.ident.name == method_name,\n+        hir::ExprKind::Path(QPath::Resolved(_, segments)) => {\n+            segments.segments.last().unwrap().ident.name == method_name\n+        },\n+        hir::ExprKind::Closure(_, _, c, _, _) => {\n+            let body = cx.tcx.hir().body(*c);\n+            let closure_expr = remove_blocks(&body.value);\n+            let arg_id = body.params[0].pat.hir_id;\n+            match closure_expr.kind {\n+                hir::ExprKind::MethodCall(hir::PathSegment { ident, .. }, _, args, _) => {\n+                    if_chain! {\n+                    if ident.name == method_name;\n+                    if let hir::ExprKind::Path(path) = &args[0].kind;\n+                    if let Res::Local(ref local) = cx.qpath_res(path, args[0].hir_id);\n+                    then {\n+                        return arg_id == *local\n+                    }\n+                    }\n+                    false\n+                },\n+                _ => false,\n+            }\n+        },\n+        _ => false,\n+    }\n+}\n+\n+fn is_option_filter_map<'tcx>(cx: &LateContext<'tcx>, filter_arg: &hir::Expr<'_>, map_arg: &hir::Expr<'_>) -> bool {\n+    is_method(cx, map_arg, sym::unwrap) && is_method(cx, filter_arg, sym!(is_some))\n+}\n+\n+/// lint use of `filter().map()` for `Iterators`\n+fn lint_filter_some_map_unwrap(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    filter_recv: &hir::Expr<'_>,\n+    filter_arg: &hir::Expr<'_>,\n+    map_arg: &hir::Expr<'_>,\n+    target_span: Span,\n+    methods_span: Span,\n+) {\n+    let iterator = is_trait_method(cx, expr, sym::Iterator);\n+    let option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(filter_recv), sym::option_type);\n+    if (iterator || option) && is_option_filter_map(cx, filter_arg, map_arg) {\n+        let msg = \"`filter` for `Some` followed by `unwrap`\";\n+        let help = \"consider using `flatten` instead\";\n+        let sugg = format!(\n+            \"{}\",\n+            reindent_multiline(Cow::Borrowed(\"flatten()\"), true, indent_of(cx, target_span),)\n+        );\n+        span_lint_and_sugg(\n+            cx,\n+            OPTION_FILTER_MAP,\n+            methods_span,\n+            msg,\n+            help,\n+            sugg,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n \n /// lint use of `filter().map()` or `find().map()` for `Iterators`\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, is_find: bool) {\n+#[allow(clippy::too_many_arguments)]\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    filter_recv: &hir::Expr<'_>,\n+    filter_arg: &hir::Expr<'_>,\n+    filter_span: Span,\n+    map_recv: &hir::Expr<'_>,\n+    map_arg: &hir::Expr<'_>,\n+    map_span: Span,\n+    is_find: bool,\n+) {\n+    lint_filter_some_map_unwrap(\n+        cx,\n+        expr,\n+        filter_recv,\n+        filter_arg,\n+        map_arg,\n+        map_span,\n+        filter_span.with_hi(expr.span.hi()),\n+    );\n     if_chain! {\n-        if let ExprKind::MethodCall(_, _, [map_recv, map_arg], map_span) = expr.kind;\n-        if let ExprKind::MethodCall(_, _, [_, filter_arg], filter_span) = map_recv.kind;\n-        if is_trait_method(cx, map_recv, sym::Iterator);\n+            if is_trait_method(cx, map_recv, sym::Iterator);\n \n-        // filter(|x| ...is_some())...\n-        if let ExprKind::Closure(_, _, filter_body_id, ..) = filter_arg.kind;\n-        let filter_body = cx.tcx.hir().body(filter_body_id);\n-        if let [filter_param] = filter_body.params;\n-        // optional ref pattern: `filter(|&x| ..)`\n-        let (filter_pat, is_filter_param_ref) = if let PatKind::Ref(ref_pat, _) = filter_param.pat.kind {\n-            (ref_pat, true)\n-        } else {\n-            (filter_param.pat, false)\n-        };\n-        // closure ends with is_some() or is_ok()\n-        if let PatKind::Binding(_, filter_param_id, _, None) = filter_pat.kind;\n-        if let ExprKind::MethodCall(path, _, [filter_arg], _) = filter_body.value.kind;\n-        if let Some(opt_ty) = cx.typeck_results().expr_ty(filter_arg).ty_adt_def();\n-        if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::option_type, opt_ty.did) {\n-            Some(false)\n-        } else if cx.tcx.is_diagnostic_item(sym::result_type, opt_ty.did) {\n-            Some(true)\n-        } else {\n-            None\n-        };\n-        if path.ident.name.as_str() == if is_result { \"is_ok\" } else { \"is_some\" };\n+            // filter(|x| ...is_some())...\n+            if let ExprKind::Closure(_, _, filter_body_id, ..) = filter_arg.kind;\n+            let filter_body = cx.tcx.hir().body(filter_body_id);\n+            if let [filter_param] = filter_body.params;\n+            // optional ref pattern: `filter(|&x| ..)`\n+            let (filter_pat, is_filter_param_ref) = if let PatKind::Ref(ref_pat, _) = filter_param.pat.kind {\n+                (ref_pat, true)\n+            } else {\n+                (filter_param.pat, false)\n+            };\n+            // closure ends with is_some() or is_ok()\n+            if let PatKind::Binding(_, filter_param_id, _, None) = filter_pat.kind;\n+            if let ExprKind::MethodCall(path, _, [filter_arg], _) = filter_body.value.kind;\n+            if let Some(opt_ty) = cx.typeck_results().expr_ty(filter_arg).ty_adt_def();\n+            if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::option_type, opt_ty.did) {\n+                Some(false)\n+            } else if cx.tcx.is_diagnostic_item(sym::result_type, opt_ty.did) {\n+                Some(true)\n+            } else {\n+                None\n+            };\n+            if path.ident.name.as_str() == if is_result { \"is_ok\" } else { \"is_some\" };\n \n-        // ...map(|x| ...unwrap())\n-        if let ExprKind::Closure(_, _, map_body_id, ..) = map_arg.kind;\n-        let map_body = cx.tcx.hir().body(map_body_id);\n-        if let [map_param] = map_body.params;\n-        if let PatKind::Binding(_, map_param_id, map_param_ident, None) = map_param.pat.kind;\n-        // closure ends with expect() or unwrap()\n-        if let ExprKind::MethodCall(seg, _, [map_arg, ..], _) = map_body.value.kind;\n-        if matches!(seg.ident.name, sym::expect | sym::unwrap | sym::unwrap_or);\n+            // ...map(|x| ...unwrap())\n+            if let ExprKind::Closure(_, _, map_body_id, ..) = map_arg.kind;\n+            let map_body = cx.tcx.hir().body(map_body_id);\n+            if let [map_param] = map_body.params;\n+            if let PatKind::Binding(_, map_param_id, map_param_ident, None) = map_param.pat.kind;\n+            // closure ends with expect() or unwrap()\n+            if let ExprKind::MethodCall(seg, _, [map_arg, ..], _) = map_body.value.kind;\n+            if matches!(seg.ident.name, sym::expect | sym::unwrap | sym::unwrap_or);\n \n-        let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n-            // in `filter(|x| ..)`, replace `*x` with `x`\n-            let a_path = if_chain! {\n-                if !is_filter_param_ref;\n-                if let ExprKind::Unary(UnOp::Deref, expr_path) = a.kind;\n-                then { expr_path } else { a }\n-            };\n-            // let the filter closure arg and the map closure arg be equal\n-            if_chain! {\n-                if path_to_local_id(a_path, filter_param_id);\n-                if path_to_local_id(b, map_param_id);\n-                if TyS::same_type(cx.typeck_results().expr_ty_adjusted(a), cx.typeck_results().expr_ty_adjusted(b));\n-                then {\n-                    return true;\n+            let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n+                // in `filter(|x| ..)`, replace `*x` with `x`\n+                let a_path = if_chain! {\n+                    if !is_filter_param_ref;\n+                    if let ExprKind::Unary(UnOp::Deref, expr_path) = a.kind;\n+                    then { expr_path } else { a }\n+                };\n+                // let the filter closure arg and the map closure arg be equal\n+                if_chain! {\n+                    if path_to_local_id(a_path, filter_param_id);\n+                    if path_to_local_id(b, map_param_id);\n+                    if TyS::same_type(cx.typeck_results().expr_ty_adjusted(a), cx.typeck_results().expr_ty_adjusted(b));\n+                    then {\n+                        return true;\n+                    }\n                 }\n-            }\n-            false\n-        };\n-        if SpanlessEq::new(cx).expr_fallback(eq_fallback).eq_expr(filter_arg, map_arg);\n-        then {\n-            let span = filter_span.to(map_span);\n-            let (filter_name, lint) = if is_find {\n-                (\"find\", MANUAL_FIND_MAP)\n-            } else {\n-                (\"filter\", MANUAL_FILTER_MAP)\n+                false\n             };\n-            let msg = format!(\"`{}(..).map(..)` can be simplified as `{0}_map(..)`\", filter_name);\n-            let to_opt = if is_result { \".ok()\" } else { \"\" };\n-            let sugg = format!(\"{}_map(|{}| {}{})\", filter_name, map_param_ident,\n-                snippet(cx, map_arg.span, \"..\"), to_opt);\n-            span_lint_and_sugg(cx, lint, span, &msg, \"try\", sugg, Applicability::MachineApplicable);\n-        }\n+            if SpanlessEq::new(cx).expr_fallback(eq_fallback).eq_expr(filter_arg, map_arg);\n+            then {\n+                let span = filter_span.with_hi(expr.span.hi());\n+                let (filter_name, lint) = if is_find {\n+                    (\"find\", MANUAL_FIND_MAP)\n+                } else {\n+                    (\"filter\", MANUAL_FILTER_MAP)\n+                };\n+                let msg = format!(\"`{}(..).map(..)` can be simplified as `{0}_map(..)`\", filter_name);\n+                let to_opt = if is_result { \".ok()\" } else { \"\" };\n+                let sugg = format!(\"{}_map(|{}| {}{})\", filter_name, map_param_ident,\n+                    snippet(cx, map_arg.span, \"..\"), to_opt);\n+                span_lint_and_sugg(cx, lint, span, &msg, \"try\", sugg, Applicability::MachineApplicable);\n+            }\n     }\n }"}, {"sha": "3a61f4ccad78930ccc5aca26b70de78a1727e1a1", "filename": "clippy_lints/src/methods/filter_map_identity.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -8,15 +8,8 @@ use rustc_span::{source_map::Span, sym};\n \n use super::FILTER_MAP_IDENTITY;\n \n-pub(super) fn check(\n-    cx: &LateContext<'_>,\n-    expr: &hir::Expr<'_>,\n-    filter_map_args: &[hir::Expr<'_>],\n-    filter_map_span: Span,\n-) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, filter_map_arg: &hir::Expr<'_>, filter_map_span: Span) {\n     if is_trait_method(cx, expr, sym::Iterator) {\n-        let arg_node = &filter_map_args[1].kind;\n-\n         let apply_lint = |message: &str| {\n             span_lint_and_sugg(\n                 cx,\n@@ -30,8 +23,8 @@ pub(super) fn check(\n         };\n \n         if_chain! {\n-            if let hir::ExprKind::Closure(_, _, body_id, _, _) = arg_node;\n-            let body = cx.tcx.hir().body(*body_id);\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = filter_map_arg.kind;\n+            let body = cx.tcx.hir().body(body_id);\n \n             if let hir::PatKind::Binding(_, binding_id, ..) = body.params[0].pat.kind;\n             if path_to_local_id(&body.value, binding_id);\n@@ -41,7 +34,7 @@ pub(super) fn check(\n         }\n \n         if_chain! {\n-            if let hir::ExprKind::Path(ref qpath) = arg_node;\n+            if let hir::ExprKind::Path(ref qpath) = filter_map_arg.kind;\n \n             if match_qpath(qpath, &paths::STD_CONVERT_IDENTITY);\n "}, {"sha": "2b19e4ee8c055b16c9b962465dbc43769ebbce98", "filename": "clippy_lints/src/methods/filter_map_next.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -14,7 +14,8 @@ const FILTER_MAP_NEXT_MSRV: RustcVersion = RustcVersion::new(1, 30, 0);\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n-    filter_args: &'tcx [hir::Expr<'_>],\n+    recv: &'tcx hir::Expr<'_>,\n+    arg: &'tcx hir::Expr<'_>,\n     msrv: Option<&RustcVersion>,\n ) {\n     if is_trait_method(cx, expr, sym::Iterator) {\n@@ -24,9 +25,9 @@ pub(super) fn check<'tcx>(\n \n         let msg = \"called `filter_map(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n                    `.find_map(..)` instead\";\n-        let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n+        let filter_snippet = snippet(cx, arg.span, \"..\");\n         if filter_snippet.lines().count() <= 1 {\n-            let iter_snippet = snippet(cx, filter_args[0].span, \"..\");\n+            let iter_snippet = snippet(cx, recv.span, \"..\");\n             span_lint_and_sugg(\n                 cx,\n                 FILTER_MAP_NEXT,"}, {"sha": "172714f6b01c61d97b31eac24d6a7d3bbc8f013b", "filename": "clippy_lints/src/methods/filter_next.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -9,14 +9,19 @@ use rustc_span::sym;\n use super::FILTER_NEXT;\n \n /// lint use of `filter().next()` for `Iterators`\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, filter_args: &'tcx [hir::Expr<'_>]) {\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    recv: &'tcx hir::Expr<'_>,\n+    filter_arg: &'tcx hir::Expr<'_>,\n+) {\n     // lint if caller of `.filter().next()` is an Iterator\n     if is_trait_method(cx, expr, sym::Iterator) {\n         let msg = \"called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n                    `.find(..)` instead\";\n-        let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n+        let filter_snippet = snippet(cx, filter_arg.span, \"..\");\n         if filter_snippet.lines().count() <= 1 {\n-            let iter_snippet = snippet(cx, filter_args[0].span, \"..\");\n+            let iter_snippet = snippet(cx, recv.span, \"..\");\n             // add note if not multi-line\n             span_lint_and_sugg(\n                 cx,"}, {"sha": "dd613d0cd6384f827c311c580beab208091cb273", "filename": "clippy_lints/src/methods/flat_map_identity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -12,11 +12,11 @@ use super::FLAT_MAP_IDENTITY;\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n-    flat_map_args: &'tcx [hir::Expr<'_>],\n+    flat_map_arg: &'tcx hir::Expr<'_>,\n     flat_map_span: Span,\n ) {\n     if is_trait_method(cx, expr, sym::Iterator) {\n-        let arg_node = &flat_map_args[1].kind;\n+        let arg_node = &flat_map_arg.kind;\n \n         let apply_lint = |message: &str| {\n             span_lint_and_sugg(\n@@ -35,7 +35,7 @@ pub(super) fn check<'tcx>(\n             let body = cx.tcx.hir().body(*body_id);\n \n             if let hir::PatKind::Binding(_, _, binding_ident, _) = body.params[0].pat.kind;\n-            if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = body.value.kind;\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = body.value.kind;\n \n             if path.segments.len() == 1;\n             if path.segments[0].ident.name == binding_ident.name;"}, {"sha": "707c54f7a3cad180a37af7f2c0175fef03b4eecb", "filename": "clippy_lints/src/methods/from_iter_instead_of_collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -40,8 +40,8 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Exp\n }\n \n fn extract_turbofish(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ty: Ty<'tcx>) -> String {\n+    let call_site = expr.span.source_callsite();\n     if_chain! {\n-        let call_site = expr.span.source_callsite();\n         if let Ok(snippet) = cx.sess().source_map().span_to_snippet(call_site);\n         let snippet_split = snippet.split(\"::\").collect::<Vec<_>>();\n         if let Some((_, elements)) = snippet_split.split_last();"}, {"sha": "54f280643841368df11c504b4c0aad291cb41321", "filename": "clippy_lints/src/methods/get_unwrap.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -11,18 +11,20 @@ use rustc_span::sym;\n \n use super::GET_UNWRAP;\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args: &'tcx [hir::Expr<'_>], is_mut: bool) {\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    recv: &'tcx hir::Expr<'tcx>,\n+    get_arg: &'tcx hir::Expr<'_>,\n+    is_mut: bool,\n+) {\n     // Note: we don't want to lint `get_mut().unwrap` for `HashMap` or `BTreeMap`,\n     // because they do not implement `IndexMut`\n     let mut applicability = Applicability::MachineApplicable;\n-    let expr_ty = cx.typeck_results().expr_ty(&get_args[0]);\n-    let get_args_str = if get_args.len() > 1 {\n-        snippet_with_applicability(cx, get_args[1].span, \"..\", &mut applicability)\n-    } else {\n-        return; // not linting on a .get().unwrap() chain or variant\n-    };\n+    let expr_ty = cx.typeck_results().expr_ty(recv);\n+    let get_args_str = snippet_with_applicability(cx, get_arg.span, \"..\", &mut applicability);\n     let mut needs_ref;\n-    let caller_type = if derefs_to_slice(cx, &get_args[0], expr_ty).is_some() {\n+    let caller_type = if derefs_to_slice(cx, recv, expr_ty).is_some() {\n         needs_ref = get_args_str.parse::<usize>().is_ok();\n         \"slice\"\n     } else if is_type_diagnostic_item(cx, expr_ty, sym::vec_type) {\n@@ -77,7 +79,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args\n         format!(\n             \"{}{}[{}]\",\n             borrow_str,\n-            snippet_with_applicability(cx, get_args[0].span, \"..\", &mut applicability),\n+            snippet_with_applicability(cx, recv.span, \"..\", &mut applicability),\n             get_args_str\n         ),\n         applicability,"}, {"sha": "1211e2f2bf7cb23105c687a05c208d3bdf8f33eb", "filename": "clippy_lints/src/methods/implicit_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -13,7 +13,7 @@ use clippy_utils::is_diagnostic_assoc_item;\n pub fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, trait_diagnostic: Symbol) {\n     if_chain! {\n         if let ExprKind::MethodCall(method_path, _, [arg], _) = &expr.kind;\n-        let return_type = cx.typeck_results().expr_ty(&expr);\n+        let return_type = cx.typeck_results().expr_ty(expr);\n         let input_type = cx.typeck_results().expr_ty(arg).peel_refs();\n         if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let Some(ty_name) = input_type.ty_adt_def().map(|adt_def| cx.tcx.item_name(adt_def.did));"}, {"sha": "739f313716e99db6a75378660ebfe52dbef71061", "filename": "clippy_lints/src/methods/iter_cloned_collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -9,10 +9,10 @@ use rustc_span::sym;\n \n use super::ITER_CLONED_COLLECT;\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, recv: &'tcx hir::Expr<'_>) {\n     if_chain! {\n         if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::vec_type);\n-        if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.typeck_results().expr_ty(&iter_args[0]));\n+        if let Some(slice) = derefs_to_slice(cx, recv, cx.typeck_results().expr_ty(recv));\n         if let Some(to_replace) = expr.span.trim_start(slice.span.source_callsite());\n \n         then {"}, {"sha": "c6b7c7cd1795dc15398f62194c71fa6876f5188c", "filename": "clippy_lints/src/methods/iter_count.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -10,9 +10,9 @@ use rustc_span::sym;\n \n use super::ITER_COUNT;\n \n-pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, iter_args: &'tcx [Expr<'tcx>], iter_method: &str) {\n-    let ty = cx.typeck_results().expr_ty(&iter_args[0]);\n-    let caller_type = if derefs_to_slice(cx, &iter_args[0], ty).is_some() {\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, recv: &'tcx Expr<'tcx>, iter_method: &str) {\n+    let ty = cx.typeck_results().expr_ty(recv);\n+    let caller_type = if derefs_to_slice(cx, recv, ty).is_some() {\n         \"slice\"\n     } else if is_type_diagnostic_item(cx, ty, sym::vec_type) {\n         \"Vec\"\n@@ -42,7 +42,7 @@ pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, iter_args: &'\n         \"try\",\n         format!(\n             \"{}.len()\",\n-            snippet_with_applicability(cx, iter_args[0].span, \"..\", &mut applicability),\n+            snippet_with_applicability(cx, recv.span, \"..\", &mut applicability),\n         ),\n         applicability,\n     );"}, {"sha": "a49851de38e1eec3e13fdfda8da0e815fc465687", "filename": "clippy_lints/src/methods/iter_next_slice.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -13,9 +13,7 @@ use rustc_span::symbol::sym;\n \n use super::ITER_NEXT_SLICE;\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n-    let caller_expr = &iter_args[0];\n-\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, caller_expr: &'tcx hir::Expr<'_>) {\n     // Skip lint if the `iter().next()` expression is a for loop argument,\n     // since it is already covered by `&loops::ITER_NEXT_LOOP`\n     let mut parent_expr_opt = get_parent_expr(cx, expr);\n@@ -29,7 +27,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, ite\n     if derefs_to_slice(cx, caller_expr, cx.typeck_results().expr_ty(caller_expr)).is_some() {\n         // caller is a Slice\n         if_chain! {\n-            if let hir::ExprKind::Index(ref caller_var, ref index_expr) = &caller_expr.kind;\n+            if let hir::ExprKind::Index(caller_var, index_expr) = &caller_expr.kind;\n             if let Some(higher::Range { start: Some(start_expr), end: None, limits: ast::RangeLimits::HalfOpen })\n                 = higher::range(index_expr);\n             if let hir::ExprKind::Lit(ref start_lit) = &start_expr.kind;"}, {"sha": "c2232239fe43f7ef20af03e9c2dbd9a05789989f", "filename": "clippy_lints/src/methods/iter_nth.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -11,20 +11,20 @@ use super::ITER_NTH;\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &hir::Expr<'_>,\n-    nth_and_iter_args: &[&'tcx [hir::Expr<'tcx>]],\n+    iter_recv: &'tcx hir::Expr<'tcx>,\n+    nth_recv: &hir::Expr<'_>,\n+    nth_arg: &hir::Expr<'_>,\n     is_mut: bool,\n ) {\n-    let iter_args = nth_and_iter_args[1];\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n-    let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.typeck_results().expr_ty(&iter_args[0])).is_some() {\n+    let caller_type = if derefs_to_slice(cx, iter_recv, cx.typeck_results().expr_ty(iter_recv)).is_some() {\n         \"slice\"\n-    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym::vec_type) {\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(iter_recv), sym::vec_type) {\n         \"Vec\"\n-    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym::vecdeque_type) {\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(iter_recv), sym::vecdeque_type) {\n         \"VecDeque\"\n     } else {\n-        let nth_args = nth_and_iter_args[0];\n-        iter_nth_zero::check(cx, expr, &nth_args);\n+        iter_nth_zero::check(cx, expr, nth_recv, nth_arg);\n         return; // caller is not a type that we want to lint\n     };\n "}, {"sha": "52d7c15332e809c593b4d4e7cbebec2cd717390b", "filename": "clippy_lints/src/methods/iter_nth_zero.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -10,10 +10,10 @@ use rustc_span::sym;\n \n use super::ITER_NTH_ZERO;\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, nth_args: &'tcx [hir::Expr<'_>]) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n     if_chain! {\n         if is_trait_method(cx, expr, sym::Iterator);\n-        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), &nth_args[1]);\n+        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), arg);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n@@ -22,7 +22,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, nth_args\n                 expr.span,\n                 \"called `.nth(0)` on a `std::iter::Iterator`, when `.next()` is equivalent\",\n                 \"try calling `.next()` instead of `.nth(0)`\",\n-                format!(\"{}.next()\", snippet_with_applicability(cx, nth_args[0].span, \"..\", &mut applicability)),\n+                format!(\"{}.next()\", snippet_with_applicability(cx, recv.span, \"..\", &mut applicability)),\n                 applicability,\n             );\n         }"}, {"sha": "e32594757d0caa929da4a608e335baad4b527d42", "filename": "clippy_lints/src/methods/iter_skip_next.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -8,19 +8,17 @@ use rustc_span::sym;\n \n use super::ITER_SKIP_NEXT;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, skip_args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n     // lint if caller of skip is an Iterator\n     if is_trait_method(cx, expr, sym::Iterator) {\n-        if let [caller, n] = skip_args {\n-            span_lint_and_sugg(\n-                cx,\n-                ITER_SKIP_NEXT,\n-                expr.span.trim_start(caller.span).unwrap(),\n-                \"called `skip(..).next()` on an iterator\",\n-                \"use `nth` instead\",\n-                format!(\".nth({})\", snippet(cx, n.span, \"..\")),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n+        span_lint_and_sugg(\n+            cx,\n+            ITER_SKIP_NEXT,\n+            expr.span.trim_start(recv.span).unwrap(),\n+            \"called `skip(..).next()` on an iterator\",\n+            \"use `nth` instead\",\n+            format!(\".nth({})\", snippet(cx, arg.span, \"..\")),\n+            Applicability::MachineApplicable,\n+        );\n     }\n }"}, {"sha": "06b12998b1aae958fe22a34e16189fd1711161de", "filename": "clippy_lints/src/methods/iterator_step_by_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -7,9 +7,9 @@ use rustc_span::sym;\n \n use super::ITERATOR_STEP_BY_ZERO;\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, args: &'tcx [hir::Expr<'_>]) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &'tcx hir::Expr<'_>) {\n     if is_trait_method(cx, expr, sym::Iterator) {\n-        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), &args[1]) {\n+        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), arg) {\n             span_lint(\n                 cx,\n                 ITERATOR_STEP_BY_ZERO,"}, {"sha": "ecb8b72ef46105b28838b2893c5e41e0946e5157", "filename": "clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -8,11 +8,14 @@ use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_target::abi::LayoutOf;\n \n-pub fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[&[hir::Expr<'_>]], arith: &str) {\n-    let unwrap_arg = &args[0][1];\n-    let arith_lhs = &args[1][0];\n-    let arith_rhs = &args[1][1];\n-\n+pub fn check(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    arith_lhs: &hir::Expr<'_>,\n+    arith_rhs: &hir::Expr<'_>,\n+    unwrap_arg: &hir::Expr<'_>,\n+    arith: &str,\n+) {\n     let ty = cx.typeck_results().expr_ty(arith_lhs);\n     if !ty.is_integral() {\n         return;\n@@ -41,44 +44,28 @@ pub fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[&[hir::Expr<'_>\n             // \"mul\" is omitted because lhs can be negative.\n             _ => return,\n         }\n-\n-        let mut applicability = Applicability::MachineApplicable;\n-        span_lint_and_sugg(\n-            cx,\n-            super::MANUAL_SATURATING_ARITHMETIC,\n-            expr.span,\n-            \"manual saturating arithmetic\",\n-            &format!(\"try using `saturating_{}`\", arith),\n-            format!(\n-                \"{}.saturating_{}({})\",\n-                snippet_with_applicability(cx, arith_lhs.span, \"..\", &mut applicability),\n-                arith,\n-                snippet_with_applicability(cx, arith_rhs.span, \"..\", &mut applicability),\n-            ),\n-            applicability,\n-        );\n     } else {\n         match (mm, arith) {\n             (MinMax::Max, \"add\" | \"mul\") | (MinMax::Min, \"sub\") => (),\n             _ => return,\n         }\n-\n-        let mut applicability = Applicability::MachineApplicable;\n-        span_lint_and_sugg(\n-            cx,\n-            super::MANUAL_SATURATING_ARITHMETIC,\n-            expr.span,\n-            \"manual saturating arithmetic\",\n-            &format!(\"try using `saturating_{}`\", arith),\n-            format!(\n-                \"{}.saturating_{}({})\",\n-                snippet_with_applicability(cx, arith_lhs.span, \"..\", &mut applicability),\n-                arith,\n-                snippet_with_applicability(cx, arith_rhs.span, \"..\", &mut applicability),\n-            ),\n-            applicability,\n-        );\n     }\n+\n+    let mut applicability = Applicability::MachineApplicable;\n+    span_lint_and_sugg(\n+        cx,\n+        super::MANUAL_SATURATING_ARITHMETIC,\n+        expr.span,\n+        \"manual saturating arithmetic\",\n+        &format!(\"try using `saturating_{}`\", arith),\n+        format!(\n+            \"{}.saturating_{}({})\",\n+            snippet_with_applicability(cx, arith_lhs.span, \"..\", &mut applicability),\n+            arith,\n+            snippet_with_applicability(cx, arith_rhs.span, \"..\", &mut applicability),\n+        ),\n+        applicability,\n+    );\n }\n \n #[derive(PartialEq, Eq)]"}, {"sha": "82063ad70b5358f33e54a3fa30befee48619dbe8", "filename": "clippy_lints/src/methods/map_collect_result_unit.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -14,21 +14,20 @@ use super::MAP_COLLECT_RESULT_UNIT;\n pub(super) fn check(\n     cx: &LateContext<'_>,\n     expr: &hir::Expr<'_>,\n-    map_args: &[hir::Expr<'_>],\n-    collect_args: &[hir::Expr<'_>],\n+    iter: &hir::Expr<'_>,\n+    map_fn: &hir::Expr<'_>,\n+    collect_recv: &hir::Expr<'_>,\n ) {\n     if_chain! {\n         // called on Iterator\n-        if let [map_expr] = collect_args;\n-        if is_trait_method(cx, map_expr, sym::Iterator);\n+        if is_trait_method(cx, collect_recv, sym::Iterator);\n         // return of collect `Result<(),_>`\n         let collect_ret_ty = cx.typeck_results().expr_ty(expr);\n         if is_type_diagnostic_item(cx, collect_ret_ty, sym::result_type);\n         if let ty::Adt(_, substs) = collect_ret_ty.kind();\n         if let Some(result_t) = substs.types().next();\n         if result_t.is_unit();\n         // get parts for snippet\n-        if let [iter, map_fn] = map_args;\n         then {\n             span_lint_and_sugg(\n                 cx,"}, {"sha": "e8ad16bc0def91b6676b11792eaedfb218ee0f2e", "filename": "clippy_lints/src/methods/map_flatten.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -11,10 +11,15 @@ use rustc_span::symbol::sym;\n use super::MAP_FLATTEN;\n \n /// lint use of `map().flatten()` for `Iterators` and 'Options'\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_args: &'tcx [hir::Expr<'_>]) {\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    recv: &'tcx hir::Expr<'_>,\n+    map_arg: &'tcx hir::Expr<'_>,\n+) {\n     // lint if caller of `.map().flatten()` is an Iterator\n     if is_trait_method(cx, expr, sym::Iterator) {\n-        let map_closure_ty = cx.typeck_results().expr_ty(&map_args[1]);\n+        let map_closure_ty = cx.typeck_results().expr_ty(map_arg);\n         let is_map_to_option = match map_closure_ty.kind() {\n             ty::Closure(_, _) | ty::FnDef(_, _) | ty::FnPtr(_) => {\n                 let map_closure_sig = match map_closure_ty.kind() {\n@@ -34,12 +39,12 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n             // `(...).map(...)` has type `impl Iterator<Item=impl Iterator<...>>\n             \"flat_map\"\n         };\n-        let func_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let func_snippet = snippet(cx, map_arg.span, \"..\");\n         let hint = format!(\".{0}({1})\", method_to_use, func_snippet);\n         span_lint_and_sugg(\n             cx,\n             MAP_FLATTEN,\n-            expr.span.with_lo(map_args[0].span.hi()),\n+            expr.span.with_lo(recv.span.hi()),\n             \"called `map(..).flatten()` on an `Iterator`\",\n             &format!(\"try using `{}` instead\", method_to_use),\n             hint,\n@@ -48,13 +53,13 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     }\n \n     // lint if caller of `.map().flatten()` is an Option\n-    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type) {\n-        let func_snippet = snippet(cx, map_args[1].span, \"..\");\n+    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::option_type) {\n+        let func_snippet = snippet(cx, map_arg.span, \"..\");\n         let hint = format!(\".and_then({})\", func_snippet);\n         span_lint_and_sugg(\n             cx,\n             MAP_FLATTEN,\n-            expr.span.with_lo(map_args[0].span.hi()),\n+            expr.span.with_lo(recv.span.hi()),\n             \"called `map(..).flatten()` on an `Option`\",\n             \"try using `and_then` instead\",\n             hint,"}, {"sha": "4330fea727b3aad373ace7e667c9d61f568b9e10", "filename": "clippy_lints/src/methods/map_unwrap_or.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -18,22 +18,23 @@ const MAP_UNWRAP_OR_MSRV: RustcVersion = RustcVersion::new(1, 41, 0);\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n-    map_args: &'tcx [hir::Expr<'_>],\n-    unwrap_args: &'tcx [hir::Expr<'_>],\n+    recv: &'tcx hir::Expr<'_>,\n+    map_arg: &'tcx hir::Expr<'_>,\n+    unwrap_arg: &'tcx hir::Expr<'_>,\n     msrv: Option<&RustcVersion>,\n ) -> bool {\n     if !meets_msrv(msrv, &MAP_UNWRAP_OR_MSRV) {\n         return false;\n     }\n     // lint if the caller of `map()` is an `Option`\n-    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type);\n-    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::result_type);\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::result_type);\n \n     if is_option || is_result {\n         // Don't make a suggestion that may fail to compile due to mutably borrowing\n         // the same variable twice.\n-        let map_mutated_vars = mutated_variables(&map_args[0], cx);\n-        let unwrap_mutated_vars = mutated_variables(&unwrap_args[1], cx);\n+        let map_mutated_vars = mutated_variables(recv, cx);\n+        let unwrap_mutated_vars = mutated_variables(unwrap_arg, cx);\n         if let (Some(map_mutated_vars), Some(unwrap_mutated_vars)) = (map_mutated_vars, unwrap_mutated_vars) {\n             if map_mutated_vars.intersection(&unwrap_mutated_vars).next().is_some() {\n                 return false;\n@@ -51,14 +52,14 @@ pub(super) fn check<'tcx>(\n             `.map_or_else(<g>, <f>)` instead\"\n         };\n         // get snippets for args to map() and unwrap_or_else()\n-        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n-        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n+        let map_snippet = snippet(cx, map_arg.span, \"..\");\n+        let unwrap_snippet = snippet(cx, unwrap_arg.span, \"..\");\n         // lint, with note if neither arg is > 1 line and both map() and\n         // unwrap_or_else() have the same span\n         let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n-        let same_span = map_args[1].span.ctxt() == unwrap_args[1].span.ctxt();\n+        let same_span = map_arg.span.ctxt() == unwrap_arg.span.ctxt();\n         if same_span && !multiline {\n-            let var_snippet = snippet(cx, map_args[0].span, \"..\");\n+            let var_snippet = snippet(cx, recv.span, \"..\");\n             span_lint_and_sugg(\n                 cx,\n                 MAP_UNWRAP_OR,"}, {"sha": "b1ade5addd6aa089e36707a7960d76860a9a09a3", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 203, "deletions": 142, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -62,17 +62,18 @@ mod zst_offset;\n use bind_instead_of_map::BindInsteadOfMap;\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::ty::{contains_adt_constructor, contains_ty, implements_trait, is_copy, is_type_diagnostic_item};\n-use clippy_utils::{contains_return, get_trait_def_id, in_macro, iter_input_pats, method_calls, paths, return_ty};\n+use clippy_utils::{contains_return, get_trait_def_id, in_macro, iter_input_pats, paths, return_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_hir::{PrimTy, QPath, TraitItem, TraitItemKind};\n+use rustc_hir::{Expr, ExprKind, PrimTy, QPath, TraitItem, TraitItemKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, TraitRef, Ty, TyS};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::{sym, SymbolStr};\n+use rustc_span::symbol::SymbolStr;\n+use rustc_span::{sym, Span};\n use rustc_typeck::hir_ty_to_ty;\n \n declare_clippy_lint! {\n@@ -205,6 +206,13 @@ declare_clippy_lint! {\n     /// |`to_`  | not `_mut` |`self`                 | `Copy`       |\n     /// |`to_`  | not `_mut` |`&self`                | not `Copy`   |\n     ///\n+    /// Note: Clippy doesn't trigger methods with `to_` prefix in:\n+    /// - Traits definition.\n+    /// Clippy can not tell if a type that implements a trait is `Copy` or not.\n+    /// - Traits implementation, when `&self` is taken.\n+    /// The method signature is controlled by the trait and often `&self` is required for all types that implement the trait\n+    /// (see e.g. the `std::string::ToString` trait).\n+    ///\n     /// Please find more info here:\n     /// https://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv\n     ///\n@@ -896,6 +904,28 @@ declare_clippy_lint! {\n     \"using `Iterator::step_by(0)`, which will panic at runtime\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for indirect collection of populated `Option`\n+    ///\n+    /// **Why is this bad?** `Option` is like a collection of 0-1 things, so `flatten`\n+    /// automatically does this without suspicious-looking `unwrap` calls.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let _ = std::iter::empty::<Option<i32>>().filter(Option::is_some).map(Option::unwrap);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let _ = std::iter::empty::<Option<i32>>().flatten();\n+    /// ```\n+    pub OPTION_FILTER_MAP,\n+    complexity,\n+    \"filtering `Option` for `Some` then force-unwrapping, which can be one type-safe operation\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for the use of `iter.nth(0)`.\n     ///\n@@ -1651,6 +1681,7 @@ impl_lint_pass!(Methods => [\n     FILTER_MAP_IDENTITY,\n     MANUAL_FILTER_MAP,\n     MANUAL_FIND_MAP,\n+    OPTION_FILTER_MAP,\n     FILTER_MAP_NEXT,\n     FLAT_MAP_IDENTITY,\n     MAP_FLATTEN,\n@@ -1681,140 +1712,38 @@ impl_lint_pass!(Methods => [\n     IMPLICIT_CLONE\n ]);\n \n+/// Extracts a method call name, args, and `Span` of the method name.\n+fn method_call<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> Option<(SymbolStr, &'tcx [hir::Expr<'tcx>], Span)> {\n+    if let ExprKind::MethodCall(path, span, args, _) = recv.kind {\n+        if !args.iter().any(|e| e.span.from_expansion()) {\n+            return Some((path.ident.name.as_str(), args, span));\n+        }\n+    }\n+    None\n+}\n+\n+/// Same as `method_call` but the `SymbolStr` is dereferenced into a temporary `&str`\n+macro_rules! method_call {\n+    ($expr:expr) => {\n+        method_call($expr)\n+            .as_ref()\n+            .map(|&(ref name, args, span)| (&**name, args, span))\n+    };\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for Methods {\n-    #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if in_macro(expr.span) {\n             return;\n         }\n \n-        let (method_names, arg_lists, method_spans) = method_calls(expr, 2);\n-        let method_names: Vec<SymbolStr> = method_names.iter().map(|s| s.as_str()).collect();\n-        let method_names: Vec<&str> = method_names.iter().map(|s| &**s).collect();\n-\n-        match method_names.as_slice() {\n-            [\"unwrap\", \"get\"] => get_unwrap::check(cx, expr, arg_lists[1], false),\n-            [\"unwrap\", \"get_mut\"] => get_unwrap::check(cx, expr, arg_lists[1], true),\n-            [\"unwrap\", ..] => unwrap_used::check(cx, expr, arg_lists[0]),\n-            [\"expect\", \"ok\"] => ok_expect::check(cx, expr, arg_lists[1]),\n-            [\"expect\", ..] => expect_used::check(cx, expr, arg_lists[0]),\n-            [\"unwrap_or\", \"map\"] => option_map_unwrap_or::check(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n-            [\"unwrap_or_else\", \"map\"] => {\n-                if !map_unwrap_or::check(cx, expr, arg_lists[1], arg_lists[0], self.msrv.as_ref()) {\n-                    unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"unwrap_or\");\n-                }\n-            },\n-            [\"map_or\", ..] => option_map_or_none::check(cx, expr, arg_lists[0]),\n-            [\"and_then\", ..] => {\n-                let biom_option_linted = bind_instead_of_map::OptionAndThenSome::check(cx, expr, arg_lists[0]);\n-                let biom_result_linted = bind_instead_of_map::ResultAndThenOk::check(cx, expr, arg_lists[0]);\n-                if !biom_option_linted && !biom_result_linted {\n-                    unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"and\");\n-                }\n-            },\n-            [\"or_else\", ..] => {\n-                if !bind_instead_of_map::ResultOrElseErrInfo::check(cx, expr, arg_lists[0]) {\n-                    unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"or\");\n-                }\n-            },\n-            [\"next\", \"filter\"] => filter_next::check(cx, expr, arg_lists[1]),\n-            [\"next\", \"skip_while\"] => skip_while_next::check(cx, expr, arg_lists[1]),\n-            [\"next\", \"iter\"] => iter_next_slice::check(cx, expr, arg_lists[1]),\n-            [\"map\", \"filter\"] => filter_map::check(cx, expr, false),\n-            [\"map\", \"filter_map\"] => filter_map_map::check(cx, expr),\n-            [\"next\", \"filter_map\"] => filter_map_next::check(cx, expr, arg_lists[1], self.msrv.as_ref()),\n-            [\"map\", \"find\"] => filter_map::check(cx, expr, true),\n-            [\"flat_map\", \"filter\"] => filter_flat_map::check(cx, expr),\n-            [\"flat_map\", \"filter_map\"] => filter_map_flat_map::check(cx, expr),\n-            [\"flat_map\", ..] => flat_map_identity::check(cx, expr, arg_lists[0], method_spans[0]),\n-            [\"flatten\", \"map\"] => map_flatten::check(cx, expr, arg_lists[1]),\n-            [option_check_method, \"find\"] if \"is_some\" == *option_check_method || \"is_none\" == *option_check_method => {\n-                search_is_some::check(\n-                    cx,\n-                    expr,\n-                    \"find\",\n-                    option_check_method,\n-                    arg_lists[1],\n-                    arg_lists[0],\n-                    method_spans[1],\n-                )\n-            },\n-            [option_check_method, \"position\"]\n-                if \"is_some\" == *option_check_method || \"is_none\" == *option_check_method =>\n-            {\n-                search_is_some::check(\n-                    cx,\n-                    expr,\n-                    \"position\",\n-                    option_check_method,\n-                    arg_lists[1],\n-                    arg_lists[0],\n-                    method_spans[1],\n-                )\n-            },\n-            [option_check_method, \"rposition\"]\n-                if \"is_some\" == *option_check_method || \"is_none\" == *option_check_method =>\n-            {\n-                search_is_some::check(\n-                    cx,\n-                    expr,\n-                    \"rposition\",\n-                    option_check_method,\n-                    arg_lists[1],\n-                    arg_lists[0],\n-                    method_spans[1],\n-                )\n-            },\n-            [\"extend\", ..] => string_extend_chars::check(cx, expr, arg_lists[0]),\n-            [\"count\", \"into_iter\"] => iter_count::check(cx, expr, &arg_lists[1], \"into_iter\"),\n-            [\"count\", \"iter\"] => iter_count::check(cx, expr, &arg_lists[1], \"iter\"),\n-            [\"count\", \"iter_mut\"] => iter_count::check(cx, expr, &arg_lists[1], \"iter_mut\"),\n-            [\"nth\", \"iter\"] => iter_nth::check(cx, expr, &arg_lists, false),\n-            [\"nth\", \"iter_mut\"] => iter_nth::check(cx, expr, &arg_lists, true),\n-            [\"nth\", \"bytes\"] => bytes_nth::check(cx, expr, &arg_lists[1]),\n-            [\"nth\", ..] => iter_nth_zero::check(cx, expr, arg_lists[0]),\n-            [\"step_by\", ..] => iterator_step_by_zero::check(cx, expr, arg_lists[0]),\n-            [\"next\", \"skip\"] => iter_skip_next::check(cx, expr, arg_lists[1]),\n-            [\"collect\", \"cloned\"] => iter_cloned_collect::check(cx, expr, arg_lists[1]),\n-            [\"as_ref\"] => useless_asref::check(cx, expr, \"as_ref\", arg_lists[0]),\n-            [\"as_mut\"] => useless_asref::check(cx, expr, \"as_mut\", arg_lists[0]),\n-            [\"fold\", ..] => unnecessary_fold::check(cx, expr, arg_lists[0], method_spans[0]),\n-            [\"filter_map\", ..] => {\n-                unnecessary_filter_map::check(cx, expr, arg_lists[0]);\n-                filter_map_identity::check(cx, expr, arg_lists[0], method_spans[0]);\n-            },\n-            [\"count\", \"map\"] => suspicious_map::check(cx, expr, arg_lists[1], arg_lists[0]),\n-            [\"assume_init\"] => uninit_assumed_init::check(cx, &arg_lists[0][0], expr),\n-            [\"unwrap_or\", arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\")] => {\n-                manual_saturating_arithmetic::check(cx, expr, &arg_lists, &arith[\"checked_\".len()..])\n-            },\n-            [\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\"] => {\n-                zst_offset::check(cx, expr, arg_lists[0])\n-            },\n-            [\"is_file\", ..] => filetype_is_file::check(cx, expr, arg_lists[0]),\n-            [\"map\", \"as_ref\"] => {\n-                option_as_ref_deref::check(cx, expr, arg_lists[1], arg_lists[0], false, self.msrv.as_ref())\n-            },\n-            [\"map\", \"as_mut\"] => {\n-                option_as_ref_deref::check(cx, expr, arg_lists[1], arg_lists[0], true, self.msrv.as_ref())\n-            },\n-            [\"unwrap_or_else\", ..] => unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"unwrap_or\"),\n-            [\"get_or_insert_with\", ..] => unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"get_or_insert\"),\n-            [\"ok_or_else\", ..] => unnecessary_lazy_eval::check(cx, expr, arg_lists[0], \"ok_or\"),\n-            [\"collect\", \"map\"] => map_collect_result_unit::check(cx, expr, arg_lists[1], arg_lists[0]),\n-            [\"for_each\", \"inspect\"] => inspect_for_each::check(cx, expr, method_spans[1]),\n-            [\"to_owned\", ..] => implicit_clone::check(cx, expr, sym::ToOwned),\n-            [\"to_os_string\", ..] => implicit_clone::check(cx, expr, sym::OsStr),\n-            [\"to_path_buf\", ..] => implicit_clone::check(cx, expr, sym::Path),\n-            [\"to_vec\", ..] => implicit_clone::check(cx, expr, sym::slice),\n-            _ => {},\n-        }\n+        check_methods(cx, expr, self.msrv.as_ref());\n \n         match expr.kind {\n-            hir::ExprKind::Call(ref func, ref args) => {\n+            hir::ExprKind::Call(func, args) => {\n                 from_iter_instead_of_collect::check(cx, expr, args, &func.kind);\n             },\n-            hir::ExprKind::MethodCall(ref method_call, ref method_span, ref args, _) => {\n+            hir::ExprKind::MethodCall(method_call, ref method_span, args, _) => {\n                 or_fun_call::check(cx, expr, *method_span, &method_call.ident.as_str(), args);\n                 expect_fun_call::check(cx, expr, *method_span, &method_call.ident.as_str(), args);\n                 clone_on_copy::check(cx, expr, method_call.ident.name, args);\n@@ -1824,17 +1753,15 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 into_iter_on_ref::check(cx, expr, *method_span, method_call.ident.name, args);\n                 single_char_pattern::check(cx, expr, method_call.ident.name, args);\n             },\n-            hir::ExprKind::Binary(op, ref lhs, ref rhs)\n-                if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne =>\n-            {\n+            hir::ExprKind::Binary(op, lhs, rhs) if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne => {\n                 let mut info = BinaryExprInfo {\n                     expr,\n                     chain: lhs,\n                     other: rhs,\n                     eq: op.node == hir::BinOpKind::Eq,\n                 };\n                 lint_binary_expr_with_method_call(cx, &mut info);\n-            }\n+            },\n             _ => (),\n         }\n     }\n@@ -1850,10 +1777,9 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         let self_ty = cx.tcx.type_of(item.def_id);\n \n         let implements_trait = matches!(item.kind, hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }));\n-\n         if_chain! {\n             if let hir::ImplItemKind::Fn(ref sig, id) = impl_item.kind;\n-            if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir().body(id)).next();\n+            if let Some(first_arg) = iter_input_pats(sig.decl, cx.tcx.hir().body(id)).next();\n \n             let method_sig = cx.tcx.fn_sig(impl_item.def_id);\n             let method_sig = cx.tcx.erase_late_bound_regions(method_sig);\n@@ -1873,7 +1799,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                             method_config.output_type.matches(&sig.decl.output) &&\n                             method_config.self_kind.matches(cx, self_ty, first_arg_ty) &&\n                             fn_header_equals(method_config.fn_header, sig.header) &&\n-                            method_config.lifetime_param_cond(&impl_item)\n+                            method_config.lifetime_param_cond(impl_item)\n                         {\n                             span_lint_and_help(\n                                 cx,\n@@ -1902,6 +1828,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                     self_ty,\n                     first_arg_ty,\n                     first_arg.pat.span,\n+                    implements_trait,\n                     false\n                 );\n             }\n@@ -1960,18 +1887,18 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         if_chain! {\n             if let TraitItemKind::Fn(ref sig, _) = item.kind;\n             if let Some(first_arg_ty) = sig.decl.inputs.iter().next();\n-            let first_arg_span = first_arg_ty.span;\n-            let first_arg_ty = hir_ty_to_ty(cx.tcx, first_arg_ty);\n-            let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id()).self_ty();\n-\n             then {\n+                let first_arg_span = first_arg_ty.span;\n+                let first_arg_ty = hir_ty_to_ty(cx.tcx, first_arg_ty);\n+                let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id()).self_ty();\n                 wrong_self_convention::check(\n                     cx,\n                     &item.ident.name.as_str(),\n                     false,\n                     self_ty,\n                     first_arg_ty,\n                     first_arg_span,\n+                    false,\n                     true\n                 );\n             }\n@@ -1997,6 +1924,140 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n     extract_msrv_attr!(LateContext);\n }\n+\n+#[allow(clippy::too_many_lines)]\n+fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Option<&RustcVersion>) {\n+    if let Some((name, [recv, args @ ..], span)) = method_call!(expr) {\n+        match (name, args) {\n+            (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [recv, _]) => {\n+                zst_offset::check(cx, expr, recv)\n+            },\n+            (\"and_then\", [arg]) => {\n+                let biom_option_linted = bind_instead_of_map::OptionAndThenSome::check(cx, expr, recv, arg);\n+                let biom_result_linted = bind_instead_of_map::ResultAndThenOk::check(cx, expr, recv, arg);\n+                if !biom_option_linted && !biom_result_linted {\n+                    unnecessary_lazy_eval::check(cx, expr, recv, arg, \"and\");\n+                }\n+            },\n+            (\"as_mut\", []) => useless_asref::check(cx, expr, \"as_mut\", recv),\n+            (\"as_ref\", []) => useless_asref::check(cx, expr, \"as_ref\", recv),\n+            (\"assume_init\", []) => uninit_assumed_init::check(cx, expr, recv),\n+            (\"collect\", []) => match method_call!(recv) {\n+                Some((\"cloned\", [recv2], _)) => iter_cloned_collect::check(cx, expr, recv2),\n+                Some((\"map\", [m_recv, m_arg], _)) => {\n+                    map_collect_result_unit::check(cx, expr, m_recv, m_arg, recv);\n+                },\n+                _ => {},\n+            },\n+            (\"count\", []) => match method_call!(recv) {\n+                Some((name @ (\"into_iter\" | \"iter\" | \"iter_mut\"), [recv2], _)) => {\n+                    iter_count::check(cx, expr, recv2, name);\n+                },\n+                Some((\"map\", [_, arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n+                _ => {},\n+            },\n+            (\"expect\", [_]) => match method_call!(recv) {\n+                Some((\"ok\", [recv], _)) => ok_expect::check(cx, expr, recv),\n+                _ => expect_used::check(cx, expr, recv),\n+            },\n+            (\"extend\", [arg]) => string_extend_chars::check(cx, expr, recv, arg),\n+            (\"filter_map\", [arg]) => {\n+                unnecessary_filter_map::check(cx, expr, arg);\n+                filter_map_identity::check(cx, expr, arg, span);\n+            },\n+            (\"flat_map\", [flm_arg]) => match method_call!(recv) {\n+                Some((\"filter\", [_, _], _)) => filter_flat_map::check(cx, expr),\n+                Some((\"filter_map\", [_, _], _)) => filter_map_flat_map::check(cx, expr),\n+                _ => flat_map_identity::check(cx, expr, flm_arg, span),\n+            },\n+            (\"flatten\", []) => {\n+                if let Some((\"map\", [recv, map_arg], _)) = method_call!(recv) {\n+                    map_flatten::check(cx, expr, recv, map_arg);\n+                }\n+            },\n+            (\"fold\", [init, acc]) => unnecessary_fold::check(cx, expr, init, acc, span),\n+            (\"for_each\", [_]) => {\n+                if let Some((\"inspect\", [_, _], span2)) = method_call!(recv) {\n+                    inspect_for_each::check(cx, expr, span2);\n+                }\n+            },\n+            (\"get_or_insert_with\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"get_or_insert\"),\n+            (\"is_file\", []) => filetype_is_file::check(cx, expr, recv),\n+            (\"is_none\", []) => check_is_some_is_none(cx, expr, recv, false),\n+            (\"is_some\", []) => check_is_some_is_none(cx, expr, recv, true),\n+            (\"map\", [m_arg]) => {\n+                if let Some((name, [recv2, args @ ..], span2)) = method_call!(recv) {\n+                    match (name, args) {\n+                        (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, msrv),\n+                        (\"as_ref\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, false, msrv),\n+                        (\"filter\", [f_arg]) => {\n+                            filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, false)\n+                        },\n+                        (\"filter_map\", [_]) => filter_map_map::check(cx, expr),\n+                        (\"find\", [f_arg]) => filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, true),\n+                        _ => {},\n+                    }\n+                }\n+            },\n+            (\"map_or\", [def, map]) => option_map_or_none::check(cx, expr, recv, def, map),\n+            (\"next\", []) => {\n+                if let Some((name, [recv, args @ ..], _)) = method_call!(recv) {\n+                    match (name, args) {\n+                        (\"filter\", [arg]) => filter_next::check(cx, expr, recv, arg),\n+                        (\"filter_map\", [arg]) => filter_map_next::check(cx, expr, recv, arg, msrv),\n+                        (\"iter\", []) => iter_next_slice::check(cx, expr, recv),\n+                        (\"skip\", [arg]) => iter_skip_next::check(cx, expr, recv, arg),\n+                        (\"skip_while\", [_]) => skip_while_next::check(cx, expr),\n+                        _ => {},\n+                    }\n+                }\n+            },\n+            (\"nth\", [n_arg]) => match method_call!(recv) {\n+                Some((\"bytes\", [recv2], _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n+                Some((\"iter\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n+                Some((\"iter_mut\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n+                _ => iter_nth_zero::check(cx, expr, recv, n_arg),\n+            },\n+            (\"ok_or_else\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"ok_or\"),\n+            (\"or_else\", [arg]) => {\n+                if !bind_instead_of_map::ResultOrElseErrInfo::check(cx, expr, recv, arg) {\n+                    unnecessary_lazy_eval::check(cx, expr, recv, arg, \"or\");\n+                }\n+            },\n+            (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n+            (\"to_os_string\", []) => implicit_clone::check(cx, expr, sym::OsStr),\n+            (\"to_owned\", []) => implicit_clone::check(cx, expr, sym::ToOwned),\n+            (\"to_path_buf\", []) => implicit_clone::check(cx, expr, sym::Path),\n+            (\"to_vec\", []) => implicit_clone::check(cx, expr, sym::slice),\n+            (\"unwrap\", []) => match method_call!(recv) {\n+                Some((\"get\", [recv, get_arg], _)) => get_unwrap::check(cx, expr, recv, get_arg, false),\n+                Some((\"get_mut\", [recv, get_arg], _)) => get_unwrap::check(cx, expr, recv, get_arg, true),\n+                _ => unwrap_used::check(cx, expr, recv),\n+            },\n+            (\"unwrap_or\", [u_arg]) => match method_call!(recv) {\n+                Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), [lhs, rhs], _)) => {\n+                    manual_saturating_arithmetic::check(cx, expr, lhs, rhs, u_arg, &arith[\"checked_\".len()..]);\n+                },\n+                Some((\"map\", [m_recv, m_arg], span)) => {\n+                    option_map_unwrap_or::check(cx, expr, m_recv, m_arg, recv, u_arg, span)\n+                },\n+                _ => {},\n+            },\n+            (\"unwrap_or_else\", [u_arg]) => match method_call!(recv) {\n+                Some((\"map\", [recv, map_arg], _)) if map_unwrap_or::check(cx, expr, recv, map_arg, u_arg, msrv) => {},\n+                _ => unnecessary_lazy_eval::check(cx, expr, recv, u_arg, \"unwrap_or\"),\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+fn check_is_some_is_none(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, is_some: bool) {\n+    if let Some((name @ (\"find\" | \"position\" | \"rposition\"), [f_recv, arg], span)) = method_call!(recv) {\n+        search_is_some::check(cx, expr, name, is_some, f_recv, arg, recv, span)\n+    }\n+}\n+\n /// Used for `lint_binary_expr_with_method_call`.\n #[derive(Copy, Clone)]\n struct BinaryExprInfo<'a> {\n@@ -2209,10 +2270,10 @@ impl OutType {\n         let is_unit = |ty: &hir::Ty<'_>| matches!(ty.kind, hir::TyKind::Tup(&[]));\n         match (self, ty) {\n             (Self::Unit, &hir::FnRetTy::DefaultReturn(_)) => true,\n-            (Self::Unit, &hir::FnRetTy::Return(ref ty)) if is_unit(ty) => true,\n-            (Self::Bool, &hir::FnRetTy::Return(ref ty)) if is_bool(ty) => true,\n-            (Self::Any, &hir::FnRetTy::Return(ref ty)) if !is_unit(ty) => true,\n-            (Self::Ref, &hir::FnRetTy::Return(ref ty)) => matches!(ty.kind, hir::TyKind::Rptr(_, _)),\n+            (Self::Unit, &hir::FnRetTy::Return(ty)) if is_unit(ty) => true,\n+            (Self::Bool, &hir::FnRetTy::Return(ty)) if is_bool(ty) => true,\n+            (Self::Any, &hir::FnRetTy::Return(ty)) if !is_unit(ty) => true,\n+            (Self::Ref, &hir::FnRetTy::Return(ty)) => matches!(ty.kind, hir::TyKind::Rptr(_, _)),\n             _ => false,\n         }\n     }"}, {"sha": "d0b1b4b84be507f0bba45e2ab0f8a38467656d46", "filename": "clippy_lints/src/methods/ok_expect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fok_expect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fok_expect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fok_expect.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -9,11 +9,11 @@ use rustc_span::sym;\n use super::OK_EXPECT;\n \n /// lint use of `ok().expect()` for `Result`s\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ok_args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n     if_chain! {\n         // lint if the caller of `ok()` is a `Result`\n-        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&ok_args[0]), sym::result_type);\n-        let result_type = cx.typeck_results().expr_ty(&ok_args[0]);\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::result_type);\n+        let result_type = cx.typeck_results().expr_ty(recv);\n         if let Some(error_type) = get_error_type(cx, result_type);\n         if has_debug_impl(error_type, cx);\n "}, {"sha": "7e9c8fa829decd77f9feb3ce6b1b5fe66ae30955", "filename": "clippy_lints/src/methods/option_as_ref_deref.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -18,8 +18,8 @@ const OPTION_AS_REF_DEREF_MSRV: RustcVersion = RustcVersion::new(1, 40, 0);\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &hir::Expr<'_>,\n-    as_ref_args: &[hir::Expr<'_>],\n-    map_args: &[hir::Expr<'_>],\n+    as_ref_recv: &hir::Expr<'_>,\n+    map_arg: &hir::Expr<'_>,\n     is_mut: bool,\n     msrv: Option<&RustcVersion>,\n ) {\n@@ -29,7 +29,7 @@ pub(super) fn check<'tcx>(\n \n     let same_mutability = |m| (is_mut && m == &hir::Mutability::Mut) || (!is_mut && m == &hir::Mutability::Not);\n \n-    let option_ty = cx.typeck_results().expr_ty(&as_ref_args[0]);\n+    let option_ty = cx.typeck_results().expr_ty(as_ref_recv);\n     if !is_type_diagnostic_item(cx, option_ty, sym::option_type) {\n         return;\n     }\n@@ -46,9 +46,9 @@ pub(super) fn check<'tcx>(\n         &paths::VEC_AS_MUT_SLICE,\n     ];\n \n-    let is_deref = match map_args[1].kind {\n+    let is_deref = match map_arg.kind {\n         hir::ExprKind::Path(ref expr_qpath) => cx\n-            .qpath_res(expr_qpath, map_args[1].hir_id)\n+            .qpath_res(expr_qpath, map_arg.hir_id)\n             .opt_def_id()\n             .map_or(false, |fun_def_id| {\n                 deref_aliases.iter().any(|path| match_def_path(cx, fun_def_id, path))\n@@ -77,10 +77,10 @@ pub(super) fn check<'tcx>(\n                         }\n                     }\n                 },\n-                hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, ref inner) if same_mutability(m) => {\n+                hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, inner) if same_mutability(m) => {\n                     if_chain! {\n-                        if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner1) = inner.kind;\n-                        if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner2) = inner1.kind;\n+                        if let hir::ExprKind::Unary(hir::UnOp::Deref, inner1) = inner.kind;\n+                        if let hir::ExprKind::Unary(hir::UnOp::Deref, inner2) = inner1.kind;\n                         then {\n                             path_to_local_id(inner2, closure_body.params[0].pat.hir_id)\n                         } else {\n@@ -96,12 +96,12 @@ pub(super) fn check<'tcx>(\n \n     if is_deref {\n         let current_method = if is_mut {\n-            format!(\".as_mut().map({})\", snippet(cx, map_args[1].span, \"..\"))\n+            format!(\".as_mut().map({})\", snippet(cx, map_arg.span, \"..\"))\n         } else {\n-            format!(\".as_ref().map({})\", snippet(cx, map_args[1].span, \"..\"))\n+            format!(\".as_ref().map({})\", snippet(cx, map_arg.span, \"..\"))\n         };\n         let method_hint = if is_mut { \"as_deref_mut\" } else { \"as_deref\" };\n-        let hint = format!(\"{}.{}()\", snippet(cx, as_ref_args[0].span, \"..\"), method_hint);\n+        let hint = format!(\"{}.{}()\", snippet(cx, as_ref_recv.span, \"..\"), method_hint);\n         let suggestion = format!(\"try using {} instead\", method_hint);\n \n         let msg = format!("}, {"sha": "013a6f90ac97b06bdfd443938f50e64ec7c22649", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -11,9 +11,15 @@ use super::OPTION_MAP_OR_NONE;\n use super::RESULT_MAP_OR_INTO_OPTION;\n \n /// lint use of `_.map_or(None, _)` for `Option`s and `Result`s\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_or_args: &'tcx [hir::Expr<'_>]) {\n-    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym::option_type);\n-    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym::result_type);\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    recv: &'tcx hir::Expr<'_>,\n+    def_arg: &'tcx hir::Expr<'_>,\n+    map_arg: &'tcx hir::Expr<'_>,\n+) {\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::result_type);\n \n     // There are two variants of this `map_or` lint:\n     // (1) using `map_or` as an adapter from `Result<T,E>` to `Option<T>`\n@@ -25,7 +31,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     }\n \n     let (lint_name, msg, instead, hint) = {\n-        let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = map_or_args[1].kind {\n+        let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = def_arg.kind {\n             match_qpath(qpath, &paths::OPTION_NONE)\n         } else {\n             return;\n@@ -36,15 +42,15 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n             return;\n         }\n \n-        let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_or_args[2].kind {\n+        let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_arg.kind {\n             match_qpath(qpath, &paths::OPTION_SOME)\n         } else {\n             false\n         };\n \n         if is_option {\n-            let self_snippet = snippet(cx, map_or_args[0].span, \"..\");\n-            let func_snippet = snippet(cx, map_or_args[2].span, \"..\");\n+            let self_snippet = snippet(cx, recv.span, \"..\");\n+            let func_snippet = snippet(cx, map_arg.span, \"..\");\n             let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n                        `and_then(..)` instead\";\n             (\n@@ -56,7 +62,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n         } else if f_arg_is_some {\n             let msg = \"called `map_or(None, Some)` on a `Result` value. This can be done more directly by calling \\\n                        `ok()` instead\";\n-            let self_snippet = snippet(cx, map_or_args[0].span, \"..\");\n+            let self_snippet = snippet(cx, recv.span, \"..\");\n             (\n                 RESULT_MAP_OR_INTO_OPTION,\n                 msg,"}, {"sha": "5bca49dec241408e5587e52db2ead38d67d67705", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -18,41 +18,43 @@ use super::MAP_UNWRAP_OR;\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &rustc_hir::Expr<'_>,\n-    map_args: &'tcx [rustc_hir::Expr<'_>],\n-    unwrap_args: &'tcx [rustc_hir::Expr<'_>],\n+    recv: &rustc_hir::Expr<'_>,\n+    map_arg: &'tcx rustc_hir::Expr<'_>,\n+    unwrap_recv: &rustc_hir::Expr<'_>,\n+    unwrap_arg: &'tcx rustc_hir::Expr<'_>,\n     map_span: Span,\n ) {\n     // lint if the caller of `map()` is an `Option`\n-    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type) {\n-        if !is_copy(cx, cx.typeck_results().expr_ty(&unwrap_args[1])) {\n+    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::option_type) {\n+        if !is_copy(cx, cx.typeck_results().expr_ty(unwrap_arg)) {\n             // Do not lint if the `map` argument uses identifiers in the `map`\n             // argument that are also used in the `unwrap_or` argument\n \n             let mut unwrap_visitor = UnwrapVisitor {\n                 cx,\n                 identifiers: FxHashSet::default(),\n             };\n-            unwrap_visitor.visit_expr(&unwrap_args[1]);\n+            unwrap_visitor.visit_expr(unwrap_arg);\n \n             let mut map_expr_visitor = MapExprVisitor {\n                 cx,\n                 identifiers: unwrap_visitor.identifiers,\n                 found_identifier: false,\n             };\n-            map_expr_visitor.visit_expr(&map_args[1]);\n+            map_expr_visitor.visit_expr(map_arg);\n \n             if map_expr_visitor.found_identifier {\n                 return;\n             }\n         }\n \n-        if differing_macro_contexts(unwrap_args[1].span, map_span) {\n+        if differing_macro_contexts(unwrap_arg.span, map_span) {\n             return;\n         }\n \n         let mut applicability = Applicability::MachineApplicable;\n         // get snippet for unwrap_or()\n-        let unwrap_snippet = snippet_with_applicability(cx, unwrap_args[1].span, \"..\", &mut applicability);\n+        let unwrap_snippet = snippet_with_applicability(cx, unwrap_arg.span, \"..\", &mut applicability);\n         // lint message\n         // comparing the snippet from source to raw text (\"None\") below is safe\n         // because we already have checked the type.\n@@ -70,14 +72,14 @@ pub(super) fn check<'tcx>(\n         );\n \n         span_lint_and_then(cx, MAP_UNWRAP_OR, expr.span, msg, |diag| {\n-            let map_arg_span = map_args[1].span;\n+            let map_arg_span = map_arg.span;\n \n             let mut suggestion = vec![\n                 (\n                     map_span,\n                     String::from(if unwrap_snippet_none { \"and_then\" } else { \"map_or\" }),\n                 ),\n-                (expr.span.with_lo(unwrap_args[0].span.hi()), String::from(\"\")),\n+                (expr.span.with_lo(unwrap_recv.span.hi()), String::from(\"\")),\n             ];\n \n             if !unwrap_snippet_none {"}, {"sha": "800172f4cf3dcdd3ee8a51363444b396c60b4040", "filename": "clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -10,7 +10,7 @@ use rustc_hir::{BlockCheckMode, UnsafeSource};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{kw, sym};\n use std::borrow::Cow;\n \n use super::OR_FUN_CALL;\n@@ -38,8 +38,8 @@ pub(super) fn check<'tcx>(\n             if !or_has_args;\n             if name == \"unwrap_or\";\n             if let hir::ExprKind::Path(ref qpath) = fun.kind;\n-            let path = &*last_path_segment(qpath).ident.as_str();\n-            if [\"default\", \"new\"].contains(&path);\n+            let path = last_path_segment(qpath).ident.name;\n+            if matches!(path, kw::Default | sym::new);\n             let arg_ty = cx.typeck_results().expr_ty(arg);\n             if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n             if implements_trait(cx, arg_ty, default_trait_id, &[]);\n@@ -86,7 +86,7 @@ pub(super) fn check<'tcx>(\n             (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n         ];\n \n-        if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = &arg.kind {\n+        if let hir::ExprKind::MethodCall(path, _, args, _) = &arg.kind {\n             if path.ident.as_str() == \"len\" {\n                 let ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n \n@@ -105,7 +105,7 @@ pub(super) fn check<'tcx>(\n             if KNOW_TYPES.iter().any(|k| k.2.contains(&name));\n \n             if is_lazyness_candidate(cx, arg);\n-            if !contains_return(&arg);\n+            if !contains_return(arg);\n \n             let self_ty = cx.typeck_results().expr_ty(self_expr);\n \n@@ -158,7 +158,7 @@ pub(super) fn check<'tcx>(\n \n     if args.len() == 2 {\n         match args[1].kind {\n-            hir::ExprKind::Call(ref fun, ref or_args) => {\n+            hir::ExprKind::Call(fun, or_args) => {\n                 let or_has_args = !or_args.is_empty();\n                 if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n                     let fun_span = if or_has_args { None } else { Some(fun.span) };"}, {"sha": "ecec6fc3bb7fa6b4742bed27dcfa3ce22597e93d", "filename": "clippy_lints/src/methods/search_is_some.rs", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -15,35 +15,37 @@ use super::SEARCH_IS_SOME;\n \n /// lint searching an Iterator followed by `is_some()`\n /// or calling `find()` on a string followed by `is_some()` or `is_none()`\n-#[allow(clippy::too_many_lines)]\n+#[allow(clippy::too_many_arguments, clippy::too_many_lines)]\n pub(super) fn check<'tcx>(\n-    cx: &LateContext<'tcx>,\n+    cx: &LateContext<'_>,\n     expr: &'tcx hir::Expr<'_>,\n     search_method: &str,\n-    option_check_method: &str,\n-    search_args: &'tcx [hir::Expr<'_>],\n-    is_some_args: &'tcx [hir::Expr<'_>],\n+    is_some: bool,\n+    search_recv: &hir::Expr<'_>,\n+    search_arg: &'tcx hir::Expr<'_>,\n+    is_some_recv: &hir::Expr<'_>,\n     method_span: Span,\n ) {\n+    let option_check_method = if is_some { \"is_some\" } else { \"is_none\" };\n     // lint if caller of search is an Iterator\n-    if is_trait_method(cx, &is_some_args[0], sym::Iterator) {\n+    if is_trait_method(cx, is_some_recv, sym::Iterator) {\n         let msg = format!(\n             \"called `{}()` after searching an `Iterator` with `{}`\",\n             option_check_method, search_method\n         );\n-        let search_snippet = snippet(cx, search_args[1].span, \"..\");\n+        let search_snippet = snippet(cx, search_arg.span, \"..\");\n         if search_snippet.lines().count() <= 1 {\n             // suggest `any(|x| ..)` instead of `any(|&x| ..)` for `find(|&x| ..).is_some()`\n             // suggest `any(|..| *..)` instead of `any(|..| **..)` for `find(|..| **..).is_some()`\n             let any_search_snippet = if_chain! {\n                 if search_method == \"find\";\n-                if let hir::ExprKind::Closure(_, _, body_id, ..) = search_args[1].kind;\n+                if let hir::ExprKind::Closure(_, _, body_id, ..) = search_arg.kind;\n                 let closure_body = cx.tcx.hir().body(body_id);\n                 if let Some(closure_arg) = closure_body.params.get(0);\n                 then {\n                     if let hir::PatKind::Ref(..) = closure_arg.pat.kind {\n                         Some(search_snippet.replacen('&', \"\", 1))\n-                    } else if let PatKind::Binding(_, _, ident, _) = strip_pat_refs(&closure_arg.pat).kind {\n+                    } else if let PatKind::Binding(_, _, ident, _) = strip_pat_refs(closure_arg.pat).kind {\n                         let name = &*ident.name.as_str();\n                         Some(search_snippet.replace(&format!(\"*{}\", name), name))\n                     } else {\n@@ -54,38 +56,34 @@ pub(super) fn check<'tcx>(\n                 }\n             };\n             // add note if not multi-line\n-            match option_check_method {\n-                \"is_some\" => {\n-                    span_lint_and_sugg(\n-                        cx,\n-                        SEARCH_IS_SOME,\n-                        method_span.with_hi(expr.span.hi()),\n-                        &msg,\n-                        \"use `any()` instead\",\n-                        format!(\n-                            \"any({})\",\n-                            any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n-                        ),\n-                        Applicability::MachineApplicable,\n-                    );\n-                },\n-                \"is_none\" => {\n-                    let iter = snippet(cx, search_args[0].span, \"..\");\n-                    span_lint_and_sugg(\n-                        cx,\n-                        SEARCH_IS_SOME,\n-                        expr.span,\n-                        &msg,\n-                        \"use `!_.any()` instead\",\n-                        format!(\n-                            \"!{}.any({})\",\n-                            iter,\n-                            any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n-                        ),\n-                        Applicability::MachineApplicable,\n-                    );\n-                },\n-                _ => (),\n+            if is_some {\n+                span_lint_and_sugg(\n+                    cx,\n+                    SEARCH_IS_SOME,\n+                    method_span.with_hi(expr.span.hi()),\n+                    &msg,\n+                    \"use `any()` instead\",\n+                    format!(\n+                        \"any({})\",\n+                        any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                let iter = snippet(cx, search_recv.span, \"..\");\n+                span_lint_and_sugg(\n+                    cx,\n+                    SEARCH_IS_SOME,\n+                    expr.span,\n+                    &msg,\n+                    \"use `!_.any()` instead\",\n+                    format!(\n+                        \"!{}.any({})\",\n+                        iter,\n+                        any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n             }\n         } else {\n             let hint = format!(\n@@ -110,14 +108,14 @@ pub(super) fn check<'tcx>(\n             }\n         };\n         if_chain! {\n-            if is_string_or_str_slice(&search_args[0]);\n-            if is_string_or_str_slice(&search_args[1]);\n+            if is_string_or_str_slice(search_recv);\n+            if is_string_or_str_slice(search_arg);\n             then {\n                 let msg = format!(\"called `{}()` after calling `find()` on a string\", option_check_method);\n                 match option_check_method {\n                     \"is_some\" => {\n                         let mut applicability = Applicability::MachineApplicable;\n-                        let find_arg = snippet_with_applicability(cx, search_args[1].span, \"..\", &mut applicability);\n+                        let find_arg = snippet_with_applicability(cx, search_arg.span, \"..\", &mut applicability);\n                         span_lint_and_sugg(\n                             cx,\n                             SEARCH_IS_SOME,\n@@ -129,9 +127,9 @@ pub(super) fn check<'tcx>(\n                         );\n                     },\n                     \"is_none\" => {\n-                        let string = snippet(cx, search_args[0].span, \"..\");\n+                        let string = snippet(cx, search_recv.span, \"..\");\n                         let mut applicability = Applicability::MachineApplicable;\n-                        let find_arg = snippet_with_applicability(cx, search_args[1].span, \"..\", &mut applicability);\n+                        let find_arg = snippet_with_applicability(cx, search_arg.span, \"..\", &mut applicability);\n                         span_lint_and_sugg(\n                             cx,\n                             SEARCH_IS_SOME,"}, {"sha": "9f0b6c34ea2efb715d1c1362cf4a503d193534d3", "filename": "clippy_lints/src/methods/skip_while_next.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fskip_while_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fskip_while_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fskip_while_next.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -7,7 +7,7 @@ use rustc_span::sym;\n use super::SKIP_WHILE_NEXT;\n \n /// lint use of `skip_while().next()` for `Iterators`\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, _skip_while_args: &'tcx [hir::Expr<'_>]) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n     // lint if caller of `.skip_while().next()` is an Iterator\n     if is_trait_method(cx, expr, sym::Iterator) {\n         span_lint_and_help("}, {"sha": "6e7890a3080e60a0b99838e13c83a1fe70af04dc", "filename": "clippy_lints/src/methods/string_extend_chars.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -10,12 +10,11 @@ use rustc_span::symbol::sym;\n \n use super::STRING_EXTEND_CHARS;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    let obj_ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n+    let obj_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n     if !is_type_diagnostic_item(cx, obj_ty, sym::string_type) {\n         return;\n     }\n-    let arg = &args[1];\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n         let self_ty = cx.typeck_results().expr_ty(target).peel_refs();\n@@ -36,7 +35,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Exp\n             \"try this\",\n             format!(\n                 \"{}.push_str({}{})\",\n-                snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability),\n+                snippet_with_applicability(cx, recv.span, \"..\", &mut applicability),\n                 ref_str,\n                 snippet_with_applicability(cx, target.span, \"..\", &mut applicability)\n             ),"}, {"sha": "0fd0668c734022b4e4834781c1bdba1128a3b78e", "filename": "clippy_lints/src/methods/suspicious_map.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -8,15 +8,8 @@ use rustc_span::sym;\n \n use super::SUSPICIOUS_MAP;\n \n-pub fn check<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &hir::Expr<'_>,\n-    map_args: &[hir::Expr<'_>],\n-    count_args: &[hir::Expr<'_>],\n-) {\n+pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, count_recv: &hir::Expr<'_>, map_arg: &hir::Expr<'_>) {\n     if_chain! {\n-        if let [count_recv] = count_args;\n-        if let [_, map_arg] = map_args;\n         if is_trait_method(cx, count_recv, sym::Iterator);\n         let closure = expr_or_init(cx, map_arg);\n         if let Some(body_id) = cx.tcx.hir().maybe_body_owned_by(closure.hir_id);"}, {"sha": "0ae65c0c01dba0e06c429fc776362bc9be4e9db6", "filename": "clippy_lints/src/methods/uninit_assumed_init.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -8,18 +8,18 @@ use rustc_middle::ty::{self, Ty};\n use super::UNINIT_ASSUMED_INIT;\n \n /// lint for `MaybeUninit::uninit().assume_init()` (we already have the latter)\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, outer: &hir::Expr<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n     if_chain! {\n-        if let hir::ExprKind::Call(ref callee, ref args) = expr.kind;\n+        if let hir::ExprKind::Call(callee, args) = recv.kind;\n         if args.is_empty();\n         if let hir::ExprKind::Path(ref path) = callee.kind;\n         if match_qpath(path, &paths::MEM_MAYBEUNINIT_UNINIT);\n-        if !is_maybe_uninit_ty_valid(cx, cx.typeck_results().expr_ty_adjusted(outer));\n+        if !is_maybe_uninit_ty_valid(cx, cx.typeck_results().expr_ty_adjusted(expr));\n         then {\n             span_lint(\n                 cx,\n                 UNINIT_ASSUMED_INIT,\n-                outer.span,\n+                expr.span,\n                 \"this call for this type may be undefined behavior\"\n             );\n         }\n@@ -28,9 +28,9 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, outer: &hir::Exp\n \n fn is_maybe_uninit_ty_valid(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     match ty.kind() {\n-        ty::Array(ref component, _) => is_maybe_uninit_ty_valid(cx, component),\n-        ty::Tuple(ref types) => types.types().all(|ty| is_maybe_uninit_ty_valid(cx, ty)),\n-        ty::Adt(ref adt, _) => match_def_path(cx, adt.did, &paths::MEM_MAYBEUNINIT),\n+        ty::Array(component, _) => is_maybe_uninit_ty_valid(cx, component),\n+        ty::Tuple(types) => types.types().all(|ty| is_maybe_uninit_ty_valid(cx, ty)),\n+        ty::Adt(adt, _) => match_def_path(cx, adt.did, &paths::MEM_MAYBEUNINIT),\n         _ => false,\n     }\n }"}, {"sha": "0f28bfdf09e89c3be43a26fe34925201a966b03c", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::usage::mutated_variables;\n use clippy_utils::{is_trait_method, match_qpath, path_to_local_id, paths};\n-use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_lint::LateContext;\n@@ -10,20 +9,20 @@ use rustc_span::sym;\n \n use super::UNNECESSARY_FILTER_MAP;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n     if !is_trait_method(cx, expr, sym::Iterator) {\n         return;\n     }\n \n-    if let hir::ExprKind::Closure(_, _, body_id, ..) = args[1].kind {\n+    if let hir::ExprKind::Closure(_, _, body_id, ..) = arg.kind {\n         let body = cx.tcx.hir().body(body_id);\n         let arg_id = body.params[0].pat.hir_id;\n         let mutates_arg =\n             mutated_variables(&body.value, cx).map_or(true, |used_mutably| used_mutably.contains(&arg_id));\n \n-        let (mut found_mapping, mut found_filtering) = check_expression(&cx, arg_id, &body.value);\n+        let (mut found_mapping, mut found_filtering) = check_expression(cx, arg_id, &body.value);\n \n-        let mut return_visitor = ReturnVisitor::new(&cx, arg_id);\n+        let mut return_visitor = ReturnVisitor::new(cx, arg_id);\n         return_visitor.visit_expr(&body.value);\n         found_mapping |= return_visitor.found_mapping;\n         found_filtering |= return_visitor.found_filtering;\n@@ -53,38 +52,35 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Exp\n // returns (found_mapping, found_filtering)\n fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tcx hir::Expr<'_>) -> (bool, bool) {\n     match &expr.kind {\n-        hir::ExprKind::Call(ref func, ref args) => {\n-            if_chain! {\n-                if let hir::ExprKind::Path(ref path) = func.kind;\n-                then {\n-                    if match_qpath(path, &paths::OPTION_SOME) {\n-                        if path_to_local_id(&args[0], arg_id) {\n-                            return (false, false)\n-                        }\n-                        return (true, false);\n+        hir::ExprKind::Call(func, args) => {\n+            if let hir::ExprKind::Path(ref path) = func.kind {\n+                if match_qpath(path, &paths::OPTION_SOME) {\n+                    if path_to_local_id(&args[0], arg_id) {\n+                        return (false, false);\n                     }\n-                    // We don't know. It might do anything.\n-                    return (true, true);\n+                    return (true, false);\n                 }\n+                // We don't know. It might do anything.\n+                return (true, true);\n             }\n             (true, true)\n         },\n-        hir::ExprKind::Block(ref block, _) => block\n+        hir::ExprKind::Block(block, _) => block\n             .expr\n             .as_ref()\n-            .map_or((false, false), |expr| check_expression(cx, arg_id, &expr)),\n+            .map_or((false, false), |expr| check_expression(cx, arg_id, expr)),\n         hir::ExprKind::Match(_, arms, _) => {\n             let mut found_mapping = false;\n             let mut found_filtering = false;\n             for arm in *arms {\n-                let (m, f) = check_expression(cx, arg_id, &arm.body);\n+                let (m, f) = check_expression(cx, arg_id, arm.body);\n                 found_mapping |= m;\n                 found_filtering |= f;\n             }\n             (found_mapping, found_filtering)\n         },\n         // There must be an else_arm or there will be a type error\n-        hir::ExprKind::If(_, ref if_arm, Some(ref else_arm)) => {\n+        hir::ExprKind::If(_, if_arm, Some(else_arm)) => {\n             let if_check = check_expression(cx, arg_id, if_arm);\n             let else_check = check_expression(cx, arg_id, else_arm);\n             (if_check.0 | else_check.0, if_check.1 | else_check.1)"}, {"sha": "75517c48a21c90efdcf80bed24239cf6cf14830d", "filename": "clippy_lints/src/methods/unnecessary_fold.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -11,30 +11,36 @@ use rustc_span::{source_map::Span, sym};\n \n use super::UNNECESSARY_FOLD;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, fold_args: &[hir::Expr<'_>], fold_span: Span) {\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    init: &hir::Expr<'_>,\n+    acc: &hir::Expr<'_>,\n+    fold_span: Span,\n+) {\n     fn check_fold_with_op(\n         cx: &LateContext<'_>,\n         expr: &hir::Expr<'_>,\n-        fold_args: &[hir::Expr<'_>],\n+        acc: &hir::Expr<'_>,\n         fold_span: Span,\n         op: hir::BinOpKind,\n         replacement_method_name: &str,\n         replacement_has_args: bool,\n     ) {\n         if_chain! {\n             // Extract the body of the closure passed to fold\n-            if let hir::ExprKind::Closure(_, _, body_id, _, _) = fold_args[2].kind;\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = acc.kind;\n             let closure_body = cx.tcx.hir().body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);\n \n             // Check if the closure body is of the form `acc <op> some_expr(x)`\n-            if let hir::ExprKind::Binary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.kind;\n+            if let hir::ExprKind::Binary(ref bin_op, left_expr, right_expr) = closure_expr.kind;\n             if bin_op.node == op;\n \n             // Extract the names of the two arguments to the closure\n             if let [param_a, param_b] = closure_body.params;\n-            if let PatKind::Binding(_, first_arg_id, ..) = strip_pat_refs(&param_a.pat).kind;\n-            if let PatKind::Binding(_, second_arg_id, second_arg_ident, _) = strip_pat_refs(&param_b.pat).kind;\n+            if let PatKind::Binding(_, first_arg_id, ..) = strip_pat_refs(param_a.pat).kind;\n+            if let PatKind::Binding(_, second_arg_id, second_arg_ident, _) = strip_pat_refs(param_b.pat).kind;\n \n             if path_to_local_id(left_expr, first_arg_id);\n             if replacement_has_args || path_to_local_id(right_expr, second_arg_id);\n@@ -74,25 +80,14 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, fold_args: &[hir\n         return;\n     }\n \n-    assert!(\n-        fold_args.len() == 3,\n-        \"Expected fold_args to have three entries - the receiver, the initial value and the closure\"\n-    );\n-\n     // Check if the first argument to .fold is a suitable literal\n-    if let hir::ExprKind::Lit(ref lit) = fold_args[1].kind {\n+    if let hir::ExprKind::Lit(ref lit) = init.kind {\n         match lit.node {\n-            ast::LitKind::Bool(false) => {\n-                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Or, \"any\", true)\n-            },\n-            ast::LitKind::Bool(true) => {\n-                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::And, \"all\", true)\n-            },\n-            ast::LitKind::Int(0, _) => {\n-                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Add, \"sum\", false)\n-            },\n+            ast::LitKind::Bool(false) => check_fold_with_op(cx, expr, acc, fold_span, hir::BinOpKind::Or, \"any\", true),\n+            ast::LitKind::Bool(true) => check_fold_with_op(cx, expr, acc, fold_span, hir::BinOpKind::And, \"all\", true),\n+            ast::LitKind::Int(0, _) => check_fold_with_op(cx, expr, acc, fold_span, hir::BinOpKind::Add, \"sum\", false),\n             ast::LitKind::Int(1, _) => {\n-                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Mul, \"product\", false)\n+                check_fold_with_op(cx, expr, acc, fold_span, hir::BinOpKind::Mul, \"product\", false)\n             },\n             _ => (),\n         }"}, {"sha": "b7380883a5eecad1574296e8d1b222d590a866fa", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -14,14 +14,15 @@ use super::UNNECESSARY_LAZY_EVALUATIONS;\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n-    args: &'tcx [hir::Expr<'_>],\n+    recv: &'tcx hir::Expr<'_>,\n+    arg: &'tcx hir::Expr<'_>,\n     simplify_using: &str,\n ) {\n-    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym::option_type);\n-    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym::result_type);\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::result_type);\n \n     if is_option || is_result {\n-        if let hir::ExprKind::Closure(_, _, eid, _, _) = args[1].kind {\n+        if let hir::ExprKind::Closure(_, _, eid, _, _) = arg.kind {\n             let body = cx.tcx.hir().body(eid);\n             let body_expr = &body.value;\n \n@@ -55,7 +56,7 @@ pub(super) fn check<'tcx>(\n                     &format!(\"use `{}` instead\", simplify_using),\n                     format!(\n                         \"{0}.{1}({2})\",\n-                        snippet(cx, args[0].span, \"..\"),\n+                        snippet(cx, recv.span, \"..\"),\n                         simplify_using,\n                         snippet(cx, body_expr.span, \"..\"),\n                     ),"}, {"sha": "7fd1948594d707904de39347a38671d6ecb0b2e9", "filename": "clippy_lints/src/methods/unwrap_used.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -7,8 +7,8 @@ use rustc_span::sym;\n use super::UNWRAP_USED;\n \n /// lint use of `unwrap()` for `Option`s and `Result`s\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n-    let obj_ty = cx.typeck_results().expr_ty(&unwrap_args[0]).peel_refs();\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n+    let obj_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym::option_type) {\n         Some((UNWRAP_USED, \"an Option\", \"None\"))"}, {"sha": "e0b1de68b37d359b85c8e7d41eed620338b0c54f", "filename": "clippy_lints/src/methods/useless_asref.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -10,12 +10,11 @@ use rustc_lint::LateContext;\n use super::USELESS_ASREF;\n \n /// Checks for the `USELESS_ASREF` lint.\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_ref_args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, recvr: &hir::Expr<'_>) {\n     // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n     // check if the call is to the actual `AsRef` or `AsMut` trait\n     if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n         // check if the type after `as_ref` or `as_mut` is the same as before\n-        let recvr = &as_ref_args[0];\n         let rcv_ty = cx.typeck_results().expr_ty(recvr);\n         let res_ty = cx.typeck_results().expr_ty(expr);\n         let (base_res_ty, res_depth) = walk_ptrs_ty_depth(res_ty);"}, {"sha": "f6bf37e08b96614007217d910fe0778d3c8ffa6b", "filename": "clippy_lints/src/methods/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Futils.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -26,7 +26,7 @@ pub(super) fn derefs_to_slice<'tcx>(\n         }\n     }\n \n-    if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind {\n+    if let hir::ExprKind::MethodCall(path, _, args, _) = expr.kind {\n         if path.ident.name == sym::iter && may_slice(cx, cx.typeck_results().expr_ty(&args[0])) {\n             Some(&args[0])\n         } else {"}, {"sha": "1e0de249a91f1792c8f5c132ad9cd3f710f8a2ee", "filename": "clippy_lints/src/methods/wrong_self_convention.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -21,8 +21,10 @@ const CONVENTIONS: [(&[Convention], &[SelfKind]); 9] = [\n \n     // Conversion using `to_` can use borrowed (non-Copy types) or owned (Copy types).\n     // Source: https://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv\n-    (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\"), Convention::IsSelfTypeCopy(false), Convention::ImplementsTrait(false)], &[SelfKind::Ref]),\n-    (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\"), Convention::IsSelfTypeCopy(true), Convention::ImplementsTrait(false)], &[SelfKind::Value]),\n+    (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\"), Convention::IsSelfTypeCopy(false), \n+    Convention::IsTraitItem(false)], &[SelfKind::Ref]),\n+    (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\"), Convention::IsSelfTypeCopy(true), \n+    Convention::IsTraitItem(false), Convention::ImplementsTrait(false)], &[SelfKind::Value]),\n ];\n \n enum Convention {\n@@ -32,18 +34,27 @@ enum Convention {\n     NotEndsWith(&'static str),\n     IsSelfTypeCopy(bool),\n     ImplementsTrait(bool),\n+    IsTraitItem(bool),\n }\n \n impl Convention {\n     #[must_use]\n-    fn check<'tcx>(&self, cx: &LateContext<'tcx>, self_ty: &'tcx TyS<'tcx>, other: &str, is_trait_def: bool) -> bool {\n+    fn check<'tcx>(\n+        &self,\n+        cx: &LateContext<'tcx>,\n+        self_ty: &'tcx TyS<'tcx>,\n+        other: &str,\n+        implements_trait: bool,\n+        is_trait_item: bool,\n+    ) -> bool {\n         match *self {\n             Self::Eq(this) => this == other,\n             Self::StartsWith(this) => other.starts_with(this) && this != other,\n             Self::EndsWith(this) => other.ends_with(this) && this != other,\n-            Self::NotEndsWith(this) => !Self::EndsWith(this).check(cx, self_ty, other, is_trait_def),\n+            Self::NotEndsWith(this) => !Self::EndsWith(this).check(cx, self_ty, other, implements_trait, is_trait_item),\n             Self::IsSelfTypeCopy(is_true) => is_true == is_copy(cx, self_ty),\n-            Self::ImplementsTrait(is_true) => is_true == is_trait_def,\n+            Self::ImplementsTrait(is_true) => is_true == implements_trait,\n+            Self::IsTraitItem(is_true) => is_true == is_trait_item,\n         }\n     }\n }\n@@ -60,19 +71,25 @@ impl fmt::Display for Convention {\n             },\n             Self::ImplementsTrait(is_true) => {\n                 let (negation, s_suffix) = if is_true { (\"\", \"s\") } else { (\" does not\", \"\") };\n-                format!(\"Method{} implement{} a trait\", negation, s_suffix).fmt(f)\n+                format!(\"method{} implement{} a trait\", negation, s_suffix).fmt(f)\n+            },\n+            Self::IsTraitItem(is_true) => {\n+                let suffix = if is_true { \" is\" } else { \" is not\" };\n+                format!(\"method{} a trait item\", suffix).fmt(f)\n             },\n         }\n     }\n }\n \n+#[allow(clippy::too_many_arguments)]\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     item_name: &str,\n     is_pub: bool,\n     self_ty: &'tcx TyS<'tcx>,\n     first_arg_ty: &'tcx TyS<'tcx>,\n     first_arg_span: Span,\n+    implements_trait: bool,\n     is_trait_item: bool,\n ) {\n     let lint = if is_pub {\n@@ -83,7 +100,7 @@ pub(super) fn check<'tcx>(\n     if let Some((conventions, self_kinds)) = &CONVENTIONS.iter().find(|(convs, _)| {\n         convs\n             .iter()\n-            .all(|conv| conv.check(cx, self_ty, item_name, is_trait_item))\n+            .all(|conv| conv.check(cx, self_ty, item_name, implements_trait, is_trait_item))\n     }) {\n         if !self_kinds.iter().any(|k| k.matches(cx, self_ty, first_arg_ty)) {\n             let suggestion = {\n@@ -99,6 +116,7 @@ pub(super) fn check<'tcx>(\n                         .filter_map(|conv| {\n                             if (cut_ends_with_conv && matches!(conv, Convention::NotEndsWith(_)))\n                                 || matches!(conv, Convention::ImplementsTrait(_))\n+                                || matches!(conv, Convention::IsTraitItem(_))\n                             {\n                                 None\n                             } else {"}, {"sha": "866cf616679c29a0d5adf02572ca971f43fbb41d", "filename": "clippy_lints/src/methods/zst_offset.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -6,10 +6,9 @@ use rustc_middle::ty;\n \n use super::ZST_OFFSET;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n     if_chain! {\n-        if args.len() == 2;\n-        if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.typeck_results().expr_ty(&args[0]).kind();\n+        if let ty::RawPtr(ty::TypeAndMut { ty, .. }) = cx.typeck_results().expr_ty(recv).kind();\n         if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty));\n         if layout.is_zst();\n         then {"}, {"sha": "45948f4d926bc6efe292203c932c2adfda9d83ca", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -67,7 +67,7 @@ enum MinMax {\n \n fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n     match expr.kind {\n-        ExprKind::Call(ref path, ref args) => {\n+        ExprKind::Call(path, args) => {\n             if let ExprKind::Path(ref qpath) = path.kind {\n                 cx.typeck_results()\n                     .qpath_res(qpath, path.hir_id)\n@@ -85,7 +85,7 @@ fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Cons\n                 None\n             }\n         },\n-        ExprKind::MethodCall(ref path, _, ref args, _) => {\n+        ExprKind::MethodCall(path, _, args, _) => {\n             if_chain! {\n                 if let [obj, _] = args;\n                 if cx.typeck_results().expr_ty(obj).is_floating_point() || match_trait_method(cx, expr, &paths::ORD);"}, {"sha": "afced5a5ce58a246ad38591d9a74f3e326fc4867", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 61, "deletions": 65, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -304,55 +304,54 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         if_chain! {\n             if !in_external_macro(cx.tcx.sess, stmt.span);\n-            if let StmtKind::Local(ref local) = stmt.kind;\n+            if let StmtKind::Local(local) = stmt.kind;\n             if let PatKind::Binding(an, .., name, None) = local.pat.kind;\n-            if let Some(ref init) = local.init;\n+            if let Some(init) = local.init;\n             if !higher::is_from_for_desugar(local);\n+            if an == BindingAnnotation::Ref || an == BindingAnnotation::RefMut;\n             then {\n-                if an == BindingAnnotation::Ref || an == BindingAnnotation::RefMut {\n-                    // use the macro callsite when the init span (but not the whole local span)\n-                    // comes from an expansion like `vec![1, 2, 3]` in `let ref _ = vec![1, 2, 3];`\n-                    let sugg_init = if init.span.from_expansion() && !local.span.from_expansion() {\n-                        Sugg::hir_with_macro_callsite(cx, init, \"..\")\n-                    } else {\n-                        Sugg::hir(cx, init, \"..\")\n-                    };\n-                    let (mutopt, initref) = if an == BindingAnnotation::RefMut {\n-                        (\"mut \", sugg_init.mut_addr())\n-                    } else {\n-                        (\"\", sugg_init.addr())\n-                    };\n-                    let tyopt = if let Some(ref ty) = local.ty {\n-                        format!(\": &{mutopt}{ty}\", mutopt=mutopt, ty=snippet(cx, ty.span, \"..\"))\n-                    } else {\n-                        String::new()\n-                    };\n-                    span_lint_hir_and_then(\n-                        cx,\n-                        TOPLEVEL_REF_ARG,\n-                        init.hir_id,\n-                        local.pat.span,\n-                        \"`ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\",\n-                        |diag| {\n-                            diag.span_suggestion(\n-                                stmt.span,\n-                                \"try\",\n-                                format!(\n-                                    \"let {name}{tyopt} = {initref};\",\n-                                    name=snippet(cx, name.span, \"..\"),\n-                                    tyopt=tyopt,\n-                                    initref=initref,\n-                                ),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    );\n-                }\n+                // use the macro callsite when the init span (but not the whole local span)\n+                // comes from an expansion like `vec![1, 2, 3]` in `let ref _ = vec![1, 2, 3];`\n+                let sugg_init = if init.span.from_expansion() && !local.span.from_expansion() {\n+                    Sugg::hir_with_macro_callsite(cx, init, \"..\")\n+                } else {\n+                    Sugg::hir(cx, init, \"..\")\n+                };\n+                let (mutopt, initref) = if an == BindingAnnotation::RefMut {\n+                    (\"mut \", sugg_init.mut_addr())\n+                } else {\n+                    (\"\", sugg_init.addr())\n+                };\n+                let tyopt = if let Some(ty) = local.ty {\n+                    format!(\": &{mutopt}{ty}\", mutopt=mutopt, ty=snippet(cx, ty.span, \"..\"))\n+                } else {\n+                    String::new()\n+                };\n+                span_lint_hir_and_then(\n+                    cx,\n+                    TOPLEVEL_REF_ARG,\n+                    init.hir_id,\n+                    local.pat.span,\n+                    \"`ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\",\n+                    |diag| {\n+                        diag.span_suggestion(\n+                            stmt.span,\n+                            \"try\",\n+                            format!(\n+                                \"let {name}{tyopt} = {initref};\",\n+                                name=snippet(cx, name.span, \"..\"),\n+                                tyopt=tyopt,\n+                                initref=initref,\n+                            ),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                );\n             }\n         };\n         if_chain! {\n-            if let StmtKind::Semi(ref expr) = stmt.kind;\n-            if let ExprKind::Binary(ref binop, ref a, ref b) = expr.kind;\n+            if let StmtKind::Semi(expr) = stmt.kind;\n+            if let ExprKind::Binary(ref binop, a, b) = expr.kind;\n             if binop.node == BinOpKind::And || binop.node == BinOpKind::Or;\n             if let Some(sugg) = Sugg::hir_opt(cx, a);\n             then {\n@@ -379,11 +378,11 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         match expr.kind {\n-            ExprKind::Cast(ref e, ref ty) => {\n+            ExprKind::Cast(e, ty) => {\n                 check_cast(cx, expr.span, e, ty);\n                 return;\n             },\n-            ExprKind::Binary(ref cmp, ref left, ref right) => {\n+            ExprKind::Binary(ref cmp, left, right) => {\n                 check_binary(cx, expr, cmp, left, right);\n                 return;\n             },\n@@ -462,21 +461,18 @@ fn check_nan(cx: &LateContext<'_>, expr: &Expr<'_>, cmp_expr: &Expr<'_>) {\n     if_chain! {\n         if !in_constant(cx, cmp_expr.hir_id);\n         if let Some((value, _)) = constant(cx, cx.typeck_results(), expr);\n+        if match value {\n+            Constant::F32(num) => num.is_nan(),\n+            Constant::F64(num) => num.is_nan(),\n+            _ => false,\n+        };\n         then {\n-            let needs_lint = match value {\n-                Constant::F32(num) => num.is_nan(),\n-                Constant::F64(num) => num.is_nan(),\n-                _ => false,\n-            };\n-\n-            if needs_lint {\n-                span_lint(\n-                    cx,\n-                    CMP_NAN,\n-                    cmp_expr.span,\n-                    \"doomed comparison with `NAN`, use `{f32,f64}::is_nan()` instead\",\n-                );\n-            }\n+            span_lint(\n+                cx,\n+                CMP_NAN,\n+                cmp_expr.span,\n+                \"doomed comparison with `NAN`, use `{f32,f64}::is_nan()` instead\",\n+            );\n         }\n     }\n }\n@@ -505,12 +501,12 @@ fn is_allowed<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n // Return true if `expr` is the result of `signum()` invoked on a float value.\n fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     // The negation of a signum is still a signum\n-    if let ExprKind::Unary(UnOp::Neg, ref child_expr) = expr.kind {\n-        return is_signum(cx, &child_expr);\n+    if let ExprKind::Unary(UnOp::Neg, child_expr) = expr.kind {\n+        return is_signum(cx, child_expr);\n     }\n \n     if_chain! {\n-        if let ExprKind::MethodCall(ref method_name, _, ref expressions, _) = expr.kind;\n+        if let ExprKind::MethodCall(method_name, _, expressions, _) = expr.kind;\n         if sym!(signum) == method_name.ident.name;\n         // Check that the receiver of the signum() is a float (expressions[0] is the receiver of\n         // the method call)\n@@ -556,7 +552,7 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n     }\n \n     let (arg_ty, snip) = match expr.kind {\n-        ExprKind::MethodCall(.., ref args, _) if args.len() == 1 => {\n+        ExprKind::MethodCall(.., args, _) if args.len() == 1 => {\n             if_chain!(\n                 if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n                 if is_diagnostic_assoc_item(cx, expr_def_id, sym::ToString)\n@@ -568,7 +564,7 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n                 }\n             )\n         },\n-        ExprKind::Call(ref path, ref v) if v.len() == 1 => {\n+        ExprKind::Call(path, v) if v.len() == 1 => {\n             if let ExprKind::Path(ref path) = path.kind {\n                 if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n                     (cx.typeck_results().expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n@@ -653,7 +649,7 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n /// of what it means for an expression to be \"used\".\n fn is_used(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     get_parent_expr(cx, expr).map_or(true, |parent| match parent.kind {\n-        ExprKind::Assign(_, ref rhs, _) | ExprKind::AssignOp(_, _, ref rhs) => SpanlessEq::new(cx).eq_expr(rhs, expr),\n+        ExprKind::Assign(_, rhs, _) | ExprKind::AssignOp(_, _, rhs) => SpanlessEq::new(cx).eq_expr(rhs, expr),\n         _ => is_used(cx, parent),\n     })\n }"}, {"sha": "0dc02431ad5383141ebfbe54c140330f2d1f9c36", "filename": "clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -138,7 +138,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n \n         let mir = cx.tcx.optimized_mir(def_id);\n \n-        if let Err((span, err)) = is_min_const_fn(cx.tcx, &mir) {\n+        if let Err((span, err)) = is_min_const_fn(cx.tcx, mir) {\n             if rustc_mir::const_eval::is_min_const_fn(cx.tcx, def_id.to_def_id()) {\n                 cx.tcx.sess.span_err(span, &err);\n             }"}, {"sha": "dfab3e8a93112b447bed16a486dce483a2031333", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -5,10 +5,10 @@\n // [`missing_doc`]: https://github.com/rust-lang/rust/blob/cf9cf7c923eb01146971429044f216a3ca905e06/compiler/rustc_lint/src/builtin.rs#L415\n //\n \n+use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint;\n use if_chain::if_chain;\n use rustc_ast::ast::{self, MetaItem, MetaItemKind};\n-use rustc_ast::attr;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty;\n@@ -93,9 +93,9 @@ impl MissingDoc {\n             return;\n         }\n \n-        let has_doc = attrs\n-            .iter()\n-            .any(|a| a.is_doc_comment() || a.doc_str().is_some() || a.value_str().is_some() || Self::has_include(a.meta()));\n+        let has_doc = attrs.iter().any(|a| {\n+            a.is_doc_comment() || a.doc_str().is_some() || a.value_str().is_some() || Self::has_include(a.meta())\n+        });\n         if !has_doc {\n             span_lint(\n                 cx,\n@@ -111,14 +111,7 @@ impl_lint_pass!(MissingDoc => [MISSING_DOCS_IN_PRIVATE_ITEMS]);\n \n impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     fn enter_lint_attrs(&mut self, _: &LateContext<'tcx>, attrs: &'tcx [ast::Attribute]) {\n-        let doc_hidden = self.doc_hidden()\n-            || attrs.iter().any(|attr| {\n-                attr.has_name(sym::doc)\n-                    && match attr.meta_item_list() {\n-                        None => false,\n-                        Some(l) => attr::list_contains_name(&l[..], sym::hidden),\n-                    }\n-            });\n+        let doc_hidden = self.doc_hidden() || is_doc_hidden(attrs);\n         self.doc_hidden_stack.push(doc_hidden);\n     }\n "}, {"sha": "041fe64a1a9785a77e30d1f68dc82505dd92d2cf", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n                 let attrs = cx.tcx.hir().attrs(it.hir_id());\n                 check_missing_inline_attrs(cx, attrs, it.span, desc);\n             },\n-            hir::ItemKind::Trait(ref _is_auto, ref _unsafe, ref _generics, ref _bounds, trait_items) => {\n+            hir::ItemKind::Trait(ref _is_auto, ref _unsafe, ref _generics, _bounds, trait_items) => {\n                 // note: we need to check if the trait is exported so we can't use\n                 // `LateLintPass::check_trait_item` here.\n                 for tit in trait_items {"}, {"sha": "1786d5805d78b342dfa1b5c693d76b8db1aeae62", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -59,21 +59,21 @@ declare_lint_pass!(MutableKeyType => [ MUTABLE_KEY_TYPE ]);\n impl<'tcx> LateLintPass<'tcx> for MutableKeyType {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         if let hir::ItemKind::Fn(ref sig, ..) = item.kind {\n-            check_sig(cx, item.hir_id(), &sig.decl);\n+            check_sig(cx, item.hir_id(), sig.decl);\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'tcx>) {\n         if let hir::ImplItemKind::Fn(ref sig, ..) = item.kind {\n             if trait_ref_of_method(cx, item.hir_id()).is_none() {\n-                check_sig(cx, item.hir_id(), &sig.decl);\n+                check_sig(cx, item.hir_id(), sig.decl);\n             }\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'tcx>) {\n         if let hir::TraitItemKind::Fn(ref sig, ..) = item.kind {\n-            check_sig(cx, item.hir_id(), &sig.decl);\n+            check_sig(cx, item.hir_id(), sig.decl);\n         }\n     }\n "}, {"sha": "4b9c51d0c16ccbb3bad95282c25eded9feb57fd6", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n             // Let's ignore the generated code.\n             intravisit::walk_expr(self, arg);\n             intravisit::walk_expr(self, body);\n-        } else if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, ref e) = expr.kind {\n+        } else if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, e) = expr.kind {\n             if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, _) = e.kind {\n                 span_lint(\n                     self.cx,\n@@ -85,7 +85,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n         if let hir::TyKind::Rptr(\n             _,\n             hir::MutTy {\n-                ty: ref pty,\n+                ty: pty,\n                 mutbl: hir::Mutability::Mut,\n             },\n         ) = ty.kind"}, {"sha": "cea6fce119561225d5e7dab1d527aff3f089fff6", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -33,7 +33,7 @@ declare_lint_pass!(UnnecessaryMutPassed => [UNNECESSARY_MUT_PASSED]);\n impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         match e.kind {\n-            ExprKind::Call(ref fn_expr, ref arguments) => {\n+            ExprKind::Call(fn_expr, arguments) => {\n                 if let ExprKind::Path(ref path) = fn_expr.kind {\n                     check_arguments(\n                         cx,\n@@ -44,7 +44,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryMutPassed {\n                     );\n                 }\n             },\n-            ExprKind::MethodCall(ref path, _, ref arguments, _) => {\n+            ExprKind::MethodCall(path, _, arguments, _) => {\n                 let def_id = cx.typeck_results().type_dependent_def_id(e.hir_id).unwrap();\n                 let substs = cx.typeck_results().node_substs(e.hir_id);\n                 let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);"}, {"sha": "96a58d1410f226b01058fd56dc9ecbbb6ca9bba2", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -71,7 +71,7 @@ declare_lint_pass!(NeedlessBool => [NEEDLESS_BOOL]);\n impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         use self::Expression::{Bool, RetBool};\n-        if let ExprKind::If(ref pred, ref then_block, Some(ref else_expr)) = e.kind {\n+        if let ExprKind::If(pred, then_block, Some(else_expr)) = e.kind {\n             let reduce = |ret, not| {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let snip = Sugg::hir_with_applicability(cx, pred, \"<predicate>\", &mut applicability);\n@@ -81,7 +81,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n                     snip = snip.make_return();\n                 }\n \n-                if parent_node_is_if_expr(&e, &cx) {\n+                if parent_node_is_if_expr(e, cx) {\n                     snip = snip.blockify()\n                 }\n \n@@ -95,7 +95,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n                     applicability,\n                 );\n             };\n-            if let ExprKind::Block(ref then_block, _) = then_block.kind {\n+            if let ExprKind::Block(then_block, _) = then_block.kind {\n                 match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n                     (RetBool(true), RetBool(true)) | (Bool(true), Bool(true)) => {\n                         span_lint(\n@@ -225,7 +225,7 @@ fn check_comparison<'a, 'tcx>(\n ) {\n     use self::Expression::{Bool, Other};\n \n-    if let ExprKind::Binary(op, ref left_side, ref right_side) = e.kind {\n+    if let ExprKind::Binary(op, left_side, right_side) = e.kind {\n         let (l_ty, r_ty) = (\n             cx.typeck_results().expr_ty(left_side),\n             cx.typeck_results().expr_ty(right_side),\n@@ -237,7 +237,7 @@ fn check_comparison<'a, 'tcx>(\n             let mut applicability = Applicability::MachineApplicable;\n \n             if let BinOpKind::Eq = op.node {\n-                let expression_info = one_side_is_unary_not(&left_side, &right_side);\n+                let expression_info = one_side_is_unary_not(left_side, right_side);\n                 if expression_info.one_side_is_unary_not {\n                     span_lint_and_sugg(\n                         cx,\n@@ -324,9 +324,9 @@ fn fetch_bool_block(block: &Block<'_>) -> Expression {\n     match (&*block.stmts, block.expr.as_ref()) {\n         (&[], Some(e)) => fetch_bool_expr(&**e),\n         (&[ref e], None) => {\n-            if let StmtKind::Semi(ref e) = e.kind {\n+            if let StmtKind::Semi(e) = e.kind {\n                 if let ExprKind::Ret(_) = e.kind {\n-                    fetch_bool_expr(&**e)\n+                    fetch_bool_expr(e)\n                 } else {\n                     Expression::Other\n                 }\n@@ -340,15 +340,15 @@ fn fetch_bool_block(block: &Block<'_>) -> Expression {\n \n fn fetch_bool_expr(expr: &Expr<'_>) -> Expression {\n     match expr.kind {\n-        ExprKind::Block(ref block, _) => fetch_bool_block(block),\n+        ExprKind::Block(block, _) => fetch_bool_block(block),\n         ExprKind::Lit(ref lit_ptr) => {\n             if let LitKind::Bool(value) = lit_ptr.node {\n                 Expression::Bool(value)\n             } else {\n                 Expression::Other\n             }\n         },\n-        ExprKind::Ret(Some(ref expr)) => match fetch_bool_expr(expr) {\n+        ExprKind::Ret(Some(expr)) => match fetch_bool_expr(expr) {\n             Expression::Bool(value) => Expression::RetBool(value),\n             _ => Expression::Other,\n         },"}, {"sha": "eef3c16730b133baea1e05f498728e7b3a7bb1ac", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n         if e.span.from_expansion() || self.derived_item.is_some() {\n             return;\n         }\n-        if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, ref inner) = e.kind {\n+        if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = e.kind {\n             if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty(inner).kind() {\n                 for adj3 in cx.typeck_results().expr_adjustments(e).windows(3) {\n                     if let [Adjustment {"}, {"sha": "0e976b130ebf14f6334a6b1c3eca8ad0bcc1261a", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrowedRef {\n \n         if_chain! {\n             // Only lint immutable refs, because `&mut ref T` may be useful.\n-            if let PatKind::Ref(ref sub_pat, Mutability::Not) = pat.kind;\n+            if let PatKind::Ref(sub_pat, Mutability::Not) = pat.kind;\n \n             // Check sub_pat got a `ref` keyword (excluding `ref mut`).\n             if let PatKind::Binding(BindingAnnotation::Ref, .., spanned_name, _) = sub_pat.kind;"}, {"sha": "079b6642d5833c66f242172d32a4c07053d6721a", "filename": "clippy_lints/src/needless_for_each.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_for_each.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,167 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{\n+    intravisit::{walk_expr, NestedVisitorMap, Visitor},\n+    Expr, ExprKind, Stmt, StmtKind,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{source_map::Span, sym, Symbol};\n+\n+use if_chain::if_chain;\n+\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::is_trait_method;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::has_iter_method;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `for_each` that would be more simply written as a\n+    /// `for` loop.\n+    ///\n+    /// **Why is this bad?** `for_each` may be used after applying iterator transformers like\n+    /// `filter` for better readability and performance. It may also be used to fit a simple\n+    /// operation on one line.\n+    /// But when none of these apply, a simple `for` loop is more idiomatic.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let v = vec![0, 1, 2];\n+    /// v.iter().for_each(|elem| {\n+    ///     println!(\"{}\", elem);\n+    /// })\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let v = vec![0, 1, 2];\n+    /// for elem in v.iter() {\n+    ///     println!(\"{}\", elem);\n+    /// }\n+    /// ```\n+    pub NEEDLESS_FOR_EACH,\n+    pedantic,\n+    \"using `for_each` where a `for` loop would be simpler\"\n+}\n+\n+declare_lint_pass!(NeedlessForEach => [NEEDLESS_FOR_EACH]);\n+\n+impl LateLintPass<'_> for NeedlessForEach {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n+        let expr = match stmt.kind {\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr,\n+            _ => return,\n+        };\n+\n+        if_chain! {\n+            // Check the method name is `for_each`.\n+            if let ExprKind::MethodCall(method_name, _, [for_each_recv, for_each_arg], _) = expr.kind;\n+            if method_name.ident.name == Symbol::intern(\"for_each\");\n+            // Check `for_each` is an associated function of `Iterator`.\n+            if is_trait_method(cx, expr, sym::Iterator);\n+            // Checks the receiver of `for_each` is also a method call.\n+            if let ExprKind::MethodCall(_, _, [iter_recv], _) = for_each_recv.kind;\n+            // Skip the lint if the call chain is too long. e.g. `v.field.iter().for_each()` or\n+            // `v.foo().iter().for_each()` must be skipped.\n+            if matches!(\n+                iter_recv.kind,\n+                ExprKind::Array(..) | ExprKind::Call(..) | ExprKind::Path(..)\n+            );\n+            // Checks the type of the `iter` method receiver is NOT a user defined type.\n+            if has_iter_method(cx, cx.typeck_results().expr_ty(iter_recv)).is_some();\n+            // Skip the lint if the body is not block because this is simpler than `for` loop.\n+            // e.g. `v.iter().for_each(f)` is simpler and clearer than using `for` loop.\n+            if let ExprKind::Closure(_, _, body_id, ..) = for_each_arg.kind;\n+            let body = cx.tcx.hir().body(body_id);\n+            if let ExprKind::Block(..) = body.value.kind;\n+            then {\n+                let mut ret_collector = RetCollector::default();\n+                ret_collector.visit_expr(&body.value);\n+\n+                // Skip the lint if `return` is used in `Loop` in order not to suggest using `'label`.\n+                if ret_collector.ret_in_loop {\n+                    return;\n+                }\n+\n+                let (mut applicability, ret_suggs) = if ret_collector.spans.is_empty() {\n+                    (Applicability::MachineApplicable, None)\n+                } else {\n+                    (\n+                        Applicability::MaybeIncorrect,\n+                        Some(\n+                            ret_collector\n+                                .spans\n+                                .into_iter()\n+                                .map(|span| (span, \"continue\".to_string()))\n+                                .collect(),\n+                        ),\n+                    )\n+                };\n+\n+                let sugg = format!(\n+                    \"for {} in {} {}\",\n+                    snippet_with_applicability(cx, body.params[0].pat.span, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, for_each_recv.span, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, body.value.span, \"..\", &mut applicability),\n+                );\n+\n+                span_lint_and_then(cx, NEEDLESS_FOR_EACH, stmt.span, \"needless use of `for_each`\", |diag| {\n+                    diag.span_suggestion(stmt.span, \"try\", sugg, applicability);\n+                    if let Some(ret_suggs) = ret_suggs {\n+                        diag.multipart_suggestion(\"...and replace `return` with `continue`\", ret_suggs, applicability);\n+                    }\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+/// This type plays two roles.\n+/// 1. Collect spans of `return` in the closure body.\n+/// 2. Detect use of `return` in `Loop` in the closure body.\n+///\n+/// NOTE: The functionality of this type is similar to\n+/// [`crate::utilts::visitors::find_all_ret_expressions`], but we can't use\n+/// `find_all_ret_expressions` instead of this type. The reasons are:\n+/// 1. `find_all_ret_expressions` passes the argument of `ExprKind::Ret` to a callback, but what we\n+///    need here is `ExprKind::Ret` itself.\n+/// 2. We can't trace current loop depth with `find_all_ret_expressions`.\n+#[derive(Default)]\n+struct RetCollector {\n+    spans: Vec<Span>,\n+    ret_in_loop: bool,\n+    loop_depth: u16,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for RetCollector {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &Expr<'_>) {\n+        match expr.kind {\n+            ExprKind::Ret(..) => {\n+                if self.loop_depth > 0 && !self.ret_in_loop {\n+                    self.ret_in_loop = true\n+                }\n+\n+                self.spans.push(expr.span)\n+            },\n+\n+            ExprKind::Loop(..) => {\n+                self.loop_depth += 1;\n+                walk_expr(self, expr);\n+                self.loop_depth -= 1;\n+                return;\n+            },\n+\n+            _ => {},\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "780e224129347492b47447beaf512dba264affa5", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -5,10 +5,11 @@ use clippy_utils::ty::{implements_trait, is_copy, is_type_diagnostic_item};\n use clippy_utils::{get_trait_def_id, is_self, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::Attribute;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{BindingAnnotation, Body, FnDecl, GenericArg, HirId, Impl, ItemKind, Node, PatKind, QPath, TyKind};\n+use rustc_hir::{HirIdMap, HirIdSet};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::mir::FakeReadCause;\n@@ -207,7 +208,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                             if is_type_diagnostic_item(cx, ty, sym::vec_type);\n                             if let Some(clone_spans) =\n                                 get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_owned()\")]);\n-                            if let TyKind::Path(QPath::Resolved(_, ref path)) = input.kind;\n+                            if let TyKind::Path(QPath::Resolved(_, path)) = input.kind;\n                             if let Some(elem_ty) = path.segments.iter()\n                                 .find(|seg| seg.ident.name == sym::Vec)\n                                 .and_then(|ps| ps.args.as_ref())\n@@ -310,10 +311,10 @@ fn requires_exact_signature(attrs: &[Attribute]) -> bool {\n \n #[derive(Default)]\n struct MovedVariablesCtxt {\n-    moved_vars: FxHashSet<HirId>,\n+    moved_vars: HirIdSet,\n     /// Spans which need to be prefixed with `*` for dereferencing the\n     /// suggested additional reference.\n-    spans_need_deref: FxHashMap<HirId, FxHashSet<Span>>,\n+    spans_need_deref: HirIdMap<FxHashSet<Span>>,\n }\n \n impl MovedVariablesCtxt {"}, {"sha": "8f325404deb45bffcb0ae58fc1fd91cdd0586276", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -49,7 +49,7 @@ declare_lint_pass!(NeedlessUpdate => [NEEDLESS_UPDATE]);\n \n impl<'tcx> LateLintPass<'tcx> for NeedlessUpdate {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.kind {\n+        if let ExprKind::Struct(_, fields, Some(base)) = expr.kind {\n             let ty = cx.typeck_results().expr_ty(expr);\n             if let ty::Adt(def, _) = ty.kind() {\n                 if fields.len() == def.non_enum_variant().fields.len()"}, {"sha": "0704173a01178cb11a1a478b29f6da6780d84011", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -51,8 +51,8 @@ impl<'tcx> LateLintPass<'tcx> for NoNegCompOpForPartialOrd {\n         if_chain! {\n \n             if !in_external_macro(cx.sess(), expr.span);\n-            if let ExprKind::Unary(UnOp::Not, ref inner) = expr.kind;\n-            if let ExprKind::Binary(ref op, ref left, _) = inner.kind;\n+            if let ExprKind::Unary(UnOp::Not, inner) = expr.kind;\n+            if let ExprKind::Binary(ref op, left, _) = inner.kind;\n             if let BinOpKind::Le | BinOpKind::Ge | BinOpKind::Lt | BinOpKind::Gt = op.node;\n \n             then {"}, {"sha": "34fd012572f4b88ae8bb13ae79d879f6aed80f7c", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -28,12 +28,12 @@ declare_lint_pass!(NegMultiply => [NEG_MULTIPLY]);\n #[allow(clippy::match_same_arms)]\n impl<'tcx> LateLintPass<'tcx> for NegMultiply {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(ref op, ref left, ref right) = e.kind {\n+        if let ExprKind::Binary(ref op, left, right) = e.kind {\n             if BinOpKind::Mul == op.node {\n                 match (&left.kind, &right.kind) {\n                     (&ExprKind::Unary(..), &ExprKind::Unary(..)) => {},\n-                    (&ExprKind::Unary(UnOp::Neg, ref lit), _) => check_mul(cx, e.span, lit, right),\n-                    (_, &ExprKind::Unary(UnOp::Neg, ref lit)) => check_mul(cx, e.span, lit, left),\n+                    (&ExprKind::Unary(UnOp::Neg, lit), _) => check_mul(cx, e.span, lit, right),\n+                    (_, &ExprKind::Unary(UnOp::Neg, lit)) => check_mul(cx, e.span, lit, left),\n                     _ => {},\n                 }\n             }"}, {"sha": "a5f91eb035f97a0a57688ba4df77b5f56fb989b9", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -97,60 +97,60 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                             // impl of `Default`\n                             return;\n                         }\n-                        if sig.decl.inputs.is_empty() && name == sym::new && cx.access_levels.is_reachable(id) {\n+                        if_chain! {\n+                            if sig.decl.inputs.is_empty();\n+                            if name == sym::new;\n+                            if cx.access_levels.is_reachable(id);\n                             let self_def_id = cx.tcx.hir().local_def_id(cx.tcx.hir().get_parent_item(id));\n                             let self_ty = cx.tcx.type_of(self_def_id);\n-                            if_chain! {\n-                                if TyS::same_type(self_ty, return_ty(cx, id));\n-                                if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n-                                then {\n-                                    if self.impling_types.is_none() {\n-                                        let mut impls = HirIdSet::default();\n-                                        cx.tcx.for_each_impl(default_trait_id, |d| {\n-                                            if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n-                                                if let Some(local_def_id) = ty_def.did.as_local() {\n-                                                    impls.insert(cx.tcx.hir().local_def_id_to_hir_id(local_def_id));\n-                                                }\n-                                            }\n-                                        });\n-                                        self.impling_types = Some(impls);\n-                                    }\n-\n-                                    // Check if a Default implementation exists for the Self type, regardless of\n-                                    // generics\n-                                    if_chain! {\n-                                        if let Some(ref impling_types) = self.impling_types;\n-                                        if let Some(self_def) = cx.tcx.type_of(self_def_id).ty_adt_def();\n-                                        if let Some(self_local_did) = self_def.did.as_local();\n-                                        then {\n-                                            let self_id = cx.tcx.hir().local_def_id_to_hir_id(self_local_did);\n-                                            if impling_types.contains(&self_id) {\n-                                                return;\n+                            if TyS::same_type(self_ty, return_ty(cx, id));\n+                            if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n+                            then {\n+                                if self.impling_types.is_none() {\n+                                    let mut impls = HirIdSet::default();\n+                                    cx.tcx.for_each_impl(default_trait_id, |d| {\n+                                        if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n+                                            if let Some(local_def_id) = ty_def.did.as_local() {\n+                                                impls.insert(cx.tcx.hir().local_def_id_to_hir_id(local_def_id));\n                                             }\n                                         }\n-                                    }\n+                                    });\n+                                    self.impling_types = Some(impls);\n+                                }\n \n-                                    let generics_sugg = snippet(cx, generics.span, \"\");\n-                                    span_lint_hir_and_then(\n-                                        cx,\n-                                        NEW_WITHOUT_DEFAULT,\n-                                        id,\n-                                        impl_item.span,\n-                                        &format!(\n-                                            \"you should consider adding a `Default` implementation for `{}`\",\n-                                            self_ty\n-                                        ),\n-                                        |diag| {\n-                                            diag.suggest_prepend_item(\n-                                                cx,\n-                                                item.span,\n-                                                \"try this\",\n-                                                &create_new_without_default_suggest_msg(self_ty, &generics_sugg),\n-                                                Applicability::MaybeIncorrect,\n-                                            );\n-                                        },\n-                                    );\n+                                // Check if a Default implementation exists for the Self type, regardless of\n+                                // generics\n+                                if_chain! {\n+                                    if let Some(ref impling_types) = self.impling_types;\n+                                    if let Some(self_def) = cx.tcx.type_of(self_def_id).ty_adt_def();\n+                                    if let Some(self_local_did) = self_def.did.as_local();\n+                                    let self_id = cx.tcx.hir().local_def_id_to_hir_id(self_local_did);\n+                                    if impling_types.contains(&self_id);\n+                                    then {\n+                                        return;\n+                                    }\n                                 }\n+\n+                                let generics_sugg = snippet(cx, generics.span, \"\");\n+                                span_lint_hir_and_then(\n+                                    cx,\n+                                    NEW_WITHOUT_DEFAULT,\n+                                    id,\n+                                    impl_item.span,\n+                                    &format!(\n+                                        \"you should consider adding a `Default` implementation for `{}`\",\n+                                        self_ty\n+                                    ),\n+                                    |diag| {\n+                                        diag.suggest_prepend_item(\n+                                            cx,\n+                                            item.span,\n+                                            \"try this\",\n+                                            &create_new_without_default_suggest_msg(self_ty, &generics_sugg),\n+                                            Applicability::MaybeIncorrect,\n+                                        );\n+                                    },\n+                                );\n                             }\n                         }\n                     }"}, {"sha": "cfcaf5094716bb7710adc32131786cae232bc29e", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -51,23 +51,21 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Lit(..) | ExprKind::Closure(..) => true,\n         ExprKind::Path(..) => !has_drop(cx, cx.typeck_results().expr_ty(expr)),\n-        ExprKind::Index(ref a, ref b) | ExprKind::Binary(_, ref a, ref b) => {\n-            has_no_effect(cx, a) && has_no_effect(cx, b)\n-        },\n-        ExprKind::Array(ref v) | ExprKind::Tup(ref v) => v.iter().all(|val| has_no_effect(cx, val)),\n-        ExprKind::Repeat(ref inner, _)\n-        | ExprKind::Cast(ref inner, _)\n-        | ExprKind::Type(ref inner, _)\n-        | ExprKind::Unary(_, ref inner)\n-        | ExprKind::Field(ref inner, _)\n-        | ExprKind::AddrOf(_, _, ref inner)\n-        | ExprKind::Box(ref inner) => has_no_effect(cx, inner),\n-        ExprKind::Struct(_, ref fields, ref base) => {\n+        ExprKind::Index(a, b) | ExprKind::Binary(_, a, b) => has_no_effect(cx, a) && has_no_effect(cx, b),\n+        ExprKind::Array(v) | ExprKind::Tup(v) => v.iter().all(|val| has_no_effect(cx, val)),\n+        ExprKind::Repeat(inner, _)\n+        | ExprKind::Cast(inner, _)\n+        | ExprKind::Type(inner, _)\n+        | ExprKind::Unary(_, inner)\n+        | ExprKind::Field(inner, _)\n+        | ExprKind::AddrOf(_, _, inner)\n+        | ExprKind::Box(inner) => has_no_effect(cx, inner),\n+        ExprKind::Struct(_, fields, ref base) => {\n             !has_drop(cx, cx.typeck_results().expr_ty(expr))\n-                && fields.iter().all(|field| has_no_effect(cx, &field.expr))\n+                && fields.iter().all(|field| has_no_effect(cx, field.expr))\n                 && base.as_ref().map_or(true, |base| has_no_effect(cx, base))\n         },\n-        ExprKind::Call(ref callee, ref args) => {\n+        ExprKind::Call(callee, args) => {\n             if let ExprKind::Path(ref qpath) = callee.kind {\n                 let res = cx.qpath_res(qpath, callee.hir_id);\n                 match res {\n@@ -81,7 +79,7 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n                 false\n             }\n         },\n-        ExprKind::Block(ref block, _) => {\n+        ExprKind::Block(block, _) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| has_no_effect(cx, expr))\n         },\n         _ => false,\n@@ -92,7 +90,7 @@ declare_lint_pass!(NoEffect => [NO_EFFECT, UNNECESSARY_OPERATION]);\n \n impl<'tcx> LateLintPass<'tcx> for NoEffect {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n-        if let StmtKind::Semi(ref expr) = stmt.kind {\n+        if let StmtKind::Semi(expr) = stmt.kind {\n             if has_no_effect(cx, expr) {\n                 span_lint(cx, NO_EFFECT, stmt.span, \"statement with no effect\");\n             } else if let Some(reduced) = reduce_expression(cx, expr) {\n@@ -127,26 +125,26 @@ fn reduce_expression<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Vec\n         return None;\n     }\n     match expr.kind {\n-        ExprKind::Index(ref a, ref b) => Some(vec![&**a, &**b]),\n-        ExprKind::Binary(ref binop, ref a, ref b) if binop.node != BinOpKind::And && binop.node != BinOpKind::Or => {\n-            Some(vec![&**a, &**b])\n+        ExprKind::Index(a, b) => Some(vec![a, b]),\n+        ExprKind::Binary(ref binop, a, b) if binop.node != BinOpKind::And && binop.node != BinOpKind::Or => {\n+            Some(vec![a, b])\n         },\n-        ExprKind::Array(ref v) | ExprKind::Tup(ref v) => Some(v.iter().collect()),\n-        ExprKind::Repeat(ref inner, _)\n-        | ExprKind::Cast(ref inner, _)\n-        | ExprKind::Type(ref inner, _)\n-        | ExprKind::Unary(_, ref inner)\n-        | ExprKind::Field(ref inner, _)\n-        | ExprKind::AddrOf(_, _, ref inner)\n-        | ExprKind::Box(ref inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n-        ExprKind::Struct(_, ref fields, ref base) => {\n+        ExprKind::Array(v) | ExprKind::Tup(v) => Some(v.iter().collect()),\n+        ExprKind::Repeat(inner, _)\n+        | ExprKind::Cast(inner, _)\n+        | ExprKind::Type(inner, _)\n+        | ExprKind::Unary(_, inner)\n+        | ExprKind::Field(inner, _)\n+        | ExprKind::AddrOf(_, _, inner)\n+        | ExprKind::Box(inner) => reduce_expression(cx, inner).or_else(|| Some(vec![inner])),\n+        ExprKind::Struct(_, fields, ref base) => {\n             if has_drop(cx, cx.typeck_results().expr_ty(expr)) {\n                 None\n             } else {\n                 Some(fields.iter().map(|f| &f.expr).chain(base).map(Deref::deref).collect())\n             }\n         },\n-        ExprKind::Call(ref callee, ref args) => {\n+        ExprKind::Call(callee, args) => {\n             if let ExprKind::Path(ref qpath) = callee.kind {\n                 let res = cx.qpath_res(qpath, callee.hir_id);\n                 match res {\n@@ -161,7 +159,7 @@ fn reduce_expression<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<Vec\n                 None\n             }\n         },\n-        ExprKind::Block(ref block, _) => {\n+        ExprKind::Block(block, _) => {\n             if block.stmts.is_empty() {\n                 block.expr.as_ref().and_then(|e| {\n                     match block.rules {"}, {"sha": "d775cd7c7f740b4392563a5bb09ea8ec32dd0ff6", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -307,19 +307,17 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                             // we should use here as a frozen variant is a potential to be frozen\n                             // similar to unknown layouts.\n                             // e.g. `layout_of(...).is_err() || has_frozen_variant(...);`\n+                        let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+                        let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n+                        if is_unfrozen(cx, normalized);\n+                        if is_value_unfrozen_poly(cx, *body_id, normalized);\n                         then {\n-                            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-                            let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n-                            if is_unfrozen(cx, normalized)\n-                                && is_value_unfrozen_poly(cx, *body_id, normalized)\n-                            {\n-                                lint(\n-                                   cx,\n-                                   Source::Assoc {\n-                                       item: impl_item.span,\n-                                    },\n-                                );\n-                            }\n+                            lint(\n+                               cx,\n+                               Source::Assoc {\n+                                   item: impl_item.span,\n+                                },\n+                            );\n                         }\n                     }\n                 },"}, {"sha": "a83daea97bf6bfc5871a8080a30ca69e7623aa2f", "filename": "clippy_lints/src/non_octal_unix_permissions.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,106 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n+use clippy_utils::ty::match_type;\n+use clippy_utils::{match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for non-octal values used to set Unix file permissions.\n+    ///\n+    /// **Why is this bad?** They will be converted into octal, creating potentially\n+    /// unintended file permissions.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::unix::fs::OpenOptionsExt;\n+    ///\n+    /// let mut options = OpenOptions::new();\n+    /// options.mode(644);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::unix::fs::OpenOptionsExt;\n+    ///\n+    /// let mut options = OpenOptions::new();\n+    /// options.mode(0o644);\n+    /// ```\n+    pub NON_OCTAL_UNIX_PERMISSIONS,\n+    correctness,\n+    \"use of non-octal value to set unix file permissions, which will be translated into octal\"\n+}\n+\n+declare_lint_pass!(NonOctalUnixPermissions => [NON_OCTAL_UNIX_PERMISSIONS]);\n+\n+impl LateLintPass<'_> for NonOctalUnixPermissions {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        match &expr.kind {\n+            ExprKind::MethodCall(path, _, [func, param], _) => {\n+                let obj_ty = cx.typeck_results().expr_ty(func).peel_refs();\n+\n+                if_chain! {\n+                    if (path.ident.name == sym!(mode)\n+                        && (match_type(cx, obj_ty, &paths::OPEN_OPTIONS)\n+                            || match_type(cx, obj_ty, &paths::DIR_BUILDER)))\n+                        || (path.ident.name == sym!(set_mode) && match_type(cx, obj_ty, &paths::PERMISSIONS));\n+                    if let ExprKind::Lit(_) = param.kind;\n+\n+                    then {\n+                        let snip = match snippet_opt(cx, param.span) {\n+                            Some(s) => s,\n+                            _ => return,\n+                        };\n+\n+                        if !snip.starts_with(\"0o\") {\n+                            show_error(cx, param);\n+                        }\n+                    }\n+                }\n+            },\n+            ExprKind::Call(func, [param]) => {\n+                if_chain! {\n+                    if let ExprKind::Path(ref path) = func.kind;\n+                    if let Some(def_id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n+                    if match_def_path(cx, def_id, &paths::PERMISSIONS_FROM_MODE);\n+                    if let ExprKind::Lit(_) = param.kind;\n+\n+                    then {\n+                        let snip = match snippet_opt(cx, param.span) {\n+                            Some(s) => s,\n+                            _ => return,\n+                        };\n+\n+                        if !snip.starts_with(\"0o\") {\n+                            show_error(cx, param);\n+                        }\n+                    }\n+                }\n+            },\n+            _ => {},\n+        };\n+    }\n+}\n+\n+fn show_error(cx: &LateContext<'_>, param: &Expr<'_>) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    span_lint_and_sugg(\n+        cx,\n+        NON_OCTAL_UNIX_PERMISSIONS,\n+        param.span,\n+        \"using a non-octal value to set unix file permissions\",\n+        \"consider using an octal literal instead\",\n+        format!(\n+            \"0o{}\",\n+            snippet_with_applicability(cx, param.span, \"0o..\", &mut applicability,),\n+        ),\n+        applicability,\n+    );\n+}"}, {"sha": "9efe45336bfce55c31435de8c444ff616b960972", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -31,7 +31,7 @@ declare_lint_pass!(OpenOptions => [NONSENSICAL_OPEN_OPTIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for OpenOptions {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::MethodCall(ref path, _, ref arguments, _) = e.kind {\n+        if let ExprKind::MethodCall(path, _, arguments, _) = e.kind {\n             let obj_ty = cx.typeck_results().expr_ty(&arguments[0]).peel_refs();\n             if path.ident.name == sym!(open) && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n@@ -59,7 +59,7 @@ enum OpenOption {\n }\n \n fn get_open_options(cx: &LateContext<'_>, argument: &Expr<'_>, options: &mut Vec<(OpenOption, Argument)>) {\n-    if let ExprKind::MethodCall(ref path, _, ref arguments, _) = argument.kind {\n+    if let ExprKind::MethodCall(path, _, arguments, _) = argument.kind {\n         let obj_ty = cx.typeck_results().expr_ty(&arguments[0]).peel_refs();\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions"}, {"sha": "b6f518661bdb1b4efbf38ef9fb0868909a4b92cd", "filename": "clippy_lints/src/option_env_unwrap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Foption_env_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Foption_env_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_env_unwrap.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -4,6 +4,7 @@ use if_chain::if_chain;\n use rustc_ast::ast::{Expr, ExprKind};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `option_env!(...).unwrap()` and\n@@ -37,8 +38,7 @@ impl EarlyLintPass for OptionEnvUnwrap {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         if_chain! {\n             if let ExprKind::MethodCall(path_segment, args, _) = &expr.kind;\n-            let method_name = path_segment.ident.as_str();\n-            if method_name == \"expect\" || method_name == \"unwrap\";\n+            if matches!(path_segment.ident.name, sym::expect | sym::unwrap);\n             if let ExprKind::Call(caller, _) = &args[0].kind;\n             if is_direct_expn_of(caller.span, \"option_env\").is_some();\n             then {"}, {"sha": "1b9120ae45f54c763dd72209e3b6295ec54b3d6a", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -66,9 +66,9 @@ declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n \n /// Returns true iff the given expression is the result of calling `Result::ok`\n fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n-    if let ExprKind::MethodCall(ref path, _, &[ref receiver], _) = &expr.kind {\n+    if let ExprKind::MethodCall(path, _, &[ref receiver], _) = &expr.kind {\n         path.ident.name.as_str() == \"ok\"\n-            && is_type_diagnostic_item(cx, &cx.typeck_results().expr_ty(&receiver), sym::result_type)\n+            && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(receiver), sym::result_type)\n     } else {\n         false\n     }\n@@ -97,9 +97,9 @@ fn extract_body_from_arm<'a>(arm: &'a Arm<'a>) -> Option<&'a Expr<'a>> {\n     ) = &arm.body.kind\n     {\n         if let [] = statements {\n-            Some(&expr)\n+            Some(expr)\n         } else {\n-            Some(&arm.body)\n+            Some(arm.body)\n         }\n     } else {\n         None"}, {"sha": "e222782c2cc8c597f2b7755b4098ff88ddd860e5", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -31,11 +31,11 @@ impl<'tcx> LateLintPass<'tcx> for OverflowCheckConditional {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let eq = |l, r| SpanlessEq::new(cx).eq_path_segment(l, r);\n         if_chain! {\n-            if let ExprKind::Binary(ref op, ref first, ref second) = expr.kind;\n-            if let ExprKind::Binary(ref op2, ref ident1, ref ident2) = first.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path1)) = ident1.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path3)) = second.kind;\n+            if let ExprKind::Binary(ref op, first, second) = expr.kind;\n+            if let ExprKind::Binary(ref op2, ident1, ident2) = first.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path1)) = ident1.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path2)) = ident2.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path3)) = second.kind;\n             if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n             if cx.typeck_results().expr_ty(ident1).is_integral();\n             if cx.typeck_results().expr_ty(ident2).is_integral();\n@@ -56,11 +56,11 @@ impl<'tcx> LateLintPass<'tcx> for OverflowCheckConditional {\n         }\n \n         if_chain! {\n-            if let ExprKind::Binary(ref op, ref first, ref second) = expr.kind;\n-            if let ExprKind::Binary(ref op2, ref ident1, ref ident2) = second.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path1)) = ident1.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path2)) = ident2.kind;\n-            if let ExprKind::Path(QPath::Resolved(_, ref path3)) = first.kind;\n+            if let ExprKind::Binary(ref op, first, second) = expr.kind;\n+            if let ExprKind::Binary(ref op2, ident1, ident2) = second.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path1)) = ident1.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path2)) = ident2.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path3)) = first.kind;\n             if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n             if cx.typeck_results().expr_ty(ident1).is_integral();\n             if cx.typeck_results().expr_ty(ident2).is_integral();"}, {"sha": "1e9468589472326ad23098a935f3de9ff052a747", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -97,11 +97,10 @@ impl<'tcx> LateLintPass<'tcx> for PanicUnimplemented {\n fn get_outer_span(expr: &Expr<'_>) -> Span {\n     if_chain! {\n         if expr.span.from_expansion();\n-        let first = expr.span.ctxt().outer_expn_data();\n-        if first.call_site.from_expansion();\n-        let second = first.call_site.ctxt().outer_expn_data();\n+        let first = expr.span.ctxt().outer_expn_data().call_site;\n+        if first.from_expansion();\n         then {\n-            second.call_site\n+            first.ctxt().outer_expn_data().call_site\n         } else {\n             expr.span\n         }"}, {"sha": "6f80e447c7ddd71fd99a21e8d69a4f2890d860af", "filename": "clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -142,11 +142,11 @@ impl<'tcx> PassByRefOrValue {\n                     };\n \n                     if_chain! {\n-                        if !output_lts.contains(&input_lt);\n+                        if !output_lts.contains(input_lt);\n                         if is_copy(cx, ty);\n                         if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n                         if size <= self.ref_min_size;\n-                        if let hir::TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.kind;\n+                        if let hir::TyKind::Rptr(_, MutTy { ty: decl_ty, .. }) = input.kind;\n                         then {\n                             let value_type = if is_self_ty(decl_ty) {\n                                 \"self\".into()"}, {"sha": "0024592638104a39ecd638b073c990be980b5155", "filename": "clippy_lints/src/path_buf_push_overwrite.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -45,7 +45,7 @@ declare_lint_pass!(PathBufPushOverwrite => [PATH_BUF_PUSH_OVERWRITE]);\n impl<'tcx> LateLintPass<'tcx> for PathBufPushOverwrite {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n             if path.ident.name == sym!(push);\n             if args.len() == 2;\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]).peel_refs(), sym::PathBuf);"}, {"sha": "9bab783998aa5693088f8352a3319e55f23086a1", "filename": "clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -87,7 +87,7 @@ declare_lint_pass!(PatternTypeMismatch => [PATTERN_TYPE_MISMATCH]);\n \n impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n-        if let StmtKind::Local(ref local) = stmt.kind {\n+        if let StmtKind::Local(local) = stmt.kind {\n             if let Some(init) = &local.init {\n                 if let Some(init_ty) = cx.typeck_results().node_type_opt(init.hir_id) {\n                     let pat = &local.pat;\n@@ -105,7 +105,7 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(ref expr, arms, source) = expr.kind {\n+        if let ExprKind::Match(expr, arms, source) = expr.kind {\n             match source {\n                 MatchSource::Normal | MatchSource::IfLetDesugar { .. } | MatchSource::WhileLetDesugar => {\n                     if let Some(expr_ty) = cx.typeck_results().node_type_opt(expr.hir_id) {\n@@ -136,7 +136,7 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n     ) {\n         if let Some(fn_sig) = cx.typeck_results().liberated_fn_sigs().get(hir_id) {\n             for (param, ty) in iter::zip(body.params, fn_sig.inputs()) {\n-                apply_lint(cx, &param.pat, ty, DerefPossible::Impossible);\n+                apply_lint(cx, param.pat, ty, DerefPossible::Impossible);\n             }\n         }\n     }\n@@ -188,7 +188,7 @@ fn find_first_mismatch<'tcx>(\n     ty: Ty<'tcx>,\n     level: Level,\n ) -> Option<(Span, Mutability, Level)> {\n-    if let PatKind::Ref(ref sub_pat, _) = pat.kind {\n+    if let PatKind::Ref(sub_pat, _) = pat.kind {\n         if let TyKind::Ref(_, sub_ty, _) = ty.kind() {\n             return find_first_mismatch(cx, sub_pat, sub_ty, Level::Lower);\n         }\n@@ -200,17 +200,17 @@ fn find_first_mismatch<'tcx>(\n         }\n     }\n \n-    if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.kind {\n-        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind() {\n+    if let PatKind::Struct(ref qpath, field_pats, _) = pat.kind {\n+        if let TyKind::Adt(adt_def, substs_ref) = ty.kind() {\n             if let Some(variant) = get_variant(adt_def, qpath) {\n                 let field_defs = &variant.fields;\n                 return find_first_mismatch_in_struct(cx, field_pats, field_defs, substs_ref);\n             }\n         }\n     }\n \n-    if let PatKind::TupleStruct(ref qpath, ref pats, _) = pat.kind {\n-        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind() {\n+    if let PatKind::TupleStruct(ref qpath, pats, _) = pat.kind {\n+        if let TyKind::Adt(adt_def, substs_ref) = ty.kind() {\n             if let Some(variant) = get_variant(adt_def, qpath) {\n                 let field_defs = &variant.fields;\n                 let ty_iter = field_defs.iter().map(|field_def| field_def.ty(cx.tcx, substs_ref));\n@@ -219,7 +219,7 @@ fn find_first_mismatch<'tcx>(\n         }\n     }\n \n-    if let PatKind::Tuple(ref pats, _) = pat.kind {\n+    if let PatKind::Tuple(pats, _) = pat.kind {\n         if let TyKind::Tuple(..) = ty.kind() {\n             return find_first_mismatch_in_tuple(cx, pats, ty.tuple_fields());\n         }"}, {"sha": "09fcdb5faf84272c37e10a7de8a4a7922be48768", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -124,7 +124,7 @@ declare_lint_pass!(Ptr => [PTR_ARG, CMP_NULL, MUT_FROM_REF]);\n impl<'tcx> LateLintPass<'tcx> for Ptr {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if let ItemKind::Fn(ref sig, _, body_id) = item.kind {\n-            check_fn(cx, &sig.decl, item.hir_id(), Some(body_id));\n+            check_fn(cx, sig.decl, item.hir_id(), Some(body_id));\n         }\n     }\n \n@@ -136,7 +136,7 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n                     return; // ignore trait impls\n                 }\n             }\n-            check_fn(cx, &sig.decl, item.hir_id(), Some(body_id));\n+            check_fn(cx, sig.decl, item.hir_id(), Some(body_id));\n         }\n     }\n \n@@ -147,12 +147,12 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n             } else {\n                 None\n             };\n-            check_fn(cx, &sig.decl, item.hir_id(), body_id);\n+            check_fn(cx, sig.decl, item.hir_id(), body_id);\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(ref op, ref l, ref r) = expr.kind {\n+        if let ExprKind::Binary(ref op, l, r) = expr.kind {\n             if (op.node == BinOpKind::Eq || op.node == BinOpKind::Ne) && (is_null_path(l) || is_null_path(r)) {\n                 span_lint(\n                     cx,\n@@ -262,35 +262,34 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n                 }\n             } else if match_type(cx, ty, &paths::COW) {\n                 if_chain! {\n-                    if let TyKind::Rptr(_, MutTy { ref ty, ..} ) = arg.kind;\n-                    if let TyKind::Path(QPath::Resolved(None, ref pp)) = ty.kind;\n+                    if let TyKind::Rptr(_, MutTy { ty, ..} ) = arg.kind;\n+                    if let TyKind::Path(QPath::Resolved(None, pp)) = ty.kind;\n                     if let [ref bx] = *pp.segments;\n-                    if let Some(ref params) = bx.args;\n+                    if let Some(params) = bx.args;\n                     if !params.parenthesized;\n                     if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n                         GenericArg::Type(ty) => Some(ty),\n                         _ => None,\n                     });\n+                    let replacement = snippet_opt(cx, inner.span);\n+                    if let Some(r) = replacement;\n                     then {\n-                        let replacement = snippet_opt(cx, inner.span);\n-                        if let Some(r) = replacement {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                PTR_ARG,\n-                                arg.span,\n-                                \"using a reference to `Cow` is not recommended\",\n-                                \"change this to\",\n-                                \"&\".to_owned() + &r,\n-                                Applicability::Unspecified,\n-                            );\n-                        }\n+                        span_lint_and_sugg(\n+                            cx,\n+                            PTR_ARG,\n+                            arg.span,\n+                            \"using a reference to `Cow` is not recommended\",\n+                            \"change this to\",\n+                            \"&\".to_owned() + &r,\n+                            Applicability::Unspecified,\n+                        );\n                     }\n                 }\n             }\n         }\n     }\n \n-    if let FnRetTy::Return(ref ty) = decl.output {\n+    if let FnRetTy::Return(ty) = decl.output {\n         if let Some((out, Mutability::Mut, _)) = get_rptr_lm(ty) {\n             let mut immutables = vec![];\n             for (_, ref mutbl, ref argspan) in decl\n@@ -323,8 +322,8 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n \n fn get_only_generic_arg_snippet(cx: &LateContext<'_>, arg: &Ty<'_>) -> Option<String> {\n     if_chain! {\n-        if let TyKind::Path(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).kind;\n-        if let Some(&PathSegment{args: Some(ref parameters), ..}) = path.segments.last();\n+        if let TyKind::Path(QPath::Resolved(_, path)) = walk_ptrs_hir_ty(arg).kind;\n+        if let Some(&PathSegment{args: Some(parameters), ..}) = path.segments.last();\n         let types: Vec<_> = parameters.args.iter().filter_map(|arg| match arg {\n             GenericArg::Type(ty) => Some(ty),\n             _ => None,\n@@ -347,7 +346,7 @@ fn get_rptr_lm<'tcx>(ty: &'tcx Ty<'tcx>) -> Option<(&'tcx Lifetime, Mutability,\n }\n \n fn is_null_path(expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Call(ref pathexp, ref args) = expr.kind {\n+    if let ExprKind::Call(pathexp, args) = expr.kind {\n         if args.is_empty() {\n             if let ExprKind::Path(ref path) = pathexp.kind {\n                 return match_qpath(path, &paths::PTR_NULL) || match_qpath(path, &paths::PTR_NULL_MUT);"}, {"sha": "77cfa3f6b176cd076c433af4c607a9fbd5d23cf9", "filename": "clippy_lints/src/ptr_eq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fptr_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fptr_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_eq.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -46,11 +46,11 @@ impl LateLintPass<'_> for PtrEq {\n             return;\n         }\n \n-        if let ExprKind::Binary(ref op, ref left, ref right) = expr.kind {\n+        if let ExprKind::Binary(ref op, left, right) = expr.kind {\n             if BinOpKind::Eq == op.node {\n                 let (left, right) = match (expr_as_cast_to_usize(cx, left), expr_as_cast_to_usize(cx, right)) {\n                     (Some(lhs), Some(rhs)) => (lhs, rhs),\n-                    _ => (&**left, &**right),\n+                    _ => (left, right),\n                 };\n \n                 if_chain! {\n@@ -79,7 +79,7 @@ impl LateLintPass<'_> for PtrEq {\n // E.g., `foo as *const _ as usize` returns `foo as *const _`.\n fn expr_as_cast_to_usize<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if cx.typeck_results().expr_ty(cast_expr) == cx.tcx.types.usize {\n-        if let ExprKind::Cast(ref expr, _) = cast_expr.kind {\n+        if let ExprKind::Cast(expr, _) = cast_expr.kind {\n             return Some(expr);\n         }\n     }\n@@ -90,7 +90,7 @@ fn expr_as_cast_to_usize<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>\n // E.g., `foo as *const _` returns `foo`.\n fn expr_as_cast_to_raw_pointer<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     if cx.typeck_results().expr_ty(cast_expr).is_unsafe_ptr() {\n-        if let ExprKind::Cast(ref expr, _) = cast_expr.kind {\n+        if let ExprKind::Cast(expr, _) = cast_expr.kind {\n             return Some(expr);\n         }\n     }"}, {"sha": "afb198f49559aac2c666237d7ff309210335a859", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -78,8 +78,8 @@ impl<'tcx> LateLintPass<'tcx> for PtrOffsetWithCast {\n \n // If the given expression is a cast from a usize, return the lhs of the cast\n fn expr_as_cast_from_usize<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    if let ExprKind::Cast(ref cast_lhs_expr, _) = expr.kind {\n-        if is_expr_ty_usize(cx, &cast_lhs_expr) {\n+    if let ExprKind::Cast(cast_lhs_expr, _) = expr.kind {\n+        if is_expr_ty_usize(cx, cast_lhs_expr) {\n             return Some(cast_lhs_expr);\n         }\n     }\n@@ -92,7 +92,7 @@ fn expr_as_ptr_offset_call<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n ) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>, Method)> {\n-    if let ExprKind::MethodCall(ref path_segment, _, ref args, _) = expr.kind {\n+    if let ExprKind::MethodCall(path_segment, _, args, _) = expr.kind {\n         if is_expr_ty_raw_ptr(cx, &args[0]) {\n             if path_segment.ident.name == sym::offset {\n                 return Some((&args[0], &args[1], Method::Offset));"}, {"sha": "6d720f43851a0d56402553fc4d404610571f2947", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -148,14 +148,14 @@ impl QuestionMark {\n \n     fn expression_returns_none(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n         match expression.kind {\n-            ExprKind::Block(ref block, _) => {\n+            ExprKind::Block(block, _) => {\n                 if let Some(return_expression) = Self::return_expression(block) {\n-                    return Self::expression_returns_none(cx, &return_expression);\n+                    return Self::expression_returns_none(cx, return_expression);\n                 }\n \n                 false\n             },\n-            ExprKind::Ret(Some(ref expr)) => Self::expression_returns_none(cx, expr),\n+            ExprKind::Ret(Some(expr)) => Self::expression_returns_none(cx, expr),\n             ExprKind::Path(ref qp) => {\n                 if let Res::Def(DefKind::Ctor(def::CtorOf::Variant, def::CtorKind::Const), def_id) =\n                     cx.qpath_res(qp, expression.hir_id)\n@@ -174,7 +174,7 @@ impl QuestionMark {\n         if_chain! {\n             if block.stmts.len() == 1;\n             if let Some(expr) = block.stmts.iter().last();\n-            if let StmtKind::Semi(ref expr) = expr.kind;\n+            if let StmtKind::Semi(expr) = expr.kind;\n             if let ExprKind::Ret(Some(ret_expr)) = expr.kind;\n \n             then {"}, {"sha": "1c3c125e579132a7ef28745d57e65dcb81fb1034", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -183,10 +183,10 @@ impl_lint_pass!(Ranges => [\n impl<'tcx> LateLintPass<'tcx> for Ranges {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         match expr.kind {\n-            ExprKind::MethodCall(ref path, _, ref args, _) => {\n+            ExprKind::MethodCall(path, _, args, _) => {\n                 check_range_zip_with_len(cx, path, args, expr.span);\n             },\n-            ExprKind::Binary(ref op, ref l, ref r) => {\n+            ExprKind::Binary(ref op, l, r) => {\n                 if meets_msrv(self.msrv.as_ref(), &MANUAL_RANGE_CONTAINS_MSRV) {\n                     check_possible_range_contains(cx, op.node, l, r, expr);\n                 }\n@@ -287,7 +287,7 @@ fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'\n }\n \n fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant, Ident, Span, Span, Ordering, bool)> {\n-    if let ExprKind::Binary(ref op, ref l, ref r) = ex.kind {\n+    if let ExprKind::Binary(ref op, l, r) = ex.kind {\n         let (inclusive, ordering) = match op.node {\n             BinOpKind::Gt => (false, Ordering::Greater),\n             BinOpKind::Ge => (true, Ordering::Greater),\n@@ -320,32 +320,29 @@ fn match_ident(e: &Expr<'_>) -> Option<Ident> {\n }\n \n fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args: &[Expr<'_>], span: Span) {\n-    let name = path.ident.as_str();\n-    if name == \"zip\" && args.len() == 2 {\n-        let iter = &args[0].kind;\n-        let zip_arg = &args[1];\n-        if_chain! {\n-            // `.iter()` call\n-            if let ExprKind::MethodCall(ref iter_path, _, ref iter_args, _) = *iter;\n-            if iter_path.ident.name == sym::iter;\n-            // range expression in `.zip()` call: `0..x.len()`\n-            if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n-            if is_integer_const(cx, start, 0);\n-            // `.len()` call\n-            if let ExprKind::MethodCall(ref len_path, _, ref len_args, _) = end.kind;\n-            if len_path.ident.name == sym!(len) && len_args.len() == 1;\n-            // `.iter()` and `.len()` called on same `Path`\n-            if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].kind;\n-            if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].kind;\n-            if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n-            then {\n-                span_lint(cx,\n-                    RANGE_ZIP_WITH_LEN,\n-                    span,\n-                    &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n-                        snippet(cx, iter_args[0].span, \"_\"))\n-                );\n-            }\n+    if_chain! {\n+        if path.ident.as_str() == \"zip\";\n+        if let [iter, zip_arg] = args;\n+        // `.iter()` call\n+        if let ExprKind::MethodCall(iter_path, _, iter_args, _) = iter.kind;\n+        if iter_path.ident.name == sym::iter;\n+        // range expression in `.zip()` call: `0..x.len()`\n+        if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n+        if is_integer_const(cx, start, 0);\n+        // `.len()` call\n+        if let ExprKind::MethodCall(len_path, _, len_args, _) = end.kind;\n+        if len_path.ident.name == sym!(len) && len_args.len() == 1;\n+        // `.iter()` and `.len()` called on same `Path`\n+        if let ExprKind::Path(QPath::Resolved(_, iter_path)) = iter_args[0].kind;\n+        if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_args[0].kind;\n+        if SpanlessEq::new(cx).eq_path_segments(iter_path.segments, len_path.segments);\n+        then {\n+            span_lint(cx,\n+                RANGE_ZIP_WITH_LEN,\n+                span,\n+                &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n+                    snippet(cx, iter_args[0].span, \"_\"))\n+            );\n         }\n     }\n }\n@@ -511,8 +508,8 @@ fn y_plus_one<'t>(cx: &LateContext<'_>, expr: &'t Expr<'_>) -> Option<&'t Expr<'\n             Spanned {\n                 node: BinOpKind::Add, ..\n             },\n-            ref lhs,\n-            ref rhs,\n+            lhs,\n+            rhs,\n         ) => {\n             if is_integer_const(cx, lhs, 1) {\n                 Some(rhs)\n@@ -532,8 +529,8 @@ fn y_minus_one<'t>(cx: &LateContext<'_>, expr: &'t Expr<'_>) -> Option<&'t Expr<\n             Spanned {\n                 node: BinOpKind::Sub, ..\n             },\n-            ref lhs,\n-            ref rhs,\n+            lhs,\n+            rhs,\n         ) if is_integer_const(cx, rhs, 1) => Some(lhs),\n         _ => None,\n     }"}, {"sha": "7dafce60d5eda1cc2c09bbf31913a4dc277772d7", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 152, "deletions": 106, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -94,7 +94,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n             .into_results_cursor(mir);\n         let mut possible_borrower = {\n             let mut vis = PossibleBorrowerVisitor::new(cx, mir);\n-            vis.visit_body(&mir);\n+            vis.visit_body(mir);\n             vis.into_map(cx, maybe_storage_live_result)\n         };\n \n@@ -126,7 +126,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                 continue;\n             }\n \n-            if let ty::Adt(ref def, _) = arg_ty.kind() {\n+            if let ty::Adt(def, _) = arg_ty.kind() {\n                 if match_def_path(cx, def.did, &paths::MEM_MANUALLY_DROP) {\n                     continue;\n                 }\n@@ -199,79 +199,72 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                 (local, deref_clone_ret)\n             };\n \n-            let is_temp = mir.local_kind(ret_local) == mir::LocalKind::Temp;\n-\n-            // 1. `local` can be moved out if it is not used later.\n-            // 2. If `ret_local` is a temporary and is neither consumed nor mutated, we can remove this `clone`\n-            // call anyway.\n-            let (used, consumed_or_mutated) = traversal::ReversePostorder::new(&mir, bb).skip(1).fold(\n-                (false, !is_temp),\n-                |(used, consumed), (tbb, tdata)| {\n-                    // Short-circuit\n-                    if (used && consumed) ||\n-                        // Give up on loops\n-                        tdata.terminator().successors().any(|s| *s == bb)\n-                    {\n-                        return (true, true);\n+            let clone_usage = if local == ret_local {\n+                CloneUsage {\n+                    cloned_used: false,\n+                    cloned_consume_or_mutate_loc: None,\n+                    clone_consumed_or_mutated: true,\n+                }\n+            } else {\n+                let clone_usage = visit_clone_usage(local, ret_local, mir, bb);\n+                if clone_usage.cloned_used && clone_usage.clone_consumed_or_mutated {\n+                    // cloned value is used, and the clone is modified or moved\n+                    continue;\n+                } else if let Some(loc) = clone_usage.cloned_consume_or_mutate_loc {\n+                    // cloned value is mutated, and the clone is alive.\n+                    if possible_borrower.is_alive_at(ret_local, loc) {\n+                        continue;\n                     }\n+                }\n+                clone_usage\n+            };\n \n-                    let mut vis = LocalUseVisitor {\n-                        used: (local, false),\n-                        consumed_or_mutated: (ret_local, false),\n-                    };\n-                    vis.visit_basic_block_data(tbb, tdata);\n-                    (used || vis.used.1, consumed || vis.consumed_or_mutated.1)\n-                },\n-            );\n-\n-            if !used || !consumed_or_mutated {\n-                let span = terminator.source_info.span;\n-                let scope = terminator.source_info.scope;\n-                let node = mir.source_scopes[scope]\n-                    .local_data\n-                    .as_ref()\n-                    .assert_crate_local()\n-                    .lint_root;\n-\n-                if_chain! {\n-                    if let Some(snip) = snippet_opt(cx, span);\n-                    if let Some(dot) = snip.rfind('.');\n-                    then {\n-                        let sugg_span = span.with_lo(\n-                            span.lo() + BytePos(u32::try_from(dot).unwrap())\n-                        );\n-                        let mut app = Applicability::MaybeIncorrect;\n-\n-                        let call_snip = &snip[dot + 1..];\n-                        // Machine applicable when `call_snip` looks like `foobar()`\n-                        if let Some(call_snip) = call_snip.strip_suffix(\"()\").map(str::trim) {\n-                            if call_snip.as_bytes().iter().all(|b| b.is_ascii_alphabetic() || *b == b'_') {\n-                                app = Applicability::MachineApplicable;\n-                            }\n+            let span = terminator.source_info.span;\n+            let scope = terminator.source_info.scope;\n+            let node = mir.source_scopes[scope]\n+                .local_data\n+                .as_ref()\n+                .assert_crate_local()\n+                .lint_root;\n+\n+            if_chain! {\n+                if let Some(snip) = snippet_opt(cx, span);\n+                if let Some(dot) = snip.rfind('.');\n+                then {\n+                    let sugg_span = span.with_lo(\n+                        span.lo() + BytePos(u32::try_from(dot).unwrap())\n+                    );\n+                    let mut app = Applicability::MaybeIncorrect;\n+\n+                    let call_snip = &snip[dot + 1..];\n+                    // Machine applicable when `call_snip` looks like `foobar()`\n+                    if let Some(call_snip) = call_snip.strip_suffix(\"()\").map(str::trim) {\n+                        if call_snip.as_bytes().iter().all(|b| b.is_ascii_alphabetic() || *b == b'_') {\n+                            app = Applicability::MachineApplicable;\n                         }\n+                    }\n \n-                        span_lint_hir_and_then(cx, REDUNDANT_CLONE, node, sugg_span, \"redundant clone\", |diag| {\n-                            diag.span_suggestion(\n-                                sugg_span,\n-                                \"remove this\",\n-                                String::new(),\n-                                app,\n+                    span_lint_hir_and_then(cx, REDUNDANT_CLONE, node, sugg_span, \"redundant clone\", |diag| {\n+                        diag.span_suggestion(\n+                            sugg_span,\n+                            \"remove this\",\n+                            String::new(),\n+                            app,\n+                        );\n+                        if clone_usage.cloned_used {\n+                            diag.span_note(\n+                                span,\n+                                \"cloned value is neither consumed nor mutated\",\n                             );\n-                            if used {\n-                                diag.span_note(\n-                                    span,\n-                                    \"cloned value is neither consumed nor mutated\",\n-                                );\n-                            } else {\n-                                diag.span_note(\n-                                    span.with_hi(span.lo() + BytePos(u32::try_from(dot).unwrap())),\n-                                    \"this value is dropped without further use\",\n-                                );\n-                            }\n-                        });\n-                    } else {\n-                        span_lint_hir(cx, REDUNDANT_CLONE, node, span, \"redundant clone\");\n-                    }\n+                        } else {\n+                            diag.span_note(\n+                                span.with_hi(span.lo() + BytePos(u32::try_from(dot).unwrap())),\n+                                \"this value is dropped without further use\",\n+                            );\n+                        }\n+                    });\n+                } else {\n+                    span_lint_hir(cx, REDUNDANT_CLONE, node, span, \"redundant clone\");\n                 }\n             }\n         }\n@@ -365,49 +358,97 @@ fn base_local_and_movability<'tcx>(\n     (local, deref || field || slice)\n }\n \n-struct LocalUseVisitor {\n-    used: (mir::Local, bool),\n-    consumed_or_mutated: (mir::Local, bool),\n+#[derive(Default)]\n+struct CloneUsage {\n+    /// Whether the cloned value is used after the clone.\n+    cloned_used: bool,\n+    /// The first location where the cloned value is consumed or mutated, if any.\n+    cloned_consume_or_mutate_loc: Option<mir::Location>,\n+    /// Whether the clone value is mutated.\n+    clone_consumed_or_mutated: bool,\n }\n-\n-impl<'tcx> mir::visit::Visitor<'tcx> for LocalUseVisitor {\n-    fn visit_basic_block_data(&mut self, block: mir::BasicBlock, data: &mir::BasicBlockData<'tcx>) {\n-        let statements = &data.statements;\n-        for (statement_index, statement) in statements.iter().enumerate() {\n-            self.visit_statement(statement, mir::Location { block, statement_index });\n-        }\n-\n-        self.visit_terminator(\n-            data.terminator(),\n-            mir::Location {\n-                block,\n-                statement_index: statements.len(),\n-            },\n-        );\n+fn visit_clone_usage(cloned: mir::Local, clone: mir::Local, mir: &mir::Body<'_>, bb: mir::BasicBlock) -> CloneUsage {\n+    struct V {\n+        cloned: mir::Local,\n+        clone: mir::Local,\n+        result: CloneUsage,\n     }\n+    impl<'tcx> mir::visit::Visitor<'tcx> for V {\n+        fn visit_basic_block_data(&mut self, block: mir::BasicBlock, data: &mir::BasicBlockData<'tcx>) {\n+            let statements = &data.statements;\n+            for (statement_index, statement) in statements.iter().enumerate() {\n+                self.visit_statement(statement, mir::Location { block, statement_index });\n+            }\n \n-    fn visit_place(&mut self, place: &mir::Place<'tcx>, ctx: PlaceContext, _: mir::Location) {\n-        let local = place.local;\n-\n-        if local == self.used.0\n-            && !matches!(\n-                ctx,\n-                PlaceContext::MutatingUse(MutatingUseContext::Drop) | PlaceContext::NonUse(_)\n-            )\n-        {\n-            self.used.1 = true;\n+            self.visit_terminator(\n+                data.terminator(),\n+                mir::Location {\n+                    block,\n+                    statement_index: statements.len(),\n+                },\n+            );\n         }\n \n-        if local == self.consumed_or_mutated.0 {\n-            match ctx {\n-                PlaceContext::NonMutatingUse(NonMutatingUseContext::Move)\n-                | PlaceContext::MutatingUse(MutatingUseContext::Borrow) => {\n-                    self.consumed_or_mutated.1 = true;\n-                },\n-                _ => {},\n+        fn visit_place(&mut self, place: &mir::Place<'tcx>, ctx: PlaceContext, loc: mir::Location) {\n+            let local = place.local;\n+\n+            if local == self.cloned\n+                && !matches!(\n+                    ctx,\n+                    PlaceContext::MutatingUse(MutatingUseContext::Drop) | PlaceContext::NonUse(_)\n+                )\n+            {\n+                self.result.cloned_used = true;\n+                self.result.cloned_consume_or_mutate_loc = self.result.cloned_consume_or_mutate_loc.or_else(|| {\n+                    matches!(\n+                        ctx,\n+                        PlaceContext::NonMutatingUse(NonMutatingUseContext::Move)\n+                            | PlaceContext::MutatingUse(MutatingUseContext::Borrow)\n+                    )\n+                    .then(|| loc)\n+                });\n+            } else if local == self.clone {\n+                match ctx {\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Move)\n+                    | PlaceContext::MutatingUse(MutatingUseContext::Borrow) => {\n+                        self.result.clone_consumed_or_mutated = true;\n+                    },\n+                    _ => {},\n+                }\n             }\n         }\n     }\n+\n+    let init = CloneUsage {\n+        cloned_used: false,\n+        cloned_consume_or_mutate_loc: None,\n+        // Consider non-temporary clones consumed.\n+        // TODO: Actually check for mutation of non-temporaries.\n+        clone_consumed_or_mutated: mir.local_kind(clone) != mir::LocalKind::Temp,\n+    };\n+    traversal::ReversePostorder::new(mir, bb)\n+        .skip(1)\n+        .fold(init, |usage, (tbb, tdata)| {\n+            // Short-circuit\n+            if (usage.cloned_used && usage.clone_consumed_or_mutated) ||\n+                // Give up on loops\n+                tdata.terminator().successors().any(|s| *s == bb)\n+            {\n+                return CloneUsage {\n+                    cloned_used: true,\n+                    clone_consumed_or_mutated: true,\n+                    ..usage\n+                };\n+            }\n+\n+            let mut v = V {\n+                cloned,\n+                clone,\n+                result: usage,\n+            };\n+            v.visit_basic_block_data(tbb, tdata);\n+            v.result\n+        })\n }\n \n /// Determines liveness of each local purely based on `StorageLive`/`Dead`.\n@@ -547,7 +588,7 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n             // If the call returns something with lifetimes,\n             // let's conservatively assume the returned value contains lifetime of all the arguments.\n             // For example, given `let y: Foo<'a> = foo(x)`, `y` is considered to be a possible borrower of `x`.\n-            if ContainsRegion.visit_ty(&self.body.local_decls[*dest].ty).is_continue() {\n+            if ContainsRegion.visit_ty(self.body.local_decls[*dest].ty).is_continue() {\n                 return;\n             }\n \n@@ -623,4 +664,9 @@ impl PossibleBorrowerMap<'_, '_> {\n \n         self.bitset.0 == self.bitset.1\n     }\n+\n+    fn is_alive_at(&mut self, local: mir::Local, at: mir::Location) -> bool {\n+        self.maybe_live.seek_after_primary_effect(at);\n+        self.maybe_live.contains(local)\n+    }\n }"}, {"sha": "92921bedf4dffd1604bd9a05ddd3e66a5500dda8", "filename": "clippy_lints/src/redundant_closure_call.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_closure_call.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -111,10 +111,10 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClosureCall {\n \n                 fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n                     if_chain! {\n-                        if let hir::ExprKind::Call(ref closure, _) = expr.kind;\n-                        if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = closure.kind;\n-                        if self.path.segments[0].ident == path.segments[0].ident\n-                            && self.path.res == path.res;\n+                        if let hir::ExprKind::Call(closure, _) = expr.kind;\n+                        if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = closure.kind;\n+                        if self.path.segments[0].ident == path.segments[0].ident;\n+                        if self.path.res == path.res;\n                         then {\n                             self.count += 1;\n                         }\n@@ -133,14 +133,14 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClosureCall {\n \n         for w in block.stmts.windows(2) {\n             if_chain! {\n-                if let hir::StmtKind::Local(ref local) = w[0].kind;\n-                if let Option::Some(ref t) = local.init;\n+                if let hir::StmtKind::Local(local) = w[0].kind;\n+                if let Option::Some(t) = local.init;\n                 if let hir::ExprKind::Closure(..) = t.kind;\n                 if let hir::PatKind::Binding(_, _, ident, _) = local.pat.kind;\n-                if let hir::StmtKind::Semi(ref second) = w[1].kind;\n-                if let hir::ExprKind::Assign(_, ref call, _) = second.kind;\n-                if let hir::ExprKind::Call(ref closure, _) = call.kind;\n-                if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = closure.kind;\n+                if let hir::StmtKind::Semi(second) = w[1].kind;\n+                if let hir::ExprKind::Assign(_, call, _) = second.kind;\n+                if let hir::ExprKind::Call(closure, _) = call.kind;\n+                if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = closure.kind;\n                 if ident == path.segments[0].ident;\n                 if count_closure_usage(cx, block, path) == 1;\n                 then {"}, {"sha": "9c6cd7b4fa625f0200a16891a1ac4ea7331b22dd", "filename": "clippy_lints/src/redundant_slicing.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fredundant_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fredundant_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_slicing.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::ty::is_type_lang_item;\n+use clippy_utils::{get_parent_expr, in_macro};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, LangItem};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::{lint::in_external_macro, ty::TyS};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, LangItem, Mutability};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::TyS;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -40,26 +41,44 @@ declare_lint_pass!(RedundantSlicing => [REDUNDANT_SLICING]);\n \n impl LateLintPass<'_> for RedundantSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if in_external_macro(cx.sess(), expr.span) {\n+        if in_macro(expr.span) {\n             return;\n         }\n \n+        let ctxt = expr.span.ctxt();\n         if_chain! {\n-            if let ExprKind::AddrOf(_, _, addressee) = expr.kind;\n+            if let ExprKind::AddrOf(BorrowKind::Ref, mutability, addressee) = expr.kind;\n+            if addressee.span.ctxt() == ctxt;\n             if let ExprKind::Index(indexed, range) = addressee.kind;\n             if is_type_lang_item(cx, cx.typeck_results().expr_ty_adjusted(range), LangItem::RangeFull);\n             if TyS::same_type(cx.typeck_results().expr_ty(expr), cx.typeck_results().expr_ty(indexed));\n             then {\n                 let mut app = Applicability::MachineApplicable;\n-                let hint = snippet_with_applicability(cx, indexed.span, \"..\", &mut app).into_owned();\n+                let snip = snippet_with_context(cx, indexed.span, ctxt, \"..\", &mut app).0;\n+\n+                let (reborrow_str, help_str) = if mutability == Mutability::Mut {\n+                    // The slice was used to reborrow the mutable reference.\n+                    (\"&mut *\", \"reborrow the original value instead\")\n+                } else if matches!(\n+                    get_parent_expr(cx, expr),\n+                    Some(Expr {\n+                        kind: ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, _),\n+                        ..\n+                    })\n+                ) {\n+                    // The slice was used to make a temporary reference.\n+                    (\"&*\", \"reborrow the original value instead\")\n+                } else {\n+                    (\"\", \"use the original value instead\")\n+                };\n \n                 span_lint_and_sugg(\n                     cx,\n                     REDUNDANT_SLICING,\n                     expr.span,\n                     \"redundant slicing of the whole range\",\n-                    \"use the original slice instead\",\n-                    hint,\n+                    help_str,\n+                    format!(\"{}{}\", reborrow_str, snip),\n                     app,\n                 );\n             }"}, {"sha": "0cf4e0ce7fe225bc0400d100b80b844e50f98a2e", "filename": "clippy_lints/src/ref_option_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fref_option_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fref_option_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fref_option_ref.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -44,7 +44,7 @@ impl<'tcx> LateLintPass<'tcx> for RefOptionRef {\n             if let Some(def_id) = res.opt_def_id();\n \n             if cx.tcx.is_diagnostic_item(sym::option_type, def_id);\n-            if let Some(ref params) = last_path_segment(qpath).args ;\n+            if let Some(params) = last_path_segment(qpath).args ;\n             if !params.parenthesized;\n             if let Some(inner_ty) = params.args.iter().find_map(|arg| match arg {\n                 GenericArg::Type(inner_ty) => Some(inner_ty),"}, {"sha": "4b5306de58ecdc4e911a4f3c7a9b78929e730d15", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -60,7 +60,7 @@ impl_lint_pass!(Regex => [INVALID_REGEX, TRIVIAL_REGEX]);\n impl<'tcx> LateLintPass<'tcx> for Regex {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Call(ref fun, ref args) = expr.kind;\n+            if let ExprKind::Call(fun, args) = expr.kind;\n             if let ExprKind::Path(ref qpath) = fun.kind;\n             if args.len() == 1;\n             if let Some(def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n@@ -134,7 +134,7 @@ fn is_trivial_regex(s: &regex_syntax::hir::Hir) -> Option<&'static str> {\n \n fn check_set<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n     if_chain! {\n-        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref expr) = expr.kind;\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, expr) = expr.kind;\n         if let ExprKind::Array(exprs) = expr.kind;\n         then {\n             for expr in exprs {"}, {"sha": "560a5e7c9200aa0295a407b6fee9d6efe5dd7259", "filename": "clippy_lints/src/repeat_once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frepeat_once.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -45,10 +45,10 @@ impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n         if_chain! {\n             if let ExprKind::MethodCall(path, _, [receiver, count], _) = &expr.kind;\n             if path.ident.name == sym!(repeat);\n-            if let Some(Constant::Int(1)) = constant_context(cx, cx.typeck_results()).expr(&count);\n+            if let Some(Constant::Int(1)) = constant_context(cx, cx.typeck_results()).expr(count);\n             if !in_macro(receiver.span);\n             then {\n-                let ty = cx.typeck_results().expr_ty(&receiver).peel_refs();\n+                let ty = cx.typeck_results().expr_ty(receiver).peel_refs();\n                 if ty.is_str() {\n                     span_lint_and_sugg(\n                         cx,"}, {"sha": "af772cf4a145d30bb67aa50d648bc29a6c7d895d", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -102,7 +102,7 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n                         err.span_label(local.span, \"unnecessary `let` binding\");\n \n                         if let Some(mut snippet) = snippet_opt(cx, initexpr.span) {\n-                            if !cx.typeck_results().expr_adjustments(&retexpr).is_empty() {\n+                            if !cx.typeck_results().expr_adjustments(retexpr).is_empty() {\n                                 snippet.push_str(\" as _\");\n                             }\n                             err.multipart_suggestion(\n@@ -143,7 +143,7 @@ impl<'tcx> LateLintPass<'tcx> for Return {\n                 check_final_expr(cx, &body.value, Some(body.value.span), replacement)\n             },\n             FnKind::ItemFn(..) | FnKind::Method(..) => {\n-                if let ExprKind::Block(ref block, _) = body.value.kind {\n+                if let ExprKind::Block(block, _) = body.value.kind {\n                     check_block_return(cx, block);\n                 }\n             },\n@@ -160,7 +160,7 @@ fn check_block_return<'tcx>(cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n         check_final_expr(cx, expr, Some(expr.span), RetReplacement::Empty);\n     } else if let Some(stmt) = block.stmts.iter().last() {\n         match stmt.kind {\n-            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => {\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => {\n                 check_final_expr(cx, expr, Some(stmt.span), RetReplacement::Empty);\n             },\n             _ => (),\n@@ -192,11 +192,11 @@ fn check_final_expr<'tcx>(\n             }\n         },\n         // a whole block? check it!\n-        ExprKind::Block(ref block, _) => {\n+        ExprKind::Block(block, _) => {\n             check_block_return(cx, block);\n         },\n         ExprKind::If(_, then, else_clause_opt) => {\n-            if let ExprKind::Block(ref ifblock, _) = then.kind {\n+            if let ExprKind::Block(ifblock, _) = then.kind {\n                 check_block_return(cx, ifblock);\n             }\n             if let Some(else_clause) = else_clause_opt {\n@@ -207,16 +207,16 @@ fn check_final_expr<'tcx>(\n         // an if/if let expr, check both exprs\n         // note, if without else is going to be a type checking error anyways\n         // (except for unit type functions) so we don't match it\n-        ExprKind::Match(_, ref arms, source) => match source {\n+        ExprKind::Match(_, arms, source) => match source {\n             MatchSource::Normal => {\n                 for arm in arms.iter() {\n-                    check_final_expr(cx, &arm.body, Some(arm.body.span), RetReplacement::Block);\n+                    check_final_expr(cx, arm.body, Some(arm.body.span), RetReplacement::Block);\n                 }\n             },\n             MatchSource::IfLetDesugar {\n                 contains_else_clause: true,\n             } => {\n-                if let ExprKind::Block(ref ifblock, _) = arms[0].body.kind {\n+                if let ExprKind::Block(ifblock, _) = arms[0].body.kind {\n                     check_block_return(cx, ifblock);\n                 }\n                 check_final_expr(cx, arms[1].body, None, RetReplacement::Empty);"}, {"sha": "553987a426b57c2243eef297e56f220ef3000da6", "filename": "clippy_lints/src/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -51,7 +51,7 @@ impl LateLintPass<'_> for SemicolonIfNothingReturned {\n                     return;\n                 }\n \n-                let sugg = sugg::Sugg::hir_with_macro_callsite(cx, &expr, \"..\");\n+                let sugg = sugg::Sugg::hir_with_macro_callsite(cx, expr, \"..\");\n                 let suggestion = format!(\"{0};\", sugg);\n                 span_lint_and_sugg(\n                     cx,"}, {"sha": "d6101bd5e36a2d53744cc224acf5436e82add96c", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -130,12 +130,12 @@ fn check_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'_>, bindings: &\n     let len = bindings.len();\n     for stmt in block.stmts {\n         match stmt.kind {\n-            StmtKind::Local(ref local) => check_local(cx, local, bindings),\n-            StmtKind::Expr(ref e) | StmtKind::Semi(ref e) => check_expr(cx, e, bindings),\n+            StmtKind::Local(local) => check_local(cx, local, bindings),\n+            StmtKind::Expr(e) | StmtKind::Semi(e) => check_expr(cx, e, bindings),\n             StmtKind::Item(..) => {},\n         }\n     }\n-    if let Some(ref o) = block.expr {\n+    if let Some(o) = block.expr {\n         check_expr(cx, o, bindings);\n     }\n     bindings.truncate(len);\n@@ -149,16 +149,16 @@ fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &\n         return;\n     }\n     let Local {\n-        ref pat,\n+        pat,\n         ref ty,\n         ref init,\n         span,\n         ..\n     } = *local;\n-    if let Some(ref t) = *ty {\n+    if let Some(t) = *ty {\n         check_ty(cx, t, bindings)\n     }\n-    if let Some(ref o) = *init {\n+    if let Some(o) = *init {\n         check_expr(cx, o, bindings);\n         check_pat(cx, pat, Some(o), span, bindings);\n     } else {\n@@ -196,34 +196,34 @@ fn check_pat<'tcx>(\n                     bindings.push((name, ident.span));\n                 }\n             }\n-            if let Some(ref p) = *inner {\n+            if let Some(p) = *inner {\n                 check_pat(cx, p, init, span, bindings);\n             }\n         },\n         PatKind::Struct(_, pfields, _) => {\n             if let Some(init_struct) = init {\n-                if let ExprKind::Struct(_, ref efields, _) = init_struct.kind {\n+                if let ExprKind::Struct(_, efields, _) = init_struct.kind {\n                     for field in pfields {\n                         let name = field.ident.name;\n                         let efield = efields\n                             .iter()\n                             .find_map(|f| if f.ident.name == name { Some(&*f.expr) } else { None });\n-                        check_pat(cx, &field.pat, efield, span, bindings);\n+                        check_pat(cx, field.pat, efield, span, bindings);\n                     }\n                 } else {\n                     for field in pfields {\n-                        check_pat(cx, &field.pat, init, span, bindings);\n+                        check_pat(cx, field.pat, init, span, bindings);\n                     }\n                 }\n             } else {\n                 for field in pfields {\n-                    check_pat(cx, &field.pat, None, span, bindings);\n+                    check_pat(cx, field.pat, None, span, bindings);\n                 }\n             }\n         },\n         PatKind::Tuple(inner, _) => {\n             if let Some(init_tup) = init {\n-                if let ExprKind::Tup(ref tup) = init_tup.kind {\n+                if let ExprKind::Tup(tup) = init_tup.kind {\n                     for (i, p) in inner.iter().enumerate() {\n                         check_pat(cx, p, Some(&tup[i]), p.span, bindings);\n                     }\n@@ -238,18 +238,18 @@ fn check_pat<'tcx>(\n                 }\n             }\n         },\n-        PatKind::Box(ref inner) => {\n+        PatKind::Box(inner) => {\n             if let Some(initp) = init {\n-                if let ExprKind::Box(ref inner_init) = initp.kind {\n-                    check_pat(cx, inner, Some(&**inner_init), span, bindings);\n+                if let ExprKind::Box(inner_init) = initp.kind {\n+                    check_pat(cx, inner, Some(inner_init), span, bindings);\n                 } else {\n                     check_pat(cx, inner, init, span, bindings);\n                 }\n             } else {\n                 check_pat(cx, inner, init, span, bindings);\n             }\n         },\n-        PatKind::Ref(ref inner, _) => check_pat(cx, inner, init, span, bindings),\n+        PatKind::Ref(inner, _) => check_pat(cx, inner, init, span, bindings),\n         // PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n         _ => (),\n     }\n@@ -323,30 +323,29 @@ fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut\n         return;\n     }\n     match expr.kind {\n-        ExprKind::Unary(_, ref e)\n-        | ExprKind::Field(ref e, _)\n-        | ExprKind::AddrOf(_, _, ref e)\n-        | ExprKind::Box(ref e) => check_expr(cx, e, bindings),\n-        ExprKind::Block(ref block, _) | ExprKind::Loop(ref block, ..) => check_block(cx, block, bindings),\n+        ExprKind::Unary(_, e) | ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) | ExprKind::Box(e) => {\n+            check_expr(cx, e, bindings)\n+        },\n+        ExprKind::Block(block, _) | ExprKind::Loop(block, ..) => check_block(cx, block, bindings),\n         // ExprKind::Call\n         // ExprKind::MethodCall\n         ExprKind::Array(v) | ExprKind::Tup(v) => {\n             for e in v {\n                 check_expr(cx, e, bindings)\n             }\n         },\n-        ExprKind::If(ref cond, ref then, ref otherwise) => {\n+        ExprKind::If(cond, then, ref otherwise) => {\n             check_expr(cx, cond, bindings);\n-            check_expr(cx, &**then, bindings);\n-            if let Some(ref o) = *otherwise {\n+            check_expr(cx, then, bindings);\n+            if let Some(o) = *otherwise {\n                 check_expr(cx, o, bindings);\n             }\n         },\n-        ExprKind::Match(ref init, arms, _) => {\n+        ExprKind::Match(init, arms, _) => {\n             check_expr(cx, init, bindings);\n             let len = bindings.len();\n             for arm in arms {\n-                check_pat(cx, &arm.pat, Some(&**init), arm.pat.span, bindings);\n+                check_pat(cx, arm.pat, Some(init), arm.pat.span, bindings);\n                 // This is ugly, but needed to get the right type\n                 if let Some(ref guard) = arm.guard {\n                     match guard {\n@@ -357,7 +356,7 @@ fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut\n                         },\n                     }\n                 }\n-                check_expr(cx, &arm.body, bindings);\n+                check_expr(cx, arm.body, bindings);\n                 bindings.truncate(len);\n             }\n         },\n@@ -367,14 +366,12 @@ fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut\n \n fn check_ty<'tcx>(cx: &LateContext<'tcx>, ty: &'tcx Ty<'_>, bindings: &mut Vec<(Symbol, Span)>) {\n     match ty.kind {\n-        TyKind::Slice(ref sty) => check_ty(cx, sty, bindings),\n-        TyKind::Array(ref fty, ref anon_const) => {\n+        TyKind::Slice(sty) => check_ty(cx, sty, bindings),\n+        TyKind::Array(fty, ref anon_const) => {\n             check_ty(cx, fty, bindings);\n             check_expr(cx, &cx.tcx.hir().body(anon_const.body).value, bindings);\n         },\n-        TyKind::Ptr(MutTy { ty: ref mty, .. }) | TyKind::Rptr(_, MutTy { ty: ref mty, .. }) => {\n-            check_ty(cx, mty, bindings)\n-        },\n+        TyKind::Ptr(MutTy { ty: mty, .. }) | TyKind::Rptr(_, MutTy { ty: mty, .. }) => check_ty(cx, mty, bindings),\n         TyKind::Tup(tup) => {\n             for t in tup {\n                 check_ty(cx, t, bindings)\n@@ -387,12 +384,12 @@ fn check_ty<'tcx>(cx: &LateContext<'tcx>, ty: &'tcx Ty<'_>, bindings: &mut Vec<(\n \n fn is_self_shadow(name: Symbol, expr: &Expr<'_>) -> bool {\n     match expr.kind {\n-        ExprKind::Box(ref inner) | ExprKind::AddrOf(_, _, ref inner) => is_self_shadow(name, inner),\n-        ExprKind::Block(ref block, _) => {\n+        ExprKind::Box(inner) | ExprKind::AddrOf(_, _, inner) => is_self_shadow(name, inner),\n+        ExprKind::Block(block, _) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |e| is_self_shadow(name, e))\n         },\n-        ExprKind::Unary(op, ref inner) => (UnOp::Deref == op) && is_self_shadow(name, inner),\n-        ExprKind::Path(QPath::Resolved(_, ref path)) => path_eq_name(name, path),\n+        ExprKind::Unary(op, inner) => (UnOp::Deref == op) && is_self_shadow(name, inner),\n+        ExprKind::Path(QPath::Resolved(_, path)) => path_eq_name(name, path),\n         _ => false,\n     }\n }"}, {"sha": "8cf89ae456ee8a3e6ae9da78966749df566b00b6", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -70,14 +70,14 @@ impl<'tcx> LateLintPass<'tcx> for SlowVectorInit {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // Matches initialization on reassignements. For example: `vec = Vec::with_capacity(100)`\n         if_chain! {\n-            if let ExprKind::Assign(ref left, ref right, _) = expr.kind;\n+            if let ExprKind::Assign(left, right, _) = expr.kind;\n \n             // Extract variable name\n-            if let ExprKind::Path(QPath::Resolved(_, ref path)) = left.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, path)) = left.kind;\n             if let Some(variable_name) = path.segments.get(0);\n \n             // Extract len argument\n-            if let Some(ref len_arg) = Self::is_vec_with_capacity(right);\n+            if let Some(len_arg) = Self::is_vec_with_capacity(right);\n \n             then {\n                 let vi = VecAllocation {\n@@ -94,10 +94,10 @@ impl<'tcx> LateLintPass<'tcx> for SlowVectorInit {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         // Matches statements which initializes vectors. For example: `let mut vec = Vec::with_capacity(10)`\n         if_chain! {\n-            if let StmtKind::Local(ref local) = stmt.kind;\n+            if let StmtKind::Local(local) = stmt.kind;\n             if let PatKind::Binding(BindingAnnotation::Mutable, .., variable_name, None) = local.pat.kind;\n-            if let Some(ref init) = local.init;\n-            if let Some(ref len_arg) = Self::is_vec_with_capacity(init);\n+            if let Some(init) = local.init;\n+            if let Some(len_arg) = Self::is_vec_with_capacity(init);\n \n             then {\n                 let vi = VecAllocation {\n@@ -117,7 +117,7 @@ impl SlowVectorInit {\n     /// of the first argument of `with_capacity` call if it matches or `None` if it does not.\n     fn is_vec_with_capacity<'tcx>(expr: &Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n         if_chain! {\n-            if let ExprKind::Call(ref func, ref args) = expr.kind;\n+            if let ExprKind::Call(func, args) = expr.kind;\n             if let ExprKind::Path(ref path) = func.kind;\n             if match_qpath(path, &[\"Vec\", \"with_capacity\"]);\n             if args.len() == 1;\n@@ -208,11 +208,11 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_extend_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n             if let ExprKind::Path(ref qpath_subj) = args[0].kind;\n-            if match_qpath(&qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n+            if match_qpath(qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n             if path.ident.name == sym!(extend);\n-            if let Some(ref extend_arg) = args.get(1);\n+            if let Some(extend_arg) = args.get(1);\n             if self.is_repeat_take(extend_arg);\n \n             then {\n@@ -225,11 +225,11 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_resize_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n             if let ExprKind::Path(ref qpath_subj) = args[0].kind;\n-            if match_qpath(&qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n+            if match_qpath(qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n             if path.ident.name == sym!(resize);\n-            if let (Some(ref len_arg), Some(fill_arg)) = (args.get(1), args.get(2));\n+            if let (Some(len_arg), Some(fill_arg)) = (args.get(1), args.get(2));\n \n             // Check that is filled with 0\n             if let ExprKind::Lit(ref lit) = fill_arg.kind;\n@@ -247,15 +247,15 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     /// Returns `true` if give expression is `repeat(0).take(...)`\n     fn is_repeat_take(&self, expr: &Expr<'_>) -> bool {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref take_path, _, ref take_args, _) = expr.kind;\n+            if let ExprKind::MethodCall(take_path, _, take_args, _) = expr.kind;\n             if take_path.ident.name == sym!(take);\n \n             // Check that take is applied to `repeat(0)`\n-            if let Some(ref repeat_expr) = take_args.get(0);\n+            if let Some(repeat_expr) = take_args.get(0);\n             if Self::is_repeat_zero(repeat_expr);\n \n             // Check that len expression is equals to `with_capacity` expression\n-            if let Some(ref len_arg) = take_args.get(1);\n+            if let Some(len_arg) = take_args.get(1);\n             if SpanlessEq::new(self.cx).eq_expr(len_arg, self.vec_alloc.len_expr);\n \n             then {\n@@ -269,10 +269,10 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     /// Returns `true` if given expression is `repeat(0)`\n     fn is_repeat_zero(expr: &Expr<'_>) -> bool {\n         if_chain! {\n-            if let ExprKind::Call(ref fn_expr, ref repeat_args) = expr.kind;\n+            if let ExprKind::Call(fn_expr, repeat_args) = expr.kind;\n             if let ExprKind::Path(ref qpath_repeat) = fn_expr.kind;\n-            if match_qpath(&qpath_repeat, &[\"repeat\"]);\n-            if let Some(ref repeat_arg) = repeat_args.get(0);\n+            if match_qpath(qpath_repeat, &[\"repeat\"]);\n+            if let Some(repeat_arg) = repeat_args.get(0);\n             if let ExprKind::Lit(ref lit) = repeat_arg.kind;\n             if let LitKind::Int(0, _) = lit.node;\n \n@@ -291,7 +291,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VectorInitializationVisitor<'a, 'tcx> {\n     fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n         if self.initialization_found {\n             match stmt.kind {\n-                StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => {\n+                StmtKind::Expr(expr) | StmtKind::Semi(expr) => {\n                     self.search_slow_extend_filling(expr);\n                     self.search_slow_resize_filling(expr);\n                 },\n@@ -306,7 +306,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VectorInitializationVisitor<'a, 'tcx> {\n \n     fn visit_block(&mut self, block: &'tcx Block<'_>) {\n         if self.initialization_found {\n-            if let Some(ref s) = block.stmts.get(0) {\n+            if let Some(s) = block.stmts.get(0) {\n                 self.visit_stmt(s)\n             }\n "}, {"sha": "9d91b53e1bbc1ad4b4827198f2380379e596707a", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -119,15 +119,15 @@ impl<'tcx> LateLintPass<'tcx> for StringAdd {\n             Spanned {\n                 node: BinOpKind::Add, ..\n             },\n-            ref left,\n+            left,\n             _,\n         ) = e.kind\n         {\n             if is_string(cx, left) {\n                 if !is_allowed(cx, STRING_ADD_ASSIGN, e.hir_id) {\n                     let parent = get_parent_expr(cx, e);\n                     if let Some(p) = parent {\n-                        if let ExprKind::Assign(ref target, _, _) = p.kind {\n+                        if let ExprKind::Assign(target, _, _) = p.kind {\n                             // avoid duplicate matches\n                             if SpanlessEq::new(cx).eq_expr(target, left) {\n                                 return;\n@@ -142,7 +142,7 @@ impl<'tcx> LateLintPass<'tcx> for StringAdd {\n                     \"you added something to a string. Consider using `String::push_str()` instead\",\n                 );\n             }\n-        } else if let ExprKind::Assign(ref target, ref src, _) = e.kind {\n+        } else if let ExprKind::Assign(target, src, _) = e.kind {\n             if is_string(cx, target) && is_add(cx, src, target) {\n                 span_lint(\n                     cx,\n@@ -166,10 +166,10 @@ fn is_add(cx: &LateContext<'_>, src: &Expr<'_>, target: &Expr<'_>) -> bool {\n             Spanned {\n                 node: BinOpKind::Add, ..\n             },\n-            ref left,\n+            left,\n             _,\n         ) => SpanlessEq::new(cx).eq_expr(target, left),\n-        ExprKind::Block(ref block, _) => {\n+        ExprKind::Block(block, _) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| is_add(cx, expr, target))\n         },\n         _ => false,\n@@ -210,8 +210,8 @@ impl<'tcx> LateLintPass<'tcx> for StringLitAsBytes {\n             if let Some(args) = match_function_call(cx, e, &paths::STR_FROM_UTF8);\n \n             // Find string::as_bytes\n-            if let ExprKind::AddrOf(BorrowKind::Ref, _, ref args) = args[0].kind;\n-            if let ExprKind::Index(ref left, ref right) = args.kind;\n+            if let ExprKind::AddrOf(BorrowKind::Ref, _, args) = args[0].kind;\n+            if let ExprKind::Index(left, right) = args.kind;\n             let (method_names, expressions, _) = method_calls(left, 1);\n             if method_names.len() == 1;\n             if expressions.len() == 1;"}, {"sha": "cb2237e531262fb95d2975e7515782749b383f51", "filename": "clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -225,7 +225,7 @@ fn attempt_to_emit_no_difference_lint(\n                     emit_suggestion(\n                         cx,\n                         binop.span,\n-                        replace_left_sugg(cx, &binop, &sugg, &mut applicability),\n+                        replace_left_sugg(cx, binop, &sugg, &mut applicability),\n                         applicability,\n                     );\n                     return;\n@@ -247,7 +247,7 @@ fn attempt_to_emit_no_difference_lint(\n                     emit_suggestion(\n                         cx,\n                         binop.span,\n-                        replace_right_sugg(cx, &binop, &sugg, &mut applicability),\n+                        replace_right_sugg(cx, binop, &sugg, &mut applicability),\n                         applicability,\n                     );\n                     return;\n@@ -276,8 +276,8 @@ fn ident_swap_sugg(\n     location: IdentLocation,\n     applicability: &mut Applicability,\n ) -> Option<String> {\n-    let left_ident = get_ident(&binop.left, location)?;\n-    let right_ident = get_ident(&binop.right, location)?;\n+    let left_ident = get_ident(binop.left, location)?;\n+    let right_ident = get_ident(binop.right, location)?;\n \n     let sugg = match (\n         paired_identifiers.contains(&left_ident),\n@@ -293,24 +293,22 @@ fn ident_swap_sugg(\n             // ends up duplicating a clause, the `logic_bug` lint\n             // should catch it.\n \n-            let right_suggestion =\n-                suggestion_with_swapped_ident(cx, &binop.right, location, left_ident, applicability)?;\n+            let right_suggestion = suggestion_with_swapped_ident(cx, binop.right, location, left_ident, applicability)?;\n \n             replace_right_sugg(cx, binop, &right_suggestion, applicability)\n         },\n         (false, true) => {\n             // We haven't seen a pair involving the left one, so\n             // it's probably what is wanted.\n \n-            let right_suggestion =\n-                suggestion_with_swapped_ident(cx, &binop.right, location, left_ident, applicability)?;\n+            let right_suggestion = suggestion_with_swapped_ident(cx, binop.right, location, left_ident, applicability)?;\n \n             replace_right_sugg(cx, binop, &right_suggestion, applicability)\n         },\n         (true, false) => {\n             // We haven't seen a pair involving the right one, so\n             // it's probably what is wanted.\n-            let left_suggestion = suggestion_with_swapped_ident(cx, &binop.left, location, right_ident, applicability)?;\n+            let left_suggestion = suggestion_with_swapped_ident(cx, binop.left, location, right_ident, applicability)?;\n \n             replace_left_sugg(cx, binop, &left_suggestion, applicability)\n         },"}, {"sha": "512abde11a63433a827f797f95002b6489ac6a20", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -68,14 +68,13 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n \n             // Check for more than one binary operation in the implemented function\n             // Linting when multiple operations are involved can result in false positives\n+            let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id);\n             if_chain! {\n-                let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id);\n                 if let hir::Node::ImplItem(impl_item) = cx.tcx.hir().get(parent_fn);\n                 if let hir::ImplItemKind::Fn(_, body_id) = impl_item.kind;\n-                let body = cx.tcx.hir().body(body_id);\n-                let mut visitor = BinaryExprVisitor { nb_binops: 0 };\n-\n                 then {\n+                    let body = cx.tcx.hir().body(body_id);\n+                    let mut visitor = BinaryExprVisitor { nb_binops: 0 };\n                     walk_expr(&mut visitor, &body.value);\n                     if visitor.nb_binops > 1 {\n                         return;"}, {"sha": "19967e2c9701499dba553101ca583e474f08bd75", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -78,26 +78,26 @@ fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n     for w in block.stmts.windows(3) {\n         if_chain! {\n             // let t = foo();\n-            if let StmtKind::Local(ref tmp) = w[0].kind;\n-            if let Some(ref tmp_init) = tmp.init;\n+            if let StmtKind::Local(tmp) = w[0].kind;\n+            if let Some(tmp_init) = tmp.init;\n             if let PatKind::Binding(.., ident, None) = tmp.pat.kind;\n \n             // foo() = bar();\n-            if let StmtKind::Semi(ref first) = w[1].kind;\n-            if let ExprKind::Assign(ref lhs1, ref rhs1, _) = first.kind;\n+            if let StmtKind::Semi(first) = w[1].kind;\n+            if let ExprKind::Assign(lhs1, rhs1, _) = first.kind;\n \n             // bar() = t;\n-            if let StmtKind::Semi(ref second) = w[2].kind;\n-            if let ExprKind::Assign(ref lhs2, ref rhs2, _) = second.kind;\n-            if let ExprKind::Path(QPath::Resolved(None, ref rhs2)) = rhs2.kind;\n+            if let StmtKind::Semi(second) = w[2].kind;\n+            if let ExprKind::Assign(lhs2, rhs2, _) = second.kind;\n+            if let ExprKind::Path(QPath::Resolved(None, rhs2)) = rhs2.kind;\n             if rhs2.segments.len() == 1;\n \n             if ident.name == rhs2.segments[0].ident.name;\n             if eq_expr_value(cx, tmp_init, lhs1);\n             if eq_expr_value(cx, rhs1, lhs2);\n             then {\n-                if let ExprKind::Field(ref lhs1, _) = lhs1.kind {\n-                    if let ExprKind::Field(ref lhs2, _) = lhs2.kind {\n+                if let ExprKind::Field(lhs1, _) = lhs1.kind {\n+                    if let ExprKind::Field(lhs2, _) = lhs2.kind {\n                         if lhs1.hir_id.owner == lhs2.hir_id.owner {\n                             return;\n                         }\n@@ -192,8 +192,8 @@ enum Slice<'a> {\n \n /// Checks if both expressions are index operations into \"slice-like\" types.\n fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<'_>) -> Slice<'a> {\n-    if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.kind {\n-        if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.kind {\n+    if let ExprKind::Index(lhs1, idx1) = lhs1.kind {\n+        if let ExprKind::Index(lhs2, idx2) = lhs2.kind {\n             if eq_expr_value(cx, lhs1, lhs2) {\n                 let ty = cx.typeck_results().expr_ty(lhs1).peel_refs();\n \n@@ -217,11 +217,11 @@ fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<\n fn check_suspicious_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n     for w in block.stmts.windows(2) {\n         if_chain! {\n-            if let StmtKind::Semi(ref first) = w[0].kind;\n-            if let StmtKind::Semi(ref second) = w[1].kind;\n+            if let StmtKind::Semi(first) = w[0].kind;\n+            if let StmtKind::Semi(second) = w[1].kind;\n             if !differing_macro_contexts(first.span, second.span);\n-            if let ExprKind::Assign(ref lhs0, ref rhs0, _) = first.kind;\n-            if let ExprKind::Assign(ref lhs1, ref rhs1, _) = second.kind;\n+            if let ExprKind::Assign(lhs0, rhs0, _) = first.kind;\n+            if let ExprKind::Assign(lhs1, rhs1, _) = second.kind;\n             if eq_expr_value(cx, lhs0, rhs1);\n             if eq_expr_value(cx, lhs1, rhs0);\n             then {"}, {"sha": "a0492a88f912ad9229560c38fd1a0796b431702c", "filename": "clippy_lints/src/tabs_in_doc_comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftabs_in_doc_comments.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -86,7 +86,7 @@ impl TabsInDocComments {\n \n impl EarlyLintPass for TabsInDocComments {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attribute: &ast::Attribute) {\n-        Self::warn_if_tabs_in_doc(cx, &attribute);\n+        Self::warn_if_tabs_in_doc(cx, attribute);\n     }\n }\n "}, {"sha": "ae05a8da37bc93fab9c2e6030ead26bf225340b5", "filename": "clippy_lints/src/to_string_in_display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -92,7 +92,7 @@ impl LateLintPass<'_> for ToStringInDisplay {\n         if_chain! {\n             if self.in_display_impl;\n             if let Some(self_hir_id) = self.self_hir_id;\n-            if let ExprKind::MethodCall(ref path, _, args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n             if path.ident.name == sym!(to_string);\n             if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n             if is_diagnostic_assoc_item(cx, expr_def_id, sym::ToString);"}, {"sha": "b0589b0512ef5cfc002bae4a198ce27770f7abb6", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -107,7 +107,7 @@ impl TraitBounds {\n                 if let WherePredicate::BoundPredicate(ref p) = bound;\n                 if p.bounds.len() as u64 <= self.max_trait_bounds;\n                 if !in_macro(p.span);\n-                let h = hash(&p.bounded_ty);\n+                let h = hash(p.bounded_ty);\n                 if let Some(ref v) = map.insert(h, p.bounds.iter().collect::<Vec<_>>());\n \n                 then {\n@@ -170,7 +170,7 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n         if_chain! {\n             if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n             if !in_macro(bound_predicate.span);\n-            if let TyKind::Path(QPath::Resolved(_, Path { ref segments, .. })) = bound_predicate.bounded_ty.kind;\n+            if let TyKind::Path(QPath::Resolved(_, Path { segments, .. })) = bound_predicate.bounded_ty.kind;\n             if let Some(segment) = segments.first();\n             if let Some(trait_resolutions_direct) = map.get(&segment.ident);\n             then {"}, {"sha": "86ac916df6cba743262ab8b90298e02e8c858233", "filename": "clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -325,7 +325,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n     #[allow(clippy::similar_names, clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Call(ref path_expr, ref args) = e.kind;\n+            if let ExprKind::Call(path_expr, args) = e.kind;\n             if let ExprKind::Path(ref qpath) = path_expr.kind;\n             if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::TRANSMUTE);"}, {"sha": "3aa3c393ba57cce3a8d26a402683405ba607f099", "filename": "clippy_lints/src/transmute/transmute_float_to_int.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -30,16 +30,16 @@ pub(super) fn check<'tcx>(\n                     let mut arg = sugg::Sugg::hir(cx, expr, \"..\");\n \n                     if let ExprKind::Unary(UnOp::Neg, inner_expr) = &expr.kind {\n-                        expr = &inner_expr;\n+                        expr = inner_expr;\n                     }\n \n                     if_chain! {\n                         // if the expression is a float literal and it is unsuffixed then\n                         // add a suffix so the suggestion is valid and unambiguous\n-                        let op = format!(\"{}{}\", arg, float_ty.name_str()).into();\n                         if let ExprKind::Lit(lit) = &expr.kind;\n                         if let ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) = lit.node;\n                         then {\n+                            let op = format!(\"{}{}\", arg, float_ty.name_str()).into();\n                             match arg {\n                                 sugg::Sugg::MaybeParen(_) => arg = sugg::Sugg::MaybeParen(op),\n                                 _ => arg = sugg::Sugg::NonParen(op)"}, {"sha": "f359b606e4548b1736876e4fc3074ed6ace86ff5", "filename": "clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -16,7 +16,7 @@ use rustc_typeck::check::{cast::CastCheck, FnCtxt, Inherited};\n pub(super) fn get_type_snippet(cx: &LateContext<'_>, path: &QPath<'_>, to_ref_ty: Ty<'_>) -> String {\n     let seg = last_path_segment(path);\n     if_chain! {\n-        if let Some(ref params) = seg.args;\n+        if let Some(params) = seg.args;\n         if !params.parenthesized;\n         if let Some(to_ty) = params.args.iter().filter_map(|arg| match arg {\n             GenericArg::Type(ty) => Some(ty),"}, {"sha": "0be05d3e0cf3f2a1304581516a7026e08259a1bb", "filename": "clippy_lints/src/transmuting_null.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -37,7 +37,7 @@ impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n         }\n \n         if_chain! {\n-            if let ExprKind::Call(ref func, ref args) = expr.kind;\n+            if let ExprKind::Call(func, args) = expr.kind;\n             if let ExprKind::Path(ref path) = func.kind;\n             if match_qpath(path, &paths::STD_MEM_TRANSMUTE);\n             if args.len() == 1;\n@@ -58,7 +58,7 @@ impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n                 // Catching:\n                 // `std::mem::transmute(0 as *const i32)`\n                 if_chain! {\n-                    if let ExprKind::Cast(ref inner_expr, ref _cast_ty) = args[0].kind;\n+                    if let ExprKind::Cast(inner_expr, _cast_ty) = args[0].kind;\n                     if let ExprKind::Lit(ref lit) = inner_expr.kind;\n                     if let LitKind::Int(0, _) = lit.node;\n                     then {\n@@ -69,7 +69,7 @@ impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n                 // Catching:\n                 // `std::mem::transmute(std::ptr::null::<i32>())`\n                 if_chain! {\n-                    if let ExprKind::Call(ref func1, ref args1) = args[0].kind;\n+                    if let ExprKind::Call(func1, args1) = args[0].kind;\n                     if let ExprKind::Path(ref path1) = func1.kind;\n                     if match_qpath(path1, &paths::STD_PTR_NULL);\n                     if args1.is_empty();"}, {"sha": "23a1953ffaceb8715200c0ec8d2c2c400e295df6", "filename": "clippy_lints/src/try_err.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -60,13 +60,13 @@ impl<'tcx> LateLintPass<'tcx> for TryErr {\n         // };\n         if_chain! {\n             if !in_external_macro(cx.tcx.sess, expr.span);\n-            if let ExprKind::Match(ref match_arg, _, MatchSource::TryDesugar) = expr.kind;\n-            if let ExprKind::Call(ref match_fun, ref try_args) = match_arg.kind;\n+            if let ExprKind::Match(match_arg, _, MatchSource::TryDesugar) = expr.kind;\n+            if let ExprKind::Call(match_fun, try_args) = match_arg.kind;\n             if let ExprKind::Path(ref match_fun_path) = match_fun.kind;\n             if matches!(match_fun_path, QPath::LangItem(LangItem::TryIntoResult, _));\n-            if let Some(ref try_arg) = try_args.get(0);\n-            if let ExprKind::Call(ref err_fun, ref err_args) = try_arg.kind;\n-            if let Some(ref err_arg) = err_args.get(0);\n+            if let Some(try_arg) = try_args.get(0);\n+            if let ExprKind::Call(err_fun, err_args) = try_arg.kind;\n+            if let Some(err_arg) = err_args.get(0);\n             if let ExprKind::Path(ref err_fun_path) = err_fun.kind;\n             if match_qpath(err_fun_path, &paths::RESULT_ERR);\n             if let Some(return_ty) = find_return_type(cx, &expr.kind);\n@@ -123,9 +123,9 @@ impl<'tcx> LateLintPass<'tcx> for TryErr {\n \n /// Finds function return type by examining return expressions in match arms.\n fn find_return_type<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx ExprKind<'_>) -> Option<Ty<'tcx>> {\n-    if let ExprKind::Match(_, ref arms, MatchSource::TryDesugar) = expr {\n+    if let ExprKind::Match(_, arms, MatchSource::TryDesugar) = expr {\n         for arm in arms.iter() {\n-            if let ExprKind::Ret(Some(ref ret)) = arm.body.kind {\n+            if let ExprKind::Ret(Some(ret)) = arm.body.kind {\n                 return Some(cx.typeck_results().expr_ty(ret));\n             }\n         }\n@@ -138,9 +138,8 @@ fn result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'t\n     if_chain! {\n         if let ty::Adt(_, subst) = ty.kind();\n         if is_type_diagnostic_item(cx, ty, sym::result_type);\n-        let err_ty = subst.type_at(1);\n         then {\n-            Some(err_ty)\n+            Some(subst.type_at(1))\n         } else {\n             None\n         }\n@@ -156,10 +155,8 @@ fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<\n \n         if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n         if cx.tcx.is_diagnostic_item(sym::result_type, ready_def.did);\n-        let err_ty = ready_subst.type_at(1);\n-\n         then {\n-            Some(err_ty)\n+            Some(ready_subst.type_at(1))\n         } else {\n             None\n         }\n@@ -179,10 +176,8 @@ fn poll_option_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) ->\n \n         if let ty::Adt(some_def, some_subst) = some_ty.kind();\n         if cx.tcx.is_diagnostic_item(sym::result_type, some_def.did);\n-        let err_ty = some_subst.type_at(1);\n-\n         then {\n-            Some(err_ty)\n+            Some(some_subst.type_at(1))\n         } else {\n             None\n         }"}, {"sha": "1425d8f3f37edf1e9a62f66ece489bfbbc8f06fe", "filename": "clippy_lints/src/types/borrowed_box.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -19,9 +19,9 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, lt: &Lifetime, m\n             if_chain! {\n                 if let Some(def_id) = def.opt_def_id();\n                 if Some(def_id) == cx.tcx.lang_items().owned_box();\n-                if let QPath::Resolved(None, ref path) = *qpath;\n+                if let QPath::Resolved(None, path) = *qpath;\n                 if let [ref bx] = *path.segments;\n-                if let Some(ref params) = bx.args;\n+                if let Some(params) = bx.args;\n                 if !params.parenthesized;\n                 if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n                     GenericArg::Type(ty) => Some(ty),\n@@ -86,11 +86,11 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, lt: &Lifetime, m\n // Returns true if given type is `Any` trait.\n fn is_any_trait(t: &hir::Ty<'_>) -> bool {\n     if_chain! {\n-        if let TyKind::TraitObject(ref traits, ..) = t.kind;\n+        if let TyKind::TraitObject(traits, ..) = t.kind;\n         if !traits.is_empty();\n         // Only Send/Sync can be used as additional traits, so it is enough to\n         // check only the first trait.\n-        if match_path(&traits[0].trait_ref.path, &paths::ANY_TRAIT);\n+        if match_path(traits[0].trait_ref.path, &paths::ANY_TRAIT);\n         then {\n             return true;\n         }"}, {"sha": "d9b47a699dc3cc4150b3bb85eb2e32153527183e", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 124, "deletions": 951, "changes": 1075, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,43 +1,22 @@\n-#![allow(rustc::default_hash_types)]\n-\n mod borrowed_box;\n mod box_vec;\n mod linked_list;\n mod option_option;\n mod rc_buffer;\n mod redundant_allocation;\n+mod type_complexity;\n mod utils;\n mod vec_box;\n \n-use std::borrow::Cow;\n-use std::cmp::Ordering;\n-use std::collections::BTreeMap;\n-\n-use clippy_utils::diagnostics::{multispan_sugg, span_lint, span_lint_and_help, span_lint_and_then};\n-use clippy_utils::source::{snippet, snippet_opt};\n-use clippy_utils::ty::{is_isize_or_usize, is_type_diagnostic_item};\n-use if_chain::if_chain;\n-use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n-    BinOpKind, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem,\n-    ImplItemKind, Item, ItemKind, Local, MutTy, QPath, TraitFn, TraitItem, TraitItemKind, TyKind,\n+    Body, FnDecl, FnRetTy, GenericArg, HirId, ImplItem, ImplItemKind, Item, ItemKind, Local, MutTy, QPath, TraitItem,\n+    TraitItemKind, TyKind,\n };\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::hir::map::Map;\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, IntTy, Ty, TyS, TypeckResults, UintTy};\n-use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::sym;\n-use rustc_target::abi::LayoutOf;\n-use rustc_target::spec::abi::Abi;\n-use rustc_typeck::hir_ty_to_ty;\n-\n-use crate::consts::{constant, Constant};\n-use clippy_utils::paths;\n-use clippy_utils::{clip, comparisons, differing_macro_contexts, int_bits, match_path, sext, unsext};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for use of `Box<Vec<_>>` anywhere in the code.\n@@ -250,68 +229,142 @@ declare_clippy_lint! {\n     \"shared ownership of a buffer type\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for types used in structs, parameters and `let`\n+    /// declarations above a certain complexity threshold.\n+    ///\n+    /// **Why is this bad?** Too complex types make the code less readable. Consider\n+    /// using a `type` definition to simplify them.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # use std::rc::Rc;\n+    /// struct Foo {\n+    ///     inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>,\n+    /// }\n+    /// ```\n+    pub TYPE_COMPLEXITY,\n+    complexity,\n+    \"usage of very complex types that might be better factored into `type` definitions\"\n+}\n+\n pub struct Types {\n     vec_box_size_threshold: u64,\n+    type_complexity_threshold: u64,\n }\n \n-impl_lint_pass!(Types => [BOX_VEC, VEC_BOX, OPTION_OPTION, LINKEDLIST, BORROWED_BOX, REDUNDANT_ALLOCATION, RC_BUFFER]);\n+impl_lint_pass!(Types => [BOX_VEC, VEC_BOX, OPTION_OPTION, LINKEDLIST, BORROWED_BOX, REDUNDANT_ALLOCATION, RC_BUFFER, TYPE_COMPLEXITY]);\n \n impl<'tcx> LateLintPass<'tcx> for Types {\n     fn check_fn(&mut self, cx: &LateContext<'_>, _: FnKind<'_>, decl: &FnDecl<'_>, _: &Body<'_>, _: Span, id: HirId) {\n-        // Skip trait implementations; see issue #605.\n-        if let Some(hir::Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_item(id)) {\n-            if let ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = item.kind {\n-                return;\n-            }\n+        let is_in_trait_impl = if let Some(hir::Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_item(id))\n+        {\n+            matches!(item.kind, ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }))\n+        } else {\n+            false\n+        };\n+\n+        self.check_fn_decl(\n+            cx,\n+            decl,\n+            CheckTyContext {\n+                is_in_trait_impl,\n+                ..CheckTyContext::default()\n+            },\n+        );\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        match item.kind {\n+            ItemKind::Static(ty, _, _) | ItemKind::Const(ty, _) => self.check_ty(cx, ty, CheckTyContext::default()),\n+            // functions, enums, structs, impls and traits are covered\n+            _ => (),\n         }\n+    }\n \n-        self.check_fn_decl(cx, decl);\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n+        match item.kind {\n+            ImplItemKind::Const(ty, _) | ImplItemKind::TyAlias(ty) => self.check_ty(\n+                cx,\n+                ty,\n+                CheckTyContext {\n+                    is_in_trait_impl: true,\n+                    ..CheckTyContext::default()\n+                },\n+            ),\n+            // methods are covered by check_fn\n+            ImplItemKind::Fn(..) => (),\n+        }\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n-        self.check_ty(cx, &field.ty, false);\n+        self.check_ty(cx, field.ty, CheckTyContext::default());\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_>, item: &TraitItem<'_>) {\n         match item.kind {\n-            TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => self.check_ty(cx, ty, false),\n-            TraitItemKind::Fn(ref sig, _) => self.check_fn_decl(cx, &sig.decl),\n+            TraitItemKind::Const(ty, _) | TraitItemKind::Type(_, Some(ty)) => {\n+                self.check_ty(cx, ty, CheckTyContext::default())\n+            },\n+            TraitItemKind::Fn(ref sig, _) => self.check_fn_decl(cx, sig.decl, CheckTyContext::default()),\n             TraitItemKind::Type(..) => (),\n         }\n     }\n \n     fn check_local(&mut self, cx: &LateContext<'_>, local: &Local<'_>) {\n-        if let Some(ref ty) = local.ty {\n-            self.check_ty(cx, ty, true);\n+        if let Some(ty) = local.ty {\n+            self.check_ty(\n+                cx,\n+                ty,\n+                CheckTyContext {\n+                    is_local: true,\n+                    ..CheckTyContext::default()\n+                },\n+            );\n         }\n     }\n }\n \n impl Types {\n-    pub fn new(vec_box_size_threshold: u64) -> Self {\n-        Self { vec_box_size_threshold }\n+    pub fn new(vec_box_size_threshold: u64, type_complexity_threshold: u64) -> Self {\n+        Self {\n+            vec_box_size_threshold,\n+            type_complexity_threshold,\n+        }\n     }\n \n-    fn check_fn_decl(&mut self, cx: &LateContext<'_>, decl: &FnDecl<'_>) {\n+    fn check_fn_decl(&mut self, cx: &LateContext<'_>, decl: &FnDecl<'_>, context: CheckTyContext) {\n         for input in decl.inputs {\n-            self.check_ty(cx, input, false);\n+            self.check_ty(cx, input, context);\n         }\n \n-        if let FnRetTy::Return(ref ty) = decl.output {\n-            self.check_ty(cx, ty, false);\n+        if let FnRetTy::Return(ty) = decl.output {\n+            self.check_ty(cx, ty, context);\n         }\n     }\n \n     /// Recursively check for `TypePass` lints in the given type. Stop at the first\n     /// lint found.\n     ///\n     /// The parameter `is_local` distinguishes the context of the type.\n-    fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, is_local: bool) {\n+    fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, mut context: CheckTyContext) {\n         if hir_ty.span.from_expansion() {\n             return;\n         }\n+\n+        if !context.is_nested_call && type_complexity::check(cx, hir_ty, self.type_complexity_threshold) {\n+            return;\n+        }\n+\n+        // Skip trait implementations; see issue #605.\n+        if context.is_in_trait_impl {\n+            return;\n+        }\n+\n         match hir_ty.kind {\n-            TyKind::Path(ref qpath) if !is_local => {\n+            TyKind::Path(ref qpath) if !context.is_local => {\n                 let hir_id = hir_ty.hir_id;\n                 let res = cx.qpath_res(qpath, hir_id);\n                 if let Some(def_id) = res.opt_def_id() {\n@@ -328,8 +381,9 @@ impl Types {\n                     }\n                 }\n                 match *qpath {\n-                    QPath::Resolved(Some(ref ty), ref p) => {\n-                        self.check_ty(cx, ty, is_local);\n+                    QPath::Resolved(Some(ty), p) => {\n+                        context.is_nested_call = true;\n+                        self.check_ty(cx, ty, context);\n                         for ty in p.segments.iter().flat_map(|seg| {\n                             seg.args\n                                 .as_ref()\n@@ -339,10 +393,11 @@ impl Types {\n                                     _ => None,\n                                 })\n                         }) {\n-                            self.check_ty(cx, ty, is_local);\n+                            self.check_ty(cx, ty, context);\n                         }\n                     },\n-                    QPath::Resolved(None, ref p) => {\n+                    QPath::Resolved(None, p) => {\n+                        context.is_nested_call = true;\n                         for ty in p.segments.iter().flat_map(|seg| {\n                             seg.args\n                                 .as_ref()\n@@ -352,930 +407,48 @@ impl Types {\n                                     _ => None,\n                                 })\n                         }) {\n-                            self.check_ty(cx, ty, is_local);\n+                            self.check_ty(cx, ty, context);\n                         }\n                     },\n-                    QPath::TypeRelative(ref ty, ref seg) => {\n-                        self.check_ty(cx, ty, is_local);\n-                        if let Some(ref params) = seg.args {\n+                    QPath::TypeRelative(ty, seg) => {\n+                        context.is_nested_call = true;\n+                        self.check_ty(cx, ty, context);\n+                        if let Some(params) = seg.args {\n                             for ty in params.args.iter().filter_map(|arg| match arg {\n                                 GenericArg::Type(ty) => Some(ty),\n                                 _ => None,\n                             }) {\n-                                self.check_ty(cx, ty, is_local);\n+                                self.check_ty(cx, ty, context);\n                             }\n                         }\n                     },\n                     QPath::LangItem(..) => {},\n                 }\n             },\n             TyKind::Rptr(ref lt, ref mut_ty) => {\n+                context.is_nested_call = true;\n                 if !borrowed_box::check(cx, hir_ty, lt, mut_ty) {\n-                    self.check_ty(cx, &mut_ty.ty, is_local);\n+                    self.check_ty(cx, mut_ty.ty, context);\n                 }\n             },\n-            TyKind::Slice(ref ty) | TyKind::Array(ref ty, _) | TyKind::Ptr(MutTy { ref ty, .. }) => {\n-                self.check_ty(cx, ty, is_local)\n+            TyKind::Slice(ty) | TyKind::Array(ty, _) | TyKind::Ptr(MutTy { ty, .. }) => {\n+                context.is_nested_call = true;\n+                self.check_ty(cx, ty, context)\n             },\n             TyKind::Tup(tys) => {\n+                context.is_nested_call = true;\n                 for ty in tys {\n-                    self.check_ty(cx, ty, is_local);\n+                    self.check_ty(cx, ty, context);\n                 }\n             },\n             _ => {},\n         }\n     }\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for types used in structs, parameters and `let`\n-    /// declarations above a certain complexity threshold.\n-    ///\n-    /// **Why is this bad?** Too complex types make the code less readable. Consider\n-    /// using a `type` definition to simplify them.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # use std::rc::Rc;\n-    /// struct Foo {\n-    ///     inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>,\n-    /// }\n-    /// ```\n-    pub TYPE_COMPLEXITY,\n-    complexity,\n-    \"usage of very complex types that might be better factored into `type` definitions\"\n-}\n-\n-pub struct TypeComplexity {\n-    threshold: u64,\n-}\n-\n-impl TypeComplexity {\n-    #[must_use]\n-    pub fn new(threshold: u64) -> Self {\n-        Self { threshold }\n-    }\n-}\n-\n-impl_lint_pass!(TypeComplexity => [TYPE_COMPLEXITY]);\n-\n-impl<'tcx> LateLintPass<'tcx> for TypeComplexity {\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'tcx>,\n-        _: FnKind<'tcx>,\n-        decl: &'tcx FnDecl<'_>,\n-        _: &'tcx Body<'_>,\n-        _: Span,\n-        _: HirId,\n-    ) {\n-        self.check_fndecl(cx, decl);\n-    }\n-\n-    fn check_field_def(&mut self, cx: &LateContext<'tcx>, field: &'tcx hir::FieldDef<'_>) {\n-        // enum variants are also struct fields now\n-        self.check_type(cx, &field.ty);\n-    }\n-\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        match item.kind {\n-            ItemKind::Static(ref ty, _, _) | ItemKind::Const(ref ty, _) => self.check_type(cx, ty),\n-            // functions, enums, structs, impls and traits are covered\n-            _ => (),\n-        }\n-    }\n-\n-    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n-        match item.kind {\n-            TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => self.check_type(cx, ty),\n-            TraitItemKind::Fn(FnSig { ref decl, .. }, TraitFn::Required(_)) => self.check_fndecl(cx, decl),\n-            // methods with default impl are covered by check_fn\n-            TraitItemKind::Type(..) | TraitItemKind::Fn(_, TraitFn::Provided(_)) => (),\n-        }\n-    }\n-\n-    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n-        match item.kind {\n-            ImplItemKind::Const(ref ty, _) | ImplItemKind::TyAlias(ref ty) => self.check_type(cx, ty),\n-            // methods are covered by check_fn\n-            ImplItemKind::Fn(..) => (),\n-        }\n-    }\n-\n-    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n-        if let Some(ref ty) = local.ty {\n-            self.check_type(cx, ty);\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeComplexity {\n-    fn check_fndecl(&self, cx: &LateContext<'tcx>, decl: &'tcx FnDecl<'_>) {\n-        for arg in decl.inputs {\n-            self.check_type(cx, arg);\n-        }\n-        if let FnRetTy::Return(ref ty) = decl.output {\n-            self.check_type(cx, ty);\n-        }\n-    }\n-\n-    fn check_type(&self, cx: &LateContext<'_>, ty: &hir::Ty<'_>) {\n-        if ty.span.from_expansion() {\n-            return;\n-        }\n-        let score = {\n-            let mut visitor = TypeComplexityVisitor { score: 0, nest: 1 };\n-            visitor.visit_ty(ty);\n-            visitor.score\n-        };\n-\n-        if score > self.threshold {\n-            span_lint(\n-                cx,\n-                TYPE_COMPLEXITY,\n-                ty.span,\n-                \"very complex type used. Consider factoring parts into `type` definitions\",\n-            );\n-        }\n-    }\n-}\n-\n-/// Walks a type and assigns a complexity score to it.\n-struct TypeComplexityVisitor {\n-    /// total complexity score of the type\n-    score: u64,\n-    /// current nesting level\n-    nest: u64,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty<'_>) {\n-        let (add_score, sub_nest) = match ty.kind {\n-            // _, &x and *x have only small overhead; don't mess with nesting level\n-            TyKind::Infer | TyKind::Ptr(..) | TyKind::Rptr(..) => (1, 0),\n-\n-            // the \"normal\" components of a type: named types, arrays/tuples\n-            TyKind::Path(..) | TyKind::Slice(..) | TyKind::Tup(..) | TyKind::Array(..) => (10 * self.nest, 1),\n-\n-            // function types bring a lot of overhead\n-            TyKind::BareFn(ref bare) if bare.abi == Abi::Rust => (50 * self.nest, 1),\n-\n-            TyKind::TraitObject(ref param_bounds, _, _) => {\n-                let has_lifetime_parameters = param_bounds.iter().any(|bound| {\n-                    bound\n-                        .bound_generic_params\n-                        .iter()\n-                        .any(|gen| matches!(gen.kind, GenericParamKind::Lifetime { .. }))\n-                });\n-                if has_lifetime_parameters {\n-                    // complex trait bounds like A<'a, 'b>\n-                    (50 * self.nest, 1)\n-                } else {\n-                    // simple trait bounds like A + B\n-                    (20 * self.nest, 0)\n-                }\n-            },\n-\n-            _ => (0, 0),\n-        };\n-        self.score += add_score;\n-        self.nest += sub_nest;\n-        walk_ty(self, ty);\n-        self.nest -= sub_nest;\n-    }\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for comparisons where one side of the relation is\n-    /// either the minimum or maximum value for its type and warns if it involves a\n-    /// case that is always true or always false. Only integer and boolean types are\n-    /// checked.\n-    ///\n-    /// **Why is this bad?** An expression like `min <= x` may misleadingly imply\n-    /// that it is possible for `x` to be less than the minimum. Expressions like\n-    /// `max < x` are probably mistakes.\n-    ///\n-    /// **Known problems:** For `usize` the size of the current compile target will\n-    /// be assumed (e.g., 64 bits on 64 bit systems). This means code that uses such\n-    /// a comparison to detect target pointer width will trigger this lint. One can\n-    /// use `mem::sizeof` and compare its value or conditional compilation\n-    /// attributes\n-    /// like `#[cfg(target_pointer_width = \"64\")] ..` instead.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// let vec: Vec<isize> = Vec::new();\n-    /// if vec.len() <= 0 {}\n-    /// if 100 > i32::MAX {}\n-    /// ```\n-    pub ABSURD_EXTREME_COMPARISONS,\n-    correctness,\n-    \"a comparison with a maximum or minimum value that is always true or false\"\n-}\n-\n-declare_lint_pass!(AbsurdExtremeComparisons => [ABSURD_EXTREME_COMPARISONS]);\n-\n-enum ExtremeType {\n-    Minimum,\n-    Maximum,\n-}\n-\n-struct ExtremeExpr<'a> {\n-    which: ExtremeType,\n-    expr: &'a Expr<'a>,\n-}\n-\n-enum AbsurdComparisonResult {\n-    AlwaysFalse,\n-    AlwaysTrue,\n-    InequalityImpossible,\n-}\n-\n-fn is_cast_between_fixed_and_target<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-    if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n-        let precast_ty = cx.typeck_results().expr_ty(cast_exp);\n-        let cast_ty = cx.typeck_results().expr_ty(expr);\n-\n-        return is_isize_or_usize(precast_ty) != is_isize_or_usize(cast_ty);\n-    }\n-\n-    false\n-}\n-\n-fn detect_absurd_comparison<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    op: BinOpKind,\n-    lhs: &'tcx Expr<'_>,\n-    rhs: &'tcx Expr<'_>,\n-) -> Option<(ExtremeExpr<'tcx>, AbsurdComparisonResult)> {\n-    use crate::types::AbsurdComparisonResult::{AlwaysFalse, AlwaysTrue, InequalityImpossible};\n-    use crate::types::ExtremeType::{Maximum, Minimum};\n-    use clippy_utils::comparisons::{normalize_comparison, Rel};\n-\n-    // absurd comparison only makes sense on primitive types\n-    // primitive types don't implement comparison operators with each other\n-    if cx.typeck_results().expr_ty(lhs) != cx.typeck_results().expr_ty(rhs) {\n-        return None;\n-    }\n-\n-    // comparisons between fix sized types and target sized types are considered unanalyzable\n-    if is_cast_between_fixed_and_target(cx, lhs) || is_cast_between_fixed_and_target(cx, rhs) {\n-        return None;\n-    }\n-\n-    let (rel, normalized_lhs, normalized_rhs) = normalize_comparison(op, lhs, rhs)?;\n-\n-    let lx = detect_extreme_expr(cx, normalized_lhs);\n-    let rx = detect_extreme_expr(cx, normalized_rhs);\n-\n-    Some(match rel {\n-        Rel::Lt => {\n-            match (lx, rx) {\n-                (Some(l @ ExtremeExpr { which: Maximum, .. }), _) => (l, AlwaysFalse), // max < x\n-                (_, Some(r @ ExtremeExpr { which: Minimum, .. })) => (r, AlwaysFalse), // x < min\n-                _ => return None,\n-            }\n-        },\n-        Rel::Le => {\n-            match (lx, rx) {\n-                (Some(l @ ExtremeExpr { which: Minimum, .. }), _) => (l, AlwaysTrue), // min <= x\n-                (Some(l @ ExtremeExpr { which: Maximum, .. }), _) => (l, InequalityImpossible), // max <= x\n-                (_, Some(r @ ExtremeExpr { which: Minimum, .. })) => (r, InequalityImpossible), // x <= min\n-                (_, Some(r @ ExtremeExpr { which: Maximum, .. })) => (r, AlwaysTrue), // x <= max\n-                _ => return None,\n-            }\n-        },\n-        Rel::Ne | Rel::Eq => return None,\n-    })\n-}\n-\n-fn detect_extreme_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<ExtremeExpr<'tcx>> {\n-    use crate::types::ExtremeType::{Maximum, Minimum};\n-\n-    let ty = cx.typeck_results().expr_ty(expr);\n-\n-    let cv = constant(cx, cx.typeck_results(), expr)?.0;\n-\n-    let which = match (ty.kind(), cv) {\n-        (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => Minimum,\n-        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::MIN >> (128 - int_bits(cx.tcx, ity)), ity) => {\n-            Minimum\n-        },\n-\n-        (&ty::Bool, Constant::Bool(true)) => Maximum,\n-        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::MAX >> (128 - int_bits(cx.tcx, ity)), ity) => {\n-            Maximum\n-        },\n-        (&ty::Uint(uty), Constant::Int(i)) if clip(cx.tcx, u128::MAX, uty) == i => Maximum,\n-\n-        _ => return None,\n-    };\n-    Some(ExtremeExpr { which, expr })\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for AbsurdExtremeComparisons {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        use crate::types::AbsurdComparisonResult::{AlwaysFalse, AlwaysTrue, InequalityImpossible};\n-        use crate::types::ExtremeType::{Maximum, Minimum};\n-\n-        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.kind {\n-            if let Some((culprit, result)) = detect_absurd_comparison(cx, cmp.node, lhs, rhs) {\n-                if !expr.span.from_expansion() {\n-                    let msg = \"this comparison involving the minimum or maximum element for this \\\n-                               type contains a case that is always true or always false\";\n-\n-                    let conclusion = match result {\n-                        AlwaysFalse => \"this comparison is always false\".to_owned(),\n-                        AlwaysTrue => \"this comparison is always true\".to_owned(),\n-                        InequalityImpossible => format!(\n-                            \"the case where the two sides are not equal never occurs, consider using `{} == {}` \\\n-                             instead\",\n-                            snippet(cx, lhs.span, \"lhs\"),\n-                            snippet(cx, rhs.span, \"rhs\")\n-                        ),\n-                    };\n-\n-                    let help = format!(\n-                        \"because `{}` is the {} value for this type, {}\",\n-                        snippet(cx, culprit.expr.span, \"x\"),\n-                        match culprit.which {\n-                            Minimum => \"minimum\",\n-                            Maximum => \"maximum\",\n-                        },\n-                        conclusion\n-                    );\n-\n-                    span_lint_and_help(cx, ABSURD_EXTREME_COMPARISONS, expr.span, msg, None, &help);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for comparisons where the relation is always either\n-    /// true or false, but where one side has been upcast so that the comparison is\n-    /// necessary. Only integer types are checked.\n-    ///\n-    /// **Why is this bad?** An expression like `let x : u8 = ...; (x as u32) > 300`\n-    /// will mistakenly imply that it is possible for `x` to be outside the range of\n-    /// `u8`.\n-    ///\n-    /// **Known problems:**\n-    /// https://github.com/rust-lang/rust-clippy/issues/886\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let x: u8 = 1;\n-    /// (x as u32) > 300;\n-    /// ```\n-    pub INVALID_UPCAST_COMPARISONS,\n-    pedantic,\n-    \"a comparison involving an upcast which is always true or false\"\n-}\n-\n-declare_lint_pass!(InvalidUpcastComparisons => [INVALID_UPCAST_COMPARISONS]);\n-\n-#[derive(Copy, Clone, Debug, Eq)]\n-enum FullInt {\n-    S(i128),\n-    U(u128),\n-}\n-\n-impl FullInt {\n-    #[allow(clippy::cast_sign_loss)]\n-    #[must_use]\n-    fn cmp_s_u(s: i128, u: u128) -> Ordering {\n-        if s < 0 {\n-            Ordering::Less\n-        } else if u > (i128::MAX as u128) {\n-            Ordering::Greater\n-        } else {\n-            (s as u128).cmp(&u)\n-        }\n-    }\n-}\n-\n-impl PartialEq for FullInt {\n-    #[must_use]\n-    fn eq(&self, other: &Self) -> bool {\n-        self.partial_cmp(other).expect(\"`partial_cmp` only returns `Some(_)`\") == Ordering::Equal\n-    }\n-}\n-\n-impl PartialOrd for FullInt {\n-    #[must_use]\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(match (self, other) {\n-            (&Self::S(s), &Self::S(o)) => s.cmp(&o),\n-            (&Self::U(s), &Self::U(o)) => s.cmp(&o),\n-            (&Self::S(s), &Self::U(o)) => Self::cmp_s_u(s, o),\n-            (&Self::U(s), &Self::S(o)) => Self::cmp_s_u(o, s).reverse(),\n-        })\n-    }\n-}\n-\n-impl Ord for FullInt {\n-    #[must_use]\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.partial_cmp(other)\n-            .expect(\"`partial_cmp` for FullInt can never return `None`\")\n-    }\n-}\n-\n-fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) -> Option<(FullInt, FullInt)> {\n-    if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n-        let pre_cast_ty = cx.typeck_results().expr_ty(cast_exp);\n-        let cast_ty = cx.typeck_results().expr_ty(expr);\n-        // if it's a cast from i32 to u32 wrapping will invalidate all these checks\n-        if cx.layout_of(pre_cast_ty).ok().map(|l| l.size) == cx.layout_of(cast_ty).ok().map(|l| l.size) {\n-            return None;\n-        }\n-        match pre_cast_ty.kind() {\n-            ty::Int(int_ty) => Some(match int_ty {\n-                IntTy::I8 => (FullInt::S(i128::from(i8::MIN)), FullInt::S(i128::from(i8::MAX))),\n-                IntTy::I16 => (FullInt::S(i128::from(i16::MIN)), FullInt::S(i128::from(i16::MAX))),\n-                IntTy::I32 => (FullInt::S(i128::from(i32::MIN)), FullInt::S(i128::from(i32::MAX))),\n-                IntTy::I64 => (FullInt::S(i128::from(i64::MIN)), FullInt::S(i128::from(i64::MAX))),\n-                IntTy::I128 => (FullInt::S(i128::MIN), FullInt::S(i128::MAX)),\n-                IntTy::Isize => (FullInt::S(isize::MIN as i128), FullInt::S(isize::MAX as i128)),\n-            }),\n-            ty::Uint(uint_ty) => Some(match uint_ty {\n-                UintTy::U8 => (FullInt::U(u128::from(u8::MIN)), FullInt::U(u128::from(u8::MAX))),\n-                UintTy::U16 => (FullInt::U(u128::from(u16::MIN)), FullInt::U(u128::from(u16::MAX))),\n-                UintTy::U32 => (FullInt::U(u128::from(u32::MIN)), FullInt::U(u128::from(u32::MAX))),\n-                UintTy::U64 => (FullInt::U(u128::from(u64::MIN)), FullInt::U(u128::from(u64::MAX))),\n-                UintTy::U128 => (FullInt::U(u128::MIN), FullInt::U(u128::MAX)),\n-                UintTy::Usize => (FullInt::U(usize::MIN as u128), FullInt::U(usize::MAX as u128)),\n-            }),\n-            _ => None,\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n-fn node_as_const_fullint<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<FullInt> {\n-    let val = constant(cx, cx.typeck_results(), expr)?.0;\n-    if let Constant::Int(const_int) = val {\n-        match *cx.typeck_results().expr_ty(expr).kind() {\n-            ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n-            ty::Uint(_) => Some(FullInt::U(const_int)),\n-            _ => None,\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n-fn err_upcast_comparison(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, always: bool) {\n-    if let ExprKind::Cast(ref cast_val, _) = expr.kind {\n-        span_lint(\n-            cx,\n-            INVALID_UPCAST_COMPARISONS,\n-            span,\n-            &format!(\n-                \"because of the numeric bounds on `{}` prior to casting, this expression is always {}\",\n-                snippet(cx, cast_val.span, \"the expression\"),\n-                if always { \"true\" } else { \"false\" },\n-            ),\n-        );\n-    }\n-}\n-\n-fn upcast_comparison_bounds_err<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    span: Span,\n-    rel: comparisons::Rel,\n-    lhs_bounds: Option<(FullInt, FullInt)>,\n-    lhs: &'tcx Expr<'_>,\n-    rhs: &'tcx Expr<'_>,\n-    invert: bool,\n-) {\n-    use clippy_utils::comparisons::Rel;\n-\n-    if let Some((lb, ub)) = lhs_bounds {\n-        if let Some(norm_rhs_val) = node_as_const_fullint(cx, rhs) {\n-            if rel == Rel::Eq || rel == Rel::Ne {\n-                if norm_rhs_val < lb || norm_rhs_val > ub {\n-                    err_upcast_comparison(cx, span, lhs, rel == Rel::Ne);\n-                }\n-            } else if match rel {\n-                Rel::Lt => {\n-                    if invert {\n-                        norm_rhs_val < lb\n-                    } else {\n-                        ub < norm_rhs_val\n-                    }\n-                },\n-                Rel::Le => {\n-                    if invert {\n-                        norm_rhs_val <= lb\n-                    } else {\n-                        ub <= norm_rhs_val\n-                    }\n-                },\n-                Rel::Eq | Rel::Ne => unreachable!(),\n-            } {\n-                err_upcast_comparison(cx, span, lhs, true)\n-            } else if match rel {\n-                Rel::Lt => {\n-                    if invert {\n-                        norm_rhs_val >= ub\n-                    } else {\n-                        lb >= norm_rhs_val\n-                    }\n-                },\n-                Rel::Le => {\n-                    if invert {\n-                        norm_rhs_val > ub\n-                    } else {\n-                        lb > norm_rhs_val\n-                    }\n-                },\n-                Rel::Eq | Rel::Ne => unreachable!(),\n-            } {\n-                err_upcast_comparison(cx, span, lhs, false)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for InvalidUpcastComparisons {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.kind {\n-            let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n-            let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n-                val\n-            } else {\n-                return;\n-            };\n-\n-            let lhs_bounds = numeric_cast_precast_bounds(cx, normalized_lhs);\n-            let rhs_bounds = numeric_cast_precast_bounds(cx, normalized_rhs);\n-\n-            upcast_comparison_bounds_err(cx, expr.span, rel, lhs_bounds, normalized_lhs, normalized_rhs, false);\n-            upcast_comparison_bounds_err(cx, expr.span, rel, rhs_bounds, normalized_rhs, normalized_lhs, true);\n-        }\n-    }\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for public `impl` or `fn` missing generalization\n-    /// over different hashers and implicitly defaulting to the default hashing\n-    /// algorithm (`SipHash`).\n-    ///\n-    /// **Why is this bad?** `HashMap` or `HashSet` with custom hashers cannot be\n-    /// used with them.\n-    ///\n-    /// **Known problems:** Suggestions for replacing constructors can contain\n-    /// false-positives. Also applying suggestions can require modification of other\n-    /// pieces of code, possibly including external crates.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # use std::collections::HashMap;\n-    /// # use std::hash::{Hash, BuildHasher};\n-    /// # trait Serialize {};\n-    /// impl<K: Hash + Eq, V> Serialize for HashMap<K, V> { }\n-    ///\n-    /// pub fn foo(map: &mut HashMap<i32, i32>) { }\n-    /// ```\n-    /// could be rewritten as\n-    /// ```rust\n-    /// # use std::collections::HashMap;\n-    /// # use std::hash::{Hash, BuildHasher};\n-    /// # trait Serialize {};\n-    /// impl<K: Hash + Eq, V, S: BuildHasher> Serialize for HashMap<K, V, S> { }\n-    ///\n-    /// pub fn foo<S: BuildHasher>(map: &mut HashMap<i32, i32, S>) { }\n-    /// ```\n-    pub IMPLICIT_HASHER,\n-    pedantic,\n-    \"missing generalization over different hashers\"\n-}\n-\n-declare_lint_pass!(ImplicitHasher => [IMPLICIT_HASHER]);\n-\n-impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n-    #[allow(clippy::cast_possible_truncation, clippy::too_many_lines)]\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        use rustc_span::BytePos;\n-\n-        fn suggestion<'tcx>(\n-            cx: &LateContext<'tcx>,\n-            diag: &mut DiagnosticBuilder<'_>,\n-            generics_span: Span,\n-            generics_suggestion_span: Span,\n-            target: &ImplicitHasherType<'_>,\n-            vis: ImplicitHasherConstructorVisitor<'_, '_, '_>,\n-        ) {\n-            let generics_snip = snippet(cx, generics_span, \"\");\n-            // trim `<` `>`\n-            let generics_snip = if generics_snip.is_empty() {\n-                \"\"\n-            } else {\n-                &generics_snip[1..generics_snip.len() - 1]\n-            };\n-\n-            multispan_sugg(\n-                diag,\n-                \"consider adding a type parameter\",\n-                vec![\n-                    (\n-                        generics_suggestion_span,\n-                        format!(\n-                            \"<{}{}S: ::std::hash::BuildHasher{}>\",\n-                            generics_snip,\n-                            if generics_snip.is_empty() { \"\" } else { \", \" },\n-                            if vis.suggestions.is_empty() {\n-                                \"\"\n-                            } else {\n-                                // request users to add `Default` bound so that generic constructors can be used\n-                                \" + Default\"\n-                            },\n-                        ),\n-                    ),\n-                    (\n-                        target.span(),\n-                        format!(\"{}<{}, S>\", target.type_name(), target.type_arguments(),),\n-                    ),\n-                ],\n-            );\n-\n-            if !vis.suggestions.is_empty() {\n-                multispan_sugg(diag, \"...and use generic constructor\", vis.suggestions);\n-            }\n-        }\n-\n-        if !cx.access_levels.is_exported(item.hir_id()) {\n-            return;\n-        }\n-\n-        match item.kind {\n-            ItemKind::Impl(ref impl_) => {\n-                let mut vis = ImplicitHasherTypeVisitor::new(cx);\n-                vis.visit_ty(impl_.self_ty);\n-\n-                for target in &vis.found {\n-                    if differing_macro_contexts(item.span, target.span()) {\n-                        return;\n-                    }\n-\n-                    let generics_suggestion_span = impl_.generics.span.substitute_dummy({\n-                        let pos = snippet_opt(cx, item.span.until(target.span()))\n-                            .and_then(|snip| Some(item.span.lo() + BytePos(snip.find(\"impl\")? as u32 + 4)));\n-                        if let Some(pos) = pos {\n-                            Span::new(pos, pos, item.span.data().ctxt)\n-                        } else {\n-                            return;\n-                        }\n-                    });\n-\n-                    let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n-                    for item in impl_.items.iter().map(|item| cx.tcx.hir().impl_item(item.id)) {\n-                        ctr_vis.visit_impl_item(item);\n-                    }\n-\n-                    span_lint_and_then(\n-                        cx,\n-                        IMPLICIT_HASHER,\n-                        target.span(),\n-                        &format!(\n-                            \"impl for `{}` should be generalized over different hashers\",\n-                            target.type_name()\n-                        ),\n-                        move |diag| {\n-                            suggestion(cx, diag, impl_.generics.span, generics_suggestion_span, target, ctr_vis);\n-                        },\n-                    );\n-                }\n-            },\n-            ItemKind::Fn(ref sig, ref generics, body_id) => {\n-                let body = cx.tcx.hir().body(body_id);\n-\n-                for ty in sig.decl.inputs {\n-                    let mut vis = ImplicitHasherTypeVisitor::new(cx);\n-                    vis.visit_ty(ty);\n-\n-                    for target in &vis.found {\n-                        if in_external_macro(cx.sess(), generics.span) {\n-                            continue;\n-                        }\n-                        let generics_suggestion_span = generics.span.substitute_dummy({\n-                            let pos = snippet_opt(cx, item.span.until(body.params[0].pat.span))\n-                                .and_then(|snip| {\n-                                    let i = snip.find(\"fn\")?;\n-                                    Some(item.span.lo() + BytePos((i + (&snip[i..]).find('(')?) as u32))\n-                                })\n-                                .expect(\"failed to create span for type parameters\");\n-                            Span::new(pos, pos, item.span.data().ctxt)\n-                        });\n-\n-                        let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n-                        ctr_vis.visit_body(body);\n-\n-                        span_lint_and_then(\n-                            cx,\n-                            IMPLICIT_HASHER,\n-                            target.span(),\n-                            &format!(\n-                                \"parameter of type `{}` should be generalized over different hashers\",\n-                                target.type_name()\n-                            ),\n-                            move |diag| {\n-                                suggestion(cx, diag, generics.span, generics_suggestion_span, target, ctr_vis);\n-                            },\n-                        );\n-                    }\n-                }\n-            },\n-            _ => {},\n-        }\n-    }\n-}\n-\n-enum ImplicitHasherType<'tcx> {\n-    HashMap(Span, Ty<'tcx>, Cow<'static, str>, Cow<'static, str>),\n-    HashSet(Span, Ty<'tcx>, Cow<'static, str>),\n-}\n-\n-impl<'tcx> ImplicitHasherType<'tcx> {\n-    /// Checks that `ty` is a target type without a `BuildHasher`.\n-    fn new(cx: &LateContext<'tcx>, hir_ty: &hir::Ty<'_>) -> Option<Self> {\n-        if let TyKind::Path(QPath::Resolved(None, ref path)) = hir_ty.kind {\n-            let params: Vec<_> = path\n-                .segments\n-                .last()\n-                .as_ref()?\n-                .args\n-                .as_ref()?\n-                .args\n-                .iter()\n-                .filter_map(|arg| match arg {\n-                    GenericArg::Type(ty) => Some(ty),\n-                    _ => None,\n-                })\n-                .collect();\n-            let params_len = params.len();\n-\n-            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-\n-            if is_type_diagnostic_item(cx, ty, sym::hashmap_type) && params_len == 2 {\n-                Some(ImplicitHasherType::HashMap(\n-                    hir_ty.span,\n-                    ty,\n-                    snippet(cx, params[0].span, \"K\"),\n-                    snippet(cx, params[1].span, \"V\"),\n-                ))\n-            } else if is_type_diagnostic_item(cx, ty, sym::hashset_type) && params_len == 1 {\n-                Some(ImplicitHasherType::HashSet(\n-                    hir_ty.span,\n-                    ty,\n-                    snippet(cx, params[0].span, \"T\"),\n-                ))\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn type_name(&self) -> &'static str {\n-        match *self {\n-            ImplicitHasherType::HashMap(..) => \"HashMap\",\n-            ImplicitHasherType::HashSet(..) => \"HashSet\",\n-        }\n-    }\n-\n-    fn type_arguments(&self) -> String {\n-        match *self {\n-            ImplicitHasherType::HashMap(.., ref k, ref v) => format!(\"{}, {}\", k, v),\n-            ImplicitHasherType::HashSet(.., ref t) => format!(\"{}\", t),\n-        }\n-    }\n-\n-    fn ty(&self) -> Ty<'tcx> {\n-        match *self {\n-            ImplicitHasherType::HashMap(_, ty, ..) | ImplicitHasherType::HashSet(_, ty, ..) => ty,\n-        }\n-    }\n-\n-    fn span(&self) -> Span {\n-        match *self {\n-            ImplicitHasherType::HashMap(span, ..) | ImplicitHasherType::HashSet(span, ..) => span,\n-        }\n-    }\n-}\n-\n-struct ImplicitHasherTypeVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    found: Vec<ImplicitHasherType<'tcx>>,\n-}\n-\n-impl<'a, 'tcx> ImplicitHasherTypeVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'tcx>) -> Self {\n-        Self { cx, found: vec![] }\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ImplicitHasherTypeVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_ty(&mut self, t: &'tcx hir::Ty<'_>) {\n-        if let Some(target) = ImplicitHasherType::new(self.cx, t) {\n-            self.found.push(target);\n-        }\n-\n-        walk_ty(self, t);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-/// Looks for default-hasher-dependent constructors like `HashMap::new`.\n-struct ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n-    target: &'b ImplicitHasherType<'tcx>,\n-    suggestions: BTreeMap<Span, String>,\n-}\n-\n-impl<'a, 'b, 'tcx> ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n-    fn new(cx: &'a LateContext<'tcx>, target: &'b ImplicitHasherType<'tcx>) -> Self {\n-        Self {\n-            cx,\n-            maybe_typeck_results: cx.maybe_typeck_results(),\n-            target,\n-            suggestions: BTreeMap::new(),\n-        }\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_body(&mut self, body: &'tcx Body<'_>) {\n-        let old_maybe_typeck_results = self.maybe_typeck_results.replace(self.cx.tcx.typeck_body(body.id()));\n-        walk_body(self, body);\n-        self.maybe_typeck_results = old_maybe_typeck_results;\n-    }\n-\n-    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Call(ref fun, ref args) = e.kind;\n-            if let ExprKind::Path(QPath::TypeRelative(ref ty, ref method)) = fun.kind;\n-            if let TyKind::Path(QPath::Resolved(None, ty_path)) = ty.kind;\n-            then {\n-                if !TyS::same_type(self.target.ty(), self.maybe_typeck_results.unwrap().expr_ty(e)) {\n-                    return;\n-                }\n-\n-                if match_path(ty_path, &paths::HASHMAP) {\n-                    if method.ident.name == sym::new {\n-                        self.suggestions\n-                            .insert(e.span, \"HashMap::default()\".to_string());\n-                    } else if method.ident.name == sym!(with_capacity) {\n-                        self.suggestions.insert(\n-                            e.span,\n-                            format!(\n-                                \"HashMap::with_capacity_and_hasher({}, Default::default())\",\n-                                snippet(self.cx, args[0].span, \"capacity\"),\n-                            ),\n-                        );\n-                    }\n-                } else if match_path(ty_path, &paths::HASHSET) {\n-                    if method.ident.name == sym::new {\n-                        self.suggestions\n-                            .insert(e.span, \"HashSet::default()\".to_string());\n-                    } else if method.ident.name == sym!(with_capacity) {\n-                        self.suggestions.insert(\n-                            e.span,\n-                            format!(\n-                                \"HashSet::with_capacity_and_hasher({}, Default::default())\",\n-                                snippet(self.cx, args[0].span, \"capacity\"),\n-                            ),\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-\n-        walk_expr(self, e);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n-    }\n+#[derive(Clone, Copy, Default)]\n+struct CheckTyContext {\n+    is_in_trait_impl: bool,\n+    is_local: bool,\n+    is_nested_call: bool,\n }"}, {"sha": "d8c4b67520d116d73eb2cd62e3acee2edce8b402", "filename": "clippy_lints/src/types/type_complexity.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftypes%2Ftype_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftypes%2Ftype_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Ftype_complexity.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,79 @@\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{walk_ty, NestedVisitorMap, Visitor};\n+use rustc_hir::{GenericParamKind, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use rustc_target::spec::abi::Abi;\n+\n+use super::TYPE_COMPLEXITY;\n+\n+pub(super) fn check(cx: &LateContext<'_>, ty: &hir::Ty<'_>, type_complexity_threshold: u64) -> bool {\n+    let score = {\n+        let mut visitor = TypeComplexityVisitor { score: 0, nest: 1 };\n+        visitor.visit_ty(ty);\n+        visitor.score\n+    };\n+\n+    if score > type_complexity_threshold {\n+        span_lint(\n+            cx,\n+            TYPE_COMPLEXITY,\n+            ty.span,\n+            \"very complex type used. Consider factoring parts into `type` definitions\",\n+        );\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Walks a type and assigns a complexity score to it.\n+struct TypeComplexityVisitor {\n+    /// total complexity score of the type\n+    score: u64,\n+    /// current nesting level\n+    nest: u64,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty<'_>) {\n+        let (add_score, sub_nest) = match ty.kind {\n+            // _, &x and *x have only small overhead; don't mess with nesting level\n+            TyKind::Infer | TyKind::Ptr(..) | TyKind::Rptr(..) => (1, 0),\n+\n+            // the \"normal\" components of a type: named types, arrays/tuples\n+            TyKind::Path(..) | TyKind::Slice(..) | TyKind::Tup(..) | TyKind::Array(..) => (10 * self.nest, 1),\n+\n+            // function types bring a lot of overhead\n+            TyKind::BareFn(bare) if bare.abi == Abi::Rust => (50 * self.nest, 1),\n+\n+            TyKind::TraitObject(param_bounds, _, _) => {\n+                let has_lifetime_parameters = param_bounds.iter().any(|bound| {\n+                    bound\n+                        .bound_generic_params\n+                        .iter()\n+                        .any(|gen| matches!(gen.kind, GenericParamKind::Lifetime { .. }))\n+                });\n+                if has_lifetime_parameters {\n+                    // complex trait bounds like A<'a, 'b>\n+                    (50 * self.nest, 1)\n+                } else {\n+                    // simple trait bounds like A + B\n+                    (20 * self.nest, 0)\n+                }\n+            },\n+\n+            _ => (0, 0),\n+        };\n+        self.score += add_score;\n+        self.nest += sub_nest;\n+        walk_ty(self, ty);\n+        self.nest -= sub_nest;\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "0fa75f8f0a9be3e7c06632da3bd8bb0a7988fe37", "filename": "clippy_lints/src/types/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftypes%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftypes%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Futils.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -7,7 +7,7 @@ use rustc_span::source_map::Span;\n pub(super) fn match_borrows_parameter(_cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<Span> {\n     let last = last_path_segment(qpath);\n     if_chain! {\n-        if let Some(ref params) = last.args;\n+        if let Some(params) = last.args;\n         if !params.parenthesized;\n         if let Some(ty) = params.args.iter().find_map(|arg| match arg {\n             GenericArg::Type(ty) => Some(ty),"}, {"sha": "7a444174626f47378e020cf6459a90c717c03565", "filename": "clippy_lints/src/types/vec_box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -22,7 +22,7 @@ pub(super) fn check(\n     if cx.tcx.is_diagnostic_item(sym::vec_type, def_id) {\n         if_chain! {\n             // Get the _ part of Vec<_>\n-            if let Some(ref last) = last_path_segment(qpath).args;\n+            if let Some(last) = last_path_segment(qpath).args;\n             if let Some(ty) = last.args.iter().find_map(|arg| match arg {\n                 GenericArg::Type(ty) => Some(ty),\n                 _ => None,\n@@ -33,7 +33,7 @@ pub(super) fn check(\n             if let Some(def_id) = res.opt_def_id();\n             if Some(def_id) == cx.tcx.lang_items().owned_box();\n             // At this point, we know ty is Box<T>, now get T\n-            if let Some(ref last) = last_path_segment(ty_qpath).args;\n+            if let Some(last) = last_path_segment(ty_qpath).args;\n             if let Some(boxed_ty) = last.args.iter().find_map(|arg| match arg {\n                 GenericArg::Type(ty) => Some(ty),\n                 _ => None,"}, {"sha": "f4f5e1233e3512ec62ac53e1cbe489c9cc836708", "filename": "clippy_lints/src/undropped_manually_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fundropped_manually_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fundropped_manually_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fundropped_manually_drops.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -35,7 +35,7 @@ declare_lint_pass!(UndroppedManuallyDrops => [UNDROPPED_MANUALLY_DROPS]);\n \n impl LateLintPass<'tcx> for UndroppedManuallyDrops {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some(ref args) = match_function_call(cx, expr, &paths::DROP) {\n+        if let Some(args) = match_function_call(cx, expr, &paths::DROP) {\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n             if is_type_lang_item(cx, ty, lang_items::LangItem::ManuallyDrop) {\n                 span_lint_and_help("}, {"sha": "1c420a504272126ae8ad69d3830f75789933821d", "filename": "clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -116,8 +116,8 @@ fn check_arg<'tcx>(cx: &LateContext<'tcx>, arg: &'tcx Expr<'tcx>) -> Option<(Spa\n         let ty = cx.tcx.erase_late_bound_regions(ret_ty);\n         if ty.is_unit();\n         then {\n+            let body = cx.tcx.hir().body(body_id);\n             if_chain! {\n-                let body = cx.tcx.hir().body(body_id);\n                 if let ExprKind::Block(block, _) = body.value.kind;\n                 if block.expr.is_none();\n                 if let Some(stmt) = block.stmts.last();\n@@ -138,7 +138,7 @@ fn check_arg<'tcx>(cx: &LateContext<'tcx>, arg: &'tcx Expr<'tcx>) -> Option<(Spa\n \n impl<'tcx> LateLintPass<'tcx> for UnitReturnExpectingOrd {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if let ExprKind::MethodCall(_, _, ref args, _) = expr.kind {\n+        if let ExprKind::MethodCall(_, _, args, _) = expr.kind {\n             let arg_indices = get_args_to_check(cx, expr);\n             for (i, trait_name) in arg_indices {\n                 if i < args.len() {"}, {"sha": "fad647dfb2662ee4f380670e1c17f38a253d78fb", "filename": "clippy_lints/src/unit_types/let_unit_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -9,8 +9,8 @@ use rustc_middle::lint::in_external_macro;\n use super::LET_UNIT_VALUE;\n \n pub(super) fn check(cx: &LateContext<'_>, stmt: &Stmt<'_>) {\n-    if let StmtKind::Local(ref local) = stmt.kind {\n-        if cx.typeck_results().pat_ty(&local.pat).is_unit() {\n+    if let StmtKind::Local(local) = stmt.kind {\n+        if cx.typeck_results().pat_ty(local.pat).is_unit() {\n             if in_external_macro(cx.sess(), stmt.span) || local.pat.span.from_expansion() {\n                 return;\n             }"}, {"sha": "57be2d2f674cfdc2fa25bbb0fb826b2173fa2759", "filename": "clippy_lints/src/unit_types/unit_arg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -19,9 +19,9 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if is_questionmark_desugar_marked_call(expr) {\n         return;\n     }\n+    let map = &cx.tcx.hir();\n+    let opt_parent_node = map.find(map.get_parent_node(expr.hir_id));\n     if_chain! {\n-        let map = &cx.tcx.hir();\n-        let opt_parent_node = map.find(map.get_parent_node(expr.hir_id));\n         if let Some(hir::Node::Expr(parent_expr)) = opt_parent_node;\n         if is_questionmark_desugar_marked_call(parent_expr);\n         then {\n@@ -54,7 +54,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n fn is_questionmark_desugar_marked_call(expr: &Expr<'_>) -> bool {\n     use rustc_span::hygiene::DesugaringKind;\n-    if let ExprKind::Call(ref callee, _) = expr.kind {\n+    if let ExprKind::Call(callee, _) = expr.kind {\n         callee.span.is_desugaring(DesugaringKind::QuestionMark)\n     } else {\n         false"}, {"sha": "85257f3113cb774adc43f326707c0182b1eac616", "filename": "clippy_lints/src/unit_types/unit_cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Funit_cmp.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -9,7 +9,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if expr.span.from_expansion() {\n         if let Some(callee) = expr.span.source_callee() {\n             if let ExpnKind::Macro(MacroKind::Bang, symbol) = callee.kind {\n-                if let ExprKind::Binary(ref cmp, ref left, _) = expr.kind {\n+                if let ExprKind::Binary(ref cmp, left, _) = expr.kind {\n                     let op = cmp.node;\n                     if op.is_comparison() && cx.typeck_results().expr_ty(left).is_unit() {\n                         let result = match &*symbol.as_str() {\n@@ -34,7 +34,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         return;\n     }\n \n-    if let ExprKind::Binary(ref cmp, ref left, _) = expr.kind {\n+    if let ExprKind::Binary(ref cmp, left, _) = expr.kind {\n         let op = cmp.node;\n         if op.is_comparison() && cx.typeck_results().expr_ty(left).is_unit() {\n             let result = match op {"}, {"sha": "9a3750b2356bcae03de90b93db607621584c947c", "filename": "clippy_lints/src/unit_types/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funit_types%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funit_types%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Futils.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,5 +1,5 @@\n use rustc_hir::{Expr, ExprKind};\n \n pub(super) fn is_unit_literal(expr: &Expr<'_>) -> bool {\n-    matches!(expr.kind, ExprKind::Tup(ref slice) if slice.is_empty())\n+    matches!(expr.kind, ExprKind::Tup(slice) if slice.is_empty())\n }"}, {"sha": "9cca05b1f1a650744d698639616abe322f72a187", "filename": "clippy_lints/src/unnamed_address.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funnamed_address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funnamed_address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnamed_address.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -77,7 +77,7 @@ impl LateLintPass<'_> for UnnamedAddress {\n         }\n \n         if_chain! {\n-            if let ExprKind::Binary(binop, ref left, ref right) = expr.kind;\n+            if let ExprKind::Binary(binop, left, right) = expr.kind;\n             if is_comparison(binop.node);\n             if is_trait_ptr(cx, left) && is_trait_ptr(cx, right);\n             then {\n@@ -93,7 +93,7 @@ impl LateLintPass<'_> for UnnamedAddress {\n         }\n \n         if_chain! {\n-            if let ExprKind::Call(ref func, [ref _left, ref _right]) = expr.kind;\n+            if let ExprKind::Call(func, [ref _left, ref _right]) = expr.kind;\n             if let ExprKind::Path(ref func_qpath) = func.kind;\n             if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::PTR_EQ) ||\n@@ -114,10 +114,10 @@ impl LateLintPass<'_> for UnnamedAddress {\n         }\n \n         if_chain! {\n-            if let ExprKind::Binary(binop, ref left, ref right) = expr.kind;\n+            if let ExprKind::Binary(binop, left, right) = expr.kind;\n             if is_comparison(binop.node);\n-            if cx.typeck_results().expr_ty_adjusted(left).is_fn_ptr() &&\n-                cx.typeck_results().expr_ty_adjusted(right).is_fn_ptr();\n+            if cx.typeck_results().expr_ty_adjusted(left).is_fn_ptr();\n+            if cx.typeck_results().expr_ty_adjusted(right).is_fn_ptr();\n             if is_fn_def(cx, left) || is_fn_def(cx, right);\n             then {\n                 span_lint("}, {"sha": "347d858b640264caed856933662baee8e59f7e94", "filename": "clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -81,9 +81,8 @@ fn mirrored_exprs(\n         },\n         // Two arrays with mirrored contents\n         (ExprKind::Array(left_exprs), ExprKind::Array(right_exprs)) => {\n-            iter::zip(*left_exprs, *right_exprs)\n-                .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n-        }\n+            iter::zip(*left_exprs, *right_exprs).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+        },\n         // The two exprs are function calls.\n         // Check to see that the function itself and its arguments are mirrored\n         (ExprKind::Call(left_expr, left_args), ExprKind::Call(right_expr, right_args)) => {\n@@ -101,12 +100,11 @@ fn mirrored_exprs(\n             left_segment.ident == right_segment.ident\n                 && iter::zip(*left_args, *right_args)\n                     .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n-        }\n+        },\n         // Two tuples with mirrored contents\n         (ExprKind::Tup(left_exprs), ExprKind::Tup(right_exprs)) => {\n-            iter::zip(*left_exprs, *right_exprs)\n-                .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n-        }\n+            iter::zip(*left_exprs, *right_exprs).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+        },\n         // Two binary ops, which are the same operation and which have mirrored arguments\n         (ExprKind::Binary(left_op, left_left, left_right), ExprKind::Binary(right_op, right_left, right_right)) => {\n             left_op.node == right_op.node\n@@ -143,8 +141,7 @@ fn mirrored_exprs(\n                 },\n             )),\n         ) => {\n-            (iter::zip(*left_segments, *right_segments)\n-                .all(|(left, right)| left.ident == right.ident)\n+            (iter::zip(*left_segments, *right_segments).all(|(left, right)| left.ident == right.ident)\n                 && left_segments\n                     .iter()\n                     .all(|seg| &seg.ident != a_ident && &seg.ident != b_ident))\n@@ -182,15 +179,15 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n         if method_path.ident.name == sym::cmp;\n         then {\n             let (closure_body, closure_arg, reverse) = if mirrored_exprs(\n-                &cx,\n-                &left_expr,\n-                &left_ident,\n-                &right_expr,\n-                &right_ident\n+                cx,\n+                left_expr,\n+                left_ident,\n+                right_expr,\n+                right_ident\n             ) {\n-                (Sugg::hir(cx, &left_expr, \"..\").to_string(), left_ident.name.to_string(), false)\n-            } else if mirrored_exprs(&cx, &left_expr, &right_ident, &right_expr, &left_ident) {\n-                (Sugg::hir(cx, &left_expr, \"..\").to_string(), right_ident.name.to_string(), true)\n+                (Sugg::hir(cx, left_expr, \"..\").to_string(), left_ident.name.to_string(), false)\n+            } else if mirrored_exprs(cx, left_expr, right_ident, right_expr, left_ident) {\n+                (Sugg::hir(cx, left_expr, \"..\").to_string(), right_ident.name.to_string(), true)\n             } else {\n                 return None;\n             };"}, {"sha": "5bb417cb1be4b4d40a2cc04a3ca58516c442a193", "filename": "clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -103,7 +103,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n             if_chain! {\n                 if !in_macro(ret_expr.span);\n                 // Check if a function call.\n-                if let ExprKind::Call(ref func, ref args) = ret_expr.kind;\n+                if let ExprKind::Call(func, args) = ret_expr.kind;\n                 // Get the Path of the function call.\n                 if let ExprKind::Path(ref qpath) = func.kind;\n                 // Check if OPTION_SOME or RESULT_OK, depending on return type."}, {"sha": "9376a2cf66a90b1bd497498906e2e7111ccf2671", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,15 +1,19 @@\n #![allow(clippy::wildcard_imports, clippy::enum_glob_use)]\n \n-use clippy_utils::ast_utils::{eq_field_pat, eq_id, eq_pat, eq_path};\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::over;\n+use clippy_utils::{\n+    ast_utils::{eq_field_pat, eq_id, eq_pat, eq_path},\n+    meets_msrv,\n+};\n use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, Pat, PatKind, PatKind::*, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::DUMMY_SP;\n \n use std::cell::Cell;\n@@ -50,26 +54,50 @@ declare_clippy_lint! {\n     \"unnested or-patterns, e.g., `Foo(Bar) | Foo(Baz) instead of `Foo(Bar | Baz)`\"\n }\n \n-declare_lint_pass!(UnnestedOrPatterns => [UNNESTED_OR_PATTERNS]);\n+const UNNESTED_OR_PATTERNS_MSRV: RustcVersion = RustcVersion::new(1, 53, 0);\n+\n+#[derive(Clone, Copy)]\n+pub struct UnnestedOrPatterns {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl UnnestedOrPatterns {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(UnnestedOrPatterns => [UNNESTED_OR_PATTERNS]);\n \n impl EarlyLintPass for UnnestedOrPatterns {\n     fn check_arm(&mut self, cx: &EarlyContext<'_>, a: &ast::Arm) {\n-        lint_unnested_or_patterns(cx, &a.pat);\n+        if meets_msrv(self.msrv.as_ref(), &UNNESTED_OR_PATTERNS_MSRV) {\n+            lint_unnested_or_patterns(cx, &a.pat);\n+        }\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n-        if let ast::ExprKind::Let(pat, _) = &e.kind {\n-            lint_unnested_or_patterns(cx, pat);\n+        if meets_msrv(self.msrv.as_ref(), &UNNESTED_OR_PATTERNS_MSRV) {\n+            if let ast::ExprKind::Let(pat, _) = &e.kind {\n+                lint_unnested_or_patterns(cx, pat);\n+            }\n         }\n     }\n \n     fn check_param(&mut self, cx: &EarlyContext<'_>, p: &ast::Param) {\n-        lint_unnested_or_patterns(cx, &p.pat);\n+        if meets_msrv(self.msrv.as_ref(), &UNNESTED_OR_PATTERNS_MSRV) {\n+            lint_unnested_or_patterns(cx, &p.pat);\n+        }\n     }\n \n     fn check_local(&mut self, cx: &EarlyContext<'_>, l: &ast::Local) {\n-        lint_unnested_or_patterns(cx, &l.pat);\n+        if meets_msrv(self.msrv.as_ref(), &UNNESTED_OR_PATTERNS_MSRV) {\n+            lint_unnested_or_patterns(cx, &l.pat);\n+        }\n     }\n+\n+    extract_msrv_attr!(EarlyContext);\n }\n \n fn lint_unnested_or_patterns(cx: &EarlyContext<'_>, pat: &Pat) {"}, {"sha": "024ab03fd418ed02bcbfb3d4201898122ddad8f7", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -36,13 +36,13 @@ declare_lint_pass!(UnusedIoAmount => [UNUSED_IO_AMOUNT]);\n impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n     fn check_stmt(&mut self, cx: &LateContext<'_>, s: &hir::Stmt<'_>) {\n         let expr = match s.kind {\n-            hir::StmtKind::Semi(ref expr) | hir::StmtKind::Expr(ref expr) => &**expr,\n+            hir::StmtKind::Semi(expr) | hir::StmtKind::Expr(expr) => expr,\n             _ => return,\n         };\n \n         match expr.kind {\n-            hir::ExprKind::Match(ref res, _, _) if is_try(expr).is_some() => {\n-                if let hir::ExprKind::Call(ref func, ref args) = res.kind {\n+            hir::ExprKind::Match(res, _, _) if is_try(expr).is_some() => {\n+                if let hir::ExprKind::Call(func, args) = res.kind {\n                     if matches!(\n                         func.kind,\n                         hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::TryIntoResult, _))\n@@ -54,7 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n                 }\n             },\n \n-            hir::ExprKind::MethodCall(ref path, _, ref args, _) => match &*path.ident.as_str() {\n+            hir::ExprKind::MethodCall(path, _, args, _) => match &*path.ident.as_str() {\n                 \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n                     check_method_call(cx, &args[0], expr);\n                 },\n@@ -67,7 +67,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n }\n \n fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n-    if let hir::ExprKind::MethodCall(ref path, _, _, _) = call.kind {\n+    if let hir::ExprKind::MethodCall(path, _, _, _) = call.kind {\n         let symbol = &*path.ident.as_str();\n         let read_trait = match_trait_method(cx, call, &paths::IO_READ);\n         let write_trait = match_trait_method(cx, call, &paths::IO_WRITE);"}, {"sha": "15343cf90f2311931c86f6981dd08558b8d59349", "filename": "clippy_lints/src/unused_self.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_self.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -49,21 +49,18 @@ impl<'tcx> LateLintPass<'tcx> for UnusedSelf {\n             if assoc_item.fn_has_self_parameter;\n             if let ImplItemKind::Fn(.., body_id) = &impl_item.kind;\n             let body = cx.tcx.hir().body(*body_id);\n-            if !body.params.is_empty();\n+            if let [self_param, ..] = body.params;\n+            let self_hir_id = self_param.pat.hir_id;\n+            if !LocalUsedVisitor::new(cx, self_hir_id).check_body(body);\n             then {\n-                let self_param = &body.params[0];\n-                let self_hir_id = self_param.pat.hir_id;\n-                if !LocalUsedVisitor::new(cx, self_hir_id).check_body(body) {\n-                    span_lint_and_help(\n-                        cx,\n-                        UNUSED_SELF,\n-                        self_param.span,\n-                        \"unused `self` argument\",\n-                        None,\n-                        \"consider refactoring to a associated function\",\n-                    );\n-                    return;\n-                }\n+                span_lint_and_help(\n+                    cx,\n+                    UNUSED_SELF,\n+                    self_param.span,\n+                    \"unused `self` argument\",\n+                    None,\n+                    \"consider refactoring to a associated function\",\n+                );\n             }\n         }\n     }"}, {"sha": "ce2d0b3ab2f24962599d2ca957d5564641a2e193", "filename": "clippy_lints/src/unused_unit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_unit.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -45,7 +45,7 @@ impl EarlyLintPass for UnusedUnit {\n \n     fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         if_chain! {\n-            if let Some(ref stmt) = block.stmts.last();\n+            if let Some(stmt) = block.stmts.last();\n             if let ast::StmtKind::Expr(ref expr) = stmt.kind;\n             if is_unit_expr(expr) && !stmt.span.from_expansion();\n             then {"}, {"sha": "d4efee56efff53053a6c17a28db18a35298ca38f", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -166,8 +166,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         } else {\n             // find `unwrap[_err]()` calls:\n             if_chain! {\n-                if let ExprKind::MethodCall(ref method_name, _, ref args, _) = expr.kind;\n-                if let ExprKind::Path(QPath::Resolved(None, ref path)) = args[0].kind;\n+                if let ExprKind::MethodCall(method_name, _, args, _) = expr.kind;\n+                if let ExprKind::Path(QPath::Resolved(None, path)) = args[0].kind;\n                 if [sym::unwrap, sym!(unwrap_err)].contains(&method_name.ident.name);\n                 let call_to_unwrap = method_name.ident.name == sym::unwrap;\n                 if let Some(unwrappable) = self.unwrappables.iter()"}, {"sha": "d17aa6d842411e2ba252c40ea9a58bf793e0fd62", "filename": "clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -110,31 +110,27 @@ impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n }\n \n fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tcx hir::ImplItem<'_>) {\n-    if_chain! {\n+    if let ImplItemKind::Fn(_, body_id) = impl_item.kind {\n+        let body = cx.tcx.hir().body(body_id);\n+        let mut fpu = FindExpectUnwrap {\n+            lcx: cx,\n+            typeck_results: cx.tcx.typeck(impl_item.def_id),\n+            result: Vec::new(),\n+        };\n+        fpu.visit_expr(&body.value);\n \n-        if let ImplItemKind::Fn(_, body_id) = impl_item.kind;\n-        then {\n-            let body = cx.tcx.hir().body(body_id);\n-            let mut fpu = FindExpectUnwrap {\n-                lcx: cx,\n-                typeck_results: cx.tcx.typeck(impl_item.def_id),\n-                result: Vec::new(),\n-            };\n-            fpu.visit_expr(&body.value);\n-\n-            // if we've found one, lint\n-            if  !fpu.result.is_empty()  {\n-                span_lint_and_then(\n-                    cx,\n-                    UNWRAP_IN_RESULT,\n-                    impl_span,\n-                    \"used unwrap or expect in a function that returns result or option\",\n-                    move |diag| {\n-                        diag.help(\n-                            \"unwrap and expect should not be used in a function that returns result or option\" );\n-                        diag.span_note(fpu.result, \"potential non-recoverable error(s)\");\n-                    });\n-            }\n+        // if we've found one, lint\n+        if !fpu.result.is_empty() {\n+            span_lint_and_then(\n+                cx,\n+                UNWRAP_IN_RESULT,\n+                impl_span,\n+                \"used unwrap or expect in a function that returns result or option\",\n+                move |diag| {\n+                    diag.help(\"unwrap and expect should not be used in a function that returns result or option\");\n+                    diag.span_note(fpu.result, \"potential non-recoverable error(s)\");\n+                },\n+            );\n         }\n     }\n }"}, {"sha": "4ac2ec55b987d915ad8e1161f64bb19bbe1cbb56", "filename": "clippy_lints/src/upper_case_acronyms.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fupper_case_acronyms.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use if_chain::if_chain;\n use itertools::Itertools;\n-use rustc_ast::ast::{Item, ItemKind, Variant, VisibilityKind};\n+use rustc_ast::ast::{Item, ItemKind, VisibilityKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -99,21 +98,21 @@ fn check_ident(cx: &EarlyContext<'_>, ident: &Ident, be_aggressive: bool) {\n \n impl EarlyLintPass for UpperCaseAcronyms {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, it: &Item) {\n-        if_chain! {\n-            if !in_external_macro(cx.sess(), it.span);\n+        // do not lint public items or in macros\n+        if !in_external_macro(cx.sess(), it.span) && !matches!(it.vis.kind, VisibilityKind::Public) {\n             if matches!(\n                 it.kind,\n-                ItemKind::TyAlias(..) | ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Trait(..)\n-            );\n-            // do not lint public items\n-            if !matches!(it.vis.kind, VisibilityKind::Public);\n-            then {\n+                ItemKind::TyAlias(..) | ItemKind::Struct(..) | ItemKind::Trait(..)\n+            ) {\n                 check_ident(cx, &it.ident, self.upper_case_acronyms_aggressive);\n+            } else if let ItemKind::Enum(ref enumdef, _) = it.kind {\n+                // check enum variants seperately because again we only want to lint on private enums and\n+                // the fn check_variant does not know about the vis of the enum of its variants\n+                enumdef\n+                    .variants\n+                    .iter()\n+                    .for_each(|variant| check_ident(cx, &variant.ident, self.upper_case_acronyms_aggressive));\n             }\n         }\n     }\n-\n-    fn check_variant(&mut self, cx: &EarlyContext<'_>, v: &Variant) {\n-        check_ident(cx, &v.ident, self.upper_case_acronyms_aggressive);\n-    }\n }"}, {"sha": "c6a3c58a9a2a45c391f7191e93c1287e55779965", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -104,7 +104,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                 of_trait,\n                 ..\n             }) => {\n-                let should_check = if let TyKind::Path(QPath::Resolved(_, ref item_path)) = hir_self_ty.kind {\n+                let should_check = if let TyKind::Path(QPath::Resolved(_, item_path)) = hir_self_ty.kind {\n                     let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n                     parameters.as_ref().map_or(true, |params| {\n                         !params.parenthesized && !params.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n@@ -197,7 +197,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                 for (impl_hir_ty, trait_sem_ty) in impl_inputs_outputs.zip(trait_method_sig.inputs_and_output) {\n                     if trait_sem_ty.walk().any(|inner| inner == self_ty.into()) {\n                         let mut visitor = SkipTyCollector::default();\n-                        visitor.visit_ty(&impl_hir_ty);\n+                        visitor.visit_ty(impl_hir_ty);\n                         types_to_skip.extend(visitor.types_to_skip);\n                     }\n                 }\n@@ -333,7 +333,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                 // unit enum variants (`Enum::A`)\n                 ExprKind::Path(qpath) => {\n                     if expr_ty_matches(cx, expr, self_ty) {\n-                        span_lint_on_qpath_resolved(cx, &qpath, true);\n+                        span_lint_on_qpath_resolved(cx, qpath, true);\n                     }\n                 },\n                 _ => (),"}, {"sha": "7edb280be73eabb6ff0eef97fb3160414d7525e9", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -53,17 +53,17 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n         }\n \n         match e.kind {\n-            ExprKind::Match(_, ref arms, MatchSource::TryDesugar) => {\n+            ExprKind::Match(_, arms, MatchSource::TryDesugar) => {\n                 let e = match arms[0].body.kind {\n-                    ExprKind::Ret(Some(ref e)) | ExprKind::Break(_, Some(ref e)) => e,\n+                    ExprKind::Ret(Some(e)) | ExprKind::Break(_, Some(e)) => e,\n                     _ => return,\n                 };\n-                if let ExprKind::Call(_, ref args) = e.kind {\n+                if let ExprKind::Call(_, args) = e.kind {\n                     self.try_desugar_arm.push(args[0].hir_id);\n                 }\n             },\n \n-            ExprKind::MethodCall(ref name, .., ref args, _) => {\n+            ExprKind::MethodCall(name, .., args, _) => {\n                 if match_trait_method(cx, e, &paths::INTO) && &*name.ident.as_str() == \"into\" {\n                     let a = cx.typeck_results().expr_ty(e);\n                     let b = cx.typeck_results().expr_ty(&args[0]);\n@@ -82,7 +82,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                 }\n                 if match_trait_method(cx, e, &paths::INTO_ITERATOR) && name.ident.name == sym::into_iter {\n                     if let Some(parent_expr) = get_parent_expr(cx, e) {\n-                        if let ExprKind::MethodCall(ref parent_name, ..) = parent_expr.kind {\n+                        if let ExprKind::MethodCall(parent_name, ..) = parent_expr.kind {\n                             if parent_name.ident.name != sym::into_iter {\n                                 return;\n                             }\n@@ -103,38 +103,35 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                         );\n                     }\n                 }\n-                if match_trait_method(cx, e, &paths::TRY_INTO_TRAIT) && &*name.ident.as_str() == \"try_into\" {\n-                    if_chain! {\n-                        let a = cx.typeck_results().expr_ty(e);\n-                        let b = cx.typeck_results().expr_ty(&args[0]);\n-                        if is_type_diagnostic_item(cx, a, sym::result_type);\n-                        if let ty::Adt(_, substs) = a.kind();\n-                        if let Some(a_type) = substs.types().next();\n-                        if TyS::same_type(a_type, b);\n-\n-                        then {\n-                            span_lint_and_help(\n-                                cx,\n-                                USELESS_CONVERSION,\n-                                e.span,\n-                                &format!(\"useless conversion to the same type: `{}`\", b),\n-                                None,\n-                                \"consider removing `.try_into()`\",\n-                            );\n-                        }\n+                if_chain! {\n+                    if match_trait_method(cx, e, &paths::TRY_INTO_TRAIT) && &*name.ident.as_str() == \"try_into\";\n+                    let a = cx.typeck_results().expr_ty(e);\n+                    let b = cx.typeck_results().expr_ty(&args[0]);\n+                    if is_type_diagnostic_item(cx, a, sym::result_type);\n+                    if let ty::Adt(_, substs) = a.kind();\n+                    if let Some(a_type) = substs.types().next();\n+                    if TyS::same_type(a_type, b);\n+                    then {\n+                        span_lint_and_help(\n+                            cx,\n+                            USELESS_CONVERSION,\n+                            e.span,\n+                            &format!(\"useless conversion to the same type: `{}`\", b),\n+                            None,\n+                            \"consider removing `.try_into()`\",\n+                        );\n                     }\n                 }\n             },\n \n-            ExprKind::Call(ref path, ref args) => {\n+            ExprKind::Call(path, args) => {\n                 if_chain! {\n                     if args.len() == 1;\n                     if let ExprKind::Path(ref qpath) = path.kind;\n                     if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n-                    let a = cx.typeck_results().expr_ty(e);\n-                    let b = cx.typeck_results().expr_ty(&args[0]);\n-\n                     then {\n+                        let a = cx.typeck_results().expr_ty(e);\n+                        let b = cx.typeck_results().expr_ty(&args[0]);\n                         if_chain! {\n                             if match_def_path(cx, def_id, &paths::TRY_FROM);\n                             if is_type_diagnostic_item(cx, a, sym::result_type);"}, {"sha": "e70f8a09ebef1dd0aae22daccaab355ed176332b", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -203,13 +203,13 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n         print!(\"    if let ExprKind::\");\n         let current = format!(\"{}.kind\", self.current);\n         match expr.kind {\n-            ExprKind::Box(ref inner) => {\n+            ExprKind::Box(inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"Box(ref {}) = {};\", inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n-            ExprKind::Array(ref elements) => {\n+            ExprKind::Array(elements) => {\n                 let elements_pat = self.next(\"elements\");\n                 println!(\"Array(ref {}) = {};\", elements_pat, current);\n                 println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n@@ -218,7 +218,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.visit_expr(element);\n                 }\n             },\n-            ExprKind::Call(ref func, ref args) => {\n+            ExprKind::Call(func, args) => {\n                 let func_pat = self.next(\"func\");\n                 let args_pat = self.next(\"args\");\n                 println!(\"Call(ref {}, ref {}) = {};\", func_pat, args_pat, current);\n@@ -230,14 +230,14 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.visit_expr(arg);\n                 }\n             },\n-            ExprKind::MethodCall(ref _method_name, ref _generics, ref _args, ref _fn_span) => {\n+            ExprKind::MethodCall(_method_name, ref _generics, _args, ref _fn_span) => {\n                 println!(\n                     \"MethodCall(ref method_name, ref generics, ref args, ref fn_span) = {};\",\n                     current\n                 );\n                 println!(\"    // unimplemented: `ExprKind::MethodCall` is not further destructured at the moment\");\n             },\n-            ExprKind::Tup(ref elements) => {\n+            ExprKind::Tup(elements) => {\n                 let elements_pat = self.next(\"elements\");\n                 println!(\"Tup(ref {}) = {};\", elements_pat, current);\n                 println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n@@ -246,7 +246,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.visit_expr(element);\n                 }\n             },\n-            ExprKind::Binary(ref op, ref left, ref right) => {\n+            ExprKind::Binary(ref op, left, right) => {\n                 let op_pat = self.next(\"op\");\n                 let left_pat = self.next(\"left\");\n                 let right_pat = self.next(\"right\");\n@@ -260,7 +260,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = right_pat;\n                 self.visit_expr(right);\n             },\n-            ExprKind::Unary(ref op, ref inner) => {\n+            ExprKind::Unary(ref op, inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"Unary(UnOp::{:?}, ref {}) = {};\", op, inner_pat, current);\n                 self.current = inner_pat;\n@@ -296,7 +296,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     },\n                 }\n             },\n-            ExprKind::Cast(ref expr, ref ty) => {\n+            ExprKind::Cast(expr, ty) => {\n                 let cast_pat = self.next(\"expr\");\n                 let cast_ty = self.next(\"cast_ty\");\n                 let qp_label = self.next(\"qp\");\n@@ -310,24 +310,24 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n-            ExprKind::Type(ref expr, ref _ty) => {\n+            ExprKind::Type(expr, _ty) => {\n                 let cast_pat = self.next(\"expr\");\n                 println!(\"Type(ref {}, _) = {};\", cast_pat, current);\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n-            ExprKind::Loop(ref body, _, desugaring, _) => {\n+            ExprKind::Loop(body, _, desugaring, _) => {\n                 let body_pat = self.next(\"body\");\n                 let des = loop_desugaring_name(desugaring);\n                 let label_pat = self.next(\"label\");\n                 println!(\"Loop(ref {}, ref {}, {}) = {};\", body_pat, label_pat, des, current);\n                 self.current = body_pat;\n                 self.visit_block(body);\n             },\n-            ExprKind::If(ref cond, ref then, ref opt_else) => {\n+            ExprKind::If(cond, then, ref opt_else) => {\n                 let cond_pat = self.next(\"cond\");\n                 let then_pat = self.next(\"then\");\n-                if let Some(ref else_) = *opt_else {\n+                if let Some(else_) = *opt_else {\n                     let else_pat = self.next(\"else_\");\n                     println!(\n                         \"If(ref {}, ref {}, Some(ref {})) = {};\",\n@@ -343,7 +343,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = then_pat;\n                 self.visit_expr(then);\n             },\n-            ExprKind::Match(ref expr, ref arms, desugaring) => {\n+            ExprKind::Match(expr, arms, desugaring) => {\n                 let des = desugaring_name(desugaring);\n                 let expr_pat = self.next(\"expr\");\n                 let arms_pat = self.next(\"arms\");\n@@ -353,18 +353,18 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 println!(\"    if {}.len() == {};\", arms_pat, arms.len());\n                 for (i, arm) in arms.iter().enumerate() {\n                     self.current = format!(\"{}[{}].body\", arms_pat, i);\n-                    self.visit_expr(&arm.body);\n+                    self.visit_expr(arm.body);\n                     if let Some(ref guard) = arm.guard {\n                         let guard_pat = self.next(\"guard\");\n                         println!(\"    if let Some(ref {}) = {}[{}].guard;\", guard_pat, arms_pat, i);\n                         match guard {\n-                            hir::Guard::If(ref if_expr) => {\n+                            hir::Guard::If(if_expr) => {\n                                 let if_expr_pat = self.next(\"expr\");\n                                 println!(\"    if let Guard::If(ref {}) = {};\", if_expr_pat, guard_pat);\n                                 self.current = if_expr_pat;\n                                 self.visit_expr(if_expr);\n                             },\n-                            hir::Guard::IfLet(ref if_let_pat, ref if_let_expr) => {\n+                            hir::Guard::IfLet(if_let_pat, if_let_expr) => {\n                                 let if_let_pat_pat = self.next(\"pat\");\n                                 let if_let_expr_pat = self.next(\"expr\");\n                                 println!(\n@@ -379,26 +379,26 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                         }\n                     }\n                     self.current = format!(\"{}[{}].pat\", arms_pat, i);\n-                    self.visit_pat(&arm.pat);\n+                    self.visit_pat(arm.pat);\n                 }\n             },\n-            ExprKind::Closure(ref _capture_clause, ref _func, _, _, _) => {\n+            ExprKind::Closure(ref _capture_clause, _func, _, _, _) => {\n                 println!(\"Closure(ref capture_clause, ref func, _, _, _) = {};\", current);\n                 println!(\"    // unimplemented: `ExprKind::Closure` is not further destructured at the moment\");\n             },\n-            ExprKind::Yield(ref sub, _) => {\n+            ExprKind::Yield(sub, _) => {\n                 let sub_pat = self.next(\"sub\");\n                 println!(\"Yield(ref sub) = {};\", current);\n                 self.current = sub_pat;\n                 self.visit_expr(sub);\n             },\n-            ExprKind::Block(ref block, _) => {\n+            ExprKind::Block(block, _) => {\n                 let block_pat = self.next(\"block\");\n                 println!(\"Block(ref {}) = {};\", block_pat, current);\n                 self.current = block_pat;\n                 self.visit_block(block);\n             },\n-            ExprKind::Assign(ref target, ref value, _) => {\n+            ExprKind::Assign(target, value, _) => {\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n                 println!(\n@@ -410,7 +410,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             },\n-            ExprKind::AssignOp(ref op, ref target, ref value) => {\n+            ExprKind::AssignOp(ref op, target, value) => {\n                 let op_pat = self.next(\"op\");\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n@@ -424,15 +424,15 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             },\n-            ExprKind::Field(ref object, ref field_ident) => {\n+            ExprKind::Field(object, ref field_ident) => {\n                 let obj_pat = self.next(\"object\");\n                 let field_name_pat = self.next(\"field_name\");\n                 println!(\"Field(ref {}, ref {}) = {};\", obj_pat, field_name_pat, current);\n                 println!(\"    if {}.as_str() == {:?}\", field_name_pat, field_ident.as_str());\n                 self.current = obj_pat;\n                 self.visit_expr(object);\n             },\n-            ExprKind::Index(ref object, ref index) => {\n+            ExprKind::Index(object, index) => {\n                 let object_pat = self.next(\"object\");\n                 let index_pat = self.next(\"index\");\n                 println!(\"Index(ref {}, ref {}) = {};\", object_pat, index_pat, current);\n@@ -447,7 +447,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = path_pat;\n                 self.print_qpath(path);\n             },\n-            ExprKind::AddrOf(kind, mutability, ref inner) => {\n+            ExprKind::AddrOf(kind, mutability, inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\n                     \"AddrOf(BorrowKind::{:?}, Mutability::{:?}, ref {}) = {};\",\n@@ -458,7 +458,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n             },\n             ExprKind::Break(ref _destination, ref opt_value) => {\n                 let destination_pat = self.next(\"destination\");\n-                if let Some(ref value) = *opt_value {\n+                if let Some(value) = *opt_value {\n                     let value_pat = self.next(\"value\");\n                     println!(\"Break(ref {}, Some(ref {})) = {};\", destination_pat, value_pat, current);\n                     self.current = value_pat;\n@@ -474,7 +474,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 // FIXME: implement label printing\n             },\n             ExprKind::Ret(ref opt_value) => {\n-                if let Some(ref value) = *opt_value {\n+                if let Some(value) = *opt_value {\n                     let value_pat = self.next(\"value\");\n                     println!(\"Ret(Some(ref {})) = {};\", value_pat, current);\n                     self.current = value_pat;\n@@ -491,10 +491,10 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 println!(\"LlvmInlineAsm(_) = {};\", current);\n                 println!(\"    // unimplemented: `ExprKind::LlvmInlineAsm` is not further destructured at the moment\");\n             },\n-            ExprKind::Struct(ref path, ref fields, ref opt_base) => {\n+            ExprKind::Struct(path, fields, ref opt_base) => {\n                 let path_pat = self.next(\"path\");\n                 let fields_pat = self.next(\"fields\");\n-                if let Some(ref base) = *opt_base {\n+                if let Some(base) = *opt_base {\n                     let base_pat = self.next(\"base\");\n                     println!(\n                         \"Struct(ref {}, ref {}, Some(ref {})) = {};\",\n@@ -516,7 +516,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = value_pat;\n             },\n             // FIXME: compute length (needs type info)\n-            ExprKind::Repeat(ref value, _) => {\n+            ExprKind::Repeat(value, _) => {\n                 let value_pat = self.next(\"value\");\n                 println!(\"Repeat(ref {}, _) = {};\", value_pat, current);\n                 println!(\"// unimplemented: repeat count check\");\n@@ -526,7 +526,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n             ExprKind::Err => {\n                 println!(\"Err = {}\", current);\n             },\n-            ExprKind::DropTemps(ref expr) => {\n+            ExprKind::DropTemps(expr) => {\n                 let expr_pat = self.next(\"expr\");\n                 println!(\"DropTemps(ref {}) = {};\", expr_pat, current);\n                 self.current = expr_pat;\n@@ -560,7 +560,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     BindingAnnotation::RefMut => \"BindingAnnotation::RefMut\",\n                 };\n                 let name_pat = self.next(\"name\");\n-                if let Some(ref sub) = *sub {\n+                if let Some(sub) = *sub {\n                     let sub_pat = self.next(\"sub\");\n                     println!(\n                         \"Binding({}, _, {}, Some(ref {})) = {};\",\n@@ -573,7 +573,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 }\n                 println!(\"    if {}.as_str() == \\\"{}\\\";\", name_pat, ident.as_str());\n             },\n-            PatKind::Struct(ref path, ref fields, ignore) => {\n+            PatKind::Struct(ref path, fields, ignore) => {\n                 let path_pat = self.next(\"path\");\n                 let fields_pat = self.next(\"fields\");\n                 println!(\n@@ -585,13 +585,13 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n                 println!(\"    // unimplemented: field checks\");\n             },\n-            PatKind::Or(ref fields) => {\n+            PatKind::Or(fields) => {\n                 let fields_pat = self.next(\"fields\");\n                 println!(\"Or(ref {}) = {};\", fields_pat, current);\n                 println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n                 println!(\"    // unimplemented: field checks\");\n             },\n-            PatKind::TupleStruct(ref path, ref fields, skip_pos) => {\n+            PatKind::TupleStruct(ref path, fields, skip_pos) => {\n                 let path_pat = self.next(\"path\");\n                 let fields_pat = self.next(\"fields\");\n                 println!(\n@@ -609,25 +609,25 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = path_pat;\n                 self.print_qpath(path);\n             },\n-            PatKind::Tuple(ref fields, skip_pos) => {\n+            PatKind::Tuple(fields, skip_pos) => {\n                 let fields_pat = self.next(\"fields\");\n                 println!(\"Tuple(ref {}, {:?}) = {};\", fields_pat, skip_pos, current);\n                 println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n                 println!(\"    // unimplemented: field checks\");\n             },\n-            PatKind::Box(ref pat) => {\n+            PatKind::Box(pat) => {\n                 let pat_pat = self.next(\"pat\");\n                 println!(\"Box(ref {}) = {};\", pat_pat, current);\n                 self.current = pat_pat;\n                 self.visit_pat(pat);\n             },\n-            PatKind::Ref(ref pat, muta) => {\n+            PatKind::Ref(pat, muta) => {\n                 let pat_pat = self.next(\"pat\");\n                 println!(\"Ref(ref {}, Mutability::{:?}) = {};\", pat_pat, muta, current);\n                 self.current = pat_pat;\n                 self.visit_pat(pat);\n             },\n-            PatKind::Lit(ref lit_expr) => {\n+            PatKind::Lit(lit_expr) => {\n                 let lit_expr_pat = self.next(\"lit_expr\");\n                 println!(\"Lit(ref {}) = {}\", lit_expr_pat, current);\n                 self.current = lit_expr_pat;\n@@ -645,10 +645,10 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 self.current = end_pat;\n                 walk_list!(self, visit_expr, end);\n             },\n-            PatKind::Slice(ref start, ref middle, ref end) => {\n+            PatKind::Slice(start, ref middle, end) => {\n                 let start_pat = self.next(\"start\");\n                 let end_pat = self.next(\"end\");\n-                if let Some(ref middle) = middle {\n+                if let Some(middle) = middle {\n                     let middle_pat = self.next(\"middle\");\n                     println!(\n                         \"Slice(ref {}, Some(ref {}), ref {}) = {};\",\n@@ -678,33 +678,33 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n         let current = format!(\"{}.kind\", self.current);\n         match s.kind {\n             // A local (let) binding:\n-            StmtKind::Local(ref local) => {\n+            StmtKind::Local(local) => {\n                 let local_pat = self.next(\"local\");\n                 println!(\"Local(ref {}) = {};\", local_pat, current);\n-                if let Some(ref init) = local.init {\n+                if let Some(init) = local.init {\n                     let init_pat = self.next(\"init\");\n                     println!(\"    if let Some(ref {}) = {}.init;\", init_pat, local_pat);\n                     self.current = init_pat;\n                     self.visit_expr(init);\n                 }\n                 self.current = format!(\"{}.pat\", local_pat);\n-                self.visit_pat(&local.pat);\n+                self.visit_pat(local.pat);\n             },\n             // An item binding:\n             StmtKind::Item(_) => {\n                 println!(\"Item(item_id) = {};\", current);\n             },\n \n             // Expr without trailing semi-colon (must have unit type):\n-            StmtKind::Expr(ref e) => {\n+            StmtKind::Expr(e) => {\n                 let e_pat = self.next(\"e\");\n                 println!(\"Expr(ref {}, _) = {}\", e_pat, current);\n                 self.current = e_pat;\n                 self.visit_expr(e);\n             },\n \n             // Expr with trailing semi-colon (may have any type):\n-            StmtKind::Semi(ref e) => {\n+            StmtKind::Semi(e) => {\n                 let e_pat = self.next(\"e\");\n                 println!(\"Semi(ref {}, _) = {}\", e_pat, current);\n                 self.current = e_pat;\n@@ -752,7 +752,7 @@ fn loop_desugaring_name(des: hir::LoopSource) -> &'static str {\n \n fn print_path(path: &QPath<'_>, first: &mut bool) {\n     match *path {\n-        QPath::Resolved(_, ref path) => {\n+        QPath::Resolved(_, path) => {\n             for segment in path.segments {\n                 if *first {\n                     *first = false;\n@@ -762,7 +762,7 @@ fn print_path(path: &QPath<'_>, first: &mut bool) {\n                 print!(\"{:?}\", segment.ident.as_str());\n             }\n         },\n-        QPath::TypeRelative(ref ty, ref segment) => match ty.kind {\n+        QPath::TypeRelative(ty, segment) => match ty.kind {\n             hir::TyKind::Path(ref inner_path) => {\n                 print_path(inner_path, first);\n                 if *first {"}, {"sha": "147f823491d6dab7973d8eac8fad2283a1d4b7a8", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -106,7 +106,7 @@ macro_rules! define_Conf {\n \n pub use self::helpers::Conf;\n define_Conf! {\n-    /// Lint: REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN. The minimum rust version that the project supports\n+    /// Lint: REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, NEEDLESS_QUESTION_MARK, PTR_AS_PTR. The minimum rust version that the project supports\n     (msrv, \"msrv\": Option<String>, None),\n     /// Lint: BLACKLISTED_NAME. The list of blacklisted names to lint about. NB: `bar` is not here since it has legitimate uses\n     (blacklisted_names, \"blacklisted_names\": Vec<String>, [\"foo\", \"baz\", \"quux\"].iter().map(ToString::to_string).collect()),"}, {"sha": "4665eeeff7b21c2264c1469d0966cad2e7c780f7", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -47,7 +47,7 @@ impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n         match item.vis.node {\n             hir::VisibilityKind::Public => println!(\"public\"),\n             hir::VisibilityKind::Crate(_) => println!(\"visible crate wide\"),\n-            hir::VisibilityKind::Restricted { ref path, .. } => println!(\n+            hir::VisibilityKind::Restricted { path, .. } => println!(\n                 \"visible in module `{}`\",\n                 rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(path, false))\n             ),\n@@ -99,31 +99,31 @@ impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n         if !has_attr(cx.sess(), cx.tcx.hir().attrs(arm.hir_id)) {\n             return;\n         }\n-        print_pat(cx, &arm.pat, 1);\n+        print_pat(cx, arm.pat, 1);\n         if let Some(ref guard) = arm.guard {\n             println!(\"guard:\");\n             print_guard(cx, guard, 1);\n         }\n         println!(\"body:\");\n-        print_expr(cx, &arm.body, 1);\n+        print_expr(cx, arm.body, 1);\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n         if !has_attr(cx.sess(), cx.tcx.hir().attrs(stmt.hir_id)) {\n             return;\n         }\n         match stmt.kind {\n-            hir::StmtKind::Local(ref local) => {\n+            hir::StmtKind::Local(local) => {\n                 println!(\"local variable of type {}\", cx.typeck_results().node_type(local.hir_id));\n                 println!(\"pattern:\");\n-                print_pat(cx, &local.pat, 0);\n-                if let Some(ref e) = local.init {\n+                print_pat(cx, local.pat, 0);\n+                if let Some(e) = local.init {\n                     println!(\"init expression:\");\n                     print_expr(cx, e, 0);\n                 }\n             },\n             hir::StmtKind::Item(_) => println!(\"item decl\"),\n-            hir::StmtKind::Expr(ref e) | hir::StmtKind::Semi(ref e) => print_expr(cx, e, 0),\n+            hir::StmtKind::Expr(e) | hir::StmtKind::Semi(e) => print_expr(cx, e, 0),\n         }\n     }\n     // fn check_foreign_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx\n@@ -151,7 +151,7 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n         cx.typeck_results().adjustments().get(expr.hir_id)\n     );\n     match expr.kind {\n-        hir::ExprKind::Box(ref e) => {\n+        hir::ExprKind::Box(e) => {\n             println!(\"{}Box\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n@@ -161,7 +161,7 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprKind::Call(ref func, args) => {\n+        hir::ExprKind::Call(func, args) => {\n             println!(\"{}Call\", ind);\n             println!(\"{}function:\", ind);\n             print_expr(cx, func, indent + 1);\n@@ -170,7 +170,7 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n-        hir::ExprKind::MethodCall(ref path, _, args, _) => {\n+        hir::ExprKind::MethodCall(path, _, args, _) => {\n             println!(\"{}MethodCall\", ind);\n             println!(\"{}method name: {}\", ind, path.ident.name);\n             for arg in args {\n@@ -183,15 +183,15 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n+        hir::ExprKind::Binary(op, lhs, rhs) => {\n             println!(\"{}Binary\", ind);\n             println!(\"{}op: {:?}\", ind, op.node);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n-        hir::ExprKind::Unary(op, ref inner) => {\n+        hir::ExprKind::Unary(op, inner) => {\n             println!(\"{}Unary\", ind);\n             println!(\"{}op: {:?}\", ind, op);\n             print_expr(cx, inner, indent + 1);\n@@ -200,29 +200,29 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n             println!(\"{}Lit\", ind);\n             println!(\"{}{:?}\", ind, lit);\n         },\n-        hir::ExprKind::Cast(ref e, ref target) => {\n+        hir::ExprKind::Cast(e, target) => {\n             println!(\"{}Cast\", ind);\n             print_expr(cx, e, indent + 1);\n             println!(\"{}target type: {:?}\", ind, target);\n         },\n-        hir::ExprKind::Type(ref e, ref target) => {\n+        hir::ExprKind::Type(e, target) => {\n             println!(\"{}Type\", ind);\n             print_expr(cx, e, indent + 1);\n             println!(\"{}target type: {:?}\", ind, target);\n         },\n         hir::ExprKind::Loop(..) => {\n             println!(\"{}Loop\", ind);\n         },\n-        hir::ExprKind::If(ref cond, _, ref else_opt) => {\n+        hir::ExprKind::If(cond, _, ref else_opt) => {\n             println!(\"{}If\", ind);\n             println!(\"{}condition:\", ind);\n             print_expr(cx, cond, indent + 1);\n-            if let Some(ref els) = *else_opt {\n+            if let Some(els) = *else_opt {\n                 println!(\"{}else:\", ind);\n                 print_expr(cx, els, indent + 1);\n             }\n         },\n-        hir::ExprKind::Match(ref cond, _, ref source) => {\n+        hir::ExprKind::Match(cond, _, ref source) => {\n             println!(\"{}Match\", ind);\n             println!(\"{}condition:\", ind);\n             print_expr(cx, cond, indent + 1);\n@@ -232,72 +232,72 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n             println!(\"{}Closure\", ind);\n             println!(\"{}clause: {:?}\", ind, clause);\n         },\n-        hir::ExprKind::Yield(ref sub, _) => {\n+        hir::ExprKind::Yield(sub, _) => {\n             println!(\"{}Yield\", ind);\n             print_expr(cx, sub, indent + 1);\n         },\n         hir::ExprKind::Block(_, _) => {\n             println!(\"{}Block\", ind);\n         },\n-        hir::ExprKind::Assign(ref lhs, ref rhs, _) => {\n+        hir::ExprKind::Assign(lhs, rhs, _) => {\n             println!(\"{}Assign\", ind);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n-        hir::ExprKind::AssignOp(ref binop, ref lhs, ref rhs) => {\n+        hir::ExprKind::AssignOp(ref binop, lhs, rhs) => {\n             println!(\"{}AssignOp\", ind);\n             println!(\"{}op: {:?}\", ind, binop.node);\n             println!(\"{}lhs:\", ind);\n             print_expr(cx, lhs, indent + 1);\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n-        hir::ExprKind::Field(ref e, ident) => {\n+        hir::ExprKind::Field(e, ident) => {\n             println!(\"{}Field\", ind);\n             println!(\"{}field name: {}\", ind, ident.name);\n             println!(\"{}struct expr:\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n-        hir::ExprKind::Index(ref arr, ref idx) => {\n+        hir::ExprKind::Index(arr, idx) => {\n             println!(\"{}Index\", ind);\n             println!(\"{}array expr:\", ind);\n             print_expr(cx, arr, indent + 1);\n             println!(\"{}index expr:\", ind);\n             print_expr(cx, idx, indent + 1);\n         },\n-        hir::ExprKind::Path(hir::QPath::Resolved(ref ty, ref path)) => {\n+        hir::ExprKind::Path(hir::QPath::Resolved(ref ty, path)) => {\n             println!(\"{}Resolved Path, {:?}\", ind, ty);\n             println!(\"{}path: {:?}\", ind, path);\n         },\n-        hir::ExprKind::Path(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n+        hir::ExprKind::Path(hir::QPath::TypeRelative(ty, seg)) => {\n             println!(\"{}Relative Path, {:?}\", ind, ty);\n             println!(\"{}seg: {:?}\", ind, seg);\n         },\n         hir::ExprKind::Path(hir::QPath::LangItem(lang_item, ..)) => {\n             println!(\"{}Lang Item Path, {:?}\", ind, lang_item.name());\n         },\n-        hir::ExprKind::AddrOf(kind, ref muta, ref e) => {\n+        hir::ExprKind::AddrOf(kind, ref muta, e) => {\n             println!(\"{}AddrOf\", ind);\n             println!(\"kind: {:?}\", kind);\n             println!(\"mutability: {:?}\", muta);\n             print_expr(cx, e, indent + 1);\n         },\n         hir::ExprKind::Break(_, ref e) => {\n             println!(\"{}Break\", ind);\n-            if let Some(ref e) = *e {\n+            if let Some(e) = *e {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n         hir::ExprKind::Continue(_) => println!(\"{}Again\", ind),\n         hir::ExprKind::Ret(ref e) => {\n             println!(\"{}Ret\", ind);\n-            if let Some(ref e) = *e {\n+            if let Some(e) = *e {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprKind::InlineAsm(ref asm) => {\n+        hir::ExprKind::InlineAsm(asm) => {\n             println!(\"{}InlineAsm\", ind);\n             println!(\"{}template: {}\", ind, InlineAsmTemplatePiece::to_string(asm.template));\n             println!(\"{}options: {:?}\", ind, asm.options);\n@@ -321,11 +321,11 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n                     hir::InlineAsmOperand::Const { anon_const } => {\n                         println!(\"{}anon_const:\", ind);\n                         print_expr(cx, &cx.tcx.hir().body(anon_const.body).value, indent + 1);\n-                    }\n+                    },\n                 }\n             }\n         },\n-        hir::ExprKind::LlvmInlineAsm(ref asm) => {\n+        hir::ExprKind::LlvmInlineAsm(asm) => {\n             let inputs = &asm.inputs_exprs;\n             let outputs = &asm.outputs_exprs;\n             println!(\"{}LlvmInlineAsm\", ind);\n@@ -338,14 +338,14 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprKind::Struct(ref path, fields, ref base) => {\n+        hir::ExprKind::Struct(path, fields, ref base) => {\n             println!(\"{}Struct\", ind);\n             println!(\"{}path: {:?}\", ind, path);\n             for field in fields {\n                 println!(\"{}field \\\"{}\\\":\", ind, field.ident.name);\n-                print_expr(cx, &field.expr, indent + 1);\n+                print_expr(cx, field.expr, indent + 1);\n             }\n-            if let Some(ref base) = *base {\n+            if let Some(base) = *base {\n                 println!(\"{}base:\", ind);\n                 print_expr(cx, base, indent + 1);\n             }\n@@ -355,7 +355,7 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n             println!(\"{}anon_const:\", ind);\n             print_expr(cx, &cx.tcx.hir().body(anon_const.body).value, indent + 1);\n         },\n-        hir::ExprKind::Repeat(ref val, ref anon_const) => {\n+        hir::ExprKind::Repeat(val, ref anon_const) => {\n             println!(\"{}Repeat\", ind);\n             println!(\"{}value:\", ind);\n             print_expr(cx, val, indent + 1);\n@@ -365,7 +365,7 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n         hir::ExprKind::Err => {\n             println!(\"{}Err\", ind);\n         },\n-        hir::ExprKind::DropTemps(ref e) => {\n+        hir::ExprKind::DropTemps(e) => {\n             println!(\"{}DropTemps\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n@@ -378,7 +378,7 @@ fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n     match item.vis.node {\n         hir::VisibilityKind::Public => println!(\"public\"),\n         hir::VisibilityKind::Crate(_) => println!(\"visible crate wide\"),\n-        hir::VisibilityKind::Restricted { ref path, .. } => println!(\n+        hir::VisibilityKind::Restricted { path, .. } => println!(\n             \"visible in module `{}`\",\n             rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(path, false))\n         ),\n@@ -398,7 +398,7 @@ fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n                 println!(\"weird extern crate without a crate id\");\n             }\n         },\n-        hir::ItemKind::Use(ref path, ref kind) => println!(\"{:?}, {:?}\", path, kind),\n+        hir::ItemKind::Use(path, ref kind) => println!(\"{:?}, {:?}\", path, kind),\n         hir::ItemKind::Static(..) => println!(\"static item of type {:#?}\", cx.tcx.type_of(did)),\n         hir::ItemKind::Const(..) => println!(\"const item of type {:#?}\", cx.tcx.type_of(did)),\n         hir::ItemKind::Fn(..) => {\n@@ -407,7 +407,7 @@ fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n         },\n         hir::ItemKind::Mod(..) => println!(\"module\"),\n         hir::ItemKind::ForeignMod { abi, .. } => println!(\"foreign module with abi: {}\", abi),\n-        hir::ItemKind::GlobalAsm(ref asm) => println!(\"global asm: {:?}\", asm),\n+        hir::ItemKind::GlobalAsm(asm) => println!(\"global asm: {:?}\", asm),\n         hir::ItemKind::TyAlias(..) => {\n             println!(\"type alias for {:?}\", cx.tcx.type_of(did));\n         },\n@@ -457,7 +457,7 @@ fn print_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, indent: usize) {\n             println!(\"{}Binding\", ind);\n             println!(\"{}mode: {:?}\", ind, mode);\n             println!(\"{}name: {}\", ind, ident.name);\n-            if let Some(ref inner) = *inner {\n+            if let Some(inner) = *inner {\n                 println!(\"{}inner:\", ind);\n                 print_pat(cx, inner, indent + 1);\n             }\n@@ -482,7 +482,7 @@ fn print_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, indent: usize) {\n                 if field.is_shorthand {\n                     println!(\"{}  in shorthand notation\", ind);\n                 }\n-                print_pat(cx, &field.pat, indent + 1);\n+                print_pat(cx, field.pat, indent + 1);\n             }\n         },\n         hir::PatKind::TupleStruct(ref path, fields, opt_dots_position) => {\n@@ -499,11 +499,11 @@ fn print_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, indent: usize) {\n                 print_pat(cx, field, indent + 1);\n             }\n         },\n-        hir::PatKind::Path(hir::QPath::Resolved(ref ty, ref path)) => {\n+        hir::PatKind::Path(hir::QPath::Resolved(ref ty, path)) => {\n             println!(\"{}Resolved Path, {:?}\", ind, ty);\n             println!(\"{}path: {:?}\", ind, path);\n         },\n-        hir::PatKind::Path(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n+        hir::PatKind::Path(hir::QPath::TypeRelative(ty, seg)) => {\n             println!(\"{}Relative Path, {:?}\", ind, ty);\n             println!(\"{}seg: {:?}\", ind, seg);\n         },\n@@ -519,16 +519,16 @@ fn print_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, indent: usize) {\n                 print_pat(cx, field, indent + 1);\n             }\n         },\n-        hir::PatKind::Box(ref inner) => {\n+        hir::PatKind::Box(inner) => {\n             println!(\"{}Box\", ind);\n             print_pat(cx, inner, indent + 1);\n         },\n-        hir::PatKind::Ref(ref inner, ref muta) => {\n+        hir::PatKind::Ref(inner, ref muta) => {\n             println!(\"{}Ref\", ind);\n             println!(\"{}mutability: {:?}\", ind, muta);\n             print_pat(cx, inner, indent + 1);\n         },\n-        hir::PatKind::Lit(ref e) => {\n+        hir::PatKind::Lit(e) => {\n             println!(\"{}Lit\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n@@ -552,7 +552,7 @@ fn print_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, indent: usize) {\n                 print_pat(cx, pat, indent + 1);\n             }\n             println!(\"i:\");\n-            if let Some(ref pat) = *range {\n+            if let Some(pat) = *range {\n                 print_pat(cx, pat, indent + 1);\n             }\n             println!(\"[y, z]:\");"}, {"sha": "cf8039d6059b64a287483aedf4c2a2034fc37fc4", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 183, "deletions": 16, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,8 +1,10 @@\n use crate::consts::{constant_simple, Constant};\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg};\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n-use clippy_utils::{is_expn_of, match_def_path, match_qpath, method_calls, path_to_res, paths, run_lints, SpanlessEq};\n+use clippy_utils::{\n+    is_else_clause, is_expn_of, match_def_path, match_qpath, method_calls, path_to_res, paths, run_lints, SpanlessEq,\n+};\n use if_chain::if_chain;\n use rustc_ast::ast::{Crate as AstCrate, ItemKind, LitKind, ModKind, NodeId};\n use rustc_ast::visit::FnKind;\n@@ -14,15 +16,17 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BinOpKind, Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Node, Path, StmtKind, Ty, TyKind, UnOp,\n+    BinOpKind, Block, Crate, Expr, ExprKind, HirId, Item, Local, MatchSource, MutTy, Mutability, Node, Path, Stmt,\n+    StmtKind, Ty, TyKind, UnOp,\n };\n-use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::{Span, Spanned};\n+use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{Symbol, SymbolStr};\n+use rustc_span::{BytePos, Span};\n use rustc_typeck::hir_ty_to_ty;\n \n use std::borrow::{Borrow, Cow};\n@@ -297,6 +301,13 @@ declare_clippy_lint! {\n     \"unnecessary conversion between Symbol and string\"\n }\n \n+declare_clippy_lint! {\n+    /// Finds unidiomatic usage of `if_chain!`\n+    pub IF_CHAIN_STYLE,\n+    internal,\n+    \"non-idiomatic `if_chain!` usage\"\n+}\n+\n declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n@@ -342,12 +353,12 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n             return;\n         }\n \n-        if let hir::ItemKind::Static(ref ty, Mutability::Not, body_id) = item.kind {\n+        if let hir::ItemKind::Static(ty, Mutability::Not, body_id) = item.kind {\n             if is_lint_ref_type(cx, ty) {\n                 let expr = &cx.tcx.hir().body(body_id).value;\n                 if_chain! {\n-                    if let ExprKind::AddrOf(_, _, ref inner_exp) = expr.kind;\n-                    if let ExprKind::Struct(_, ref fields, _) = inner_exp.kind;\n+                    if let ExprKind::AddrOf(_, _, inner_exp) = expr.kind;\n+                    if let ExprKind::Struct(_, fields, _) = inner_exp.kind;\n                     let field = fields\n                         .iter()\n                         .find(|f| f.ident.as_str() == \"desc\")\n@@ -374,7 +385,7 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n         {\n             if let hir::ItemKind::Impl(hir::Impl {\n                 of_trait: None,\n-                items: ref impl_item_refs,\n+                items: impl_item_refs,\n                 ..\n             }) = item.kind\n             {\n@@ -426,7 +437,7 @@ fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &Ty<'_>) -> bool {\n     if let TyKind::Rptr(\n         _,\n         MutTy {\n-            ty: ref inner,\n+            ty: inner,\n             mutbl: Mutability::Not,\n         },\n     ) = ty.kind\n@@ -487,7 +498,7 @@ impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n         }\n \n         if_chain! {\n-            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = expr.kind;\n             let fn_name = path.ident;\n             if let Some(sugg) = self.map.get(&*fn_name.as_str());\n             let ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n@@ -566,7 +577,7 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n         }\n \n         if_chain! {\n-            if let ExprKind::Call(ref func, ref and_then_args) = expr.kind;\n+            if let ExprKind::Call(func, and_then_args) = expr.kind;\n             if let ExprKind::Path(ref path) = func.kind;\n             if match_qpath(path, &[\"span_lint_and_then\"]);\n             if and_then_args.len() == 5;\n@@ -576,10 +587,10 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n             let stmts = &block.stmts;\n             if stmts.len() == 1 && block.expr.is_none();\n             if let StmtKind::Semi(only_expr) = &stmts[0].kind;\n-            if let ExprKind::MethodCall(ref ps, _, ref span_call_args, _) = &only_expr.kind;\n-            let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n-            let mut sle = SpanlessEq::new(cx).deny_side_effects();\n+            if let ExprKind::MethodCall(ps, _, span_call_args, _) = &only_expr.kind;\n             then {\n+                let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n+                let mut sle = SpanlessEq::new(cx).deny_side_effects();\n                 match &*ps.ident.as_str() {\n                     \"span_suggestion\" if sle.eq_expr(&and_then_args[2], &span_call_args[1]) => {\n                         suggest_suggestion(cx, expr, &and_then_snippets, &span_suggestion_snippets(cx, span_call_args));\n@@ -751,7 +762,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n             // Check if this is a call to utils::match_type()\n             if let ExprKind::Call(fn_path, [context, ty, ty_path]) = expr.kind;\n             if let ExprKind::Path(fn_qpath) = &fn_path.kind;\n-            if match_qpath(&fn_qpath, &[\"utils\", \"match_type\"]);\n+            if match_qpath(fn_qpath, &[\"utils\", \"match_type\"]);\n             // Extract the path to the matched type\n             if let Some(segments) = path_to_matched_type(cx, ty_path);\n             let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n@@ -1063,3 +1074,159 @@ impl<'tcx> SymbolStrExpr<'tcx> {\n         }\n     }\n }\n+\n+declare_lint_pass!(IfChainStyle => [IF_CHAIN_STYLE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for IfChainStyle {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx hir::Block<'_>) {\n+        let (local, after, if_chain_span) = if_chain! {\n+            if let [Stmt { kind: StmtKind::Local(local), .. }, after @ ..] = block.stmts;\n+            if let Some(if_chain_span) = is_expn_of(block.span, \"if_chain\");\n+            then { (local, after, if_chain_span) } else { return }\n+        };\n+        if is_first_if_chain_expr(cx, block.hir_id, if_chain_span) {\n+            span_lint(\n+                cx,\n+                IF_CHAIN_STYLE,\n+                if_chain_local_span(cx, local, if_chain_span),\n+                \"`let` expression should be above the `if_chain!`\",\n+            );\n+        } else if local.span.ctxt() == block.span.ctxt() && is_if_chain_then(after, block.expr, if_chain_span) {\n+            span_lint(\n+                cx,\n+                IF_CHAIN_STYLE,\n+                if_chain_local_span(cx, local, if_chain_span),\n+                \"`let` expression should be inside `then { .. }`\",\n+            )\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        let (cond, then, els) = match expr.kind {\n+            ExprKind::If(cond, then, els) => (Some(cond), then, els.is_some()),\n+            ExprKind::Match(\n+                _,\n+                [arm, ..],\n+                MatchSource::IfLetDesugar {\n+                    contains_else_clause: els,\n+                },\n+            ) => (None, arm.body, els),\n+            _ => return,\n+        };\n+        let then_block = match then.kind {\n+            ExprKind::Block(block, _) => block,\n+            _ => return,\n+        };\n+        let if_chain_span = is_expn_of(expr.span, \"if_chain\");\n+        if !els {\n+            check_nested_if_chains(cx, expr, then_block, if_chain_span);\n+        }\n+        let if_chain_span = match if_chain_span {\n+            None => return,\n+            Some(span) => span,\n+        };\n+        // check for `if a && b;`\n+        if_chain! {\n+            if let Some(cond) = cond;\n+            if let ExprKind::Binary(op, _, _) = cond.kind;\n+            if op.node == BinOpKind::And;\n+            if cx.sess().source_map().is_multiline(cond.span);\n+            then {\n+                span_lint(cx, IF_CHAIN_STYLE, cond.span, \"`if a && b;` should be `if a; if b;`\");\n+            }\n+        }\n+        if is_first_if_chain_expr(cx, expr.hir_id, if_chain_span)\n+            && is_if_chain_then(then_block.stmts, then_block.expr, if_chain_span)\n+        {\n+            span_lint(cx, IF_CHAIN_STYLE, expr.span, \"`if_chain!` only has one `if`\")\n+        }\n+    }\n+}\n+\n+fn check_nested_if_chains(\n+    cx: &LateContext<'_>,\n+    if_expr: &Expr<'_>,\n+    then_block: &Block<'_>,\n+    if_chain_span: Option<Span>,\n+) {\n+    #[rustfmt::skip]\n+    let (head, tail) = match *then_block {\n+        Block { stmts, expr: Some(tail), .. } => (stmts, tail),\n+        Block {\n+            stmts: &[\n+                ref head @ ..,\n+                Stmt { kind: StmtKind::Expr(tail) | StmtKind::Semi(tail), .. }\n+            ],\n+            ..\n+        } => (head, tail),\n+        _ => return,\n+    };\n+    if_chain! {\n+        if matches!(tail.kind,\n+            ExprKind::If(_, _, None)\n+            | ExprKind::Match(.., MatchSource::IfLetDesugar { contains_else_clause: false }));\n+        let sm = cx.sess().source_map();\n+        if head\n+            .iter()\n+            .all(|stmt| matches!(stmt.kind, StmtKind::Local(..)) && !sm.is_multiline(stmt.span));\n+        if if_chain_span.is_some() || !is_else_clause(cx.tcx, if_expr);\n+        then {} else { return }\n+    }\n+    let (span, msg) = match (if_chain_span, is_expn_of(tail.span, \"if_chain\")) {\n+        (None, Some(_)) => (if_expr.span, \"this `if` can be part of the inner `if_chain!`\"),\n+        (Some(_), None) => (tail.span, \"this `if` can be part of the outer `if_chain!`\"),\n+        (Some(a), Some(b)) if a != b => (b, \"this `if_chain!` can be merged with the outer `if_chain!`\"),\n+        _ => return,\n+    };\n+    span_lint_and_then(cx, IF_CHAIN_STYLE, span, msg, |diag| {\n+        let (span, msg) = match head {\n+            [] => return,\n+            [stmt] => (stmt.span, \"this `let` statement can also be in the `if_chain!`\"),\n+            [a, .., b] => (\n+                a.span.to(b.span),\n+                \"these `let` statements can also be in the `if_chain!`\",\n+            ),\n+        };\n+        diag.span_help(span, msg);\n+    });\n+}\n+\n+fn is_first_if_chain_expr(cx: &LateContext<'_>, hir_id: HirId, if_chain_span: Span) -> bool {\n+    cx.tcx\n+        .hir()\n+        .parent_iter(hir_id)\n+        .find(|(_, node)| {\n+            #[rustfmt::skip]\n+            !matches!(node, Node::Expr(Expr { kind: ExprKind::Block(..), .. }) | Node::Stmt(_))\n+        })\n+        .map_or(false, |(id, _)| {\n+            is_expn_of(cx.tcx.hir().span(id), \"if_chain\") != Some(if_chain_span)\n+        })\n+}\n+\n+/// Checks a trailing slice of statements and expression of a `Block` to see if they are part\n+/// of the `then {..}` portion of an `if_chain!`\n+fn is_if_chain_then(stmts: &[Stmt<'_>], expr: Option<&Expr<'_>>, if_chain_span: Span) -> bool {\n+    let span = if let [stmt, ..] = stmts {\n+        stmt.span\n+    } else if let Some(expr) = expr {\n+        expr.span\n+    } else {\n+        // empty `then {}`\n+        return true;\n+    };\n+    is_expn_of(span, \"if_chain\").map_or(true, |span| span != if_chain_span)\n+}\n+\n+/// Creates a `Span` for `let x = ..;` in an `if_chain!` call.\n+fn if_chain_local_span(cx: &LateContext<'_>, local: &Local<'_>, if_chain_span: Span) -> Span {\n+    let mut span = local.pat.span;\n+    if let Some(init) = local.init {\n+        span = span.to(init.span);\n+    }\n+    span.adjust(if_chain_span.ctxt().outer_expn());\n+    let sm = cx.sess().source_map();\n+    let span = sm.span_extend_to_prev_str(span, \"let\", false);\n+    let span = sm.span_extend_to_next_char(span, ';', false);\n+    Span::new(span.lo() - BytePos(3), span.hi() + BytePos(1), span.ctxt())\n+}"}, {"sha": "febd4b6ff7b3c1533c302487e5df914ebf5ae96a", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -6,7 +6,7 @@ use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_copy;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -49,10 +49,10 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n         if_chain! {\n             if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(expr).kind();\n             if let ty::Slice(..) = ty.kind();\n-            if let ExprKind::AddrOf(BorrowKind::Ref, _, ref addressee) = expr.kind;\n+            if let ExprKind::AddrOf(BorrowKind::Ref, mutability, addressee) = expr.kind;\n             if let Some(vec_args) = higher::vec_macro(cx, addressee);\n             then {\n-                self.check_vec_macro(cx, &vec_args, expr.span);\n+                self.check_vec_macro(cx, &vec_args, mutability, expr.span);\n             }\n         }\n \n@@ -70,14 +70,20 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n                     .ctxt()\n                     .outer_expn_data()\n                     .call_site;\n-                self.check_vec_macro(cx, &vec_args, span);\n+                self.check_vec_macro(cx, &vec_args, Mutability::Not, span);\n             }\n         }\n     }\n }\n \n impl UselessVec {\n-    fn check_vec_macro<'tcx>(self, cx: &LateContext<'tcx>, vec_args: &higher::VecArgs<'tcx>, span: Span) {\n+    fn check_vec_macro<'tcx>(\n+        self,\n+        cx: &LateContext<'tcx>,\n+        vec_args: &higher::VecArgs<'tcx>,\n+        mutability: Mutability,\n+        span: Span,\n+    ) {\n         let mut applicability = Applicability::MachineApplicable;\n         let snippet = match *vec_args {\n             higher::VecArgs::Repeat(elem, len) => {\n@@ -87,11 +93,22 @@ impl UselessVec {\n                         return;\n                     }\n \n-                    format!(\n-                        \"&[{}; {}]\",\n-                        snippet_with_applicability(cx, elem.span, \"elem\", &mut applicability),\n-                        snippet_with_applicability(cx, len.span, \"len\", &mut applicability)\n-                    )\n+                    match mutability {\n+                        Mutability::Mut => {\n+                            format!(\n+                                \"&mut [{}; {}]\",\n+                                snippet_with_applicability(cx, elem.span, \"elem\", &mut applicability),\n+                                snippet_with_applicability(cx, len.span, \"len\", &mut applicability)\n+                            )\n+                        },\n+                        Mutability::Not => {\n+                            format!(\n+                                \"&[{}; {}]\",\n+                                snippet_with_applicability(cx, elem.span, \"elem\", &mut applicability),\n+                                snippet_with_applicability(cx, len.span, \"len\", &mut applicability)\n+                            )\n+                        },\n+                    }\n                 } else {\n                     return;\n                 }\n@@ -104,9 +121,22 @@ impl UselessVec {\n                     }\n                     let span = args[0].span.to(last.span);\n \n-                    format!(\"&[{}]\", snippet_with_applicability(cx, span, \"..\", &mut applicability))\n+                    match mutability {\n+                        Mutability::Mut => {\n+                            format!(\n+                                \"&mut [{}]\",\n+                                snippet_with_applicability(cx, span, \"..\", &mut applicability)\n+                            )\n+                        },\n+                        Mutability::Not => {\n+                            format!(\"&[{}]\", snippet_with_applicability(cx, span, \"..\", &mut applicability))\n+                        },\n+                    }\n                 } else {\n-                    \"&[]\".into()\n+                    match mutability {\n+                        Mutability::Mut => \"&mut []\".into(),\n+                        Mutability::Not => \"&[]\".into(),\n+                    }\n                 }\n             },\n         };"}, {"sha": "c7190e2f9798c67f88a17695282cdf704d7b91a9", "filename": "clippy_lints/src/vec_init_then_push.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -108,22 +108,21 @@ impl LateLintPass<'_> for VecInitThenPush {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if self.searcher.is_none() {\n-            if_chain! {\n-                if !in_external_macro(cx.sess(), expr.span);\n-                if let ExprKind::Assign(left, right, _) = expr.kind;\n-                if let Some(id) = path_to_local(left);\n-                if let Some(init_kind) = get_vec_init_kind(cx, right);\n-                then {\n-                    self.searcher = Some(VecPushSearcher {\n-                        local_id: id,\n-                        init: init_kind,\n-                        lhs_is_local: false,\n-                        lhs_span: left.span,\n-                        err_span: expr.span,\n-                        found: 0,\n-                    });\n-                }\n+        if_chain! {\n+            if self.searcher.is_none();\n+            if !in_external_macro(cx.sess(), expr.span);\n+            if let ExprKind::Assign(left, right, _) = expr.kind;\n+            if let Some(id) = path_to_local(left);\n+            if let Some(init_kind) = get_vec_init_kind(cx, right);\n+            then {\n+                self.searcher = Some(VecPushSearcher {\n+                    local_id: id,\n+                    init: init_kind,\n+                    lhs_is_local: false,\n+                    lhs_span: left.span,\n+                    err_span: expr.span,\n+                    found: 0,\n+                });\n             }\n         }\n     }"}, {"sha": "5540e87405ff9d083e742933639bca476c505da9", "filename": "clippy_lints/src/vec_resize_to_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -30,7 +30,7 @@ declare_lint_pass!(VecResizeToZero => [VEC_RESIZE_TO_ZERO]);\n impl<'tcx> LateLintPass<'tcx> for VecResizeToZero {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let hir::ExprKind::MethodCall(path_segment, _, ref args, _) = expr.kind;\n+            if let hir::ExprKind::MethodCall(path_segment, _, args, _) = expr.kind;\n             if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n             if match_def_path(cx, method_def_id, &paths::VEC_RESIZE) && args.len() == 3;\n             if let ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = args[1].kind;"}, {"sha": "350b1cf25ff05723711f4fde5f4a368db19aceb7", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -31,7 +31,7 @@ impl<'tcx> LateLintPass<'tcx> for ZeroDiv {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // check for instances of 0.0/0.0\n         if_chain! {\n-            if let ExprKind::Binary(ref op, ref left, ref right) = expr.kind;\n+            if let ExprKind::Binary(ref op, left, right) = expr.kind;\n             if let BinOpKind::Div = op.node;\n             // TODO - constant_simple does not fold many operations involving floats.\n             // That's probably fine for this lint - it's pretty unlikely that someone would"}, {"sha": "f93f0047f514f5100536a77500a8a1082c48356b", "filename": "clippy_lints/src/zero_sized_map_values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_sized_map_values.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -50,7 +50,7 @@ impl LateLintPass<'_> for ZeroSizedMapValues {\n             if !in_trait_impl(cx, hir_ty.hir_id);\n             let ty = ty_from_hir_ty(cx, hir_ty);\n             if is_type_diagnostic_item(cx, ty, sym::hashmap_type) || match_type(cx, ty, &paths::BTREEMAP);\n-            if let Adt(_, ref substs) = ty.kind();\n+            if let Adt(_, substs) = ty.kind();\n             let ty = substs.type_at(1);\n             // Do this to prevent `layout_of` crashing, being unable to fully normalize `ty`.\n             if is_normalizable(cx, cx.param_env, ty);"}, {"sha": "7ec8452bf4c67a5bee04738155ff324bdb08231b", "filename": "clippy_utils/src/attrs.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fattrs.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::ast;\n+use rustc_ast::{ast, attr};\n use rustc_errors::Applicability;\n use rustc_session::Session;\n use rustc_span::sym;\n@@ -148,3 +148,13 @@ pub fn get_unique_inner_attr(sess: &Session, attrs: &[ast::Attribute], name: &'s\n pub fn is_proc_macro(sess: &Session, attrs: &[ast::Attribute]) -> bool {\n     attrs.iter().any(|attr| sess.is_proc_macro_attr(attr))\n }\n+\n+/// Return true if the attributes contain `#[doc(hidden)]`\n+pub fn is_doc_hidden(attrs: &[ast::Attribute]) -> bool {\n+    #[allow(clippy::filter_map)]\n+    attrs\n+        .iter()\n+        .filter(|attr| attr.has_name(sym::doc))\n+        .flat_map(ast::Attribute::meta_item_list)\n+        .any(|l| attr::list_contains_name(&l, sym::hidden))\n+}"}, {"sha": "2a305d8bcbe0d1682b06840d864aac361df9d93d", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -140,12 +140,10 @@ impl Constant {\n             (&Self::F64(l), &Self::F64(r)) => l.partial_cmp(&r),\n             (&Self::F32(l), &Self::F32(r)) => l.partial_cmp(&r),\n             (&Self::Bool(ref l), &Self::Bool(ref r)) => Some(l.cmp(r)),\n-            (&Self::Tuple(ref l), &Self::Tuple(ref r)) | (&Self::Vec(ref l), &Self::Vec(ref r)) => {\n-                iter::zip(l, r)\n-                    .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n-                    .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n-                    .unwrap_or_else(|| Some(l.len().cmp(&r.len())))\n-            }\n+            (&Self::Tuple(ref l), &Self::Tuple(ref r)) | (&Self::Vec(ref l), &Self::Vec(ref r)) => iter::zip(l, r)\n+                .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n+                .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n+                .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n             (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => {\n                 match Self::partial_cmp(tcx, cmp_type, lv, rv) {\n                     Some(Equal) => Some(ls.cmp(rs)),"}, {"sha": "7f827f1759d2f9542a6fa53668b6aa7204f0507e", "filename": "clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fdiagnostics.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -133,9 +133,11 @@ pub fn span_lint_and_note<'a, T: LintContext>(\n ///\n /// If you need to customize your lint output a lot, use this function.\n /// If you change the signature, remember to update the internal lint `CollapsibleCalls`\n-pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str, f: F)\n+pub fn span_lint_and_then<C, S, F>(cx: &C, lint: &'static Lint, sp: S, msg: &str, f: F)\n where\n-    F: for<'b> FnOnce(&mut DiagnosticBuilder<'b>),\n+    C: LintContext,\n+    S: Into<MultiSpan>,\n+    F: FnOnce(&mut DiagnosticBuilder<'_>),\n {\n     cx.struct_span_lint(lint, sp, |diag| {\n         let mut diag = diag.build(msg);\n@@ -216,6 +218,11 @@ where\n     multispan_sugg_with_applicability(diag, help_msg, Applicability::Unspecified, sugg)\n }\n \n+/// Create a suggestion made from several `span \u2192 replacement`.\n+///\n+/// rustfix currently doesn't support the automatic application of suggestions with\n+/// multiple spans. This is tracked in issue [rustfix#141](https://github.com/rust-lang/rustfix/issues/141).\n+/// Suggestions with multiple spans will be silently ignored.\n pub fn multispan_sugg_with_applicability<I>(\n     diag: &mut DiagnosticBuilder<'_>,\n     help_msg: &str,"}, {"sha": "f695f1a61e716c19ef909b9d86b09018e845783c", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -2,9 +2,9 @@ use crate::consts::{constant_context, constant_simple};\n use crate::differing_macro_contexts;\n use crate::source::snippet_opt;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def::Res;\n+use rustc_hir::HirIdMap;\n use rustc_hir::{\n     BinOpKind, Block, BlockCheckMode, BodyId, BorrowKind, CaptureBy, Expr, ExprField, ExprKind, FnRetTy, GenericArg,\n     GenericArgs, Guard, HirId, InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatField, PatKind, Path,\n@@ -58,13 +58,14 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n \n     /// Use this method to wrap comparisons that may involve inter-expression context.\n     /// See `self.locals`.\n-    fn inter_expr(&mut self) -> HirEqInterExpr<'_, 'a, 'tcx> {\n+    pub fn inter_expr(&mut self) -> HirEqInterExpr<'_, 'a, 'tcx> {\n         HirEqInterExpr {\n             inner: self,\n-            locals: FxHashMap::default(),\n+            locals: HirIdMap::default(),\n         }\n     }\n \n+    #[allow(dead_code)]\n     pub fn eq_block(&mut self, left: &Block<'_>, right: &Block<'_>) -> bool {\n         self.inter_expr().eq_block(left, right)\n     }\n@@ -82,22 +83,24 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n }\n \n-struct HirEqInterExpr<'a, 'b, 'tcx> {\n+pub struct HirEqInterExpr<'a, 'b, 'tcx> {\n     inner: &'a mut SpanlessEq<'b, 'tcx>,\n \n     // When binding are declared, the binding ID in the left expression is mapped to the one on the\n     // right. For example, when comparing `{ let x = 1; x + 2 }` and `{ let y = 1; y + 2 }`,\n     // these blocks are considered equal since `x` is mapped to `y`.\n-    locals: FxHashMap<HirId, HirId>,\n+    locals: HirIdMap<HirId>,\n }\n \n impl HirEqInterExpr<'_, '_, '_> {\n-    fn eq_stmt(&mut self, left: &Stmt<'_>, right: &Stmt<'_>) -> bool {\n+    pub fn eq_stmt(&mut self, left: &Stmt<'_>, right: &Stmt<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n             (&StmtKind::Local(ref l), &StmtKind::Local(ref r)) => {\n-                self.eq_pat(&l.pat, &r.pat)\n+                // eq_pat adds the HirIds to the locals map. We therefor call it last to make sure that\n+                // these only get added if the init and type is equal.\n+                both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n                     && both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r))\n-                    && both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n+                    && self.eq_pat(&l.pat, &r.pat)\n             },\n             (&StmtKind::Expr(ref l), &StmtKind::Expr(ref r)) | (&StmtKind::Semi(ref l), &StmtKind::Semi(ref r)) => {\n                 self.eq_expr(l, r)\n@@ -159,7 +162,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n     }\n \n     #[allow(clippy::similar_names)]\n-    fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n+    pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n         if !self.inner.allow_side_effects && differing_macro_contexts(left.span, right.span) {\n             return false;\n         }\n@@ -483,6 +486,15 @@ pub fn over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -\n     left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n }\n \n+/// Counts how many elements of the slices are equal as per `eq_fn`.\n+pub fn count_eq<X: Sized>(\n+    left: &mut dyn Iterator<Item = X>,\n+    right: &mut dyn Iterator<Item = X>,\n+    mut eq_fn: impl FnMut(&X, &X) -> bool,\n+) -> usize {\n+    left.zip(right).take_while(|(l, r)| eq_fn(l, r)).count()\n+}\n+\n /// Checks if two expressions evaluate to the same value, and don't contain any side effects.\n pub fn eq_expr_value(cx: &LateContext<'_>, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n     SpanlessEq::new(cx).deny_side_effects().eq_expr(left, right)"}, {"sha": "c847712ec2e9e854353c509acc46749df82fc740", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 44, "deletions": 60, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -48,7 +48,7 @@ pub mod usage;\n pub mod visitors;\n \n pub use self::attrs::*;\n-pub use self::hir_utils::{both, eq_expr_value, over, SpanlessEq, SpanlessHash};\n+pub use self::hir_utils::{both, count_eq, eq_expr_value, over, SpanlessEq, SpanlessHash};\n \n use std::collections::hash_map::Entry;\n use std::hash::BuildHasherDefault;\n@@ -61,10 +61,9 @@ use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    def, Arm, BindingAnnotation, Block, Body, Constness, Expr, ExprKind, FieldDef, FnDecl, ForeignItem, GenericArgs,\n-    GenericParam, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind, LangItem, Lifetime, Local, MacroDef,\n-    MatchSource, Mod, Node, Param, Pat, PatKind, Path, PathSegment, QPath, Stmt, TraitItem, TraitItemKind, TraitRef,\n-    TyKind, Variant, Visibility,\n+    def, Arm, BindingAnnotation, Block, Body, Constness, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl, ImplItem,\n+    ImplItemKind, Item, ItemKind, LangItem, MatchSource, Node, Param, Pat, PatKind, Path, PathSegment, QPath,\n+    TraitItem, TraitItemKind, TraitRef, TyKind,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n@@ -76,7 +75,7 @@ use rustc_session::Session;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n use rustc_span::sym;\n-use rustc_span::symbol::{kw, Ident, Symbol};\n+use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n \n@@ -350,6 +349,10 @@ pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment\n     }\n }\n \n+/// THIS METHOD IS DEPRECATED and will eventually be removed since it does not match against the\n+/// entire path or resolved `DefId`. Prefer using `match_def_path`. Consider getting a `DefId` from\n+/// `QPath::Resolved.1.res.opt_def_id()`.\n+///\n /// Matches a `QPath` against a slice of segment string literals.\n ///\n /// There is also `match_path` if you are dealing with a `rustc_hir::Path` instead of a\n@@ -377,6 +380,10 @@ pub fn match_qpath(path: &QPath<'_>, segments: &[&str]) -> bool {\n     }\n }\n \n+/// THIS METHOD IS DEPRECATED and will eventually be removed since it does not match against the\n+/// entire path or resolved `DefId`. Prefer using `match_def_path`. Consider getting a `DefId` from\n+/// `QPath::Resolved.1.res.opt_def_id()`.\n+///\n /// Matches a `Path` against a slice of segment string literals.\n ///\n /// There is also `match_qpath` if you are dealing with a `rustc_hir::QPath` instead of a\n@@ -610,9 +617,9 @@ pub fn get_pat_name(pat: &Pat<'_>) -> Option<Symbol> {\n     }\n }\n \n-struct ContainsName {\n-    name: Symbol,\n-    result: bool,\n+pub struct ContainsName {\n+    pub name: Symbol,\n+    pub result: bool,\n }\n \n impl<'tcx> Visitor<'tcx> for ContainsName {\n@@ -713,41 +720,6 @@ fn line_span<T: LintContext>(cx: &T, span: Span) -> Span {\n     Span::new(line_start, span.hi(), span.ctxt())\n }\n \n-/// Gets the span of the node, if there is one.\n-pub fn get_node_span(node: Node<'_>) -> Option<Span> {\n-    match node {\n-        Node::Param(Param { span, .. })\n-        | Node::Item(Item { span, .. })\n-        | Node::ForeignItem(ForeignItem { span, .. })\n-        | Node::TraitItem(TraitItem { span, .. })\n-        | Node::ImplItem(ImplItem { span, .. })\n-        | Node::Variant(Variant { span, .. })\n-        | Node::Field(FieldDef { span, .. })\n-        | Node::Expr(Expr { span, .. })\n-        | Node::Stmt(Stmt { span, .. })\n-        | Node::PathSegment(PathSegment {\n-            ident: Ident { span, .. },\n-            ..\n-        })\n-        | Node::Ty(hir::Ty { span, .. })\n-        | Node::TraitRef(TraitRef {\n-            path: Path { span, .. },\n-            ..\n-        })\n-        | Node::Binding(Pat { span, .. })\n-        | Node::Pat(Pat { span, .. })\n-        | Node::Arm(Arm { span, .. })\n-        | Node::Block(Block { span, .. })\n-        | Node::Local(Local { span, .. })\n-        | Node::MacroDef(MacroDef { span, .. })\n-        | Node::Lifetime(Lifetime { span, .. })\n-        | Node::GenericParam(GenericParam { span, .. })\n-        | Node::Visibility(Visibility { span, .. })\n-        | Node::Crate(Mod { inner: span, .. }) => Some(*span),\n-        Node::Ctor(_) | Node::AnonConst(_) => None,\n-    }\n-}\n-\n /// Gets the parent node, if any.\n pub fn get_parent_node(tcx: TyCtxt<'_>, id: HirId) -> Option<Node<'_>> {\n     tcx.hir().parent_iter(id).next().map(|(_, node)| node)\n@@ -798,22 +770,29 @@ pub fn get_parent_as_impl(tcx: TyCtxt<'_>, id: HirId) -> Option<&Impl<'_>> {\n     }\n }\n \n-/// Checks if the given expression is the else clause in the expression `if let .. {} else {}`\n-pub fn is_else_clause_of_if_let_else(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n+/// Checks if the given expression is the else clause of either an `if` or `if let` expression.\n+pub fn is_else_clause(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n     let map = tcx.hir();\n     let mut iter = map.parent_iter(expr.hir_id);\n-    let arm_id = match iter.next() {\n-        Some((id, Node::Arm(..))) => id,\n-        _ => return false,\n-    };\n     match iter.next() {\n+        Some((arm_id, Node::Arm(..))) => matches!(\n+            iter.next(),\n+            Some((\n+                _,\n+                Node::Expr(Expr {\n+                    kind: ExprKind::Match(_, [_, else_arm], MatchSource::IfLetDesugar { .. }),\n+                    ..\n+                })\n+            ))\n+            if else_arm.hir_id == arm_id\n+        ),\n         Some((\n             _,\n             Node::Expr(Expr {\n-                kind: ExprKind::Match(_, [_, else_arm], kind),\n+                kind: ExprKind::If(_, _, Some(else_expr)),\n                 ..\n             }),\n-        )) => else_arm.hir_id == arm_id && matches!(kind, MatchSource::IfLetDesugar { .. }),\n+        )) => else_expr.hir_id == expr.hir_id,\n         _ => false,\n     }\n }\n@@ -1210,6 +1189,8 @@ pub fn if_sequence<'tcx>(mut expr: &'tcx Expr<'tcx>) -> (Vec<&'tcx Expr<'tcx>>,\n     (conds, blocks)\n }\n \n+/// This function returns true if the given expression is the `else` or `if else` part of an if\n+/// statement\n pub fn parent_node_is_if_expr(expr: &Expr<'_>, cx: &LateContext<'_>) -> bool {\n     let map = cx.tcx.hir();\n     let parent_id = map.get_parent_node(expr.hir_id);\n@@ -1223,16 +1204,9 @@ pub fn parent_node_is_if_expr(expr: &Expr<'_>, cx: &LateContext<'_>) -> bool {\n     )\n }\n \n-// Finds the attribute with the given name, if any\n-pub fn attr_by_name<'a>(attrs: &'a [Attribute], name: &'_ str) -> Option<&'a Attribute> {\n-    attrs\n-        .iter()\n-        .find(|attr| attr.ident().map_or(false, |ident| ident.as_str() == name))\n-}\n-\n // Finds the `#[must_use]` attribute, if any\n pub fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n-    attr_by_name(attrs, \"must_use\")\n+    attrs.iter().find(|a| a.has_name(sym::must_use))\n }\n \n // check if expr is calling method or function with #[must_use] attribute\n@@ -1320,6 +1294,16 @@ pub fn fn_def_id(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<DefId> {\n     }\n }\n \n+/// This function checks if any of the lints in the slice is enabled for the provided `HirId`.\n+/// A lint counts as enabled with any of the levels: `Level::Forbid` | `Level::Deny` | `Level::Warn`\n+///\n+/// ```ignore\n+/// #[deny(clippy::YOUR_AWESOME_LINT)]\n+/// println!(\"Hello, World!\"); // <- Clippy code: run_lints(cx, &[YOUR_AWESOME_LINT], id) == true\n+///\n+/// #[allow(clippy::YOUR_AWESOME_LINT)]\n+/// println!(\"See you soon!\"); // <- Clippy code: run_lints(cx, &[YOUR_AWESOME_LINT], id) == false\n+/// ```\n pub fn run_lints(cx: &LateContext<'_>, lints: &[&'static Lint], id: HirId) -> bool {\n     lints.iter().any(|lint| {\n         matches!("}, {"sha": "3b4c4070c0ed38999580d460db3e22cb1b3aba69", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -26,6 +26,7 @@ pub const DEFAULT_TRAIT: [&str; 3] = [\"core\", \"default\", \"Default\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n pub const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n+pub const DIR_BUILDER: [&str; 3] = [\"std\", \"fs\", \"DirBuilder\"];\n pub const DISPLAY_FMT_METHOD: [&str; 4] = [\"core\", \"fmt\", \"Display\", \"fmt\"];\n pub const DISPLAY_TRAIT: [&str; 3] = [\"core\", \"fmt\", \"Display\"];\n pub const DOUBLE_ENDED_ITERATOR: [&str; 4] = [\"core\", \"iter\", \"traits\", \"DoubleEndedIterator\"];\n@@ -92,9 +93,10 @@ pub(super) const PANIC_ANY: [&str; 3] = [\"std\", \"panic\", \"panic_any\"];\n pub const PARKING_LOT_MUTEX_GUARD: [&str; 2] = [\"parking_lot\", \"MutexGuard\"];\n pub const PARKING_LOT_RWLOCK_READ_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockReadGuard\"];\n pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockWriteGuard\"];\n-pub const PATH_BUF: [&str; 3] = [\"std\", \"path\", \"PathBuf\"];\n pub const PATH_BUF_AS_PATH: [&str; 4] = [\"std\", \"path\", \"PathBuf\", \"as_path\"];\n pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n+pub const PERMISSIONS: [&str; 3] = [\"std\", \"fs\", \"Permissions\"];\n+pub const PERMISSIONS_FROM_MODE: [&str; 7] = [\"std\", \"sys\", \"unix\", \"ext\", \"fs\", \"PermissionsExt\", \"from_mode\"];\n pub const POLL: [&str; 4] = [\"core\", \"task\", \"poll\", \"Poll\"];\n pub const POLL_PENDING: [&str; 5] = [\"core\", \"task\", \"poll\", \"Poll\", \"Pending\"];\n pub const POLL_READY: [&str; 5] = [\"core\", \"task\", \"poll\", \"Poll\", \"Ready\"];"}, {"sha": "b52cbf31e35aad71c4f8a31c704633e6b5dab059", "filename": "clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -210,21 +210,19 @@ fn check_statement(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId, statemen\n         StatementKind::Assign(box (place, rval)) => {\n             check_place(tcx, *place, span, body)?;\n             check_rvalue(tcx, body, def_id, rval, span)\n-        }\n+        },\n \n         StatementKind::FakeRead(box (_, place)) => check_place(tcx, *place, span, body),\n         // just an assignment\n         StatementKind::SetDiscriminant { place, .. } => check_place(tcx, **place, span, body),\n \n         StatementKind::LlvmInlineAsm { .. } => Err((span, \"cannot use inline assembly in const fn\".into())),\n \n-        StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping{\n-          dst, src, count,\n-        }) => {\n-          check_operand(tcx, dst, span, body)?;\n-          check_operand(tcx, src, span, body)?;\n-          check_operand(tcx, count, span, body)\n-        }\n+        StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping { dst, src, count }) => {\n+            check_operand(tcx, dst, span, body)?;\n+            check_operand(tcx, src, span, body)?;\n+            check_operand(tcx, count, span, body)\n+        },\n         // These are all NOPs\n         StatementKind::StorageLive(_)\n         | StatementKind::StorageDead(_)"}, {"sha": "0633a19391f8633d281567ac0986bf088d25cb8d", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -267,17 +267,44 @@ impl<'a> Sugg<'a> {\n             Sugg::NonParen(..) => self,\n             // `(x)` and `(x).y()` both don't need additional parens.\n             Sugg::MaybeParen(sugg) => {\n-                if sugg.starts_with('(') && sugg.ends_with(')') {\n+                if has_enclosing_paren(&sugg) {\n                     Sugg::MaybeParen(sugg)\n                 } else {\n                     Sugg::NonParen(format!(\"({})\", sugg).into())\n                 }\n             },\n-            Sugg::BinOp(_, sugg) => Sugg::NonParen(format!(\"({})\", sugg).into()),\n+            Sugg::BinOp(_, sugg) => {\n+                if has_enclosing_paren(&sugg) {\n+                    Sugg::NonParen(sugg)\n+                } else {\n+                    Sugg::NonParen(format!(\"({})\", sugg).into())\n+                }\n+            },\n         }\n     }\n }\n \n+/// Return `true` if `sugg` is enclosed in parenthesis.\n+fn has_enclosing_paren(sugg: impl AsRef<str>) -> bool {\n+    let mut chars = sugg.as_ref().chars();\n+    if let Some('(') = chars.next() {\n+        let mut depth = 1;\n+        while let Some(c) = chars.next() {\n+            if c == '(' {\n+                depth += 1;\n+            } else if c == ')' {\n+                depth -= 1;\n+            }\n+            if depth == 0 {\n+                break;\n+            }\n+        }\n+        chars.next().is_none()\n+    } else {\n+        false\n+    }\n+}\n+\n // Copied from the rust standart library, and then edited\n macro_rules! forward_binop_impls_to_ref {\n     (impl $imp:ident, $method:ident for $t:ty, type Output = $o:ty) => {\n@@ -668,6 +695,8 @@ impl<T: LintContext> DiagnosticBuilderExt<T> for rustc_errors::DiagnosticBuilder\n #[cfg(test)]\n mod test {\n     use super::Sugg;\n+\n+    use rustc_ast::util::parser::AssocOp;\n     use std::borrow::Cow;\n \n     const SUGGESTION: Sugg<'static> = Sugg::NonParen(Cow::Borrowed(\"function_call()\"));\n@@ -681,4 +710,13 @@ mod test {\n     fn blockify_transforms_sugg_into_a_block() {\n         assert_eq!(\"{ function_call() }\", SUGGESTION.blockify().to_string());\n     }\n+\n+    #[test]\n+    fn binop_maybe_par() {\n+        let sugg = Sugg::BinOp(AssocOp::Add, \"(1 + 1)\".into());\n+        assert_eq!(\"(1 + 1)\", sugg.maybe_par().to_string());\n+\n+        let sugg = Sugg::BinOp(AssocOp::Add, \"(1 + 1) + (1 + 1)\".into());\n+        assert_eq!(\"((1 + 1) + (1 + 1))\", sugg.maybe_par().to_string());\n+    }\n }"}, {"sha": "650b70c63af9534de621d959c29cbcc5d4bd35e3", "filename": "clippy_utils/src/usage.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/clippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fusage.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,9 +1,9 @@\n use crate as utils;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::intravisit;\n use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n+use rustc_hir::HirIdSet;\n use rustc_hir::{Expr, ExprKind, HirId, Path};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n@@ -13,9 +13,9 @@ use rustc_middle::ty;\n use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n \n /// Returns a set of mutated local variable IDs, or `None` if mutations could not be determined.\n-pub fn mutated_variables<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) -> Option<FxHashSet<HirId>> {\n+pub fn mutated_variables<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) -> Option<HirIdSet> {\n     let mut delegate = MutVarsDelegate {\n-        used_mutably: FxHashSet::default(),\n+        used_mutably: HirIdSet::default(),\n         skip: false,\n     };\n     cx.tcx.infer_ctxt().enter(|infcx| {\n@@ -44,7 +44,7 @@ pub fn is_potentially_mutated<'tcx>(variable: &'tcx Path<'_>, expr: &'tcx Expr<'\n }\n \n struct MutVarsDelegate {\n-    used_mutably: FxHashSet<HirId>,\n+    used_mutably: HirIdSet,\n     skip: bool,\n }\n "}, {"sha": "99b86953d51a6287ceccb8bcb9207d881b0f368e", "filename": "doc/adding_lints.md", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -18,7 +18,7 @@ because that's clearly a non-descriptive name.\n   - [Lint passes](#lint-passes)\n   - [Emitting a lint](#emitting-a-lint)\n   - [Adding the lint logic](#adding-the-lint-logic)\n-  - [Specifying the lint's minimum supported Rust version (msrv)](#specifying-the-lints-minimum-supported-rust-version-msrv)\n+  - [Specifying the lint's minimum supported Rust version (MSRV)](#specifying-the-lints-minimum-supported-rust-version-msrv)\n   - [Author lint](#author-lint)\n   - [Documentation](#documentation)\n   - [Running rustfmt](#running-rustfmt)\n@@ -388,18 +388,19 @@ pass.\n [`FnKind::Fn`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_ast/visit/enum.FnKind.html#variant.Fn\n [ident]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Ident.html\n \n-## Specifying the lint's minimum supported Rust version (msrv)\n+## Specifying the lint's minimum supported Rust version (MSRV)\n \n-Projects supporting older versions of Rust would need to disable a lint if it targets features\n-present in later versions. Support for this can be added by specifying an msrv in your lint like so,\n+Projects supporting older versions of Rust would need to disable a lint if it\n+targets features present in later versions. Support for this can be added by\n+specifying an MSRV in your lint like so,\n \n ```rust\n const MANUAL_STRIP_MSRV: RustcVersion = RustcVersion::new(1, 45, 0);\n ```\n \n-The project's msrv will also have to be an attribute in the lint so you'll have to add a struct\n-and constructor for your lint. The project's msrv needs to be passed when the lint is registered\n-in `lib.rs`\n+The project's MSRV will also have to be an attribute in the lint so you'll have\n+to add a struct and constructor for your lint. The project's MSRV needs to be\n+passed when the lint is registered in `lib.rs`\n \n ```rust\n pub struct ManualStrip {\n@@ -414,18 +415,19 @@ impl ManualStrip {\n }\n ```\n \n-The project's msrv can then be matched against the lint's msrv in the LintPass using the `meets_msrv` utility\n-function.\n+The project's MSRV can then be matched against the lint's `msrv` in the LintPass\n+using the `meets_msrv` utility function.\n \n ``` rust\n if !meets_msrv(self.msrv.as_ref(), &MANUAL_STRIP_MSRV) {\n     return;\n }\n ```\n \n-The project's msrv can also be specified as an inner attribute, which overrides the value from\n-`clippy.toml`. This can be accounted for using the `extract_msrv_attr!(LintContext)` macro and passing\n-LateContext/EarlyContext.\n+The project's MSRV can also be specified as an inner attribute, which overrides\n+the value from `clippy.toml`. This can be accounted for using the\n+`extract_msrv_attr!(LintContext)` macro and passing\n+`LateContext`/`EarlyContext`.\n \n ```rust\n impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n@@ -436,8 +438,20 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n }\n ```\n \n-Once the msrv is added to the lint, a relevant test case should be added to `tests/ui/min_rust_version_attr.rs`\n-which verifies that the lint isn't emitted if the project's msrv is lower.\n+Once the `msrv` is added to the lint, a relevant test case should be added to\n+`tests/ui/min_rust_version_attr.rs` which verifies that the lint isn't emitted\n+if the project's MSRV is lower.\n+\n+As a last step, the lint should be added to the lint documentation. This is done\n+in `clippy_lints/src/utils/conf.rs`:\n+\n+```rust\n+define_Conf! {\n+    /// Lint: LIST, OF, LINTS, <THE_NEWLY_ADDED_LINT>. The minimum rust version that the project supports\n+    (msrv, \"msrv\": Option<String>, None),\n+    ...\n+}\n+```\n \n ## Author lint\n \n@@ -533,9 +547,9 @@ Before submitting your PR make sure you followed all of the basic requirements:\n \n ## Adding configuration to a lint\n \n-Clippy supports the configuration of lints values using a `clippy.toml` file in the workspace \n+Clippy supports the configuration of lints values using a `clippy.toml` file in the workspace\n directory. Adding a configuration to a lint can be useful for thresholds or to constrain some\n-behavior that can be seen as a false positive for some users. Adding a configuration is done \n+behavior that can be seen as a false positive for some users. Adding a configuration is done\n in the following steps:\n \n 1. Adding a new configuration entry to [clippy_utils::conf](/clippy_utils/src/conf.rs)\n@@ -544,10 +558,10 @@ in the following steps:\n     /// Lint: LINT_NAME. <The configuration field doc comment>\n     (configuration_ident, \"configuration_value\": Type, DefaultValue),\n     ```\n-    The configuration value and identifier should usually be the same. The doc comment will be \n+    The configuration value and identifier should usually be the same. The doc comment will be\n     automatically added to the lint documentation.\n 2. Adding the configuration value to the lint impl struct:\n-    1. This first requires the definition of a lint impl struct. Lint impl structs are usually \n+    1. This first requires the definition of a lint impl struct. Lint impl structs are usually\n         generated with the `declare_lint_pass!` macro. This struct needs to be defined manually\n         to add some kind of metadata to it:\n         ```rust\n@@ -564,7 +578,7 @@ in the following steps:\n             LINT_NAME\n         ]);\n         ```\n-    \n+\n     2. Next add the configuration value and a corresponding creation method like this:\n         ```rust\n         #[derive(Copy, Clone)]\n@@ -584,7 +598,7 @@ in the following steps:\n         ```\n 3. Passing the configuration value to the lint impl struct:\n \n-    First find the struct construction in the [clippy_lints lib file](/clippy_lints/src/lib.rs). \n+    First find the struct construction in the [clippy_lints lib file](/clippy_lints/src/lib.rs).\n     The configuration value is now cloned or copied into a local value that is then passed to the\n     impl struct like this:\n     ```rust\n@@ -601,9 +615,9 @@ in the following steps:\n \n 4. Adding tests:\n     1. The default configured value can be tested like any normal lint in [`tests/ui`](/tests/ui).\n-    2. The configuration itself will be tested separately in [`tests/ui-toml`](/tests/ui-toml). \n-        Simply add a new subfolder with a fitting name. This folder contains a `clippy.toml` file \n-        with the configuration value and a rust file that should be linted by Clippy. The test can \n+    2. The configuration itself will be tested separately in [`tests/ui-toml`](/tests/ui-toml).\n+        Simply add a new subfolder with a fitting name. This folder contains a `clippy.toml` file\n+        with the configuration value and a rust file that should be linted by Clippy. The test can\n         otherwise be written as usual.\n \n ## Cheatsheet"}, {"sha": "8f22bd656836c882fddbbdba867b8454f4aa6512", "filename": "lintcheck-logs/lintcheck_crates_logs.txt", "status": "modified", "additions": 146, "deletions": 34, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/lintcheck-logs%2Flintcheck_crates_logs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/lintcheck-logs%2Flintcheck_crates_logs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck-logs%2Flintcheck_crates_logs.txt?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,12 +1,12 @@\n-clippy 0.1.52 (94d1c0a96 2021-03-11)\n+clippy 0.1.53 (0b7671963 2021-03-31)\n \n target/lintcheck/sources/anyhow-1.0.38/build.rs:1:null clippy::cargo_common_metadata \"package `anyhow` is missing `package.keywords` metadata\"\n target/lintcheck/sources/anyhow-1.0.38/src/error.rs:350:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n target/lintcheck/sources/anyhow-1.0.38/src/lib.rs:1:null clippy::cargo_common_metadata \"package `anyhow` is missing `package.keywords` metadata\"\n-target/lintcheck/sources/async-trait-0.1.42/registry/src/github.com-1ecc6299db9ec823/syn-1.0.63/src/custom_keyword.rs:201:9 clippy::expl_impl_clone_on_copy \"you are implementing `Clone` explicitly on a `Copy` type\"\n target/lintcheck/sources/async-trait-0.1.42/src/expand.rs:130:1 clippy::too_many_lines \"this function has too many lines (104/100)\"\n target/lintcheck/sources/async-trait-0.1.42/src/expand.rs:156:26 clippy::default_trait_access \"calling `syn::token::Where::default()` is more clear than this expression\"\n target/lintcheck/sources/async-trait-0.1.42/src/expand.rs:259:1 clippy::too_many_lines \"this function has too many lines (204/100)\"\n+target/lintcheck/sources/async-trait-0.1.42/src/expand.rs:387:17 clippy::match_wildcard_for_single_variants \"wildcard matches only a single variant and will also match any future added variants\"\n target/lintcheck/sources/async-trait-0.1.42/src/expand.rs:414:35 clippy::shadow_unrelated \"`generics` is being shadowed\"\n target/lintcheck/sources/async-trait-0.1.42/src/expand.rs:464:32 clippy::if_not_else \"unnecessary `!=` operation\"\n target/lintcheck/sources/async-trait-0.1.42/src/lib.rs:102:7 clippy::doc_markdown \"you should put `async_trait` between ticks in the documentation\"\n@@ -88,7 +88,6 @@ target/lintcheck/sources/cargo-0.49.0/src/bin/cargo/commands/yank.rs:32:36 clipp\n target/lintcheck/sources/cargo-0.49.0/src/bin/cargo/commands/yank.rs:33:35 clippy::redundant_closure_for_method_calls \"redundant closure\"\n target/lintcheck/sources/cargo-0.49.0/src/bin/cargo/commands/yank.rs:34:36 clippy::redundant_closure_for_method_calls \"redundant closure\"\n target/lintcheck/sources/cargo-0.49.0/src/bin/cargo/commands/yank.rs:35:36 clippy::redundant_closure_for_method_calls \"redundant closure\"\n-target/lintcheck/sources/cargo-0.49.0/src/bin/cargo/main.rs:100:17 clippy::match_wildcard_for_single_variants \"wildcard match will miss any future added variants\"\n target/lintcheck/sources/cargo-0.49.0/src/bin/cargo/main.rs:118:41 clippy::redundant_closure_for_method_calls \"redundant closure\"\n target/lintcheck/sources/cargo-0.49.0/src/bin/cargo/main.rs:137:43 clippy::redundant_closure_for_method_calls \"redundant closure\"\n target/lintcheck/sources/cargo-0.49.0/src/bin/cargo/main.rs:148:19 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n@@ -101,7 +100,6 @@ target/lintcheck/sources/cargo-0.49.0/src/bin/cargo/main.rs:1:null clippy::multi\n target/lintcheck/sources/cargo-0.49.0/src/bin/cargo/main.rs:1:null clippy::multiple_crate_versions \"multiple versions for dependency `humantime`: 1.3.0, 2.0.0\"\n target/lintcheck/sources/cargo-0.49.0/src/bin/cargo/main.rs:72:22 clippy::redundant_closure_for_method_calls \"redundant closure\"\n target/lintcheck/sources/cargo-0.49.0/src/bin/cargo/main.rs:79:40 clippy::manual_map \"manual implementation of `Option::map`\"\n-target/lintcheck/sources/cargo-0.49.0/src/bin/cargo/main.rs:94:13 clippy::match_wildcard_for_single_variants \"wildcard match will miss any future added variants\"\n target/lintcheck/sources/cargo-0.49.0/src/bin/cargo/main.rs:98:60 clippy::redundant_closure_for_method_calls \"redundant closure\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/build_config.rs:155:13 clippy::enum_glob_use \"usage of wildcard import for enum variants\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/build_config.rs:170:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n@@ -125,7 +123,7 @@ target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/build_context/targ\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:469:58 clippy::redundant_closure_for_method_calls \"redundant closure\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:603:19 clippy::redundant_closure_for_method_calls \"redundant closure\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:665:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:697:12 clippy::inconsistent_struct_constructor \"inconsistent struct constructor\"\n+target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:697:12 clippy::inconsistent_struct_constructor \"struct constructor field order is inconsistent with struct definition field order\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:82:31 clippy::doc_markdown \"you should put `FileType` between ticks in the documentation\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:83:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/build_context/target_info.rs:84:9 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n@@ -255,6 +253,8 @@ target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/job_queue.rs:871:1\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/job_queue.rs:890:9 clippy::unused_self \"unused `self` argument\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/job_queue.rs:93:24 clippy::doc_markdown \"you should put `JobQueue` between ticks in the documentation\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/links.rs:8:1 clippy::module_name_repetitions \"item name ends with its containing module's name\"\n+target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/lto.rs:130:13 clippy::unnested_or_patterns \"unnested or-patterns\"\n+target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/lto.rs:135:13 clippy::unnested_or_patterns \"unnested or-patterns\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/mod.rs:1016:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/mod.rs:1094:19 clippy::redundant_closure_for_method_calls \"redundant closure\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/mod.rs:1131:1 clippy::unnecessary_wraps \"this function's return value is unnecessary\"\n@@ -271,6 +271,7 @@ target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/mod.rs:392:45 clip\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/mod.rs:415:23 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/mod.rs:464:18 clippy::ptr_arg \"writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/mod.rs:488:61 clippy::ptr_arg \"writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\"\n+target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/mod.rs:498:21 clippy::unnested_or_patterns \"unnested or-patterns\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/mod.rs:654:46 clippy::implicit_clone \"implicitly cloning a `PathBuf` by calling `to_path_buf` on its dereferenced type\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/mod.rs:667:15 clippy::similar_names \"binding's name is too similar to existing binding\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/mod.rs:693:1 clippy::unnecessary_wraps \"this function's return value is unnecessary\"\n@@ -279,7 +280,6 @@ target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/mod.rs:736:1 clipp\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/mod.rs:73:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/mod.rs:777:12 clippy::if_not_else \"unnecessary boolean `not` operation\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/mod.rs:873:5 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n-target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/output_depinfo.rs:41:13 clippy::match_wildcard_for_single_variants \"wildcard match will miss any future added variants\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/rustdoc.rs:16:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/rustdoc.rs:57:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/compiler/rustdoc.rs:72:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n@@ -554,7 +554,6 @@ target/lintcheck/sources/cargo-0.49.0/src/cargo/core/resolver/context.rs:42:1 cl\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/resolver/context.rs:74:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/resolver/encode.rs:156:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/resolver/encode.rs:156:5 clippy::too_many_lines \"this function has too many lines (164/100)\"\n-target/lintcheck/sources/cargo-0.49.0/src/cargo/core/resolver/encode.rs:339:17 clippy::match_wildcard_for_single_variants \"wildcard match will miss any future added variants\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/resolver/encode.rs:438:5 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/resolver/encode.rs:449:5 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/resolver/encode.rs:529:34 clippy::redundant_closure_for_method_calls \"redundant closure\"\n@@ -636,6 +635,7 @@ target/lintcheck/sources/cargo-0.49.0/src/cargo/core/shell.rs:130:9 clippy::sing\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/shell.rs:148:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/shell.rs:153:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/shell.rs:163:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n+target/lintcheck/sources/cargo-0.49.0/src/cargo/core/shell.rs:166:13 clippy::match_wildcard_for_single_variants \"wildcard matches only a single variant and will also match any future added variants\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/shell.rs:18:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/shell.rs:198:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/shell.rs:206:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n@@ -781,6 +781,7 @@ target/lintcheck/sources/cargo-0.49.0/src/cargo/core/workspace.rs:267:5 clippy::\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/workspace.rs:317:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/workspace.rs:329:37 clippy::doc_markdown \"you should put `VirtualManifest` between ticks in the documentation\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/workspace.rs:410:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n+target/lintcheck/sources/cargo-0.49.0/src/cargo/core/workspace.rs:420:17 clippy::match_wildcard_for_single_variants \"wildcard matches only a single variant and will also match any future added variants\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/workspace.rs:440:9 clippy::unnecessary_wraps \"this function's return value is unnecessarily wrapped by `Result`\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/workspace.rs:511:32 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/core/workspace.rs:561:25 clippy::non_ascii_literal \"literal non-ASCII character detected\"\n@@ -964,6 +965,7 @@ target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/registry.rs:510:1 clippy::mi\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/registry.rs:529:5 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/registry.rs:53:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/registry.rs:53:1 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n+target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/registry.rs:573:17 clippy::match_wildcard_for_single_variants \"wildcard matches only a single variant and will also match any future added variants\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/registry.rs:573:22 clippy::match_same_arms \"this `match` has identical arm bodies\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/registry.rs:608:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/registry.rs:621:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n@@ -990,7 +992,9 @@ target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/resolve.rs:58:1 clippy::modu\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/resolve.rs:602:5 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/resolve.rs:75:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/resolve.rs:75:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n+target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/tree/format/mod.rs:103:21 clippy::match_wildcard_for_single_variants \"wildcard matches only a single variant and will also match any future added variants\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/tree/graph.rs:129:26 clippy::doc_markdown \"you should put `PackageIds` between ticks in the documentation\"\n+target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/tree/graph.rs:137:17 clippy::match_wildcard_for_single_variants \"wildcard matches only a single variant and will also match any future added variants\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/tree/graph.rs:152:15 clippy::match_on_vec_items \"indexing into a vector may panic\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/tree/graph.rs:173:9 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/tree/graph.rs:234:46 clippy::filter_map \"called `filter(..).flat_map(..)` on an `Iterator`\"\n@@ -1010,10 +1014,10 @@ target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/vendor.rs:14:1 clippy::modul\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/vendor.rs:215:9 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/vendor.rs:21:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/vendor.rs:21:1 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n+target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/vendor.rs:311:13 clippy::unnested_or_patterns \"unnested or-patterns\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/vendor.rs:314:34 clippy::match_same_arms \"this `match` has identical arm bodies\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/vendor.rs:320:29 clippy::case_sensitive_file_extension_comparisons \"case-sensitive file extension comparison\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/vendor.rs:320:60 clippy::case_sensitive_file_extension_comparisons \"case-sensitive file extension comparison\"\n-target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/vendor.rs:324:13 clippy::match_wildcard_for_single_variants \"wildcard match will miss any future added variants\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/ops/vendor.rs:70:1 clippy::too_many_lines \"this function has too many lines (175/100)\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/sources/config.rs:102:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/sources/config.rs:111:28 clippy::needless_question_mark \"question mark operator is useless here\"\n@@ -1167,6 +1171,7 @@ target/lintcheck/sources/cargo-0.49.0/src/cargo/util/config/mod.rs:1323:9 clippy\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/config/mod.rs:1339:39 clippy::unused_self \"unused `self` argument\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/config/mod.rs:1344:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/config/mod.rs:1420:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n+target/lintcheck/sources/cargo-0.49.0/src/cargo/util/config/mod.rs:1531:13 clippy::unnested_or_patterns \"unnested or-patterns\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/config/mod.rs:1553:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/config/mod.rs:1560:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/config/mod.rs:1567:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n@@ -1187,7 +1192,6 @@ target/lintcheck/sources/cargo-0.49.0/src/cargo/util/config/mod.rs:1778:1 clippy\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/config/mod.rs:1804:1 clippy::module_name_repetitions \"item name ends with its containing module's name\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/config/mod.rs:1896:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/config/mod.rs:1901:5 clippy::doc_markdown \"you should put `StringList` between ticks in the documentation\"\n-target/lintcheck/sources/cargo-0.49.0/src/cargo/util/config/mod.rs:214:13 clippy::match_wildcard_for_single_variants \"wildcard match will miss any future added variants\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/config/mod.rs:259:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/config/mod.rs:298:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/config/mod.rs:311:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n@@ -1242,6 +1246,8 @@ target/lintcheck/sources/cargo-0.49.0/src/cargo/util/errors.rs:150:5 clippy::mus\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/errors.rs:15:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/errors.rs:237:5 clippy::pub_enum_variant_names \"variant name ends with the enum's name\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/errors.rs:245:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n+target/lintcheck/sources/cargo-0.49.0/src/cargo/util/errors.rs:289:21 clippy::match_wildcard_for_single_variants \"wildcard matches only a single variant and will also match any future added variants\"\n+target/lintcheck/sources/cargo-0.49.0/src/cargo/util/errors.rs:293:13 clippy::match_wildcard_for_single_variants \"wildcard matches only a single variant and will also match any future added variants\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/errors.rs:321:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/errors.rs:328:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/errors.rs:356:1 clippy::must_use_candidate \"this function could have a `#[must_use]` attribute\"\n@@ -1348,7 +1354,7 @@ target/lintcheck/sources/cargo-0.49.0/src/cargo/util/process_builder.rs:185:5 cl\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/process_builder.rs:190:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/process_builder.rs:218:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/process_builder.rs:218:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n-target/lintcheck/sources/cargo-0.49.0/src/cargo/util/process_builder.rs:278:22 clippy::inconsistent_struct_constructor \"inconsistent struct constructor\"\n+target/lintcheck/sources/cargo-0.49.0/src/cargo/util/process_builder.rs:278:22 clippy::inconsistent_struct_constructor \"struct constructor field order is inconsistent with struct definition field order\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/process_builder.rs:307:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/process_builder.rs:343:39 clippy::needless_pass_by_value \"this argument is passed by value, but not consumed in the function body\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/progress.rs:122:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n@@ -1448,6 +1454,8 @@ target/lintcheck/sources/cargo-0.49.0/src/cargo/util/workspace.rs:56:1 clippy::m\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/workspace.rs:60:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cargo-0.49.0/src/cargo/util/workspace.rs:64:1 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/error.rs:107:13 clippy::enum_glob_use \"usage of wildcard import for enum variants\"\n+target/lintcheck/sources/cfg-expr-0.7.1/src/error.rs:55:13 clippy::unnested_or_patterns \"unnested or-patterns\"\n+target/lintcheck/sources/cfg-expr-0.7.1/src/error.rs:58:13 clippy::unnested_or_patterns \"unnested or-patterns\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/error.rs:5:1 clippy::module_name_repetitions \"item name ends with its containing module's name\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/error.rs:74:13 clippy::enum_glob_use \"usage of wildcard import for enum variants\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/error.rs:91:24 clippy::if_not_else \"unnecessary boolean `not` operation\"\n@@ -1458,6 +1466,7 @@ target/lintcheck/sources/cfg-expr-0.7.1/src/expr/lexer.rs:58:5 clippy::must_use_\n target/lintcheck/sources/cfg-expr-0.7.1/src/expr/lexer.rs:76:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/expr/lexer.rs:97:9 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/expr/mod.rs:351:13 clippy::enum_glob_use \"usage of wildcard import for enum variants\"\n+target/lintcheck/sources/cfg-expr-0.7.1/src/expr/mod.rs:408:13 clippy::match_wildcard_for_single_variants \"wildcard matches only a single variant and will also match any future added variants\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/expr/mod.rs:464:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/expr/mod.rs:57:13 clippy::enum_glob_use \"usage of wildcard import for enum variants\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/expr/mod.rs:586:33 clippy::match_same_arms \"this `match` has identical arm bodies\"\n@@ -1467,12 +1476,25 @@ target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:116:31 clippy::simila\n target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:124:36 clippy::similar_names \"binding's name is too similar to existing binding\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:17:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:17:5 clippy::too_many_lines \"this function has too many lines (345/100)\"\n+target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:211:21 clippy::unnested_or_patterns \"unnested or-patterns\"\n+target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:211:21 clippy::unnested_or_patterns \"unnested or-patterns\"\n+target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:211:21 clippy::unnested_or_patterns \"unnested or-patterns\"\n+target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:211:21 clippy::unnested_or_patterns \"unnested or-patterns\"\n+target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:211:21 clippy::unnested_or_patterns \"unnested or-patterns\"\n+target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:211:21 clippy::unnested_or_patterns \"unnested or-patterns\"\n+target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:211:21 clippy::unnested_or_patterns \"unnested or-patterns\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:22:13 clippy::shadow_unrelated \"`original` is being shadowed\"\n+target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:238:21 clippy::unnested_or_patterns \"unnested or-patterns\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:243:36 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:254:34 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n+target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:259:21 clippy::unnested_or_patterns \"unnested or-patterns\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:25:9 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n+target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:284:21 clippy::unnested_or_patterns \"unnested or-patterns\"\n+target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:292:21 clippy::unnested_or_patterns \"unnested or-patterns\"\n+target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:347:21 clippy::unnested_or_patterns \"unnested or-patterns\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:390:9 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:392:17 clippy::if_not_else \"unnecessary `!=` operation\"\n+target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:39:31 clippy::too_many_lines \"this function has too many lines (136/100)\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/expr/parser.rs:67:13 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/lib.rs:1:null clippy::cargo_common_metadata \"package `cfg-expr` is missing `package.categories` metadata\"\n target/lintcheck/sources/cfg-expr-0.7.1/src/targets/builtins.rs:11:5 clippy::wildcard_imports \"usage of wildcard import\"\n@@ -2191,9 +2213,7 @@ target/lintcheck/sources/libc-0.2.81/src/unix/mod.rs:202:35 clippy::unnecessary_\n target/lintcheck/sources/libc-0.2.81/src/unix/mod.rs:282:40 clippy::unreadable_literal \"long literal lacking separators\"\n target/lintcheck/sources/libc-0.2.81/src/unix/mod.rs:284:41 clippy::unreadable_literal \"long literal lacking separators\"\n target/lintcheck/sources/libc-0.2.81/src/unix/mod.rs:285:36 clippy::unreadable_literal \"long literal lacking separators\"\n-target/lintcheck/sources/libc-0.2.81/src/unix/mod.rs:34:10 clippy::upper_case_acronyms \"name `DIR` contains a capitalized acronym\"\n target/lintcheck/sources/libc-0.2.81/src/unix/mod.rs:36:1 clippy::expl_impl_clone_on_copy \"you are implementing `Clone` explicitly on a `Copy` type\"\n-target/lintcheck/sources/libc-0.2.81/src/unix/mod.rs:386:10 clippy::upper_case_acronyms \"name `FILE` contains a capitalized acronym\"\n target/lintcheck/sources/libc-0.2.81/src/unix/mod.rs:388:1 clippy::expl_impl_clone_on_copy \"you are implementing `Clone` explicitly on a `Copy` type\"\n target/lintcheck/sources/libc-0.2.81/src/unix/mod.rs:396:1 clippy::expl_impl_clone_on_copy \"you are implementing `Clone` explicitly on a `Copy` type\"\n target/lintcheck/sources/log-0.4.11/src/lib.rs:1047:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n@@ -2212,11 +2232,13 @@ target/lintcheck/sources/log-0.4.11/src/lib.rs:356:1 clippy::expl_impl_clone_on_\n target/lintcheck/sources/log-0.4.11/src/lib.rs:448:12 clippy::manual_range_contains \"manual `RangeInclusive::contains` implementation\"\n target/lintcheck/sources/log-0.4.11/src/lib.rs:500:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/log-0.4.11/src/lib.rs:506:28 clippy::trivially_copy_pass_by_ref \"this argument (8 byte) is passed by reference, but would be more efficient if passed by value (limit: 8 byte)\"\n+target/lintcheck/sources/log-0.4.11/src/lib.rs:506:28 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\"\n target/lintcheck/sources/log-0.4.11/src/lib.rs:506:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n target/lintcheck/sources/log-0.4.11/src/lib.rs:506:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/log-0.4.11/src/lib.rs:538:1 clippy::expl_impl_clone_on_copy \"you are implementing `Clone` explicitly on a `Copy` type\"\n target/lintcheck/sources/log-0.4.11/src/lib.rs:653:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/log-0.4.11/src/lib.rs:661:21 clippy::trivially_copy_pass_by_ref \"this argument (8 byte) is passed by reference, but would be more efficient if passed by value (limit: 8 byte)\"\n+target/lintcheck/sources/log-0.4.11/src/lib.rs:661:21 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\"\n target/lintcheck/sources/log-0.4.11/src/lib.rs:661:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/log-0.4.11/src/lib.rs:677:44 clippy::match_same_arms \"this `match` has identical arm bodies\"\n target/lintcheck/sources/log-0.4.11/src/lib.rs:758:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n@@ -2233,13 +2255,14 @@ target/lintcheck/sources/log-0.4.11/src/lib.rs:908:5 clippy::must_use_candidate\n target/lintcheck/sources/log-0.4.11/src/lib.rs:908:5 clippy::new_without_default \"you should consider adding a `Default` implementation for `RecordBuilder<'a>`\"\n target/lintcheck/sources/log-0.4.11/src/lib.rs:995:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/proc-macro2-1.0.24/src/detection.rs:2:5 clippy::wildcard_imports \"usage of wildcard import\"\n-target/lintcheck/sources/proc-macro2-1.0.24/src/fallback.rs:108:17 clippy::match_wildcard_for_single_variants \"wildcard match will miss any future added variants\"\n+target/lintcheck/sources/proc-macro2-1.0.24/src/fallback.rs:108:17 clippy::match_wildcard_for_single_variants \"wildcard matches only a single variant and will also match any future added variants\"\n target/lintcheck/sources/proc-macro2-1.0.24/src/fallback.rs:269:20 clippy::unused_self \"unused `self` argument\"\n target/lintcheck/sources/proc-macro2-1.0.24/src/fallback.rs:430:24 clippy::trivially_copy_pass_by_ref \"this argument (0 byte) is passed by reference, but would be more efficient if passed by value (limit: 8 byte)\"\n target/lintcheck/sources/proc-macro2-1.0.24/src/fallback.rs:437:23 clippy::trivially_copy_pass_by_ref \"this argument (0 byte) is passed by reference, but would be more efficient if passed by value (limit: 8 byte)\"\n target/lintcheck/sources/proc-macro2-1.0.24/src/fallback.rs:437:23 clippy::unused_self \"unused `self` argument\"\n target/lintcheck/sources/proc-macro2-1.0.24/src/fallback.rs:471:17 clippy::trivially_copy_pass_by_ref \"this argument (0 byte) is passed by reference, but would be more efficient if passed by value (limit: 8 byte)\"\n target/lintcheck/sources/proc-macro2-1.0.24/src/fallback.rs:471:17 clippy::unused_self \"unused `self` argument\"\n+target/lintcheck/sources/proc-macro2-1.0.24/src/fallback.rs:50:9 clippy::mem_replace_with_default \"replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\"\n target/lintcheck/sources/proc-macro2-1.0.24/src/fallback.rs:654:5 clippy::manual_range_contains \"manual `RangeInclusive::contains` implementation\"\n target/lintcheck/sources/proc-macro2-1.0.24/src/fallback.rs:655:12 clippy::manual_range_contains \"manual `RangeInclusive::contains` implementation\"\n target/lintcheck/sources/proc-macro2-1.0.24/src/fallback.rs:661:5 clippy::manual_range_contains \"manual `RangeInclusive::contains` implementation\"\n@@ -2286,6 +2309,12 @@ target/lintcheck/sources/proc-macro2-1.0.24/src/lib.rs:891:36 clippy::doc_markdo\n target/lintcheck/sources/proc-macro2-1.0.24/src/lib.rs:894:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/proc-macro2-1.0.24/src/lib.rs:911:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/proc-macro2-1.0.24/src/lib.rs:996:9 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n+target/lintcheck/sources/proc-macro2-1.0.24/src/parse.rs:353:17 clippy::unnested_or_patterns \"unnested or-patterns\"\n+target/lintcheck/sources/proc-macro2-1.0.24/src/parse.rs:360:17 clippy::unnested_or_patterns \"unnested or-patterns\"\n+target/lintcheck/sources/proc-macro2-1.0.24/src/parse.rs:411:17 clippy::unnested_or_patterns \"unnested or-patterns\"\n+target/lintcheck/sources/proc-macro2-1.0.24/src/parse.rs:413:17 clippy::unnested_or_patterns \"unnested or-patterns\"\n+target/lintcheck/sources/proc-macro2-1.0.24/src/parse.rs:476:13 clippy::unnested_or_patterns \"unnested or-patterns\"\n+target/lintcheck/sources/proc-macro2-1.0.24/src/parse.rs:500:13 clippy::unnested_or_patterns \"unnested or-patterns\"\n target/lintcheck/sources/proc-macro2-1.0.24/src/parse.rs:552:5 clippy::while_let_on_iterator \"this loop could be written as a `for` loop\"\n target/lintcheck/sources/proc-macro2-1.0.24/src/parse.rs:584:21 clippy::manual_range_contains \"manual `RangeInclusive::contains` implementation\"\n target/lintcheck/sources/proc-macro2-1.0.24/src/parse.rs:602:20 clippy::map_unwrap_or \"called `map(<f>).unwrap_or(<a>)` on an `Option` value. This can be done more directly by calling `map_or(<a>, <f>)` instead\"\n@@ -2360,6 +2389,10 @@ target/lintcheck/sources/quote-1.0.7/src/runtime.rs:52:5 clippy::module_name_rep\n target/lintcheck/sources/quote-1.0.7/src/runtime.rs:63:5 clippy::module_name_repetitions \"item name ends with its containing module's name\"\n target/lintcheck/sources/quote-1.0.7/src/runtime.rs:66:33 clippy::doc_markdown \"you should put `DoesNotHaveIter` between ticks in the documentation\"\n target/lintcheck/sources/quote-1.0.7/src/runtime.rs:80:5 clippy::module_name_repetitions \"item name ends with its containing module's name\"\n+target/lintcheck/sources/quote-1.0.7/src/to_tokens.rs:132:26 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\"\n+target/lintcheck/sources/quote-1.0.7/src/to_tokens.rs:159:18 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\"\n+target/lintcheck/sources/quote-1.0.7/src/to_tokens.rs:165:18 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\"\n+target/lintcheck/sources/quote-1.0.7/src/to_tokens.rs:80:18 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\"\n target/lintcheck/sources/rand-0.7.3/src/distributions/bernoulli.rs:103:20 clippy::cast_possible_truncation \"casting `f64` to `u64` may truncate the value\"\n target/lintcheck/sources/rand-0.7.3/src/distributions/bernoulli.rs:103:20 clippy::cast_sign_loss \"casting `f64` to `u64` may lose the sign of the value\"\n target/lintcheck/sources/rand-0.7.3/src/distributions/bernoulli.rs:116:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n@@ -2467,9 +2500,9 @@ target/lintcheck/sources/rand-0.7.3/src/distributions/uniform.rs:943:54 clippy::\n target/lintcheck/sources/rand-0.7.3/src/distributions/unit_circle.rs:30:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n target/lintcheck/sources/rand-0.7.3/src/distributions/unit_sphere.rs:24:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n target/lintcheck/sources/rand-0.7.3/src/distributions/unit_sphere.rs:29:5 clippy::must_use_candidate \"this method could have a `#[must_use]` attribute\"\n-target/lintcheck/sources/rand-0.7.3/src/distributions/utils.rs:247:15 clippy::wrong_self_convention \"methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\"\n-target/lintcheck/sources/rand-0.7.3/src/distributions/utils.rs:248:20 clippy::wrong_self_convention \"methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\"\n-target/lintcheck/sources/rand-0.7.3/src/distributions/utils.rs:249:18 clippy::wrong_self_convention \"methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\"\n+target/lintcheck/sources/rand-0.7.3/src/distributions/utils.rs:247:15 clippy::wrong_self_convention \"methods called `is_*` usually take `self` by reference or no `self`\"\n+target/lintcheck/sources/rand-0.7.3/src/distributions/utils.rs:248:20 clippy::wrong_self_convention \"methods called `is_*` usually take `self` by reference or no `self`\"\n+target/lintcheck/sources/rand-0.7.3/src/distributions/utils.rs:249:18 clippy::wrong_self_convention \"methods called `is_*` usually take `self` by reference or no `self`\"\n target/lintcheck/sources/rand-0.7.3/src/distributions/utils.rs:254:5 clippy::inline_always \"you have declared `#[inline(always)]` on `lanes`. This is usually a bad idea\"\n target/lintcheck/sources/rand-0.7.3/src/distributions/utils.rs:258:5 clippy::inline_always \"you have declared `#[inline(always)]` on `splat`. This is usually a bad idea\"\n target/lintcheck/sources/rand-0.7.3/src/distributions/utils.rs:262:5 clippy::inline_always \"you have declared `#[inline(always)]` on `extract`. This is usually a bad idea\"\n@@ -2504,7 +2537,69 @@ target/lintcheck/sources/rand-0.7.3/src/distributions/weighted/mod.rs:169:16 cli\n target/lintcheck/sources/rand-0.7.3/src/distributions/weighted/mod.rs:386:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n target/lintcheck/sources/rand-0.7.3/src/distributions/weighted/mod.rs:85:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n target/lintcheck/sources/rand-0.7.3/src/lib.rs:333:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-target/lintcheck/sources/rand-0.7.3/src/lib.rs:404:14 clippy::wrong_self_convention \"methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:412:14 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:435:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:435:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:435:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:435:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:435:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:435:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:435:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:435:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:435:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:435:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:435:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:459:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:459:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:459:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:459:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:459:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:459:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:459:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:459:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:459:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:459:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:459:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n+target/lintcheck/sources/rand-0.7.3/src/lib.rs:489:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n target/lintcheck/sources/rand-0.7.3/src/lib.rs:552:1 clippy::must_use_candidate \"this function could have a `#[must_use]` attribute\"\n target/lintcheck/sources/rand-0.7.3/src/rngs/adapter/read.rs:47:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n target/lintcheck/sources/rand-0.7.3/src/rngs/adapter/read.rs:89:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n@@ -2605,6 +2700,7 @@ target/lintcheck/sources/rayon-1.5.0/src/collections/hash_set.rs:9:5 clippy::wil\n target/lintcheck/sources/rayon-1.5.0/src/collections/linked_list.rs:7:5 clippy::wildcard_imports \"usage of wildcard import\"\n target/lintcheck/sources/rayon-1.5.0/src/collections/linked_list.rs:8:5 clippy::wildcard_imports \"usage of wildcard import\"\n target/lintcheck/sources/rayon-1.5.0/src/collections/mod.rs:59:32 clippy::mem_replace_with_default \"replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\"\n+target/lintcheck/sources/rayon-1.5.0/src/collections/mod.rs:68:40 clippy::mem_replace_with_default \"replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\"\n target/lintcheck/sources/rayon-1.5.0/src/collections/vec_deque.rs:8:5 clippy::wildcard_imports \"usage of wildcard import\"\n target/lintcheck/sources/rayon-1.5.0/src/collections/vec_deque.rs:9:5 clippy::wildcard_imports \"usage of wildcard import\"\n target/lintcheck/sources/rayon-1.5.0/src/compile_fail/cannot_collect_filtermap_data.rs:2:1 clippy::needless_doctest_main \"needless `fn main` in doctest\"\n@@ -2626,7 +2722,7 @@ target/lintcheck/sources/rayon-1.5.0/src/iter/chain.rs:58:17 clippy::shadow_unre\n target/lintcheck/sources/rayon-1.5.0/src/iter/chain.rs:78:14 clippy::shadow_unrelated \"`a` is being shadowed\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/chain.rs:78:17 clippy::shadow_unrelated \"`b` is being shadowed\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/chain.rs:97:9 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n-target/lintcheck/sources/rayon-1.5.0/src/iter/chunks.rs:29:9 clippy::inconsistent_struct_constructor \"inconsistent struct constructor\"\n+target/lintcheck/sources/rayon-1.5.0/src/iter/chunks.rs:29:9 clippy::inconsistent_struct_constructor \"struct constructor field order is inconsistent with struct definition field order\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/chunks.rs:3:5 clippy::wildcard_imports \"usage of wildcard import\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/chunks.rs:4:5 clippy::wildcard_imports \"usage of wildcard import\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/chunks.rs:77:9 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n@@ -2704,8 +2800,6 @@ target/lintcheck/sources/rayon-1.5.0/src/iter/interleave.rs:200:23 clippy::doc_m\n target/lintcheck/sources/rayon-1.5.0/src/iter/interleave.rs:249:41 clippy::doc_markdown \"you should put `DoubleEndedIterator` between ticks in the documentation\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/interleave.rs:250:5 clippy::doc_markdown \"you should put `ExactSizeIterator` between ticks in the documentation\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/interleave.rs:263:33 clippy::doc_markdown \"you should put `InterleaveSeq` between ticks in the documentation\"\n-target/lintcheck/sources/rayon-1.5.0/src/iter/interleave.rs:280:17 clippy::match_wildcard_for_single_variants \"wildcard match will miss any future added variants\"\n-target/lintcheck/sources/rayon-1.5.0/src/iter/interleave.rs:285:17 clippy::match_wildcard_for_single_variants \"wildcard match will miss any future added variants\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/interleave.rs:2:5 clippy::wildcard_imports \"usage of wildcard import\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/interleave.rs:313:9 clippy::comparison_chain \"`if` chain can be rewritten with `match`\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/interleave.rs:82:9 clippy::items_after_statements \"adding items after statements is confusing, since items exist from the start of the scope\"\n@@ -2761,6 +2855,7 @@ target/lintcheck/sources/rayon-1.5.0/src/iter/positions.rs:1:5 clippy::wildcard_\n target/lintcheck/sources/rayon-1.5.0/src/iter/positions.rs:2:5 clippy::wildcard_imports \"usage of wildcard import\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/product.rs:1:5 clippy::wildcard_imports \"usage of wildcard import\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/reduce.rs:1:5 clippy::wildcard_imports \"usage of wildcard import\"\n+target/lintcheck/sources/rayon-1.5.0/src/iter/reduce.rs:67:19 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/repeat.rs:103:1 clippy::module_name_repetitions \"item name starts with its containing module's name\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/repeat.rs:1:5 clippy::wildcard_imports \"usage of wildcard import\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/repeat.rs:2:5 clippy::wildcard_imports \"usage of wildcard import\"\n@@ -2787,7 +2882,9 @@ target/lintcheck/sources/rayon-1.5.0/src/iter/try_fold.rs:190:1 clippy::module_n\n target/lintcheck/sources/rayon-1.5.0/src/iter/try_fold.rs:1:5 clippy::wildcard_imports \"usage of wildcard import\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/try_fold.rs:2:5 clippy::wildcard_imports \"usage of wildcard import\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/try_reduce.rs:1:5 clippy::wildcard_imports \"usage of wildcard import\"\n+target/lintcheck/sources/rayon-1.5.0/src/iter/try_reduce.rs:74:19 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/try_reduce_with.rs:1:5 clippy::wildcard_imports \"usage of wildcard import\"\n+target/lintcheck/sources/rayon-1.5.0/src/iter/try_reduce_with.rs:69:19 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/unzip.rs:1:5 clippy::wildcard_imports \"usage of wildcard import\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/unzip.rs:2:5 clippy::wildcard_imports \"usage of wildcard import\"\n target/lintcheck/sources/rayon-1.5.0/src/iter/update.rs:1:5 clippy::wildcard_imports \"usage of wildcard import\"\n@@ -2960,6 +3057,7 @@ target/lintcheck/sources/regex-1.3.2/src/dfa.rs:1129:13 clippy::doc_markdown \"yo\n target/lintcheck/sources/regex-1.3.2/src/dfa.rs:1134:13 clippy::doc_markdown \"you should put `is_match` between ticks in the documentation\"\n target/lintcheck/sources/regex-1.3.2/src/dfa.rs:1185:68 clippy::doc_markdown \"you should put `is_match` between ticks in the documentation\"\n target/lintcheck/sources/regex-1.3.2/src/dfa.rs:1193:13 clippy::enum_glob_use \"usage of wildcard import for enum variants\"\n+target/lintcheck/sources/regex-1.3.2/src/dfa.rs:1205:13 clippy::mem_replace_with_default \"replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\"\n target/lintcheck/sources/regex-1.3.2/src/dfa.rs:1244:50 clippy::doc_markdown \"you should put `current_state` between ticks in the documentation\"\n target/lintcheck/sources/regex-1.3.2/src/dfa.rs:1338:58 clippy::doc_markdown \"you should put `STATE_DEAD` between ticks in the documentation\"\n target/lintcheck/sources/regex-1.3.2/src/dfa.rs:1339:9 clippy::doc_markdown \"you should put `STATE_UNKNOWN` between ticks in the documentation\"\n@@ -3365,7 +3463,7 @@ target/lintcheck/sources/ripgrep-12.1.1/crates/core/args.rs:369:5 clippy::upper_\n target/lintcheck/sources/ripgrep-12.1.1/crates/core/args.rs:410:14 clippy::trivially_copy_pass_by_ref \"this argument (2 byte) is passed by reference, but would be more efficient if passed by value (limit: 8 byte)\"\n target/lintcheck/sources/ripgrep-12.1.1/crates/core/args.rs:475:18 clippy::match_same_arms \"this `match` has identical arm bodies\"\n target/lintcheck/sources/ripgrep-12.1.1/crates/core/args.rs:512:19 clippy::doc_markdown \"you should put `ArgMatches` between ticks in the documentation\"\n-target/lintcheck/sources/ripgrep-12.1.1/crates/core/args.rs:549:16 clippy::wrong_self_convention \"methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\"\n+target/lintcheck/sources/ripgrep-12.1.1/crates/core/args.rs:549:16 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n target/lintcheck/sources/ripgrep-12.1.1/crates/core/args.rs:76:18 clippy::trivially_copy_pass_by_ref \"this argument (1 byte) is passed by reference, but would be more efficient if passed by value (limit: 8 byte)\"\n target/lintcheck/sources/ripgrep-12.1.1/crates/core/args.rs:77:13 clippy::enum_glob_use \"usage of wildcard import for enum variants\"\n target/lintcheck/sources/ripgrep-12.1.1/crates/core/args.rs:923:42 clippy::doc_markdown \"you should put `BinaryDetection::quit` between ticks in the documentation\"\n@@ -3409,6 +3507,14 @@ target/lintcheck/sources/rpmalloc-0.2.0/src/lib.rs:71:73 clippy::doc_markdown \"y\n target/lintcheck/sources/rpmalloc-0.2.0/src/lib.rs:72:50 clippy::doc_markdown \"you should put bare URLs between `<`/`>` or make a proper Markdown link\"\n target/lintcheck/sources/rpmalloc-0.2.0/src/lib.rs:92:9 clippy::ptr_as_ptr \"`as` casting between raw pointers without changing its mutability\"\n target/lintcheck/sources/rpmalloc-0.2.0/src/lib.rs:95:21 clippy::ptr_as_ptr \"`as` casting between raw pointers without changing its mutability\"\n+target/lintcheck/sources/serde-1.0.118/src/de/from_primitive.rs:103:24 clippy::wrong_self_convention \"methods called `from_*` usually take no `self`\"\n+target/lintcheck/sources/serde-1.0.118/src/de/from_primitive.rs:107:25 clippy::wrong_self_convention \"methods called `from_*` usually take no `self`\"\n+target/lintcheck/sources/serde-1.0.118/src/de/from_primitive.rs:111:25 clippy::wrong_self_convention \"methods called `from_*` usually take no `self`\"\n+target/lintcheck/sources/serde-1.0.118/src/de/from_primitive.rs:115:25 clippy::wrong_self_convention \"methods called `from_*` usually take no `self`\"\n+target/lintcheck/sources/serde-1.0.118/src/de/from_primitive.rs:48:24 clippy::wrong_self_convention \"methods called `from_*` usually take no `self`\"\n+target/lintcheck/sources/serde-1.0.118/src/de/from_primitive.rs:52:25 clippy::wrong_self_convention \"methods called `from_*` usually take no `self`\"\n+target/lintcheck/sources/serde-1.0.118/src/de/from_primitive.rs:56:25 clippy::wrong_self_convention \"methods called `from_*` usually take no `self`\"\n+target/lintcheck/sources/serde-1.0.118/src/de/from_primitive.rs:60:25 clippy::wrong_self_convention \"methods called `from_*` usually take no `self`\"\n target/lintcheck/sources/serde-1.0.118/src/de/mod.rs:1592:9 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n target/lintcheck/sources/serde-1.0.118/src/de/mod.rs:1616:9 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n target/lintcheck/sources/serde-1.0.118/src/de/mod.rs:1627:9 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n@@ -3418,10 +3524,18 @@ target/lintcheck/sources/serde-1.0.118/src/de/mod.rs:952:13 clippy::let_undersco\n target/lintcheck/sources/serde-1.0.118/src/de/mod.rs:986:13 clippy::let_underscore_drop \"non-binding `let` on a type that implements `Drop`\"\n target/lintcheck/sources/serde_yaml-0.8.17/src/lib.rs:1:null clippy::cargo_common_metadata \"package `serde_yaml` is missing `package.categories` metadata\"\n target/lintcheck/sources/syn-1.0.54/build.rs:1:null clippy::cargo_common_metadata \"package `syn` is missing `package.keywords` metadata\"\n+target/lintcheck/sources/syn-1.0.54/src/custom_keyword.rs:177:26 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\"\n+target/lintcheck/sources/syn-1.0.54/src/gen/clone.rs:1900:13 clippy::match_wildcard_for_single_variants \"wildcard matches only a single variant and will also match any future added variants\"\n+target/lintcheck/sources/syn-1.0.54/src/generics.rs:1227:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\"\n target/lintcheck/sources/syn-1.0.54/src/lib.rs:1:null clippy::cargo_common_metadata \"package `syn` is missing `package.keywords` metadata\"\n target/lintcheck/sources/syn-1.0.54/src/lit.rs:1397:40 clippy::redundant_else \"redundant else block\"\n target/lintcheck/sources/syn-1.0.54/src/lit.rs:1405:28 clippy::redundant_else \"redundant else block\"\n target/lintcheck/sources/syn-1.0.54/src/lit.rs:1485:32 clippy::redundant_else \"redundant else block\"\n+target/lintcheck/sources/syn-1.0.54/src/op.rs:190:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\"\n+target/lintcheck/sources/syn-1.0.54/src/op.rs:226:22 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\"\n+target/lintcheck/sources/syn-1.0.54/src/token.rs:311:30 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\"\n+target/lintcheck/sources/syn-1.0.54/src/token.rs:446:30 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\"\n+target/lintcheck/sources/syn-1.0.54/src/token.rs:563:18 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\"\n target/lintcheck/sources/syn-1.0.54/src/token.rs:974:5 clippy::missing_panics_doc \"docs for function which may panic missing `# Panics` section\"\n target/lintcheck/sources/tame-oidc-0.1.0/src/errors.rs:9:5 clippy::upper_case_acronyms \"name `HTTP` contains a capitalized acronym\"\n target/lintcheck/sources/tame-oidc-0.1.0/src/lib.rs:1:null clippy::cargo_common_metadata \"package `tame-oidc` is missing `package.categories` metadata\"\n@@ -3439,21 +3553,19 @@ target/lintcheck/sources/tame-oidc-0.1.0/src/provider.rs:26:5 clippy::missing_er\n target/lintcheck/sources/tame-oidc-0.1.0/src/provider.rs:38:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/tame-oidc-0.1.0/src/provider.rs:57:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/tame-oidc-0.1.0/src/provider.rs:71:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n-target/lintcheck/sources/tame-oidc-0.1.0/src/provider.rs:77:12 clippy::upper_case_acronyms \"name `JWK` contains a capitalized acronym\"\n-target/lintcheck/sources/tame-oidc-0.1.0/src/provider.rs:90:12 clippy::upper_case_acronyms \"name `JWKS` contains a capitalized acronym\"\n target/lintcheck/sources/tame-oidc-0.1.0/src/provider.rs:95:5 clippy::missing_errors_doc \"docs for function returning `Result` missing `# Errors` section\"\n target/lintcheck/sources/thiserror-1.0.24/src/lib.rs:1:null clippy::cargo_common_metadata \"package `thiserror` is missing `package.keywords` metadata\"\n target/lintcheck/sources/unicode-xid-0.2.1/src/lib.rs:1:null clippy::cargo_common_metadata \"package `unicode-xid` is missing `package.categories` metadata\"\n target/lintcheck/sources/unicode-xid-0.2.1/src/lib.rs:57:64 clippy::doc_markdown \"you should put `XID_Start` between ticks in the documentation\"\n target/lintcheck/sources/unicode-xid-0.2.1/src/lib.rs:60:10 clippy::doc_markdown \"you should put `XID_Start` between ticks in the documentation\"\n target/lintcheck/sources/unicode-xid-0.2.1/src/lib.rs:62:27 clippy::doc_markdown \"you should put `ID_Start` between ticks in the documentation\"\n target/lintcheck/sources/unicode-xid-0.2.1/src/lib.rs:62:67 clippy::doc_markdown \"you should put `NFKx` between ticks in the documentation\"\n-target/lintcheck/sources/unicode-xid-0.2.1/src/lib.rs:63:21 clippy::wrong_self_convention \"methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\"\n+target/lintcheck/sources/unicode-xid-0.2.1/src/lib.rs:63:21 clippy::wrong_self_convention \"methods called `is_*` usually take `self` by reference or no `self`\"\n target/lintcheck/sources/unicode-xid-0.2.1/src/lib.rs:65:61 clippy::doc_markdown \"you should put `XID_Continue` between ticks in the documentation\"\n target/lintcheck/sources/unicode-xid-0.2.1/src/lib.rs:68:10 clippy::doc_markdown \"you should put `XID_Continue` between ticks in the documentation\"\n target/lintcheck/sources/unicode-xid-0.2.1/src/lib.rs:70:28 clippy::doc_markdown \"you should put `ID_Continue` between ticks in the documentation\"\n target/lintcheck/sources/unicode-xid-0.2.1/src/lib.rs:70:72 clippy::doc_markdown \"you should put `NFKx` between ticks in the documentation\"\n-target/lintcheck/sources/unicode-xid-0.2.1/src/lib.rs:71:24 clippy::wrong_self_convention \"methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\"\n+target/lintcheck/sources/unicode-xid-0.2.1/src/lib.rs:71:24 clippy::wrong_self_convention \"methods called `is_*` usually take `self` by reference or no `self`\"\n target/lintcheck/sources/xsv-0.13.0/src/cmd/cat.rs:101:34 clippy::redundant_closure_for_method_calls \"redundant closure\"\n target/lintcheck/sources/xsv-0.13.0/src/cmd/cat.rs:42:1 clippy::struct_excessive_bools \"more than 3 bools in a struct\"\n target/lintcheck/sources/xsv-0.13.0/src/cmd/cat.rs:53:9 clippy::similar_names \"binding's name is too similar to existing binding\"\n@@ -3520,7 +3632,6 @@ target/lintcheck/sources/xsv-0.13.0/src/cmd/sample.rs:115:21 clippy::cast_possib\n target/lintcheck/sources/xsv-0.13.0/src/cmd/sample.rs:11:16 clippy::redundant_static_lifetimes \"statics have by default a `'static` lifetime\"\n target/lintcheck/sources/xsv-0.13.0/src/cmd/sample.rs:51:9 clippy::similar_names \"binding's name is too similar to existing binding\"\n target/lintcheck/sources/xsv-0.13.0/src/cmd/sample.rs:58:19 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n-target/lintcheck/sources/xsv-0.13.0/src/cmd/sample.rs:69:9 clippy::match_wildcard_for_single_variants \"wildcard match will miss any future added variants\"\n target/lintcheck/sources/xsv-0.13.0/src/cmd/sample.rs:75:16 clippy::explicit_into_iter_loop \"it is more concise to loop over containers instead of using explicit iteration methods\"\n target/lintcheck/sources/xsv-0.13.0/src/cmd/sample.rs:91:42 clippy::cast_possible_truncation \"casting `u64` to `usize` may truncate the value on targets with 32-bit wide pointers\"\n target/lintcheck/sources/xsv-0.13.0/src/cmd/sample.rs:92:43 clippy::cast_possible_truncation \"casting `u64` to `usize` may truncate the value on targets with 32-bit wide pointers\"\n@@ -3567,7 +3678,7 @@ target/lintcheck/sources/xsv-0.13.0/src/cmd/stats.rs:293:25 clippy::match_same_a\n target/lintcheck/sources/xsv-0.13.0/src/cmd/stats.rs:297:25 clippy::option_map_unit_fn \"called `map(f)` on an `Option` value where `f` is a closure that returns the unit type `()`\"\n target/lintcheck/sources/xsv-0.13.0/src/cmd/stats.rs:301:21 clippy::option_map_unit_fn \"called `map(f)` on an `Option` value where `f` is a closure that returns the unit type `()`\"\n target/lintcheck/sources/xsv-0.13.0/src/cmd/stats.rs:302:21 clippy::option_map_unit_fn \"called `map(f)` on an `Option` value where `f` is a closure that returns the unit type `()`\"\n-target/lintcheck/sources/xsv-0.13.0/src/cmd/stats.rs:308:18 clippy::wrong_self_convention \"methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\"\n+target/lintcheck/sources/xsv-0.13.0/src/cmd/stats.rs:308:18 clippy::wrong_self_convention \"methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\"\n target/lintcheck/sources/xsv-0.13.0/src/cmd/stats.rs:318:9 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n target/lintcheck/sources/xsv-0.13.0/src/cmd/stats.rs:322:45 clippy::redundant_closure_for_method_calls \"redundant closure\"\n target/lintcheck/sources/xsv-0.13.0/src/cmd/stats.rs:322:9 clippy::single_match_else \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\"\n@@ -3600,7 +3711,7 @@ target/lintcheck/sources/xsv-0.13.0/src/cmd/table.rs:50:9 clippy::similar_names\n target/lintcheck/sources/xsv-0.13.0/src/cmd/table.rs:54:9 clippy::similar_names \"binding's name is too similar to existing binding\"\n target/lintcheck/sources/xsv-0.13.0/src/config.rs:113:43 clippy::or_fun_call \"use of `unwrap_or` followed by a function call\"\n target/lintcheck/sources/xsv-0.13.0/src/config.rs:58:1 clippy::struct_excessive_bools \"more than 3 bools in a struct\"\n-target/lintcheck/sources/xsv-0.13.0/src/config.rs:77:28 clippy::explicit_deref_methods \"explicit deref method call\"\n+target/lintcheck/sources/xsv-0.13.0/src/config.rs:77:28 clippy::explicit_deref_methods \"explicit `deref` method call\"\n target/lintcheck/sources/xsv-0.13.0/src/config.rs:90:13 clippy::redundant_field_names \"redundant field names in struct initialization\"\n target/lintcheck/sources/xsv-0.13.0/src/index.rs:31:13 clippy::redundant_field_names \"redundant field names in struct initialization\"\n target/lintcheck/sources/xsv-0.13.0/src/main.rs:164:49 clippy::redundant_clone \"redundant clone\"\n@@ -3640,7 +3751,6 @@ clippy::from_iter_instead_of_collect 1\n clippy::int_plus_one 1\n clippy::manual_flatten 1\n clippy::manual_saturating_arithmetic 1\n-clippy::mem_replace_with_default 1\n clippy::nonminimal_bool 1\n clippy::or_fun_call 1\n clippy::precedence 1\n@@ -3677,7 +3787,9 @@ clippy::inconsistent_struct_constructor 3\n clippy::manual_map 3\n clippy::mut_mut 3\n clippy::ptr_arg 3\n+clippy::upper_case_acronyms 3\n clippy::zero_ptr 3\n+clippy::mem_replace_with_default 4\n clippy::too_many_arguments 4\n clippy::explicit_iter_loop 5\n clippy::field_reassign_with_default 5\n@@ -3695,16 +3807,14 @@ clippy::implicit_clone 7\n clippy::map_clone 7\n clippy::option_map_unit_fn 7\n clippy::range_plus_one 7\n-clippy::upper_case_acronyms 7\n clippy::invalid_upcast_comparisons 8\n clippy::needless_question_mark 8\n-clippy::wrong_self_convention 8\n clippy::len_without_is_empty 9\n clippy::multiple_crate_versions 9\n clippy::manual_range_contains 10\n-clippy::match_wildcard_for_single_variants 10\n clippy::missing_safety_doc 10\n clippy::needless_doctest_main 10\n+clippy::match_wildcard_for_single_variants 11\n clippy::needless_lifetimes 12\n clippy::linkedlist 14\n clippy::single_char_add_str 14\n@@ -3722,11 +3832,12 @@ clippy::cargo_common_metadata 21\n clippy::ptr_as_ptr 21\n clippy::redundant_static_lifetimes 21\n clippy::cast_lossless 23\n+clippy::unnested_or_patterns 25\n clippy::default_trait_access 26\n clippy::let_underscore_drop 26\n clippy::trivially_copy_pass_by_ref 26\n clippy::redundant_else 29\n-clippy::too_many_lines 35\n+clippy::too_many_lines 36\n clippy::if_not_else 38\n clippy::unseparated_literal_suffix 41\n clippy::cast_precision_loss 44\n@@ -3736,13 +3847,14 @@ clippy::inline_always 59\n clippy::missing_panics_doc 59\n clippy::match_same_arms 62\n clippy::similar_names 83\n+clippy::wrong_self_convention 94\n clippy::cast_possible_truncation 95\n clippy::redundant_field_names 111\n clippy::redundant_closure_for_method_calls 131\n clippy::items_after_statements 143\n clippy::module_name_repetitions 146\n+clippy::expl_impl_clone_on_copy 164\n clippy::wildcard_imports 164\n-clippy::expl_impl_clone_on_copy 165\n clippy::doc_markdown 184\n clippy::missing_errors_doc 356\n clippy::unreadable_literal 365"}, {"sha": "2041aed2b97c7f4ee88e573e73e0766586f46389", "filename": "lintcheck/src/main.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/lintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/lintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fmain.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -294,6 +294,14 @@ impl Crate {\n             });\n         let stdout = String::from_utf8_lossy(&all_output.stdout);\n         let stderr = String::from_utf8_lossy(&all_output.stderr);\n+        let status = &all_output.status;\n+\n+        if !status.success() {\n+            eprintln!(\n+                \"\\nWARNING: bad exit status after checking {} {} \\n\",\n+                self.name, self.version\n+            );\n+        }\n \n         if fix {\n             if let Some(stderr) = stderr"}, {"sha": "7e4d12b8632be48d274287e40f5e14a853687759", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-03-25\"\n+channel = \"nightly-2021-04-08\"\n components = [\"llvm-tools-preview\", \"rustc-dev\", \"rust-src\"]"}, {"sha": "fa0c5f01430b615ce7d2b46e5c713f45bb8992c0", "filename": "src/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -99,17 +99,17 @@ impl rustc_driver::Callbacks for ClippyCallbacks {\n         config.parse_sess_created = Some(Box::new(move |parse_sess| {\n             track_clippy_args(parse_sess, &clippy_args_var);\n         }));\n-        config.register_lints = Some(Box::new(move |sess, mut lint_store| {\n+        config.register_lints = Some(Box::new(move |sess, lint_store| {\n             // technically we're ~guaranteed that this is none but might as well call anything that\n             // is there already. Certainly it can't hurt.\n             if let Some(previous) = &previous {\n                 (previous)(sess, lint_store);\n             }\n \n-            let conf = clippy_lints::read_conf(&[], &sess);\n-            clippy_lints::register_plugins(&mut lint_store, &sess, &conf);\n-            clippy_lints::register_pre_expansion_lints(&mut lint_store);\n-            clippy_lints::register_renamed(&mut lint_store);\n+            let conf = clippy_lints::read_conf(&[], sess);\n+            clippy_lints::register_plugins(lint_store, sess, &conf);\n+            clippy_lints::register_pre_expansion_lints(lint_store);\n+            clippy_lints::register_renamed(lint_store);\n         }));\n \n         // FIXME: #4825; This is required, because Clippy lints that are based on MIR have to be\n@@ -191,7 +191,7 @@ fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     ];\n \n     for note in &xs {\n-        handler.note_without_error(&note);\n+        handler.note_without_error(note);\n     }\n \n     // If backtraces are enabled, also print the query stack"}, {"sha": "f4d354f0bf94240a97ab9753c61d82a0614be0b2", "filename": "tests/compile-test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -98,7 +98,7 @@ fn default_config() -> compiletest::Config {\n fn run_mode(cfg: &mut compiletest::Config) {\n     cfg.mode = TestMode::Ui;\n     cfg.src_base = Path::new(\"tests\").join(\"ui\");\n-    compiletest::run_tests(&cfg);\n+    compiletest::run_tests(cfg);\n }\n \n fn run_internal_tests(cfg: &mut compiletest::Config) {\n@@ -108,7 +108,7 @@ fn run_internal_tests(cfg: &mut compiletest::Config) {\n     }\n     cfg.mode = TestMode::Ui;\n     cfg.src_base = Path::new(\"tests\").join(\"ui-internal\");\n-    compiletest::run_tests(&cfg);\n+    compiletest::run_tests(cfg);\n }\n \n fn run_ui_toml(config: &mut compiletest::Config) {\n@@ -136,7 +136,7 @@ fn run_ui_toml(config: &mut compiletest::Config) {\n                     base: config.src_base.clone(),\n                     relative_dir: dir_path.file_name().unwrap().into(),\n                 };\n-                let test_name = compiletest::make_test_name(&config, &paths);\n+                let test_name = compiletest::make_test_name(config, &paths);\n                 let index = tests\n                     .iter()\n                     .position(|test| test.desc.name == test_name)\n@@ -150,10 +150,10 @@ fn run_ui_toml(config: &mut compiletest::Config) {\n     config.mode = TestMode::Ui;\n     config.src_base = Path::new(\"tests\").join(\"ui-toml\").canonicalize().unwrap();\n \n-    let tests = compiletest::make_tests(&config);\n+    let tests = compiletest::make_tests(config);\n \n     let manifest_dir = var(\"CARGO_MANIFEST_DIR\").unwrap_or_default();\n-    let res = run_tests(&config, tests);\n+    let res = run_tests(config, tests);\n     set_var(\"CARGO_MANIFEST_DIR\", &manifest_dir);\n     match res {\n         Ok(true) => {},\n@@ -221,7 +221,7 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n                         base: config.src_base.clone(),\n                         relative_dir: src_path.strip_prefix(&config.src_base).unwrap().into(),\n                     };\n-                    let test_name = compiletest::make_test_name(&config, &paths);\n+                    let test_name = compiletest::make_test_name(config, &paths);\n                     let index = tests\n                         .iter()\n                         .position(|test| test.desc.name == test_name)\n@@ -240,11 +240,11 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n     config.mode = TestMode::Ui;\n     config.src_base = Path::new(\"tests\").join(\"ui-cargo\").canonicalize().unwrap();\n \n-    let tests = compiletest::make_tests(&config);\n+    let tests = compiletest::make_tests(config);\n \n     let current_dir = env::current_dir().unwrap();\n     let conf_dir = var(\"CLIPPY_CONF_DIR\").unwrap_or_default();\n-    let res = run_tests(&config, &config.filters, tests);\n+    let res = run_tests(config, &config.filters, tests);\n     env::set_current_dir(current_dir).unwrap();\n     set_var(\"CLIPPY_CONF_DIR\", conf_dir);\n "}, {"sha": "2f8989c8e114082eabd4957b8431f0a090d879a8", "filename": "tests/lint_message_convention.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Flint_message_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Flint_message_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Flint_message_convention.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -89,14 +89,14 @@ fn lint_message_convention() {\n         .filter(|message| !message.bad_lines.is_empty())\n         .collect();\n \n-    bad_tests.iter().for_each(|message| {\n+    for message in &bad_tests {\n         eprintln!(\n             \"error: the test '{}' contained the following nonconforming lines :\",\n             message.path.display()\n         );\n         message.bad_lines.iter().for_each(|line| eprintln!(\"{}\", line));\n         eprintln!(\"\\n\\n\");\n-    });\n+    }\n \n     eprintln!(\n         \"\\n\\n\\nLint message should not start with a capital letter and should not have punctuation at the end of the message unless multiple sentences are needed.\""}, {"sha": "5e9aa8dc36a6e40e768016e7f2b2d7dca99fbd52", "filename": "tests/ui-cargo/cargo_common_metadata/fail/src/main.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail%2Fsrc%2Fmain.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,9 +1,7 @@\n-error: package `cargo_common_metadata` is missing `package.authors` metadata\n+error: package `cargo_common_metadata` is missing `package.description` metadata\n    |\n    = note: `-D clippy::cargo-common-metadata` implied by `-D warnings`\n \n-error: package `cargo_common_metadata` is missing `package.description` metadata\n-\n error: package `cargo_common_metadata` is missing `either package.license or package.license_file` metadata\n \n error: package `cargo_common_metadata` is missing `package.repository` metadata\n@@ -14,5 +12,5 @@ error: package `cargo_common_metadata` is missing `package.keywords` metadata\n \n error: package `cargo_common_metadata` is missing `package.categories` metadata\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "5e9aa8dc36a6e40e768016e7f2b2d7dca99fbd52", "filename": "tests/ui-cargo/cargo_common_metadata/fail_publish/src/main.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail_publish%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail_publish%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail_publish%2Fsrc%2Fmain.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,9 +1,7 @@\n-error: package `cargo_common_metadata` is missing `package.authors` metadata\n+error: package `cargo_common_metadata` is missing `package.description` metadata\n    |\n    = note: `-D clippy::cargo-common-metadata` implied by `-D warnings`\n \n-error: package `cargo_common_metadata` is missing `package.description` metadata\n-\n error: package `cargo_common_metadata` is missing `either package.license or package.license_file` metadata\n \n error: package `cargo_common_metadata` is missing `package.repository` metadata\n@@ -14,5 +12,5 @@ error: package `cargo_common_metadata` is missing `package.keywords` metadata\n \n error: package `cargo_common_metadata` is missing `package.categories` metadata\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "5e9aa8dc36a6e40e768016e7f2b2d7dca99fbd52", "filename": "tests/ui-cargo/cargo_common_metadata/fail_publish_true/src/main.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail_publish_true%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail_publish_true%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fcargo_common_metadata%2Ffail_publish_true%2Fsrc%2Fmain.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,9 +1,7 @@\n-error: package `cargo_common_metadata` is missing `package.authors` metadata\n+error: package `cargo_common_metadata` is missing `package.description` metadata\n    |\n    = note: `-D clippy::cargo-common-metadata` implied by `-D warnings`\n \n-error: package `cargo_common_metadata` is missing `package.description` metadata\n-\n error: package `cargo_common_metadata` is missing `either package.license or package.license_file` metadata\n \n error: package `cargo_common_metadata` is missing `package.repository` metadata\n@@ -14,5 +12,5 @@ error: package `cargo_common_metadata` is missing `package.keywords` metadata\n \n error: package `cargo_common_metadata` is missing `package.categories` metadata\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "cb4774d43a2c1c194fd1682ec85c58cbb6371bc3", "filename": "tests/ui-cargo/cargo_common_metadata/pass/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui-cargo%2Fcargo_common_metadata%2Fpass%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui-cargo%2Fcargo_common_metadata%2Fpass%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fcargo_common_metadata%2Fpass%2FCargo.toml?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -2,7 +2,6 @@\n name = \"cargo_common_metadata\"\n version = \"0.1.0\"\n publish = false\n-authors = [\"Random person from the Internet <someone@someplace.org>\"]\n description = \"A test package for the cargo_common_metadata lint\"\n repository = \"https://github.com/someone/cargo_common_metadata\"\n readme = \"README.md\""}, {"sha": "8e871707aa8f36953805aaf9780309ea45995f59", "filename": "tests/ui-internal/if_chain_style.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui-internal%2Fif_chain_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui-internal%2Fif_chain_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fif_chain_style.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,92 @@\n+#![warn(clippy::if_chain_style)]\n+#![allow(clippy::no_effect)]\n+\n+extern crate if_chain;\n+\n+use if_chain::if_chain;\n+\n+fn main() {\n+    if true {\n+        let x = \"\";\n+        // `if_chain!` inside `if`\n+        if_chain! {\n+            if true;\n+            if true;\n+            then {}\n+        }\n+    }\n+    if_chain! {\n+        if true\n+            // multi-line AND'ed conditions\n+            && false;\n+        if let Some(1) = Some(1);\n+        // `let` before `then`\n+        let x = \"\";\n+        then {\n+            ();\n+        }\n+    }\n+    if_chain! {\n+        // single `if` condition\n+        if true;\n+        then {\n+            let x = \"\";\n+            // nested if\n+            if true {}\n+        }\n+    }\n+    if_chain! {\n+        // starts with `let ..`\n+        let x = \"\";\n+        if let Some(1) = Some(1);\n+        then {\n+            let x = \"\";\n+            let x = \"\";\n+            // nested if_chain!\n+            if_chain! {\n+                if true;\n+                if true;\n+                then {}\n+            }\n+        }\n+    }\n+}\n+\n+fn negative() {\n+    if true {\n+        ();\n+        if_chain! {\n+            if true;\n+            if true;\n+            then { (); }\n+        }\n+    }\n+    if_chain! {\n+        if true;\n+        let x = \"\";\n+        if true;\n+        then { (); }\n+    }\n+    if_chain! {\n+        if true;\n+        if true;\n+        then {\n+            if true { 1 } else { 2 }\n+        } else {\n+            3\n+        }\n+    };\n+    if true {\n+        if_chain! {\n+            if true;\n+            if true;\n+            then {}\n+        }\n+    } else if false {\n+        if_chain! {\n+            if true;\n+            if false;\n+            then {}\n+        }\n+    }\n+}"}, {"sha": "b53c3ea05da9f20d91195349d78029390279cc26", "filename": "tests/ui-internal/if_chain_style.stderr", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui-internal%2Fif_chain_style.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui-internal%2Fif_chain_style.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fif_chain_style.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,85 @@\n+error: this `if` can be part of the inner `if_chain!`\n+  --> $DIR/if_chain_style.rs:9:5\n+   |\n+LL | /     if true {\n+LL | |         let x = \"\";\n+LL | |         // `if_chain!` inside `if`\n+LL | |         if_chain! {\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::if-chain-style` implied by `-D warnings`\n+help: this `let` statement can also be in the `if_chain!`\n+  --> $DIR/if_chain_style.rs:10:9\n+   |\n+LL |         let x = \"\";\n+   |         ^^^^^^^^^^^\n+\n+error: `if a && b;` should be `if a; if b;`\n+  --> $DIR/if_chain_style.rs:19:12\n+   |\n+LL |           if true\n+   |  ____________^\n+LL | |             // multi-line AND'ed conditions\n+LL | |             && false;\n+   | |____________________^\n+\n+error: `let` expression should be inside `then { .. }`\n+  --> $DIR/if_chain_style.rs:24:9\n+   |\n+LL |         let x = \"\";\n+   |         ^^^^^^^^^^^\n+\n+error: this `if` can be part of the outer `if_chain!`\n+  --> $DIR/if_chain_style.rs:35:13\n+   |\n+LL |             if true {}\n+   |             ^^^^^^^^^^\n+   |\n+help: this `let` statement can also be in the `if_chain!`\n+  --> $DIR/if_chain_style.rs:33:13\n+   |\n+LL |             let x = \"\";\n+   |             ^^^^^^^^^^^\n+\n+error: `if_chain!` only has one `if`\n+  --> $DIR/if_chain_style.rs:29:5\n+   |\n+LL | /     if_chain! {\n+LL | |         // single `if` condition\n+LL | |         if true;\n+LL | |         then {\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: `let` expression should be above the `if_chain!`\n+  --> $DIR/if_chain_style.rs:40:9\n+   |\n+LL |         let x = \"\";\n+   |         ^^^^^^^^^^^\n+\n+error: this `if_chain!` can be merged with the outer `if_chain!`\n+  --> $DIR/if_chain_style.rs:46:13\n+   |\n+LL | /             if_chain! {\n+LL | |                 if true;\n+LL | |                 if true;\n+LL | |                 then {}\n+LL | |             }\n+   | |_____________^\n+   |\n+help: these `let` statements can also be in the `if_chain!`\n+  --> $DIR/if_chain_style.rs:43:13\n+   |\n+LL | /             let x = \"\";\n+LL | |             let x = \"\";\n+   | |_______________________^\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "1a5cf1b1947c5e7be4c8266da92d6a63ab9552fa", "filename": "tests/ui-toml/upper_case_acronyms_aggressive/upper_case_acronyms.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -25,4 +25,20 @@ pub struct MIXEDCapital;\n \n pub struct FULLCAPITAL;\n \n+// enum variants should not be linted if the num is pub\n+pub enum ParseError<T> {\n+    FULLCAPITAL(u8),\n+    MIXEDCapital(String),\n+    Utf8(std::string::FromUtf8Error),\n+    Parse(T, String),\n+}\n+\n+// private, do lint here\n+enum ParseErrorPrivate<T> {\n+    WASD(u8),\n+    WASDMixed(String),\n+    Utf8(std::string::FromUtf8Error),\n+    Parse(T, String),\n+}\n+\n fn main() {}"}, {"sha": "02f29bbefe14a4f3043d563a90a1b6e978b5d11a", "filename": "tests/ui-toml/upper_case_acronyms_aggressive/upper_case_acronyms.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -66,5 +66,17 @@ error: name `GCCLLVMSomething` contains a capitalized acronym\n LL | struct GCCLLVMSomething;\n    |        ^^^^^^^^^^^^^^^^ help: consider making the acronym lowercase, except the initial letter: `GccllvmSomething`\n \n-error: aborting due to 11 previous errors\n+error: name `WASD` contains a capitalized acronym\n+  --> $DIR/upper_case_acronyms.rs:38:5\n+   |\n+LL |     WASD(u8),\n+   |     ^^^^ help: consider making the acronym lowercase, except the initial letter: `Wasd`\n+\n+error: name `WASDMixed` contains a capitalized acronym\n+  --> $DIR/upper_case_acronyms.rs:39:5\n+   |\n+LL |     WASDMixed(String),\n+   |     ^^^^^^^^^ help: consider making the acronym lowercase, except the initial letter: `WasdMixed`\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "4327f12c37c8eb82576eaff0d74cdf595194a93e", "filename": "tests/ui/borrow_interior_mutable_const/others.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,5 +1,9 @@\n #![warn(clippy::borrow_interior_mutable_const)]\n-#![allow(clippy::declare_interior_mutable_const, clippy::ref_in_deref)]\n+#![allow(\n+    clippy::declare_interior_mutable_const,\n+    clippy::ref_in_deref,\n+    clippy::needless_borrow\n+)]\n #![allow(const_item_mutation)]\n \n use std::borrow::Cow;"}, {"sha": "f146b97cf61161f0c96b320c8bc1c6759d09fa5f", "filename": "tests/ui/borrow_interior_mutable_const/others.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_interior_mutable_const%2Fothers.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,5 +1,5 @@\n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:54:5\n+  --> $DIR/others.rs:58:5\n    |\n LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    |     ^^^^^^\n@@ -8,103 +8,103 @@ LL |     ATOMIC.store(1, Ordering::SeqCst); //~ ERROR interior mutability\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:55:16\n+  --> $DIR/others.rs:59:16\n    |\n LL |     assert_eq!(ATOMIC.load(Ordering::SeqCst), 5); //~ ERROR interior mutability\n    |                ^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:58:22\n+  --> $DIR/others.rs:62:22\n    |\n LL |     let _once_ref = &ONCE_INIT; //~ ERROR interior mutability\n    |                      ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:59:25\n+  --> $DIR/others.rs:63:25\n    |\n LL |     let _once_ref_2 = &&ONCE_INIT; //~ ERROR interior mutability\n    |                         ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:60:27\n+  --> $DIR/others.rs:64:27\n    |\n LL |     let _once_ref_4 = &&&&ONCE_INIT; //~ ERROR interior mutability\n    |                           ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:61:26\n+  --> $DIR/others.rs:65:26\n    |\n LL |     let _once_mut = &mut ONCE_INIT; //~ ERROR interior mutability\n    |                          ^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:72:14\n+  --> $DIR/others.rs:76:14\n    |\n LL |     let _ = &ATOMIC_TUPLE; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:73:14\n+  --> $DIR/others.rs:77:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:74:19\n+  --> $DIR/others.rs:78:19\n    |\n LL |     let _ = &(&&&&ATOMIC_TUPLE).0; //~ ERROR interior mutability\n    |                   ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:75:14\n+  --> $DIR/others.rs:79:14\n    |\n LL |     let _ = &ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |              ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:76:13\n+  --> $DIR/others.rs:80:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0].load(Ordering::SeqCst); //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:82:13\n+  --> $DIR/others.rs:86:13\n    |\n LL |     let _ = ATOMIC_TUPLE.0[0]; //~ ERROR interior mutability\n    |             ^^^^^^^^^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:87:5\n+  --> $DIR/others.rs:91:5\n    |\n LL |     CELL.set(2); //~ ERROR interior mutability\n    |     ^^^^\n    |\n    = help: assign this const to a local or static variable, and use the variable here\n \n error: a `const` item with interior mutability should not be borrowed\n-  --> $DIR/others.rs:88:16\n+  --> $DIR/others.rs:92:16\n    |\n LL |     assert_eq!(CELL.get(), 6); //~ ERROR interior mutability\n    |                ^^^^"}, {"sha": "c389c243d447e45adaf8e20707d8d1013ee6736e", "filename": "tests/ui/branches_sharing_code/shared_at_bottom.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_bottom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_bottom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_bottom.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,209 @@\n+#![allow(dead_code)]\n+#![deny(clippy::if_same_then_else, clippy::branches_sharing_code)]\n+\n+// This tests the branches_sharing_code lint at the end of blocks\n+\n+fn simple_examples() {\n+    let x = 1;\n+\n+    let _ = if x == 7 {\n+        println!(\"Branch I\");\n+        let start_value = 0;\n+        println!(\"=^.^=\");\n+\n+        // Same but not moveable due to `start_value`\n+        let _ = start_value;\n+\n+        // The rest is self contained and moveable => Only lint the rest\n+        let result = false;\n+        println!(\"Block end!\");\n+        result\n+    } else {\n+        println!(\"Branch II\");\n+        let start_value = 8;\n+        println!(\"xD\");\n+\n+        // Same but not moveable due to `start_value`\n+        let _ = start_value;\n+\n+        // The rest is self contained and moveable => Only lint the rest\n+        let result = false;\n+        println!(\"Block end!\");\n+        result\n+    };\n+\n+    // Else if block\n+    if x == 9 {\n+        println!(\"The index is: 6\");\n+\n+        println!(\"Same end of block\");\n+    } else if x == 8 {\n+        println!(\"The index is: 4\");\n+\n+        // We should only get a lint trigger for the last statement\n+        println!(\"This is also eq with the else block\");\n+        println!(\"Same end of block\");\n+    } else {\n+        println!(\"This is also eq with the else block\");\n+        println!(\"Same end of block\");\n+    }\n+\n+    // Use of outer scope value\n+    let outer_scope_value = \"I'm outside the if block\";\n+    if x < 99 {\n+        let z = \"How are you\";\n+        println!(\"I'm a local because I use the value `z`: `{}`\", z);\n+\n+        println!(\n+            \"I'm moveable because I know: `outer_scope_value`: '{}'\",\n+            outer_scope_value\n+        );\n+    } else {\n+        let z = 45678000;\n+        println!(\"I'm a local because I use the value `z`: `{}`\", z);\n+\n+        println!(\n+            \"I'm moveable because I know: `outer_scope_value`: '{}'\",\n+            outer_scope_value\n+        );\n+    }\n+\n+    if x == 9 {\n+        if x == 8 {\n+            // No parent!!\n+            println!(\"---\");\n+            println!(\"Hello World\");\n+        } else {\n+            println!(\"Hello World\");\n+        }\n+    }\n+}\n+\n+/// Simple examples where the move can cause some problems due to moved values\n+fn simple_but_suggestion_is_invalid() {\n+    let x = 16;\n+\n+    // Local value\n+    let later_used_value = 17;\n+    if x == 9 {\n+        let _ = 9;\n+        let later_used_value = \"A string value\";\n+        println!(\"{}\", later_used_value);\n+    } else {\n+        let later_used_value = \"A string value\";\n+        println!(\"{}\", later_used_value);\n+        // I'm expecting a note about this\n+    }\n+    println!(\"{}\", later_used_value);\n+\n+    // outer function\n+    if x == 78 {\n+        let simple_examples = \"I now identify as a &str :)\";\n+        println!(\"This is the new simple_example: {}\", simple_examples);\n+    } else {\n+        println!(\"Separator print statement\");\n+\n+        let simple_examples = \"I now identify as a &str :)\";\n+        println!(\"This is the new simple_example: {}\", simple_examples);\n+    }\n+    simple_examples();\n+}\n+\n+/// Tests where the blocks are not linted due to the used value scope\n+fn not_moveable_due_to_value_scope() {\n+    let x = 18;\n+\n+    // Using a local value in the moved code\n+    if x == 9 {\n+        let y = 18;\n+        println!(\"y is: `{}`\", y);\n+    } else {\n+        let y = \"A string\";\n+        println!(\"y is: `{}`\", y);\n+    }\n+\n+    // Using a local value in the expression\n+    let _ = if x == 0 {\n+        let mut result = x + 1;\n+\n+        println!(\"1. Doing some calculations\");\n+        println!(\"2. Some more calculations\");\n+        println!(\"3. Setting result\");\n+\n+        result\n+    } else {\n+        let mut result = x - 1;\n+\n+        println!(\"1. Doing some calculations\");\n+        println!(\"2. Some more calculations\");\n+        println!(\"3. Setting result\");\n+\n+        result\n+    };\n+\n+    let _ = if x == 7 {\n+        let z1 = 100;\n+        println!(\"z1: {}\", z1);\n+\n+        let z2 = z1;\n+        println!(\"z2: {}\", z2);\n+\n+        z2\n+    } else {\n+        let z1 = 300;\n+        println!(\"z1: {}\", z1);\n+\n+        let z2 = z1;\n+        println!(\"z2: {}\", z2);\n+\n+        z2\n+    };\n+}\n+\n+/// This should add a note to the lint msg since the moved expression is not `()`\n+fn added_note_for_expression_use() -> u32 {\n+    let x = 9;\n+\n+    let _ = if x == 7 {\n+        x << 2\n+    } else {\n+        let _ = 6;\n+        x << 2\n+    };\n+\n+    if x == 9 {\n+        x * 4\n+    } else {\n+        let _ = 17;\n+        x * 4\n+    }\n+}\n+\n+#[rustfmt::skip]\n+fn test_suggestion_with_weird_formatting() {\n+    let x = 9;\n+    let mut a = 0;\n+    let mut b = 0;\n+\n+    // The error message still looks weird tbh but this is the best I can do\n+    // for weird formatting\n+    if x == 17 { b = 1; a = 0x99; } else { a = 0x99; }\n+}\n+\n+fn fp_test() {\n+    let x = 17;\n+\n+    if x == 18 {\n+        let y = 19;\n+        if y < x {\n+            println!(\"Trigger\")\n+        }\n+    } else {\n+        let z = 166;\n+        if z < x {\n+            println!(\"Trigger\")\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "271fcd8b6c129fa87203db8f8f04a4cd765ad93a", "filename": "tests/ui/branches_sharing_code/shared_at_bottom.stderr", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_bottom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_bottom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_bottom.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,143 @@\n+error: all if blocks contain the same code at the end\n+  --> $DIR/shared_at_bottom.rs:30:5\n+   |\n+LL | /         let result = false;\n+LL | |         println!(\"Block end!\");\n+LL | |         result\n+LL | |     };\n+   | |_____^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/shared_at_bottom.rs:2:36\n+   |\n+LL | #![deny(clippy::if_same_then_else, clippy::branches_sharing_code)]\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: The end suggestion probably needs some adjustments to use the expression result correctly\n+help: consider moving the end statements out like this\n+   |\n+LL |     }\n+LL |     let result = false;\n+LL |     println!(\"Block end!\");\n+LL |     result;\n+   |\n+\n+error: all if blocks contain the same code at the end\n+  --> $DIR/shared_at_bottom.rs:48:5\n+   |\n+LL | /         println!(\"Same end of block\");\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider moving the end statements out like this\n+   |\n+LL |     }\n+LL |     println!(\"Same end of block\");\n+   |\n+\n+error: all if blocks contain the same code at the end\n+  --> $DIR/shared_at_bottom.rs:65:5\n+   |\n+LL | /         println!(\n+LL | |             \"I'm moveable because I know: `outer_scope_value`: '{}'\",\n+LL | |             outer_scope_value\n+LL | |         );\n+LL | |     }\n+   | |_____^\n+   |\n+help: consider moving the end statements out like this\n+   |\n+LL |     }\n+LL |     println!(\n+LL |         \"I'm moveable because I know: `outer_scope_value`: '{}'\",\n+LL |         outer_scope_value\n+LL |     );\n+   |\n+\n+error: all if blocks contain the same code at the end\n+  --> $DIR/shared_at_bottom.rs:77:9\n+   |\n+LL | /             println!(\"Hello World\");\n+LL | |         }\n+   | |_________^\n+   |\n+help: consider moving the end statements out like this\n+   |\n+LL |         }\n+LL |         println!(\"Hello World\");\n+   |\n+\n+error: all if blocks contain the same code at the end\n+  --> $DIR/shared_at_bottom.rs:93:5\n+   |\n+LL | /         let later_used_value = \"A string value\";\n+LL | |         println!(\"{}\", later_used_value);\n+LL | |         // I'm expecting a note about this\n+LL | |     }\n+   | |_____^\n+   |\n+   = warning: Some moved values might need to be renamed to avoid wrong references\n+help: consider moving the end statements out like this\n+   |\n+LL |     }\n+LL |     let later_used_value = \"A string value\";\n+LL |     println!(\"{}\", later_used_value);\n+   |\n+\n+error: all if blocks contain the same code at the end\n+  --> $DIR/shared_at_bottom.rs:106:5\n+   |\n+LL | /         let simple_examples = \"I now identify as a &str :)\";\n+LL | |         println!(\"This is the new simple_example: {}\", simple_examples);\n+LL | |     }\n+   | |_____^\n+   |\n+   = warning: Some moved values might need to be renamed to avoid wrong references\n+help: consider moving the end statements out like this\n+   |\n+LL |     }\n+LL |     let simple_examples = \"I now identify as a &str :)\";\n+LL |     println!(\"This is the new simple_example: {}\", simple_examples);\n+   |\n+\n+error: all if blocks contain the same code at the end\n+  --> $DIR/shared_at_bottom.rs:171:5\n+   |\n+LL | /         x << 2\n+LL | |     };\n+   | |_____^\n+   |\n+   = note: The end suggestion probably needs some adjustments to use the expression result correctly\n+help: consider moving the end statements out like this\n+   |\n+LL |     }\n+LL |     x << 2;\n+   |\n+\n+error: all if blocks contain the same code at the end\n+  --> $DIR/shared_at_bottom.rs:178:5\n+   |\n+LL | /         x * 4\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: The end suggestion probably needs some adjustments to use the expression result correctly\n+help: consider moving the end statements out like this\n+   |\n+LL |     }\n+LL |     x * 4\n+   |\n+\n+error: all if blocks contain the same code at the end\n+  --> $DIR/shared_at_bottom.rs:190:44\n+   |\n+LL |     if x == 17 { b = 1; a = 0x99; } else { a = 0x99; }\n+   |                                            ^^^^^^^^^^^\n+   |\n+help: consider moving the end statements out like this\n+   |\n+LL |     if x == 17 { b = 1; a = 0x99; } else { }\n+LL |     a = 0x99;\n+   |\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "e65bcfd78737f329e673fbce03cc79343ce40e03", "filename": "tests/ui/branches_sharing_code/shared_at_top.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,103 @@\n+#![allow(dead_code, clippy::eval_order_dependence)]\n+#![deny(clippy::if_same_then_else, clippy::branches_sharing_code)]\n+\n+// This tests the branches_sharing_code lint at the start of blocks\n+\n+fn simple_examples() {\n+    let x = 0;\n+\n+    // Simple\n+    if true {\n+        println!(\"Hello World!\");\n+        println!(\"I'm branch nr: 1\");\n+    } else {\n+        println!(\"Hello World!\");\n+        println!(\"I'm branch nr: 2\");\n+    }\n+\n+    // Else if\n+    if x == 0 {\n+        let y = 9;\n+        println!(\"The value y was set to: `{}`\", y);\n+        let _z = y;\n+\n+        println!(\"I'm the true start index of arrays\");\n+    } else if x == 1 {\n+        let y = 9;\n+        println!(\"The value y was set to: `{}`\", y);\n+        let _z = y;\n+\n+        println!(\"I start counting from 1 so my array starts from `1`\");\n+    } else {\n+        let y = 9;\n+        println!(\"The value y was set to: `{}`\", y);\n+        let _z = y;\n+\n+        println!(\"Ha, Pascal allows you to start the array where you want\")\n+    }\n+\n+    // Return a value\n+    let _ = if x == 7 {\n+        let y = 16;\n+        println!(\"What can I say except: \\\"you're welcome?\\\"\");\n+        let _ = y;\n+        x\n+    } else {\n+        let y = 16;\n+        println!(\"Thank you\");\n+        y\n+    };\n+}\n+\n+/// Simple examples where the move can cause some problems due to moved values\n+fn simple_but_suggestion_is_invalid() {\n+    let x = 10;\n+\n+    // Can't be automatically moved because used_value_name is getting used again\n+    let used_value_name = 19;\n+    if x == 10 {\n+        let used_value_name = \"Different type\";\n+        println!(\"Str: {}\", used_value_name);\n+        let _ = 1;\n+    } else {\n+        let used_value_name = \"Different type\";\n+        println!(\"Str: {}\", used_value_name);\n+        let _ = 2;\n+    }\n+    let _ = used_value_name;\n+\n+    // This can be automatically moved as `can_be_overridden` is not used again\n+    let can_be_overridden = 8;\n+    let _ = can_be_overridden;\n+    if x == 11 {\n+        let can_be_overridden = \"Move me\";\n+        println!(\"I'm also moveable\");\n+        let _ = 111;\n+    } else {\n+        let can_be_overridden = \"Move me\";\n+        println!(\"I'm also moveable\");\n+        let _ = 222;\n+    }\n+}\n+\n+/// This function tests that the `IS_SAME_THAN_ELSE` only covers the lint if it's enabled.\n+fn check_if_same_than_else_mask() {\n+    let x = 2021;\n+\n+    #[allow(clippy::if_same_then_else)]\n+    if x == 2020 {\n+        println!(\"This should trigger the `SHARED_CODE_IN_IF_BLOCKS` lint.\");\n+        println!(\"Because `IF_SAME_THEN_ELSE` is allowed here\");\n+    } else {\n+        println!(\"This should trigger the `SHARED_CODE_IN_IF_BLOCKS` lint.\");\n+        println!(\"Because `IF_SAME_THEN_ELSE` is allowed here\");\n+    }\n+\n+    if x == 2019 {\n+        println!(\"This should trigger `IS_SAME_THAN_ELSE` as usual\");\n+    } else {\n+        println!(\"This should trigger `IS_SAME_THAN_ELSE` as usual\");\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "15867e9ea020ac09d5aa280e761f622be9229e13", "filename": "tests/ui/branches_sharing_code/shared_at_top.stderr", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,121 @@\n+error: all if blocks contain the same code at the start\n+  --> $DIR/shared_at_top.rs:10:5\n+   |\n+LL | /     if true {\n+LL | |         println!(\"Hello World!\");\n+   | |_________________________________^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/shared_at_top.rs:2:36\n+   |\n+LL | #![deny(clippy::if_same_then_else, clippy::branches_sharing_code)]\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider moving the start statements out like this\n+   |\n+LL |     println!(\"Hello World!\");\n+LL |     if true {\n+   |\n+\n+error: all if blocks contain the same code at the start\n+  --> $DIR/shared_at_top.rs:19:5\n+   |\n+LL | /     if x == 0 {\n+LL | |         let y = 9;\n+LL | |         println!(\"The value y was set to: `{}`\", y);\n+LL | |         let _z = y;\n+   | |___________________^\n+   |\n+   = warning: Some moved values might need to be renamed to avoid wrong references\n+help: consider moving the start statements out like this\n+   |\n+LL |     let y = 9;\n+LL |     println!(\"The value y was set to: `{}`\", y);\n+LL |     let _z = y;\n+LL |     if x == 0 {\n+   |\n+\n+error: all if blocks contain the same code at the start\n+  --> $DIR/shared_at_top.rs:40:5\n+   |\n+LL | /     let _ = if x == 7 {\n+LL | |         let y = 16;\n+   | |___________________^\n+   |\n+help: consider moving the start statements out like this\n+   |\n+LL |     let y = 16;\n+LL |     let _ = if x == 7 {\n+   |\n+\n+error: all if blocks contain the same code at the start\n+  --> $DIR/shared_at_top.rs:58:5\n+   |\n+LL | /     if x == 10 {\n+LL | |         let used_value_name = \"Different type\";\n+LL | |         println!(\"Str: {}\", used_value_name);\n+   | |_____________________________________________^\n+   |\n+   = warning: Some moved values might need to be renamed to avoid wrong references\n+help: consider moving the start statements out like this\n+   |\n+LL |     let used_value_name = \"Different type\";\n+LL |     println!(\"Str: {}\", used_value_name);\n+LL |     if x == 10 {\n+   |\n+\n+error: all if blocks contain the same code at the start\n+  --> $DIR/shared_at_top.rs:72:5\n+   |\n+LL | /     if x == 11 {\n+LL | |         let can_be_overridden = \"Move me\";\n+LL | |         println!(\"I'm also moveable\");\n+   | |______________________________________^\n+   |\n+   = warning: Some moved values might need to be renamed to avoid wrong references\n+help: consider moving the start statements out like this\n+   |\n+LL |     let can_be_overridden = \"Move me\";\n+LL |     println!(\"I'm also moveable\");\n+LL |     if x == 11 {\n+   |\n+\n+error: all if blocks contain the same code at the start\n+  --> $DIR/shared_at_top.rs:88:5\n+   |\n+LL | /     if x == 2020 {\n+LL | |         println!(\"This should trigger the `SHARED_CODE_IN_IF_BLOCKS` lint.\");\n+LL | |         println!(\"Because `IF_SAME_THEN_ELSE` is allowed here\");\n+   | |________________________________________________________________^\n+   |\n+help: consider moving the start statements out like this\n+   |\n+LL |     println!(\"This should trigger the `SHARED_CODE_IN_IF_BLOCKS` lint.\");\n+LL |     println!(\"Because `IF_SAME_THEN_ELSE` is allowed here\");\n+LL |     if x == 2020 {\n+   |\n+\n+error: this `if` has identical blocks\n+  --> $DIR/shared_at_top.rs:96:18\n+   |\n+LL |       if x == 2019 {\n+   |  __________________^\n+LL | |         println!(\"This should trigger `IS_SAME_THAN_ELSE` as usual\");\n+LL | |     } else {\n+   | |_____^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/shared_at_top.rs:2:9\n+   |\n+LL | #![deny(clippy::if_same_then_else, clippy::branches_sharing_code)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: same as this\n+  --> $DIR/shared_at_top.rs:98:12\n+   |\n+LL |       } else {\n+   |  ____________^\n+LL | |         println!(\"This should trigger `IS_SAME_THAN_ELSE` as usual\");\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "deefdad32c9dd271635a5cac077d817490d409ca", "filename": "tests/ui/branches_sharing_code/shared_at_top_and_bottom.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top_and_bottom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top_and_bottom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top_and_bottom.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,119 @@\n+#![allow(dead_code)]\n+#![deny(clippy::if_same_then_else, clippy::branches_sharing_code)]\n+\n+// branches_sharing_code at the top and bottom of the if blocks\n+\n+struct DataPack {\n+    id: u32,\n+    name: String,\n+    some_data: Vec<u8>,\n+}\n+\n+fn overlapping_eq_regions() {\n+    let x = 9;\n+\n+    // Overlap with separator\n+    if x == 7 {\n+        let t = 7;\n+        let _overlap_start = t * 2;\n+        let _overlap_end = 2 * t;\n+        let _u = 9;\n+    } else {\n+        let t = 7;\n+        let _overlap_start = t * 2;\n+        let _overlap_end = 2 * t;\n+        println!(\"Overlap separator\");\n+        let _overlap_start = t * 2;\n+        let _overlap_end = 2 * t;\n+        let _u = 9;\n+    }\n+\n+    // Overlap with separator\n+    if x == 99 {\n+        let r = 7;\n+        let _overlap_start = r;\n+        let _overlap_middle = r * r;\n+        let _overlap_end = r * r * r;\n+        let z = \"end\";\n+    } else {\n+        let r = 7;\n+        let _overlap_start = r;\n+        let _overlap_middle = r * r;\n+        let _overlap_middle = r * r;\n+        let _overlap_end = r * r * r;\n+        let z = \"end\";\n+    }\n+}\n+\n+fn complexer_example() {\n+    fn gen_id(x: u32, y: u32) -> u32 {\n+        let x = x & 0x0000_ffff;\n+        let y = (y & 0xffff_0000) << 16;\n+        x | y\n+    }\n+\n+    fn process_data(data: DataPack) {\n+        let _ = data;\n+    }\n+\n+    let x = 8;\n+    let y = 9;\n+    if (x > 7 && y < 13) || (x + y) % 2 == 1 {\n+        let a = 0xcafe;\n+        let b = 0xffff00ff;\n+        let e_id = gen_id(a, b);\n+\n+        println!(\"From the a `{}` to the b `{}`\", a, b);\n+\n+        let pack = DataPack {\n+            id: e_id,\n+            name: \"Player 1\".to_string(),\n+            some_data: vec![0x12, 0x34, 0x56, 0x78, 0x90],\n+        };\n+        process_data(pack);\n+    } else {\n+        let a = 0xcafe;\n+        let b = 0xffff00ff;\n+        let e_id = gen_id(a, b);\n+\n+        println!(\"The new ID is '{}'\", e_id);\n+\n+        let pack = DataPack {\n+            id: e_id,\n+            name: \"Player 1\".to_string(),\n+            some_data: vec![0x12, 0x34, 0x56, 0x78, 0x90],\n+        };\n+        process_data(pack);\n+    }\n+}\n+\n+/// This should add a note to the lint msg since the moved expression is not `()`\n+fn added_note_for_expression_use() -> u32 {\n+    let x = 9;\n+\n+    let _ = if x == 7 {\n+        let _ = 19;\n+\n+        let _splitter = 6;\n+\n+        x << 2\n+    } else {\n+        let _ = 19;\n+\n+        x << 2\n+    };\n+\n+    if x == 9 {\n+        let _ = 17;\n+\n+        let _splitter = 6;\n+\n+        x * 4\n+    } else {\n+        let _ = 17;\n+\n+        x * 4\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "212cfb2f1d1803f3ef7b96314a95b09b86dbbfbe", "filename": "tests/ui/branches_sharing_code/shared_at_top_and_bottom.stderr", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top_and_bottom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top_and_bottom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Fshared_at_top_and_bottom.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,154 @@\n+error: all if blocks contain the same code at the start and the end. Here at the start\n+  --> $DIR/shared_at_top_and_bottom.rs:16:5\n+   |\n+LL | /     if x == 7 {\n+LL | |         let t = 7;\n+LL | |         let _overlap_start = t * 2;\n+LL | |         let _overlap_end = 2 * t;\n+   | |_________________________________^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/shared_at_top_and_bottom.rs:2:36\n+   |\n+LL | #![deny(clippy::if_same_then_else, clippy::branches_sharing_code)]\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: and here at the end\n+  --> $DIR/shared_at_top_and_bottom.rs:28:5\n+   |\n+LL | /         let _u = 9;\n+LL | |     }\n+   | |_____^\n+help: consider moving the start statements out like this\n+   |\n+LL |     let t = 7;\n+LL |     let _overlap_start = t * 2;\n+LL |     let _overlap_end = 2 * t;\n+LL |     if x == 7 {\n+   |\n+help: and consider moving the end statements out like this\n+   |\n+LL |     }\n+LL |     let _u = 9;\n+   |\n+\n+error: all if blocks contain the same code at the start and the end. Here at the start\n+  --> $DIR/shared_at_top_and_bottom.rs:32:5\n+   |\n+LL | /     if x == 99 {\n+LL | |         let r = 7;\n+LL | |         let _overlap_start = r;\n+LL | |         let _overlap_middle = r * r;\n+   | |____________________________________^\n+   |\n+note: and here at the end\n+  --> $DIR/shared_at_top_and_bottom.rs:43:5\n+   |\n+LL | /         let _overlap_end = r * r * r;\n+LL | |         let z = \"end\";\n+LL | |     }\n+   | |_____^\n+   = warning: Some moved values might need to be renamed to avoid wrong references\n+help: consider moving the start statements out like this\n+   |\n+LL |     let r = 7;\n+LL |     let _overlap_start = r;\n+LL |     let _overlap_middle = r * r;\n+LL |     if x == 99 {\n+   |\n+help: and consider moving the end statements out like this\n+   |\n+LL |     }\n+LL |     let _overlap_end = r * r * r;\n+LL |     let z = \"end\";\n+   |\n+\n+error: all if blocks contain the same code at the start and the end. Here at the start\n+  --> $DIR/shared_at_top_and_bottom.rs:61:5\n+   |\n+LL | /     if (x > 7 && y < 13) || (x + y) % 2 == 1 {\n+LL | |         let a = 0xcafe;\n+LL | |         let b = 0xffff00ff;\n+LL | |         let e_id = gen_id(a, b);\n+   | |________________________________^\n+   |\n+note: and here at the end\n+  --> $DIR/shared_at_top_and_bottom.rs:81:5\n+   |\n+LL | /         let pack = DataPack {\n+LL | |             id: e_id,\n+LL | |             name: \"Player 1\".to_string(),\n+LL | |             some_data: vec![0x12, 0x34, 0x56, 0x78, 0x90],\n+LL | |         };\n+LL | |         process_data(pack);\n+LL | |     }\n+   | |_____^\n+   = warning: Some moved values might need to be renamed to avoid wrong references\n+help: consider moving the start statements out like this\n+   |\n+LL |     let a = 0xcafe;\n+LL |     let b = 0xffff00ff;\n+LL |     let e_id = gen_id(a, b);\n+LL |     if (x > 7 && y < 13) || (x + y) % 2 == 1 {\n+   |\n+help: and consider moving the end statements out like this\n+   |\n+LL |     }\n+LL |     let pack = DataPack {\n+LL |         id: e_id,\n+LL |         name: \"Player 1\".to_string(),\n+LL |         some_data: vec![0x12, 0x34, 0x56, 0x78, 0x90],\n+LL |     };\n+ ...\n+\n+error: all if blocks contain the same code at the start and the end. Here at the start\n+  --> $DIR/shared_at_top_and_bottom.rs:94:5\n+   |\n+LL | /     let _ = if x == 7 {\n+LL | |         let _ = 19;\n+   | |___________________^\n+   |\n+note: and here at the end\n+  --> $DIR/shared_at_top_and_bottom.rs:103:5\n+   |\n+LL | /         x << 2\n+LL | |     };\n+   | |_____^\n+   = note: The end suggestion probably needs some adjustments to use the expression result correctly\n+help: consider moving the start statements out like this\n+   |\n+LL |     let _ = 19;\n+LL |     let _ = if x == 7 {\n+   |\n+help: and consider moving the end statements out like this\n+   |\n+LL |     }\n+LL |     x << 2;\n+   |\n+\n+error: all if blocks contain the same code at the start and the end. Here at the start\n+  --> $DIR/shared_at_top_and_bottom.rs:106:5\n+   |\n+LL | /     if x == 9 {\n+LL | |         let _ = 17;\n+   | |___________________^\n+   |\n+note: and here at the end\n+  --> $DIR/shared_at_top_and_bottom.rs:115:5\n+   |\n+LL | /         x * 4\n+LL | |     }\n+   | |_____^\n+   = note: The end suggestion probably needs some adjustments to use the expression result correctly\n+help: consider moving the start statements out like this\n+   |\n+LL |     let _ = 17;\n+LL |     if x == 9 {\n+   |\n+help: and consider moving the end statements out like this\n+   |\n+LL |     }\n+LL |     x * 4\n+   |\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "0c70e3748ec16aa480832a1297f7d7eb96b8f1c8", "filename": "tests/ui/branches_sharing_code/valid_if_blocks.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fbranches_sharing_code%2Fvalid_if_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fbranches_sharing_code%2Fvalid_if_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Fvalid_if_blocks.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,155 @@\n+#![allow(dead_code, clippy::eval_order_dependence)]\n+#![deny(clippy::if_same_then_else, clippy::branches_sharing_code)]\n+\n+// This tests valid if blocks that shouldn't trigger the lint\n+\n+// Tests with value references are includes in \"shared_code_at_bottom.rs\"\n+\n+fn valid_examples() {\n+    let x = 2;\n+\n+    // The edge statements are different\n+    if x == 9 {\n+        let y = 1 << 5;\n+\n+        println!(\"This is the same: vvv\");\n+        let _z = y;\n+        println!(\"The block expression is different\");\n+\n+        println!(\"Different end 1\");\n+    } else {\n+        let y = 1 << 7;\n+\n+        println!(\"This is the same: vvv\");\n+        let _z = y;\n+        println!(\"The block expression is different\");\n+\n+        println!(\"Different end 2\");\n+    }\n+\n+    // No else\n+    if x == 2 {\n+        println!(\"Hello world!\");\n+        println!(\"Hello back, how are you?\");\n+\n+        // This is different vvvv\n+        println!(\"Howdy stranger =^.^=\");\n+\n+        println!(\"Bye Bye World\");\n+    } else if x == 9 {\n+        println!(\"Hello world!\");\n+        println!(\"Hello back, how are you?\");\n+\n+        // This is different vvvv\n+        println!(\"Hello reviewer :D\");\n+\n+        println!(\"Bye Bye World\");\n+    }\n+\n+    // Overlapping statements only in else if blocks -> Don't lint\n+    if x == 0 {\n+        println!(\"I'm important!\")\n+    } else if x == 17 {\n+        println!(\"I share code in else if\");\n+\n+        println!(\"x is 17\");\n+    } else {\n+        println!(\"I share code in else if\");\n+\n+        println!(\"x is nether x nor 17\");\n+    }\n+\n+    // Mutability is different\n+    if x == 13 {\n+        let mut y = 9;\n+        println!(\"Value y is: {}\", y);\n+        y += 16;\n+        let _z1 = y;\n+    } else {\n+        let y = 9;\n+        println!(\"Value y is: {}\", y);\n+        let _z2 = y;\n+    }\n+\n+    // Same blocks but at start and bottom so no `if_same_then_else` lint\n+    if x == 418 {\n+        let y = 9;\n+        let z = 8;\n+        let _ = (x, y, z);\n+        // Don't tell the programmer, my code is also in the else block\n+    } else if x == 419 {\n+        println!(\"+-----------+\");\n+        println!(\"|           |\");\n+        println!(\"|  O     O  |\");\n+        println!(\"|     \u00b0     |\");\n+        println!(\"|  \\\\_____/  |\");\n+        println!(\"|           |\");\n+        println!(\"+-----------+\");\n+    } else {\n+        let y = 9;\n+        let z = 8;\n+        let _ = (x, y, z);\n+        // I'm so much better than the x == 418 block. Trust me\n+    }\n+\n+    let x = 1;\n+    if true {\n+        println!(\"{}\", x);\n+    } else {\n+        let x = 2;\n+        println!(\"{}\", x);\n+    }\n+\n+    // Let's test empty blocks\n+    if false {\n+    } else {\n+    }\n+}\n+\n+/// This makes sure that the `if_same_then_else` masks the `shared_code_in_if_blocks` lint\n+fn trigger_other_lint() {\n+    let x = 0;\n+    let y = 1;\n+\n+    // Same block\n+    if x == 0 {\n+        let u = 19;\n+        println!(\"How are u today?\");\n+        let _ = \"This is a string\";\n+    } else {\n+        let u = 19;\n+        println!(\"How are u today?\");\n+        let _ = \"This is a string\";\n+    }\n+\n+    // Only same expression\n+    let _ = if x == 6 { 7 } else { 7 };\n+\n+    // Same in else if block\n+    let _ = if x == 67 {\n+        println!(\"Well I'm the most important block\");\n+        \"I'm a pretty string\"\n+    } else if x == 68 {\n+        println!(\"I'm a doppelg\u00e4nger\");\n+        // Don't listen to my clone below\n+\n+        if y == 90 { \"=^.^=\" } else { \":D\" }\n+    } else {\n+        // Don't listen to my clone above\n+        println!(\"I'm a doppelg\u00e4nger\");\n+\n+        if y == 90 { \"=^.^=\" } else { \":D\" }\n+    };\n+\n+    if x == 0 {\n+        println!(\"I'm single\");\n+    } else if x == 68 {\n+        println!(\"I'm a doppelg\u00e4nger\");\n+        // Don't listen to my clone below\n+    } else {\n+        // Don't listen to my clone above\n+        println!(\"I'm a doppelg\u00e4nger\");\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a815995e71721f1bcd75a7a21897e2d04b4edcfd", "filename": "tests/ui/branches_sharing_code/valid_if_blocks.stderr", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fbranches_sharing_code%2Fvalid_if_blocks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fbranches_sharing_code%2Fvalid_if_blocks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbranches_sharing_code%2Fvalid_if_blocks.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,101 @@\n+error: this `if` has identical blocks\n+  --> $DIR/valid_if_blocks.rs:104:14\n+   |\n+LL |       if false {\n+   |  ______________^\n+LL | |     } else {\n+   | |_____^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/valid_if_blocks.rs:2:9\n+   |\n+LL | #![deny(clippy::if_same_then_else, clippy::branches_sharing_code)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: same as this\n+  --> $DIR/valid_if_blocks.rs:105:12\n+   |\n+LL |       } else {\n+   |  ____________^\n+LL | |     }\n+   | |_____^\n+\n+error: this `if` has identical blocks\n+  --> $DIR/valid_if_blocks.rs:115:15\n+   |\n+LL |       if x == 0 {\n+   |  _______________^\n+LL | |         let u = 19;\n+LL | |         println!(\"How are u today?\");\n+LL | |         let _ = \"This is a string\";\n+LL | |     } else {\n+   | |_____^\n+   |\n+note: same as this\n+  --> $DIR/valid_if_blocks.rs:119:12\n+   |\n+LL |       } else {\n+   |  ____________^\n+LL | |         let u = 19;\n+LL | |         println!(\"How are u today?\");\n+LL | |         let _ = \"This is a string\";\n+LL | |     }\n+   | |_____^\n+\n+error: this `if` has identical blocks\n+  --> $DIR/valid_if_blocks.rs:126:23\n+   |\n+LL |     let _ = if x == 6 { 7 } else { 7 };\n+   |                       ^^^^^\n+   |\n+note: same as this\n+  --> $DIR/valid_if_blocks.rs:126:34\n+   |\n+LL |     let _ = if x == 6 { 7 } else { 7 };\n+   |                                  ^^^^^\n+\n+error: this `if` has identical blocks\n+  --> $DIR/valid_if_blocks.rs:132:23\n+   |\n+LL |       } else if x == 68 {\n+   |  _______________________^\n+LL | |         println!(\"I'm a doppelg\u00e4nger\");\n+LL | |         // Don't listen to my clone below\n+LL | |\n+LL | |         if y == 90 { \"=^.^=\" } else { \":D\" }\n+LL | |     } else {\n+   | |_____^\n+   |\n+note: same as this\n+  --> $DIR/valid_if_blocks.rs:137:12\n+   |\n+LL |       } else {\n+   |  ____________^\n+LL | |         // Don't listen to my clone above\n+LL | |         println!(\"I'm a doppelg\u00e4nger\");\n+LL | |\n+LL | |         if y == 90 { \"=^.^=\" } else { \":D\" }\n+LL | |     };\n+   | |_____^\n+\n+error: this `if` has identical blocks\n+  --> $DIR/valid_if_blocks.rs:146:23\n+   |\n+LL |       } else if x == 68 {\n+   |  _______________________^\n+LL | |         println!(\"I'm a doppelg\u00e4nger\");\n+LL | |         // Don't listen to my clone below\n+LL | |     } else {\n+   | |_____^\n+   |\n+note: same as this\n+  --> $DIR/valid_if_blocks.rs:149:12\n+   |\n+LL |       } else {\n+   |  ____________^\n+LL | |         // Don't listen to my clone above\n+LL | |         println!(\"I'm a doppelg\u00e4nger\");\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "ec082c73b44c08fa534779647f395260864d3266", "filename": "tests/ui/checked_unwrap/complex_conditionals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,5 +1,5 @@\n #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n-#![allow(clippy::if_same_then_else)]\n+#![allow(clippy::if_same_then_else, clippy::branches_sharing_code)]\n \n fn test_complex_conditions() {\n     let x: Result<(), ()> = Ok(());"}, {"sha": "043ea4148dc517ed736dacd5c647f69d5c456fcf", "filename": "tests/ui/checked_unwrap/complex_conditionals_nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals_nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals_nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals_nested.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,5 +1,5 @@\n #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n-#![allow(clippy::if_same_then_else)]\n+#![allow(clippy::if_same_then_else, clippy::branches_sharing_code)]\n \n fn test_nested() {\n     fn nested() {"}, {"sha": "8f23fb28827a23a8841a70f4743dca2067c0ee6e", "filename": "tests/ui/checked_unwrap/simple_conditionals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,5 +1,5 @@\n #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n-#![allow(clippy::if_same_then_else)]\n+#![allow(clippy::if_same_then_else, clippy::branches_sharing_code)]\n \n macro_rules! m {\n     ($a:expr) => {"}, {"sha": "8d43f64768d417f3b7323ce95dcfe4bf490b2279", "filename": "tests/ui/clone_on_copy.fixed", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fclone_on_copy.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fclone_on_copy.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy.fixed?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -6,7 +6,8 @@\n     clippy::deref_addrof,\n     clippy::no_effect,\n     clippy::unnecessary_operation,\n-    clippy::vec_init_then_push\n+    clippy::vec_init_then_push,\n+    clippy::toplevel_ref_arg\n )]\n \n use std::cell::RefCell;\n@@ -29,6 +30,37 @@ fn clone_on_copy() {\n     let rc = RefCell::new(0);\n     *rc.borrow();\n \n+    let x = 0u32;\n+    x.rotate_left(1);\n+\n+    #[derive(Clone, Copy)]\n+    struct Foo;\n+    impl Foo {\n+        fn clone(&self) -> u32 {\n+            0\n+        }\n+    }\n+    Foo.clone(); // ok, this is not the clone trait\n+\n+    macro_rules! m {\n+        ($e:expr) => {{ $e }};\n+    }\n+    m!(42);\n+\n+    struct Wrap([u32; 2]);\n+    impl core::ops::Deref for Wrap {\n+        type Target = [u32; 2];\n+        fn deref(&self) -> &[u32; 2] {\n+            &self.0\n+        }\n+    }\n+    let x = Wrap([0, 0]);\n+    (*x)[0];\n+\n+    let x = 42;\n+    let ref y = x.clone(); // ok, binds by reference\n+    let ref mut y = x.clone(); // ok, binds by reference\n+\n     // Issue #4348\n     let mut x = 43;\n     let _ = &x.clone(); // ok, getting a ref"}, {"sha": "f15501f71844f0ceb1b9f4a59acd5e5952e30540", "filename": "tests/ui/clone_on_copy.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -6,7 +6,8 @@\n     clippy::deref_addrof,\n     clippy::no_effect,\n     clippy::unnecessary_operation,\n-    clippy::vec_init_then_push\n+    clippy::vec_init_then_push,\n+    clippy::toplevel_ref_arg\n )]\n \n use std::cell::RefCell;\n@@ -29,6 +30,37 @@ fn clone_on_copy() {\n     let rc = RefCell::new(0);\n     rc.borrow().clone();\n \n+    let x = 0u32;\n+    x.clone().rotate_left(1);\n+\n+    #[derive(Clone, Copy)]\n+    struct Foo;\n+    impl Foo {\n+        fn clone(&self) -> u32 {\n+            0\n+        }\n+    }\n+    Foo.clone(); // ok, this is not the clone trait\n+\n+    macro_rules! m {\n+        ($e:expr) => {{ $e }};\n+    }\n+    m!(42).clone();\n+\n+    struct Wrap([u32; 2]);\n+    impl core::ops::Deref for Wrap {\n+        type Target = [u32; 2];\n+        fn deref(&self) -> &[u32; 2] {\n+            &self.0\n+        }\n+    }\n+    let x = Wrap([0, 0]);\n+    x.clone()[0];\n+\n+    let x = 42;\n+    let ref y = x.clone(); // ok, binds by reference\n+    let ref mut y = x.clone(); // ok, binds by reference\n+\n     // Issue #4348\n     let mut x = 43;\n     let _ = &x.clone(); // ok, getting a ref"}, {"sha": "e7d28b4320bc862691b54709ed4e8bbe605d04ac", "filename": "tests/ui/clone_on_copy.stderr", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fclone_on_copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fclone_on_copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,34 +1,52 @@\n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:23:5\n+  --> $DIR/clone_on_copy.rs:24:5\n    |\n LL |     42.clone();\n    |     ^^^^^^^^^^ help: try removing the `clone` call: `42`\n    |\n    = note: `-D clippy::clone-on-copy` implied by `-D warnings`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:27:5\n+  --> $DIR/clone_on_copy.rs:28:5\n    |\n LL |     (&42).clone();\n    |     ^^^^^^^^^^^^^ help: try dereferencing it: `*(&42)`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:30:5\n+  --> $DIR/clone_on_copy.rs:31:5\n    |\n LL |     rc.borrow().clone();\n    |     ^^^^^^^^^^^^^^^^^^^ help: try dereferencing it: `*rc.borrow()`\n \n+error: using `clone` on type `u32` which implements the `Copy` trait\n+  --> $DIR/clone_on_copy.rs:34:5\n+   |\n+LL |     x.clone().rotate_left(1);\n+   |     ^^^^^^^^^ help: try removing the `clone` call: `x`\n+\n+error: using `clone` on type `i32` which implements the `Copy` trait\n+  --> $DIR/clone_on_copy.rs:48:5\n+   |\n+LL |     m!(42).clone();\n+   |     ^^^^^^^^^^^^^^ help: try removing the `clone` call: `m!(42)`\n+\n+error: using `clone` on type `[u32; 2]` which implements the `Copy` trait\n+  --> $DIR/clone_on_copy.rs:58:5\n+   |\n+LL |     x.clone()[0];\n+   |     ^^^^^^^^^ help: try dereferencing it: `(*x)`\n+\n error: using `clone` on type `char` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:36:14\n+  --> $DIR/clone_on_copy.rs:68:14\n    |\n LL |     is_ascii('z'.clone());\n    |              ^^^^^^^^^^^ help: try removing the `clone` call: `'z'`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:40:14\n+  --> $DIR/clone_on_copy.rs:72:14\n    |\n LL |     vec.push(42.clone());\n    |              ^^^^^^^^^^ help: try removing the `clone` call: `42`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "5bfa256623b6bbcd5b56bb93421b655e417f0d68", "filename": "tests/ui/clone_on_copy_mut.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cde58f7174cd83752b3c0a00a970dcc07c511077/tests%2Fui%2Fclone_on_copy_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde58f7174cd83752b3c0a00a970dcc07c511077/tests%2Fui%2Fclone_on_copy_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy_mut.rs?ref=cde58f7174cd83752b3c0a00a970dcc07c511077", "patch": "@@ -1,18 +0,0 @@\n-pub fn dec_read_dec(i: &mut i32) -> i32 {\n-    *i -= 1;\n-    let ret = *i;\n-    *i -= 1;\n-    ret\n-}\n-\n-pub fn minus_1(i: &i32) -> i32 {\n-    dec_read_dec(&mut i.clone())\n-}\n-\n-fn main() {\n-    let mut i = 10;\n-    assert_eq!(minus_1(&i), 9);\n-    assert_eq!(i, 10);\n-    assert_eq!(dec_read_dec(&mut i), 9);\n-    assert_eq!(i, 8);\n-}"}, {"sha": "542e69484276d47b96cc79c3ad382fd6270147a6", "filename": "tests/ui/collapsible_match2.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fcollapsible_match2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fcollapsible_match2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match2.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,5 +1,10 @@\n #![warn(clippy::collapsible_match)]\n-#![allow(clippy::needless_return, clippy::no_effect, clippy::single_match)]\n+#![allow(\n+    clippy::needless_return,\n+    clippy::no_effect,\n+    clippy::single_match,\n+    clippy::needless_borrow\n+)]\n \n fn lint_cases(opt_opt: Option<Option<u32>>, res_opt: Result<Option<u32>, String>) {\n     // if guards on outer match"}, {"sha": "ffef32d1fde9aac110ff74304c5d002d301a63e7", "filename": "tests/ui/collapsible_match2.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fcollapsible_match2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fcollapsible_match2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match2.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,5 +1,5 @@\n error: unnecessary nested match\n-  --> $DIR/collapsible_match2.rs:8:34\n+  --> $DIR/collapsible_match2.rs:13:34\n    |\n LL |               Ok(val) if make() => match val {\n    |  __________________________________^\n@@ -10,15 +10,15 @@ LL | |             },\n    |\n    = note: `-D clippy::collapsible-match` implied by `-D warnings`\n help: the outer pattern can be modified to include the inner pattern\n-  --> $DIR/collapsible_match2.rs:8:16\n+  --> $DIR/collapsible_match2.rs:13:16\n    |\n LL |             Ok(val) if make() => match val {\n    |                ^^^ replace this binding\n LL |                 Some(n) => foo(n),\n    |                 ^^^^^^^ with this pattern\n \n error: unnecessary nested match\n-  --> $DIR/collapsible_match2.rs:15:24\n+  --> $DIR/collapsible_match2.rs:20:24\n    |\n LL |               Ok(val) => match val {\n    |  ________________________^\n@@ -28,15 +28,15 @@ LL | |             },\n    | |_____________^\n    |\n help: the outer pattern can be modified to include the inner pattern\n-  --> $DIR/collapsible_match2.rs:15:16\n+  --> $DIR/collapsible_match2.rs:20:16\n    |\n LL |             Ok(val) => match val {\n    |                ^^^ replace this binding\n LL |                 Some(n) => foo(n),\n    |                 ^^^^^^^ with this pattern\n \n error: unnecessary nested match\n-  --> $DIR/collapsible_match2.rs:29:29\n+  --> $DIR/collapsible_match2.rs:34:29\n    |\n LL |                       $pat => match $e {\n    |  _____________________________^\n@@ -49,7 +49,7 @@ LL |           mac!(res_opt => Ok(val), val => Some(n), foo(n));\n    |           ------------------------------------------------- in this macro invocation\n    |\n help: the outer pattern can be modified to include the inner pattern\n-  --> $DIR/collapsible_match2.rs:41:28\n+  --> $DIR/collapsible_match2.rs:46:28\n    |\n LL |         mac!(res_opt => Ok(val), val => Some(n), foo(n));\n    |                            ^^^          ^^^^^^^ with this pattern\n@@ -58,7 +58,7 @@ LL |         mac!(res_opt => Ok(val), val => Some(n), foo(n));\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: unnecessary nested match\n-  --> $DIR/collapsible_match2.rs:46:20\n+  --> $DIR/collapsible_match2.rs:51:20\n    |\n LL |           Some(s) => match *s {\n    |  ____________________^\n@@ -68,15 +68,15 @@ LL | |         },\n    | |_________^\n    |\n help: the outer pattern can be modified to include the inner pattern\n-  --> $DIR/collapsible_match2.rs:46:14\n+  --> $DIR/collapsible_match2.rs:51:14\n    |\n LL |         Some(s) => match *s {\n    |              ^ replace this binding\n LL |             [n] => foo(n),\n    |             ^^^ with this pattern\n \n error: unnecessary nested match\n-  --> $DIR/collapsible_match2.rs:55:24\n+  --> $DIR/collapsible_match2.rs:60:24\n    |\n LL |           Some(ref s) => match &*s {\n    |  ________________________^\n@@ -86,7 +86,7 @@ LL | |         },\n    | |_________^\n    |\n help: the outer pattern can be modified to include the inner pattern\n-  --> $DIR/collapsible_match2.rs:55:14\n+  --> $DIR/collapsible_match2.rs:60:14\n    |\n LL |         Some(ref s) => match &*s {\n    |              ^^^^^ replace this binding"}, {"sha": "60bdbc4f124e736dbacd33e0682ce3a896e17d72", "filename": "tests/ui/crashes/ice-7012.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fcrashes%2Fice-7012.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fcrashes%2Fice-7012.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-7012.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -0,0 +1,17 @@\n+#![allow(clippy::all)]\n+\n+enum _MyOption {\n+    None,\n+    Some(()),\n+}\n+\n+impl _MyOption {\n+    fn _foo(&self) {\n+        match self {\n+            &Self::Some(_) => {},\n+            _ => {},\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "43468872db0b45f69c61799afc1c6b75521e7100", "filename": "tests/ui/default_numeric_fallback.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -3,6 +3,7 @@\n #![allow(clippy::never_loop)]\n #![allow(clippy::no_effect)]\n #![allow(clippy::unnecessary_operation)]\n+#![allow(clippy::branches_sharing_code)]\n \n mod basic_expr {\n     fn test() {"}, {"sha": "d1c4c8203dd832a07875d668dd9d7178928f64ca", "filename": "tests/ui/default_numeric_fallback.stderr", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fdefault_numeric_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fdefault_numeric_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,145 +1,145 @@\n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:10:17\n+  --> $DIR/default_numeric_fallback.rs:11:17\n    |\n LL |         let x = 22;\n    |                 ^^ help: consider adding suffix: `22_i32`\n    |\n    = note: `-D clippy::default-numeric-fallback` implied by `-D warnings`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:11:18\n+  --> $DIR/default_numeric_fallback.rs:12:18\n    |\n LL |         let x = [1, 2, 3];\n    |                  ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:11:21\n+  --> $DIR/default_numeric_fallback.rs:12:21\n    |\n LL |         let x = [1, 2, 3];\n    |                     ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:11:24\n+  --> $DIR/default_numeric_fallback.rs:12:24\n    |\n LL |         let x = [1, 2, 3];\n    |                        ^ help: consider adding suffix: `3_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:12:28\n+  --> $DIR/default_numeric_fallback.rs:13:28\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                            ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:12:31\n+  --> $DIR/default_numeric_fallback.rs:13:31\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                               ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:12:44\n+  --> $DIR/default_numeric_fallback.rs:13:44\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                                            ^ help: consider adding suffix: `3_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:12:47\n+  --> $DIR/default_numeric_fallback.rs:13:47\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                                               ^ help: consider adding suffix: `4_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:13:23\n+  --> $DIR/default_numeric_fallback.rs:14:23\n    |\n LL |         let x = match 1 {\n    |                       ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:14:13\n+  --> $DIR/default_numeric_fallback.rs:15:13\n    |\n LL |             1 => 1,\n    |             ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:14:18\n+  --> $DIR/default_numeric_fallback.rs:15:18\n    |\n LL |             1 => 1,\n    |                  ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:15:18\n+  --> $DIR/default_numeric_fallback.rs:16:18\n    |\n LL |             _ => 2,\n    |                  ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:19:17\n+  --> $DIR/default_numeric_fallback.rs:20:17\n    |\n LL |         let x = 0.12;\n    |                 ^^^^ help: consider adding suffix: `0.12_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:37:21\n+  --> $DIR/default_numeric_fallback.rs:38:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:45:21\n+  --> $DIR/default_numeric_fallback.rs:46:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:51:21\n+  --> $DIR/default_numeric_fallback.rs:52:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:63:9\n+  --> $DIR/default_numeric_fallback.rs:64:9\n    |\n LL |         1\n    |         ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:69:27\n+  --> $DIR/default_numeric_fallback.rs:70:27\n    |\n LL |         let f = || -> _ { 1 };\n    |                           ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:73:29\n+  --> $DIR/default_numeric_fallback.rs:74:29\n    |\n LL |         let f = || -> i32 { 1 };\n    |                             ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:87:21\n+  --> $DIR/default_numeric_fallback.rs:88:21\n    |\n LL |         generic_arg(1);\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:90:32\n+  --> $DIR/default_numeric_fallback.rs:91:32\n    |\n LL |         let x: _ = generic_arg(1);\n    |                                ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:108:28\n+  --> $DIR/default_numeric_fallback.rs:109:28\n    |\n LL |         GenericStruct { x: 1 };\n    |                            ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:111:36\n+  --> $DIR/default_numeric_fallback.rs:112:36\n    |\n LL |         let _ = GenericStruct { x: 1 };\n    |                                    ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:131:23\n+  --> $DIR/default_numeric_fallback.rs:132:23\n    |\n LL |         s.generic_arg(1);\n    |                       ^ help: consider adding suffix: `1_i32`"}, {"sha": "4e46bf1399173f40379eed86ad5225192a538b28", "filename": "tests/ui/derive.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -35,7 +35,6 @@ impl<'a> Clone for Lt<'a> {\n     }\n }\n \n-// Ok, `Clone` cannot be derived because of the big array\n #[derive(Copy)]\n struct BigArray {\n     a: [u8; 65],\n@@ -47,7 +46,6 @@ impl Clone for BigArray {\n     }\n }\n \n-// Ok, function pointers are not always Clone\n #[derive(Copy)]\n struct FnPtr {\n     a: fn() -> !,\n@@ -59,7 +57,7 @@ impl Clone for FnPtr {\n     }\n }\n \n-// Ok, generics\n+// Ok, Clone trait impl doesn't have constrained generics.\n #[derive(Copy)]\n struct Generic<T> {\n     a: T,\n@@ -71,4 +69,21 @@ impl<T> Clone for Generic<T> {\n     }\n }\n \n+#[derive(Copy)]\n+struct Generic2<T>(T);\n+impl<T: Clone> Clone for Generic2<T> {\n+    fn clone(&self) -> Self {\n+        Self(self.0.clone())\n+    }\n+}\n+\n+// Ok, Clone trait impl doesn't have constrained generics.\n+#[derive(Copy)]\n+struct GenericRef<'a, T, U>(T, &'a U);\n+impl<T: Clone, U> Clone for GenericRef<'_, T, U> {\n+    fn clone(&self) -> Self {\n+        Self(self.0.clone(), self.1)\n+    }\n+}\n+\n fn main() {}"}, {"sha": "82a70ceecc368710f3e0e6411aeb08be51316520", "filename": "tests/ui/derive.stderr", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fderive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fderive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -40,7 +40,7 @@ LL | | }\n    | |_^\n \n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:44:1\n+  --> $DIR/derive.rs:43:1\n    |\n LL | / impl Clone for BigArray {\n LL | |     fn clone(&self) -> Self {\n@@ -50,7 +50,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:44:1\n+  --> $DIR/derive.rs:43:1\n    |\n LL | / impl Clone for BigArray {\n LL | |     fn clone(&self) -> Self {\n@@ -60,7 +60,7 @@ LL | | }\n    | |_^\n \n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:56:1\n+  --> $DIR/derive.rs:54:1\n    |\n LL | / impl Clone for FnPtr {\n LL | |     fn clone(&self) -> Self {\n@@ -70,7 +70,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:56:1\n+  --> $DIR/derive.rs:54:1\n    |\n LL | / impl Clone for FnPtr {\n LL | |     fn clone(&self) -> Self {\n@@ -79,5 +79,25 @@ LL | |     }\n LL | | }\n    | |_^\n \n-error: aborting due to 4 previous errors\n+error: you are implementing `Clone` explicitly on a `Copy` type\n+  --> $DIR/derive.rs:74:1\n+   |\n+LL | / impl<T: Clone> Clone for Generic2<T> {\n+LL | |     fn clone(&self) -> Self {\n+LL | |         Self(self.0.clone())\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: consider deriving `Clone` or removing `Copy`\n+  --> $DIR/derive.rs:74:1\n+   |\n+LL | / impl<T: Clone> Clone for Generic2<T> {\n+LL | |     fn clone(&self) -> Self {\n+LL | |         Self(self.0.clone())\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 5 previous errors\n "}, {"sha": "c946a047f1b0a88c56ef98d57428b1d8cd98b20e", "filename": "tests/ui/doc.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,8 +1,8 @@\n //! This file tests for the `DOC_MARKDOWN` lint.\n \n-#![allow(dead_code)]\n+#![allow(dead_code, incomplete_features)]\n #![warn(clippy::doc_markdown)]\n-#![feature(custom_inner_attributes)]\n+#![feature(custom_inner_attributes, const_generics, const_evaluatable_checked, const_option)]\n #![rustfmt::skip]\n \n /// The foo_bar function does _nothing_. See also foo::bar. (note the dot there)\n@@ -202,3 +202,20 @@ fn issue_2343() {}\n /// This should not cause an ICE:\n /// __|_ _|__||_|\n fn pulldown_cmark_crash() {}\n+\n+// issue #7033 - const_evaluatable_checked ICE\n+struct S<T, const N: usize>\n+where [(); N.checked_next_power_of_two().unwrap()]: {\n+    arr: [T; N.checked_next_power_of_two().unwrap()],\n+    n: usize,\n+}\n+\n+impl<T: Copy + Default, const N: usize> S<T, N>\n+where [(); N.checked_next_power_of_two().unwrap()]: {\n+    fn new() -> Self {\n+        Self {\n+            arr: [T::default(); N.checked_next_power_of_two().unwrap()],\n+            n: 0,\n+        }\n+    }\n+}"}, {"sha": "13e2b6c7a2e765a5a3d7269504368b6bc3bf8db0", "filename": "tests/ui/escape_analysis.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fescape_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fescape_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fescape_analysis.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -101,7 +101,7 @@ fn warn_match() {\n     let x = box A;\n     match &x {\n         // not moved\n-        ref y => (),\n+        y => (),\n     }\n }\n \n@@ -111,7 +111,7 @@ fn nowarn_large_array() {\n     let x = box [1; 10000];\n     match &x {\n         // not moved\n-        ref y => (),\n+        y => (),\n     }\n }\n "}, {"sha": "5b487bb8fcf790cae0bb771ae964327b04036cc5", "filename": "tests/ui/floating_point_log.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Ffloating_point_log.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Ffloating_point_log.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_log.fixed?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -27,7 +27,7 @@ fn check_ln1p() {\n     let _ = (x / 2.0).ln_1p();\n     let _ = x.powi(3).ln_1p();\n     let _ = (x.powi(3) / 2.0).ln_1p();\n-    let _ = ((std::f32::consts::E - 1.0)).ln_1p();\n+    let _ = (std::f32::consts::E - 1.0).ln_1p();\n     let _ = x.ln_1p();\n     let _ = x.powi(3).ln_1p();\n     let _ = (x + 2.0).ln_1p();"}, {"sha": "96e5a15444170f4fd2d9453ac15774af596f86d7", "filename": "tests/ui/floating_point_log.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Ffloating_point_log.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Ffloating_point_log.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_log.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -90,7 +90,7 @@ error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:30:13\n    |\n LL |     let _ = (1.0 + (std::f32::consts::E - 1.0)).ln();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `((std::f32::consts::E - 1.0)).ln_1p()`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(std::f32::consts::E - 1.0).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:31:13"}, {"sha": "da5c16f8d01a8a582c9537062fb6cbde9511a881", "filename": "tests/ui/from_str_radix_10.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Ffrom_str_radix_10.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Ffrom_str_radix_10.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_str_radix_10.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -28,7 +28,7 @@ error: this call to `from_str_radix` can be replaced with a call to `str::parse`\n   --> $DIR/from_str_radix_10.rs:32:5\n    |\n LL |     u16::from_str_radix(&(\"10\".to_owned() + \"5\"), 10)?;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `((\"10\".to_owned() + \"5\")).parse::<u16>()`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(\"10\".to_owned() + \"5\").parse::<u16>()`\n \n error: this call to `from_str_radix` can be replaced with a call to `str::parse`\n   --> $DIR/from_str_radix_10.rs:33:5"}, {"sha": "ef9567455008bfcfdf8bb4885d092dbf76f140c5", "filename": "tests/ui/if_same_then_else.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fif_same_then_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fif_same_then_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -5,7 +5,8 @@\n     clippy::never_loop,\n     clippy::no_effect,\n     clippy::unused_unit,\n-    clippy::zero_divided_by_zero\n+    clippy::zero_divided_by_zero,\n+    clippy::branches_sharing_code\n )]\n \n struct Foo {"}, {"sha": "2f38052fc209e957e76bb06f97000d40bb45c15f", "filename": "tests/ui/if_same_then_else.stderr", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fif_same_then_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fif_same_then_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,111 +1,111 @@\n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else.rs:28:12\n+  --> $DIR/if_same_then_else.rs:21:13\n    |\n-LL |       } else {\n-   |  ____________^\n-LL | |         //~ ERROR same body as `if` block\n+LL |       if true {\n+   |  _____________^\n LL | |         Foo { bar: 42 };\n LL | |         0..10;\n+LL | |         ..;\n ...  |\n LL | |         foo();\n-LL | |     }\n+LL | |     } else {\n    | |_____^\n    |\n    = note: `-D clippy::if-same-then-else` implied by `-D warnings`\n note: same as this\n-  --> $DIR/if_same_then_else.rs:20:13\n+  --> $DIR/if_same_then_else.rs:29:12\n    |\n-LL |       if true {\n-   |  _____________^\n+LL |       } else {\n+   |  ____________^\n+LL | |         //~ ERROR same body as `if` block\n LL | |         Foo { bar: 42 };\n LL | |         0..10;\n-LL | |         ..;\n ...  |\n LL | |         foo();\n-LL | |     } else {\n+LL | |     }\n    | |_____^\n \n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else.rs:66:12\n-   |\n-LL |       } else {\n-   |  ____________^\n-LL | |         //~ ERROR same body as `if` block\n-LL | |         0.0\n-LL | |     };\n-   | |_____^\n-   |\n-note: same as this\n-  --> $DIR/if_same_then_else.rs:64:21\n+  --> $DIR/if_same_then_else.rs:65:21\n    |\n LL |       let _ = if true {\n    |  _____________________^\n LL | |         0.0\n LL | |     } else {\n    | |_____^\n-\n-error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else.rs:73:12\n+   |\n+note: same as this\n+  --> $DIR/if_same_then_else.rs:67:12\n    |\n LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n-LL | |         -0.0\n+LL | |         0.0\n LL | |     };\n    | |_____^\n-   |\n-note: same as this\n-  --> $DIR/if_same_then_else.rs:71:21\n+\n+error: this `if` has identical blocks\n+  --> $DIR/if_same_then_else.rs:72:21\n    |\n LL |       let _ = if true {\n    |  _____________________^\n LL | |         -0.0\n LL | |     } else {\n    | |_____^\n-\n-error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else.rs:89:12\n+   |\n+note: same as this\n+  --> $DIR/if_same_then_else.rs:74:12\n    |\n LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n-LL | |         42\n+LL | |         -0.0\n LL | |     };\n    | |_____^\n-   |\n-note: same as this\n-  --> $DIR/if_same_then_else.rs:87:21\n+\n+error: this `if` has identical blocks\n+  --> $DIR/if_same_then_else.rs:88:21\n    |\n LL |       let _ = if true {\n    |  _____________________^\n LL | |         42\n LL | |     } else {\n    | |_____^\n-\n-error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else.rs:101:12\n+   |\n+note: same as this\n+  --> $DIR/if_same_then_else.rs:90:12\n    |\n LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n+LL | |         42\n+LL | |     };\n+   | |_____^\n+\n+error: this `if` has identical blocks\n+  --> $DIR/if_same_then_else.rs:95:13\n+   |\n+LL |       if true {\n+   |  _____________^\n LL | |         let bar = if true { 42 } else { 43 };\n LL | |\n+LL | |         while foo() {\n ...  |\n LL | |         bar + 1;\n-LL | |     }\n+LL | |     } else {\n    | |_____^\n    |\n note: same as this\n-  --> $DIR/if_same_then_else.rs:94:13\n+  --> $DIR/if_same_then_else.rs:102:12\n    |\n-LL |       if true {\n-   |  _____________^\n+LL |       } else {\n+   |  ____________^\n+LL | |         //~ ERROR same body as `if` block\n LL | |         let bar = if true { 42 } else { 43 };\n LL | |\n-LL | |         while foo() {\n ...  |\n LL | |         bar + 1;\n-LL | |     } else {\n+LL | |     }\n    | |_____^\n \n error: aborting due to 5 previous errors"}, {"sha": "e4dc5b647dfd2eb0d3a42be5d5e7c262eaf41228", "filename": "tests/ui/if_same_then_else2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fif_same_then_else2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fif_same_then_else2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else2.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -5,7 +5,8 @@\n     clippy::collapsible_if,\n     clippy::ifs_same_cond,\n     clippy::needless_return,\n-    clippy::single_element_loop\n+    clippy::single_element_loop,\n+    clippy::branches_sharing_code\n )]\n \n fn if_same_then_else2() -> Result<&'static str, ()> {"}, {"sha": "6524be0af8517ff4925a7723b8554ffd30e7aa93", "filename": "tests/ui/if_same_then_else2.stderr", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fif_same_then_else2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fif_same_then_else2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else2.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,19 +1,5 @@\n error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:21:12\n-   |\n-LL |       } else {\n-   |  ____________^\n-LL | |         //~ ERROR same body as `if` block\n-LL | |         for _ in &[42] {\n-LL | |             let bar: &Option<_> = &Some::<u8>(42);\n-...  |\n-LL | |         }\n-LL | |     }\n-   | |_____^\n-   |\n-   = note: `-D clippy::if-same-then-else` implied by `-D warnings`\n-note: same as this\n-  --> $DIR/if_same_then_else2.rs:12:13\n+  --> $DIR/if_same_then_else2.rs:13:13\n    |\n LL |       if true {\n    |  _____________^\n@@ -24,102 +10,116 @@ LL | |             if foo.is_some() {\n LL | |         }\n LL | |     } else {\n    | |_____^\n-\n-error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:35:12\n+   |\n+   = note: `-D clippy::if-same-then-else` implied by `-D warnings`\n+note: same as this\n+  --> $DIR/if_same_then_else2.rs:22:12\n    |\n LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n-LL | |         if let Some(a) = Some(42) {}\n+LL | |         for _ in &[42] {\n+LL | |             let bar: &Option<_> = &Some::<u8>(42);\n+...  |\n+LL | |         }\n LL | |     }\n    | |_____^\n-   |\n-note: same as this\n-  --> $DIR/if_same_then_else2.rs:33:13\n+\n+error: this `if` has identical blocks\n+  --> $DIR/if_same_then_else2.rs:34:13\n    |\n LL |       if true {\n    |  _____________^\n LL | |         if let Some(a) = Some(42) {}\n LL | |     } else {\n    | |_____^\n-\n-error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:42:12\n+   |\n+note: same as this\n+  --> $DIR/if_same_then_else2.rs:36:12\n    |\n LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n-LL | |         if let (1, .., 3) = (1, 2, 3) {}\n+LL | |         if let Some(a) = Some(42) {}\n LL | |     }\n    | |_____^\n-   |\n-note: same as this\n-  --> $DIR/if_same_then_else2.rs:40:13\n+\n+error: this `if` has identical blocks\n+  --> $DIR/if_same_then_else2.rs:41:13\n    |\n LL |       if true {\n    |  _____________^\n LL | |         if let (1, .., 3) = (1, 2, 3) {}\n LL | |     } else {\n    | |_____^\n-\n-error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:92:12\n+   |\n+note: same as this\n+  --> $DIR/if_same_then_else2.rs:43:12\n    |\n LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n-LL | |         f32::NAN\n-LL | |     };\n+LL | |         if let (1, .., 3) = (1, 2, 3) {}\n+LL | |     }\n    | |_____^\n-   |\n-note: same as this\n-  --> $DIR/if_same_then_else2.rs:90:21\n+\n+error: this `if` has identical blocks\n+  --> $DIR/if_same_then_else2.rs:91:21\n    |\n LL |       let _ = if true {\n    |  _____________________^\n LL | |         f32::NAN\n LL | |     } else {\n    | |_____^\n-\n-error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:99:12\n+   |\n+note: same as this\n+  --> $DIR/if_same_then_else2.rs:93:12\n    |\n LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n-LL | |         Ok(\"foo\")?;\n-LL | |     }\n+LL | |         f32::NAN\n+LL | |     };\n    | |_____^\n-   |\n-note: same as this\n-  --> $DIR/if_same_then_else2.rs:97:13\n+\n+error: this `if` has identical blocks\n+  --> $DIR/if_same_then_else2.rs:98:13\n    |\n LL |       if true {\n    |  _____________^\n LL | |         Ok(\"foo\")?;\n LL | |     } else {\n    | |_____^\n-\n-error: this `if` has identical blocks\n-  --> $DIR/if_same_then_else2.rs:124:12\n+   |\n+note: same as this\n+  --> $DIR/if_same_then_else2.rs:100:12\n    |\n LL |       } else {\n    |  ____________^\n-LL | |         let foo = \"\";\n-LL | |         return Ok(&foo[0..]);\n+LL | |         //~ ERROR same body as `if` block\n+LL | |         Ok(\"foo\")?;\n LL | |     }\n    | |_____^\n-   |\n-note: same as this\n-  --> $DIR/if_same_then_else2.rs:121:20\n+\n+error: this `if` has identical blocks\n+  --> $DIR/if_same_then_else2.rs:122:20\n    |\n LL |       } else if true {\n    |  ____________________^\n LL | |         let foo = \"\";\n LL | |         return Ok(&foo[0..]);\n LL | |     } else {\n    | |_____^\n+   |\n+note: same as this\n+  --> $DIR/if_same_then_else2.rs:125:12\n+   |\n+LL |       } else {\n+   |  ____________^\n+LL | |         let foo = \"\";\n+LL | |         return Ok(&foo[0..]);\n+LL | |     }\n+   | |_____^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "cef71cf79d79721814cce022ec3ef1a736b31439", "filename": "tests/ui/implicit_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_clone.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -66,7 +66,7 @@ fn main() {\n     let _ = vec.to_vec();\n \n     let vec_ref = &vec;\n-    let _ = return_owned_from_slice(&vec_ref);\n+    let _ = return_owned_from_slice(vec_ref);\n     let _ = vec_ref.to_owned();\n     let _ = vec_ref.to_vec();\n "}, {"sha": "b77f17944d89a35a28a21bcf6d100750d98e8da4", "filename": "tests/ui/into_iter_on_ref.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Finto_iter_on_ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Finto_iter_on_ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finto_iter_on_ref.fixed?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(clippy::useless_vec)]\n+#![allow(clippy::useless_vec, clippy::needless_borrow)]\n #![warn(clippy::into_iter_on_ref)]\n \n struct X;"}, {"sha": "3854bb05af8fbfc463d73a5bf47bbb11d331c5e7", "filename": "tests/ui/into_iter_on_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Finto_iter_on_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Finto_iter_on_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finto_iter_on_ref.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(clippy::useless_vec)]\n+#![allow(clippy::useless_vec, clippy::needless_borrow)]\n #![warn(clippy::into_iter_on_ref)]\n \n struct X;"}, {"sha": "b9d66347c27487b9857e99e2be575796273ac6b7", "filename": "tests/ui/len_without_is_empty.rs", "status": "modified", "additions": 98, "deletions": 1, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Flen_without_is_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Flen_without_is_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_without_is_empty.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,3 +1,5 @@\n+// edition:2018\n+\n #![warn(clippy::len_without_is_empty)]\n #![allow(dead_code, unused)]\n \n@@ -172,9 +174,9 @@ pub trait DependsOnFoo: Foo {\n     fn len(&mut self) -> usize;\n }\n \n+// issue #1562\n pub struct MultipleImpls;\n \n-// issue #1562\n impl MultipleImpls {\n     pub fn len(&self) -> usize {\n         1\n@@ -187,4 +189,99 @@ impl MultipleImpls {\n     }\n }\n \n+// issue #6958\n+pub struct OptionalLen;\n+\n+impl OptionalLen {\n+    pub fn len(&self) -> Option<usize> {\n+        Some(0)\n+    }\n+\n+    pub fn is_empty(&self) -> Option<bool> {\n+        Some(true)\n+    }\n+}\n+\n+pub struct OptionalLen2;\n+impl OptionalLen2 {\n+    pub fn len(&self) -> Option<usize> {\n+        Some(0)\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        true\n+    }\n+}\n+\n+pub struct OptionalLen3;\n+impl OptionalLen3 {\n+    pub fn len(&self) -> usize {\n+        0\n+    }\n+\n+    // should lint, len is not an option\n+    pub fn is_empty(&self) -> Option<bool> {\n+        None\n+    }\n+}\n+\n+pub struct ResultLen;\n+impl ResultLen {\n+    pub fn len(&self) -> Result<usize, ()> {\n+        Ok(0)\n+    }\n+\n+    // Differing result types\n+    pub fn is_empty(&self) -> Option<bool> {\n+        Some(true)\n+    }\n+}\n+\n+pub struct ResultLen2;\n+impl ResultLen2 {\n+    pub fn len(&self) -> Result<usize, ()> {\n+        Ok(0)\n+    }\n+\n+    pub fn is_empty(&self) -> Result<bool, ()> {\n+        Ok(true)\n+    }\n+}\n+\n+pub struct ResultLen3;\n+impl ResultLen3 {\n+    pub fn len(&self) -> Result<usize, ()> {\n+        Ok(0)\n+    }\n+\n+    // Non-fallible result is ok.\n+    pub fn is_empty(&self) -> bool {\n+        true\n+    }\n+}\n+\n+pub struct OddLenSig;\n+impl OddLenSig {\n+    // don't lint\n+    pub fn len(&self) -> bool {\n+        true\n+    }\n+}\n+\n+// issue #6958\n+pub struct AsyncLen;\n+impl AsyncLen {\n+    async fn async_task(&self) -> bool {\n+        true\n+    }\n+\n+    pub async fn len(&self) -> usize {\n+        if self.async_task().await { 0 } else { 1 }\n+    }\n+\n+    pub async fn is_empty(&self) -> bool {\n+        self.len().await == 0\n+    }\n+}\n+\n fn main() {}"}, {"sha": "3282709bcd6717f664ef135c6132b38e9ab3a389", "filename": "tests/ui/len_without_is_empty.stderr", "status": "modified", "additions": 69, "deletions": 10, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Flen_without_is_empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Flen_without_is_empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_without_is_empty.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,64 +1,123 @@\n error: struct `PubOne` has a public `len` method, but no `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:7:5\n+  --> $DIR/len_without_is_empty.rs:9:5\n    |\n LL |     pub fn len(&self) -> isize {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::len-without-is-empty` implied by `-D warnings`\n \n error: trait `PubTraitsToo` has a `len` method but no (possibly inherited) `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:55:1\n+  --> $DIR/len_without_is_empty.rs:57:1\n    |\n LL | / pub trait PubTraitsToo {\n LL | |     fn len(&self) -> isize;\n LL | | }\n    | |_^\n \n error: struct `HasIsEmpty` has a public `len` method, but a private `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:68:5\n+  --> $DIR/len_without_is_empty.rs:70:5\n    |\n LL |     pub fn len(&self) -> isize {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: `is_empty` defined here\n-  --> $DIR/len_without_is_empty.rs:72:5\n+  --> $DIR/len_without_is_empty.rs:74:5\n    |\n LL |     fn is_empty(&self) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: struct `HasWrongIsEmpty` has a public `len` method, but the `is_empty` method has an unexpected signature\n-  --> $DIR/len_without_is_empty.rs:80:5\n+  --> $DIR/len_without_is_empty.rs:82:5\n    |\n LL |     pub fn len(&self) -> isize {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: `is_empty` defined here\n-  --> $DIR/len_without_is_empty.rs:84:5\n+  --> $DIR/len_without_is_empty.rs:86:5\n    |\n LL |     pub fn is_empty(&self, x: u32) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: expected signature: `(&self) -> bool`\n \n error: struct `MismatchedSelf` has a public `len` method, but the `is_empty` method has an unexpected signature\n-  --> $DIR/len_without_is_empty.rs:92:5\n+  --> $DIR/len_without_is_empty.rs:94:5\n    |\n LL |     pub fn len(self) -> isize {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: `is_empty` defined here\n-  --> $DIR/len_without_is_empty.rs:96:5\n+  --> $DIR/len_without_is_empty.rs:98:5\n    |\n LL |     pub fn is_empty(&self) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: expected signature: `(self) -> bool`\n \n error: trait `DependsOnFoo` has a `len` method but no (possibly inherited) `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:171:1\n+  --> $DIR/len_without_is_empty.rs:173:1\n    |\n LL | / pub trait DependsOnFoo: Foo {\n LL | |     fn len(&mut self) -> usize;\n LL | | }\n    | |_^\n \n-error: aborting due to 6 previous errors\n+error: struct `OptionalLen3` has a public `len` method, but the `is_empty` method has an unexpected signature\n+  --> $DIR/len_without_is_empty.rs:218:5\n+   |\n+LL |     pub fn len(&self) -> usize {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `is_empty` defined here\n+  --> $DIR/len_without_is_empty.rs:223:5\n+   |\n+LL |     pub fn is_empty(&self) -> Option<bool> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected signature: `(&self) -> bool`\n+\n+error: struct `ResultLen` has a public `len` method, but the `is_empty` method has an unexpected signature\n+  --> $DIR/len_without_is_empty.rs:230:5\n+   |\n+LL |     pub fn len(&self) -> Result<usize, ()> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `is_empty` defined here\n+  --> $DIR/len_without_is_empty.rs:235:5\n+   |\n+LL |     pub fn is_empty(&self) -> Option<bool> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected signature: `(&self) -> bool` or `(&self) -> Result<bool>\n+\n+error: this returns a `Result<_, ()>`\n+  --> $DIR/len_without_is_empty.rs:230:5\n+   |\n+LL |     pub fn len(&self) -> Result<usize, ()> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::result-unit-err` implied by `-D warnings`\n+   = help: use a custom `Error` type instead\n+\n+error: this returns a `Result<_, ()>`\n+  --> $DIR/len_without_is_empty.rs:242:5\n+   |\n+LL |     pub fn len(&self) -> Result<usize, ()> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a custom `Error` type instead\n+\n+error: this returns a `Result<_, ()>`\n+  --> $DIR/len_without_is_empty.rs:246:5\n+   |\n+LL |     pub fn is_empty(&self) -> Result<bool, ()> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a custom `Error` type instead\n+\n+error: this returns a `Result<_, ()>`\n+  --> $DIR/len_without_is_empty.rs:253:5\n+   |\n+LL |     pub fn len(&self) -> Result<usize, ()> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a custom `Error` type instead\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "2d8f3c2f0e7aacf69c5d1b0808e4f38117cfa311", "filename": "tests/ui/let_if_seq.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_if_seq.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -2,7 +2,8 @@\n     unused_variables,\n     unused_assignments,\n     clippy::similar_names,\n-    clippy::blacklisted_name\n+    clippy::blacklisted_name,\n+    clippy::branches_sharing_code\n )]\n #![warn(clippy::useless_let_if_seq)]\n "}, {"sha": "9cf2e10a5ee56940e5a06d103a6bcd01323dbf05", "filename": "tests/ui/let_if_seq.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Flet_if_seq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Flet_if_seq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_if_seq.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,5 +1,5 @@\n error: `if _ { .. } else { .. }` is an expression\n-  --> $DIR/let_if_seq.rs:64:5\n+  --> $DIR/let_if_seq.rs:65:5\n    |\n LL | /     let mut foo = 0;\n LL | |     if f() {\n@@ -11,7 +11,7 @@ LL | |     }\n    = note: you might not need `mut` at all\n \n error: `if _ { .. } else { .. }` is an expression\n-  --> $DIR/let_if_seq.rs:69:5\n+  --> $DIR/let_if_seq.rs:70:5\n    |\n LL | /     let mut bar = 0;\n LL | |     if f() {\n@@ -25,7 +25,7 @@ LL | |     }\n    = note: you might not need `mut` at all\n \n error: `if _ { .. } else { .. }` is an expression\n-  --> $DIR/let_if_seq.rs:77:5\n+  --> $DIR/let_if_seq.rs:78:5\n    |\n LL | /     let quz;\n LL | |     if f() {\n@@ -36,7 +36,7 @@ LL | |     }\n    | |_____^ help: it is more idiomatic to write: `let quz = if f() { 42 } else { 0 };`\n \n error: `if _ { .. } else { .. }` is an expression\n-  --> $DIR/let_if_seq.rs:106:5\n+  --> $DIR/let_if_seq.rs:107:5\n    |\n LL | /     let mut baz = 0;\n LL | |     if f() {"}, {"sha": "2c3b25cd45e80552789e3f7c34de5cbf5fd7b43f", "filename": "tests/ui/linkedlist.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Flinkedlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Flinkedlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flinkedlist.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -5,6 +5,9 @@\n extern crate alloc;\n use alloc::collections::linked_list::LinkedList;\n \n+const C: LinkedList<i32> = LinkedList::new();\n+static S: LinkedList<i32> = LinkedList::new();\n+\n trait Foo {\n     type Baz = LinkedList<u8>;\n     fn foo(_: LinkedList<u8>);", "previous_filename": "tests/ui/dlist.rs"}, {"sha": "38ae71714d6624a638cdfc497e78c20667830e91", "filename": "tests/ui/linkedlist.stderr", "status": "renamed", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Flinkedlist.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Flinkedlist.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flinkedlist.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,51 +1,67 @@\n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/dlist.rs:9:16\n+  --> $DIR/linkedlist.rs:8:10\n+   |\n+LL | const C: LinkedList<i32> = LinkedList::new();\n+   |          ^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::linkedlist` implied by `-D warnings`\n+   = help: a `VecDeque` might work\n+\n+error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n+  --> $DIR/linkedlist.rs:9:11\n+   |\n+LL | static S: LinkedList<i32> = LinkedList::new();\n+   |           ^^^^^^^^^^^^^^^\n+   |\n+   = help: a `VecDeque` might work\n+\n+error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n+  --> $DIR/linkedlist.rs:12:16\n    |\n LL |     type Baz = LinkedList<u8>;\n    |                ^^^^^^^^^^^^^^\n    |\n-   = note: `-D clippy::linkedlist` implied by `-D warnings`\n    = help: a `VecDeque` might work\n \n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/dlist.rs:10:15\n+  --> $DIR/linkedlist.rs:13:15\n    |\n LL |     fn foo(_: LinkedList<u8>);\n    |               ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/dlist.rs:11:23\n+  --> $DIR/linkedlist.rs:14:23\n    |\n LL |     const BAR: Option<LinkedList<u8>>;\n    |                       ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/dlist.rs:22:15\n+  --> $DIR/linkedlist.rs:25:15\n    |\n LL |     fn foo(_: LinkedList<u8>) {}\n    |               ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/dlist.rs:25:39\n+  --> $DIR/linkedlist.rs:28:39\n    |\n LL | pub fn test(my_favourite_linked_list: LinkedList<u8>) {\n    |                                       ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n-  --> $DIR/dlist.rs:29:29\n+  --> $DIR/linkedlist.rs:32:29\n    |\n LL | pub fn test_ret() -> Option<LinkedList<u8>> {\n    |                             ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 8 previous errors\n ", "previous_filename": "tests/ui/dlist.stderr"}, {"sha": "ee0158457778673751f097c518d285560900de7a", "filename": "tests/ui/manual_map_option.fixed", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fmanual_map_option.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fmanual_map_option.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.fixed?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -7,6 +7,7 @@\n     clippy::map_identity,\n     clippy::unit_arg,\n     clippy::match_ref_pats,\n+    clippy::redundant_pattern_matching,\n     dead_code\n )]\n \n@@ -130,7 +131,19 @@ fn main() {\n     }\n \n     // #6847\n-    if Some(0).is_some() {\n+    if let Some(_) = Some(0) {\n         Some(0)\n     } else { Some(0).map(|x| x + 1) };\n+\n+    if true {\n+        Some(0)\n+    } else { Some(0).map(|x| x + 1) };\n+\n+    // #6967\n+    const fn f4() {\n+        match Some(0) {\n+            Some(x) => Some(x + 1),\n+            None => None,\n+        };\n+    }\n }"}, {"sha": "29509bddfd94d260a10dc919a24d01273d521577", "filename": "tests/ui/manual_map_option.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fmanual_map_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fmanual_map_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -7,6 +7,7 @@\n     clippy::map_identity,\n     clippy::unit_arg,\n     clippy::match_ref_pats,\n+    clippy::redundant_pattern_matching,\n     dead_code\n )]\n \n@@ -195,4 +196,20 @@ fn main() {\n     } else {\n         None\n     };\n+\n+    if true {\n+        Some(0)\n+    } else if let Some(x) = Some(0) {\n+        Some(x + 1)\n+    } else {\n+        None\n+    };\n+\n+    // #6967\n+    const fn f4() {\n+        match Some(0) {\n+            Some(x) => Some(x + 1),\n+            None => None,\n+        };\n+    }\n }"}, {"sha": "cdc2c0e62a9b9434838946240bbbc1f44e3a7f5c", "filename": "tests/ui/manual_map_option.stderr", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fmanual_map_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fmanual_map_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -1,5 +1,5 @@\n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:14:5\n+  --> $DIR/manual_map_option.rs:15:5\n    |\n LL | /     match Some(0) {\n LL | |         Some(_) => Some(2),\n@@ -10,7 +10,7 @@ LL | |     };\n    = note: `-D clippy::manual-map` implied by `-D warnings`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:19:5\n+  --> $DIR/manual_map_option.rs:20:5\n    |\n LL | /     match Some(0) {\n LL | |         Some(x) => Some(x + 1),\n@@ -19,7 +19,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(0).map(|x| x + 1)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:24:5\n+  --> $DIR/manual_map_option.rs:25:5\n    |\n LL | /     match Some(\"\") {\n LL | |         Some(x) => Some(x.is_empty()),\n@@ -28,7 +28,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(\"\").map(|x| x.is_empty())`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:29:5\n+  --> $DIR/manual_map_option.rs:30:5\n    |\n LL | /     if let Some(x) = Some(0) {\n LL | |         Some(!x)\n@@ -38,7 +38,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(0).map(|x| !x)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:36:5\n+  --> $DIR/manual_map_option.rs:37:5\n    |\n LL | /     match Some(0) {\n LL | |         Some(x) => { Some(std::convert::identity(x)) }\n@@ -47,7 +47,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(0).map(std::convert::identity)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:41:5\n+  --> $DIR/manual_map_option.rs:42:5\n    |\n LL | /     match Some(&String::new()) {\n LL | |         Some(x) => Some(str::len(x)),\n@@ -56,7 +56,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(&String::new()).map(|x| str::len(x))`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:51:5\n+  --> $DIR/manual_map_option.rs:52:5\n    |\n LL | /     match &Some([0, 1]) {\n LL | |         Some(x) => Some(x[0]),\n@@ -65,7 +65,7 @@ LL | |     };\n    | |_____^ help: try this: `Some([0, 1]).as_ref().map(|x| x[0])`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:56:5\n+  --> $DIR/manual_map_option.rs:57:5\n    |\n LL | /     match &Some(0) {\n LL | |         &Some(x) => Some(x * 2),\n@@ -74,7 +74,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(0).map(|x| x * 2)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:61:5\n+  --> $DIR/manual_map_option.rs:62:5\n    |\n LL | /     match Some(String::new()) {\n LL | |         Some(ref x) => Some(x.is_empty()),\n@@ -83,7 +83,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.is_empty())`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:66:5\n+  --> $DIR/manual_map_option.rs:67:5\n    |\n LL | /     match &&Some(String::new()) {\n LL | |         Some(x) => Some(x.len()),\n@@ -92,7 +92,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.len())`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:71:5\n+  --> $DIR/manual_map_option.rs:72:5\n    |\n LL | /     match &&Some(0) {\n LL | |         &&Some(x) => Some(x + x),\n@@ -101,7 +101,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(0).map(|x| x + x)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:84:9\n+  --> $DIR/manual_map_option.rs:85:9\n    |\n LL | /         match &mut Some(String::new()) {\n LL | |             Some(x) => Some(x.push_str(\"\")),\n@@ -110,7 +110,7 @@ LL | |         };\n    | |_________^ help: try this: `Some(String::new()).as_mut().map(|x| x.push_str(\"\"))`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:90:5\n+  --> $DIR/manual_map_option.rs:91:5\n    |\n LL | /     match &mut Some(String::new()) {\n LL | |         Some(ref x) => Some(x.len()),\n@@ -119,7 +119,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.len())`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:95:5\n+  --> $DIR/manual_map_option.rs:96:5\n    |\n LL | /     match &mut &Some(String::new()) {\n LL | |         Some(x) => Some(x.is_empty()),\n@@ -128,7 +128,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.is_empty())`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:100:5\n+  --> $DIR/manual_map_option.rs:101:5\n    |\n LL | /     match Some((0, 1, 2)) {\n LL | |         Some((x, y, z)) => Some(x + y + z),\n@@ -137,7 +137,7 @@ LL | |     };\n    | |_____^ help: try this: `Some((0, 1, 2)).map(|(x, y, z)| x + y + z)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:105:5\n+  --> $DIR/manual_map_option.rs:106:5\n    |\n LL | /     match Some([1, 2, 3]) {\n LL | |         Some([first, ..]) => Some(first),\n@@ -146,7 +146,7 @@ LL | |     };\n    | |_____^ help: try this: `Some([1, 2, 3]).map(|[first, ..]| first)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:110:5\n+  --> $DIR/manual_map_option.rs:111:5\n    |\n LL | /     match &Some((String::new(), \"test\")) {\n LL | |         Some((x, y)) => Some((y, x)),\n@@ -155,7 +155,7 @@ LL | |     };\n    | |_____^ help: try this: `Some((String::new(), \"test\")).as_ref().map(|(x, y)| (y, x))`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:168:5\n+  --> $DIR/manual_map_option.rs:169:5\n    |\n LL | /     match Some(0) {\n LL | |         Some(x) => Some(vec![x]),\n@@ -164,24 +164,27 @@ LL | |     };\n    | |_____^ help: try this: `Some(0).map(|x| vec![x])`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:173:5\n+  --> $DIR/manual_map_option.rs:174:5\n    |\n LL | /     match option_env!(\"\") {\n LL | |         Some(x) => Some(String::from(x)),\n LL | |         None => None,\n LL | |     };\n    | |_____^ help: try this: `option_env!(\"\").map(String::from)`\n \n-error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/manual_map_option.rs:191:12\n-   |\n-LL |     if let Some(_) = Some(0) {\n-   |     -------^^^^^^^---------- help: try this: `if Some(0).is_some()`\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:194:12\n    |\n-   = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n+LL |       } else if let Some(x) = Some(0) {\n+   |  ____________^\n+LL | |         Some(x + 1)\n+LL | |     } else {\n+LL | |         None\n+LL | |     };\n+   | |_____^ help: try this: `{ Some(0).map(|x| x + 1) }`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:193:12\n+  --> $DIR/manual_map_option.rs:202:12\n    |\n LL |       } else if let Some(x) = Some(0) {\n    |  ____________^"}, {"sha": "a2f2dfce168d5bd561450bc1a8eefda32e3b28da", "filename": "tests/ui/manual_memcpy/with_loop_counters.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416", "patch": "@@ -43,7 +43,7 @@ LL | /     for i in 3..(3 + src.len()) {\n LL | |         dst[i] = src[count];\n LL | |         count += 1;\n LL | |     }\n-   | |_____^ help: try replacing the loop by: `dst[3..((3 + src.len()))].clone_from_slice(&src[..((3 + src.len()) - 3)]);`\n+   | |_____^ help: try replacing the loop by: `dst[3..(3 + src.len())].clone_from_slice(&src[..((3 + src.len()) - 3)]);`\n \n error: it looks like you're manually copying between slices\n   --> $DIR/with_loop_counters.rs:35:5"}, {"sha": "67474e65cde4fb2f1fedfb64bcc5bedcc86684af", "filename": "tests/ui/match_ref_pats.stderr", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fmatch_ref_pats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fmatch_ref_pats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_ref_pats.stderr?ref=f6d1f368db9e726fde825dc2525cdec07673b416"}, {"sha": "31b743f7a18d73f53457e986d5572269a2746385", "filename": "tests/ui/match_wildcard_for_single_variants.fixed", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fmatch_wildcard_for_single_variants.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fmatch_wildcard_for_single_variants.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_wildcard_for_single_variants.fixed?ref=f6d1f368db9e726fde825dc2525cdec07673b416"}, {"sha": "d19e6ab7eb2e1ee8aa588f075550da007be81a22", "filename": "tests/ui/match_wildcard_for_single_variants.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fmatch_wildcard_for_single_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d1f368db9e726fde825dc2525cdec07673b416/tests%2Fui%2Fmatch_wildcard_for_single_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_wildcard_for_single_variants.rs?ref=f6d1f368db9e726fde825dc2525cdec07673b416"}]}