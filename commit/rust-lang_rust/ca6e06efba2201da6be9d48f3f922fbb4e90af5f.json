{"sha": "ca6e06efba2201da6be9d48f3f922fbb4e90af5f", "node_id": "C_kwDOAAsO6NoAKGNhNmUwNmVmYmEyMjAxZGE2YmU5ZDQ4ZjNmOTIyZmJiNGU5MGFmNWY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-15T02:14:38Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-28T05:36:29Z"}, "message": "make GATs print properly in traits", "tree": {"sha": "d589db449ecfe4427c7dee2f447ec7942f44140d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d589db449ecfe4427c7dee2f447ec7942f44140d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca6e06efba2201da6be9d48f3f922fbb4e90af5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca6e06efba2201da6be9d48f3f922fbb4e90af5f", "html_url": "https://github.com/rust-lang/rust/commit/ca6e06efba2201da6be9d48f3f922fbb4e90af5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a0c2c4e83c216811d96a4a5af9987431b75bd6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a0c2c4e83c216811d96a4a5af9987431b75bd6f", "html_url": "https://github.com/rust-lang/rust/commit/8a0c2c4e83c216811d96a4a5af9987431b75bd6f"}], "stats": {"total": 146, "additions": 98, "deletions": 48}, "files": [{"sha": "2864f69756b8f004e81297bf1e6cd31436ee7cf7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 47, "deletions": 23, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ca6e06efba2201da6be9d48f3f922fbb4e90af5f", "patch": "@@ -985,9 +985,10 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     TyMethodItem(t)\n                 }\n                 hir::TraitItemKind::Type(bounds, ref default) => {\n+                    let generics = self.generics.clean(cx);\n                     let bounds = bounds.iter().filter_map(|x| x.clean(cx)).collect();\n                     let default = default.map(|t| t.clean(cx));\n-                    AssocTypeItem(bounds, default)\n+                    AssocTypeItem(Box::new(generics), bounds, default)\n                 }\n             };\n             let what_rustc_thinks =\n@@ -1138,32 +1139,55 @@ impl Clean<Item> for ty::AssocItem {\n                 if let ty::TraitContainer(_) = self.container {\n                     let bounds = tcx.explicit_item_bounds(self.def_id);\n                     let predicates = ty::GenericPredicates { parent: None, predicates: bounds };\n-                    let generics = clean_ty_generics(cx, tcx.generics_of(self.def_id), predicates);\n+                    let mut generics =\n+                        clean_ty_generics(cx, tcx.generics_of(self.def_id), predicates);\n+                    // Filter out the bounds that are (likely?) directly attached to the associated type,\n+                    // as opposed to being located in the where clause.\n                     let mut bounds = generics\n                         .where_predicates\n-                        .iter()\n-                        .filter_map(|pred| {\n-                            let (name, self_type, trait_, bounds) = match *pred {\n-                                WherePredicate::BoundPredicate {\n-                                    ty: QPath { ref name, ref self_type, ref trait_, .. },\n-                                    ref bounds,\n-                                    ..\n-                                } => (name, self_type, trait_, bounds),\n-                                _ => return None,\n-                            };\n-                            if *name != my_name {\n-                                return None;\n-                            }\n-                            if trait_.def_id() != self.container.id() {\n-                                return None;\n+                        .drain_filter(|pred| match *pred {\n+                            WherePredicate::BoundPredicate {\n+                                ty: QPath { name, ref self_type, ref trait_, .. },\n+                                ..\n+                            } => {\n+                                if name != my_name {\n+                                    return false;\n+                                }\n+                                if trait_.def_id() != self.container.id() {\n+                                    return false;\n+                                }\n+                                match **self_type {\n+                                    Generic(ref s) if *s == kw::SelfUpper => {}\n+                                    _ => return false,\n+                                }\n+                                match &assoc.args {\n+                                    GenericArgs::AngleBracketed { args, bindings } => {\n+                                        if !bindings.is_empty()\n+                                            || generics\n+                                                .params\n+                                                .iter()\n+                                                .zip(args)\n+                                                .any(|(param, arg)| !param_eq_arg(param, arg))\n+                                        {\n+                                            return false;\n+                                        }\n+                                    }\n+                                    GenericArgs::Parenthesized { .. } => {\n+                                        // The only time this happens is if we're inside the rustdoc for Fn(),\n+                                        // which only has one associated type, which is not a GAT, so whatever.\n+                                    }\n+                                }\n+                                true\n                             }\n-                            match **self_type {\n-                                Generic(ref s) if *s == kw::SelfUpper => {}\n-                                _ => return None,\n+                            _ => false,\n+                        })\n+                        .flat_map(|pred| {\n+                            if let WherePredicate::BoundPredicate { bounds, .. } = pred {\n+                                bounds\n+                            } else {\n+                                unreachable!()\n                             }\n-                            Some(bounds)\n                         })\n-                        .flat_map(|i| i.iter().cloned())\n                         .collect::<Vec<_>>();\n                     // Our Sized/?Sized bound didn't get handled when creating the generics\n                     // because we didn't actually get our whole set of bounds until just now\n@@ -1183,7 +1207,7 @@ impl Clean<Item> for ty::AssocItem {\n                         None\n                     };\n \n-                    AssocTypeItem(bounds, ty.map(|t| t.clean(cx)))\n+                    AssocTypeItem(Box::new(generics), bounds, ty.map(|t| t.clean(cx)))\n                 } else {\n                     // FIXME: when could this happen? Associated items in inherent impls?\n                     let type_ = tcx.type_of(self.def_id).clean(cx);"}, {"sha": "3f40385f9b9e606177db1a190a0685c112137741", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=ca6e06efba2201da6be9d48f3f922fbb4e90af5f", "patch": "@@ -683,7 +683,7 @@ crate enum ItemKind {\n     ///\n     /// The bounds may be non-empty if there is a `where` clause.\n     /// The `Option<Type>` is the default concrete type (e.g. `trait Trait { type Target = usize; }`)\n-    AssocTypeItem(Vec<GenericBound>, Option<Type>),\n+    AssocTypeItem(Box<Generics>, Vec<GenericBound>, Option<Type>),\n     /// An item that has been stripped by a rustdoc pass\n     StrippedItem(Box<ItemKind>),\n     KeywordItem(Symbol),\n@@ -721,7 +721,7 @@ impl ItemKind {\n             | ProcMacroItem(_)\n             | PrimitiveItem(_)\n             | AssocConstItem(_, _)\n-            | AssocTypeItem(_, _)\n+            | AssocTypeItem(..)\n             | StrippedItem(_)\n             | KeywordItem(_) => [].iter(),\n         }"}, {"sha": "fbb8b572ea43025a54fba2e5a71debace19f275f", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=ca6e06efba2201da6be9d48f3f922fbb4e90af5f", "patch": "@@ -86,7 +86,7 @@ crate trait DocFolder: Sized {\n             | ProcMacroItem(_)\n             | PrimitiveItem(_)\n             | AssocConstItem(_, _)\n-            | AssocTypeItem(_, _)\n+            | AssocTypeItem(..)\n             | KeywordItem(_) => kind,\n         }\n     }"}, {"sha": "558dbb3b3965a5e6dd4b968e39c7e36f17cb65bd", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=ca6e06efba2201da6be9d48f3f922fbb4e90af5f", "patch": "@@ -773,22 +773,25 @@ fn assoc_const(\n fn assoc_type(\n     w: &mut Buffer,\n     it: &clean::Item,\n+    generics: &clean::Generics,\n     bounds: &[clean::GenericBound],\n     default: Option<&clean::Type>,\n     link: AssocItemLink<'_>,\n-    extra: &str,\n+    indent: usize,\n     cx: &Context<'_>,\n ) {\n     write!(\n         w,\n-        \"{}type <a href=\\\"{}\\\" class=\\\"associatedtype\\\">{}</a>\",\n-        extra,\n-        naive_assoc_href(it, link, cx),\n-        it.name.as_ref().unwrap()\n+        \"{indent}type <a href=\\\"{href}\\\" class=\\\"associatedtype\\\">{name}</a>{generics}\",\n+        indent = \" \".repeat(indent),\n+        href = naive_assoc_href(it, link, cx),\n+        name = it.name.as_ref().unwrap(),\n+        generics = generics.print(cx),\n     );\n     if !bounds.is_empty() {\n         write!(w, \": {}\", print_generic_bounds(bounds, cx))\n     }\n+    write!(w, \"{}\", print_where_clause(generics, cx, indent, false));\n     if let Some(default) = default {\n         write!(w, \" = {}\", default.print(cx))\n     }\n@@ -812,11 +815,8 @@ fn assoc_method(\n         AssocItemLink::GotoSource(did, provided_methods) => {\n             // We're creating a link from an impl-item to the corresponding\n             // trait-item and need to map the anchored type accordingly.\n-            let ty = if provided_methods.contains(name) {\n-                ItemType::Method\n-            } else {\n-                ItemType::TyMethod\n-            };\n+            let ty =\n+                if provided_methods.contains(name) { ItemType::Method } else { ItemType::TyMethod };\n \n             match (href(did.expect_def_id(), cx), ty) {\n                 (Ok(p), ty) => Some(format!(\"{}#{}.{}\", p.0, ty, name)),\n@@ -974,13 +974,14 @@ fn render_assoc_item(\n         clean::AssocConstItem(ref ty, _) => {\n             assoc_const(w, item, ty, link, if parent == ItemType::Trait { \"    \" } else { \"\" }, cx)\n         }\n-        clean::AssocTypeItem(ref bounds, ref default) => assoc_type(\n+        clean::AssocTypeItem(ref generics, ref bounds, ref default) => assoc_type(\n             w,\n             item,\n+            generics,\n             bounds,\n             default.as_ref(),\n             link,\n-            if parent == ItemType::Trait { \"    \" } else { \"\" },\n+            if parent == ItemType::Trait { 4 } else { 0 },\n             cx,\n         ),\n         _ => panic!(\"render_assoc_item called on non-associated-item\"),\n@@ -1284,7 +1285,16 @@ fn notable_traits_decl(decl: &clean::FnDecl, cx: &Context<'_>) -> String {\n                                 let empty_set = FxHashSet::default();\n                                 let src_link =\n                                     AssocItemLink::GotoSource(trait_did.into(), &empty_set);\n-                                assoc_type(&mut out, it, &[], Some(&tydef.type_), src_link, \"\", cx);\n+                                assoc_type(\n+                                    &mut out,\n+                                    it,\n+                                    &tydef.generics,\n+                                    &[],\n+                                    Some(&tydef.type_),\n+                                    src_link,\n+                                    0,\n+                                    cx,\n+                                );\n                                 out.push_str(\";</span>\");\n                             }\n                         }\n@@ -1463,10 +1473,11 @@ fn render_impl(\n                 assoc_type(\n                     w,\n                     item,\n-                    &Vec::new(),\n+                    &tydef.generics,\n+                    &[],\n                     Some(&tydef.type_),\n                     link.anchor(if trait_.is_some() { &source_id } else { &id }),\n-                    \"\",\n+                    0,\n                     cx,\n                 );\n                 w.write_str(\"</h4>\");\n@@ -1494,7 +1505,7 @@ fn render_impl(\n                 w.write_str(\"</h4>\");\n                 w.write_str(\"</section>\");\n             }\n-            clean::AssocTypeItem(ref bounds, ref default) => {\n+            clean::AssocTypeItem(ref generics, ref bounds, ref default) => {\n                 let source_id = format!(\"{}.{}\", item_type, name);\n                 let id = cx.derive_id(source_id.clone());\n                 write!(w, \"<section id=\\\"{}\\\" class=\\\"{}{}\\\">\", id, item_type, in_trait_class,);\n@@ -1503,10 +1514,11 @@ fn render_impl(\n                 assoc_type(\n                     w,\n                     item,\n+                    generics,\n                     bounds,\n                     default.as_ref(),\n                     link.anchor(if trait_.is_some() { &source_id } else { &id }),\n-                    \"\",\n+                    0,\n                     cx,\n                 );\n                 w.write_str(\"</h4>\");\n@@ -1727,7 +1739,16 @@ pub(crate) fn render_impl_summary(\n             for it in &i.inner_impl().items {\n                 if let clean::TypedefItem(ref tydef, _) = *it.kind {\n                     w.write_str(\"<span class=\\\"where fmt-newline\\\">  \");\n-                    assoc_type(w, it, &[], Some(&tydef.type_), AssocItemLink::Anchor(None), \"\", cx);\n+                    assoc_type(\n+                        w,\n+                        it,\n+                        &tydef.generics,\n+                        &[],\n+                        Some(&tydef.type_),\n+                        AssocItemLink::Anchor(None),\n+                        0,\n+                        cx,\n+                    );\n                     w.write_str(\";</span>\");\n                 }\n             }"}, {"sha": "da92e682fe85fa2bcd87ee44a68e51fa8d90e46d", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=ca6e06efba2201da6be9d48f3f922fbb4e90af5f", "patch": "@@ -222,8 +222,9 @@ fn from_clean_item(item: clean::Item, tcx: TyCtxt<'_>) -> ItemEnum {\n         AssocConstItem(ty, default) => {\n             ItemEnum::AssocConst { type_: ty.into_tcx(tcx), default: default.map(|c| c.expr(tcx)) }\n         }\n-        AssocTypeItem(g, t) => ItemEnum::AssocType {\n-            bounds: g.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n+        AssocTypeItem(g, b, t) => ItemEnum::AssocType {\n+            generics: (*g).into_tcx(tcx),\n+            bounds: b.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n             default: t.map(|x| x.into_tcx(tcx)),\n         },\n         // `convert_item` early returns `None` for striped items"}, {"sha": "3c2a08463d8edb58633e92cdb840b52a68929484", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=ca6e06efba2201da6be9d48f3f922fbb4e90af5f", "patch": "@@ -9,6 +9,7 @@\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n #![feature(box_syntax)]\n+#![feature(drain_filter)]\n #![feature(let_else)]\n #![feature(nll)]\n #![feature(test)]"}, {"sha": "6cffb52bb875f794929c7570a52703a98e8b1546", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=ca6e06efba2201da6be9d48f3f922fbb4e90af5f", "patch": "@@ -62,7 +62,7 @@ crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> boo\n             clean::StructFieldItem(_)\n                 | clean::VariantItem(_)\n                 | clean::AssocConstItem(_, _)\n-                | clean::AssocTypeItem(_, _)\n+                | clean::AssocTypeItem(..)\n                 | clean::TypedefItem(_, _)\n                 | clean::StaticItem(_)\n                 | clean::ConstantItem(_)"}, {"sha": "b16cab1c646f13f6d642d661a92be507f34b606f", "filename": "src/librustdoc/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Flibrustdoc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Flibrustdoc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit.rs?ref=ca6e06efba2201da6be9d48f3f922fbb4e90af5f", "patch": "@@ -41,7 +41,7 @@ crate trait DocVisitor: Sized {\n             | ProcMacroItem(_)\n             | PrimitiveItem(_)\n             | AssocConstItem(_, _)\n-            | AssocTypeItem(_, _)\n+            | AssocTypeItem(..)\n             | KeywordItem(_) => {}\n         }\n     }"}, {"sha": "dfaec6991a424c395d84036b763f9b4d19f32c5b", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca6e06efba2201da6be9d48f3f922fbb4e90af5f/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=ca6e06efba2201da6be9d48f3f922fbb4e90af5f", "patch": "@@ -233,6 +233,9 @@ pub enum ItemEnum {\n         default: Option<String>,\n     },\n     AssocType {\n+        /// generics and `where` clause\n+        generics: Generics,\n+        /// e.g. `: Sized`\n         bounds: Vec<GenericBound>,\n         /// e.g. `type X = usize;`\n         default: Option<Type>,"}]}