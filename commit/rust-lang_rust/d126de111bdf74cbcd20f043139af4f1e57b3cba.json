{"sha": "d126de111bdf74cbcd20f043139af4f1e57b3cba", "node_id": "C_kwDOAAsO6NoAKGQxMjZkZTExMWJkZjc0Y2JjZDIwZjA0MzEzOWFmNGYxZTU3YjNjYmE", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-06-01T21:44:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-01T21:44:27Z"}, "message": "Rollup merge of #97166 - nnethercote:move-conditions-out, r=estebank\n\nMove conditions out of recover/report functions.\n\n`Parser` has six recover/report functions that are passed a boolean, and\nnothing is done if the boolean has a particular value.\n\nThis PR moves the tests outside the functions. This has the following effects.\n- The number of lines of code goes down.\n- Some `use` items become shorter.\n- Avoids the strangeness whereby 11 out of 12 calls to\n  `maybe_recover_from_bad_qpath` pass `true` as the second argument.\n- Makes it clear at the call site that only one of\n  `maybe_recover_from_bad_type_plus` and `maybe_report_ambiguous_plus` will be\n  run.\n\nr? `@estebank`", "tree": {"sha": "c4898d93146c2adc40885e5185086030dd450160", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4898d93146c2adc40885e5185086030dd450160"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d126de111bdf74cbcd20f043139af4f1e57b3cba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJil927CRBK7hj4Ov3rIwAAkxAIAKcAgJRFPIAopzHkvOVcydn8\n7UkCHpbE94oKjyfZVXacPyNkv6w4qJZ3FPbCm/L2xuvZ+koENvW3Td2miJvZTCFi\nVOYTAbk1VHq12/ZCy3sI5QI6Ztg0r805PPSe6GzdmK5SlN9NQ8WPDqn1goptnYCE\nCOja544ObjzYdg5XxUjPUpJ2NfUSAneEsf7wQmycGOjyHXFw+uZEE+hT14xgT0sA\nAtBCw8IMGperzVkp4UxbyXpK0jh+StEdg/ou5QusFosi6MiSrlX7FUoLOpSVJ9tH\nWu8lyXZlQc3ADagvShkAvcv86Pw9hHoJwNNTKDUe/hMUB4d91edpRZ4K1gfBkQ0=\n=Wk45\n-----END PGP SIGNATURE-----\n", "payload": "tree c4898d93146c2adc40885e5185086030dd450160\nparent 9fc3fc3a0cf63b9be317f92b84dcaa9b20162279\nparent 7b6c5c76a5b4b1a7676f7792c92939c4a7e85f5b\nauthor Yuki Okushi <jtitor@2k36.org> 1654119867 +0900\ncommitter GitHub <noreply@github.com> 1654119867 +0900\n\nRollup merge of #97166 - nnethercote:move-conditions-out, r=estebank\n\nMove conditions out of recover/report functions.\n\n`Parser` has six recover/report functions that are passed a boolean, and\nnothing is done if the boolean has a particular value.\n\nThis PR moves the tests outside the functions. This has the following effects.\n- The number of lines of code goes down.\n- Some `use` items become shorter.\n- Avoids the strangeness whereby 11 out of 12 calls to\n  `maybe_recover_from_bad_qpath` pass `true` as the second argument.\n- Makes it clear at the call site that only one of\n  `maybe_recover_from_bad_type_plus` and `maybe_report_ambiguous_plus` will be\n  run.\n\nr? `@estebank`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d126de111bdf74cbcd20f043139af4f1e57b3cba", "html_url": "https://github.com/rust-lang/rust/commit/d126de111bdf74cbcd20f043139af4f1e57b3cba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d126de111bdf74cbcd20f043139af4f1e57b3cba/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fc3fc3a0cf63b9be317f92b84dcaa9b20162279", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fc3fc3a0cf63b9be317f92b84dcaa9b20162279", "html_url": "https://github.com/rust-lang/rust/commit/9fc3fc3a0cf63b9be317f92b84dcaa9b20162279"}, {"sha": "7b6c5c76a5b4b1a7676f7792c92939c4a7e85f5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b6c5c76a5b4b1a7676f7792c92939c4a7e85f5b", "html_url": "https://github.com/rust-lang/rust/commit/7b6c5c76a5b4b1a7676f7792c92939c4a7e85f5b"}], "stats": {"total": 91, "additions": 41, "deletions": 50}, "files": [{"sha": "ee8e41620019a744af79cc90f15901de929bbd04", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 31, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d126de111bdf74cbcd20f043139af4f1e57b3cba/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d126de111bdf74cbcd20f043139af4f1e57b3cba/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=d126de111bdf74cbcd20f043139af4f1e57b3cba", "patch": "@@ -1,8 +1,7 @@\n use super::pat::Expected;\n-use super::ty::{AllowPlus, RecoverQuestionMark};\n use super::{\n-    BlockMode, CommaRecoveryMode, Parser, PathStyle, RecoverColon, RecoverComma, Restrictions,\n-    SemiColonMode, SeqSep, TokenExpectType, TokenType,\n+    BlockMode, CommaRecoveryMode, Parser, PathStyle, Restrictions, SemiColonMode, SeqSep,\n+    TokenExpectType, TokenType,\n };\n \n use crate::lexer::UnmatchedBrace;\n@@ -1233,26 +1232,14 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub(super) fn maybe_report_ambiguous_plus(\n-        &mut self,\n-        allow_plus: AllowPlus,\n-        impl_dyn_multi: bool,\n-        ty: &Ty,\n-    ) {\n-        if matches!(allow_plus, AllowPlus::No) && impl_dyn_multi {\n+    pub(super) fn maybe_report_ambiguous_plus(&mut self, impl_dyn_multi: bool, ty: &Ty) {\n+        if impl_dyn_multi {\n             self.sess.emit_err(AmbiguousPlus { sum_ty: pprust::ty_to_string(&ty), span: ty.span });\n         }\n     }\n \n     /// Swift lets users write `Ty?` to mean `Option<Ty>`. Parse the construct and recover from it.\n-    pub(super) fn maybe_recover_from_question_mark(\n-        &mut self,\n-        ty: P<Ty>,\n-        recover_question_mark: RecoverQuestionMark,\n-    ) -> P<Ty> {\n-        if let RecoverQuestionMark::No = recover_question_mark {\n-            return ty;\n-        }\n+    pub(super) fn maybe_recover_from_question_mark(&mut self, ty: P<Ty>) -> P<Ty> {\n         if self.token == token::Question {\n             self.bump();\n             self.struct_span_err(self.prev_token.span, \"invalid `?` in type\")\n@@ -1272,13 +1259,9 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub(super) fn maybe_recover_from_bad_type_plus(\n-        &mut self,\n-        allow_plus: AllowPlus,\n-        ty: &Ty,\n-    ) -> PResult<'a, ()> {\n+    pub(super) fn maybe_recover_from_bad_type_plus(&mut self, ty: &Ty) -> PResult<'a, ()> {\n         // Do not add `+` to expected tokens.\n-        if matches!(allow_plus, AllowPlus::No) || !self.token.is_like_plus() {\n+        if !self.token.is_like_plus() {\n             return Ok(());\n         }\n \n@@ -1444,10 +1427,9 @@ impl<'a> Parser<'a> {\n     pub(super) fn maybe_recover_from_bad_qpath<T: RecoverQPath>(\n         &mut self,\n         base: P<T>,\n-        allow_recovery: bool,\n     ) -> PResult<'a, P<T>> {\n         // Do not add `::` to expected tokens.\n-        if allow_recovery && self.token == token::ModSep {\n+        if self.token == token::ModSep {\n             if let Some(ty) = base.to_ty() {\n                 return self.maybe_recover_from_bad_qpath_stage_2(ty.span, ty);\n             }\n@@ -1593,7 +1575,7 @@ impl<'a> Parser<'a> {\n             _ => ExprKind::Await(expr),\n         };\n         let expr = self.mk_expr(lo.to(sp), kind, attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n+        self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     fn recover_await_macro(&mut self) -> PResult<'a, (Span, P<Expr>, bool)> {\n@@ -2457,10 +2439,9 @@ impl<'a> Parser<'a> {\n     pub(crate) fn maybe_recover_colon_colon_in_pat_typo(\n         &mut self,\n         mut first_pat: P<Pat>,\n-        ra: RecoverColon,\n         expected: Expected,\n     ) -> P<Pat> {\n-        if RecoverColon::Yes != ra || token::Colon != self.token.kind {\n+        if token::Colon != self.token.kind {\n             return first_pat;\n         }\n         if !matches!(first_pat.kind, PatKind::Ident(_, _, None) | PatKind::Path(..))\n@@ -2594,10 +2575,9 @@ impl<'a> Parser<'a> {\n     pub(crate) fn maybe_recover_unexpected_comma(\n         &mut self,\n         lo: Span,\n-        rc: RecoverComma,\n         rt: CommaRecoveryMode,\n     ) -> PResult<'a, ()> {\n-        if rc == RecoverComma::No || self.token != token::Comma {\n+        if self.token != token::Comma {\n             return Ok(());\n         }\n "}, {"sha": "63c7decbb2fe65103185ef93646d8883de14792b", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d126de111bdf74cbcd20f043139af4f1e57b3cba/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d126de111bdf74cbcd20f043139af4f1e57b3cba/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=d126de111bdf74cbcd20f043139af4f1e57b3cba", "patch": "@@ -1417,7 +1417,7 @@ impl<'a> Parser<'a> {\n         match self.parse_opt_lit() {\n             Some(literal) => {\n                 let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Lit(literal), attrs);\n-                self.maybe_recover_from_bad_qpath(expr, true)\n+                self.maybe_recover_from_bad_qpath(expr)\n             }\n             None => self.try_macro_suggestion(),\n         }\n@@ -1444,7 +1444,7 @@ impl<'a> Parser<'a> {\n             ExprKind::Tup(es)\n         };\n         let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n+        self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     fn parse_array_or_repeat_expr(\n@@ -1481,7 +1481,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n         let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n+        self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     fn parse_path_start_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n@@ -1519,7 +1519,7 @@ impl<'a> Parser<'a> {\n         };\n \n         let expr = self.mk_expr(lo.to(hi), kind, attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n+        self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Parse `'label: $expr`. The label is already parsed.\n@@ -1604,7 +1604,7 @@ impl<'a> Parser<'a> {\n         let lo = self.prev_token.span;\n         let kind = ExprKind::Ret(self.parse_expr_opt()?);\n         let expr = self.mk_expr(lo.to(self.prev_token.span), kind, attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n+        self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Parse `\"do\" \"yeet\" expr?`.\n@@ -1619,7 +1619,7 @@ impl<'a> Parser<'a> {\n         let span = lo.to(self.prev_token.span);\n         self.sess.gated_spans.gate(sym::yeet_expr, span);\n         let expr = self.mk_expr(span, kind, attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n+        self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Parse `\"break\" (('label (:? expr)?) | expr?)` with `\"break\"` token already eaten.\n@@ -1679,7 +1679,7 @@ impl<'a> Parser<'a> {\n             None\n         };\n         let expr = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Break(label, kind), attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n+        self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Parse `\"yield\" expr?`.\n@@ -1689,7 +1689,7 @@ impl<'a> Parser<'a> {\n         let span = lo.to(self.prev_token.span);\n         self.sess.gated_spans.gate(sym::generators, span);\n         let expr = self.mk_expr(span, kind, attrs);\n-        self.maybe_recover_from_bad_qpath(expr, true)\n+        self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Returns a string literal if the next token is a string literal."}, {"sha": "2ad3f3ec19d572a4b80d4426e07eeac487b918a2", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d126de111bdf74cbcd20f043139af4f1e57b3cba/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d126de111bdf74cbcd20f043139af4f1e57b3cba/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=d126de111bdf74cbcd20f043139af4f1e57b3cba", "patch": "@@ -100,8 +100,10 @@ impl<'a> Parser<'a> {\n         };\n \n         // Parse the first pattern (`p_0`).\n-        let first_pat = self.parse_pat_no_top_alt(expected)?;\n-        self.maybe_recover_unexpected_comma(first_pat.span, rc, rt)?;\n+        let mut first_pat = self.parse_pat_no_top_alt(expected)?;\n+        if rc == RecoverComma::Yes {\n+            self.maybe_recover_unexpected_comma(first_pat.span, rt)?;\n+        }\n \n         // If the next token is not a `|`,\n         // this is not an or-pattern and we should exit here.\n@@ -111,7 +113,9 @@ impl<'a> Parser<'a> {\n             // This complicated procedure is done purely for diagnostics UX.\n \n             // Check if the user wrote `foo:bar` instead of `foo::bar`.\n-            let first_pat = self.maybe_recover_colon_colon_in_pat_typo(first_pat, ra, expected);\n+            if ra == RecoverColon::Yes {\n+                first_pat = self.maybe_recover_colon_colon_in_pat_typo(first_pat, expected);\n+            }\n \n             if let Some(leading_vert_span) = leading_vert_span {\n                 // If there was a leading vert, treat this as an or-pattern. This improves\n@@ -139,7 +143,9 @@ impl<'a> Parser<'a> {\n                 err.span_label(lo, WHILE_PARSING_OR_MSG);\n                 err\n             })?;\n-            self.maybe_recover_unexpected_comma(pat.span, rc, rt)?;\n+            if rc == RecoverComma::Yes {\n+                self.maybe_recover_unexpected_comma(pat.span, rt)?;\n+            }\n             pats.push(pat);\n         }\n         let or_pattern_span = lo.to(self.prev_token.span);\n@@ -408,7 +414,7 @@ impl<'a> Parser<'a> {\n         };\n \n         let pat = self.mk_pat(lo.to(self.prev_token.span), pat);\n-        let pat = self.maybe_recover_from_bad_qpath(pat, true)?;\n+        let pat = self.maybe_recover_from_bad_qpath(pat)?;\n         let pat = self.recover_intersection_pat(pat)?;\n \n         if !allow_range_pat {"}, {"sha": "7907ec44e98e9682554c741a9b3152c4e08a68d4", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d126de111bdf74cbcd20f043139af4f1e57b3cba/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d126de111bdf74cbcd20f043139af4f1e57b3cba/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=d126de111bdf74cbcd20f043139af4f1e57b3cba", "patch": "@@ -180,7 +180,7 @@ impl<'a> Parser<'a> {\n         } else {\n             // Since none of the above applied, this is an expression statement macro.\n             let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac), AttrVec::new());\n-            let e = self.maybe_recover_from_bad_qpath(e, true)?;\n+            let e = self.maybe_recover_from_bad_qpath(e)?;\n             let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n             let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n             StmtKind::Expr(e)"}, {"sha": "dee025cfd3c8a5659a617a403a0f977394e41ccb", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d126de111bdf74cbcd20f043139af4f1e57b3cba/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d126de111bdf74cbcd20f043139af4f1e57b3cba/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=d126de111bdf74cbcd20f043139af4f1e57b3cba", "patch": "@@ -312,13 +312,18 @@ impl<'a> Parser<'a> {\n         };\n \n         let span = lo.to(self.prev_token.span);\n-        let ty = self.mk_ty(span, kind);\n+        let mut ty = self.mk_ty(span, kind);\n \n         // Try to recover from use of `+` with incorrect priority.\n-        self.maybe_report_ambiguous_plus(allow_plus, impl_dyn_multi, &ty);\n-        self.maybe_recover_from_bad_type_plus(allow_plus, &ty)?;\n-        let ty = self.maybe_recover_from_question_mark(ty, recover_question_mark);\n-        self.maybe_recover_from_bad_qpath(ty, allow_qpath_recovery)\n+        if matches!(allow_plus, AllowPlus::Yes) {\n+            self.maybe_recover_from_bad_type_plus(&ty)?;\n+        } else {\n+            self.maybe_report_ambiguous_plus(impl_dyn_multi, &ty);\n+        }\n+        if let RecoverQuestionMark::Yes = recover_question_mark {\n+            ty = self.maybe_recover_from_question_mark(ty);\n+        }\n+        if allow_qpath_recovery { self.maybe_recover_from_bad_qpath(ty) } else { Ok(ty) }\n     }\n \n     /// Parses either:"}]}