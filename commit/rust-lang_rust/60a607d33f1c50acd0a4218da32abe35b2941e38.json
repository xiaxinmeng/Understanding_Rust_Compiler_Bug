{"sha": "60a607d33f1c50acd0a4218da32abe35b2941e38", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwYTYwN2QzM2YxYzUwYWNkMGE0MjE4ZGEzMmFiZTM1YjI5NDFlMzg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-24T14:54:18Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-24T14:54:18Z"}, "message": "new struct id", "tree": {"sha": "fa1e5e1785cb04186ed07e04e3e5c1c73bb83c79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa1e5e1785cb04186ed07e04e3e5c1c73bb83c79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60a607d33f1c50acd0a4218da32abe35b2941e38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60a607d33f1c50acd0a4218da32abe35b2941e38", "html_url": "https://github.com/rust-lang/rust/commit/60a607d33f1c50acd0a4218da32abe35b2941e38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60a607d33f1c50acd0a4218da32abe35b2941e38/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c57a8579888643e73e12dd0ca23e81f88608c52f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c57a8579888643e73e12dd0ca23e81f88608c52f", "html_url": "https://github.com/rust-lang/rust/commit/c57a8579888643e73e12dd0ca23e81f88608c52f"}], "stats": {"total": 306, "additions": 200, "deletions": 106}, "files": [{"sha": "3caf60ee6d0c116436cba77426b8b4ac69d572da", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=60a607d33f1c50acd0a4218da32abe35b2941e38", "patch": "@@ -9,19 +9,27 @@ use ra_syntax::{\n };\n \n use crate::{\n-    DefId, DefLoc, Name, AsName, Struct, Enum, EnumVariant,\n+    DefId, DefLoc, Name, AsName, Struct, Enum, EnumVariant, Module, HirFileId,\n     HirDatabase, DefKind,\n     SourceItemId,\n     type_ref::TypeRef,\n+    ids::{StructLoc},\n };\n \n impl Struct {\n-    pub(crate) fn new(def_id: DefId) -> Self {\n-        Struct { def_id }\n+    pub(crate) fn from_ast(\n+        db: &impl HirDatabase,\n+        module: Module,\n+        file_id: HirFileId,\n+        ast: &ast::StructDef,\n+    ) -> Struct {\n+        let loc: StructLoc = StructLoc::from_ast(db, module, file_id, ast);\n+        let id = loc.id(db);\n+        Struct { id }\n     }\n \n     pub(crate) fn variant_data(&self, db: &impl HirDatabase) -> Arc<VariantData> {\n-        db.struct_data(self.def_id).variant_data.clone()\n+        db.struct_data((*self).into()).variant_data.clone()\n     }\n }\n \n@@ -39,13 +47,9 @@ impl StructData {\n         StructData { name, variant_data }\n     }\n \n-    pub(crate) fn struct_data_query(db: &impl HirDatabase, def_id: DefId) -> Arc<StructData> {\n-        let def_loc = def_id.loc(db);\n-        assert!(def_loc.kind == DefKind::Struct);\n-        let syntax = db.file_item(def_loc.source_item_id);\n-        let struct_def =\n-            ast::StructDef::cast(&syntax).expect(\"struct def should point to StructDef node\");\n-        Arc::new(StructData::new(struct_def))\n+    pub(crate) fn struct_data_query(db: &impl HirDatabase, struct_: Struct) -> Arc<StructData> {\n+        let (_, struct_def) = struct_.source(db);\n+        Arc::new(StructData::new(&*struct_def))\n     }\n }\n "}, {"sha": "948718aa62b2c0b372aad31924da13e4b2b30e5b", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=60a607d33f1c50acd0a4218da32abe35b2941e38", "patch": "@@ -10,13 +10,13 @@ use crate::{\n     nameres::{ModuleScope, lower::ImportId},\n     db::HirDatabase,\n     expr::BodySyntaxMapping,\n-    ty::InferenceResult,\n+    ty::{InferenceResult, VariantDef},\n     adt::VariantData,\n     generics::GenericParams,\n     code_model_impl::def_id_to_ast,\n     docs::{Documentation, Docs, docs_from_ast},\n     module_tree::ModuleId,\n-    ids::FunctionId,\n+    ids::{FunctionId, StructId},\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -68,6 +68,7 @@ pub struct Module {\n pub enum ModuleDef {\n     Module(Module),\n     Function(Function),\n+    Struct(Struct),\n     Def(DefId),\n }\n \n@@ -83,6 +84,12 @@ impl Into<ModuleDef> for Function {\n     }\n }\n \n+impl Into<ModuleDef> for Struct {\n+    fn into(self) -> ModuleDef {\n+        ModuleDef::Struct(self)\n+    }\n+}\n+\n impl Into<ModuleDef> for DefId {\n     fn into(self) -> ModuleDef {\n         ModuleDef::Def(self)\n@@ -187,7 +194,7 @@ impl Module {\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct StructField {\n-    parent: DefId,\n+    parent: VariantDef,\n     name: Name,\n }\n \n@@ -201,38 +208,38 @@ impl StructField {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Struct {\n-    pub(crate) def_id: DefId,\n+    pub(crate) id: StructId,\n }\n \n impl Struct {\n-    pub fn def_id(&self) -> DefId {\n-        self.def_id\n+    pub fn module(&self, db: &impl HirDatabase) -> Module {\n+        self.id.loc(db).module\n     }\n \n     pub fn name(&self, db: &impl HirDatabase) -> Option<Name> {\n-        db.struct_data(self.def_id).name.clone()\n+        db.struct_data(*self).name.clone()\n     }\n \n     pub fn fields(&self, db: &impl HirDatabase) -> Vec<StructField> {\n-        db.struct_data(self.def_id)\n+        db.struct_data(*self)\n             .variant_data\n             .fields()\n             .iter()\n             .map(|it| StructField {\n-                parent: self.def_id,\n+                parent: (*self).into(),\n                 name: it.name.clone(),\n             })\n             .collect()\n     }\n \n     pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::StructDef>) {\n-        def_id_to_ast(db, self.def_id)\n+        self.id.loc(db).source(db)\n     }\n \n     pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n-        db.generic_params(self.def_id.into())\n+        db.generic_params((*self).into())\n     }\n }\n \n@@ -310,7 +317,7 @@ impl EnumVariant {\n             .fields()\n             .iter()\n             .map(|it| StructField {\n-                parent: self.def_id,\n+                parent: self.def_id.into(),\n                 name: it.name.clone(),\n             })\n             .collect()"}, {"sha": "42f10e9415a626bc21c05d5b15d7367eb8f2f835", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=60a607d33f1c50acd0a4218da32abe35b2941e38", "patch": "@@ -135,7 +135,7 @@ impl Module {\n                         None => PerNs::none(),\n                     }\n                 }\n-                ModuleDef::Function(_) => PerNs::none(),\n+                ModuleDef::Function(_) | ModuleDef::Struct(_) => PerNs::none(),\n                 ModuleDef::Def(def) => {\n                     match def.resolve(db) {\n                         Def::Enum(e) => {"}, {"sha": "75935c30f508d336210d77e29c65b22c73f72fd9", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=60a607d33f1c50acd0a4218da32abe35b2941e38", "patch": "@@ -8,10 +8,11 @@ use crate::{\n     SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n     query_definitions,\n     Function, FnSignature, FnScopes,\n+    Struct,\n     macros::MacroExpansion,\n     module_tree::ModuleTree,\n     nameres::{ItemMap, lower::{LoweredModule, ImportSourceMap}},\n-    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef},\n+    ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef, VariantDef},\n     adt::{StructData, EnumData, EnumVariantData},\n     impl_block::ModuleImplBlocks,\n     generics::{GenericParams, GenericDef},\n@@ -29,7 +30,7 @@ pub trait HirDatabase: SyntaxDatabase + AsRef<HirInterner> {\n     fn fn_scopes(&self, func: Function) -> Arc<FnScopes>;\n \n     #[salsa::invoke(crate::adt::StructData::struct_data_query)]\n-    fn struct_data(&self, def_id: DefId) -> Arc<StructData>;\n+    fn struct_data(&self, struct_: Struct) -> Arc<StructData>;\n \n     #[salsa::invoke(crate::adt::EnumData::enum_data_query)]\n     fn enum_data(&self, def_id: DefId) -> Arc<EnumData>;\n@@ -44,7 +45,7 @@ pub trait HirDatabase: SyntaxDatabase + AsRef<HirInterner> {\n     fn type_for_def(&self, def: TypableDef) -> Ty;\n \n     #[salsa::invoke(crate::ty::type_for_field)]\n-    fn type_for_field(&self, def_id: DefId, field: Name) -> Option<Ty>;\n+    fn type_for_field(&self, def: VariantDef, field: Name) -> Option<Ty>;\n \n     #[salsa::invoke(query_definitions::file_items)]\n     fn file_items(&self, file_id: HirFileId) -> Arc<SourceFileItems>;"}, {"sha": "e10b85ec90bde60ec33b39cd499255f3f6ef0a2e", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=60a607d33f1c50acd0a4218da32abe35b2941e38", "patch": "@@ -7,7 +7,7 @@ use std::sync::Arc;\n \n use ra_syntax::ast::{self, AstNode, NameOwner, TypeParamsOwner};\n \n-use crate::{db::HirDatabase, DefId, Name, AsName, Function};\n+use crate::{db::HirDatabase, DefId, Name, AsName, Function, Struct};\n \n /// Data about a generic parameter (to a function, struct, impl, ...).\n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -25,6 +25,7 @@ pub struct GenericParams {\n #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n pub enum GenericDef {\n     Function(Function),\n+    Struct(Struct),\n     Def(DefId),\n }\n \n@@ -34,6 +35,12 @@ impl From<Function> for GenericDef {\n     }\n }\n \n+impl From<Struct> for GenericDef {\n+    fn from(func: Struct) -> GenericDef {\n+        GenericDef::Struct(func)\n+    }\n+}\n+\n impl From<DefId> for GenericDef {\n     fn from(def_id: DefId) -> GenericDef {\n         GenericDef::Def(def_id)\n@@ -53,6 +60,12 @@ impl GenericParams {\n                     generics.fill(type_param_list)\n                 }\n             }\n+            GenericDef::Struct(s) => {\n+                let (_, struct_def) = s.source(db);\n+                if let Some(type_param_list) = struct_def.type_param_list() {\n+                    generics.fill(type_param_list)\n+                }\n+            }\n             GenericDef::Def(def_id) => {\n                 let (_file_id, node) = def_id.source(db);\n                 if let Some(type_param_list) = node.children().find_map(ast::TypeParamList::cast) {"}, {"sha": "2791149dd9088dfb1a850b42810589ac4ca2187e", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=60a607d33f1c50acd0a4218da32abe35b2941e38", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{TreeArc, SyntaxNode, SourceFile, AstNode, ast};\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n use crate::{\n-    HirDatabase, Def, Struct, Enum, EnumVariant, Crate,\n+    HirDatabase, Def, Enum, EnumVariant, Crate,\n     Module, Trait, Type, Static, Const,\n };\n \n@@ -257,10 +257,7 @@ impl DefId {\n     pub fn resolve(self, db: &impl HirDatabase) -> Def {\n         let loc = self.loc(db);\n         match loc.kind {\n-            DefKind::Struct => {\n-                let struct_def = Struct::new(self);\n-                Def::Struct(struct_def)\n-            }\n+            DefKind::Struct => unreachable!(),\n             DefKind::Enum => Def::Enum(Enum::new(self)),\n             DefKind::EnumVariant => Def::EnumVariant(EnumVariant::new(self)),\n             DefKind::Const => {"}, {"sha": "5d63718924e003e8ea5a36c51a92ae549df3fe9a", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=60a607d33f1c50acd0a4218da32abe35b2941e38", "patch": "@@ -43,7 +43,7 @@ pub use self::{\n     ids::{HirFileId, DefId, DefLoc, MacroCallId, MacroCallLoc, HirInterner},\n     macros::{MacroDef, MacroInput, MacroExpansion},\n     nameres::{ItemMap, PerNs, Namespace, Resolution},\n-    ty::Ty,\n+    ty::{Ty, AdtDef},\n     impl_block::{ImplBlock, ImplItem},\n     code_model_impl::function::{FnScopes, ScopesWithSyntaxMapping},\n     docs::{Docs, Documentation}"}, {"sha": "b0c4aa819d2718065e55085fc286fa17f478983c", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=60a607d33f1c50acd0a4218da32abe35b2941e38", "patch": "@@ -10,7 +10,7 @@ use rustc_hash::FxHashMap;\n use crate::{\n     SourceItemId, Path, ModuleSource, HirDatabase, Name, SourceFileItems,\n     HirFileId, MacroCallLoc, AsName, PerNs, DefKind, DefLoc, Function,\n-    ModuleDef, Module,\n+    ModuleDef, Module, Struct,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -147,7 +147,14 @@ impl LoweredModule {\n         item: &ast::ModuleItem,\n     ) {\n         let name = match item.kind() {\n-            ast::ModuleItemKind::StructDef(it) => it.name(),\n+            ast::ModuleItemKind::StructDef(it) => {\n+                if let Some(name) = it.name() {\n+                    let s = Struct::from_ast(db, module, file_id, it);\n+                    let s: ModuleDef = s.into();\n+                    self.declarations.insert(name.as_name(), PerNs::both(s, s));\n+                }\n+                return;\n+            }\n             ast::ModuleItemKind::EnumDef(it) => it.name(),\n             ast::ModuleItemKind::FnDef(it) => {\n                 if let Some(name) = it.name() {"}, {"sha": "fc699a2ae2e391d10d9b7bb58c19c7b00317853f", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 106, "deletions": 44, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=60a607d33f1c50acd0a4218da32abe35b2941e38", "patch": "@@ -32,7 +32,7 @@ use rustc_hash::FxHashMap;\n \n use crate::{\n     Def, DefId, Module, Function, Struct, StructField, Enum, EnumVariant, Path, Name, ImplBlock,\n-    FnSignature, FnScopes, ModuleDef,\n+    FnSignature, FnScopes, ModuleDef, Crate,\n     db::HirDatabase,\n     type_ref::{TypeRef, Mutability},\n     name::KnownName,\n@@ -163,6 +163,33 @@ impl Substs {\n     }\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum AdtDef {\n+    Struct(Struct),\n+    Def(DefId), // Enum\n+}\n+\n+impl From<Struct> for AdtDef {\n+    fn from(struct_: Struct) -> AdtDef {\n+        AdtDef::Struct(struct_)\n+    }\n+}\n+\n+impl From<DefId> for AdtDef {\n+    fn from(def_id: DefId) -> AdtDef {\n+        AdtDef::Def(def_id)\n+    }\n+}\n+\n+impl AdtDef {\n+    fn krate(self, db: &impl HirDatabase) -> Option<Crate> {\n+        match self {\n+            AdtDef::Struct(s) => s.module(db).krate(db),\n+            AdtDef::Def(def_id) => def_id.krate(db),\n+        }\n+    }\n+}\n+\n /// A type. This is based on the `TyKind` enum in rustc (librustc/ty/sty.rs).\n ///\n /// This should be cheap to clone.\n@@ -184,7 +211,7 @@ pub enum Ty {\n     /// Structures, enumerations and unions.\n     Adt {\n         /// The DefId of the struct/enum.\n-        def_id: DefId,\n+        def_id: AdtDef,\n         /// The name, for displaying.\n         name: Name,\n         /// Substitutions for the generic parameters of the type.\n@@ -384,6 +411,7 @@ impl Ty {\n         let resolved = match module.resolve_path(db, path).take_types() {\n             Some(ModuleDef::Def(r)) => r.into(),\n             Some(ModuleDef::Function(f)) => f.into(),\n+            Some(ModuleDef::Struct(s)) => s.into(),\n             None | Some(ModuleDef::Module(_)) => return Ty::Unknown,\n         };\n         let ty = db.type_for_def(resolved);\n@@ -409,6 +437,7 @@ impl Ty {\n             .expect(\"path should have at least one segment\");\n         let (def_generics, segment) = match resolved {\n             TypableDef::Function(func) => (func.generic_params(db), last),\n+            TypableDef::Struct(s) => (s.generic_params(db), last),\n             TypableDef::Def(def_id) => match def_id.resolve(db) {\n                 Def::Struct(s) => (s.generic_params(db), last),\n                 Def::Enum(e) => (e.generic_params(db), last),\n@@ -642,7 +671,7 @@ fn make_substs(generics: &GenericParams) -> Substs {\n fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n     let generics = s.generic_params(db);\n     Ty::Adt {\n-        def_id: s.def_id(),\n+        def_id: s.into(),\n         name: s.name(db).unwrap_or_else(Name::missing),\n         substs: make_substs(&generics),\n     }\n@@ -651,7 +680,7 @@ fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n pub(crate) fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Ty {\n     let generics = s.generic_params(db);\n     Ty::Adt {\n-        def_id: s.def_id(),\n+        def_id: s.def_id().into(),\n         name: s.name(db).unwrap_or_else(Name::missing),\n         substs: make_substs(&generics),\n     }\n@@ -666,6 +695,7 @@ pub(crate) fn type_for_enum_variant(db: &impl HirDatabase, ev: EnumVariant) -> T\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum TypableDef {\n     Function(Function),\n+    Struct(Struct),\n     Def(DefId),\n }\n \n@@ -675,6 +705,12 @@ impl From<Function> for TypableDef {\n     }\n }\n \n+impl From<Struct> for TypableDef {\n+    fn from(struct_: Struct) -> TypableDef {\n+        TypableDef::Struct(struct_)\n+    }\n+}\n+\n impl From<DefId> for TypableDef {\n     fn from(func: DefId) -> TypableDef {\n         TypableDef::Def(func)\n@@ -684,8 +720,8 @@ impl From<DefId> for TypableDef {\n pub(super) fn type_for_def(db: &impl HirDatabase, def: TypableDef) -> Ty {\n     match def {\n         TypableDef::Function(f) => type_for_fn(db, f),\n+        TypableDef::Struct(s) => type_for_struct(db, s),\n         TypableDef::Def(def_id) => match def_id.resolve(db) {\n-            Def::Struct(s) => type_for_struct(db, s),\n             Def::Enum(e) => type_for_enum(db, e),\n             Def::EnumVariant(ev) => type_for_enum_variant(db, ev),\n             _ => {\n@@ -700,22 +736,44 @@ pub(super) fn type_for_def(db: &impl HirDatabase, def: TypableDef) -> Ty {\n     }\n }\n \n-pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name) -> Option<Ty> {\n-    let def = def_id.resolve(db);\n-    let (variant_data, generics) = match def {\n-        Def::Struct(s) => (s.variant_data(db), s.generic_params(db)),\n-        Def::EnumVariant(ev) => (ev.variant_data(db), ev.parent_enum(db).generic_params(db)),\n-        // TODO: unions\n-        Def::Enum(_) => {\n-            // this can happen in (invalid) code, but enums don't have fields themselves\n-            return None;\n-        }\n-        _ => panic!(\n-            \"trying to get type for field {:?} in non-struct/variant {:?}\",\n-            field, def_id\n-        ),\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum VariantDef {\n+    Struct(Struct),\n+    Def(DefId), // EnumVariant\n+}\n+\n+impl From<Struct> for VariantDef {\n+    fn from(struct_: Struct) -> VariantDef {\n+        VariantDef::Struct(struct_)\n+    }\n+}\n+\n+impl From<DefId> for VariantDef {\n+    fn from(def_id: DefId) -> VariantDef {\n+        VariantDef::Def(def_id)\n+    }\n+}\n+\n+pub(super) fn type_for_field(db: &impl HirDatabase, def: VariantDef, field: Name) -> Option<Ty> {\n+    let (variant_data, generics, module) = match def {\n+        VariantDef::Struct(s) => (s.variant_data(db), s.generic_params(db), s.module(db)),\n+        VariantDef::Def(def_id) => match def_id.resolve(db) {\n+            Def::EnumVariant(ev) => (\n+                ev.variant_data(db),\n+                ev.parent_enum(db).generic_params(db),\n+                def_id.module(db),\n+            ),\n+            // TODO: unions\n+            Def::Enum(_) => {\n+                // this can happen in (invalid) code, but enums don't have fields themselves\n+                return None;\n+            }\n+            _ => panic!(\n+                \"trying to get type for field {:?} in non-struct/variant {:?}\",\n+                field, def_id\n+            ),\n+        },\n     };\n-    let module = def_id.module(db);\n     // We can't have an impl block ere, right?\n     // let impl_block = def_id.impl_block(db);\n     let type_ref = variant_data.get_field_type_ref(&field)?;\n@@ -1076,25 +1134,27 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n \n         // resolve in module\n-        let resolved = match self.module.resolve_path(self.db, &path).take_values()? {\n+        let typable = match self.module.resolve_path(self.db, &path).take_values()? {\n             ModuleDef::Def(it) => it.into(),\n             ModuleDef::Function(func) => func.into(),\n+            ModuleDef::Struct(s) => s.into(),\n             ModuleDef::Module(_) => return None,\n         };\n-        let ty = self.db.type_for_def(resolved);\n+        let ty = self.db.type_for_def(typable);\n         let ty = self.insert_type_vars(ty);\n         Some(ty)\n     }\n \n-    fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<DefId>) {\n+    fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantDef>) {\n         let path = match path {\n             Some(path) => path,\n             None => return (Ty::Unknown, None),\n         };\n         let def = match self.module.resolve_path(self.db, &path).take_types() {\n             Some(ModuleDef::Def(def_id)) => def_id.into(),\n             Some(ModuleDef::Function(func)) => func.into(),\n-            _ => return (Ty::Unknown, None),\n+            Some(ModuleDef::Struct(s)) => s.into(),\n+            None | Some(ModuleDef::Module(_)) => return (Ty::Unknown, None),\n         };\n         // TODO remove the duplication between here and `Ty::from_path`?\n         // TODO provide generics of function\n@@ -1109,37 +1169,36 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         );\n         match def {\n             TypableDef::Def(def_id) => match def_id.resolve(self.db) {\n-                Def::Struct(s) => {\n-                    let ty = type_for_struct(self.db, s);\n-                    let ty = self.insert_type_vars(ty.apply_substs(substs));\n-                    (ty, Some(def_id))\n-                }\n                 Def::EnumVariant(ev) => {\n                     let ty = type_for_enum_variant(self.db, ev);\n                     let ty = self.insert_type_vars(ty.apply_substs(substs));\n-                    (ty, Some(def_id))\n+                    (ty, Some(def_id.into()))\n                 }\n                 _ => (Ty::Unknown, None),\n             },\n             TypableDef::Function(_) => (Ty::Unknown, None),\n+            TypableDef::Struct(s) => {\n+                let ty = type_for_struct(self.db, s);\n+                let ty = self.insert_type_vars(ty.apply_substs(substs));\n+                (ty, Some(s.into()))\n+            }\n         }\n     }\n \n     fn resolve_fields(&mut self, path: Option<&Path>) -> Option<(Ty, Vec<StructField>)> {\n-        let (ty, def_id) = self.resolve_variant(path);\n-        let def_id = def_id?;\n-        let def = def_id.resolve(self.db);\n-\n-        match def {\n-            Def::Struct(s) => {\n+        let (ty, def) = self.resolve_variant(path);\n+        match def? {\n+            VariantDef::Struct(s) => {\n                 let fields = s.fields(self.db);\n                 Some((ty, fields))\n             }\n-            Def::EnumVariant(ev) => {\n-                let fields = ev.fields(self.db);\n-                Some((ty, fields))\n-            }\n-            _ => None,\n+            VariantDef::Def(def_id) => match def_id.resolve(self.db) {\n+                Def::EnumVariant(ev) => {\n+                    let fields = ev.fields(self.db);\n+                    Some((ty, fields))\n+                }\n+                _ => None,\n+            },\n         }\n     }\n \n@@ -1240,6 +1299,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 .and_then(|module_def| match module_def {\n                     ModuleDef::Def(it) => Some(it.into()),\n                     ModuleDef::Function(func) => Some(func.into()),\n+                    ModuleDef::Struct(s) => Some(s.into()),\n                     ModuleDef::Module(_) => None,\n                 })\n                 .map_or(Ty::Unknown, |resolved| self.db.type_for_def(resolved)),\n@@ -1433,7 +1493,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 for field in fields {\n                     let field_ty = if let Some(def_id) = def_id {\n                         self.db\n-                            .type_for_field(def_id, field.name.clone())\n+                            .type_for_field(def_id.into(), field.name.clone())\n                             .unwrap_or(Ty::Unknown)\n                             .subst(&substs)\n                     } else {\n@@ -1457,10 +1517,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             i.and_then(|i| fields.get(i).cloned())\n                         }\n                         Ty::Adt {\n-                            def_id, ref substs, ..\n+                            def_id: AdtDef::Struct(s),\n+                            ref substs,\n+                            ..\n                         } => self\n                             .db\n-                            .type_for_field(def_id, name.clone())\n+                            .type_for_field(s.into(), name.clone())\n                             .map(|ty| ty.subst(substs)),\n                         _ => None,\n                     })"}, {"sha": "9a571c2aaf51a826ef03aa7def0db243be2c6656", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=60a607d33f1c50acd0a4218da32abe35b2941e38", "patch": "@@ -7,16 +7,16 @@ use std::sync::Arc;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    HirDatabase, DefId, module_tree::ModuleId, Module, Crate, Name, Function,\n+    HirDatabase, module_tree::ModuleId, Module, Crate, Name, Function,\n     impl_block::{ImplId, ImplBlock, ImplItem},\n-    generics::GenericParams\n+    generics::GenericParams,\n+    ty::{AdtDef, Ty}\n };\n-use super::Ty;\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum TyFingerprint {\n-    Adt(DefId),\n+    Adt(AdtDef),\n     // we'll also want to index impls for primitive types etc.\n }\n "}, {"sha": "8747fae1814d9e1932b7855ad08b58a03128e50f", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_struct.snap", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_struct.snap", "raw_url": "https://github.com/rust-lang/rust/raw/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_struct.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_struct.snap?ref=60a607d33f1c50acd0a4218da32abe35b2941e38", "patch": "@@ -1,19 +1,19 @@\n ---\n-created: \"2019-01-22T14:45:00.058678600+00:00\"\n-creator: insta@0.4.0\n+created: \"2019-01-24T14:51:32.808861856+00:00\"\n+creator: insta@0.5.2\n expression: \"&result\"\n-source: \"crates\\\\ra_hir\\\\src\\\\ty\\\\tests.rs\"\n+source: crates/ra_hir/src/ty/tests.rs\n ---\n [72; 154) '{     ...a.c; }': ()\n [82; 83) 'c': [unknown]\n-[86; 87) 'C': [unknown]\n+[86; 87) 'C': C\n [86; 90) 'C(1)': [unknown]\n [88; 89) '1': i32\n-[96; 97) 'B': [unknown]\n+[96; 97) 'B': B\n [107; 108) 'a': A\n [114; 133) 'A { b:...C(1) }': A\n [121; 122) 'B': B\n-[127; 128) 'C': [unknown]\n+[127; 128) 'C': C\n [127; 131) 'C(1)': C\n [129; 130) '1': i32\n [139; 140) 'a': A"}, {"sha": "1a2b0b2f68a6a08cd3e497139f556d45414a2c43", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60a607d33f1c50acd0a4218da32abe35b2941e38/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=60a607d33f1c50acd0a4218da32abe35b2941e38", "patch": "@@ -1,4 +1,4 @@\n-use hir::{Ty, Def};\n+use hir::{Ty, Def, AdtDef};\n \n use crate::completion::{CompletionContext, Completions, CompletionItem, CompletionItemKind};\n use crate::completion::completion_item::CompletionKind;\n@@ -28,21 +28,24 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n             Ty::Adt {\n                 def_id, ref substs, ..\n             } => {\n-                match def_id.resolve(ctx.db) {\n-                    Def::Struct(s) => {\n-                        for field in s.fields(ctx.db) {\n-                            CompletionItem::new(\n-                                CompletionKind::Reference,\n-                                ctx.source_range(),\n-                                field.name().to_string(),\n-                            )\n-                            .kind(CompletionItemKind::Field)\n-                            .set_detail(field.ty(ctx.db).map(|ty| ty.subst(substs).to_string()))\n-                            .add_to(acc);\n+                match def_id {\n+                    AdtDef::Struct() => {}\n+                    AdtDef::Def(def_id) => match def_id.resolve(ctx.db) {\n+                        Def::Struct(s) => {\n+                            for field in s.fields(ctx.db) {\n+                                CompletionItem::new(\n+                                    CompletionKind::Reference,\n+                                    ctx.source_range(),\n+                                    field.name().to_string(),\n+                                )\n+                                .kind(CompletionItemKind::Field)\n+                                .set_detail(field.ty(ctx.db).map(|ty| ty.subst(substs).to_string()))\n+                                .add_to(acc);\n+                            }\n                         }\n-                    }\n-                    // TODO unions\n-                    _ => {}\n+                        // TODO unions\n+                        _ => {}\n+                    },\n                 }\n             }\n             Ty::Tuple(fields) => {"}]}