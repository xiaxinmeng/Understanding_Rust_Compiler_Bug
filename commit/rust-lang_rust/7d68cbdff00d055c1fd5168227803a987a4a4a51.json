{"sha": "7d68cbdff00d055c1fd5168227803a987a4a4a51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNjhjYmRmZjAwZDA1NWMxZmQ1MTY4MjI3ODAzYTk4N2E0YTRhNTE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-31T12:24:04Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-31T12:29:16Z"}, "message": "Have blocks return their result by writing to a reserved space\n\nThis makes it possible to pass the location of that space through to\nnested blocks, resulting in less copying, taking, and dropping.\n\nThis makes the compiler slightly faster and 19k smaller.\n\nA FIXME is to use 'move' semantics when returning the values from the\nblock -- don't bump the refcount and drop it again for the returning\nblock, but simply assign ownership to the receiver. To do this, we'll\nneed a way to (safely) scrub things from a block's cleanup list.", "tree": {"sha": "b656970515f5c28d00a3ceaac56d90450f1f7787", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b656970515f5c28d00a3ceaac56d90450f1f7787"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d68cbdff00d055c1fd5168227803a987a4a4a51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d68cbdff00d055c1fd5168227803a987a4a4a51", "html_url": "https://github.com/rust-lang/rust/commit/7d68cbdff00d055c1fd5168227803a987a4a4a51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d68cbdff00d055c1fd5168227803a987a4a4a51/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81fc2d8728b622275d55243cbacbc7834641503f", "url": "https://api.github.com/repos/rust-lang/rust/commits/81fc2d8728b622275d55243cbacbc7834641503f", "html_url": "https://github.com/rust-lang/rust/commit/81fc2d8728b622275d55243cbacbc7834641503f"}], "stats": {"total": 174, "additions": 103, "deletions": 71}, "files": [{"sha": "a3fccafce98b51d44c77bcd5dafff11f4a36c70d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 103, "deletions": 71, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/7d68cbdff00d055c1fd5168227803a987a4a4a51/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d68cbdff00d055c1fd5168227803a987a4a4a51/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7d68cbdff00d055c1fd5168227803a987a4a4a51", "patch": "@@ -3712,14 +3712,28 @@ fn join_results(&@block_ctxt parent_cx,\n     ret res(join_cx, phi);\n }\n \n+fn join_branches(&@block_ctxt parent_cx, &vec[result] ins) -> @block_ctxt {\n+    auto out = new_sub_block_ctxt(parent_cx, \"join\");\n+    for (result r in ins) {\n+        if (!is_terminated(r.bcx)) {\n+            r.bcx.build.Br(out.llbb);\n+        }\n+    }\n+    ret out;\n+}\n+\n+tag out_method {\n+    return;\n+    save_in(ValueRef);\n+}\n+\n fn trans_if(&@block_ctxt cx, &@ast::expr cond,\n             &ast::block thn, &option::t[@ast::expr] els,\n-            &ast::ann ann) -> result {\n-\n+            &ast::ann ann, &out_method output) -> result {\n     auto cond_res = trans_expr(cx, cond);\n \n     auto then_cx = new_scope_block_ctxt(cx, \"then\");\n-    auto then_res = trans_block(then_cx, thn);\n+    auto then_res = trans_block(then_cx, thn, output);\n \n     auto else_cx = new_scope_block_ctxt(cx, \"else\");\n \n@@ -3739,14 +3753,14 @@ fn trans_if(&@block_ctxt cx, &@ast::expr cond,\n                               a = ann);\n                     auto elseif_blk = rec(node = elseif_blk_,\n                                           span = elexpr.span);\n-                    else_res = trans_block(else_cx, elseif_blk);\n+                    else_res = trans_block(else_cx, elseif_blk, output);\n                 }\n                 case (ast::expr_block(?blk, _)) {\n                     // Calling trans_block directly instead of trans_expr\n                     // because trans_expr will create another scope block\n                     // context for the block, but we've already got the\n                     // 'else' context\n-                    else_res = trans_block(else_cx, blk);\n+                    else_res = trans_block(else_cx, blk, output);\n                 }\n             }\n \n@@ -3771,9 +3785,7 @@ fn trans_if(&@block_ctxt cx, &@ast::expr cond,\n     cond_res.bcx.build.CondBr(cond_res.val,\n                               then_cx.llbb,\n                               else_cx.llbb);\n-\n-    ret join_results(cx, expr_llty,\n-                     [then_res, else_res]);\n+    ret res(join_branches(cx, [then_res, else_res]), C_nil());\n }\n \n fn trans_for(&@block_ctxt cx,\n@@ -3795,7 +3807,7 @@ fn trans_for(&@block_ctxt cx,\n         auto bcx = copy_val(local_res.bcx, INIT, local_res.val, curr, t).bcx;\n         scope_cx.cleanups +=\n             [clean(bind drop_slot(_, local_res.val, t))];\n-        bcx = trans_block(bcx, body).bcx;\n+        bcx = trans_block(bcx, body, return).bcx;\n         bcx.build.Br(next_cx.llbb);\n         ret res(next_cx, C_nil());\n     }\n@@ -4053,7 +4065,7 @@ fn trans_for_each(&@block_ctxt cx,\n \n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n-    auto r = trans_block(bcx, body);\n+    auto r = trans_block(bcx, body, return);\n \n     finish_fn(fcx, lltop);\n \n@@ -4099,7 +4111,7 @@ fn trans_while(&@block_ctxt cx, &@ast::expr cond,\n     auto body_cx = new_loop_scope_block_ctxt(cx, option::none[@block_ctxt],\n                                              next_cx, \"while loop body\");\n \n-    auto body_res = trans_block(body_cx, body);\n+    auto body_res = trans_block(body_cx, body, return);\n     auto cond_res = trans_expr(cond_cx, cond);\n \n     body_res.bcx.build.Br(cond_cx.llbb);\n@@ -4118,7 +4130,7 @@ fn trans_do_while(&@block_ctxt cx, &ast::block body,\n     auto body_cx = new_loop_scope_block_ctxt(cx, option::none[@block_ctxt],\n                                              next_cx, \"do-while loop body\");\n \n-    auto body_res = trans_block(body_cx, body);\n+    auto body_res = trans_block(body_cx, body, return);\n     auto cond_res = trans_expr(body_res.bcx, cond);\n \n     cond_res.bcx.build.CondBr(cond_res.val,\n@@ -4259,7 +4271,8 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat,\n }\n \n fn trans_alt(&@block_ctxt cx, &@ast::expr expr,\n-             &vec[ast::arm] arms, &ast::ann ann) -> result {\n+             &vec[ast::arm] arms, &ast::ann ann,\n+             &out_method output) -> result {\n     auto expr_res = trans_expr(cx, expr);\n \n     auto this_cx = expr_res.bcx;\n@@ -4275,12 +4288,13 @@ fn trans_alt(&@block_ctxt cx, &@ast::expr expr,\n         auto binding_res = trans_pat_binding(binding_cx, arm.pat,\n                                              expr_res.val, false);\n \n-        auto block_res = trans_block(binding_res.bcx, arm.block);\n+        auto block_res = trans_block(binding_res.bcx, arm.block, output);\n         arm_results += [block_res];\n \n         this_cx = next_cx;\n     }\n \n+\n     auto default_cx = this_cx;\n     auto default_res = trans_fail(default_cx, some[common::span](expr.span),\n                                   \"non-exhaustive match failure\");\n@@ -4297,7 +4311,7 @@ fn trans_alt(&@block_ctxt cx, &@ast::expr expr,\n         }\n     }\n \n-    ret join_results(cx, expr_llty, arm_results);\n+    ret res(join_branches(cx, arm_results), C_nil());\n }\n \n type generic_info = rec(ty::t item_type,\n@@ -4454,7 +4468,7 @@ fn trans_path(&@block_ctxt cx, &ast::path p, &ast::ann ann) -> lval_result {\n \n                     auto lltagty;\n                     if (ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx,\n-                                                 tag_ty)) {\n+                                                  tag_ty)) {\n                         lltagty = T_opaque_tag(cx.fcx.lcx.ccx.tn);\n                     } else {\n                         lltagty = type_of(cx.fcx.lcx.ccx, p.span, tag_ty);\n@@ -5428,6 +5442,11 @@ fn trans_rec(&@block_ctxt cx, &vec[ast::field] fields,\n }\n \n fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n+    be trans_expr_out(cx, e, return);\n+}\n+\n+fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output)\n+    -> result {\n     *cx = rec(sp=e.span with *cx);\n     alt (e.node) {\n         case (ast::expr_lit(?lit, ?ann)) {\n@@ -5445,7 +5464,8 @@ fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n         }\n \n         case (ast::expr_if(?cond, ?thn, ?els, ?ann)) {\n-            ret trans_if(cx, cond, thn, els, ann);\n+            ret with_out_method(bind trans_if(cx, cond, thn, els, ann, _),\n+                                cx, ann, output);\n         }\n \n         case (ast::expr_for(?decl, ?seq, ?body, _)) {\n@@ -5465,18 +5485,18 @@ fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n         }\n \n         case (ast::expr_alt(?expr, ?arms, ?ann)) {\n-            ret trans_alt(cx, expr, arms, ann);\n+            ret with_out_method(bind trans_alt(cx, expr, arms, ann, _),\n+                                cx, ann, output);\n         }\n \n-        case (ast::expr_block(?blk, _)) {\n+        case (ast::expr_block(?blk, ?ann)) {\n             *cx = rec(sp=blk.span with *cx);\n             auto sub_cx = new_scope_block_ctxt(cx, \"block-expr body\");\n             auto next_cx = new_sub_block_ctxt(cx, \"next\");\n-            auto sub = trans_block(sub_cx, blk);\n-\n+            auto sub = with_out_method(bind trans_block(sub_cx, blk, _),\n+                                       cx, ann, output);\n             cx.build.Br(sub_cx.llbb);\n             sub.bcx.build.Br(next_cx.llbb);\n-\n             ret res(next_cx, sub.val);\n         }\n \n@@ -5617,6 +5637,34 @@ fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n     ret res(sub.res.bcx, load_if_immediate(sub.res.bcx, sub.res.val, t));\n }\n \n+fn with_out_method(fn(&out_method) -> result work, &@block_ctxt cx,\n+                   &ast::ann ann, &out_method outer_output) -> result {\n+    auto ccx = cx.fcx.lcx.ccx;\n+    if (outer_output != return) {\n+        ret work(outer_output);\n+    } else {\n+        auto tp = node_ann_type(ccx, ann);\n+        if (ty::type_is_nil(ccx.tcx, tp)) {\n+            ret work(return);\n+        }\n+        auto res_alloca = alloc_ty(cx, tp);\n+        cx = zero_alloca(res_alloca.bcx, res_alloca.val, tp).bcx;\n+\n+        fn drop_hoisted_ty(&@block_ctxt cx,\n+                           ValueRef target,\n+                           ty::t t) -> result {\n+            auto reg_val = load_if_immediate(cx, target, t);\n+            ret drop_ty(cx, reg_val, t);\n+        }\n+        auto cleanup = bind drop_hoisted_ty(_, res_alloca.val, tp);\n+        find_scope_cx(cx).cleanups += [clean(cleanup)];\n+\n+        auto done = work(save_in(res_alloca.val));\n+        done.val = load_if_immediate(done.bcx, res_alloca.val, tp);\n+        ret done;\n+    }\n+}\n+\n // We pass structural values around the compiler \"by pointer\" and\n // non-structural values (scalars, boxes, pointers) \"by value\". We call the\n // latter group \"immediates\" and, in some circumstances when we know we have a\n@@ -6472,9 +6520,8 @@ fn alloc_local(&@block_ctxt cx, &@ast::local local) -> result {\n     ret r;\n }\n \n-fn trans_block(&@block_ctxt cx, &ast::block b) -> result {\n+fn trans_block(&@block_ctxt cx, &ast::block b, &out_method output) -> result {\n     auto bcx = cx;\n-\n     for each (@ast::local local in block_locals(b)) {\n         *bcx = rec(sp=local_rhs_span(local, cx.sp) with *bcx);\n         bcx = alloc_local(bcx, local).bcx;\n@@ -6491,58 +6538,43 @@ fn trans_block(&@block_ctxt cx, &ast::block b) -> result {\n         }\n     }\n \n+    fn accept_out_method(&@ast::expr expr) -> bool {\n+        ret alt (expr.node) {\n+            case (ast::expr_if(_, _, _, _)) { true }\n+            case (ast::expr_alt(_, _, _)) { true }\n+            case (ast::expr_block(_, _)) { true }\n+            case (_) { false }\n+        };\n+    }\n+\n     alt (b.node.expr) {\n         case (some(?e)) {\n-            // Hold onto the context for this scope since we'll need it to\n-            // find the outer scope\n-            auto scope_bcx = bcx;\n-            r = trans_expr(bcx, e);\n+            auto pass = output != return && accept_out_method(e);\n+            if (pass) {\n+                r = trans_expr_out(bcx, e, output);\n+            } else {\n+                r = trans_expr(bcx, e);\n+            }\n             bcx = r.bcx;\n \n-            if (is_terminated(bcx)) {\n+            auto ccx = cx.fcx.lcx.ccx;\n+            auto r_ty = ty::expr_ty(ccx.tcx, e);\n+            if (is_terminated(bcx) ||\n+                ty::type_is_bot(ccx.tcx, r_ty)) {\n                 ret r;\n-            } else {\n-                auto r_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n-                if (!ty::type_is_nil(cx.fcx.lcx.ccx.tcx, r_ty)\n-                    && !ty::type_is_bot(cx.fcx.lcx.ccx.tcx, r_ty)) {\n-                    // The value resulting from the block gets copied into an\n-                    // alloca created in an outer scope and its refcount\n-                    // bumped so that it can escape this block. This means\n-                    // that it will definitely live until the end of the\n-                    // enclosing scope, even if nobody uses it, which may be\n-                    // something of a surprise.\n-\n-                    // It's possible we never hit this block, so the alloca\n-                    // must be initialized to null, then when the potential\n-                    // value finally goes out of scope the drop glue will see\n-                    // that it was never used and ignore it.\n-\n-                    // NB: Here we're building and initalizing the alloca in\n-                    // the alloca context, not this block's context.\n-                    auto res_alloca = alloc_ty(bcx, r_ty);\n-                    auto llbcx = llallocas_block_ctxt(bcx.fcx);\n-                    zero_alloca(llbcx, res_alloca.val, r_ty);\n-\n-                    // Now we're working in our own block context again\n-                    auto res_copy = copy_val(bcx, INIT,\n-                                            res_alloca.val, r.val, r_ty);\n-                    bcx = res_copy.bcx;\n-\n-                    fn drop_hoisted_ty(&@block_ctxt cx,\n-                                       ValueRef alloca_val,\n-                                       ty::t t) -> result {\n-                        auto reg_val = load_if_immediate(cx,\n-                                                            alloca_val, t);\n-                        ret drop_ty(cx, reg_val, t);\n+            } else if (!pass) {\n+                alt (output) {\n+                    case (save_in(?target)) {\n+                        // The output method is to save the value at target,\n+                        // and we didn't pass it to the recursive trans_expr\n+                        // call.\n+                        // FIXME Use move semantics!\n+                        auto res_copy = copy_val(bcx, INIT, target,\n+                                                 r.val, r_ty);\n+                        bcx = res_copy.bcx;\n+                        r = res(bcx, C_nil());\n                     }\n-\n-                    auto cleanup = bind drop_hoisted_ty(_, res_alloca.val,\n-                                                        r_ty);\n-                    auto outer_scope_cx = find_outer_scope_cx(scope_bcx);\n-                    outer_scope_cx.cleanups += [clean(cleanup)];\n-\n-                    r = res(bcx, load_if_immediate(bcx,\n-                                                   res_alloca.val, r_ty));\n+                    case (return) {}\n                 }\n             }\n         }\n@@ -6860,7 +6892,7 @@ fn trans_fn(@local_ctxt cx, &ast::span sp, &ast::_fn f, ast::def_id fid,\n \n     auto lltop = bcx.llbb;\n \n-    auto res = trans_block(bcx, f.body);\n+    auto res = trans_block(bcx, f.body, return);\n     if (!is_terminated(res.bcx)) {\n         // FIXME: until LLVM has a unit type, we are moving around\n         // C_nil values rather than their void type."}]}