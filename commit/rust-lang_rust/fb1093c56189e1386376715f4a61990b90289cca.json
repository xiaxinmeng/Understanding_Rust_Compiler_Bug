{"sha": "fb1093c56189e1386376715f4a61990b90289cca", "node_id": "C_kwDOAAsO6NoAKGZiMTA5M2M1NjE4OWUxMzg2Mzc2NzE1ZjRhNjE5OTBiOTAyODljY2E", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-06T21:44:52Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-07T17:22:27Z"}, "message": "Split out `match_ref_pats`", "tree": {"sha": "10e1ffc0ed844d313c3631bfa1791f0604c8bfcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10e1ffc0ed844d313c3631bfa1791f0604c8bfcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb1093c56189e1386376715f4a61990b90289cca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb1093c56189e1386376715f4a61990b90289cca", "html_url": "https://github.com/rust-lang/rust/commit/fb1093c56189e1386376715f4a61990b90289cca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb1093c56189e1386376715f4a61990b90289cca/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1da26c8a70c13a0b897f70209c7c33f993d178f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1da26c8a70c13a0b897f70209c7c33f993d178f9", "html_url": "https://github.com/rust-lang/rust/commit/1da26c8a70c13a0b897f70209c7c33f993d178f9"}], "stats": {"total": 135, "additions": 71, "deletions": 64}, "files": [{"sha": "80f964ba1b72c4a246f24ee264d3ce5a508276d4", "filename": "clippy_lints/src/matches/match_ref_pats.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/fb1093c56189e1386376715f4a61990b90289cca/clippy_lints%2Fsrc%2Fmatches%2Fmatch_ref_pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb1093c56189e1386376715f4a61990b90289cca/clippy_lints%2Fsrc%2Fmatches%2Fmatch_ref_pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_ref_pats.rs?ref=fb1093c56189e1386376715f4a61990b90289cca", "patch": "@@ -0,0 +1,66 @@\n+use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n+use clippy_utils::source::snippet;\n+use clippy_utils::sugg::Sugg;\n+use core::iter::once;\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, Pat, PatKind};\n+use rustc_lint::LateContext;\n+\n+use super::MATCH_REF_PATS;\n+\n+pub(crate) fn check<'a, 'b, I>(cx: &LateContext<'_>, ex: &Expr<'_>, pats: I, expr: &Expr<'_>)\n+where\n+    'b: 'a,\n+    I: Clone + Iterator<Item = &'a Pat<'b>>,\n+{\n+    if !has_multiple_ref_pats(pats.clone()) {\n+        return;\n+    }\n+\n+    let (first_sugg, msg, title);\n+    let span = ex.span.source_callsite();\n+    if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = ex.kind {\n+        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n+        msg = \"try\";\n+        title = \"you don't need to add `&` to both the expression and the patterns\";\n+    } else {\n+        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n+        msg = \"instead of prefixing all patterns with `&`, you can dereference the expression\";\n+        title = \"you don't need to add `&` to all patterns\";\n+    }\n+\n+    let remaining_suggs = pats.filter_map(|pat| {\n+        if let PatKind::Ref(refp, _) = pat.kind {\n+            Some((pat.span, snippet(cx, refp.span, \"..\").to_string()))\n+        } else {\n+            None\n+        }\n+    });\n+\n+    span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |diag| {\n+        if !expr.span.from_expansion() {\n+            multispan_sugg(diag, msg, first_sugg.chain(remaining_suggs));\n+        }\n+    });\n+}\n+\n+fn has_multiple_ref_pats<'a, 'b, I>(pats: I) -> bool\n+where\n+    'b: 'a,\n+    I: Iterator<Item = &'a Pat<'b>>,\n+{\n+    let mut ref_count = 0;\n+    for opt in pats.map(|pat| match pat.kind {\n+        PatKind::Ref(..) => Some(true), // &-patterns\n+        PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n+        _ => None,                      // any other pattern is not fine\n+    }) {\n+        if let Some(inner) = opt {\n+            if inner {\n+                ref_count += 1;\n+            }\n+        } else {\n+            return false;\n+        }\n+    }\n+    ref_count > 1\n+}"}, {"sha": "56f1031f9b93a565a0a4bfd104ce72705acb4c69", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 64, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fb1093c56189e1386376715f4a61990b90289cca/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb1093c56189e1386376715f4a61990b90289cca/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=fb1093c56189e1386376715f4a61990b90289cca", "patch": "@@ -1,11 +1,9 @@\n-use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::source::{snippet, snippet_with_applicability};\n-use clippy_utils::sugg::Sugg;\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n+use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{is_wild, meets_msrv, msrvs, path_to_local_id, peel_blocks, strip_pat_refs};\n-use core::iter::once;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Pat, PatKind, QPath};\n+use rustc_hir::{Arm, Expr, ExprKind, Local, MatchSource, Pat, PatKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_semver::RustcVersion;\n@@ -14,6 +12,7 @@ use rustc_session::{declare_tool_lint, impl_lint_pass};\n mod match_as_ref;\n mod match_bool;\n mod match_like_matches;\n+mod match_ref_pats;\n mod match_same_arms;\n mod match_single_binding;\n mod match_wild_enum;\n@@ -633,7 +632,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n             }\n         }\n         if let ExprKind::Match(ex, arms, _) = expr.kind {\n-            check_match_ref_pats(cx, ex, arms.iter().map(|el| el.pat), expr);\n+            match_ref_pats::check(cx, ex, arms.iter().map(|el| el.pat), expr);\n         }\n     }\n \n@@ -698,42 +697,6 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n     extract_msrv_attr!(LateContext);\n }\n \n-fn check_match_ref_pats<'a, 'b, I>(cx: &LateContext<'_>, ex: &Expr<'_>, pats: I, expr: &Expr<'_>)\n-where\n-    'b: 'a,\n-    I: Clone + Iterator<Item = &'a Pat<'b>>,\n-{\n-    if !has_multiple_ref_pats(pats.clone()) {\n-        return;\n-    }\n-\n-    let (first_sugg, msg, title);\n-    let span = ex.span.source_callsite();\n-    if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = ex.kind {\n-        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n-        msg = \"try\";\n-        title = \"you don't need to add `&` to both the expression and the patterns\";\n-    } else {\n-        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n-        msg = \"instead of prefixing all patterns with `&`, you can dereference the expression\";\n-        title = \"you don't need to add `&` to all patterns\";\n-    }\n-\n-    let remaining_suggs = pats.filter_map(|pat| {\n-        if let PatKind::Ref(refp, _) = pat.kind {\n-            Some((pat.span, snippet(cx, refp.span, \"..\").to_string()))\n-        } else {\n-            None\n-        }\n-    });\n-\n-    span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |diag| {\n-        if !expr.span.from_expansion() {\n-            multispan_sugg(diag, msg, first_sugg.chain(remaining_suggs));\n-        }\n-    });\n-}\n-\n fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n     for arm in arms {\n         if let PatKind::Or(fields) = arm.pat.kind {\n@@ -751,25 +714,3 @@ fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n         }\n     }\n }\n-\n-fn has_multiple_ref_pats<'a, 'b, I>(pats: I) -> bool\n-where\n-    'b: 'a,\n-    I: Iterator<Item = &'a Pat<'b>>,\n-{\n-    let mut ref_count = 0;\n-    for opt in pats.map(|pat| match pat.kind {\n-        PatKind::Ref(..) => Some(true), // &-patterns\n-        PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n-        _ => None,                      // any other pattern is not fine\n-    }) {\n-        if let Some(inner) = opt {\n-            if inner {\n-                ref_count += 1;\n-            }\n-        } else {\n-            return false;\n-        }\n-    }\n-    ref_count > 1\n-}"}]}