{"sha": "d1c7ae476bc5949e2c05ca85b24571286356b8c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxYzdhZTQ3NmJjNTk0OWUyYzA1Y2E4NWIyNDU3MTI4NjM1NmI4YzQ=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-22T23:09:57Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-22T23:09:57Z"}, "message": "Rollup merge of #21056 - steveklabnik:return_strings, r=sfackler\n\nWhen we moved over to the book, we lost this.", "tree": {"sha": "e238228d3c02fcc0a2d3d8896eb4717b649bd6e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e238228d3c02fcc0a2d3d8896eb4717b649bd6e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1c7ae476bc5949e2c05ca85b24571286356b8c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1c7ae476bc5949e2c05ca85b24571286356b8c4", "html_url": "https://github.com/rust-lang/rust/commit/d1c7ae476bc5949e2c05ca85b24571286356b8c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1c7ae476bc5949e2c05ca85b24571286356b8c4/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8160fc4786383fb2df5f99d7e35a3e6ac82c1b12", "url": "https://api.github.com/repos/rust-lang/rust/commits/8160fc4786383fb2df5f99d7e35a3e6ac82c1b12", "html_url": "https://github.com/rust-lang/rust/commit/8160fc4786383fb2df5f99d7e35a3e6ac82c1b12"}, {"sha": "cef82952b2600080a69a3e8a9c76f978bf93ad69", "url": "https://api.github.com/repos/rust-lang/rust/commits/cef82952b2600080a69a3e8a9c76f978bf93ad69", "html_url": "https://github.com/rust-lang/rust/commit/cef82952b2600080a69a3e8a9c76f978bf93ad69"}], "stats": {"total": 284, "additions": 284, "deletions": 0}, "files": [{"sha": "bf9eaee1975a15a4c0f44ef5d0569cf91d5813a8", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1c7ae476bc5949e2c05ca85b24571286356b8c4/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/d1c7ae476bc5949e2c05ca85b24571286356b8c4/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=d1c7ae476bc5949e2c05ca85b24571286356b8c4", "patch": "@@ -16,6 +16,7 @@\n     * [Standard Input](standard-input.md)\n     * [Guessing Game](guessing-game.md)\n * [II: Intermediate Rust](intermediate.md)\n+    * [More Strings](more-strings.md)\n     * [Crates and Modules](crates-and-modules.md)\n     * [Testing](testing.md)\n     * [Pointers](pointers.md)"}, {"sha": "07b49751b10a0f377c53919256d610217b9c410d", "filename": "src/doc/trpl/more-strings.md", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/d1c7ae476bc5949e2c05ca85b24571286356b8c4/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/d1c7ae476bc5949e2c05ca85b24571286356b8c4/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmore-strings.md?ref=d1c7ae476bc5949e2c05ca85b24571286356b8c4", "patch": "@@ -0,0 +1,283 @@\n+% More Strings\n+\n+Strings are an important concept to master in any programming language. If you\n+come from a managed language background, you may be surprised at the complexity\n+of string handling in a systems programming language. Efficient access and\n+allocation of memory for a dynamically sized structure involves a lot of\n+details. Luckily, Rust has lots of tools to help us here.\n+\n+A **string** is a sequence of unicode scalar values encoded as a stream of\n+UTF-8 bytes. All strings are guaranteed to be validly-encoded UTF-8 sequences.\n+Additionally, strings are not null-terminated and can contain null bytes.\n+\n+Rust has two main types of strings: `&str` and `String`.\n+\n+# &str\n+\n+The first kind is a `&str`. This is pronounced a 'string slice'.\n+String literals are of the type `&str`:\n+\n+```\n+let string = \"Hello there.\";\n+```\n+\n+Like any Rust reference, string slices have an associated lifetime. A string\n+literal is a `&'static str`.  A string slice can be written without an explicit\n+lifetime in many cases, such as in function arguments. In these cases the\n+lifetime will be inferred:\n+\n+```\n+fn takes_slice(slice: &str) {\n+    println!(\"Got: {}\", slice);\n+}\n+```\n+\n+Like vector slices, string slices are simply a pointer plus a length. This\n+means that they're a 'view' into an already-allocated string, such as a\n+string literal or a `String`.\n+\n+# String\n+\n+A `String` is a heap-allocated string. This string is growable, and is also\n+guaranteed to be UTF-8.\n+\n+```\n+let mut s = \"Hello\".to_string();\n+println!(\"{}\", s);\n+\n+s.push_str(\", world.\");\n+println!(\"{}\", s);\n+```\n+\n+You can coerce a `String` into a `&str` by dereferencing it:\n+\n+```\n+fn takes_slice(slice: &str) {\n+    println!(\"Got: {}\", slice);\n+}\n+\n+fn main() {\n+    let s = \"Hello\".to_string();\n+    takes_slice(&*s);\n+}\n+```\n+\n+You can also get a `&str` from a stack-allocated array of bytes:\n+\n+```\n+use std::str;\n+\n+let x: &[u8] = &[b'a', b'b'];\n+let stack_str: &str = str::from_utf8(x).unwrap();\n+```\n+\n+# Best Practices\n+\n+## `String` vs. `&str`\n+\n+In general, you should prefer `String` when you need ownership, and `&str` when\n+you just need to borrow a string. This is very similar to using `Vec<T>` vs. `&[T]`,\n+and `T` vs `&T` in general.\n+\n+This means starting off with this:\n+\n+```{rust,ignore}\n+fn foo(s: &str) {\n+```\n+\n+and only moving to this:\n+\n+```{rust,ignore}\n+fn foo(s: String) {\n+```\n+\n+If you have good reason. It's not polite to hold on to ownership you don't\n+need, and it can make your lifetimes more complex.\n+\n+## Generic functions\n+\n+To write a function that's generic over types of strings, use `&str`.\n+\n+```\n+fn some_string_length(x: &str) -> uint {\n+        x.len()\n+}\n+\n+fn main() {\n+    let s = \"Hello, world\";\n+\n+    println!(\"{}\", some_string_length(s));\n+\n+    let s = \"Hello, world\".to_string();\n+\n+    println!(\"{}\", some_string_length(s.as_slice()));\n+}\n+```\n+\n+Both of these lines will print `12`.\n+\n+## Indexing strings\n+\n+You may be tempted to try to access a certain character of a `String`, like\n+this:\n+\n+```{rust,ignore}\n+let s = \"hello\".to_string();\n+\n+println!(\"{}\", s[0]);\n+```\n+\n+This does not compile. This is on purpose. In the world of UTF-8, direct\n+indexing is basically never what you want to do. The reason is that each\n+character can be a variable number of bytes. This means that you have to iterate\n+through the characters anyway, which is an O(n) operation.\n+\n+There's 3 basic levels of unicode (and its encodings):\n+\n+- code units, the underlying data type used to store everything\n+- code points/unicode scalar values (char)\n+- graphemes (visible characters)\n+\n+Rust provides iterators for each of these situations:\n+\n+- `.bytes()` will iterate over the underlying bytes\n+- `.chars()` will iterate over the code points\n+- `.graphemes()` will iterate over each grapheme\n+\n+Usually, the `graphemes()` method on `&str` is what you want:\n+\n+```\n+let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n+\n+for l in s.graphemes(true) {\n+    println!(\"{}\", l);\n+}\n+```\n+\n+This prints:\n+\n+```text\n+u\u0354\n+n\u030e\u0348\u0330\n+i\u0319\u032e\u035a\u0326\n+c\u0309\u035a\n+o\u0357\u033c\u0329\u0330\n+d\u0306\u0343\u0365\u0354\n+e\u0301\n+```\n+\n+Note that `l` has the type `&str` here, since a single grapheme can consist of\n+multiple codepoints, so a `char` wouldn't be appropriate.\n+\n+This will print out each visible character in turn, as you'd expect: first \"u\u0354\", then\n+\"n\u030e\u0348\u0330\", etc. If you wanted each individual codepoint of each grapheme, you can use `.chars()`:\n+\n+```\n+let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n+\n+for l in s.chars() {\n+    println!(\"{}\", l);\n+}\n+```\n+\n+This prints:\n+\n+```text\n+u\n+\u0354\n+n\n+\u030e\n+\u0348\n+\u0330\n+i\n+\u0319\n+\u032e\n+\u035a\n+\u0326\n+c\n+\u0309\n+\u035a\n+o\n+\u0357\n+\u033c\n+\u0329\n+\u0330\n+d\n+\u0306\n+\u0343\n+\u0365\n+\u0354\n+e\n+\u0301\n+```\n+\n+You can see how some of them are combining characters, and therefore the output\n+looks a bit odd.\n+\n+If you want the individual byte representation of each codepoint, you can use\n+`.bytes()`:\n+\n+```\n+let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";\n+\n+for l in s.bytes() {\n+    println!(\"{}\", l);\n+}\n+```\n+\n+This will print:\n+\n+```text\n+117\n+205\n+148\n+110\n+204\n+142\n+205\n+136\n+204\n+176\n+105\n+204\n+153\n+204\n+174\n+205\n+154\n+204\n+166\n+99\n+204\n+137\n+205\n+154\n+111\n+205\n+151\n+204\n+188\n+204\n+169\n+204\n+176\n+100\n+204\n+134\n+205\n+131\n+205\n+165\n+205\n+148\n+101\n+204\n+129\n+```\n+\n+Many more bytes than graphemes!\n+\n+# Other Documentation\n+\n+* [the `&str` API documentation](std/str/index.html)\n+* [the `String` API documentation](std/string/index.html)"}]}